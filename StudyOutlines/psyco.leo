<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="619" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="8" left="99" height="26" width="97"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences allow_rich_text="0">
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="T1" a="E"><vh>Psycho</vh>
<v t="T2"><vh>@file __init__.py</vh>
<v t="T3"><vh>&lt;&lt; about this file &gt;&gt;</vh></v>
<v t="T4"><vh>jit</vh></v>
<v t="T5"><vh>bind</vh></v>
<v t="T6"><vh>proxy</vh></v>
<v t="T7"><vh>unbind</vh></v>
<v t="T8"><vh>unproxy</vh></v>
<v t="T9"><vh>dumpcodebuf</vh></v>
<v t="T10"><vh>disabled_getframe</vh></v>
<v t="T11"><vh>&lt;&lt; ending remarks &gt;&gt;</vh></v>
</v>
<v t="T12"><vh>@file classes.py</vh>
<v t="T13"><vh>&lt;&lt; about this file &gt;&gt;</vh></v>
</v>
<v t="T14"><vh>Outer</vh>
<v a="M"><vh>headers</vh>
<v t="T15"><vh>codemanager.h</vh></v>
<v t="T16" a="M"><vh>dispatcher.h</vh>
<v t="T17"><vh>&lt;&lt; frozen PsycoObject &gt;&gt;</vh></v>
<v t="T18"><vh>&lt;&lt; psyco_compatible &gt;&gt;</vh></v>
<v t="T19"><vh>&lt;&lt; global entries &gt;&gt;</vh></v>
<v t="T20"><vh>&lt;&lt; unification &gt;&gt;</vh></v>
<v t="T21"><vh>&lt;&lt; promotion &gt;&gt;</vh></v>
<v t="T22"><vh>&lt;&lt; respawning &gt;&gt;</vh></v>
</v>
<v t="T23" a="M"><vh>encoding.h</vh>
<v t="T24"><vh>&lt;&lt; declare registers &gt;&gt;</vh></v>
<v t="T25"><vh>&lt;&lt; declare conditions &gt;&gt;</vh></v>
<v t="T26"><vh>&lt;&lt; special constants &gt;&gt;</vh></v>
<v t="T27"><vh>&lt;&lt; production of code &gt;&gt;</vh>
<v t="T28"><vh>Convenience macros</vh>
<v t="T29"><vh>CODE_FOUR_BYTES</vh></v>
<v t="T30"><vh>MODRM_EBP_BASE</vh></v>
<v t="T31"><vh>INSTR_EBP_BASE</vh></v>
<v t="T32"><vh>MODRM_FROM_RT</vh></v>
<v t="T33"><vh>INSTR_MODRM_FROM_RT</vh></v>
</v>
<v t="T34"><vh>Common instruction groups</vh>
<v t="T35"><vh>COMMON_INSTR_IMMED</vh></v>
<v t="T36"><vh>COMMON_INSTR_FROM</vh></v>
<v t="T37"><vh>COMMON_INSTR_FROM_RT</vh></v>
</v>
<v t="T38"><vh>UNARY_INSTR_ON_REG</vh></v>
<v t="T39"><vh>INCREASE_REG &amp; DECREASE_REG</vh></v>
<v t="T40"><vh>INT_ABS</vh></v>
<v t="T41"><vh>CHECK_XXX</vh></v>
<v t="T42"><vh>COMPARE_IMMED_FROM_RT</vh></v>
<v t="T43"><vh>PUSH_FROM_RT &amp; PUSH_FROM</vh></v>
<v t="T44"><vh>basic management instructions</vh></v>
<v t="T45"><vh>call a function written in C</vh></v>
<v t="T46"><vh>immediate values</vh></v>
<v t="T47"><vh>vinfo_t saving</vh></v>
<v t="T48"><vh>vinfo_t restoring </vh></v>
<v t="T49"><vh>conditional jumps </vh></v>
<v t="T50"><vh>COPY_IN_REG</vh></v>
</v>
</v>
<v t="T51"><vh>linuxmemchk.h</vh></v>
<v t="T52" a="M"><vh>mergepoints.h</vh></v>
<v t="T53" a="M"><vh>processor.h</vh>
<v t="T54"><vh>&lt;&lt; utilities &gt;&gt;</vh></v>
<v t="T55"><vh>&lt;&lt; read and write fields of structures in memory &gt;&gt;</vh></v>
<v t="T56"><vh>&lt;&lt; calling C functions &gt;&gt;</vh></v>
<v t="T57"><vh>&lt;&lt; emit common instructions &gt;&gt;</vh></v>
<v t="T58"><vh>&lt;&lt; code termination &gt;&gt;</vh></v>
<v t="T59"><vh>&lt;&lt; run-time switches &gt;&gt;</vh></v>
</v>
<v t="T60" a="M"><vh>psyco.h</vh>
<v t="T61"><vh>&lt;&lt; compile-time constants &amp; settings &gt;&gt;</vh></v>
<v t="T62"><vh>&lt;&lt; buffer settings &gt;&gt;</vh></v>
<v t="T63"><vh>&lt;&lt; memory checks &gt;&gt;</vh></v>
<v t="T64"><vh>&lt;&lt; storage allocation synonyms &gt;&gt;</vh></v>
<v t="T65"><vh>&lt;&lt; inlining &amp; more memory stuff &gt;&gt;</vh></v>
<v t="T66"><vh>&lt;&lt; synonyms for types &gt;&gt;</vh></v>
<v t="T67"><vh>&lt;&lt; function prototypes &gt;&gt;</vh></v>
<v t="T68"><vh>&lt;&lt; handling of out-of-memory conditions &gt;&gt;</vh></v>
</v>
<v t="T69" a="M"><vh>pycencoding.h (emits assembly code)</vh>
<v t="T70"><vh>DICT_ITEM_IFCHANGED</vh></v>
<v t="T71"><vh>INC_OB_REFCNT</vh></v>
<v t="T72"><vh>INC_KNOWN_OB_REFCNT</vh></v>
<v t="T73"><vh>DEC_KNOWN_OB_REFCNT_NZ</vh></v>
<v t="T74"><vh>DEC_OB_REFCNT_NZ</vh></v>
<v t="T75"><vh>DEC_OB_REFCNT</vh></v>
<v t="T76"><vh>DEC_OB_REFCNT_Z</vh></v>
<v t="T77"><vh>DEC_OB_REFCNT_T</vh></v>
<v t="T78"><vh>generic reference counting functions</vh>
<v t="T79"><vh>psyco_incref_rt</vh></v>
<v t="T80"><vh>psyco_incref_v</vh></v>
<v t="T81"><vh>psyco_decref_rt</vh></v>
<v t="T82"><vh>psyco_decref_v</vh></v>
<v t="T83"><vh>eat_reference</vh></v>
<v t="T84"><vh>need_reference</vh></v>
<v t="T85"><vh>write_array_item_ref &amp; write_array_item_var_ref</vh></v>
</v>
</v>
<v t="T86" a="M"><vh>vcompiler.h</vh>
<v t="T87"><vh>&lt;&lt; define sources of vinfo_t structures &gt;&gt;</vh></v>
<v t="T88"><vh>&lt;&lt; runtime sources &gt;&gt;</vh></v>
<v t="T89"><vh>&lt;&lt; compile-time sources &gt;&gt;</vh></v>
<v t="T90"><vh>&lt;&lt; virtual-time sources &gt;&gt;</vh></v>
<v t="T91"><vh>&lt;&lt; define vinfo_t structure &gt;&gt;</vh></v>
<v t="T92"><vh>&lt;&lt; PsycoObject &gt;&gt;</vh></v>
<v t="T93"><vh>&lt;&lt; Compiler language-independent functions &gt;&gt;</vh></v>
</v>
</v>
<v a="E"><vh>code</vh>
<v t="T94"><vh>codemanager.c</vh>
<v><vh>Macros...</vh>
<v t="T95"><vh>SET_CODE_END</vh></v>
<v t="T96"><vh>NEW_CODE_BUFFER</vh></v>
</v>
<v t="T97"><vh>psyco_new_code_buffer &amp; psyco_proxy_code_buffer</vh></v>
<v t="T98"><vh>psyco_new_code_buffer_size (not used)</vh></v>
<v t="T99"><vh>psyco_shrink_code_buffer</vh></v>
<v t="T100"><vh>psyco_tie_code_buffer (not used)</vh></v>
<v t="T101"><vh>psyco_trash_object</vh></v>
<v t="T102"><vh>codebuf_repr</vh></v>
<v t="T103"><vh>codebuf_dealloc</vh></v>
<v t="T104"><vh>CodeBuffer_Type</vh></v>
</v>
<v t="T105" a="M"><vh>dispatcher.c</vh>
<v t="T106"><vh>Snapshots</vh>
<v t="T107"><vh>fpo_build</vh></v>
<v t="T108"><vh>fpo_release</vh></v>
<v t="T109"><vh>find_regs_array</vh></v>
<v t="T110"><vh>fpo_unfreeze</vh></v>
</v>
<v t="T111"><vh>Respawning</vh>
<v t="T112"><vh>do_respawn</vh></v>
<v t="T113"><vh>psyco_respawn_detected</vh></v>
<v t="T114"><vh>psyco_prepare_respawn</vh></v>
</v>
<v a="E"><vh>Compatible array</vh>
<v t="T115"><vh>compatible_array</vh>
<v t="T116"><vh>&lt;&lt; return INCOMPATIBLE if the sizes of the arrays do not match &gt;&gt;</vh></v>
<v t="T117"><vh>&lt;&lt; examine items in turn &gt;&gt;</vh></v>
</v>
<v t="T118"><vh>psyco_compatible</vh></v>
</v>
<v t="T119"><vh>psyco_stabilize</vh></v>
<v t="T120"><vh>psyco_dispatcher_init</vh></v>
<v t="T121"><vh>Unification</vh>
<v t="T122"><vh>data_new_buffer</vh></v>
<v t="T123"><vh>data_original_table</vh></v>
<v t="T124"><vh>data_update_stack</vh></v>
<v t="T125"><vh>psyco_unify</vh></v>
<v t="T126"><vh>psyco_unify_code</vh></v>
</v>
<v t="T127"><vh>Promotion &amp; unpromotion</vh>
<v t="T128"><vh>Promotion of run-time to fixed compile-time var</vh>
<v t="T129"><vh>do_promotion_internal</vh></v>
<v t="T130"><vh>do_promotion_long</vh></v>
<v t="T131"><vh>do_promotion_pyobj</vh></v>
<v t="T132"><vh>psyco_finish_promotion</vh></v>
</v>
<v t="T133"><vh>Promotion of run-time values into compile-time values</vh>
<v t="T134"><vh>do_fixed_switch</vh></v>
<v t="T135"><vh>psyco_finish_fixed_switch</vh></v>
</v>
<v t="T136" a="E"><vh>Un-Promotion from non-fixed compile-time into run-time</vh>
<v t="T137"><vh>psyco_unfix</vh></v>
</v>
</v>
</v>
<v t="T138"><vh>hack.c</vh>
<v t="T139"><vh>&lt;&lt; hack #includes &gt;&gt;</vh></v>
</v>
<v t="T140"><vh>linuxmemchk.c</vh>
<v t="T141"><vh>&lt;&lt; linuxmemchk #includes &gt;&gt;</vh></v>
<v t="T142"><vh>&lt;&lt; linuxmemchk declarations &gt;&gt;</vh></v>
<v t="T143"><vh>_na_find</vh></v>
<v t="T144"><vh>memchk_ef_malloc</vh></v>
<v t="T145"><vh>memchk_ef_free</vh></v>
<v t="T146"><vh>memchk_ef_realloc</vh></v>
</v>
<v t="T147" a="M"><vh>mergepoints.c</vh>
<v t="T148"><vh>Tables of merge points</vh></v>
<v t="T149"><vh>psyco_get_merge_points</vh></v>
</v>
<v t="T150"><vh>processor.c (outputs real code)</vh>
<v t="T151"><vh>&lt;&lt; processor declarations &gt;&gt;</vh></v>
<v t="T152"><vh>psyco_processor_run</vh></v>
<v><vh>Call a C function with a variable number of arguments</vh>
<v t="T153"><vh>psyco_finish_return</vh></v>
<v t="T154"><vh>psyco_emergency_jump (disabled)</vh></v>
<v t="T155"><vh>psyco_jump_proxy</vh></v>
<v t="T156"><vh>psyco_stack_space_array (commented out)</vh></v>
<v t="T157"><vh>psyco_get_array_item</vh></v>
<v t="T158"><vh>psyco_read_array_item</vh></v>
<v t="T159"><vh>psyco_read_array_item_var</vh></v>
<v t="T160"><vh>psyco_write_array_item</vh></v>
<v t="T161"><vh>psyco_write_array_item_var</vh></v>
</v>
<v t="T162"><vh>Conditions codes</vh>
<v t="T163"><vh>psyco_compute_cc</vh></v>
<v t="T164"><vh>generic_computed_cc</vh></v>
<v t="T165"><vh>psyco_vinfo_condition</vh></v>
<v t="T166"><vh>psyco_vsource_cc</vh></v>
</v>
<v t="T167"><vh>COPY_CODE</vh></v>
<v t="T168"><vh>psyco_processor_init</vh></v>
<v t="T169"><vh>Runtime switches</vh>
<v t="T170"><vh>fx_compare</vh></v>
<v t="T171"><vh>fx_writecases</vh></v>
<v t="T172"><vh>computed_promotion</vh></v>
<v t="T173"><vh>psyco_vsource_is_promotion</vh></v>
<v t="T174"><vh>psyco_build_run_time_switch</vh></v>
<v t="T175"><vh>psyco_switch_lookup</vh></v>
<v t="T176"><vh>psyco_write_run_time_switch</vh></v>
<v t="T177"><vh>psyco_fix_switch_case</vh></v>
</v>
<v t="T178"><vh>Calling C functions</vh>
<v t="T179"><vh>psyco_generic_call</vh></v>
<v t="T180"><vh>psyco_call_psyco</vh></v>
</v>
<v t="T181"><vh>Emit common instructions</vh>
<v t="T182"><vh>integer_non_null</vh></v>
<v t="T183"><vh>immediate_compare</vh></v>
<v t="T184"><vh>integer_cmp</vh></v>
<v t="T185"><vh>integer_cmp_i</vh></v>
<v t="T186"><vh>integer_seqindex (not used)</vh></v>
<v t="T187"><vh>make_runtime_copy</vh></v>
</v>
</v>
<v t="T188"><vh>psyco.c (defines _psycho)</vh>
<v t="T189"><vh>&lt;&lt; psyco declarations &gt;&gt;</vh></v>
<v t="T190"><vh>Frame and arguments building</vh>
<v t="T191"><vh>count_run_time_args</vh></v>
<v t="T192"><vh>fix_run_time_args</vh></v>
<v t="T193"><vh>psyco_build_frame</vh></v>
<v t="T194"><vh>psyco_call_pyfunc</vh></v>
</v>
<v t="T195"><vh>PsycoFunctionObjects</vh>
<v t="T196"><vh>psyco_PsycoFunction_New</vh></v>
<v t="T197"><vh>psycofunction_dealloc</vh></v>
<v t="T198"><vh>psycofunction_repr</vh></v>
<v t="T199"><vh>psycofunction_call</vh></v>
<v t="T200"><vh>psycofunction_traverse</vh></v>
<v t="T201"><vh>PsycoFunction_Type</vh></v>
</v>
<v><vh>Implementation of the '_psyco' built-in module</vh>
<v t="T202"><vh>Psyco_proxy</vh></v>
</v>
<v t="T203"><vh>Dumping...</vh>
<v t="T204"><vh>vinfo_array_dump</vh></v>
<v t="T205"><vh>psyco_dump_code_buffers</vh></v>
</v>
<v t="T206"><vh>init_psyco (sets _psyco)</vh></v>
</v>
<v t="T207"><vh>pycencoding.c</vh>
<v t="T208"><vh>decref_create_new_ref</vh></v>
<v t="T209"><vh>decref_create_new_lastref</vh></v>
</v>
<v t="T210" a="M"><vh>vcompiler.c</vh>
<v><vh>Utilities</vh>
<v><vh>Storage allocation...</vh>
<v t="T211"><vh>vinfo_malloc_block</vh></v>
<v t="T212"><vh>sk_malloc_block</vh></v>
<v t="T213"><vh>array_grow1</vh></v>
<v t="T214"><vh>sk_release</vh></v>
<v t="T215"><vh>vinfo_copy</vh></v>
<v t="T216"><vh>vinfo_release</vh></v>
</v>
<v><vh>Temp marks...</vh>
<v t="T217"><vh>clear_tmp_marks</vh></v>
<v t="T218"><vh>assert_cleared_tmp_marks</vh></v>
</v>
<v><vh>Arrays...</vh>
<v t="T219"><vh>array_contains</vh></v>
<v t="T220"><vh>coherent_array</vh></v>
<v t="T221"><vh>hack_refcounts</vh></v>
<v t="T222"><vh>nonnull_refcount</vh></v>
<v t="T223"><vh>psyco_assert_coherent</vh></v>
<v t="T224"><vh>duplicate_array</vh></v>
</v>
<v t="T225"><vh>psyco_duplicate</vh></v>
<v t="T226"><vh>PsycoObject_Delete</vh></v>
</v>
<v t="T227"><vh>do_resume_coding</vh></v>
<v t="T228"><vh>psyco_coding_pause</vh></v>
<v t="T229"><vh>psyco_resume_compile</vh></v>
<v t="T230" a="M"><vh>psyco_compile (main compiling function)</vh></v>
<v t="T231"><vh>psyco_compile_cond</vh></v>
<v t="T232"><vh>psyco_compile_code</vh></v>
<v t="T233"><vh>computed_do_not_use</vh></v>
<v t="T234"><vh>psyco_compiler_init</vh></v>
</v>
</v>
</v>
<v t="T235"><vh>Objects</vh>
<v><vh>Headers</vh>
<v t="T236"><vh>pabstract.h</vh></v>
<v t="T237"><vh>pdictobject.h</vh></v>
<v t="T238"><vh>pfuncobject.h</vh></v>
<v t="T239"><vh>pintobject.h</vh></v>
<v t="T240"><vh>piterobject.h</vh></v>
<v t="T241"><vh>plistobject.h</vh></v>
<v t="T242"><vh>plongobject.h</vh></v>
<v t="T243"><vh>pmethodobject.h</vh></v>
<v t="T244"><vh>pobject.h</vh></v>
<v t="T245"><vh>pstringobject.h</vh></v>
<v t="T246"><vh>psycofuncobject.h</vh></v>
<v t="T247"><vh>ptupleobject.h</vh></v>
</v>
<v><vh>Code (psyco helpers)</vh>
<v t="T248" a="C"><vh> pabstract.c (implements psyco opcodes)</vh>
<v t="T249"><vh>type_error</vh></v>
<v t="T250" a="C"><vh>PsycoObject_Call (psyco)</vh></v>
<v t="T251" a="C"><vh>Getters... (psyco)</vh>
<v t="T252"><vh>psyco_generic_immut_ob_size</vh></v>
<v t="T253"><vh>psyco_generic_mut_ob_size</vh></v>
<v t="T254"><vh>PsycoObject_GetItem</vh></v>
<v t="T255"><vh>PsycoObject_Size</vh></v>
<v t="T256"><vh>PsycoSequence_GetItem</vh></v>
<v t="T257"><vh>PsycoSequence_GetSlice</vh></v>
</v>
<v t="T258" a="C"><vh>Setters... (psyco)</vh>
<v t="T259"><vh>PsycoObject_SetItem</vh></v>
<v t="T260"><vh>PsycoSequence_SetItem</vh></v>
<v t="T261"><vh>PsycoSequence_SetSlice</vh></v>
</v>
<v t="T262" a="C"><vh>Numeric helper functions... (psyco)</vh>
<v t="T263"><vh>PsycoNumber_Positive</vh></v>
<v t="T264"><vh>PsycoNumber_Negative</vh></v>
<v t="T265"><vh>PsycoNumber_Invert</vh></v>
<v t="T266"><vh>cimpl_oldstyle_binary_op1</vh></v>
<v t="T267"><vh>binary_op1</vh></v>
<v t="T268"><vh>binary_op</vh></v>
<v t="T269"><vh>BINARY_FUNC (Implements PsycoNumber_xxx functions)</vh></v>
<v t="T270"><vh>PsycoNumber_Remainder</vh></v>
<v t="T271"><vh>PsycoNumber_Power</vh></v>
<v t="T272"><vh>PsycoNumber_InPlaceAdd</vh></v>
<v t="T273"><vh>PsycoNumber_InPlaceOr</vh></v>
<v t="T274"><vh>PsycoNumber_InPlaceXor</vh></v>
<v t="T275"><vh>PsycoNumber_InPlaceAnd</vh></v>
<v t="T276"><vh>PsycoNumber_InPlaceLshift</vh></v>
<v t="T277"><vh>PsycoNumber_InPlaceRshift</vh></v>
<v t="T278"><vh>PsycoNumber_InPlaceSubtract</vh></v>
<v t="T279"><vh>PsycoNumber_InPlaceMultiply</vh></v>
<v t="T280"><vh>PsycoNumber_InPlaceDivide</vh></v>
<v t="T281"><vh>PsycoNumber_InPlaceRemainder</vh></v>
<v t="T282"><vh>PsycoNumber_InPlacePower</vh></v>
</v>
<v t="T283" a="C"><vh>Iteration helpers... (psyco)</vh>
<v t="T284"><vh>PsycoObject_GetIter</vh></v>
<v t="T285"><vh>PsycoIter_Next</vh></v>
</v>
</v>
<v t="T286"><vh>pdictobject.c</vh>
<v t="T287"><vh>&lt;&lt; pdictobject #includes &gt;&gt;</vh></v>
<v t="T288"><vh>PsycoDict_New</vh></v>
<v t="T289"><vh>psy_dictobject_init</vh></v>
</v>
<v t="T290"><vh>pfuncobject.c</vh>
<v t="T291"><vh>&lt;&lt; pfuncobject #includes &gt;&gt;</vh></v>
<v t="T292"><vh>function_call</vh></v>
<v t="T293"><vh>psy_funcobject_init</vh></v>
</v>
<v t="T294"><vh>pintobject.c</vh>
<v t="T295"><vh>&lt;&lt; pintobject #includes &gt;&gt;</vh></v>
<v t="T296"><vh>PsycoInt_AsLong</vh></v>
<v t="T297"><vh>compute_int</vh></v>
<v t="T298"><vh>pint_nonzero</vh></v>
<v t="T299"><vh>pint_pos</vh></v>
<v t="T300"><vh>pint_neg</vh></v>
<v t="T301"><vh>pint_invert</vh></v>
<v t="T302"><vh>pint_abs</vh></v>
<v t="T303"><vh>pint_add</vh></v>
<v t="T304"><vh>pint_sub</vh></v>
<v t="T305"><vh>pint_or</vh></v>
<v t="T306"><vh>pint_and</vh></v>
<v t="T307"><vh>psy_intobject_init</vh></v>
</v>
<v t="T308"><vh>piterobject.c</vh>
<v t="T309"><vh>&lt;&lt; piterobject #includes &gt;&gt;</vh></v>
<v t="T310"><vh>piter_getiter</vh></v>
<v t="T311"><vh>piter_next</vh></v>
<v t="T312"><vh>compute_seqiter</vh></v>
<v t="T313"><vh>psy_iterobject_init</vh></v>
</v>
<v t="T314"><vh>plistobject.c</vh>
<v t="T315"><vh>&lt;&lt; plistobject #includes &gt;&gt;</vh></v>
<v t="T316"><vh>PsycoList_New</vh></v>
<v t="T317"><vh>plist_item</vh></v>
<v t="T318"><vh>psy_listobject_init</vh></v>
</v>
<v t="T319"><vh>plongobject.c</vh>
<v t="T320"><vh>&lt;&lt; plongobject #includes &gt;&gt;</vh></v>
<v t="T321"><vh>PsycoLong_AsLong</vh></v>
<v t="T322"><vh>DEF_KNOWN_RET_TYPE_1</vh></v>
</v>
<v t="T323"><vh>pmethodobject.c</vh>
<v t="T324"><vh>&lt;&lt; pmethodobject #includes &gt;&gt;</vh></v>
<v t="T325"><vh>PsycoCFunction_Call</vh></v>
<v t="T326"><vh>psy_methodobject_init</vh></v>
</v>
<v t="T327"><vh>pobject.c</vh>
<v t="T328"><vh>&lt;&lt; pobject #includes &gt;&gt;</vh></v>
<v t="T329"><vh>&lt;&lt; pobject declarations &gt;&gt;</vh></v>
<v t="T330"><vh>PsycoObject_IsTrue</vh></v>
<v t="T331"><vh>PsycoObject_Repr</vh></v>
<v t="T332"><vh>PsycoObject_GetAttr</vh></v>
<v t="T333"><vh>PsycoObject_SetAttr</vh></v>
<v t="T334"><vh>try_rich_compare</vh></v>
<v t="T335"><vh>convert_3way_to_object</vh></v>
<v t="T336"><vh>try_3way_to_rich_compare</vh></v>
<v t="T337"><vh>PsycoObject_RichCompare</vh></v>
<v t="T338"><vh>PsycoObject_RichCompareBool</vh></v>
</v>
<v t="T339"><vh>pstringobject.c</vh>
<v t="T340"><vh>&lt;&lt; pstringobject #includes &gt;&gt;</vh></v>
<v t="T341"><vh>&lt;&lt; pstringobject declarations &gt;&gt;</vh></v>
<v t="T342"><vh>cimpl_character</vh></v>
<v t="T343"><vh>compute_char</vh></v>
<v t="T344"><vh>PsycoCharacter_NEW</vh></v>
<v t="T345"><vh>PsycoCharacter_New</vh></v>
<v t="T346"><vh>pstring_item</vh></v>
<v t="T347"><vh>psy_stringobject_init</vh></v>
</v>
<v t="T348"><vh>psycofuncobject.c</vh>
<v t="T349"><vh>&lt;&lt; psycofuncobject #includes &gt;&gt;</vh></v>
<v t="T350"><vh>meta_psycofunction_call</vh></v>
<v t="T351"><vh>psy_psycofuncobject_init</vh></v>
</v>
<v t="T352"><vh>ptupleobject.c</vh>
<v t="T353"><vh>&lt;&lt; ptupleobject #includes &gt;&gt;</vh></v>
<v t="T354"><vh>&lt;&lt; ptupleobject declarations &gt;&gt;</vh></v>
<v t="T355"><vh>compute_tuple</vh></v>
<v t="T356"><vh>PsycoTuple_New</vh></v>
<v t="T357"><vh>PsycoTuple_Load</vh></v>
<v t="T358"><vh>ptuple_item</vh></v>
<v t="T359"><vh>psy_tupleobject_init</vh></v>
</v>
</v>
</v>
<v t="T360"><vh>Python</vh>
<v><vh>Headers</vh>
<v t="T361"><vh>pbltinmodule.h</vh></v>
<v t="T362"><vh>pycheader.h</vh></v>
<v t="T363"><vh>pycompiler.h</vh></v>
</v>
<v><vh>Code</vh>
<v t="T364"><vh>pbltinmodule.c</vh>
<v t="T365"><vh>&lt;&lt; pbltinmodule #includes &gt;&gt;</vh></v>
<v t="T366"><vh>&lt;&lt; pbltinmodule declarations &gt;&gt;</vh></v>
<v t="T367"><vh>cimpl_range1</vh></v>
<v t="T368"><vh>compute_range</vh></v>
<v t="T369"><vh>get_len_of_range</vh></v>
<v t="T370"><vh>pbuiltin_range</vh></v>
<v t="T371"><vh>pbuiltin_chr</vh></v>
<v t="T372"><vh>pbuiltin_ord</vh></v>
<v t="T373"><vh>pbuiltin_id</vh></v>
<v t="T374"><vh>pbuiltin_len</vh></v>
<v t="T375"><vh>psy_bltinmodule_init</vh></v>
</v>
<v t="T376"><vh>pycompiler.c</vh>
<v t="T377"><vh>&lt;&lt; pycompiler #includes &gt;&gt;</vh></v>
<v t="T378"><vh>&lt;&lt; pycompiler declarations &gt;&gt;</vh></v>
<v t="T379"><vh>Meta functions...</vh>
<v t="T380"><vh>Psyco_DefineMeta</vh></v>
<v t="T381"><vh>Psyco_DefineMetaModule</vh></v>
<v t="T382"><vh>generic_call_check</vh></v>
<v t="T383"><vh>Psyco_Meta1x</vh></v>
<v t="T384"><vh>Psyco_Meta2x</vh></v>
<v t="T385"><vh>Psyco_Meta3x</vh></v>
<v t="T386"><vh>Psyco_Meta4x</vh></v>
</v>
<v t="T387"><vh>pyc_data_t...</vh>
<v t="T388"><vh>pyc_data_build</vh></v>
<v t="T389"><vh>block_setup</vh></v>
<v t="T390"><vh>block_pop</vh></v>
</v>
<v t="T391"><vh>Compile-time Pseudo exceptions</vh>
<v t="T392"><vh>PycException_SetString</vh></v>
<v t="T393"><vh>PycException_SetFormat</vh></v>
<v t="T394"><vh>PycException_SetObject</vh></v>
<v t="T395"><vh>PycException_SetVInfo</vh></v>
<v t="T396"><vh>PycException_Promote</vh></v>
<v t="T397"><vh>PycException_Matches</vh></v>
<v t="T398"><vh>clear_pseudo_exception</vh></v>
<v t="T399"><vh>PycException_Clear</vh></v>
<v t="T400"><vh>psyco_virtualize_exception</vh></v>
<v t="T401"><vh>cimpl_pyerr_fetch</vh></v>
<v t="T402"><vh>cimpl_pyerr_fetch_and_normalize</vh></v>
<v t="T403"><vh>PycException_Fetch</vh></v>
<v t="T404"><vh>PycException_FetchNormalize</vh></v>
</v>
<v t="T405"><vh>psyco_pycompiler_init</vh></v>
<v t="T406"><vh>Compiler...</vh>
<v t="T407" a="C"><vh>Macros (psyco)</vh></v>
<v t="T408"><vh>LOAD_GLOBAL tricks</vh></v>
<v t="T409"><vh>do_changed_global</vh></v>
<v t="T410"><vh>load_global</vh></v>
<v t="T411"><vh>Slicing...</vh>
<v t="T412"><vh>_PsycoEval_SliceIndex</vh></v>
<v t="T413"><vh>psyco_apply_slice</vh></v>
<v t="T414"><vh>psyco_assign_slice</vh></v>
</v>
<v t="T415"><vh>Run-time implementation of various opcodes</vh>
<v t="T416"><vh>cimpl_print_item_to</vh></v>
<v t="T417"><vh>cimpl_print_newline_to</vh></v>
<v t="T418"><vh>cimpl_unpack_iterable</vh></v>
<v t="T419"><vh>cimpl_unpack_list</vh></v>
</v>
<v t="T420"><vh>Main loop</vh>
<v t="T421"><vh>exit_function</vh></v>
<v t="T422" a="C"><vh>psyco_pycompiler_mainloop (Python)</vh>
<v t="T423"><vh>&lt;&lt; outer loop &gt;&gt;</vh>
<v t="T424"><vh>&lt;&lt; define loop vars &gt;&gt;</vh></v>
<v t="T425"><vh>&lt;&lt; main loop &gt;&gt;</vh>
<v t="T426" a="C"><vh>&lt;&lt; handle opcodes &gt;&gt; (psyco)</vh>
<v t="T427" a="C"><vh>&lt;&lt; binary opcodes &gt;&gt; psyco</vh>
<v t="T428"><vh>&lt;&lt; BINARY_OPCODE macro (psyco) &gt;&gt;</vh></v>
<v t="T429"><vh>&lt;&lt; binary_power &gt;&gt;</vh></v>
<v t="T430"><vh>&lt;&lt; inplace_power &gt;&gt;</vh></v>
</v>
<v t="T431" a="C"><vh>&lt;&lt; compare_op &gt;&gt; psyco</vh></v>
<v t="T432" a="C"><vh>&lt;&lt; default case &gt;&gt; psyco</vh></v>
<v t="T433" a="C"><vh>&lt;&lt; exec_stmt &gt;&gt; psyco</vh></v>
<v t="T434" a="C"><vh>&lt;&lt; flow of control cases &gt;&gt; psyco </vh>
<v t="T283" a="C"><vh>Iteration helpers... (psyco)</vh>
<v t="T284"><vh>PsycoObject_GetIter</vh></v>
<v t="T285"><vh>PsycoIter_Next</vh></v>
</v>
<v t="T435"><vh>&lt;&lt; break_loop &gt;&gt; psyco</vh></v>
<v t="T436"><vh>&lt;&lt; continue_loop &gt;&gt; psyco</vh></v>
<v t="T437"><vh>&lt;&lt; end_finally &gt;&gt; psyco</vh></v>
<v t="T438"><vh>&lt;&lt; iters &gt;&gt; psycho</vh>
<v t="T439"><vh>&lt;&lt; for_iter &gt;&gt;</vh></v>
<v t="T440"><vh>&lt;&lt; get_iter &gt;&gt;</vh></v>
<v t="T441"><vh>&lt;&lt; yeild_value &gt;&gt;</vh></v>
</v>
<v t="T442"><vh>&lt;&lt; jumps &gt;&gt; psyco</vh>
<v t="T443"><vh>&lt;&lt; jump_forward &gt;&gt;</vh></v>
<v t="T444"><vh>&lt;&lt; jump_if_true/false &gt;&gt;</vh></v>
<v t="T445"><vh>&lt;&lt; jump_absolute &gt;&gt;</vh></v>
</v>
<v t="T446"><vh>&lt;&lt; pop_block &gt;&gt; psyco</vh></v>
<v t="T447"><vh>&lt;&lt; setup_loop/except/finally &gt;&gt; psyco</vh></v>
</v>
<v t="T448" a="C"><vh>&lt;&lt; function call/make/return &gt;&gt; psyco</vh>
<v t="T449"><vh>&lt;&lt; call_function &gt;&gt;</vh></v>
<v t="T450"><vh>&lt;&lt; extended_arg &gt;&gt;</vh></v>
<v t="T451"><vh>&lt;&lt; return_value &gt;&gt; psyco</vh></v>
</v>
<v t="T452" a="C"><vh>&lt;&lt; import &gt;&gt; psyco</vh></v>
<v t="T453" a="C"><vh>&lt;&lt; load/store/build/delete &gt;&gt; psyco</vh>
<v t="T454"><vh>&lt;&lt; build_list &gt;&gt;</vh></v>
<v t="T455"><vh>&lt;&lt; build_map &gt;&gt;</vh></v>
<v t="T456"><vh>&lt;&lt; build_tuple &gt;&gt;</vh></v>
<v t="T457"><vh>&lt;&lt; delete_attr &gt;&gt;</vh></v>
<v t="T458"><vh>&lt;&lt; delete_fast &gt;&gt;</vh></v>
<v t="T459"><vh>&lt;&lt; delete_global &gt;&gt;</vh></v>
<v t="T460"><vh>&lt;&lt; load_attr &gt;&gt;</vh></v>
<v t="T461"><vh>&lt;&lt; load_const &gt;&gt;</vh></v>
<v t="T462"><vh>&lt;&lt; load_fast &gt;&gt;</vh></v>
<v t="T463"><vh>&lt;&lt; load_global &gt;&gt;</vh></v>
<v t="T464"><vh>&lt;&lt; store_attr &gt;&gt;</vh></v>
<v t="T465"><vh>&lt;&lt; store_fast &gt;&gt;</vh></v>
<v t="T466"><vh>&lt;&lt; store_global &gt;&gt;</vh></v>
</v>
<v t="T467" a="C"><vh>&lt;&lt; print &gt;&gt; psyco</vh>
<v t="T468"><vh>&lt;&lt; print_item &gt;&gt;</vh></v>
<v t="T469"><vh>&lt;&lt; print_item_to &gt;&gt;</vh></v>
<v t="T470"><vh>&lt;&lt; print_newline &gt;&gt;</vh></v>
<v t="T471"><vh>&lt;&lt; print_newline_to &gt;&gt;</vh></v>
</v>
<v t="T472" a="C"><vh>&lt;&lt; set_lineno &gt;&gt; psyco</vh></v>
<v t="T473" a="C"><vh>&lt;&lt; slice &gt;&gt; psyco</vh>
<v t="T474"><vh>&lt;&lt; slice cases  &gt;&gt; psyco</vh></v>
<v t="T475"><vh>&lt;&lt; store slice cases &gt;&gt; psyco</vh></v>
<v t="T476"><vh>&lt;&lt; delete slice cases &gt;&gt; psyco</vh></v>
</v>
<v t="T477" a="C"><vh>&lt;&lt; stack opcodes &gt;&gt; psyco</vh>
<v t="T478"><vh>&lt;&lt; dup_top &gt;&gt;</vh></v>
<v t="T479"><vh>&lt;&lt; dup_topx &gt;&gt;</vh></v>
<v t="T480"><vh>&lt;&lt; pop_top &gt;&gt;</vh></v>
<v t="T481"><vh>&lt;&lt; rot_two &gt;&gt;</vh></v>
<v t="T482"><vh>&lt;&lt; rot_three &gt;&gt;</vh></v>
<v t="T483"><vh>&lt;&lt; rot_four &gt;&gt;</vh></v>
</v>
<v t="T484" a="C"><vh>&lt;&lt; subscript &gt;&gt; psyco</vh>
<v t="T485"><vh>&lt;&lt; store_subscr &gt;&gt;</vh></v>
<v t="T486"><vh>&lt;&lt; delete_subscr &gt;&gt;</vh></v>
</v>
<v t="T487" a="C"><vh>&lt;&lt; unary opcodes &gt;&gt; psyco</vh>
<v t="T488"><vh>&lt;&lt; unary_positive &gt;&gt;</vh></v>
<v t="T489"><vh>&lt;&lt; unary_negative &gt;&gt;</vh></v>
<v t="T490"><vh>&lt;&lt; unary_not &gt;&gt;</vh></v>
<v t="T491"><vh>&lt;&lt; unary_convert &gt;&gt;</vh></v>
<v t="T492"><vh>&lt;&lt; unary_invert &gt;&gt;</vh></v>
</v>
<v t="T493" a="C"><vh>&lt;&lt; unpack_sequence &gt;&gt; psyco</vh></v>
</v>
</v>
<v t="T494"><vh>&lt;&lt; unwind the stack &gt;&gt;</vh></v>
<v t="T495"><vh>&lt;&lt; check for the 'promotion' pseudo-exception &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
</v>
<v><vh>(Key parts of the code)</vh>
<v t="T496"><vh>eval_frame (original C interp)</vh>
<v t="T497"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="T498" a="C"><vh>&lt;&lt; define macros &gt;&gt; c</vh></v>
<v t="T499"><vh>&lt;&lt; initialize &gt;&gt;</vh>
<v t="T500"><vh>&lt;&lt; initialize tracing &gt;&gt;</vh></v>
</v>
<v t="T501"><vh>&lt;&lt; start loop &gt;&gt;</vh>
<v t="T502"><vh>&lt;&lt; handle periodic things &gt;&gt;</vh></v>
<v t="T503"><vh>&lt;&lt; set f-&gt;f_lasti if debugging or tracing &gt;&gt;</vh></v>
<v t="T504"><vh>&lt;&lt; handle tracing and profiling &gt;&gt;</vh></v>
</v>
<v t="T505" a="C"><vh>&lt;&lt; opcode cases &gt;&gt; c</vh>
<v t="T506" a="C"><vh>&lt;&lt; binary cases &gt;&gt; c</vh>
<v t="T507"><vh>binary ops</vh>
<v t="T508"><vh>&lt;&lt; BINARY_POWER &gt;&gt;</vh></v>
<v t="T509"><vh>&lt;&lt; BINARY_MULTIPLY &gt;&gt;</vh></v>
<v t="T510"><vh>&lt;&lt; BINARY_DIVIDE &gt;&gt;</vh></v>
<v t="T511"><vh>&lt;&lt; BINARY_FLOOR_DIVIDE &gt;&gt;</vh></v>
<v t="T512"><vh>&lt;&lt; BINARY_MODULO &gt;&gt;</vh></v>
<v t="T513"><vh>&lt;&lt; BINARY_ADD &gt;&gt;</vh></v>
<v t="T514"><vh>&lt;&lt; BINARY_SUBTRACT &gt;&gt;</vh></v>
<v t="T515"><vh>&lt;&lt; BINARY_SUBSCR &gt;&gt;</vh></v>
<v t="T516"><vh>&lt;&lt; BINARY_LSHIFT &gt;&gt;</vh></v>
<v t="T517"><vh>&lt;&lt; BINARY_RSHIFT &gt;&gt;</vh></v>
<v t="T518"><vh>&lt;&lt; BINARY_AND &gt;&gt;</vh></v>
<v t="T519"><vh>&lt;&lt; BINARY_XOR &gt;&gt;</vh></v>
<v t="T520"><vh>&lt;&lt; BINARY_OR &gt;&gt;</vh></v>
</v>
<v t="T521"><vh>inplace ops</vh>
<v t="T522"><vh>&lt;&lt; INPLACE_POWER &gt;&gt;</vh></v>
<v t="T523"><vh>&lt;&lt; INPLACE_MULTIPLY &gt;&gt;</vh></v>
<v t="T524"><vh>&lt;&lt; INPLACE_DIVIDE &gt;&gt;</vh></v>
<v t="T525"><vh>&lt;&lt; INPLACE_FLOOR_DIVIDE &gt;&gt;</vh></v>
<v t="T526"><vh>&lt;&lt; INPLACE_TRUE_DIVIDE &gt;&gt;</vh></v>
<v t="T527"><vh>&lt;&lt; INPLACE_MODULO &gt;&gt;</vh></v>
<v t="T528"><vh>&lt;&lt; INPLACE_ADD &gt;&gt;</vh></v>
<v t="T529"><vh>&lt;&lt; INPLACE_SUBTRACT &gt;&gt;</vh></v>
<v t="T530"><vh>&lt;&lt; INPLACE_LSHIFT &gt;&gt;</vh></v>
<v t="T531"><vh>&lt;&lt; INPLACE_RSHIFT &gt;&gt;</vh></v>
<v t="T532"><vh>&lt;&lt; INPLACE_AND &gt;&gt;</vh></v>
<v t="T533"><vh>&lt;&lt; INPLACE_XOR &gt;&gt;</vh></v>
<v t="T534"><vh>&lt;&lt; INPLACE_OR &gt;&gt;</vh></v>
</v>
</v>
<v t="T535" a="C"><vh>&lt;&lt; build cases &gt;&gt; c</vh>
<v t="T536"><vh>&lt;&lt; BUILD_CLASS &gt;&gt;</vh></v>
<v t="T537"><vh>&lt;&lt; BUILD_LIST &gt;&gt;</vh></v>
<v t="T538"><vh>&lt;&lt; BUILD_MAP &gt;&gt;</vh></v>
<v t="T539"><vh>&lt;&lt; BUILD_SLICE &gt;&gt;</vh></v>
<v t="T540"><vh>&lt;&lt; BUILD_TUPLE &gt;&gt;</vh></v>
</v>
<v t="T541" a="C"><vh>&lt;&lt; function call/make/return cases &gt;&gt; c</vh>
<v t="T542"><vh>&lt;&lt; CALL_FUNCTION &gt;&gt;</vh></v>
<v t="T543"><vh>&lt;&lt; CALL_FUNCTION_VAR/KW/VAR_KW &gt;&gt;</vh></v>
<v t="T544"><vh>&lt;&lt; MAKE_FUNCTION &gt;&gt;</vh></v>
<v t="T545"><vh>&lt;&lt; MAKE_CLOSURE &gt;&gt;</vh></v>
<v t="T546"><vh>&lt;&lt; RETURN_VALUE &gt;&gt;</vh></v>
</v>
<v t="T547" a="C"><vh>&lt;&lt; COMPARE_OP &gt;&gt; c</vh></v>
<v t="T548" a="C"><vh>&lt;&lt; default case &gt;&gt; c</vh></v>
<v t="T549" a="C"><vh>&lt;&lt; delete cases &gt;&gt; c</vh>
<v t="T550"><vh>&lt;&lt; DELETE_ATTR &gt;&gt;</vh></v>
<v t="T551"><vh>&lt;&lt; DELETE_FAST &gt;&gt;</vh></v>
<v t="T552"><vh>&lt;&lt; DELETE_GLOBAL &gt;&gt;</vh></v>
<v t="T553"><vh>&lt;&lt; DELETE_NAME &gt;&gt;</vh></v>
</v>
<v t="T554" a="C"><vh>&lt;&lt; EXTENDED_ARG &gt;&gt; c</vh></v>
<v t="T555"><vh>&lt;&lt; EXEC_STMT &gt;&gt;</vh></v>
<v t="T556" a="C"><vh>&lt;&lt; flow-of-control cases &gt;&gt; c</vh>
<v t="T557"><vh>&lt;&lt; BREAK_LOOP &gt;&gt;</vh></v>
<v t="T558"><vh>&lt;&lt; CONTINUE_LOOP &gt;&gt;</vh></v>
<v t="T559"><vh>&lt;&lt; END_FINALLY &gt;&gt;</vh></v>
<v t="T560"><vh>&lt;&lt; iter cases &gt;&gt; c</vh>
<v t="T561"><vh>&lt;&lt; FOR_ITER &gt;&gt;</vh></v>
<v t="T562"><vh>&lt;&lt; GET_ITER &gt;&gt;</vh></v>
<v t="T563"><vh>&lt;&lt; YIELD_VALUE &gt;&gt;</vh></v>
</v>
<v t="T564"><vh>&lt;&lt; jump cases &gt;&gt; c</vh>
<v t="T565"><vh>&lt;&lt; JUMP_FORWARD &gt;&gt;</vh></v>
<v t="T566"><vh>&lt;&lt; JUMP_IF_FALSE &gt;&gt;</vh></v>
<v t="T567"><vh>&lt;&lt; JUMP_IF_TRUE &gt;&gt;</vh></v>
<v t="T568"><vh>&lt;&lt; JUMP_ABSOLUTE &gt;&gt;</vh></v>
</v>
<v t="T569"><vh>&lt;&lt; FOR_LOOP &gt;&gt;</vh></v>
<v t="T570"><vh>&lt;&lt; POP_BLOCK &gt;&gt;</vh></v>
<v t="T571"><vh>&lt;&lt; RAISE_VARARGS &gt;&gt;</vh></v>
<v t="T572"><vh>&lt;&lt; SETUP_LOOP/EXCEPT/FINALLY &gt;&gt;</vh></v>
</v>
<v t="T573" a="C"><vh>&lt;&lt; import cases &gt;&gt; c</vh>
<v t="T574"><vh>&lt;&lt; IMPORT_NAME &gt;&gt;</vh></v>
<v t="T575"><vh>&lt;&lt; IMPORT_STAR &gt;&gt;</vh></v>
<v t="T576"><vh>&lt;&lt; IMPORT_FROM &gt;&gt;</vh></v>
</v>
<v t="T577" a="C"><vh>&lt;&lt; load cases &gt;&gt; c</vh>
<v t="T578"><vh>&lt;&lt; LOAD_ATTR &gt;&gt;</vh></v>
<v t="T579"><vh>&lt;&lt; LOAD_CLOSURE &gt;&gt;</vh></v>
<v t="T580"><vh>&lt;&lt; LOAD_CONST &gt;&gt;</vh></v>
<v t="T581"><vh>&lt;&lt; LOAD_DEREF &gt;&gt;</vh></v>
<v t="T582"><vh>&lt;&lt; LOAD_LOCALS &gt;&gt;</vh></v>
<v t="T583"><vh>&lt;&lt; LOAD_FAST &gt;&gt;</vh></v>
<v t="T584"><vh>&lt;&lt; LOAD_GLOBAL &gt;&gt;</vh></v>
<v t="T585"><vh>&lt;&lt; LOAD_NAME &gt;&gt;</vh></v>
</v>
<v t="T586" a="C"><vh>&lt;&lt; print cases &gt;&gt; c</vh>
<v t="T587"><vh>&lt;&lt; PRINT_EXPR &gt;&gt;</vh></v>
<v t="T588"><vh>&lt;&lt; PRINT_ITEM_TO/PRINT_ITEM &gt;&gt;</vh></v>
<v t="T589"><vh>&lt;&lt; PRINT_NEWLINE_TO/PRINT_NEWLINE &gt;&gt;</vh></v>
</v>
<v t="T590" a="C"><vh>&lt;&lt; SET_LINENO &gt;&gt; c</vh></v>
<v t="T591" a="C"><vh>&lt;&lt; slice cases &gt;&gt; c</vh>
<v t="T592"><vh>&lt;&lt; SLICE cases &gt;&gt;</vh></v>
<v t="T593"><vh>&lt;&lt; STORE_SLICE cases &gt;&gt;</vh></v>
<v t="T594"><vh>&lt;&lt; DELETE_SLICE cases &gt;&gt;</vh></v>
</v>
<v t="T595" a="C"><vh>&lt;&lt; stack cases &gt;&gt; c</vh>
<v t="T596"><vh>&lt;&lt; DUP_TOP &gt;&gt;</vh></v>
<v t="T597"><vh>&lt;&lt; DUP_TOPX &gt;&gt;</vh></v>
<v t="T598"><vh>&lt;&lt; POP_TOP &gt;&gt;</vh></v>
<v t="T599"><vh>&lt;&lt; ROT_TWO &gt;&gt;</vh></v>
<v t="T600"><vh>&lt;&lt; ROT_THREE &gt;&gt;</vh></v>
<v t="T601"><vh>&lt;&lt; ROT_FOUR &gt;&gt;</vh></v>
</v>
<v t="T602" a="C"><vh>&lt;&lt; store cases &gt;&gt; c</vh>
<v t="T603"><vh>&lt;&lt; STORE_DEREF &gt;&gt;</vh></v>
<v t="T604"><vh>&lt;&lt; STORE_FAST &gt;&gt;</vh></v>
<v t="T605"><vh>&lt;&lt; STORE_GLOBAL &gt;&gt;</vh></v>
<v t="T606"><vh>&lt;&lt; STORE_NAME &gt;&gt;</vh></v>
</v>
<v t="T607" a="C"><vh>&lt;&lt; subscript cases &gt;&gt; c</vh>
<v t="T608"><vh>&lt;&lt; STORE_SUBSCR &gt;&gt;</vh></v>
<v t="T609"><vh>&lt;&lt; DELETE_SUBSCR &gt;&gt;</vh></v>
</v>
<v t="T610" a="C"><vh>&lt;&lt; unary cases &gt;&gt; c</vh>
<v t="T611"><vh>&lt;&lt; UNARY_POSITIVE &gt;&gt;</vh></v>
<v t="T612"><vh>&lt;&lt; UNARY_NEGATIVE &gt;&gt;</vh></v>
<v t="T613"><vh>&lt;&lt; UNARY_NOT &gt;&gt;</vh></v>
<v t="T614"><vh>&lt;&lt; UNARY_CONVERT &gt;&gt;</vh></v>
<v t="T615"><vh>&lt;&lt; UNARY_INVERT &gt;&gt;</vh></v>
</v>
<v t="T616" a="C"><vh>&lt;&lt; UNPACK_SEQUENCE &gt;&gt;</vh></v>
</v>
<v t="T617"><vh>&lt;&lt; end loop &gt;&gt;</vh></v>
<v t="T618"><vh>&lt;&lt; finalize &gt;&gt;</vh></v>
</v>
<v t="T422" a="C"><vh>psyco_pycompiler_mainloop (Python)</vh>
<v t="T423"><vh>&lt;&lt; outer loop &gt;&gt;</vh>
<v t="T424"><vh>&lt;&lt; define loop vars &gt;&gt;</vh></v>
<v t="T425"><vh>&lt;&lt; main loop &gt;&gt;</vh>
<v t="T426" a="C"><vh>&lt;&lt; handle opcodes &gt;&gt; (psyco)</vh>
<v t="T427" a="C"><vh>&lt;&lt; binary opcodes &gt;&gt; psyco</vh>
<v t="T428"><vh>&lt;&lt; BINARY_OPCODE macro (psyco) &gt;&gt;</vh></v>
<v t="T429"><vh>&lt;&lt; binary_power &gt;&gt;</vh></v>
<v t="T430"><vh>&lt;&lt; inplace_power &gt;&gt;</vh></v>
</v>
<v t="T431" a="C"><vh>&lt;&lt; compare_op &gt;&gt; psyco</vh></v>
<v t="T432" a="C"><vh>&lt;&lt; default case &gt;&gt; psyco</vh></v>
<v t="T433" a="C"><vh>&lt;&lt; exec_stmt &gt;&gt; psyco</vh></v>
<v t="T434" a="C"><vh>&lt;&lt; flow of control cases &gt;&gt; psyco </vh>
<v t="T283" a="C"><vh>Iteration helpers... (psyco)</vh>
<v t="T284"><vh>PsycoObject_GetIter</vh></v>
<v t="T285"><vh>PsycoIter_Next</vh></v>
</v>
<v t="T435"><vh>&lt;&lt; break_loop &gt;&gt; psyco</vh></v>
<v t="T436"><vh>&lt;&lt; continue_loop &gt;&gt; psyco</vh></v>
<v t="T437"><vh>&lt;&lt; end_finally &gt;&gt; psyco</vh></v>
<v t="T438"><vh>&lt;&lt; iters &gt;&gt; psycho</vh>
<v t="T439"><vh>&lt;&lt; for_iter &gt;&gt;</vh></v>
<v t="T440"><vh>&lt;&lt; get_iter &gt;&gt;</vh></v>
<v t="T441"><vh>&lt;&lt; yeild_value &gt;&gt;</vh></v>
</v>
<v t="T442"><vh>&lt;&lt; jumps &gt;&gt; psyco</vh>
<v t="T443"><vh>&lt;&lt; jump_forward &gt;&gt;</vh></v>
<v t="T444"><vh>&lt;&lt; jump_if_true/false &gt;&gt;</vh></v>
<v t="T445"><vh>&lt;&lt; jump_absolute &gt;&gt;</vh></v>
</v>
<v t="T446"><vh>&lt;&lt; pop_block &gt;&gt; psyco</vh></v>
<v t="T447"><vh>&lt;&lt; setup_loop/except/finally &gt;&gt; psyco</vh></v>
</v>
<v t="T448" a="C"><vh>&lt;&lt; function call/make/return &gt;&gt; psyco</vh>
<v t="T449"><vh>&lt;&lt; call_function &gt;&gt;</vh></v>
<v t="T450"><vh>&lt;&lt; extended_arg &gt;&gt;</vh></v>
<v t="T451"><vh>&lt;&lt; return_value &gt;&gt; psyco</vh></v>
</v>
<v t="T452" a="C"><vh>&lt;&lt; import &gt;&gt; psyco</vh></v>
<v t="T453" a="C"><vh>&lt;&lt; load/store/build/delete &gt;&gt; psyco</vh>
<v t="T454"><vh>&lt;&lt; build_list &gt;&gt;</vh></v>
<v t="T455"><vh>&lt;&lt; build_map &gt;&gt;</vh></v>
<v t="T456"><vh>&lt;&lt; build_tuple &gt;&gt;</vh></v>
<v t="T457"><vh>&lt;&lt; delete_attr &gt;&gt;</vh></v>
<v t="T458"><vh>&lt;&lt; delete_fast &gt;&gt;</vh></v>
<v t="T459"><vh>&lt;&lt; delete_global &gt;&gt;</vh></v>
<v t="T460"><vh>&lt;&lt; load_attr &gt;&gt;</vh></v>
<v t="T461"><vh>&lt;&lt; load_const &gt;&gt;</vh></v>
<v t="T462"><vh>&lt;&lt; load_fast &gt;&gt;</vh></v>
<v t="T463"><vh>&lt;&lt; load_global &gt;&gt;</vh></v>
<v t="T464"><vh>&lt;&lt; store_attr &gt;&gt;</vh></v>
<v t="T465"><vh>&lt;&lt; store_fast &gt;&gt;</vh></v>
<v t="T466"><vh>&lt;&lt; store_global &gt;&gt;</vh></v>
</v>
<v t="T467" a="C"><vh>&lt;&lt; print &gt;&gt; psyco</vh>
<v t="T468"><vh>&lt;&lt; print_item &gt;&gt;</vh></v>
<v t="T469"><vh>&lt;&lt; print_item_to &gt;&gt;</vh></v>
<v t="T470"><vh>&lt;&lt; print_newline &gt;&gt;</vh></v>
<v t="T471"><vh>&lt;&lt; print_newline_to &gt;&gt;</vh></v>
</v>
<v t="T472" a="C"><vh>&lt;&lt; set_lineno &gt;&gt; psyco</vh></v>
<v t="T473" a="C"><vh>&lt;&lt; slice &gt;&gt; psyco</vh>
<v t="T474"><vh>&lt;&lt; slice cases  &gt;&gt; psyco</vh></v>
<v t="T475"><vh>&lt;&lt; store slice cases &gt;&gt; psyco</vh></v>
<v t="T476"><vh>&lt;&lt; delete slice cases &gt;&gt; psyco</vh></v>
</v>
<v t="T477" a="C"><vh>&lt;&lt; stack opcodes &gt;&gt; psyco</vh>
<v t="T478"><vh>&lt;&lt; dup_top &gt;&gt;</vh></v>
<v t="T479"><vh>&lt;&lt; dup_topx &gt;&gt;</vh></v>
<v t="T480"><vh>&lt;&lt; pop_top &gt;&gt;</vh></v>
<v t="T481"><vh>&lt;&lt; rot_two &gt;&gt;</vh></v>
<v t="T482"><vh>&lt;&lt; rot_three &gt;&gt;</vh></v>
<v t="T483"><vh>&lt;&lt; rot_four &gt;&gt;</vh></v>
</v>
<v t="T484" a="C"><vh>&lt;&lt; subscript &gt;&gt; psyco</vh>
<v t="T485"><vh>&lt;&lt; store_subscr &gt;&gt;</vh></v>
<v t="T486"><vh>&lt;&lt; delete_subscr &gt;&gt;</vh></v>
</v>
<v t="T487" a="C"><vh>&lt;&lt; unary opcodes &gt;&gt; psyco</vh>
<v t="T488"><vh>&lt;&lt; unary_positive &gt;&gt;</vh></v>
<v t="T489"><vh>&lt;&lt; unary_negative &gt;&gt;</vh></v>
<v t="T490"><vh>&lt;&lt; unary_not &gt;&gt;</vh></v>
<v t="T491"><vh>&lt;&lt; unary_convert &gt;&gt;</vh></v>
<v t="T492"><vh>&lt;&lt; unary_invert &gt;&gt;</vh></v>
</v>
<v t="T493" a="C"><vh>&lt;&lt; unpack_sequence &gt;&gt; psyco</vh></v>
</v>
</v>
<v t="T494"><vh>&lt;&lt; unwind the stack &gt;&gt;</vh></v>
<v t="T495"><vh>&lt;&lt; check for the 'promotion' pseudo-exception &gt;&gt;</vh></v>
</v>
</v>
<v t="T248" a="C"><vh> pabstract.c (implements psyco opcodes)</vh>
<v t="T249"><vh>type_error</vh></v>
<v t="T250" a="C"><vh>PsycoObject_Call (psyco)</vh></v>
<v t="T251" a="C"><vh>Getters... (psyco)</vh>
<v t="T252"><vh>psyco_generic_immut_ob_size</vh></v>
<v t="T253"><vh>psyco_generic_mut_ob_size</vh></v>
<v t="T254"><vh>PsycoObject_GetItem</vh></v>
<v t="T255"><vh>PsycoObject_Size</vh></v>
<v t="T256"><vh>PsycoSequence_GetItem</vh></v>
<v t="T257"><vh>PsycoSequence_GetSlice</vh></v>
</v>
<v t="T258" a="C"><vh>Setters... (psyco)</vh>
<v t="T259"><vh>PsycoObject_SetItem</vh></v>
<v t="T260"><vh>PsycoSequence_SetItem</vh></v>
<v t="T261"><vh>PsycoSequence_SetSlice</vh></v>
</v>
<v t="T262" a="C"><vh>Numeric helper functions... (psyco)</vh>
<v t="T263"><vh>PsycoNumber_Positive</vh></v>
<v t="T264"><vh>PsycoNumber_Negative</vh></v>
<v t="T265"><vh>PsycoNumber_Invert</vh></v>
<v t="T266"><vh>cimpl_oldstyle_binary_op1</vh></v>
<v t="T267"><vh>binary_op1</vh></v>
<v t="T268"><vh>binary_op</vh></v>
<v t="T269"><vh>BINARY_FUNC (Implements PsycoNumber_xxx functions)</vh></v>
<v t="T270"><vh>PsycoNumber_Remainder</vh></v>
<v t="T271"><vh>PsycoNumber_Power</vh></v>
<v t="T272"><vh>PsycoNumber_InPlaceAdd</vh></v>
<v t="T273"><vh>PsycoNumber_InPlaceOr</vh></v>
<v t="T274"><vh>PsycoNumber_InPlaceXor</vh></v>
<v t="T275"><vh>PsycoNumber_InPlaceAnd</vh></v>
<v t="T276"><vh>PsycoNumber_InPlaceLshift</vh></v>
<v t="T277"><vh>PsycoNumber_InPlaceRshift</vh></v>
<v t="T278"><vh>PsycoNumber_InPlaceSubtract</vh></v>
<v t="T279"><vh>PsycoNumber_InPlaceMultiply</vh></v>
<v t="T280"><vh>PsycoNumber_InPlaceDivide</vh></v>
<v t="T281"><vh>PsycoNumber_InPlaceRemainder</vh></v>
<v t="T282"><vh>PsycoNumber_InPlacePower</vh></v>
</v>
<v t="T283" a="C"><vh>Iteration helpers... (psyco)</vh>
<v t="T284"><vh>PsycoObject_GetIter</vh></v>
<v t="T285"><vh>PsycoIter_Next</vh></v>
</v>
</v>
<v t="T505" a="C"><vh>&lt;&lt; opcode cases &gt;&gt; c</vh>
<v t="T506" a="C"><vh>&lt;&lt; binary cases &gt;&gt; c</vh>
<v t="T507"><vh>binary ops</vh>
<v t="T508"><vh>&lt;&lt; BINARY_POWER &gt;&gt;</vh></v>
<v t="T509"><vh>&lt;&lt; BINARY_MULTIPLY &gt;&gt;</vh></v>
<v t="T510"><vh>&lt;&lt; BINARY_DIVIDE &gt;&gt;</vh></v>
<v t="T511"><vh>&lt;&lt; BINARY_FLOOR_DIVIDE &gt;&gt;</vh></v>
<v t="T512"><vh>&lt;&lt; BINARY_MODULO &gt;&gt;</vh></v>
<v t="T513"><vh>&lt;&lt; BINARY_ADD &gt;&gt;</vh></v>
<v t="T514"><vh>&lt;&lt; BINARY_SUBTRACT &gt;&gt;</vh></v>
<v t="T515"><vh>&lt;&lt; BINARY_SUBSCR &gt;&gt;</vh></v>
<v t="T516"><vh>&lt;&lt; BINARY_LSHIFT &gt;&gt;</vh></v>
<v t="T517"><vh>&lt;&lt; BINARY_RSHIFT &gt;&gt;</vh></v>
<v t="T518"><vh>&lt;&lt; BINARY_AND &gt;&gt;</vh></v>
<v t="T519"><vh>&lt;&lt; BINARY_XOR &gt;&gt;</vh></v>
<v t="T520"><vh>&lt;&lt; BINARY_OR &gt;&gt;</vh></v>
</v>
<v t="T521"><vh>inplace ops</vh>
<v t="T522"><vh>&lt;&lt; INPLACE_POWER &gt;&gt;</vh></v>
<v t="T523"><vh>&lt;&lt; INPLACE_MULTIPLY &gt;&gt;</vh></v>
<v t="T524"><vh>&lt;&lt; INPLACE_DIVIDE &gt;&gt;</vh></v>
<v t="T525"><vh>&lt;&lt; INPLACE_FLOOR_DIVIDE &gt;&gt;</vh></v>
<v t="T526"><vh>&lt;&lt; INPLACE_TRUE_DIVIDE &gt;&gt;</vh></v>
<v t="T527"><vh>&lt;&lt; INPLACE_MODULO &gt;&gt;</vh></v>
<v t="T528"><vh>&lt;&lt; INPLACE_ADD &gt;&gt;</vh></v>
<v t="T529"><vh>&lt;&lt; INPLACE_SUBTRACT &gt;&gt;</vh></v>
<v t="T530"><vh>&lt;&lt; INPLACE_LSHIFT &gt;&gt;</vh></v>
<v t="T531"><vh>&lt;&lt; INPLACE_RSHIFT &gt;&gt;</vh></v>
<v t="T532"><vh>&lt;&lt; INPLACE_AND &gt;&gt;</vh></v>
<v t="T533"><vh>&lt;&lt; INPLACE_XOR &gt;&gt;</vh></v>
<v t="T534"><vh>&lt;&lt; INPLACE_OR &gt;&gt;</vh></v>
</v>
</v>
<v t="T535" a="C"><vh>&lt;&lt; build cases &gt;&gt; c</vh>
<v t="T536"><vh>&lt;&lt; BUILD_CLASS &gt;&gt;</vh></v>
<v t="T537"><vh>&lt;&lt; BUILD_LIST &gt;&gt;</vh></v>
<v t="T538"><vh>&lt;&lt; BUILD_MAP &gt;&gt;</vh></v>
<v t="T539"><vh>&lt;&lt; BUILD_SLICE &gt;&gt;</vh></v>
<v t="T540"><vh>&lt;&lt; BUILD_TUPLE &gt;&gt;</vh></v>
</v>
<v t="T541" a="C"><vh>&lt;&lt; function call/make/return cases &gt;&gt; c</vh>
<v t="T542"><vh>&lt;&lt; CALL_FUNCTION &gt;&gt;</vh></v>
<v t="T543"><vh>&lt;&lt; CALL_FUNCTION_VAR/KW/VAR_KW &gt;&gt;</vh></v>
<v t="T544"><vh>&lt;&lt; MAKE_FUNCTION &gt;&gt;</vh></v>
<v t="T545"><vh>&lt;&lt; MAKE_CLOSURE &gt;&gt;</vh></v>
<v t="T546"><vh>&lt;&lt; RETURN_VALUE &gt;&gt;</vh></v>
</v>
<v t="T547" a="C"><vh>&lt;&lt; COMPARE_OP &gt;&gt; c</vh></v>
<v t="T548" a="C"><vh>&lt;&lt; default case &gt;&gt; c</vh></v>
<v t="T549" a="C"><vh>&lt;&lt; delete cases &gt;&gt; c</vh>
<v t="T550"><vh>&lt;&lt; DELETE_ATTR &gt;&gt;</vh></v>
<v t="T551"><vh>&lt;&lt; DELETE_FAST &gt;&gt;</vh></v>
<v t="T552"><vh>&lt;&lt; DELETE_GLOBAL &gt;&gt;</vh></v>
<v t="T553"><vh>&lt;&lt; DELETE_NAME &gt;&gt;</vh></v>
</v>
<v t="T554" a="C"><vh>&lt;&lt; EXTENDED_ARG &gt;&gt; c</vh></v>
<v t="T555"><vh>&lt;&lt; EXEC_STMT &gt;&gt;</vh></v>
<v t="T556" a="C"><vh>&lt;&lt; flow-of-control cases &gt;&gt; c</vh>
<v t="T557"><vh>&lt;&lt; BREAK_LOOP &gt;&gt;</vh></v>
<v t="T558"><vh>&lt;&lt; CONTINUE_LOOP &gt;&gt;</vh></v>
<v t="T559"><vh>&lt;&lt; END_FINALLY &gt;&gt;</vh></v>
<v t="T560"><vh>&lt;&lt; iter cases &gt;&gt; c</vh>
<v t="T561"><vh>&lt;&lt; FOR_ITER &gt;&gt;</vh></v>
<v t="T562"><vh>&lt;&lt; GET_ITER &gt;&gt;</vh></v>
<v t="T563"><vh>&lt;&lt; YIELD_VALUE &gt;&gt;</vh></v>
</v>
<v t="T564"><vh>&lt;&lt; jump cases &gt;&gt; c</vh>
<v t="T565"><vh>&lt;&lt; JUMP_FORWARD &gt;&gt;</vh></v>
<v t="T566"><vh>&lt;&lt; JUMP_IF_FALSE &gt;&gt;</vh></v>
<v t="T567"><vh>&lt;&lt; JUMP_IF_TRUE &gt;&gt;</vh></v>
<v t="T568"><vh>&lt;&lt; JUMP_ABSOLUTE &gt;&gt;</vh></v>
</v>
<v t="T569"><vh>&lt;&lt; FOR_LOOP &gt;&gt;</vh></v>
<v t="T570"><vh>&lt;&lt; POP_BLOCK &gt;&gt;</vh></v>
<v t="T571"><vh>&lt;&lt; RAISE_VARARGS &gt;&gt;</vh></v>
<v t="T572"><vh>&lt;&lt; SETUP_LOOP/EXCEPT/FINALLY &gt;&gt;</vh></v>
</v>
<v t="T573" a="C"><vh>&lt;&lt; import cases &gt;&gt; c</vh>
<v t="T574"><vh>&lt;&lt; IMPORT_NAME &gt;&gt;</vh></v>
<v t="T575"><vh>&lt;&lt; IMPORT_STAR &gt;&gt;</vh></v>
<v t="T576"><vh>&lt;&lt; IMPORT_FROM &gt;&gt;</vh></v>
</v>
<v t="T577" a="C"><vh>&lt;&lt; load cases &gt;&gt; c</vh>
<v t="T578"><vh>&lt;&lt; LOAD_ATTR &gt;&gt;</vh></v>
<v t="T579"><vh>&lt;&lt; LOAD_CLOSURE &gt;&gt;</vh></v>
<v t="T580"><vh>&lt;&lt; LOAD_CONST &gt;&gt;</vh></v>
<v t="T581"><vh>&lt;&lt; LOAD_DEREF &gt;&gt;</vh></v>
<v t="T582"><vh>&lt;&lt; LOAD_LOCALS &gt;&gt;</vh></v>
<v t="T583"><vh>&lt;&lt; LOAD_FAST &gt;&gt;</vh></v>
<v t="T584"><vh>&lt;&lt; LOAD_GLOBAL &gt;&gt;</vh></v>
<v t="T585"><vh>&lt;&lt; LOAD_NAME &gt;&gt;</vh></v>
</v>
<v t="T586" a="C"><vh>&lt;&lt; print cases &gt;&gt; c</vh>
<v t="T587"><vh>&lt;&lt; PRINT_EXPR &gt;&gt;</vh></v>
<v t="T588"><vh>&lt;&lt; PRINT_ITEM_TO/PRINT_ITEM &gt;&gt;</vh></v>
<v t="T589"><vh>&lt;&lt; PRINT_NEWLINE_TO/PRINT_NEWLINE &gt;&gt;</vh></v>
</v>
<v t="T590" a="C"><vh>&lt;&lt; SET_LINENO &gt;&gt; c</vh></v>
<v t="T591" a="C"><vh>&lt;&lt; slice cases &gt;&gt; c</vh>
<v t="T592"><vh>&lt;&lt; SLICE cases &gt;&gt;</vh></v>
<v t="T593"><vh>&lt;&lt; STORE_SLICE cases &gt;&gt;</vh></v>
<v t="T594"><vh>&lt;&lt; DELETE_SLICE cases &gt;&gt;</vh></v>
</v>
<v t="T595" a="C"><vh>&lt;&lt; stack cases &gt;&gt; c</vh>
<v t="T596"><vh>&lt;&lt; DUP_TOP &gt;&gt;</vh></v>
<v t="T597"><vh>&lt;&lt; DUP_TOPX &gt;&gt;</vh></v>
<v t="T598"><vh>&lt;&lt; POP_TOP &gt;&gt;</vh></v>
<v t="T599"><vh>&lt;&lt; ROT_TWO &gt;&gt;</vh></v>
<v t="T600"><vh>&lt;&lt; ROT_THREE &gt;&gt;</vh></v>
<v t="T601"><vh>&lt;&lt; ROT_FOUR &gt;&gt;</vh></v>
</v>
<v t="T602" a="C"><vh>&lt;&lt; store cases &gt;&gt; c</vh>
<v t="T603"><vh>&lt;&lt; STORE_DEREF &gt;&gt;</vh></v>
<v t="T604"><vh>&lt;&lt; STORE_FAST &gt;&gt;</vh></v>
<v t="T605"><vh>&lt;&lt; STORE_GLOBAL &gt;&gt;</vh></v>
<v t="T606"><vh>&lt;&lt; STORE_NAME &gt;&gt;</vh></v>
</v>
<v t="T607" a="C"><vh>&lt;&lt; subscript cases &gt;&gt; c</vh>
<v t="T608"><vh>&lt;&lt; STORE_SUBSCR &gt;&gt;</vh></v>
<v t="T609"><vh>&lt;&lt; DELETE_SUBSCR &gt;&gt;</vh></v>
</v>
<v t="T610" a="C"><vh>&lt;&lt; unary cases &gt;&gt; c</vh>
<v t="T611"><vh>&lt;&lt; UNARY_POSITIVE &gt;&gt;</vh></v>
<v t="T612"><vh>&lt;&lt; UNARY_NEGATIVE &gt;&gt;</vh></v>
<v t="T613"><vh>&lt;&lt; UNARY_NOT &gt;&gt;</vh></v>
<v t="T614"><vh>&lt;&lt; UNARY_CONVERT &gt;&gt;</vh></v>
<v t="T615"><vh>&lt;&lt; UNARY_INVERT &gt;&gt;</vh></v>
</v>
<v t="T616" a="C"><vh>&lt;&lt; UNPACK_SEQUENCE &gt;&gt;</vh></v>
</v>
<v t="T426" a="C"><vh>&lt;&lt; handle opcodes &gt;&gt; (psyco)</vh>
<v t="T427" a="C"><vh>&lt;&lt; binary opcodes &gt;&gt; psyco</vh>
<v t="T428"><vh>&lt;&lt; BINARY_OPCODE macro (psyco) &gt;&gt;</vh></v>
<v t="T429"><vh>&lt;&lt; binary_power &gt;&gt;</vh></v>
<v t="T430"><vh>&lt;&lt; inplace_power &gt;&gt;</vh></v>
</v>
<v t="T431" a="C"><vh>&lt;&lt; compare_op &gt;&gt; psyco</vh></v>
<v t="T432" a="C"><vh>&lt;&lt; default case &gt;&gt; psyco</vh></v>
<v t="T433" a="C"><vh>&lt;&lt; exec_stmt &gt;&gt; psyco</vh></v>
<v t="T434" a="C"><vh>&lt;&lt; flow of control cases &gt;&gt; psyco </vh>
<v t="T283" a="C"><vh>Iteration helpers... (psyco)</vh>
<v t="T284"><vh>PsycoObject_GetIter</vh></v>
<v t="T285"><vh>PsycoIter_Next</vh></v>
</v>
<v t="T435"><vh>&lt;&lt; break_loop &gt;&gt; psyco</vh></v>
<v t="T436"><vh>&lt;&lt; continue_loop &gt;&gt; psyco</vh></v>
<v t="T437"><vh>&lt;&lt; end_finally &gt;&gt; psyco</vh></v>
<v t="T438"><vh>&lt;&lt; iters &gt;&gt; psycho</vh>
<v t="T439"><vh>&lt;&lt; for_iter &gt;&gt;</vh></v>
<v t="T440"><vh>&lt;&lt; get_iter &gt;&gt;</vh></v>
<v t="T441"><vh>&lt;&lt; yeild_value &gt;&gt;</vh></v>
</v>
<v t="T442"><vh>&lt;&lt; jumps &gt;&gt; psyco</vh>
<v t="T443"><vh>&lt;&lt; jump_forward &gt;&gt;</vh></v>
<v t="T444"><vh>&lt;&lt; jump_if_true/false &gt;&gt;</vh></v>
<v t="T445"><vh>&lt;&lt; jump_absolute &gt;&gt;</vh></v>
</v>
<v t="T446"><vh>&lt;&lt; pop_block &gt;&gt; psyco</vh></v>
<v t="T447"><vh>&lt;&lt; setup_loop/except/finally &gt;&gt; psyco</vh></v>
</v>
<v t="T448" a="C"><vh>&lt;&lt; function call/make/return &gt;&gt; psyco</vh>
<v t="T449"><vh>&lt;&lt; call_function &gt;&gt;</vh></v>
<v t="T450"><vh>&lt;&lt; extended_arg &gt;&gt;</vh></v>
<v t="T451"><vh>&lt;&lt; return_value &gt;&gt; psyco</vh></v>
</v>
<v t="T452" a="C"><vh>&lt;&lt; import &gt;&gt; psyco</vh></v>
<v t="T453" a="C"><vh>&lt;&lt; load/store/build/delete &gt;&gt; psyco</vh>
<v t="T454"><vh>&lt;&lt; build_list &gt;&gt;</vh></v>
<v t="T455"><vh>&lt;&lt; build_map &gt;&gt;</vh></v>
<v t="T456"><vh>&lt;&lt; build_tuple &gt;&gt;</vh></v>
<v t="T457"><vh>&lt;&lt; delete_attr &gt;&gt;</vh></v>
<v t="T458"><vh>&lt;&lt; delete_fast &gt;&gt;</vh></v>
<v t="T459"><vh>&lt;&lt; delete_global &gt;&gt;</vh></v>
<v t="T460"><vh>&lt;&lt; load_attr &gt;&gt;</vh></v>
<v t="T461"><vh>&lt;&lt; load_const &gt;&gt;</vh></v>
<v t="T462"><vh>&lt;&lt; load_fast &gt;&gt;</vh></v>
<v t="T463"><vh>&lt;&lt; load_global &gt;&gt;</vh></v>
<v t="T464"><vh>&lt;&lt; store_attr &gt;&gt;</vh></v>
<v t="T465"><vh>&lt;&lt; store_fast &gt;&gt;</vh></v>
<v t="T466"><vh>&lt;&lt; store_global &gt;&gt;</vh></v>
</v>
<v t="T467" a="C"><vh>&lt;&lt; print &gt;&gt; psyco</vh>
<v t="T468"><vh>&lt;&lt; print_item &gt;&gt;</vh></v>
<v t="T469"><vh>&lt;&lt; print_item_to &gt;&gt;</vh></v>
<v t="T470"><vh>&lt;&lt; print_newline &gt;&gt;</vh></v>
<v t="T471"><vh>&lt;&lt; print_newline_to &gt;&gt;</vh></v>
</v>
<v t="T472" a="C"><vh>&lt;&lt; set_lineno &gt;&gt; psyco</vh></v>
<v t="T473" a="C"><vh>&lt;&lt; slice &gt;&gt; psyco</vh>
<v t="T474"><vh>&lt;&lt; slice cases  &gt;&gt; psyco</vh></v>
<v t="T475"><vh>&lt;&lt; store slice cases &gt;&gt; psyco</vh></v>
<v t="T476"><vh>&lt;&lt; delete slice cases &gt;&gt; psyco</vh></v>
</v>
<v t="T477" a="C"><vh>&lt;&lt; stack opcodes &gt;&gt; psyco</vh>
<v t="T478"><vh>&lt;&lt; dup_top &gt;&gt;</vh></v>
<v t="T479"><vh>&lt;&lt; dup_topx &gt;&gt;</vh></v>
<v t="T480"><vh>&lt;&lt; pop_top &gt;&gt;</vh></v>
<v t="T481"><vh>&lt;&lt; rot_two &gt;&gt;</vh></v>
<v t="T482"><vh>&lt;&lt; rot_three &gt;&gt;</vh></v>
<v t="T483"><vh>&lt;&lt; rot_four &gt;&gt;</vh></v>
</v>
<v t="T484" a="C"><vh>&lt;&lt; subscript &gt;&gt; psyco</vh>
<v t="T485"><vh>&lt;&lt; store_subscr &gt;&gt;</vh></v>
<v t="T486"><vh>&lt;&lt; delete_subscr &gt;&gt;</vh></v>
</v>
<v t="T487" a="C"><vh>&lt;&lt; unary opcodes &gt;&gt; psyco</vh>
<v t="T488"><vh>&lt;&lt; unary_positive &gt;&gt;</vh></v>
<v t="T489"><vh>&lt;&lt; unary_negative &gt;&gt;</vh></v>
<v t="T490"><vh>&lt;&lt; unary_not &gt;&gt;</vh></v>
<v t="T491"><vh>&lt;&lt; unary_convert &gt;&gt;</vh></v>
<v t="T492"><vh>&lt;&lt; unary_invert &gt;&gt;</vh></v>
</v>
<v t="T493" a="C"><vh>&lt;&lt; unpack_sequence &gt;&gt; psyco</vh></v>
</v>
</v>
<v t="T619" a="V"><vh>(Psyco vs. eval_frame)</vh>
<v t="T248" a="C"><vh> pabstract.c (implements psyco opcodes)</vh>
<v t="T249"><vh>type_error</vh></v>
<v t="T250" a="C"><vh>PsycoObject_Call (psyco)</vh></v>
<v t="T251" a="C"><vh>Getters... (psyco)</vh>
<v t="T252"><vh>psyco_generic_immut_ob_size</vh></v>
<v t="T253"><vh>psyco_generic_mut_ob_size</vh></v>
<v t="T254"><vh>PsycoObject_GetItem</vh></v>
<v t="T255"><vh>PsycoObject_Size</vh></v>
<v t="T256"><vh>PsycoSequence_GetItem</vh></v>
<v t="T257"><vh>PsycoSequence_GetSlice</vh></v>
</v>
<v t="T258" a="C"><vh>Setters... (psyco)</vh>
<v t="T259"><vh>PsycoObject_SetItem</vh></v>
<v t="T260"><vh>PsycoSequence_SetItem</vh></v>
<v t="T261"><vh>PsycoSequence_SetSlice</vh></v>
</v>
<v t="T262" a="C"><vh>Numeric helper functions... (psyco)</vh>
<v t="T263"><vh>PsycoNumber_Positive</vh></v>
<v t="T264"><vh>PsycoNumber_Negative</vh></v>
<v t="T265"><vh>PsycoNumber_Invert</vh></v>
<v t="T266"><vh>cimpl_oldstyle_binary_op1</vh></v>
<v t="T267"><vh>binary_op1</vh></v>
<v t="T268"><vh>binary_op</vh></v>
<v t="T269"><vh>BINARY_FUNC (Implements PsycoNumber_xxx functions)</vh></v>
<v t="T270"><vh>PsycoNumber_Remainder</vh></v>
<v t="T271"><vh>PsycoNumber_Power</vh></v>
<v t="T272"><vh>PsycoNumber_InPlaceAdd</vh></v>
<v t="T273"><vh>PsycoNumber_InPlaceOr</vh></v>
<v t="T274"><vh>PsycoNumber_InPlaceXor</vh></v>
<v t="T275"><vh>PsycoNumber_InPlaceAnd</vh></v>
<v t="T276"><vh>PsycoNumber_InPlaceLshift</vh></v>
<v t="T277"><vh>PsycoNumber_InPlaceRshift</vh></v>
<v t="T278"><vh>PsycoNumber_InPlaceSubtract</vh></v>
<v t="T279"><vh>PsycoNumber_InPlaceMultiply</vh></v>
<v t="T280"><vh>PsycoNumber_InPlaceDivide</vh></v>
<v t="T281"><vh>PsycoNumber_InPlaceRemainder</vh></v>
<v t="T282"><vh>PsycoNumber_InPlacePower</vh></v>
</v>
<v t="T283" a="C"><vh>Iteration helpers... (psyco)</vh>
<v t="T284"><vh>PsycoObject_GetIter</vh></v>
<v t="T285"><vh>PsycoIter_Next</vh></v>
</v>
</v>
<v><vh>Arithmetic opcodes</vh>
<v t="T262" a="C"><vh>Numeric helper functions... (psyco)</vh>
<v t="T263"><vh>PsycoNumber_Positive</vh></v>
<v t="T264"><vh>PsycoNumber_Negative</vh></v>
<v t="T265"><vh>PsycoNumber_Invert</vh></v>
<v t="T266"><vh>cimpl_oldstyle_binary_op1</vh></v>
<v t="T267"><vh>binary_op1</vh></v>
<v t="T268"><vh>binary_op</vh></v>
<v t="T269"><vh>BINARY_FUNC (Implements PsycoNumber_xxx functions)</vh></v>
<v t="T270"><vh>PsycoNumber_Remainder</vh></v>
<v t="T271"><vh>PsycoNumber_Power</vh></v>
<v t="T272"><vh>PsycoNumber_InPlaceAdd</vh></v>
<v t="T273"><vh>PsycoNumber_InPlaceOr</vh></v>
<v t="T274"><vh>PsycoNumber_InPlaceXor</vh></v>
<v t="T275"><vh>PsycoNumber_InPlaceAnd</vh></v>
<v t="T276"><vh>PsycoNumber_InPlaceLshift</vh></v>
<v t="T277"><vh>PsycoNumber_InPlaceRshift</vh></v>
<v t="T278"><vh>PsycoNumber_InPlaceSubtract</vh></v>
<v t="T279"><vh>PsycoNumber_InPlaceMultiply</vh></v>
<v t="T280"><vh>PsycoNumber_InPlaceDivide</vh></v>
<v t="T281"><vh>PsycoNumber_InPlaceRemainder</vh></v>
<v t="T282"><vh>PsycoNumber_InPlacePower</vh></v>
</v>
<v a="E"><vh>binary opcodes</vh>
<v t="T506" a="C"><vh>&lt;&lt; binary cases &gt;&gt; c</vh>
<v t="T507"><vh>binary ops</vh>
<v t="T508"><vh>&lt;&lt; BINARY_POWER &gt;&gt;</vh></v>
<v t="T509"><vh>&lt;&lt; BINARY_MULTIPLY &gt;&gt;</vh></v>
<v t="T510"><vh>&lt;&lt; BINARY_DIVIDE &gt;&gt;</vh></v>
<v t="T511"><vh>&lt;&lt; BINARY_FLOOR_DIVIDE &gt;&gt;</vh></v>
<v t="T512"><vh>&lt;&lt; BINARY_MODULO &gt;&gt;</vh></v>
<v t="T513"><vh>&lt;&lt; BINARY_ADD &gt;&gt;</vh></v>
<v t="T514"><vh>&lt;&lt; BINARY_SUBTRACT &gt;&gt;</vh></v>
<v t="T515"><vh>&lt;&lt; BINARY_SUBSCR &gt;&gt;</vh></v>
<v t="T516"><vh>&lt;&lt; BINARY_LSHIFT &gt;&gt;</vh></v>
<v t="T517"><vh>&lt;&lt; BINARY_RSHIFT &gt;&gt;</vh></v>
<v t="T518"><vh>&lt;&lt; BINARY_AND &gt;&gt;</vh></v>
<v t="T519"><vh>&lt;&lt; BINARY_XOR &gt;&gt;</vh></v>
<v t="T520"><vh>&lt;&lt; BINARY_OR &gt;&gt;</vh></v>
</v>
<v t="T521"><vh>inplace ops</vh>
<v t="T522"><vh>&lt;&lt; INPLACE_POWER &gt;&gt;</vh></v>
<v t="T523"><vh>&lt;&lt; INPLACE_MULTIPLY &gt;&gt;</vh></v>
<v t="T524"><vh>&lt;&lt; INPLACE_DIVIDE &gt;&gt;</vh></v>
<v t="T525"><vh>&lt;&lt; INPLACE_FLOOR_DIVIDE &gt;&gt;</vh></v>
<v t="T526"><vh>&lt;&lt; INPLACE_TRUE_DIVIDE &gt;&gt;</vh></v>
<v t="T527"><vh>&lt;&lt; INPLACE_MODULO &gt;&gt;</vh></v>
<v t="T528"><vh>&lt;&lt; INPLACE_ADD &gt;&gt;</vh></v>
<v t="T529"><vh>&lt;&lt; INPLACE_SUBTRACT &gt;&gt;</vh></v>
<v t="T530"><vh>&lt;&lt; INPLACE_LSHIFT &gt;&gt;</vh></v>
<v t="T531"><vh>&lt;&lt; INPLACE_RSHIFT &gt;&gt;</vh></v>
<v t="T532"><vh>&lt;&lt; INPLACE_AND &gt;&gt;</vh></v>
<v t="T533"><vh>&lt;&lt; INPLACE_XOR &gt;&gt;</vh></v>
<v t="T534"><vh>&lt;&lt; INPLACE_OR &gt;&gt;</vh></v>
</v>
</v>
<v t="T427" a="CE"><vh>&lt;&lt; binary opcodes &gt;&gt; psyco</vh>
<v t="T428"><vh>&lt;&lt; BINARY_OPCODE macro (psyco) &gt;&gt;</vh></v>
<v t="T429"><vh>&lt;&lt; binary_power &gt;&gt;</vh></v>
<v t="T430"><vh>&lt;&lt; inplace_power &gt;&gt;</vh></v>
</v>
</v>
<v><vh>compare opcode</vh>
<v t="T547" a="C"><vh>&lt;&lt; COMPARE_OP &gt;&gt; c</vh></v>
<v t="T431" a="C"><vh>&lt;&lt; compare_op &gt;&gt; psyco</vh></v>
</v>
<v><vh>unary opcodes</vh>
<v t="T610" a="C"><vh>&lt;&lt; unary cases &gt;&gt; c</vh>
<v t="T611"><vh>&lt;&lt; UNARY_POSITIVE &gt;&gt;</vh></v>
<v t="T612"><vh>&lt;&lt; UNARY_NEGATIVE &gt;&gt;</vh></v>
<v t="T613"><vh>&lt;&lt; UNARY_NOT &gt;&gt;</vh></v>
<v t="T614"><vh>&lt;&lt; UNARY_CONVERT &gt;&gt;</vh></v>
<v t="T615"><vh>&lt;&lt; UNARY_INVERT &gt;&gt;</vh></v>
</v>
<v t="T487" a="C"><vh>&lt;&lt; unary opcodes &gt;&gt; psyco</vh>
<v t="T488"><vh>&lt;&lt; unary_positive &gt;&gt;</vh></v>
<v t="T489"><vh>&lt;&lt; unary_negative &gt;&gt;</vh></v>
<v t="T490"><vh>&lt;&lt; unary_not &gt;&gt;</vh></v>
<v t="T491"><vh>&lt;&lt; unary_convert &gt;&gt;</vh></v>
<v t="T492"><vh>&lt;&lt; unary_invert &gt;&gt;</vh></v>
</v>
</v>
</v>
<v><vh>default case</vh>
<v t="T548" a="C"><vh>&lt;&lt; default case &gt;&gt; c</vh></v>
<v t="T432" a="C"><vh>&lt;&lt; default case &gt;&gt; psyco</vh></v>
</v>
<v><vh>flow of control opcodes</vh>
<v t="T498" a="C"><vh>&lt;&lt; define macros &gt;&gt; c</vh></v>
<v t="T407" a="C"><vh>Macros (psyco)</vh></v>
<v t="T556" a="C"><vh>&lt;&lt; flow-of-control cases &gt;&gt; c</vh>
<v t="T557"><vh>&lt;&lt; BREAK_LOOP &gt;&gt;</vh></v>
<v t="T558"><vh>&lt;&lt; CONTINUE_LOOP &gt;&gt;</vh></v>
<v t="T559"><vh>&lt;&lt; END_FINALLY &gt;&gt;</vh></v>
<v t="T560"><vh>&lt;&lt; iter cases &gt;&gt; c</vh>
<v t="T561"><vh>&lt;&lt; FOR_ITER &gt;&gt;</vh></v>
<v t="T562"><vh>&lt;&lt; GET_ITER &gt;&gt;</vh></v>
<v t="T563"><vh>&lt;&lt; YIELD_VALUE &gt;&gt;</vh></v>
</v>
<v t="T564"><vh>&lt;&lt; jump cases &gt;&gt; c</vh>
<v t="T565"><vh>&lt;&lt; JUMP_FORWARD &gt;&gt;</vh></v>
<v t="T566"><vh>&lt;&lt; JUMP_IF_FALSE &gt;&gt;</vh></v>
<v t="T567"><vh>&lt;&lt; JUMP_IF_TRUE &gt;&gt;</vh></v>
<v t="T568"><vh>&lt;&lt; JUMP_ABSOLUTE &gt;&gt;</vh></v>
</v>
<v t="T569"><vh>&lt;&lt; FOR_LOOP &gt;&gt;</vh></v>
<v t="T570"><vh>&lt;&lt; POP_BLOCK &gt;&gt;</vh></v>
<v t="T571"><vh>&lt;&lt; RAISE_VARARGS &gt;&gt;</vh></v>
<v t="T572"><vh>&lt;&lt; SETUP_LOOP/EXCEPT/FINALLY &gt;&gt;</vh></v>
</v>
<v t="T434" a="C"><vh>&lt;&lt; flow of control cases &gt;&gt; psyco </vh>
<v t="T283" a="C"><vh>Iteration helpers... (psyco)</vh>
<v t="T284"><vh>PsycoObject_GetIter</vh></v>
<v t="T285"><vh>PsycoIter_Next</vh></v>
</v>
<v t="T435"><vh>&lt;&lt; break_loop &gt;&gt; psyco</vh></v>
<v t="T436"><vh>&lt;&lt; continue_loop &gt;&gt; psyco</vh></v>
<v t="T437"><vh>&lt;&lt; end_finally &gt;&gt; psyco</vh></v>
<v t="T438"><vh>&lt;&lt; iters &gt;&gt; psycho</vh>
<v t="T439"><vh>&lt;&lt; for_iter &gt;&gt;</vh></v>
<v t="T440"><vh>&lt;&lt; get_iter &gt;&gt;</vh></v>
<v t="T441"><vh>&lt;&lt; yeild_value &gt;&gt;</vh></v>
</v>
<v t="T442"><vh>&lt;&lt; jumps &gt;&gt; psyco</vh>
<v t="T443"><vh>&lt;&lt; jump_forward &gt;&gt;</vh></v>
<v t="T444"><vh>&lt;&lt; jump_if_true/false &gt;&gt;</vh></v>
<v t="T445"><vh>&lt;&lt; jump_absolute &gt;&gt;</vh></v>
</v>
<v t="T446"><vh>&lt;&lt; pop_block &gt;&gt; psyco</vh></v>
<v t="T447"><vh>&lt;&lt; setup_loop/except/finally &gt;&gt; psyco</vh></v>
</v>
</v>
<v><vh>function call/return opcodes</vh>
<v t="T250" a="C"><vh>PsycoObject_Call (psyco)</vh></v>
<v t="T541" a="C"><vh>&lt;&lt; function call/make/return cases &gt;&gt; c</vh>
<v t="T542"><vh>&lt;&lt; CALL_FUNCTION &gt;&gt;</vh></v>
<v t="T543"><vh>&lt;&lt; CALL_FUNCTION_VAR/KW/VAR_KW &gt;&gt;</vh></v>
<v t="T544"><vh>&lt;&lt; MAKE_FUNCTION &gt;&gt;</vh></v>
<v t="T545"><vh>&lt;&lt; MAKE_CLOSURE &gt;&gt;</vh></v>
<v t="T546"><vh>&lt;&lt; RETURN_VALUE &gt;&gt;</vh></v>
</v>
<v t="T448" a="C"><vh>&lt;&lt; function call/make/return &gt;&gt; psyco</vh>
<v t="T449"><vh>&lt;&lt; call_function &gt;&gt;</vh></v>
<v t="T450"><vh>&lt;&lt; extended_arg &gt;&gt;</vh></v>
<v t="T451"><vh>&lt;&lt; return_value &gt;&gt; psyco</vh></v>
</v>
</v>
<v><vh>import opcodes</vh>
<v t="T573" a="C"><vh>&lt;&lt; import cases &gt;&gt; c</vh>
<v t="T574"><vh>&lt;&lt; IMPORT_NAME &gt;&gt;</vh></v>
<v t="T575"><vh>&lt;&lt; IMPORT_STAR &gt;&gt;</vh></v>
<v t="T576"><vh>&lt;&lt; IMPORT_FROM &gt;&gt;</vh></v>
</v>
<v t="T452" a="C"><vh>&lt;&lt; import &gt;&gt; psyco</vh></v>
</v>
<v><vh>load/store/build/delete/unpack opcodes</vh>
<v><vh>c</vh>
<v t="T535" a="C"><vh>&lt;&lt; build cases &gt;&gt; c</vh>
<v t="T536"><vh>&lt;&lt; BUILD_CLASS &gt;&gt;</vh></v>
<v t="T537"><vh>&lt;&lt; BUILD_LIST &gt;&gt;</vh></v>
<v t="T538"><vh>&lt;&lt; BUILD_MAP &gt;&gt;</vh></v>
<v t="T539"><vh>&lt;&lt; BUILD_SLICE &gt;&gt;</vh></v>
<v t="T540"><vh>&lt;&lt; BUILD_TUPLE &gt;&gt;</vh></v>
</v>
<v t="T549" a="C"><vh>&lt;&lt; delete cases &gt;&gt; c</vh>
<v t="T550"><vh>&lt;&lt; DELETE_ATTR &gt;&gt;</vh></v>
<v t="T551"><vh>&lt;&lt; DELETE_FAST &gt;&gt;</vh></v>
<v t="T552"><vh>&lt;&lt; DELETE_GLOBAL &gt;&gt;</vh></v>
<v t="T553"><vh>&lt;&lt; DELETE_NAME &gt;&gt;</vh></v>
</v>
<v t="T577" a="C"><vh>&lt;&lt; load cases &gt;&gt; c</vh>
<v t="T578"><vh>&lt;&lt; LOAD_ATTR &gt;&gt;</vh></v>
<v t="T579"><vh>&lt;&lt; LOAD_CLOSURE &gt;&gt;</vh></v>
<v t="T580"><vh>&lt;&lt; LOAD_CONST &gt;&gt;</vh></v>
<v t="T581"><vh>&lt;&lt; LOAD_DEREF &gt;&gt;</vh></v>
<v t="T582"><vh>&lt;&lt; LOAD_LOCALS &gt;&gt;</vh></v>
<v t="T583"><vh>&lt;&lt; LOAD_FAST &gt;&gt;</vh></v>
<v t="T584"><vh>&lt;&lt; LOAD_GLOBAL &gt;&gt;</vh></v>
<v t="T585"><vh>&lt;&lt; LOAD_NAME &gt;&gt;</vh></v>
</v>
<v t="T602" a="C"><vh>&lt;&lt; store cases &gt;&gt; c</vh>
<v t="T603"><vh>&lt;&lt; STORE_DEREF &gt;&gt;</vh></v>
<v t="T604"><vh>&lt;&lt; STORE_FAST &gt;&gt;</vh></v>
<v t="T605"><vh>&lt;&lt; STORE_GLOBAL &gt;&gt;</vh></v>
<v t="T606"><vh>&lt;&lt; STORE_NAME &gt;&gt;</vh></v>
</v>
<v t="T616" a="C"><vh>&lt;&lt; UNPACK_SEQUENCE &gt;&gt;</vh></v>
</v>
<v t="T251" a="C"><vh>Getters... (psyco)</vh>
<v t="T252"><vh>psyco_generic_immut_ob_size</vh></v>
<v t="T253"><vh>psyco_generic_mut_ob_size</vh></v>
<v t="T254"><vh>PsycoObject_GetItem</vh></v>
<v t="T255"><vh>PsycoObject_Size</vh></v>
<v t="T256"><vh>PsycoSequence_GetItem</vh></v>
<v t="T257"><vh>PsycoSequence_GetSlice</vh></v>
</v>
<v t="T258" a="C"><vh>Setters... (psyco)</vh>
<v t="T259"><vh>PsycoObject_SetItem</vh></v>
<v t="T260"><vh>PsycoSequence_SetItem</vh></v>
<v t="T261"><vh>PsycoSequence_SetSlice</vh></v>
</v>
<v t="T453" a="C"><vh>&lt;&lt; load/store/build/delete &gt;&gt; psyco</vh>
<v t="T454"><vh>&lt;&lt; build_list &gt;&gt;</vh></v>
<v t="T455"><vh>&lt;&lt; build_map &gt;&gt;</vh></v>
<v t="T456"><vh>&lt;&lt; build_tuple &gt;&gt;</vh></v>
<v t="T457"><vh>&lt;&lt; delete_attr &gt;&gt;</vh></v>
<v t="T458"><vh>&lt;&lt; delete_fast &gt;&gt;</vh></v>
<v t="T459"><vh>&lt;&lt; delete_global &gt;&gt;</vh></v>
<v t="T460"><vh>&lt;&lt; load_attr &gt;&gt;</vh></v>
<v t="T461"><vh>&lt;&lt; load_const &gt;&gt;</vh></v>
<v t="T462"><vh>&lt;&lt; load_fast &gt;&gt;</vh></v>
<v t="T463"><vh>&lt;&lt; load_global &gt;&gt;</vh></v>
<v t="T464"><vh>&lt;&lt; store_attr &gt;&gt;</vh></v>
<v t="T465"><vh>&lt;&lt; store_fast &gt;&gt;</vh></v>
<v t="T466"><vh>&lt;&lt; store_global &gt;&gt;</vh></v>
</v>
<v t="T493" a="C"><vh>&lt;&lt; unpack_sequence &gt;&gt; psyco</vh></v>
</v>
<v><vh>misc opcodes</vh>
<v><vh>exec opcode (not implemented in psyco)</vh>
<v t="T554" a="C"><vh>&lt;&lt; EXTENDED_ARG &gt;&gt; c</vh></v>
<v t="T433" a="C"><vh>&lt;&lt; exec_stmt &gt;&gt; psyco</vh></v>
</v>
<v><vh>print opcodes</vh>
<v t="T586" a="C"><vh>&lt;&lt; print cases &gt;&gt; c</vh>
<v t="T587"><vh>&lt;&lt; PRINT_EXPR &gt;&gt;</vh></v>
<v t="T588"><vh>&lt;&lt; PRINT_ITEM_TO/PRINT_ITEM &gt;&gt;</vh></v>
<v t="T589"><vh>&lt;&lt; PRINT_NEWLINE_TO/PRINT_NEWLINE &gt;&gt;</vh></v>
</v>
<v t="T467" a="C"><vh>&lt;&lt; print &gt;&gt; psyco</vh>
<v t="T468"><vh>&lt;&lt; print_item &gt;&gt;</vh></v>
<v t="T469"><vh>&lt;&lt; print_item_to &gt;&gt;</vh></v>
<v t="T470"><vh>&lt;&lt; print_newline &gt;&gt;</vh></v>
<v t="T471"><vh>&lt;&lt; print_newline_to &gt;&gt;</vh></v>
</v>
</v>
<v><vh>set_lineno opcode</vh>
<v t="T590" a="C"><vh>&lt;&lt; SET_LINENO &gt;&gt; c</vh></v>
<v t="T472" a="C"><vh>&lt;&lt; set_lineno &gt;&gt; psyco</vh></v>
</v>
</v>
<v><vh>slice opcodes</vh>
<v t="T591" a="C"><vh>&lt;&lt; slice cases &gt;&gt; c</vh>
<v t="T592"><vh>&lt;&lt; SLICE cases &gt;&gt;</vh></v>
<v t="T593"><vh>&lt;&lt; STORE_SLICE cases &gt;&gt;</vh></v>
<v t="T594"><vh>&lt;&lt; DELETE_SLICE cases &gt;&gt;</vh></v>
</v>
<v t="T473" a="C"><vh>&lt;&lt; slice &gt;&gt; psyco</vh>
<v t="T474"><vh>&lt;&lt; slice cases  &gt;&gt; psyco</vh></v>
<v t="T475"><vh>&lt;&lt; store slice cases &gt;&gt; psyco</vh></v>
<v t="T476"><vh>&lt;&lt; delete slice cases &gt;&gt; psyco</vh></v>
</v>
</v>
<v><vh>stack opcodes</vh>
<v t="T595" a="C"><vh>&lt;&lt; stack cases &gt;&gt; c</vh>
<v t="T596"><vh>&lt;&lt; DUP_TOP &gt;&gt;</vh></v>
<v t="T597"><vh>&lt;&lt; DUP_TOPX &gt;&gt;</vh></v>
<v t="T598"><vh>&lt;&lt; POP_TOP &gt;&gt;</vh></v>
<v t="T599"><vh>&lt;&lt; ROT_TWO &gt;&gt;</vh></v>
<v t="T600"><vh>&lt;&lt; ROT_THREE &gt;&gt;</vh></v>
<v t="T601"><vh>&lt;&lt; ROT_FOUR &gt;&gt;</vh></v>
</v>
<v t="T477" a="C"><vh>&lt;&lt; stack opcodes &gt;&gt; psyco</vh>
<v t="T478"><vh>&lt;&lt; dup_top &gt;&gt;</vh></v>
<v t="T479"><vh>&lt;&lt; dup_topx &gt;&gt;</vh></v>
<v t="T480"><vh>&lt;&lt; pop_top &gt;&gt;</vh></v>
<v t="T481"><vh>&lt;&lt; rot_two &gt;&gt;</vh></v>
<v t="T482"><vh>&lt;&lt; rot_three &gt;&gt;</vh></v>
<v t="T483"><vh>&lt;&lt; rot_four &gt;&gt;</vh></v>
</v>
</v>
<v><vh>subscript opcodes</vh>
<v t="T607" a="C"><vh>&lt;&lt; subscript cases &gt;&gt; c</vh>
<v t="T608"><vh>&lt;&lt; STORE_SUBSCR &gt;&gt;</vh></v>
<v t="T609"><vh>&lt;&lt; DELETE_SUBSCR &gt;&gt;</vh></v>
</v>
<v t="T484" a="C"><vh>&lt;&lt; subscript &gt;&gt; psyco</vh>
<v t="T485"><vh>&lt;&lt; store_subscr &gt;&gt;</vh></v>
<v t="T486"><vh>&lt;&lt; delete_subscr &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="T1">@ Study the headers first!
@c

@ignore
@language python</t>
<t tx="T2">
&lt;&lt; about this file &gt;&gt;

import _psyco, sys, new, __builtin__
from types import FunctionType, MethodType

__all__ = ['error', 'jit', 'bind', 'proxy', 'dumpcodebuf']
error = _psyco.error

@others

# Psyco mode check
if hasattr(_psyco, 'ALL_CHECKS'):
    print &gt;&gt; sys.stderr, 'psyco: running in debugging mode'

# Reading this variable always return zero, but Psyco special-cases it by
# returning 1 instead. So __in_psyco__ can be used to know in a function if
# the function is being executed by Psyco or not.
__builtin__.__in_psyco__ = 0

sys_getframe = sys._getframe  # old value
sys._getframe = disabled_getframe
_erronce = 0

&lt;&lt; ending remarks &gt;&gt;</t>
<t tx="T3">###########################################################################
# 
#  Psyco top-level file of the Psyco package.
#   Copyright (C) 2001-2002  Armin Rigo et.al.
#
#  All source files of Psyco, including all Python sources in this package,
#   are protected by the GNU General Public License as found in COPYING.txt.

"""Psyco, the Python Specializing Compiler

Compile all global functions:
  import psyco; psyco.jit()

  This enables transparent just-in-time compilation of the most
  used functions of your programs. Just execute 'psyco.jit()' once.
  Note that this only works on global functions.

Compile all class methods:
  from psyco.classes import *

  For Python &gt;= 2.2, the above line to put at the beginning of each
  file defining classes instructs Psyco to compile all their methods.
  Alternatively, you can manually select the classes to optimize by
  having them inherit from 'psyco.classes.psyobj'.

Detailled choice of functions and classes to compile:
  psyco.bind(f)

  For larger programs, the above solutions are too heavy, as Psyco
  currently does not automatically identify the performance
  bottlenecks. You can trigger the compilation of only the most
  algorithmically intensive functions or classes with psyco.bind().
"""
###########################################################################</t>
<t tx="T4">def jit(tick=5):
    """Enable just-in-time compilation.
Argument is number of invocations before rebinding."""
    _psyco.selective(tick)
</t>
<t tx="T5">def bind(func, rec=_psyco.DEFAULT_RECURSION):
    """Enable compilation of the given function, method or class.
In the latter case all methods defined in the class are rebound.

The optional second argument specifies the number of recursive
compilation levels: all functions called by func are compiled
up to the given depth of indirection."""

    if isinstance(func, FunctionType):
        func.func_code = _psyco.proxycode(func, rec)
    elif isinstance(func, MethodType):
        bind(func.im_func, rec)
    elif hasattr(func, '__dict__'):  # for classes
        for object in func.__dict__.values():
            try:
                bind(object, rec)
            except error:
                pass
</t>
<t tx="T6">def proxy(func, rec=_psyco.DEFAULT_RECURSION):
    """Return a Psyco-enabled copy of the function.

The original function is still available for non-compiled calls.
The optional second argument specifies the number of recursive
compilation levels: all functions called by func are compiled
up to the given depth of indirection."""

    if isinstance(func, FunctionType):
        code = _psyco.proxycode(func, rec)
        return new.function(code, func.func_globals, func.func_name)
    if isinstance(func, MethodType):
        p = proxy(func.im_func, rec)
        return new.instancemethod(p, func.im_self, func.im_class)
    else:
        raise TypeError, 'function or method required'
</t>
<t tx="T7">def unbind(func):
    """Disable compilation of the given function, method or class.
Any future call to 'func' will use the regular Python interpreter."""

    if isinstance(func, FunctionType):
        try:
            f = _psyco.unproxycode(func.func_code)
        except error:
            pass
        else:
            func.func_code = f.func_code
    elif isinstance(func, MethodType):
        unbind(func.im_func)
    elif hasattr(func, '__dict__'):  # for classes
        for object in func.__dict__.values():
            unbind(object)
</t>
<t tx="T8">def unproxy(func):
    """Return a new copy of the original function of a proxy.
The result behaves like the original function in that calling it
does not trigger compilation nor execution of any compiled code."""

    if isinstance(func, FunctionType):
        return _psyco.unproxycode(func.func_code)
    if isinstance(func, MethodType):
        f = unproxy(func.im_func)
        return new.instancemethod(f, func.im_self, func.im_class)
    else:
        raise TypeError, 'function or method required'
</t>
<t tx="T9">def dumpcodebuf():
    """Write in file psyco.dump a copy of the emitted machine code,
provided Psyco was compiled with a non-zero CODE_DUMP.
See py-utils/httpxam.py to examine psyco.dump."""

    if hasattr(_psyco, 'dumpcodebuf'):
        _psyco.dumpcodebuf()
</t>
<t tx="T10"># Support for Python's warnings is not complete, because it
# uses sys._getframe() which will give strange results on a mixed Psyco-
# and Python-style stack frame.
# We work around this by having sys._getframe() always raise ValueError.
# The warning subsystem will then apply the filters globally instead of
# on a per-module basis.

def disabled_getframe(n=0):
    global _erronce
    if not _erronce:
        # cannot use Warnings, I guess it would cause an endless loop
        print &gt;&gt; sys.stderr, 'psyco: sys._getframe() not supported; support for warnings is only partial'
        _erronce = 1
    raise ValueError, 'sys._getframe() disabled for Psyco'
</t>
<t tx="T11">###########################################################################
# The code produced by Psyco is not nice with threads; it does not
# include all the checks the Python interpreter does regularly.

###########################################################################
# Python-based rebinding code, now moved in selective.c. This code
# should probably be partially moved back here, leaving only the detection
# of the most used functions to C code, not the rebinding.

#  import sys

#  ticks = 0
#  depth = 10
#  funcs = {}

#  def f(frame, event, arg):
#      if event != 'call':  return
#      print type(frame.f_globals)
#      c = frame.f_code.co_code
#      fn = frame.f_code.co_name
#      g = frame.f_globals
#      if not funcs.has_key(c):
#          funcs[c] = 1
#      if funcs[c] != None:
#          funcs[c] = funcs[c] + 1
#          if funcs[c] &gt; ticks and g.has_key(fn):
#              g[fn] = _psyco.proxy(g[fn], depth)
#              funcs[c] = None
#              print 'psyco rebinding function:', fn

#  sys.setprofile(f)</t>
<t tx="T12">&lt;&lt; about this file &gt;&gt;

import psyco
__all__ = ['psyobj', 'psymetaclass', '__metaclass__']


# Python version check
try:
    object
except NameError:
    class psyobj:        # compatilibity
        pass
    psymetaclass = None
else:
    # version &gt;= 2.2 only
    from types import FunctionType
    recursivity = 5
    
    class psymetaclass(type):
        "Psyco-optimized meta-class. Turns all methods into Psyco proxies."
    
        def __init__(self, name, bases, dict):
            type.__init__(self, name, bases, dict)
            bindlist = self.__dict__.get('__psyco__bind__')
            if bindlist is None:
                psyco.bind(self)
            else:
                for attr in bindlist:
                    psyco.bind(self.__dict__.get(attr))
    
    psyobj = psymetaclass("psyobj", (), {})
__metaclass__ = psymetaclass</t>
<t tx="T13">
###########################################################################
# 
#  Psyco class support module.
#   Copyright (C) 2001-2002  Armin Rigo et.al.
#
#  All source files of Psyco, including all Python sources in this package,
#   are protected by the GNU General Public License as found in COPYING.txt.

"""Psyco class support module.

'psyco.classes.psyobj' is an alternate Psyco-optimized root for classes.
Any class inheriting from it or using the metaclass '__metaclass__' might
get optimized specifically for Psyco. It is equivalent to call
psyco.bind() on the class object after its creation.

Note that this module has no effect with Python version 2.1 or earlier.

Importing everything from psyco.classes in a module will import the
'__metaclass__' name, so all classes defined after a

       from psyco.classes import *

will automatically use the Psyco-optimized metaclass.
"""
###########################################################################</t>
<t tx="T14">@language c</t>
<t tx="T15">/***************************************************************/
/***         Support to manage the emitted code chunks       ***/
/***************************************************************/

#ifndef _CODEMANAGER_H
#define _CODEMANAGER_H

#include "psyco.h"
#include "dispatcher.h"

/* define to store the end of the code in CodeBufferObjects */
/*#undef STORE_CODE_END*/

#ifdef CODE_DUMP_FILE
# define STORE_CODE_END   /* always needed by CODE_DUMP_FILE */
#endif

/* a CodeBufferObject is a pointer to emitted code.
   The 'state' PsycoObject records the state of the compiler at
   the start of the emission of code. Consider this field as private.
   Future versions of the code manager will probably encode the recorded
   states in a more sophisticated form than just a dump copy.
   (There are usually a lot of small CodeBufferObjects, so if each
   one has a full copy of the state big projects will explode the memory.)
*/
struct CodeBufferObject_s {
	PyObject_HEAD
	code_t* codeptr;
	FrozenPsycoObject snapshot;
	#ifdef STORE_CODE_END
		code_t* codeend;
		char* codemode;
		#ifdef CODE_DUMP_FILE
			CodeBufferObject* chained_list;
		#endif
	#endif
};

#ifdef CODE_DUMP_FILE
	EXTERNVAR CodeBufferObject* psyco_codebuf_chained_list;
#endif


#define CodeBuffer_Check(v)	((v)-&gt;ob_type == &amp;CodeBuffer_Type)
EXTERNVAR PyTypeObject CodeBuffer_Type;

/* starts a new code buffer, whose size is initially BIG_BUFFER_SIZE.
   'po' is the state of the compiler at this point, of which a
   frozen copy will be made. It can be NULL. If not, set 'ge' as in
   psyco_compile(). */
EXTERNFN
CodeBufferObject* psyco_new_code_buffer(PsycoObject* po, global_entries_t* ge);

/* creates a CodeBufferObject pointing to an already existing code target */
EXTERNFN
CodeBufferObject* psyco_proxy_code_buffer(PsycoObject* po, global_entries_t* ge);

/* shrink a buffer returned by new_code_buffer() */
EXTERNFN
void psyco_shrink_code_buffer(CodeBufferObject* obj, int nsize);

#ifdef STORE_CODE_END
#define SHRINK_CODE_BUFFER(obj, nsize, mode)    do {    \
      psyco_shrink_code_buffer(obj, nsize);             \
      (obj)-&gt;codemode = (mode);                         \
} while (0)
#else
# define SHRINK_CODE_BUFFER(obj, nsize, mode)     \
      psyco_shrink_code_buffer(obj, nsize)
#endif

/* a replacement for Py_XDECREF(obj) which does not release the object
   immediately, but only at the next call to psyco_trash_object() */
EXTERNFN
void psyco_trash_object(PyObject* obj);

#endif /* _CODEMANAGER_H */</t>
<t tx="T16">/***************************************************************/
/***          Structures used by the dispatcher part         ***/
/***************************************************************/

#ifndef _DISPATCHER_H
#define _DISPATCHER_H

#include "psyco.h"
#include "vcompiler.h"
#include "processor.h"

EXTERNFN void psyco_dispatcher_init();
&lt;&lt; frozen PsycoObject &gt;&gt;
&lt;&lt; psyco_compatible &gt;&gt;
&lt;&lt; global entries &gt;&gt;
&lt;&lt; unification &gt;&gt;
&lt;&lt; promotion &gt;&gt;
&lt;&lt; respawning &gt;&gt;
#endif /* _DISPATCHER_H */</t>
<t tx="T17">@ a frozen PsycoObject is a snapshot of an actual PsycoObject, capturing the
state of the compiler in a form that can be used later to compare live states
to it. Currently implemented as a copy of the PsycoObject vlocals and
stack_depth.

XXX should be optimized very differently the FrozenPsycoObject's
secondary goal is to capture enough information to rebuild a "live"
PsycoObject, close enough to the original to let the next few Python
instructions produce exactly the same machine code as the original. See
psyco_prepare_respawn(). Be careful, there are a lot of such snapshots around
in memory; keep them as small as possible.

@c
struct FrozenPsycoObject_s {
  union {
    int as_int;   /* last_used_reg in bits 0-7 and stack_depth in the rest */
    struct respawn_s* respawning;
  } fz_stuff;
  vinfo_array_t fz_vlocals;
  short fz_arguments_count;
  short fz_respawned_cnt;
  CodeBufferObject* fz_respawned_from;
  pyc_data_t* fz_pyc_data;  /* only partially allocated */
};

/* construction */
inline void fpo_mark_new(FrozenPsycoObject* fpo) {
	fpo-&gt;fz_respawned_from = NULL;
}
inline void fpo_mark_unused(FrozenPsycoObject* fpo) {
	fpo-&gt;fz_vlocals.count = 0;
	fpo-&gt;fz_pyc_data = NULL;
}
EXTERNFN void fpo_build(FrozenPsycoObject* fpo, PsycoObject* po);
EXTERNFN void fpo_release(FrozenPsycoObject* fpo);

/* build a 'live' PsycoObject from frozen snapshot */
EXTERNFN PsycoObject* fpo_unfreeze(FrozenPsycoObject* fpo);

/* inspection */
inline int get_stack_depth(FrozenPsycoObject* fpo) {
	return fpo-&gt;fz_stuff.as_int &gt;&gt; 8;
}</t>
<t tx="T18">@ psyco_compatible()

search in the given global_entries_t for a match to the living PsycoObject.
Return the best match in *matching. The result is either COMPATIBLE,
INCOMPATIBLE (no match), or an actual vinfo_t* of 'po' which is a compile-time
value that should be un-promoted to run-time.
   
If the result is COMPATIBLE, this call leaves the dispatcher in a unstable
state; it must be fixed by calling one of the psyco_unify() functions below, or
by psyco_stabilize().
@c

#define COMPATIBLE    NULL
#define INCOMPATIBLE  ((vinfo_t*) 1)

EXTERNFN vinfo_t* psyco_compatible(PsycoObject* po, global_entries_t* pattern,
				   CodeBufferObject** matching);

EXTERNFN void psyco_stabilize(CodeBufferObject* lastmatch);</t>
<t tx="T19">@ global entry points for the compiler.

One global entry point holds a list of already-compiled code buffers
corresponding to the various states in which the compiler has already be seen
at this point. See psyco_compatible().

The dispatcher saves all CodeBufferObjects (with their copy of the compiler
state) in a list for each 'entry point' of the compiler (the main entry point
is spec_main_loop, the start of the main loop). When coming back to this entry
point later, the list let us determine whether we already encountered the same
state.
   
The details of this structure are private.
XXX implemented as a list object holding CodeBufferObjects in no
XXX particular order. MUST be optimized for reasonably fast searches.
@c

struct global_entries_s {
	PyObject* fatlist;      /* list of CodeBufferObjects */
};

EXTERNVAR global_entries_t global_entries;   /* the single global entry point */

/* register the code buffer; it will be found by future calls to
   psyco_compatible(). */
inline int register_codebuf(global_entries_t* ge, CodeBufferObject* codebuf) {
	return PyList_Append(ge-&gt;fatlist, (PyObject*) codebuf);
}</t>
<t tx="T20">@

Update 'po' to match 'target', then jump to 'target'.

For the conversion we might have to emit some code. If this-&gt;code == NULL or
there is not enough room between code and this-&gt;codelimit, a new code buffer is
created and returned in 'target'; otherwise, Py_INCREF(*target). If this-&gt;code
!= NULL, the return value points at the end of the code that has been written
there; otherwise, the return value is undefined (but not NULL).
   
Note: this function only works right after a successful call to compare_array.
It needs the data left in the 'tmp' fields. It releases 'po'.
@c

EXTERNFN code_t* psyco_unify(PsycoObject* po, CodeBufferObject** target);

/* Simplified interface to psyco_unify() without using a previously
   existing code buffer (i.e. 'po-&gt;code' is uninitialized). If needed,
   return a new buffer with the necessary code followed by a JMP to
   'target'. If no code is needed, just return a new reference to 'target'.
*/
EXTERNFN CodeBufferObject* psyco_unify_code(PsycoObject* po,
                                            CodeBufferObject* target);</t>
<t tx="T21">@ Promotion of a run-time variable into a fixed compile-time one.

Finish the code block with a jump to the dispatcher that promotes the run-time
variable 'fix' to compile-time. This usually means the compiler will be called
back again, at the given entry point. Note: Releases 'po'.
@c
EXTERNFN code_t* psyco_finish_promotion(PsycoObject* po, vinfo_t* fix,
                                        long kflags);

/* Promotion of certain run-time values into compile-time ones
   (promotion only occurs for values inside a given set, e.g. for
   types that we know how to optimize). The special values are
   described in an array of long, turned into a source_known_t
   (see processor.h).
   Note: Releases 'po'.
*/
EXTERNFN code_t* psyco_finish_fixed_switch(PsycoObject* po, vinfo_t* fix,
                                           long kflags,
                                           fixed_switch_t* special_values);

/* Un-Promotion from non-fixed compile-time into run-time.
   Note: this does not release 'po'. Un-promoting is easy and
   don't require encoding calls to the dispatcher.
*/
EXTERNFN void psyco_unfix(PsycoObject* po, vinfo_t* vi);</t>
<t tx="T22">/* internal use */
EXTERNFN void psyco_prepare_respawn(PsycoObject* po,condition_code_t jmpcondition);

EXTERNFN void psyco_respawn_detected(PsycoObject* po);

inline bool detect_respawn(PsycoObject* po) {
	if (!++po-&gt;respawn_cnt) {
		psyco_respawn_detected(po);
		return true;
	}
	else
		return false;
}

inline bool is_respawning(PsycoObject* po) { return po-&gt;respawn_cnt &lt; 0; }
	
/* the following powerful function stands for 'if the processor flag (cond) is
   set at run-time, then...'. Of course we do not know yet if this will be
   the case or not, but the macro takes care of preparing the required
   respawns if needed. 'cond' may be CC_ALWAYS_xxx or a real processor flag.
   runtime_condition_f() assumes the outcome is generally false,
   runtime_condition_t() assumes the outcome is generally true. */

inline bool runtime_condition_f(PsycoObject* po, condition_code_t cond) {
	if (cond == CC_ALWAYS_FALSE) return false;
	if (cond == CC_ALWAYS_TRUE) return true;
	if (detect_respawn(po)) return true;
	psyco_prepare_respawn(po, cond);
	return false;
}

inline bool runtime_condition_t(PsycoObject* po, condition_code_t cond) {
	if (cond == CC_ALWAYS_TRUE) return true;
	if (cond == CC_ALWAYS_FALSE) return false;
	if (detect_respawn(po)) return false;
	psyco_prepare_respawn(po, INVERT_CC(cond));
	return true;
}</t>
<t tx="T23">/***************************************************************/
/***       Processor-specific code-producing macros           ***/
/***************************************************************/

#ifndef _ENCODING_H
#define _ENCODING_H

#include "psyco.h"

 /* Define to 1 to always write the most compact encoding of instructions.
    (a quite minor overhead). Set to 0 to disable. No effect on real
    optimizations. */
#define COMPACT_ENCODING   1

/* Define to 1 to use EBP as the stack frame base.
   Define to 0 to always refer to variables via ESP. */
#define EBP_IS_RESERVED    0

#if EBP_IS_RESERVED
# error "not usable right now; code misses prolog and epilog to set/restore EBP"
#endif

&lt;&lt; declare registers &gt;&gt;
&lt;&lt; declare conditions &gt;&gt;
&lt;&lt; special constants &gt;&gt;
&lt;&lt; production of code &gt;&gt;

#endif /* _ENCODING_H */</t>
<t tx="T24">
typedef enum {
        REG_EAX    = 0,
        REG_ECX    = 1,
        REG_EDX    = 2,
        REG_EBX    = 3,
        REG_ESP    = 4,
        REG_EBP    = 5,
        REG_ESI    = 6,
        REG_EDI    = 7,
#define REG_TOTAL    8
        
        REG_NONE   = -1} reg_t;

#define REG_FUNCTIONS_RETURN       REG_EAX
#define REG_ANY_CALLER_SAVED       REG_EAX  /* just any "trash" register */</t>
<t tx="T25">typedef enum {
        CC_O         = 0,    /* overflow */
        CC_NO        = 1,
        CC_B         = 2,    /* below (unsigned) */
        CC_NB        = 3,
        CC_E         = 4,    /* equal */
        CC_NE        = 5,
        CC_BE        = 6,    /* below or equal (unsigned) */
        CC_NBE       = 7,
        CC_S         = 8,    /* sign (i.e. negative) */
        CC_NS        = 9,
        CC_L         = 12,   /* lower than */
        CC_NL        = 13,
        CC_LE        = 14,   /* lower or equal */
        CC_NLE       = 15,
#define CC_TOTAL       16
/* synonyms */
        CC_NGE       = CC_L,   /* not greater or equal */
        CC_GE        = CC_NL,  /* greater or equal */
        CC_NG        = CC_LE,  /* not greater than */
        CC_G         = CC_NLE, /* greater than */
        CC_uL        = CC_B,     /* unsigned test */
        CC_uNL       = CC_NB,    /* unsigned test */
        CC_uLE       = CC_BE,    /* unsigned test */
        CC_uNLE      = CC_NBE,   /* unsigned test */
        CC_uNGE      = CC_uL,    /* unsigned test */
        CC_uGE       = CC_uNL,   /* unsigned test */
        CC_uNG       = CC_uLE,   /* unsigned test */
        CC_uG        = CC_uNLE,  /* unsigned test */
        CC_ALWAYS_FALSE  = 16,   /* pseudo condition codes for known outcomes */
        CC_ALWAYS_TRUE   = 17,
        CC_ERROR         = -1 } condition_code_t;

#define INVERT_CC(cc)    ((condition_code_t)((int)(cc) ^ 1))</t>
<t tx="T26">/* the registers we want Psyco to use in compiled code,
   as a circular linked list (see processor.c) */
EXTERNVAR reg_t RegistersLoop[REG_TOTAL];

/* the first register in RegistersLoop that Psyco will use.
   The best choice is probably the first callee-saved register */
#define REG_LOOP_START      REG_EBX

#define INITIAL_STACK_DEPTH  4 /* anything &gt;0 and a multiple of 4 */

/* like offsetof() but checks that the offset is a multiple of 4 */
#define OffsetOf(struct, field)                         \
    (extra_assert((offsetof(struct, field) &amp; 3) == 0),  \
     offsetof(struct, field))

#define QUARTER(n)   (extra_assert(((n)&amp;3)==0), (n)/4)</t>
<t tx="T27">/*****************************************************************/
 /***   Production of code (common instruction encodings)       ***/


@others
</t>
<t tx="T28">
/* Most of the following macros implicitely use and update the
 * local variable 'code'. Some also use 'po'. No macro outside the
 * present header file must implicitely use or modify 'code'.
 *
 * Convenience macros to start/end a code-emitting instruction block:
 */
#define BEGIN_CODE         { code_t* code = po-&gt;code;
#define UPDATE_CODE          po-&gt;code = code;
#define END_CODE             po-&gt;code = code; }

/* Written as a large set of macro. */

#define RSOURCE_REG(src)         (CHKTIME(src, RunTime), getreg(src))
#define RSOURCE_REG_IS_NONE(src) (CHKTIME(src, RunTime), is_reg_none(src))
#define RSOURCE_STACK(src)       (CHKTIME(src, RunTime), getstack(src))

#define RUNTIME_STACK_MAX        RunTime_StackMax
#define RUNTIME_STACK_NONE       RunTime_StackNone
#define RUNTIME_REG(vi)	         RSOURCE_REG         ((vi)-&gt;source)
#define RUNTIME_REG_IS_NONE(vi)	 RSOURCE_REG_IS_NONE ((vi)-&gt;source)
#define RUNTIME_STACK(vi)        RSOURCE_STACK       ((vi)-&gt;source)

#define SET_RUNTIME_REG_TO(vi, rg)      ((vi)-&gt;source =                         \
                                         set_rtreg_to((vi)-&gt;source, rg))
#define SET_RUNTIME_REG_TO_NONE(vi)     ((vi)-&gt;source =                         \
                                         set_rtreg_to_none((vi)-&gt;source))
#define SET_RUNTIME_STACK_TO(vi, s)     ((vi)-&gt;source =                         \
                                         set_rtstack_to((vi)-&gt;source, (s)))
#define SET_RUNTIME_STACK_TO_NONE(vi)   ((vi)-&gt;source =                         \
                                         set_rtstack_to_none((vi)-&gt;source))

#define KSOURCE_SOURCE(src)     (CHKTIME(src, CompileTime), CompileTime_Get(src))
#define KNOWN_SOURCE(vi)        KSOURCE_SOURCE((vi)-&gt;source)

#define NEXT_FREE_REG()         next_free_reg(po)
#define REG_NUMBER(po, rg)      ((po)-&gt;reg_array[(int)(rg)])


/*****************************************************************/</t>
<t tx="T29">#define CODE_FOUR_BYTES(code, b1, b2, b3, b4)   /* for constant bytes */        \
  (*(long*)(code) = ((unsigned char)(b1)) | (((unsigned char)(b2))&lt;&lt;8) |        \
                   (((unsigned char)(b3))&lt;&lt;16) | (((unsigned char)(b4))&lt;&lt;24))

</t>
<t tx="T30">/* note: the following macro starts writing at code+1 */
#if EBP_IS_RESERVED
	/* access stack by [EBP-n] where 'n' is fixed for the variable */
	#define MODRM_EBP_BASE(middle, stack_pos)       do {                    \
	  extra_assert(0 &lt; (stack_pos) &amp;&amp; (stack_pos) &lt;= RUNTIME_STACK_MAX);    \
	  if (COMPACT_ENCODING &amp;&amp; (stack_pos) &lt;= 128)                           \
		{                                                                   \
		  code[1] = 0x45 | (middle);                                        \
		  code[2] = -(stack_pos);                                           \
		  code += 3;                                                        \
		}                                                                   \
	  else                                                                  \
		{                                                                   \
		  code[1] = 0x85 | (middle);                                        \
		  *(long*)(code+2) = -(stack_pos);                                  \
		  code += 6;                                                        \
		}                                                                   \
	} while (0)
#else
	/* access stack by [ESP+n] where 'n' varies depending on the current ESP */
	#define MODRM_EBP_BASE(middle, stack_pos)       do {                    \
	  int _s_p = po-&gt;stack_depth - (stack_pos);                             \
	  extra_assert(0 &lt; (stack_pos) &amp;&amp; (stack_pos) &lt;= RUNTIME_STACK_MAX);    \
	  extra_assert(0 &lt;= _s_p);                                              \
	  code[2] = 0x24;                                                       \
	  if (COMPACT_ENCODING &amp;&amp; _s_p == 0)                                    \
		{                                                                   \
		  code[1] = 0x04 | (middle);                                        \
		  code += 3;                                                        \
		}                                                                   \
	  else if (COMPACT_ENCODING &amp;&amp; _s_p &lt; 128)                              \
		{                                                                   \
		  code[1] = 0x44 | (middle);                                        \
		  code[3] = _s_p;                                                   \
		  code += 4;                                                        \
		}                                                                   \
	  else                                                                  \
		{                                                                   \
		  code[1] = 0x84 | (middle);                                        \
		  *(long*)(code+3) = _s_p;                                          \
		  code += 7;                                                        \
		}                                                                   \
	} while (0)
#endif</t>
<t tx="T31">/* Emit instruction 'opcode' having a mod/rm as its second byte.
   Insert 'middle' in the mod/rm. Let the mod/rm point to the given stack_pos. */
   
#define INSTR_EBP_BASE(opcode, middle, stack_pos)   do {        \
  code[0] = (opcode);                                           \
  MODRM_EBP_BASE(middle, stack_pos);                            \
} while (0)

</t>
<t tx="T32">/* note: the following macro starts writing at code+1 */

#define MODRM_FROM_RT(source, middle)   do {            \
  if (RSOURCE_REG_IS_NONE(source))                      \
    MODRM_EBP_BASE(middle, RSOURCE_STACK(source));      \
  else {  /* register source */                         \
    code[1] = 0xC0 | (middle) | RSOURCE_REG(source);    \
    code += 2;                                          \
  }                                                     \
} while (0)</t>
<t tx="T33">/* Same as INSTR_EBP_BASE but reading from the 'source' of a run-time vinfo_t */

#define INSTR_MODRM_FROM_RT(source, opcode, middle)	do {    \
  code[0] = (opcode);                                           \
  MODRM_FROM_RT(source, middle);                                \
} while (0)
</t>
<t tx="T34">/* The "common instructions" groups: there are 8 arithmetic instructions
   whose encodings are identical. Here they are, with their 'group' value:
     ADD    (group 0)
     OR     (group 1)
     ADC    (group 2)
     SBB    (group 3)
     AND    (group 4)
     SUB    (group 5)
     XOR    (group 6)
     CMP    (group 7)  */</t>
<t tx="T35">/* The following macro encodes  "INSTR register, immediate"  */
#define COMMON_INSTR_IMMED(group, rg, value) do {       \
  long _v;                                              \
  code[1] = 0xC0 | (group&lt;&lt;3) | (rg);                   \
  _v = value;                                           \
  if (COMPACT_ENCODING &amp;&amp; -128 &lt;= _v &amp;&amp; _v &lt; 128) {     \
    code[2] = _v;                                       \
    code[0] = 0x83;                                     \
    code += 3;                                          \
  }                                                     \
  else {                                                \
    *(long*)(code+2) = _v;                              \
    code[0] = 0x81;                                     \
    code += 6;                                          \
  }                                                     \
} while (0)</t>
<t tx="T36">/* Encodes  "INSTR register, source"  for a run-time or compile-time vinfo_t */
#define COMMON_INSTR_FROM(group, rg, source)   do {                     \
  if (((source) &amp; TimeMask) == RunTime)                                 \
    COMMON_INSTR_FROM_RT(group, rg, source);                            \
  else                                                                  \
    COMMON_INSTR_IMMED(group, rg, KSOURCE_SOURCE(source)-&gt;value);       \
} while(0)</t>
<t tx="T37">/* Encodes  "INSTR register, source"  for a run-time vinfo_t */
#define COMMON_INSTR_FROM_RT(group, rg, source)    do { \
  code[0] = group*8 + 3;                                \
  MODRM_FROM_RT(source, (rg)&lt;&lt;3);                       \
} while(0)
</t>
<t tx="T38">/* Encodes "INSTR reg" for the following instructions:
     NOT    (group 2)
     NEG    (group 3)  */
	
#define UNARY_INSTR_ON_REG(group, rg)              do { \
  code[0] = 0xF7;                                       \
  code[1] = 0xC0 | (group&lt;&lt;3) | (rg);                   \
  code += 2;                                            \
} while (0)</t>
<t tx="T39">/* Encodes "INC rg" and "DEC rg" */
#define INCREASE_REG(rg)   (*code++ = 0x40 | (rg))
#define DECREASE_REG(rg)   (*code++ = 0x48 | (rg))</t>
<t tx="T40">/* Encodes taking absolute value of the register 'rg' knowing that
   'sourcecopy' is a (run-time) copy of 'rg' */
 
#define INT_ABS(rg, sourcecopy)       do {                                      \
  /* as you can check the following takes the absolute value of (say) EAX:      \
       ADD EAX, EAX                                                             \
       SBB EAX, sourcecopy                                                      \
       SBB EDX, EDX                                                             \
       XOR EAX, EDX                                                             \
    (note: although the idea is not original, the above code might be           \
     original as it has been found by an exhaustive search on *all*             \
     short codes :-)                                                            \
  */                                                                            \
  reg_t _rg2;                                                                   \
  code[0] = 0x01;                                                               \
  code[1] = 0xC0 | ((rg)&lt;&lt;3) | (rg);   /* ADD rg, rg */                         \
  code += 2;                                                                    \
  COMMON_INSTR_FROM_RT(3, rg, sourcecopy);  /* SBB rg, sourcecopy */            \
  DELAY_USE_OF(rg);                                                             \
  NEED_FREE_REG(_rg2);                                                          \
  code[0] = 0x19;                                                               \
  code[1] = 0xC0 | (_rg2&lt;&lt;3) | _rg2;  /* SBB _rg2, _rg2 */                      \
  code[2] = 0x31;                                                               \
  code[3] = 0xC0 | (_rg2&lt;&lt;3) | (rg);  /* XOR rg, _rg2 */                        \
  code += 4;                                                                    \
} while (0)</t>
<t tx="T41">#define CHECK_ABS_OVERFLOW   CC_S

/* Encodes a check (zero/non-zero) on the given 'source' */
#define CHECK_ZERO_CONDITION      CC_E
#define CHECK_NONZERO_CONDITION   INVERT_CC(CHECK_ZERO_CONDITION)
#define CHECK_NONZERO_FROM_RT(source)             do {                          \
  NEED_CC();                                                                    \
  if (RSOURCE_REG_IS_NONE(source))                                              \
    {                                                                           \
      INSTR_MODRM_FROM_RT(source, 0x83, 7&lt;&lt;3);  /* CMP (source), imm8 */        \
      *code++ = 0;                                                              \
    }                                                                           \
  else                                                                          \
    CHECK_NONZERO_REG(RSOURCE_REG(source));                                     \
} while (0)
#define CHECK_NONZERO_REG(rg)    (              \
  code[0] = 0x85,      /* TEST reg, reg */      \
  code[1] = 0xC0 | ((rg)*9),                    \
  code += 2)
</t>
<t tx="T42">#define COMPARE_IMMED_FROM_RT(source, immed)   do {                             \
  long _value = (immed);                                                        \
  if (COMPACT_ENCODING &amp;&amp; -128 &lt;= _value &amp;&amp; _value &lt; 128)                       \
    /*if (_value == 0 &amp;&amp; !RSOURCE_REG_IS_NONE(source))                          \
      CHECK_NONZERO_REG(RSOURCE_REG(source));                                   \
    else*/ {                                                                    \
      INSTR_MODRM_FROM_RT(source, 0x83, 7&lt;&lt;3);  /* CMP (source), imm8 */        \
      *code++ = _value;                                                         \
    }                                                                           \
  else {                                                                        \
    INSTR_MODRM_FROM_RT(source, 0x81, 7&lt;&lt;3);    /* CMP (source), imm32 */       \
    *(long*)code = _value;                                                      \
    code += 4;                                                                  \
  }                                                                             \
} while (0)
</t>
<t tx="T43">/* PUSH the value described in the 'source' of a run-time vinfo_t */
#define PUSH_FROM_RT(source)   do {                     \
  if (RSOURCE_REG_IS_NONE(source))                      \
    PUSH_EBP_BASE(RSOURCE_STACK(source));               \
  else                                                  \
    PUSH_REG(RSOURCE_REG(source));                      \
} while (0)

/* insert a PUSH_FROM_RT at point 'insert_at' in the given 'code1' */
/* EXTERNFN code_t* insert_push_from_rt(PsycoObject* po, code_t* code1, */
/*                                      long source, code_t* insert_at); */

/* PUSH a run-time or compile-time vinfo_t's value */
#define PUSH_FROM(source)   do {                \
  if (((source) &amp; TimeMask) == RunTime)       \
    PUSH_FROM_RT(source);                       \
  else                                          \
    PUSH_IMMED(KSOURCE_SOURCE(source)-&gt;value);  \
} while (0)
</t>
<t tx="T44">/*****************************************************************/
/***   Some basic management instructions...                   ***/

/* these two macros do not actually emit the code.
   They just give you the one-byte instruction encoding. */
#define PUSH_REG_INSTR(reg)       (0x50 | (reg))
#define POP_REG_INSTR(reg)        (0x58 | (reg))

#define PUSH_REG(reg)       (*code++ = PUSH_REG_INSTR(reg))
#define POP_REG(reg)        (*code++ = POP_REG_INSTR(reg))

#define PUSH_CC_FLAGS_INSTR     0x9C   /* PUSHF */
#define POP_CC_FLAGS_INSTR      0x9D   /* POPF */

#define PUSH_CC_FLAGS()       (*code++ = PUSH_CC_FLAGS_INSTR)
#define POP_CC_FLAGS()        (*code++ = POP_CC_FLAGS_INSTR)

#define LOAD_REG_FROM_REG(dst, src)  (                  \
  code[0] = 0x89,		/* MOV dst, src */      \
  code[1] = 0xC0 | ((src) &lt;&lt; 3) | (dst),                \
  code += 2                                             \
)

#define XCHG_REGS(rg1, rg2)   do {                      \
  if (COMPACT_ENCODING &amp;&amp; ((rg1) == REG_EAX))           \
    *code++ = 0x90 | (rg2);                             \
  else if (COMPACT_ENCODING &amp;&amp; ((rg2) == REG_EAX))      \
    *code++ = 0x90 | (rg1);                             \
  else {                                                \
    code[0] = 0x87;                                     \
    code[1] = 0xC0 | ((rg2)&lt;&lt;3) | (rg1);                \
    code += 2;                                          \
  }                                                     \
} while (0)

#define LOAD_REG_FROM_IMMED(dst, immed) (               \
  code[0] = 0xB8 | (dst),       /* MOV dst, immed */    \
  *(long*)(code+1) = (immed),                           \
  code += 5                                             \
)

/* loads 0 in a register. The macro name reminds you that this
   clobbers po-&gt;ccreg (use NEED_CC() to save it first). */
/* #define CLEAR_REG_CLOBBER_CC(rg) (                      \ */
/*   code[0] = 0x33,                  * XOR rg, rg *       \ */
/*   code[1] = 0xC0 | ((rg)&lt;&lt;3) | (rg),                    \ */
/*   code += 2                                             \ */
/* ) */

#define LOAD_REG_FROM_EBP_BASE(dst, stack_pos)		\
  INSTR_EBP_BASE(0x8B, (dst)&lt;&lt;3, stack_pos)	/* MOV dst, [EBP-stack_pos] */

#define SAVE_REG_TO_EBP_BASE(src, stack_pos)		\
  INSTR_EBP_BASE(0x89, (src)&lt;&lt;3, stack_pos)	/* MOV [EBP-stack_pos], src */

#define XCHG_REG_AND_EBP_BASE(src, stack_pos)		\
  INSTR_EBP_BASE(0x87, (src)&lt;&lt;3, stack_pos)	/* XCHG src, [EBP-stack_pos] */

#define LOAD_REG_FROM_RT(source, dst)			\
  INSTR_MODRM_FROM_RT(source, 0x8B, (dst)&lt;&lt;3)   /* MOV dst, (...) */

#define SAVE_REG_TO_RT(source, src)			\
  INSTR_MODRM_FROM_RT(source, 0x89, (src)&lt;&lt;3)   /* MOV (...), src */

#define PUSH_EBP_BASE(ofs)				\
  INSTR_EBP_BASE(0xFF, 0x30, ofs)		/* PUSH [EBP-ofs] */

#define POP_EBP_BASE(ofs)				\
  INSTR_EBP_BASE(0x8F, 0x00, ofs)		/* POP [EBP-ofs] */

#define PUSH_IMMED(immed)     do {                              \
  if (COMPACT_ENCODING &amp;&amp; -128 &lt;= (immed) &amp;&amp; (immed) &lt; 128) {   \
    code[0] = 0x6A;    /* PUSH imm8 */                          \
    code[1] = (immed);                                          \
    code += 2;                                                  \
  }                                                             \
  else {                                                        \
    code[0] = 0x68;      /* PUSH imm32 */                       \
    *(long*)(code+1) = (immed);                                 \
    code += 5;                                                  \
  }                                                             \
} while (0)
</t>
<t tx="T45">/* call a function written in C. Use the macros CALL_SET_ARG_xxx() for
   each argument in reverse order, then use CALL_C_FUNCTION(). */
/* Note: the update of po-&gt;stack_depth saves one "ADD ESP, 4*nb_args"
   at the end of the call. If the stack is to be kept as compact as
   possible we might as well write the instruction. We have to
   update po-&gt;stack_depth at each CALL_SET_ARG_xxx (instead of just
   in CALL_C_FUNCTION) because run-time arguments after the first one
   would be fetched at the wrong place otherwise. */
   
#define CALL_SET_ARG_IMMED(immed, arg_index, nb_args)     do {  \
  PUSH_IMMED(immed);                                            \
  po-&gt;stack_depth += 4;                                         \
} while (0)

#define CALL_SET_ARG_FROM_RT(source, arg_index, nb_args)  do {  \
  PUSH_FROM_RT(source);                                         \
  po-&gt;stack_depth += 4;                                         \
} while (0)

#define CALL_SET_ARG_FROM(source, arg_index, nb_args)     do {  \
  PUSH_FROM(source);                                            \
  po-&gt;stack_depth += 4;                                         \
} while (0)

#define CALL_C_FUNCTION(target, nb_args)   do { \
  code[0] = 0xE8;    /* CALL */                 \
  code += 5;                                    \
  *(long*)(code-4) = (code_t*)(target) - code;  \
} while (0)

#define CALL_C_FUNCTION_FROM_RT(source, nb_args)                \
  INSTR_MODRM_FROM_RT(source, 0xFF, 2&lt;&lt;3)    /* CALL [source] */
#define CALL_C_FUNCTION_FROM(source, nb_args)   do {            \
  if (((source) &amp; CompileTime) != 0)                            \
    CALL_C_FUNCTION(KSOURCE_SOURCE(source)-&gt;value, nb_args);    \
  else                                                          \
    CALL_C_FUNCTION_FROM_RT(source, nb_args);                   \
} while (0)

/* optimization of a CALL followed by a JMP */
#define CALL_C_FUNCTION_AND_JUMP(target, nb_args, jmptarget) do {       \
  PUSH_IMMED((long)(jmptarget));                                        \
  JUMP_TO((code_t*)(target));                                           \
} while (0)

/* C functions that want to return several values can do so by
   taking an array of longs as arguments. Use the following
   macro to reserve space in the stack. In the register 'rg' will
   be copied the address of the reserved space.
   Use psyco_alloc_space_array() to allocate the reserved space
   to an array of vinfo_t's.  */
  
#define RESERVE_STACK_SPACE(cnt, rg)     do {   \
  STACK_CORRECTION(4*(cnt));                    \
  po-&gt;stack_depth += 4*(cnt);                   \
  LOAD_REG_FROM_REG(rg, REG_ESP);               \
} while (0)

/* load the 'dst' register with the run-time address of 'source'
   which must be in the stack */
#define LOAD_ADDRESS_FROM_RT(source, dst)    do {                               \
  extra_assert(RSOURCE_STACK(source) != RUNTIME_STACK_NONE);                    \
  INSTR_MODRM_FROM_RT(source, 0x8D, ((dst)&lt;&lt;3));  /* LEA dst, [source] */       \
} while (0)

#define LOAD_REG_FROM_REG_PLUS_REG(dst, rg1, rg2)   do {        \
  code[0] = 0x8D;                                               \
  code[1] = 0x04 | ((dst)&lt;&lt;3);  /* LEA dst, [rg1+rg2] */        \
  code[2] = ((rg1)&lt;&lt;3) | (rg2);                                 \
  if (!EBP_IS_RESERVED &amp;&amp; (rg2) == REG_EBP)                     \
    {                                                           \
      if ((rg1) != REG_EBP)                                     \
        code[2] = ((rg2)&lt;&lt;3) | (rg1);                           \
      else                                                      \
        {                                                       \
          code[1] |= 0x40;                                      \
          code[3] = 0;                                          \
          code++;                                               \
        }                                                       \
    }                                                           \
  code += 3;                                                    \
} while (0)


/* saving and restoring the registers currently in use (see also
   SAVE_REGS_FN_CALLS) */
#define TEMP_SAVE_REGS_FN_CALLS       do {                      \
  if (COMPACT_ENCODING) {                                       \
    if (REG_NUMBER(po, REG_EAX) != NULL) PUSH_REG(REG_EAX);     \
    if (REG_NUMBER(po, REG_ECX) != NULL) PUSH_REG(REG_ECX);     \
    if (REG_NUMBER(po, REG_EDX) != NULL) PUSH_REG(REG_EDX);     \
    if (po-&gt;ccreg != NULL)               PUSH_CC_FLAGS();       \
  }                                                             \
  else {                                                        \
    CODE_FOUR_BYTES(code,                                       \
                    PUSH_REG_INSTR(REG_EAX),                    \
                    PUSH_REG_INSTR(REG_ECX),                    \
                    PUSH_REG_INSTR(REG_EDX),                    \
                    PUSH_CC_FLAGS_INSTR);                       \
    code += 4;                                                  \
  }                                                             \
} while (0)

#define TEMP_RESTORE_REGS_FN_CALLS    do {                      \
  if (COMPACT_ENCODING) {                                       \
    if (po-&gt;ccreg != NULL)               POP_CC_FLAGS();        \
    if (REG_NUMBER(po, REG_EDX) != NULL) POP_REG(REG_EDX);      \
    if (REG_NUMBER(po, REG_ECX) != NULL) POP_REG(REG_ECX);      \
    if (REG_NUMBER(po, REG_EAX) != NULL) POP_REG(REG_EAX);      \
  }                                                             \
  else {                                                        \
    CODE_FOUR_BYTES(code,                                       \
                    POP_CC_FLAGS_INSTR,                         \
                    POP_REG_INSTR(REG_EDX),                     \
                    POP_REG_INSTR(REG_ECX),                     \
                    POP_REG_INSTR(REG_EAX));                    \
    code += 4;                                                  \
  }                                                             \
} while (0)

/* same as above, but concludes with a JMP *EAX */
#define TEMP_RESTORE_REGS_FN_CALLS_AND_JUMP   do {              \
  if (COMPACT_ENCODING) {                                       \
    if (po-&gt;ccreg != NULL)               POP_CC_FLAGS();        \
    if (REG_NUMBER(po, REG_EDX) != NULL) POP_REG(REG_EDX);      \
    if (REG_NUMBER(po, REG_ECX) != NULL) POP_REG(REG_ECX);      \
  }                                                             \
  else {                                                        \
    CODE_FOUR_BYTES(code,                                       \
                    POP_CC_FLAGS_INSTR,                         \
                    POP_REG_INSTR(REG_EDX),                     \
                    POP_REG_INSTR(REG_ECX),                     \
                    0   /* dummy */);                           \
    code += 3;                                                  \
  }                                                             \
  if (!COMPACT_ENCODING || REG_NUMBER(po, REG_EAX) != NULL) {   \
    /* must restore EAX, but it contains the jump target... */  \
    CODE_FOUR_BYTES(code,                                       \
                    0x87,                                       \
                    0x04,                                       \
                    0x24,           /* XCHG EAX, [ESP] */       \
                    0xC3);          /* RET             */       \
    code += 4;                                                  \
  }                                                             \
  else {                                                        \
    code[0] = 0xFF;                                             \
    code[1] = 0xE0;     /* JMP *EAX */                          \
    code += 2;                                                  \
  }                                                             \
} while (0)

</t>
<t tx="T46">/* put an immediate value in memory */
#define SET_REG_ADDR_TO_IMMED(rg, immed)    do {        \
  code[0] = 0xC7;               /* MOV [reg], immed */  \
  if (EBP_IS_RESERVED || (rg) != REG_EBP)               \
    {                                                   \
      extra_assert((rg) != REG_EBP);                    \
      code[1] = (rg);                                   \
    }                                                   \
  else                                                  \
    {                                                   \
      *++code = 0x45;                                   \
      code[1] = 0;                                      \
    }                                                   \
  *(long*)(code+2) = (immed);                           \
  code += 6;                                            \
} while (0)

/* put an immediate value in memory */
#define SET_IMMED_ADDR_TO_IMMED(addr, immed)    do {    \
  code[0] = 0xC7;               /* MOV [addr], immed */ \
  code[1] = 0x05;                                       \
  *(long*)(code+2) = (addr);                            \
  *(long*)(code+6) = (immed);                           \
  code += 10;                                           \
} while (0)
</t>
<t tx="T47">/*****************************************************************/
/***   vinfo_t saving                                          ***/

/* save 'vi', which is currently in register 'rg'. */
#define SAVE_REG_VINFO(vi, rg)	do {            \
  PUSH_REG(rg);                                 \
  po-&gt;stack_depth += 4;                         \
  SET_RUNTIME_STACK_TO(vi, po-&gt;stack_depth);    \
} while (0)

/* * save 'vi' if needed. * */
/* #define SAVE_VINFO(vi)		do {                        */
/*   if (((vi)-&gt;source &amp; (TIME_MASK | RUNTIME_STACK_MASK)) ==       */
/*                       (RUN_TIME  | RUNTIME_STACK_NONE))          */
/*     SAVE_REG_VINFO(vi, RUNTIME_REG(vi), 0);                      */
/* } while (0) */

/* ensure that the register 'rg' is free */
#define NEED_REGISTER(rg)    do {                       \
  vinfo_t* _content = REG_NUMBER(po, (rg));             \
  if (_content != NULL) {                               \
    if (RUNTIME_STACK(_content) == RUNTIME_STACK_NONE)  \
      SAVE_REG_VINFO(_content, rg);                     \
    SET_RUNTIME_REG_TO_NONE(_content);                  \
    REG_NUMBER(po, (rg)) = NULL;                        \
  }                                                     \
} while (0)

/* ensure that the condition code flags of the processor no
   longer contain any useful information */

#define NEED_CC()       do {                    \
  if (po-&gt;ccreg != NULL)                        \
    code = psyco_compute_cc(po, code);          \
} while (0)
/*internal, see processor.c*/
EXTERNFN code_t* psyco_compute_cc(PsycoObject* po, code_t* code);

#define LOAD_REG_FROM_CONDITION(rg, cc)   do {  /* 'rg' is an 8-bit reg */      \
  code[0] = 0x0F;               /* SETcond rg8 */                               \
  code[1] = 0x90 | (cc);                                                        \
  code[2] = 0xC0 | (rg);   /* actually an 8-bit register, but the first four    \
                              32-bit registers have the same number as their    \
                              respective lower-8-bit parts */                   \
  code[3] = 0x0F;                                                               \
  code[4] = 0xB6;               /* MOVZX rg32, rg8 */                           \
  code[5] = 0xC0 | ((rg)*9);                                                    \
  code += 6;                                                                    \
} while (0)

/* save all registers that might be clobbered by a call to a C function */
#define SAVE_REGS_FN_CALLS   do {               \
  NEED_CC();                                    \
  NEED_REGISTER(REG_EAX);                       \
  NEED_REGISTER(REG_ECX);                       \
  NEED_REGISTER(REG_EDX);                       \
} while (0)

/* like NEED_REGISTER but 'targ' is an output argument which will
   receive the number of a now-free register */
#define NEED_FREE_REG(targ)    do {             \
  targ = po-&gt;last_used_reg;                     \
  if (REG_NUMBER(po, targ) != NULL) {           \
    targ = NEXT_FREE_REG();                     \
    NEED_REGISTER(targ);                        \
  }                                             \
} while (0)

#define NEED_FREE_BYTE_REG(rg)   do {                                           \
  /* test some registers only --                                                \
     cannot access the other registers as a single byte */                      \
  if (REG_NUMBER(po, REG_EDX) == NULL)       rg = REG_EDX;  /* a.k.a REG_DL */  \
  else if (REG_NUMBER(po, REG_ECX) == NULL)  rg = REG_ECX;  /* a.k.a REG_CL */  \
  else if (REG_NUMBER(po, REG_EAX) == NULL)  rg = REG_EAX;  /* a.k.a REG_AL */  \
  else {                                                                        \
    NEED_REGISTER(REG_EBX);                                                     \
    rg = REG_EBX;  /* a.k.a REG_BL */                                           \
  }                                                                             \
} while (0)

/* make sure that the register 'reg' will not
   be returned by the next call to NEED_FREE_REG() */
#define DELAY_USE_OF(reg)       do {                    \
  if (RegistersLoop[(int) po-&gt;last_used_reg] == (reg))  \
    po-&gt;last_used_reg = (reg);                          \
  if (po-&gt;last_used_reg == (reg))                       \
    NEXT_FREE_REG();                                    \
} while (0)

/* the same for two registers */
#define DELAY_USE_OF_2(rg1, rg2)   do {         \
  DELAY_USE_OF(rg1);                            \
  DELAY_USE_OF(rg2);                            \
  DELAY_USE_OF(rg1);                            \
} while (0)
</t>
<t tx="T48">/*****************************************************************/
/***   vinfo_t restoring                                       ***/

/* reload a vinfo from the stack */
#define STACK_VINFO_IN_REG(vi)	do {            \
  reg_t _rg;                                    \
  long _stack;                                  \
  NEED_FREE_REG(_rg);                           \
  REG_NUMBER(po, _rg) = (vi);                   \
  _stack = RUNTIME_STACK(vi);                   \
  SET_RUNTIME_REG_TO(vi, _rg);                  \
  LOAD_REG_FROM_EBP_BASE(_rg, _stack);          \
} while (0)

/* ensure that a run-time vinfo is in a register */
#define RTVINFO_IN_REG(vi)	  do {          \
  if (RUNTIME_REG_IS_NONE(vi))                  \
    STACK_VINFO_IN_REG(vi);                     \
} while (0)

/* load register 'dst' from the given non-virtual source vinfo */
#define LOAD_REG_FROM(source, dst)    do {                      \
  if (((source) &amp; CompileTime) != 0)                            \
    LOAD_REG_FROM_IMMED(dst, KSOURCE_SOURCE(source)-&gt;value);    \
  else {                                                        \
    if (RSOURCE_REG(source) != dst)                             \
      LOAD_REG_FROM_RT(source, dst);                            \
  }                                                             \
} while (0)
</t>
<t tx="T49"> /*****************************************************************/
 /***   conditional jumps                                       ***/

#define JUMP_TO(addr)   do {                    \
  code[0] = 0xE9;   /* JMP rel32 */             \
  code += 5;                                    \
  *(long*)(code-4) = (addr) - code;             \
} while (0)

#define IS_A_JUMP(code, targetaddr)                             \
  (code[0]==(char)0xE9 ? (targetaddr=code+5+*(long*)(code+1), 1) : 0)

#define IS_A_SINGLE_JUMP(code, codeend, targetaddr)             \
  ((codeend)-(code) == 5 &amp;&amp; IS_A_JUMP(code, targetaddr))

#define FAR_COND_JUMP_TO(addr, condition)   do {        \
  code[0] = 0x0F;    /* Jcond rel32 */                  \
  code[1] = 0x80 | (char)(condition);                   \
  code += 6;                                            \
  *(long*)(code-4) = (addr) - code;                     \
} while (0)

#define SIZE_OF_SHORT_CONDITIONAL_JUMP     2    /* Jcond rel8 */
#define RANGE_OF_SHORT_CONDITIONAL_JUMP  127    /* max. positive offset */

#define SHORT_COND_JUMP_TO(addr, condition)  do {       \
  long _ofs = (addr) - code;                            \
  extra_assert(-128 &lt;= _ofs &amp;&amp; _ofs &lt; 128);             \
  code[0] = 0x70 | (char)(condition);                   \
  code[1] = _ofs;                                       \
  code += 2;                                            \
} while (0)

/* CMOV instruction: this instruction does not exist on the i486,
   should we avoid it? Or should be test for Pentium-ness at start-up?
   We currently avoid it. */
/* #define CONDITIONAL_LOAD_REG_FROM_RT(source, dst, condition)  do {      \ */
/*   *code++ = 0x0F;        * CMOVxx dst, (...) *                          \ */
/*   INSTR_MODRM_FROM_RT(source, 0x40 | (condition), (dst)&lt;&lt;3);            \ */
/* } while (0) */

/* correct the stack pointer */
#define STACK_CORRECTION(stack_correction)   do {                       \
  if ((stack_correction) != 0) {                                        \
    NEED_CC();                                                          \
    if (COMPACT_ENCODING &amp;&amp;                                             \
        -128 &lt;= (stack_correction) &amp;&amp; (stack_correction) &lt; 128) {       \
      code[0] = 0x83;   /* SUB			*/                      \
      code[1] = 0xEC;   /*     ESP, imm8	*/                      \
      code[2] = (stack_correction);                                     \
      code += 3;                                                        \
    }                                                                   \
    else {                                                              \
      code[0] = 0x81;   /* SUB			*/                      \
      code[1] = 0xEC;   /*     ESP, imm32	*/                      \
      *(long*)(code+2) = (stack_correction);                            \
      code += 6;                                                        \
    }                                                                   \
  }                                                                     \
} while (0)

</t>
<t tx="T50">/* convenience macros */
#define COPY_IN_REG(vi, rg)   do {                      \
   if ((((vi)-&gt;source &amp; TimeMask) == RunTime) &amp;&amp;        \
       RUNTIME_STACK(vi) == RUNTIME_STACK_NONE) {       \
     char _rg2;                                         \
     rg = RUNTIME_REG(vi);                              \
     NEED_FREE_REG(_rg2);                               \
     LOAD_REG_FROM_REG(_rg2, rg);                       \
     SET_RUNTIME_REG_TO(vi, _rg2);                      \
     REG_NUMBER(po, _rg2) = vi;                         \
     REG_NUMBER(po, rg) = NULL;                         \
   }                                                    \
   else {                                               \
     NEED_FREE_REG(rg);                                 \
     LOAD_REG_FROM(vi-&gt;source, rg);                     \
   }                                                    \
} while (0)</t>
<t tx="T51">#include &lt;Python.h&gt;

#undef PyCore_MALLOC
#undef PyCore_REALLOC
#undef PyCore_FREE

EXTERNFN void* memchk_ef_malloc(int size);
EXTERNFN void memchk_ef_free(void* data);
EXTERNFN void* memchk_ef_realloc(void* data, int nsize);

#define PyCore_MALLOC   memchk_ef_malloc
#define PyCore_REALLOC  memchk_ef_realloc
#define PyCore_FREE     memchk_ef_free
</t>
<t tx="T52">/***************************************************************/
/***                Tables of code merge points              ***/
/***************************************************************/

#ifndef _MERGEPOINTS_H
#define _MERGEPOINTS_H

#include "psyco.h"
#include &lt;compile.h&gt;

#define CHECK_ARRAY_BIT(s, n)   ((s)[(n)/8] &amp;  (1&lt;&lt;((n)&amp;7)))
#define SET_ARRAY_BIT(s, n)     ((s)[(n)/8] |= (1&lt;&lt;((n)&amp;7)))

/* A merge point is a point reached by two or more control paths in
   the bytecode. They are a subset of the targets found by the standard
   module function dis.findlabels(). It may be a subset because some
   targets can only be reached by jumping from a single point, e.g. 'else:'.
   
   The following function detects the merge points and set them in a bit array.
*/
EXTERNFN char* psyco_get_merge_points(PyCodeObject* co);

#endif /* _MERGEPOINTS_H */
</t>
<t tx="T53">/***************************************************************/
/***             Processor-specific definitions              ***/
/***************************************************************/

#ifndef _PROCESSOR_H
#define _PROCESSOR_H

#include "vcompiler.h"

EXTERNFN void psyco_processor_init();

&lt;&lt; utilities &gt;&gt;
&lt;&lt; read and write fields of structures in memory &gt;&gt;
&lt;&lt; calling C functions &gt;&gt;
&lt;&lt; emit common instructions &gt;&gt;
&lt;&lt; code termination &gt;&gt;
&lt;&lt; run-time switches &gt;&gt;

#endif /* _PROCESSOR_H */</t>
<t tx="T54"> /***************************************************************/
 /*** Utilities                                               ***/

/* executes a block of code. A new stack frame is created and
   the 'initial_stack' values are PUSHed into it. The number
   of values pushed are determined by the saved arguments_count of
   the 'codebuf'.
*/
EXTERNFN PyObject* psyco_processor_run(CodeBufferObject* codebuf,
                                       long initial_stack[]);

/* return a new vinfo_t* meaning `in the processor flags, true if &lt;cc&gt;',
   as an integer 0 or 1. The source of the vinfo_t* is compile-time
   if cc is CC_ALWAYS_TRUE/FALSE, and virtual-time otherwise. (In the latter
   case it gets stored in po-&gt;ccreg.) */
EXTERNFN vinfo_t* psyco_vinfo_condition(PsycoObject* po, condition_code_t cc);

/* if 'source' comes from psyco_vinfo_condition(), return its &lt;cc&gt;;
   otherwise return CC_ALWAYS_FALSE. */
EXTERNFN condition_code_t psyco_vsource_cc(Source source);

/* returns the next register that should be used */
inline reg_t next_free_reg(PsycoObject* po) {
	return (po-&gt;last_used_reg = RegistersLoop[(int)(po-&gt;last_used_reg)]);
}

/* call a C function with a variable number of arguments
   (implemented as a pointer to assembler code) */
EXTERNVAR long (*psyco_call_var) (void* c_func, int argcount, long arguments[]);</t>
<t tx="T55"> /*****************************************************************/
 /***   read and write fields of structures in memory           ***/


/* only called by the inlined functions defined below; do not use directly. */
EXTERNFN vinfo_t* psyco_get_array_item(PsycoObject* po, vinfo_t* vi, int index);
EXTERNFN vinfo_t* psyco_read_array_item(PsycoObject* po, vinfo_t* vi, int index);
EXTERNFN vinfo_t* psyco_read_array_item_var(PsycoObject* po, vinfo_t* v0,
                                            vinfo_t* v1, int ofsbase, int shift);
EXTERNFN bool psyco_write_array_item(PsycoObject* po, vinfo_t* src,
                                     vinfo_t* v, int index);
EXTERNFN bool psyco_write_array_item_var(PsycoObject* po, vinfo_t* src,
                                         vinfo_t* v0, vinfo_t* v1, int ofsbase);


/* Use read/write_array_item to emit the code that performs the read or
   write to a structure. Use get/set_array_item if the vinfo_array_t*
   can be considered as a cache over the in-memory structure. In other
   words, get_array_item will not reload a value if it has already been
   loaded once, and set_array_item never actually writes any value at
   all (it stays in the vinfo_array_t* cache).
*/

inline vinfo_t* get_array_item(PsycoObject* po, vinfo_t* vi, int index) {
	/* does not return a new reference */
	vinfo_t* result = vinfo_getitem(vi, index);
	if (result == NULL)
		result = psyco_get_array_item(po, vi, index);
	return result;
}

inline vinfo_t* read_array_item(PsycoObject* po, vinfo_t* vi, int index) {
	/* returns a new reference */
	vinfo_t* result;
	if (is_virtualtime(vi-&gt;source) &amp;&amp;
	    (result = vinfo_getitem(vi, index)) != NULL)
		vinfo_incref(result);   /* done, bypass compute() */
	else
		result = psyco_read_array_item(po, vi, index);
	return result;
}

inline vinfo_t* read_array_item_var(PsycoObject* po, vinfo_t* vi, int baseindex,
				    vinfo_t* varindex, bool byte) {
	/* returns a new reference */
	return psyco_read_array_item_var(po, vi, varindex,
					 baseindex*sizeof(long), byte ? 0 : 2);
}

#if 0
	--- Disabled: not safe, could make the PsycoObject grow unboundedly
	inline vinfo_t* get_array_item_var(PsycoObject* po, vinfo_t* vi, int baseindex,
									   vinfo_t* varindex, bool byte) {
		/* returns a new reference */
		if (is_compiletime(varindex-&gt;source)) {
			vinfo_t* r = get_array_item(po, vi,
				CompileTime_Get(varindex-&gt;source)-&gt;value + baseindex);
			if (r != NULL)
				vinfo_incref(r);
			return r;
		}
		else
			return read_array_item_var(po, vi, baseindex, varindex, byte);
	}
#endif

inline vinfo_t* read_immut_array_item_var(PsycoObject* po, vinfo_t* vi,
                                          int baseindex, vinfo_t* varindex,
                                          bool byte) {
	/* returns a new reference */
	if (is_compiletime(varindex-&gt;source)) {
		vinfo_t* r = vinfo_getitem(vi,
		    CompileTime_Get(varindex-&gt;source)-&gt;value + baseindex);
		if (r != NULL) {
			vinfo_incref(r);
			return r;
		}
	}
	return read_array_item_var(po, vi, baseindex, varindex, byte);
}

inline void set_array_item(PsycoObject* po, vinfo_t* vi,
			   int index, vinfo_t* newitem) {
	/* CONSUMES a reference on 'newitem' */
	vinfo_t* item = vinfo_needitem(vi, index);
	vinfo_xdecref(item, po);
	vi-&gt;array-&gt;items[index] = newitem;
}

inline bool write_array_item(PsycoObject* po, vinfo_t* vi,
			     int index, vinfo_t* newitem) {
	/* does not consume any reference */
	return psyco_write_array_item(po, newitem, vi, index);
}

inline bool write_array_item_var(PsycoObject* po, vinfo_t* vi, int baseindex,
                                 vinfo_t* varindex, vinfo_t* newitem) {
	/* does not consume any reference */
	return psyco_write_array_item_var(po, newitem, vi, varindex,
                                          baseindex*sizeof(long));
}


#if 0
	/* XXX to do: references from the code buffers. This is tricky because
	   we can have quite indirect references, or references to a subobject of
	   a Python object, or to a field only of a Python object, etc... */
	inline long reference_from_code(PsycoObject* po, CompileTimeSource source)
	{
		--- DISABLED ---
		source_known_t* sk = CompileTime_Get(source);
		if ((sk-&gt;refcount1_flags &amp; SkFlagPyObj) != 0) {
			/* XXX we get a reference from the code.
			   Implement freeing such references
			   together with code buffers. */
			sk_incref(sk);
		}
		return sk-&gt;value;
	}
#endif</t>
<t tx="T56"> /*****************************************************************/
 /***   Calling C functions                                     ***/

/* A generic way of emitting the call to a C function.
   For maximal performance you can also directly use the macros
   CALL_C_FUNCTION()&amp;co. in encoding.h.

   'arguments' is a string describing the following arguments
   of psyco_generic_call(). Each argument to the C function to call
   comes from a 'vinfo_t*' structure, excepted when it is known to be
   compile-time, in which case a 'long' or 'PyObject*' can be passed
   instead. In 'arguments' the characters are interpreted as follows:

      l      an immediate 'long' or 'PyObject*' value
      v      a 'vinfo_t*' value
      r      a run-time 'vinfo_t*' value passed as a reference
      a      a 'vinfo_array_t*' used by the C function as output buffer
      A      same as 'a', but the C function creates new references

   'r' means that the C function wants to get a reference to a
   single-word value (typically it is an output argument). The
   run-time value is pushed in the stack if it is just in a
   register. Incompatible with CfPure.

   'a' means that the C function gets a pointer to a buffer capable of
   containing as many words as specified by the array count.
   psyco_generic_call() fills the array with run-time vinfo_ts
   representing the output values. Incompatible with CfPure.
*/
EXTERNFN vinfo_t* psyco_generic_call(PsycoObject* po, void* c_function,
                                     int flags, const char* arguments, ...);

/* if the C function has no side effect it can be called at compile-time
   if all its arguments are compile-time. Use CfPure in this case. */
#define CfPure           0x10

/* if the C function returns a long or a PyObject* but not a new reference */
#define CfReturnNormal   0x00   /* default */

/* if the C function returns a new reference */
#define CfReturnRef      0x01

/* if the C function returns a flag (true/false). In this case,
   typecast the return value of psyco_generic_call() to condition_code_t.
   psyco_flag_call() does it for you. */
#define CfReturnFlag     0x02
#define psyco_flag_call  (condition_code_t) psyco_generic_call

/* if the C function does not return anything (incompatible with CfPure)
   or if you are not interested in getting the result in a vinfo_t.
   psyco_generic_call() returns anything non-NULL (unless there is an error)
   in this case. */
#define CfNoReturnValue  0x03

#define CfReturnMask     0x0F
/* See also the Python-specific flags CfPyErrXxx defined in pycheader.h. */


/* a faster variant for the commonly-used(?) form of psyco_generic_call()
   with no argument and CfNoReturnValue */
inline void psyco_call_void(PsycoObject* po, void* c_function) {
	BEGIN_CODE
	SAVE_REGS_FN_CALLS;
	CALL_C_FUNCTION(c_function,  0);
	END_CODE
}

/* To emit the call to other code blocks emitted by Psyco. 'argsources' gives
   the run-time sources for the arguments, as specified by
   psyco_build_frame(). */
EXTERNFN vinfo_t* psyco_call_psyco(PsycoObject* po, CodeBufferObject* codebuf,
                                   Source argsources[]);</t>
<t tx="T57"> /*****************************************************************/
 /***   Emit common instructions                                ***/

EXTERNFN condition_code_t integer_non_null(PsycoObject* po, vinfo_t* vi);

/* Instructions with an 'ovf' parameter will check for overflow
   if 'ovf' is true. They return NULL if an overflow is detected. */
EXTERNFN
vinfo_t* integer_add  (PsycoObject* po, vinfo_t* v1, vinfo_t* v2, bool ovf);
EXTERNFN
vinfo_t* integer_add_i(PsycoObject* po, vinfo_t* v1, long value2);
EXTERNFN
vinfo_t* integer_sub  (PsycoObject* po, vinfo_t* v1, vinfo_t* v2, bool ovf);
EXTERNFN
vinfo_t* integer_sub_i(PsycoObject* po, vinfo_t* v1, long value2);
EXTERNFN
vinfo_t* integer_or   (PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN
vinfo_t* integer_and  (PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN
vinfo_t* integer_not  (PsycoObject* po, vinfo_t* v1);
EXTERNFN
vinfo_t* integer_neg  (PsycoObject* po, vinfo_t* v1, bool ovf);
EXTERNFN
vinfo_t* integer_abs  (PsycoObject* po, vinfo_t* v1, bool ovf);

/* Comparison: 'py_op' is one of Python's rich comparison numbers
   Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE
   optionally together with COMPARE_UNSIGNED */
EXTERNFN condition_code_t integer_cmp  (
	PsycoObject* po, vinfo_t* v1, vinfo_t* v2, int py_op);
EXTERNFN condition_code_t integer_cmp_i(
	PsycoObject* po, vinfo_t* v1, long value2, int py_op);

#define COMPARE_UNSIGNED  8

/* For sequence indices: 'vn' is the length of the sequence, 'vi' an
   index. Check that vi is in range(0,vn). Increase 'vi' by 'vn' if
   needed to put it in the correct range. */
#if 0
						  (not used)
	EXTERNFN vinfo_t* integer_seqindex(PsycoObject* po, vinfo_t* vi,
					   vinfo_t* vn, bool ovf);
#endif

/* make a run-time copy of a vinfo_t */
EXTERNFN vinfo_t* make_runtime_copy(PsycoObject* po, vinfo_t* v);</t>
<t tx="T58"> /*****************************************************************/
 /***   code termination                                        ***/

/* write a return, clearing the stack as necessary, and releases 'po'. */
EXTERNFN code_t*
psyco_finish_return(PsycoObject* po, NonVirtualSource retval);

/* write codes that calls the C function 'fn' and jumps to its
   return value. Save registers before calling psyco_finish_call_proxy().
   Set 'restore' to 1 if you used TEMP_SAVE_REGS_FN_CALLS,
   or 0 if you used SAVE_REGS_FN_CALLS.
   The arguments passed to 'fn' will be a pointer to a constant structure
   at the end of the code, plus any others previously specified by calls
   to CALL_SET_ARG_xxx(). Set 'nb_args' to one plus your own arguments.
   The constant structure is at the end of the code, and
   psyco_finish_call_proxy() returns a pointer to it. */
EXTERNFN void*
psyco_jump_proxy(PsycoObject* po, void* fn, int restore, int nb_args);

#if 0   /* disabled */
	/* emergency code for out-of-memory conditions in which do not
	   have a code buffer available for psyco_finish_err_xxx().
	   A temporary buffer of the size EMERGENCY_PROXY_SIZE is enough. */
	#define EMERGENCY_PROXY_SIZE    11
	code_t* psyco_emergency_jump(PsycoObject* po, code_t* code);
#endif</t>
<t tx="T59"> /*****************************************************************/
 /***   run-time switches                                       ***/

typedef struct c_promotion_s {
  source_virtual_t header;
  struct fixed_switch_s* fs;
  long kflags;
} c_promotion_t;

typedef struct fixed_switch_s {  /* private structure */
  int switchcodesize;   /* size of 'switchcode' */
  code_t* switchcode;
  int count;
  struct fxcase_s* fxc;
  long* fixtargets;
  long zero;            /* for 'array' pointers from vinfo_t structures */
  struct c_promotion_s fixed_promotion; /* pseudo-exception meaning 'fix me' */
} fixed_switch_t;

/* initialization of a fixed_switch_t structure */
EXTERNFN int
psyco_build_run_time_switch(
	fixed_switch_t* rts, long kflags,
    long values[], int count);

/* Look for a (known) value in a prepared switch.
   Return -1 if not found. */
EXTERNFN int psyco_switch_lookup(fixed_switch_t* rts, long value);

/* Write the code that does a 'switch' on the prepared 'values'.
   The register 'reg' contains the value to switch on. All jump targets
   are initially at the end of the written code; see
   psyco_fix_switch_target(). */
EXTERNFN code_t* psyco_write_run_time_switch(
	fixed_switch_t* rts,code_t* code, char reg);

/* Fix the target corresponding to the given case ('item' is a value
   returned by psyco_switch_lookup()). 'code' is the *end* of the
   switch code, as returned by psyco_write_run_time_switch(). */
EXTERNFN void psyco_fix_switch_case(fixed_switch_t* rts, code_t* code,
                                    int item, code_t* newtarget);

/* The pseudo-exceptions meaning 'promote me' but against no particular
   fixed_switch_t. The second one has the SkFlagPyObj flag. */
EXTERNVAR c_promotion_t psyco_nonfixed_promotion;
EXTERNVAR c_promotion_t psyco_nonfixed_pyobj_promotion;

/* Check if the given virtual source is a promotion exception */
EXTERNFN bool psyco_vsource_is_promotion(VirtualTimeSource source);

/* is the given run-time vinfo_t known to be none of the values listed in rts? */
inline bool known_to_be_default(vinfo_t* vi, fixed_switch_t* rts) {
	return vi-&gt;array == NullArrayAt(rts-&gt;zero);
}</t>
<t tx="T60">/***************************************************************/
/***                 Global Psyco definitions                ***/
/***************************************************************/

#ifndef _PSYCO_H
#define _PSYCO_H

#include &lt;Python.h&gt;
#include &lt;structmember.h&gt;   /* for offsetof() */
#include &lt;compile.h&gt;        /* for PyCodeObject */

&lt;&lt; compile-time constants &amp; settings &gt;&gt;
&lt;&lt; buffer settings &gt;&gt;
&lt;&lt; memory checks &gt;&gt;
&lt;&lt; storage allocation synonyms &gt;&gt;
&lt;&lt; inlining &amp; more memory stuff &gt;&gt;
&lt;&lt; synonyms for types &gt;&gt;
&lt;&lt; function prototypes &gt;&gt;
&lt;&lt; handling of out-of-memory conditions &gt;&gt;

#endif /* _PSYCO_H */</t>
<t tx="T61">
#ifndef DISABLE_DEBUG
 /* define for extra assert()'s */
# define ALL_CHECKS

 /* define for a few debugging outputs */
# define VERBOSE

 /* define for *heavy* memory checking */
# define HEAVY_MEM_CHECK
 /* define for **really** **heavy** memory checking */
/*#undef HEAVY_HEAVY_MEM_CHECK*/

 /* define to write produced blocks of code into a file
    See 'xam.py' */
# define CODE_DUMP_FILE    "psyco.dump"
# define CODE_DUMP_AT_END_ONLY
# define SPEC_DICT_SIGNATURE   0x98247b9d   /* arbitrary */

#endif  /* !DISABLE_DEBUG */

 /* define to inline the most common functions in the produced code
    (should be enabled unless you want to trade code size for speed) */
#define INLINE_COMMON_FUNCTIONS</t>
<t tx="T62">
/*****************************************************************/

/* Size of buffer to allocate when emitting code.
   Can be relatively large, but not so large that special allocation
   routines (like mmap) are invoked. We rely on the fact that
   PyObject_REALLOC will not move the memory around when shrinking
   a block of BIG_BUFFER_SIZE+sizeof(CodeBufferObject) bytes. */
#ifdef DISABLE_DEBUG
# define BIG_BUFFER_SIZE  0x7F00
#else
# define BIG_BUFFER_SIZE  0x7F0
#endif

/* A safety margin for occasional overflows: we might write a few
   instructions too much before we realize we wrote past 'codelimit'.
   XXX carefully check that it is impossible to overflow by more
   We need more than 128 bytes because of the way conditional jumps
   are emitted; see pycompiler.c */
#define BUFFER_MARGIN    (192 + GUARANTEED_MINIMUM)

/* When emitting code, all called functions can assume that they
   have at least this amount of room to write their code. If they
   might need more, they have to allocate new buffers and write a
   jump to these from the original code (jumps can be done in less
   than GUARANTEED_MINIMUM bytes). */
#define GUARANTEED_MINIMUM    32</t>
<t tx="T63">
#ifdef ALL_CHECKS
# define MALLOC_CHECK_    2  /* GCC malloc() checks */
# undef NDEBUG
# include &lt;assert.h&gt;
# define extra_assert(x)  assert(x)
#else
# define extra_assert(x)  1  /* nothing */
#endif

#ifdef VERBOSE
# define debug_printf(args)   printf args
#else
# define debug_printf(args)   1  /* nothing */
#endif</t>
<t tx="T64">
#ifdef ALL_STATIC
# define EXTERNVAR   staticforward
# define EXTERNFN    static
# define DEFINEVAR   statichere
# define DEFINEFN    static
#else
# define EXTERNVAR   extern
# define EXTERNFN
# define DEFINEVAR
# define DEFINEFN
#endif</t>
<t tx="T65">#ifdef INLINE_COMMON_FUNCTIONS
# define inline      __inline__ static   /* is this GCC-specific? */
#else
# define inline      static
#endif

#ifdef HEAVY_MEM_CHECK
# include "linuxmemchk.h"
# ifdef HEAVY_HEAVY_MEM_CHECK
#  define PSYCO_NO_LINKED_LISTS
# endif
#endif</t>
<t tx="T66">
#ifndef bool
typedef int bool;
#endif
#ifndef false
static const bool false = 0;
#endif
#ifndef true
static const bool true = 1;
#endif


typedef char code_t;

typedef struct vinfo_s vinfo_t;             /* defined in compiler.h */
typedef struct vinfo_array_s vinfo_array_t; /* defined in compiler.h */
typedef struct PsycoObject_s PsycoObject;   /* defined in compiler.h */
typedef struct FrozenPsycoObject_s FrozenPsycoObject; /* def in dispatcher.h */
typedef struct CodeBufferObject_s CodeBufferObject;  /* def in codemanager.h */
typedef struct global_entries_s global_entries_t;  /* def in dispatcher.h */

EXTERNVAR PyObject* PyExc_PsycoError;

/*#undef PY_PSYCO_MODULE*/   /* nothing useful in psyco.py right now */
#ifdef PY_PSYCO_MODULE
	EXTERNVAR PyObject* PyPsycoModule;
#endif

/* moved here from vcompiler.h because needed by numerous header files */
typedef bool (*compute_fn_t)(PsycoObject* po, vinfo_t* vi);

typedef struct {
  compute_fn_t compute_fn;
} source_virtual_t;
</t>
<t tx="T67">
/* Build a PsycoObject "frame" corresponding to the call of a Python
   function. Raise a Python exception and return NULL in case of failure.
   The 'arginfo' array gives the number of arguments as well as
   additional information about them. It will be expanded with the
   default values of missing arguments, if any, and finally released.
   If 'sources!=NULL', it is set to an array of the sources of the values
   that must be pushed to make the call. */
EXTERNFN PsycoObject* psyco_build_frame(PyFunctionObject* function,
                                        vinfo_array_t* arginfo, int recursion,
                                        long** sources);

/* Encode a call to the given Python function, compiling it as needed. */
EXTERNFN vinfo_t* psyco_call_pyfunc(PsycoObject* po, PyFunctionObject* function,
                                    vinfo_t* arg_tuple, int recursion);


/* Psyco proxies for Python functions */
typedef struct {
  PyObject_HEAD
  PyFunctionObject* psy_func;   /* Python function object */
  int psy_recursion;    /* # levels to automatically compile called functions */
} PsycoFunctionObject;

#define PsycoFunction_Check(v)	((v)-&gt;ob_type == &amp;PsycoFunction_Type)
EXTERNVAR PyTypeObject PsycoFunction_Type;

EXTERNFN PsycoFunctionObject* psyco_PsycoFunction_New(PyFunctionObject* func,
                                                      int rec);


#if defined(CODE_DUMP_FILE) &amp;&amp; !defined(CODE_DUMP_AT_END_ONLY)
EXTERNFN void psyco_dump_code_buffers();
#else
# define psyco_dump_code_buffers()    do { } while (0) /* nothing */
#endif

/* defined in pycompiler.c */
#define GLOBAL_ENTRY_POINT	psyco_pycompiler_mainloop
EXTERNFN code_t* psyco_pycompiler_mainloop(PsycoObject* po);</t>
<t tx="T68">/* XXX no handling of out-of-memory conditions. We have to define precisely
   what should occur in various cases, like when we run out of memory in the
   middle of writing code, when the beginning is already executing. When
   should we report the exception? */
#define OUT_OF_MEMORY()      Py_FatalError("psyco: out of memory")</t>
<t tx="T69"> /***************************************************************/
/***     Processor- and language-dependent code producers      ***/
 /***************************************************************/

#ifndef _PYCENCODING_H
#define _PYCENCODING_H

#include "psyco.h"
#include "processor.h"
#include "dispatcher.h"

#include "Objects/pobject.h"

@others

#endif /* _PYCENCODING_H */
</t>
<t tx="T70">/* Note: the following macro must output a fixed number of bytes of
   code, so that it can be called again with different arguments later
   to update an existing code buffer */
  
#define DICT_ITEM_IFCHANGED(code, mp, index, key, value, jmptarget)  do {       \
  char _mprg;                                                                   \
  NEED_FREE_REG(_mprg);                                                         \
  LOAD_REG_FROM_IMMED(_mprg, (long)(mp));                                       \
  extra_assert(0 &lt; offsetof(PyDictObject, ma_mask) &amp;&amp;                           \
                   offsetof(PyDictObject, ma_mask) &lt; 128);                      \
  extra_assert(0 &lt; offsetof(PyDictObject, ma_table) &amp;&amp;                          \
                   offsetof(PyDictObject, ma_table) &lt; 128);                     \
  code[0] = 0x81;           /* CMP [...], imm32 */                              \
  code[1] = 0x40 | (7&lt;&lt;3) | _mprg;   /* CMP [mpreg-&gt;ma_mask], ... */            \
  code[2] = offsetof(PyDictObject, ma_mask);                                    \
  *(long*)(code+3) = (index);                                                   \
  /* perform the load before checking the CMP outcome */                        \
  code[7] = 0x8B;                                                               \
  code[8] = 0x40 | (_mprg&lt;&lt;3) | _mprg;   /* MOV mpreg, [mpreg-&gt;ma_table] */     \
  CODE_FOUR_BYTES(code+9,                                                       \
            offsetof(PyDictObject, ma_table),                                   \
            0x70 | CC_L,                 /* JL +22 (to 'JNE target') */         \
            34 - 12,                                                            \
            0x81);       /* CMP [mpreg+dictentry*index+me_key], key */          \
  code[13] = 0x80 | (7&lt;&lt;3) | _mprg;                                             \
  *(long*)(code+14) = (index)*sizeof(PyDictEntry) +                             \
                                  offsetof(PyDictEntry, me_key);                \
  *(long*)(code+18) = (long)(key);                                              \
  CODE_FOUR_BYTES(code+22,                                                      \
            0x70 | CC_NE,              /* JNE +10 (to 'JNE target') */          \
            34 - 24,                                                            \
            0x81,        /* CMP [mpreg+dictentry*index+me_value], value */      \
            0x80 | (7&lt;&lt;3) | _mprg);                                             \
  *(long*)(code+26) = (index)*sizeof(PyDictEntry) +                             \
                                  offsetof(PyDictEntry, me_value);              \
  *(long*)(code+30) = (long)(value);                                            \
  code[34] = 0x0F;                       /* JNE target */                       \
  code[35] = 0x80 | CC_NE;                                                      \
  code += 40;                                                                   \
  *(long*)(code-4) = ((code_t*)(jmptarget)) - code;                             \
} while (0)
</t>
<t tx="T71">/* emit the equivalent of the Py_INCREF() macro */
/* the PyObject* is stored in the register 'rg' */

#define INC_OB_REFCNT(rg)	do {                    \
  NEED_CC();                                            \
  extra_assert(offsetof(PyObject, ob_refcnt) == 0);     \
  code[0] = 0xFF;          /* INC [reg] */              \
  if (EBP_IS_RESERVED || (rg) != REG_EBP)               \
    {                                                   \
      extra_assert((rg) != REG_EBP);                    \
      code[1] = (rg);                                   \
    }                                                   \
  else                                                  \
    {                                                   \
      code++;                                           \
      code[0] = 0x45;                                   \
      code[1] = 0;                                      \
    }                                                   \
  code += 2;                                            \
} while (0)
</t>
<t tx="T72">/* Py_INCREF() for a compile-time-known 'pyobj' */

#define INC_KNOWN_OB_REFCNT(pyobj)    do {      \
  NEED_CC();                                    \
  code[0] = 0xFF;  /* INC [address] */          \
  code[1] = 0x05;                               \
  *(int**)(code+2) = &amp;(pyobj)-&gt;ob_refcnt;       \
  code += 6;                                    \
 } while (0)
</t>
<t tx="T73">/* Py_DECREF() for a compile-time 'pyobj' assuming counter cannot reach zero */

#define DEC_KNOWN_OB_REFCNT_NZ(pyobj)    do {   \
  NEED_CC();                                    \
  code[0] = 0xFF;  /* DEC [address] */          \
  code[1] = (1&lt;&lt;3) | 0x05;                      \
  *(int**)(code+2) = &amp;(pyobj)-&gt;ob_refcnt;       \
  code += 6;                                    \
 } while (0)</t>
<t tx="T74">/* like DEC_OB_REFCNT() but assume the reference counter cannot reach zero */

#define DEC_OB_REFCNT_NZ(rg)    do {            \
  NEED_CC();                                    \
  code[0] = 0xFF;          /* DEC [reg] */      \
  if (EBP_IS_RESERVED || (rg) != REG_EBP)       \
    {                                           \
      extra_assert((rg) != REG_EBP);            \
      code[1] = 0x08 | (rg);                    \
    }                                           \
  else                                          \
    {                                           \
      code++;                                   \
      code[0] = 0x4D;                           \
      code[1] = 0;                              \
    }                                           \
  code += 2;                                    \
} while (0)</t>
<t tx="T75">/* the equivalent of Py_DECREF() */

#define DEC_OB_REFCNT(rg)	do {                                    \
  DEC_OB_REFCNT_NZ(rg);                                                 \
  extra_assert(offsetof(PyObject, ob_refcnt) == 0);                     \
  extra_assert(offsetof(PyObject, ob_type) &lt; 128);                      \
  extra_assert(offsetof(PyTypeObject, tp_dealloc) &lt; 128);               \
  CODE_FOUR_BYTES(code,                                                 \
            0x75,          /* JNZ rel8 */                               \
            16 - 2,        /* to the end of this code block */          \
            PUSH_REG_INSTR(REG_EAX),   /* XXX if COMPACT_ENCODING, */   \
            PUSH_REG_INSTR(REG_ECX));  /* XXX  avoid these PUSH    */   \
  code[4] = PUSH_REG_INSTR(REG_EDX);   /* XXX  when unnecessary    */   \
  code[5] = PUSH_REG_INSTR(rg);                                         \
  code[6] = 0x8B;          /* MOV EAX, [reg+ob_type] */                 \
  code[7] = 0x40 | (rg);                                                \
  CODE_FOUR_BYTES(code+8,                                               \
            offsetof(PyObject, ob_type),                                \
            0xFF,         /* CALL [EAX+tp_dealloc] */                   \
            0x50,                                                       \
            offsetof(PyTypeObject, tp_dealloc));                        \
  CODE_FOUR_BYTES(code+12,                                              \
            POP_REG_INSTR(REG_EDX),                                     \
            POP_REG_INSTR(REG_EDX),                                     \
            POP_REG_INSTR(REG_ECX),                                     \
            POP_REG_INSTR(REG_EAX));                                    \
  code += 16;                                                           \
} while (0)</t>
<t tx="T76">/* the same as above, when we know that the reference counter is reaching zero */

#define DEC_OB_REFCNT_Z(rg)    do {                             \
  --- note: this is not used ---                                \
  extra_assert(offsetof(PyObject, ob_refcnt) == 0);             \
  extra_assert(offsetof(PyObject, ob_type) &lt; 128);              \
  extra_assert(offsetof(PyTypeObject, tp_dealloc) &lt; 128);       \
  SAVE_REGS_FN_CALL;                                            \
  SET_REG_ADDR_TO_IMMED(rg, 0);                                 \
  code[0] = PUSH_REG_INSTR(rg);                                 \
  code[1] = 0x8B;          /* MOV EAX, [reg+ob_type] */         \
  code[2] = 0x40 | (rg);                                        \
  CODE_FOUR_BYTES(code+3,                                       \
            offsetof(PyObject, ob_type),                        \
            0xFF,         /* CALL [EAX+tp_dealloc] */           \
            0x50,                                               \
            offsetof(PyTypeObject, tp_dealloc));                \
  code += 7;                                                    \
  po-&gt;stack_depth += 4;                                         \
} while (0)
</t>
<t tx="T77">/* the equivalent of Py_DECREF() when we know the type of the object
   (assuming that tp_dealloc never changes for a given type) */

#define DEC_OB_REFCNT_T(rg, type)     do {                              \
  DEC_OB_REFCNT_NZ(rg);                                                 \
  extra_assert(offsetof(PyObject, ob_refcnt) == 0);                     \
  CODE_FOUR_BYTES(code,                                                 \
            0x75,          /* JNZ rel8 */                               \
            15 - 2,        /* to the end of this code block */          \
            PUSH_REG_INSTR(REG_EAX),   /* XXX if COMPACT_ENCODING, */   \
            PUSH_REG_INSTR(REG_ECX));  /* XXX  avoid these PUSH    */   \
  code[4] = PUSH_REG_INSTR(REG_EDX);   /* XXX  when unnecessary    */   \
  code[5] = PUSH_REG_INSTR(rg);                                         \
  code[6] = 0xE8;    /* CALL */                                         \
  code += 11;                                                           \
  *(long*)(code-4) = (code_t*)((type)-&gt;tp_dealloc) - code;              \
  CODE_FOUR_BYTES(code,                                                 \
            POP_REG_INSTR(REG_EDX),                                     \
            POP_REG_INSTR(REG_EDX),                                     \
            POP_REG_INSTR(REG_ECX),                                     \
            POP_REG_INSTR(REG_EAX));                                    \
  code += 4;                                                            \
} while (0)

</t>
<t tx="T78"> /***************************************************************/
 /***   generic reference counting functions                  ***/


@others

</t>
<t tx="T79">/* emit Py_INCREF(v) for run-time v */

inline void psyco_incref_rt(PsycoObject* po, vinfo_t* v)
{
  reg_t rg;
  BEGIN_CODE
  RTVINFO_IN_REG(v);
  rg = RUNTIME_REG(v);
  INC_OB_REFCNT(rg);
  END_CODE
}</t>
<t tx="T80">/* emit Py_INCREF(v) */
inline bool psyco_incref_v(PsycoObject* po, vinfo_t* v)
{
  NonVirtualSource src = vinfo_compute(v, po);
  if (src == SOURCE_ERROR)
    return false;
  if (!is_compiletime(src))
    psyco_incref_rt(po, v);
  else
    {
      BEGIN_CODE
      INC_KNOWN_OB_REFCNT((PyObject*) CompileTime_Get(v-&gt;source)-&gt;value);
      END_CODE
    }
  return true;
}</t>
<t tx="T81">/* emit Py_DECREF(v) for run-time v. Used by vcompiler.c when releasing a
   run-time vinfo_t holding a reference to a Python object. */

inline void psyco_decref_rt(PsycoObject* po, vinfo_t* v)
{
  vinfo_t* vtp = vinfo_getitem(v, OB_TYPE);
  reg_t rg;
  BEGIN_CODE
  RTVINFO_IN_REG(v);
  rg = RUNTIME_REG(v);
  if (vtp != NULL &amp;&amp; is_compiletime(vtp-&gt;source))
    DEC_OB_REFCNT_T(rg, (PyTypeObject*) (CompileTime_Get(vtp-&gt;source)-&gt;value));
  else
    DEC_OB_REFCNT(rg);
  END_CODE
}</t>
<t tx="T82">/* emit Py_DECREF(v) for any v */

inline void psyco_decref_v(PsycoObject* po, vinfo_t* v)
{
  switch (gettime(v-&gt;source)) {
    
  case RunTime:
    psyco_decref_rt(po, v);
    break;

  case CompileTime:
    BEGIN_CODE
    DEC_KNOWN_OB_REFCNT_NZ((PyObject*) CompileTime_Get(v-&gt;source)-&gt;value);
    END_CODE
    break;
  }
}
</t>
<t tx="T83">/* can eat a reference if we had one in the first place, and
   if no one else will require it (i.e. there is only one reference
   left to 'vi') */
inline bool eat_reference(vinfo_t* vi)
{
  if (has_rtref(vi-&gt;source) &amp;&amp; vi-&gt;refcount == 1)
    {
      vi-&gt;source = remove_rtref(vi-&gt;source);
      return true;
    }
  else
    return false;
}</t>
<t tx="T84">/* make sure we have a reference on 'vi' */
inline void need_reference(PsycoObject* po, vinfo_t* vi)
{
  if ((vi-&gt;source &amp; (TimeMask | RunTime_NoRef)) == (RunTime | RunTime_NoRef))
    {
      vi-&gt;source = add_rtref(vi-&gt;source);
      psyco_incref_rt(po, vi);
    }
}
</t>
<t tx="T85">/* internal utilities for the next two functions */
EXTERNFN void decref_create_new_ref(PsycoObject* po, vinfo_t* w);
EXTERNFN void decref_create_new_lastref(PsycoObject* po, vinfo_t* w);

/* write 'newitem' into the array of 'v' at position 'index',
   creating a new Python reference. If 'lastref', 'newitem' is supposed to
   be freed soon; this allows an eventual Python reference owned by 'newitem'
   to be moved to the array without having to emit any actual
   Py_INCREF()/Py_DECREF() code. */
inline bool write_array_item_ref(PsycoObject* po, vinfo_t* v, int index,
                                 vinfo_t* newitem, bool lastref)
{
	if (!write_array_item(po, v, index, newitem))
		return false;
	if (lastref)
		decref_create_new_lastref(po, newitem);
	else
		decref_create_new_ref(po, newitem);
	return true;
}
inline bool write_array_item_var_ref(PsycoObject* po, vinfo_t* vi,
				     int baseindex, vinfo_t* varindex,
				     vinfo_t* newitem, bool lastref)
{
	if (!write_array_item_var(po, vi, baseindex, varindex, newitem))
		return false;
	if (lastref)
		decref_create_new_lastref(po, newitem);
	else
		decref_create_new_ref(po, newitem);
	return true;
}
</t>
<t tx="T86"> /***************************************************************/
/***           Structures used by the compiler part            ***/
 /***************************************************************/

#ifndef _VCOMPILER_H
#define _VCOMPILER_H


#include "psyco.h"
#include "encoding.h"
#include "Python/pycheader.h"


EXTERNFN void psyco_compiler_init();
&lt;&lt; define sources of vinfo_t structures &gt;&gt;
&lt;&lt; runtime sources &gt;&gt;
&lt;&lt; compile-time sources &gt;&gt;
&lt;&lt; virtual-time sources &gt;&gt;
&lt;&lt; define vinfo_t structure &gt;&gt;
&lt;&lt; PsycoObject &gt;&gt;
&lt;&lt; Compiler language-independent functions &gt;&gt;

#endif /* _VCOMPILER_H */</t>
<t tx="T87">/*****************************************************************/
/***   Definition of the "sources" of vinfo_t structures       ***/

/* A "source" defines the stage of the variable (run-time,
   compile-time or virtual-time), and gives information about
   the value of the variable */
typedef long Source;   /* Implemented as a bitfield 32-bit integer. */

/* the next typedefs are for documentation purposes only, as the C compiler
   will not make any difference between them all */
typedef long NonVirtualSource;
typedef long RunTimeSource;
typedef long CompileTimeSource;
typedef long VirtualTimeSource;

#define RunTime         0
#define CompileTime     1    /* a.k.a. "Known value" */
#define VirtualTime     2
#define TimeMask        (CompileTime | VirtualTime)

inline bool is_runtime(Source s)     { return (s &amp; TimeMask) == RunTime; }
inline bool is_compiletime(Source s) { return (s &amp; CompileTime) != 0; }
inline bool is_virtualtime(Source s) { return (s &amp; VirtualTime) != 0; }
inline long gettime(Source s)        { return s &amp; TimeMask; }
#define CHKTIME(src, time)           extra_assert(gettime(src) == (time))</t>
<t tx="T88">/************************ Run-time sources *******************************
 *
 * If the last two bits of 'source' are 'RunTime', we have a run-time value.
 * The rest of 'source' encodes both the position of the value in the stack
 * (or StackNone) and the register holding this value (or REG_NONE).
 *
 **/

/* flags */
#define RunTime_StackMask    0x07FFFFFC
#define RunTime_StackMax     RunTime_StackMask
#define RunTime_StackNone    0
#define RunTime_RegMask      0xF0000000
#define RunTime_NoRef        0x08000000
#define RunTime_FlagsMask    RunTime_NoRef

/* construction */
inline RunTimeSource RunTime_NewStack(int stack_position, reg_t reg, bool ref) {
	long result = RunTime + stack_position + ((long) reg &lt;&lt; 28);
	if (!ref)
		result += RunTime_NoRef;
	return (RunTimeSource) result;
}
inline RunTimeSource RunTime_New(reg_t reg, bool ref) {
	return RunTime_NewStack(RunTime_StackNone, reg, ref);
}

/* field inspection */
inline bool has_rtref(Source s) {
	return (s &amp; (TimeMask|RunTime_NoRef)) == RunTime;
}
inline reg_t getreg(RunTimeSource s)     { return (reg_t)(s &gt;&gt; 28); }
inline bool is_reg_none(RunTimeSource s) { return s &lt; 0; }
inline int getstack(RunTimeSource s)     { return s &amp; RunTime_StackMask; }

/* mutation */
inline RunTimeSource remove_rtref(RunTimeSource s) { return s | RunTime_NoRef; }
inline RunTimeSource add_rtref(RunTimeSource s)    { return s &amp; ~RunTime_NoRef; }
inline RunTimeSource set_rtreg_to(RunTimeSource s, reg_t newreg) {
	return (s &amp; ~RunTime_RegMask) | ((long) newreg &lt;&lt; 28);
}
inline RunTimeSource set_rtreg_to_none(RunTimeSource s) {
	return s | ((long) REG_NONE &lt;&lt; 28);
}
inline RunTimeSource set_rtstack_to(RunTimeSource s, int stack) {
	extra_assert(getstack(s) == RunTime_StackNone);
	return s | stack;
}
inline RunTimeSource set_rtstack_to_none(RunTimeSource s) {
	return s &amp; ~RunTime_StackMask;
}</t>
<t tx="T89">/************************ Compile-time sources *******************************
 *
 * if the last two bits of 'source' are 'CompileTime',
 * the rest of 'source' points to a 'source_known_t' structure:
 *
 **/
typedef struct {
	long refcount1_flags; /* flags and reference counter */
	long value;           /* compile-time known value */
} source_known_t;

/* flags for source_known_t::refcount1_flags: */

/* flag added when producing code that relies
   essentially on this value to be constant */
#define SkFlagFixed   0x01

/* value is a PyObject* and holds a reference */
#define SkFlagPyObj   0x02

/* first unused flag */
#define SkFlagEnd     0x04
#define SkFlagMask    (SkFlagEnd-1)

/* refcounting */
EXTERNFN void sk_release(source_known_t *sk);
inline void sk_incref(source_known_t *sk) { sk-&gt;refcount1_flags += SkFlagEnd; }
inline void sk_decref(source_known_t *sk) {
	if ((sk-&gt;refcount1_flags -= SkFlagEnd)&lt;0) sk_release(sk);
}

/* construction */
EXTERNVAR void** sk_linked_list;
EXTERNFN void* sk_malloc_block();
inline source_known_t* sk_new(long v, long flags) {
	source_known_t* sk;
	if (sk_linked_list == NULL)
		sk = (source_known_t*) sk_malloc_block();
	else {
		sk = (source_known_t*) sk_linked_list;
		sk_linked_list = *(void**) sk;
	}
	sk-&gt;refcount1_flags = flags;
	sk-&gt;value = v;
	return sk;
}
inline void sk_delete(source_known_t* sk) {
	*(void**) sk = sk_linked_list;
	sk_linked_list = (void**) sk;
}

/* Compile-time sources */
/* construction */
inline CompileTimeSource CompileTime_NewSk(source_known_t* newsource) {
	extra_assert((((long) newsource) &amp; TimeMask) == 0);
	return (CompileTimeSource) (((char*) newsource) + CompileTime);
}
inline CompileTimeSource CompileTime_New(long value) {
	return CompileTime_NewSk(sk_new(value, 0));
}

/* inspection */
inline source_known_t* CompileTime_Get(CompileTimeSource s) {
	return (source_known_t*)(((char*) s) - CompileTime);
}
inline CompileTimeSource set_ct_value(CompileTimeSource s, long v) {
	source_known_t* sk = CompileTime_Get(s);
        extra_assert((sk-&gt;refcount1_flags &amp; SkFlagPyObj) == 0);
	if (sk-&gt;refcount1_flags &lt; SkFlagEnd) {
		sk-&gt;value = v; /* reuse object when only one reference */
		return s;
	}
	else {
		sk_decref(sk);
		return CompileTime_NewSk(sk_new(v, sk-&gt;refcount1_flags &amp;
						SkFlagMask));
	}
}</t>
<t tx="T90">/************************ Virtual-time sources *******************************
 *
 * if the last two bits of 'source' are VIRTUAL_TIME,
 * the rest of 'source' points to a 'source_virtual_t' structure.
 * See psyco.h for the definition of source_virtual_t.
 *
 **/

/* construction */
inline VirtualTimeSource VirtualTime_New(source_virtual_t* sv) {
	extra_assert((((long) sv) &amp; TimeMask) == 0);
	return (VirtualTimeSource) (((char*) sv) + VirtualTime);
}

/* inspection */
inline source_virtual_t* VirtualTime_Get(VirtualTimeSource s) {
	return (source_virtual_t*)(((char*) s) - VirtualTime);
}

EXTERNVAR source_virtual_t psyco_vsource_not_important;

#define SOURCE_NOT_IMPORTANT     VirtualTime_New(&amp;psyco_vsource_not_important)
#define SOURCE_DUMMY             RunTime_New(REG_NONE, false)
#define SOURCE_DUMMY_WITH_REF    RunTime_New(REG_NONE, true)
#define SOURCE_ERROR             ((Source) -1)</t>
<t tx="T91"> /***************************************************************/
/***      Definition of the fundamental vinfo_t structure      ***/
 /***************************************************************/

/* 'array' fields are never NULL, but point to a fraction of vinfo_array_t
 * in which 'count' is 0, like 'NullArray'.
 * This allows 'array-&gt;count' to always return a sensible value.
 * Invariant: the array is dynamically allocated if and only if 'array-&gt;count'
 * is greater than 0.
 */
EXTERNVAR const long psyco_zero;
#define NullArrayAt(zero_variable)  ((vinfo_array_t*)(&amp;(zero_variable)))
#define NullArray                   NullArrayAt(psyco_zero)

struct vinfo_array_s {
	int count;
	vinfo_t* items[NB_LOCALS]; /* variable-sized when not in a PsycoObject */
};

/* construction */
EXTERNFN vinfo_array_t* array_grow1(vinfo_array_t* array, int ncount);
inline void array_release(vinfo_array_t* array) {
	if (array-&gt;count &gt; 0) PyCore_FREE(array);
}
inline vinfo_array_t* array_new(int ncount) {
	if (ncount &gt; 0)
		return array_grow1(NullArray, ncount);
	else
		return NullArray;
}

/* 'vinfo_t' defines for the compiler the stage of a
   variable and where it is found. It is a wrapper around a 'Source'.
   For pointers to structures, 'array' is used to decompose the structure
   fields into 'vinfo_t'-described variables which can in turn
   be at various stages. */
struct vinfo_s {
	int refcount;           /* reference counter */
	Source source;
	vinfo_array_t* array;   /* substructure variables or a NullArray */
	vinfo_t* tmp;           /* internal use of the dispatcher */
};

/* allocation */
EXTERNVAR void** vinfo_linked_list;
EXTERNVAR void* vinfo_malloc_block();
/* private! Do not use */
#ifdef PSYCO_NO_LINKED_LISTS
# define VINFO_FREE_1(vi)   PyCore_FREE(vi)
#else
# define VINFO_FREE_1(vi)   (*(void**) vi = vinfo_linked_list,  \
                             vinfo_linked_list = (void**) vi)
#endif

/* construction */
inline vinfo_t* vinfo_new(Source src) {
	vinfo_t* vi;
	if (vinfo_linked_list == NULL)
		vi = (vinfo_t*) vinfo_malloc_block();
	else {
		vi = (vinfo_t*) vinfo_linked_list;
		vinfo_linked_list = *(void**) vi;
	}
	vi-&gt;refcount = 1;
	vi-&gt;source = src;
	vi-&gt;array = NullArray;
	return vi;
}

/* copy constructor */
EXTERNFN vinfo_t* vinfo_copy(vinfo_t* vi);

/* refcounting */
EXTERNFN void vinfo_release(vinfo_t* vi, PsycoObject* po);
inline void vinfo_incref(vinfo_t* vi) { ++vi-&gt;refcount; }
inline void vinfo_decref(vinfo_t* vi, PsycoObject* po) {
	if (!--vi-&gt;refcount) vinfo_release(vi, po);
}
inline void vinfo_xdecref(vinfo_t* vi, PsycoObject* po) {
	if (vi != NULL) vinfo_decref(vi, po);
}

/* promoting out of virtual-time */
inline NonVirtualSource vinfo_compute(vinfo_t* vi, PsycoObject* po) {
	if (is_virtualtime(vi-&gt;source)) {
		if (!VirtualTime_Get(vi-&gt;source)-&gt;compute_fn(po, vi))
			return SOURCE_ERROR;
		extra_assert(!is_virtualtime(vi-&gt;source));
	}
	return (NonVirtualSource) vi-&gt;source;
}

/* sub-array (see also processor.h, get_array_item()&amp;co.) */
inline void vinfo_array_grow(vinfo_t* vi, int ncount) {
	if (ncount &gt; vi-&gt;array-&gt;count)
		vi-&gt;array = array_grow1(vi-&gt;array, ncount);
}
inline vinfo_t* vinfo_getitem(vinfo_t* vi, int index) {
	if (index &lt; vi-&gt;array-&gt;count)
		return vi-&gt;array-&gt;items[index];
	else
		return NULL;
}
inline vinfo_t* vinfo_needitem(vinfo_t* vi, int index) {
	vinfo_array_grow(vi, index+1);
	return vi-&gt;array-&gt;items[index];
}
inline void vinfo_setitem(PsycoObject* po, vinfo_t* vi, int index,
                          vinfo_t* newitem) {
	/* consumes a reference to 'newitem' */
	vinfo_array_grow(vi, index+1);
	vinfo_xdecref(vi-&gt;array-&gt;items[index], po);
	vi-&gt;array-&gt;items[index] = newitem;
}


/* array management */
EXTERNFN void clear_tmp_marks(vinfo_array_t* array);
#ifdef ALL_CHECKS
EXTERNFN void assert_cleared_tmp_marks(vinfo_array_t* array);
#else
inline void assert_cleared_tmp_marks(vinfo_array_t* array) { }   /* nothing */
#endif
EXTERNFN bool array_contains(vinfo_array_t* array, vinfo_t* vi);
EXTERNFN void duplicate_array(vinfo_array_t* target, vinfo_array_t* source);
inline void deallocate_array(vinfo_array_t* array, PsycoObject* po) {
	int i = array-&gt;count;
	while (i--) vinfo_xdecref(array-&gt;items[i], po);
}
inline void array_delete(vinfo_array_t* array, PsycoObject* po) {
	deallocate_array(array, po);
	array_release(array);
}</t>
<t tx="T92">/*****************************************************************/
 /***   PsycoObject: state of the compiler                      ***/

struct PsycoObject_s {
  /* used to be a Python object, hence the name */

  /* first, the description of variable stages. This is the data against
     which state matches and synchronizations are performed. */
  int stack_depth;         /* the size of data currently pushed in the stack */
  vinfo_array_t vlocals;           /* all the 'vinfo_t' variables            */
  vinfo_t* reg_array[REG_TOTAL];   /* the 'vinfo_t' currently stored in regs */
  vinfo_t* ccreg;                  /* processor condition codes (aka flags)  */

  /* next, compiler private variables for producing and optimizing code. */
  reg_t last_used_reg;          /* the most recently used register            */
  int arguments_count;          /* # run-time arguments given to the function */
  int respawn_cnt;                  /* see psyco_prepare_respawn()           */
  CodeBufferObject* respawn_proxy;  /* see psyco_prepare_respawn()           */
  code_t* code;                /* where the emitted code goes                */
  code_t* codelimit;           /* do not write code past this limit          */
  pyc_data_t pr;               /* private language-dependent data            */
};

/* run-time vinfo_t creation */
inline vinfo_t* new_rtvinfo(PsycoObject* po, reg_t reg, bool ref) {
	vinfo_t* vi = vinfo_new(RunTime_New(reg, ref));
	REG_NUMBER(po, reg) = vi;
	return vi;
}

/* move 'vsource-&gt;source' into 'vtarget-&gt;source'. Must be the last reference
   to 'vsource', which is freed. 'vsource' must have no array, and
   'vtarget-&gt;source' must hold no reference to anything. In short, this
   function must not be used except by virtual-time computers. */
inline void vinfo_move(PsycoObject* po, vinfo_t* vtarget, vinfo_t* vsource)
{
	Source src = vtarget-&gt;source = vsource-&gt;source;
	if (is_runtime(src) &amp;&amp; !is_reg_none(src))
		REG_NUMBER(po, getreg(src)) = vtarget;
	VINFO_FREE_1(vsource);
}</t>
<t tx="T93">/*****************************************************************/
 /***   Compiler language-independent functions                 ***/

/* compilation */

/* Main compiling function. Emit machine code corresponding to the state
   'po'. The compiler produces its code into 'code' and the return value is
   the end of the written code. 'po' is freed.

   Be sure to call po-&gt;vlocals.clear_tmp_marks() before this function.

   'continue_compilation' is normally false. When compile() is called
   during the compilation of 'po', 'continue_compilation' is true and
   psyco_compile() may return NULL to tell the caller to continue the
   compilation of 'po' itself. The sole purpose of this is to reduce the
   depth of recursion of the C stack.
*/
EXTERNFN code_t* psyco_compile(PsycoObject* po, bool continue_compilation);

/* Conditional compilation: the state 'po' is compiled to be executed only if
   'condition' holds. In general this creates a coding pause for it to be
   compiled later. It always makes a copy of 'po' so that the original can be
   used to compile the other case ('not condition'). 'condition' must not be
   CC_ALWAYS_xxx here.
*/
EXTERNFN void psyco_compile_cond(PsycoObject* po, condition_code_t condition);

/* Simplified interface to compile() without using a previously
   existing code buffer. Return a new code buffer. */
EXTERNFN CodeBufferObject* psyco_compile_code(PsycoObject* po);

/* Prepare a 'coding pause', i.e. a short amount of code (proxy) that will be
   called only if the execution actually reaches it to go on with compilation.
   'this' is the PsycoObject corresponding to the proxy.
   'condition' may not be CC_ALWAYS_FALSE.
   The (possibly conditional) jump to the proxy is encoded in 'calling_code'.
   When the execution reaches the proxy, 'resume_fn' is called and the proxy
   destroys itself and replaces the original jump to it by a jump to the newly
   compiled code. */
typedef code_t* (*resume_fn_t)(PsycoObject* po, void* extra);
EXTERNFN void psyco_coding_pause(PsycoObject* po, condition_code_t jmpcondition,
				 resume_fn_t resume_fn,
				 void* extra, int extrasize);

/* management functions; see comments in compiler.c */
#ifdef ALL_CHECKS
EXTERNFN void psyco_assert_coherent(PsycoObject* po);
#else
inline void psyco_assert_coherent(PsycoObject* po) { }   /* nothing */
#endif

/* construction */
inline PsycoObject* PsycoObject_New() {
	PsycoObject* po = (PsycoObject*) PyCore_MALLOC(sizeof(PsycoObject));
        if (po == NULL)
		OUT_OF_MEMORY();
	memset(po, 0, sizeof(PsycoObject));
	return po;
}
EXTERNFN PsycoObject* psyco_duplicate(PsycoObject* po);  /* internal */
inline PsycoObject* PsycoObject_Duplicate(PsycoObject* po) {
	clear_tmp_marks(&amp;po-&gt;vlocals);
	return psyco_duplicate(po);
}
EXTERNFN void PsycoObject_Delete(PsycoObject* po);</t>
<t tx="T94">#include "codemanager.h"

@others

</t>
<t tx="T95">#ifdef STORE_CODE_END
	# define SET_CODE_END(proxy)\
	    (b-&gt;codeend = (proxy) ? b-&gt;codeptr : NULL,   \
	     b-&gt;codemode = (proxy) ? "proxy" : "(compiling)")
#else
	# define SET_CODE_END(proxy)    /* nothing */
#endif
</t>
<t tx="T96">#define NEW_CODE_BUFFER(extrasize, codepointer, setcodelimit)   \
{                                                               \
  PyObject* o;                                                  \
  CodeBufferObject* b;                                          \
  psyco_trash_object(NULL);                                     \
                                                                \
  /* PyObject_New is inlined */                                 \
  o = PyObject_MALLOC(sizeof(CodeBufferObject) + (extrasize));  \
  if (o == NULL)                                                \
    return (CodeBufferObject*) PyErr_NoMemory();                \
  b = (CodeBufferObject*) PyObject_INIT(o, &amp;CodeBuffer_Type);   \
  b-&gt;codeptr = (codepointer);                                   \
  SET_CODE_END(!setcodelimit);                                  \
  debug_printf(("psyco: %s code buffer %p\n",                   \
         extrasize ? "new" : "proxy", b-&gt;codeptr));             \
                                                                \
  fpo_mark_new(&amp;b-&gt;snapshot);                                   \
  if (po == NULL)                                               \
    fpo_mark_unused(&amp;b-&gt;snapshot);                              \
  else                                                          \
    {                                                           \
      fpo_build(&amp;b-&gt;snapshot, po);                              \
      register_codebuf(ge, b);                                  \
      if (setcodelimit)                                         \
        po-&gt;codelimit = b-&gt;codeptr + BIG_BUFFER_SIZE -          \
                                     GUARANTEED_MINIMUM;        \
      po-&gt;respawn_cnt = 0;                                      \
      po-&gt;respawn_proxy = b;                                    \
    }                                                           \
  return b;                                                     \
}
</t>
<t tx="T97">DEFINEFN
CodeBufferObject* psyco_new_code_buffer(PsycoObject* po, global_entries_t* ge)
     NEW_CODE_BUFFER(BIG_BUFFER_SIZE,                                           \
                     ((code_t*)(b+1)),   /* buffer is after the object */       \
                     1)

DEFINEFN
CodeBufferObject* psyco_proxy_code_buffer(PsycoObject* po, global_entries_t* ge)
     NEW_CODE_BUFFER(0,                                         \
                     po-&gt;code,  /* buffer is elsewhere */       \
                     0)</t>
<t tx="T98">#if 0    /* not used in this version */

	DEFINEFN
	CodeBufferObject* psyco_new_code_buffer_size(int size)
	{
	  PyObject* o;
	  CodeBufferObject* b;
	  
	  /* PyObject_New is inlined */
	  o = PyObject_MALLOC(sizeof(CodeBufferObject) + size);
	  if (o == NULL)
		return (CodeBufferObject*) PyErr_NoMemory();
	  b = (CodeBufferObject*) PyObject_INIT(o, &amp;CodeBuffer_Type);
	  b-&gt;codeptr = (code_t*) (b + 1);
	  b-&gt;po = NULL;
	  debug_printf(("psyco: new_code_buffer_size(%d) %p\n", size, b-&gt;codeptr));
	  return b;
	}

#endif</t>
<t tx="T99">#ifdef CODE_DUMP_FILE
DEFINEVAR CodeBufferObject* psyco_codebuf_chained_list = NULL;
#endif

DEFINEFN
void psyco_shrink_code_buffer(CodeBufferObject* obj, int nsize)
{
  void* ndata;
  extra_assert(0 &lt; nsize &amp;&amp; nsize &lt;= BIG_BUFFER_SIZE - GUARANTEED_MINIMUM);
  ndata = PyObject_REALLOC(obj, sizeof(CodeBufferObject) + nsize);
  //printf("psyco: shrink_code_buffer %p to %d\n", obj-&gt;codeptr, nsize);
  debug_printf(("psyco: disassemble %p %p    (%d bytes)\n", obj-&gt;codeptr,
                obj-&gt;codeptr + nsize, nsize));
  assert(ndata == obj);   /* don't know what to do if this is not the case */
#ifdef STORE_CODE_END
  extra_assert(obj-&gt;codeend == NULL);
  obj-&gt;codeend = obj-&gt;codeptr + nsize;
  obj-&gt;codemode = "normal";
#endif
#ifdef CODE_DUMP_FILE
  obj-&gt;chained_list = psyco_codebuf_chained_list;
  psyco_codebuf_chained_list = obj;
#endif
}
</t>
<t tx="T100">/* int psyco_tie_code_buffer(PsycoObject* po) */
/* { */
/*   CodeBufferObject* b = po-&gt;respawn_proxy; */
/*   global_entries_t* ge = GET_UNUSED_SNAPSHOT(b-&gt;snapshot); */
/*   if (psyco_snapshot(b, po, ge)) */
/*     return -1; */
/*   po-&gt;respawn_cnt = 0; */
/*   return 0; */
/* } */</t>
<t tx="T101">static PyObject* trashed = NULL;

DEFINEFN
void psyco_trash_object(PyObject* obj)
{
  Py_XDECREF(trashed);
  trashed = obj;
}
</t>
<t tx="T102">static PyObject* codebuf_repr(CodeBufferObject* self)
{
  char buf[100];
  sprintf(buf, "&lt;code buffer ptr %p at %p&gt;",
	  self-&gt;codeptr, self);
  return PyString_FromString(buf);
}
</t>
<t tx="T103">static void codebuf_dealloc(CodeBufferObject* self)
{
#ifdef CODE_DUMP_FILE
  CodeBufferObject** ptr = &amp;psyco_codebuf_chained_list;
  while (*ptr != NULL)
    {
      if (*ptr == self)
        {
          *ptr = self-&gt;chained_list;
          break;
        }
      ptr = &amp;((*ptr)-&gt;chained_list);
    }
#endif
  debug_printf(("psyco: releasing code buffer %p at %p\n", self-&gt;codeptr, self));
  fpo_release(&amp;self-&gt;snapshot);
  PyObject_Del(self);
}</t>
<t tx="T104">DEFINEVAR
PyTypeObject CodeBuffer_Type = {
	PyObject_HEAD_INIT(NULL)
	0,			/*ob_size*/
	"CodeBuffer",		/*tp_name*/
	sizeof(CodeBufferObject),	/*tp_basicsize*/
	0,			/*tp_itemsize*/
	/* methods */
	(destructor)codebuf_dealloc, /*tp_dealloc*/
	0,			/*tp_print*/
	0,			/*tp_getattr*/
	0,			/*tp_setattr*/
	0,			/*tp_compare*/
	(reprfunc)codebuf_repr,	/*tp_repr*/
	0,			/*tp_as_number*/
	0,			/*tp_as_sequence*/
	0,			/*tp_as_mapping*/
	0,			/*tp_hash*/
	0,			/*tp_call*/
};
</t>
<t tx="T105">#include "dispatcher.h"
#include "codemanager.h"
#include "Python/pycompiler.h"   /* for pyc_data_xxx() */
#include "pycencoding.h"  /* for INC_OB_REFCNT() */

@others
</t>
<t tx="T106">@ **************************************************************/
** Snapshots ***/
**************************************************************/
</t>
<t tx="T107">DEFINEFN
void fpo_build(FrozenPsycoObject* fpo, PsycoObject* po)
{
  clear_tmp_marks(&amp;po-&gt;vlocals);
  duplicate_array(&amp;fpo-&gt;fz_vlocals, &amp;po-&gt;vlocals);
  fpo-&gt;fz_stuff.as_int =
    (po-&gt;stack_depth&lt;&lt;8) | ((int) po-&gt;last_used_reg);
  fpo-&gt;fz_arguments_count = po-&gt;arguments_count;
  fpo-&gt;fz_pyc_data = pyc_data_new(&amp;po-&gt;pr);
}
</t>
<t tx="T108">DEFINEFN
void fpo_release(FrozenPsycoObject* fpo)
{
  if (fpo-&gt;fz_pyc_data != NULL)
    pyc_data_delete(fpo-&gt;fz_pyc_data);
  deallocate_array(&amp;fpo-&gt;fz_vlocals, NULL);
}
</t>
<t tx="T109">static void find_regs_array(vinfo_array_t* source, PsycoObject* po)
{
  int i = source-&gt;count;
  while (i--)
    {
      vinfo_t* a = source-&gt;items[i];
      if (a != NULL)
        {
          Source src = a-&gt;source;
          if (is_runtime(src) &amp;&amp; !is_reg_none(src))
            REG_NUMBER(po, getreg(src)) = a;
          else if (psyco_vsource_cc(src) != CC_ALWAYS_FALSE)
            po-&gt;ccreg = a;
          if (a-&gt;array != NullArray)
            find_regs_array(a-&gt;array, po);
        }
    }
}
</t>
<t tx="T110">DEFINEFN
PsycoObject* fpo_unfreeze(FrozenPsycoObject* fpo)
{
  /* rebuild a PsycoObject from 'this' */
  PsycoObject* po = PsycoObject_New();
  po-&gt;stack_depth = get_stack_depth(fpo);
  po-&gt;last_used_reg = (reg_t)(fpo-&gt;fz_stuff.as_int &amp; 0xFF);
  po-&gt;arguments_count = fpo-&gt;fz_arguments_count;
  assert_cleared_tmp_marks(&amp;fpo-&gt;fz_vlocals);
  duplicate_array(&amp;po-&gt;vlocals, &amp;fpo-&gt;fz_vlocals);
  clear_tmp_marks(&amp;fpo-&gt;fz_vlocals);
  find_regs_array(&amp;po-&gt;vlocals, po);
  pyc_data_build(po);
  frozen_copy(&amp;po-&gt;pr, fpo-&gt;fz_pyc_data);
  return po;
}
</t>
<t tx="T111">@ Respawning is restoring a frozen compiler state into a live PsycoObject and
restarting the compilation.

It will produce exactly the same code up to a given point. This point was a
jump in the run-time code, pointing to code that we did not compile yet. The
purpose of 'replaying' the compilation is to rebuild exactly the same state as
the compiler had when it emitted the jump instruction in the first place.

At this point we can go on with the real compilation of the missing code. This
is all based on the idea that we want to avoid tons of copies of PsycoObjects
all around for all pending compilation branches, and there are a lot of them --
e.g. all instructions that could trigger an exception have such a (generally
uncompiled) branch.
</t>
<t tx="T112">typedef struct respawn_s {
  CodeBufferObject* self;
  code_t* write_jmp;
  char cond;
  short respawn_cnt;
  CodeBufferObject* respawn_from;
} respawn_t;

static code_t* do_respawn(respawn_t* rs)
{
  /* called when entering a not-compiled branch requiring a respawn */
  code_t* code;
  CodeBufferObject* firstcodebuf;
  CodeBufferObject* codebuf;
  PsycoObject* po;

  /* we might have a chain of code buffers, each containing a conditional
     jump to the next one. It ends with a proxy (not-yet-compiled) calling
     the function do_respawn().
     
     +----------+
     |  ...     |
     |  Jcond -----------&gt;  +----------+
     |  ...     |           |  ...     |
     +----------+           |  Jcond -----------&gt;   +-----------------+
                            |  ...     |            | CALL do_respawn |
                            +----------+            +-----------------+

     The structure 'rs' is stored in the last block (the proxy).
     'rs-&gt;respawn_from' is the previous code buffer.
     'rs-&gt;respawn_from-&gt;snapshot.fz_respawned_from' is the previous one.
     etc.
  */
  int respawn_cnt = rs-&gt;respawn_cnt;
  /* find the first code buffer in the chain */
  for (firstcodebuf = rs-&gt;respawn_from;
       firstcodebuf-&gt;snapshot.fz_respawned_from != NULL;
       firstcodebuf = firstcodebuf-&gt;snapshot.fz_respawned_from)
    respawn_cnt = firstcodebuf-&gt;snapshot.fz_respawned_cnt;
  /* respawn there */
  po = fpo_unfreeze(&amp;firstcodebuf-&gt;snapshot);
  
  codebuf = psyco_new_code_buffer(NULL, NULL);
  if (codebuf == NULL)
    OUT_OF_MEMORY();
  codebuf-&gt;snapshot.fz_stuff.respawning = rs;
  codebuf-&gt;snapshot.fz_respawned_cnt = rs-&gt;respawn_cnt;
  codebuf-&gt;snapshot.fz_respawned_from = firstcodebuf;
  code = codebuf-&gt;codeptr;
  po-&gt;code = code;
  po-&gt;codelimit = code + BIG_BUFFER_SIZE - GUARANTEED_MINIMUM;
  /* respawn by restarting the Python compiler at the beginning of the
     instruction where it left. It will probably re-emit a few machine
     instructions -- not needed, they will be trashed, but this has
     rebuilt the correct PsycoObject state. This occurs when eventually
     a positive DETECT_RESPAWN() is iussed. */
  po-&gt;respawn_cnt = - respawn_cnt;
  po-&gt;respawn_proxy = codebuf;

  code = GLOBAL_ENTRY_POINT(po);
  
  SHRINK_CODE_BUFFER(codebuf, code - codebuf-&gt;codeptr, "respawned");
  /* make sure DETECT_RESPAWN() succeeded */
  extra_assert(codebuf-&gt;snapshot.fz_respawned_from == rs-&gt;respawn_from);

  /* fix the jump to point to 'codebuf-&gt;codeptr' */
  code = rs-&gt;write_jmp;
/*   if (rs-&gt;cond == CC_ALWAYS_TRUE) */
/*     JUMP_TO(codebuf-&gt;codeptr); */
/*   else */
    FAR_COND_JUMP_TO(codebuf-&gt;codeptr, rs-&gt;cond);
  /* cannot Py_DECREF(cp-&gt;self) because the current function is returning into
     that code now, but any time later is fine: use the trash of codemanager.c */
  psyco_trash_object((PyObject*) rs-&gt;self);
  psyco_dump_code_buffers();
  /* XXX don't know what to do with this reference to codebuf */
  return codebuf-&gt;codeptr;
}
</t>
<t tx="T113">DEFINEFN
void psyco_respawn_detected(PsycoObject* po)
{
  /* this is called when detect_respawn() succeeds. We can now proceed
     to the next code block in the picture above. When we reach the
     last one, it means we are about to compile the 'special' branch of
     a conditional jump -- the one that is not compiled yet.
  */
  CodeBufferObject* codebuf = po-&gt;respawn_proxy;
  CodeBufferObject* current = codebuf-&gt;snapshot.fz_respawned_from;
  respawn_t* rs = codebuf-&gt;snapshot.fz_stuff.respawning;

  /* 'codebuf' is the new block we are writing.
     'current' is the block we are currently respawning.
     'rs-&gt;respawn_from' is the last block before the proxy calling
        do_respawn(). */
  if (current == rs-&gt;respawn_from)
    {
      /* respawn finished */
      extra_assert(codebuf-&gt;snapshot.fz_vlocals.count == 0);
      fpo_build(&amp;codebuf-&gt;snapshot, po);
    }
  else
    {
      /* proceed to the next block */
      CodeBufferObject* nextblock;
      int respawn_cnt = rs-&gt;respawn_cnt;
      for (nextblock = rs-&gt;respawn_from;
           nextblock-&gt;snapshot.fz_respawned_from != current;
           nextblock = nextblock-&gt;snapshot.fz_respawned_from)
        respawn_cnt = nextblock-&gt;snapshot.fz_respawned_cnt;
      codebuf-&gt;snapshot.fz_respawned_from = nextblock;
      po-&gt;respawn_cnt = - respawn_cnt;
    }
  /* restart at the beginning of the buffer, overriding the code written
     so far. XXX when implementing freeing of code, be careful that this
     lost code does not looses references to other objects as well.
     Use is_respawning() to bypass the creation of all references when
     compiling during respawn. */
  po-&gt;code = codebuf-&gt;codeptr;
}
</t>
<t tx="T114">DEFINEFN
void psyco_prepare_respawn(PsycoObject* po, condition_code_t jmpcondition)
{
  /* ignore calls to psyco_prepare_respawn() while currently respawning */
  if (!is_respawning(po))
    {
      respawn_t* rs;
      code_t* calling_code;
      CodeBufferObject* codebuf = psyco_new_code_buffer(NULL, NULL);
      if (codebuf == NULL)
        OUT_OF_MEMORY();
  
      extra_assert(jmpcondition &lt; CC_TOTAL);

      /* the proxy contains only a jump to do_respawn,
         followed by a respawn_t structure */
      calling_code = po-&gt;code;
      po-&gt;code = codebuf-&gt;codeptr;
      BEGIN_CODE
      TEMP_SAVE_REGS_FN_CALLS;
      END_CODE
      rs = (respawn_t*) psyco_jump_proxy(po, &amp;do_respawn, 1, 1);
      SHRINK_CODE_BUFFER(codebuf,
                         (code_t*)(rs+1) - codebuf-&gt;codeptr,
                         "respawn");
      /* fill in the respawn_t structure */
      extra_assert(po-&gt;respawn_proxy != NULL);
      rs-&gt;self = codebuf;
      rs-&gt;write_jmp = calling_code;
      rs-&gt;cond = jmpcondition;
      rs-&gt;respawn_cnt = po-&gt;respawn_cnt;
      rs-&gt;respawn_from = po-&gt;respawn_proxy;

      /* write the jump to the proxy */
      po-&gt;code = calling_code;
      BEGIN_CODE
      /*   if (jmpcondition == CC_ALWAYS_TRUE) */
      /*     JUMP_TO(codebuf-&gt;codeptr); */
      /*   else */
        FAR_COND_JUMP_TO(codebuf-&gt;codeptr, jmpcondition);
      END_CODE
      psyco_dump_code_buffers();
    }
  else
    po-&gt;code = po-&gt;respawn_proxy-&gt;codeptr;  /* respawning: come back at the
                                               beginning of the trash memory for
                                               the next instructions */
}
</t>
<t tx="T115">@ ****************************************************************/
@c

static vinfo_t* compatible_array(vinfo_array_t* aa, vinfo_array_t* bb)
{
  /* 'aa' is the array from the live PsycoObject. 'bb' is from the snapshop.
     Test for compatibility. More precisely, it must be allowable for the
     living state 'aa' to jump back to the code already produced for the
     state 'bb'. There might be more information in 'aa' than in 'bb' (which
     will then just be discarded), but the converse is not allowable.
     Moreover, if two slots in the arrays point to the same vinfo_t in 'bb',
     they must also do so in 'aa' because the code compiled from 'bb' might
     have used this fact. Conversely, shared pointers in 'aa' need *not* be
     shared any more in 'bb'.
     
     Return value of compatible_array(): as in psyco_compatible().
  */
  vinfo_t* result = COMPATIBLE;
  int i;
  int count = bb-&gt;count;
  if (aa-&gt;count != count) {
	&lt;&lt; return INCOMPATIBLE if the sizes of the arrays do not match &gt;&gt;
  }
  for (i=0; i&lt;count; i++) {
	&lt;&lt; examine items in turn &gt;&gt;
  }
  return result;

 incompatible:     /* we have to reset the 'tmp' fields to NULL,
                      but only as far as we actually progressed */
  for (; i&gt;=0; i--)
    if (bb-&gt;items[i] != NULL)
      {
	bb-&gt;items[i]-&gt;tmp = NULL;
	if (bb-&gt;items[i]-&gt;array != NullArray)
	  clear_tmp_marks(bb-&gt;items[i]-&gt;array);
      }
  return INCOMPATIBLE;
}</t>
<t tx="T116">  if (aa-&gt;count &lt; count)   /* array too short; ok only if the extra items */
{                      /*   in 'bb' are all NULL.                     */
  for (i=aa-&gt;count; i&lt;count; i++)
    if (bb-&gt;items[i] != NULL)
      return INCOMPATIBLE;   /* differs */
  count = aa-&gt;count;
}
  else      /* array too long; fail unless all the extra items are NULL */
{
  for (i=aa-&gt;count; i&gt;count; )
    if (aa-&gt;items[--i] != NULL)
      return INCOMPATIBLE;   /* differs */
}</t>
<t tx="T117">  vinfo_t* b = bb-&gt;items[i];
  if (b != NULL)     /* if b == NULL, any value in 'a' is ok. */
{
      vinfo_t* a = aa-&gt;items[i];
      /* we store in the 'tmp' fields of the 'bb' arrays pointers to the
         vinfo_t that matched in 'aa'. We assume that all 'tmp' fields
         are NULL initially. If, walking in the 'bb' arrays, we encounter
         the same 'b' several times, we use these 'tmp' pointers to make
         sure they all matched the same 'a'. */
  if (b-&gt;tmp != NULL)
    {
          /* This 'b' has already be seen. */
      if (b-&gt;tmp != a)
	goto incompatible;  /* not a quotient graph */
    }
  else
        {                /* A new 'b', let's check if its 'a' matches. */
          long diff;
          if (a == NULL)
            goto incompatible;  /* NULL not compatible with non-NULL */
          b-&gt;tmp = a;
          diff = ((long)a-&gt;source) ^ ((long)b-&gt;source);
          if (diff != 0)
            {
              if ((diff &amp; TimeMask) != 0)
                goto incompatible;  /* not the same TIME_MASK */
              if (is_runtime(a-&gt;source))
                {
                  if ((diff &amp; RunTime_NoRef) != 0)
                    {
                      /* from 'with ref' to 'without ref' or vice-versa:
                         a source in 'a' with reference cannot pass for
                         a source in 'b' without reference */
                      if ((a-&gt;source &amp; RunTime_NoRef) == 0)
                        goto incompatible;
                    }
                }
              else
                {
                  if (is_virtualtime(a-&gt;source))
                    goto incompatible;  /* different virtual sources */
                  if (KNOWN_SOURCE(a)-&gt;value != KNOWN_SOURCE(b)-&gt;value)
                    {
                      if ((KNOWN_SOURCE(b)-&gt;refcount1_flags &amp;
                           SkFlagFixed) != 0)
                        goto incompatible;  /* b's value is fixed */
                      /* approximative match, might un-promote 'a' from
                         compile-time to run-time. */
                      //fprintf(stderr, "psyco: compatible_array() with vinfo_t* a=%p, b=%p\n", a, b);
                      if (result == COMPATIBLE)
                        result = a;
                    }
                }
            }
          if (a-&gt;array != b-&gt;array)
            {                     /* can only be equal if both ==NullArray */
              vinfo_t* subresult = compatible_array(a-&gt;array, b-&gt;array);
              if (subresult == INCOMPATIBLE)
                goto incompatible;
              if (result == COMPATIBLE)
                result = subresult;
            }
        }
    }</t>
<t tx="T118">DEFINEFN
vinfo_t* psyco_compatible(PsycoObject* po, global_entries_t* patterns,
                          CodeBufferObject** matching)
{
  int i;
  vinfo_t* result = INCOMPATIBLE;
  PyObject* plist = patterns-&gt;fatlist;
  extra_assert(PyList_Check(plist));
  i = PyList_GET_SIZE(plist);
  while (i--)    /* the most dummy algorithm: step by step in the list, */
    {            /* checking for a match at each step.                  */
      vinfo_t* diff;
      CodeBufferObject* codebuf = (CodeBufferObject*) PyList_GET_ITEM(plist, i);
      extra_assert(CodeBuffer_Check(codebuf));
      /* invariant: all snapshot.fz_vlocals in the fatlist have
         all their 'tmp' fields set to NULL. */
      assert_cleared_tmp_marks(&amp;codebuf-&gt;snapshot.fz_vlocals);
      diff = compatible_array(&amp;po-&gt;vlocals, &amp;codebuf-&gt;snapshot.fz_vlocals);
      if (diff != INCOMPATIBLE)
	{
          /* compatible_array() leaves data in the 'tmp' fields.
             It must be cleared unless it is the final result of
             psyco_compatible() itself. */
	  if (diff == COMPATIBLE)
	    {
              /* Total match */
	      *matching = codebuf;
	      return COMPATIBLE;
	    }
          else
            {
              /* Partial match, clear 'tmp' fields */
              clear_tmp_marks(&amp;codebuf-&gt;snapshot.fz_vlocals);
              if (result == INCOMPATIBLE)
                {
                  /* Record the first partial match we find */
                  *matching = codebuf;
                  result = diff;
                }
            }
	}
      else   /* compatible_array() should have reset all 'tmp' fields */
	assert_cleared_tmp_marks(&amp;codebuf-&gt;snapshot.fz_vlocals);
    }
  return result;
}
</t>
<t tx="T119">DEFINEFN
void psyco_stabilize(CodeBufferObject* lastmatch)
{
  clear_tmp_marks(&amp;lastmatch-&gt;snapshot.fz_vlocals);
}
</t>
<t tx="T120">DEFINEFN
void psyco_dispatcher_init()
{
  global_entries.fatlist = PyList_New(0);
}
</t>
<t tx="T121">@ **************************************************************/
** Unification ***/
**************************************************************/
@c

</t>
<t tx="T122">struct dmove_s {
  PsycoObject* po;
  char* usages;   /* buffer: array of vinfo_t*, see ORIGINAL_VINFO() below */
  int usages_size;
  vinfo_t* copy_regs[REG_TOTAL];
  code_t* code_origin;
  code_t* code_limit;
  CodeBufferObject* private_codebuf;
};

static code_t* data_new_buffer(code_t* code, struct dmove_s* dm)
{
  /* creates a new buffer containing a copy of the already-written code */
  CodeBufferObject* codebuf;
  int codesize;
  assert(dm-&gt;private_codebuf == NULL);  /* otherwise it means we overwrote
                                           the BIG_BUFFER_SIZE */
  codebuf = psyco_new_code_buffer(NULL, NULL);
  if (codebuf == NULL)
    OUT_OF_MEMORY();
  /* copy old code to new buffer */
  codesize = code - dm-&gt;code_origin;
  memcpy(codebuf-&gt;codeptr, dm-&gt;code_origin, codesize);
  dm-&gt;private_codebuf = codebuf;
  dm-&gt;code_origin = codebuf-&gt;codeptr;
  dm-&gt;code_limit = dm-&gt;code_origin + BIG_BUFFER_SIZE;
  return codebuf-&gt;codeptr + codesize;
}
</t>
<t tx="T123">#define ORIGINAL_VINFO(spos)   (*(vinfo_t**)(dm-&gt;usages + (spos)))

static void data_original_table(struct dmove_s* dm, vinfo_array_t* bb)
{
  int i = bb-&gt;count;
  while (i--)
    {
      vinfo_t* b = bb-&gt;items[i];
      if (b != NULL)
        {
	  if (is_runtime(b-&gt;source) &amp;&amp; RUNTIME_STACK(b-&gt;tmp) &lt; dm-&gt;usages_size)
            ORIGINAL_VINFO(RUNTIME_STACK(b-&gt;tmp)) = b-&gt;tmp;
          if (b-&gt;array != NullArray)
	    data_original_table(dm, b-&gt;array);
        }
    }
}
</t>
<t tx="T124">static code_t* data_update_stack(code_t* code, struct dmove_s* dm,
                                 vinfo_array_t* bb)
{
  PsycoObject* po = dm-&gt;po;
  int i = bb-&gt;count;
  while (i--)
    {
      vinfo_t* b = bb-&gt;items[i];
      if (b != NULL)
        {
          if (is_runtime(b-&gt;source))
            {
              char rg;
              vinfo_t* overridden;
              vinfo_t* a = b-&gt;tmp;   /* source value */
              long dststack = RUNTIME_STACK(b);
              long srcstack = RUNTIME_STACK(a);

              /* check for values passing from no-reference to reference
                 or vice-versa */
              if (((a-&gt;source ^ b-&gt;source) &amp; RunTime_NoRef) != 0)
                {
                  /* from 'with ref' to 'no ref' is forbidden
                     by psyco_compatible() */
                  extra_assert((a-&gt;source &amp; RunTime_NoRef) != 0);
                  RTVINFO_IN_REG(a);
                  rg = RUNTIME_REG(a);
                  INC_OB_REFCNT(rg);
                  a-&gt;source &amp;= ~RunTime_NoRef;
                }
              
              rg = RUNTIME_REG(b);
              if (rg != REG_NONE)
                dm-&gt;copy_regs[(int)rg] = a;
              if (dststack == RUNTIME_STACK_NONE || dststack == srcstack)
                goto done;
              rg = RUNTIME_REG(a);
              if (rg == REG_NONE)
                {
                  NEED_FREE_REG(rg);
                  LOAD_REG_FROM_EBP_BASE(rg, srcstack);
                  REG_NUMBER(po, rg) = a;
                  SET_RUNTIME_REG_TO(a, rg);
                }
              a-&gt;source = RunTime_NewStack(dststack, getreg(a-&gt;source), false);
              overridden = ORIGINAL_VINFO(dststack);
              if (overridden == NULL)
                goto can_save_only;
              ORIGINAL_VINFO(dststack) = NULL;
              
              if (!RUNTIME_REG_IS_NONE(overridden))
                {
                  SET_RUNTIME_STACK_TO_NONE(overridden);
                can_save_only:
                  SAVE_REG_TO_EBP_BASE(rg, dststack);
                }
              else
                {
                  XCHG_REG_AND_EBP_BASE(rg, dststack);
                  SET_RUNTIME_REG_TO(overridden, rg);
                  SET_RUNTIME_STACK_TO_NONE(overridden);
                }
              
              if (code &gt; dm-&gt;code_limit)
                /* oops, buffer overflow. Start a new buffer */
                code = data_new_buffer(code, dm);
            }
        done:
          if (b-&gt;array != NullArray)
            code = data_update_stack(code, dm, b-&gt;array);
        }
    }
  return code;
}
</t>
<t tx="T125">DEFINEFN
code_t* psyco_unify(PsycoObject* po, CodeBufferObject** target)
{
  /* Update 'this' to match 'target', then jump to 'target'. */

  int i;
  struct dmove_s dm;
  code_t* code = po-&gt;code;
  CodeBufferObject* target_codebuf = *target;
  int sdepth = get_stack_depth(&amp;target_codebuf-&gt;snapshot);
  char pops[REG_TOTAL+2];

  psyco_assert_coherent(po);
  if (sdepth &gt; po-&gt;stack_depth)
    {
      /* more items in the target stack (uncommon case).
         Let the stack grow. */
      STACK_CORRECTION(sdepth - po-&gt;stack_depth);
      po-&gt;stack_depth = sdepth;
    }
  dm.usages_size = sdepth + sizeof(vinfo_t**);
  dm.usages = (char*) PyCore_MALLOC(dm.usages_size);
  if (dm.usages == NULL)
    OUT_OF_MEMORY();
  memset(dm.usages, 0, dm.usages_size);   /* set to all NULL */
  memset(dm.copy_regs, 0, sizeof(dm.copy_regs));
  data_original_table(&amp;dm, &amp;target_codebuf-&gt;snapshot.fz_vlocals);

  dm.po = po;
  dm.code_origin = code;
  dm.code_limit = po-&gt;codelimit == NULL ? code : po-&gt;codelimit;
  dm.private_codebuf = NULL;

  /* update the stack */
  code = data_update_stack(code, &amp;dm, &amp;target_codebuf-&gt;snapshot.fz_vlocals);

  /* update the registers (1): reg-to-reg moves and exchanges */
  memset(pops, -1, sizeof(pops));
  for (i=0; i&lt;REG_TOTAL; i++)
    {
      vinfo_t* a = dm.copy_regs[i];
      if (a != NULL)
        {
          char rg = RUNTIME_REG(a);
          if (rg != REG_NONE)
            {
              if (rg != i)
                {
                  vinfo_t* c = REG_NUMBER(po, i);
                  if (c != NULL)
                    {
                      SET_RUNTIME_REG_TO(c, rg);
                      REG_NUMBER(po, rg) = c;
                      XCHG_REGS(i, rg);
                    }
                  else
                    LOAD_REG_FROM_REG(i, rg);
                  /* an update is omitted because we are about to
                     release 'this' anyway: 'REG_NUMBER(po, i) = a;' */
                }
              dm.copy_regs[i] = NULL;
            }
          else
            {  /* prepare the step (2) below by looking for registers
                  whose source is near the top of the stack */
              int from_tos = po-&gt;stack_depth - RUNTIME_STACK(a);
              extra_assert(from_tos &gt;= 0);
              if (from_tos &lt; REG_TOTAL*sizeof(void*))
                {
                  char* target = pops + (from_tos / sizeof(void*));
                  if (*target == -1)
                    *target = i;
                  else
                    *target = -2;
                }
            }
        }
    }
  /* update the registers (2): stack-to-register POPs */
  for (i=0; pops[i]&gt;=0 || pops[i+1]&gt;=0; i++)
    {
      char reg = pops[i];
      if (reg&lt;0)
        {  /* If there is only one 'garbage' stack entry, POP it as well.
              If there are more, give up and use regular MOVs to load the rest */
          po-&gt;stack_depth -= 4;
          reg = pops[++i];
          POP_REG(reg);
        }
      POP_REG(reg);
      dm.copy_regs[(int) reg] = NULL;
      po-&gt;stack_depth -= 4;
    }
  /* update the registers (3): stack-to-register loads */
  for (i=0; i&lt;REG_TOTAL; i++)
    {
      vinfo_t* a = dm.copy_regs[i];
      if (a != NULL)
        LOAD_REG_FROM_EBP_BASE(i, RUNTIME_STACK(a));
    }

  /* done */
  STACK_CORRECTION(sdepth - po-&gt;stack_depth);
  if (code &gt; dm.code_limit)  /* start a new buffer if we wrote past the end */
    code = data_new_buffer(code, &amp;dm);
  JUMP_TO(target_codebuf-&gt;codeptr);
  
  /* start a new buffer if the last JUMP_TO overflowed,
     but not if we had no room at all in the first place. */
  if (code &gt; dm.code_limit &amp;&amp; po-&gt;codelimit != NULL)
    code = data_new_buffer(code, &amp;dm);
  
  PyCore_FREE(dm.usages);
  psyco_stabilize(target_codebuf);
  if (dm.private_codebuf == NULL)
    Py_INCREF(target_codebuf);      /* no new buffer created */
  else
    {
      SHRINK_CODE_BUFFER(dm.private_codebuf, code - dm.code_origin,
                         "unify");
      *target = dm.private_codebuf;
      /* add a jump from the original code buffer to the new one */
      code = po-&gt;code;
      JUMP_TO(dm.private_codebuf-&gt;codeptr);
      psyco_dump_code_buffers();
    }
  PsycoObject_Delete(po);
  return code;
}
</t>
<t tx="T126">CodeBufferObject* psyco_unify_code(PsycoObject* po, CodeBufferObject* target)
{
  /* simplified interface to psyco_unify() without using a previously
     existing code buffer. */

  code_t localbuf[GUARANTEED_MINIMUM];
  /* relies on the fact that psyco_unify() has no room at all in localbuf.
     Anything but the final JMP will trigger the creation of a new code
     buffer. */
  po-&gt;code = localbuf;
  po-&gt;codelimit = NULL;
  psyco_unify(po, &amp;target);
  return target;
}
</t>
<t tx="T127">@ **************************************************************/
** Promotion and un-promotion ***/
**************************************************************/

</t>
<t tx="T128">@ ****************************************************************/
** Promotion of a run-time variable into a fixed ***/
** compile-time one ***/
@c

Promotion of a run-time variable into a fixed compile-time one

typedef struct { /* produced at compile time and read by the dispatcher */
  PsycoObject* po;        /* state before promotion */
  vinfo_t* fix;           /* variable to promote */
  PyObject* spec_dict;    /* local cache (promotions to already-seen values) */
  long kflags;            /* SkFlagXxx to use in new source_known_t */
#ifdef CODE_DUMP_FILE
  long signature;         /* must be last, with spec_dict and kflags before */
#endif
} rt_promotion_t;

</t>
<t tx="T129">static CodeBufferObject* do_promotion_internal(rt_promotion_t* fs, long value,
                                               PyObject* key)
{
  CodeBufferObject* codebuf;
  vinfo_t* v;
  PsycoObject* newpo;
  PsycoObject* po = fs-&gt;po;

  /* get a copy of the compiler state */
  newpo = PsycoObject_Duplicate(po);
  if (newpo == NULL)
    OUT_OF_MEMORY();
  /* store the copy back into 'fs' and use the old 'po' to compile.
     We do so because in 'newpo' all 'tmp' fields are now NULL,
     but no longer in 'po'. */
  fs-&gt;po = newpo;
  v = fs-&gt;fix;      /* get the variable we will promote to compile-time... */
  fs-&gt;fix = v-&gt;tmp; /*     ...and update 'fs' with its copy in 'newpo'     */
  
  /* fix the value of 'v' */
  CHKTIME(v-&gt;source, RunTime);   /* from run-time to compile-time */
  extra_assert(RUNTIME_REG_IS_NONE(v));   /* taken care of in
                                             finish_promotion() */
  if ((fs-&gt;kflags &amp; SkFlagPyObj) != 0)
    Py_INCREF((PyObject*) value);
  v-&gt;source = CompileTime_NewSk(sk_new(value, fs-&gt;kflags));

  /* compile from this new state, in which 'v' has been promoted to
     compile-time. */
  codebuf = psyco_compile_code(po);

  /* store the new code buffer into the local cache */
  if (PyDict_SetItem(fs-&gt;spec_dict, key, (PyObject*) codebuf))
    OUT_OF_MEMORY();
  Py_DECREF(codebuf);  /* there is a reference left
                          in the dictionary */
  psyco_dump_code_buffers();
  return codebuf;
}
</t>
<t tx="T130">@ NOTE: the following two functions must be as fast as possible, because they are called from the run-time code even during normal (non-compiling) execution. */
@c

static code_t* do_promotion_long(rt_promotion_t* fs, long value)
{
  /* need a PyObject* key for the local cache dictionary */
  CodeBufferObject* codebuf;
  PyObject* key = PyInt_FromLong(value);
  if (key == NULL)
    OUT_OF_MEMORY();

  /* have we already seen this value? */
  codebuf = (CodeBufferObject*) PyDict_GetItem(fs-&gt;spec_dict, key);
  if (codebuf == NULL)   /* no -&gt; we must build new code */
    codebuf = do_promotion_internal(fs, value, key);
  Py_DECREF(key);
  return codebuf-&gt;codeptr;   /* done -&gt; jump to codebuf */
}
</t>
<t tx="T131">static code_t* do_promotion_pyobj(rt_promotion_t* fs, PyObject* key)
{
  CodeBufferObject* codebuf;

  /* have we already seen this value? */
  codebuf = (CodeBufferObject*) PyDict_GetItem(fs-&gt;spec_dict, key);
  if (codebuf == NULL)   /* no -&gt; we must build new code */
    codebuf = do_promotion_internal(fs, (long) key, key);
  return codebuf-&gt;codeptr;   /* done -&gt; jump to codebuf */
}
</t>
<t tx="T132">DEFINEFN
code_t* psyco_finish_promotion(PsycoObject* po, vinfo_t* fix, long kflags)
{
  int xsource;
  rt_promotion_t* fs;
  void* do_promotion;
  PyObject* d = PyDict_New();
  if (d == NULL)
    OUT_OF_MEMORY();

  xsource = fix-&gt;source;
  BEGIN_CODE
  if (!RSOURCE_REG_IS_NONE(xsource))  /* will soon no longer be RUN_TIME */
    {
      REG_NUMBER(po, RSOURCE_REG(xsource)) = NULL;
      SET_RUNTIME_REG_TO_NONE(fix);
    }
  SAVE_REGS_FN_CALLS;  /* save the registers EAX, ECX and EDX if needed
                          and mark them invalid because of the CALL below */
  CALL_SET_ARG_FROM_RT(xsource, 1, 2);  /* argument index 1 out of total 2 */
  END_CODE

  /* write the code that calls the proxy 'do_promotion' */
  if ((kflags &amp; SkFlagPyObj) == 0)
    do_promotion = &amp;do_promotion_long;
  else
    do_promotion = &amp;do_promotion_pyobj;
  fs = (rt_promotion_t*) psyco_jump_proxy(po, do_promotion, 0, 2);

  /* fill in the constant structure that 'do_promotion' will get as parameter */
  clear_tmp_marks(&amp;po-&gt;vlocals);
  psyco_assert_coherent(po);
  fs-&gt;po = po;    /* don't release 'po' */
  fs-&gt;fix = fix;
  fs-&gt;spec_dict = d;
  fs-&gt;kflags = kflags;
#ifdef CODE_DUMP_FILE
  fs-&gt;signature = SPEC_DICT_SIGNATURE;
#endif
  return (code_t*)(fs+1);  /* end of code == end of 'fs' structure */
}
</t>
<t tx="T133">@ ****************************************************************/
** Promotion of certain run-time values into ***/
** compile-time ones (promotion only occurs for certain ***/
** values, e.g. for types that we know how to optimize). ***/
@c

typedef struct { /* produced at compile time and read by the dispatcher */
  fixed_switch_t* rts;    /* special values */
  PsycoObject* po;        /* state before promotion */
  vinfo_t* fix;           /* variable to promote */
  long kflags;            /* flags after promotion */
  code_t* switchcodeend;  /* end of the private copy of the switch code */
} rt_fixed_switch_t;

</t>
<t tx="T134">static code_t* do_fixed_switch(rt_fixed_switch_t* rtfxs, long value)
{
  int item;
  CodeBufferObject* codebuf;
  fixed_switch_t* rts = rtfxs-&gt;rts;
  vinfo_t* v;
  PsycoObject* newpo;
  PsycoObject* po = rtfxs-&gt;po;

  /* get a copy of the compiler state */
  newpo = psyco_duplicate(po);
  /* store the copy back into rtfxs and use the old 'po' to compile.
     We do so because in 'newpo' all 'tmp' fields are now NULL,
     but no longer in 'po'. */
  rtfxs-&gt;po = newpo;
  v = rtfxs-&gt;fix;      /* get the variable we will promote to compile-time... */
  rtfxs-&gt;fix = v-&gt;tmp; /*   ...and update 'rtfxs' with its copy in 'newpo'    */

  item = psyco_switch_lookup(rts, value);   /* which value did we found? */
  if (item == -1)
    {
      /* none --&gt; go into 'default' mode */
      /* abuse the 'array' field to point to this fixed_switch_t
         to mean 'known to be none of the special values'.
         See known_to_be_default(). */
      v-&gt;array = NullArrayAt(rts-&gt;zero);
    }
  else
    {
      /* fix the value of 'v' to the one we found */
      CHKTIME(v-&gt;source, RunTime);   /* from run-time to compile-time */
      if (!RUNTIME_REG_IS_NONE(v))
        REG_NUMBER(po, RUNTIME_REG(v)) = NULL;
      v-&gt;source = CompileTime_NewSk(sk_new(value, rtfxs-&gt;kflags));
    }

  /* compile from this new state */
  codebuf = psyco_compile_code(po);

  /* store the pointer to the new code directly into
     the original code that jumped to do_fixed_switch() */
  psyco_fix_switch_case(rts, rtfxs-&gt;switchcodeend, item, codebuf-&gt;codeptr);
  
  return codebuf-&gt;codeptr;  /* jump there */
  /* XXX no place to store the reference to codebuf */
}
</t>
<t tx="T135">DEFINEFN
code_t* psyco_finish_fixed_switch(PsycoObject* po, vinfo_t* fix, long kflags,
                                  fixed_switch_t* special_values)
{
  rt_fixed_switch_t* rtfxs;
  code_t* switchcodeend;
  CHKTIME(fix-&gt;source, RunTime);
  extra_assert(fix-&gt;array-&gt;count == 0);  /* cannot fix array values,
                                            because of known_to_be_default() */
  BEGIN_CODE
  NEED_CC();
  RTVINFO_IN_REG(fix);
  switchcodeend = code = psyco_write_run_time_switch(special_values, code,
                                                     RUNTIME_REG(fix));
  
  TEMP_SAVE_REGS_FN_CALLS;   /* save all registers that might be clobbered */
  CALL_SET_ARG_FROM_RT(fix-&gt;source, 1, 2);/* argument index 1 out of total 2 */
  END_CODE

  /* write the code that calls the proxy 'do_fixed_switch' */
  rtfxs = (rt_fixed_switch_t*) psyco_jump_proxy(po, &amp;do_fixed_switch, 1, 2);

  /* fill in the constant struct that 'do_fixed_switch' will get as parameter */
  clear_tmp_marks(&amp;po-&gt;vlocals);
  psyco_assert_coherent(po);
  rtfxs-&gt;rts = special_values;
  rtfxs-&gt;po = po;
  rtfxs-&gt;fix = fix;
  rtfxs-&gt;kflags = kflags;
  rtfxs-&gt;switchcodeend = switchcodeend;
  return (code_t*)(rtfxs+1);
}
</t>
<t tx="T136">@ ****************************************************************/
** Un-Promotion from non-fixed compile-time into run-time ***/
@c</t>
<t tx="T137">DEFINEFN
void psyco_unfix(PsycoObject* po, vinfo_t* vi)
{
  /* Convert 'vi' from compile-time-known to run-time-variable. */
  vinfo_t* newvi;
  source_known_t* sk;

  /*printf("psyco_unfix(%p, %p, %p)\n", po, code, vi);*/
  extra_assert(array_contains(&amp;po-&gt;vlocals, vi));
  CHKTIME(vi-&gt;source, CompileTime);

  newvi = make_runtime_copy(po, vi);
  /* make_runtime_copy() never fails for compile-time sources */
  extra_assert(newvi != NULL);

  /* release 'vi-&gt;source' and move 'newvi-&gt;source' into it */
  sk = CompileTime_Get(vi-&gt;source);
  if (sk-&gt;refcount1_flags &amp; SkFlagPyObj) {
    /* XXX can't release the PyObject anywhere, because we
       write a pointer to it in the code itself. We should
       somehow transfer the ownership of this reference to
       the CodeBufferObject. Fix me when implementing
       memory releasing! */
    sk-&gt;refcount1_flags &amp;= ~SkFlagPyObj;
  }
  sk_decref(sk);
  vinfo_move(po, vi, newvi);
}
</t>
<t tx="T138">/* this file includes all other .c and .h files.
   Its purpose is to provide a version of _psycomodule.so whose only
   exported (non-static) symbol is init_psyco().
   It also seems that the GDB debugger doesn't locate too well non-static
   symbols in shared libraries.
*/

/* means that all .c files are meant to be compiler together,
    with all symbols 'static' */
#define ALL_STATIC

/* disable all debugging code */
/*#define DISABLE_DEBUG*/


&lt;&lt; hack #includes &gt;&gt;


#ifdef HEAVY_MEM_CHECK
# include "linuxmemchk.c"
#endif


 /***************************************************************/
/***   Debug dumping of state                                  ***/
 /***************************************************************/

/* #ifdef PSYCO_DUMP */
/* static int psyco_dump() */
/* { */
/*   int i; */
/*   PyObject* source = psyco_ge_mainloop.fatlist; */
/*   FILE* f = fopen("psyco.dump", "wb"); */
/*   if (f == NULL) */
/*     return -1; */

/*   for (i=0; i&lt;PyList_Size(source); i++) */
/*     { */
/*       CodeBufferObject* codebuf = (CodeBufferObject*) PyList_GetItem(source, i); */
/*       int size; */
/*       assert(codebuf != NULL &amp;&amp; CodeBuffer_Check(codebuf)); */
/*       size = codebuf-&gt;codesize; */
/*       if (size == -1) */
/*         size = BIG_BUFFER_SIZE - GUARANTEED_MINIMUM; */
/*       fprintf(f, "CodeBufferObject %p %d %d\n", */
/*               codebuf-&gt;codeptr, codebuf-&gt;codesize, size); */
/*       fwrite(codebuf-&gt;codeptr, 1, size, f); */
/*     } */
  
/*   return fclose(f); */
/* } */
/* void* psyco_just_a_dummy_pointer = &amp;psyco_dump; */
/* #endif */
</t>
<t tx="T139">#include "psyco.h"

#include "Python/pycompiler.c"
#include "Python/pbltinmodule.c"

#include "Objects/pabstract.c"
#include "Objects/pdictobject.c"
#include "Objects/pfuncobject.c"
#include "Objects/pintobject.c"
#include "Objects/piterobject.c"
#include "Objects/plistobject.c"
#include "Objects/plongobject.c"
#include "Objects/pmethodobject.c"
#include "Objects/pobject.c"
#include "Objects/psycofuncobject.c"
#include "Objects/pstringobject.c"
#include "Objects/ptupleobject.c"

#include "codemanager.c"
#include "dispatcher.c"
#include "processor.c"
#include "vcompiler.c"
#include "mergepoints.c"
#include "pycencoding.c"
#include "psyco.c"   /* must be the last one for CODE_DUMP_AT_END_ONLY to work */
</t>
<t tx="T140">/* custom checking allocators a la Electric Fence */

&lt;&lt; linuxmemchk #includes &gt;&gt;
&lt;&lt; linuxmemchk declarations &gt;&gt;
@others
</t>
<t tx="T141">#include &lt;assert.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
</t>
<t tx="T142">#define PAGESIZE 4096
#define MALLOC_BIGBUFFER   PAGESIZE*16384


struct _alloc_s {
  void* ptr;
  int npages;
};
static void* _na_start = NULL;
static char* _na_cur;
</t>
<t tx="T143">static struct _alloc_s* _na_find(void* data)
{
  int err;
  long data1;
  struct _alloc_s* s;
  assert(_na_start+PAGESIZE &lt;= data &amp;&amp;
         data &lt; _na_start+MALLOC_BIGBUFFER-PAGESIZE);
  data1 = (long) data;
  data1 &amp;= ~(PAGESIZE-1);
  data1 -= PAGESIZE;
  err = mprotect((void*) data1, PAGESIZE, PROT_READ|PROT_WRITE);
  assert(!err);
  s = (struct _alloc_s*) data1;
  assert(s-&gt;npages &gt; 0);
  return s;
}
</t>
<t tx="T144">DEFINEFN
void* memchk_ef_malloc(int size)
{
  int err, npages = (size + PAGESIZE-1) / PAGESIZE + 1;
  struct _alloc_s* s;
  char* data;
  if (_na_start == NULL)
    {
      int fd = open("/dev/zero", O_RDWR);
      _na_start = mmap(NULL, MALLOC_BIGBUFFER, PROT_NONE, MAP_PRIVATE, fd, 0);
      assert(_na_start != MAP_FAILED);
      _na_cur = (char*) _na_start;
    }
  s = (struct _alloc_s*) _na_cur;
  _na_cur += npages * PAGESIZE;
  if (_na_cur &gt;= ((char*) _na_start) + MALLOC_BIGBUFFER)
    {
      fprintf(stderr, "Nothing wrong so far, but MALLOC_CHECK is running out of mmap'ed memory.\nIncrease MALLOC_BIGBUFFER.\n");
      assert(0);
    }
  err = mprotect(s, npages * PAGESIZE, PROT_READ|PROT_WRITE|PROT_EXEC);
  assert(!err);
  s-&gt;ptr = data = _na_cur - ((size+3)&amp;~3);
  s-&gt;npages = npages;
  err = mprotect(s, PAGESIZE, PROT_NONE);
  assert(!err);
  return data;
}
</t>
<t tx="T145">DEFINEFN
void memchk_ef_free(void* data)
{
  int err, npages;
  struct _alloc_s* s = _na_find(data);
  assert(s-&gt;ptr == data);
  npages = s-&gt;npages;
  s-&gt;npages = 0;
  err = mprotect(s, npages * PAGESIZE, PROT_NONE);
  assert(!err);
  //fprintf(stderr, "PyCore_FREE(%p): mprotect %p %x\n", data, s, npages*PAGESIZE);
}
</t>
<t tx="T146">DEFINEFN
void* memchk_ef_realloc(void* data, int nsize)
{
  int size;
  struct _alloc_s* s = _na_find(data);
  void* ndata = PyCore_MALLOC(nsize);

  assert(s-&gt;ptr == data);
  size = ((char*)s) + s-&gt;npages * PAGESIZE - (char*)data;
  memcpy(ndata, data, size&lt;nsize ? size : nsize);
  PyCore_FREE(data);
  return ndata;
}
</t>
<t tx="T147">#include "mergepoints.h"
#include "vcompiler.h"
#include &lt;opcode.h&gt;

@others
</t>
<t tx="T148">@ **************************************************************/
** Tables of code merge points ***/
**************************************************************/

for each code object we build a bitarray specifying which positions in the byte
code are potential merge points.

A "merge point" is an instruction which can be executed immediately after two
or more other instructions, typically jump targets. The respawn mecanisms (see
psyco_prepare_respawn()) require that a merge point be also added after each
instruction whose produced machine code might depend on external data. We
should also avoid too long uninterrupted ranges of instructions without a
single merge point. instructions that cause an unconditional jump:
@c

#define IS_JUMP_INSTR(op)    ((op) == BREAK_LOOP ||     \
                              (op) == RETURN_VALUE ||   \
                              (op) == JUMP_FORWARD ||   \
                              (op) == JUMP_ABSOLUTE ||  \
                              (op) == CONTINUE_LOOP ||  \
                              (op) == RAISE_VARARGS ||  \
                              0)

/* instructions with a target: */
#define HAS_JREL_INSTR(op)   ((op) == JUMP_FORWARD ||   \
                              (op) == JUMP_IF_FALSE ||  \
                              (op) == JUMP_IF_TRUE ||   \
                              (op) == FOR_LOOP ||       \
                              (op) == SETUP_LOOP ||     \
                              (op) == SETUP_EXCEPT ||   \
                              (op) == SETUP_FINALLY ||  \
                              0)
     
#define HAS_JABS_INSTR(op)   ((op) == JUMP_ABSOLUTE ||  \
                              (op) == CONTINUE_LOOP ||  \
                              0)

/* instructions whose target may be jumped to several times: */
#define HAS_J_MULTIPLE(op)   ((op) == SETUP_LOOP ||     \
                              (op) == SETUP_EXCEPT ||   \
                              (op) == SETUP_FINALLY ||  \
                              0)

/* instructions producing code dependent on the context: */
#define IS_CTXDEP_INSTR(op)  ((op) == LOAD_GLOBAL ||    \
                              0)

#define MAX_UNINTERRUPTED_RANGE   300  /* bytes of Python bytecode */</t>
<t tx="T149">DEFINEFN
char* psyco_get_merge_points(PyCodeObject* co)
{
  static PyObject* CodeMergePoints = NULL;
  PyObject* s;
  if (CodeMergePoints == NULL)
    {
      CodeMergePoints = PyDict_New();
      if (CodeMergePoints == NULL)
        OUT_OF_MEMORY();
    }

  /* cache results */
  s = PyDict_GetItem(CodeMergePoints, co-&gt;co_code);
  if (s == NULL)
    {
      int length = PyString_GET_SIZE(co-&gt;co_code);
      int bytelength = (length+7)/8;
      unsigned char* source = (unsigned char*) PyString_AS_STRING(co-&gt;co_code);
      char* target;
      char* paths = (char*) PyCore_MALLOC(length);
      int i, lasti, oparg = 0;
      if (paths == NULL)
        OUT_OF_MEMORY();
      memset(paths, 0, length);
      
      for (i=0; i&lt;length; )
        {
          unsigned char op = source[i++];
          if (HAS_ARG(op))
            {
              i += 2;
              oparg = (source[i-1]&lt;&lt;8) + source[i-2];
              if (op == EXTENDED_ARG)
                {
                  op = source[i++];
                  assert(HAS_ARG(op) &amp;&amp; op != EXTENDED_ARG);
                  i += 2;
                  oparg = oparg&lt;&lt;16 | ((source[i-1]&lt;&lt;8) + source[i-2]);
                }
              if (HAS_JREL_INSTR(op) &amp;&amp; paths[i+oparg] &lt; 2)
                {
                  if (HAS_J_MULTIPLE(op))
                    paths[i+oparg] = 2;
                  else
                    paths[i+oparg]++;
                }
              if (HAS_JABS_INSTR(op) &amp;&amp; paths[oparg] &lt; 2)
                {
                  if (HAS_J_MULTIPLE(op))
                    paths[oparg] = 2;
                  else
                    paths[oparg]++;
                }
              if (IS_CTXDEP_INSTR(op))
                paths[i] = 2;
            }
          if (!IS_JUMP_INSTR(op))
            paths[i]++;
        }

      s = PyString_FromStringAndSize(NULL, bytelength);
      if (s == NULL)
        OUT_OF_MEMORY();
      target = PyString_AS_STRING(s);
      memset(target, 0, bytelength);

/*       printf("mergepoints.c: "); */
      lasti = 0;
      for (i=0; i&lt;length; i++)
        if (paths[i] &gt; 1 || (i-lasti &gt; MAX_UNINTERRUPTED_RANGE &amp;&amp; paths[i] &gt; 0))
          {
            lasti = i;
            SET_ARRAY_BIT(target, i);
/*             printf("[%d]", i); */
          }
/*       printf("\n"); */
      
      PyCore_FREE(paths);
      if (PyDict_SetItem(CodeMergePoints, co-&gt;co_code, s))
        OUT_OF_MEMORY();
    }
  return PyString_AS_STRING(s);
}
</t>
<t tx="T150">#include "processor.h"
#include "vcompiler.h"
#include "codemanager.h"
#include "Python/pycompiler.h"  /* for exception handling stuff */

&lt;&lt; processor declarations &gt;&gt;
@others
</t>
<t tx="T151">/* define to copy static machine code in the heap before running it.
   I've seen some Linux distributions in which the static data pages
   are not executable by default. */
#define COPY_CODE_IN_HEAP


/* We make no special use of any register but ESP, and maybe EBP
 * (if EBP_IF_RESERVED).
 * We consider that we can call C functions with arbitrary values in
 * all registers but ESP, and that only EAX, ECX and EDX will be
 * clobbered.
 * If EBP_IS_RESERVED is set to 1, the frame pointer is in EBP,
 * just as in normal C compiled functions. The instruction encodings
 * to access an EBP-relative memory address are one byte shorter than
 * the ESP-relative encodings.
 */

DEFINEVAR
reg_t RegistersLoop[REG_TOTAL] = {
  /* following REG_EAX: */  REG_ECX,
  /* following REG_ECX: */  REG_EDX,
  /* following REG_EDX: */  REG_EBX,
  /* following REG_EBX: */  EBP_IS_RESERVED ? REG_ESI : REG_EBP,
  /* following REG_ESP: */  REG_NONE,
  /* following REG_EBP: */  EBP_IS_RESERVED ? REG_NONE : REG_ESI,
  /* following REG_ESI: */  REG_EDI,
  /* following REG_EDI: */  REG_EAX };


/* glue code for psyco_processor_run(). */
static code_t glue_run_code[] = {
  0x8B, 0x44, 0x24, 4,          /*   MOV EAX, [ESP+4]  (code target)   */
  0x8B, 0x4C, 0x24, 8,          /*   MOV ECX, [ESP+8]  (stack end)     */
  0x8B, 0x54, 0x24, 12,         /*   MOV EDX, [ESP+12] (initial stack) */
  PUSH_REG_INSTR(REG_EBP),      /*   PUSH EBP        */
  PUSH_REG_INSTR(REG_EBX),      /*   PUSH EBX        */
  PUSH_REG_INSTR(REG_ESI),      /*   PUSH ESI        */
  PUSH_REG_INSTR(REG_EDI),      /*   PUSH EDI        */
  0xEB, +5,                     /*   JMP Label2      */
                                /* Label1:           */
  0x83, 0xE9, 4,                /*   SUB ECX, 4      */
  0xFF, 0x31,                   /*   PUSH [ECX]      */
                                /* Label2:           */
  0x39, 0xCA,                   /*   CMP EDX, ECX    */
  0x75, -9,                     /*   JNE Label1      */
  0xFF, 0xD0,                   /*   CALL *EAX     (callee removes args)  */
  POP_REG_INSTR(REG_EDI),       /*   POP EDI         */
  POP_REG_INSTR(REG_ESI),       /*   POP ESI         */
  POP_REG_INSTR(REG_EBX),       /*   POP EBX         */
  POP_REG_INSTR(REG_EBP),       /*   POP EBP         */
  0xC3,                         /*   RET             */
};

typedef PyObject* (*glue_run_code_fn) (code_t* code_target,
                                      long* stack_end,
                                      long* initial_stack);

#ifdef COPY_CODE_IN_HEAP
static glue_run_code_fn glue_run_code_1;
#else
# define glue_run_code_1 ((glue_run_code_fn) glue_run_code)
#endif</t>
<t tx="T152">DEFINEFN
PyObject* psyco_processor_run(CodeBufferObject* codebuf,
                              long initial_stack[])
{
  return glue_run_code_1(codebuf-&gt;codeptr,
                         initial_stack + codebuf-&gt;snapshot.fz_arguments_count,
                         initial_stack);
}
</t>
<t tx="T153">@ call a C function with a variable number of arguments */
@c

DEFINEVAR long (*psyco_call_var) (void* c_func, int argcount, long arguments[]);

static code_t glue_call_var[] = {
	0x53,			          /*   PUSH EBX                      */
	0x8B, 0x5C, 0x24, 12,	/*   MOV EBX, [ESP+12]  (argcount) */
	0x8B, 0x44, 0x24, 8,	 /*   MOV EAX, [ESP+8]   (c_func)   */
	0x09, 0xDB,		         /*   OR EBX, EBX                   */
	0x74, +16,		          /*   JZ Label1                     */
	0x8B, 0x54, 0x24, 16,	/*   MOV EDX, [ESP+16] (arguments) */
	0x8D, 0x0C, 0x9A,	    /*   LEA ECX, [EDX+4*EBX]          */
				          /* Label2:                         */
	0x83, 0xE9, 4,		      /*   SUB ECX, 4                    */
	0xFF, 0x31,		         /*   PUSH [ECX]                    */
	0x39, 0xCA,		         /*   CMP EDX, ECX                  */
	0x75, -9,		           /*   JNE Label2                    */
				          /* Label1:                         */
	0xFF, 0xD0,		         /*   CALL *EAX                     */
	0x8D, 0x24, 0x9C,	    /*   LEA ESP, [ESP+4*EBX]          */
	0x5B,			          /*   POP EBX                       */
	0xC3,			          /*   RET                           */
};


DEFINEFN
code_t* psyco_finish_return(PsycoObject* po, NonVirtualSource retval)
{
  code_t* code = po-&gt;code;
  if (retval != SOURCE_DUMMY)
    LOAD_REG_FROM(retval, REG_FUNCTIONS_RETURN);
	
  STACK_CORRECTION(INITIAL_STACK_DEPTH + 4 + po-&gt;arguments_count * 4
                   - po-&gt;stack_depth);
	
  code[0] = 0xC2;   // RET
  *(short*)(code+1) = po-&gt;arguments_count * 4;
  PsycoObject_Delete(po);
  return code+3;
}
</t>
<t tx="T154">#if 0   /* disabled */
	DEFINEFN
	code_t* psyco_emergency_jump(PsycoObject* po, code_t* code)
	{
	  STACK_CORRECTION(INITIAL_STACK_DEPTH - po-&gt;stack_depth);  /* at most 6 bytes */
	  code[0] = 0xE9;   /* JMP rel32 */
	  code += 5;
	  *(long*)(code-4) = ((code_t*)(&amp;PyErr_NoMemory)) - code;
	  /* total: at most 11 bytes. Check the value of EMERGENCY_PROXY_SIZE. */
	  return code;
	}
#endif</t>
<t tx="T155">DEFINEFN
void* psyco_jump_proxy(PsycoObject* po, void* fn, int restore, int nb_args)
{
  code_t* code = po-&gt;code;
  void* result;
  code_t* fixvalue;
  
  /* last pushed argument (will be the first argument of 'fn') */
  code[0] = 0x68;     /* PUSH IMM32	*/
  fixvalue = code+1;  /* will be filled below */
  code[5] = 0xE8;     /* CALL fn	*/
  code += 10;
  *(long*)(code-4) = ((code_t*)fn) - code;

  if (restore)
    {
      /* cancel the effect of any CALL_SET_ARG_xxx on po-&gt;stack_depth,
         to match the 'ADD ESP' instruction below */
      po-&gt;stack_depth -= 4*(nb_args-1);
      
      extra_assert(4*nb_args &lt; 128);   /* a safe guess */
      CODE_FOUR_BYTES(code,
                      0x83,       /* ADD		  */
                      0xC4,       /*     ESP,		  */
                      4*nb_args,  /*           4*nb_args  */
                      0);         /* not used             */
      code += 3;
      TEMP_RESTORE_REGS_FN_CALLS_AND_JUMP;
    }
  else
    {
      po-&gt;stack_depth += 4;  /* for the PUSH IMM32 above */
      code[0] = 0xFF;        /* JMP *EAX */
      code[1] = 0xE0;
      code += 2;
    }

    /* make 'fs' point just after the end of the code, aligned */
  result = (void*)(((long)code + 3) &amp; ~ 3);
#ifdef CODE_DUMP_FILE
  while (code != (char*) result)
    *code++ = 0xFE;   /* fill with invalid instructions */
#endif
  *(void**)fixvalue = result;    /* set value at code+1 above */
  return result;
}
</t>
<t tx="T156">@ DEFINEFN void psyco_stack_space_array(PsycoObject* po, vinfo_t** args, int cnt, bool with_reference) { int i = cnt; BEGIN_CODE ...... END_CODE while (i--) args[i] = vinfo_new(RunTime_NewStack(po_stack_depth - 4*i, REG_NONE, with_reference)); }*/

DEFINEFN */
code_t* insert_push_from_rt(PsycoObject* po, code_t* code1, */
long source, code_t* insert_at) */
{ */
code_t codebuffer[16]; */
code_t* code = codebuffer; */
int shiftby; */
PUSH_FROM_RT(source); */
shiftby = code - codebuffer; */
memmove(insert_at + shiftby, insert_at, code1-insert_at); */
return code1 + shiftby; */
} */
@c
</t>
<t tx="T157">DEFINEFN
vinfo_t* psyco_get_array_item(PsycoObject* po, vinfo_t* vi, int index)
{
  vinfo_t* result;
  NonVirtualSource source = vinfo_compute(vi, po);
  if (source == SOURCE_ERROR) return NULL;
  if (is_runtime(source))
    {
      reg_t src, rg;
      BEGIN_CODE
      RTVINFO_IN_REG(vi);
      src = RUNTIME_REG(vi);
      DELAY_USE_OF(src);
      NEED_FREE_REG(rg);
      code[0] = 0x8B;        /* MOV rg, [src + 4*index] */
      if (COMPACT_ENCODING &amp;&amp; index &lt; 128/4) {
        code[1] = 0x40 | (rg&lt;&lt;3) | src;
        code[2] = index*4;
        code += 3;
      }
      else {
        code[1] = 0x80 | (rg&lt;&lt;3) | src;
        *(long*)(code+2) = index*4;
        code += 6;
      }
      END_CODE
      result = new_rtvinfo(po, rg, false);
    }
  else {
    long value = ((long*)(CompileTime_Get(source)-&gt;value))[index];
    result = vinfo_new(CompileTime_New(value));
  }
  vinfo_setitem(po, vi, index, result);
  return result;
}
</t>
<t tx="T158">#define READ_ARRAY_ITEM_1(rg, _v, offset, _byte)     do {       \
  char _modrm;                                                  \
  long _value = (offset);                                       \
  if (!is_compiletime(_v-&gt;source))                              \
    {                                                           \
      reg_t _src;                                               \
      DELAY_USE_OF(rg);                                         \
      RTVINFO_IN_REG(_v);                                       \
      _src = RUNTIME_REG(_v);                                   \
      extra_assert(_value &gt;= 0);                                \
      if (COMPACT_ENCODING &amp;&amp; _value &lt; 128)                     \
        _modrm = 0x40 | _src;    /* MOV rg, [src + offset] */   \
      else                                                      \
        _modrm = 0x80 | _src;    /* MOV rg, [src + offset] */   \
    }                                                           \
  else                                                          \
    {                                                           \
      _modrm = 0x05;           /* MOV rg, [immed] */            \
      _value += KNOWN_SOURCE(_v)-&gt;value;                        \
    }                                                           \
  if (_byte) {                                                  \
    *code++ = 0x0F;                                             \
    code[0] = 0xB6;   /* MOVZX instead of MOV */                \
  }                                                             \
  else                                                          \
    code[0] = 0x8B;   /* MOV */                                 \
  code[1] = _modrm | ((rg)&lt;&lt;3);                                 \
  if (COMPACT_ENCODING &amp;&amp; (_modrm &amp; 0x40) != 0) {               \
    code[2] = _value;                                           \
    code += 3;                                                  \
  }                                                             \
  else {                                                        \
    *(long*)(code+2) = _value;                                  \
    code += 6;                                                  \
  }                                                             \
} while (0)

DEFINEFN
vinfo_t* psyco_read_array_item(PsycoObject* po, vinfo_t* vi, int index)
{
  reg_t rg;
  if (vinfo_compute(vi, po) == SOURCE_ERROR) return NULL;
  BEGIN_CODE
  NEED_FREE_REG(rg);
  READ_ARRAY_ITEM_1(rg, vi, index*4, 0);
  END_CODE
  return new_rtvinfo(po, rg, false);
}
</t>
<t tx="T159">DEFINEFN
vinfo_t* psyco_read_array_item_var(PsycoObject* po, vinfo_t* v0,
                                   vinfo_t* v1, int ofsbase, int shift)
{
  reg_t rg1;
  NonVirtualSource v0_source;
  NonVirtualSource v1_source;
  v0_source = vinfo_compute(v0, po);
  if (v0_source == SOURCE_ERROR) return NULL;
  v1_source = vinfo_compute(v1, po);
  if (v0_source == SOURCE_ERROR) return NULL;
  BEGIN_CODE
  NEED_FREE_REG(rg1);
  if (is_compiletime(v1_source))
    READ_ARRAY_ITEM_1(rg1, v0,
                      (CompileTime_Get(v1_source)-&gt;value &lt;&lt; shift) + ofsbase,
                      !shift);
  else
    {
      reg_t src0, src1;
      DELAY_USE_OF(rg1);
      RTVINFO_IN_REG(v1);
      src1 = RUNTIME_REG(v1);
      
      if (!is_compiletime(v0_source))
        {
          DELAY_USE_OF_2(rg1, src1);
          RTVINFO_IN_REG(v0);
          src0 = RUNTIME_REG(v0);
        }
      else
        src0 = 0x05;

      if (shift)
        code[0] = 0x8B;     /* MOV rg1, [ofsbase+(src0-or-immed)+src1&lt;&lt;shift] */
      else
        {
          *code++ = 0x0F;
          code[0] = 0xB6;   /* MOVZX instead of MOV */
        }
      code[1] = 0x04 | (rg1&lt;&lt;3);
      code[2] = (shift&lt;&lt;6) | (src1&lt;&lt;3) | src0;
      
      if (is_compiletime(v0_source))
        {
          /* MOV(ZX)  rg1, [base+src1&lt;&lt;shift] */
          *(long*)(code+3) = CompileTime_Get(v0_source)-&gt;value + ofsbase;
          code += 7;
        }
      else
        {
          code += 3;
          if (ofsbase != 0 || (!EBP_IS_RESERVED &amp;&amp; src0 == REG_EBP))
            {
              extra_assert(0 &lt;= ofsbase);
              if (COMPACT_ENCODING &amp;&amp; ofsbase &lt; 128)
                {
                  code[-2] |= 0x40;
                  *code++ = ofsbase;
                }
              else
                {
                  code[-2] |= 0x80;
                  *(long*)code = ofsbase;
                  code += 4;
                }
            }
        }
    }
  END_CODE
  return new_rtvinfo(po, rg1, false);
}
</t>
<t tx="T160">DEFINEFN
bool psyco_write_array_item(PsycoObject* po, vinfo_t* src, vinfo_t* v, int index)
{
  char rg, modrm;
  long value = index*4;
  if (is_virtualtime(v-&gt;source))
    {
      vinfo_incref(src);   /* done, bypass compute() */
      set_array_item(po, v, index, src);
    }
  else
    {
      if (vinfo_compute(src, po) == SOURCE_ERROR) return false;
      BEGIN_CODE
      if (!is_compiletime(v-&gt;source))
        {
          reg_t srcrg;
          RTVINFO_IN_REG(v);
          srcrg = RUNTIME_REG(v);
          DELAY_USE_OF(srcrg);
          if (COMPACT_ENCODING &amp;&amp; value &lt; 128)
            modrm = 0x40 | srcrg;    /* MOV [src + 4*item], ... */
          else
            modrm = 0x80 | srcrg;    /* MOV [src + 4*item], ... */
        }
      else
        {
          modrm = 0x05;           /* MOV [immed], ... */
          value += KNOWN_SOURCE(v)-&gt;value;
        }
      if (is_compiletime(src-&gt;source))
        code[0] = 0xC7;   /* MOV [...], imm32 */
      else
        {
          RTVINFO_IN_REG(src);
          rg = RUNTIME_REG(src);
          code[0] = 0x89;   /* MOV [...], rg */
          modrm |= (rg&lt;&lt;3);
        }
      code[1] = modrm;
      if (COMPACT_ENCODING &amp;&amp; (modrm &amp; 0x40) != 0) {
        code[2] = value;
        code += 3;
      }
      else {
        *(long*)(code+2) = value;
        code += 6;
      }
      if (is_compiletime(src-&gt;source)) {
        *(long*)code = KNOWN_SOURCE(src)-&gt;value;
        code += 4;
      }
      END_CODE
    }
  return true;
}
</t>
<t tx="T161">DEFINEFN
bool psyco_write_array_item_var(PsycoObject* po, vinfo_t* src,
                                vinfo_t* v0, vinfo_t* v1, int ofsbase)
{
  NonVirtualSource v1_source = vinfo_compute(v1, po);
  if (v1_source == SOURCE_ERROR) return false;
  if (is_compiletime(v1_source))
    psyco_write_array_item(po, src, v0,
                           CompileTime_Get(v1_source)-&gt;value + QUARTER(ofsbase));
  else
    {
      char src0, src1, rg1;
      NonVirtualSource src_source, v0_source;
      src_source = vinfo_compute(src, po);
      if (src_source == SOURCE_ERROR) return false;
      v0_source  = vinfo_compute(v0, po);
      if (v0_source == SOURCE_ERROR) return false;

      BEGIN_CODE
      if (!is_compiletime(src_source))
        {
          RTVINFO_IN_REG(src);
          rg1 = RUNTIME_REG(src);
          DELAY_USE_OF(rg1);
        }
      else
        rg1 = REG_NONE;
      
      RTVINFO_IN_REG(v1);
      src1 = RUNTIME_REG(v1);
      
      if (!is_compiletime(v0_source))
        {
          DELAY_USE_OF_2(rg1, src1);
          RTVINFO_IN_REG(v0);
          src0 = RUNTIME_REG(v0);
        }
      else
        src0 = 0x05;

      if (rg1 != REG_NONE)
        {
          code[0] = 0x89;    /* MOV [ofsbase+(src0-or-immed)+src1&lt;&lt;shift], rg1 */
          code[1] = 0x04 | (rg1&lt;&lt;3);
        }
      else
        {
          code[0] = 0xC7;    /* MOV [ the same as above ], immed */
          code[1] = 0x04 | (0&lt;&lt;3);
        }
      code[2] = (2&lt;&lt;6) | (src1&lt;&lt;3) | src0;
      if (is_compiletime(v0_source))
        {
          /* MOV  [base+src1&lt;&lt;shift], ... */
          *(long*)(code+3) = CompileTime_Get(v0_source)-&gt;value + ofsbase;
          code += 7;
        }
      else
        {
          code += 3;
          if (ofsbase != 0 || (!EBP_IS_RESERVED &amp;&amp; src0 == REG_EBP))
            {
              extra_assert(0 &lt;= ofsbase);
              if (COMPACT_ENCODING &amp;&amp; ofsbase &lt; 128)
                {
                  code[-2] |= 0x40;
                  *code++ = ofsbase;
                }
              else
                {
                  code[-2] |= 0x80;
                  *(long*)code = ofsbase;
                  code += 4;
                }
            }
        }
      
      if (is_compiletime(src_source))
        {
          /* MOV  [...], immed */
          *(long*)code = CompileTime_Get(src_source)-&gt;value;
          code += 4;
        }
      END_CODE
    }
  return true;
}
</t>
<t tx="T162">@ **************************************************************/
** Condition Codes (a.k.a. the processor 'flags' register) ***/
@c

typedef struct {
  source_virtual_t header;
  char cc;
} computed_cc_t;

</t>
<t tx="T163">/* internal, see NEED_CC() */
DEFINEFN
code_t* psyco_compute_cc(PsycoObject* po, code_t* code)
{
	vinfo_t* v = po-&gt;ccreg;
	computed_cc_t* cc = (computed_cc_t*) VirtualTime_Get(v-&gt;source);
	reg_t rg;

	NEED_FREE_BYTE_REG(rg);
	LOAD_REG_FROM_CONDITION(rg, cc-&gt;cc);

	v-&gt;source = RunTime_New(rg, false);
	REG_NUMBER(po, rg) = v;
	po-&gt;ccreg = NULL;
        return code;
}
</t>
<t tx="T164">static bool generic_computed_cc(PsycoObject* po, vinfo_t* v)
{
	extra_assert(po-&gt;ccreg == v);
        BEGIN_CODE
	code = psyco_compute_cc(po, code);
        END_CODE
	return true;
}
</t>
<t tx="T165">static computed_cc_t cc_functions_table[CC_TOTAL];

DEFINEFN
vinfo_t* psyco_vinfo_condition(PsycoObject* po, condition_code_t cc)
{
  vinfo_t* result;
  extra_assert(po-&gt;ccreg == NULL);
  if (cc &lt; CC_TOTAL)
    {
      result = vinfo_new(VirtualTime_New(&amp;cc_functions_table[(int)cc].header));
      po-&gt;ccreg = result;
    }
  else
    result = vinfo_new(CompileTime_New(cc == CC_ALWAYS_TRUE));
  return result;
}
</t>
<t tx="T166">DEFINEFN
condition_code_t psyco_vsource_cc(Source source)
{
  if (is_virtualtime(source))
    {
      computed_cc_t* s = (computed_cc_t*) VirtualTime_Get(source);
      long result = s - cc_functions_table;
      if (0 &lt;= result &amp;&amp; result &lt; CC_TOTAL)
        return (condition_code_t) result;
    }
  return CC_ALWAYS_FALSE;
}
</t>
<t tx="T167">#ifdef COPY_CODE_IN_HEAP
	#  define COPY_CODE(target, source, type)   do {	\
		char* c = PyCore_MALLOC(sizeof(source));	\
		if (c == NULL) {				\
			PyErr_NoMemory();			\
			return;					\
		}						\
		memcpy(c, source, sizeof(source));		\
		target = (type) c;				\
	} while (0)
#else
	#  define COPY_CODE(target, source, type)   (target = (type) source)
#endif</t>
<t tx="T168">static bool computed_promotion(PsycoObject* po, vinfo_t* v);  /* forward */

DEFINEFN
void psyco_processor_init()
{
  int i;
#ifdef COPY_CODE_IN_HEAP
  COPY_CODE(glue_run_code_1, glue_run_code, glue_run_code_fn);
#endif
  COPY_CODE(psyco_call_var, glue_call_var, long(*)(void*, int, long[]));
  for (i=0; i&lt;CC_TOTAL; i++)
    {
      cc_functions_table[i].header.compute_fn = &amp;generic_computed_cc;
      cc_functions_table[i].cc = (condition_code_t) i;
    }
  psyco_nonfixed_promotion.header.compute_fn = &amp;computed_promotion;
  psyco_nonfixed_promotion.fs = NULL;
  psyco_nonfixed_promotion.kflags = SkFlagFixed;
  psyco_nonfixed_pyobj_promotion.header.compute_fn = &amp;computed_promotion;
  psyco_nonfixed_pyobj_promotion.fs = NULL;
  psyco_nonfixed_pyobj_promotion.kflags = SkFlagFixed | SkFlagPyObj;
}
</t>
<t tx="T169">@ ****************************************************************/
** run-time switches ***/

The tactic is to precompute, given a list of the values we will have to switch
on, a binary tree search algorithm in machine code.

Example for the list of values [10, 20, 30, 40]:

    CMP EAX,30
	JG L1        ; if EAX &gt; 30, jump to L1
    JE Case30    ; if EAX == 30, jump to Case30
    CMP EAX,20
	JG L2        ; if 20 &lt; EAX &lt; 30, jump to L2
    JE Case20    ; if EAX == 20, jump to Case20
    CMP EAX,10
    JE Case10    ; if EAX == 10, jump to Case10
    JMP L2       ; otherwise, jump to L2
L1: CMP EAX,40
    JE Case40    ; if EAX == 40, jump to Case40
L2: JMP Default  ; &lt;--- 'supposed_end' below ; &lt;--- 'supposed_end+5'

All targets (Default and Case10 ... Case40) are initially set to point to the
end of this code block. At compile-time we will put at this place a proxy that
calls the dispatcher. The dispatcher then fixes the target in the code itself
as a shortcut for the next time that the same value is found. The second byte
of the CMP instructions must be dynamically corrected to mention the actual
register, which is not necessarily EAX. This is done by coding a linked list in
these bytes, each one holding the offset to the next CMP's second byte.
@c

struct fxcase_s {
  long value;             /* value to switch on */
  long index;             /* original (unsorted) index of this value */
};

</t>
<t tx="T170">static int fx_compare(const void* a, const void* b)
{
  long va = ((const struct fxcase_s*)a)-&gt;value;
  long vb = ((const struct fxcase_s*)b)-&gt;value;
  if (va &lt; vb)
    return -1;
  if (va &gt; vb)
    return 1;
  return 0;
}
</t>
<t tx="T171">#define FX_BASE_SIZE        5
#define FX_MAX_ITEM_SIZE    18
#define FX_LAST_JUMP_SIZE   2

static code_t* fx_writecases(code_t* code, code_t** lastcmp,
                             struct fxcase_s* fxc, long* fixtargets,
                             int first, int last, code_t* supposed_end)
{
  /* write the part of the switch corresponding to the cases between
     'first' (inclusive) and 'last' (exclusive).
     '*lastcmp' points to the last CMP instruction's second byte. */
  if (first == last)
    {
      /* jump to 'default:' */
      long offset;
      code += 2;
      offset = supposed_end - code;
      if (offset &lt; 128)
        {
          code[-2] = 0xEB;   /* JMP rel8 */
          code[-1] = offset;
        }
      else
        {
          code += 3;
          code[-5] = 0xE9;   /* JMP rel32 */
          *(long*)(code-4) = offset;
        }
    }
  else
    {
      code_t* code2 = code+1;
      long offset;
      int middle = (first+last)/2;
      COMMON_INSTR_IMMED(7, 0, fxc[middle].value); /* CMP reg, imm */
      if (*lastcmp != NULL)
        {
          extra_assert(code2 - *lastcmp &lt; 128);   /* CMP instructions are close
                                                    to each other */
          **lastcmp = code2 - *lastcmp;
        }
      *lastcmp = code2;
      if ((last-first) &gt; 2)
        {
          code += 2;
          code2 = fx_writecases(code+6, lastcmp, fxc, fixtargets,
                                first, middle, supposed_end);
          offset = code2 - code;
          if (offset &lt; 128)
            {
              code[-2] = 0x7F;    /* JG rel8 */
              code[-1] = offset;
            }
          else
            {
              code += 4;
              code2 = fx_writecases(code+6, lastcmp, fxc, fixtargets,
                                    first, middle, supposed_end);
              code[-6] = 0x0F;
              code[-5] = 0x8F;    /* JG rel32 */
              *(long*)(code-4) = code2 - code;
            }
          first = middle+1;
        }
      else
        {
          code2 = code+6;
          last = middle;
        }
      code[0] = 0x0F;
      code[1] = 0x84;    /* JE rel32 */
      code += 6;
      fixtargets[fxc[middle].index] = *(long*)(code-4) = (supposed_end+5) - code;
      code = fx_writecases(code2, lastcmp, fxc, fixtargets,
                           first, last, supposed_end);
    }
  return code;
}
</t>
<t tx="T172">static bool computed_promotion(PsycoObject* po, vinfo_t* v)
{
  /* uncomputable, but still use the address of computed_promotion() as a
     tag to figure out if a virtual source is a c_promotion_s structure. */
  return psyco_vsource_not_important.compute_fn(po, v);
}
</t>
<t tx="T173">DEFINEVAR struct c_promotion_s psyco_nonfixed_promotion;

DEFINEFN
bool psyco_vsource_is_promotion(VirtualTimeSource source)
{
  return VirtualTime_Get(source)-&gt;compute_fn == &amp;computed_promotion;
}
</t>
<t tx="T174">@ preparation for psyco_write_run_time_switch()
@c

DEFINEFN
int psyco_build_run_time_switch(fixed_switch_t* rts, long kflags,
				long values[], int count)
{
  code_t* code;
  code_t* codeend;
  code_t* codeorigin = NULL;
  struct fxcase_s* fxc = NULL;
  long* fixtargets = NULL;
  int i, size;
  
    /* a large enough buffer, will be shrunk later */
  codeorigin = (code_t*) PyCore_MALLOC(FX_BASE_SIZE + count * FX_MAX_ITEM_SIZE);
  if (codeorigin == NULL)
    goto out_of_memory;
  fxc = (struct fxcase_s*) PyCore_MALLOC(count *
                                         (sizeof(struct fxcase_s)+sizeof(long)));
  if (fxc == NULL)
    goto out_of_memory;
  /* 'fixtargets' lists the offset of the targets to fix in 'switchcode'.
     It is not stored in the array 'fxc' because it is indexed by the
     original index value, whereas 'fxc' is sorted by value. But we can
     put 'fixtargets' after 'fxc' in the same memory block. */
  fixtargets = (long*) (fxc+count);
  
  for (i=0; i&lt;count; i++)
    {
      fxc[i].value = values[i];
      fxc[i].index = i;
    }
  qsort(fxc, count, sizeof(struct fxcase_s), &amp;fx_compare);

  /* we try to emit the code by supposing that its end is at 'codeend'.
     Depending on the supposition this creates either short or long jumps,
     so it changes the size of the code. We begin by supposing that the
     end is at the beginning, and emit code over and over again until the
     real end stabilizes at the presupposed end position. (It can be proved
     to converge.) */
  codeend = codeorigin;
  while (1)
    {
      code_t* lastcmp = NULL;
      code = fx_writecases(codeorigin, &amp;lastcmp, fxc, fixtargets,
                           0, count, codeend);
      if (lastcmp != NULL)
        *lastcmp = 0;  /* end of list */
      if (code == (codeend + FX_LAST_JUMP_SIZE))
        break;   /* ok, it converged */
      codeend = code - FX_LAST_JUMP_SIZE;   /* otherwise try again */
    }
  /* the LAST_JUMP is a 'JMP rel8', which we do not need (it corresponds
     to the default case jumping to the supposed_end). We overwrite it
     with a 'JMP rel32' which jumps at supposed_end+5, that it,
     at the end of the block. */
  codeend[0] = 0xE9;    /* JMP rel32 */
  codeend += 5;
  *(long*)(codeend-4) = 0;

  size = codeend - codeorigin;
  codeorigin = (code_t*) PyCore_REALLOC(codeorigin, size);
  if (codeorigin == NULL)
    goto out_of_memory;

  rts-&gt;switchcodesize = size;
  rts-&gt;switchcode = codeorigin;
  rts-&gt;count = count;
  rts-&gt;fxc = fxc;
  rts-&gt;fixtargets = fixtargets;
  rts-&gt;zero = 0;
  rts-&gt;fixed_promotion.header.compute_fn = &amp;computed_promotion;
  rts-&gt;fixed_promotion.fs = rts;
  rts-&gt;fixed_promotion.kflags = kflags;
  return 0;

 out_of_memory:
  PyCore_FREE(fxc);
  PyCore_FREE(codeorigin);
  PyErr_NoMemory();
  return -1;
}
</t>
<t tx="T175">DEFINEFN
int psyco_switch_lookup(fixed_switch_t* rts, long value)
{
  /* look-up in the fxc array */
  struct fxcase_s* fxc = rts-&gt;fxc;
  int first = 0, last = rts-&gt;count;
  while (first &lt; last)
    {
      int middle = (first+last)/2;
      if (fxc[middle].value == value)
        return fxc[middle].index;   /* found, return index */
      if (fxc[middle].value &lt; value)
        first = middle+1;
      else
        last = middle;
    }
  return -1;    /* not found */
}
</t>
<t tx="T176">DEFINEFN
code_t* psyco_write_run_time_switch(fixed_switch_t* rts, code_t* code, char reg)
{
  /* Write the code that does a 'switch' on the prepared 'values'. */
  memcpy(code, rts-&gt;switchcode, rts-&gt;switchcodesize);

  if (rts-&gt;count &gt; 0)
    {
      /* Fix the 1st operand (register number) used by all CMP instruction */
      char new_value = 0xC0 | (7&lt;&lt;3) | reg;
      code_t* fix = code+1;   /* 2nd byte of first CMP instruction */
      while (1)
        {
          int offset = *fix;
          *fix = new_value;
          if (offset == 0)
            break;
          fix += offset;
        }
    }
  return code + rts-&gt;switchcodesize;
}
</t>
<t tx="T177">DEFINEFN
void psyco_fix_switch_case(
	fixed_switch_t* rts,
	code_t* code,
    int item,
	code_t* newtarget)
{
  /* Fix the target corresponding to the given case. */
  long fixtarget = item&lt;0 ? 0 : rts-&gt;fixtargets[item];
  code_t* fixme = code - fixtarget;
  *(long*)(fixme-4) = newtarget - fixme;
}

</t>
<t tx="T178">@ ****************************************************************/
** Calling C functions ***/
@c

#define MAX_ARGUMENTS_COUNT    16

</t>
<t tx="T179">DEFINEFN
vinfo_t* psyco_generic_call(PsycoObject* po, void* c_function,
                            int flags, const char* arguments, ...)
{
	char argtags[MAX_ARGUMENTS_COUNT];
	long args[MAX_ARGUMENTS_COUNT];
	int count, i;
	vinfo_t* vresult;
	bool has_refs = false;

	va_list vargs;

#ifdef HAVE_STDARG_PROTOTYPES
	va_start(vargs, arguments);
#else
	va_start(vargs);
#endif

	for (count=0; arguments[count]; count++) {
		long arg;
		NonVirtualSource src;
		char tag;
		vinfo_t* vi;
		
		extra_assert(count &lt;= MAX_ARGUMENTS_COUNT);
		arg = va_arg(vargs, long);
		tag = arguments[count];

		switch (tag) {
			
		case 'l':
			break;
			
		case 'v':
			/* Compute all values first */
			vi = (vinfo_t*) arg;
			src = vinfo_compute(vi, po);
			if (src == SOURCE_ERROR)
				goto Error;
			if (!is_compiletime(src)) {
				flags &amp;= ~CfPure;
			}
			else {
				/* compile-time: get the value */
				arg = CompileTime_Get(src)-&gt;value;
				tag = 'l';
			}
			break;

		case 'r':
			/* Push by-reference values in the stack now */
			vi = (vinfo_t*) arg;
			extra_assert(is_runtime(vi-&gt;source));
			if (getstack(vi-&gt;source) == RunTime_StackNone) {
				reg_t rg = getreg(vi-&gt;source);
				if (rg == REG_NONE) {
					/* for undefined sources, pushing
					   just any register will be fine */
					rg = REG_ANY_CALLER_SAVED;
				}
				BEGIN_CODE
				SAVE_REG_VINFO(vi, rg);
				END_CODE
			}
                        arg = RunTime_NewStack(getstack(vi-&gt;source),
                                               REG_NONE, false);
			has_refs = true;
			break;

                case 'a':
                case 'A':
			has_refs = true;
			break;

		default:
			Py_FatalError("unknown character argument in"
				      " psyco_generic_call()");
		}
		args[count] = arg;
		argtags[count] = tag;
	}
	va_end(vargs);

	if (flags &amp; CfPure) {
		/* calling a pure function with no run-time argument */
		long result;
#ifdef ALL_CHECKS
		if (has_refs)
			Py_FatalError("psyco_generic_call(): arg mode "
				      "incompatible with CfPure");
#endif
		result = psyco_call_var(c_function, count, args);
		if (PyErr_Occurred()) {
			psyco_virtualize_exception(po);
			goto Error;
		}
		
		switch (flags &amp; CfReturnMask) {

		case CfReturnNormal:
			vresult = vinfo_new(CompileTime_New(result));
			break;
			
		case CfReturnRef:
			vresult = vinfo_new(CompileTime_NewSk(sk_new(result,
								SkFlagPyObj)));
			break;

		case CfReturnFlag:
			if (result != 0)
				vresult = (vinfo_t*) CC_ALWAYS_TRUE;
			else
				vresult = (vinfo_t*) CC_ALWAYS_FALSE;
			break;

		default:
			Py_FatalError("psyco_generic_call(): bad flags");
		}
		return vresult;
	}

	if (has_refs) {
		/* we will need a trash register to compute the references
		   we push later. The following three lines prevent another
		   argument which would currently be in the same trash
		   register from being pushed from the register after we
		   clobbered it. */
		BEGIN_CODE
		NEED_REGISTER(REG_ANY_CALLER_SAVED);
		END_CODE
	}
	
	for (count=0; arguments[count]; count++) {
		if (argtags[count] == 'v') {
			/* We collect all the sources in 'args' now,
			   before SAVE_REGS_FN_CALLS which might move
			   some run-time values into the stack. In this
			   case the old copy in the registers is still
			   useable to PUSH it for the C function call. */
			RunTimeSource src = ((vinfo_t*)(args[count]))-&gt;source;
			args[count] = (long) src;
		}
	}

	BEGIN_CODE
	SAVE_REGS_FN_CALLS;
	for (i=count; i--; ) {
		switch (argtags[i]) {
			
		case 'v':
			CALL_SET_ARG_FROM_RT (args[i],   i, count);
			break;
			
		case 'r':
			LOAD_ADDRESS_FROM_RT (args[i],   REG_ANY_CALLER_SAVED);
			CALL_SET_ARG_FROM_RT (RunTime_New(REG_ANY_CALLER_SAVED,
							  false),  i, count);
			break;
			
		case 'a':
		case 'A':
		{
			vinfo_array_t* array = (vinfo_array_t*) args[i];
			bool with_reference = (argtags[i] == 'A');
			int j = array-&gt;count;
			if (j &gt; 0) {
				RESERVE_STACK_SPACE(j, REG_ANY_CALLER_SAVED);
			}
			while (j--) {
				array-&gt;items[j] = vinfo_new
					(RunTime_NewStack(po-&gt;stack_depth - 4*j,
							  REG_NONE,
							  with_reference));
			}
			CALL_SET_ARG_FROM_RT (RunTime_New(REG_ANY_CALLER_SAVED,
							  false),  i, count);
			break;
		}
			
		default:
			CALL_SET_ARG_IMMED   (args[i],   i, count);
			break;
		}
	}
	CALL_C_FUNCTION                      (c_function,   count);
	END_CODE

	switch (flags &amp; CfReturnMask) {

	case CfReturnNormal:
		vresult = new_rtvinfo(po, REG_FUNCTIONS_RETURN, false);
		break;

	case CfReturnRef:
		vresult = new_rtvinfo(po, REG_FUNCTIONS_RETURN, true);
		break;

	case CfReturnFlag:
		BEGIN_CODE
		CHECK_NONZERO_REG(REG_FUNCTIONS_RETURN);
		END_CODE
		vresult = (vinfo_t*) CHECK_NONZERO_CONDITION;
		break;

	default:
		vresult = (vinfo_t*) 1;  /* anything non-NULL */
	}
	
	if (flags &amp; CfPyErrMask)
		vresult = generic_call_check(po, flags, vresult);
	return vresult;

    Error:
	if ((flags &amp; CfReturnMask) == CfReturnFlag)
		return (vinfo_t*) CC_ERROR;
	else
		return NULL;
}
</t>
<t tx="T180">DEFINEFN
vinfo_t* psyco_call_psyco(PsycoObject* po, CodeBufferObject* codebuf,
			  Source argsources[])
{
	/* this is a simplified version of psyco_generic_call() which
	   assumes Psyco's calling convention instead of the C's. */
	int i, initial_depth;
	Source* p;
	BEGIN_CODE
	NEED_CC();
	for (i=0; i&lt;REG_TOTAL; i++)
		NEED_REGISTER(i);
	initial_depth = po-&gt;stack_depth;
	p = argsources;
	for (i=codebuf-&gt;snapshot.fz_arguments_count; i--; p++)
		CALL_SET_ARG_FROM_RT(*p, i,codebuf-&gt;snapshot.fz_arguments_count);
	CALL_C_FUNCTION(codebuf-&gt;codeptr,  codebuf-&gt;snapshot.fz_arguments_count);
	po-&gt;stack_depth = initial_depth;  /* callee removes arguments */
	END_CODE
	return generic_call_check(po, CfReturnRef|CfPyErrIfNull,
				  new_rtvinfo(po, REG_FUNCTIONS_RETURN, true));
}
</t>
<t tx="T181">@ ****************************************************************/
** Emit common instructions ***/
@c

</t>
<t tx="T182">DEFINEFN
condition_code_t integer_non_null(PsycoObject* po, vinfo_t* vi)
{
	condition_code_t result;
	
	if (is_virtualtime(vi-&gt;source)) {
		result = psyco_vsource_cc(vi-&gt;source);
		if (result != CC_ALWAYS_FALSE)
			return result;
		if (vinfo_compute(vi, po) == SOURCE_ERROR)
			return CC_ERROR;
	}
	if (is_compiletime(vi-&gt;source)) {
		if (KNOWN_SOURCE(vi)-&gt;value != 0)
			return CC_ALWAYS_TRUE;
		else
			return CC_ALWAYS_FALSE;
	}
	BEGIN_CODE
	CHECK_NONZERO_FROM_RT(vi-&gt;source);
	END_CODE
	return CHECK_NONZERO_CONDITION;
}
</t>
<t tx="T183">#define GENERIC_BINARY_INSTR_1(group, c_code, ovf, c_ovf)	\
{								\
  NonVirtualSource v1s, v2s;					\
  v2s = vinfo_compute(v2, po);					\
  if (v2s == SOURCE_ERROR) return NULL;				\
  v1s = vinfo_compute(v1, po);					\
  if (v1s == SOURCE_ERROR) return NULL;				\
  if (is_compiletime(v1s) &amp;&amp; is_compiletime(v2s))		\
    {								\
      long a = CompileTime_Get(v1s)-&gt;value;			\
      long b = CompileTime_Get(v2s)-&gt;value;			\
      long c = (c_code);					\
      if (!((ovf) &amp;&amp; (c_ovf)))     /* if not overflow */	\
        return vinfo_new(CompileTime_New(c));			\
    }								\
  else								\
    {								\
      reg_t rg;							\
      BEGIN_CODE						\
      NEED_CC();						\
      COPY_IN_REG(v1, rg);                   /* MOV rg, (v1) */	\
      COMMON_INSTR_FROM(group, rg, v2s);     /* XXX rg, (v2) */	\
      END_CODE							\
      if (!((ovf) &amp;&amp; runtime_condition_f(po, CC_O)))		\
        return new_rtvinfo(po, rg, false);			\
    }								\
  return NULL;							\
}

#define GENERIC_BINARY_INSTR_2(group, c_code)                           \
{                                                                       \
  NonVirtualSource v1s = vinfo_compute(v1, po);                         \
  if (v1s == SOURCE_ERROR) return NULL;				        \
  if (is_compiletime(v1s))                                              \
    {                                                                   \
      long a = CompileTime_Get(v1s)-&gt;value;                             \
      long b = value2;                                                  \
      long c = (c_code);                                                \
      return vinfo_new(CompileTime_New(c));                             \
    }                                                                   \
  else                                                                  \
    {                                                                   \
      reg_t rg;                                                         \
      BEGIN_CODE                                                        \
      NEED_CC();                                                        \
      COPY_IN_REG(v1, rg);                   /* MOV rg, (v1) */         \
      COMMON_INSTR_IMMED(group, rg, value2); /* XXX rg, value2 */       \
      END_CODE                                                          \
      return new_rtvinfo(po, rg, false);                                \
    }                                                                   \
}

DEFINEFN
vinfo_t* integer_add(PsycoObject* po, vinfo_t* v1, vinfo_t* v2, bool ovf)
  GENERIC_BINARY_INSTR_1(0, a+b, ovf, (c^a) &lt; 0 &amp;&amp; (c^b) &lt; 0)
DEFINEFN
vinfo_t* integer_add_i(PsycoObject* po, vinfo_t* v1, long value2)
  GENERIC_BINARY_INSTR_2(0, a+b)

DEFINEFN
vinfo_t* integer_sub(PsycoObject* po, vinfo_t* v1, vinfo_t* v2, bool ovf)
  GENERIC_BINARY_INSTR_1(5, a-b, ovf, (c^a) &lt; 0 &amp;&amp; (c^~b) &lt; 0)
DEFINEFN
vinfo_t* integer_sub_i(PsycoObject* po, vinfo_t* v1, long value2)
  GENERIC_BINARY_INSTR_2(5, a-b)

DEFINEFN
vinfo_t* integer_or(PsycoObject* po, vinfo_t* v1, vinfo_t* v2)
  GENERIC_BINARY_INSTR_1(1, a|b, false, false)

DEFINEFN
vinfo_t* integer_and(PsycoObject* po, vinfo_t* v1, vinfo_t* v2)
  GENERIC_BINARY_INSTR_1(4, a&amp;b, false, false)


#define GENERIC_UNARY_INSTR(rtmacro, c_code, ovf, c_ovf, cond_ovf)      \
{                                                                       \
  NonVirtualSource v1s = vinfo_compute(v1, po);                         \
  if (v1s == SOURCE_ERROR) return NULL;				        \
  if (is_compiletime(v1s))                                              \
    {                                                                   \
      long a = CompileTime_Get(v1s)-&gt;value;                             \
      long c = (c_code);                                                \
      if (!((ovf) &amp;&amp; (c_ovf)))                                          \
        return vinfo_new(CompileTime_New(c));                           \
    }                                                                   \
  else                                                                  \
    {                                                                   \
      reg_t rg;                                                         \
      BEGIN_CODE                                                        \
      NEED_CC();                                                        \
      COPY_IN_REG(v1, rg);                  /* MOV rg, (v1) */          \
      rtmacro;                              /* XXX rg       */          \
      END_CODE                                                          \
      if (!((ovf) &amp;&amp; runtime_condition_f(po, cond_ovf)))                \
        return new_rtvinfo(po, rg, false);                              \
    }                                                                   \
  return NULL;                                                          \
}

DEFINEFN
vinfo_t* integer_not(PsycoObject* po, vinfo_t* v1)
  GENERIC_UNARY_INSTR(UNARY_INSTR_ON_REG(3, rg), ~a,
                           false, false, CC_ALWAYS_FALSE)

DEFINEFN
vinfo_t* integer_neg(PsycoObject* po, vinfo_t* v1, bool ovf)
  GENERIC_UNARY_INSTR(UNARY_INSTR_ON_REG(2, rg), -a,
                           ovf, c == (-LONG_MAX-1), CC_O)

DEFINEFN
vinfo_t* integer_abs(PsycoObject* po, vinfo_t* v1, bool ovf)
  GENERIC_UNARY_INSTR(INT_ABS(rg, v1-&gt;source), a&lt;0 ? -a : a,
                           ovf, c == (-LONG_MAX-1), CHECK_ABS_OVERFLOW)


static const condition_code_t direct_results[16] = {
	  /*****   signed comparison      **/
          /* Py_LT: */  CC_L,
          /* Py_LE: */  CC_LE,
          /* Py_EQ: */  CC_E,
          /* Py_NE: */  CC_NE,
          /* Py_GT: */  CC_G,
          /* Py_GE: */  CC_GE,
	  /* (6)    */  CC_ERROR,
	  /* (7)    */  CC_ERROR,
	  /*****  unsigned comparison     **/
          /* Py_LT: */  CC_uL,
          /* Py_LE: */  CC_uLE,
          /* Py_EQ: */  CC_E,
          /* Py_NE: */  CC_NE,
          /* Py_GT: */  CC_uG,
          /* Py_GE: */  CC_uGE,
	  /* (14)   */  CC_ERROR,
	  /* (15)   */  CC_ERROR };

static const condition_code_t inverted_results[16] = {
	  /*****   signed comparison      **/
          /* inverted Py_LT: */  CC_G,
          /* inverted Py_LE: */  CC_GE,
          /* inverted Py_EQ: */  CC_E,
          /* inverted Py_NE: */  CC_NE,
          /* inverted Py_GT: */  CC_L,
          /* inverted Py_GE: */  CC_LE,
	  /* (6)             */  CC_ERROR,
	  /* (7)             */  CC_ERROR,
	  /*****  unsigned comparison     **/
          /* inverted Py_LT: */  CC_uG,
          /* inverted Py_LE: */  CC_uGE,
          /* inverted Py_EQ: */  CC_E,
          /* inverted Py_NE: */  CC_NE,
          /* inverted Py_GT: */  CC_uL,
          /* inverted Py_GE: */  CC_uLE,
	  /* (14)            */  CC_ERROR,
	  /* (15)            */  CC_ERROR };

inline condition_code_t immediate_compare(long a, long b, int py_op)
{
  switch (py_op) {
    case Py_LT:  return a &lt; b  ? CC_ALWAYS_TRUE : CC_ALWAYS_FALSE;
    case Py_LE:  return a &lt;= b ? CC_ALWAYS_TRUE : CC_ALWAYS_FALSE;
    case Py_EQ|COMPARE_UNSIGNED:
    case Py_EQ:  return a == b ? CC_ALWAYS_TRUE : CC_ALWAYS_FALSE;
    case Py_NE|COMPARE_UNSIGNED:
    case Py_NE:  return a != b ? CC_ALWAYS_TRUE : CC_ALWAYS_FALSE;
    case Py_GT:  return a &gt; b  ? CC_ALWAYS_TRUE : CC_ALWAYS_FALSE;
    case Py_GE:  return a &gt;= b ? CC_ALWAYS_TRUE : CC_ALWAYS_FALSE;

  case Py_LT|COMPARE_UNSIGNED:  return ((unsigned long) a) &lt;  ((unsigned long) b)
                                  ? CC_ALWAYS_TRUE : CC_ALWAYS_FALSE;
  case Py_LE|COMPARE_UNSIGNED:  return ((unsigned long) a) &lt;= ((unsigned long) b)
                                  ? CC_ALWAYS_TRUE : CC_ALWAYS_FALSE;
  case Py_GT|COMPARE_UNSIGNED:  return ((unsigned long) a) &gt;  ((unsigned long) b)
                                  ? CC_ALWAYS_TRUE : CC_ALWAYS_FALSE;
  case Py_GE|COMPARE_UNSIGNED:  return ((unsigned long) a) &gt;= ((unsigned long) b)
                                  ? CC_ALWAYS_TRUE : CC_ALWAYS_FALSE;
  default:
    Py_FatalError("immediate_compare(): bad py_op");
    return CC_ERROR;
  }
}
</t>
<t tx="T184">DEFINEFN
condition_code_t integer_cmp(PsycoObject* po, vinfo_t* v1,
                             vinfo_t* v2, int py_op)
{
  condition_code_t result;
  NonVirtualSource v1s;
  NonVirtualSource v2s;
  
  if (v1-&gt;source == v2-&gt;source)
    goto same_source;

  v1s = vinfo_compute(v1, po);
  if (v1s == SOURCE_ERROR) return CC_ERROR;
  v2s = vinfo_compute(v2, po);
  if (v2s == SOURCE_ERROR) return CC_ERROR;

  if (v1s == v2s)
    {
    same_source:
      /* comparing equal sources */
      switch (py_op &amp; ~ COMPARE_UNSIGNED) {
      case Py_LE:
      case Py_EQ:
      case Py_GE:
        return CC_ALWAYS_TRUE;
      default:
        return CC_ALWAYS_FALSE;
      }
    }
  if (is_compiletime(v1s))
    if (is_compiletime(v2s))
      {
        long a = CompileTime_Get(v1s)-&gt;value;
        long b = CompileTime_Get(v2s)-&gt;value;
        return immediate_compare(a, b, py_op);
      }
    else
      {
        NonVirtualSource tmp;
        /* invert the two operands because the processor has only CMP xxx,immed
           and not CMP immed,xxx */
        result = inverted_results[py_op];
        tmp = v1s;
        v1s = v2s;
        v2s = tmp;
      }
  else
    {
      result = direct_results[py_op];
    }
  BEGIN_CODE
  NEED_CC();
  if (is_compiletime(v2s))
    COMPARE_IMMED_FROM_RT(v1s, CompileTime_Get(v2s)-&gt;value); /* CMP v1, immed2 */
  else
    {
      RTVINFO_IN_REG(v1);         /* CMP v1, v2 */
      COMMON_INSTR_FROM_RT(7, getreg(v1-&gt;source), v2-&gt;source);
    }
  END_CODE
  return result;
}
</t>
<t tx="T185">DEFINEFN
condition_code_t integer_cmp_i(PsycoObject* po, vinfo_t* v1,
                               long value2, int py_op)
{
  NonVirtualSource v1s = vinfo_compute(v1, po);
  if (v1s == SOURCE_ERROR) return CC_ERROR;
  
  if (is_compiletime(v1s))
    {
      long a = CompileTime_Get(v1s)-&gt;value;
      return immediate_compare(a, value2, py_op);
    }
  else
    {
      BEGIN_CODE
      NEED_CC();
      COMPARE_IMMED_FROM_RT(v1s, value2);  /* CMP v1, immed2 */
      END_CODE
      return direct_results[py_op];
    }
}
</t>
<t tx="T186">#if 0
DEFINEFN      (not used)
vinfo_t* integer_seqindex(PsycoObject* po, vinfo_t* vi, vinfo_t* vn, bool ovf)
{
  NonVirtualSource vns, vis;
  vns = vinfo_compute(vn, po);
  if (vns == SOURCE_ERROR) return NULL;
  vis = vinfo_compute(vi, po);
  if (vis == SOURCE_ERROR) return NULL;
  
  if (!is_compiletime(vis))
    {
      reg_t rg, tmprg;
      BEGIN_CODE
      NEED_CC();
      NEED_FREE_REG(rg);
      LOAD_REG_FROM_RT(vis, rg);
      DELAY_USE_OF(rg);
      NEED_FREE_REG(tmprg);

      /* Increase 'rg' by 'vns' unless it is already in the range(0, vns). */
         /* CMP i, n */
      COMMON_INSTR_FROM(7, rg, vns);
         /* SBB t, t */
      COMMON_INSTR_FROM_RT(3, tmprg, RunTime_New(tmprg, false));
         /* AND t, n */
      COMMON_INSTR_FROM(4, tmprg, vns);
         /* SUB i, t */
      COMMON_INSTR_FROM_RT(5, rg, RunTime_New(tmprg, false));
         /* ADD i, n */
      COMMON_INSTR_FROM(0, rg, vns);
      END_CODE

      if (ovf &amp;&amp; runtime_condition_f(po, CC_NB))  /* if out of range */
        return NULL;
      return new_rtvinfo(po, rg, false);
    }
  else
    {
      long index = CompileTime_Get(vis)-&gt;value;
      long reqlength;
      if (index &gt;= 0)
        reqlength = index;  /* index is known, length must be greater than it */
      else
        reqlength = ~index;  /* idem for negative index */
      if (ovf)
        {
          /* test for out of range index -- more precisely, test that the
             length is not large enough for the known index */
          condition_code_t cc = integer_cmp_i(po, vn, reqlength, Py_LE);
          if (cc == CC_ERROR || runtime_condition_f(po, cc))
            return NULL;
        }
      if (index &gt;= 0)
        {
          vinfo_incref(vi);
          return vi;
        }
      else
        return integer_add_i(po, vn, index);
    }
}
#endif  /* 0 */</t>
<t tx="T187">DEFINEFN
vinfo_t* make_runtime_copy(PsycoObject* po, vinfo_t* v)
{
	reg_t rg;
	NonVirtualSource src = vinfo_compute(v, po);
	if (src == SOURCE_ERROR)
		return NULL;
	BEGIN_CODE
	NEED_FREE_REG(rg);
	LOAD_REG_FROM(src, rg);
	END_CODE
	return new_rtvinfo(po, rg, false);
}
</t>
<t tx="T188">#include "psyco.h"
#include "codemanager.h"
#include "vcompiler.h"
#include "dispatcher.h"
#include "processor.h"
#include "Python/pycompiler.h"
#include "Objects/ptupleobject.h"

&lt;&lt; psyco declarations &gt;&gt;

@others
</t>
<t tx="T189">#if defined(CODE_DUMP_FILE) &amp;&amp; defined(CODE_DUMP_AT_END_ONLY)
# undef psyco_dump_code_buffers
EXTERNFN void psyco_dump_code_buffers();
#endif

</t>
<t tx="T190">/***************************************************************/
/***   Frame and arguments building                            ***/
/***************************************************************/

DEFINEVAR PyObject* PyExc_PsycoError;
</t>
<t tx="T191">static int count_run_time_args(vinfo_array_t* source)
{
  /* returns an approxmation only (may return a bit too much because
     of shared structures counted several times) */
  int result = 0;
  int i = source-&gt;count;
  while (i--)
    {
      vinfo_t* a = source-&gt;items[i];
      if (a != NULL)
        {
          if (is_runtime(a-&gt;source))
            result++;
          if (a-&gt;array != NullArray)
            result += count_run_time_args(a-&gt;array);
        }
    }
  return result;
}
</t>
<t tx="T192">static void fix_run_time_args(PsycoObject * po, vinfo_array_t* source,
                              long* sources)
{
  int i = source-&gt;count;
  while (i--)
    {
      vinfo_t* a = source-&gt;items[i];
      if (a != NULL &amp;&amp; a-&gt;tmp != NULL)
        {
          if (is_runtime(a-&gt;source))
            {
              if (sources != NULL)
                sources[po-&gt;arguments_count] = a-&gt;source;
              po-&gt;arguments_count++;
              po-&gt;stack_depth += sizeof(long);
              /* arguments get borrowed references */
              a-&gt;tmp-&gt;source = RunTime_NewStack(po-&gt;stack_depth, REG_NONE,
                                                false);
            }
          a-&gt;tmp = NULL;
          if (a-&gt;array != NullArray)
            fix_run_time_args(po, a-&gt;array, sources);
        }
    }
}
</t>
<t tx="T193">DEFINEFN
PsycoObject* psyco_build_frame(PyFunctionObject* function,
                               vinfo_array_t* arginfo, int recursion,
                               long** sources)
{
  /* build a "frame" in a PsycoObject according to the given code object. */

  PyCodeObject* co = (PyCodeObject*) PyFunction_GET_CODE(function);
  PyObject* globals = PyFunction_GET_GLOBALS(function);
  PyObject* defaults = PyFunction_GET_DEFAULTS(function);
  PsycoObject* po;
  long* source1;
  int extras, i, minargcnt, inputargs;
  int ncells = PyTuple_GET_SIZE(co-&gt;co_cellvars);
  int nfrees = PyTuple_GET_SIZE(co-&gt;co_freevars);
  if (co-&gt;co_flags &amp; (CO_VARARGS | CO_VARKEYWORDS))
    {
      PyErr_SetString(PyExc_PsycoError, "* and ** arguments not supported yet");
      return NULL;
    }
  if (ncells != 0 || nfrees != 0)
    {
      PyErr_SetString(PyExc_PsycoError, "free and cell variables not supported yet");
      return NULL;
    }
  minargcnt = co-&gt;co_argcount - (defaults ? PyTuple_GET_SIZE(defaults) : 0);
  inputargs = arginfo-&gt;count;
  if (inputargs != co-&gt;co_argcount)
    {
      if (inputargs &lt; minargcnt || inputargs &gt; co-&gt;co_argcount)
        {
          int n = co-&gt;co_argcount &lt; minargcnt ? minargcnt : co-&gt;co_argcount;
          PyErr_Format(PyExc_PsycoError,
                       "%.200s() takes %s %d %sargument%s (%d given)",
                       PyString_AsString(co-&gt;co_name),
                       minargcnt == co-&gt;co_argcount ? "exactly" :
                         (inputargs &lt; n ? "at least" : "at most"),
                       n,
                       /*kwcount ? "non-keyword " :*/ "",
                       n == 1 ? "" : "s",
                       inputargs);
          return NULL;
        }

      /* fill missing arguments with default values */
      arginfo = array_grow1(arginfo, co-&gt;co_argcount);
      for (i=inputargs; i&lt;co-&gt;co_argcount; i++)
        /* references borrowed from the code object */
        arginfo-&gt;items[i] = vinfo_new(CompileTime_New((long) PyTuple_GET_ITEM
						       (defaults, i-minargcnt)));
    }
  
  extras = co-&gt;co_stacksize + co-&gt;co_nlocals + ncells + nfrees;

  po = PsycoObject_New();
  po-&gt;stack_depth = INITIAL_STACK_DEPTH;
  po-&gt;vlocals.count = NB_LOCALS;
  po-&gt;last_used_reg = REG_LOOP_START;
  po-&gt;pr.auto_recursion = recursion;

  /* make an array of size 'extra' for the locals and the stack */
  LOC_LOCALS_PLUS = vinfo_new(SOURCE_NOT_IMPORTANT);
  LOC_LOCALS_PLUS-&gt;array = array_new(extras);

  /* duplicate the array of arguments. If two arguments share some common
     part, they will also share it in the copy. */
  clear_tmp_marks(arginfo);
  duplicate_array(LOC_LOCALS_PLUS-&gt;array, arginfo);
  LOC_LOCALS_PLUS-&gt;array-&gt;count = extras;/*was overwritten by duplicate_array()*/

  /* all run-time arguments or argument parts must be corrected: in arginfo
     they have arbitrary sources, but in the new frame's sources they will
     have to be fetched from the machine stack, where the caller will have
     pushed them. */
  if (sources != NULL)
    {
      source1 = PyCore_MALLOC(count_run_time_args(arginfo) * sizeof(long));
      if (source1 == NULL)
        OUT_OF_MEMORY();
      *sources = source1;
    }
  else
    source1 = NULL;
  fix_run_time_args(po, arginfo, source1);
  
  /* the rest of locals is uninitialized */
  for (i=arginfo-&gt;count; i&lt;co-&gt;co_nlocals; i++)
    {
      vinfo_incref(psyco_viZero);
      LOC_LOCALS_PLUS-&gt;array-&gt;items[i] = psyco_viZero;
    }
  /* the rest of the array is the currently empty stack,
     set to NULL by array_new(). */

  array_delete(arginfo, NULL);
  
  /* store the code and globals objects */
  LOC_CODE = vinfo_new(CompileTime_NewSk(sk_new((long) co,
                                                SkFlagFixed | SkFlagPyObj)));
  Py_INCREF(co);  /* reference in LOC_CODE */
  LOC_GLOBALS = vinfo_new(CompileTime_NewSk(sk_new((long) globals,
                                                SkFlagFixed | SkFlagPyObj)));
  Py_INCREF(globals); /* reference in LOC_GLOBALS */

  /* initialize the remaining variables */
  LOC_NEXT_INSTR = vinfo_new(CompileTime_NewSk(sk_new(0, SkFlagFixed)));
  pyc_data_build(po);
  
  po-&gt;stack_depth += sizeof(long);  /* count the CALL return address */
  psyco_assert_coherent(po);
  return po;
}
</t>
<t tx="T194">DEFINEFN
vinfo_t* psyco_call_pyfunc(PsycoObject* po, PyFunctionObject* function,
                           vinfo_t* arg_tuple, int recursion)
{
  CodeBufferObject* codebuf;
  PsycoObject* mypo;
  vinfo_array_t* arginfo;
  Source* sources;
  vinfo_t* result;
  int i;

  int tuple_size = PsycoTuple_Load(arg_tuple);
  if (tuple_size == -1)
    {
      /* XXX calling with an unknown-at-compile-time number of arguments
         is not implemented, revert to the default behaviour */
      return psyco_generic_call(po, PyFunction_Type.tp_call,
                                CfReturnRef|CfPyErrIfNull,
                                "vvl", function, arg_tuple, NULL);
    }

  /* prepare a frame */
  arginfo = array_new(tuple_size);
  for (i=0; i&lt;tuple_size; i++)
    {
      vinfo_t* v = PsycoTuple_GET_ITEM(arg_tuple, i);
      arginfo-&gt;items[i] = v;
      vinfo_incref(v);
    }
  mypo = psyco_build_frame(function, arginfo, recursion, &amp;sources);
  if (mypo == NULL)
    {
      psyco_virtualize_exception(po);
      return NULL;
    }

  /* compile the function (this frees mypo) */
  codebuf = psyco_compile_code(mypo);

  /* get the run-time argument sources and push them on the stack
     and write the actual CALL */
  result = psyco_call_psyco(po, codebuf, sources);
  PyCore_FREE(sources);
  return result;
}
</t>
<t tx="T195">@ **************************************************************/
** PsycoFunctionObjects ***/
**************************************************************/
</t>
<t tx="T196">DEFINEFN
PsycoFunctionObject* psyco_PsycoFunction_New(PyFunctionObject* func, int rec)
{
	PsycoFunctionObject* result = PyObject_GC_New(PsycoFunctionObject,
						      &amp;PsycoFunction_Type);
	if (result != NULL) {
		Py_INCREF(func);
		result-&gt;psy_func = func;
		result-&gt;psy_recursion = rec;
		_PyObject_GC_TRACK(result);
	}
	return result;
}
</t>
<t tx="T197">static void psycofunction_dealloc(PsycoFunctionObject* self)
{
	_PyObject_GC_UNTRACK(self);
	Py_DECREF(self-&gt;psy_func);
	PyObject_GC_Del(self);
}
</t>
<t tx="T198">static PyObject* psycofunction_repr(PsycoFunctionObject* self)
{
	char buf[100];
	if (self-&gt;psy_func-&gt;func_name == Py_None)
		sprintf(buf, "&lt;anonymous psyco function at %p&gt;", self);
	else
		sprintf(buf, "&lt;psyco function %s at %p&gt;",
			PyString_AsString(self-&gt;psy_func-&gt;func_name), self);
	return PyString_FromString(buf);
}
</t>
<t tx="T199">static PyObject* psycofunction_call(PsycoFunctionObject* self,
				    PyObject* arg, PyObject* kw)
{
	PyFunctionObject* function = self-&gt;psy_func;
	CodeBufferObject* codebuf;
	PsycoObject* po;
	long* initial_stack;
	PyObject* result;
	vinfo_array_t* arginfo;
	int i;
	
	if (kw != NULL &amp;&amp; PyDict_Check(kw) &amp;&amp; PyDict_Size(kw) &gt; 0) {
		PyErr_SetString(PyExc_PsycoError,
				"keyword arguments not supported yet");
		return NULL;
	}

	/* make an array of run-time values */
	i = PyTuple_GET_SIZE(arg);
	arginfo = array_new(i);
	while (i--) {
		/* arbitrary values for the source */
		arginfo-&gt;items[i] = vinfo_new(SOURCE_DUMMY);
	}
	
	/* make a "frame" */
	po = psyco_build_frame(function, arginfo, self-&gt;psy_recursion, NULL);
	if (po == NULL)
		return NULL;
	
	/* compile the function */
	codebuf = psyco_compile_code(po);
	
	/* get the actual arguments */
	assert(codebuf-&gt;snapshot.fz_arguments_count == PyTuple_GET_SIZE(arg));
	initial_stack = (long*) (&amp;PyTuple_GET_ITEM(arg, 0));

	/* run! */
	result = psyco_processor_run(codebuf, initial_stack);
	
	Py_DECREF(codebuf);
	psyco_trash_object(NULL);  /* free any trashed object now */

#ifdef CODE_DUMP_FILE
        psyco_dump_code_buffers();
#endif

	return result;
}
</t>
<t tx="T200">static int psycofunction_traverse(PsycoFunctionObject *f,
				  visitproc visit, void *arg)
{
	return visit((PyObject*) f-&gt;psy_func, arg);
}
</t>
<t tx="T201">DEFINEVAR
PyTypeObject PsycoFunction_Type = {
	PyObject_HEAD_INIT(NULL)
	0,					/*ob_size*/
	"Psyco_function",			/*tp_name*/
	sizeof(PsycoFunctionObject),		/*tp_basicsize*/
	0,					/*tp_itemsize*/
	/* methods */
	(destructor)psycofunction_dealloc,	/*tp_dealloc*/
	0,					/*tp_print*/
	0,					/*tp_getattr*/
	0,					/*tp_setattr*/
	0,					/*tp_compare*/
	(reprfunc)psycofunction_repr,		/*tp_repr*/
	0,					/*tp_as_number*/
	0,					/*tp_as_sequence*/
	0,					/*tp_as_mapping*/
	0,					/*tp_hash*/
	(ternaryfunc)psycofunction_call,	/*tp_call*/
	0,					/* tp_str */
	0,					/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */
	0,					/* tp_doc */
	(traverseproc)psycofunction_traverse,	/* tp_traverse */
	0,					/* tp_clear */
	0,					/* tp_richcompare */
};
</t>
<t tx="T202"> /***************************************************************/
/***   Implementation of the '_psyco' built-in module          ***/
 /***************************************************************/

/* NB: it would be nice to set _psyco.proxy to the PsycoFunction_Type
   as the following function is nothing more than a constructor,
   but this is incompatible with Python versions &lt;2.2b1
*/
static PyObject* Psyco_proxy(PyObject* self, PyObject* args)
{
	int recursion = 0;
	PyFunctionObject* function;
	
	if (!PyArg_ParseTuple(args, "O!|i",
			      &amp;PyFunction_Type, &amp;function,
			      &amp;recursion))
		return NULL;

	return (PyObject*) psyco_PsycoFunction_New(function, recursion);
}
</t>
<t tx="T203">#ifdef CODE_DUMP_FILE
@others
#endif</t>
<t tx="T204">struct sd_s {
  PyObject* spec_dict;
  long kflags;
  long signature;
};

static void vinfo_array_dump(vinfo_array_t* array, FILE* f, PyObject* d)
{
  int i = array-&gt;count;
  fprintf(f, "%d\n", i);
  while (i--)
    {
      vinfo_t* vi = array-&gt;items[i];
      PyObject* key = PyInt_FromLong((long)vi);
      assert(key);
      fprintf(f, "%ld\n", (long)vi);
      if (vi != NULL &amp;&amp; !PyDict_GetItem(d, key))
        {
          switch (gettime(vi-&gt;source)) {
          case CompileTime:
            fprintf(f, "ct %ld %ld\n",
                    CompileTime_Get(vi-&gt;source)-&gt;refcount1_flags,
                    CompileTime_Get(vi-&gt;source)-&gt;value);
            break;
          case RunTime:
            fprintf(f, "rt %ld\n", vi-&gt;source);
            break;
          case VirtualTime:
            fprintf(f, "vt %p\n", VirtualTime_Get(vi-&gt;source));
            break;
          default:
            assert(0);
          }
          PyDict_SetItem(d, key, Py_None);
          vinfo_array_dump(vi-&gt;array, f, d);
        }
      Py_DECREF(key);
    }
}
</t>
<t tx="T205">DEFINEFN
void psyco_dump_code_buffers()
{
  FILE* f = fopen(CODE_DUMP_FILE, "wb");
  if (f != NULL)
    {
      CodeBufferObject* obj;
      PyObject *exc, *val, *tb;
      PyErr_Fetch(&amp;exc, &amp;val, &amp;tb);
      debug_printf(("psyco: writing " CODE_DUMP_FILE "\n"));
      for (obj=psyco_codebuf_chained_list; obj != NULL; obj=obj-&gt;chained_list)
        {
          PyObject* d;
          int nsize = obj-&gt;codeend - obj-&gt;codeptr;
          PyCodeObject* co;
          if (obj-&gt;snapshot.fz_vlocals.count &gt; INDEX_LOC_CODE)
            co = (PyCodeObject*)(CompileTime_Get(
                 obj-&gt;snapshot.fz_vlocals.items[INDEX_LOC_CODE]-&gt;source)-&gt;value);
          else
            co = NULL;
          fprintf(f, "CodeBufferObject %p %d %d '%s' '%s' '%s'\n",
                  obj-&gt;codeptr, nsize, get_stack_depth(&amp;obj-&gt;snapshot),
                  co?PyString_AsString(co-&gt;co_filename):"",
                  co?PyString_AsString(co-&gt;co_name):"",
                  obj-&gt;codemode);
          d = PyDict_New();
          assert(d);
          vinfo_array_dump(&amp;obj-&gt;snapshot.fz_vlocals, f, d);
          Py_DECREF(d);
          fwrite(obj-&gt;codeptr, 1, nsize, f);
          if (nsize &gt; sizeof(struct sd_s) &amp;&amp;
              ((struct sd_s*)(obj-&gt;codeptr+nsize))[-1].signature ==
              SPEC_DICT_SIGNATURE)   /* unelegant hack */
            {
              struct sd_s* sd = ((struct sd_s*)(obj-&gt;codeptr+nsize)) - 1;
              int i = 0;
              PyObject *key, *value;
              fprintf(f, "spec_dict\n");
              while (PyDict_Next(sd-&gt;spec_dict, &amp;i, &amp;key, &amp;value))
                {
                  PyObject* repr;
                  if (PyInt_Check(key))
                    repr = (key-&gt;ob_type-&gt;tp_as_number-&gt;nb_hex)(key);
                  else
                    repr = PyObject_Repr(key);
                  assert(!PyErr_Occurred());
                  assert(PyString_Check(repr));
                  assert(CodeBuffer_Check(value));
                  fprintf(f, "%p %s\n", ((CodeBufferObject*)value)-&gt;codeptr,
                          PyString_AsString(repr));
                  Py_DECREF(repr);
                }
              fprintf(f, "\n");
            }
        }
      fclose(f);
      PyErr_Restore(exc, val, tb);
    }
}

</t>
<t tx="T206">/*****************************************************************/

static PyMethodDef PsycoMethods[] = {
	{"proxy",	&amp;Psyco_proxy,		METH_VARARGS},
	{NULL,		NULL}        /* Sentinel */
};

/* Initialization */
void init_psyco()
{
  PyObject* CPsycoModule;

  PsycoFunction_Type.ob_type = &amp;PyType_Type;
  CodeBuffer_Type.ob_type = &amp;PyType_Type;

  CPsycoModule = Py_InitModule("_psyco", PsycoMethods);
  if (CPsycoModule == NULL)
    return;
  PyExc_PsycoError = PyErr_NewException("psyco.error", NULL, NULL);
  if (PyExc_PsycoError == NULL)
    return;
  if (PyModule_AddObject(CPsycoModule, "error", PyExc_PsycoError))
    return;
  Py_INCREF(&amp;PsycoFunction_Type);
  if (PyModule_AddObject(CPsycoModule, "PsycoFunctionType",
			 (PyObject*) &amp;PsycoFunction_Type))
    return;
#ifdef ALL_CHECKS
  if (PyModule_AddIntConstant(CPsycoModule, "ALL_CHECKS", 1))
    return;
#endif
#ifdef PY_PSYCO_MODULE
  PyPsycoModule = PyImport_ImportModule("psyco");
  if (PyPsycoModule == NULL)
    return;
#endif

  psyco_processor_init();
  psyco_dispatcher_init();
  psyco_compiler_init();
  psyco_pycompiler_init();  /* this one last */
  /*if (PyErr_Occurred())
    return;*/
}
</t>
<t tx="T207">#include "pycencoding.h"

@others
</t>
<t tx="T208">DEFINEFN
void decref_create_new_ref(PsycoObject* po, vinfo_t* w)
{
	/* we must Py_INCREF() the object */
	BEGIN_CODE
	if (is_compiletime(w-&gt;source))
		INC_KNOWN_OB_REFCNT((PyObject*)
				    CompileTime_Get(w-&gt;source)-&gt;value);
	else {
		/* 'w' is in a register because of write_array_item() */
		extra_assert(!RUNTIME_REG_IS_NONE(w));
		INC_OB_REFCNT(RUNTIME_REG(w));
	}
	END_CODE
}
</t>
<t tx="T209">DEFINEFN
void decref_create_new_lastref(PsycoObject* po, vinfo_t* w)
{
	if (!eat_reference(w)) {
		/* in this case we must Py_INCREF() the object */
		BEGIN_CODE
		if (is_compiletime(w-&gt;source))
			INC_KNOWN_OB_REFCNT((PyObject*)
					    CompileTime_Get(w-&gt;source)-&gt;value);
		else {
			/* 'w' is in a register because of write_array_item() */
			extra_assert(!RUNTIME_REG_IS_NONE(w));
			INC_OB_REFCNT(RUNTIME_REG(w));
		}
                END_CODE
	}
}
</t>
<t tx="T210">#include "vcompiler.h"
#include "dispatcher.h"
#include "codemanager.h"
#include "Python/pycompiler.h"
#include "pycencoding.h"

DEFINEVAR const long psyco_zero = 0;
DEFINEVAR source_virtual_t psyco_vsource_not_important;

#define VI_BLOCK_COUNT   (4096 / sizeof(vinfo_t))

DEFINEVAR void** vinfo_linked_list = NULL;

@others</t>
<t tx="T211">DEFINEFN
void* vinfo_malloc_block()
#ifdef PSYCO_NO_LINKED_LISTS
{
  vinfo_t* p = (vinfo_t*) PyCore_MALLOC(sizeof(vinfo_t));
  if (p == NULL)
    OUT_OF_MEMORY();
  return p;
}
#else
{
  vinfo_t* p;
  vinfo_t* prev = (vinfo_t*) vinfo_linked_list;
  vinfo_t* block = (vinfo_t*) PyCore_MALLOC(VI_BLOCK_COUNT*sizeof(vinfo_t));
  if (block == NULL)
    /*return NULL;*/ OUT_OF_MEMORY();
  
  for (p=block+VI_BLOCK_COUNT; --p!=block; )
    {
      *(vinfo_t**)p = prev;
      prev = p;
    }
  vinfo_linked_list = *(void***) prev;
  return prev;
}
#endif</t>
<t tx="T212">#define SK_BLOCK_COUNT   (1024 / sizeof(source_known_t))

DEFINEVAR void** sk_linked_list = NULL;

DEFINEFN
void* sk_malloc_block()
#ifdef PSYCO_NO_LINKED_LISTS
{
  source_known_t* p = (source_known_t*) PyCore_MALLOC(sizeof(source_known_t));
  if (p == NULL)
    OUT_OF_MEMORY();
  return p;
}
#else
{
  source_known_t* p;
  source_known_t* prev = (source_known_t*) sk_linked_list;
  source_known_t* block = (source_known_t*)      \
    PyCore_MALLOC(SK_BLOCK_COUNT*sizeof(source_known_t));
  if (block == NULL)
    /*return NULL;*/ OUT_OF_MEMORY();
  
  for (p=block+SK_BLOCK_COUNT; --p!=block; )
    {
      *(source_known_t**)p = prev;
      prev = p;
    }
  sk_linked_list = *(void***) prev;
  return prev;
}
#endif</t>
<t tx="T213">DEFINEFN
vinfo_array_t* array_grow1(vinfo_array_t* array, int ncount)
{
  int i = array-&gt;count;
  extra_assert(ncount &gt; i);
  if (i == 0)
    array = PyCore_MALLOC(sizeof(int) + ncount * sizeof(vinfo_t*));
  else
    array = PyCore_REALLOC(array, sizeof(int) + ncount * sizeof(vinfo_t*));
  if (array == NULL)
    OUT_OF_MEMORY();
  array-&gt;count = ncount;
  while (i&lt;ncount)
    array-&gt;items[i++] = NULL;
  return array;
}
</t>
<t tx="T214">DEFINEFN
void sk_release(source_known_t *sk)
{
#if 0
  XXX --- XXX --- XXX --- XXX --- XXX --- XXX --- XXX --- XXX --- XXX
    The Python objects who get once in a source_known_t are never
    freed. This is so because we might have references to them left
    in the code buffers. This is tricky because the references can
    be indirect (to a sub-objects, to a field in the object structure,
                 etc...)
    So not freeing them at all is the easy way out. It is expected
    that not too many objects will get lost this way. This must be
    carefully worked out when implementing releasing of code
    buffers. It will probably require careful checks for all
    instructions that might emit an immediate value in the code,
    and for where this immediate value (indirectly or not) comes from.
  XXX --- XXX --- XXX --- XXX --- XXX --- XXX --- XXX --- XXX --- XXX
  if ((sk-&gt;refcount1_flags &amp; SkFlagPyObj) != 0) {
    Py_XDECREF((PyObject*)(sk-&gt;value));
  }
#endif
  sk_delete(sk);
}
</t>
<t tx="T215">DEFINEFN
vinfo_t* vinfo_copy(vinfo_t* vi)
{
  vinfo_t* result = vinfo_new(vi-&gt;source);
  result-&gt;array = vi-&gt;array;
  if (result-&gt;array-&gt;count &gt; 0)
    {
      result-&gt;array = array_new(result-&gt;array-&gt;count);
      duplicate_array(result-&gt;array, vi-&gt;array);
    }
  if (is_compiletime(result-&gt;source))
    sk_incref(CompileTime_Get(result-&gt;source));
  return result;
}
</t>
<t tx="T216">DEFINEFN
void vinfo_release(vinfo_t* vi, PsycoObject* po)
{
  switch (gettime(vi-&gt;source)) {
    
  case RunTime:
    if (po != NULL)
      {
        if (has_rtref(vi-&gt;source))
          {
            /* write Py_DECREF() when releasing the last reference to
               a run-time vinfo_t holding a reference to a Python object */
            psyco_decref_rt(po, vi);
          }
        if (!is_reg_none(vi-&gt;source))
          REG_NUMBER(po, getreg(vi-&gt;source)) = NULL;
      }
    break;

  case CompileTime:
    sk_decref(CompileTime_Get(vi-&gt;source));
    break;
    
  case VirtualTime:
    if (po != NULL &amp;&amp; vi == po-&gt;ccreg)
      po-&gt;ccreg = NULL;
    break;
  }

  /* must be after the switch because psyco_decref_rt() will use the
     array to extract any available time information to speed up Py_DECREF(). */
  if (vi-&gt;array != NullArray)
    array_delete(vi-&gt;array, po);

  /* only virtual-time vinfos are allowed in po-&gt;ccreg */
  extra_assert(po == NULL || vi != po-&gt;ccreg);
  VINFO_FREE_1(vi);
}
</t>
<t tx="T217">DEFINEFN
void clear_tmp_marks(vinfo_array_t* array)
{
  /* clear all 'tmp' fields in the array, recursively */
  int i = array-&gt;count;
  while (i--)
    if (array-&gt;items[i] != NULL)
      {
	array-&gt;items[i]-&gt;tmp = NULL;
	if (array-&gt;items[i]-&gt;array != NullArray)
	  clear_tmp_marks(array-&gt;items[i]-&gt;array);
      }
}
</t>
<t tx="T218">#ifdef ALL_CHECKS
DEFINEFN
void assert_cleared_tmp_marks(vinfo_array_t* array)
{
  /* assert that all 'tmp' fields are NULL */
  int i = array-&gt;count;
  while (i--)
    if (array-&gt;items[i] != NULL)
      {
	assert(array-&gt;items[i]-&gt;tmp == NULL);
	if (array-&gt;items[i]-&gt;array != NullArray)
	  assert_cleared_tmp_marks(array-&gt;items[i]-&gt;array);
      }
}
#endif</t>
<t tx="T219">DEFINEFN
bool array_contains(vinfo_array_t* array, vinfo_t* vi)
{
  int i = array-&gt;count;
  while (i--)
    if (array-&gt;items[i] != NULL)
      {
	if (array-&gt;items[i] == vi)
          return true;
	if (array-&gt;items[i]-&gt;array != NullArray)
	  if (array_contains(array-&gt;items[i]-&gt;array, vi))
            return true;
      }
  return false;
}
</t>
<t tx="T220">#ifdef ALL_CHECKS
static void coherent_array(vinfo_array_t* source, PsycoObject* po, int found[])
{
  int i = source-&gt;count;
  while (i--)
    if (source-&gt;items[i] != NULL)
      {
        Source src = source-&gt;items[i]-&gt;source;
	if (is_runtime(src) &amp;&amp; !is_reg_none(src))
          {
            assert(REG_NUMBER(po, getreg(src)) == source-&gt;items[i]);
            found[(int) getreg(src)] = 1;
          }
        if (psyco_vsource_cc(src) != CC_ALWAYS_FALSE)
          {
            assert(po-&gt;ccreg == source-&gt;items[i]);
            found[REG_TOTAL] = 1;
          }
	if (source-&gt;items[i]-&gt;array != NullArray)
	  coherent_array(source-&gt;items[i]-&gt;array, po, found);
      }
}
</t>
<t tx="T221">static void hack_refcounts(vinfo_array_t* source, int delta, int mvalue)
{
  int i = source-&gt;count;
  while (i--)
    if (source-&gt;items[i] != NULL)
      {
        *(short*)(&amp;source-&gt;items[i]-&gt;refcount) += delta;
        if ((source-&gt;items[i]-&gt;refcount &amp; 0x10000) == mvalue)
          {
            source-&gt;items[i]-&gt;refcount ^= 0x10000;
            if (source-&gt;items[i]-&gt;array != NullArray)
              hack_refcounts(source-&gt;items[i]-&gt;array, delta, mvalue);
          }
      }
}
</t>
<t tx="T222">static vinfo_t* nonnull_refcount(vinfo_array_t* source)
{
  int i = source-&gt;count;
  while (i--)
    if (source-&gt;items[i] != NULL)
      {
        if (source-&gt;items[i]-&gt;refcount != 0x10000 &amp;&amp;
            /* list here the 'global' vinfo_t's whose reference counters
               might be larger than the # of references hold by this po alone */
            source-&gt;items[i] != psyco_viNone &amp;&amp;
            source-&gt;items[i] != psyco_viZero &amp;&amp;
            source-&gt;items[i] != psyco_viOne  &amp;&amp;
            1)
          {
            fprintf(stderr, "nonnull_refcount: item %d\n", i);
            return source-&gt;items[i];
          }
	if (source-&gt;items[i]-&gt;array != NullArray)
          {
            vinfo_t* result = nonnull_refcount(source-&gt;items[i]-&gt;array);
            if (result != NULL)
              {
                fprintf(stderr, "nonnull_refcount: in array item %d\n", i);
                return result;
              }
          }
      }
  return NULL;
}
</t>
<t tx="T223">DEFINEFN
void psyco_assert_coherent(PsycoObject* po)
{
  vinfo_array_t debug_extra_refs;
  int found[REG_TOTAL+1];
  int i;
  vinfo_t* err;
  for (i=0; i&lt;=REG_TOTAL; i++)
    found[i] = 0;
  debug_extra_refs.count = 2;
  debug_extra_refs.items[0] = po-&gt;pr.exc;  /* normally private to pycompiler.c,*/
  debug_extra_refs.items[1] = po-&gt;pr.val;  /* but this is for debugging only */
  coherent_array(&amp;po-&gt;vlocals, po, found);
  coherent_array(&amp;debug_extra_refs, po, found);
  for (i=0; i&lt;REG_TOTAL; i++)
    if (!found[i])
      assert(REG_NUMBER(po, i) == NULL);
  if (!found[REG_TOTAL])
    assert(po-&gt;ccreg == NULL);
  hack_refcounts(&amp;po-&gt;vlocals, -1, 0);
  hack_refcounts(&amp;debug_extra_refs, -1, 0);
  err = nonnull_refcount(&amp;po-&gt;vlocals);
  hack_refcounts(&amp;debug_extra_refs, +1, 0x10000);
  hack_refcounts(&amp;po-&gt;vlocals, +1, 0x10000);
  assert(!err);  /* see nonnull_refcounts() */
}
#endif</t>
<t tx="T224">DEFINEFN
void duplicate_array(vinfo_array_t* target, vinfo_array_t* source)
{
  /* make a depth copy of an array.
     Same requirements as PsycoObject::duplicate(). */
  int i;
  for (i=0; i&lt;source-&gt;count; i++)
    {
      vinfo_t* sourcevi = source-&gt;items[i];
      if (sourcevi == NULL)
	target-&gt;items[i] = NULL;
      else if (sourcevi-&gt;tmp != NULL)
	{
	  target-&gt;items[i] = sourcevi-&gt;tmp;
	  target-&gt;items[i]-&gt;refcount++;
	}
      else
	{
	  vinfo_t* targetvi = vinfo_copy(sourcevi);
	  targetvi-&gt;tmp = NULL;
	  target-&gt;items[i] = sourcevi-&gt;tmp = targetvi;
	}
    }
  target-&gt;count = source-&gt;count;
  
  /*return true;

 fail:
  while (i--)
    if (items[i] != NULL)
      {
        items[i]-&gt;tmp = NULL;
        target-&gt;items[i]-&gt;decref(NULL);
      }
      return false;*/
}
</t>
<t tx="T225">DEFINEFN
PsycoObject* psyco_duplicate(PsycoObject* po)
{
  /* Requires that all 'tmp' marks in 'po' are cleared.
     In the new copy all 'tmp' marks will be cleared. */
  
  int i;
  PsycoObject* result = PsycoObject_New();
  psyco_assert_coherent(po);
  assert_cleared_tmp_marks(&amp;po-&gt;vlocals);
  duplicate_array(&amp;result-&gt;vlocals, &amp;po-&gt;vlocals);

  /* set the register pointers of 'result' to the new vinfo_t's */
  for (i=0; i&lt;REG_TOTAL; i++)
    if (REG_NUMBER(po, i) != NULL)
      REG_NUMBER(result, i) = REG_NUMBER(po, i)-&gt;tmp;
  if (po-&gt;ccreg != NULL)
    result-&gt;ccreg = po-&gt;ccreg-&gt;tmp;

  /* the rest of the data is copied with no change */
  result-&gt;stack_depth = po-&gt;stack_depth;
  result-&gt;last_used_reg = po-&gt;last_used_reg;
  result-&gt;arguments_count = po-&gt;arguments_count;
  result-&gt;respawn_cnt = po-&gt;respawn_cnt;
  result-&gt;respawn_proxy = po-&gt;respawn_proxy;
  result-&gt;code = po-&gt;code;
  result-&gt;codelimit = po-&gt;codelimit;
  pyc_data_duplicate(&amp;result-&gt;pr, &amp;po-&gt;pr);

  assert_cleared_tmp_marks(&amp;result-&gt;vlocals);
  return result;
}
</t>
<t tx="T226">DEFINEFN void PsycoObject_Delete(PsycoObject* po)
{
  pyc_data_release(&amp;po-&gt;pr);
  deallocate_array(&amp;po-&gt;vlocals, NULL);
  PyCore_FREE(po);
}
</t>
<t tx="T227">typedef struct {
	CodeBufferObject*	self;
	PsycoObject* 		po;
	resume_fn_t		resume_fn;
	code_t*			write_jmp;
	condition_code_t	cond;
} coding_pause_t;

static code_t* do_resume_coding(coding_pause_t* cp)
{
  /* called when entering a coding_pause (described by 'cp') */
  code_t* code;
  code_t* target = (cp-&gt;resume_fn) (cp-&gt;po, cp+1);

  /* fix the jump to point to 'target' */
  /* safety check: do not write a JMP whose target is itself...
     would make an endless loop */
  code = cp-&gt;write_jmp;
  assert(target != code);
  if (cp-&gt;cond == CC_ALWAYS_TRUE)
    JUMP_TO(target);
  else
    FAR_COND_JUMP_TO(target, cp-&gt;cond);
  /* cannot Py_DECREF(cp-&gt;self) because the current function is returning into
     that code now, but any time later is fine: use the trash of codemanager.c */
  psyco_dump_code_buffers();
  psyco_trash_object((PyObject*) cp-&gt;self);
  return target;
}
</t>
<t tx="T228">@ Prepare a 'coding pause', i.e. a short amount of code (proxy) that will be called only if the execution actually reaches it to go on with compilation.

'po' is the PsycoObject corresponding to the proxy. 'condition' may not be CC_ALWAYS_FALSE. The (possibly conditional) jump to the proxy is encoded in 'calling_code'. When the execution reaches the proxy, 'resume_fn' is called and the proxy destroys itself and replaces the original jump to it by a jump to the newly compiled code.
@c

DEFINEFN
void psyco_coding_pause(PsycoObject* po, condition_code_t jmpcondition,
                        resume_fn_t resume_fn, void* extra, int extrasize)
{
  coding_pause_t* cp;
  code_t* calling_code;
  CodeBufferObject* codebuf = psyco_new_code_buffer(NULL, NULL);
  if (codebuf == NULL)
    OUT_OF_MEMORY();
  
  extra_assert(jmpcondition != CC_ALWAYS_FALSE);

  /* the proxy contains only a jump to do_resume_coding,
     followed by a coding_pause_t structure, itself followed by the
     'extra' data. */
  calling_code = po-&gt;code;
  po-&gt;code = codebuf-&gt;codeptr;
  BEGIN_CODE
  TEMP_SAVE_REGS_FN_CALLS;
  END_CODE
  cp = (coding_pause_t*) psyco_jump_proxy(po, &amp;do_resume_coding, 1, 1);
  SHRINK_CODE_BUFFER(codebuf,
                     (code_t*)(cp+1) + extrasize - codebuf-&gt;codeptr,
                     "coding_pause");
  /* fill in the coding_pause_t structure and the following 'extra' data */
  cp-&gt;self = codebuf;
  cp-&gt;po = po;
  cp-&gt;resume_fn = resume_fn;
  cp-&gt;write_jmp = calling_code;
  cp-&gt;cond = jmpcondition;
  memcpy(cp+1, extra, extrasize);

  /* write the jump to the proxy */
  po-&gt;code = calling_code;
  BEGIN_CODE
  if (jmpcondition == CC_ALWAYS_TRUE)
    JUMP_TO(codebuf-&gt;codeptr);  /* jump always */
  else
    FAR_COND_JUMP_TO(codebuf-&gt;codeptr, jmpcondition);
  END_CODE
  psyco_dump_code_buffers();
}
</t>
<t tx="T229">@ for psyco_coding_pause(): a resume function that simply resumes compilation.
@c

static code_t* psyco_resume_compile(PsycoObject* po, void* extra)
{
  return psyco_compile_code(po)-&gt;codeptr;
  /* XXX don't know what to do with the reference returned by
     XXX po-&gt;compile_code() */
}
</t>
<t tx="T230">@ Main compiling function.

Emit code corresponding to 'this' state.

The compiler produces its code into 'this-&gt;code' and the return value is the end of the written code.
@c

DEFINEFN
code_t* psyco_compile(PsycoObject* po, bool continue_compilation)
{
  CodeBufferObject* codebuf;
  CodeBufferObject* oldcodebuf;
  vinfo_t* diff = psyco_compatible(po, &amp;global_entries, &amp;oldcodebuf);

  /*psyco_assert_cleared_tmp_marks(&amp;po-&gt;vlocals);  -- not needed -- */
  
  if (diff == COMPATIBLE)
    {
      code_t* code2 = psyco_unify(po, &amp;oldcodebuf);
      Py_DECREF(oldcodebuf);
      return code2;
    }
  else
    {
      if (po-&gt;codelimit - po-&gt;code &lt;= BUFFER_MARGIN &amp;&amp; diff == INCOMPATIBLE)
        {
          /* Running out of space in this buffer. */
          
          /* Instead of going on we stop now and make ready to
             start the new buffer later, when the execution actually
             reaches this point. This forces the emission of code to
             pause at predicible intervals. Among other advantages it
             prevents long or infinite loops from exploding the memory
             while the user sees no progression in the execution of
             her program.
           */
          psyco_coding_pause(po, CC_ALWAYS_TRUE, &amp;psyco_resume_compile, NULL, 0);
          return po-&gt;code;
        }

      /* Enough space left, continue in the same buffer. */
      codebuf = psyco_proxy_code_buffer(po, &amp;global_entries);
      if (codebuf == NULL)
        OUT_OF_MEMORY();
#ifdef CODE_DUMP_FILE
      codebuf-&gt;chained_list = psyco_codebuf_chained_list;
      psyco_codebuf_chained_list = codebuf;
#endif
      Py_DECREF(codebuf);
      
      if (diff != INCOMPATIBLE)
        {
          /* diff points to a vinfo_t: make it run-time */
          psyco_unfix(po, diff);
          /* start over (maybe we have already seen this new state) */
          return psyco_compile(po, continue_compilation);
        }

      if (continue_compilation)
        return NULL;  /* I won't actually compile myself, let the caller know */
      
      /* call the entry point function which performs the actual compilation */
      return GLOBAL_ENTRY_POINT(po);
    }
}
</t>
<t tx="T231">DEFINEFN
void psyco_compile_cond(PsycoObject* po, condition_code_t condition)
{
  CodeBufferObject* oldcodebuf;
  vinfo_t* diff = psyco_compatible(po, &amp;global_entries, &amp;oldcodebuf);
  PsycoObject* po2 = PsycoObject_Duplicate(po);

  extra_assert(condition &lt; CC_TOTAL);

  if (diff == COMPATIBLE)
    {
      /* try to emit:
                           JNcond Label
                           &lt;unification-and-jump&gt;
                          Label:

         if &lt;unification-and-jump&gt; is only a JMP, recode the whole as a single
                           Jcond &lt;unification-jump-target&gt;
      */
      code_t* code2 = po-&gt;code + SIZE_OF_SHORT_CONDITIONAL_JUMP;
      code_t* target;
      code_t* codeend;
      
      po2-&gt;code = code2;
      po2-&gt;codelimit = code2 + RANGE_OF_SHORT_CONDITIONAL_JUMP;
      codeend = psyco_unify(po2, &amp;oldcodebuf);
      Py_DECREF(oldcodebuf);
      BEGIN_CODE
      if (IS_A_SINGLE_JUMP(code2, codeend, target))
        FAR_COND_JUMP_TO(target, condition);
      else
        {
          SHORT_COND_JUMP_TO(codeend, INVERT_CC(condition));
          code = codeend;
        }
      END_CODE
    }
  else
    {
      /* Use the conditional-compiling abilities of
         coding_pause(); it will write a Jcond to a proxy
         which will perform the actual compilation later.
      */
      psyco_coding_pause(po2, condition, &amp;psyco_resume_compile, NULL, 0);
      po-&gt;code = po2-&gt;code;
    }
}
</t>
<t tx="T232">@ Simplified interface to compile() without using a previously existing code buffer. Return a new code buffer.
@c

DEFINEFN
CodeBufferObject* psyco_compile_code(PsycoObject* po)
{
  code_t* code1;
  CodeBufferObject* codebuf;
  CodeBufferObject* oldcodebuf;
  vinfo_t* diff = psyco_compatible(po, &amp;global_entries, &amp;oldcodebuf);

  /*psyco_assert_cleared_tmp_marks(&amp;po-&gt;vlocals);  -- not needed -- */

  if (diff == COMPATIBLE)
    return psyco_unify_code(po, oldcodebuf);

  codebuf = psyco_new_code_buffer(po, &amp;global_entries);  /* start a new buffer */
  if (codebuf == NULL)
    OUT_OF_MEMORY();
  po-&gt;code = codebuf-&gt;codeptr;
  
  if (diff != INCOMPATIBLE)
    {
      psyco_unfix(po, diff);
      /* start over (maybe we have already seen this new state) */
      code1 = psyco_compile(po, false);
    }
  else
    {
      /* call the entry point function which performs the actual compilation
         (this is the usual case) */
      code1 = GLOBAL_ENTRY_POINT(po);
    }

  /* we have written some code into a new codebuf, now shrink it to
     its actual size */
  psyco_shrink_code_buffer(codebuf, code1 - codebuf-&gt;codeptr);
  psyco_dump_code_buffers();
  return codebuf;
}
</t>
<t tx="T233">static bool computed_do_not_use(PsycoObject* po, vinfo_t* vi)
{
  fprintf(stderr, "psyco: internal error (computed_do_not_use)\n");
  extra_assert(0);     /* stop if debugging */
  vi-&gt;source = SOURCE_DUMMY;
  return true;
}
</t>
<t tx="T234">DEFINEFN
void psyco_compiler_init()
{
  psyco_vsource_not_important.compute_fn = &amp;computed_do_not_use;
}
</t>
<t tx="T235">@language c</t>
<t tx="T236"> /***************************************************************/
/***             Psyco equivalent of abstract.h                ***/
 /***************************************************************/

#ifndef _PSY_ABSTRACT_H
#define _PSY_ABSTRACT_H


#include "pobject.h"
#include "../pycencoding.h"


/* #ifndef BINARY_FLOOR_DIVIDE */
/* # define PyNumber_FloorDivide          NULL */
/* # define PyNumber_TrueDivide           NULL */
/* # define PyNumber_InPlaceFloorDivide   NULL */
/* # define PyNumber_InPlaceTrueDivide    NULL */
/* #endif */


/* 'kw' may be NULL */
EXTERNFN vinfo_t* PsycoObject_Call(PsycoObject* po, vinfo_t* callable_object,
                                   vinfo_t* args, vinfo_t* kw);

EXTERNFN vinfo_t* PsycoObject_Size(PsycoObject* po, vinfo_t* vi);
EXTERNFN vinfo_t* PsycoObject_GetItem(PsycoObject* po, vinfo_t* o, vinfo_t* key);
EXTERNFN bool PsycoObject_SetItem(PsycoObject* po, vinfo_t* o, vinfo_t* key,
                                  vinfo_t* value);

EXTERNFN vinfo_t* PsycoSequence_GetItem(PsycoObject* po, vinfo_t* o, vinfo_t* i);
EXTERNFN bool     PsycoSequence_SetItem(PsycoObject* po, vinfo_t* o, vinfo_t* i,
                                        vinfo_t* value);
EXTERNFN vinfo_t* PsycoSequence_GetSlice(PsycoObject* po, vinfo_t* o,
                                         vinfo_t* ilow, vinfo_t* ihigh);
EXTERNFN bool     PsycoSequence_SetSlice(PsycoObject* po, vinfo_t* o,
                                         vinfo_t* ilow, vinfo_t* ihigh,
                                         vinfo_t* value);

EXTERNFN vinfo_t* PsycoNumber_Positive(PsycoObject* po, vinfo_t* vi);
EXTERNFN vinfo_t* PsycoNumber_Negative(PsycoObject* po, vinfo_t* vi);
EXTERNFN vinfo_t* PsycoNumber_Invert(PsycoObject* po, vinfo_t* vi);

EXTERNFN vinfo_t* PsycoNumber_Add(PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN vinfo_t* PsycoNumber_Or(PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN vinfo_t* PsycoNumber_Xor(PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN vinfo_t* PsycoNumber_And(PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN vinfo_t* PsycoNumber_Lshift(PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN vinfo_t* PsycoNumber_Rshift(PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN vinfo_t* PsycoNumber_Subtract(PsycoObject* po, vinfo_t* v1, vinfo_t*v2);
EXTERNFN vinfo_t* PsycoNumber_Multiply(PsycoObject* po, vinfo_t* v1, vinfo_t*v2);
EXTERNFN vinfo_t* PsycoNumber_Divide(PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN vinfo_t* PsycoNumber_Divmod(PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN vinfo_t* PsycoNumber_Remainder(PsycoObject* po, vinfo_t* v1,vinfo_t*v2);
EXTERNFN vinfo_t* PsycoNumber_Power(PsycoObject* po, vinfo_t* v1, vinfo_t* v2,
                                    vinfo_t* v3);

EXTERNFN
vinfo_t* PsycoNumber_InPlaceAdd(PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN
vinfo_t* PsycoNumber_InPlaceOr(PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN
vinfo_t* PsycoNumber_InPlaceXor(PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN
vinfo_t* PsycoNumber_InPlaceAnd(PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN
vinfo_t* PsycoNumber_InPlaceLshift(PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN
vinfo_t* PsycoNumber_InPlaceRshift(PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN
vinfo_t* PsycoNumber_InPlaceSubtract(PsycoObject* po, vinfo_t* v1, vinfo_t*v2);
EXTERNFN
vinfo_t* PsycoNumber_InPlaceMultiply(PsycoObject* po, vinfo_t* v1, vinfo_t*v2);
EXTERNFN
vinfo_t* PsycoNumber_InPlaceDivide(PsycoObject* po, vinfo_t* v1, vinfo_t* v2);
EXTERNFN
vinfo_t* PsycoNumber_InPlaceRemainder(PsycoObject* po, vinfo_t* v1,vinfo_t*v2);
EXTERNFN
vinfo_t* PsycoNumber_InPlacePower(PsycoObject* po, vinfo_t* v1, vinfo_t* v2,
                                  vinfo_t* v3);

   /* Attention! This does not catch PyExc_StopIteration.
      As with all meta-functions, when it returns NULL there is
      an exception set. All iterators raise PyExc_StopIteration at
      the meta-level (because this is not time-consuming, the
      exceptions being virtualized and not really set at Python's
      eyes): */
EXTERNFN vinfo_t* PsycoIter_Next(PsycoObject* po, vinfo_t* iter);
EXTERNFN vinfo_t* PsycoObject_GetIter(PsycoObject* po, vinfo_t* vi);


/* generic len() function that reads the object's ob_size field;
   see e.g. plistobject.c */
EXTERNFN vinfo_t* psyco_generic_immut_ob_size(PsycoObject* po, vinfo_t* vi);
EXTERNFN vinfo_t* psyco_generic_mut_ob_size(PsycoObject* po, vinfo_t* vi);


inline void psy_abstract_init() { }  /* nothing */

#endif /* _PSY_ABSTRACT_H */
</t>
<t tx="T237"> /***************************************************************/
/***            Psyco equivalent of dictobject.h               ***/
 /***************************************************************/

#ifndef _PSY_DICTOBJECT_H
#define _PSY_DICTOBJECT_H


#include "pobject.h"
#include "pabstract.h"


EXTERNFN vinfo_t* PsycoDict_New(PsycoObject* po);


EXTERNFN void psy_dictobject_init();

#endif /* _PSY_LISTOBJECT_H */
</t>
<t tx="T238"> /***************************************************************/
/***            Psyco equivalent of funcobject.h               ***/
 /***************************************************************/

#ifndef _PSY_FUNCOBJECT_H
#define _PSY_FUNCOBJECT_H


#include "pobject.h"
#include "pabstract.h"


EXTERNFN void psy_funcobject_init();

#endif /* _PSY_FUNCOBJECT_H */
</t>
<t tx="T239"> /***************************************************************/
/***             Psyco equivalent of intobject.h               ***/
 /***************************************************************/

#ifndef _PSY_INTOBJECT_H
#define _PSY_INTOBJECT_H


#include "pobject.h"
#include "pabstract.h"


#define INT_OB_IVAL         QUARTER(offsetof(PyIntObject, ob_ival))


#define PsycoInt_Check(tp) PyType_TypeCheck(tp, &amp;PyInt_Type)


 /***************************************************************/
  /***   Virtual-time object builder                           ***/

/* not-yet-computed integers; it will call PyInt_FromLong */
EXTERNVAR source_virtual_t psyco_computed_int;

/* !! consumes a reference to vlong. PsycoInt_FromLong() does not. */
inline vinfo_t* PsycoInt_FROM_LONG(vinfo_t* vlong)
{
	vinfo_t* result = vinfo_new(VirtualTime_New(&amp;psyco_computed_int));
	result-&gt;array = array_new(INT_OB_IVAL+1);
	result-&gt;array-&gt;items[OB_TYPE] =
		vinfo_new(CompileTime_New((long)(&amp;PyInt_Type)));
	result-&gt;array-&gt;items[INT_OB_IVAL] = vlong;
	return result;
}
inline vinfo_t* PsycoInt_FromLong(vinfo_t* vlong)
{
	vinfo_incref(vlong);
	return PsycoInt_FROM_LONG(vlong);
}

inline vinfo_t* PsycoInt_AS_LONG(PsycoObject* po, vinfo_t* v)
{	/* no type check; does not return a new reference. */
	return get_array_item(po, v, INT_OB_IVAL);
}

/* return a new ref */
EXTERNFN vinfo_t* PsycoInt_AsLong(PsycoObject* po, vinfo_t* v);


inline vinfo_t* PsycoIntInt_RichCompare(PsycoObject* po, vinfo_t* v,
					vinfo_t* w, int op)
{	/* only for two integer objects */
	vinfo_t* a;
	vinfo_t* b;
	condition_code_t cc;
	a = PsycoInt_AS_LONG(po, v);
	if (a == NULL) return NULL;
	b = PsycoInt_AS_LONG(po, w);
	if (b == NULL) return NULL;
	cc = integer_cmp(po, a, b, op);
	if (cc == CC_ERROR) return NULL;
	return PsycoInt_FROM_LONG(psyco_vinfo_condition(po, cc));
}


EXTERNFN void psy_intobject_init();


#endif /* _PSY_INTOBJECT_H */
</t>
<t tx="T240"> /***************************************************************/
/***            Psyco equivalent of iterobject.h               ***/
 /***************************************************************/

#ifndef _PSY_ITEROBJECT_H
#define _PSY_ITEROBJECT_H


#include "pobject.h"
#include "pabstract.h"


/* this structure not exported by iterobject.h */
typedef struct {
	PyObject_HEAD
	long      it_index;
	PyObject *it_seq;
} seqiterobject;

#define SEQITER_IT_INDEX    QUARTER(offsetof(seqiterobject, it_index))
#define SEQITER_IT_SEQ      QUARTER(offsetof(seqiterobject, it_seq))
#define SEQITER_IT_MAX      SEQITER_IT_SEQ


/*********************************************************************/
 /* Virtual sequence iterators. Created if needed by PySetIter_New(). */
EXTERNVAR source_virtual_t psyco_computed_seqiter;

/* !! consumes a ref on 'seq' */
inline vinfo_t* PsycoSeqIter_NEW(vinfo_t* seq)
{
	vinfo_t* result = vinfo_new(VirtualTime_New(&amp;psyco_computed_seqiter));
	result-&gt;array = array_new(SEQITER_IT_MAX+1);
	result-&gt;array-&gt;items[OB_TYPE] =
		vinfo_new(CompileTime_New((long)(&amp;PySeqIter_Type)));
	/* don't use psyco_viZero here because it is better without
	   SkFlagFixed */
	result-&gt;array-&gt;items[SEQITER_IT_INDEX] =
		vinfo_new(CompileTime_New(0));
	result-&gt;array-&gt;items[SEQITER_IT_SEQ] = seq;
	return result;
}
inline vinfo_t* PsycoSeqIter_New(vinfo_t* seq)
{
	vinfo_incref(seq);
	return PsycoSeqIter_NEW(seq);
}


EXTERNFN void psy_iterobject_init();

#endif /* _PSY_ITEROBJECT_H */
</t>
<t tx="T241"> /***************************************************************/
/***            Psyco equivalent of listobject.h               ***/
 /***************************************************************/

#ifndef _PSY_LISTOBJECT_H
#define _PSY_LISTOBJECT_H


#include "pobject.h"
#include "pabstract.h"


#define LIST_OB_ITEM        QUARTER(offsetof(PyListObject, ob_item))


EXTERNFN vinfo_t* PsycoList_New(PsycoObject* po, int size);


EXTERNFN void psy_listobject_init();  /* nothing */

#endif /* _PSY_LISTOBJECT_H */
</t>
<t tx="T242"> /***************************************************************/
/***            Psyco equivalent of longobject.h               ***/
 /***************************************************************/

#ifndef _PSY_LONGOBJECT_H
#define _PSY_LONGOBJECT_H


#include "pobject.h"
#include "pabstract.h"


#define PsycoLong_Check(tp) PyType_TypeCheck(tp, &amp;PyLong_Type)


EXTERNFN vinfo_t* PsycoLong_AsLong(PsycoObject* po, vinfo_t* v);


EXTERNFN void psy_longobject_init();

#endif /* _PSY_LONGOBJECT_H */
</t>
<t tx="T243"> /***************************************************************/
/***           Psyco equivalent of methodobject.h              ***/
 /***************************************************************/

#ifndef _PSY_METHODOBJECT_H
#define _PSY_METHODOBJECT_H


#include "pobject.h"
#include "pabstract.h"


#define CFUNC_M_ML          QUARTER(offsetof(PyCFunctionObject, m_ml))
#define CFUNC_M_SELF        QUARTER(offsetof(PyCFunctionObject, m_self))


EXTERNFN void psy_methodobject_init();

#endif /* _PSY_METHODOBJECT_H */
</t>
<t tx="T244"> /***************************************************************/
/***             Psyco equivalent of object.h                  ***/
 /***************************************************************/

#ifndef _PSY_OBJECT_H
#define _PSY_OBJECT_H


#include "../Python/pycompiler.h"


#define OB_REFCOUNT         QUARTER(offsetof(PyObject, ob_refcnt))
#define OB_TYPE             QUARTER(offsetof(PyObject, ob_type))
#define VAR_OB_SIZE         QUARTER(offsetof(PyVarObject, ob_size))


/* common type checkers, rewritten because in Psyco we manipulate type
   objects directly and Python's usual macros insist on taking a regular
   PyObject* whose type is checked. */
#if NEW_STYLE_TYPES
# define PyType_TypeCheck(tp1, tp)  	\
	((tp1) == (tp) || PyType_IsSubtype((tp1), (tp)))
#else
# define PyType_TypeCheck(tp1, tp)    ((tp1) == (tp))
#endif

#define PsycoIter_Check(tp) \
    (PyType_HasFeature(tp, Py_TPFLAGS_HAVE_ITER) &amp;&amp; \
     (tp)-&gt;tp_iternext != NULL)

#define PsycoSequence_Check(tp) \
	((tp)-&gt;tp_as_sequence &amp;&amp; (tp)-&gt;tp_as_sequence-&gt;sq_item != NULL)


/* Return the type of an object, or NULL in case of exception (typically
   a promotion exception). */
inline PyTypeObject* Psyco_NeedType(PsycoObject* po, vinfo_t* vi) {
	 vinfo_t* vtp = get_array_item(po, vi, OB_TYPE);
	 if (vtp == NULL)
		 return NULL;
	 return (PyTypeObject*) psyco_pyobj_atcompiletime(po, vtp);
}
inline PyTypeObject* Psyco_FastType(vinfo_t* vi) {
	/* only call this when you know the type has already been
	   loaded by a previous Psyco_NeedType() */
	vinfo_t* vtp = vinfo_getitem(vi, OB_TYPE);
	extra_assert(vtp != NULL &amp;&amp; is_compiletime(vtp-&gt;source));
	return (PyTypeObject*) (CompileTime_Get(vtp-&gt;source)-&gt;value);
}
/* Check for the type of an object. Returns the index in the set 'fs' or
   -1 if not in the set (or if exception). Used this is better than
   Psyco_NeedType() if you are only interested in some types, not all of them. */
inline int Psyco_TypeSwitch(PsycoObject* po, vinfo_t* vi, fixed_switch_t* fs) {
	vinfo_t* vtp = get_array_item(po, vi, OB_TYPE);
	 if (vtp == NULL)
		 return -1;
	 return psyco_switch_index(po, vtp, fs);
}


EXTERNFN condition_code_t PsycoObject_IsTrue(PsycoObject* po, vinfo_t* vi);
EXTERNFN vinfo_t* PsycoObject_Repr(PsycoObject* po, vinfo_t* vi);

/* Note: DelAttr() is SetAttr() with 'v' set to NULL (and not some vinfo_t
   that would happend to contain zero). */
EXTERNFN vinfo_t* PsycoObject_GetAttr(PsycoObject* po, vinfo_t* o,
                                      vinfo_t* attr_name);
EXTERNFN bool PsycoObject_SetAttr(PsycoObject* po, vinfo_t* o,
                                  vinfo_t* attr_name, vinfo_t* v);

EXTERNFN vinfo_t* PsycoObject_RichCompare(PsycoObject* po, vinfo_t* v,
					  vinfo_t* w, int op);
EXTERNFN condition_code_t PsycoObject_RichCompareBool(PsycoObject* po,
						      vinfo_t* v,
						      vinfo_t* w, int op);


/* a quick way to specify the type of the object returned by an operation
   when it is known, without having to go into all the details of the
   operation itself (be careful, you must be *sure* of the return type): */
#define DEF_KNOWN_RET_TYPE_1(cname, op, flags, knowntype)			\
static vinfo_t* cname(PsycoObject* po, vinfo_t* v1) {				\
	vinfo_t* result = psyco_generic_call(po, op, flags, "v", v1);		\
	if (result != NULL) {							\
		set_array_item(po, result, OB_TYPE,				\
			       vinfo_new(CompileTime_New((long)(&amp;knowntype))));	\
	}									\
	return result;								\
}
#define DEF_KNOWN_RET_TYPE_2(cname, op, flags, knowntype)			\
static vinfo_t* cname(PsycoObject* po, vinfo_t* v1,				\
				      vinfo_t* v2) {				\
	vinfo_t* result = psyco_generic_call(po, op, flags, "vv", v1, v2);	\
	if (result != NULL) {							\
		set_array_item(po, result, OB_TYPE,				\
			       vinfo_new(CompileTime_New((long)(&amp;knowntype))));	\
	}									\
	return result;								\
}


/* definition of commonly used "fixed switches", i.e. sets of
   values (duplicating fixed switch structures for the same set
   of value can inccur a run-time performance loss in some cases) */

/* the variable names list the values in order.
   'int' means '&amp;PyInt_Type' etc. */
EXTERNVAR fixed_switch_t psyfs_int;
EXTERNVAR fixed_switch_t psyfs_int_long;
EXTERNVAR fixed_switch_t psyfs_tuple_list;
EXTERNVAR fixed_switch_t psyfs_string_unicode;


inline void psy_object_init()
{
	long values[2];
        int cnt;

	values[0] = (long)(&amp;PyInt_Type);
	psyco_build_run_time_switch(&amp;psyfs_int, SkFlagFixed, values, 1);

        values[0] = (long)(&amp;PyInt_Type);
	values[1] = (long)(&amp;PyLong_Type);
        psyco_build_run_time_switch(&amp;psyfs_int_long, SkFlagFixed, values, 2);

	values[0] = (long)(&amp;PyTuple_Type);
	values[1] = (long)(&amp;PyList_Type);
        psyco_build_run_time_switch(&amp;psyfs_tuple_list, SkFlagFixed, values, 2);

	values[0] = (long)(&amp;PyString_Type);
#ifdef Py_USING_UNICODE
	values[1] = (long)(&amp;PyUnicode_Type);
        cnt = 2;
#else
        cnt = 1;
#endif
        psyco_build_run_time_switch(&amp;psyfs_string_unicode, SkFlagFixed,
                                    values, cnt);
}

#endif /* _PSY_OBJECT_H */
</t>
<t tx="T245"> /***************************************************************/
/***           Psyco equivalent of stringobject.h              ***/
 /***************************************************************/

#ifndef _PSY_STRINGOBJECT_H
#define _PSY_STRINGOBJECT_H


#include "pobject.h"
#include "pabstract.h"


#define STR_OB_SVAL         QUARTER(offsetof(PyStringObject, ob_sval))


#define PsycoString_Check(tp) PyType_TypeCheck(tp, &amp;PyString_Type)
#ifdef Py_USING_UNICODE
# define PsycoUnicode_Check(tp) PyType_TypeCheck(tp, &amp;PyUnicode_Type)
#else
# define PsycoUnicode_Check(tp)                 0
#endif


inline vinfo_t* PsycoString_AS_STRING(PsycoObject* po, vinfo_t* v)
{	/* no type check */
	return integer_add_i(po, v, offsetof(PyStringObject, ob_sval));
}
inline vinfo_t* PsycoString_GET_SIZE(PsycoObject* po, vinfo_t* v)
{	/* no type check */
	return get_array_item(po, v, VAR_OB_SIZE);
}


EXTERNFN vinfo_t* PsycoCharacter_New(vinfo_t* chrval);


EXTERNFN void psy_stringobject_init();  /* nothing */

#endif /* _PSY_STRINGOBJECT_H */
</t>
<t tx="T246"> /***************************************************************/
/***    Meta-level for Psyco's own proxies (PsycoFuncObject)   ***/
 /***************************************************************/

#ifndef _PSY_PSYCOFUNCOBJECT_H
#define _PSY_PSYCOFUNCOBJECT_H


#include "../psyco.h"
#include "pobject.h"
#include "pabstract.h"


EXTERNFN void psy_psycofuncobject_init();

#endif /* _PSY_PSYCOFUNCOBJECT_H */
</t>
<t tx="T247"> /***************************************************************/
/***            Psyco equivalent of tupleobject.h              ***/
 /***************************************************************/

#ifndef _PSY_TUPLEOBJECT_H
#define _PSY_TUPLEOBJECT_H


#include "pobject.h"
#include "pabstract.h"


#define TUPLE_OB_ITEM       QUARTER(offsetof(PyTupleObject, ob_item))

/* The following macro reads an item from a Psyco tuple without any
   checks. Be sure the item has already been loaded in the array of
   the vinfo_t. This should only be used after a successful call to
   PsycoTuple_Load(). */
#define PsycoTuple_GET_ITEM(vtuple, index)  \
		((vtuple)-&gt;array-&gt;items[TUPLE_OB_ITEM + (index)])


/***************************************************************/
/* virtual tuples.
   If 'source' is not NULL it gives the content of the tuple.
   If 'source' is NULL you have to initialize it yourself. */
EXTERNFN vinfo_t* PsycoTuple_New(int count, vinfo_t** source);

/* get the (possibly virtual) array of items in the tuple,
   returning the length of the tuple or -1 if it fails (items not known).
   The items are then found in tuple-&gt;array-&gt;items[TUPLE_OB_ITEM+i]. */
EXTERNFN int PsycoTuple_Load(vinfo_t* tuple);


EXTERNFN void psy_tupleobject_init();

#endif /* _PSY_TUPLEOBJECT_H */
</t>
<t tx="T248">#include "pabstract.h"
#include "pintobject.h"
#include "plongobject.h"
#include "pstringobject.h"
#include "piterobject.h"

@others
</t>
<t tx="T249">@ ** This file is translated from the original 'abstract.c', see comments in the original file for the general ideas about the algorithms. ***/
Shorthand to return certain errors */
@c

static vinfo_t* type_error(PsycoObject* po, const char *msg)
{
	PycException_SetString(po, PyExc_TypeError, msg);
	return NULL;
}
</t>
<t tx="T250">DEFINEFN
vinfo_t* PsycoObject_Call(PsycoObject* po, vinfo_t* callable_object,
                          vinfo_t* args, vinfo_t* kw)
{	/* 'kw' may be NULL */
	ternaryfunc call;
	PyTypeObject* tp = Psyco_NeedType(po, callable_object);
	if (tp == NULL)
		return NULL;

	if ((call = tp-&gt;tp_call) != NULL) {
		if (kw == NULL)
			kw = psyco_viZero;
		return Psyco_META3(po, call, CfReturnRef|CfPyErrIfNull,
				   "vvv", callable_object, args, kw);
	}
	PycException_SetFormat(po, PyExc_TypeError,
			       "object of type '%.100s' is not callable",
			       tp-&gt;tp_name);
	return NULL;
}
</t>
<t tx="T251"></t>
<t tx="T252">DEFINEFN
vinfo_t* psyco_generic_immut_ob_size(PsycoObject* po, vinfo_t* vi)
{
	vinfo_t* result = get_array_item(po, vi, VAR_OB_SIZE);
	if (result != NULL)
		vinfo_incref(result);
	return result;
}
</t>
<t tx="T253">DEFINEFN
vinfo_t* psyco_generic_mut_ob_size(PsycoObject* po, vinfo_t* vi)
{
	return read_array_item(po, vi, VAR_OB_SIZE);
}
</t>
<t tx="T254">DEFINEFN
vinfo_t* PsycoObject_GetItem(PsycoObject* po, vinfo_t* o, vinfo_t* key)
{
	PyMappingMethods *m;
	PyTypeObject* tp = Psyco_NeedType(po, o);
	if (tp == NULL)
		return NULL;

	m = tp-&gt;tp_as_mapping;
	if (m &amp;&amp; m-&gt;mp_subscript)
		return Psyco_META2(po, m-&gt;mp_subscript,
				   CfReturnRef|CfPyErrIfNull, "vv", o, key);

	if (tp-&gt;tp_as_sequence) {
		PyTypeObject* ktp = Psyco_NeedType(po, key);
		if (ktp == NULL)
			return NULL;
		if (PsycoInt_Check(ktp))
			return PsycoSequence_GetItem(po, o,
						     PsycoInt_AS_LONG(po, key));
		else if (PsycoLong_Check(ktp)) {
			vinfo_t* key_value = PsycoLong_AsLong(po, key);
			if (key_value == NULL)
				return NULL;
			return PsycoSequence_GetItem(po, o, key_value);
		}
		return type_error(po, "sequence index must be integer");
	}

	return type_error(po, "unsubscriptable object");
}
</t>
<t tx="T255">DEFINEFN
vinfo_t* PsycoObject_Size(PsycoObject* po, vinfo_t* vi)
{
	PySequenceMethods *m;
	void* f;
	PyTypeObject* tp = Psyco_NeedType(po, vi);
	if (tp == NULL)
		return NULL;

	m = tp-&gt;tp_as_sequence;
	if (m &amp;&amp; m-&gt;sq_length)
		f = m-&gt;sq_length;
	else {
		PyMappingMethods *m2 = tp-&gt;tp_as_mapping;
		if (m2 &amp;&amp; m2-&gt;mp_length)
			f = m2-&gt;mp_length;
		else
			return type_error(po, "len() of unsized object");
	}
	
	return Psyco_META1(po, f, CfReturnNormal|CfPyErrIfNeg, "v", vi);
}
</t>
<t tx="T256">DEFINEFN
vinfo_t* PsycoSequence_GetItem(PsycoObject* po, vinfo_t* o, vinfo_t* i)
{
	PySequenceMethods *m;
	PyTypeObject* tp = Psyco_NeedType(po, o);
	if (tp == NULL)
		return NULL;

	m = tp-&gt;tp_as_sequence;
	if (m &amp;&amp; m-&gt;sq_item) {
		vinfo_t* result;
		vinfo_t* i2 = i;
		if (m-&gt;sq_length) {
			condition_code_t cc = integer_cmp_i(po, i, 0, Py_LT);
			if (cc == CC_ERROR)
				return NULL;
			if (runtime_condition_f(po, cc)) {
				vinfo_t* l = Psyco_META1(po, m-&gt;sq_length,
						CfReturnNormal|CfPyErrIfNeg,
							 "v", o);
				if (l == NULL)
					return NULL;
				i2 = integer_add(po, i, l, false);
				vinfo_decref(l, po);
				if (i2 == NULL)
					return NULL;
                                i = NULL;
			}
		}
		result = Psyco_META2(po, m-&gt;sq_item, CfReturnRef|CfPyErrIfNull,
				     "vv", o, i2);
		if (i == NULL)
			vinfo_decref(i2, po);
		return result;
	}

	return type_error(po, "unindexable object");
}
</t>
<t tx="T257">DEFINEFN
vinfo_t* PsycoSequence_GetSlice(PsycoObject* po, vinfo_t* o,
				vinfo_t* ilow, vinfo_t* ihigh)
{
	/* XXX implement me */
	return psyco_generic_call(po, PySequence_GetSlice,
				  CfReturnRef|CfPyErrIfNull,
				  "vvv", o, ilow, ihigh);
}
</t>
<t tx="T258"></t>
<t tx="T259">DEFINEFN
bool PsycoObject_SetItem(PsycoObject* po, vinfo_t* o, vinfo_t* key,
			 vinfo_t* value)
{
	/* XXX implement me */
	if (value != NULL)
		return psyco_flag_call(po, PyObject_SetItem,
				       CfReturnFlag|CfPyErrIfNonNull,
				       "vvv", o, key, value) != CC_ERROR;
	else
		return psyco_flag_call(po, PyObject_DelItem,
				       CfReturnFlag|CfPyErrIfNonNull,
				       "vv", o, key) != CC_ERROR;
}
</t>
<t tx="T260">DEFINEFN
bool PsycoSequence_SetItem(PsycoObject* po, vinfo_t* o, vinfo_t* i,
			   vinfo_t* value)
{
	/* XXX implement me */
	if (value != NULL)
		return psyco_flag_call(po, PySequence_SetItem,
				       CfReturnFlag|CfPyErrIfNonNull,
				       "vvv", o, i, value) != CC_ERROR;
	else
		return psyco_flag_call(po, PySequence_DelItem,
				       CfReturnFlag|CfPyErrIfNonNull,
				       "vv", o, i) != CC_ERROR;
}
</t>
<t tx="T261">DEFINEFN
bool PsycoSequence_SetSlice(PsycoObject* po, vinfo_t* o,
			    vinfo_t* ilow, vinfo_t* ihigh, vinfo_t* value)
{
	/* XXX implement me */
	if (value != NULL)
		return psyco_flag_call(po, PySequence_SetSlice,
				       CfReturnFlag|CfPyErrIfNonNull,
				       "vvvv", o, ilow, ihigh, value)!= CC_ERROR;
	else
		return psyco_flag_call(po, PySequence_DelSlice,
				       CfReturnFlag|CfPyErrIfNonNull,
				       "vvv", o, ilow, ihigh) != CC_ERROR;
}
</t>
<t tx="T262"></t>
<t tx="T263">DEFINEFN
vinfo_t* PsycoNumber_Positive(PsycoObject* po, vinfo_t* vi)
{
	PyNumberMethods *m;
	PyTypeObject* tp = Psyco_NeedType(po, vi);
	if (tp == NULL)
		return NULL;

	m = tp-&gt;tp_as_number;
	if (m &amp;&amp; m-&gt;nb_positive)
		return Psyco_META1(po, m-&gt;nb_positive,
				   CfReturnRef|CfPyErrIfNull, "v", vi);

	return type_error(po, "bad operand type for unary +");
}
</t>
<t tx="T264">DEFINEFN
vinfo_t* PsycoNumber_Negative(PsycoObject* po, vinfo_t* vi)
{
	PyNumberMethods *m;
	PyTypeObject* tp = Psyco_NeedType(po, vi);
	if (tp == NULL)
		return NULL;

	m = tp-&gt;tp_as_number;
	if (m &amp;&amp; m-&gt;nb_negative)
		return Psyco_META1(po, m-&gt;nb_negative,
				   CfReturnRef|CfPyErrIfNull, "v", vi);

	return type_error(po, "bad operand type for unary -");
}
</t>
<t tx="T265">DEFINEFN
vinfo_t* PsycoNumber_Invert(PsycoObject* po, vinfo_t* vi)
{
	PyNumberMethods *m;
	PyTypeObject* tp = Psyco_NeedType(po, vi);
	if (tp == NULL)
		return NULL;

	m = tp-&gt;tp_as_number;
	if (m &amp;&amp; m-&gt;nb_invert)
		return Psyco_META1(po, m-&gt;nb_invert,
				   CfReturnRef|CfPyErrIfNull, "v", vi);

	return type_error(po, "bad operand type for unary ~");
}
</t>
<t tx="T266">#ifdef Py_TPFLAGS_CHECKTYPES
# define NEW_STYLE_NUMBER(otp) PyType_HasFeature((otp), \
				Py_TPFLAGS_CHECKTYPES)
#else
# define NEW_STYLE_NUMBER(otp)     0
#endif


#define NB_SLOT(x) offsetof(PyNumberMethods, x)
#define NB_BINOP(nb_methods, slot) \
		((binaryfunc*)(&amp; ((char*)nb_methods)[slot] ))
#define NB_TERNOP(nb_methods, slot) \
		((ternaryfunc*)(&amp; ((char*)nb_methods)[slot] ))


/* the 'cimpl_xxx()' functions are called at run-time, to do things
   we give up to write at the meta-level in the PsycoXxx() functions. */
static PyObject* cimpl_oldstyle_binary_op1(PyObject* v, PyObject* w,
					   const int op_slot)
{
	int err = PyNumber_CoerceEx(&amp;v, &amp;w);
	if (err &lt; 0) {
		return NULL;
	}
	if (err == 0) {
		PyNumberMethods *mv = v-&gt;ob_type-&gt;tp_as_number;
		if (mv) {
			binaryfunc slot;
			slot = *NB_BINOP(mv, op_slot);
			if (slot) {
				PyObject *x = slot(v, w);
				Py_DECREF(v);
				Py_DECREF(w);
				return x;
			}
		}
		/* CoerceEx incremented the reference counts */
		Py_DECREF(v);
		Py_DECREF(w);
	}
	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
</t>
<t tx="T267">static vinfo_t* binary_op1(PsycoObject* po, vinfo_t* v, vinfo_t* w,
			   const int op_slot)
{
	vinfo_t* x;
	binaryfunc slotv = NULL;
	binaryfunc slotw = NULL;
	
	PyTypeObject* vtp;
	PyTypeObject* wtp;
	vtp = Psyco_NeedType(po, v);
	if (vtp == NULL)
		return NULL;
	wtp = Psyco_NeedType(po, w);
	if (wtp == NULL)
		return NULL;

	if (vtp-&gt;tp_as_number != NULL &amp;&amp; NEW_STYLE_NUMBER(vtp))
		slotv = *NB_BINOP(vtp-&gt;tp_as_number, op_slot);
	if (wtp != vtp &amp;&amp;
	    wtp-&gt;tp_as_number != NULL &amp;&amp; NEW_STYLE_NUMBER(wtp)) {
		slotw = *NB_BINOP(wtp-&gt;tp_as_number, op_slot);
		if (slotw == slotv)
			slotw = NULL;
	}
	if (slotv) {
		if (slotw &amp;&amp; PyType_IsSubtype(wtp, vtp)) {
			x = Psyco_META2(po, slotw,
					CfReturnRef|CfPyErrNotImplemented,
					"vv", v, w);
			if (x != psyco_viNotImplemented)
				return x;  /* may be NULL */
			vinfo_decref(x, po); /* can't do it */
			slotw = NULL;
		}
		x = Psyco_META2(po, slotv,
				CfReturnRef|CfPyErrNotImplemented, "vv", v, w);
		if (x != psyco_viNotImplemented)
			return x;
		vinfo_decref(x, po); /* can't do it */
	}
	if (slotw) {
		x = Psyco_META2(po, slotw, CfReturnRef|CfPyErrNotImplemented,
				"vv", v, w);
		if (x != psyco_viNotImplemented)
			return x;
		vinfo_decref(x, po); /* can't do it */
	}
	if (!NEW_STYLE_NUMBER(vtp) || !NEW_STYLE_NUMBER(wtp)) {
		/* no optimization for the part specific to old-style numbers */
		return psyco_generic_call(po, cimpl_oldstyle_binary_op1,
                                          CfReturnRef|CfPyErrIfNull,
					  "vvl", v, w, op_slot);
	}
	vinfo_incref(psyco_viNotImplemented);
	return psyco_viNotImplemented;
}
</t>
<t tx="T268">static vinfo_t* binary_op(PsycoObject* po, vinfo_t* v, vinfo_t* w,
			  const int op_slot, const char *op_name)
{
	vinfo_t* result = binary_op1(po, v, w, op_slot);
	if (result == psyco_viNotImplemented) {
		vinfo_decref(result, po);
		PycException_SetFormat(po, PyExc_TypeError,
			"unsupported operand type(s) for %s: '%s' and '%s'",
				       op_name,
				       Psyco_FastType(v)-&gt;tp_name,
				       Psyco_FastType(w)-&gt;tp_name);
		return NULL;
	}
	return result;
}
</t>
<t tx="T269">#define BINARY_FUNC(func, op, op_name)					\
DEFINEFN vinfo_t* func(PsycoObject* po, vinfo_t* v, vinfo_t* w) {	\
	return binary_op(po, v, w, NB_SLOT(op), op_name);		\
}

BINARY_FUNC(PsycoNumber_Or, nb_or, "|")
BINARY_FUNC(PsycoNumber_Xor, nb_xor, "^")
BINARY_FUNC(PsycoNumber_And, nb_and, "&amp;")
BINARY_FUNC(PsycoNumber_Lshift, nb_lshift, "&lt;&lt;")
BINARY_FUNC(PsycoNumber_Rshift, nb_rshift, "&gt;&gt;")
BINARY_FUNC(PsycoNumber_Subtract, nb_subtract, "-")
BINARY_FUNC(PsycoNumber_Multiply, nb_multiply, "*")
BINARY_FUNC(PsycoNumber_Divide, nb_divide, "/")
BINARY_FUNC(PsycoNumber_Divmod, nb_divmod, "divmod()")


DEFINEFN
vinfo_t* PsycoNumber_Add(PsycoObject* po, vinfo_t* v, vinfo_t* w)
{
	vinfo_t* result = binary_op1(po, v, w, NB_SLOT(nb_add));
	if (result == psyco_viNotImplemented) {
		PySequenceMethods* m;
		vinfo_decref(result, po);
		m = Psyco_FastType(v)-&gt;tp_as_sequence;
		if (m &amp;&amp; m-&gt;sq_concat) {
			result = Psyco_META2(po, m-&gt;sq_concat,
					     CfReturnRef|CfPyErrIfNull,
					     "vv", v, w);
		}
                else {
			PycException_SetFormat(po, PyExc_TypeError,
			    "unsupported operand types for +: '%s' and '%s'",
					       Psyco_FastType(v)-&gt;tp_name,
					       Psyco_FastType(w)-&gt;tp_name);
			result = NULL;
                }
	}
	return result;
}
</t>
<t tx="T270">DEFINEFN
vinfo_t* PsycoNumber_Remainder(PsycoObject* po, vinfo_t* v, vinfo_t* w)
{
	PyTypeObject* vtp = Psyco_NeedType(po, v);
	if (vtp == NULL)
		return NULL;
	if (PsycoString_Check(vtp))
		return psyco_generic_call(po, PyString_Format,
                                          CfReturnRef|CfPyErrIfNull,
					  "vv", v, w);
#ifdef Py_USING_UNICODE
	else if (PsycoUnicode_Check(vtp))
		return psyco_generic_call(po, PyUnicode_Format,
                                          CfReturnRef|CfPyErrIfNull,
					  "vv", v, w);
#endif
	return binary_op(po, v, w, NB_SLOT(nb_remainder), "%");
}
</t>
<t tx="T271">DEFINEFN
vinfo_t* PsycoNumber_Power(PsycoObject* po, vinfo_t* v1, vinfo_t* v2, vinfo_t*v3)
{
	/* XXX implement the ternary operators */
	return psyco_generic_call(po, PyNumber_Power, CfReturnRef|CfPyErrIfNull,
				  "vvv", v1, v2, v3);
}
</t>
<t tx="T272">@ XXX implement the in-place operators */
@c

DEFINEFN
vinfo_t* PsycoNumber_InPlaceAdd(PsycoObject* po, vinfo_t* v1, vinfo_t* v2) {
	return psyco_generic_call(po, PyNumber_InPlaceAdd,
                                  CfReturnRef|CfPyErrIfNull,
				  "vv", v1, v2);
}
</t>
<t tx="T273">DEFINEFN
vinfo_t* PsycoNumber_InPlaceOr(PsycoObject* po, vinfo_t* v1, vinfo_t* v2) {
	return psyco_generic_call(po, PyNumber_InPlaceOr,
                                  CfReturnRef|CfPyErrIfNull,
				  "vv", v1, v2);
}
</t>
<t tx="T274">DEFINEFN
vinfo_t* PsycoNumber_InPlaceXor(PsycoObject* po, vinfo_t* v1, vinfo_t* v2) {
	return psyco_generic_call(po, PyNumber_InPlaceXor,
                                  CfReturnRef|CfPyErrIfNull,
				  "vv", v1, v2);
}
</t>
<t tx="T275">DEFINEFN
vinfo_t* PsycoNumber_InPlaceAnd(PsycoObject* po, vinfo_t* v1, vinfo_t* v2) {
	return psyco_generic_call(po, PyNumber_InPlaceAnd,
                                  CfReturnRef|CfPyErrIfNull,
				  "vv", v1, v2);
}
</t>
<t tx="T276">DEFINEFN
vinfo_t* PsycoNumber_InPlaceLshift(PsycoObject* po, vinfo_t* v1, vinfo_t* v2) {
	return psyco_generic_call(po, PyNumber_InPlaceLshift,
                                  CfReturnRef|CfPyErrIfNull,
				  "vv", v1, v2);
}
</t>
<t tx="T277">DEFINEFN
vinfo_t* PsycoNumber_InPlaceRshift(PsycoObject* po, vinfo_t* v1, vinfo_t* v2) {
	return psyco_generic_call(po, PyNumber_InPlaceRshift,
                                  CfReturnRef|CfPyErrIfNull,
				  "vv", v1, v2);
}
</t>
<t tx="T278">DEFINEFN
vinfo_t* PsycoNumber_InPlaceSubtract(PsycoObject* po, vinfo_t* v1, vinfo_t*v2) {
	return psyco_generic_call(po, PyNumber_InPlaceSubtract,
                                  CfReturnRef|CfPyErrIfNull,
				  "vv", v1, v2);
}
</t>
<t tx="T279">DEFINEFN
vinfo_t* PsycoNumber_InPlaceMultiply(PsycoObject* po, vinfo_t* v1, vinfo_t*v2) {
	return psyco_generic_call(po, PyNumber_InPlaceMultiply,
                                  CfReturnRef|CfPyErrIfNull,
				  "vv", v1, v2);
}
</t>
<t tx="T280">DEFINEFN
vinfo_t* PsycoNumber_InPlaceDivide(PsycoObject* po, vinfo_t* v1, vinfo_t* v2) {
	return psyco_generic_call(po, PyNumber_InPlaceDivide,
                                  CfReturnRef|CfPyErrIfNull,
				  "vv", v1, v2);
}
</t>
<t tx="T281">DEFINEFN
vinfo_t* PsycoNumber_InPlaceRemainder(PsycoObject* po, vinfo_t* v1,vinfo_t*v2) {
	return psyco_generic_call(po, PyNumber_InPlaceRemainder,
                                  CfReturnRef|CfPyErrIfNull,
				  "vv", v1, v2);
}
</t>
<t tx="T282">DEFINEFN
vinfo_t* PsycoNumber_InPlacePower(PsycoObject* po, vinfo_t* v1, vinfo_t* v2,
				  vinfo_t* v3) {
	return psyco_generic_call(po, PyNumber_InPlacePower,
                                  CfReturnRef|CfPyErrIfNull,
				  "vvv", v1, v2, v3);
}
</t>
<t tx="T283"></t>
<t tx="T284">DEFINEFN
vinfo_t* PsycoObject_GetIter(PsycoObject* po, vinfo_t* vi)
{
	getiterfunc f;
	PyTypeObject* t = Psyco_NeedType(po, vi);
	if (t == NULL)
		return NULL;
	if (PyType_HasFeature(t, Py_TPFLAGS_HAVE_ITER))
		f = t-&gt;tp_iter;
	else
		f = NULL;
	if (f == NULL) {
		if (PsycoSequence_Check(t))
			return PsycoSeqIter_New(vi);
		PycException_SetString(po, PyExc_TypeError,
				       "iteration over non-sequence");
		return NULL;
	}
	else {
		return psyco_generic_call(po, f, CfReturnRef|CfPyErrIfNull,
					  "v", vi);
	}
}
</t>
<t tx="T285">DEFINEFN
vinfo_t* PsycoIter_Next(PsycoObject* po, vinfo_t* iter)
{
	PyTypeObject* tp = Psyco_NeedType(po, iter);
	if (tp == NULL)
		return NULL;
	if (!PsycoIter_Check(tp)) {
		PycException_SetFormat(po, PyExc_TypeError,
				       "'%.100s' object is not an iterator",
				       tp-&gt;tp_name);
		return NULL;
	}
	return Psyco_META1(po, tp-&gt;tp_iternext, CfReturnRef|CfPyErrIterNext,
			   "v", iter);
}
</t>
<t tx="T286">&lt;&lt; pdictobject #includes &gt;&gt;
@others
</t>
<t tx="T287">#include "pdictobject.h"
</t>
<t tx="T288">DEFINEFN
vinfo_t* PsycoDict_New(PsycoObject* po)
{
	/* no virtual dicts (yet?) */
	vinfo_t* v = psyco_generic_call(po, PyDict_New,
					CfReturnRef|CfPyErrIfNull, "");
	if (v == NULL)
		return NULL;

	/* the result is a dict */
	set_array_item(po, v, OB_TYPE,
		       vinfo_new(CompileTime_New((long)(&amp;PyDict_Type))));
	return v;
}
</t>
<t tx="T289">DEFINEFN
void psy_dictobject_init()
{
	PyMappingMethods *m = PyDict_Type.tp_as_mapping;
	Psyco_DefineMeta(m-&gt;mp_length, psyco_generic_mut_ob_size);
}
</t>
<t tx="T290">&lt;&lt; pfuncobject #includes &gt;&gt;
@others
</t>
<t tx="T291">#include "pfuncobject.h"
</t>
<t tx="T292">static vinfo_t* function_call(PsycoObject* po, vinfo_t* func,
                              vinfo_t* arg, vinfo_t* kw)
{
	/* calling a Python function: compile the called function if
	   auto_recursion &gt; 0. We promote the Python function to
	   compile-time if it is not known yet. */
	if (po-&gt;pr.auto_recursion &gt; 0 &amp;&amp; psyco_knowntobe(kw, (long) NULL)) {
		PyObject* pyfunc = psyco_pyobj_atcompiletime(po, func);
		if (pyfunc == NULL)
			return NULL;
		return psyco_call_pyfunc(po, (PyFunctionObject*) pyfunc,
					 arg, po-&gt;pr.auto_recursion - 1);
	}
	else
		return psyco_generic_call(po, PyFunction_Type.tp_call,
					  CfReturnRef|CfPyErrIfNull,
					  "vvv", func, arg, kw);
}
</t>
<t tx="T293">DEFINEFN
void psy_funcobject_init()
{
	Psyco_DefineMeta(PyFunction_Type.tp_call, function_call);
}
</t>
<t tx="T294">&lt;&lt; pintobject #includes &gt;&gt;
@others
</t>
<t tx="T295">#include "pintobject.h"
</t>
<t tx="T296">DEFINEFN
vinfo_t* PsycoInt_AsLong(PsycoObject* po, vinfo_t* v)
{
	vinfo_t* result;
	PyNumberMethods *nb;
	PyTypeObject* tp;
	
	tp = Psyco_NeedType(po, v);
	if (tp == NULL)
		return NULL;

	if (PsycoInt_Check(tp)) {
		result = PsycoInt_AS_LONG(po, v);
		vinfo_incref(result);
		return result;
	}

	if ((nb = tp-&gt;tp_as_number) == NULL || nb-&gt;nb_int == NULL) {
		PycException_SetString(po, PyExc_TypeError,
				       "an integer is required");
		return NULL;
	}

	v = Psyco_META1(po, nb-&gt;nb_int,
			CfReturnRef|CfPyErrIfNull,
			"v", v);
	if (v == NULL)
		return NULL;
	
	/* silently assumes the result is an integer object */
	result = PsycoInt_AS_LONG(po, v);
	vinfo_incref(result);
	vinfo_decref(v, po);
	return result;
}
</t>
<t tx="T297">static bool compute_int(PsycoObject* po, vinfo_t* intobj)
{
	vinfo_t* newobj;
	vinfo_t* x;
	
	/* get the field 'ob_ival' from the Python object 'intobj' */
	x = get_array_item(po, intobj, INT_OB_IVAL);
	if (x == NULL)
		return false;

	/* call PyInt_FromLong() */
	newobj = psyco_generic_call(po, PyInt_FromLong,
				    CfPure|CfReturnRef|CfPyErrIfNull, "v", x);
	if (newobj == NULL)
		return false;

	/* move the resulting non-virtual Python object back into 'intobj' */
	vinfo_move(po, intobj, newobj);
	return true;
}
</t>
<t tx="T298">DEFINEVAR source_virtual_t psyco_computed_int;


 /***************************************************************/
  /*** integer objects meta-implementation                     ***/

static condition_code_t pint_nonzero(PsycoObject* po, vinfo_t* intobj)
{
	vinfo_t* ival = PsycoInt_AS_LONG(po, intobj);
	return integer_non_null(po, ival);
}
</t>
<t tx="T299">static vinfo_t* pint_pos(PsycoObject* po, vinfo_t* intobj)
{
	vinfo_t* vtp = vinfo_getitem(intobj, OB_TYPE);  /* might be NULL */
	if (psyco_knowntobe(vtp, (long)(&amp;PyInt_Type))) {
		vinfo_incref(intobj);
		return intobj;
	}
	else {
		vinfo_t* ival = PsycoInt_AS_LONG(po, intobj);
		if (ival == NULL)
			return NULL;
		return PsycoInt_FromLong(ival);
	}
}
</t>
<t tx="T300">static vinfo_t* pint_neg(PsycoObject* po, vinfo_t* intobj)
{
	vinfo_t* result;
	vinfo_t* ival = PsycoInt_AS_LONG(po, intobj);
	if (ival == NULL)
		return NULL;
	result = integer_neg(po, ival, true);
	if (result != NULL)
		return PsycoInt_FROM_LONG(result);
	
	if (PycException_Occurred(po))
		return NULL;
	/* overflow */
	return psyco_generic_call(po, PyInt_Type.tp_as_number-&gt;nb_negative,
				  CfPure|CfReturnRef|CfPyErrIfNull,
				  "v", intobj);
}
</t>
<t tx="T301">static vinfo_t* pint_invert(PsycoObject* po, vinfo_t* intobj)
{
	vinfo_t* result;
	vinfo_t* ival = PsycoInt_AS_LONG(po, intobj);
	if (ival == NULL)
		return NULL;
	result = integer_not(po, ival);
	if (result != NULL)
		result = PsycoInt_FROM_LONG(result);
	return result;
}
</t>
<t tx="T302">static vinfo_t* pint_abs(PsycoObject* po, vinfo_t* intobj)
{
	vinfo_t* result;
	vinfo_t* ival = PsycoInt_AS_LONG(po, intobj);
	if (ival == NULL)
		return NULL;
	result = integer_abs(po, ival, true);
	if (result != NULL)
		return PsycoInt_FROM_LONG(result);
	
	if (PycException_Occurred(po))
		return NULL;
	/* overflow */
	return psyco_generic_call(po, PyInt_Type.tp_as_number-&gt;nb_absolute,
				  CfPure|CfReturnRef|CfPyErrIfNull,
				  "v", intobj);
}
</t>
<t tx="T303">#define CONVERT_TO_LONG(vobj, vlng)				\
	if (Psyco_TypeSwitch(po, vobj, &amp;psyfs_int) == 0) {	\
		vlng = PsycoInt_AS_LONG(po, vobj);		\
		if (vlng == NULL)				\
			return NULL;				\
	}							\
	else {							\
		if (PycException_Occurred(po))			\
			return NULL;				\
		vinfo_incref(psyco_viNotImplemented);		\
		return psyco_viNotImplemented;			\
	}

static vinfo_t* pint_add(PsycoObject* po, vinfo_t* v, vinfo_t* w)
{
	vinfo_t* a;
	vinfo_t* b;
	vinfo_t* x;
	CONVERT_TO_LONG(v, a);
	CONVERT_TO_LONG(w, b);
	x = integer_add(po, a, b, true);
	if (x != NULL)
		return PsycoInt_FROM_LONG(x);
	if (PycException_Occurred(po))
		return NULL;
	/* overflow */
	return psyco_generic_call(po, PyInt_Type.tp_as_number-&gt;nb_add,
				  CfPure|CfReturnRef|CfPyErrIfNull,
				  "vv", v, w);
}
</t>
<t tx="T304">static vinfo_t* pint_sub(PsycoObject* po, vinfo_t* v, vinfo_t* w)
{
	vinfo_t* a;
	vinfo_t* b;
	vinfo_t* x;
	CONVERT_TO_LONG(v, a);
	CONVERT_TO_LONG(w, b);
	x = integer_sub(po, a, b, true);
	if (x != NULL)
		return PsycoInt_FROM_LONG(x);
	if (PycException_Occurred(po))
		return NULL;
	/* overflow */
	return psyco_generic_call(po, PyInt_Type.tp_as_number-&gt;nb_subtract,
				  CfPure|CfReturnRef|CfPyErrIfNull,
				  "vv", v, w);
}
</t>
<t tx="T305">static vinfo_t* pint_or(PsycoObject* po, vinfo_t* v, vinfo_t* w)
{
	vinfo_t* a;
	vinfo_t* b;
	vinfo_t* x;
	CONVERT_TO_LONG(v, a);
	CONVERT_TO_LONG(w, b);
	x = integer_or(po, a, b);
	if (x != NULL)
		x = PsycoInt_FROM_LONG(x);
	return x;
}
</t>
<t tx="T306">static vinfo_t* pint_and(PsycoObject* po, vinfo_t* v, vinfo_t* w)
{
	vinfo_t* a;
	vinfo_t* b;
	vinfo_t* x;
	CONVERT_TO_LONG(v, a);
	CONVERT_TO_LONG(w, b);
	x = integer_and(po, a, b);
	if (x != NULL)
		x = PsycoInt_FROM_LONG(x);
	return x;
}
</t>
<t tx="T307">DEFINEFN
void psy_intobject_init()
{
	PyNumberMethods *m = PyInt_Type.tp_as_number;
	Psyco_DefineMeta(m-&gt;nb_nonzero,  pint_nonzero);
	
	Psyco_DefineMeta(m-&gt;nb_positive, pint_pos);
	Psyco_DefineMeta(m-&gt;nb_negative, pint_neg);
	Psyco_DefineMeta(m-&gt;nb_invert,   pint_invert);
	Psyco_DefineMeta(m-&gt;nb_absolute, pint_abs);
	
	Psyco_DefineMeta(m-&gt;nb_add,      pint_add);
	Psyco_DefineMeta(m-&gt;nb_subtract, pint_sub);
	Psyco_DefineMeta(m-&gt;nb_or,       pint_or);
	Psyco_DefineMeta(m-&gt;nb_and,      pint_and);

	psyco_computed_int.compute_fn = &amp;compute_int;
}
</t>
<t tx="T308">&lt;&lt; piterobject #includes &gt;&gt;
@others
</t>
<t tx="T309">#include "piterobject.h"
</t>
<t tx="T310">static vinfo_t* piter_getiter(PsycoObject* po, vinfo_t* v)
{
	vinfo_incref(v);
	return v;
}
</t>
<t tx="T311">static vinfo_t* piter_next(PsycoObject* po, vinfo_t* v)
{
	vinfo_t* seq;
	vinfo_t* index;
	vinfo_t* result;
	vinfo_t* index_plus_1;
	
	seq = get_array_item(po, v, SEQITER_IT_SEQ);
	if (seq == NULL)
		return NULL;

	index = get_array_item(po, v, SEQITER_IT_INDEX);
	if (index == NULL)
		return NULL;
	index_plus_1 = integer_add_i(po, index, 1);
	if (index_plus_1 == NULL)
		return NULL;

	result = PsycoSequence_GetItem(po, seq, index);

	set_array_item(po, v, SEQITER_IT_INDEX, index_plus_1);

	if (result == NULL) {
		condition_code_t cc;
		cc = PycException_Matches(po, PyExc_IndexError);
		if (cc != CC_ERROR &amp;&amp; runtime_condition_t(po, cc)) {
			vinfo_incref(psyco_viNone);
			PycException_SetVInfo(po, PyExc_StopIteration,
					      psyco_viNone);
		}
	}
	return result;
}
</t>
<t tx="T312">static bool compute_seqiter(PsycoObject* po, vinfo_t* v)
{
	vinfo_t* seq;
	vinfo_t* index;
	vinfo_t* newobj;

	index = get_array_item(po, v, SEQITER_IT_INDEX);
	if (index == NULL)
		return false;

	seq = get_array_item(po, v, SEQITER_IT_SEQ);
	if (seq == NULL)
		return false;

	newobj = psyco_generic_call(po, PySeqIter_New,
				    CfReturnRef|CfPyErrIfNull, "v", seq);
	if (newobj == NULL)
		return false;

	/* Put the current index into the seq iterator.
	   This is done by putting the value directly in the
	   seqiterobject structure; it could be done by calling
	   PyIter_Next() n times but obviously that's not too
	   good a solution */
	if (!psyco_knowntobe(index, 0)) {
		if (!write_array_item(po, v, SEQITER_IT_INDEX, index)) {
			vinfo_decref(newobj, po);
			return false;
		}
	}

	/* Remove the SEQITER_IT_INDEX entry from v-&gt;array because it
	   is a mutable field now, and could be changed at any time by
	   anybody .*/
	v-&gt;array-&gt;items[SEQITER_IT_INDEX] = NULL;
	vinfo_decref(index, po);

	vinfo_move(po, v, newobj);
	return true;
}
</t>
<t tx="T313">DEFINEVAR source_virtual_t psyco_computed_seqiter;


DEFINEFN
void psy_iterobject_init()
{
	psyco_computed_seqiter.compute_fn = &amp;compute_seqiter;
        Psyco_DefineMeta(PySeqIter_Type.tp_iter, &amp;piter_getiter);
        Psyco_DefineMeta(PySeqIter_Type.tp_iternext, &amp;piter_next);
}
</t>
<t tx="T314">&lt;&lt; plistobject #includes &gt;&gt;
@others
</t>
<t tx="T315">#include "plistobject.h"
#include "pintobject.h"
#include "../Python/pbltinmodule.h"
</t>
<t tx="T316">DEFINEFN
vinfo_t* PsycoList_New(PsycoObject* po, int size)
{
	/* no virtual lists (yet?) */
	vinfo_t *v = psyco_generic_call(po, PyList_New,
					CfReturnRef|CfPyErrIfNull, "l", size);
	if (v == NULL)
		return NULL;

	/* the result is a list */
	set_array_item(po, v, OB_TYPE,
		       vinfo_new(CompileTime_New((long)(&amp;PyList_Type))));
	return v;
}
</t>
<t tx="T317">@ **************************************************************/
** list objects meta-implementation ***/
@c

static vinfo_t* plist_item(PsycoObject* po, vinfo_t* a, vinfo_t* i)
{
	condition_code_t cc;
	vinfo_t* vlen;
	vinfo_t* ob_item;
	vinfo_t* result;

	vlen = get_array_item(po, a, VAR_OB_SIZE);
	if (vlen == NULL)
		return NULL;
	
	cc = integer_cmp(po, i, vlen, Py_GE|COMPARE_UNSIGNED);
	if (cc == CC_ERROR)
		return NULL;

	if (runtime_condition_f(po, cc)) {
		PycException_SetString(po, PyExc_IndexError,
				       "list index out of range");
		return NULL;
	}

	if (a-&gt;source == VirtualTime_New(&amp;psyco_computed_range)) {
		/* optimize range().__getitem__() */
		/* XXX no support for 'step' right now,
		   so that the return value is simply 'start+i'. */
		vinfo_t* vstart = get_array_item(po, a, RANGE_START);
		if (vstart == NULL)
			return NULL;
		result = integer_add(po, i, vstart, false);
		if (result == NULL)
			return NULL;
		return PsycoInt_FROM_LONG(result);
	}

	ob_item = read_array_item(po, a, LIST_OB_ITEM);
	if (ob_item == NULL)
		return NULL;

	result = read_array_item_var(po, ob_item, 0, i, false);
	vinfo_decref(ob_item, po);
	return result;
}
</t>
<t tx="T318">DEFINEFN
void psy_listobject_init()
{
	PySequenceMethods *m = PyList_Type.tp_as_sequence;
	Psyco_DefineMeta(m-&gt;sq_length, psyco_generic_mut_ob_size);
	Psyco_DefineMeta(m-&gt;sq_item, plist_item);
}
</t>
<t tx="T319">&lt;&lt; plongobject #includes &gt;&gt;
@others
</t>
<t tx="T320">#include "plongobject.h"
</t>
<t tx="T321">DEFINEFN
vinfo_t* PsycoLong_AsLong(PsycoObject* po, vinfo_t* v)
{
	/* XXX implement me */
	return psyco_generic_call(po, PyLong_AsLong,
				  CfReturnNormal|CfPyErrCheckMinus1,
				  "v", v);
}
</t>
<t tx="T322">DEF_KNOWN_RET_TYPE_1(plong_pos, PyLong_Type.tp_as_number-&gt;nb_positive,
		     CfReturnRef|CfPyErrIfNull, PyLong_Type)
DEF_KNOWN_RET_TYPE_1(plong_neg, PyLong_Type.tp_as_number-&gt;nb_negative,
		     CfReturnRef|CfPyErrIfNull, PyLong_Type)
DEF_KNOWN_RET_TYPE_1(plong_invert, PyLong_Type.tp_as_number-&gt;nb_invert,
		     CfReturnRef|CfPyErrIfNull, PyLong_Type)
DEF_KNOWN_RET_TYPE_1(plong_abs, PyLong_Type.tp_as_number-&gt;nb_absolute,
		     CfReturnRef|CfPyErrIfNull, PyLong_Type)
DEF_KNOWN_RET_TYPE_2(plong_add, PyLong_Type.tp_as_number-&gt;nb_add,
		     CfReturnRef|CfPyErrIfNull, PyLong_Type)
DEF_KNOWN_RET_TYPE_2(plong_sub, PyLong_Type.tp_as_number-&gt;nb_subtract,
		     CfReturnRef|CfPyErrIfNull, PyLong_Type)
DEF_KNOWN_RET_TYPE_2(plong_or, PyLong_Type.tp_as_number-&gt;nb_or,
		     CfReturnRef|CfPyErrIfNull, PyLong_Type)
DEF_KNOWN_RET_TYPE_2(plong_and, PyLong_Type.tp_as_number-&gt;nb_and,
		     CfReturnRef|CfPyErrIfNull, PyLong_Type)

DEFINEFN
void psy_longobject_init()
{
	PyNumberMethods *m = PyLong_Type.tp_as_number;
	
	Psyco_DefineMeta(m-&gt;nb_positive, plong_pos);
	Psyco_DefineMeta(m-&gt;nb_negative, plong_neg);
	Psyco_DefineMeta(m-&gt;nb_invert,   plong_invert);
	Psyco_DefineMeta(m-&gt;nb_absolute, plong_abs);
	
	Psyco_DefineMeta(m-&gt;nb_add,      plong_add);
	Psyco_DefineMeta(m-&gt;nb_subtract, plong_sub);
	Psyco_DefineMeta(m-&gt;nb_or,       plong_or);
	Psyco_DefineMeta(m-&gt;nb_and,      plong_and);
}
</t>
<t tx="T323">&lt;&lt; pmethodobject #includes &gt;&gt;
@others
</t>
<t tx="T324">#include "pmethodobject.h"
#include "ptupleobject.h"
</t>
<t tx="T325">static vinfo_t* PsycoCFunction_Call(PsycoObject* po, vinfo_t* func,
				    vinfo_t* tuple, vinfo_t* kw)
{
	vinfo_t* vml = get_array_item(po, func, CFUNC_M_ML);
	if (vml == NULL)
		return NULL;
	
	if (is_compiletime(vml-&gt;source)) {
		/* optimize only if we know which C function we are calling. */
		PyMethodDef* ml = (PyMethodDef*) \
			CompileTime_Get(vml-&gt;source)-&gt;value;
		int flags = ml-&gt;ml_flags;
		int tuplesize;
		vinfo_t* carg;

		vinfo_t* vself = get_array_item(po, func, CFUNC_M_SELF);
		if (vself == NULL)
			return NULL;

		if (flags &amp; METH_KEYWORDS) {
			return Psyco_META3(po, ml-&gt;ml_meth,
					   CfReturnRef|CfPyErrIfNull,
					   "vvv", vself, tuple, kw);
		}
		if (!psyco_knowntobe(kw, (long) NULL))
			goto use_proxy;

		switch (flags) {
		case METH_VARARGS:
			carg = tuple;
			break;
		case METH_NOARGS:
			tuplesize = PsycoTuple_Load(tuple);
			if (tuplesize != 0)
				/* if size unknown or known to be != 0 */
				goto use_proxy;
			carg = psyco_viZero;
			break;
		case METH_O:
			tuplesize = PsycoTuple_Load(tuple);
			if (tuplesize != 1)
				/* if size unknown or known to be != 1 */
				goto use_proxy;
			carg = PsycoTuple_GET_ITEM(tuple, 0);
			break;
		default:
			goto use_proxy;
		}
		return Psyco_META2(po, ml-&gt;ml_meth, CfReturnRef|CfPyErrIfNull,
				   "vv", vself, carg);
	}

	/* default, slow version */
   use_proxy:
	return psyco_generic_call(po, PyCFunction_Call,
				  CfReturnRef|CfPyErrIfNull,
				  "vvv", func, tuple, kw);
}
</t>
<t tx="T326">DEFINEFN
void psy_methodobject_init()
{
	Psyco_DefineMeta(PyCFunction_Type.tp_call, PsycoCFunction_Call);
}
</t>
<t tx="T327">&lt;&lt; pobject #includes &gt;&gt;
&lt;&lt; pobject declarations &gt;&gt;
@others
</t>
<t tx="T328">#include "pobject.h"
#include "pintobject.h"
#include "pstringobject.h"
</t>
<t tx="T329">

DEFINEVAR fixed_switch_t psyfs_int;
DEFINEVAR fixed_switch_t psyfs_tuple_list;
</t>
<t tx="T330">DEFINEFN
condition_code_t PsycoObject_IsTrue(PsycoObject* po, vinfo_t* vi)
{
	PyTypeObject* tp;
	tp = (PyTypeObject*) Psyco_NeedType(po, vi);
	if (tp == NULL)
		return CC_ERROR;

	if (tp == Py_None-&gt;ob_type)
		return CC_ALWAYS_FALSE;
	
	else if (tp-&gt;tp_as_number != NULL &amp;&amp;
		 tp-&gt;tp_as_number-&gt;nb_nonzero != NULL)
		return Psyco_flag_META1(po, tp-&gt;tp_as_number-&gt;nb_nonzero,
					CfReturnFlag, "v", vi);
	
	else if (tp-&gt;tp_as_mapping != NULL &amp;&amp;
		 tp-&gt;tp_as_mapping-&gt;mp_length != NULL)
		return Psyco_flag_META1(po, tp-&gt;tp_as_mapping-&gt;mp_length,
					CfReturnFlag, "v", vi);
	
	else if (tp-&gt;tp_as_sequence != NULL &amp;&amp;
		 tp-&gt;tp_as_sequence-&gt;sq_length != NULL)
		return Psyco_flag_META1(po, tp-&gt;tp_as_sequence-&gt;sq_length,
					CfReturnFlag, "v", vi);

	else
		return CC_ALWAYS_TRUE;
}
</t>
<t tx="T331">DEFINEFN
vinfo_t* PsycoObject_Repr(PsycoObject* po, vinfo_t* vi)
{
	/* XXX implement me */
	vinfo_t* vstr = psyco_generic_call(po, PyObject_Repr,
					   CfReturnRef|CfPyErrIfNull,
					   "v", vi);
	if (vstr != NULL) {
		/* the result is a string */
		set_array_item(po, vstr, OB_TYPE,
		       vinfo_new(CompileTime_New((long)(&amp;PyString_Type))));
	}
	return vstr;
}
</t>
<t tx="T332">DEFINEFN
vinfo_t* PsycoObject_GetAttr(PsycoObject* po, vinfo_t* o, vinfo_t* attr_name)
{
	PyTypeObject* tp;
	
	switch (Psyco_TypeSwitch(po, attr_name, &amp;psyfs_string_unicode)) {

	case 0:  /* PyString_Type */
		break;

#ifdef Py_USING_UNICODE
	case 1:  /* PyUnicode_Type */
		goto generic;
#endif
	default:
		if (!PycException_Occurred(po)) {
			PycException_SetString(po, PyExc_TypeError,
					       "attribute name must be string");
		}
		return NULL;
	}

	tp = (PyTypeObject*) Psyco_NeedType(po, o);
	if (tp == NULL)
		return NULL;
	if (tp-&gt;tp_getattro != NULL)
		return Psyco_META2(po, tp-&gt;tp_getattro,
				   CfReturnRef|CfPyErrIfNull,
				   "vv", o, attr_name);
	if (tp-&gt;tp_getattr != NULL)
		return Psyco_META2(po, tp-&gt;tp_getattr,
				   CfReturnRef|CfPyErrIfNull,
				   "vv", o,
                                   PsycoString_AS_STRING(po, attr_name));

   generic:
	/* when the above fails */
	return psyco_generic_call(po, PyObject_GetAttr,
				  CfReturnRef|CfPyErrIfNull,
				  "vv", o, attr_name);
}
</t>
<t tx="T333">DEFINEFN
bool PsycoObject_SetAttr(PsycoObject* po, vinfo_t* o,
                         vinfo_t* attr_name, vinfo_t* v)
{
	/* XXX implement me */
	if (v != NULL)
		return psyco_flag_call(po, PyObject_SetAttr,
				       CfReturnFlag|CfPyErrIfNonNull,
				       "vvv", o, attr_name, v) != CC_ERROR;
	else
		return psyco_flag_call(po, PyObject_SetAttr,
				       CfReturnFlag|CfPyErrIfNonNull,
				       "vvl", o, attr_name, NULL) != CC_ERROR;
}
</t>
<t tx="T334">@ Macro to get the tp_richcompare field of a type if defined */
@c

#define RICHCOMPARE(t) (PyType_HasFeature((t), Py_TPFLAGS_HAVE_RICHCOMPARE) \
                         ? (t)-&gt;tp_richcompare : NULL)

/* Map rich comparison operators to their swapped version, e.g. LT --&gt; GT */
static int swapped_op[] = {Py_GT, Py_GE, Py_EQ, Py_NE, Py_LT, Py_LE};

static vinfo_t* try_rich_compare(PsycoObject* po, vinfo_t* v, vinfo_t* w, int op)
{
	bool swap;
	PyTypeObject* vtp = Psyco_FastType(v);
	PyTypeObject* wtp = Psyco_FastType(w);
	richcmpfunc f;
	vinfo_t* res;

	swap = (vtp != wtp &amp;&amp;
		PyType_IsSubtype(wtp, vtp) &amp;&amp;
		(f = RICHCOMPARE(wtp)) != NULL);
	if (swap) {
		res = Psyco_META3(po, f, CfReturnRef|CfPyErrNotImplemented,
				  "vvl", w, v, swapped_op[op]);
		if (res != psyco_viNotImplemented)
			return res;
		vinfo_decref(res, po);
	}
	if ((f = RICHCOMPARE(vtp)) != NULL) {
		res = Psyco_META3(po, f, CfReturnRef|CfPyErrNotImplemented,
				  "vvl", v, w, op);
		if (res != psyco_viNotImplemented)
			return res;
		vinfo_decref(res, po);
	}
	if (!swap &amp;&amp; (f = RICHCOMPARE(wtp)) != NULL) {
		return Psyco_META3(po, f, CfReturnRef|CfPyErrNotImplemented,
				   "vvl", w, v, swapped_op[op]);
	}
	res = psyco_viNotImplemented;
	vinfo_incref(res);
	return res;
}
</t>
<t tx="T335">inline vinfo_t* convert_3way_to_object(PsycoObject* po, int op, vinfo_t* c)
{
	condition_code_t cc = integer_cmp_i(po, c, 0, op);
	if (cc == CC_ERROR)
		return NULL;
	return PsycoInt_FROM_LONG(psyco_vinfo_condition(po, cc));
}
</t>
<t tx="T336">inline vinfo_t* try_3way_to_rich_compare(PsycoObject* po, vinfo_t* v,
					 vinfo_t* w, int op)
{
	/* XXX implement me (some day) */
	return psyco_generic_call(po, PyObject_RichCompare,
				  CfReturnRef|CfPyErrIfNull,
				  "vvl", v, w, (long) op);
}
</t>
<t tx="T337">DEFINEFN vinfo_t* PsycoObject_RichCompare(PsycoObject* po, vinfo_t* v,
					  vinfo_t* w, int op)
{
	PyTypeObject* vtp;
	PyTypeObject* wtp;
	vinfo_t* res;
	cmpfunc f;
	extra_assert(Py_LT &lt;= op &amp;&amp; op &lt;= Py_GE);
	
	/* XXX try to detect circular data structures */

	vtp = (PyTypeObject*) Psyco_NeedType(po, v);
	if (vtp == NULL)
		return NULL;
	wtp = (PyTypeObject*) Psyco_NeedType(po, w);
	if (wtp == NULL)
		return NULL;

	/* If the types are equal, don't bother with coercions etc. 
	   Instances are special-cased in try_3way_compare, since
	   a result of 2 does *not* mean one value being greater
	   than the other. */
	if (vtp == wtp
	    &amp;&amp; (f = vtp-&gt;tp_compare) != NULL
	    &amp;&amp; !PyType_TypeCheck(vtp, &amp;PyInstance_Type)) {
		vinfo_t* c;
		richcmpfunc f1;
		if (vtp == &amp;PyInt_Type) {
			/* Special-case integers because they don't use
			   rich comparison, and the plain 3-way comparisons
			   are too low-level for serious optimizations
			   (they would require building the value -1, 0 or
			   1 in a register and then testing it). */
			return PsycoIntInt_RichCompare(po, v, w, op);
		}
		if ((f1 = RICHCOMPARE(vtp)) != NULL) {
			/* If the type has richcmp, try it first.
			   try_rich_compare would try it two-sided,
			   which is not needed since we've a single
			   type only. */
			res = Psyco_META3(po, f1,
					  CfReturnRef|CfPyErrNotImplemented,
					  "vvl", v, w, (long) op);
			if (res != psyco_viNotImplemented)
				return res;
			vinfo_decref(res, po);
		}
		c = Psyco_META2(po, f, CfReturnNormal|CfPyErrCheck,
				"vv", v, w);
		if (c == NULL)
			return NULL;
		return convert_3way_to_object(po, op, c);
	}

	res = try_rich_compare(po, v, w, op);
	if (res != psyco_viNotImplemented)
		return res;
	vinfo_decref(res, po);

	return try_3way_to_rich_compare(po, v, w, op);
}
</t>
<t tx="T338">DEFINEFN
condition_code_t PsycoObject_RichCompareBool(PsycoObject* po,
                                             vinfo_t* v,
                                             vinfo_t* w, int op)
{
	condition_code_t cc;
	vinfo_t* result = PsycoObject_RichCompare(po, v, w, op);
	if (result == NULL)
		return CC_ERROR;
        cc = PsycoObject_IsTrue(po, result);
        vinfo_decref(result, po);
	return cc;
}
</t>
<t tx="T339">&lt;&lt; pstringobject #includes &gt;&gt;
&lt;&lt; pstringobject declarations &gt;&gt;
@others
</t>
<t tx="T340">#include "pstringobject.h"
</t>
<t tx="T341">


/***************************************************************/
/* string characters.
   Should be changed to arbitrary string slices. */
static source_virtual_t psyco_computed_char;
</t>
<t tx="T342">#define CHARACTER_CHAR     STR_OB_SVAL

static PyObject* cimpl_character(char c)
{
	return PyString_FromStringAndSize(&amp;c, 1);
}
</t>
<t tx="T343">static bool compute_char(PsycoObject* po, vinfo_t* v)
{
	vinfo_t* chrval;
	vinfo_t* newobj;

	chrval = get_array_item(po, v, CHARACTER_CHAR);
	if (chrval == NULL)
		return false;

	newobj = psyco_generic_call(po, cimpl_character,
				    CfPure|CfReturnRef|CfPyErrIfNull,
				    "v", chrval);
	if (newobj == NULL)
		return false;

	/* move the resulting non-virtual Python object back into 'v' */
	vinfo_move(po, v, newobj);
	return true;
}
</t>
<t tx="T344">inline vinfo_t* PsycoCharacter_NEW(vinfo_t* chrval)
{
	/* consumes a ref to 'chrval' */
	vinfo_t* result = vinfo_new(VirtualTime_New(&amp;psyco_computed_char));
	result-&gt;array = array_new(CHARACTER_CHAR+1);
	result-&gt;array-&gt;items[OB_TYPE] =
		vinfo_new(CompileTime_New((long)(&amp;PyString_Type)));
	result-&gt;array-&gt;items[VAR_OB_SIZE] = psyco_viOne;
	vinfo_incref(psyco_viOne);
	result-&gt;array-&gt;items[CHARACTER_CHAR] = chrval;
	return result;
}
</t>
<t tx="T345">DEFINEFN
vinfo_t* PsycoCharacter_New(vinfo_t* chrval)
{
	vinfo_incref(chrval);
	return PsycoCharacter_NEW(chrval);
}
</t>
<t tx="T346">@ **************************************************************/
** string objects meta-implementation ***/
@c

static vinfo_t* pstring_item(PsycoObject* po, vinfo_t* a, vinfo_t* i)
{
	condition_code_t cc;
	vinfo_t* vlen;
        vinfo_t* result;

	vlen = get_array_item(po, a, VAR_OB_SIZE);
	if (vlen == NULL)
		return NULL;
	
	cc = integer_cmp(po, i, vlen, Py_GE|COMPARE_UNSIGNED);
	if (cc == CC_ERROR)
		return NULL;

	if (runtime_condition_f(po, cc)) {
		PycException_SetString(po, PyExc_IndexError,
				       "string index out of range");
		return NULL;
	}
	
	result = read_immut_array_item_var(po, a, STR_OB_SVAL, i, true);
	if (result == NULL)
		return NULL;

	return PsycoCharacter_NEW(result);
}
</t>
<t tx="T347">DEFINEFN
void psy_stringobject_init()
{
	PySequenceMethods *m = PyString_Type.tp_as_sequence;
	Psyco_DefineMeta(m-&gt;sq_length, psyco_generic_immut_ob_size);
	Psyco_DefineMeta(m-&gt;sq_item, pstring_item);
	psyco_computed_char.compute_fn = &amp;compute_char;
}
</t>
<t tx="T348">&lt;&lt; psycofuncobject #includes &gt;&gt;
@others
</t>
<t tx="T349">#include "psycofuncobject.h"
</t>
<t tx="T350">static vinfo_t* meta_psycofunction_call(PsycoObject* po, vinfo_t* func,
				   vinfo_t* arg, vinfo_t* kw)
{
	PsycoFunctionObject* psyfunc;
	if (!psyco_knowntobe(kw, (long) NULL))  /* XXX support keywords */
		return psyco_generic_call(po, PsycoFunction_Type.tp_call,
					  CfReturnRef|CfPyErrIfNull,
					  "vvv", func, arg, kw);
	
	/* calling a Psyco proxy to a Python function: always compile
	   the function. We promote the PsycoFunctionObject to
	   compile-time if it is not known yet. */
	psyfunc = (PsycoFunctionObject*) psyco_pyobj_atcompiletime(po, func);
	if (psyfunc == NULL)
		return NULL;
	return psyco_call_pyfunc(po, psyfunc-&gt;psy_func,
				 arg, psyfunc-&gt;psy_recursion);
}
</t>
<t tx="T351">DEFINEFN
void psy_psycofuncobject_init()
{
	Psyco_DefineMeta(PsycoFunction_Type.tp_call, meta_psycofunction_call);
}
</t>
<t tx="T352">&lt;&lt; ptupleobject #includes &gt;&gt;
&lt;&lt; ptupleobject declarations &gt;&gt;
@others
</t>
<t tx="T353">#include "ptupleobject.h"
</t>
<t tx="T354">

 /***************************************************************/
  /***   Virtual tuples                                        ***/

static source_virtual_t psyco_computed_tuple;
</t>
<t tx="T355">static bool compute_tuple(PsycoObject* po, vinfo_t* v)
{
	int i, tuple_end = v-&gt;array-&gt;count;
	
	extra_assert(tuple_end == TUPLE_OB_ITEM +
		   CompileTime_Get(v-&gt;array-&gt;items[VAR_OB_SIZE]-&gt;source)-&gt;value);
	
	/* check whether all tuple objects are constant */
	for (i=TUPLE_OB_ITEM; i&lt;tuple_end; i++) {
		vinfo_t* vi = v-&gt;array-&gt;items[i];
		NonVirtualSource src = vinfo_compute(vi, po);
		if (src == SOURCE_ERROR)
			return false;
		if (!is_compiletime(src))
			break;  /* no */
	}
	if (i == tuple_end) {
		/* yes -- let's build a constant compile-time tuple */
		source_known_t* sk;
		PyObject* constant = PyTuple_New(tuple_end - TUPLE_OB_ITEM);
		if (constant == NULL)
			OUT_OF_MEMORY();
		for (i=TUPLE_OB_ITEM; i&lt;tuple_end; i++) {
			PyObject* obj;
			sk = CompileTime_Get(v-&gt;array-&gt;items[i]-&gt;source);
			obj = (PyObject*) sk-&gt;value;
			Py_INCREF(obj);
			PyTuple_SET_ITEM(constant, i-TUPLE_OB_ITEM, obj);
		}
		sk = sk_new((long) constant, SkFlagPyObj);
		v-&gt;source = CompileTime_NewSk(sk);
	}
	else {
		/* no -- code a call to PyTuple_New() */
		vinfo_t* tuple = psyco_generic_call(po, PyTuple_New,
                                                    CfReturnRef|CfPyErrIfNull,
                                                    "l",
                                                    tuple_end - TUPLE_OB_ITEM);
		if (tuple == NULL)
			return false;

		/* write the storing of the objects in the tuple */
		for (i=TUPLE_OB_ITEM; i&lt;tuple_end; i++) {
			vinfo_t* vi = v-&gt;array-&gt;items[i];
			if (!write_array_item_ref(po, tuple, i, vi, false)) {
				vinfo_decref(tuple, po);
				return false;
			}
		}
		vinfo_move(po, v, tuple);
	}
	return true;
}
</t>
<t tx="T356">DEFINEFN
vinfo_t* PsycoTuple_New(int count, vinfo_t** source)
{
	int i;
	vinfo_t* r = vinfo_new(VirtualTime_New(&amp;psyco_computed_tuple));
	r-&gt;array = array_new(TUPLE_OB_ITEM + count);
	r-&gt;array-&gt;items[OB_TYPE] =
		vinfo_new(CompileTime_New((long)(&amp;PyTuple_Type)));
	r-&gt;array-&gt;items[VAR_OB_SIZE] = vinfo_new(CompileTime_New(count));
	if (source != NULL)
		for (i=0; i&lt;count; i++) {
			vinfo_incref(source[i]);
			r-&gt;array-&gt;items[TUPLE_OB_ITEM + i] = source[i];
		}
	return r;
}
</t>
<t tx="T357">@ do not load a constant tuple into a vinfo_array_t if longer than: */
@c

#define CT_TUPLE_LOAD_SIZE_LIMIT    15

DEFINEFN
int PsycoTuple_Load(vinfo_t* tuple)
{
	int size;
	/* if the tuple is virtual, then all items in its
	   vinfo_array_t are already filled */
	if (tuple-&gt;source == VirtualTime_New(&amp;psyco_computed_tuple))
		size = tuple-&gt;array-&gt;count - TUPLE_OB_ITEM;
	else if (is_compiletime(tuple-&gt;source)) {
		/* a constant tuple means constant tuple items */
		int i;
		PyObject* o = (PyObject*)(CompileTime_Get(tuple-&gt;source)-&gt;value);
		extra_assert(PyTuple_Check(o));
		size = PyTuple_GET_SIZE(o);
		if (tuple-&gt;array-&gt;count &lt; TUPLE_OB_ITEM + size) {
			if (/*not_too_much &amp;&amp;*/ size &gt; CT_TUPLE_LOAD_SIZE_LIMIT)
				return -1;
			vinfo_array_grow(tuple, TUPLE_OB_ITEM + size);
		}
		/* load the tuple into the vinfo_array_t */
		for (i=0; i&lt;size; i++) {
			if (tuple-&gt;array-&gt;items[TUPLE_OB_ITEM + i] == NULL) {
				PyObject* item = PyTuple_GET_ITEM(o, i);
				source_known_t* sk = sk_new((long) item,
							    SkFlagPyObj);
				Py_INCREF(item);
				tuple-&gt;array-&gt;items[TUPLE_OB_ITEM + i] =
					vinfo_new(CompileTime_NewSk(sk));
			}
		}
	}
	else
		return -1;
	return size;
}
</t>
<t tx="T358">@ **************************************************************/
** tuple objects meta-implementation ***/
@c

static vinfo_t* ptuple_item(PsycoObject* po, vinfo_t* a, vinfo_t* i)
{
	condition_code_t cc;
	vinfo_t* vlen;

	vlen = get_array_item(po, a, VAR_OB_SIZE);
	if (vlen == NULL)
		return NULL;
	
	cc = integer_cmp(po, i, vlen, Py_GE|COMPARE_UNSIGNED);
	if (cc == CC_ERROR)
		return NULL;

	if (runtime_condition_f(po, cc)) {
		PycException_SetString(po, PyExc_IndexError,
				       "tuple index out of range");
		return NULL;
	}
        
        return read_immut_array_item_var(po, a, TUPLE_OB_ITEM, i, false);
}
</t>
<t tx="T359">DEFINEFN
void psy_tupleobject_init()
{
	PySequenceMethods *m = PyTuple_Type.tp_as_sequence;
	Psyco_DefineMeta(m-&gt;sq_length, psyco_generic_immut_ob_size);
	Psyco_DefineMeta(m-&gt;sq_item, ptuple_item);
	psyco_computed_tuple.compute_fn = &amp;compute_tuple;
}
</t>
<t tx="T360">@language c</t>
<t tx="T361"> /***************************************************************/
/***               interface to bltinmodule.c                  ***/
 /***************************************************************/

#ifndef _PSY_BLTINMODULE_H
#define _PSY_BLTINMODULE_H


#include "pycompiler.h"


#define RANGE_LEN           VAR_OB_SIZE       /* for virtual range() only */
#define RANGE_START         (LIST_OB_ITEM+1)  /*       "                  */
/*#define RANGE_STEP          (LIST_OB_ITEM+2)  *       "                  */
/* XXX no support for steps currently. Needs implementation of division to
   figure out the length. */

EXTERNVAR source_virtual_t psyco_computed_range;


EXTERNFN void psy_bltinmodule_init();

#endif /* _PSY_BLTINMODULE_H */
</t>
<t tx="T362"> /***************************************************************/
/***          Language-dependent structures                    ***/
 /***************************************************************/


#ifndef _PYCHEADER_H
#define _PYCHEADER_H


#include "../psyco.h"
#include "../encoding.h"
#include &lt;compile.h&gt;
#include &lt;frameobject.h&gt;


/* "Frames": the Python compiler may be interrupted between the
   compilation of two opcodes. Any local data it needs that should
   persist across such interruptions must be stored in the PsycoObject
   driving compilation. The PsycoObject plays the same role as the
   FrameObject in normal interpretation. The usual fields of
   FrameObjects are split into two groups:

   1) in the 'vlocals' array, as 'vinfo_t' structures. This makes
      dynamically-staged variables, that is, whose value may be known
      at compile-time, run-time or virtual-time only. Use the LOC_xxx
      macros to access these variables.

   2) in the 'pr' field whose structure is defined below. For
      compile-time-only data.

   IMPORTANT: the dispatcher only looks at LOC_xxx variables to
   determine if the needed code has already be compiled. If two
   PsycoObjects differ only by their 'pr' field, the code that
   the compiler would emit in each case must be interchangeable
   (but not necessary identical, as different optimizations
   could be done).
*/

#define INDEX_LOC_CODE          0   /* running code object */
#define INDEX_LOC_GLOBALS       1   /* globals() dict object */
#define INDEX_LOC_LOCALS_PLUS   2   /* local variables + stack */
#define INDEX_LOC_NEXT_INSTR    3   /* next instruction index */
#define NB_LOCALS               4

#define LOC_CODE            po-&gt;vlocals.items[INDEX_LOC_CODE]
#define LOC_GLOBALS         po-&gt;vlocals.items[INDEX_LOC_GLOBALS]
#define LOC_LOCALS_PLUS     po-&gt;vlocals.items[INDEX_LOC_LOCALS_PLUS]
#define LOC_NEXT_INSTR      po-&gt;vlocals.items[INDEX_LOC_NEXT_INSTR]


typedef struct {
  int auto_recursion;   /* # levels to auto-compile calls to Python functions */
  int iblock;		/* index in blockstack */
  PyTryBlock blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */
  
  /* fields after 'blockstack' are not saved in a FrozenPsycoObject */
  int stack_base;       /* number of items before the stack in LOC_LOCALS_PLUS */
  int stack_level;      /* see note below */
  char* merge_points;   /* see mergepoints.h */
  vinfo_t* exc;         /* current compile-time (pseudo) exception, see below */
  vinfo_t* val;         /* exception value */
  PyObject* f_builtins;
} pyc_data_t;

/* Note.
   'stack_level' is stored in 'pr'. To do so we must assume that the level
   of the interpreter value stack is always the same when execution reaches
   the same position in the bytecode. This is normally the case in Python,
   with a few exceptions that need to be worked around ('finally:' clauses
   in the original interpreter are invoked with a variable number of objects
   pushed on the stack; the present interpreter always only pushes one,
   grouping objects in a tuple if necessary (remember that tuples are
   abstracted to virtual-time, so this doesn't mean we loose time building
   and deconstructing Python tuples)).

   The same assumption holds for the other fields of pyc_data_t but only
   'stack_level' needs special care.
*/


/* some extra flags recognized by psyco_generic_call(). They tell how the
   Python C function signals errors. They are ignored by the Psyco_METAX()
   macros if a meta-implementation is found, as meta-implementations always
   signal errors by returning either (vinfo_t*)NULL or CC_ERROR. */
#define CfPyErrDontCheck    0x000   /* default: no check */
#define CfPyErrIfNull       0x100   /* a return == 0 (or NULL) means an error */
#define CfPyErrIfNonNull    0x200   /* a return != 0 means an error */
#define CfPyErrIfNeg        0x300   /* a return &lt; 0 means an error */
#define CfPyErrIfMinus1     0x400   /* only -1 means an error */
#define CfPyErrCheck        0x500   /* always check with PyErr_Occurred() */
#define CfPyErrCheckMinus1  0x600   /* use PyErr_Occurred() if return is -1 */
#define CfPyErrCheckNeg     0x700   /* use PyErr_Occurred() if return is &lt; 0 */
#define CfPyErrNotImplemented 0x800 /* test for a Py_NotImplemented result */
#define CfPyErrIterNext     0x900   /* specially for tp_iternext slots */

#define CfPyErrMask         0xF00

/* Note: CfPyErrNotImplemented means that the C function may return
   Py_NotImplemented, and this is checked; if true, then Psyco_METAX()
   returns exactly 'psyco_viNotImplemented', and not just a possibly run-time
   vinfo_t* containing Py_NotImplemented. Meta-implementations always return
   exactly 'psyco_viNotImplemented'. */

/* for psyco_generic_call() only */
EXTERNFN vinfo_t* generic_call_check(PsycoObject* po, int flags, vinfo_t* vi);


/* the following known values have the SkFlagFixed set */
EXTERNVAR vinfo_t* psyco_viNone;    /* known value 'Py_None' */
EXTERNVAR vinfo_t* psyco_viZero;    /* known value 0 */
EXTERNVAR vinfo_t* psyco_viOne;     /* known value 1 */
EXTERNVAR vinfo_t* psyco_viNotImplemented;   /* 'Py_NotImplemented' */


#endif /* _PYCHEADER_H */
</t>
<t tx="T363"> /***************************************************************/
/***          Language-dependent part of the compiler          ***/
 /***************************************************************/

#ifndef _PYCOMPILER_H
#define _PYCOMPILER_H


#include "pycheader.h"
#include "../vcompiler.h"
#include "../processor.h"
#include "../dispatcher.h"


EXTERNFN void psyco_pycompiler_init();


#ifdef PyString_CheckExact
# define NEW_STYLE_TYPES       1    /* Python &gt;=2.2b1 */
#else
# define NEW_STYLE_TYPES       0
# define PyString_CheckExact   PyString_Check
#endif


/*****************************************************************/
 /***   Compile-time Pseudo exceptions                          ***/


/*****
 * A pseudo-exception is the compile-time equivalent of a Python exception.
 * They are encoded in the fields 'exc' and 'val' of pyc_data_t. For real
 * Python the translation is immediate: 'exc' describes the PyObject*
 * pointing to the Python exception class, and 'val' is the associated value.
 *
 * For the other pseudo-exceptions, like special events breaking the Python
 * main loop (returns, break, continue), 'exc' is a virtual value using
 * one of the following non-computable virtual sources.
 *
 * 'ERtPython' is particular: it is the virtual equivalent of "the exception
 * currently set at run-time". Use PycException_Fetch() to emit the actual
 * call to PyErr_Fetch().
 */
EXTERNVAR source_virtual_t ERtPython;  /* Exception raised by Python */
EXTERNVAR source_virtual_t EReturn;    /* 'return' statement */
EXTERNVAR source_virtual_t EBreak;     /* 'break' statement */
EXTERNVAR source_virtual_t EContinue;  /* 'continue' statement */


/* Check whether a pseudo-exception is currently set */
inline bool PycException_Occurred(PsycoObject* po) {
	return po-&gt;pr.exc != NULL;
}


/* raise an arbitrary pseudo-exception (consumes the references) */
EXTERNFN void PycException_Clear(PsycoObject* po);
inline void PycException_Raise(PsycoObject* po, vinfo_t* exc, vinfo_t* val) {
	if (PycException_Occurred(po))
		PycException_Clear(po);
	po-&gt;pr.exc = exc;
	po-&gt;pr.val = val;
}

/* for Python exceptions detected at compile-time */
EXTERNFN void PycException_SetString(PsycoObject* po,
				     PyObject* e, const char* text);
EXTERNFN void PycException_SetFormat(PsycoObject* po,
				     PyObject* e, const char* fmt, ...);
 /* consumes a reference on 'v': */
EXTERNFN void PycException_SetObject(PsycoObject* po, PyObject* e, PyObject* v);
 /* consumes a reference on 'v': */
EXTERNFN void PycException_SetVInfo(PsycoObject* po, PyObject* e, vinfo_t* v);

/* checking for the Python class of an exception */
EXTERNFN condition_code_t PycException_Matches(PsycoObject* po, PyObject* e);

inline bool PycException_Is(PsycoObject* po, source_virtual_t* sv) {
	return po-&gt;pr.exc-&gt;source == VirtualTime_New(sv);
}
inline bool PycException_IsPython(PsycoObject* po) {
	Source src = po-&gt;pr.exc-&gt;source;
	if (is_virtualtime(src)) {
		return !(src == VirtualTime_New(&amp;EReturn) ||
			 src == VirtualTime_New(&amp;EBreak) ||
			 src == VirtualTime_New(&amp;EContinue) ||
			 psyco_vsource_is_promotion(src));
	}
	else
		return true;
};

/* fetch a Python exception set at compile-time (that is, now) and turn into
   a pseudo-exception (typically to be re-raised at run-time). */
EXTERNFN void psyco_virtualize_exception(PsycoObject* po);

/* fetch a Python exception set at run-time (that is, a ERtPython) and turn into
   a pseudo-exception. This is a no-op if !PycException_Is(po, &amp;ERtPython). */
EXTERNFN void PycException_Fetch(PsycoObject* po);


/*****************************************************************/
 /***   Promotion                                               ***/

/* Raise a pseudo-exception meaning "promote 'vi' from run-time to
   compile-time". If 'promotion-&gt;fs' is not NULL, only promote if the
   run-time value turns out to be in the given set.
*/
EXTERNFN void PycException_Promote(PsycoObject* po,
                                   vinfo_t* vi, c_promotion_t* promotion);

/* A powerful function: it appears to return the value of the
   variable 'vi', even if it is a run-time variable. Implemented
   by raising a EPromotion exception if needed. Returns -1 in
   this case; use PycException_Occurred() to know if it is really
   an exception or a plain normal -1. */
inline long psyco_atcompiletime(PsycoObject* po, vinfo_t *vi) {
	NonVirtualSource src = vinfo_compute(vi, po);
	if (src == SOURCE_ERROR)
		return -1;
	if (is_runtime(src)) {
		PycException_Promote(po, vi, &amp;psyco_nonfixed_promotion);
		return -1;
	}
	else {
		source_known_t* sk = CompileTime_Get(src);
		sk-&gt;refcount1_flags |= SkFlagFixed;
		return sk-&gt;value;
	}
}
/* the same if the value to promote is itself a PyObject* which can be
   used as key in the look-up dictionary */
inline PyObject* psyco_pyobj_atcompiletime(PsycoObject* po, vinfo_t *vi) {
	NonVirtualSource src = vinfo_compute(vi, po);
	if (src == SOURCE_ERROR)
		return NULL;
	if (is_runtime(src)) {
		PycException_Promote(po, vi, &amp;psyco_nonfixed_pyobj_promotion);
		return NULL;
	}
	else {
		source_known_t* sk = CompileTime_Get(src);
		sk-&gt;refcount1_flags |= SkFlagFixed;
		return (PyObject*) sk-&gt;value;
	}
}

/* same as above, when the return value is used in a switch.
   In this case we must only promote the known values. So instead
   of writing 'switch (psyco_atcompiletime(po, vi))' you
   must write 'switch (psyco_switch_index(po, vi, fs))' */
inline int psyco_switch_index(PsycoObject* po, vinfo_t* vi, fixed_switch_t* fs) {
	NonVirtualSource src = vinfo_compute(vi, po);
	if (src == SOURCE_ERROR)
		return -1;
	if (is_runtime(src)) {
		if (!known_to_be_default(vi, fs))
			PycException_Promote(po, vi, &amp;fs-&gt;fixed_promotion);
		return -1;
	}
	else
		return psyco_switch_lookup(fs, CompileTime_Get(src)-&gt;value);
}

/* lazy comparison. Returns true if 'vi' is non-NULL, compile-time, and has the
   given value, and false otherwise. */
inline bool psyco_knowntobe(vinfo_t* vi, long value) {
	return vi != NULL &amp;&amp; is_compiletime(vi-&gt;source) &amp;&amp;
		CompileTime_Get(vi-&gt;source)-&gt;value == value;
}

/* comparison with a special PyObject* value, e.g. Py_NotImplemented; assume
   that virtual sources are never one of these special objects. The _f version
   assumes a generally false outcome, and the _t version a generally true one. */
/* --- disabled, use CfPyErrNotImplemented instead --- */
/* inline bool psyco_is_special_f(PsycoObject* po, vinfo_t* vi, */
/*                                PyObject* value) { */
/* 	return !is_virtualtime(vi-&gt;source) &amp;&amp; */
/* 		runtime_condition_f(po, * integer_cmp_i does not fail here * */
/* 			    integer_cmp_i(po, vi, (long) value, Py_EQ)); */
/* } */
/* inline bool psyco_is_special_t(PsycoObject* po, vinfo_t* vi, PyObject* */
/*                                value) { */
/* 	return !is_virtualtime(vi-&gt;source) &amp;&amp; */
/* 		runtime_condition_t(po, * integer_cmp_i does not fail here * */
/* 			    integer_cmp_i(po, vi, (long) value, Py_EQ)); */
/* } */


/*****************************************************************/
 /***   Exception utilities                                     ***/

/* Psyco equivalent of PyErr_Occurred() */
inline condition_code_t PsycoErr_Occurred(PsycoObject* po) {
	if (PycException_Occurred(po) &amp;&amp; PycException_IsPython(po))
		return CC_ALWAYS_TRUE;
	else
		return psyco_flag_call(po, PyErr_Occurred, CfReturnFlag, "");
}


/*****************************************************************/
 /***   Meta functions                                          ***/

/* Each C function of the Python interpreter might be associated to a
   "meta" function from Psyco with the same signature but 'vinfo_t*' for
   the arguments and return value. The idea is that when such a meta
   function exists, Psyco can invoke it at compile-time to do (a part of)
   what the Python interpreter would do at run-time only. The code of the
   meta function typically ressembles that of the original function enough
   that we might dream about a language in which we never have to write
   the two versions (where Psyco's version could be derived automatically
   from the standard version).
*/

EXTERNVAR PyObject* Psyco_Meta_Dict;  /* key is a PyIntObject holding the
					 address of the C function, value is
					 a PyIntObject holding the address
					 of the corresponding Psyco function. */
EXTERNFN void Psyco_DefineMeta(void* c_function, void* psyco_function);
inline void* Psyco_Lookup(void* c_function) {
	PyObject* value;
	PyObject* key = PyInt_FromLong((long) c_function);
	if (key == NULL) OUT_OF_MEMORY();
	value = PyDict_GetItem(Psyco_Meta_Dict, key);
	Py_DECREF(key);
	if (value != NULL)
		return (void*) PyInt_AS_LONG(value);
	else
		return NULL;
}

/* for tables describing the content of a Python module and mapping its
   objects to meta-implementations */
typedef struct {
	char* cd_name;             /* name of an object in the module */
	int cd_flags;              /* METH_xxx or CD_META_xxx */
	void* cd_function;         /* filled by Psyco_DefineMetaModule() */
} cfunc_descr_t;
typedef struct {
	cfunc_descr_t* mm_descr;   /* C function */
	void* mm_psyco_fn;         /* it meta-implementation */
} meta_impl_t;
EXTERNFN void Psyco_DefineMetaModule(char* modulename, meta_impl_t* def);

/* To implement calls to a built-in function object, use the same calling
   convention METH_xxx as cd_flags. To implement calls to a type
   (Python &gt;=2.2b1) use: */
#define CD_META_TP_NEW   101


/* the general-purpose calling routine: it looks for a meta implementation of
   'c_function' and call it if found; if not found, it encode a run-time call
   to 'c_function'. The 'flags' and 'arguments' are as in psyco_generic_call().
   The remaining arguments are given to the meta function or encoded in the
   run-time call; they should be compatible with the description given in
   'arguments'.
   This is a bit tricky, with one version of the macro per number of arguments,
   because the C processor is too limited and we want to avoid handling
   functions with '...' arguments all around
*/
#define Psyco_META1(po, c_function, flags, arguments, a1)		\
		Psyco_Meta1x(po, c_function, flags, arguments,		\
			     (long)(a1))
#define Psyco_META2(po, c_function, flags, arguments, a1, a2)		\
		Psyco_Meta2x(po, c_function, flags, arguments,		\
			     (long)(a1), (long)(a2))
#define Psyco_META3(po, c_function, flags, arguments, a1, a2, a3)	\
		Psyco_Meta3x(po, c_function, flags, arguments,		\
			     (long)(a1), (long)(a2), (long)(a3))
#define Psyco_META4(po, c_function, flags, arguments, a1, a2, a3, a4)	\
		Psyco_Meta4x(po, c_function, flags, arguments,		\
			     (long)(a1), (long)(a2), (long)(a3), (long)(a4))

#define Psyco_flag_META1	(condition_code_t) Psyco_META1
#define Psyco_flag_META2	(condition_code_t) Psyco_META2
#define Psyco_flag_META3	(condition_code_t) Psyco_META3
#define Psyco_flag_META4	(condition_code_t) Psyco_META4

EXTERNFN vinfo_t* Psyco_Meta1x(PsycoObject* po, void* c_function, int flags,
                               const char* arguments, long a1);
EXTERNFN vinfo_t* Psyco_Meta2x(PsycoObject* po, void* c_function, int flags,
                               const char* arguments, long a1, long a2);
EXTERNFN vinfo_t* Psyco_Meta3x(PsycoObject* po, void* c_function, int flags,
                               const char* arguments, long a1, long a2, long a3);
EXTERNFN vinfo_t* Psyco_Meta4x(PsycoObject* po, void* c_function, int flags,
                               const char* arguments,
                               long a1, long a2, long a3, long a4);


/******************************************************************/
 /*** pyc_data_t implementation and snapshots for the dispatcher ***/

/* construction for non-frozen snapshots */
EXTERNFN void pyc_data_build(PsycoObject* po);
inline void pyc_data_duplicate(pyc_data_t* target, pyc_data_t* source) {
	memcpy(target, source, sizeof(pyc_data_t));
	target-&gt;exc = NULL;
}
inline void pyc_data_release(pyc_data_t* pyc) {
	vinfo_xdecref(pyc-&gt;val, NULL);
	vinfo_xdecref(pyc-&gt;exc, NULL);
}

/* construction for frozen snapshots */
inline size_t frozen_size(pyc_data_t* pyc) {
	return offsetof(pyc_data_t, blockstack) + pyc-&gt;iblock*sizeof(PyTryBlock);
}
inline void frozen_copy(pyc_data_t* target, pyc_data_t* source) {
	memcpy(target, source, frozen_size(source));
}
inline pyc_data_t* pyc_data_new(pyc_data_t* original) {
	pyc_data_t* pyc = (pyc_data_t*) PyCore_MALLOC(frozen_size(original));
	if (pyc == NULL) OUT_OF_MEMORY();
	frozen_copy(pyc, original);
	return pyc;
}
inline void pyc_data_delete(pyc_data_t* pyc) {
	PyCore_FREE(pyc);
}


#endif /* _PYCOMPILER_H */
</t>
<t tx="T364">&lt;&lt; pbltinmodule #includes &gt;&gt;
&lt;&lt; pbltinmodule declarations &gt;&gt;
@others
</t>
<t tx="T365">#include "pbltinmodule.h"
#include "../Objects/pintobject.h"
#include "../Objects/ptupleobject.h"
#include "../Objects/plistobject.h"
#include "../Objects/pstringobject.h"
</t>
<t tx="T366">

static cfunc_descr_t cd_range = { "range", METH_VARARGS };
static cfunc_descr_t cd_chr   = { "chr",   METH_VARARGS };
static cfunc_descr_t cd_ord   = { "ord",   METH_O };
static cfunc_descr_t cd_id    = { "id",    METH_O };
static cfunc_descr_t cd_len   = { "len",   METH_O };
/*static cfunc_descr_t cd_type  = { "type",  CD_META_TP_NEW };*/


/***************************************************************/
/* range().
   This is not for xrange(), which is not optimized by Psyco here.
   As a result range() is now more efficient than xrange() in common cases.
   This could be taken care of by short-circuiting the Psyco implementation
   of xrange() to that of range() itself and thus completely bypassing
   Python's own xrange types. */
DEFINEVAR source_virtual_t psyco_computed_range;
</t>
<t tx="T367">static PyObject* cimpl_range1(long start, long len)
{
  PyObject* lst = PyList_New(len);
  long i;
  if (lst != NULL)
    {
      for (i=0; i&lt;len; i++)
        {
          PyObject* o = PyInt_FromLong(start);
          if (o == NULL)
            {
              Py_DECREF(lst);
              return NULL;
            }
          PyList_SET_ITEM(lst, i, o);
          start++;
        }
    }
  return lst;
}
</t>
<t tx="T368">static bool compute_range(PsycoObject* po, vinfo_t* rangelst)
{
	vinfo_t* newobj;
	vinfo_t* vstart;
	vinfo_t* vlen;

	vstart = get_array_item(po, rangelst, RANGE_START);
	if (vstart == NULL)
		return false;

	vlen = get_array_item(po, rangelst, RANGE_LEN);
	if (vlen == NULL)
		return false;

	newobj = psyco_generic_call(po, cimpl_range1,
				    CfReturnRef|CfPyErrIfNull,
				    "vv", vstart, vlen);
	if (newobj == NULL)
		return false;

	/* remove the RANGE_xxx entries from v-&gt;array because they are
	   no longer relevant */
	rangelst-&gt;array-&gt;items[RANGE_START] = NULL;
	vinfo_decref(vstart, po);
	rangelst-&gt;array-&gt;items[RANGE_LEN]   = NULL;
	vinfo_decref(vlen, po);
	
	/* move the resulting non-virtual Python object back into 'rangelst' */
	vinfo_move(po, rangelst, newobj);
	return true;
}
</t>
<t tx="T369">static vinfo_t* get_len_of_range(PsycoObject* po, vinfo_t* lo, vinfo_t* hi
				 /*, vinfo_t* step == 1 currently*/)
{
	/* translated from bltinmodule.c */
	condition_code_t cc = integer_cmp(po, lo, hi, Py_LT);
	if (cc == CC_ERROR)
		return NULL;
	if (runtime_condition_t(po, cc))
		return integer_sub(po, hi, lo, false);
	else {
		vinfo_incref(psyco_viZero);
		return psyco_viZero;
	}
}
</t>
<t tx="T370">static vinfo_t* pbuiltin_range(PsycoObject* po, vinfo_t* vself, vinfo_t* vargs)
{
	vinfo_t* result = NULL;
	vinfo_t* ilen;
	vinfo_t* ilow = NULL;
	vinfo_t* ihigh = NULL;
	/*vinfo_t* istep = NULL;*/
	int tuplesize = PsycoTuple_Load(vargs);  /* -1 if unknown */
	
	switch (tuplesize) {
	case 1:
		ihigh = PsycoInt_AsLong(po, PsycoTuple_GET_ITEM(vargs, 0));
		if (ihigh == NULL) goto End;
		ilow = vinfo_new(CompileTime_New(0));
		break;
	/*case 3:
		istep = PsycoInt_AsLong(po, PsycoTuple_GET_ITEM(vargs, 2));
		if (istep == NULL) return NULL;*/
		/* fall through */
	case 2:
		ilow  = PsycoInt_AsLong(po, PsycoTuple_GET_ITEM(vargs, 0));
		if (ilow == NULL) goto End;
		ihigh = PsycoInt_AsLong(po, PsycoTuple_GET_ITEM(vargs, 1));
		if (ihigh == NULL) goto End;
		break;
	default:
		return psyco_generic_call(po, cd_range.cd_function,
					  CfReturnRef|CfPyErrIfNull,
					  "lv", NULL, vargs);
	}
	ilen = get_len_of_range(po, ilow, ihigh);
	if (ilen == NULL) goto End;
	
	result = vinfo_new(VirtualTime_New(&amp;psyco_computed_range));
	result-&gt;array = array_new(/*RANGE_STEP*/RANGE_START+1);
	result-&gt;array-&gt;items[OB_TYPE] =
		vinfo_new(CompileTime_New((long)(&amp;PyList_Type)));
	result-&gt;array-&gt;items[RANGE_LEN] = ilen;
	result-&gt;array-&gt;items[RANGE_START] = ilow;
	ilow = NULL;

   End:
	/*vinfo_xdecref(istep, po);*/
	vinfo_xdecref(ihigh, po);
	vinfo_xdecref(ilow, po);
	return result;
}
</t>
<t tx="T371">static vinfo_t* pbuiltin_chr(PsycoObject* po, vinfo_t* vself, vinfo_t* vargs)
{
	vinfo_t* vi;
	condition_code_t cc;
	
	if (PsycoTuple_Load(vargs) != 1)
		goto use_proxy;
	vi = PsycoTuple_GET_ITEM(vargs, 0);

	cc = integer_cmp_i(po, vi, 255, Py_GT|COMPARE_UNSIGNED);
	if (cc == CC_ERROR)
		return NULL;
	if (runtime_condition_f(po, cc))
		goto use_proxy;

	return PsycoCharacter_New(vi);

   use_proxy:
	return psyco_generic_call(po, cd_chr.cd_function,
				  CfReturnRef|CfPyErrIfNull,
				  "lv", NULL, vargs);
}
</t>
<t tx="T372">static vinfo_t* pbuiltin_ord(PsycoObject* po, vinfo_t* vself, vinfo_t* vobj)
{
	vinfo_t* vlen;
	vinfo_t* result;
	condition_code_t cc;

	switch (Psyco_TypeSwitch(po, vobj, &amp;psyfs_string_unicode)) {

	case 0:   /* PyString_Type */
		vlen = PsycoString_GET_SIZE(po, vobj);
		if (vlen == NULL)
			return NULL;
		cc = integer_cmp_i(po, vlen, 1, Py_NE);
		if (cc == CC_ERROR)
			return NULL;
		if (runtime_condition_f(po, cc))
			goto use_proxy;
		
		result = read_immut_array_item_var(po, vobj, STR_OB_SVAL,
                                                   psyco_viZero, true);
		if (result == NULL)
			return NULL;
		return PsycoInt_FROM_LONG(result);

#ifdef Py_USING_UNICODE
/* 	case 1:   * PyUnicode_Type * */
/* 		...; */
/* 		break; */
#endif
	default:
		if (PycException_Occurred(po))
			return NULL;
	}
	
   use_proxy:
	return psyco_generic_call(po, cd_ord.cd_function,
				  CfReturnRef|CfPyErrIfNull,
				  "lv", NULL, vobj);
}
</t>
<t tx="T373">static vinfo_t* pbuiltin_id(PsycoObject* po, vinfo_t* vself, vinfo_t* vobj)
{
	return PsycoInt_FromLong(vobj);
}
</t>
<t tx="T374">static vinfo_t* pbuiltin_len(PsycoObject* po, vinfo_t* vself, vinfo_t* vobj)
{
	vinfo_t* result = PsycoObject_Size(po, vobj);
	if (result != NULL)
		result = PsycoInt_FROM_LONG(result);
	return result;
}
</t>
<t tx="T375">@ **************************************************************/
@c

static meta_impl_t meta_bltin[] = {
	{&amp;cd_range,	&amp;pbuiltin_range},
	{&amp;cd_chr,	&amp;pbuiltin_chr},
	{&amp;cd_ord,	&amp;pbuiltin_ord},
	{&amp;cd_id,	&amp;pbuiltin_id},
	{&amp;cd_len,	&amp;pbuiltin_len},
	/*{&amp;cd_type,	&amp;pbuiltin_type},*/
	{NULL,		NULL}	/* sentinel */
};

DEFINEFN
void psy_bltinmodule_init()
{
	psyco_computed_range.compute_fn = &amp;compute_range;
	Psyco_DefineMetaModule("__builtin__", meta_bltin);
}
</t>
<t tx="T376">&lt;&lt; pycompiler #includes &gt;&gt;
&lt;&lt; pycompiler declarations &gt;&gt;
@others
</t>
<t tx="T377">#include "pycompiler.h"
#include "../pycencoding.h"
#include "../processor.h"
#include "../dispatcher.h"
#include "../mergepoints.h"
#include "../codemanager.h"

#include "pbltinmodule.h"

#include "../Objects/pobject.h"
#include "../Objects/pabstract.h"
#include "../Objects/pdictobject.h"
#include "../Objects/pfuncobject.h"
#include "../Objects/pintobject.h"
#include "../Objects/piterobject.h"
#include "../Objects/plistobject.h"
#include "../Objects/plongobject.h"
#include "../Objects/pmethodobject.h"
#include "../Objects/psycofuncobject.h"
#include "../Objects/pstringobject.h"
#include "../Objects/ptupleobject.h"

#include &lt;eval.h&gt;
#include &lt;opcode.h&gt;
</t>
<t tx="T378">#define KNOWN_VAR(type, varname, loc)   \
    type varname = (type)(KNOWN_SOURCE(loc)-&gt;value)
</t>
<t tx="T379">/*****************************************************************/
 /***   Meta functions                                          ***/

DEFINEVAR PyObject* Psyco_Meta_Dict = NULL;
</t>
<t tx="T380">DEFINEFN
void Psyco_DefineMeta(void* c_function, void* psyco_function)
{
	PyObject* key;
	PyObject* value;
	if (Psyco_Meta_Dict == NULL) {
		Psyco_Meta_Dict = PyDict_New();
		if (Psyco_Meta_Dict == NULL)
			return;
	}
	key = PyInt_FromLong((long) c_function);
	if (key != NULL) {
		value = PyInt_FromLong((long) psyco_function);
		if (value != NULL) {
			PyDict_SetItem(Psyco_Meta_Dict, key, value);
			Py_DECREF(value);
		}
		Py_DECREF(key);
	}
}
</t>
<t tx="T381">DEFINEFN
void Psyco_DefineMetaModule(char* modulename, meta_impl_t* def)
{
	/* call Psyco_DefineMeta() for all functions of module 'modulename'
	   found in the NULL-terminated array 'def'. */
	PyObject* module;
	PyObject* fobj;
	char* name;
	void* f;

	/* XXX should not load the modules now. Not loaded modules should
	   be registered in some hook and Psyco_DefineMetaModule() should
	   be automatically called again if and when the module is called. */
	module = PyImport_ImportModule(modulename);
	if (module == NULL) {
		PyErr_Clear();
		debug_printf(("psyco: note: module %s not found\n",
			      modulename));
		return;
	}
	
	for (; def-&gt;mm_descr != NULL; def++) {
		name = def-&gt;mm_descr-&gt;cd_name;
		fobj = PyObject_GetAttrString(module, name);
		if (fobj == NULL) {
			PyErr_Clear();
			debug_printf(("psyco: note: %s.%s not found\n",
				      modulename, name));
			continue;
		}
		f = NULL;
		switch (def-&gt;mm_descr-&gt;cd_flags) {

#if NEW_STYLE_TYPES
		case CD_META_TP_NEW:
			if (PyType_Check(fobj))
				f = ((PyTypeObject*) fobj)-&gt;tp_new;
			break;
#endif
		default:
			if (PyCFunction_Check(fobj) &amp;&amp;
			    PyCFunction_GET_FLAGS(fobj)==def-&gt;mm_descr-&gt;cd_flags)
				f = PyCFunction_GET_FUNCTION(fobj);
		}

		def-&gt;mm_descr-&gt;cd_function = f;
		if (f != NULL) {
			Psyco_DefineMeta(f, def-&gt;mm_psyco_fn);
		}
		else {
			debug_printf(("psyco: note: %s.%s not implemented "
				      "as expected\n",
				      modulename, name));
		}
		Py_DECREF(fobj);
	}
	Py_DECREF(module);
}
</t>
<t tx="T382">#define BAD_FLAGS(fl)  if ((flags &amp; CfReturnMask) == (fl))			\
			    Py_FatalError("generic_call_check(): CfPyErrXxx "	\
					  "flags incompatible with "		\
					  "CfReturnXxx flags")
#define FORGET_REF     if (has_rtref(vi-&gt;source))			\
			    vi-&gt;source = remove_rtref(vi-&gt;source)

DEFINEFN
vinfo_t* generic_call_check(PsycoObject* po, int flags, vinfo_t* vi)
{
	condition_code_t cc;
	
	switch (flags &amp; CfPyErrMask) {

	case CfPyErrIfNull:   /* a return == 0 (or NULL) means an error */
		BAD_FLAGS(CfNoReturnValue);
		if ((flags &amp; CfReturnMask) == CfReturnFlag)
			cc = INVERT_CC((condition_code_t) vi);
		else
			cc = integer_cmp_i(po, vi, 0, Py_EQ);
		break;

	case CfPyErrIfNonNull:   /* a return != 0 means an error */
		BAD_FLAGS(CfNoReturnValue);
		if ((flags &amp; CfReturnMask) == CfReturnFlag)
			cc = (condition_code_t) vi;
		else
			cc = integer_cmp_i(po, vi, 0, Py_NE);
		break;

	case CfPyErrIfNeg:   /* a return &lt; 0 means an error */
		BAD_FLAGS(CfReturnFlag);
		BAD_FLAGS(CfNoReturnValue);
		cc = integer_cmp_i(po, vi, 0, Py_LT);
		break;

	case CfPyErrIfMinus1:     /* only -1 means an error */
		BAD_FLAGS(CfReturnFlag);
		BAD_FLAGS(CfNoReturnValue);
		cc = integer_cmp_i(po, vi, -1, Py_EQ);
		break;

	case CfPyErrCheck:    /* always check with PyErr_Occurred() */
		cc = PsycoErr_Occurred(po);
		break;

	case CfPyErrCheckMinus1:   /* use PyErr_Occurred() if return is -1 */
		BAD_FLAGS(CfReturnFlag);
		BAD_FLAGS(CfNoReturnValue);
		cc = integer_cmp_i(po, vi, -1, Py_NE);
		if (cc == CC_ERROR)
			goto Error;
		if (runtime_condition_t(po, cc))
			return vi;   /* result is not -1, ok */
		cc = PsycoErr_Occurred(po);
		break;

        case CfPyErrCheckNeg:   /* use PyErr_Occurred() if return is &lt; 0 */
		BAD_FLAGS(CfReturnFlag);
		BAD_FLAGS(CfNoReturnValue);
		cc = integer_cmp_i(po, vi, 0, Py_GE);
		if (cc == CC_ERROR)
			goto Error;
		if (runtime_condition_t(po, cc))
			return vi;   /* result is &gt;= 0, ok */
		cc = PsycoErr_Occurred(po);
		break;

	case CfPyErrNotImplemented:   /* test for a Py_NotImplemented result */
		BAD_FLAGS(CfReturnFlag);
		BAD_FLAGS(CfNoReturnValue);
		cc = integer_cmp_i(po, vi, (long) Py_NotImplemented, Py_EQ);
		if (cc == CC_ERROR)
			goto Error;
		if (runtime_condition_f(po, cc)) {
			/* result is Py_NotImplemented */
			vinfo_decref(vi, po);
			vinfo_incref(psyco_viNotImplemented);
			return psyco_viNotImplemented;
		}
		cc = integer_cmp_i(po, vi, 0, Py_EQ);
		break;

	case CfPyErrIterNext:    /* specially for tp_iternext slots */
		BAD_FLAGS(CfReturnFlag);
		BAD_FLAGS(CfNoReturnValue);
		cc = integer_cmp_i(po, vi, 0, Py_NE);
		if (cc == CC_ERROR)
			goto Error;
		if (runtime_condition_t(po, cc))
			return vi;   /* result is not 0, ok */
		
		FORGET_REF;  /* NULL result */
		vinfo_decref(vi, po);
		cc = PsycoErr_Occurred(po);
		if (cc == CC_ERROR || runtime_condition_f(po, cc))
			goto PythonError;  /* PyErr_Occurred() returns true */

		/* NULL result with no error set; it is the end of the
		   iteration. Raise a pseudo PyErr_StopIteration. */
		vinfo_incref(psyco_viNone);
		PycException_SetVInfo(po, PyExc_StopIteration, psyco_viNone);
		return NULL;
	}
	
	if (cc == CC_ERROR || runtime_condition_f(po, cc)) {

	   Error:
		switch (flags &amp; CfReturnMask) {
		case CfReturnRef:   /* in case of error, 'vi' is not a real
				       reference, so forget it */
			FORGET_REF;
			/* fall through */
		case CfReturnNormal:
			vinfo_decref(vi, po);
			vi = NULL;
			break;
		case CfReturnFlag:
			vi = (vinfo_t*) CC_ERROR;
			break;
		default:
			vi = NULL;
		}
		/* We have detected that a Python exception must be set at
		   this point. */
	   PythonError:
		PycException_Raise(po, vinfo_new(VirtualTime_New(&amp;ERtPython)),
				   NULL);
	}
	return vi;
}

#undef BAD_FLAGS
#undef FORGET_REF

</t>
<t tx="T383">DEFINEFN
vinfo_t* Psyco_Meta1x(PsycoObject* po, void* c_function, int flags,
		      const char* arguments, long a1)
{
	void* psyco_fn = Psyco_Lookup(c_function);
	if (psyco_fn == NULL) {
		return psyco_generic_call(po, c_function, flags, arguments,
					  a1);
        }
	else
		return ((vinfo_t*(*)(PsycoObject*, long))(psyco_fn))
			(po, a1);
}
</t>
<t tx="T384">DEFINEFN
vinfo_t* Psyco_Meta2x(PsycoObject* po, void* c_function, int flags,
		      const char* arguments, long a1, long a2)
{
	void* psyco_fn = Psyco_Lookup(c_function);
	if (psyco_fn == NULL)
		return psyco_generic_call(po, c_function, flags, arguments,
					  a1, a2);
	else
		return ((vinfo_t*(*)(PsycoObject*, long, long))(psyco_fn))
			(po, a1, a2);
}
</t>
<t tx="T385">DEFINEFN
vinfo_t* Psyco_Meta3x(PsycoObject* po, void* c_function, int flags,
		      const char* arguments, long a1, long a2, long a3)
{
	void* psyco_fn = Psyco_Lookup(c_function);
	if (psyco_fn == NULL)
		return psyco_generic_call(po, c_function, flags, arguments,
					  a1, a2, a3);
	else
		return ((vinfo_t*(*)(PsycoObject*, long, long, long))(psyco_fn))
			(po, a1, a2, a3);
}
</t>
<t tx="T386">DEFINEFN
vinfo_t* Psyco_Meta4x(PsycoObject* po, void* c_function, int flags,
			     const char* arguments,
			     long a1, long a2, long a3, long a4)
{
	void* psyco_fn = Psyco_Lookup(c_function);
	if (psyco_fn == NULL)
		return psyco_generic_call(po, c_function, flags, arguments,
					   a1, a2, a3, a4);
	else
		return ((vinfo_t*(*)(PsycoObject*, long, long,
				     long, long))(psyco_fn))
			(po, a1, a2, a3, a4);
}
</t>
<t tx="T387">@ **************************************************************/
** pyc_data_t ***/
@c

</t>
<t tx="T388">DEFINEFN
void pyc_data_build(PsycoObject* po)
{
	/* rebuild the data in the pyc_data_t */
	int i;
	KNOWN_VAR(PyCodeObject*, co, LOC_CODE);
	int stack_base = LOC_LOCALS_PLUS-&gt;array-&gt;count - co-&gt;co_stacksize;
	for (i=stack_base; i&lt;LOC_LOCALS_PLUS-&gt;array-&gt;count; i++)
		if (LOC_LOCALS_PLUS-&gt;array-&gt;items[i] == NULL)
			break;
	po-&gt;pr.stack_base = stack_base;
	po-&gt;pr.stack_level = i - stack_base;
	po-&gt;pr.merge_points = psyco_get_merge_points(co);
}
</t>
<t tx="T389">static void block_setup(PsycoObject* po, int type, int handler, int level)
{
  PyTryBlock *b;
  if (po-&gt;pr.iblock &gt;= CO_MAXBLOCKS)
    Py_FatalError("block stack overflow");
  b = &amp;po-&gt;pr.blockstack[po-&gt;pr.iblock++];
  b-&gt;b_type = type;
  b-&gt;b_level = level;
  b-&gt;b_handler = handler;
}
</t>
<t tx="T390">static PyTryBlock* block_pop(PsycoObject* po)
{
  if (po-&gt;pr.iblock &lt;= 0)
    Py_FatalError("block stack underflow");
  return &amp;po-&gt;pr.blockstack[--po-&gt;pr.iblock];
}
</t>
<t tx="T391">@ ****************************************************************/
** Compile-time Pseudo exceptions ***/
@c</t>
<t tx="T392">DEFINEVAR source_virtual_t ERtPython;  /* Exception raised by Python */
DEFINEVAR source_virtual_t EReturn;    /* 'return' statement */
DEFINEVAR source_virtual_t EBreak;     /* 'break' statement */
DEFINEVAR source_virtual_t EContinue;  /* 'continue' statement */

DEFINEFN
void PycException_SetString(PsycoObject* po, PyObject* e, const char* text)
{
	PyObject* s = PyString_FromString(text);
	if (s == NULL)
		OUT_OF_MEMORY();
	PycException_SetObject(po, e, s);
}
</t>
<t tx="T393">DEFINEFN
void PycException_SetFormat(PsycoObject* po, PyObject* e, const char* fmt, ...)
{
	PyObject* s;
	va_list vargs;

#ifdef HAVE_STDARG_PROTOTYPES
	va_start(vargs, fmt);
#else
	va_start(vargs);
#endif
	s = PyString_FromFormatV(fmt, vargs);
	va_end(vargs);

	if (s == NULL)
		OUT_OF_MEMORY();
	PycException_SetObject(po, e, s);
}
</t>
<t tx="T394">DEFINEFN
void PycException_SetObject(PsycoObject* po, PyObject* e, PyObject* v)
{
	PycException_Raise(po, vinfo_new(CompileTime_New((long) e)),
			   vinfo_new(CompileTime_NewSk(sk_new((long) v,
                                                              SkFlagPyObj))));
}
</t>
<t tx="T395">DEFINEFN
void PycException_SetVInfo(PsycoObject* po, PyObject* e, vinfo_t* v)
{
	PycException_Raise(po, vinfo_new(CompileTime_New((long) e)), v);
}
</t>
<t tx="T396">DEFINEFN
void PycException_Promote(PsycoObject* po, vinfo_t* vi, c_promotion_t* promotion)
{
	vinfo_incref(vi);
	PycException_Raise(po, vinfo_new(VirtualTime_New(&amp;promotion-&gt;header)),
			   vi);
}
</t>
<t tx="T397">DEFINEFN
condition_code_t PycException_Matches(PsycoObject* po, PyObject* e)
{
	condition_code_t cc;
	if (PycException_Is(po, &amp;ERtPython)) {
		/* Exception raised by Python, emit a call to
		   PyErr_ExceptionMatches() */
		cc = psyco_flag_call(po, PyErr_ExceptionMatches,
				     CfReturnFlag, "l", (long) e);
	}
	else if (PycException_IsPython(po)) {
		/* Exception virtually set, that is, present in the PsycoObject
		   but not actually set at run-time by Python's PyErr_SetXxx */
		cc = psyco_flag_call(po, PyErr_GivenExceptionMatches,
				     CfPure | CfReturnFlag,
				     "vl", po-&gt;pr.exc, (long) e);
	}
	else {   /* pseudo exceptions don't match real Python ones */
		cc = CC_ALWAYS_FALSE;
	}
	return cc;
}
</t>
<t tx="T398">inline void clear_pseudo_exception(PsycoObject* po)
{
	extra_assert(PycException_Occurred(po));
	if (po-&gt;pr.val != NULL) {
		vinfo_decref(po-&gt;pr.val, po);
		po-&gt;pr.val = NULL;
	}
	vinfo_decref(po-&gt;pr.exc, po);
	po-&gt;pr.exc = NULL;
}
</t>
<t tx="T399">DEFINEFN
void PycException_Clear(PsycoObject* po)
{
	if (PycException_Is(po, &amp;ERtPython)) {
		/* Clear the Python exception set at run-time */
		psyco_call_void(po, PyErr_Clear);
	}
	clear_pseudo_exception(po);
}
</t>
<t tx="T400">DEFINEFN
void psyco_virtualize_exception(PsycoObject* po)
{
	/* fetch a Python exception set at compile-time (that is, now)
	   and turn into a pseudo-exception (typically to be re-raised
	   at run-time). */
	PyObject *exc, *val, *tb;
	PyErr_Fetch(&amp;exc, &amp;val, &amp;tb);
	extra_assert(exc != NULL);

	PycException_Raise(po,
			  vinfo_new(CompileTime_NewSk(sk_new((long) exc,
                                                             SkFlagPyObj))),
			  vinfo_new(CompileTime_NewSk(sk_new((long) val,
                                                             SkFlagPyObj))));
	Py_XDECREF(tb);  /* XXX implement tracebacks */
}
</t>
<t tx="T401">static void cimpl_pyerr_fetch(PyObject* target[])
{
	PyObject* tb;
	PyErr_Fetch(target+0, target+1, &amp;tb);
	Py_XDECREF(tb);  /* XXX implement tracebacks */
	/* XXX call set_exc_info() */
	if (target[0] == NULL) {
		target[0] = Py_None;
		Py_INCREF(Py_None);
	}
	if (target[1] == NULL) {
		target[1] = Py_None;
		Py_INCREF(Py_None);
	}
}
</t>
<t tx="T402">static void cimpl_pyerr_fetch_and_normalize(PyObject* target[])
{
	PyObject* tb;
	PyErr_Fetch(target+0, target+1, &amp;tb);
	PyErr_NormalizeException(target+0, target+1, &amp;tb);
	Py_XDECREF(tb);  /* XXX implement tracebacks */
	/* XXX call set_exc_info() */
}
</t>
<t tx="T403">DEFINEFN
void PycException_Fetch(PsycoObject* po)
{
	if (PycException_Is(po, &amp;ERtPython)) {
/* 		vinfo_t* exc = vinfo_new(SOURCE_DUMMY_WITH_REF); */
/* 		vinfo_t* val = vinfo_new(SOURCE_DUMMY_WITH_REF); */
/* 		vinfo_t* tb  = vinfo_new(SOURCE_DUMMY_WITH_REF); */
/* 		psyco_generic_call(po, PyErr_Fetch, CfNoReturnValue, */
/* 				   "rrr", exc, val, tb); */
/* 		vinfo_decref(tb, po); */
		vinfo_array_t* array = array_new(2);
		psyco_generic_call(po, cimpl_pyerr_fetch,
				   CfNoReturnValue, "A", array);
		clear_pseudo_exception(po);
		PycException_Raise(po, array-&gt;items[0], array-&gt;items[1]);
		array_release(array);
	}
}
</t>
<t tx="T404">inline bool PycException_FetchNormalize(PsycoObject* po)
{
	if (PycException_Is(po, &amp;ERtPython)) {
		vinfo_array_t* array = array_new(2);
		if (psyco_generic_call(po, cimpl_pyerr_fetch_and_normalize,
				       CfNoReturnValue, "A", array) == NULL)
			return false;
		clear_pseudo_exception(po);
		PycException_Raise(po, array-&gt;items[0], array-&gt;items[1]);
		array_release(array);
	}
	else {
		/* normalize the exception */
		vinfo_t* exc;
		vinfo_t* val;
		vinfo_t* tb;
		exc = make_runtime_copy(po, po-&gt;pr.exc);
		if (exc == NULL) return false;
		val = make_runtime_copy(po, po-&gt;pr.val);
		if (val == NULL) return false;
		tb = make_runtime_copy(po, psyco_viZero);
		if (tb == NULL) return false;
		if (psyco_generic_call(po, PyErr_NormalizeException,
				CfNoReturnValue, "rrr", exc, val, tb) == NULL)
			return false;
		vinfo_decref(tb, po);
		PycException_Raise(po, exc, val);
	}
	return true;
}
</t>
<t tx="T405">@ **************************************************************/
** Initialization ***/
**************************************************************/
@c

DEFINEVAR vinfo_t* psyco_viNone;    /* known value 'Py_None' */
DEFINEVAR vinfo_t* psyco_viZero;    /* known value 0 */
DEFINEVAR vinfo_t* psyco_viOne;     /* known value 1 */
DEFINEVAR vinfo_t* psyco_viNotImplemented;

static PyObject* s_builtin_object;   /* intern string '__builtins__' */

DEFINEFN
void psyco_pycompiler_init()
{
	s_builtin_object = PyString_InternFromString("__builtins__");
	
	psyco_viNone = vinfo_new(CompileTime_NewSk(sk_new((long) Py_None,
							  SkFlagFixed)));
	psyco_viZero = vinfo_new(CompileTime_NewSk(sk_new(0, SkFlagFixed)));
	psyco_viOne  = vinfo_new(CompileTime_NewSk(sk_new(1, SkFlagFixed)));
	psyco_viNotImplemented = vinfo_new(CompileTime_NewSk(sk_new
				((long) Py_NotImplemented, SkFlagFixed)));

	ERtPython = psyco_vsource_not_important;
	EReturn   = psyco_vsource_not_important;
	EContinue = psyco_vsource_not_important;
	EBreak    = psyco_vsource_not_important;

        psy_object_init();
        psy_abstract_init();
        psy_dictobject_init();
        psy_funcobject_init();
        psy_intobject_init();
        psy_iterobject_init();
        psy_listobject_init();
        psy_longobject_init();
        psy_methodobject_init();
        psy_psycofuncobject_init();
        psy_stringobject_init();
        psy_tupleobject_init();

	psy_bltinmodule_init();
}
</t>
<t tx="T406">@ **************************************************************/
** Compiler ***/
**************************************************************/
@c

</t>
<t tx="T407">#define CHKSTACK(n)     extra_assert(0 &lt;= po-&gt;pr.stack_level+(n) &amp;&amp;             \
                                     po-&gt;pr.stack_base+po-&gt;pr.stack_level+(n) &lt; \
                                     LOC_LOCALS_PLUS-&gt;array-&gt;count)

#define NEXTOP()	(bytecode[next_instr++])
#define NEXTARG()	(next_instr += 2,                                       \
                         (bytecode[next_instr-1]&lt;&lt;8) + bytecode[next_instr-2])

#define PUSH(v)         (CHKSTACK(0), stack_a[po-&gt;pr.stack_level++] = v)
#define POP(targ)       (CHKSTACK(-1), targ = stack_a[--po-&gt;pr.stack_level],   \
                         stack_a[po-&gt;pr.stack_level] = NULL)
#define NTOP(n)         (CHKSTACK(-(n)), stack_a[po-&gt;pr.stack_level-(n)])
#define TOP()           NTOP(1)
#define POP_DECREF()    do { vinfo_t* v1; POP(v1);			\
				vinfo_decref(v1, po); } while (0)

/*#define GETCODEOBJ()    ((PyCodeObject*)(KNOWN_SOURCE(LOC_CODE)-&gt;value))*/
#define GETCONST(i)     (PyTuple_GET_ITEM(co-&gt;co_consts, i))
#define GETNAMEV(i)     (PyTuple_GET_ITEM(co-&gt;co_names, i))

#define GETLOCAL(i)	(LOC_LOCALS_PLUS-&gt;array-&gt;items[i])
#define SETLOCAL(i, v)	do { vinfo_decref(GETLOCAL(i), po); \
                             GETLOCAL(i) = v; } while (0)

#define STACK_POINTER() (stack_a + po-&gt;pr.stack_level)
#define INSTR_OFFSET()  (next_instr)
#define STACK_LEVEL()   (po-&gt;pr.stack_level)
#define JUMPBY(offset)  (next_instr += (offset))
#define JUMPTO(target)  (next_instr = (target))

#define SAVE_NEXT_INSTR(next_instr)   \
    (LOC_NEXT_INSTR-&gt;source = set_ct_value(LOC_NEXT_INSTR-&gt;source, next_instr))

#define MISSING_OPCODE(opcode)							\
	case opcode:								\
		PycException_SetString(po, PyExc_PsycoError,		        \
				  "opcode '" #opcode "' not implemented");	\
		break
</t>
<t tx="T408">/***************************************************************/
 /***   LOAD_GLOBAL tricks                                    ***/

/*  Definition hacks for Python version &lt;2.2b1,
 *  as detected by the missing macro PyString_CheckExact.
 *   (this assumes that the structure of the dictionaries is
 *    exported if and only if NEW_STYLE_TYPES)
 */

#if !NEW_STYLE_TYPES
typedef struct {
	long me_hash;      /* cached hash code of me_key */
	PyObject *me_key;
	PyObject *me_value;
#ifdef USE_CACHE_ALIGNED
	long	aligner;
#endif
} PyDictEntry;
typedef struct _dictobject PyDictObject;
struct _dictobject {
	PyObject_HEAD
	int ma_fill;  /* # Active + # Dummy */
	int ma_used;  /* # Active */
	int ma_mask;
	PyDictEntry *ma_table;
	PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
	/* not needed: PyDictEntry ma_smalltable[PyDict_MINSIZE]; */
};
#endif  /* !NEW_STYLE_TYPES */


/* 'compilation pause' stuff, similar to psyco_coding_pause() */
typedef struct {
	CodeBufferObject* self;
	PsycoObject* po;
	PyObject* varname;
	PyObject* previousvalue;
	code_t* originalmacrocode;
} changed_global_t;

</t>
<t tx="T409">static code_t* do_changed_global(changed_global_t* cg)
{
	PsycoObject* po = cg-&gt;po;
	PyObject* key = cg-&gt;varname;
	code_t* code = cg-&gt;originalmacrocode;
	vinfo_t* v;
	vinfo_t** stack_a = LOC_LOCALS_PLUS-&gt;array-&gt;items + po-&gt;pr.stack_base;
	KNOWN_VAR(PyDictObject*, globals, LOC_GLOBALS);
	PyDictEntry* ep;
	void* dict_subscript;
	code_t* target;

	/* first check that the value really changed; it could merely
	   have moved in the dictionary table (reallocations etc.) */
	ep = (globals-&gt;ma_lookup)(globals, key,
				  ((PyStringObject*) key)-&gt;ob_shash);
	
	if (ep-&gt;me_value == cg-&gt;previousvalue) {
		int index = ep - globals-&gt;ma_table;
		/* no real change; update the original macro code
		   and that's it */
		DICT_ITEM_IFCHANGED(code, globals, index, key, ep-&gt;me_value,
				    cg-&gt;self-&gt;codeptr);
		return code;  /* execution continues after the macro code */
	}

	/* un-promote the global variable to run-time and write code that
	   calls dict_subscript(). Warning: we assume this will not overflow
	   the (relatively large) code previously written by the macro
	   DICT_ITEM_IFCHANGED at the same place.

	   We call dict_subscript() instead of PyDict_GetItem() for the extra
	   reference; indeed, we cannot be sure how long we will need the
	   object so we must own a reference. dict_subscript() could be
	   inlined too (but be careful about the overflow problem above!)
	*/
	SAVE_REGS_FN_CALLS;
	CALL_SET_ARG_IMMED((long) key,         1, 2);
	CALL_SET_ARG_IMMED((long) globals,     0, 2);

	v = new_rtvinfo(po, REG_FUNCTIONS_RETURN, true);
	PUSH(v);
	/* 'v' is now run-time, recompile */
	target = psyco_compile_code(po)-&gt;codeptr;
	/* XXX don't know what to do with the reference returned by
	   XXX psyco_compile_code() */

	dict_subscript = PyDict_Type.tp_as_mapping-&gt;mp_subscript;
	CALL_C_FUNCTION_AND_JUMP(dict_subscript,  2,  target);
  
  /* cannot Py_DECREF(cg-&gt;self) because the current function is returning into
     that code now, but any time later is fine: use the trash of codemanager.h */
	psyco_trash_object((PyObject*) cg-&gt;self);
	return cg-&gt;originalmacrocode;
}
</t>
<t tx="T410">#define GLOBAL_NAME_ERROR_MSG \
	"global name '%.200s' is not defined"
#define UNBOUNDLOCAL_ERROR_MSG \
	"local variable '%.200s' referenced before assignment"

/* Load the global variable whose name is in 'key' (an interned string).
   Returns a new reference to the result or NULL. */
static PyObject* load_global(PsycoObject* po, PyObject* key, int next_instr)
{
	/* XXX this assumes that builtins never change, and that
	   no global variable shadowing a builtin variable is added
           or removed after Psyco has compiled a piece of code.

	   Idea of the current implementation: we perform now the
           look-up in the globals() and remember where it was found
           in the ma_table of the dictionary. We then emit machine
           code that performs a speeded-up version of the lookup by
           checking directly at that place if the same value is still
           in place. If it is not, we call a helper function to redo
           a complete look-up, and if the value is found to have
	   changed, un-promote the variable from compile-time to
           run-time.
	   
	   This requires knowledge of the internal workings of a
	   dictionary.

           This also assumes that a majority of global variables
           never change, which should be the case (typically,
           global functions, classes, etc. do not change).

           A more correct but more involved solution could be
           implemented by adding to dictobject.c some kind of
           'on-change' hooks. The hooks might be called at any
           time; we would then have to insert an espace sequence
           inside of the machine code to trigger recompilation the
           next time the execution reaches this point. This is not
           easy to do because it must be done in a single byte to
           prevent accidental overrides of the next instruction.
           Processors typically have such a minimally-sized
           instruction for debugging purposes but it is not
           supposed to be used outside of debuggers -- it
	   triggers some kind of OS-dependent signal which must
           be caught. Not portable at all. (insert dummy NOPs in
           the first place to make room for a future JMP?)
	*/
	KNOWN_VAR(PyDictObject*, globals, LOC_GLOBALS);
	PyDictEntry* ep;
	PyObject* result;
	/* the compiler only puts interned strings in op_names */
	extra_assert(PyString_CheckExact(key));
	extra_assert(((PyStringObject*) key)-&gt;ob_sinterned != NULL);
	extra_assert(((PyStringObject*) key)-&gt;ob_shash != -1);

	ep = (globals-&gt;ma_lookup)(globals, key,
				  ((PyStringObject*) key)-&gt;ob_shash);
	if (ep-&gt;me_value != NULL) {
		/* found in the globals() */
		int index = ep - globals-&gt;ma_table;
		CodeBufferObject* onchangebuf;
		PsycoObject* po1 = po;
		changed_global_t* cg;
		code_t* code;
		
		result = ep-&gt;me_value;
		
		/* if the object is changed later we will jump to
		   a proxy which we prepare now */
		onchangebuf = psyco_new_code_buffer(NULL, NULL);
                if (onchangebuf == NULL)
			OUT_OF_MEMORY();
		po = PsycoObject_Duplicate(po);

                /* The global object has not been PUSHed on the Python stack
                   yet. However, if we enter do_changed_global() later and
                   figure out the value changed, do_changed_global() will
                   emit code that loads the run-time value of the global
                   and emulate the LOAD_GLOBAL opcode by PUSHing a run-time
                   vinfo_t. This means the recompilation triggered by
                   do_changed_global() must restart *after* the LOAD_GLOBAL
                   instruction and not *at* it, so we store the next
                   instruction position in the new 'po': */
                SAVE_NEXT_INSTR(next_instr);

		code = onchangebuf-&gt;codeptr;
		TEMP_SAVE_REGS_FN_CALLS;
		po-&gt;code = code;
		cg = (changed_global_t*) psyco_jump_proxy(po,
						   &amp;do_changed_global, 1, 1);
		cg-&gt;self = onchangebuf;
		cg-&gt;po = po;
		cg-&gt;varname = key;
                cg-&gt;previousvalue = result;    Py_INCREF(result);
		cg-&gt;originalmacrocode = po1-&gt;code;
		SHRINK_CODE_BUFFER(onchangebuf,
                                   (code_t*)(cg+1) - onchangebuf-&gt;codeptr,
                                   "load_global");

		/* go on in the main code sequence */
		po = po1;
		/* write code that quickly checks that the same
		   object is still in place in the dictionary */
		code = po-&gt;code;
		DICT_ITEM_IFCHANGED(code, globals, index, key, result,
				    onchangebuf-&gt;codeptr);
		po-&gt;code = code;
                psyco_dump_code_buffers();

		Py_INCREF(result);
		return result;
	}
	else {
		/* no such global variable, get the builtins */
		if (po-&gt;pr.f_builtins == NULL) {
			PyObject* builtins;
				/* code copied from frameobject.c */
				/* XXX we currently consider the absence
				   of builtins to be a fatal error */
			builtins = PyDict_GetItem((PyObject*) globals,
						  s_builtin_object);
			assert(builtins != NULL);
			if (PyModule_Check(builtins)) {
				builtins = PyModule_GetDict(builtins);
				assert(builtins != NULL);
			}
			assert(PyDict_Check(builtins));
			po-&gt;pr.f_builtins = builtins;
		}
		result = PyDict_GetItem(po-&gt;pr.f_builtins, key);
		
		/* found at all? */
		if (result != NULL)
			Py_INCREF(result);
		else
			PycException_SetFormat(po, PyExc_NameError,
					       GLOBAL_NAME_ERROR_MSG,
					       PyString_AS_STRING(key));
	}
	return result;
}
</t>
<t tx="T411">@ **************************************************************/
** Slicing ***/
@c

</t>
<t tx="T412">static vinfo_t* _PsycoEval_SliceIndex(PsycoObject* po, vinfo_t* v)
{
	vinfo_t* result;
	switch (Psyco_TypeSwitch(po, v, &amp;psyfs_int_long)) {

	case 0:   /* PyInt_Type */
		result = PsycoInt_AS_LONG(po, v);
		vinfo_incref(result);
		break;

	case 1:   /* PyLong_Type */
		result = PsycoLong_AsLong(po, v);
		if (result == NULL) {
			vinfo_t* vi_zero;
			PyObject* long_zero;
			condition_code_t cc;
			long x;

			if (!PycException_Matches(po, PyExc_OverflowError))
				return NULL;
			/* It's an overflow error, so we need to
			   check the sign of the long integer,
			   set the value to INT_MAX or 0, and clear
			   the error. */
			PycException_Clear(po);

			long_zero = PyLong_FromLong(0L);
			if (long_zero == NULL)
				OUT_OF_MEMORY();
			vi_zero = vinfo_new(CompileTime_NewSk(sk_new
					      ((long) long_zero, SkFlagPyObj)));
			cc = PsycoObject_RichCompareBool(po, v, vi_zero, Py_GT);
			vinfo_decref(vi_zero, po);
			if (cc == CC_ERROR)
				return NULL;
			if (runtime_condition_t(po, cc))
				x = INT_MAX;
			else
				x = 0;
			result = vinfo_new(CompileTime_New(x));
		}
		break;

	default:
		/* no error set */
		result = NULL;
	}
	return result;
}
</t>
<t tx="T413">static vinfo_t* psyco_apply_slice(PsycoObject* po, vinfo_t* u,
				  vinfo_t* v, vinfo_t* w)
{	 /* u[v:w] */
	PyTypeObject *tp;
	PySequenceMethods *sq;

	tp = Psyco_NeedType(po, u);
	if (tp == NULL)
		return NULL;
	sq = tp-&gt;tp_as_sequence;

	if (sq &amp;&amp; sq-&gt;sq_slice) {
		vinfo_t* ilow;
		vinfo_t* ihigh;
		if (v == NULL) {
			ilow = psyco_viZero;
			vinfo_incref(ilow);
		}
		else {
			ilow = _PsycoEval_SliceIndex(po, v);
			if (ilow == NULL) {
				if (PycException_Occurred(po))
					return NULL;
				goto with_slice_object;
			}
		}
		if (w == NULL)
			ihigh = vinfo_new(CompileTime_New(INT_MAX));
		else {
			ihigh = _PsycoEval_SliceIndex(po, w);
			if (ihigh == NULL) {
				vinfo_decref(ilow, po);
				if (PycException_Occurred(po))
					return NULL;
				goto with_slice_object;
			}
		}
		u = PsycoSequence_GetSlice(po, u, ilow, ihigh);
		vinfo_decref(ihigh, po);
		vinfo_decref(ilow, po);
		return u;
	}

   with_slice_object:
	{
		char modes[4];
		vinfo_t* vslice;
		modes[0] = v == NULL ? 'l' : 'v';
		modes[1] = w == NULL ? 'l' : 'v';
		modes[2] = 'l';
		modes[3] = 0;
		vslice = psyco_generic_call(po, PySlice_New,
					    CfReturnRef|CfPyErrIfNull,
					    modes, v, w, NULL);
		if (vslice != NULL) {
			u = PsycoObject_GetItem(po, u, vslice);
			vinfo_decref(vslice, po);
			return u;
		}
		else
			return NULL;
	}
}
</t>
<t tx="T414">static bool psyco_assign_slice(PsycoObject* po, vinfo_t* u,
			       vinfo_t* v, vinfo_t* w, vinfo_t* x)
{	 /* u[v:w] = x  or  del u[v:w] if x==NULL */
	PyTypeObject *tp;
	PySequenceMethods *sq;
	bool ok;

	tp = Psyco_NeedType(po, u);
	if (tp == NULL)
		return false;
	sq = tp-&gt;tp_as_sequence;

	if (sq &amp;&amp; sq-&gt;sq_slice) {
		vinfo_t* ilow;
		vinfo_t* ihigh;
		if (v == NULL) {
			ilow = psyco_viZero;
			vinfo_incref(ilow);
		}
		else {
			ilow = _PsycoEval_SliceIndex(po, v);
			if (ilow == NULL) {
				if (PycException_Occurred(po))
					return false;
				goto with_slice_object;
			}
		}
		if (w == NULL)
			ihigh = vinfo_new(CompileTime_New(INT_MAX));
		else {
			ihigh = _PsycoEval_SliceIndex(po, w);
			if (ihigh == NULL) {
				vinfo_decref(ilow, po);
				if (PycException_Occurred(po))
					return false;
				goto with_slice_object;
			}
		}
		ok = PsycoSequence_SetSlice(po, u, ilow, ihigh, x);
		vinfo_decref(ihigh, po);
		vinfo_decref(ilow, po);
		return ok;
	}

   with_slice_object:
	{
		char modes[4];
		vinfo_t* vslice;
		modes[0] = v == NULL ? 'l' : 'v';
		modes[1] = w == NULL ? 'l' : 'v';
		modes[2] = 'l';
		modes[3] = 0;
		vslice = psyco_generic_call(po, PySlice_New,
					    CfReturnRef|CfPyErrIfNull,
					    modes, v, w, NULL);
		if (vslice != NULL) {
			ok = PsycoObject_SetItem(po, u, vslice, x);
			vinfo_decref(vslice, po);
			return ok;
		}
		else
			return false;
	}
}
</t>
<t tx="T415">@ **************************************************************/
** Run-time implementation of various opcodes ***/
the code of the following functions is "copy-pasted" from ceval.c */
@c

</t>
<t tx="T416">static int cimpl_print_item_to(PyObject* v, PyObject* stream)
{
	if (stream == NULL || stream == Py_None) {
		stream = PySys_GetObject("stdout");
		if (stream == NULL) {
			PyErr_SetString(PyExc_RuntimeError,
					"lost sys.stdout");
			return -1;
		}
	}
	if (PyFile_SoftSpace(stream, 1))
		if (PyFile_WriteString(" ", stream))
			return -1;
	if (PyFile_WriteObject(v, stream, Py_PRINT_RAW))
		return -1;
	if (PyString_Check(v)) {
		/* move into writeobject() ? */
		char *s = PyString_AsString(v);
		int len = PyString_Size(v);
		if (len &gt; 0 &amp;&amp;
		    isspace(Py_CHARMASK(s[len-1])) &amp;&amp;
		    s[len-1] != ' ')
			PyFile_SoftSpace(stream, 0);
	}
	return 0;
}
</t>
<t tx="T417">static int cimpl_print_newline_to(PyObject* stream)
{
	if (stream == NULL || stream == Py_None) {
		stream = PySys_GetObject("stdout");
		if (stream == NULL) {
			PyErr_SetString(PyExc_RuntimeError,
					"lost sys.stdout");
			return -1;
		}
	}
	if (PyFile_WriteString("\n", stream))
		return -1;
	PyFile_SoftSpace(stream, 0);
	return 0;
}
</t>
<t tx="T418">static int cimpl_unpack_iterable(PyObject* v, int argcnt, PyObject** sp)
{
	int i = 0;
	PyObject *it;  /* iter(v) */
	PyObject *w;

	assert(v != NULL);

	it = PyObject_GetIter(v);
	if (it == NULL)
		goto Error;

	for (; i &lt; argcnt; i++) {
		w = PyIter_Next(it);
		if (w == NULL) {
			/* Iterator done, via error or exhaustion. */
			if (!PyErr_Occurred()) {
				PyErr_Format(PyExc_ValueError,
					"need more than %d value%s to unpack",
					i, i == 1 ? "" : "s");
			}
			goto Error;
		}
		*sp++ = w;
	}

	/* We better have exhausted the iterator now. */
	w = PyIter_Next(it);
	if (w == NULL) {
		if (PyErr_Occurred())
			goto Error;
		Py_DECREF(it);
		return 0;
	}
	PyErr_SetString(PyExc_ValueError, "too many values to unpack");
	Py_DECREF(w);
	/* fall through */
Error:
	for (; i &gt; 0; i--) {
		--sp;
		Py_DECREF(*sp);
	}
	Py_XDECREF(it);
	return -1;
}
</t>
<t tx="T419">static int cimpl_unpack_list(PyObject* listobject, int argcnt, PyObject** sp)
{
	int i;
	extra_assert(PyList_Check(listobject));

	if (PyList_GET_SIZE(listobject) != argcnt) {
		PyErr_SetString(PyExc_ValueError, "unpack list of wrong size");
		return -1;
	}
	for (i=argcnt; i--; ) {
		PyObject* v = sp[i] = PyList_GET_ITEM(listobject, i);
		Py_INCREF(v);
	}
	return 0;
}
</t>
<t tx="T420">@ **************************************************************/
** Main loop ***/
**************************************************************/
@c</t>
<t tx="T421">static code_t* exit_function(PsycoObject* po)
{
	int i;
	vinfo_t** locals_plus;
	NonVirtualSource retsource;
	
	/* clear the stack and the locals */
	locals_plus = LOC_LOCALS_PLUS-&gt;array-&gt;items;
	for (i=LOC_LOCALS_PLUS-&gt;array-&gt;count; i--; )
		if (locals_plus[i] != NULL) {
			vinfo_decref(locals_plus[i], po);
			locals_plus[i] = NULL;
		}
	
	if (PycException_Is(po, &amp;EReturn)) {
		/* load the return value */
		vinfo_t* retval = po-&gt;pr.val;
		retsource = vinfo_compute(retval, po);
		if (retsource == SOURCE_ERROR) return NULL;
		if (!eat_reference(retval)) {
			/* return a new reference */
			psyco_incref_v(po, retval);
		}
	}
	else {
		/* &amp;ERtPython is the case where the code that raised
		   the Python exception is already written, e.g. when
		   we called a function in the Python interpreter which
		   raised an exception. */
		if (!PycException_Is(po, &amp;ERtPython)) {
			/* In the other cases (virtual exception),
			   compute and raise the exception now. */
			if (psyco_generic_call(po, PyErr_SetObject,
					       CfNoReturnValue, "vv",
					       po-&gt;pr.exc, po-&gt;pr.val) == NULL)
				return NULL;
			clear_pseudo_exception(po);
		}
		retsource = psyco_viZero-&gt;source;  /* to return NULL */
	}
	
	return psyco_finish_return(po, retsource);
}
</t>
<t tx="T422">@language c

@ **************************************************************/
** the main loop of the interpreter/compiler. ***/
@c

DEFINEFN
code_t* psyco_pycompiler_mainloop(PsycoObject* po)
{
  /* 'stack_a' is the Python stack base pointer */
  vinfo_t** stack_a = LOC_LOCALS_PLUS-&gt;array-&gt;items + po-&gt;pr.stack_base;
  code_t* code1;
  
  /* save and restore the current Python exception throughout compilation */
  PyObject *old_py_exc, *old_py_val, *old_py_tb;
  PyErr_Fetch(&amp;old_py_exc, &amp;old_py_val, &amp;old_py_tb);

  while (LOC_NEXT_INSTR != NULL) {
    &lt;&lt; outer loop &gt;&gt;
  }
  	
  /* function return (either by RETURN or by exception). */
  while ((code1 = exit_function(po)) == NULL) {
	  /* If LOC_EXCEPTION is still set after exit_function(), it
	     means an exception was raised while handling the functn
	     return... In this case, we do a function return again,
	     this time with the newly raised exception.
		 XXX make sure this loop cannot be endless. */
  }

finished:
	#ifdef ALL_CHECKS
	  if (PyErr_Occurred()) {
		  fprintf(stderr, "psyco: unexpected Python exception during compilation:\n");
		  PyErr_WriteUnraisable(Py_None);
	  }
	#endif

	PyErr_Restore(old_py_exc, old_py_val, old_py_tb);
	return code1;
}</t>
<t tx="T423">&lt;&lt; define loop vars &gt;&gt;

/* main loop */
while (1) {
  &lt;&lt; main loop &gt;&gt;
}  /* end of the main loop, exit if exception */

psyco_assert_coherent(po);
&lt;&lt; check for the 'promotion' pseudo-exception &gt;&gt;

/* At this point, we got a real pseudo-exception. */

/* Unwind the Python stack until we find a handler for the (pseudo) exception.
   You will recognize here ceval.c's stack unwinding code. */
while (po-&gt;pr.iblock &gt; 0) {
	&lt;&lt; unwind the stack &gt;&gt;
} /* end of unwind stack */

/* End the function if we still have a (pseudo) exception */
if (PycException_Occurred(po)) {
  /* at the end of the function we set LOC_NEXT_INSTR to NULL
     because the actual position has no longer any importance */
  vinfo_decref(LOC_NEXT_INSTR, po);
  LOC_NEXT_INSTR = NULL;
}</t>
<t tx="T424">/* 'co' is the code object we are interpreting/compiling */
KNOWN_VAR(PyCodeObject*, co, LOC_CODE);

unsigned char* bytecode = (unsigned char*) PyString_AS_STRING(co-&gt;co_code);

int opcode=0;	/* Current opcode */
int oparg=0;	/* Current opcode argument, if any */

vinfo_t *u, *v,	/* temporary objects    */
  *w, *x;	/* popped off the stack */

condition_code_t cc;

/* 'next_instr' is the position in the byte-code of the next instr */
KNOWN_VAR(int, next_instr, LOC_NEXT_INSTR);
</t>
<t tx="T425">extra_assert(!PycException_Occurred(po));
psyco_assert_coherent(po);  /* this test is expensive */

/* save 'next_instr' */
SAVE_NEXT_INSTR(next_instr);  /* could be optimized, not needed in the
                                   case of an opcode that cannot set
                                   run-time conditions */
  
opcode = NEXTOP();
if (HAS_ARG(opcode))
	oparg = NEXTARG();
dispatch_opcode:

/* Main switch on opcode */

/* !!IMPORTANT!!
 No operation with side-effects must be performed before we are
 sure the compilation of the current instruction succeeded!
 Indeed, if the compilation is interrupted by a C++ exception,
 it will be restarted by re-running psyco_pycompiler_mainloop()
 and this will restart the compilation of the instruction from
 the beginning. In particular, use POP() with care. Better use
 TOP() to get the arguments off the stack and call POP() at the
 end when you are sure everything when fine. */

switch (opcode) {
  &lt;&lt; handle opcodes &gt;&gt;
}  /* switch (opcode) */

/* Exit if an error occurred */
if (PycException_Occurred(po))
	break;

fine:
extra_assert(!PycException_Occurred(po));

/* are we running out of space in the current code buffer? */
if ((po-&gt;codelimit - po-&gt;code) &lt; BUFFER_MARGIN) {
	extra_assert(!is_respawning(po));
	SAVE_NEXT_INSTR(next_instr);
	code1 = psyco_compile(po, false);
	goto finished;
}

/* mark merge points via a call to psyco_compile() */
if (CHECK_ARRAY_BIT(po-&gt;pr.merge_points, next_instr)) {
	extra_assert(!is_respawning(po));
	SAVE_NEXT_INSTR(next_instr);
	code1 = psyco_compile(po, true);
	if (code1 != NULL)
		goto finished;
}</t>
<t tx="T426">@language c
/* case STOP_CODE: this is an error! */
&lt;&lt; binary opcodes &gt;&gt;
&lt;&lt; compare_op &gt;&gt;
&lt;&lt; exec_stmt &gt;&gt;
&lt;&lt; flow of control cases &gt;&gt;
&lt;&lt; function call/make/return &gt;&gt;
&lt;&lt; import &gt;&gt;
&lt;&lt; load/store/build/delete &gt;&gt;
&lt;&lt; print &gt;&gt;
&lt;&lt; set_lineno &gt;&gt;
&lt;&lt; slice &gt;&gt;
&lt;&lt; subscript &gt;&gt;
&lt;&lt; stack opcodes &gt;&gt;
&lt;&lt; unary opcodes &gt;&gt;
&lt;&lt; unpack_sequence &gt;&gt;
default:
	&lt;&lt; default case &gt;&gt;</t>
<t tx="T427">&lt;&lt; binary_power &gt;&gt;
&lt;&lt; BINARY_OPCODE macro (psyco) &gt;&gt;
BINARY_OPCODE(BINARY_MULTIPLY, PsycoNumber_Multiply);
BINARY_OPCODE(BINARY_DIVIDE, PsycoNumber_Divide);
#ifdef BINARY_FLOOR_DIVIDE
	MISSING_OPCODE(BINARY_FLOOR_DIVIDE);    /* XXX */
	MISSING_OPCODE(BINARY_TRUE_DIVIDE);
	MISSING_OPCODE(INPLACE_FLOOR_DIVIDE);
	MISSING_OPCODE(INPLACE_TRUE_DIVIDE);
#endif
BINARY_OPCODE(BINARY_MODULO, PsycoNumber_Remainder);
BINARY_OPCODE(BINARY_ADD, PsycoNumber_Add);
BINARY_OPCODE(BINARY_SUBTRACT, PsycoNumber_Subtract);
BINARY_OPCODE(BINARY_SUBSCR, PsycoObject_GetItem);
BINARY_OPCODE(BINARY_LSHIFT, PsycoNumber_Lshift);
BINARY_OPCODE(BINARY_RSHIFT, PsycoNumber_Rshift);
BINARY_OPCODE(BINARY_AND, PsycoNumber_And);
BINARY_OPCODE(BINARY_XOR, PsycoNumber_Xor);
BINARY_OPCODE(BINARY_OR, PsycoNumber_Or);
&lt;&lt; inplace_power &gt;&gt;
BINARY_OPCODE(INPLACE_MULTIPLY, PsycoNumber_InPlaceMultiply);
BINARY_OPCODE(INPLACE_DIVIDE, PsycoNumber_InPlaceDivide);
BINARY_OPCODE(INPLACE_MODULO, PsycoNumber_InPlaceRemainder);
BINARY_OPCODE(INPLACE_ADD, PsycoNumber_InPlaceAdd);
BINARY_OPCODE(INPLACE_SUBTRACT, PsycoNumber_InPlaceSubtract);
BINARY_OPCODE(INPLACE_LSHIFT, PsycoNumber_InPlaceLshift);
BINARY_OPCODE(INPLACE_RSHIFT, PsycoNumber_InPlaceRshift);
BINARY_OPCODE(INPLACE_AND, PsycoNumber_InPlaceAnd);
BINARY_OPCODE(INPLACE_XOR, PsycoNumber_InPlaceXor);
BINARY_OPCODE(INPLACE_OR, PsycoNumber_InPlaceOr);</t>
<t tx="T428">#define BINARY_OPCODE(opcode, psycofn)			\
case opcode:					\
	x = psycofn (po, NTOP(2), NTOP(1));	\
	if (x == NULL)				\
		break;				\
	POP_DECREF();				\
	POP_DECREF();				\
	PUSH(x);				\
	goto fine</t>
<t tx="T429">case BINARY_POWER:
	x = PsycoNumber_Power(po, NTOP(2), NTOP(1), psyco_viNone);
	if (x == NULL)
		break;
	POP_DECREF();
	POP_DECREF();
	PUSH(x);
	goto fine;</t>
<t tx="T430">case INPLACE_POWER:
	x = PsycoNumber_InPlacePower(po, NTOP(2), NTOP(1), psyco_viNone);
	if (x == NULL)
		break;
	POP_DECREF();
	POP_DECREF();
	PUSH(x);
	goto fine;</t>
<t tx="T431">case COMPARE_OP:
{
	condition_code_t cc;
	w = TOP();
	v = NTOP(2);
	switch (oparg) {
		
	case IS:      /* pointer comparison */
		cc = integer_cmp(po, v, w, Py_EQ);
		break;
		
	case IS_NOT:  /* pointer comparison */
		cc = integer_cmp(po, v, w, Py_NE);
		break;

	MISSING_OPCODE(IN);
	MISSING_OPCODE(NOT_IN);

	case EXC_MATCH:
		cc = psyco_flag_call(po, PyErr_GivenExceptionMatches,
				     CfPure | CfReturnFlag, "vv", v, w);
		break;

	default:
		x = PsycoObject_RichCompare(po, v, w, oparg);
		goto compare_done;
	}

	if (cc == CC_ERROR)
		break;
	
	/* turns 'cc' into a virtual Python integer object, 0 or 1 */
	x = PsycoInt_FROM_LONG(psyco_vinfo_condition(po, cc));
	
compare_done:
	if (x == NULL)
		break;
	POP_DECREF();
	POP_DECREF();
	PUSH(x);  /* consumes ref on x */
	goto fine;
}</t>
<t tx="T432">fprintf(stderr,
	"XXX opcode: %d\n",
	opcode);
Py_FatalError("unknown opcode");</t>
<t tx="T433">MISSING_OPCODE(EXEC_STMT);</t>
<t tx="T434">MISSING_OPCODE(FOR_LOOP);
MISSING_OPCODE(RAISE_VARARGS);
MISSING_OPCODE(LOAD_LOCALS);
&lt;&lt; break_loop &gt;&gt;
&lt;&lt; continue_loop &gt;&gt;
&lt;&lt; end_finally &gt;&gt;
&lt;&lt; iters &gt;&gt;
&lt;&lt; jumps &gt;&gt;
&lt;&lt; pop_block &gt;&gt;
</t>
<t tx="T435">case BREAK_LOOP:
	PycException_Raise(po, vinfo_new(VirtualTime_New(&amp;EBreak)),
			   NULL);
	break;</t>
<t tx="T436">case CONTINUE_LOOP:
	PycException_Raise(po, vinfo_new(VirtualTime_New(&amp;EContinue)),
			   vinfo_new(CompileTime_New(oparg)));
	break;</t>
<t tx="T437">case END_FINALLY:
	POP(v);
	if (is_compiletime(v-&gt;source) &amp;&amp;
	    CompileTime_Get(v-&gt;source)-&gt;value == (long) Py_None) {
		/* 'None' on the stack, it is the end of a finally
		   block with no exception raised */
		vinfo_decref(v, po);
		goto fine;
	}
	if (v-&gt;array-&gt;count &gt; OB_TYPE &amp;&amp;
	    is_compiletime(v-&gt;array-&gt;items[OB_TYPE]-&gt;source) &amp;&amp;
	    CompileTime_Get(v-&gt;array-&gt;items[OB_TYPE]-&gt;source)-&gt;value ==
	     (long)(&amp;PyTuple_Type) &amp;&amp;
	    PsycoTuple_Load(v) == 3) {
		/* 'v' is a 3- tuple. As no real Python exception is
		   a tuple object we are sure it comes from a
		   finally block (see the SETUP_FINALLY stack unwind
		   code at the end of pycompiler.c) */
		/* Re-raise the pseudo exception. This will re-raise
		   exceptions like EReturn as well. */
		po-&gt;pr.exc = PsycoTuple_GET_ITEM(v, 0);
		PsycoTuple_GET_ITEM(v, 0) = NULL;
		po-&gt;pr.val = PsycoTuple_GET_ITEM(v, 1);
		PsycoTuple_GET_ITEM(v, 1) = NULL;
		/* XXX no traceback support */
		/* tb will be decref'ed by vinfo_decref(v) below */
		vinfo_decref(v, po);
		break;
	}
	else {
		/* end of an EXCEPT block, re-raise the exception
		   stored in the stack.
		   XXX when implementing tracebacks find a trick to
		       mark this as a re-raising */
		po-&gt;pr.exc = v;
		POP(po-&gt;pr.val);
		POP(v);
		vinfo_decref(v, po);   /* XXX traceback */
		break;
	}</t>
<t tx="T438">&lt;&lt; get_iter &gt;&gt;
&lt;&lt; for_iter &gt;&gt;
&lt;&lt; yeild_value &gt;&gt;</t>
<t tx="T439">case FOR_ITER:
	v = PsycoIter_Next(po, TOP());
	if (v != NULL) {
		/* iterator not exhausted */
		PUSH(v);
	}
	else {
		/* catch PyExc_StopIteration */
		cc = PycException_Matches(po, PyExc_StopIteration);
		if (cc == CC_ERROR)
			break;
		if (runtime_condition_t(po, cc)) {
			/* iterator ended normally */
			PycException_Clear(po);
			POP_DECREF();
			JUMPBY(oparg);
		}
		else
			break;   /* any other exception */
	}
	goto fine;</t>
<t tx="T440">case GET_ITER:
	x = PsycoObject_GetIter(po, TOP());
	if (x == NULL)
		break;
	POP_DECREF();
	PUSH(x);
	goto fine;</t>
<t tx="T441">#ifdef YIELD_VALUE
MISSING_OPCODE(YIELD_VALUE);
#endif</t>
<t tx="T442">&lt;&lt; jump_forward &gt;&gt;
&lt;&lt; jump_if_true/false &gt;&gt;
&lt;&lt; jump_absolute &gt;&gt;</t>
<t tx="T443">case JUMP_FORWARD:
	JUMPBY(oparg);
	goto fine;</t>
<t tx="T444">case JUMP_IF_TRUE:
case JUMP_IF_FALSE:
	/* This code is very different from the original
	   interpreter's, because we generally do not know the
	   outcome of PyObject_IsTrue(). In the case of JUMP_IF_xxx
	   we must be prepared to have to compile the two possible
	   paths. */
	cc = PsycoObject_IsTrue(po, TOP());
	if (cc == CC_ERROR)
		break;
	if (opcode == JUMP_IF_FALSE)
		cc = INVERT_CC(cc);
	if (cc &lt; CC_TOTAL) {
		/* compile the beginning of the "if true" path */
		int current_instr = next_instr;
		JUMPBY(oparg);
		SAVE_NEXT_INSTR(next_instr);
		psyco_compile_cond(po, cc);
		next_instr = current_instr;
	}
	else if (cc == CC_ALWAYS_TRUE)
		JUMPBY(oparg);   /* always jump */
	else
		;                  /* never jump */
	goto fine;</t>
<t tx="T445">case JUMP_ABSOLUTE:
	JUMPTO(oparg);
	goto fine;</t>
<t tx="T446">case POP_BLOCK:
{
	PyTryBlock *b = block_pop(po);
	while (STACK_LEVEL() &gt; b-&gt;b_level) {
		POP(v);
		vinfo_decref(v, po);
	}
	goto fine;
}</t>
<t tx="T447">case SETUP_LOOP:
case SETUP_EXCEPT:
case SETUP_FINALLY:
	block_setup(po, opcode, INSTR_OFFSET() + oparg,
		    STACK_LEVEL());
	goto fine;</t>
<t tx="T448">&lt;&lt; call_function &gt;&gt;
MISSING_OPCODE(CALL_FUNCTION_VAR);
MISSING_OPCODE(CALL_FUNCTION_KW);
MISSING_OPCODE(CALL_FUNCTION_VAR_KW);
MISSING_OPCODE(MAKE_FUNCTION);
MISSING_OPCODE(MAKE_CLOSURE);
&lt;&lt; extended_arg &gt;&gt;
&lt;&lt; return_value &gt;&gt;</t>
<t tx="T449">case CALL_FUNCTION:
{
	int na = oparg &amp; 0xff;
	int nk = (oparg&gt;&gt;8) &amp; 0xff;
	int n = na + 2 * nk;
	vinfo_t** args = STACK_POINTER() - n;
	vinfo_t* func = args[-1];
            
	/* build a virtual tuple for apply() */
	v = PsycoTuple_New(na, args);
	if (nk != 0) {
		/* XXX to do: PsycoDict_Virtual() */
		int i;
                    w = PsycoDict_New(po);
		if (w != NULL) {
			/* XXX do something closer to
			   update_keyword_args() in ceval.c, e.g.
			   check for duplicate keywords */
			for (i=na; i&lt;n; i+=2) {
				if (psyco_flag_call(po, PyDict_SetItem,
					CfReturnFlag|CfPyErrIfNonNull,
					"vvv", w, args[i], args[i+1])
				    == CC_ERROR)
					break;
			}
		}
	}
	else
		w = NULL;
	if (PycException_Occurred(po))
		x = NULL;
	else
		x = PsycoObject_Call(po, func, v, w);
	vinfo_xdecref(w, po);
	vinfo_decref(v, po);
	if (x == NULL)
		break;

	/* clean up the stack (remove args and func) */
	while (n-- &gt;= 0)
		POP_DECREF();
	PUSH(x);
	goto fine;
}</t>
<t tx="T450">case EXTENDED_ARG:
	opcode = NEXTOP();
	oparg = oparg&lt;&lt;16 | NEXTARG();
	goto dispatch_opcode;</t>
<t tx="T451">case RETURN_VALUE:
	POP(v);
	PycException_Raise(po, vinfo_new(VirtualTime_New(&amp;EReturn)), v);
	break;</t>
<t tx="T452">MISSING_OPCODE(IMPORT_NAME);
MISSING_OPCODE(IMPORT_STAR);
MISSING_OPCODE(IMPORT_FROM);</t>
<t tx="T453">MISSING_OPCODE(BUILD_CLASS);
&lt;&lt; build_list &gt;&gt;
&lt;&lt; build_map &gt;&gt;
MISSING_OPCODE(BUILD_SLICE);
&lt;&lt; build_tuple &gt;&gt;

&lt;&lt; delete_attr &gt;&gt;
&lt;&lt; delete_fast &gt;&gt;
&lt;&lt; delete_global &gt;&gt;
MISSING_OPCODE(DELETE_NAME);

&lt;&lt; load_attr &gt;&gt;
MISSING_OPCODE(LOAD_DEREF);
MISSING_OPCODE(LOAD_CLOSURE);
&lt;&lt; load_const &gt;&gt;
MISSING_OPCODE(LOAD_NAME);
&lt;&lt; load_global &gt;&gt;
&lt;&lt; load_fast &gt;&gt;

&lt;&lt; store_attr &gt;&gt;
MISSING_OPCODE(STORE_DEREF);
&lt;&lt; store_fast &gt;&gt;
&lt;&lt; store_global &gt;&gt;
MISSING_OPCODE(STORE_NAME);</t>
<t tx="T454">case BUILD_LIST:
	v = PsycoList_New(po, oparg);
	if (v == NULL)
		break;
	
            if (oparg &gt; 0) {
		int i;
		
		/* load 'list-&gt;ob_item' into 'w' */
		w = read_array_item(po, v, LIST_OB_ITEM);
		if (w == NULL) {
			vinfo_decref(v, po);
			break;
		}
		
		/* write the list items from 'w' */
		for (i=0; i&lt;oparg; i++) {
			x = NTOP(oparg-i);
			if (!write_array_item_ref(po, w, i, x, true))
				break;
		}
		vinfo_decref(w, po);
		if (PycException_Occurred(po)) {
			vinfo_decref(v, po);
			break;
		}
		while (oparg--)
			POP_DECREF();
	}
	PUSH(v);
	goto fine;</t>
<t tx="T455">case BUILD_MAP:
	v = PsycoDict_New(po);
	if (v == NULL)
		break;
	PUSH(v);
	goto fine;</t>
<t tx="T456">case BUILD_TUPLE:
	v = PsycoTuple_New(oparg, STACK_POINTER() - oparg);
	while (oparg--)
		POP_DECREF();
	PUSH(v);
	goto fine;</t>
<t tx="T457">case DELETE_ATTR:
{
	bool ok;
	w = vinfo_new(CompileTime_New(((long) GETNAMEV(oparg))));
	ok = PsycoObject_SetAttr(po, TOP(), w, NULL);   /* del v.w */
	vinfo_decref(w, po);
	if (!ok)
		break;
	POP_DECREF();
	goto fine;
}</t>
<t tx="T458">case DELETE_FAST:
	x = GETLOCAL(oparg);
	/* a local variable can only be unbound if its
	   value is known to be (PyObject*)NULL. A run-time
	   or virtual value is always non-NULL. */
	if (psyco_knowntobe(x, 0)) {
		PyObject* namev;
		namev = PyTuple_GetItem(co-&gt;co_varnames, oparg);
		PycException_SetFormat(po, PyExc_UnboundLocalError,
				       UNBOUNDLOCAL_ERROR_MSG,
				       PyString_AsString(namev));
		break;
	}

	SETLOCAL(oparg, psyco_viZero);
	vinfo_incref(psyco_viZero);
	goto fine;</t>
<t tx="T459">case DELETE_GLOBAL:
{
	KNOWN_VAR(PyObject*, globals, LOC_GLOBALS);
	PyObject* w = GETNAMEV(oparg);

	if (psyco_flag_call(po, PyDict_DelItem,
			    CfReturnFlag|CfPyErrIfNonNull,
			    "ll", globals, w) == CC_ERROR) {
		/*if (!Py_Occurred() at run-time)*/
		PycException_SetFormat(po, PyExc_NameError,
				       GLOBAL_NAME_ERROR_MSG,
				       PyString_AsString(w));
		break;
	}
	POP_DECREF();
	goto fine;
}</t>
<t tx="T460">case LOAD_ATTR:
	w = vinfo_new(CompileTime_New(((long) GETNAMEV(oparg))));
	x = PsycoObject_GetAttr(po, TOP(), w);  /* v.w */
	vinfo_decref(w, po);
	if (x == NULL)
		break;
	POP_DECREF();
	PUSH(x);
	goto fine;</t>
<t tx="T461">case LOAD_CONST:
	/* reference borrowed from the code object */
	v = vinfo_new(CompileTime_New((long) GETCONST(oparg)));
	PUSH(v);
	goto fine;</t>
<t tx="T462">case LOAD_FAST:
	x = GETLOCAL(oparg);
	/* a local variable can only be unbound if its
	   value is known to be (PyObject*)NULL. A run-time
	   or virtual value is always non-NULL. */
	if (psyco_knowntobe(x, 0)) {
		PyObject* namev;
		namev = PyTuple_GetItem(co-&gt;co_varnames, oparg);
		PycException_SetFormat(po, PyExc_UnboundLocalError,
				       UNBOUNDLOCAL_ERROR_MSG,
				       PyString_AsString(namev));
		break;
	}
	vinfo_incref(x);
	PUSH(x);
	goto fine;</t>
<t tx="T463">case LOAD_GLOBAL:
{
	PyObject* namev = GETNAMEV(oparg);
            PyObject* value = load_global(po, namev, next_instr);
	if (value == NULL)
		break;
	v = vinfo_new(CompileTime_NewSk(sk_new((long) value,
					       SkFlagPyObj)));
	PUSH(v);
	goto fine;
}</t>
<t tx="T464">case STORE_ATTR:
{
	bool ok;
	w = vinfo_new(CompileTime_New(((long) GETNAMEV(oparg))));
	ok = PsycoObject_SetAttr(po, TOP(), w, NTOP(2));  /* v.w = u */
	vinfo_decref(w, po);
	if (!ok)
		break;
	POP_DECREF();
	POP_DECREF();
	goto fine;
}</t>
<t tx="T465">case STORE_FAST:
	POP(v);
	SETLOCAL(oparg, v);
	goto fine;</t>
<t tx="T466">case STORE_GLOBAL:
{
	KNOWN_VAR(PyObject*, globals, LOC_GLOBALS);
	PyObject* w = GETNAMEV(oparg);

	if (psyco_flag_call(po, PyDict_SetItem,
			    CfReturnFlag|CfPyErrIfNonNull,
			    "llv", globals, w, TOP()) == CC_ERROR)
		break;
	POP_DECREF();
	goto fine;
}</t>
<t tx="T467">MISSING_OPCODE(PRINT_EXPR);
&lt;&lt; print_item &gt;&gt;
&lt;&lt; print_item_to &gt;&gt;
&lt;&lt; print_newline &gt;&gt;
&lt;&lt; print_newline_to &gt;&gt;</t>
<t tx="T468">case PRINT_ITEM:
	if (psyco_flag_call(po, cimpl_print_item_to,
			    CfReturnFlag|CfPyErrIfNonNull,
			    "vl", TOP(), 0) == CC_ERROR)
		break;
	POP_DECREF();
	goto fine;</t>
<t tx="T469">case PRINT_ITEM_TO:
	if (psyco_flag_call(po, cimpl_print_item_to,
			    CfReturnFlag|CfPyErrIfNonNull,
			    "vv", NTOP(2), TOP()) == CC_ERROR)
		break;
	POP_DECREF();
	POP_DECREF();
	goto fine;</t>
<t tx="T470">case PRINT_NEWLINE:
	psyco_flag_call(po, cimpl_print_newline_to,
			CfReturnFlag|CfPyErrIfNonNull,
			"l", 0);
	break;</t>
<t tx="T471">case PRINT_NEWLINE_TO:
	if (psyco_flag_call(po, cimpl_print_newline_to,
			    CfReturnFlag|CfPyErrIfNonNull,
			    "v", TOP()) == CC_ERROR)
		break;
	POP_DECREF();
	goto fine;</t>
<t tx="T472">case SET_LINENO:
	/* nothing */
	goto fine;</t>
<t tx="T473">&lt;&lt; slice cases &gt;&gt;
&lt;&lt; store slice cases &gt;&gt;
&lt;&lt; delete slice cases &gt;&gt;</t>
<t tx="T474">case SLICE+0:
case SLICE+1:
case SLICE+2:
case SLICE+3:
{
	int from_top = 1;
	if ((opcode-SLICE) &amp; 2) {
		w = NTOP(from_top);
		from_top++;
	}
	else
		w = NULL;
	if ((opcode-SLICE) &amp; 1) {
		v = NTOP(from_top);
		from_top++;
	}
	else
		v = NULL;
	u = NTOP(from_top);
	x = psyco_apply_slice(po, u, v, w);
	if (x == NULL)
		break;
	POP_DECREF();
	if (v != NULL) POP_DECREF();
	if (w != NULL) POP_DECREF();
	PUSH(x);
	goto fine;
}</t>
<t tx="T475">case STORE_SLICE+0:
case STORE_SLICE+1:
case STORE_SLICE+2:
case STORE_SLICE+3:
{
	int from_top = 1;
	if ((opcode-STORE_SLICE) &amp; 2) {
		w = NTOP(from_top);
		from_top++;
	}
	else
		w = NULL;
	if ((opcode-STORE_SLICE) &amp; 1) {
		v = NTOP(from_top);
		from_top++;
	}
	else
		v = NULL;
	u = NTOP(from_top);
	if (!psyco_assign_slice(po, u, v, w, NTOP(from_top+1)))
		break;
	POP_DECREF();
	POP_DECREF();
	if (v != NULL) POP_DECREF();
	if (w != NULL) POP_DECREF();
	goto fine;
}</t>
<t tx="T476">case DELETE_SLICE+0:
case DELETE_SLICE+1:
case DELETE_SLICE+2:
case DELETE_SLICE+3:
{
	int from_top = 1;
	if ((opcode-DELETE_SLICE) &amp; 2) {
		w = NTOP(from_top);
		from_top++;
	}
	else
		w = NULL;
	if ((opcode-DELETE_SLICE) &amp; 1) {
		v = NTOP(from_top);
		from_top++;
	}
	else
		v = NULL;
	u = NTOP(from_top);
	if (!psyco_assign_slice(po, u, v, w, NULL))
		break;
	POP_DECREF();
	if (v != NULL) POP_DECREF();
	if (w != NULL) POP_DECREF();
	goto fine;
}</t>
<t tx="T477">&lt;&lt; pop_top &gt;&gt;
&lt;&lt; rot_two &gt;&gt;
&lt;&lt; rot_three &gt;&gt;
&lt;&lt; rot_four &gt;&gt;
&lt;&lt; dup_top &gt;&gt;
&lt;&lt; dup_topx &gt;&gt;</t>
<t tx="T478">case DUP_TOP:
	v = TOP();
	vinfo_incref(v);
	PUSH(v);
	goto fine;</t>
<t tx="T479">case DUP_TOPX:
{
	int i;
	for (i=0; i&lt;oparg; i++) {
		x = NTOP(oparg);
		vinfo_incref(x);
		PUSH(x);
	}
	goto fine;
}</t>
<t tx="T480">case POP_TOP:
	POP_DECREF();
	goto fine;</t>
<t tx="T481">case ROT_TWO:
	POP(v);
	POP(w);
	PUSH(v);
	PUSH(w);
	goto fine;</t>
<t tx="T482">case ROT_THREE:
	POP(v);
	POP(w);
	POP(x);
	PUSH(v);
	PUSH(x);
	PUSH(w);
	goto fine;</t>
<t tx="T483">case ROT_FOUR:
	POP(u);
	POP(v);
	POP(w);
	POP(x);
	PUSH(u);
	PUSH(x);
	PUSH(w);
	PUSH(v);
	goto fine;</t>
<t tx="T484">&lt;&lt; store_subscr &gt;&gt;
&lt;&lt; delete_subscr &gt;&gt;</t>
<t tx="T485">case STORE_SUBSCR:
	w = NTOP(1);
	v = NTOP(2);
	u = NTOP(3);
	/* v[w] = u */
	if (!PsycoObject_SetItem(po, v, w, u))
		break;
	POP_DECREF();
	POP_DECREF();
	POP_DECREF();
	goto fine;</t>
<t tx="T486">case DELETE_SUBSCR:
	w = NTOP(1);
	v = NTOP(2);
	/* del v[w] */
	if (!PsycoObject_SetItem(po, v, w, NULL))
		break;
	POP_DECREF();
	POP_DECREF();
	goto fine;</t>
<t tx="T487">&lt;&lt; unary_positive &gt;&gt;
&lt;&lt; unary_negative &gt;&gt;
&lt;&lt; unary_not &gt;&gt;
&lt;&lt; unary_convert &gt;&gt;
&lt;&lt; unary_invert &gt;&gt;</t>
<t tx="T488">case UNARY_POSITIVE:
	x = PsycoNumber_Positive(po, TOP());
	if (x == NULL)
		break;
	POP_DECREF();
	PUSH(x);
	goto fine;
	
</t>
<t tx="T489">case UNARY_NEGATIVE:
	x = PsycoNumber_Negative(po, TOP());
	if (x == NULL)
		break;
	POP_DECREF();
	PUSH(x);
	goto fine;</t>
<t tx="T490">case UNARY_NOT:
	cc = PsycoObject_IsTrue(po, TOP());
	if (cc == CC_ERROR)
		break;
	/* turns 'cc' into a Python integer object, 0 or 1 */
	x = PsycoInt_FROM_LONG(psyco_vinfo_condition(po, cc));
	POP_DECREF();
	PUSH(x);  /* consumes ref on 'x' */
	goto fine;</t>
<t tx="T491">case UNARY_CONVERT:
	x = PsycoObject_Repr(po, TOP());
	if (x == NULL)
		break;
	POP_DECREF();
	PUSH(x);
	goto fine;</t>
<t tx="T492">case UNARY_INVERT:
	x = PsycoNumber_Invert(po, TOP());
	if (x == NULL)
		break;
	POP_DECREF();
	PUSH(x);
	goto fine;</t>
<t tx="T493">case UNPACK_SEQUENCE:
{
	int i;
	vinfo_array_t* array;
	void* cimpl_unpack = cimpl_unpack_iterable;
	
	v = TOP();
	u = get_array_item(po, TOP(), OB_TYPE);
	if (u == NULL)
		break;
	switch (psyco_switch_index(po, u, &amp;psyfs_tuple_list)) {
		
	case 0:   /* PyTuple_Type */

		/* shortcut: is this a virtual tuple?
		             of the correct length? */
		if (PsycoTuple_Load(v) != oparg) {

			/* No, fall back to the default path:
			   load the size, compare it with oparg,
			   and if they match proceed by loading the
			   tuple item by item into the stack. */
			vinfo_t* vsize;
			vsize = get_array_item(po, v, VAR_OB_SIZE);
			if (vsize == NULL)
				break;

			/* check the size */
			cc = integer_cmp_i(po, vsize, oparg, Py_NE);
			if (cc == CC_ERROR)
				break;
			if (runtime_condition_f(po, cc)) {
				PycException_SetString(po,
					PyExc_ValueError,
					"unpack tuple of wrong size");
				break;
			}

			/* make sure the tuple data is loaded */
			for (i=oparg; i--; ) {
				w = get_array_item(po, v,
						   TUPLE_OB_ITEM + i);
				if (w == NULL)
					break;
			}
		}
		/* copy the tuple items into the stack */
		for (i=oparg; i--; ) {
			w = v-&gt;array-&gt;items[TUPLE_OB_ITEM + i];
                            vinfo_incref(w);
                            PUSH(w);
                            /* in case the tuple is freed while its items
                               are still in use: */
                            need_reference(po, w);
                    }
                    break;

	case 1:   /* PyList_Type */
		cimpl_unpack = cimpl_unpack_list;
		/* fall through */

	default:
		array = array_new(oparg);
		if (psyco_flag_call(po, cimpl_unpack,
				    CfReturnFlag|CfPyErrIfNonNull,
				    "vlA", v, oparg, array) == CC_ERROR){
			array_delete(array, po);
			break;
		}
		POP_DECREF();
		for (i=oparg; i--; )
			PUSH(array-&gt;items[i]);
		array_release(array);
		goto fine;
	}
	break;
}</t>
<t tx="T494">PyTryBlock *b = block_pop(po);
    
if (b-&gt;b_type == SETUP_LOOP &amp;&amp; PycException_Is(po, &amp;EContinue)) {
	/* For a continue inside a try block,
	   don't pop the block for the loop. */
	int next_instr;
	block_setup(po, b-&gt;b_type, b-&gt;b_handler, b-&gt;b_level);
	JUMPTO(CompileTime_Get(po-&gt;pr.val-&gt;source)-&gt;value);
	clear_pseudo_exception(po);
	SAVE_NEXT_INSTR(next_instr);
	break;
}

/* clear the stack up to b-&gt;b_level */
while (STACK_LEVEL() &gt; b-&gt;b_level) {
	POP_DECREF();   /* no NULLs here */
}

if (b-&gt;b_type == SETUP_LOOP &amp;&amp; PycException_Is(po, &amp;EBreak)) {
	int next_instr;
	clear_pseudo_exception(po);
	JUMPTO(b-&gt;b_handler);
	SAVE_NEXT_INSTR(next_instr);
	break;
}

if (b-&gt;b_type == SETUP_FINALLY) {
	/* unlike ceval.c, SETUP_FINALLY always pushes a single
	   object on the stack. See comments in pycompiler.h.
	   This object is a 3-tuple (exc, value, traceback) which
	   might represent a pseudo-exception like EReturn. */
	int next_instr;
	vinfo_t** stack_a = LOC_LOCALS_PLUS-&gt;array-&gt;items +
				po-&gt;pr.stack_base;
	vinfo_t* exc_info = PsycoTuple_New(3, NULL);
	PycException_Fetch(po);
	exc_info-&gt;array-&gt;items[TUPLE_OB_ITEM + 0] = po-&gt;pr.exc;
	exc_info-&gt;array-&gt;items[TUPLE_OB_ITEM + 1] = po-&gt;pr.val;
	po-&gt;pr.exc = NULL;
	po-&gt;pr.val = NULL;
	PUSH(exc_info);
	JUMPTO(b-&gt;b_handler);
	SAVE_NEXT_INSTR(next_instr);
	break;
}

if (b-&gt;b_type == SETUP_EXCEPT &amp;&amp; PycException_IsPython(po)) {
	/* SETUP_EXCEPT pushes three objects individually as in
	   ceval.c, as needed for bytecode compatibility. See tricks
	   in END_FINALLY to distinguish between the end of a FINALLY
	   and the end of an EXCEPT block. */
	int next_instr;
	vinfo_t** stack_a = LOC_LOCALS_PLUS-&gt;array-&gt;items +
				po-&gt;pr.stack_base;
	while (!PycException_FetchNormalize(po)) {
		/* got an exception while initializing the EXCEPT
		   block... Consider this new exception as overriding
		   the previous one, so that we just re-enter the same
		   EXCEPT block. */
		/* XXX check that this empty loop cannot be endless */
	}
	PUSH(psyco_viNone);  vinfo_incref(psyco_viNone);
	PUSH(po-&gt;pr.val);    po-&gt;pr.val = NULL;
	PUSH(po-&gt;pr.exc);    po-&gt;pr.exc = NULL;
	JUMPTO(b-&gt;b_handler);
	SAVE_NEXT_INSTR(next_instr);
	break;
}</t>
<t tx="T495">
/* check for the 'promotion' pseudo-exception.
This is the only case in which the instruction
causing the exception is restarted. */
if (is_virtualtime(po-&gt;pr.exc-&gt;source) &amp;&amp;
psyco_vsource_is_promotion(po-&gt;pr.exc-&gt;source)) {
  c_promotion_t* promotion = (c_promotion_t*) \
	  VirtualTime_Get(po-&gt;pr.exc-&gt;source);
  vinfo_t* promote_me = po-&gt;pr.val;
  /* NOTE: we assume that 'promote_me' is a member of the
 'po-&gt;vlocals' arrays, so that we can safely DECREF it
 now without actually releasing it. If this assumption
 is false, the psyco_finish_xxx() calls below will give
 unexpected results. */
  extra_assert(array_contains(&amp;po-&gt;vlocals, promote_me));
  clear_pseudo_exception(po);
  if (promotion-&gt;fs == NULL)
	  code1 = psyco_finish_promotion(po,
					 promote_me,
					 promotion-&gt;kflags);
  else
	  code1 = psyco_finish_fixed_switch(po,
					promote_me,
					promotion-&gt;kflags,
					promotion-&gt;fs);
  goto finished;
}</t>
<t tx="T496">@language c

/* Interpreter main loop */

static PyObject *
eval_frame(PyFrameObject *f)
{
	&lt;&lt; define vars &gt;&gt;
	&lt;&lt; define macros &gt;&gt;
	&lt;&lt; initialize &gt;&gt;
	why = WHY_NOT; err = 0;
	w = NULL; x = Py_None;	/* Not a reference, just anything non-NULL */
	for (;;) {
		&lt;&lt; start loop &gt;&gt;
		switch (opcode) {
		&lt;&lt; opcode cases &gt;&gt;
		}
		&lt;&lt; end loop &gt;&gt;
	}
	&lt;&lt; finalize &gt;&gt;
	return retval;
}</t>
<t tx="T497">#ifdef DXPAIRS
int lastopcode = 0;
#endif

PyObject **stack_pointer; /* Next free slot in value stack */

register unsigned char *next_instr;
register int opcode=0;	/* Current opcode */
register int oparg=0;	/* Current opcode argument, if any */
register enum why_code why; /* Reason for block stack unwind */
register int err;	/* Error status -- nonzero if error */

register PyObject *x;	/* Result object -- NULL if error */
register PyObject *v;	/* Temporary objects popped off stack */
register PyObject *w;
register PyObject *u;
register PyObject *t;

register PyObject *stream = NULL;    /* for PRINT opcodes */
register PyObject **fastlocals, **freevars;
PyObject *retval = NULL;	/* Return value */
PyThreadState *tstate = PyThreadState_GET();
PyCodeObject *co;
unsigned char *first_instr;

#ifdef LLTRACE
	int lltrace;
#endif

#if defined(Py_DEBUG) || defined(LLTRACE)
	/* Make it easier to find out where we are with a debugger */
	char *filename;
#endif</t>
<t tx="T498">// EKR: from object.h

#define Py_INCREF(op) ((op)-&gt;ob_refcnt++)
#define Py_DECREF(op) { if (--op-&gt;ob_refcnt == 0) _Py_Dealloc(op) }

// EKR: from frameobject.h

#define GETITEM(v, i)     PyTuple_GET_ITEM((PyTupleObject *)(v), (i))
#define GETITEMNAME(v, i) PyString_AS_STRING( (PyStringObject *) GETITEM((v),(i)) )

#define Getconst(f, i)	(GETITEM(     (f)-&gt;f_code-&gt;co_consts, (i) ))
#define Getname(f, i)	 (GETITEMNAME( (f)-&gt;f_code-&gt;co_names,  (i) ))
#define Getnamev(f, i)	(GETITEM(     (f)-&gt;f_code-&gt;co_names,  (i) ))

// EKR: from tupleobject.h

#define PyTuple_GET_ITEM(op, i)    (((PyTupleObject *)(op))-&gt;ob_item[i])
#define PyTuple_GET_SIZE(op)       (((PyTupleObject *)(op))-&gt;ob_size)
#define PyTuple_SET_ITEM(op, i, v) (((PyTupleObject *)(op))-&gt;ob_item[i] = v)

/* Code access macros */

#define GETCONST(i)	Getconst(f, i)
#define GETNAME(i)	 Getname (f, i)
#define GETNAMEV(i)	Getnamev(f, i)
#define INSTR_OFFSET()	(next_instr - first_instr)
#define NEXTOP()	(*next_instr++)
#define NEXTARG()	(next_instr += 2, (next_instr[-1]&lt;&lt;8) + next_instr[-2])
#define JUMPTO(x)	(next_instr = first_instr + (x))
#define JUMPBY(x)	(next_instr += (x))

/* Stack manipulation macros */

#define STACK_LEVEL()	(stack_pointer - f-&gt;f_valuestack)
#define EMPTY()		(STACK_LEVEL() == 0)
#define TOP()		(stack_pointer[-1])

#define BASIC_PUSH(v)	(*stack_pointer++ = (v))
#define BASIC_POP()	  (*--stack_pointer)

#ifdef LLTRACE
	#define PUSH(v)		{ (void)(BASIC_PUSH(v), \
						   lltrace &amp;&amp; prtrace(TOP(), "push")); \
						   assert(STACK_LEVEL() &lt;= f-&gt;f_stacksize); }
	#define POP()		((void)(lltrace &amp;&amp; prtrace(TOP(), "pop")), BASIC_POP())
#else
	#define PUSH(v)		BASIC_PUSH(v)
	#define POP()		BASIC_POP()
#endif

/* Local variable macros */

#define GETLOCAL(i)	(fastlocals[i])
#define SETLOCAL(i, value)	\
	do { Py_XDECREF(GETLOCAL(i)); \
		GETLOCAL(i) = value;\
	} while (0)</t>
<t tx="T499">/* Start of code */
if (f == NULL)
	return NULL;

#ifdef USE_STACKCHECK
	if (tstate-&gt;recursion_depth%10 == 0 &amp;&amp; PyOS_CheckStack()) {
		PyErr_SetString(PyExc_MemoryError, "Stack overflow");
		return NULL;
	}
#endif

/* push frame */
if (++tstate-&gt;recursion_depth &gt; recursion_limit) {
	--tstate-&gt;recursion_depth;
	PyErr_SetString(PyExc_RuntimeError,
			"maximum recursion depth exceeded");
	tstate-&gt;frame = f-&gt;f_back;
	return NULL;
}

tstate-&gt;frame = f;
co = f-&gt;f_code;
fastlocals = f-&gt;f_localsplus;
freevars = f-&gt;f_localsplus + f-&gt;f_nlocals;
_PyCode_GETCODEPTR(co, &amp;first_instr);
next_instr = first_instr + f-&gt;f_lasti;

// EKR: Get the stack pointer from the frame.
stack_pointer = f-&gt;f_stacktop;
assert(stack_pointer != NULL);
f-&gt;f_stacktop = NULL;	/* remains NULL unless yield suspends frame */

if (tstate-&gt;use_tracing) {
	&lt;&lt; initialize tracing &gt;&gt;
}

#ifdef LLTRACE
	lltrace = PyDict_GetItemString(f-&gt;f_globals,"__lltrace__") != NULL;
#endif

#if defined(Py_DEBUG) || defined(LLTRACE)
	filename = PyString_AsString(co-&gt;co_filename);
#endif</t>
<t tx="T500">@ tstate-&gt;c_tracefunc, if defined, is a function that will be called on *every* entry to a code block.  Its return value, if not None, is a function that will be called at the start of each executed line of code. (Actually, the function must return itself in order to continue tracing.)
	   
The trace functions are called with three arguments: a pointer to the current frame, a string indicating why the function is called, and an argument which depends on the situation. The global trace function is also called whenever an exception is detected.
@c

if (tstate-&gt;c_tracefunc != NULL) {
	if (call_trace(tstate-&gt;c_tracefunc, tstate-&gt;c_traceobj,
			   f, PyTrace_CALL, Py_None)) {
		/* Trace function raised an error */
		return NULL;
	}
}

@ Similar for c_profilefunc, except it needn't return itself and isn't called for "line" events.
@c

if (tstate-&gt;c_profilefunc != NULL) {
	if (call_trace(tstate-&gt;c_profilefunc,
			   tstate-&gt;c_profileobj,
			   f, PyTrace_CALL, Py_None)) {
		/* Profile function raised an error */
		return NULL;
	}
}</t>
<t tx="T501">assert(stack_pointer &gt;= f-&gt;f_valuestack);	/* else underflow */
assert(STACK_LEVEL() &lt;= f-&gt;f_stacksize);	/* else overflow */

if (things_to_do || --tstate-&gt;ticker &lt; 0) {
	&lt;&lt; handle periodic things &gt;&gt;
}

&lt;&lt; set f-&gt;f_lasti if debugging or tracing &gt;&gt;

opcode = NEXTOP();

if (HAS_ARG(opcode))
	oparg = NEXTARG();

dispatch_opcode:

&lt;&lt; handle tracing and profiling &gt;&gt;</t>
<t tx="T502">@ Doing this every time through the loop would add too much overhead, so we do it only every Nth instruction.  We also do it if ``things_to_do'' is set, i.e. when an asynchronous event needs attention (e.g. a signal handler or async I/O handler); see Py_AddPendingCall() and Py_MakePendingCalls() above.
@c

tstate-&gt;ticker = tstate-&gt;interp-&gt;checkinterval;
if (things_to_do) {
	if (Py_MakePendingCalls() &lt; 0) {
		why = WHY_EXCEPTION;
		goto on_error;
	}
}
#if !defined(HAVE_SIGNAL_H) || defined(macintosh)
	/* If we have true signals, the signal handler
	   will call Py_AddPendingCall() so we don't
	   have to call sigcheck().  On the Mac and
	   DOS, alas, we have to call it. */
	if (PyErr_CheckSignals()) {
		why = WHY_EXCEPTION;
		goto on_error;
	}
#endif

#ifdef WITH_THREAD
	if (interpreter_lock) {
		/* Give another thread a chance */

		if (PyThreadState_Swap(NULL) != tstate)
			Py_FatalError("ceval: tstate mix-up");
		PyThread_release_lock(interpreter_lock);

		/* Other threads may run now */

		PyThread_acquire_lock(interpreter_lock, 1);
		if (PyThreadState_Swap(tstate) != NULL)
			Py_FatalError("ceval: orphan tstate");
	}
#endif</t>
<t tx="T503">#if defined(Py_DEBUG) || defined(LLTRACE)
	f-&gt;f_lasti = INSTR_OFFSET();
#endif</t>
<t tx="T504">#ifdef DYNAMIC_EXECUTION_PROFILE
	#ifdef DXPAIRS
		dxpairs[lastopcode][opcode]++;
		lastopcode = opcode;
	#endif
		dxp[opcode]++;
#endif

#ifdef LLTRACE
	/* Instruction tracing */
	if (lltrace) {
		if (HAS_ARG(opcode)) {
			printf("%d: %d, %d\n",
				(int) (INSTR_OFFSET() - 3), opcode, oparg);
		}
		else {
			printf("%d: %d\n",
				(int) (INSTR_OFFSET() - 1), opcode);
		}
	}
#endif</t>
<t tx="T505">@ BEWARE! It is essential that any operation that fails sets either, x to NULL, err to nonzero, or why to anything but WHY_NOT, and that no operation that succeeds does this!

EKR: i.e., any one of the folowing denotes failure:
1. setting x to NULL,
2. setting err to nonzero,
3. setting why to anything but WHY_NOT.
@c
@language c

/* case STOP_CODE: this is an error! */

&lt;&lt; unary cases &gt;&gt;
&lt;&lt; binary cases &gt;&gt;
&lt;&lt; print cases &gt;&gt;
&lt;&lt; stack cases &gt;&gt;
&lt;&lt; slice cases &gt;&gt;
&lt;&lt; subscript cases &gt;&gt;

#ifdef CASE_TOO_BIG
default: switch (opcode) {
#endif

&lt;&lt; build cases &gt;&gt;
&lt;&lt; function call/make/return cases &gt;&gt;
&lt;&lt; COMPARE_OP &gt;&gt;
&lt;&lt; delete cases &gt;&gt;
&lt;&lt; EXTENDED_ARG &gt;&gt;
&lt;&lt; EXEC_STMT &gt;&gt;
&lt;&lt; flow-of-control cases &gt;&gt;
&lt;&lt; import cases &gt;&gt;
&lt;&lt; load cases &gt;&gt;
&lt;&lt; SET_LINENO &gt;&gt;
&lt;&lt; store cases &gt;&gt;
&lt;&lt; UNPACK_SEQUENCE &gt;&gt;
default:
	&lt;&lt; default case &gt;&gt;

#ifdef CASE_TOO_BIG
}
#endif</t>
<t tx="T506">&lt;&lt; BINARY_POWER &gt;&gt;
&lt;&lt; BINARY_MULTIPLY &gt;&gt;
&lt;&lt; BINARY_DIVIDE &gt;&gt;
&lt;&lt; BINARY_FLOOR_DIVIDE &gt;&gt;
&lt;&lt; BINARY_MODULO &gt;&gt;
&lt;&lt; BINARY_ADD &gt;&gt;
&lt;&lt; BINARY_SUBTRACT &gt;&gt;
&lt;&lt; BINARY_SUBSCR &gt;&gt;
&lt;&lt; BINARY_LSHIFT &gt;&gt;
&lt;&lt; BINARY_RSHIFT &gt;&gt;
&lt;&lt; BINARY_AND &gt;&gt;
&lt;&lt; BINARY_XOR &gt;&gt;
&lt;&lt; BINARY_OR &gt;&gt;
&lt;&lt; INPLACE_POWER &gt;&gt;
&lt;&lt; INPLACE_MULTIPLY &gt;&gt;
&lt;&lt; INPLACE_DIVIDE &gt;&gt;
&lt;&lt; INPLACE_FLOOR_DIVIDE &gt;&gt;
&lt;&lt; INPLACE_TRUE_DIVIDE &gt;&gt;
&lt;&lt; INPLACE_MODULO &gt;&gt;
&lt;&lt; INPLACE_ADD &gt;&gt;
&lt;&lt; INPLACE_SUBTRACT &gt;&gt;
&lt;&lt; INPLACE_LSHIFT &gt;&gt;
&lt;&lt; INPLACE_RSHIFT &gt;&gt;
&lt;&lt; INPLACE_AND &gt;&gt;
&lt;&lt; INPLACE_XOR &gt;&gt;
&lt;&lt; INPLACE_OR &gt;&gt;</t>
<t tx="T507"></t>
<t tx="T508">case BINARY_POWER:
	w = POP();
	v = POP();
	x = PyNumber_Power(v, w, Py_None);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T509">case BINARY_MULTIPLY:
	w = POP();
	v = POP();
	x = PyNumber_Multiply(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T510">case BINARY_DIVIDE:
	if (!_Py_QnewFlag) {
		w = POP();
		v = POP();
		x = PyNumber_Divide(v, w);
		Py_DECREF(v);
		Py_DECREF(w);
		PUSH(x);
		if (x != NULL) continue;
		break;
	}
	/* -Qnew is in effect:  fall through to
	   BINARY_TRUE_DIVIDE */
case BINARY_TRUE_DIVIDE:
	w = POP();
	v = POP();
	x = PyNumber_TrueDivide(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T511">case BINARY_FLOOR_DIVIDE:
	w = POP();
	v = POP();
	x = PyNumber_FloorDivide(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T512">case BINARY_MODULO:
	w = POP();
	v = POP();
	x = PyNumber_Remainder(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T513">case BINARY_ADD:
	w = POP();
	v = POP();
	if (PyInt_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) {
		/* INLINE: int + int */
		register long a, b, i;
		a = PyInt_AS_LONG(v);
		b = PyInt_AS_LONG(w);
		i = a + b;
		if ((i^a) &lt; 0 &amp;&amp; (i^b) &lt; 0)
			goto slow_add;
		x = PyInt_FromLong(i);
	}
	else {
	  slow_add:
		x = PyNumber_Add(v, w);
	}
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T514">case BINARY_SUBTRACT:
	w = POP();
	v = POP();
	if (PyInt_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) {
		/* INLINE: int - int */
		register long a, b, i;
		a = PyInt_AS_LONG(v);
		b = PyInt_AS_LONG(w);
		i = a - b;
		if ((i^a) &lt; 0 &amp;&amp; (i^~b) &lt; 0)
			goto slow_sub;
		x = PyInt_FromLong(i);
	}
	else {
	  slow_sub:
		x = PyNumber_Subtract(v, w);
	}
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T515">case BINARY_SUBSCR:
	w = POP();
	v = POP();
	if (PyList_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) {
		/* INLINE: list[int] */
		long i = PyInt_AsLong(w);
		if (i &lt; 0)
			i += PyList_GET_SIZE(v);
		if (i &lt; 0 ||
		    i &gt;= PyList_GET_SIZE(v)) {
			PyErr_SetString(PyExc_IndexError,
				"list index out of range");
			x = NULL;
		}
		else {
			x = PyList_GET_ITEM(v, i);
			Py_INCREF(x);
		}
	}
	else
		x = PyObject_GetItem(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T516">case BINARY_LSHIFT:
	w = POP();
	v = POP();
	x = PyNumber_Lshift(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T517">case BINARY_RSHIFT:
	w = POP();
	v = POP();
	x = PyNumber_Rshift(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T518">case BINARY_AND:
	w = POP();
	v = POP();
	x = PyNumber_And(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T519">case BINARY_XOR:
	w = POP();
	v = POP();
	x = PyNumber_Xor(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T520">case BINARY_OR:
	w = POP();
	v = POP();
	x = PyNumber_Or(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T521"></t>
<t tx="T522">case INPLACE_POWER:
	w = POP();
	v = POP();
	x = PyNumber_InPlacePower(v, w, Py_None);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T523">case INPLACE_MULTIPLY:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceMultiply(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T524">case INPLACE_DIVIDE:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceDivide(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T525">case INPLACE_FLOOR_DIVIDE:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceFloorDivide(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T526">case INPLACE_TRUE_DIVIDE:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceTrueDivide(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T527">case INPLACE_MODULO:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceRemainder(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T528">case INPLACE_ADD:
	w = POP();
	v = POP();
	if (PyInt_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) {
		/* INLINE: int + int */
		register long a, b, i;
		a = PyInt_AS_LONG(v);
		b = PyInt_AS_LONG(w);
		i = a + b;
		if ((i^a) &lt; 0 &amp;&amp; (i^b) &lt; 0)
			goto slow_iadd;
		x = PyInt_FromLong(i);
	}
	else {
	  slow_iadd:
		x = PyNumber_InPlaceAdd(v, w);
	}
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T529">case INPLACE_SUBTRACT:
	w = POP();
	v = POP();
	if (PyInt_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) {
		/* INLINE: int - int */
		register long a, b, i;
		a = PyInt_AS_LONG(v);
		b = PyInt_AS_LONG(w);
		i = a - b;
		if ((i^a) &lt; 0 &amp;&amp; (i^~b) &lt; 0)
			goto slow_isub;
		x = PyInt_FromLong(i);
	}
	else {
	  slow_isub:
		x = PyNumber_InPlaceSubtract(v, w);
	}
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T530">case INPLACE_LSHIFT:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceLshift(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T531">case INPLACE_RSHIFT:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceRshift(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T532">case INPLACE_AND:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceAnd(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T533">case INPLACE_XOR:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceXor(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T534">case INPLACE_OR:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceOr(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T535">&lt;&lt; BUILD_CLASS &gt;&gt;
&lt;&lt; BUILD_LIST &gt;&gt;
&lt;&lt; BUILD_MAP &gt;&gt;
&lt;&lt; BUILD_SLICE &gt;&gt;
&lt;&lt; BUILD_TUPLE &gt;&gt;
</t>
<t tx="T536">case BUILD_CLASS:
	u = POP();
	v = POP();
	w = POP();
	x = build_class(u, v, w);
	PUSH(x);
	Py_DECREF(u);
	Py_DECREF(v);
	Py_DECREF(w);
	break;</t>
<t tx="T537">case BUILD_LIST:
	x = PyList_New(oparg);
	if (x != NULL) {
		for (; --oparg &gt;= 0;) {
			w = POP();
			PyList_SET_ITEM(x, oparg, w);
		}
		PUSH(x);
		continue;
	}
	break;</t>
<t tx="T538">case BUILD_MAP:
	x = PyDict_New();
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T539">case BUILD_SLICE:
	if (oparg == 3)
		w = POP();
	else
		w = NULL;
	v = POP();
	u = POP();
	x = PySlice_New(u, v, w);
	Py_DECREF(u);
	Py_DECREF(v);
	Py_XDECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T540">case BUILD_TUPLE:
	x = PyTuple_New(oparg);
	if (x != NULL) {
		for (; --oparg &gt;= 0;) {
			w = POP();
			PyTuple_SET_ITEM(x, oparg, w);
		}
		PUSH(x);
		continue;
	}
	break;</t>
<t tx="T541">&lt;&lt; CALL_FUNCTION &gt;&gt;
&lt;&lt; CALL_FUNCTION_VAR/KW/VAR_KW &gt;&gt;
&lt;&lt; MAKE_FUNCTION &gt;&gt;
&lt;&lt; MAKE_CLOSURE &gt;&gt;
&lt;&lt; RETURN_VALUE &gt;&gt;
</t>
<t tx="T542">case CALL_FUNCTION:
{
    int na = oparg &amp; 0xff;
    int nk = (oparg&gt;&gt;8) &amp; 0xff;
    int n = na + 2 * nk;
    PyObject **pfunc = stack_pointer - n - 1;
    PyObject *func = *pfunc;
    f-&gt;f_lasti = INSTR_OFFSET() - 3; /* For tracing */

    /* Always dispatch PyCFunction first, because
       these are presumed to be the most frequent
       callable object.
    */
    if (PyCFunction_Check(func)) {
	    int flags = PyCFunction_GET_FLAGS(func);
	    if (nk != 0 || (flags &amp; METH_KEYWORDS))
		    x = do_call(func, &amp;stack_pointer,
				na, nk);
	    else if (flags == METH_VARARGS) {
		    PyObject *callargs;
		    callargs = load_args(&amp;stack_pointer, na);
		    x = PyCFunction_Call(func, callargs, NULL);
		    Py_XDECREF(callargs); 
	    } else
		    x = fast_cfunction(func,
				       &amp;stack_pointer, na);
    } else {
	    if (PyMethod_Check(func)
		&amp;&amp; PyMethod_GET_SELF(func) != NULL) {
		    /* optimize access to bound methods */
		    PyObject *self = PyMethod_GET_SELF(func);
		    Py_INCREF(self);
		    func = PyMethod_GET_FUNCTION(func);
		    Py_INCREF(func);
		    Py_DECREF(*pfunc);
		    *pfunc = self;
		    na++;
		    n++;
	    } else
		    Py_INCREF(func);
	    if (PyFunction_Check(func)) {
		    x = fast_function(func, &amp;stack_pointer,
				      n, na, nk);
	    } else {
		    x = do_call(func, &amp;stack_pointer,
				na, nk);
	    }
	    Py_DECREF(func);
    }

    while (stack_pointer &gt; pfunc) {
	    w = POP();
	    Py_DECREF(w);
    }
    PUSH(x);
    if (x != NULL)
	    continue;
    break;
}</t>
<t tx="T543">case CALL_FUNCTION_VAR:
case CALL_FUNCTION_KW:
case CALL_FUNCTION_VAR_KW:
{
    int na = oparg &amp; 0xff;
    int nk = (oparg&gt;&gt;8) &amp; 0xff;
    int flags = (opcode - CALL_FUNCTION) &amp; 3;
    int n = na + 2 * nk;
    PyObject **pfunc, *func;
    if (flags &amp; CALL_FLAG_VAR)
	    n++;
    if (flags &amp; CALL_FLAG_KW)
	    n++;
    pfunc = stack_pointer - n - 1;
    func = *pfunc;
    f-&gt;f_lasti = INSTR_OFFSET() - 3; /* For tracing */

    if (PyMethod_Check(func)
	&amp;&amp; PyMethod_GET_SELF(func) != NULL) {
	    PyObject *self = PyMethod_GET_SELF(func);
	    Py_INCREF(self);
	    func = PyMethod_GET_FUNCTION(func);
	    Py_INCREF(func);
	    Py_DECREF(*pfunc);
	    *pfunc = self;
	    na++;
	    n++;
    } else
	    Py_INCREF(func);
    x = ext_do_call(func, &amp;stack_pointer, flags, na, nk);
    Py_DECREF(func);

    while (stack_pointer &gt; pfunc) {
	    w = POP();
	    Py_DECREF(w);
    }
    PUSH(x);
    if (x != NULL)
	    continue;
    break;
}</t>
<t tx="T544">case MAKE_FUNCTION:
	v = POP(); /* code object */
	x = PyFunction_New(v, f-&gt;f_globals);
	Py_DECREF(v);
	/* XXX Maybe this should be a separate opcode? */
	if (x != NULL &amp;&amp; oparg &gt; 0) {
		v = PyTuple_New(oparg);
		if (v == NULL) {
			Py_DECREF(x);
			x = NULL;
			break;
		}
		while (--oparg &gt;= 0) {
			w = POP();
			PyTuple_SET_ITEM(v, oparg, w);
		}
		err = PyFunction_SetDefaults(x, v);
		Py_DECREF(v);
	}
	PUSH(x);
	break;</t>
<t tx="T545">case MAKE_CLOSURE:
{
	int nfree;
	v = POP(); /* code object */
	x = PyFunction_New(v, f-&gt;f_globals);
	nfree = PyCode_GetNumFree((PyCodeObject *)v);
	Py_DECREF(v);
	/* XXX Maybe this should be a separate opcode? */
	if (x != NULL &amp;&amp; nfree &gt; 0) {
		v = PyTuple_New(nfree);
		if (v == NULL) {
			Py_DECREF(x);
			x = NULL;
			break;
		}
		while (--nfree &gt;= 0) {
			w = POP();
			PyTuple_SET_ITEM(v, nfree, w);
		}
		err = PyFunction_SetClosure(x, v);
		Py_DECREF(v);
	}
	if (x != NULL &amp;&amp; oparg &gt; 0) {
		v = PyTuple_New(oparg);
		if (v == NULL) {
			Py_DECREF(x);
			x = NULL;
			break;
		}
		while (--oparg &gt;= 0) {
			w = POP();
			PyTuple_SET_ITEM(v, oparg, w);
		}
		err = PyFunction_SetDefaults(x, v);
		Py_DECREF(v);
	}
	PUSH(x);
	break;
}</t>
<t tx="T546">case RETURN_VALUE:
	retval = POP();
	why = WHY_RETURN;
	break;</t>
<t tx="T547">case COMPARE_OP:
	w = POP();
	v = POP();
	if (PyInt_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) {
		/* INLINE: cmp(int, int) */
		register long a, b;
		register int res;
		a = PyInt_AS_LONG(v);
		b = PyInt_AS_LONG(w);
		switch (oparg) {
		case LT: res = a &lt;  b; break;
		case LE: res = a &lt;= b; break;
		case EQ: res = a == b; break;
		case NE: res = a != b; break;
		case GT: res = a &gt;  b; break;
		case GE: res = a &gt;= b; break;
		case IS: res = v == w; break;
		case IS_NOT: res = v != w; break;
		default: goto slow_compare;
		}
		x = res ? Py_True : Py_False;
		Py_INCREF(x);
	}
	else {
	  slow_compare:
		x = cmp_outcome(oparg, v, w);
	}
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T548">fprintf(stderr,
	"XXX lineno: %d, opcode: %d\n",
	f-&gt;f_lineno, opcode);

PyErr_SetString(PyExc_SystemError, "unknown opcode");
why = WHY_EXCEPTION;
break;</t>
<t tx="T549">&lt;&lt; DELETE_ATTR &gt;&gt;
&lt;&lt; DELETE_FAST &gt;&gt;
&lt;&lt; DELETE_GLOBAL &gt;&gt;
&lt;&lt; DELETE_NAME &gt;&gt;</t>
<t tx="T550">case DELETE_ATTR:
	w = GETNAMEV(oparg);
	v = POP();
	err = PyObject_SetAttr(v, w, (PyObject *)NULL);
					/* del v.w */
	Py_DECREF(v);
	break;</t>
<t tx="T551">case DELETE_FAST:
	x = GETLOCAL(oparg);
	if (x == NULL) {
		format_exc_check_arg(
			PyExc_UnboundLocalError,
			UNBOUNDLOCAL_ERROR_MSG,
			PyTuple_GetItem(co-&gt;co_varnames, oparg)
			);
		break;
	}
	SETLOCAL(oparg, NULL);
	continue;</t>
<t tx="T552">case DELETE_GLOBAL:
	w = GETNAMEV(oparg);
	if ((err = PyDict_DelItem(f-&gt;f_globals, w)) != 0)
		format_exc_check_arg(
		    PyExc_NameError, GLOBAL_NAME_ERROR_MSG, w);
	break;</t>
<t tx="T553">case DELETE_NAME:
	w = GETNAMEV(oparg);
	if ((x = f-&gt;f_locals) == NULL) {
		PyErr_Format(PyExc_SystemError,
			     "no locals when deleting %s",
			     PyObject_REPR(w));
		break;
	}
	if ((err = PyDict_DelItem(x, w)) != 0)
		format_exc_check_arg(PyExc_NameError,
					NAME_ERROR_MSG ,w);
	break;</t>
<t tx="T554">case EXTENDED_ARG:
	opcode = NEXTOP();
	oparg = oparg&lt;&lt;16 | NEXTARG();
	goto dispatch_opcode;</t>
<t tx="T555">case EXEC_STMT:
	w = POP();
	v = POP();
	u = POP();
	err = exec_statement(f, u, v, w);
	Py_DECREF(u);
	Py_DECREF(v);
	Py_DECREF(w);
	break;</t>
<t tx="T556">&lt;&lt; BREAK_LOOP &gt;&gt;
&lt;&lt; CONTINUE_LOOP &gt;&gt;
&lt;&lt; FOR_LOOP &gt;&gt;
&lt;&lt; iter cases &gt;&gt;
&lt;&lt; jump cases &gt;&gt;
&lt;&lt; RAISE_VARARGS &gt;&gt;
&lt;&lt; SETUP_LOOP/EXCEPT/FINALLY &gt;&gt;
&lt;&lt; POP_BLOCK &gt;&gt;
&lt;&lt; END_FINALLY &gt;&gt;</t>
<t tx="T557">case BREAK_LOOP:
	why = WHY_BREAK;
	break;</t>
<t tx="T558">case CONTINUE_LOOP:
	retval = PyInt_FromLong(oparg);
	why = WHY_CONTINUE;
	break;</t>
<t tx="T559">case END_FINALLY:
	v = POP();
	if (PyInt_Check(v)) {
		why = (enum why_code) PyInt_AsLong(v);
		if (why == WHY_RETURN ||
		    why == WHY_YIELD ||
		    why == CONTINUE_LOOP)
			retval = POP();
	}
	else if (PyString_Check(v) || PyClass_Check(v)) {
		w = POP();
		u = POP();
		PyErr_Restore(v, w, u);
		why = WHY_RERAISE;
		break;
	}
	else if (v != Py_None) {
		PyErr_SetString(PyExc_SystemError,
			"'finally' pops bad exception");
		why = WHY_EXCEPTION;
	}
	Py_DECREF(v);
	break;</t>
<t tx="T560"></t>
<t tx="T561">case FOR_ITER:
	/* before: [iter]; after: [iter, iter()] *or* [] */
	v = TOP();
	x = PyIter_Next(v);
	if (x != NULL) {
		PUSH(x);
		continue;
	}
	if (!PyErr_Occurred()) {
		/* iterator ended normally */
		x = v = POP();
		Py_DECREF(v);
		JUMPBY(oparg);
		continue;
	}
	break;</t>
<t tx="T562">case GET_ITER:
	/* before: [obj]; after [getiter(obj)] */
	v = POP();
	x = PyObject_GetIter(v);
	Py_DECREF(v);
	if (x != NULL) {
		PUSH(x);
		continue;
	}
	break;</t>
<t tx="T563">case YIELD_VALUE:
	retval = POP();
	f-&gt;f_stacktop = stack_pointer;
	f-&gt;f_lasti = INSTR_OFFSET();
	why = WHY_YIELD;
	break;</t>
<t tx="T564">&lt;&lt; JUMP_FORWARD &gt;&gt;
&lt;&lt; JUMP_IF_FALSE &gt;&gt;
&lt;&lt; JUMP_IF_TRUE &gt;&gt;
&lt;&lt; JUMP_ABSOLUTE &gt;&gt;</t>
<t tx="T565">case JUMP_FORWARD:
	JUMPBY(oparg);
	continue;</t>
<t tx="T566">case JUMP_IF_FALSE:
	err = PyObject_IsTrue(TOP());
	if (err &gt; 0)
		err = 0;
	else if (err == 0)
		JUMPBY(oparg);
	else
		break;
	continue;</t>
<t tx="T567">case JUMP_IF_TRUE:
	err = PyObject_IsTrue(TOP());
	if (err &gt; 0) {
		err = 0;
		JUMPBY(oparg);
	}
	else if (err == 0)
		;
	else
		break;
	continue;</t>
<t tx="T568">case JUMP_ABSOLUTE:
	JUMPTO(oparg);
	continue;</t>
<t tx="T569">case FOR_LOOP:
	/* for v in s: ...
	   On entry: stack contains s, i.
	   On exit: stack contains s, i+1, s[i];
	   but if loop exhausted:
	   	s, i are popped, and we jump */
	w = POP(); /* Loop index */
	v = POP(); /* Sequence object */
	u = loop_subscript(v, w);
	if (u != NULL) {
		PUSH(v);
		x = PyInt_FromLong(PyInt_AsLong(w)+1);
		PUSH(x);
		Py_DECREF(w);
		PUSH(u);
		if (x != NULL) continue;
	}
	else {
		Py_DECREF(v);
		Py_DECREF(w);
		/* A NULL can mean "s exhausted"
		   but also an error: */
		if (PyErr_Occurred())
			why = WHY_EXCEPTION;
		else {
			JUMPBY(oparg);
			continue;
		}
	}
	break;</t>
<t tx="T570">case POP_BLOCK:
	{
		PyTryBlock *b = PyFrame_BlockPop(f);
		while (STACK_LEVEL() &gt; b-&gt;b_level) {
			v = POP();
			Py_DECREF(v);
		}
	}
	break;</t>
<t tx="T571">case RAISE_VARARGS:
	u = v = w = NULL;
	switch (oparg) {
	case 3:
		u = POP(); /* traceback */
		/* Fallthrough */
	case 2:
		v = POP(); /* value */
		/* Fallthrough */
	case 1:
		w = POP(); /* exc */
	case 0: /* Fallthrough */
		why = do_raise(w, v, u);
		break;
	default:
		PyErr_SetString(PyExc_SystemError,
			   "bad RAISE_VARARGS oparg");
		why = WHY_EXCEPTION;
		break;
	}
	break;</t>
<t tx="T572">case SETUP_LOOP:
case SETUP_EXCEPT:
case SETUP_FINALLY:
	PyFrame_BlockSetup(f, opcode, INSTR_OFFSET() + oparg,
			   STACK_LEVEL());
	continue;</t>
<t tx="T573">&lt;&lt; IMPORT_NAME &gt;&gt;
&lt;&lt; IMPORT_STAR &gt;&gt;
&lt;&lt; IMPORT_FROM &gt;&gt;</t>
<t tx="T574">case IMPORT_NAME:
	w = GETNAMEV(oparg);
	x = PyDict_GetItemString(f-&gt;f_builtins, "__import__");
	if (x == NULL) {
		PyErr_SetString(PyExc_ImportError,
				"__import__ not found");
		break;
	}
	u = POP();
	w = Py_BuildValue("(OOOO)",
		    w,
		    f-&gt;f_globals,
		    f-&gt;f_locals == NULL ?
			  Py_None : f-&gt;f_locals,
		    u);
	Py_DECREF(u);
	if (w == NULL) {
		x = NULL;
		break;
	}
	x = PyEval_CallObject(x, w);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T575">case IMPORT_STAR:
	v = POP();
	PyFrame_FastToLocals(f);
	if ((x = f-&gt;f_locals) == NULL) {
		PyErr_SetString(PyExc_SystemError,
			"no locals found during 'import *'");
		break;
	}
	err = import_all_from(x, v);
	PyFrame_LocalsToFast(f, 0);
	Py_DECREF(v);
	if (err == 0) continue;
	break;</t>
<t tx="T576">case IMPORT_FROM:
	w = GETNAMEV(oparg);
	v = TOP();
	x = import_from(v, w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T577">&lt;&lt; LOAD_ATTR &gt;&gt;
&lt;&lt; LOAD_CLOSURE &gt;&gt;
&lt;&lt; LOAD_CONST &gt;&gt;
&lt;&lt; LOAD_DEREF &gt;&gt;
&lt;&lt; LOAD_LOCALS &gt;&gt;
&lt;&lt; LOAD_FAST &gt;&gt;
&lt;&lt; LOAD_GLOBAL &gt;&gt;
&lt;&lt; LOAD_NAME &gt;&gt;
</t>
<t tx="T578">case LOAD_ATTR:
	w = GETNAMEV(oparg);
	v = POP();  
	x = PyObject_GetAttr(v, w);  // Expensive?
	Py_DECREF(v);  // if (--op-&gt;ob_refcnt == 0) _Py_Dealloc(op)
	PUSH(x);  // *stack_pointer++ = x
	if (x != NULL) continue;
	break;</t>
<t tx="T579">case LOAD_CLOSURE:
	x = freevars[oparg];
	Py_INCREF(x);  // x-&gt;ob_refcnt++
	PUSH(x); // *stack_pointer++ = x
	break;</t>
<t tx="T580">case LOAD_CONST:
	x = GETCONST(oparg);
	Py_INCREF(x);
	PUSH(x);
	break;</t>
<t tx="T581">case LOAD_DEREF:
	x = freevars[oparg];
	w = PyCell_Get(x);
	if (w == NULL) {
		if (oparg &lt; f-&gt;f_ncells) {
			v = PyTuple_GetItem(co-&gt;co_cellvars,
					       oparg);
		       format_exc_check_arg(
			       PyExc_UnboundLocalError,
			       UNBOUNDLOCAL_ERROR_MSG,
			       v);
		} else {
		       v = PyTuple_GetItem(
				      co-&gt;co_freevars,
				      oparg - f-&gt;f_ncells);
		       format_exc_check_arg(
			       PyExc_NameError,
			       UNBOUNDFREE_ERROR_MSG,
			       v);
		}
		err = -1;
		break;
	}
	PUSH(w);
	break;</t>
<t tx="T582">case LOAD_LOCALS:
	if ((x = f-&gt;f_locals) == NULL) {
		PyErr_SetString(PyExc_SystemError,
				"no locals");
		break;
	}
	Py_INCREF(x);
	PUSH(x);
	break;</t>
<t tx="T583">case LOAD_FAST:
	x = GETLOCAL(oparg);
	if (x == NULL) {
		format_exc_check_arg(
			PyExc_UnboundLocalError,
			UNBOUNDLOCAL_ERROR_MSG,
			PyTuple_GetItem(co-&gt;co_varnames, oparg)
			);
		break;
	}
	Py_INCREF(x);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T584">case LOAD_GLOBAL:
	w = GETNAMEV(oparg);
	x = PyDict_GetItem(f-&gt;f_globals, w);
	if (x == NULL) {
		x = PyDict_GetItem(f-&gt;f_builtins, w);
		if (x == NULL) {
			format_exc_check_arg(
				    PyExc_NameError,
				    GLOBAL_NAME_ERROR_MSG ,w);
			break;
		}
	}
	Py_INCREF(x);
	PUSH(x);
	break;</t>
<t tx="T585">case LOAD_NAME:
	w = GETNAMEV(oparg);
	if ((x = f-&gt;f_locals) == NULL) {
		PyErr_Format(PyExc_SystemError,
			     "no locals when loading %s",
			     PyObject_REPR(w));
		break;
	}
	x = PyDict_GetItem(x, w);
	if (x == NULL) {
		x = PyDict_GetItem(f-&gt;f_globals, w);
		if (x == NULL) {
			x = PyDict_GetItem(f-&gt;f_builtins, w);
			if (x == NULL) {
				format_exc_check_arg(
					    PyExc_NameError,
					    NAME_ERROR_MSG ,w);
				break;
			}
		}
	}
	Py_INCREF(x);
	PUSH(x);
	break;</t>
<t tx="T586">&lt;&lt; PRINT_EXPR &gt;&gt;
&lt;&lt; PRINT_ITEM_TO/PRINT_ITEM &gt;&gt;
&lt;&lt; PRINT_NEWLINE_TO/PRINT_NEWLINE &gt;&gt;</t>
<t tx="T587">case PRINT_EXPR:
	v = POP();
	w = PySys_GetObject("displayhook");
	if (w == NULL) {
		PyErr_SetString(PyExc_RuntimeError,
				"lost sys.displayhook");
		err = -1;
		x = NULL;
	}
	if (err == 0) {
		x = Py_BuildValue("(O)", v);
		if (x == NULL)
			err = -1;
	}
	if (err == 0) {
		w = PyEval_CallObject(w, x);
		Py_XDECREF(w);
		if (w == NULL)
			err = -1;
	}
	Py_DECREF(v);
	Py_XDECREF(x);
	break;</t>
<t tx="T588">case PRINT_ITEM_TO:
	w = stream = POP();
	/* fall through to PRINT_ITEM */

case PRINT_ITEM:
	v = POP();
	if (stream == NULL || stream == Py_None) {
		w = PySys_GetObject("stdout");
		if (w == NULL) {
			PyErr_SetString(PyExc_RuntimeError,
					"lost sys.stdout");
			err = -1;
		}
	}
	if (w != NULL &amp;&amp; PyFile_SoftSpace(w, 1))
		err = PyFile_WriteString(" ", w);
	if (err == 0)
		err = PyFile_WriteObject(v, w, Py_PRINT_RAW);
	if (err == 0) {
		/* XXX move into writeobject() ? */
	    if (PyString_Check(v)) {
		char *s = PyString_AS_STRING(v);
		int len = PyString_GET_SIZE(v);
		if (len &gt; 0 &amp;&amp;
		    isspace(Py_CHARMASK(s[len-1])) &amp;&amp;
		    s[len-1] != ' ')
			PyFile_SoftSpace(w, 0);
	    } 
#ifdef Py_USING_UNICODE
	    else if (PyUnicode_Check(v)) {
		Py_UNICODE *s = PyUnicode_AS_UNICODE(v);
		int len = PyUnicode_GET_SIZE(v);
		if (len &gt; 0 &amp;&amp;
		    Py_UNICODE_ISSPACE(s[len-1]) &amp;&amp;
		    s[len-1] != ' ')
		    PyFile_SoftSpace(w, 0);
	    }
#endif
	}
	Py_DECREF(v);
	Py_XDECREF(stream);
	stream = NULL;
	if (err == 0)
		continue;
	break;</t>
<t tx="T589">case PRINT_NEWLINE_TO:
	w = stream = POP();
	/* fall through to PRINT_NEWLINE */

case PRINT_NEWLINE:
	if (stream == NULL || stream == Py_None) {
		w = PySys_GetObject("stdout");
		if (w == NULL)
			PyErr_SetString(PyExc_RuntimeError,
					"lost sys.stdout");
	}
	if (w != NULL) {
		err = PyFile_WriteString("\n", w);
		if (err == 0)
			PyFile_SoftSpace(w, 0);
	}
	Py_XDECREF(stream);
	stream = NULL;
	break;</t>
<t tx="T590">case SET_LINENO:
#ifdef LLTRACE
	if (lltrace)
		printf("--- %s:%d \n", filename, oparg);
#endif
	f-&gt;f_lineno = oparg;
	if (tstate-&gt;c_tracefunc == NULL || tstate-&gt;tracing)
		continue;
	/* Trace each line of code reached */
	f-&gt;f_lasti = INSTR_OFFSET();
	/* Inline call_trace() for performance: */
	tstate-&gt;tracing++;
	tstate-&gt;use_tracing = 0;
	err = (tstate-&gt;c_tracefunc)(tstate-&gt;c_traceobj, f,
				    PyTrace_LINE, Py_None);
	tstate-&gt;use_tracing = (tstate-&gt;c_tracefunc
			       || tstate-&gt;c_profilefunc);
	tstate-&gt;tracing--;
	break;</t>
<t tx="T591">&lt;&lt; SLICE cases &gt;&gt;
&lt;&lt; STORE_SLICE cases &gt;&gt;
&lt;&lt; DELETE_SLICE cases &gt;&gt;</t>
<t tx="T592">case SLICE+0:
case SLICE+1:
case SLICE+2:
case SLICE+3:
	if ((opcode-SLICE) &amp; 2)
		w = POP();
	else
		w = NULL;
	if ((opcode-SLICE) &amp; 1)
		v = POP();
	else
		v = NULL;
	u = POP();
	x = apply_slice(u, v, w);
	Py_DECREF(u);
	Py_XDECREF(v);
	Py_XDECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T593">case STORE_SLICE+0:
case STORE_SLICE+1:
case STORE_SLICE+2:
case STORE_SLICE+3:
	if ((opcode-STORE_SLICE) &amp; 2)
		w = POP();
	else
		w = NULL;
	if ((opcode-STORE_SLICE) &amp; 1)
		v = POP();
	else
		v = NULL;
	u = POP();
	t = POP();
	err = assign_slice(u, v, w, t); /* u[v:w] = t */
	Py_DECREF(t);
	Py_DECREF(u);
	Py_XDECREF(v);
	Py_XDECREF(w);
	if (err == 0) continue;
	break;</t>
<t tx="T594">case DELETE_SLICE+0:
case DELETE_SLICE+1:
case DELETE_SLICE+2:
case DELETE_SLICE+3:
	if ((opcode-DELETE_SLICE) &amp; 2)
		w = POP();
	else
		w = NULL;
	if ((opcode-DELETE_SLICE) &amp; 1)
		v = POP();
	else
		v = NULL;
	u = POP();
	err = assign_slice(u, v, w, (PyObject *)NULL);
					/* del u[v:w] */
	Py_DECREF(u);
	Py_XDECREF(v);
	Py_XDECREF(w);
	if (err == 0) continue;
	break;</t>
<t tx="T595">&lt;&lt; POP_TOP &gt;&gt;
&lt;&lt; ROT_TWO &gt;&gt;
&lt;&lt; ROT_THREE &gt;&gt;
&lt;&lt; ROT_FOUR &gt;&gt;
&lt;&lt; DUP_TOP &gt;&gt;
&lt;&lt; DUP_TOPX &gt;&gt;</t>
<t tx="T596">case DUP_TOP:
	v = TOP();
	Py_INCREF(v);
	PUSH(v);
	continue;</t>
<t tx="T597">case DUP_TOPX:
	switch (oparg) {
	case 1:
		x = TOP();
		Py_INCREF(x);
		PUSH(x);
		continue;
	case 2:
		x = POP();
		Py_INCREF(x);
		w = TOP();
		Py_INCREF(w);
		PUSH(x);
		PUSH(w);
		PUSH(x);
		continue;
	case 3:
		x = POP();
		Py_INCREF(x);
		w = POP();
		Py_INCREF(w);
		v = TOP();
		Py_INCREF(v);
		PUSH(w);
		PUSH(x);
		PUSH(v);
		PUSH(w);
		PUSH(x);
		continue;
	case 4:
		x = POP();
		Py_INCREF(x);
		w = POP();
		Py_INCREF(w);
		v = POP();
		Py_INCREF(v);
		u = TOP();
		Py_INCREF(u);
		PUSH(v);
		PUSH(w);
		PUSH(x);
		PUSH(u);
		PUSH(v);
		PUSH(w);
		PUSH(x);
		continue;
	case 5:
		x = POP();
		Py_INCREF(x);
		w = POP();
		Py_INCREF(w);
		v = POP();
		Py_INCREF(v);
		u = POP();
		Py_INCREF(u);
		t = TOP();
		Py_INCREF(t);
		PUSH(u);
		PUSH(v);
		PUSH(w);
		PUSH(x);
		PUSH(t);
		PUSH(u);
		PUSH(v);
		PUSH(w);
		PUSH(x);
		continue;
	default:
		Py_FatalError("invalid argument to DUP_TOPX"
			      " (bytecode corruption?)");
	}
	break;</t>
<t tx="T598">case POP_TOP:
	v = POP();
	Py_DECREF(v);
	continue;</t>
<t tx="T599">case ROT_TWO:
	v = POP();
	w = POP();
	PUSH(v);
	PUSH(w);
	continue;</t>
<t tx="T600">case ROT_THREE:
	v = POP();
	w = POP();
	x = POP();
	PUSH(v);
	PUSH(x);
	PUSH(w);
	continue;</t>
<t tx="T601">case ROT_FOUR:
	u = POP();
	v = POP();
	w = POP();
	x = POP();
	PUSH(u);
	PUSH(x);
	PUSH(w);
	PUSH(v);
	continue;</t>
<t tx="T602">&lt;&lt; STORE_DEREF &gt;&gt;
&lt;&lt; STORE_FAST &gt;&gt;
&lt;&lt; STORE_GLOBAL &gt;&gt;
&lt;&lt; STORE_NAME &gt;&gt;</t>
<t tx="T603">case STORE_DEREF:
	w = POP();
	x = freevars[oparg];
	PyCell_Set(x, w);
	Py_DECREF(w);
	continue;</t>
<t tx="T604">case STORE_FAST:
	v = POP();
	SETLOCAL(oparg, v);
	continue;</t>
<t tx="T605">case STORE_GLOBAL:
	w = GETNAMEV(oparg);
	v = POP();
	err = PyDict_SetItem(f-&gt;f_globals, w, v);
	Py_DECREF(v);
	break;</t>
<t tx="T606">case STORE_NAME:
	w = GETNAMEV(oparg);
	v = POP();
	if ((x = f-&gt;f_locals) == NULL) {
		PyErr_Format(PyExc_SystemError,
			     "no locals found when storing %s",
			     PyObject_REPR(w));
		break;
	}
	err = PyDict_SetItem(x, w, v);
	Py_DECREF(v);
	break;</t>
<t tx="T607">&lt;&lt; STORE_SUBSCR &gt;&gt;
&lt;&lt; DELETE_SUBSCR &gt;&gt;</t>
<t tx="T608">case STORE_SUBSCR:
	w = POP();
	v = POP();
	u = POP();
	/* v[w] = u */
	err = PyObject_SetItem(v, w, u);
	Py_DECREF(u);
	Py_DECREF(v);
	Py_DECREF(w);
	if (err == 0) continue;
	break;</t>
<t tx="T609">case DELETE_SUBSCR:
	w = POP();
	v = POP();
	/* del v[w] */
	err = PyObject_DelItem(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	if (err == 0) continue;
	break;</t>
<t tx="T610">&lt;&lt; UNARY_POSITIVE &gt;&gt;
&lt;&lt; UNARY_NEGATIVE &gt;&gt;
&lt;&lt; UNARY_NOT &gt;&gt;
&lt;&lt; UNARY_CONVERT &gt;&gt;
&lt;&lt; UNARY_INVERT &gt;&gt;</t>
<t tx="T611">case UNARY_POSITIVE:
	v = POP();
	x = PyNumber_Positive(v);
	Py_DECREF(v);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T612">case UNARY_NEGATIVE:
	v = POP();
	x = PyNumber_Negative(v);
	Py_DECREF(v);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T613">case UNARY_NOT:
	v = POP();
	err = PyObject_IsTrue(v);
	Py_DECREF(v);
	if (err == 0) {
		Py_INCREF(Py_True);
		PUSH(Py_True);
		continue;
	}
	else if (err &gt; 0) {
		Py_INCREF(Py_False);
		PUSH(Py_False);
		err = 0;
		continue;
	}
	break;</t>
<t tx="T614">case UNARY_CONVERT:
	v = POP();
	x = PyObject_Repr(v);
	Py_DECREF(v);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T615">case UNARY_INVERT:
	v = POP();
	x = PyNumber_Invert(v);
	Py_DECREF(v);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T616">case UNPACK_SEQUENCE:
	v = POP();
	if (PyTuple_Check(v)) {
		if (PyTuple_Size(v) != oparg) {
			PyErr_SetString(PyExc_ValueError,
				 "unpack tuple of wrong size");
			why = WHY_EXCEPTION;
		}
		else {
			for (; --oparg &gt;= 0; ) {
				w = PyTuple_GET_ITEM(v, oparg);
				Py_INCREF(w);
				PUSH(w);
			}
		}
	}
	else if (PyList_Check(v)) {
		if (PyList_Size(v) != oparg) {
			PyErr_SetString(PyExc_ValueError,
				  "unpack list of wrong size");
			why = WHY_EXCEPTION;
		}
		else {
			for (; --oparg &gt;= 0; ) {
				w = PyList_GET_ITEM(v, oparg);
				Py_INCREF(w);
				PUSH(w);
			}
		}
	}
	else if (unpack_iterable(v, oparg,
				 stack_pointer + oparg))
		stack_pointer += oparg;
	else {
		if (PyErr_ExceptionMatches(PyExc_TypeError))
			PyErr_SetString(PyExc_TypeError,
				"unpack non-sequence");
		why = WHY_EXCEPTION;
	}
	Py_DECREF(v);
	break;</t>
<t tx="T617">on_error:

/* Quickly continue if no error occurred */

if (why == WHY_NOT) {
	if (err == 0 &amp;&amp; x != NULL) {
#ifdef CHECKEXC
		/* This check is expensive! */
		if (PyErr_Occurred())
			fprintf(stderr,
				"XXX undetected error\n");
		else
#endif
			continue; /* Normal, fast path */
	}
	why = WHY_EXCEPTION;
	x = Py_None;
	err = 0;
}

/* Double-check exception status */

if (why == WHY_EXCEPTION || why == WHY_RERAISE) {
	if (!PyErr_Occurred()) {
		PyErr_SetString(PyExc_SystemError,
			"error return without exception set");
		why = WHY_EXCEPTION;
	}
}
#ifdef CHECKEXC
else {
	/* This check is expensive! */
	if (PyErr_Occurred()) {
		fprintf(stderr,
			"XXX undetected error (why=%d)\n",
			why);
		why = WHY_EXCEPTION;
	}
}
#endif

/* Log traceback info if this is a real exception */

if (why == WHY_EXCEPTION) {
	f-&gt;f_lasti = INSTR_OFFSET() - 1;
	if (HAS_ARG(opcode))
		f-&gt;f_lasti -= 2;
	PyTraceBack_Here(f);

	if (tstate-&gt;c_tracefunc != NULL)
		call_exc_trace(tstate-&gt;c_tracefunc,
			       tstate-&gt;c_traceobj, f);
}

/* For the rest, treat WHY_RERAISE as WHY_EXCEPTION */

if (why == WHY_RERAISE)
	why = WHY_EXCEPTION;

/* Unwind stacks if a (pseudo) exception occurred */

while (why != WHY_NOT &amp;&amp; why != WHY_YIELD &amp;&amp; f-&gt;f_iblock &gt; 0) {
	PyTryBlock *b = PyFrame_BlockPop(f);

	if (b-&gt;b_type == SETUP_LOOP &amp;&amp; why == WHY_CONTINUE) {
		/* For a continue inside a try block,
		   don't pop the block for the loop. */
		PyFrame_BlockSetup(f, b-&gt;b_type, b-&gt;b_handler,
				   b-&gt;b_level);
		why = WHY_NOT;
		JUMPTO(PyInt_AS_LONG(retval));
		Py_DECREF(retval);
		break;
	}

	while (STACK_LEVEL() &gt; b-&gt;b_level) {
		v = POP();
		Py_XDECREF(v);
	}
	if (b-&gt;b_type == SETUP_LOOP &amp;&amp; why == WHY_BREAK) {
		why = WHY_NOT;
		JUMPTO(b-&gt;b_handler);
		break;
	}
	if (b-&gt;b_type == SETUP_FINALLY ||
	    (b-&gt;b_type == SETUP_EXCEPT &amp;&amp;
	     why == WHY_EXCEPTION)) {
		if (why == WHY_EXCEPTION) {
			PyObject *exc, *val, *tb;
			PyErr_Fetch(&amp;exc, &amp;val, &amp;tb);
			if (val == NULL) {
				val = Py_None;
				Py_INCREF(val);
			}
			/* Make the raw exception data
			   available to the handler,
			   so a program can emulate the
			   Python main loop.  Don't do
			   this for 'finally'. */
			if (b-&gt;b_type == SETUP_EXCEPT) {
				PyErr_NormalizeException(
					&amp;exc, &amp;val, &amp;tb);
				set_exc_info(tstate,
					     exc, val, tb);
			}
			if (tb == NULL) {
				Py_INCREF(Py_None);
				PUSH(Py_None);
			} else
				PUSH(tb);
			PUSH(val);
			PUSH(exc);
		}
		else {
			if (why == WHY_RETURN ||
			    why == CONTINUE_LOOP)
				PUSH(retval);
			v = PyInt_FromLong((long)why);
			PUSH(v);
		}
		why = WHY_NOT;
		JUMPTO(b-&gt;b_handler);
		break;
	}
} /* unwind stack */

/* End the loop if we still have an error (or return) */

if (why != WHY_NOT)
	break;</t>
<t tx="T618">if (why != WHY_YIELD) {
	/* Pop remaining stack entries -- but when yielding */
	while (!EMPTY()) {
		v = POP();
		Py_XDECREF(v);
	}
}

if (why != WHY_RETURN &amp;&amp; why != WHY_YIELD)
	retval = NULL;

if (tstate-&gt;use_tracing) {
	if (tstate-&gt;c_tracefunc
	    &amp;&amp; (why == WHY_RETURN || why == WHY_YIELD)) {
		if (call_trace(tstate-&gt;c_tracefunc,
			       tstate-&gt;c_traceobj, f,
			       PyTrace_RETURN, retval)) {
			Py_XDECREF(retval);
			retval = NULL;
			why = WHY_EXCEPTION;
		}
	}
	if (tstate-&gt;c_profilefunc) {
		if (why == WHY_EXCEPTION)
			call_trace_protected(tstate-&gt;c_profilefunc,
					     tstate-&gt;c_profileobj, f,
					     PyTrace_RETURN);
		else if (call_trace(tstate-&gt;c_profilefunc,
				    tstate-&gt;c_profileobj, f,
				    PyTrace_RETURN, retval)) {
			Py_XDECREF(retval);
			retval = NULL;
			why = WHY_EXCEPTION;
		}
	}
}

reset_exc_info(tstate);

/* pop frame */
--tstate-&gt;recursion_depth;
tstate-&gt;frame = f-&gt;f_back;</t>
<t tx="T619">@language c
@ This section compares the Psyco "compiler" code to the C interpreter code opcode by opcode.

</t>
</tnodes>
</leo_file>
