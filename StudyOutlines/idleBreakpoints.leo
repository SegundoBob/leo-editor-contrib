<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="158" clone_windows="0"/>
<globals body_outline_ratio="0.499">
	<global_window_position top="31" left="115" height="725" width="923"/>
	<global_log_window_position top="0" left="0" height="96" width="112"/>
</globals>
<preferences allow_rich_text="0" tab_width="4" page_width="132" tangle_bat="0" untangle_bat="0" output_doc_chunks="1" defaultTargetLanguage="C" use_header_flag="1">
	
<TSyntaxMemo_options>DBSoft6:OPT#8#67100656GWD#1#0GCL#11#-2147483633WRC#1#0IDS#1#4WRO#3#&gt;|:FON#11#Courier NewFOS#1#9STC#8#16777215STB#7#8388608TBC#0#TBD#1#4EFF#297#17,0,0,16777215,;3,0,16777215,;4,8421504,16777215,;5,0,16777215,;6,255,16777215,;10,16711680,16777215,;11,0,16777215,;12,16711680,16777215,;20,16711680,16777215,;21,255,16777215,;22,255,16777215,;23,16711680,16777215,;40,255,16777215,;42,0,16777215,;43,255,16777215,;45,0,16777215,;46,0,16777215,;GDF#1#0MDF#1#0SDF#1#0BDF#1#0FOC#1#0RMG#1#0LNN#13#MS Sans SerifLNS#1#8LNC#11#-2147483640LNT#1#1LNE#0##END#</TSyntaxMemo_options>
</preferences>
<find_panel_settings whole_word="1" search_body="1">
	<find_string>set_break</find_string>
	<change_string>    </change_string>
</find_panel_settings>
<vnodes>
<v t="T1" a="ET"><vh>IDLE breakpoints</vh>
<v t="T2"><vh>email</vh></v>
<v t="T3"><vh>Notes</vh></v>
<v a="E"><vh>Changes made</vh>
<v t="T4"><vh>Debugger.set_break</vh></v>
</v>
<v t="T5"><vh>Suggestions</vh></v>
<v><vh>Lib</vh>
<v t="T6" a="E"><vh>bdb.py</vh>
<v t="T7"><vh>&lt;&lt; bdb declarations &gt;&gt;</vh></v>
<v t="T8" a="E"><vh>class Bdb</vh>
<v t="T9"><vh>&lt;&lt; class Bdb declarations &gt;&gt;</vh></v>
<v t="T10"><vh>__init__</vh></v>
<v t="T11"><vh>canonic</vh></v>
<v t="T12"><vh>reset</vh></v>
<v t="T13"><vh>trace_dispatch (tracing function for sys.settrace)</vh></v>
<v t="T14" a="M"><vh>dispatch_line (calls break_here)</vh></v>
<v t="T15"><vh>dispatch_call (calls break_anywhere)</vh></v>
<v t="T16"><vh>dispatch_return</vh></v>
<v t="T17"><vh>dispatch_exception</vh></v>
<v t="T18"><vh>stop_here</vh></v>
<v t="T19" a="M"><vh>break_here</vh></v>
<v t="T20"><vh>do_clear</vh></v>
<v t="T21"><vh>break_anywhere</vh></v>
<v t="T22"><vh>user_call (to be overridden)</vh></v>
<v t="T23"><vh>user_line (to be overridden: called when stop or break at line)</vh></v>
<v t="T24"><vh>user_return (to be overridden)</vh></v>
<v t="T25"><vh>user_exception (to be overridden)</vh></v>
<v t="T26"><vh>set_step</vh></v>
<v t="T27"><vh>set_next</vh></v>
<v t="T28"><vh>set_return</vh></v>
<v t="T29"><vh>set_trace</vh></v>
<v t="T30" a="M"><vh>set_continue (when user hits go button)</vh></v>
<v t="T31"><vh>set_quit</vh></v>
<v t="T32" a="M"><vh>set_break (creates Breakpoint instance) (overridden in Debugger)</vh></v>
<v t="T33"><vh>clear_break</vh></v>
<v t="T34"><vh>clear_bpbynumber</vh></v>
<v t="T35"><vh>clear_all_file_breaks</vh></v>
<v t="T36"><vh>clear_all_breaks</vh></v>
<v t="T37"><vh>get_break</vh></v>
<v t="T38"><vh>get_breaks</vh></v>
<v t="T39"><vh>get_file_breaks</vh></v>
<v t="T40"><vh>get_all_breaks</vh></v>
<v t="T41"><vh>get_stack</vh></v>
<v t="T42"><vh>format_stack_entry</vh></v>
<v t="T43"><vh>run</vh></v>
<v t="T44"><vh>runeval</vh></v>
<v t="T45"><vh>runctx</vh></v>
<v t="T46"><vh>runcall</vh></v>
</v>
<v t="T47"><vh>set_trace</vh></v>
<v t="T48" a="E"><vh>class Breakpoint</vh>
<v t="T49"><vh>&lt;&lt; class Breakpoint declarations &gt;&gt;</vh></v>
<v t="T50"><vh>__init__</vh></v>
<v t="T51"><vh>deleteMe</vh></v>
<v t="T52"><vh>enable</vh></v>
<v t="T53"><vh>disable</vh></v>
<v t="T54"><vh>bpprint</vh></v>
</v>
<v t="T55"><vh>effective</vh></v>
<v t="T56"><vh>class Tdb</vh>
<v t="T57"><vh>user_call</vh></v>
<v t="T58"><vh>user_line</vh></v>
<v t="T59"><vh>user_return</vh></v>
<v t="T60"><vh>user_exception</vh></v>
</v>
<v t="T61"><vh>foo</vh></v>
<v t="T62"><vh>bar</vh></v>
<v t="T63"><vh>test</vh></v>
</v>
</v>
<v><vh>Idle</vh>
<v t="T64" a="E"><vh>PyShell.py</vh>
<v t="T65"><vh>&lt;&lt; PyShell declarations &gt;&gt;</vh></v>
<v t="T66"><vh>linecache_checkcache</vh></v>
<v t="T67" a="E"><vh>class PyShellEditorWindow</vh>
<v t="T68"><vh>&lt;&lt; class PyShellEditorWindow declarations &gt;&gt;</vh></v>
<v t="T69" a="M"><vh>__init__</vh></v>
<v t="T70"><vh>set_breakpoint_here</vh></v>
</v>
<v t="T71"><vh>class PyShellFileList</vh>
<v t="T72"><vh>&lt;&lt; class PyShellFileList declarations &gt;&gt;</vh></v>
<v t="T73"><vh>open_shell</vh></v>
</v>
<v t="T74"><vh>class ModifiedColorDelegator</vh>
<v t="T75"><vh>&lt;&lt; class ModifiedColorDelegator declarations &gt;&gt;</vh></v>
<v t="T76"><vh>recolorize_main</vh></v>
</v>
<v t="T77"><vh>class ModifiedUndoDelegator</vh>
<v t="T78"><vh>&lt;&lt; class ModifiedUndoDelegator declarations &gt;&gt;</vh></v>
<v t="T79"><vh>insert</vh></v>
<v t="T80"><vh>delete</vh></v>
</v>
<v t="T81"><vh>class ModifiedInterpreter</vh>
<v t="T82"><vh>__init__</vh></v>
<v t="T83"><vh>execsource</vh></v>
<v t="T84"><vh>execfile</vh></v>
<v t="T85"><vh>runsource</vh></v>
<v t="T86"><vh>stuffsource</vh></v>
<v t="T87"><vh>showsyntaxerror</vh></v>
<v t="T88"><vh>unpackerror</vh></v>
<v t="T89"><vh>showtraceback</vh></v>
<v t="T90"><vh>checklinecache</vh></v>
<v t="T91"><vh>setdebugger</vh></v>
<v t="T92"><vh>getdebugger</vh></v>
<v t="T93"><vh>runcode</vh></v>
<v t="T94"><vh>write</vh></v>
</v>
<v t="T95" a="E"><vh>class PyShell</vh>
<v t="T96"><vh>&lt;&lt; class PyShell declarations &gt;&gt;</vh></v>
<v t="T97"><vh>__init__</vh></v>
<v t="T98"><vh>toggle_debugger</vh></v>
<v t="T99"><vh>set_debugger_indicator</vh></v>
<v t="T100"><vh>toggle_jit_stack_viewer</vh></v>
<v t="T101"><vh>close_debugger</vh></v>
<v t="T102"><vh>open_debugger</vh></v>
<v t="T103"><vh>beginexecuting</vh></v>
<v t="T104"><vh>endexecuting</vh></v>
<v t="T105"><vh>close</vh></v>
<v t="T106"><vh>_close</vh></v>
<v t="T107"><vh>ispythonsource</vh></v>
<v t="T108"><vh>short_title</vh></v>
<v t="T109"><vh>begin</vh></v>
<v t="T110"><vh>interact</vh></v>
<v t="T111"><vh>readline</vh></v>
<v t="T112"><vh>isatty</vh></v>
<v t="T113"><vh>cancel_callback</vh></v>
<v t="T114"><vh>eof_callback</vh></v>
<v t="T115"><vh>home_callback</vh></v>
<v t="T116"><vh>linefeed_callback</vh></v>
<v t="T117"><vh>enter_callback</vh></v>
<v t="T118"><vh>recall</vh></v>
<v t="T119"><vh>runit</vh></v>
<v t="T120"><vh>cancel_check</vh></v>
<v t="T121"><vh>open_stack_viewer</vh></v>
<v t="T122"><vh>showprompt</vh></v>
<v t="T123"><vh>resetoutput</vh></v>
<v t="T124"><vh>write</vh></v>
</v>
<v t="T125"><vh>class PseudoFile</vh>
<v t="T126"><vh>__init__</vh></v>
<v t="T127"><vh>write</vh></v>
<v t="T128"><vh>writelines</vh></v>
<v t="T129"><vh>flush</vh></v>
<v t="T130"><vh>isatty</vh></v>
</v>
<v t="T131"><vh>main</vh></v>
</v>
<v t="T132" a="E"><vh>Debugger.py</vh>
<v t="T133" a="E"><vh>class Debugger (bdb.Bdb)</vh>
<v t="T134"><vh>__init__</vh></v>
<v t="T135"><vh>canonic</vh></v>
<v t="T136"><vh>close</vh></v>
<v t="T137"><vh>run</vh></v>
<v t="T138"><vh>user_line (Called when we stop or break at a line)</vh></v>
<v t="T139"><vh>user_return</vh></v>
<v t="T140"><vh>user_exception</vh></v>
<v t="T141"><vh>make_gui</vh></v>
<v t="T142"><vh>interaction</vh></v>
<v t="T143"><vh>sync_source_line</vh></v>
<v t="T144"><vh>cont (user hits go button)</vh></v>
<v t="T145"><vh>step (calls bdb.set_step)</vh></v>
<v t="T146"><vh>next (calls bdb.set_next)</vh></v>
<v t="T147"><vh>ret (calls bdb.set_return)</vh></v>
<v t="T148"><vh>quit (calls bdb.set_quit)</vh></v>
<v t="T149"><vh>show_stack</vh></v>
<v t="T150"><vh>show_source</vh></v>
<v t="T151"><vh>show_frame</vh></v>
<v t="T152"><vh>show_locals</vh></v>
<v t="T153"><vh>show_globals</vh></v>
<v t="T154"><vh>show_variables</vh></v>
<v t="T155" a="M"><vh>set_breakpoint_here</vh></v>
<v t="T156" a="M"><vh>set_break (overrides bdb.set_break)</vh></v>
</v>
</v>
</v>
<v a="E"><vh>Notes for clear breakpoint</vh>
<v t="T157"><vh>PyShell.py</vh></v>
<v t="T158" a="V"><vh>Debugger.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="T1">@ignore
@language python</t>
<t tx="T2">@nocolor

In Debugger.py insert 1 line.  Change:

def set_break(self, filename, lineno, temporary=0, cond = None):
    import linecache # Import as late as possible
    line = linecache.getline(filename, lineno)
    ...

to:

def set_break(self, filename, lineno, temporary=0, cond = None):
    import linecache # Import as late as possible
    filename = self.canonic(filename) # EKR
    line = linecache.getline(filename, lineno)
    ...
    
In bdb.py insert 2 lines.  Change:

def canonic(self, filename):
        canonic = self.fncache.get(filename)
        if not canonic:
            canonic = os.path.abspath(filename)
            self.fncache[filename] = canonic
        return canonic
To:

def canonic(self, filename):
        canonic = self.fncache.get(filename)
        if not canonic:
            canonic = os.path.abspath(filename)
            if sys.platform=="win32": # EKR
                canonic = string.lower(canonic) # EKR
            self.fncache[filename] = canonic
        return canonic

This works for me.  However, I think a cleaner change would be to do the following (I haven't tested this):

1. Define canonic as class method of bdb.
2. In breakpoint.__init__, replace:
    self.file = file    # This better be in canonical form!
by:
    self.file = bdb.canonic(file)
3. Replace all calls to self.canonic by bdb.canonic.

It is cleaner because breakpoint.__init__ can now enforce the essential condition.

Anyway, thanks for your help in stamping out this nasty bug.  I hope to see it fixed in the next release.

Edward</t>
<t tx="T3">@nocolor

** Must restart Python for changes to IDLE to take effect.
** Run leo by enabling debugger, import leo, go button in debugger
** Choosing "Quit" in the debugger "unhangs" IDLE

added print "EKR in idle.py" in idle.py
    This prints when I do the following:
    	open c: prompt window
    	python
    	import idle
added print statement to set_breakpoint_here in PyShell.py
    This prints when I do the following:
    	Enable debugger
    	Open a leo window
    	Set breakpoint.</t>
<t tx="T4">def set_break(self, filename, lineno, temporary=0, cond = None):

        import linecache # Import as late as possible
        if 1: # EKR:
            print "EKR: set_break:old,new:", `filename`, `self.canonic(filename)`
			filename = self.canonic(filename)
        line = linecache.getline(filename, lineno)
        if not line:
            return 'That line does not exist!'
        if not self.breaks.has_key(filename):
            self.breaks[filename] = []
        list = self.breaks[filename]
        if not lineno in list:
            list.append(lineno)
        bp = bdb.Breakpoint(filename, lineno, temporary, cond)
        print "EKR: Debugger.set_break: new bdb.Breakpoint:", `bp`
        print "EKR: Debugger.set_break: breaks:", `self.breaks`
</t>
<t tx="T5">Instead of ringing a bell, why not open the debugger if it isn't open?</t>
<t tx="T6">&lt;&lt; bdb declarations &gt;&gt;
&lt;&lt;  bdb methods &gt;&gt;


# end
</t>
<t tx="T7">"""Debugger basics"""

import sys
import os
import types

__all__ = ["BdbQuit","Bdb","Breakpoint"]

BdbQuit = 'bdb.BdbQuit' # Exception to give up completely

</t>
<t tx="T8">&lt;&lt; bdb methods &gt;&gt;=

class Bdb:
	&lt;&lt; class Bdb declarations &gt;&gt;
	&lt;&lt; class Bdb methods &gt;&gt;

</t>
<t tx="T9">"""Generic Python debugger base class.

This class takes care of details of the trace facility;
a derived class should implement user interaction.
The standard debugger class (pdb.Pdb) is an example.
"""

</t>
<t tx="T10">&lt;&lt; class Bdb methods &gt;&gt;=

def __init__(self):

    self.breaks = {}
    self.fncache = {}
</t>
<t tx="T11">&lt;&lt; class Bdb methods &gt;&gt;=

def canonic(self, filename):

    canonic = self.fncache.get(filename)
    if not canonic:
        canonic = os.path.abspath(filename)
        self.fncache[filename] = canonic
    return canonic
</t>
<t tx="T12">&lt;&lt; class Bdb methods &gt;&gt;=

def reset(self):

    import linecache
    linecache.checkcache()
    self.botframe = None
    self.stopframe = None
    self.returnframe = None
    self.quitting = 0
</t>
<t tx="T13">&lt;&lt; class Bdb methods &gt;&gt;=

def trace_dispatch(self, frame, event, arg):

	print "EKR: bdb.Bdb.dispatch: frame,event,arg:",`frame`,`event`,`arg`
    if self.quitting:
        return # None
    if event == 'line':
        return self.dispatch_line(frame)
    if event == 'call':
        return self.dispatch_call(frame, arg)
    if event == 'return':
        return self.dispatch_return(frame, arg)
    if event == 'exception':
        return self.dispatch_exception(frame, arg)
    print 'bdb.Bdb.dispatch: unknown debugging event:', `event`
    return self.trace_dispatch
</t>
<t tx="T14">&lt;&lt; class Bdb methods &gt;&gt;=

def dispatch_line(self, frame):

    if self.stop_here(frame) or self.break_here(frame):
        self.user_line(frame)
        if self.quitting: raise BdbQuit
    return self.trace_dispatch
</t>
<t tx="T15">&lt;&lt; class Bdb methods &gt;&gt;=

def dispatch_call(self, frame, arg):

    # XXX 'arg' is no longer used
    if self.botframe is None:
        # First call of dispatch since reset()
        self.botframe = frame
        return self.trace_dispatch
    if not (self.stop_here(frame) or self.break_anywhere(frame)):
        # No need to trace this function
        return # None

    self.user_call(frame, arg)
    if self.quitting: raise BdbQuit
    return self.trace_dispatch
</t>
<t tx="T16">&lt;&lt; class Bdb methods &gt;&gt;=

def dispatch_return(self, frame, arg):
    if self.stop_here(frame) or frame == self.returnframe:
        self.user_return(frame, arg)
        if self.quitting: raise BdbQuit
</t>
<t tx="T17">&lt;&lt; class Bdb methods &gt;&gt;=

def dispatch_exception(self, frame, arg):
    if self.stop_here(frame):
        self.user_exception(frame, arg)
        if self.quitting: raise BdbQuit
    return self.trace_dispatch
</t>
<t tx="T18">&lt;&lt; class Bdb methods &gt;&gt;=

# Normally derived classes don't override the following
# methods, but they may if they want to redefine the
# definition of stopping and breakpoints.

def stop_here(self, frame):

    if self.stopframe is None:
        return 1
    if frame is self.stopframe:
        return 1
    while frame is not None and frame is not self.stopframe:
        if frame is self.botframe:
            return 1
        frame = frame.f_back
    return 0
</t>
<t tx="T19">&lt;&lt; class Bdb methods &gt;&gt;=

def break_here(self, frame):

    filename = self.canonic(frame.f_code.co_filename)

    print "EKR bdb.break_here:",`filename`
    print "EKR self.breaks:", `self.breaks`

    if not self.breaks.has_key(filename):
        return 0

    lineno = frame.f_lineno
    if not lineno in self.breaks[filename]:
        return 0
    # flag says ok to delete temp. bp
    (bp, flag) = effective(filename, lineno, frame)
    if bp:
        self.currentbp = bp.number
        if (flag and bp.temporary):
            self.do_clear(str(bp.number))
        return 1
    else:
        return 0
</t>
<t tx="T20">&lt;&lt; class Bdb methods &gt;&gt;=

def do_clear(self, arg):
    raise NotImplementedError, "subclass of bdb must implement do_clear()"
</t>
<t tx="T21">&lt;&lt; class Bdb methods &gt;&gt;=

def break_anywhere(self, frame):

    return self.breaks.has_key(
        self.canonic(frame.f_code.co_filename))
</t>
<t tx="T22">&lt;&lt; class Bdb methods &gt;&gt;=

# Derived classes should override the user_* methods
# to gain control.

def user_call(self, frame, argument_list):

    """This method is called when there is the remote possibility
    that we ever need to stop in this function."""
    pass
</t>
<t tx="T23">&lt;&lt; class Bdb methods &gt;&gt;=

def user_line(self, frame):

    """This method is called when we stop or break at this line."""
    pass
</t>
<t tx="T24">&lt;&lt; class Bdb methods &gt;&gt;=

def user_return(self, frame, return_value):

    """This method is called when a return trap is set here."""
    pass
</t>
<t tx="T25">&lt;&lt; class Bdb methods &gt;&gt;=

def user_exception(self, frame, (exc_type, exc_value, exc_traceback)):

    """This method is called if an exception occurs,
    but only if we are to stop at or just below this level."""
    pass
</t>
<t tx="T26">&lt;&lt; class Bdb methods &gt;&gt;=

# Derived classes and clients can call the following methods
# to affect the stepping state.

def set_step(self):
    """Stop after one line of code."""
    self.stopframe = None
    self.returnframe = None
    self.quitting = 0
</t>
<t tx="T27">&lt;&lt; class Bdb methods &gt;&gt;=

def set_next(self, frame):
    """Stop on the next line in or below the given frame."""
    self.stopframe = frame
    self.returnframe = None
    self.quitting = 0
</t>
<t tx="T28">&lt;&lt; class Bdb methods &gt;&gt;=

def set_return(self, frame):
    """Stop when returning from the given frame."""
    self.stopframe = frame.f_back
    self.returnframe = frame
    self.quitting = 0
</t>
<t tx="T29">&lt;&lt; class Bdb methods &gt;&gt;=

def set_trace(self):

    """Start debugging from here."""
    try:
        1 + ''
    except:
        frame = sys.exc_info()[2].tb_frame.f_back
    self.reset()
    while frame:
        frame.f_trace = self.trace_dispatch
        self.botframe = frame
        frame = frame.f_back
    self.set_step()
    sys.settrace(self.trace_dispatch)
</t>
<t tx="T30">&lt;&lt; class Bdb methods &gt;&gt;=

def set_continue(self):

    # Don't stop except at breakpoints or when finished
    self.stopframe = self.botframe
    self.returnframe = None
    self.quitting = 0
	
	print "EKR: bdb.set_continue: breaks", `self.breaks`
    if not self.breaks:
        # no breakpoints; run without debugger overhead
        sys.settrace(None)
        try:
            1 + ''  # raise an exception
        except:
            frame = sys.exc_info()[2].tb_frame.f_back
        while frame and frame is not self.botframe:
            del frame.f_trace
            frame = frame.f_back
</t>
<t tx="T31">&lt;&lt; class Bdb methods &gt;&gt;=

def set_quit(self):

    self.stopframe = self.botframe
    self.returnframe = None
    self.quitting = 1
    sys.settrace(None)
</t>
<t tx="T32">&lt;&lt; class Bdb methods &gt;&gt;=

# Derived classes and clients can call the following methods
# to manipulate breakpoints.  These methods return an
# error message is something went wrong, None if all is well.
# Set_break prints out the breakpoint line and file:lineno.
# Call self.get_*break*() to see the breakpoints or better
# for bp in Breakpoint.bpbynumber: if bp: bp.bpprint().

def set_break(self, filename, lineno, temporary=0, cond = None):

    filename = self.canonic(filename)
    import linecache # Import as late as possible
    line = linecache.getline(filename, lineno)
    if not line:
        return 'Line %s:%d does not exist' % (filename,
                               lineno)
    if not self.breaks.has_key(filename):
        self.breaks[filename] = []
    list = self.breaks[filename]
    if not lineno in list:
        list.append(lineno)
    bp = Breakpoint(filename, lineno, temporary, cond)
</t>
<t tx="T33">&lt;&lt; class Bdb methods &gt;&gt;=

def clear_break(self, filename, lineno):
    filename = self.canonic(filename)
    if not self.breaks.has_key(filename):
        return 'There are no breakpoints in %s' % filename
    if lineno not in self.breaks[filename]:
        return 'There is no breakpoint at %s:%d' % (filename,
                                lineno)
    # If there's only one bp in the list for that file,line
    # pair, then remove the breaks entry
    for bp in Breakpoint.bplist[filename, lineno][:]:
        bp.deleteMe()
    if not Breakpoint.bplist.has_key((filename, lineno)):
        self.breaks[filename].remove(lineno)
    if not self.breaks[filename]:
        del self.breaks[filename]
</t>
<t tx="T34">&lt;&lt; class Bdb methods &gt;&gt;=

def clear_bpbynumber(self, arg):
    try:
        number = int(arg)
    except:
        return 'Non-numeric breakpoint number (%s)' % arg
    try:
        bp = Breakpoint.bpbynumber[number]
    except IndexError:
        return 'Breakpoint number (%d) out of range' % number
    if not bp:
        return 'Breakpoint (%d) already deleted' % number
    self.clear_break(bp.file, bp.line)
</t>
<t tx="T35">&lt;&lt; class Bdb methods &gt;&gt;=

def clear_all_file_breaks(self, filename):
    filename = self.canonic(filename)
    if not self.breaks.has_key(filename):
        return 'There are no breakpoints in %s' % filename
    for line in self.breaks[filename]:
        blist = Breakpoint.bplist[filename, line]
        for bp in blist:
            bp.deleteMe()
    del self.breaks[filename]
</t>
<t tx="T36">&lt;&lt; class Bdb methods &gt;&gt;=

def clear_all_breaks(self):
    if not self.breaks:
        return 'There are no breakpoints'
    for bp in Breakpoint.bpbynumber:
        if bp:
            bp.deleteMe()
    self.breaks = {}
</t>
<t tx="T37">&lt;&lt; class Bdb methods &gt;&gt;=

def get_break(self, filename, lineno):
    filename = self.canonic(filename)
    return self.breaks.has_key(filename) and \
        lineno in self.breaks[filename]
</t>
<t tx="T38">&lt;&lt; class Bdb methods &gt;&gt;=

def get_breaks(self, filename, lineno):
    filename = self.canonic(filename)
    return self.breaks.has_key(filename) and \
        lineno in self.breaks[filename] and \
        Breakpoint.bplist[filename, lineno] or []
</t>
<t tx="T39">&lt;&lt; class Bdb methods &gt;&gt;=

def get_file_breaks(self, filename):
    filename = self.canonic(filename)
    if self.breaks.has_key(filename):
        return self.breaks[filename]
    else:
        return []
</t>
<t tx="T40">&lt;&lt; class Bdb methods &gt;&gt;=

def get_all_breaks(self):
    return self.breaks
</t>
<t tx="T41">&lt;&lt; class Bdb methods &gt;&gt;=

# Derived classes and clients can call the following method
# to get a data structure representing a stack trace.

def get_stack(self, f, t):
    stack = []
    if t and t.tb_frame is f:
        t = t.tb_next
    while f is not None:
        stack.append((f, f.f_lineno))
        if f is self.botframe:
            break
        f = f.f_back
    stack.reverse()
    i = max(0, len(stack) - 1)
    while t is not None:
        stack.append((t.tb_frame, t.tb_lineno))
        t = t.tb_next
    return stack, i
</t>
<t tx="T42">&lt;&lt; class Bdb methods &gt;&gt;=

#

def format_stack_entry(self, frame_lineno, lprefix=': '):
    import linecache, repr
    frame, lineno = frame_lineno
    filename = self.canonic(frame.f_code.co_filename)
    s = filename + '(' + `lineno` + ')'
    if frame.f_code.co_name:
        s = s + frame.f_code.co_name
    else:
        s = s + "&lt;lambda&gt;"
    if frame.f_locals.has_key('__args__'):
        args = frame.f_locals['__args__']
    else:
        args = None
    if args:
        s = s + repr.repr(args)
    else:
        s = s + '()'
    if frame.f_locals.has_key('__return__'):
        rv = frame.f_locals['__return__']
        s = s + '-&gt;'
        s = s + repr.repr(rv)
    line = linecache.getline(filename, lineno)
    if line: s = s + lprefix + line.strip()
    return s
</t>
<t tx="T43">&lt;&lt; class Bdb methods &gt;&gt;=

# The following two methods can be called by clients to use
# a debugger to debug a statement, given as a string.

def run(self, cmd, globals=None, locals=None):

    if globals is None:
        import __main__
        globals = __main__.__dict__
    if locals is None:
        locals = globals
    self.reset()
    sys.settrace(self.trace_dispatch)
    if not isinstance(cmd, types.CodeType):
        cmd = cmd+'\n'
    try:
        try:
            exec cmd in globals, locals
        except BdbQuit:
            pass
    finally:
        self.quitting = 1
        sys.settrace(None)
</t>
<t tx="T44">&lt;&lt; class Bdb methods &gt;&gt;=

def runeval(self, expr, globals=None, locals=None):

    if globals is None:
        import __main__
        globals = __main__.__dict__
    if locals is None:
        locals = globals
    self.reset()
    sys.settrace(self.trace_dispatch)
    if not isinstance(expr, types.CodeType):
        expr = expr+'\n'
    try:
        try:
            return eval(expr, globals, locals)
        except BdbQuit:
            pass
    finally:
        self.quitting = 1
        sys.settrace(None)
</t>
<t tx="T45">&lt;&lt; class Bdb methods &gt;&gt;=

def runctx(self, cmd, globals, locals):

    # B/W compatibility
    self.run(cmd, globals, locals)
</t>
<t tx="T46">&lt;&lt; class Bdb methods &gt;&gt;=

# This method is more useful to debug a single function call.

def runcall(self, func, *args):
    self.reset()
    sys.settrace(self.trace_dispatch)
    res = None
    try:
        try:
            res = apply(func, args)
        except BdbQuit:
            pass
    finally:
        self.quitting = 1
        sys.settrace(None)
    return res
</t>
<t tx="T47">&lt;&lt; bdb methods &gt;&gt;=

def set_trace():
    Bdb().set_trace()
</t>
<t tx="T48">&lt;&lt; bdb methods &gt;&gt;=



class Breakpoint:
	&lt;&lt; class Breakpoint declarations &gt;&gt;
	&lt;&lt; class Breakpoint methods &gt;&gt;

</t>
<t tx="T49">"""Breakpoint class

Implements temporary breakpoints, ignore counts, disabling and
(re)-enabling, and conditionals.

Breakpoints are indexed by number through bpbynumber and by
the file,line tuple using bplist.  The former points to a
single instance of class Breakpoint.  The latter points to a
list of such instances since there may be more than one
breakpoint per line.

"""

# XXX Keeping state in the class is a mistake -- this means
# you cannot have more than one active Bdb instance.

next = 1        # Next bp to be assigned
bplist = {}     # indexed by (file, lineno) tuple
bpbynumber = [None] # Each entry is None or an instance of Bpt
            # index 0 is unused, except for marking an
            # effective break .... see effective()

</t>
<t tx="T50">&lt;&lt; class Breakpoint methods &gt;&gt;=

def __init__(self, file, line, temporary=0, cond = None):

	print "EKR: Breakpoint.__init__:", `file`,`line`
	if 1:
		self.file = os.path.abspath(filename) # EKR: from self.canonic
	else
    	self.file = file    # This better be in canonical form!
    self.line = line
    self.temporary = temporary
    self.cond = cond
    self.enabled = 1
    self.ignore = 0
    self.hits = 0
    self.number = Breakpoint.next
    Breakpoint.next = Breakpoint.next + 1
    # Build the two lists
    self.bpbynumber.append(self)
    print "EKR: Breakpoint.__init__:", `file`, `line`
    if self.bplist.has_key((file, line)):
        self.bplist[file, line].append(self)
    else:
        self.bplist[file, line] = [self]
</t>
<t tx="T51">&lt;&lt; class Breakpoint methods &gt;&gt;=

def deleteMe(self):
    index = (self.file, self.line)
    self.bpbynumber[self.number] = None   # No longer in list
    self.bplist[index].remove(self)
    if not self.bplist[index]:
        # No more bp for this f:l combo
        del self.bplist[index]
</t>
<t tx="T52">&lt;&lt; class Breakpoint methods &gt;&gt;=

def enable(self):
    self.enabled = 1
</t>
<t tx="T53">&lt;&lt; class Breakpoint methods &gt;&gt;=

def disable(self):
    self.enabled = 0
</t>
<t tx="T54">&lt;&lt; class Breakpoint methods &gt;&gt;=

def bpprint(self):
    if self.temporary:
        disp = 'del  '
    else:
        disp = 'keep '
    if self.enabled:
        disp = disp + 'yes'
    else:
        disp = disp + 'no '
    print '%-4dbreakpoint    %s at %s:%d' % (self.number, disp,
                         self.file, self.line)
    if self.cond:
        print '\tstop only if %s' % (self.cond,)
    if self.ignore:
        print '\tignore next %d hits' % (self.ignore)
    if (self.hits):
        if (self.hits &gt; 1): ss = 's'
        else: ss = ''
        print ('\tbreakpoint already hit %d time%s' %
               (self.hits, ss))
</t>
<t tx="T55">&lt;&lt; bdb methods &gt;&gt;=

# -----------end of Breakpoint class----------

# Determines if there is an effective (active) breakpoint at this
# line of code.  Returns breakpoint number or 0 if none
def effective(file, line, frame):
    """Determine which breakpoint for this file:line is to be acted upon.

    Called only if we know there is a bpt at this
    location.  Returns breakpoint that was triggered and a flag
    that indicates if it is ok to delete a temporary bp.

    """
    possibles = Breakpoint.bplist[file,line]
    for i in range(0, len(possibles)):
        b = possibles[i]
        if b.enabled == 0:
            continue
        # Count every hit when bp is enabled
        b.hits = b.hits + 1
        if not b.cond:
            # If unconditional, and ignoring,
            # go on to next, else break
            if b.ignore &gt; 0:
                b.ignore = b.ignore -1
                continue
            else:
                # breakpoint and marker that's ok
                # to delete if temporary
                return (b,1)
        else:
            # Conditional bp.
            # Ignore count applies only to those bpt hits where the
            # condition evaluates to true.
            try:
                val = eval(b.cond, frame.f_globals,
                       frame.f_locals)
                if val:
                    if b.ignore &gt; 0:
                        b.ignore = b.ignore -1
                        # continue
                    else:
                        return (b,1)
                # else:
                #   continue
            except:
                # if eval fails, most conservative
                # thing is to stop on breakpoint
                # regardless of ignore count.
                # Don't delete temporary,
                # as another hint to user.
                return (b,0)
    return (None, None)
</t>
<t tx="T56">&lt;&lt; bdb methods &gt;&gt;=


# -------------------- testing --------------------

class Tdb(Bdb):
	&lt;&lt; class Tdb methods &gt;&gt;

</t>
<t tx="T57">&lt;&lt; class Tdb methods &gt;&gt;=

def user_call(self, frame, args):
    name = frame.f_code.co_name
    if not name: name = '???'
    print '+++ call', name, args
</t>
<t tx="T58">&lt;&lt; class Tdb methods &gt;&gt;=

def user_line(self, frame):
    import linecache
    name = frame.f_code.co_name
    if not name: name = '???'
    fn = self.canonic(frame.f_code.co_filename)
    line = linecache.getline(fn, frame.f_lineno)
    print '+++', fn, frame.f_lineno, name, ':', line.strip()
</t>
<t tx="T59">&lt;&lt; class Tdb methods &gt;&gt;=

def user_return(self, frame, retval):
    print '+++ return', retval
</t>
<t tx="T60">&lt;&lt; class Tdb methods &gt;&gt;=

def user_exception(self, frame, exc_stuff):
    print '+++ exception', exc_stuff
    self.set_continue()
</t>
<t tx="T61">&lt;&lt; bdb methods &gt;&gt;=

def foo(n):
    print 'foo(', n, ')'
    x = bar(n*10)
    print 'bar returned', x
</t>
<t tx="T62">&lt;&lt; bdb methods &gt;&gt;=

def bar(a):
    print 'bar(', a, ')'
    return a/2
</t>
<t tx="T63">&lt;&lt; bdb methods &gt;&gt;=

def test():
    t = Tdb()
    t.run('import bdb; bdb.foo(10)')
</t>
<t tx="T64">&lt;&lt; PyShell declarations &gt;&gt;
&lt;&lt;  PyShell methods &gt;&gt;



if __name__ == "__main__":
    main()
</t>
<t tx="T65">#! /usr/bin/env python

import os
import sys
import string
import getopt
import re
import warnings

import linecache
from code import InteractiveInterpreter

from Tkinter import *
import tkMessageBox

from EditorWindow import EditorWindow, fixwordbreaks
from FileList import FileList
from ColorDelegator import ColorDelegator
from UndoDelegator import UndoDelegator
from OutputWindow import OutputWindow
from IdleConf import idleconf
import idlever

# We need to patch linecache.checkcache, because we don't want it
# to throw away our &lt;pyshell#...&gt; entries.
# Rather than repeating its code here, we save those entries,
# then call the original function, and then restore the saved entries.
</t>
<t tx="T66">&lt;&lt; PyShell methods &gt;&gt;=

def linecache_checkcache(orig_checkcache=linecache.checkcache):
    cache = linecache.cache
    save = {}
    for filename in cache.keys():
        if filename[:1] + filename[-1:] == '&lt;&gt;':
            save[filename] = cache[filename]
    orig_checkcache()
    cache.update(save)
</t>
<t tx="T67">&lt;&lt; PyShell methods &gt;&gt;=

linecache.checkcache = linecache_checkcache


# Note: &lt;&lt;newline-and-indent&gt;&gt; event is defined in AutoIndent.py

#$ event &lt;&lt;plain-newline-and-indent&gt;&gt;
#$ win &lt;Control-j&gt;
#$ unix &lt;Control-j&gt;

#$ event &lt;&lt;beginning-of-line&gt;&gt;
#$ win &lt;Control-a&gt;
#$ win &lt;Home&gt;
#$ unix &lt;Control-a&gt;
#$ unix &lt;Home&gt;

#$ event &lt;&lt;history-next&gt;&gt;
#$ win &lt;Alt-n&gt;
#$ unix &lt;Alt-n&gt;

#$ event &lt;&lt;history-previous&gt;&gt;
#$ win &lt;Alt-p&gt;
#$ unix &lt;Alt-p&gt;

#$ event &lt;&lt;interrupt-execution&gt;&gt;
#$ win &lt;Control-c&gt;
#$ unix &lt;Control-c&gt;

#$ event &lt;&lt;end-of-file&gt;&gt;
#$ win &lt;Control-d&gt;
#$ unix &lt;Control-d&gt;

#$ event &lt;&lt;open-stack-viewer&gt;&gt;

#$ event &lt;&lt;toggle-debugger&gt;&gt;


class PyShellEditorWindow(EditorWindow):
	&lt;&lt; class PyShellEditorWindow declarations &gt;&gt;
	&lt;&lt; class PyShellEditorWindow methods &gt;&gt;

</t>
<t tx="T68">    # Regular text edit window when a shell is present
    # XXX ought to merge with regular editor window

</t>
<t tx="T69">&lt;&lt; class PyShellEditorWindow methods &gt;&gt;=

def __init__(self, *args):
    apply(EditorWindow.__init__, (self,) + args)
    self.text.bind("&lt;&lt;set-breakpoint-here&gt;&gt;", self.set_breakpoint_here)
    self.text.bind("&lt;&lt;open-python-shell&gt;&gt;", self.flist.open_shell)
</t>
<t tx="T70">&lt;&lt; class PyShellEditorWindow methods &gt;&gt;=

rmenu_specs = [
    ("Set breakpoint here", "&lt;&lt;set-breakpoint-here&gt;&gt;"),
]

def set_breakpoint_here(self, event=None):
    print "EKR: setting breakpoint1"
    if not self.flist.pyshell or not self.flist.pyshell.interp.debugger:
        self.text.bell()
        return
    print "EKR: setting breakpoint2", `self.flist.pyshell.interp.debugger`
    self.flist.pyshell.interp.debugger.set_breakpoint_here(self)
</t>
<t tx="T71">&lt;&lt; PyShell methods &gt;&gt;=



class PyShellFileList(FileList):
	&lt;&lt; class PyShellFileList declarations &gt;&gt;
	&lt;&lt; class PyShellFileList methods &gt;&gt;

</t>
<t tx="T72"># File list when a shell is present

EditorWindow = PyShellEditorWindow

pyshell = None

</t>
<t tx="T73">&lt;&lt; class PyShellFileList methods &gt;&gt;=

def open_shell(self, event=None):
    if self.pyshell:
        self.pyshell.wakeup()
    else:
        self.pyshell = PyShell(self)
        self.pyshell.begin()
    return self.pyshell
</t>
<t tx="T74">&lt;&lt; PyShell methods &gt;&gt;=



class ModifiedColorDelegator(ColorDelegator):
	&lt;&lt; class ModifiedColorDelegator declarations &gt;&gt;
	&lt;&lt; class ModifiedColorDelegator methods &gt;&gt;

</t>
<t tx="T75">    # Colorizer for the shell window itself

</t>
<t tx="T76">&lt;&lt; class ModifiedColorDelegator methods &gt;&gt;=

def recolorize_main(self):
    self.tag_remove("TODO", "1.0", "iomark")
    self.tag_add("SYNC", "1.0", "iomark")
    ColorDelegator.recolorize_main(self)
</t>
<t tx="T77">&lt;&lt; PyShell methods &gt;&gt;=




class ModifiedUndoDelegator(UndoDelegator):
	&lt;&lt; class ModifiedUndoDelegator declarations &gt;&gt;
	&lt;&lt; class ModifiedUndoDelegator methods &gt;&gt;

</t>
<t tx="T78">    # Forbid insert/delete before the I/O mark

</t>
<t tx="T79">&lt;&lt; class ModifiedUndoDelegator methods &gt;&gt;=

def insert(self, index, chars, tags=None):
    try:
        if self.delegate.compare(index, "&lt;", "iomark"):
            self.delegate.bell()
            return
    except TclError:
        pass
    UndoDelegator.insert(self, index, chars, tags)
</t>
<t tx="T80">&lt;&lt; class ModifiedUndoDelegator methods &gt;&gt;=

def delete(self, index1, index2=None):
    try:
        if self.delegate.compare(index1, "&lt;", "iomark"):
            self.delegate.bell()
            return
    except TclError:
        pass
    UndoDelegator.delete(self, index1, index2)
</t>
<t tx="T81">&lt;&lt; PyShell methods &gt;&gt;=


class ModifiedInterpreter(InteractiveInterpreter):
	&lt;&lt; class ModifiedInterpreter methods &gt;&gt;

</t>
<t tx="T82">&lt;&lt; class ModifiedInterpreter methods &gt;&gt;=

def __init__(self, tkconsole):
    self.tkconsole = tkconsole
    locals = sys.modules['__main__'].__dict__
    InteractiveInterpreter.__init__(self, locals=locals)
    self.save_warnings_filters = None
</t>
<t tx="T83">&lt;&lt; class ModifiedInterpreter methods &gt;&gt;=

gid = 0

def execsource(self, source):
    # Like runsource() but assumes complete exec source
    filename = self.stuffsource(source)
    self.execfile(filename, source)
</t>
<t tx="T84">&lt;&lt; class ModifiedInterpreter methods &gt;&gt;=

def execfile(self, filename, source=None):
    # Execute an existing file
    if source is None:
        source = open(filename, "r").read()
    try:
        code = compile(source, filename, "exec")
    except (OverflowError, SyntaxError):
        self.tkconsole.resetoutput()
        InteractiveInterpreter.showsyntaxerror(self, filename)
    else:
        self.runcode(code)
</t>
<t tx="T85">&lt;&lt; class ModifiedInterpreter methods &gt;&gt;=

def runsource(self, source):
    # Extend base class to stuff the source in the line cache first
    filename = self.stuffsource(source)
    self.more = 0
    self.save_warnings_filters = warnings.filters[:]
    warnings.filterwarnings(action="error", category=SyntaxWarning)
    try:
        return InteractiveInterpreter.runsource(self, source, filename)
    finally:
        if self.save_warnings_filters is not None:
            warnings.filters[:] = self.save_warnings_filters
            self.save_warnings_filters = None
</t>
<t tx="T86">&lt;&lt; class ModifiedInterpreter methods &gt;&gt;=

def stuffsource(self, source):
    # Stuff source in the filename cache
    filename = "&lt;pyshell#%d&gt;" % self.gid
    self.gid = self.gid + 1
    lines = string.split(source, "\n")
    linecache.cache[filename] = len(source)+1, 0, lines, filename
    return filename
</t>
<t tx="T87">&lt;&lt; class ModifiedInterpreter methods &gt;&gt;=

def showsyntaxerror(self, filename=None):
    # Extend base class to color the offending position
    # (instead of printing it and pointing at it with a caret)
    text = self.tkconsole.text
    stuff = self.unpackerror()
    if not stuff:
        self.tkconsole.resetoutput()
        InteractiveInterpreter.showsyntaxerror(self, filename)
        return
    msg, lineno, offset, line = stuff
    if lineno == 1:
        pos = "iomark + %d chars" % (offset-1)
    else:
        pos = "iomark linestart + %d lines + %d chars" % (lineno-1,
                                                          offset-1)
    text.tag_add("ERROR", pos)
    text.see(pos)
    char = text.get(pos)
    if char and char in string.letters + string.digits + "_":
        text.tag_add("ERROR", pos + " wordstart", pos)
    self.tkconsole.resetoutput()
    self.write("SyntaxError: %s\n" % str(msg))
</t>
<t tx="T88">&lt;&lt; class ModifiedInterpreter methods &gt;&gt;=

def unpackerror(self):
    type, value, tb = sys.exc_info()
    ok = type is SyntaxError
    if ok:
        try:
            msg, (dummy_filename, lineno, offset, line) = value
        except:
            ok = 0
    if ok:
        return msg, lineno, offset, line
    else:
        return None
</t>
<t tx="T89">&lt;&lt; class ModifiedInterpreter methods &gt;&gt;=

def showtraceback(self):
    # Extend base class method to reset output properly
    text = self.tkconsole.text
    self.tkconsole.resetoutput()
    self.checklinecache()
    InteractiveInterpreter.showtraceback(self)
</t>
<t tx="T90">&lt;&lt; class ModifiedInterpreter methods &gt;&gt;=

def checklinecache(self):
    c = linecache.cache
    for key in c.keys():
        if key[:1] + key[-1:] != "&lt;&gt;":
            del c[key]
</t>
<t tx="T91">&lt;&lt; class ModifiedInterpreter methods &gt;&gt;=

debugger = None

def setdebugger(self, debugger):
    self.debugger = debugger
</t>
<t tx="T92">&lt;&lt; class ModifiedInterpreter methods &gt;&gt;=

def getdebugger(self):
    return self.debugger
</t>
<t tx="T93">&lt;&lt; class ModifiedInterpreter methods &gt;&gt;=

def runcode(self, code):
    # Override base class method
    if self.save_warnings_filters is not None:
        warnings.filters[:] = self.save_warnings_filters
        self.save_warnings_filters = None
    debugger = self.debugger
    try:
        self.tkconsole.beginexecuting()
        try:
            if debugger:
                debugger.run(code, self.locals)
            else:
                exec code in self.locals
        except SystemExit:
            if tkMessageBox.askyesno(
                "Exit?",
                "Do you want to exit altogether?",
                default="yes",
                master=self.tkconsole.text):
                raise
            else:
                self.showtraceback()
                if self.tkconsole.getvar("&lt;&lt;toggle-jit-stack-viewer&gt;&gt;"):
                    self.tkconsole.open_stack_viewer()
        except:
            self.showtraceback()
            if self.tkconsole.getvar("&lt;&lt;toggle-jit-stack-viewer&gt;&gt;"):
                self.tkconsole.open_stack_viewer()

    finally:
        self.tkconsole.endexecuting()
</t>
<t tx="T94">&lt;&lt; class ModifiedInterpreter methods &gt;&gt;=

def write(self, s):
    # Override base class write
    self.tkconsole.console.write(s)
</t>
<t tx="T95">&lt;&lt; PyShell methods &gt;&gt;=



class PyShell(OutputWindow):
	&lt;&lt; class PyShell declarations &gt;&gt;
	&lt;&lt; class PyShell methods &gt;&gt;

</t>
<t tx="T96">shell_title = "Python Shell"

# Override classes
ColorDelegator = ModifiedColorDelegator
UndoDelegator = ModifiedUndoDelegator

# Override menu bar specs
menu_specs = PyShellEditorWindow.menu_specs[:]
menu_specs.insert(len(menu_specs)-2, ("debug", "_Debug"))

# New classes
from IdleHistory import History

</t>
<t tx="T97">&lt;&lt; class PyShell methods &gt;&gt;=

def __init__(self, flist=None):
    self.interp = ModifiedInterpreter(self)
    if flist is None:
        root = Tk()
        fixwordbreaks(root)
        root.withdraw()
        flist = PyShellFileList(root)

    OutputWindow.__init__(self, flist, None, None)

    import __builtin__
    __builtin__.quit = __builtin__.exit = "To exit, type Ctrl-D."

    self.auto = self.extensions["AutoIndent"] # Required extension
    self.auto.config(usetabs=1, indentwidth=8, context_use_ps1=1)

    text = self.text
    text.configure(wrap="char")
    text.bind("&lt;&lt;newline-and-indent&gt;&gt;", self.enter_callback)
    text.bind("&lt;&lt;plain-newline-and-indent&gt;&gt;", self.linefeed_callback)
    text.bind("&lt;&lt;interrupt-execution&gt;&gt;", self.cancel_callback)
    text.bind("&lt;&lt;beginning-of-line&gt;&gt;", self.home_callback)
    text.bind("&lt;&lt;end-of-file&gt;&gt;", self.eof_callback)
    text.bind("&lt;&lt;open-stack-viewer&gt;&gt;", self.open_stack_viewer)
    text.bind("&lt;&lt;toggle-debugger&gt;&gt;", self.toggle_debugger)
    text.bind("&lt;&lt;open-python-shell&gt;&gt;", self.flist.open_shell)
    text.bind("&lt;&lt;toggle-jit-stack-viewer&gt;&gt;", self.toggle_jit_stack_viewer)

    self.save_stdout = sys.stdout
    self.save_stderr = sys.stderr
    self.save_stdin = sys.stdin
    sys.stdout = PseudoFile(self, "stdout")
    sys.stderr = PseudoFile(self, "stderr")
    sys.stdin = self
    self.console = PseudoFile(self, "console")

    self.history = self.History(self.text)
</t>
<t tx="T98">&lt;&lt; class PyShell methods &gt;&gt;=

reading = 0
executing = 0
canceled = 0
endoffile = 0

def toggle_debugger(self, event=None):
    if self.executing:
        tkMessageBox.showerror("Don't debug now",
            "You can only toggle the debugger when idle",
            master=self.text)
        self.set_debugger_indicator()
        return "break"
    else:
        db = self.interp.getdebugger()
        if db:
            self.close_debugger()
        else:
            self.open_debugger()
</t>
<t tx="T99">&lt;&lt; class PyShell methods &gt;&gt;=

def set_debugger_indicator(self):
    db = self.interp.getdebugger()
    self.setvar("&lt;&lt;toggle-debugger&gt;&gt;", not not db)
</t>
<t tx="T100">&lt;&lt; class PyShell methods &gt;&gt;=

def toggle_jit_stack_viewer( self, event=None):
    pass # All we need is the variable
</t>
<t tx="T101">&lt;&lt; class PyShell methods &gt;&gt;=

def close_debugger(self):
    db = self.interp.getdebugger()
    if db:
        self.interp.setdebugger(None)
        db.close()
        self.resetoutput()
        self.console.write("[DEBUG OFF]\n")
        sys.ps1 = "&gt;&gt;&gt; "
        self.showprompt()
    self.set_debugger_indicator()
</t>
<t tx="T102">&lt;&lt; class PyShell methods &gt;&gt;=

def open_debugger(self):

    import Debugger
    self.interp.setdebugger(Debugger.Debugger(self))
    sys.ps1 = "[DEBUG ON]\n&gt;&gt;&gt; "
    self.showprompt()
    self.set_debugger_indicator()
</t>
<t tx="T103">&lt;&lt; class PyShell methods &gt;&gt;=

def beginexecuting(self):
    # Helper for ModifiedInterpreter
    self.resetoutput()
    self.executing = 1
</t>
<t tx="T104">&lt;&lt; class PyShell methods &gt;&gt;=

    ##self._cancel_check = self.cancel_check
    ##sys.settrace(self._cancel_check)

def endexecuting(self):
    # Helper for ModifiedInterpreter
    ##sys.settrace(None)
    ##self._cancel_check = None
    self.executing = 0
    self.canceled = 0
</t>
<t tx="T105">&lt;&lt; class PyShell methods &gt;&gt;=

def close(self):
    # Extend base class method
    if self.executing:
        # XXX Need to ask a question here
        if not tkMessageBox.askokcancel(
            "Kill?",
            "The program is still running; do you want to kill it?",
            default="ok",
            master=self.text):
            return "cancel"
        self.canceled = 1
        if self.reading:
            self.top.quit()
        return "cancel"
    return PyShellEditorWindow.close(self)
</t>
<t tx="T106">&lt;&lt; class PyShell methods &gt;&gt;=

def _close(self):
    self.close_debugger()
    # Restore std streams
    sys.stdout = self.save_stdout
    sys.stderr = self.save_stderr
    sys.stdin = self.save_stdin
    # Break cycles
    self.interp = None
    self.console = None
    self.auto = None
    self.flist.pyshell = None
    self.history = None
    OutputWindow._close(self) # Really EditorWindow._close
</t>
<t tx="T107">&lt;&lt; class PyShell methods &gt;&gt;=

def ispythonsource(self, filename):
    # Override this so EditorWindow never removes the colorizer
    return 1
</t>
<t tx="T108">&lt;&lt; class PyShell methods &gt;&gt;=

def short_title(self):
    return self.shell_title
</t>
<t tx="T109">&lt;&lt; class PyShell methods &gt;&gt;=

COPYRIGHT = \
          'Type "copyright", "credits" or "license" for more information.'

def begin(self):
    self.resetoutput()
    self.write("Python %s on %s\n%s\nIDLE %s -- press F1 for help\n" %
               (sys.version, sys.platform, self.COPYRIGHT,
                idlever.IDLE_VERSION))
    try:
        sys.ps1
    except AttributeError:
        sys.ps1 = "&gt;&gt;&gt; "
    self.showprompt()
    import Tkinter
    Tkinter._default_root = None
</t>
<t tx="T110">&lt;&lt; class PyShell methods &gt;&gt;=

def interact(self):
    self.begin()
    self.top.mainloop()
</t>
<t tx="T111">&lt;&lt; class PyShell methods &gt;&gt;=

def readline(self):
    save = self.reading
    try:
        self.reading = 1
        self.top.mainloop()
    finally:
        self.reading = save
    line = self.text.get("iomark", "end-1c")
    self.resetoutput()
    if self.canceled:
        self.canceled = 0
        raise KeyboardInterrupt
    if self.endoffile:
        self.endoffile = 0
        return ""
    return line
</t>
<t tx="T112">&lt;&lt; class PyShell methods &gt;&gt;=

def isatty(self):
    return 1
</t>
<t tx="T113">&lt;&lt; class PyShell methods &gt;&gt;=

def cancel_callback(self, event):
    try:
        if self.text.compare("sel.first", "!=", "sel.last"):
            return # Active selection -- always use default binding
    except:
        pass
    if not (self.executing or self.reading):
        self.resetoutput()
        self.write("KeyboardInterrupt\n")
        self.showprompt()
        return "break"
    self.endoffile = 0
    self.canceled = 1
    if self.reading:
        self.top.quit()
    return "break"
</t>
<t tx="T114">&lt;&lt; class PyShell methods &gt;&gt;=

def eof_callback(self, event):
    if self.executing and not self.reading:
        return # Let the default binding (delete next char) take over
    if not (self.text.compare("iomark", "==", "insert") and
            self.text.compare("insert", "==", "end-1c")):
        return # Let the default binding (delete next char) take over
    if not self.executing:
##             if not tkMessageBox.askokcancel(
##                 "Exit?",
##                 "Are you sure you want to exit?",
##                 default="ok", master=self.text):
##                 return "break"
        self.resetoutput()
        self.close()
    else:
        self.canceled = 0
        self.endoffile = 1
        self.top.quit()
    return "break"
</t>
<t tx="T115">&lt;&lt; class PyShell methods &gt;&gt;=

def home_callback(self, event):
    if event.state != 0 and event.keysym == "Home":
        return # &lt;Modifier-Home&gt;; fall back to class binding
    if self.text.compare("iomark", "&lt;=", "insert") and \
       self.text.compare("insert linestart", "&lt;=", "iomark"):
        self.text.mark_set("insert", "iomark")
        self.text.tag_remove("sel", "1.0", "end")
        self.text.see("insert")
        return "break"
</t>
<t tx="T116">&lt;&lt; class PyShell methods &gt;&gt;=

def linefeed_callback(self, event):
    # Insert a linefeed without entering anything (still autoindented)
    if self.reading:
        self.text.insert("insert", "\n")
        self.text.see("insert")
    else:
        self.auto.auto_indent(event)
    return "break"
</t>
<t tx="T117">&lt;&lt; class PyShell methods &gt;&gt;=

def enter_callback(self, event):
    if self.executing and not self.reading:
        return # Let the default binding (insert '\n') take over
    # If some text is selected, recall the selection
    # (but only if this before the I/O mark)
    try:
        sel = self.text.get("sel.first", "sel.last")
        if sel:
            if self.text.compare("sel.last", "&lt;=", "iomark"):
                self.recall(sel)
                return "break"
    except:
        pass
    # If we're strictly before the line containing iomark, recall
    # the current line, less a leading prompt, less leading or
    # trailing whitespace
    if self.text.compare("insert", "&lt;", "iomark linestart"):
        # Check if there's a relevant stdin range -- if so, use it
        prev = self.text.tag_prevrange("stdin", "insert")
        if prev and self.text.compare("insert", "&lt;", prev[1]):
            self.recall(self.text.get(prev[0], prev[1]))
            return "break"
        next = self.text.tag_nextrange("stdin", "insert")
        if next and self.text.compare("insert lineend", "&gt;=", next[0]):
            self.recall(self.text.get(next[0], next[1]))
            return "break"
        # No stdin mark -- just get the current line
        self.recall(self.text.get("insert linestart", "insert lineend"))
        return "break"
    # If we're in the current input and there's only whitespace
    # beyond the cursor, erase that whitespace first
    s = self.text.get("insert", "end-1c")
    if s and not string.strip(s):
        self.text.delete("insert", "end-1c")
    # If we're in the current input before its last line,
    # insert a newline right at the insert point
    if self.text.compare("insert", "&lt;", "end-1c linestart"):
        self.auto.auto_indent(event)
        return "break"
    # We're in the last line; append a newline and submit it
    self.text.mark_set("insert", "end-1c")
    if self.reading:
        self.text.insert("insert", "\n")
        self.text.see("insert")
    else:
        self.auto.auto_indent(event)
    self.text.tag_add("stdin", "iomark", "end-1c")
    self.text.update_idletasks()
    if self.reading:
        self.top.quit() # Break out of recursive mainloop() in raw_input()
    else:
        self.runit()
    return "break"
</t>
<t tx="T118">&lt;&lt; class PyShell methods &gt;&gt;=

def recall(self, s):
    if self.history:
        self.history.recall(s)
</t>
<t tx="T119">&lt;&lt; class PyShell methods &gt;&gt;=

def runit(self):
    line = self.text.get("iomark", "end-1c")
    # Strip off last newline and surrounding whitespace.
    # (To allow you to hit return twice to end a statement.)
    i = len(line)
    while i &gt; 0 and line[i-1] in " \t":
        i = i-1
    if i &gt; 0 and line[i-1] == "\n":
        i = i-1
    while i &gt; 0 and line[i-1] in " \t":
        i = i-1
    line = line[:i]
    more = self.interp.runsource(line)
    if not more:
        self.showprompt()
</t>
<t tx="T120">&lt;&lt; class PyShell methods &gt;&gt;=

def cancel_check(self, frame, what, args,
                 dooneevent=tkinter.dooneevent,
                 dontwait=tkinter.DONT_WAIT):
    # Hack -- use the debugger hooks to be able to handle events
    # and interrupt execution at any time.
    # This slows execution down quite a bit, so you may want to
    # disable this (by not calling settrace() in runcode() above)
    # for full-bore (uninterruptable) speed.
    # XXX This should become a user option.
    if self.canceled:
        return
    dooneevent(dontwait)
    if self.canceled:
        self.canceled = 0
        raise KeyboardInterrupt
    return self._cancel_check
</t>
<t tx="T121">&lt;&lt; class PyShell methods &gt;&gt;=

def open_stack_viewer(self, event=None):
    try:
        sys.last_traceback
    except:
        tkMessageBox.showerror("No stack trace",
            "There is no stack trace yet.\n"
            "(sys.last_traceback is not defined)",
            master=self.text)
        return
    from StackViewer import StackBrowser
    sv = StackBrowser(self.root, self.flist)
</t>
<t tx="T122">&lt;&lt; class PyShell methods &gt;&gt;=

def showprompt(self):
    self.resetoutput()
    try:
        s = str(sys.ps1)
    except:
        s = ""
    self.console.write(s)
    self.text.mark_set("insert", "end-1c")
</t>
<t tx="T123">&lt;&lt; class PyShell methods &gt;&gt;=

def resetoutput(self):
    source = self.text.get("iomark", "end-1c")
    if self.history:
        self.history.history_store(source)
    if self.text.get("end-2c") != "\n":
        self.text.insert("end-1c", "\n")
    self.text.mark_set("iomark", "end-1c")
    sys.stdout.softspace = 0
</t>
<t tx="T124">&lt;&lt; class PyShell methods &gt;&gt;=

def write(self, s, tags=()):
    self.text.mark_gravity("iomark", "right")
    OutputWindow.write(self, s, tags, "iomark")
    self.text.mark_gravity("iomark", "left")
    if self.canceled:
        self.canceled = 0
        raise KeyboardInterrupt
</t>
<t tx="T125">&lt;&lt; PyShell methods &gt;&gt;=


class PseudoFile:
	&lt;&lt; class PseudoFile methods &gt;&gt;

</t>
<t tx="T126">&lt;&lt; class PseudoFile methods &gt;&gt;=

def __init__(self, shell, tags):
    self.shell = shell
    self.tags = tags
</t>
<t tx="T127">&lt;&lt; class PseudoFile methods &gt;&gt;=

def write(self, s):
    self.shell.write(s, self.tags)
</t>
<t tx="T128">&lt;&lt; class PseudoFile methods &gt;&gt;=

def writelines(self, l):
    map(self.write, l)
</t>
<t tx="T129">&lt;&lt; class PseudoFile methods &gt;&gt;=

def flush(self):
    pass
</t>
<t tx="T130">&lt;&lt; class PseudoFile methods &gt;&gt;=

def isatty(self):
    return 1
</t>
<t tx="T131">&lt;&lt; PyShell methods &gt;&gt;=

usage_msg = """\
usage: idle.py [-c command] [-d] [-e] [-s] [-t title] [arg] ...

-c command  run this command
-d          enable debugger
-e          edit mode; arguments are files to be edited
-s          run $IDLESTARTUP or $PYTHONSTARTUP before anything else
-t title    set title of shell window

When neither -c nor -e is used, and there are arguments, and the first
argument is not '-', the first argument is run as a script.  Remaining
arguments are arguments to the script or to the command run by -c.
"""

def main():
    cmd = None
    edit = 0
    debug = 0
    startup = 0

    try:
        opts, args = getopt.getopt(sys.argv[1:], "c:deist:")
    except getopt.error, msg:
        sys.stderr.write("Error: %s\n" % str(msg))
        sys.stderr.write(usage_msg)
        sys.exit(2)

    for o, a in opts:
        if o == '-c':
            cmd = a
        if o == '-d':
            debug = 1
        if o == '-e':
            edit = 1
        if o == '-s':
            startup = 1
        if o == '-t':
            PyShell.shell_title = a

    for i in range(len(sys.path)):
        sys.path[i] = os.path.abspath(sys.path[i])

    pathx = []
    if edit:
        for filename in args:
            pathx.append(os.path.dirname(filename))
    elif args and args[0] != "-":
        pathx.append(os.path.dirname(args[0]))
    else:
        pathx.append(os.curdir)
    for dir in pathx:
        dir = os.path.abspath(dir)
        if not dir in sys.path:
            sys.path.insert(0, dir)

    global flist, root
    root = Tk(className="Idle")
    fixwordbreaks(root)
    root.withdraw()
    flist = PyShellFileList(root)

    if edit:
        for filename in args:
            flist.open(filename)
    else:
        if cmd:
            sys.argv = ["-c"] + args
        else:
            sys.argv = args or [""]


    shell = PyShell(flist)
    interp = shell.interp
    flist.pyshell = shell

    if startup:
        filename = os.environ.get("IDLESTARTUP") or \
                   os.environ.get("PYTHONSTARTUP")
        if filename and os.path.isfile(filename):
            interp.execfile(filename)

    if debug:
        shell.open_debugger()
    if cmd:
        interp.execsource(cmd)
    elif not edit and args and args[0] != "-":
        interp.execfile(args[0])

    shell.begin()
    root.mainloop()
    root.destroy()
</t>
<t tx="T132">import os
import bdb
import traceback
from Tkinter import *
from WindowList import ListedToplevel

import StackViewer

class Debugger(bdb.Bdb):

	interacting = 0
	vstack = vsource = vlocals = vglobals = None
	&lt;&lt; class Debugger methods &gt;&gt;
</t>
<t tx="T133">&lt;&lt; Debugger methods &gt;&gt;=

</t>
<t tx="T134">&lt;&lt; class Debugger methods &gt;&gt;=

def __init__(self, pyshell):

    bdb.Bdb.__init__(self)
    self.pyshell = pyshell
    self.make_gui()
</t>
<t tx="T135">&lt;&lt; class Debugger methods &gt;&gt;=

def canonic(self, filename):

    # Canonicalize filename -- called by Bdb
    return os.path.normcase(os.path.abspath(filename))
</t>
<t tx="T136">&lt;&lt; class Debugger methods &gt;&gt;=

def close(self, event=None):

    if self.interacting:
        self.top.bell()
        return

    if self.stackviewer:
        self.stackviewer.close(); self.stackviewer = None
    self.pyshell.close_debugger()
    self.top.destroy()
</t>
<t tx="T137">&lt;&lt; class Debugger methods &gt;&gt;=

def run(self, *args):

    try:
        self.interacting = 1
        return apply(bdb.Bdb.run, (self,) + args)
    finally:
        self.interacting = 0
</t>
<t tx="T138">&lt;&lt; class Debugger methods &gt;&gt;=

def user_line(self, frame):

    self.interaction(frame)
</t>
<t tx="T139">&lt;&lt; class Debugger methods &gt;&gt;=

def user_return(self, frame, rv):

    # XXX show rv?
    ##self.interaction(frame)
    pass
</t>
<t tx="T140">&lt;&lt; class Debugger methods &gt;&gt;=

def user_exception(self, frame, info):

    self.interaction(frame, info)
</t>
<t tx="T141">&lt;&lt; class Debugger methods &gt;&gt;=

def make_gui(self):

    pyshell = self.pyshell
    self.flist = pyshell.flist
    self.root = root = pyshell.root
    self.top = top =ListedToplevel(root)
    self.top.wm_title("Debug Control")
    self.top.wm_iconname("Debug")
    top.wm_protocol("WM_DELETE_WINDOW", self.close)
    self.top.bind("&lt;Escape&gt;", self.close)
    #
    self.bframe = bframe = Frame(top)
    self.bframe.pack(anchor="w")
    self.buttons = bl = []
    #
    self.bcont = b = Button(bframe, text="Go", command=self.cont)
    bl.append(b)
    self.bstep = b = Button(bframe, text="Step", command=self.step)
    bl.append(b)
    self.bnext = b = Button(bframe, text="Over", command=self.next)
    bl.append(b)
    self.bret = b = Button(bframe, text="Out", command=self.ret)
    bl.append(b)
    self.bret = b = Button(bframe, text="Quit", command=self.quit)
    bl.append(b)
    #
    for b in bl:
        b.configure(state="disabled")
        b.pack(side="left")
    #
    self.cframe = cframe = Frame(bframe)
    self.cframe.pack(side="left")
    #
    if not self.vstack:
        self.__class__.vstack = BooleanVar(top)
        self.vstack.set(1)
    self.bstack = Checkbutton(cframe,
        text="Stack", command=self.show_stack, variable=self.vstack)
    self.bstack.grid(row=0, column=0)
    if not self.vsource:
        self.__class__.vsource = BooleanVar(top)
        ##self.vsource.set(1)
    self.bsource = Checkbutton(cframe,
        text="Source", command=self.show_source, variable=self.vsource)
    self.bsource.grid(row=0, column=1)
    if not self.vlocals:
        self.__class__.vlocals = BooleanVar(top)
        self.vlocals.set(1)
    self.blocals = Checkbutton(cframe,
        text="Locals", command=self.show_locals, variable=self.vlocals)
    self.blocals.grid(row=1, column=0)
    if not self.vglobals:
        self.__class__.vglobals = BooleanVar(top)
        ##self.vglobals.set(1)
    self.bglobals = Checkbutton(cframe,
        text="Globals", command=self.show_globals, variable=self.vglobals)
    self.bglobals.grid(row=1, column=1)
    #
    self.status = Label(top, anchor="w")
    self.status.pack(anchor="w")
    self.error = Label(top, anchor="w")
    self.error.pack(anchor="w", fill="x")
    self.errorbg = self.error.cget("background")
    #
    self.fstack = Frame(top, height=1)
    self.fstack.pack(expand=1, fill="both")
    self.flocals = Frame(top)
    self.flocals.pack(expand=1, fill="both")
    self.fglobals = Frame(top, height=1)
    self.fglobals.pack(expand=1, fill="both")
    #
    if self.vstack.get():
        self.show_stack()
    if self.vlocals.get():
        self.show_locals()
    if self.vglobals.get():
        self.show_globals()
</t>
<t tx="T142">&lt;&lt; class Debugger methods &gt;&gt;=

frame = None

def interaction(self, frame, info=None):

    self.frame = frame
    code = frame.f_code
    file = code.co_filename
    base = os.path.basename(file)
    lineno = frame.f_lineno
    #
    message = "%s:%s" % (base, lineno)
    if code.co_name != "?":
        message = "%s: %s()" % (message, code.co_name)
    self.status.configure(text=message)
    #
    if info:
        type, value, tb = info
        try:
            m1 = type.__name__
        except AttributeError:
            m1 = "%s" % str(type)
        if value is not None:
            try:
                m1 = "%s: %s" % (m1, str(value))
            except:
                pass
        bg = "yellow"
    else:
        m1 = ""
        tb = None
        bg = self.errorbg
    self.error.configure(text=m1, background=bg)
    #
    sv = self.stackviewer
    if sv:
        stack, i = self.get_stack(self.frame, tb)
        sv.load_stack(stack, i)
    #
    self.show_variables(1)
    #
    if self.vsource.get():
        self.sync_source_line()
    #
    for b in self.buttons:
        b.configure(state="normal")
    #
    self.top.tkraise()
    self.root.mainloop()
    #
    for b in self.buttons:
        b.configure(state="disabled")
    self.status.configure(text="")
    self.error.configure(text="", background=self.errorbg)
    self.frame = None
</t>
<t tx="T143">&lt;&lt; class Debugger methods &gt;&gt;=

def sync_source_line(self):

    frame = self.frame
    if not frame:
        return
    code = frame.f_code
    file = code.co_filename
    lineno = frame.f_lineno
    if file[:1] + file[-1:] != "&lt;&gt;" and os.path.exists(file):
        edit = self.flist.open(file)
        if edit:
            edit.gotoline(lineno)
</t>
<t tx="T144">&lt;&lt; class Debugger methods &gt;&gt;=

def cont(self):

    self.set_continue() # calls Bdb.set_continue
    self.root.quit()
</t>
<t tx="T145">&lt;&lt; class Debugger methods &gt;&gt;=

def step(self):

    self.set_step()
    self.root.quit()
</t>
<t tx="T146">&lt;&lt; class Debugger methods &gt;&gt;=

def next(self):

    self.set_next(self.frame)
    self.root.quit()
</t>
<t tx="T147">&lt;&lt; class Debugger methods &gt;&gt;=

def ret(self):

    self.set_return(self.frame)
    self.root.quit()
</t>
<t tx="T148">&lt;&lt; class Debugger methods &gt;&gt;=

def quit(self):

    self.set_quit()
    self.root.quit()
</t>
<t tx="T149">&lt;&lt; class Debugger methods &gt;&gt;=

stackviewer = None

def show_stack(self):
    if not self.stackviewer and self.vstack.get():
        self.stackviewer = sv = StackViewer.StackViewer(
            self.fstack, self.flist, self)
        if self.frame:
            stack, i = self.get_stack(self.frame, None)
            sv.load_stack(stack, i)
    else:
        sv = self.stackviewer
        if sv and not self.vstack.get():
            self.stackviewer = None
            sv.close()
        self.fstack['height'] = 1
</t>
<t tx="T150">&lt;&lt; class Debugger methods &gt;&gt;=

def show_source(self):
    if self.vsource.get():
        self.sync_source_line()
</t>
<t tx="T151">&lt;&lt; class Debugger methods &gt;&gt;=

def show_frame(self, (frame, lineno)):
    self.frame = frame
    self.show_variables()
</t>
<t tx="T152">&lt;&lt; class Debugger methods &gt;&gt;=

localsviewer = None
globalsviewer = None

def show_locals(self):
    lv = self.localsviewer
    if self.vlocals.get():
        if not lv:
            self.localsviewer = StackViewer.NamespaceViewer(
                self.flocals, "Locals")
    else:
        if lv:
            self.localsviewer = None
            lv.close()
            self.flocals['height'] = 1
    self.show_variables()
</t>
<t tx="T153">&lt;&lt; class Debugger methods &gt;&gt;=

def show_globals(self):
    gv = self.globalsviewer
    if self.vglobals.get():
        if not gv:
            self.globalsviewer = StackViewer.NamespaceViewer(
                self.fglobals, "Globals")
    else:
        if gv:
            self.globalsviewer = None
            gv.close()
            self.fglobals['height'] = 1
    self.show_variables()
</t>
<t tx="T154">&lt;&lt; class Debugger methods &gt;&gt;=

def show_variables(self, force=0):
    lv = self.localsviewer
    gv = self.globalsviewer
    frame = self.frame
    if not frame:
        ldict = gdict = None
    else:
        ldict = frame.f_locals
        gdict = frame.f_globals
        if lv and gv and ldict is gdict:
            ldict = None
    if lv:
        lv.load_dict(ldict, force)
    if gv:
        gv.load_dict(gdict, force)
</t>
<t tx="T155">&lt;&lt; class Debugger methods &gt;&gt;=

def set_breakpoint_here(self, edit):

    print "EKR: Debugger:set_breakpoint_here"
    text = edit.text
    filename = edit.io.filename
    if not filename:
        text.bell()
        return
    lineno = int(float(text.index("insert")))
    msg = self.set_break(filename, lineno)
    if msg:
        text.bell()
        return
    print "EKR: breakpoint set"
    text.tag_add("BREAK", "insert linestart", "insert lineend +1char")
</t>
<t tx="T156">&lt;&lt; class Debugger methods &gt;&gt;=

# A literal copy of Bdb.set_break() without the print statement at the end

def set_break(self, filename, lineno, temporary=0, cond = None):

    print "EKR: set_break"
    import linecache # Import as late as possible
	if 1: # EKR:
		filename = self.canonic(filename)
    line = linecache.getline(filename, lineno)
    if not line:
        return 'That line does not exist!'
    if not self.breaks.has_key(filename):
        self.breaks[filename] = []
    list = self.breaks[filename]
    if not lineno in list:
        list.append(lineno)
    bp = bdb.Breakpoint(filename, lineno, temporary, cond)
    print "EKR: Debugger.set_break: new bdb.Breakpoint:", `bp`
	print "EKR: Debugger.set_break: self.breaks", `self.breaks`
</t>
<t tx="T157">def __init__(self, *args):
    apply(EditorWindow.__init__, (self,) + args)
    self.text.bind("&lt;&lt;set-breakpoint-here&gt;&gt;", self.set_breakpoint_here)
    self.text.bind("&lt;&lt;clear-this_breakpoint&gt;&gt;", self.clear_breakpoint_here) ## EKR
    self.text.bind("&lt;&lt;open-python-shell&gt;&gt;", self.flist.open_shell)

rmenu_specs = [
    ("Set breakpoint here", "&lt;&lt;set-breakpoint-here&gt;&gt;"),
    ("Clear this breakpoint", "&lt;&lt;clear-this-breakpoint&gt;&gt;"), ## EKR
]

# EKR: all new
def clear_this_breakpoint(self, event=None):
    print "EKR: clearing breakpoint"</t>
<t tx="T158">def clear_this_breakpoint(self, edit):
        print "EKR: Debugger:clear_this_breakpoint"
        text = edit.text
        filename = edit.io.filename
        if not filename:
            text.bell()
            return
        lineno = int(float(text.index("insert")))
        msg = self.clear_break(filename, lineno)
        if msg:
            text.bell()
            return
        print "EKR: breakpoint cleared"
        text.tag_remove("BREAK", "insert linestart", "insert lineend +1char")</t>
</tnodes>
</leo_file>
