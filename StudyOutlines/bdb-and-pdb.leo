<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="159" left="242" height="580" width="800"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070417101711" a="V"><vh>Read me</vh></v>
<v t="ekr.20070417101519"><vh>@chapters</vh>
<v t="ekr.20070417101519.1"><vh>@chapter trash</vh></v>
</v>
<v t="ekr.20070417101512.171" a="E"><vh>originals</vh>
<v t="ekr.20070417101512.172"><vh>Python24/Lib/bdb(orig).py</vh>
<v t="ekr.20070417101512.173"><vh>class BdbQuit</vh></v>
<v t="ekr.20070417101512.174"><vh>class Bdb</vh>
<v t="ekr.20070417101512.175"><vh>__init__</vh></v>
<v t="ekr.20070417101512.176"><vh>canonic</vh></v>
<v t="ekr.20070417101512.177"><vh>reset</vh></v>
<v t="ekr.20070417101512.178"><vh>trace_dispatch (the argument to sys.settrace) &amp; helpers</vh>
<v t="ekr.20070417101512.179"><vh>dispatch_line</vh></v>
<v t="ekr.20070417101512.180"><vh>dispatch_call</vh></v>
<v t="ekr.20070417101512.181"><vh>dispatch_return</vh></v>
<v t="ekr.20070417101512.182"><vh>dispatch_exception</vh></v>
<v t="ekr.20070417101512.183"><vh>stop_here</vh></v>
<v t="ekr.20070417101512.184"><vh>break_here</vh></v>
<v t="ekr.20070417101512.185"><vh>break_anywhere</vh></v>
<v t="ekr.20070417101512.186"><vh>do_clear</vh></v>
</v>
<v t="ekr.20070417101512.187"><vh>To be overridden in subclasses</vh>
<v t="ekr.20070417101512.188"><vh>user_call</vh></v>
<v t="ekr.20070417101512.189"><vh>user_line</vh></v>
<v t="ekr.20070417101512.190"><vh>user_return</vh></v>
<v t="ekr.20070417101512.191"><vh>user_exception</vh></v>
</v>
<v t="ekr.20070417101512.192"><vh>Basic operations</vh>
<v t="ekr.20070417101512.193"><vh>set_step</vh></v>
<v t="ekr.20070417101512.194"><vh>set_next</vh></v>
<v t="ekr.20070417101512.195"><vh>set_return</vh></v>
<v t="ekr.20070417101512.196"><vh>set_trace</vh></v>
<v t="ekr.20070417101512.197"><vh>set_continue</vh></v>
<v t="ekr.20070417101512.198"><vh>set_quit</vh></v>
</v>
<v t="ekr.20070417101512.199"><vh>Breakpoints</vh>
<v t="ekr.20070417101512.200"><vh>set_break</vh></v>
<v t="ekr.20070417101512.201"><vh>clear_break</vh></v>
<v t="ekr.20070417101512.202"><vh>clear_bpbynumber</vh></v>
<v t="ekr.20070417101512.203"><vh>clear_all_file_breaks</vh></v>
<v t="ekr.20070417101512.204"><vh>clear_all_breaks</vh></v>
<v t="ekr.20070417101512.205"><vh>get_break</vh></v>
<v t="ekr.20070417101512.206"><vh>get_breaks</vh></v>
<v t="ekr.20070417101512.207"><vh>get_file_breaks</vh></v>
<v t="ekr.20070417101512.208"><vh>get_all_breaks</vh></v>
</v>
<v t="ekr.20070417101512.209"><vh>Stack</vh>
<v t="ekr.20070417101512.210"><vh>get_stack</vh></v>
<v t="ekr.20070417101512.211"><vh>format_stack_entry</vh></v>
</v>
<v t="ekr.20070417101512.212"><vh>Entry points</vh>
<v t="ekr.20070417101512.213"><vh>run</vh></v>
<v t="ekr.20070417101512.214"><vh>runeval</vh></v>
<v t="ekr.20070417101512.215"><vh>runctx</vh></v>
<v t="ekr.20070417101512.216"><vh>runcall</vh></v>
</v>
</v>
<v t="ekr.20070417101512.217"><vh>class Breakpoint</vh>
<v t="ekr.20070417101512.218"><vh>__init__</vh></v>
<v t="ekr.20070417101512.219"><vh>deleteMe</vh></v>
<v t="ekr.20070417101512.220"><vh>enable</vh></v>
<v t="ekr.20070417101512.221"><vh>disable</vh></v>
<v t="ekr.20070417101512.222"><vh>bpprint</vh></v>
</v>
<v t="ekr.20070417101512.223"><vh>functions</vh>
<v t="ekr.20070417101512.224"><vh>set_trace</vh></v>
<v t="ekr.20070417101512.225"><vh>checkfuncname</vh></v>
<v t="ekr.20070417101512.226"><vh>effective</vh></v>
</v>
<v t="ekr.20070417101512.227"><vh>Testing...</vh>
<v t="ekr.20070417101512.228"><vh>class Tdb</vh>
<v t="ekr.20070417101512.229"><vh>user_call</vh></v>
<v t="ekr.20070417101512.230"><vh>user_line</vh></v>
<v t="ekr.20070417101512.231"><vh>user_return</vh></v>
<v t="ekr.20070417101512.232"><vh>user_exception</vh></v>
</v>
<v t="ekr.20070417101512.233"><vh>foo</vh></v>
<v t="ekr.20070417101512.234"><vh>bar</vh></v>
<v t="ekr.20070417101512.235"><vh>test</vh></v>
</v>
</v>
<v t="ekr.20070417101512.236"><vh>Python24/Lib/pdb(orig).py</vh>
<v t="ekr.20070417101512.237"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20070417101512.238"><vh>Functions</vh>
<v t="ekr.20070417101512.239"><vh>find_function</vh></v>
<v t="ekr.20070417101512.240"><vh>simplified interface</vh>
<v t="ekr.20070417101512.241"><vh>run</vh></v>
<v t="ekr.20070417101512.242"><vh>runeval</vh></v>
<v t="ekr.20070417101512.243"><vh>runctx</vh></v>
<v t="ekr.20070417101512.244"><vh>runcall</vh></v>
<v t="ekr.20070417101512.245"><vh>set_trace</vh></v>
</v>
<v t="ekr.20070417101512.246"><vh>post mortem interface</vh>
<v t="ekr.20070417101512.247"><vh>post_mortem</vh></v>
<v t="ekr.20070417101512.248"><vh>pm</vh></v>
</v>
<v t="ekr.20070417101512.249"><vh>testing</vh>
<v t="ekr.20070417101512.250"><vh>test</vh></v>
<v t="ekr.20070417101512.251"><vh>help</vh></v>
<v t="ekr.20070417101512.252"><vh>main</vh></v>
</v>
</v>
<v t="ekr.20070417101512.253"><vh>class Pdb (Bdb, Cmd)</vh>
<v t="ekr.20070417101512.254"><vh>__init__</vh></v>
<v t="ekr.20070417101512.255"><vh>Overrides of Bdb methods</vh>
<v t="ekr.20070417101512.256"><vh>user_call</vh></v>
<v t="ekr.20070417101512.257"><vh>user_line</vh></v>
<v t="ekr.20070417101512.258"><vh>user_return</vh></v>
<v t="ekr.20070417101512.259"><vh>user_exception</vh></v>
</v>
<v t="ekr.20070417101512.260"><vh>interaction &amp; helpers</vh>
<v t="ekr.20070417101512.261"><vh>reset (overrides Bdb method)</vh></v>
<v t="ekr.20070417101512.262"><vh>setup</vh></v>
<v t="ekr.20070417101512.263"><vh>forget</vh></v>
<v t="ekr.20070417101512.264"><vh>execRcLines</vh></v>
</v>
<v t="ekr.20070417101512.265"><vh>Overrides of cmd methods</vh>
<v t="ekr.20070417101512.266"><vh>default</vh></v>
<v t="ekr.20070417101512.267"><vh>precmd</vh></v>
</v>
<v t="ekr.20070417101512.268"><vh>commands</vh>
<v t="ekr.20070417101512.269"><vh>do_alias</vh></v>
<v t="ekr.20070417101512.270"><vh>do_args</vh></v>
<v t="ekr.20070417101512.271"><vh>do_break &amp; helpers</vh>
<v t="ekr.20070417101512.272"><vh>checkline</vh></v>
<v t="ekr.20070417101512.273"><vh>lineinfo</vh></v>
<v t="ekr.20070417101512.274"><vh>defaultFile</vh></v>
<v t="ekr.20070417101512.275"><vh>lookupmodule</vh></v>
</v>
<v t="ekr.20070417101512.276"><vh>do_clear</vh></v>
<v t="ekr.20070417101512.277"><vh>do_condition</vh></v>
<v t="ekr.20070417101512.278"><vh>do_continue</vh></v>
<v t="ekr.20070417101512.279"><vh>do_debug</vh></v>
<v t="ekr.20070417101512.280"><vh>do_disable</vh></v>
<v t="ekr.20070417101512.281"><vh>do_down</vh></v>
<v t="ekr.20070417101512.282"><vh>do_enable</vh></v>
<v t="ekr.20070417101512.283"><vh>do_EOF</vh></v>
<v t="ekr.20070417101512.284"><vh>do_ignore</vh></v>
<v t="ekr.20070417101512.285"><vh>do_jump</vh></v>
<v t="ekr.20070417101512.286"><vh>do_list</vh>
<v t="ekr.20070417101512.287"><vh>&lt;&lt; compute the first &amp; last line counts &gt;&gt;</vh></v>
</v>
<v t="ekr.20070417101512.288"><vh>do_next</vh></v>
<v t="ekr.20070417101512.289"><vh>do_p</vh></v>
<v t="ekr.20070417101512.290"><vh>do_pp</vh></v>
<v t="ekr.20070417101512.291"><vh>do_quit</vh></v>
<v t="ekr.20070417101512.292"><vh>do_return</vh></v>
<v t="ekr.20070417101512.293"><vh>do_retval &amp; helper</vh>
<v t="ekr.20070417101512.294"><vh>_getval</vh></v>
</v>
<v t="ekr.20070417101512.295"><vh>do_step</vh></v>
<v t="ekr.20070417101512.296"><vh>do_tbreak</vh></v>
<v t="ekr.20070417101512.297"><vh>do_unalias</vh></v>
<v t="ekr.20070417101512.298"><vh>do_up</vh></v>
<v t="ekr.20070417101512.299"><vh>do_whatis</vh></v>
<v t="ekr.20070417101512.300"><vh>do_where</vh></v>
</v>
<v t="ekr.20070417101512.301"><vh>print...</vh>
<v t="ekr.20070417101512.302"><vh>print_stack_entry</vh></v>
<v t="ekr.20070417101512.303"><vh>print_stack_trace</vh></v>
</v>
<v t="ekr.20070417101512.304"><vh>help...</vh>
<v t="ekr.20070417101512.305"><vh>help_a</vh></v>
<v t="ekr.20070417101512.306"><vh>help_alias</vh></v>
<v t="ekr.20070417101512.307"><vh>help_args</vh></v>
<v t="ekr.20070417101512.308"><vh>help_b</vh></v>
<v t="ekr.20070417101512.309"><vh>help_break</vh></v>
<v t="ekr.20070417101512.310"><vh>help_c</vh></v>
<v t="ekr.20070417101512.311"><vh>help_cl</vh></v>
<v t="ekr.20070417101512.312"><vh>help_clear</vh></v>
<v t="ekr.20070417101512.313"><vh>help_condition</vh></v>
<v t="ekr.20070417101512.314"><vh>help_cont</vh></v>
<v t="ekr.20070417101512.315"><vh>help_continue</vh></v>
<v t="ekr.20070417101512.316"><vh>help_d</vh></v>
<v t="ekr.20070417101512.317"><vh>help_debug</vh></v>
<v t="ekr.20070417101512.318"><vh>help_disable</vh></v>
<v t="ekr.20070417101512.319"><vh>help_down</vh></v>
<v t="ekr.20070417101512.320"><vh>help_enable</vh></v>
<v t="ekr.20070417101512.321"><vh>help_EOF</vh></v>
<v t="ekr.20070417101512.322"><vh>help_exec</vh></v>
<v t="ekr.20070417101512.323"><vh>help_h</vh></v>
<v t="ekr.20070417101512.324"><vh>help_help</vh></v>
<v t="ekr.20070417101512.325"><vh>help_ignore</vh></v>
<v t="ekr.20070417101512.326"><vh>help_j</vh></v>
<v t="ekr.20070417101512.327"><vh>help_jump</vh></v>
<v t="ekr.20070417101512.328"><vh>help_l</vh></v>
<v t="ekr.20070417101512.329"><vh>help_list</vh></v>
<v t="ekr.20070417101512.330"><vh>help_n</vh></v>
<v t="ekr.20070417101512.331"><vh>help_next</vh></v>
<v t="ekr.20070417101512.332"><vh>help_p</vh></v>
<v t="ekr.20070417101512.333"><vh>help_pdb</vh></v>
<v t="ekr.20070417101512.334"><vh>help_pp</vh></v>
<v t="ekr.20070417101512.335"><vh>help_q</vh></v>
<v t="ekr.20070417101512.336"><vh>help_quit</vh></v>
<v t="ekr.20070417101512.337"><vh>help_r</vh></v>
<v t="ekr.20070417101512.338"><vh>help_return</vh></v>
<v t="ekr.20070417101512.339"><vh>help_s</vh></v>
<v t="ekr.20070417101512.340"><vh>help_step</vh></v>
<v t="ekr.20070417101512.341"><vh>help_tbreak</vh></v>
<v t="ekr.20070417101512.342"><vh>help_u</vh></v>
<v t="ekr.20070417101512.343"><vh>help_unalias</vh></v>
<v t="ekr.20070417101512.344"><vh>help_up</vh></v>
<v t="ekr.20070417101512.345"><vh>help_w</vh></v>
<v t="ekr.20070417101512.346"><vh>help_whatis</vh></v>
<v t="ekr.20070417101512.347"><vh>help_where</vh></v>
</v>
<v t="ekr.20070417101512.348"><vh>_runscript (called by main)</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20070417101512.171">@language python
@tabwidth -4</t>
<t tx="ekr.20070417101512.172">"""Debugger basics"""

import sys
import os
import types

__all__ = ["BdbQuit","Bdb","Breakpoint"]
</t>
<t tx="ekr.20070417101512.173">class BdbQuit(Exception):

    """Exception to give up completely"""
</t>
<t tx="ekr.20070417101512.174">class Bdb:

    """Generic Python debugger base class.

    This class takes care of details of the trace facility;
    a derived class should implement user interaction.
    The standard debugger class (pdb.Pdb) is an example.
    """
	@others
</t>
<t tx="ekr.20070417101512.175">def __init__(self):

    self.breaks = {}
        # Keys are canonic filenames.  Values are lists of breakpoints.
    self.fncache = {}
        # Keys are filenames, values are canonic filenames.
        # This reduces the number of strings generated between breakpoints.
</t>
<t tx="ekr.20070417101512.176">def canonic(self, filename):
    if filename == "&lt;" + filename[1:-1] + "&gt;":
        return filename
    canonic = self.fncache.get(filename)
    if not canonic:
        canonic = os.path.abspath(filename)
        canonic = os.path.normcase(canonic)
        self.fncache[filename] = canonic
    return canonic
</t>
<t tx="ekr.20070417101512.177">def reset(self):

    import linecache
    linecache.checkcache()
    self.botframe = None
    self.stopframe = None
    self.returnframe = None
    self.quitting = 0
</t>
<t tx="ekr.20070417101512.178">def trace_dispatch(self, frame, event, arg):
    if self.quitting:
        return # None
    if event == 'line':
        return self.dispatch_line(frame)
    if event == 'call':
        return self.dispatch_call(frame, arg)
    if event == 'return':
        return self.dispatch_return(frame, arg)
    if event == 'exception':
        return self.dispatch_exception(frame, arg)
    if event == 'c_call':
        return self.trace_dispatch
    if event == 'c_exception':
        return self.trace_dispatch
    if event == 'c_return':
        return self.trace_dispatch
    print 'bdb.Bdb.dispatch: unknown debugging event:', repr(event)
    return self.trace_dispatch
</t>
<t tx="ekr.20070417101512.179">def dispatch_line(self, frame):

    if self.stop_here(frame) or self.break_here(frame):
        self.user_line(frame)
        if self.quitting: raise BdbQuit

    return self.trace_dispatch
</t>
<t tx="ekr.20070417101512.180">def dispatch_call(self, frame, arg): # XXX 'arg' is no longer used

    if self.botframe is None:
        # First call of dispatch since reset()
        self.botframe = frame.f_back # (CT) Note that this may also be None!
        return self.trace_dispatch

    if not (self.stop_here(frame) or self.break_anywhere(frame)):
        # No need to trace this function
        return # None

    self.user_call(frame, arg)
    if self.quitting: raise BdbQuit
    return self.trace_dispatch
</t>
<t tx="ekr.20070417101512.181">def dispatch_return(self, frame, arg):

    if self.stop_here(frame) or frame == self.returnframe:
        self.user_return(frame, arg)
        if self.quitting: raise BdbQuit

    return self.trace_dispatch
</t>
<t tx="ekr.20070417101512.182">def dispatch_exception(self, frame, arg):

    if self.stop_here(frame):
        self.user_exception(frame, arg)
        if self.quitting: raise BdbQuit

    return self.trace_dispatch
</t>
<t tx="ekr.20070417101512.183"># Normally derived classes don't override the following
# methods, but they may if they want to redefine the
# definition of stopping and breakpoints.

def stop_here(self, frame):
    # (CT) stopframe may now also be None, see dispatch_call.
    # (CT) the former test for None is therefore removed from here.
    if frame is self.stopframe:
        return True
    while frame is not None and frame is not self.stopframe:
        if frame is self.botframe:
            return True
        frame = frame.f_back
    return False
</t>
<t tx="ekr.20070417101512.184">def break_here(self, frame):
    filename = self.canonic(frame.f_code.co_filename)
    if not filename in self.breaks:
        return False
    lineno = frame.f_lineno
    if not lineno in self.breaks[filename]:
        # The line itself has no breakpoint, but maybe the line is the
        # first line of a function with breakpoint set by function name.
        lineno = frame.f_code.co_firstlineno
        if not lineno in self.breaks[filename]:
            return False

    # flag says ok to delete temp. bp
    (bp, flag) = effective(filename, lineno, frame)
    if bp:
        self.currentbp = bp.number
        if (flag and bp.temporary):
            self.do_clear(str(bp.number))
        return True
    else:
        return False
</t>
<t tx="ekr.20070417101512.185">def break_anywhere(self, frame):

    return self.breaks.has_key(
        self.canonic(frame.f_code.co_filename))
</t>
<t tx="ekr.20070417101512.186">def do_clear(self, arg):
    raise NotImplementedError, "subclass of bdb must implement do_clear()"
</t>
<t tx="ekr.20070417101512.187"></t>
<t tx="ekr.20070417101512.188"># Derived classes should override the user_* methods
# to gain control.

def user_call(self, frame, argument_list):
    """This method is called when there is the remote possibility
    that we ever need to stop in this function."""
    pass
</t>
<t tx="ekr.20070417101512.189">def user_line(self, frame):
    """This method is called when we stop or break at this line."""
    pass
</t>
<t tx="ekr.20070417101512.190">def user_return(self, frame, return_value):
    """This method is called when a return trap is set here."""
    pass
</t>
<t tx="ekr.20070417101512.191">def user_exception(self, frame, (exc_type, exc_value, exc_traceback)):
    """This method is called if an exception occurs,
    but only if we are to stop at or just below this level."""
    pass
</t>
<t tx="ekr.20070417101512.192"></t>
<t tx="ekr.20070417101512.193"># Derived classes and clients can call the following methods
# to affect the stepping state.

def set_step(self):
    """Stop after one line of code."""
    self.stopframe = None
    self.returnframe = None
    self.quitting = 0
</t>
<t tx="ekr.20070417101512.194">def set_next(self, frame):
    """Stop on the next line in or below the given frame."""
    self.stopframe = frame
    self.returnframe = None
    self.quitting = 0
</t>
<t tx="ekr.20070417101512.195">def set_return(self, frame):
    """Stop when returning from the given frame."""
    self.stopframe = frame.f_back
    self.returnframe = frame
    self.quitting = 0
</t>
<t tx="ekr.20070417101512.196">def set_trace(self, frame=None):
    """Start debugging from `frame`.

    If frame is not specified, debugging starts from caller's frame.
    """
    if frame is None:
        frame = sys._getframe().f_back
    self.reset()
    while frame:
        frame.f_trace = self.trace_dispatch
        self.botframe = frame
        frame = frame.f_back
    self.set_step()
    sys.settrace(self.trace_dispatch)
</t>
<t tx="ekr.20070417101512.197">def set_continue(self):
    # Don't stop except at breakpoints or when finished
    self.stopframe = self.botframe
    self.returnframe = None
    self.quitting = 0
    if not self.breaks:
        # no breakpoints; run without debugger overhead
        sys.settrace(None)
        frame = sys._getframe().f_back
        while frame and frame is not self.botframe:
            del frame.f_trace
            frame = frame.f_back
</t>
<t tx="ekr.20070417101512.198">def set_quit(self):
    self.stopframe = self.botframe
    self.returnframe = None
    self.quitting = 1
    sys.settrace(None)
</t>
<t tx="ekr.20070417101512.199">@
Derived classes and clients can call the following methods
to manipulate breakpoints.  These methods return an
error message is something went wrong, None if all is well.

Set_break prints out the breakpoint line and file:lineno.

Call self.get_*break*() to see the breakpoints or better::

for bp in Breakpoint.bpbynumber:
    if bp: bp.bpprint().
</t>
<t tx="ekr.20070417101512.200">def set_break(self, filename, lineno, temporary=0, cond = None,
              funcname=None):
    filename = self.canonic(filename)
    import linecache # Import as late as possible
    line = linecache.getline(filename, lineno)
    if not line:
        return 'Line %s:%d does not exist' % (filename,
                               lineno)
    if not filename in self.breaks:
        self.breaks[filename] = []
    list = self.breaks[filename]
    if not lineno in list:
        list.append(lineno)
        
    # Bad design.  *This* class, not the breakpoint class,
    # should update the list of breakpoints.
    bp = Breakpoint(filename, lineno, temporary, cond, funcname)
</t>
<t tx="ekr.20070417101512.201">def clear_break(self, filename, lineno):
    filename = self.canonic(filename)
    if not filename in self.breaks:
        return 'There are no breakpoints in %s' % filename
    if lineno not in self.breaks[filename]:
        return 'There is no breakpoint at %s:%d' % (filename,
                                lineno)
    # If there's only one bp in the list for that file,line
    # pair, then remove the breaks entry
    
    # Bad design: bplist should be an ivar of *this* class.
    for bp in Breakpoint.bplist[filename, lineno][:]:
        bp.deleteMe()
    if not Breakpoint.bplist.has_key((filename, lineno)):
        self.breaks[filename].remove(lineno)
    if not self.breaks[filename]:
        del self.breaks[filename]
</t>
<t tx="ekr.20070417101512.202">def clear_bpbynumber(self, arg):
    try:
        number = int(arg)
    except:
        return 'Non-numeric breakpoint number (%s)' % arg
    try:
        bp = Breakpoint.bpbynumber[number]
    except IndexError:
        return 'Breakpoint number (%d) out of range' % number
    if not bp:
        return 'Breakpoint (%d) already deleted' % number
    self.clear_break(bp.file, bp.line)
</t>
<t tx="ekr.20070417101512.203">def clear_all_file_breaks(self, filename):
    
    filename = self.canonic(filename)
    if not filename in self.breaks:
        return 'There are no breakpoints in %s' % filename
        
     # Bad design: bplist should be an ivar of *this* class.
    for line in self.breaks[filename]:
        blist = Breakpoint.bplist[filename, line]
        for bp in blist:
            bp.deleteMe()

    del self.breaks[filename]
</t>
<t tx="ekr.20070417101512.204">def clear_all_breaks(self):
    if not self.breaks:
        return 'There are no breakpoints'
        
    # Bad design: bplist should be an ivar of *this* class.
    for bp in Breakpoint.bpbynumber:
        if bp:
            bp.deleteMe()

    self.breaks = {}
</t>
<t tx="ekr.20070417101512.205">def get_break(self, filename, lineno):

    filename = self.canonic(filename)

    return filename in self.breaks and lineno in self.breaks[filename]
</t>
<t tx="ekr.20070417101512.206">def get_breaks(self, filename, lineno):
    
    filename = self.canonic(filename)

    return (
        filename in self.breaks and 
        lineno in self.breaks[filename] and 
        Breakpoint.bplist[filename, lineno] or []
    )
</t>
<t tx="ekr.20070417101512.207">def get_file_breaks(self, filename):

    filename = self.canonic(filename)
    
    return self.breaks.get(filename,[])

    # if filename in self.breaks:
        # return self.breaks[filename]
    # else:
        # return []
</t>
<t tx="ekr.20070417101512.208">def get_all_breaks(self):

    return self.breaks
</t>
<t tx="ekr.20070417101512.209"></t>
<t tx="ekr.20070417101512.210"># Derived classes and clients can call the following method
# to get a data structure representing a stack trace.

def get_stack(self, f, t):
    
    # EKR: f is a frame, t is a traceback instance.

    stack = []
    if t and t.tb_frame is f:
        t = t.tb_next
    while f is not None:
        stack.append((f, f.f_lineno))
        if f is self.botframe:
            break
        f = f.f_back
    stack.reverse()
    i = max(0, len(stack) - 1)
    while t is not None:
        stack.append((t.tb_frame, t.tb_lineno))
        t = t.tb_next
    return stack, i
</t>
<t tx="ekr.20070417101512.211">#

def format_stack_entry(self, frame_lineno, lprefix=': '):
    import linecache, repr
    frame, lineno = frame_lineno
    filename = self.canonic(frame.f_code.co_filename)
    s = '%s(%r)' % (filename, lineno)
    if frame.f_code.co_name:
        s = s + frame.f_code.co_name
    else:
        s = s + "&lt;lambda&gt;"
    if '__args__' in frame.f_locals:
        args = frame.f_locals['__args__']
    else:
        args = None
    if args:
        s = s + repr.repr(args)
    else:
        s = s + '()'
    if '__return__' in frame.f_locals:
        rv = frame.f_locals['__return__']
        s = s + '-&gt;'
        s = s + repr.repr(rv)
    line = linecache.getline(filename, lineno)
    if line: s = s + lprefix + line.strip()
    return s
</t>
<t tx="ekr.20070417101512.212"># The following methods can be called by clients to use
# a debugger to debug a statement, given as a string.
</t>
<t tx="ekr.20070417101512.213">def run(self, cmd, globals=None, locals=None):
    if globals is None:
        import __main__
        globals = __main__.__dict__
    if locals is None:
        locals = globals
    self.reset()
    sys.settrace(self.trace_dispatch)
    if not isinstance(cmd, types.CodeType):
        cmd = cmd+'\n'
    try:
        try:
            exec cmd in globals, locals
        except BdbQuit:
            pass
    finally:
        self.quitting = 1
        sys.settrace(None)
</t>
<t tx="ekr.20070417101512.214">def runeval(self, expr, globals=None, locals=None):
    if globals is None:
        import __main__
        globals = __main__.__dict__
    if locals is None:
        locals = globals
    self.reset()
    sys.settrace(self.trace_dispatch)
    if not isinstance(expr, types.CodeType):
        expr = expr+'\n'
    try:
        try:
            return eval(expr, globals, locals)
        except BdbQuit:
            pass
    finally:
        self.quitting = 1
        sys.settrace(None)
</t>
<t tx="ekr.20070417101512.215">def runctx(self, cmd, globals, locals):
    # B/W compatibility
    self.run(cmd, globals, locals)
</t>
<t tx="ekr.20070417101512.216"># This method is more useful to debug a single function call.

def runcall(self, func, *args, **kwds):
    self.reset()
    sys.settrace(self.trace_dispatch)
    res = None
    try:
        try:
            res = func(*args, **kwds)
        except BdbQuit:
            pass
    finally:
        self.quitting = 1
        sys.settrace(None)
    return res
</t>
<t tx="ekr.20070417101512.217">class Breakpoint:

    """Breakpoint class

    Implements temporary breakpoints, ignore counts, disabling and
    (re)-enabling, and conditionals.

    Breakpoints are indexed by number through bpbynumber and by
    the file,line tuple using bplist.  The former points to a
    single instance of class Breakpoint.  The latter points to a
    list of such instances since there may be more than one
    breakpoint per line.

    """
	# XXX Keeping state in the class is a mistake -- this means
    # you cannot have more than one active Bdb instance.
    
    next = 1        # Next bp to be assigned
    bplist = {}     # indexed by (file, lineno) tuple
    bpbynumber = [None] # Each entry is None or an instance of Bpt
                # index 0 is unused, except for marking an
                # effective break .... see effective()

	@others
</t>
<t tx="ekr.20070417101512.218">def __init__(self, file, line, temporary=0, cond=None, funcname=None):
    self.funcname = funcname
    # Needed if funcname is not None.
    self.func_first_executable_line = None
    self.file = file    # This better be in canonical form!
    self.line = line
    self.temporary = temporary
    self.cond = cond
    self.enabled = 1
    self.ignore = 0
    self.hits = 0
    self.number = Breakpoint.next
    Breakpoint.next = Breakpoint.next + 1
    # Build the two lists
    self.bpbynumber.append(self)
    if self.bplist.has_key((file, line)):
        self.bplist[file, line].append(self)
    else:
        self.bplist[file, line] = [self]
</t>
<t tx="ekr.20070417101512.219">def deleteMe(self):
    index = (self.file, self.line)
    self.bpbynumber[self.number] = None   # No longer in list
    self.bplist[index].remove(self)
    if not self.bplist[index]:
        # No more bp for this f:l combo
        del self.bplist[index]
</t>
<t tx="ekr.20070417101512.220">def enable(self):
    self.enabled = 1
</t>
<t tx="ekr.20070417101512.221">def disable(self):
    self.enabled = 0
</t>
<t tx="ekr.20070417101512.222">def bpprint(self):
    if self.temporary:
        disp = 'del  '
    else:
        disp = 'keep '
    if self.enabled:
        disp = disp + 'yes'
    else:
        disp = disp + 'no '
    print '%-4dbreakpoint    %s at %s:%d' % (self.number, disp,
                         self.file, self.line)
    if self.cond:
        print '\tstop only if %s' % (self.cond,)
    if self.ignore:
        print '\tignore next %d hits' % (self.ignore)
    if (self.hits):
        if (self.hits &gt; 1): ss = 's'
        else: ss = ''
        print ('\tbreakpoint already hit %d time%s' %
               (self.hits, ss))
</t>
<t tx="ekr.20070417101512.223"></t>
<t tx="ekr.20070417101512.224">def set_trace():
    Bdb().set_trace()
</t>
<t tx="ekr.20070417101512.225">def checkfuncname(b, frame):
    """Check whether we should break here because of `b.funcname`."""
    if not b.funcname:
        # Breakpoint was set via line number.
        if b.line != frame.f_lineno:
            # Breakpoint was set at a line with a def statement and the function
            # defined is called: don't break.
            return False
        return True

    # Breakpoint set via function name.

    if frame.f_code.co_name != b.funcname:
        # It's not a function call, but rather execution of def statement.
        return False

    # We are in the right frame.
    if not b.func_first_executable_line:
        # The function is entered for the 1st time.
        b.func_first_executable_line = frame.f_lineno

    if  b.func_first_executable_line != frame.f_lineno:
        # But we are not at the first line number: don't break.
        return False
    return True
</t>
<t tx="ekr.20070417101512.226"># Determines if there is an effective (active) breakpoint at this
# line of code.  Returns breakpoint number or 0 if none
def effective(file, line, frame):
    """Determine which breakpoint for this file:line is to be acted upon.

    Called only if we know there is a bpt at this
    location.  Returns breakpoint that was triggered and a flag
    that indicates if it is ok to delete a temporary bp.

    """
    possibles = Breakpoint.bplist[file,line]
    for i in range(0, len(possibles)):
        b = possibles[i]
        if b.enabled == 0:
            continue
        if not checkfuncname(b, frame):
            continue
        # Count every hit when bp is enabled
        b.hits = b.hits + 1
        if not b.cond:
            # If unconditional, and ignoring,
            # go on to next, else break
            if b.ignore &gt; 0:
                b.ignore = b.ignore -1
                continue
            else:
                # breakpoint and marker that's ok
                # to delete if temporary
                return (b,1)
        else:
            # Conditional bp.
            # Ignore count applies only to those bpt hits where the
            # condition evaluates to true.
            try:
                val = eval(b.cond, frame.f_globals,
                       frame.f_locals)
                if val:
                    if b.ignore &gt; 0:
                        b.ignore = b.ignore -1
                        # continue
                    else:
                        return (b,1)
                # else:
                #   continue
            except:
                # if eval fails, most conservative
                # thing is to stop on breakpoint
                # regardless of ignore count.
                # Don't delete temporary,
                # as another hint to user.
                return (b,0)
    return (None, None)</t>
<t tx="ekr.20070417101512.227"></t>
<t tx="ekr.20070417101512.228">
# -------------------- testing --------------------

class Tdb(Bdb):
	@others
</t>
<t tx="ekr.20070417101512.229">def user_call(self, frame, args):
    name = frame.f_code.co_name
    if not name: name = '???'
    print '+++ call', name, args
</t>
<t tx="ekr.20070417101512.230">def user_line(self, frame):
    import linecache
    name = frame.f_code.co_name
    if not name: name = '???'
    fn = self.canonic(frame.f_code.co_filename)
    line = linecache.getline(fn, frame.f_lineno)
    print '+++', fn, frame.f_lineno, name, ':', line.strip()
</t>
<t tx="ekr.20070417101512.231">def user_return(self, frame, retval):
    print '+++ return', retval
</t>
<t tx="ekr.20070417101512.232">def user_exception(self, frame, exc_stuff):
    print '+++ exception', exc_stuff
    self.set_continue()
</t>
<t tx="ekr.20070417101512.233">def foo(n):
    print 'foo(', n, ')'
    x = bar(n*10)
    print 'bar returned', x
</t>
<t tx="ekr.20070417101512.234">def bar(a):
    print 'bar(', a, ')'
    return a/2
</t>
<t tx="ekr.20070417101512.235">def test():
    t = Tdb()
    t.run('import bdb; bdb.foo(10)')
</t>
<t tx="ekr.20070417101512.236">@first #! /usr/bin/env python

"""A Python debugger."""

# (See pdb.doc for documentation.)

&lt;&lt; imports &gt;&gt;

# Create a custom safe Repr instance and increase its maxstring.
# The default of 30 truncates error messages too easily.
_repr = Repr()
_repr.maxstring = 200
_saferepr = _repr.repr

__all__ = ["run", "pm", "Pdb", "runeval", "runctx", "runcall", "set_trace",
           "post_mortem", "help"]

@others

# When invoked as main program, invoke the debugger on a script
if __name__=='__main__':
    main()</t>
<t tx="ekr.20070417101512.237">import sys
import linecache
import cmd
import bdb
from repr import Repr
import os
import re
import pprint
import traceback
</t>
<t tx="ekr.20070417101512.238"></t>
<t tx="ekr.20070417101512.239">def find_function(funcname, filename):
    '''Find the function in a file.'''
    cre = re.compile(r'def\s+%s\s*[(]' % funcname)
        # 'def' + ws + 'funcname' + ws + '('
    try:
        fp = open(filename)
    except IOError:
        return None
    # consumer of this info expects the first line to be 1
    lineno = 1
    answer = None
    while 1:
        line = fp.readline()
        if line == '':
            break
        if cre.match(line):
            answer = funcname, filename, lineno
            break
        lineno = lineno + 1
    fp.close()
    return answer
</t>
<t tx="ekr.20070417101512.240"></t>
<t tx="ekr.20070417101512.241"># Simplified interface

def run(statement, globals=None, locals=None):
    Pdb().run(statement, globals, locals)
</t>
<t tx="ekr.20070417101512.242">def runeval(expression, globals=None, locals=None):
    return Pdb().runeval(expression, globals, locals)
</t>
<t tx="ekr.20070417101512.243">def runctx(statement, globals, locals):
    # B/W compatibility
    run(statement, globals, locals)
</t>
<t tx="ekr.20070417101512.244">def runcall(*args, **kwds):
    return Pdb().runcall(*args, **kwds)
</t>
<t tx="ekr.20070417101512.245">def set_trace():
    Pdb().set_trace(sys._getframe().f_back)
</t>
<t tx="ekr.20070417101512.246"></t>
<t tx="ekr.20070417101512.247"># Post-Mortem interface

def post_mortem(t):
    p = Pdb()
    p.reset()
    while t.tb_next is not None:
        t = t.tb_next
    p.interaction(t.tb_frame, t)
</t>
<t tx="ekr.20070417101512.248">def pm():
    post_mortem(sys.last_traceback)
</t>
<t tx="ekr.20070417101512.249"></t>
<t tx="ekr.20070417101512.250"># Main program for testing

TESTCMD = 'import x; x.main()'

def test():
    run(TESTCMD)
</t>
<t tx="ekr.20070417101512.251"># print help
def help():
    for dirname in sys.path:
        fullname = os.path.join(dirname, 'pdb.doc')
        if os.path.exists(fullname):
            sts = os.system('${PAGER-more} '+fullname)
            if sts: print '*** Pager exit status:', sts
            break
    else:
        print 'Sorry, can\'t find the help file "pdb.doc"',
        print 'along the Python search path'
</t>
<t tx="ekr.20070417101512.252">def main():
    if not sys.argv[1:]:
        print "usage: pdb.py scriptfile [arg] ..."
        sys.exit(2)

    mainpyfile =  sys.argv[1]     # Get script filename
    if not os.path.exists(mainpyfile):
        print 'Error:', mainpyfile, 'does not exist'
        sys.exit(1)

    del sys.argv[0]         # Hide "pdb.py" from argument list

    # Replace pdb's dir with script's dir in front of module search path.
    sys.path[0] = os.path.dirname(mainpyfile)

    # Note on saving/restoring sys.argv: it's a good idea when sys.argv was
    # modified by the script being debugged. It's a bad idea when it was
    # changed by the user from the command line. The best approach would be to
    # have a "restart" command which would allow explicit specification of
    # command line arguments.
    pdb = Pdb()
    while 1:
        try:
            pdb._runscript(mainpyfile)
            if pdb._user_requested_quit:
                break
            print "The program finished and will be restarted"
        except SystemExit:
            # In most cases SystemExit does not warrant a post-mortem session.
            print "The program exited via sys.exit(). Exit status: ",
            print sys.exc_info()[1]
        except:
            traceback.print_exc()
            print "Uncaught exception. Entering post mortem debugging"
            print "Running 'cont' or 'step' will restart the program"
            t = sys.exc_info()[2]
            while t.tb_next is not None:
                t = t.tb_next
            pdb.interaction(t.tb_frame,t)
            print "Post mortem debugger finished. The "+mainpyfile+" will be restarted"
</t>
<t tx="ekr.20070417101512.253"># Interaction prompt line will separate file and call info from code
# text using value of line_prefix string.  A newline and arrow may
# be to your liking.  You can set it once pdb is imported using the
# command "pdb.line_prefix = '\n% '".
# line_prefix = ': '    # Use this to get the old situation back
line_prefix = '\n-&gt; '   # Probably a better default

class Pdb(bdb.Bdb, cmd.Cmd):
	@others
</t>
<t tx="ekr.20070417101512.254">def __init__(self):

    bdb.Bdb.__init__(self)
    cmd.Cmd.__init__(self)
    self.prompt = '(Pdb) '
    self.aliases = {}
    self.mainpyfile = ''
    self._wait_for_mainpyfile = 0

    ### EKR: this has no effect!
    # Try to load readline if it exists
    try:
        import readline
    except ImportError:
        pass

    # Read $HOME/.pdbrc and ./.pdbrc
    # EKR: put them in self.rcLines.
    self.rcLines = []
    if 'HOME' in os.environ:
        envHome = os.environ['HOME']
        try:
            rcFile = open(os.path.join(envHome, ".pdbrc"))
        except IOError:
            pass
        else:
            for line in rcFile.readlines():
                self.rcLines.append(line)
            rcFile.close()
    try:
        rcFile = open(".pdbrc")
    except IOError:
        pass
    else:
        for line in rcFile.readlines():
            self.rcLines.append(line)
        rcFile.close()
</t>
<t tx="ekr.20070417101512.255"># EKR: called by corresponding Bdb.dispatch_xxx methods.</t>
<t tx="ekr.20070417101512.256"># Override Bdb methods

def user_call(self, frame, argument_list):

    """Called when there is the remote possibility
    that we ever need to stop in this function."""

    if self._wait_for_mainpyfile:
        return

    if self.stop_here(frame):
        print '--Call--'
        self.interaction(frame, None)
</t>
<t tx="ekr.20070417101512.257">def user_line(self, frame):

    """Called when we stop or break at this line."""

    if self._wait_for_mainpyfile:
        if (
            self.mainpyfile != self.canonic(frame.f_code.co_filename)
            or frame.f_lineno&lt;= 0
        ):
            return

        self._wait_for_mainpyfile = 0

    self.interaction(frame, None)
</t>
<t tx="ekr.20070417101512.258">def user_return(self, frame, return_value):

    """Called when a return trap is set here."""

    frame.f_locals['__return__'] = return_value

    print '--Return--'

    self.interaction(frame, None)
</t>
<t tx="ekr.20070417101512.259">def user_exception(self, frame, (exc_type, exc_value, exc_traceback)):

    """Called if an exception occurs,
    but only if we are to stop at or just below this level."""

    frame.f_locals['__exception__'] = exc_type, exc_value

    if type(exc_type) == type(''):
        exc_type_name = exc_type
    else:
        exc_type_name = exc_type.__name__
    
    print exc_type_name + ':', _saferepr(exc_value)
    self.interaction(frame, exc_traceback)
</t>
<t tx="ekr.20070417101512.260"># General interaction function

def interaction(self, frame, traceback):
    self.setup(frame, traceback)
    self.print_stack_entry(self.stack[self.curindex])
    self.cmdloop() # cmdloop is a Cmd method.
    self.forget()
</t>
<t tx="ekr.20070417101512.261">def reset(self):

    bdb.Bdb.reset(self)
    self.forget()
</t>
<t tx="ekr.20070417101512.262">def setup(self, f, t):
    
    # EKR: f is a frame, t is a traceback.

    self.forget()
    self.stack, self.curindex = self.get_stack(f, t) # get_stack is a Bdb method.
    self.curframe = self.stack[self.curindex][0]
    self.execRcLines()
</t>
<t tx="ekr.20070417101512.263">def forget(self):

    self.lineno = None
    self.stack = []
    self.curindex = 0
    self.curframe = None
</t>
<t tx="ekr.20070417101512.264"># Can be executed earlier than 'setup' if desired
def execRcLines(self):
    if self.rcLines:
        # Make local copy because of recursion
        rcLines = self.rcLines
        # executed only once
        self.rcLines = []
        for line in rcLines:
            line = line[:-1]
            if len(line) &gt; 0 and line[0] != '#':
                self.onecmd(line)
</t>
<t tx="ekr.20070417101512.265"></t>
<t tx="ekr.20070417101512.266">def default(self, line):

    if line[:1] == '!': line = line[1:]
    locals = self.curframe.f_locals
    globals = self.curframe.f_globals

    try:
        code = compile(line + '\n', '&lt;stdin&gt;', 'single')
        exec code in globals, locals
    except:
        t, v = sys.exc_info()[:2]
        if type(t) == type(''):
            exc_type_name = t
        else: exc_type_name = t.__name__
        print '***', exc_type_name + ':', v
</t>
<t tx="ekr.20070417101512.267">def precmd(self, line):

    """Handle alias expansion and ';;' separator."""

    if not line.strip():
        return line
    args = line.split()
    while args[0] in self.aliases:
        line = self.aliases[args[0]]
        ii = 1
        for tmpArg in args[1:]:
            line = line.replace("%" + str(ii),
                                  tmpArg)
            ii = ii + 1
        line = line.replace("%*", ' '.join(args[1:]))
        args = line.split()
    # split into ';;' separated commands
    # unless it's an alias command
    if args[0] != 'alias':
        marker = line.find(';;')
        if marker &gt;= 0:
            # queue up everything after marker
            next = line[marker+2:].lstrip()
            self.cmdqueue.append(next)
            line = line[:marker].rstrip()
    return line
</t>
<t tx="ekr.20070417101512.268"># Command definitions, called by cmdloop()
# The argument is the remaining string on the command line
# Return true (or 1) to exit from the command loop

@others

do_a = do_args
do_b = do_break
do_bt = do_where
do_c = do_cont = do_continue
do_cl = do_clear # 'c' is already an abbreviation for 'continue'
do_d = do_down
do_exit = do_quit
do_h = cmd.Cmd.do_help
do_j = do_jump
do_l = do_list
do_n = do_next
do_q = do_quit
do_r = do_return
do_s = do_step
do_u = do_up
do_w = do_where</t>
<t tx="ekr.20070417101512.269">def do_alias(self, arg):
    args = arg.split()
    if len(args) == 0:
        keys = self.aliases.keys()
        keys.sort()
        for alias in keys:
            print "%s = %s" % (alias, self.aliases[alias])
        return
    if args[0] in self.aliases and len(args) == 1:
        print "%s = %s" % (args[0], self.aliases[args[0]])
    else:
        self.aliases[args[0]] = ' '.join(args[1:])
</t>
<t tx="ekr.20070417101512.270">def do_args(self, arg):
    f = self.curframe
    co = f.f_code
    dict = f.f_locals
    n = co.co_argcount
    if co.co_flags &amp; 4: n = n+1
    if co.co_flags &amp; 8: n = n+1
    for i in range(n):
        name = co.co_varnames[i]
        print name, '=',
        if name in dict: print dict[name]
        else: print "*** undefined ***"
</t>
<t tx="ekr.20070417101512.271">def do_break(self, arg, temporary = 0):
    # break [ ([filename:]lineno | function) [, "condition"] ]
    if not arg:
        if self.breaks:  # There's at least one
            print "Num Type         Disp Enb   Where"
            for bp in bdb.Breakpoint.bpbynumber:
                if bp:
                    bp.bpprint()
        return
    # parse arguments; comma has lowest precedence
    # and cannot occur in filename
    filename = None
    lineno = None
    cond = None
    comma = arg.find(',')
    if comma &gt; 0:
        # parse stuff after comma: "condition"
        cond = arg[comma+1:].lstrip()
        arg = arg[:comma].rstrip()
    # parse stuff before comma: [filename:]lineno | function
    colon = arg.rfind(':')
    funcname = None
    if colon &gt;= 0:
        filename = arg[:colon].rstrip()
        f = self.lookupmodule(filename)
        if not f:
            print '*** ', repr(filename),
            print 'not found from sys.path'
            return
        else:
            filename = f
        arg = arg[colon+1:].lstrip()
        try:
            lineno = int(arg)
        except ValueError, msg:
            print '*** Bad lineno:', arg
            return
    else:
        # no colon; can be lineno or function
        try:
            lineno = int(arg)
        except ValueError:
            try:
                func = eval(arg,
                            self.curframe.f_globals,
                            self.curframe.f_locals)
            except:
                func = arg
            try:
                if hasattr(func, 'im_func'):
                    func = func.im_func
                code = func.func_code
                #use co_name to identify the bkpt (function names
                #could be aliased, but co_name is invariant)
                funcname = code.co_name
                lineno = code.co_firstlineno
                filename = code.co_filename
            except:
                # last thing to try
                (ok, filename, ln) = self.lineinfo(arg)
                if not ok:
                    print '*** The specified object',
                    print repr(arg),
                    print 'is not a function'
                    print ('or was not found '
                           'along sys.path.')
                    return
                funcname = ok # ok contains a function name
                lineno = int(ln)
    if not filename:
        filename = self.defaultFile()
    # Check for reasonable breakpoint
    line = self.checkline(filename, lineno)
    if line:
        # now set the break point
        err = self.set_break(filename, line, temporary, cond, funcname)
        if err: print '***', err
        else:
            bp = self.get_breaks(filename, line)[-1]
            print "Breakpoint %d at %s:%d" % (
                bp.number,bp.file,bp.line)
</t>
<t tx="ekr.20070417101512.272">def checkline(self, filename, lineno):
    """Check whether specified line seems to be executable.

    Return `lineno` if it is, 0 if not (e.g. a docstring, comment, blank
    line or EOF). Warning: testing is not comprehensive.
    """
    line = linecache.getline(filename, lineno)
    if not line:
        print 'End of file'
        return 0
    line = line.strip()
    # Don't allow setting breakpoint at a blank line
    if (not line or (line[0] == '#') or
         (line[:3] == '"""') or line[:3] == "'''"):
        print '*** Blank or comment'
        return 0
    return lineno
</t>
<t tx="ekr.20070417101512.273">def lineinfo(self, identifier):
    failed = (None, None, None)
    # Input is identifier, may be in single quotes
    idstring = identifier.split("'")
    if len(idstring) == 1:
        # not in single quotes
        id = idstring[0].strip()
    elif len(idstring) == 3:
        # quoted
        id = idstring[1].strip()
    else:
        return failed
    if id == '': return failed
    parts = id.split('.')
    # Protection for derived debuggers
    if parts[0] == 'self':
        del parts[0]
        if len(parts) == 0:
            return failed
    # Best first guess at file to look at
    fname = self.defaultFile()
    if len(parts) == 1:
        item = parts[0]
    else:
        # More than one part.
        # First is module, second is method/class
        f = self.lookupmodule(parts[0])
        if f:
            fname = f
        item = parts[1]
    answer = find_function(item, fname)
    return answer or failed
</t>
<t tx="ekr.20070417101512.274"># To be overridden in derived debuggers
def defaultFile(self):
    """Produce a reasonable default."""
    filename = self.curframe.f_code.co_filename
    if filename == '&lt;string&gt;' and self.mainpyfile:
        filename = self.mainpyfile
    return filename
</t>
<t tx="ekr.20070417101512.275">def lookupmodule(self, filename):
    """Helper function for break/clear parsing -- may be overridden.

    lookupmodule() translates (possibly incomplete) file or module name
    into an absolute file name.
    """
    if os.path.isabs(filename) and  os.path.exists(filename):
        return filename
    f = os.path.join(sys.path[0], filename)
    if  os.path.exists(f) and self.canonic(f) == self.mainpyfile:
        return f
    root, ext = os.path.splitext(filename)
    if ext == '':
        filename = filename + '.py'
    if os.path.isabs(filename):
        return filename
    for dirname in sys.path:
        while os.path.islink(dirname):
            dirname = os.readlink(dirname)
        fullname = os.path.join(dirname, filename)
        if os.path.exists(fullname):
            return fullname
    return None
</t>
<t tx="ekr.20070417101512.276">def do_clear(self, arg):
    """Three possibilities, tried in this order:
    clear -&gt; clear all breaks, ask for confirmation
    clear file:lineno -&gt; clear all breaks at file:lineno
    clear bpno bpno ... -&gt; clear breakpoints by number"""
    if not arg:
        try:
            reply = raw_input('Clear all breaks? ')
        except EOFError:
            reply = 'no'
        reply = reply.strip().lower()
        if reply in ('y', 'yes'):
            self.clear_all_breaks()
        return
    if ':' in arg:
        # Make sure it works for "clear C:\foo\bar.py:12"
        i = arg.rfind(':')
        filename = arg[:i]
        arg = arg[i+1:]
        try:
            lineno = int(arg)
        except:
            err = "Invalid line number (%s)" % arg
        else:
            err = self.clear_break(filename, lineno)
        if err: print '***', err
        return
    numberlist = arg.split()
    for i in numberlist:
        err = self.clear_bpbynumber(i)
        if err:
            print '***', err
        else:
            print 'Deleted breakpoint %s ' % (i,)
</t>
<t tx="ekr.20070417101512.277">def do_condition(self, arg):

    # arg is breakpoint number and condition
    args = arg.split(' ', 1)
    bpnum = int(args[0].strip())
    try:
        cond = args[1]
    except:
        cond = None
    bp = bdb.Breakpoint.bpbynumber[bpnum]
    if bp:
        bp.cond = cond
        if not cond:
            print 'Breakpoint', bpnum,
            print 'is now unconditional.'
</t>
<t tx="ekr.20070417101512.278">def do_continue(self, arg):
    self.set_continue()
    return 1
</t>
<t tx="ekr.20070417101512.279">def do_debug(self, arg):

    sys.settrace(None)
    globals = self.curframe.f_globals
    locals = self.curframe.f_locals
    p = Pdb()
    p.prompt = "(%s) " % self.prompt.strip()
    print "ENTERING RECURSIVE DEBUGGER"
    sys.call_tracing(p.run, (arg, globals, locals))
    print "LEAVING RECURSIVE DEBUGGER"
    sys.settrace(self.trace_dispatch)
    self.lastcmd = p.lastcmd
</t>
<t tx="ekr.20070417101512.280">def do_disable(self, arg):
    args = arg.split()
    for i in args:
        try:
            i = int(i)
        except ValueError:
            print 'Breakpoint index %r is not a number' % i
            continue

        if not (0 &lt;= i &lt; len(bdb.Breakpoint.bpbynumber)):
            print 'No breakpoint numbered', i
            continue

        bp = bdb.Breakpoint.bpbynumber[i]
        if bp:
            bp.disable()
</t>
<t tx="ekr.20070417101512.281">def do_down(self, arg):

    if self.curindex + 1 == len(self.stack):
        print '*** Newest frame'
    else:
        self.curindex = self.curindex + 1
        self.curframe = self.stack[self.curindex][0]
        self.print_stack_entry(self.stack[self.curindex])
        self.lineno = None
</t>
<t tx="ekr.20070417101512.282">def do_enable(self, arg):

    args = arg.split()
    for i in args:
        try:
            i = int(i)
        except ValueError:
            print 'Breakpoint index %r is not a number' % i
            continue

        if not (0 &lt;= i &lt; len(bdb.Breakpoint.bpbynumber)):
            print 'No breakpoint numbered', i
            continue

        bp = bdb.Breakpoint.bpbynumber[i]
        if bp:
            bp.enable()
</t>
<t tx="ekr.20070417101512.283">def do_EOF(self, arg):
    print
    self._user_requested_quit = 1
    self.set_quit()
    return 1
</t>
<t tx="ekr.20070417101512.284">def do_ignore(self,arg):

    """arg is bp number followed by ignore count."""
    args = arg.split()
    bpnum = int(args[0].strip())
    try:
        count = int(args[1].strip())
    except:
        count = 0
    bp = bdb.Breakpoint.bpbynumber[bpnum]
    if bp:
        bp.ignore = count
        if count &gt; 0:
            reply = 'Will ignore next '
            if count &gt; 1:
                reply = reply + '%d crossings' % count
            else:
                reply = reply + '1 crossing'
            print reply + ' of breakpoint %d.' % bpnum
        else:
            print 'Will stop next time breakpoint',
            print bpnum, 'is reached.'
</t>
<t tx="ekr.20070417101512.285">def do_jump(self, arg):

    if self.curindex + 1 != len(self.stack):
        print "*** You can only jump within the bottom frame"
        return
    try:
        arg = int(arg)
    except ValueError:
        print "*** The 'jump' command requires a line number."
    else:
        try:
            # Do the jump, fix up our copy of the stack, and display the
            # new position
            self.curframe.f_lineno = arg
            self.stack[self.curindex] = self.stack[self.curindex][0], arg
            self.print_stack_entry(self.stack[self.curindex])
        except ValueError, e:
            print '*** Jump failed:', e
</t>
<t tx="ekr.20070417101512.286">def do_list(self, arg): # Arg is the rest of the command line, i.e., the list count.

    self.lastcmd = 'list'
    &lt;&lt; compute the first &amp; last line counts &gt;&gt;

    filename = self.curframe.f_code.co_filename
    breaklist = self.get_file_breaks(filename)

    try:
        for lineno in range(first, last+1):
            line = linecache.getline(filename, lineno)
            if not line:
                print '[EOF]'
                break
            else:
                s = repr(lineno).rjust(3)
                if len(s) &lt; 4: s = s + ' '
                if lineno in breaklist: s = s + 'B'
                else: s = s + ' '
                if lineno == self.curframe.f_lineno:
                    s = s + '-&gt;'
                print s + '\t' + line,
                self.lineno = lineno
    except KeyboardInterrupt:
        pass
</t>
<t tx="ekr.20070417101512.287">last = None
if arg:
    try:
        x = eval(arg, {}, {})
        if type(x) == type(()):
            first, last = x
            first = int(first)
            last = int(last)
            if last &lt; first:
                # Assume it's a count
                last = first + last
        else:
            first = max(1, int(x) - 5)
    except:
        print '*** Error in argument:', repr(arg)
        return
elif self.lineno is None:
    first = max(1, self.curframe.f_lineno - 5)
else:
    first = self.lineno + 1
if last is None:
    last = first + 10</t>
<t tx="ekr.20070417101512.288">def do_next(self, arg):

    self.set_next(self.curframe)
    return 1
</t>
<t tx="ekr.20070417101512.289">def do_p(self, arg):
    try:
        print repr(self._getval(arg))
    except:
        pass
</t>
<t tx="ekr.20070417101512.290">def do_pp(self, arg):
    try:
        pprint.pprint(self._getval(arg))
    except:
        pass
</t>
<t tx="ekr.20070417101512.291">def do_quit(self, arg):
    self._user_requested_quit = 1
    self.set_quit()
    return 1
</t>
<t tx="ekr.20070417101512.292">def do_return(self, arg):

    self.set_return(self.curframe)
    return 1
</t>
<t tx="ekr.20070417101512.293">def do_retval(self, arg):
    if '__return__' in self.curframe.f_locals:
        print self.curframe.f_locals['__return__']
    else:
        print '*** Not yet returned!'
</t>
<t tx="ekr.20070417101512.294">do_rv = do_retval

def _getval(self, arg):
    try:
        return eval(arg, self.curframe.f_globals,
                    self.curframe.f_locals)
    except:
        t, v = sys.exc_info()[:2]
        if isinstance(t, str):
            exc_type_name = t
        else: exc_type_name = t.__name__
        print '***', exc_type_name + ':', repr(v)
        raise
</t>
<t tx="ekr.20070417101512.295">def do_step(self, arg):

    self.set_step()
    return 1
</t>
<t tx="ekr.20070417101512.296">def do_tbreak(self, arg):

    self.do_break(arg, temporary = 1)
</t>
<t tx="ekr.20070417101512.297">def do_unalias(self, arg):
    args = arg.split()
    if len(args) == 0: return
    if args[0] in self.aliases:
        del self.aliases[args[0]]
</t>
<t tx="ekr.20070417101512.298">def do_up(self, arg):

    if self.curindex == 0:
        print '*** Oldest frame'
    else:
        self.curindex = self.curindex - 1
        self.curframe = self.stack[self.curindex][0]
        self.print_stack_entry(self.stack[self.curindex])
        self.lineno = None


</t>
<t tx="ekr.20070417101512.299">def do_whatis(self, arg):
    try:
        value = eval(arg, self.curframe.f_globals,
                        self.curframe.f_locals)
    except:
        t, v = sys.exc_info()[:2]
        if type(t) == type(''):
            exc_type_name = t
        else: exc_type_name = t.__name__
        print '***', exc_type_name + ':', repr(v)
        return
    code = None
    # Is it a function?
    try: code = value.func_code
    except: pass
    if code:
        print 'Function', code.co_name
        return
    # Is it an instance method?
    try: code = value.im_func.func_code
    except: pass
    if code:
        print 'Method', code.co_name
        return
    # None of the above...
    print type(value)
</t>
<t tx="ekr.20070417101512.300">def do_where(self, arg):
    self.print_stack_trace()
</t>
<t tx="ekr.20070417101512.301"></t>
<t tx="ekr.20070417101512.302">def print_stack_entry(self, frame_lineno, prompt_prefix=line_prefix):
    frame, lineno = frame_lineno
    if frame is self.curframe:
        print '&gt;',
    else:
        print ' ',
    print self.format_stack_entry(frame_lineno, prompt_prefix)
</t>
<t tx="ekr.20070417101512.303"># Print a traceback starting at the top stack frame.
# The most recently entered frame is printed last;
# this is different from dbx and gdb, but consistent with
# the Python interpreter's stack trace.
# It is also consistent with the up/down commands (which are
# compatible with dbx and gdb: up moves towards 'main()'
# and down moves towards the most recent stack frame).

def print_stack_trace(self):

    try:
        for frame_lineno in self.stack:
            self.print_stack_entry(frame_lineno)
    except KeyboardInterrupt:
        pass
</t>
<t tx="ekr.20070417101512.304"></t>
<t tx="ekr.20070417101512.305">def help_a(self):
    print """a(rgs)
Print the arguments of the current function."""
</t>
<t tx="ekr.20070417101512.306">def help_alias(self):
    print """alias [name [command [parameter parameter ...] ]]
Creates an alias called 'name' the executes 'command'.  The command
must *not* be enclosed in quotes.  Replaceable parameters are
indicated by %1, %2, and so on, while %* is replaced by all the
parameters.  If no command is given, the current alias for name
is shown. If no name is given, all aliases are listed.

Aliases may be nested and can contain anything that can be
legally typed at the pdb prompt.  Note!  You *can* override
internal pdb commands with aliases!  Those internal commands
are then hidden until the alias is removed.  Aliasing is recursively
applied to the first word of the command line; all other words
in the line are left alone.

Some useful aliases (especially when placed in the .pdbrc file) are:

#Print instance variables (usage "pi classInst")
alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]

#Print instance variables in self
alias ps pi self
"""
</t>
<t tx="ekr.20070417101512.307">def help_args(self):
    self.help_a()
</t>
<t tx="ekr.20070417101512.308">def help_b(self):
    print """b(reak) ([file:]lineno | function) [, condition]
With a line number argument, set a break there in the current
file.  With a function name, set a break at first executable line
of that function.  Without argument, list all breaks.  If a second
argument is present, it is a string specifying an expression
which must evaluate to true before the breakpoint is honored.

The line number may be prefixed with a filename and a colon,
to specify a breakpoint in another file (probably one that
hasn't been loaded yet).  The file is searched for on sys.path;
the .py suffix may be omitted."""
</t>
<t tx="ekr.20070417101512.309">def help_break(self):
    self.help_b()
</t>
<t tx="ekr.20070417101512.310">def help_c(self):
    print """c(ont(inue))
Continue execution, only stop when a breakpoint is encountered."""
</t>
<t tx="ekr.20070417101512.311">def help_cl(self):
    print "cl(ear) filename:lineno"
    print """cl(ear) [bpnumber [bpnumber...]]
With a space separated list of breakpoint numbers, clear
those breakpoints.  Without argument, clear all breaks (but
first ask confirmation).  With a filename:lineno argument,
clear all breaks at that line in that file.

Note that the argument is different from previous versions of
the debugger (in python distributions 1.5.1 and before) where
a linenumber was used instead of either filename:lineno or
breakpoint numbers."""
</t>
<t tx="ekr.20070417101512.312">def help_clear(self):
    self.help_cl()
</t>
<t tx="ekr.20070417101512.313">def help_condition(self):
    print """condition bpnumber str_condition
str_condition is a string specifying an expression which
must evaluate to true before the breakpoint is honored.
If str_condition is absent, any existing condition is removed;
i.e., the breakpoint is made unconditional."""
</t>
<t tx="ekr.20070417101512.314">def help_cont(self):
    self.help_c()
</t>
<t tx="ekr.20070417101512.315">def help_continue(self):
    self.help_c()
</t>
<t tx="ekr.20070417101512.316">def help_d(self):
    print """d(own)
Move the current frame one level down in the stack trace
(to a newer frame)."""
</t>
<t tx="ekr.20070417101512.317">def help_debug(self):
    print """debug code
Enter a recursive debugger that steps through the code argument
(which is an arbitrary expression or statement to be executed
in the current environment)."""
</t>
<t tx="ekr.20070417101512.318">def help_disable(self):
    print """disable bpnumber [bpnumber ...]
Disables the breakpoints given as a space separated list of
bp numbers."""
</t>
<t tx="ekr.20070417101512.319">help_bt = help_w

def help_down(self):
    self.help_d()
</t>
<t tx="ekr.20070417101512.320">def help_enable(self):
    print """enable bpnumber [bpnumber ...]
Enables the breakpoints given as a space separated list of
bp numbers."""
</t>
<t tx="ekr.20070417101512.321">def help_EOF(self):
    print """EOF
Handles the receipt of EOF as a command."""
</t>
<t tx="ekr.20070417101512.322">def help_exec(self):
    print """(!) statement
Execute the (one-line) statement in the context of
the current stack frame.
The exclamation point can be omitted unless the first word
of the statement resembles a debugger command.
To assign to a global variable you must always prefix the
command with a 'global' command, e.g.:
(Pdb) global list_options; list_options = ['-l']
(Pdb)"""
</t>
<t tx="ekr.20070417101512.323">def help_h(self):
    print """h(elp)
Without argument, print the list of available commands.
With a command name as argument, print help about that command
"help pdb" pipes the full documentation file to the $PAGER
"help exec" gives help on the ! command"""
</t>
<t tx="ekr.20070417101512.324"># Help methods (derived from pdb.doc)

def help_help(self):
    self.help_h()
</t>
<t tx="ekr.20070417101512.325">def help_ignore(self):
    print """ignore bpnumber count
Sets the ignore count for the given breakpoint number.  A breakpoint
becomes active when the ignore count is zero.  When non-zero, the
count is decremented each time the breakpoint is reached and the
breakpoint is not disabled and any associated condition evaluates
to true."""
</t>
<t tx="ekr.20070417101512.326">def help_j(self):
    print """j(ump) lineno
Set the next line that will be executed."""
</t>
<t tx="ekr.20070417101512.327">def help_jump(self):
    self.help_j()
</t>
<t tx="ekr.20070417101512.328">def help_l(self):
    print """l(ist) [first [,last]]
List source code for the current file.
Without arguments, list 11 lines around the current line
or continue the previous listing.
With one argument, list 11 lines starting at that line.
With two arguments, list the given range;
if the second argument is less than the first, it is a count."""
</t>
<t tx="ekr.20070417101512.329">def help_list(self):
    self.help_l()
</t>
<t tx="ekr.20070417101512.330">def help_n(self):
    print """n(ext)
Continue execution until the next line in the current function
is reached or it returns."""
</t>
<t tx="ekr.20070417101512.331">def help_next(self):
    self.help_n()
</t>
<t tx="ekr.20070417101512.332">def help_p(self):
    print """p expression
Print the value of the expression."""
</t>
<t tx="ekr.20070417101512.333">def help_pdb(self):
    help()
</t>
<t tx="ekr.20070417101512.334">def help_pp(self):
    print """pp expression
Pretty-print the value of the expression."""
</t>
<t tx="ekr.20070417101512.335">def help_q(self):
    print """q(uit) or exit - Quit from the debugger.
The program being executed is aborted."""
</t>
<t tx="ekr.20070417101512.336">def help_quit(self):
    self.help_q()
</t>
<t tx="ekr.20070417101512.337">def help_r(self):
    print """r(eturn)
Continue execution until the current function returns."""
</t>
<t tx="ekr.20070417101512.338">def help_return(self):
    self.help_r()
</t>
<t tx="ekr.20070417101512.339">def help_s(self):
    print """s(tep)
Execute the current line, stop at the first possible occasion
(either in a function that is called or in the current function)."""
</t>
<t tx="ekr.20070417101512.340">def help_step(self):
    self.help_s()
</t>
<t tx="ekr.20070417101512.341">def help_tbreak(self):
    print """tbreak  same arguments as break, but breakpoint is
removed when first hit."""
</t>
<t tx="ekr.20070417101512.342">def help_u(self):
    print """u(p)
Move the current frame one level up in the stack trace
(to an older frame)."""
</t>
<t tx="ekr.20070417101512.343">def help_unalias(self):
    print """unalias name
Deletes the specified alias."""
</t>
<t tx="ekr.20070417101512.344">def help_up(self):
    self.help_u()
</t>
<t tx="ekr.20070417101512.345">def help_w(self):
    print """w(here)
Print a stack trace, with the most recent frame at the bottom.
An arrow indicates the "current frame", which determines the
context of most commands.  'bt' is an alias for this command."""
</t>
<t tx="ekr.20070417101512.346">help_exit = help_q

def help_whatis(self):
    print """whatis arg
Prints the type of the argument."""
</t>
<t tx="ekr.20070417101512.347">def help_where(self):
    self.help_w()
</t>
<t tx="ekr.20070417101512.348">def _runscript(self, filename):
    # Start with fresh empty copy of globals and locals and tell the script
    # that it's being run as __main__ to avoid scripts being able to access
    # the pdb.py namespace.
    globals_ = {"__name__" : "__main__"}
    locals_ = globals_

    # When bdb sets tracing, a number of call and line events happens
    # BEFORE debugger even reaches user's code (and the exact sequence of
    # events depends on python version). So we take special measures to
    # avoid stopping before we reach the main script (see user_line and
    # user_call for details).
    self._wait_for_mainpyfile = 1
    self.mainpyfile = self.canonic(filename)
    self._user_requested_quit = 0
    statement = 'execfile( "%s")' % filename
    self.run(statement, globals=globals_, locals=locals_)
</t>
<t tx="ekr.20070417101519"></t>
<t tx="ekr.20070417101519.1">trash</t>
<t tx="ekr.20070417101711">@
This is a study outline.  Generate code from this file at your own risk.
EKR made minor reorg mods to the code.

The (original, not mine) comment in the node:

originals--&gt;Python24/Lib/bdb(orig).py--&gt;class Breakpoint

states that the Breakpoint class is badly designed. This comment is correct. It
would be much better to replace the class ivars of the Breakpoint class with
ivars of the Bdb class. For example, there is a lot of code in Pdb class that
could be simplified.
</t>
</tnodes>
</leo_file>
