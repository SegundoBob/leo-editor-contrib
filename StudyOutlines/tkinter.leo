<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="616" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="22" left="44" height="793" width="942"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="ekr.20041012114208" a="TV"><vh>Read me</vh></v>
<v t="ekr.20041012114208.1" a="E"><vh>EKR Notes</vh>
<v t="ekr.20041012114208.2"><vh>&lt;&lt; Tkinter doc string &gt;&gt;</vh></v>
<v t="ekr.20041012114208.3"><vh>top down notes</vh></v>
<v t="ekr.20041012114208.4"><vh>bottom up notes</vh>
<v t="ekr.20041012114208.5"><vh>self.tk</vh></v>
<v t="ekr.20041012114208.6"><vh>tk.call</vh></v>
<v t="ekr.20041012114208.7"><vh>conversions</vh></v>
<v t="ekr.20041012114208.8"><vh>tk.setvar &amp; tk.getvar</vh></v>
<v t="ekr.20041012114208.9"><vh>tk.createcommand &amp;tk.deletecommand</vh></v>
<v t="ekr.20041012114208.10"><vh>self.tk.mainloop(n) &amp; self.tk.quit</vh></v>
</v>
</v>
<v t="ekr.20041012114208.11"><vh> _tkinter.c (In Modules)</vh>
<v t="ekr.20041012114208.12"><vh> &lt;&lt; _tkinter includes &gt;&gt;</vh></v>
<v t="ekr.20041012114208.13"><vh>&lt;&lt; _tkinter declarations &gt;&gt;</vh>
<v t="ekr.20041012114208.14"><vh>&lt;&lt; Thread declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20041012114208.15" a="M"><vh>Binding table</vh></v>
<v t="ekr.20041012114208.16"><vh>Tkinter_Error</vh></v>
<v t="ekr.20041012114208.17"><vh>Utils...</vh>
<v t="ekr.20041012114208.18"><vh>Sleep</vh></v>
<v t="ekr.20041012114208.19"><vh>AsString</vh></v>
<v t="ekr.20041012114208.20"><vh>Merge</vh></v>
<v t="ekr.20041012114208.21"><vh>Split</vh></v>
</v>
<v t="ekr.20041012114208.22"><vh>TkApp object...</vh>
<v t="ekr.20041012114208.23"><vh>Tcl_AppInit</vh></v>
<v t="ekr.20041012114208.24"><vh>Tkapp_New</vh></v>
<v t="ekr.20041012114208.25"><vh>Tcl Eval</vh>
<v t="ekr.20041012114208.26"><vh>AsObj</vh></v>
<v t="ekr.20041012114208.27"><vh>Tkapp_Call (tk.call)</vh></v>
<v t="ekr.20041012114208.28"><vh>Tkapp_Call</vh></v>
</v>
<v t="ekr.20041012114208.29"><vh>Tkapp_GlobalCall</vh></v>
<v t="ekr.20041012114208.30"><vh>Tkapp_Eval</vh></v>
<v t="ekr.20041012114208.31"><vh>Tkapp_GlobalEval</vh></v>
<v t="ekr.20041012114208.32"><vh>Tkapp_EvalFile</vh></v>
<v t="ekr.20041012114208.33"><vh>Tkapp_Record</vh></v>
<v t="ekr.20041012114208.34"><vh>Tkapp_AddErrorInfo</vh></v>
</v>
<v t="ekr.20041012114208.35"><vh>Tk variable...</vh>
<v t="ekr.20041012114208.36"><vh>SetVar</vh></v>
<v t="ekr.20041012114208.37"><vh>Tkapp_SetVar</vh></v>
<v t="ekr.20041012114208.38"><vh>Tkapp_GlobalSetVar</vh></v>
<v t="ekr.20041012114208.39"><vh>GetVar</vh></v>
<v t="ekr.20041012114208.40"><vh>Tkapp_GetVar</vh></v>
<v t="ekr.20041012114208.41"><vh>Tkapp_GlobalGetVar</vh></v>
<v t="ekr.20041012114208.42"><vh>UnsetVar</vh></v>
<v t="ekr.20041012114208.43"><vh>Tkapp_UnsetVar</vh></v>
<v t="ekr.20041012114208.44"><vh>Tkapp_GlobalUnsetVar</vh></v>
<v t="ekr.20041012114208.45"><vh>Tkapp_GetInt</vh></v>
<v t="ekr.20041012114208.46"><vh>Tkapp_GetDouble</vh></v>
<v t="ekr.20041012114208.47"><vh>Tkapp_GetBoolean</vh></v>
<v t="ekr.20041012114208.48"><vh>Tkapp_ExprString</vh></v>
<v t="ekr.20041012114208.49"><vh>Tkapp_ExprLong</vh></v>
<v t="ekr.20041012114208.50"><vh>Tkapp_ExprDouble</vh></v>
<v t="ekr.20041012114208.51"><vh>Tkapp_ExprBoolean</vh></v>
<v t="ekr.20041012114208.52"><vh>Tkapp_SplitList</vh></v>
<v t="ekr.20041012114208.53"><vh>Tkapp_Split</vh></v>
<v t="ekr.20041012114208.54"><vh>Tkapp_Merge</vh></v>
</v>
<v t="ekr.20041012114208.55"><vh>Tcl command</vh>
<v t="ekr.20041012114208.56"><vh>Client data struct</vh></v>
<v t="ekr.20041012114208.57"><vh>PythonCmd_Error</vh></v>
<v t="ekr.20041012114208.58"><vh>PythonCmd</vh></v>
<v t="ekr.20041012114208.59"><vh>PythonCmdDelete</vh></v>
<v t="ekr.20041012114208.60"><vh>Tkapp_CreateCommand</vh></v>
<v t="ekr.20041012114208.61"><vh>Tkapp_DeleteCommand</vh></v>
</v>
<v t="ekr.20041012114208.62"><vh>File handler</vh>
<v t="ekr.20041012114208.63"><vh>NewFHCD</vh></v>
<v t="ekr.20041012114208.64"><vh>DeleteFHCD</vh></v>
<v t="ekr.20041012114208.65"><vh>FileHandler</vh></v>
<v t="ekr.20041012114208.66"><vh>Tkapp_CreateFileHandler</vh></v>
<v t="ekr.20041012114208.67"><vh>Tkapp_DeleteFileHandler</vh></v>
</v>
<v t="ekr.20041012114208.68"><vh>Timer...</vh>
<v t="ekr.20041012114208.69"><vh>Timer object</vh></v>
<v t="ekr.20041012114208.70"><vh>Tktt_DeleteTimerHandler</vh></v>
<v t="ekr.20041012114208.71"><vh>Tktt_New</vh></v>
<v t="ekr.20041012114208.72"><vh>Tktt_Dealloc</vh></v>
<v t="ekr.20041012114208.73"><vh>Tktt_Repr</vh></v>
<v t="ekr.20041012114208.74"><vh>Tktt_GetAttr</vh></v>
<v t="ekr.20041012114208.75"><vh>TimerHandler</vh></v>
<v t="ekr.20041012114208.76"><vh>Tkapp_CreateTimerHandler</vh></v>
</v>
<v t="ekr.20041012114208.77"><vh>Event loop...</vh>
<v t="ekr.20041012114208.78"><vh>Tkapp_MainLoop</vh></v>
<v t="ekr.20041012114208.79"><vh>Tkapp_DoOneEvent</vh></v>
<v t="ekr.20041012114208.80"><vh>Tkapp_Quit</vh></v>
<v t="ekr.20041012114208.81"><vh>Tkapp_InterpAddr</vh></v>
</v>
<v t="ekr.20041012114208.82"><vh>TkApp methods</vh>
<v t="ekr.20041012114208.83"><vh>Tkapp_Dealloc</vh></v>
<v t="ekr.20041012114208.84"><vh>Tkapp_GetAttr</vh></v>
</v>
<v t="ekr.20041012114208.85"><vh>TkInter modules</vh>
<v t="ekr.20041012114208.86"><vh>Tkapp_Type</vh></v>
<v t="ekr.20041012114208.87"><vh>_bump</vh></v>
<v t="ekr.20041012114208.88"><vh>_flatten1</vh></v>
<v t="ekr.20041012114208.89"><vh>Tkinter_Flatten</vh></v>
<v t="ekr.20041012114208.90"><vh>Tkinter_Create</vh></v>
<v t="ekr.20041012114208.91"><vh>NmoduleMethods table</vh></v>
<v t="ekr.20041012114208.92"><vh>MyFileProc</vh></v>
<v t="ekr.20041012114208.93"><vh>EventHook</vh></v>
<v t="ekr.20041012114208.94"><vh>EnableEventHook</vh></v>
<v t="ekr.20041012114208.95"><vh>DisableEventHook</vh></v>
<v t="ekr.20041012114208.96"><vh>ins_long</vh></v>
<v t="ekr.20041012114208.97"><vh>ins_string</vh></v>
<v t="ekr.20041012114208.98"><vh>init_tkinter</vh></v>
</v>
<v t="ekr.20041012114208.99"><vh>Mac stuff</vh>
<v t="ekr.20041012114208.100"><vh>&lt;&lt; mac stuff &gt;&gt;</vh>
<v t="ekr.20041012114208.101"><vh>panic</vh></v>
<v t="ekr.20041012114208.102"><vh>PyMacConvertEvent</vh></v>
</v>
<v t="ekr.20041012114208.103"><vh>&lt;&lt; mac generating cfm stuff &gt;&gt;</vh>
<v t="ekr.20041012114208.104"><vh>init_tkinter_shlib</vh></v>
<v t="ekr.20041012114208.105"><vh>mac_addlibresources</vh></v>
</v>
</v>
</v>
<v t="ekr.20041012114208.106"><vh>tkinter.py (in Lib\lib-tk)</vh>
<v t="ekr.20041012114208.2"><vh>&lt;&lt; Tkinter doc string &gt;&gt;</vh></v>
<v t="ekr.20041012114208.107"><vh>&lt;&lt; Tkinter declarations &gt;&gt;</vh></v>
<v t="ekr.20041012114208.108"><vh>Tk and Wm</vh>
<v t="ekr.20041012114208.109"><vh>class Tk(Misc, Wm) (creates self.tk)</vh>
<v t="ekr.20041012114208.110"><vh>__init__ (creates self.tk)</vh></v>
<v t="ekr.20041012114208.111"><vh>destroy</vh></v>
<v t="ekr.20041012114208.112"><vh>readprofile</vh></v>
<v t="ekr.20041012114208.113"><vh>report_callback_exception</vh></v>
</v>
<v t="ekr.20041012114208.114"><vh>class Wm (see Tk docs)</vh>
<v t="ekr.20041012114208.115"><vh>wm_aspect</vh></v>
<v t="ekr.20041012114208.116"><vh>wm_client</vh></v>
<v t="ekr.20041012114208.117"><vh>wm_colormapwindows</vh></v>
<v t="ekr.20041012114208.118"><vh>wm_command</vh></v>
<v t="ekr.20041012114208.119"><vh>wm_deiconify</vh></v>
<v t="ekr.20041012114208.120"><vh>wm_focusmodel</vh></v>
<v t="ekr.20041012114208.121"><vh>wm_frame</vh></v>
<v t="ekr.20041012114208.122"><vh>wm_geometry</vh></v>
<v t="ekr.20041012114208.123"><vh>wm_grid</vh></v>
<v t="ekr.20041012114208.124"><vh>wm_group</vh></v>
<v t="ekr.20041012114208.125"><vh>wm_iconbitmap</vh></v>
<v t="ekr.20041012114208.126"><vh>wm_iconify</vh></v>
<v t="ekr.20041012114208.127"><vh>wm_iconmask</vh></v>
<v t="ekr.20041012114208.128"><vh>wm_iconname</vh></v>
<v t="ekr.20041012114208.129"><vh>wm_iconposition</vh></v>
<v t="ekr.20041012114208.130"><vh>wm_iconwindow</vh></v>
<v t="ekr.20041012114208.131"><vh>wm_maxsize</vh></v>
<v t="ekr.20041012114208.132"><vh>wm_minsize</vh></v>
<v t="ekr.20041012114208.133"><vh>wm_overrideredirect</vh></v>
<v t="ekr.20041012114208.134"><vh>wm_positionfrom</vh></v>
<v t="ekr.20041012114208.135"><vh>wm_protocol</vh></v>
<v t="ekr.20041012114208.136"><vh>wm_resizable</vh></v>
<v t="ekr.20041012114208.137"><vh>wm_sizefrom</vh></v>
<v t="ekr.20041012114208.138"><vh>wm_state</vh></v>
<v t="ekr.20041012114208.139"><vh>wm_title</vh></v>
<v t="ekr.20041012114208.140"><vh>wm_transient</vh></v>
<v t="ekr.20041012114208.141"><vh>wm_withdraw</vh></v>
</v>
</v>
<v t="ekr.20041012114208.142"><vh>widget classes</vh>
<v t="ekr.20041012114208.143" a="EM"><vh>Helper classes</vh>
<v t="ekr.20041012114208.144"><vh>class Event (Created only by Misc._substitute)</vh>
<v t="ekr.20041012114208.145"><vh>&lt;&lt; class Event docstring &gt;&gt;</vh></v>
<v t="ekr.20041012114208.146"><vh>NoDefaultRoot</vh></v>
<v t="ekr.20041012114208.147"><vh>_tkerror</vh></v>
<v t="ekr.20041012114208.148"><vh>_exit</vh></v>
</v>
<v t="ekr.20041012114208.149" a="E"><vh>class CallWrapper (Created only by Misc._register)</vh>
<v t="ekr.20041012114208.150"><vh>__init__</vh></v>
<v t="ekr.20041012114208.151"><vh>__call__</vh></v>
</v>
<v t="ekr.20041012114208.152"><vh>Var classes (Created only by Misc.waitVar))</vh>
<v t="ekr.20041012114208.153"><vh>class Variable</vh>
<v t="ekr.20041012114208.154"><vh>__init__</vh></v>
<v t="ekr.20041012114208.155"><vh>__del__</vh></v>
<v t="ekr.20041012114208.156"><vh>__str__</vh></v>
<v t="ekr.20041012114208.157"><vh>set</vh></v>
<v t="ekr.20041012114208.158"><vh>trace_variable</vh></v>
<v t="ekr.20041012114208.159"><vh>trace_vdelete</vh></v>
<v t="ekr.20041012114208.160"><vh>trace_vinfo</vh></v>
</v>
<v t="ekr.20041012114208.161"><vh>class StringVar (Variable)</vh>
<v t="ekr.20041012114208.162"><vh>&lt;&lt; class StringVar declarations &gt;&gt;</vh></v>
<v t="ekr.20041012114208.163"><vh>__init__</vh></v>
<v t="ekr.20041012114208.164"><vh>get</vh></v>
</v>
<v t="ekr.20041012114208.165"><vh>class IntVar (Variable)</vh>
<v t="ekr.20041012114208.166"><vh>&lt;&lt; class IntVar declarations &gt;&gt;</vh></v>
<v t="ekr.20041012114208.167"><vh>__init__</vh></v>
<v t="ekr.20041012114208.168"><vh>get</vh></v>
</v>
<v t="ekr.20041012114208.169"><vh>class DoubleVar (Variable)</vh>
<v t="ekr.20041012114208.170"><vh>&lt;&lt; class DoubleVar declarations &gt;&gt;</vh></v>
<v t="ekr.20041012114208.171"><vh>__init__</vh></v>
<v t="ekr.20041012114208.172"><vh>get</vh></v>
</v>
<v t="ekr.20041012114208.173"><vh>class BooleanVar (Variable)</vh>
<v t="ekr.20041012114208.174"><vh>&lt;&lt; class BooleanVar declarations &gt;&gt;</vh></v>
<v t="ekr.20041012114208.175"><vh>__init__</vh></v>
<v t="ekr.20041012114208.176"><vh>get</vh></v>
</v>
</v>
</v>
<v t="ekr.20041012114208.177" a="M"><vh>class Misc (shared methods) (contains configure, etc)</vh>
<v t="ekr.20041012114208.178"><vh>destroy</vh></v>
<v t="ekr.20041012114208.179"><vh>deletecommand</vh></v>
<v t="ekr.20041012114208.180"><vh>tk_strictMotif</vh></v>
<v t="ekr.20041012114208.181"><vh>tk_bisque</vh></v>
<v t="ekr.20041012114208.182"><vh>tk_setPalette</vh></v>
<v t="ekr.20041012114208.183"><vh>tk_menuBar</vh></v>
<v t="ekr.20041012114208.184"><vh>wait_variable</vh></v>
<v t="ekr.20041012114208.185"><vh>wait_window</vh></v>
<v t="ekr.20041012114208.186"><vh>wait_visibility</vh></v>
<v t="ekr.20041012114208.187" a="M"><vh>setvar</vh></v>
<v t="ekr.20041012114208.188" a="M"><vh>getvar</vh></v>
<v t="ekr.20041012114208.189" a="M"><vh>getboolean, getint, getdouble</vh></v>
<v t="ekr.20041012114208.190"><vh>focus_set</vh></v>
<v t="ekr.20041012114208.191"><vh>focus_force</vh></v>
<v t="ekr.20041012114208.192"><vh>focus_get</vh></v>
<v t="ekr.20041012114208.193"><vh>focus_displayof</vh></v>
<v t="ekr.20041012114208.194"><vh>focus_lastfor</vh></v>
<v t="ekr.20041012114208.195"><vh>tk_focusFollowsMouse</vh></v>
<v t="ekr.20041012114208.196"><vh>tk_focusNext</vh></v>
<v t="ekr.20041012114208.197"><vh>tk_focusPrev</vh></v>
<v t="ekr.20041012114208.198"><vh>after</vh></v>
<v t="ekr.20041012114208.199"><vh>after_idle</vh></v>
<v t="ekr.20041012114208.200"><vh>after_cancel</vh></v>
<v t="ekr.20041012114208.201"><vh>bell</vh></v>
<v t="ekr.20041012114208.202"><vh>clipboard_clear</vh></v>
<v t="ekr.20041012114208.203"><vh>clipboard_append</vh></v>
<v t="ekr.20041012114208.204"><vh>grab_current</vh></v>
<v t="ekr.20041012114208.205"><vh>grab_release</vh></v>
<v t="ekr.20041012114208.206"><vh>grab_set</vh></v>
<v t="ekr.20041012114208.207"><vh>grab_set_global</vh></v>
<v t="ekr.20041012114208.208"><vh>grab_status</vh></v>
<v t="ekr.20041012114208.209"><vh>lower</vh></v>
<v t="ekr.20041012114208.210"><vh>option_add</vh></v>
<v t="ekr.20041012114208.211"><vh>option_clear</vh></v>
<v t="ekr.20041012114208.212"><vh>option_get</vh></v>
<v t="ekr.20041012114208.213"><vh>option_readfile</vh></v>
<v t="ekr.20041012114208.214"><vh>selection_clear</vh></v>
<v t="ekr.20041012114208.215"><vh>selection_get</vh></v>
<v t="ekr.20041012114208.216"><vh>selection_handle</vh></v>
<v t="ekr.20041012114208.217"><vh>selection_own</vh></v>
<v t="ekr.20041012114208.218"><vh>selection_own_get</vh></v>
<v t="ekr.20041012114208.219"><vh>send</vh></v>
<v t="ekr.20041012114208.220"><vh>lower</vh></v>
<v t="ekr.20041012114208.221"><vh>tkraise</vh></v>
<v t="ekr.20041012114208.222"><vh>colormodel</vh></v>
<v t="ekr.20041012114208.223"><vh>winfo...</vh>
<v t="ekr.20041012114208.224"><vh>winfo_atom</vh></v>
<v t="ekr.20041012114208.225"><vh>winfo_atomname</vh></v>
<v t="ekr.20041012114208.226"><vh>winfo_cells</vh></v>
<v t="ekr.20041012114208.227"><vh>winfo_children</vh></v>
<v t="ekr.20041012114208.228"><vh>winfo_class</vh></v>
<v t="ekr.20041012114208.229"><vh>winfo_colormapfull</vh></v>
<v t="ekr.20041012114208.230"><vh>winfo_containing</vh></v>
<v t="ekr.20041012114208.231"><vh>winfo_depth</vh></v>
<v t="ekr.20041012114208.232"><vh>winfo_exists</vh></v>
<v t="ekr.20041012114208.233"><vh>winfo_fpixels</vh></v>
<v t="ekr.20041012114208.234"><vh>winfo_geometry</vh></v>
<v t="ekr.20041012114208.235"><vh>winfo_height</vh></v>
<v t="ekr.20041012114208.236"><vh>winfo_id</vh></v>
<v t="ekr.20041012114208.237"><vh>winfo_interps</vh></v>
<v t="ekr.20041012114208.238"><vh>winfo_ismapped</vh></v>
<v t="ekr.20041012114208.239"><vh>winfo_manager</vh></v>
<v t="ekr.20041012114208.240"><vh>winfo_name</vh></v>
<v t="ekr.20041012114208.241"><vh>winfo_parent</vh></v>
<v t="ekr.20041012114208.242"><vh>winfo_pathname</vh></v>
<v t="ekr.20041012114208.243"><vh>winfo_pixels</vh></v>
<v t="ekr.20041012114208.244"><vh>winfo_pointerx</vh></v>
<v t="ekr.20041012114208.245"><vh>winfo_pointerxy</vh></v>
<v t="ekr.20041012114208.246"><vh>winfo_pointery</vh></v>
<v t="ekr.20041012114208.247"><vh>winfo_reqheight</vh></v>
<v t="ekr.20041012114208.248"><vh>winfo_reqwidth</vh></v>
<v t="ekr.20041012114208.249"><vh>winfo_rgb</vh></v>
<v t="ekr.20041012114208.250"><vh>winfo_rootx</vh></v>
<v t="ekr.20041012114208.251"><vh>winfo_rooty</vh></v>
<v t="ekr.20041012114208.252"><vh>winfo_screen</vh></v>
<v t="ekr.20041012114208.253"><vh>winfo_screencells</vh></v>
<v t="ekr.20041012114208.254"><vh>winfo_screendepth</vh></v>
<v t="ekr.20041012114208.255"><vh>winfo_screenheight</vh></v>
<v t="ekr.20041012114208.256"><vh>winfo_screenmmheight</vh></v>
<v t="ekr.20041012114208.257"><vh>winfo_screenmmwidth</vh></v>
<v t="ekr.20041012114208.258"><vh>winfo_screenvisual</vh></v>
<v t="ekr.20041012114208.259"><vh>winfo_screenwidth</vh></v>
<v t="ekr.20041012114208.260"><vh>winfo_server</vh></v>
<v t="ekr.20041012114208.261"><vh>winfo_toplevel</vh></v>
<v t="ekr.20041012114208.262"><vh>winfo_viewable</vh></v>
<v t="ekr.20041012114208.263"><vh>winfo_visual</vh></v>
<v t="ekr.20041012114208.264"><vh>winfo_visualid</vh></v>
<v t="ekr.20041012114208.265"><vh>winfo_visualsavailable</vh></v>
<v t="ekr.20041012114208.266"><vh>__winfo_parseitem</vh></v>
<v t="ekr.20041012114208.267"><vh>__winfo_getint</vh></v>
<v t="ekr.20041012114208.268"><vh>winfo_vrootheight</vh></v>
<v t="ekr.20041012114208.269"><vh>winfo_vrootwidth</vh></v>
<v t="ekr.20041012114208.270"><vh>winfo_vrootx</vh></v>
<v t="ekr.20041012114208.271"><vh>winfo_vrooty</vh></v>
<v t="ekr.20041012114208.272"><vh>winfo_width</vh></v>
<v t="ekr.20041012114208.273"><vh>winfo_x</vh></v>
<v t="ekr.20041012114208.274"><vh>winfo_y</vh></v>
</v>
<v t="ekr.20041012114208.275"><vh>update</vh></v>
<v t="ekr.20041012114208.276"><vh>update_idletasks</vh></v>
<v t="ekr.20041012114208.277"><vh>bindtags</vh></v>
<v t="ekr.20041012114208.278"><vh>_bind</vh></v>
<v t="ekr.20041012114208.279"><vh>bind</vh></v>
<v t="ekr.20041012114208.280"><vh>unbind</vh></v>
<v t="ekr.20041012114208.281"><vh>bind_all</vh></v>
<v t="ekr.20041012114208.282"><vh>unbind_all</vh></v>
<v t="ekr.20041012114208.283"><vh>bind_class</vh></v>
<v t="ekr.20041012114208.284"><vh>unbind_class</vh></v>
<v t="ekr.20041012114208.285"><vh>mainloop</vh></v>
<v t="ekr.20041012114208.286"><vh>quit</vh></v>
<v t="ekr.20041012114208.287" a="M"><vh>_getints</vh></v>
<v t="ekr.20041012114208.288" a="M"><vh>_getdoubles</vh></v>
<v t="ekr.20041012114208.289" a="M"><vh>_getboolean</vh></v>
<v t="ekr.20041012114208.290"><vh>_displayof</vh></v>
<v t="ekr.20041012114208.291"><vh>_options</vh></v>
<v t="ekr.20041012114208.292"><vh>nametowidget</vh></v>
<v t="ekr.20041012114208.293" a="M"><vh>register &amp; _register (sets self._tclCommands)(Creates CallWrapper)</vh></v>
<v t="ekr.20041012114208.294"><vh>_root</vh></v>
<v t="ekr.20041012114208.295"><vh>_substitute</vh></v>
<v t="ekr.20041012114208.296"><vh>_report_exception</vh></v>
<v t="ekr.20041012114208.297" a="M"><vh>config &amp; configure</vh></v>
<v t="ekr.20041012114208.298" a="M"><vh>__getitem__ &amp; cget (see tk docs)</vh></v>
<v t="ekr.20041012114208.299"><vh>__setitem__</vh></v>
<v t="ekr.20041012114208.300"><vh>keys</vh></v>
<v t="ekr.20041012114208.301"><vh>__str__</vh></v>
<v t="ekr.20041012114208.302"><vh>pack methods that apply to the master</vh>
<v t="ekr.20041012114208.303"><vh>pack_propagate</vh></v>
<v t="ekr.20041012114208.304"><vh>pack_slaves</vh></v>
<v t="ekr.20041012114208.305"><vh>place_slaves</vh></v>
</v>
<v t="ekr.20041012114208.306"><vh>grid methods that apply to the master</vh>
<v t="ekr.20041012114208.307"><vh>grid_bbox</vh></v>
<v t="ekr.20041012114208.308"><vh>_grid_configure</vh></v>
<v t="ekr.20041012114208.309"><vh>grid_columnconfigure</vh></v>
<v t="ekr.20041012114208.310"><vh>grid_propagate</vh></v>
<v t="ekr.20041012114208.311"><vh>grid_rowconfigure</vh></v>
<v t="ekr.20041012114208.312"><vh>grid_size</vh></v>
<v t="ekr.20041012114208.313"><vh>grid_slaves</vh></v>
</v>
<v t="ekr.20041012114208.314"><vh>support for event command</vh>
<v t="ekr.20041012114208.315"><vh>event_add</vh></v>
<v t="ekr.20041012114208.316"><vh>event_delete</vh></v>
<v t="ekr.20041012114208.317"><vh>event_generate</vh></v>
<v t="ekr.20041012114208.318"><vh>event_info</vh></v>
</v>
<v t="ekr.20041012114208.319"><vh>image related commands</vh>
<v t="ekr.20041012114208.320"><vh>image_names</vh></v>
<v t="ekr.20041012114208.321"><vh>image_types</vh></v>
</v>
</v>
<v t="ekr.20041012114208.322"><vh>Geometry managers</vh>
<v t="ekr.20041012114208.323" a="E"><vh>class Pack</vh>
<v t="ekr.20041012114208.324"><vh>pack_configure (defines pack)</vh></v>
<v t="ekr.20041012114208.325"><vh>pack_forget</vh></v>
<v t="ekr.20041012114208.326"><vh>pack_info</vh></v>
</v>
<v t="ekr.20041012114208.327"><vh>class Place</vh>
<v t="ekr.20041012114208.328"><vh>place_configure</vh></v>
<v t="ekr.20041012114208.329"><vh>place_forget</vh></v>
<v t="ekr.20041012114208.330"><vh>place_info</vh></v>
</v>
<v t="ekr.20041012114208.331"><vh>class Grid</vh>
<v t="ekr.20041012114208.332"><vh>grid_configure</vh></v>
<v t="ekr.20041012114208.333"><vh>grid_forget</vh></v>
<v t="ekr.20041012114208.334"><vh>grid_remove</vh></v>
<v t="ekr.20041012114208.335"><vh>grid_info</vh></v>
<v t="ekr.20041012114208.336"><vh>grid_location</vh></v>
</v>
</v>
<v t="ekr.20041012114208.337"><vh>class Widget(BaseWidget, Pack, Place, Grid) (abstract)</vh></v>
<v t="ekr.20041012114208.338"><vh>class BaseWidget (Misc)</vh>
<v t="ekr.20041012114208.339"><vh>_setup</vh></v>
<v t="ekr.20041012114208.340"><vh>__init__</vh></v>
<v t="ekr.20041012114208.341"><vh>destroy</vh></v>
<v t="ekr.20041012114208.342"><vh>_do (obsolete)</vh></v>
</v>
<v t="ekr.20041012114208.343"><vh>class Toplevel (BaseWidget, Wm)</vh>
<v t="ekr.20041012114208.344"><vh>__init__</vh></v>
</v>
<v t="ekr.20041012114208.345"><vh>class Button</vh>
<v t="ekr.20041012114208.346"><vh>__init__</vh></v>
<v t="ekr.20041012114208.347"><vh>tkButtonEnter</vh></v>
<v t="ekr.20041012114208.348"><vh>tkButtonLeave</vh></v>
<v t="ekr.20041012114208.349"><vh>tkButtonDown</vh></v>
<v t="ekr.20041012114208.350"><vh>tkButtonUp</vh></v>
<v t="ekr.20041012114208.351"><vh>tkButtonInvoke</vh></v>
<v t="ekr.20041012114208.352"><vh>flash</vh></v>
<v t="ekr.20041012114208.353"><vh>invoke</vh></v>
</v>
<v t="ekr.20041012114208.354" a="M"><vh>class Canvas</vh>
<v t="ekr.20041012114208.355"><vh>__init__</vh></v>
<v t="ekr.20041012114208.356"><vh>addtag...</vh>
<v t="ekr.20041012114208.357"><vh>addtag</vh></v>
<v t="ekr.20041012114208.358"><vh>addtag_above</vh></v>
<v t="ekr.20041012114208.359"><vh>addtag_all</vh></v>
<v t="ekr.20041012114208.360"><vh>addtag_below</vh></v>
<v t="ekr.20041012114208.361"><vh>addtag_closest</vh></v>
<v t="ekr.20041012114208.362"><vh>addtag_enclosed</vh></v>
<v t="ekr.20041012114208.363"><vh>addtag_overlapping</vh></v>
<v t="ekr.20041012114208.364"><vh>addtag_withtag</vh></v>
</v>
<v t="ekr.20041012114208.365"><vh>bbox</vh></v>
<v t="ekr.20041012114208.366"><vh>tag_unbind</vh></v>
<v t="ekr.20041012114208.367"><vh>tag_bind</vh></v>
<v t="ekr.20041012114208.368"><vh>canvasx</vh></v>
<v t="ekr.20041012114208.369"><vh>canvasy</vh></v>
<v t="ekr.20041012114208.370"><vh>coords</vh></v>
<v t="ekr.20041012114208.371"><vh>create...</vh>
<v t="ekr.20041012114208.372"><vh>_create</vh></v>
<v t="ekr.20041012114208.373"><vh>create_arc</vh></v>
<v t="ekr.20041012114208.374"><vh>create_bitmap</vh></v>
<v t="ekr.20041012114208.375"><vh>create_image</vh></v>
<v t="ekr.20041012114208.376"><vh>create_line</vh></v>
<v t="ekr.20041012114208.377"><vh>create_oval</vh></v>
<v t="ekr.20041012114208.378"><vh>create_polygon</vh></v>
<v t="ekr.20041012114208.379"><vh>create_rectangle</vh></v>
<v t="ekr.20041012114208.380"><vh>create_text</vh></v>
<v t="ekr.20041012114208.381"><vh>create_window</vh></v>
</v>
<v t="ekr.20041012114208.382"><vh>dchars</vh></v>
<v t="ekr.20041012114208.383"><vh>delete</vh></v>
<v t="ekr.20041012114208.384"><vh>dtag</vh></v>
<v t="ekr.20041012114208.385"><vh>find...</vh>
<v t="ekr.20041012114208.386"><vh>find</vh></v>
<v t="ekr.20041012114208.387"><vh>find_above</vh></v>
<v t="ekr.20041012114208.388"><vh>find_all</vh></v>
<v t="ekr.20041012114208.389"><vh>find_below</vh></v>
<v t="ekr.20041012114208.390"><vh>find_closest</vh></v>
<v t="ekr.20041012114208.391"><vh>find_enclosed</vh></v>
<v t="ekr.20041012114208.392"><vh>find_overlapping</vh></v>
<v t="ekr.20041012114208.393"><vh>find_withtag</vh></v>
</v>
<v t="ekr.20041012114208.394"><vh>focus</vh></v>
<v t="ekr.20041012114208.395"><vh>gettags</vh></v>
<v t="ekr.20041012114208.396"><vh>icursor</vh></v>
<v t="ekr.20041012114208.397"><vh>index</vh></v>
<v t="ekr.20041012114208.398"><vh>insert</vh></v>
<v t="ekr.20041012114208.399"><vh>itemcget</vh></v>
<v t="ekr.20041012114208.400"><vh>itemconfigure</vh></v>
<v t="ekr.20041012114208.401"><vh>tag_lower</vh></v>
<v t="ekr.20041012114208.402"><vh>move</vh></v>
<v t="ekr.20041012114208.403"><vh>postscript</vh></v>
<v t="ekr.20041012114208.404"><vh>tag_raise</vh></v>
<v t="ekr.20041012114208.405"><vh>scale</vh></v>
<v t="ekr.20041012114208.406"><vh>scan_xxx...</vh>
<v t="ekr.20041012114208.407"><vh>scan_mark</vh></v>
<v t="ekr.20041012114208.408"><vh>scan_dragto</vh></v>
</v>
<v t="ekr.20041012114208.409"><vh>select_xxx...</vh>
<v t="ekr.20041012114208.410"><vh>select_adjust</vh></v>
<v t="ekr.20041012114208.411"><vh>select_clear</vh></v>
<v t="ekr.20041012114208.412"><vh>select_from</vh></v>
<v t="ekr.20041012114208.413"><vh>select_item</vh></v>
<v t="ekr.20041012114208.414"><vh>select_to</vh></v>
</v>
<v t="ekr.20041012114208.415"><vh>type</vh></v>
<v t="ekr.20041012114208.416"><vh>xview, yview...</vh>
<v t="ekr.20041012114208.417"><vh>xview</vh></v>
<v t="ekr.20041012114208.418"><vh>xview_moveto</vh></v>
<v t="ekr.20041012114208.419"><vh>xview_scroll</vh></v>
<v t="ekr.20041012114208.420"><vh>yview</vh></v>
<v t="ekr.20041012114208.421"><vh>yview_moveto</vh></v>
<v t="ekr.20041012114208.422"><vh>yview_scroll</vh></v>
</v>
</v>
<v t="ekr.20041012114208.423"><vh>class Checkbutton</vh>
<v t="ekr.20041012114208.424"><vh>__init__</vh></v>
<v t="ekr.20041012114208.425"><vh>deselect</vh></v>
<v t="ekr.20041012114208.426"><vh>flash</vh></v>
<v t="ekr.20041012114208.427"><vh>invoke</vh></v>
<v t="ekr.20041012114208.428"><vh>select</vh></v>
<v t="ekr.20041012114208.429"><vh>toggle</vh></v>
</v>
<v t="ekr.20041012114208.430"><vh>class Entry</vh>
<v t="ekr.20041012114208.431"><vh>__init__</vh></v>
<v t="ekr.20041012114208.432"><vh>delete</vh></v>
<v t="ekr.20041012114208.433"><vh>get</vh></v>
<v t="ekr.20041012114208.434"><vh>icursor</vh></v>
<v t="ekr.20041012114208.435"><vh>index</vh></v>
<v t="ekr.20041012114208.436"><vh>insert</vh></v>
<v t="ekr.20041012114208.437"><vh>scan_mark</vh></v>
<v t="ekr.20041012114208.438"><vh>scan_dragto</vh></v>
<v t="ekr.20041012114208.439"><vh>selection_adjust</vh></v>
<v t="ekr.20041012114208.440"><vh>selection_clear</vh></v>
<v t="ekr.20041012114208.441"><vh>selection_from</vh></v>
<v t="ekr.20041012114208.442"><vh>selection_present</vh></v>
<v t="ekr.20041012114208.443"><vh>selection_range</vh></v>
<v t="ekr.20041012114208.444"><vh>selection_to</vh></v>
<v t="ekr.20041012114208.445"><vh>xview</vh></v>
<v t="ekr.20041012114208.446"><vh>xview_moveto</vh></v>
<v t="ekr.20041012114208.447"><vh>xview_scroll</vh></v>
</v>
<v t="ekr.20041012114208.448"><vh>class Frame</vh>
<v t="ekr.20041012114208.449"><vh>__init__</vh></v>
</v>
<v t="ekr.20041012114208.450"><vh>class Label</vh>
<v t="ekr.20041012114208.451"><vh>__init__</vh></v>
</v>
<v t="ekr.20041012114208.452"><vh>class Listbox</vh>
<v t="ekr.20041012114208.453"><vh>__init__</vh></v>
<v t="ekr.20041012114208.454"><vh>activate</vh></v>
<v t="ekr.20041012114208.455"><vh>bbox</vh></v>
<v t="ekr.20041012114208.456"><vh>curselection</vh></v>
<v t="ekr.20041012114208.457"><vh>delete</vh></v>
<v t="ekr.20041012114208.458"><vh>get</vh></v>
<v t="ekr.20041012114208.459"><vh>index</vh></v>
<v t="ekr.20041012114208.460"><vh>insert</vh></v>
<v t="ekr.20041012114208.461"><vh>nearest</vh></v>
<v t="ekr.20041012114208.462"><vh>scan_mark</vh></v>
<v t="ekr.20041012114208.463"><vh>scan_dragto</vh></v>
<v t="ekr.20041012114208.464"><vh>see</vh></v>
<v t="ekr.20041012114208.465"><vh>selection_anchor</vh></v>
<v t="ekr.20041012114208.466"><vh>selection_clear</vh></v>
<v t="ekr.20041012114208.467"><vh>selection_includes</vh></v>
<v t="ekr.20041012114208.468"><vh>selection_set</vh></v>
<v t="ekr.20041012114208.469"><vh>size</vh></v>
<v t="ekr.20041012114208.470"><vh>xview</vh></v>
<v t="ekr.20041012114208.471"><vh>xview_moveto</vh></v>
<v t="ekr.20041012114208.472"><vh>xview_scroll</vh></v>
<v t="ekr.20041012114208.473"><vh>yview</vh></v>
<v t="ekr.20041012114208.474"><vh>yview_moveto</vh></v>
<v t="ekr.20041012114208.475"><vh>yview_scroll</vh></v>
</v>
<v t="ekr.20041012114208.476"><vh>class Menu</vh>
<v t="ekr.20041012114208.477"><vh>__init__</vh></v>
<v t="ekr.20041012114208.478"><vh>tk_bindForTraversal</vh></v>
<v t="ekr.20041012114208.479"><vh>tk_mbPost</vh></v>
<v t="ekr.20041012114208.480"><vh>tk_mbUnpost</vh></v>
<v t="ekr.20041012114208.481"><vh>tk_traverseToMenu</vh></v>
<v t="ekr.20041012114208.482"><vh>tk_traverseWithinMenu</vh></v>
<v t="ekr.20041012114208.483"><vh>tk_getMenuButtons</vh></v>
<v t="ekr.20041012114208.484"><vh>tk_nextMenu</vh></v>
<v t="ekr.20041012114208.485"><vh>tk_nextMenuEntry</vh></v>
<v t="ekr.20041012114208.486"><vh>tk_invokeMenu</vh></v>
<v t="ekr.20041012114208.487"><vh>tk_firstMenu</vh></v>
<v t="ekr.20041012114208.488"><vh>tk_mbButtonDown</vh></v>
<v t="ekr.20041012114208.489"><vh>tk_popup</vh></v>
<v t="ekr.20041012114208.490"><vh>activate</vh></v>
<v t="ekr.20041012114208.491"><vh>add</vh></v>
<v t="ekr.20041012114208.492"><vh>add_cascade</vh></v>
<v t="ekr.20041012114208.493"><vh>add_checkbutton</vh></v>
<v t="ekr.20041012114208.494"><vh>add_command</vh></v>
<v t="ekr.20041012114208.495"><vh>add_radiobutton</vh></v>
<v t="ekr.20041012114208.496"><vh>add_separator</vh></v>
<v t="ekr.20041012114208.497"><vh>insert</vh></v>
<v t="ekr.20041012114208.498"><vh>insert_cascade</vh></v>
<v t="ekr.20041012114208.499"><vh>insert_checkbutton</vh></v>
<v t="ekr.20041012114208.500"><vh>insert_command</vh></v>
<v t="ekr.20041012114208.501"><vh>insert_radiobutton</vh></v>
<v t="ekr.20041012114208.502"><vh>insert_separator</vh></v>
<v t="ekr.20041012114208.503"><vh>delete</vh></v>
<v t="ekr.20041012114208.504"><vh>entrycget</vh></v>
<v t="ekr.20041012114208.505"><vh>entryconfigure</vh></v>
<v t="ekr.20041012114208.506"><vh>index</vh></v>
<v t="ekr.20041012114208.507"><vh>invoke</vh></v>
<v t="ekr.20041012114208.508"><vh>post</vh></v>
<v t="ekr.20041012114208.509"><vh>type</vh></v>
<v t="ekr.20041012114208.510"><vh>unpost</vh></v>
<v t="ekr.20041012114208.511"><vh>yposition</vh></v>
</v>
<v t="ekr.20041012114208.512"><vh>class Menubutton (obsolete since Tk8.0)</vh>
<v t="ekr.20041012114208.513"><vh>__init__</vh></v>
</v>
<v t="ekr.20041012114208.514"><vh>class Message</vh>
<v t="ekr.20041012114208.515"><vh>__init__</vh></v>
</v>
<v t="ekr.20041012114208.516"><vh>class Radiobutton</vh>
<v t="ekr.20041012114208.517"><vh>__init__</vh></v>
<v t="ekr.20041012114208.518"><vh>deselect</vh></v>
<v t="ekr.20041012114208.519"><vh>flash</vh></v>
<v t="ekr.20041012114208.520"><vh>invoke</vh></v>
<v t="ekr.20041012114208.521"><vh>select</vh></v>
</v>
<v t="ekr.20041012114208.522"><vh>class Scale</vh>
<v t="ekr.20041012114208.523"><vh>__init__</vh></v>
<v t="ekr.20041012114208.524"><vh>get</vh></v>
<v t="ekr.20041012114208.525"><vh>set</vh></v>
<v t="ekr.20041012114208.526"><vh>coords</vh></v>
<v t="ekr.20041012114208.527"><vh>identify</vh></v>
</v>
<v t="ekr.20041012114208.528"><vh>class Scrollbar</vh>
<v t="ekr.20041012114208.529"><vh>__init__</vh></v>
<v t="ekr.20041012114208.530"><vh>activate</vh></v>
<v t="ekr.20041012114208.531"><vh>delta</vh></v>
<v t="ekr.20041012114208.532"><vh>fraction</vh></v>
<v t="ekr.20041012114208.533"><vh>identify</vh></v>
<v t="ekr.20041012114208.534"><vh>get</vh></v>
<v t="ekr.20041012114208.535"><vh>set</vh></v>
</v>
<v t="ekr.20041012114208.536"><vh>class Text</vh>
<v t="ekr.20041012114208.537"><vh>__init__</vh></v>
<v t="ekr.20041012114208.538"><vh>debug</vh></v>
<v t="ekr.20041012114208.539"><vh>tk_text...</vh>
<v t="ekr.20041012114208.540"><vh>tk_textSelectTo</vh></v>
<v t="ekr.20041012114208.541"><vh>tk_textBackspace</vh></v>
<v t="ekr.20041012114208.542"><vh>tk_textIndexCloser</vh></v>
<v t="ekr.20041012114208.543"><vh>tk_textResetAnchor</vh></v>
</v>
<v t="ekr.20041012114208.544" a="E"><vh>getters &amp; setters</vh>
<v t="ekr.20041012114208.545"><vh>compare</vh></v>
<v t="ekr.20041012114208.546"><vh>delete</vh></v>
<v t="ekr.20041012114208.547"><vh>get</vh></v>
<v t="ekr.20041012114208.548"><vh>index</vh></v>
<v t="ekr.20041012114208.549"><vh>insert</vh></v>
</v>
<v t="ekr.20041012114208.550"><vh>image...</vh>
<v t="ekr.20041012114208.551"><vh>image_cget</vh></v>
<v t="ekr.20041012114208.552"><vh>image_configure</vh></v>
<v t="ekr.20041012114208.553"><vh>image_create</vh></v>
<v t="ekr.20041012114208.554"><vh>image_names</vh></v>
</v>
<v t="ekr.20041012114208.555"><vh>mark...</vh>
<v t="ekr.20041012114208.556"><vh>mark_gravity</vh></v>
<v t="ekr.20041012114208.557"><vh>mark_names</vh></v>
<v t="ekr.20041012114208.558"><vh>mark_set</vh></v>
<v t="ekr.20041012114208.559"><vh>mark_unset</vh></v>
<v t="ekr.20041012114208.560"><vh>mark_next</vh></v>
<v t="ekr.20041012114208.561"><vh>mark_previous</vh></v>
</v>
<v t="ekr.20041012114208.562"><vh>scan...</vh>
<v t="ekr.20041012114208.563"><vh>scan_mark</vh></v>
<v t="ekr.20041012114208.564"><vh>scan_dragto</vh></v>
</v>
<v t="ekr.20041012114208.565"><vh>search</vh></v>
<v t="ekr.20041012114208.566"><vh>tag...</vh>
<v t="ekr.20041012114208.567"><vh>tag_add</vh></v>
<v t="ekr.20041012114208.568"><vh>tag_unbind</vh></v>
<v t="ekr.20041012114208.569"><vh>tag_bind</vh></v>
<v t="ekr.20041012114208.570"><vh>tag_cget</vh></v>
<v t="ekr.20041012114208.571"><vh>tag_configure</vh></v>
<v t="ekr.20041012114208.572"><vh>tag_delete</vh></v>
<v t="ekr.20041012114208.573"><vh>tag_lower</vh></v>
<v t="ekr.20041012114208.574"><vh>tag_names</vh></v>
<v t="ekr.20041012114208.575"><vh>tag_nextrange</vh></v>
<v t="ekr.20041012114208.576"><vh>tag_prevrange</vh></v>
<v t="ekr.20041012114208.577"><vh>tag_raise</vh></v>
<v t="ekr.20041012114208.578"><vh>tag_ranges</vh></v>
<v t="ekr.20041012114208.579"><vh>tag_remove</vh></v>
</v>
<v t="ekr.20041012114208.580"><vh>visual...</vh>
<v t="ekr.20041012114208.581"><vh>bbox</vh></v>
<v t="ekr.20041012114208.582"><vh>dlineinfo</vh></v>
<v t="ekr.20041012114208.583"><vh>see</vh></v>
</v>
<v t="ekr.20041012114208.584"><vh>window...</vh>
<v t="ekr.20041012114208.585"><vh>window_cget</vh></v>
<v t="ekr.20041012114208.586"><vh>window_configure</vh></v>
<v t="ekr.20041012114208.587"><vh>window_create</vh></v>
<v t="ekr.20041012114208.588"><vh>window_names</vh></v>
</v>
<v t="ekr.20041012114208.589"><vh>xview &amp; yview</vh>
<v t="ekr.20041012114208.590"><vh>xview</vh></v>
<v t="ekr.20041012114208.591"><vh>xview_moveto</vh></v>
<v t="ekr.20041012114208.592"><vh>xview_scroll</vh></v>
<v t="ekr.20041012114208.593"><vh>yview</vh></v>
<v t="ekr.20041012114208.594"><vh>yview_moveto</vh></v>
<v t="ekr.20041012114208.595"><vh>yview_scroll</vh></v>
<v t="ekr.20041012114208.596"><vh>yview_pickplace</vh></v>
</v>
</v>
<v t="ekr.20041012114208.597"><vh>class _setit (called only by OptionMenu.__init__)</vh>
<v t="ekr.20041012114208.598"><vh>__init__</vh></v>
<v t="ekr.20041012114208.599"><vh>__call__</vh></v>
</v>
<v t="ekr.20041012114208.600"><vh>class OptionMenu (Menubutton)</vh>
<v t="ekr.20041012114208.601"><vh>__init__</vh></v>
<v t="ekr.20041012114208.602"><vh>__getitem__</vh></v>
<v t="ekr.20041012114208.603"><vh>destroy</vh></v>
</v>
</v>
<v t="ekr.20041012114208.604"><vh>Image classes (see Tk docs)</vh>
<v t="ekr.20041012114208.605"><vh>class Image</vh>
<v t="ekr.20041012114208.606"><vh>__init__</vh></v>
<v t="ekr.20041012114208.607"><vh>__str__</vh></v>
<v t="ekr.20041012114208.608"><vh>__del__</vh></v>
<v t="ekr.20041012114208.609"><vh>__setitem__</vh></v>
<v t="ekr.20041012114208.610"><vh>__getitem__</vh></v>
<v t="ekr.20041012114208.611"><vh>configure</vh></v>
<v t="ekr.20041012114208.612"><vh>height</vh></v>
<v t="ekr.20041012114208.613"><vh>type</vh></v>
<v t="ekr.20041012114208.614"><vh>width</vh></v>
</v>
<v t="ekr.20041012114208.615"><vh>class PhotoImage (Image)</vh>
<v t="ekr.20041012114208.616"><vh>__init__</vh></v>
<v t="ekr.20041012114208.617"><vh>blank</vh></v>
<v t="ekr.20041012114208.618"><vh>cget</vh></v>
<v t="ekr.20041012114208.619"><vh>__getitem__</vh></v>
<v t="ekr.20041012114208.620"><vh>copy</vh></v>
<v t="ekr.20041012114208.621"><vh>zoom</vh></v>
<v t="ekr.20041012114208.622"><vh>subsample</vh></v>
<v t="ekr.20041012114208.623"><vh>get</vh></v>
<v t="ekr.20041012114208.624"><vh>put</vh></v>
<v t="ekr.20041012114208.625"><vh>write</vh></v>
</v>
<v t="ekr.20041012114208.626" a="E"><vh>class BitmapImage  (Image)</vh>
<v t="ekr.20041012114208.627"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20041012114208.628"><vh>Extension classes</vh>
<v t="ekr.20041012114208.629"><vh>class Studbutton</vh>
<v t="ekr.20041012114208.630"><vh>__init__</vh></v>
</v>
<v t="ekr.20041012114208.631"><vh>class Tributton</vh>
<v t="ekr.20041012114208.632"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20041012114208.633"><vh>functions</vh>
<v t="ekr.20041012114208.634"><vh>_cnfmerge</vh></v>
<v t="ekr.20041012114208.635"><vh>_flatten</vh></v>
<v t="ekr.20041012114208.636"><vh>_test (an example)</vh></v>
<v t="ekr.20041012114208.637"><vh>getint, getdouble, getboolean</vh></v>
<v t="ekr.20041012114208.638"><vh>image_names</vh></v>
<v t="ekr.20041012114208.639"><vh>image_types</vh></v>
<v t="ekr.20041012114208.640"><vh>Indices</vh>
<v t="ekr.20041012114208.641"><vh>AtEnd</vh></v>
<v t="ekr.20041012114208.642"><vh>AtInsert</vh></v>
<v t="ekr.20041012114208.643"><vh>AtSelFirst</vh></v>
<v t="ekr.20041012114208.644"><vh>AtSelLast</vh></v>
<v t="ekr.20041012114208.645"><vh>At</vh></v>
</v>
<v t="ekr.20041012114208.646"><vh>mainloop</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20041012114208">@nocolor

8/24/02

I use this file to study Tkinter.  The code in tkinter.py calls C language code in _tkinter.c.

Warning:  As distributed, all @file nodes are descendents of @ignore nodes.  This is on purpose.  Do _not_ try to recreate the actual source files from this file!</t>
<t tx="ekr.20041012114208.1">@nocolor
</t>
<t tx="ekr.20041012114208.2">"""Wrapper functions for Tcl/Tk.

Tkinter provides classes which allow the display, positioning and control of widgets. Toplevel widgets are Tk and Toplevel. Other widgets are Frame, Label, Entry, Text, Canvas, Button, Radiobutton, Checkbutton, Scale, Listbox, Scrollbar, OptionMenu. Properties of the widgets are specified with keyword arguments.  Keyword arguments have the same name as the corresponding resource under Tk.

Widgets are positioned with one of the geometry managers Place, Pack or Grid. These managers can be called with methods place, pack, grid available in every Widget.

Actions are bound to events by resources (e.g. keyword argument command) or with the method bind.

Example (Hello, World):
import Tkinter
from Tkconstants import *
tk = Tkinter.Tk()
frame = Tkinter.Frame(tk, relief=RIDGE, borderwidth=2)
frame.pack(fill=BOTH,expand=1)
label = Tkinter.Label(frame, text="Hello, World")
label.pack(fill=X, expand=1)
button = Tkinter.Button(frame,text="Exit",command=tk.destroy)
button.pack(side=BOTTOM)
tk.mainloop()
"""</t>
<t tx="ekr.20041012114208.3">Classes are as follows:

The Tk class represents the top level widget and its associated tcl interpreter.  

The Wm class provides an interface to the window manager.

The Misc class provides methods common to top level and interior widgets.

The Pack, Place and Grid classes define geometry managers.  User code should use the pack, place and grid methods defined for these classes.

Widget is an abstract base class for all widgets.  Widget derives from BaseWidget and Pack, Place and Grid.  BaseWidget derives from Misc.  Toplevel derives from BaseWidget and Wm.  All other widgers derived from Widget.  Therefore, all widgets have access to Misc methods.  All widgets except Toplevel have access to geometry managers.

Functions whose name start with an underscore are internal functions.</t>
<t tx="ekr.20041012114208.4">I'm not sure any of this is useful...

self.tk is the interface to _tkinter.

self.tk.call(s1,s2,...,sn) calls the tcl command s1 s2...sn and returns a Python string representing the tcl result.

self.tk.splitlist, self.tk.split, self.tk.getint, self.tk.getboolean, etc. convert tcl values to Python values. The Misc class contains wrappers like getboolean, _getints, etc.

self.tk.getvar and self.tk.setvar get and set tcl vars.

self.tk.createcommand and self.tk.deletecommands create and destroy tcl commands. (procs?)

Several classes use aliases for methods.  These aliases are, I think, class vars.  I'm not sure why they are used.

The constants in Tkconstants are merely strings, e.g. TOP = 'top', etc.  I have no idea why these are useful.
</t>
<t tx="ekr.20041012114208.5">self.tk is a _tkinter instance.  All calls to _tkinter are made via self.tk

Tk.__init__ contains:

	self.tk = _tkinter.create(screenName, baseName, className)
</t>
<t tx="ekr.20041012114208.6">The arguments to self.tk.call are a list of strings that are concatenated to produces a tcl command.  Return values are Python strings reprenting the tcl strings returned from the tcl interpreter.

name = self.tk.call(args)</t>
<t tx="ekr.20041012114208.7">Return values can be converted to Python values as follows

1. tk.getboolean(self,s)

Converts Tcl boolean s to Python boolean.  Example:

self.tk.getboolean(self.tk.call('set', 'tk_strictMotif', boolean))

2. tk.splitlist

Presumably splits a tcl list into a Python list.  Example

return self.tk.splitlist(self.tk.call(args))

3. tk.split

Splits a tcl list into a Python list.  Example:

4.  _getints, _getdoubles, _getboolean

_getints converts a tcl list containing tcl ints into a tuple of ints.

def _getints(self, string):
    if string:
        return tuple(map(getint, self.tk.splitlist(string)))


5. Regular Python conversions:  getint, getdouble, etc.</t>
<t tx="ekr.20041012114208.8">self.tk.getvar('tk_version') returns the value of the tcl var (a string)

def getvar(self, name='PY_VAR'):
"""Return value of Tcl variable NAME."""


self.tk.setvar(name, value) sets the tcl var

def setvar(self, name='PY_VAR', value='1'):
"""Set Tcl variable NAME to VALUE."""</t>
<t tx="ekr.20041012114208.9">self.tk.createcommand

docstring for Misc._register:

"""Return a newly created Tcl function. If this function is called, the Python function FUNC will be executed. An optional function SUBST can be given which will be executed before FUNC."""

self.tk.createcommand('tkerror', _tkerror)
self.tk.createcommand('exit', _exit)


self.tk.deletecommand(name)</t>
<t tx="ekr.20041012114208.10"></t>
<t tx="ekr.20041012114208.11">/***********************************************************
Copyright (C) 1994 Steen Lumholt.

                        All Rights Reserved

******************************************************************/

/* _tkinter.c -- Interface to libtk.a and libtcl.a. */

/* TCL/TK VERSION INFO:

	Only Tcl/Tk 8.0 and later are supported.  Older versions are not
	supported.  (Use Python 1.5.2 if you cannot upgrade your Tcl/Tk
	libraries.)
*/

/* XXX Further speed-up ideas, involving Tcl 8.0 features:

   - In Tcl_Call(), create Tcl objects from the arguments, possibly using
   intelligent mappings between Python objects and Tcl objects (e.g. ints,
   floats and Tcl window pointers could be handled specially).

   - Register a new Tcl type, "Python callable", which can be called more
   efficiently and passed to Tcl_EvalObj() directly (if this is possible).

*/
@language c
@ignore
&lt;&lt; _tkinter includes &gt;&gt;

&lt;&lt; _tkinter declarations &gt;&gt;
@others</t>
<t tx="ekr.20041012114208.12">#include "Python.h"
#include &lt;ctype.h&gt;

#ifdef WITH_THREAD
#include "pythread.h"
#endif

#ifdef MS_WINDOWS
#include &lt;windows.h&gt;
#endif

#ifdef macintosh
#define MAC_TCL
#endif

#ifdef TK_FRAMEWORK
#include &lt;Tcl/tcl.h&gt;
#include &lt;Tk/tk.h&gt;
#else
#include &lt;tcl.h&gt;
#include &lt;tk.h&gt;
#endif

#if defined(macintosh)
/* Sigh, we have to include this to get at the tcl qd pointer */
#include &lt;tkMac.h&gt;
/* And this one we need to clear the menu bar */
#include &lt;Menus.h&gt;
#endif
</t>
<t tx="ekr.20041012114208.13">#define TKMAJORMINOR (TK_MAJOR_VERSION*1000 + TK_MINOR_VERSION)

#if TKMAJORMINOR &lt; 8000
#error "Tk older than 8.0 not supported"
#endif

#if !(defined(MS_WINDOWS) || defined(__CYGWIN__) || defined(macintosh))
/* Mac has it, but it doesn't really work:-( */
#define HAVE_CREATEFILEHANDLER
#endif

#ifdef HAVE_CREATEFILEHANDLER

/* Tcl_CreateFileHandler() changed several times; these macros deal with the
   messiness.  In Tcl 8.0 and later, it is not available on Windows (and on
   Unix, only because Jack added it back); when available on Windows, it only
   applies to sockets. */

#ifdef MS_WINDOWS
#define FHANDLETYPE TCL_WIN_SOCKET
#else
#define FHANDLETYPE TCL_UNIX_FD
#endif

/* If Tcl can wait for a Unix file descriptor, define the EventHook() routine
   which uses this to handle Tcl events while the user is typing commands. */

#if FHANDLETYPE == TCL_UNIX_FD
#define WAIT_FOR_STDIN
#endif

#endif /* HAVE_CREATEFILEHANDLER */

#ifdef MS_WINDOWS
#include &lt;conio.h&gt;
#define WAIT_FOR_STDIN
#endif

&lt;&lt; Thread declarations &gt;&gt;

#ifdef macintosh

/*
** Additional cruft needed by Tcl/Tk on the Mac.
** This is for Tcl 7.5 and Tk 4.1 (patch release 1).
*/

/* ckfree() expects a char* */
#define FREECAST (char *)

#include &lt;Events.h&gt; /* For EventRecord */

typedef int (*TclMacConvertEventPtr) (EventRecord *eventPtr);
void Tcl_MacSetEventProc(TclMacConvertEventPtr procPtr);
int TkMacConvertEvent(EventRecord *eventPtr);

staticforward int PyMacConvertEvent(EventRecord *eventPtr);

#include &lt;SIOUX.h&gt;
extern int SIOUXIsAppWindow(WindowPtr);

#endif /* macintosh */

#ifndef FREECAST
#define FREECAST (char *)
#endif

/**** Tkapp Object Declaration ****/

staticforward PyTypeObject Tkapp_Type;

typedef struct {
	PyObject_HEAD
	Tcl_Interp *interp;
} TkappObject;

#define Tkapp_Check(v) ((v)-&gt;ob_type == &amp;Tkapp_Type)
#define Tkapp_Interp(v) (((TkappObject *) (v))-&gt;interp)
#define Tkapp_Result(v) Tcl_GetStringResult(Tkapp_Interp(v))

#define DEBUG_REFCNT(v) (printf("DEBUG: id=%p, refcnt=%i\n", \
(void *) v, ((PyObject *) v)-&gt;ob_refcnt))


/**** Error Handling ****/

static PyObject *Tkinter_TclError;
static int quitMainLoop = 0;
static int errorInCmd = 0;
static PyObject *excInCmd;
static PyObject *valInCmd;
static PyObject *trbInCmd;</t>
<t tx="ekr.20041012114208.14">#ifdef WITH_THREAD

/* The threading situation is complicated.  Tcl is not thread-safe, except for
   Tcl 8.1, which will probably remain in alpha status for another 6 months
   (and the README says that Tk will probably remain thread-unsafe forever).
   So we need to use a lock around all uses of Tcl.  Previously, the Python
   interpreter lock was used for this.  However, this causes problems when
   other Python threads need to run while Tcl is blocked waiting for events.

   To solve this problem, a separate lock for Tcl is introduced.  Holding it
   is incompatible with holding Python's interpreter lock.  The following four
   macros manipulate both locks together.

   ENTER_TCL and LEAVE_TCL are brackets, just like Py_BEGIN_ALLOW_THREADS and
   Py_END_ALLOW_THREADS.  They should be used whenever a call into Tcl is made
   that could call an event handler, or otherwise affect the state of a Tcl
   interpreter.  These assume that the surrounding code has the Python
   interpreter lock; inside the brackets, the Python interpreter lock has been 
   released and the lock for Tcl has been acquired.

   Sometimes, it is necessary to have both the Python lock and the Tcl lock.
   (For example, when transferring data from the Tcl interpreter result to a
   Python string object.)  This can be done by using different macros to close
   the ENTER_TCL block: ENTER_OVERLAP reacquires the Python lock (and restores
   the thread state) but doesn't release the Tcl lock; LEAVE_OVERLAP_TCL
   releases the Tcl lock.

   By contrast, ENTER_PYTHON and LEAVE_PYTHON are used in Tcl event
   handlers when the handler needs to use Python.  Such event handlers are
   entered while the lock for Tcl is held; the event handler presumably needs
   to use Python.  ENTER_PYTHON releases the lock for Tcl and acquires
   the Python interpreter lock, restoring the appropriate thread state, and
   LEAVE_PYTHON releases the Python interpreter lock and re-acquires the lock
   for Tcl.  It is okay for ENTER_TCL/LEAVE_TCL pairs to be contained inside
   the code between ENTER_PYTHON and LEAVE_PYTHON.

   These locks expand to several statements and brackets; they should not be
   used in branches of if statements and the like.

*/

static PyThread_type_lock tcl_lock = 0;
static PyThreadState *tcl_tstate = NULL;

#define ENTER_TCL \
	{ PyThreadState *tstate = PyThreadState_Get(); Py_BEGIN_ALLOW_THREADS \
	    PyThread_acquire_lock(tcl_lock, 1); tcl_tstate = tstate;

#define LEAVE_TCL \
    tcl_tstate = NULL; PyThread_release_lock(tcl_lock); Py_END_ALLOW_THREADS}

#define ENTER_OVERLAP \
	Py_END_ALLOW_THREADS

#define LEAVE_OVERLAP_TCL \
	tcl_tstate = NULL; PyThread_release_lock(tcl_lock); }

#define ENTER_PYTHON \
	{ PyThreadState *tstate = tcl_tstate; tcl_tstate = NULL; \
            PyThread_release_lock(tcl_lock); PyEval_RestoreThread((tstate)); }

#define LEAVE_PYTHON \
	{ PyThreadState *tstate = PyEval_SaveThread(); \
            PyThread_acquire_lock(tcl_lock, 1); tcl_tstate = tstate; }

#else

#define ENTER_TCL
#define LEAVE_TCL
#define ENTER_OVERLAP
#define LEAVE_OVERLAP_TCL
#define ENTER_PYTHON
#define LEAVE_PYTHON

#endif</t>
<t tx="ekr.20041012114208.15">// *** Tkapp Method List ***

static PyMethodDef Tkapp_methods[] =
{
	{"call", 	       Tkapp_Call, 0},
	{"globalcall", 	 Tkapp_GlobalCall, 0},
	{"eval", 	       Tkapp_Eval, 1},
	{"globaleval", 	       Tkapp_GlobalEval, 1},
	{"evalfile", 	       Tkapp_EvalFile, 1},
	{"record", 	       Tkapp_Record, 1},
	{"adderrorinfo",       Tkapp_AddErrorInfo, 1},
	{"setvar", 	       Tkapp_SetVar, 1},
	{"globalsetvar",       Tkapp_GlobalSetVar, 1},
	{"getvar", 	       Tkapp_GetVar, 1},
	{"globalgetvar",       Tkapp_GlobalGetVar, 1},
	{"unsetvar", 	       Tkapp_UnsetVar, 1},
	{"globalunsetvar",     Tkapp_GlobalUnsetVar, 1},
	{"getint", 	       Tkapp_GetInt, 1},
	{"getdouble", 	       Tkapp_GetDouble, 1},
	{"getboolean", 	       Tkapp_GetBoolean, 1},
	{"exprstring", 	       Tkapp_ExprString, 1},
	{"exprlong", 	       Tkapp_ExprLong, 1},
	{"exprdouble", 	       Tkapp_ExprDouble, 1},
	{"exprboolean",        Tkapp_ExprBoolean, 1},
	{"splitlist", 	       Tkapp_SplitList, 1},
	{"split", 	       Tkapp_Split, 1},
	{"merge", 	       Tkapp_Merge, 0},
	{"createcommand",      Tkapp_CreateCommand, 1},
	{"deletecommand",      Tkapp_DeleteCommand, 1},
#ifdef HAVE_CREATEFILEHANDLER
	{"createfilehandler",  Tkapp_CreateFileHandler, 1},
	{"deletefilehandler",  Tkapp_DeleteFileHandler, 1},
#endif
	{"createtimerhandler", Tkapp_CreateTimerHandler, 1},
	{"mainloop", 	       Tkapp_MainLoop, 1},
	{"dooneevent", 	       Tkapp_DoOneEvent, 1},
	{"quit", 	       Tkapp_Quit, 1},
	{"interpaddr",         Tkapp_InterpAddr, 1},
	{NULL, 		       NULL}
};
</t>
<t tx="ekr.20041012114208.16">static PyObject *
Tkinter_Error(PyObject *v)
{
	PyErr_SetString(Tkinter_TclError, Tkapp_Result(v));
	return NULL;
}
</t>
<t tx="ekr.20041012114208.17">//  *** Utils ***</t>
<t tx="ekr.20041012114208.18">
#ifdef WITH_THREAD
#ifndef MS_WINDOWS

//Millisecond sleep() for Unix platforms.
static void
Sleep(int milli)
{
	/* XXX Too bad if you don't have select(). */
	struct timeval t;
	t.tv_sec = milli/1000;
	t.tv_usec = (milli%1000) * 1000;
	select(0, (fd_set *)0, (fd_set *)0, (fd_set *)0, &amp;t);
}

#endif /* MS_WINDOWS */
#endif /* WITH_THREAD */</t>
<t tx="ekr.20041012114208.19">static char *
AsString(PyObject *value, PyObject *tmp)
{
	if (PyString_Check(value))
		return PyString_AsString(value);
#ifdef Py_USING_UNICODE
	else if (PyUnicode_Check(value)) {
		PyObject *v = PyUnicode_AsUTF8String(value);
		if (v == NULL)
			return NULL;
		if (PyList_Append(tmp, v) != 0) {
			Py_DECREF(v);
			return NULL;
		}
		Py_DECREF(v);
		return PyString_AsString(v);
	}
#endif
	else {
		PyObject *v = PyObject_Str(value);
		if (v == NULL)
			return NULL;
		if (PyList_Append(tmp, v) != 0) {
			Py_DECREF(v);
			return NULL;
		}
		Py_DECREF(v);
		return PyString_AsString(v);
	}
}
</t>
<t tx="ekr.20041012114208.20">@ define ARGSZ 64
@c

static char *
Merge(PyObject *args)
{
	PyObject *tmp = NULL;
	char *argvStore[ARGSZ];
	char **argv = NULL;
	int fvStore[ARGSZ];
	int *fv = NULL;
	int argc = 0, fvc = 0, i;
	char *res = NULL;

	if (!(tmp = PyList_New(0)))
	    return NULL;

	argv = argvStore;
	fv = fvStore;

	if (args == NULL)
		argc = 0;

	else if (!PyTuple_Check(args)) {
		argc = 1;
		fv[0] = 0;
		if (!(argv[0] = AsString(args, tmp)))
			goto finally;
	}
	else {
		argc = PyTuple_Size(args);

		if (argc &gt; ARGSZ) {
			argv = (char **)ckalloc(argc * sizeof(char *));
			fv = (int *)ckalloc(argc * sizeof(int));
			if (argv == NULL || fv == NULL) {
				PyErr_NoMemory();
				goto finally;
			}
		}

		for (i = 0; i &lt; argc; i++) {
			PyObject *v = PyTuple_GetItem(args, i);
			if (PyTuple_Check(v)) {
				fv[i] = 1;
				if (!(argv[i] = Merge(v)))
					goto finally;
				fvc++;
			}
			else if (v == Py_None) {
				argc = i;
				break;
			}
			else {
				fv[i] = 0;
				if (!(argv[i] = AsString(v, tmp)))
					goto finally;
				fvc++;
			}
		}
	}
	res = Tcl_Merge(argc, argv);
	if (res == NULL)
		PyErr_SetString(Tkinter_TclError, "merge failed");

  finally:
	for (i = 0; i &lt; fvc; i++)
		if (fv[i]) {
			ckfree(argv[i]);
		}
	if (argv != argvStore)
		ckfree(FREECAST argv);
	if (fv != fvStore)
		ckfree(FREECAST fv);

	Py_DECREF(tmp);
	return res;
}
</t>
<t tx="ekr.20041012114208.21">static PyObject *
Split(char *list)
{
	int argc;
	char **argv;
	PyObject *v;

	if (list == NULL) {
		Py_INCREF(Py_None);
		return Py_None;
	}

	if (Tcl_SplitList((Tcl_Interp *)NULL, list, &amp;argc, &amp;argv) != TCL_OK) {
		/* Not a list.
		 * Could be a quoted string containing funnies, e.g. {"}.
		 * Return the string itself.
		 */
		return PyString_FromString(list);
	}

	if (argc == 0)
		v = PyString_FromString("");
	else if (argc == 1)
		v = PyString_FromString(argv[0]);
	else if ((v = PyTuple_New(argc)) != NULL) {
		int i;
		PyObject *w;

		for (i = 0; i &lt; argc; i++) {
			if ((w = Split(argv[i])) == NULL) {
				Py_DECREF(v);
				v = NULL;
				break;
			}
			PyTuple_SetItem(v, i, w);
		}
	}
	Tcl_Free(FREECAST argv);
	return v;
}
</t>
<t tx="ekr.20041012114208.22">// *** Tkapp Object ***</t>
<t tx="ekr.20041012114208.23">#ifndef WITH_APPINIT

int
Tcl_AppInit(Tcl_Interp *interp)
{
	Tk_Window main;

	main = Tk_MainWindow(interp);
	if (Tcl_Init(interp) == TCL_ERROR) {
		PySys_WriteStderr("Tcl_Init error: %s\n", Tcl_GetStringResult(interp));
		return TCL_ERROR;
	}
	if (Tk_Init(interp) == TCL_ERROR) {
		PySys_WriteStderr("Tk_Init error: %s\n", Tcl_GetStringResult(interp));
		return TCL_ERROR;
	}
	return TCL_OK;
}

# endif /* !WITH_APPINIT */</t>
<t tx="ekr.20041012114208.24">/* Initialize the Tk application; see the `main' function in
 * `tkMain.c'.
 */

static void EnableEventHook(void); /* Forward */
static void DisableEventHook(void); /* Forward */

static TkappObject *
Tkapp_New(char *screenName, char *baseName, char *className, int interactive)
{
	TkappObject *v;
	char *argv0;
  
	v = PyObject_New(TkappObject, &amp;Tkapp_Type);
	if (v == NULL)
		return NULL;

	v-&gt;interp = Tcl_CreateInterp();

#if defined(macintosh)
	/* This seems to be needed */
	ClearMenuBar();
	TkMacInitMenus(v-&gt;interp);
#endif

	/* Delete the 'exit' command, which can screw things up */
	Tcl_DeleteCommand(v-&gt;interp, "exit");

	if (screenName != NULL)
		Tcl_SetVar2(v-&gt;interp, "env", "DISPLAY",
			    screenName, TCL_GLOBAL_ONLY);

	if (interactive)
		Tcl_SetVar(v-&gt;interp, "tcl_interactive", "1", TCL_GLOBAL_ONLY);
	else
		Tcl_SetVar(v-&gt;interp, "tcl_interactive", "0", TCL_GLOBAL_ONLY);

	/* This is used to get the application class for Tk 4.1 and up */
	argv0 = (char*)ckalloc(strlen(className) + 1);
	if (!argv0) {
		PyErr_NoMemory();
		Py_DECREF(v);
		return NULL;
	}

	strcpy(argv0, className);
	if (isupper((int)(argv0[0])))
		argv0[0] = tolower(argv0[0]);
	Tcl_SetVar(v-&gt;interp, "argv0", argv0, TCL_GLOBAL_ONLY);
	ckfree(argv0);

	if (Tcl_AppInit(v-&gt;interp) != TCL_OK)
		return (TkappObject *)Tkinter_Error((PyObject *)v);

	EnableEventHook();

	return v;
}
</t>
<t tx="ekr.20041012114208.25">@ * Tcl Eval *</t>
<t tx="ekr.20041012114208.26">#if TKMAJORMINOR &gt;= 8001
#define USING_OBJECTS
#endif

#ifdef USING_OBJECTS

static Tcl_Obj*
AsObj(PyObject *value)
{
	Tcl_Obj *result;

	if (PyString_Check(value))
		return Tcl_NewStringObj(PyString_AS_STRING(value),
					PyString_GET_SIZE(value));
	else if (PyInt_Check(value))
		return Tcl_NewLongObj(PyInt_AS_LONG(value));
	else if (PyFloat_Check(value))
		return Tcl_NewDoubleObj(PyFloat_AS_DOUBLE(value));
	else if (PyTuple_Check(value)) {
		Tcl_Obj **argv = (Tcl_Obj**)
			ckalloc(PyTuple_Size(value)*sizeof(Tcl_Obj*));
		int i;
		if(!argv)
		  return 0;
		for(i=0;i&lt;PyTuple_Size(value);i++)
		  argv[i] = AsObj(PyTuple_GetItem(value,i));
		result = Tcl_NewListObj(PyTuple_Size(value), argv);
		ckfree(FREECAST argv);
		return result;
	}
#ifdef Py_USING_UNICODE
	else if (PyUnicode_Check(value)) {
#if TKMAJORMINOR &lt;= 8001
		/* In Tcl 8.1 we must use UTF-8 */
		PyObject* utf8 = PyUnicode_AsUTF8String(value);
		if (!utf8)
			return 0;
		result = Tcl_NewStringObj(PyString_AS_STRING(utf8),
					  PyString_GET_SIZE(utf8));
		Py_DECREF(utf8);
		return result;
#else /* TKMAJORMINOR &gt; 8001 */
		/* In Tcl 8.2 and later, use Tcl_NewUnicodeObj() */
		if (sizeof(Py_UNICODE) != sizeof(Tcl_UniChar)) {
			/* XXX Should really test this at compile time */
			PyErr_SetString(PyExc_SystemError,
				"Py_UNICODE and Tcl_UniChar differ in size");
			return 0;
		}
		return Tcl_NewUnicodeObj(PyUnicode_AS_UNICODE(value),
					 PyUnicode_GET_SIZE(value));
#endif /* TKMAJORMINOR &gt; 8001 */
	}
#endif
	else {
		PyObject *v = PyObject_Str(value);
		if (!v)
			return 0;
		result = AsObj(v);
		Py_DECREF(v);
		return result;
	}
}
</t>
<t tx="ekr.20041012114208.27">static PyObject *
Tkapp_Call(PyObject *self, PyObject *args)
{
	Tcl_Obj *objStore[ARGSZ];
	Tcl_Obj **objv = NULL;
	int objc = 0, i;
	PyObject *res = NULL;
	Tcl_Interp *interp = Tkapp_Interp(self);
	/* Could add TCL_EVAL_GLOBAL if wrapped by GlobalCall... */
	int flags = TCL_EVAL_DIRECT;

	objv = objStore;

	if (args == NULL)
		/* do nothing */;

	else if (!PyTuple_Check(args)) {
		objv[0] = AsObj(args);
		if (objv[0] == 0)
			goto finally;
		objc = 1;
		Tcl_IncrRefCount(objv[0]);
	}
	else {
		objc = PyTuple_Size(args);

		if (objc &gt; ARGSZ) {
			objv = (Tcl_Obj **)ckalloc(objc * sizeof(char *));
			if (objv == NULL) {
				PyErr_NoMemory();
				objc = 0;
				goto finally;
			}
		}

		for (i = 0; i &lt; objc; i++) {
			PyObject *v = PyTuple_GetItem(args, i);
			if (v == Py_None) {
				objc = i;
				break;
			}
			objv[i] = AsObj(v);
			if (!objv[i]) {
				/* Reset objc, so it attempts to clear
				   objects only up to i. */
				objc = i;
				goto finally;
			}
			Tcl_IncrRefCount(objv[i]);
		}
	}

	ENTER_TCL

	i = Tcl_EvalObjv(interp, objc, objv, flags);

	ENTER_OVERLAP
	if (i == TCL_ERROR)
		Tkinter_Error(self);
	else {
		/* We could request the object result here, but doing
		   so would confuse applications that expect a string. */
		char *s = Tcl_GetStringResult(interp);
		char *p = s;

		/* If the result contains any bytes with the top bit set,
		   it's UTF-8 and we should decode it to Unicode */
#ifdef Py_USING_UNICODE
		while (*p != '\0') {
			if (*p &amp; 0x80)
				break;
			p++;
		}

		if (*p == '\0')
			res = PyString_FromStringAndSize(s, (int)(p-s));
		else {
			/* Convert UTF-8 to Unicode string */
			p = strchr(p, '\0');
			res = PyUnicode_DecodeUTF8(s, (int)(p-s), "strict");
			if (res == NULL) {
			    PyErr_Clear();
			    res = PyString_FromStringAndSize(s, (int)(p-s));
			}
		}
#else
		p = strchr(p, '\0');
		res = PyString_FromStringAndSize(s, (int)(p-s));
#endif
	}

	LEAVE_OVERLAP_TCL

  finally:
	for (i = 0; i &lt; objc; i++)
		Tcl_DecrRefCount(objv[i]);
	if (objv != objStore)
		ckfree(FREECAST objv);
	return res;
}
</t>
<t tx="ekr.20041012114208.28"># else /* !USING_OBJECTS */

static PyObject *
Tkapp_Call(PyObject *self, PyObject *args)
{
	/* This is copied from Merge() */
	PyObject *tmp = NULL;
	char *argvStore[ARGSZ];
	char **argv = NULL;
	int fvStore[ARGSZ];
	int *fv = NULL;
	int argc = 0, fvc = 0, i;
	PyObject *res = NULL; /* except this has a different type */
	Tcl_CmdInfo info; /* and this is added */
	Tcl_Interp *interp = Tkapp_Interp(self); /* and this too */

	if (!(tmp = PyList_New(0)))
	    return NULL;

	argv = argvStore;
	fv = fvStore;

	if (args == NULL)
		argc = 0;

	else if (!PyTuple_Check(args)) {
		argc = 1;
		fv[0] = 0;
		if (!(argv[0] = AsString(args, tmp)))
			goto finally;
	}
	else {
		argc = PyTuple_Size(args);

		if (argc &gt; ARGSZ) {
			argv = (char **)ckalloc(argc * sizeof(char *));
			fv = (int *)ckalloc(argc * sizeof(int));
			if (argv == NULL || fv == NULL) {
				PyErr_NoMemory();
				goto finally;
			}
		}

		for (i = 0; i &lt; argc; i++) {
			PyObject *v = PyTuple_GetItem(args, i);
			if (PyTuple_Check(v)) {
				fv[i] = 1;
				if (!(argv[i] = Merge(v)))
					goto finally;
				fvc++;
			}
			else if (v == Py_None) {
				argc = i;
				break;
			}
			else {
				fv[i] = 0;
				if (!(argv[i] = AsString(v, tmp)))
					goto finally;
				fvc++;
			}
		}
	}
	/* End code copied from Merge() */

	/* All this to avoid a call to Tcl_Merge() and the corresponding call
	   to Tcl_SplitList() inside Tcl_Eval()...  It can save a bundle! */
	if (Py_VerboseFlag &gt;= 2) {
		for (i = 0; i &lt; argc; i++)
			PySys_WriteStderr("%s ", argv[i]);
	}
	ENTER_TCL
	info.proc = NULL;
	if (argc &lt; 1 ||
	    !Tcl_GetCommandInfo(interp, argv[0], &amp;info) ||
	    info.proc == NULL)
	{
		char *cmd;
		cmd = Tcl_Merge(argc, argv);
		i = Tcl_Eval(interp, cmd);
		ckfree(cmd);
	}
	else {
		Tcl_ResetResult(interp);
		i = (*info.proc)(info.clientData, interp, argc, argv);
	}
	ENTER_OVERLAP
	if (info.proc == NULL &amp;&amp; Py_VerboseFlag &gt;= 2)
		PySys_WriteStderr("... use TclEval ");
	if (i == TCL_ERROR) {
		if (Py_VerboseFlag &gt;= 2)
			PySys_WriteStderr("... error: '%s'\n",
				Tcl_GetStringResult(interp));
		Tkinter_Error(self);
	}
	else {
		if (Py_VerboseFlag &gt;= 2)
			PySys_WriteStderr("-&gt; '%s'\n", Tcl_GetStringResult(interp));
		res = PyString_FromString(Tcl_GetStringResult(interp));
	}
	LEAVE_OVERLAP_TCL

	/* Copied from Merge() again */
  finally:
	for (i = 0; i &lt; fvc; i++)
		if (fv[i]) {
			ckfree(argv[i]);
		}
	if (argv != argvStore)
		ckfree(FREECAST argv);
	if (fv != fvStore)
		ckfree(FREECAST fv);

	Py_DECREF(tmp);
	return res;
}

#endif /* !USING_OBJECTS */
</t>
<t tx="ekr.20041012114208.29">static PyObject *
Tkapp_GlobalCall(PyObject *self, PyObject *args)
{
	/* Could do the same here as for Tkapp_Call(), but this is not used
	   much, so I can't be bothered.  Unfortunately Tcl doesn't export a
	   way for the user to do what all its Global* variants do (save and
	   reset the scope pointer, call the local version, restore the saved
	   scope pointer). */

	char *cmd;
	PyObject *res = NULL;

	cmd  = Merge(args);
	if (cmd) {
		int err;
		ENTER_TCL
		err = Tcl_GlobalEval(Tkapp_Interp(self), cmd);
		ENTER_OVERLAP
		if (err == TCL_ERROR)
			res = Tkinter_Error(self);
		else
			res = PyString_FromString(Tkapp_Result(self));
		LEAVE_OVERLAP_TCL
		ckfree(cmd);
	}

	return res;
}
</t>
<t tx="ekr.20041012114208.30">static PyObject *
Tkapp_Eval(PyObject *self, PyObject *args)
{
	char *script;
	PyObject *res = NULL;
	int err;
  
	if (!PyArg_ParseTuple(args, "s:eval", &amp;script))
		return NULL;

	ENTER_TCL
	err = Tcl_Eval(Tkapp_Interp(self), script);
	ENTER_OVERLAP
	if (err == TCL_ERROR)
		res = Tkinter_Error(self);
	else
		res = PyString_FromString(Tkapp_Result(self));
	LEAVE_OVERLAP_TCL
	return res;
}
</t>
<t tx="ekr.20041012114208.31">static PyObject *
Tkapp_GlobalEval(PyObject *self, PyObject *args)
{
	char *script;
	PyObject *res = NULL;
	int err;

	if (!PyArg_ParseTuple(args, "s:globaleval", &amp;script))
		return NULL;

	ENTER_TCL
	err = Tcl_GlobalEval(Tkapp_Interp(self), script);
	ENTER_OVERLAP
	if (err == TCL_ERROR)
		res = Tkinter_Error(self);
	else
		res = PyString_FromString(Tkapp_Result(self));
	LEAVE_OVERLAP_TCL
	return res;
}
</t>
<t tx="ekr.20041012114208.32">static PyObject *
Tkapp_EvalFile(PyObject *self, PyObject *args)
{
	char *fileName;
	PyObject *res = NULL;
	int err;

	if (!PyArg_ParseTuple(args, "s:evalfile", &amp;fileName))
		return NULL;

	ENTER_TCL
	err = Tcl_EvalFile(Tkapp_Interp(self), fileName);
	ENTER_OVERLAP
	if (err == TCL_ERROR)
		res = Tkinter_Error(self);

	else
		res = PyString_FromString(Tkapp_Result(self));
	LEAVE_OVERLAP_TCL
	return res;
}
</t>
<t tx="ekr.20041012114208.33">static PyObject *
Tkapp_Record(PyObject *self, PyObject *args)
{
	char *script;
	PyObject *res = NULL;
	int err;

	if (!PyArg_ParseTuple(args, "s", &amp;script))
		return NULL;

	ENTER_TCL
	err = Tcl_RecordAndEval(Tkapp_Interp(self), script, TCL_NO_EVAL);
	ENTER_OVERLAP
	if (err == TCL_ERROR)
		res = Tkinter_Error(self);
	else
		res = PyString_FromString(Tkapp_Result(self));
	LEAVE_OVERLAP_TCL
	return res;
}
</t>
<t tx="ekr.20041012114208.34">static PyObject *
Tkapp_AddErrorInfo(PyObject *self, PyObject *args)
{
	char *msg;

	if (!PyArg_ParseTuple(args, "s:adderrorinfo", &amp;msg))
		return NULL;
	ENTER_TCL
	Tcl_AddErrorInfo(Tkapp_Interp(self), msg);
	LEAVE_TCL

	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="ekr.20041012114208.35">@ * Tcl Variable *</t>
<t tx="ekr.20041012114208.36">static PyObject *
SetVar(PyObject *self, PyObject *args, int flags)
{
	char *name1, *name2, *ok, *s;
	PyObject *newValue;
	PyObject *tmp;

	tmp = PyList_New(0);
	if (!tmp)
		return NULL;

	if (PyArg_ParseTuple(args, "sO:setvar", &amp;name1, &amp;newValue)) {
		/* XXX Merge? */
		s = AsString(newValue, tmp);
		if (s == NULL)
			return NULL;
		ENTER_TCL
		ok = Tcl_SetVar(Tkapp_Interp(self), name1, s, flags);
		LEAVE_TCL
	}
	else {
		PyErr_Clear();
		if (PyArg_ParseTuple(args, "ssO:setvar",
				     &amp;name1, &amp;name2, &amp;newValue)) {
			s = AsString(newValue, tmp);
			if (s == NULL)
				return NULL;
			ENTER_TCL
			ok = Tcl_SetVar2(Tkapp_Interp(self), name1, name2, 
					 s, flags);
			LEAVE_TCL
		}
		else {
			Py_DECREF(tmp);
			return NULL;
		}
	}
	Py_DECREF(tmp);

	if (!ok)
		return Tkinter_Error(self);

	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="ekr.20041012114208.37">static PyObject *
Tkapp_SetVar(PyObject *self, PyObject *args)
{
	return SetVar(self, args, TCL_LEAVE_ERR_MSG);
}
</t>
<t tx="ekr.20041012114208.38">static PyObject *
Tkapp_GlobalSetVar(PyObject *self, PyObject *args)
{
	return SetVar(self, args, TCL_LEAVE_ERR_MSG | TCL_GLOBAL_ONLY);
}
</t>
<t tx="ekr.20041012114208.39">static PyObject *
GetVar(PyObject *self, PyObject *args, int flags)
{
	char *name1, *name2=NULL, *s;
	PyObject *res = NULL;

	if (!PyArg_ParseTuple(args, "s|s:getvar", &amp;name1, &amp;name2))
		return NULL;
	ENTER_TCL
	if (name2 == NULL)
		s = Tcl_GetVar(Tkapp_Interp(self), name1, flags);

	else
		s = Tcl_GetVar2(Tkapp_Interp(self), name1, name2, flags);
	ENTER_OVERLAP

	if (s == NULL)
		res = Tkinter_Error(self);
	else
		res = PyString_FromString(s);
	LEAVE_OVERLAP_TCL
	return res;
}
</t>
<t tx="ekr.20041012114208.40">static PyObject *
Tkapp_GetVar(PyObject *self, PyObject *args)
{
	return GetVar(self, args, TCL_LEAVE_ERR_MSG);
}
</t>
<t tx="ekr.20041012114208.41">static PyObject *
Tkapp_GlobalGetVar(PyObject *self, PyObject *args)
{
	return GetVar(self, args, TCL_LEAVE_ERR_MSG | TCL_GLOBAL_ONLY);
}
</t>
<t tx="ekr.20041012114208.42">static PyObject *
UnsetVar(PyObject *self, PyObject *args, int flags)
{
	char *name1, *name2=NULL;
	PyObject *res = NULL;
	int code;

	if (!PyArg_ParseTuple(args, "s|s:unsetvar", &amp;name1, &amp;name2))
		return NULL;
	ENTER_TCL
	if (name2 == NULL)
		code = Tcl_UnsetVar(Tkapp_Interp(self), name1, flags);

	else
		code = Tcl_UnsetVar2(Tkapp_Interp(self), name1, name2, flags);
	ENTER_OVERLAP

	if (code == TCL_ERROR)
		res = Tkinter_Error(self);
	else {
		Py_INCREF(Py_None);
		res = Py_None;
	}
	LEAVE_OVERLAP_TCL
	return res;
}
</t>
<t tx="ekr.20041012114208.43">static PyObject *
Tkapp_UnsetVar(PyObject *self, PyObject *args)
{
	return UnsetVar(self, args, TCL_LEAVE_ERR_MSG);
}
</t>
<t tx="ekr.20041012114208.44">static PyObject *
Tkapp_GlobalUnsetVar(PyObject *self, PyObject *args)
{
	return UnsetVar(self, args, TCL_LEAVE_ERR_MSG | TCL_GLOBAL_ONLY);
}
</t>
<t tx="ekr.20041012114208.45">@ * Tcl to Python *
@c

static PyObject *
Tkapp_GetInt(PyObject *self, PyObject *args)
{
	char *s;
	int v;

	if (!PyArg_ParseTuple(args, "s:getint", &amp;s))
		return NULL;
	if (Tcl_GetInt(Tkapp_Interp(self), s, &amp;v) == TCL_ERROR)
		return Tkinter_Error(self);
	return Py_BuildValue("i", v);
}
</t>
<t tx="ekr.20041012114208.46">static PyObject *
Tkapp_GetDouble(PyObject *self, PyObject *args)
{
	char *s;
	double v;

	if (!PyArg_ParseTuple(args, "s:getdouble", &amp;s))
		return NULL;
	if (Tcl_GetDouble(Tkapp_Interp(self), s, &amp;v) == TCL_ERROR)
		return Tkinter_Error(self);
	return Py_BuildValue("d", v);
}
</t>
<t tx="ekr.20041012114208.47">static PyObject *
Tkapp_GetBoolean(PyObject *self, PyObject *args)
{
	char *s;
	int v;

	if (!PyArg_ParseTuple(args, "s:getboolean", &amp;s))
		return NULL;
	if (Tcl_GetBoolean(Tkapp_Interp(self), s, &amp;v) == TCL_ERROR)
		return Tkinter_Error(self);
	return Py_BuildValue("i", v);
}
</t>
<t tx="ekr.20041012114208.48">static PyObject *
Tkapp_ExprString(PyObject *self, PyObject *args)
{
	char *s;
	PyObject *res = NULL;
	int retval;

	if (!PyArg_ParseTuple(args, "s:exprstring", &amp;s))
		return NULL;
	ENTER_TCL
	retval = Tcl_ExprString(Tkapp_Interp(self), s);
	ENTER_OVERLAP
	if (retval == TCL_ERROR)
		res = Tkinter_Error(self);
	else
		res = Py_BuildValue("s", Tkapp_Result(self));
	LEAVE_OVERLAP_TCL
	return res;
}
</t>
<t tx="ekr.20041012114208.49">static PyObject *
Tkapp_ExprLong(PyObject *self, PyObject *args)
{
	char *s;
	PyObject *res = NULL;
	int retval;
	long v;

	if (!PyArg_ParseTuple(args, "s:exprlong", &amp;s))
		return NULL;
	ENTER_TCL
	retval = Tcl_ExprLong(Tkapp_Interp(self), s, &amp;v);
	ENTER_OVERLAP
	if (retval == TCL_ERROR)
		res = Tkinter_Error(self);
	else
		res = Py_BuildValue("l", v);
	LEAVE_OVERLAP_TCL
	return res;
}
</t>
<t tx="ekr.20041012114208.50">static PyObject *
Tkapp_ExprDouble(PyObject *self, PyObject *args)
{
	char *s;
	PyObject *res = NULL;
	double v;
	int retval;

	if (!PyArg_ParseTuple(args, "s:exprdouble", &amp;s))
		return NULL;
	PyFPE_START_PROTECT("Tkapp_ExprDouble", return 0)
	ENTER_TCL
	retval = Tcl_ExprDouble(Tkapp_Interp(self), s, &amp;v);
	ENTER_OVERLAP
	PyFPE_END_PROTECT(retval)
	if (retval == TCL_ERROR)
		res = Tkinter_Error(self);
	else
		res = Py_BuildValue("d", v);
	LEAVE_OVERLAP_TCL
	return res;
}
</t>
<t tx="ekr.20041012114208.51">static PyObject *
Tkapp_ExprBoolean(PyObject *self, PyObject *args)
{
	char *s;
	PyObject *res = NULL;
	int retval;
	int v;

	if (!PyArg_ParseTuple(args, "s:exprboolean", &amp;s))
		return NULL;
	ENTER_TCL
	retval = Tcl_ExprBoolean(Tkapp_Interp(self), s, &amp;v);
	ENTER_OVERLAP
	if (retval == TCL_ERROR)
		res = Tkinter_Error(self);
	else
		res = Py_BuildValue("i", v);
	LEAVE_OVERLAP_TCL
	return res;
}
</t>
<t tx="ekr.20041012114208.52">static PyObject *
Tkapp_SplitList(PyObject *self, PyObject *args)
{
	char *list;
	int argc;
	char **argv;
	PyObject *v;
	int i;

	if (!PyArg_ParseTuple(args, "s:splitlist", &amp;list))
		return NULL;

	if (Tcl_SplitList(Tkapp_Interp(self), list, &amp;argc, &amp;argv) == TCL_ERROR)
		return Tkinter_Error(self);

	if (!(v = PyTuple_New(argc)))
		return NULL;
	
	for (i = 0; i &lt; argc; i++) {
		PyObject *s = PyString_FromString(argv[i]);
		if (!s || PyTuple_SetItem(v, i, s)) {
			Py_DECREF(v);
			v = NULL;
			goto finally;
		}
	}

  finally:
	ckfree(FREECAST argv);
	return v;
}
</t>
<t tx="ekr.20041012114208.53">static PyObject *
Tkapp_Split(PyObject *self, PyObject *args)
{
	char *list;

	if (!PyArg_ParseTuple(args, "s:split", &amp;list))
		return NULL;
	return Split(list);
}
</t>
<t tx="ekr.20041012114208.54">static PyObject *
Tkapp_Merge(PyObject *self, PyObject *args)
{
	char *s = Merge(args);
	PyObject *res = NULL;

	if (s) {
		res = PyString_FromString(s);
		ckfree(s);
	}

	return res;
}
</t>
<t tx="ekr.20041012114208.55">@ * Tcl Command *</t>
<t tx="ekr.20041012114208.56">typedef struct {
	PyObject *self;
	PyObject *func;
} PythonCmd_ClientData;
</t>
<t tx="ekr.20041012114208.57">static int
PythonCmd_Error(Tcl_Interp *interp)
{
	errorInCmd = 1;
	PyErr_Fetch(&amp;excInCmd, &amp;valInCmd, &amp;trbInCmd);
	LEAVE_PYTHON
	return TCL_ERROR;
}
</t>
<t tx="ekr.20041012114208.58">@ This is the Tcl command that acts as a wrapper for Python * function or method.
@c

static int
PythonCmd(ClientData clientData, Tcl_Interp *interp, int argc, char *argv[])
{
	PythonCmd_ClientData *data = (PythonCmd_ClientData *)clientData;
	PyObject *self, *func, *arg, *res, *tmp;
	int i, rv;
	char *s;

	ENTER_PYTHON

	/* TBD: no error checking here since we know, via the
	 * Tkapp_CreateCommand() that the client data is a two-tuple
	 */
	self = data-&gt;self;
	func = data-&gt;func;

	/* Create argument list (argv1, ..., argvN) */
	if (!(arg = PyTuple_New(argc - 1)))
		return PythonCmd_Error(interp);

	for (i = 0; i &lt; (argc - 1); i++) {
		PyObject *s = PyString_FromString(argv[i + 1]);
		if (!s || PyTuple_SetItem(arg, i, s)) {
			Py_DECREF(arg);
			return PythonCmd_Error(interp);
		}
	}
	res = PyEval_CallObject(func, arg);
	Py_DECREF(arg);

	if (res == NULL)
		return PythonCmd_Error(interp);

	if (!(tmp = PyList_New(0))) {
		Py_DECREF(res);
		return PythonCmd_Error(interp);
	}

	s = AsString(res, tmp);
	if (s == NULL) {
		rv = PythonCmd_Error(interp);
	}
	else {
		Tcl_SetResult(Tkapp_Interp(self), s, TCL_VOLATILE);
		rv = TCL_OK;
	}

	Py_DECREF(res);
	Py_DECREF(tmp);

	LEAVE_PYTHON

	return rv;
}
</t>
<t tx="ekr.20041012114208.59">static void
PythonCmdDelete(ClientData clientData)
{
	PythonCmd_ClientData *data = (PythonCmd_ClientData *)clientData;

	ENTER_PYTHON
	Py_XDECREF(data-&gt;self);
	Py_XDECREF(data-&gt;func);
	PyMem_DEL(data);
	LEAVE_PYTHON
}
</t>
<t tx="ekr.20041012114208.60">static PyObject *
Tkapp_CreateCommand(PyObject *self, PyObject *args)
{
	PythonCmd_ClientData *data;
	char *cmdName;
	PyObject *func;
	Tcl_Command err;

	if (!PyArg_ParseTuple(args, "sO:createcommand", &amp;cmdName, &amp;func))
		return NULL;
	if (!PyCallable_Check(func)) {
		PyErr_SetString(PyExc_TypeError, "command not callable");
		return NULL;
	}

	data = PyMem_NEW(PythonCmd_ClientData, 1);
	if (!data)
		return NULL;
	Py_XINCREF(self);
	Py_XINCREF(func);
	data-&gt;self = self;
	data-&gt;func = func;

	ENTER_TCL
	err = Tcl_CreateCommand(Tkapp_Interp(self), cmdName, PythonCmd,
				(ClientData)data, PythonCmdDelete);
	LEAVE_TCL
	if (err == NULL) {
		PyErr_SetString(Tkinter_TclError, "can't create Tcl command");
		PyMem_DEL(data);
		return NULL;
	}

	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="ekr.20041012114208.61">static PyObject *
Tkapp_DeleteCommand(PyObject *self, PyObject *args)
{
	char *cmdName;
	int err;

	if (!PyArg_ParseTuple(args, "s:deletecommand", &amp;cmdName))
		return NULL;
	ENTER_TCL
	err = Tcl_DeleteCommand(Tkapp_Interp(self), cmdName);
	LEAVE_TCL
	if (err == -1) {
		PyErr_SetString(Tkinter_TclError, "can't delete Tcl command");
		return NULL;
	}
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="ekr.20041012114208.62">@ * File Handler *</t>
<t tx="ekr.20041012114208.63"># ifdef HAVE_CREATEFILEHANDLER

typedef struct _fhcdata {
	PyObject *func;
	PyObject *file;
	int id;
	struct _fhcdata *next;
} FileHandler_ClientData;

static FileHandler_ClientData *HeadFHCD;

static FileHandler_ClientData *
NewFHCD(PyObject *func, PyObject *file, int id)
{
	FileHandler_ClientData *p;
	p = PyMem_NEW(FileHandler_ClientData, 1);
	if (p != NULL) {
		Py_XINCREF(func);
		Py_XINCREF(file);
		p-&gt;func = func;
		p-&gt;file = file;
		p-&gt;id = id;
		p-&gt;next = HeadFHCD;
		HeadFHCD = p;
	}
	return p;
}
</t>
<t tx="ekr.20041012114208.64">static void
DeleteFHCD(int id)
{
	FileHandler_ClientData *p, **pp;
	
	pp = &amp;HeadFHCD; 
	while ((p = *pp) != NULL) {
		if (p-&gt;id == id) {
			*pp = p-&gt;next;
			Py_XDECREF(p-&gt;func);
			Py_XDECREF(p-&gt;file);
			PyMem_DEL(p);
		}
		else
			pp = &amp;p-&gt;next;
	}
}
</t>
<t tx="ekr.20041012114208.65">static void
FileHandler(ClientData clientData, int mask)
{
	FileHandler_ClientData *data = (FileHandler_ClientData *)clientData;
	PyObject *func, *file, *arg, *res;

	ENTER_PYTHON
	func = data-&gt;func;
	file = data-&gt;file;

	arg = Py_BuildValue("(Oi)", file, (long) mask);
	res = PyEval_CallObject(func, arg);
	Py_DECREF(arg);

	if (res == NULL) {
		errorInCmd = 1;
		PyErr_Fetch(&amp;excInCmd, &amp;valInCmd, &amp;trbInCmd);
	}
	Py_XDECREF(res);
	LEAVE_PYTHON
}
</t>
<t tx="ekr.20041012114208.66">static PyObject *
Tkapp_CreateFileHandler(PyObject *self, PyObject *args)
     /* args is (file, mask, func) */
{
	FileHandler_ClientData *data;
	PyObject *file, *func;
	int mask, tfile;

	if (!PyArg_ParseTuple(args, "OiO:createfilehandler",
			      &amp;file, &amp;mask, &amp;func))
		return NULL;
	tfile = PyObject_AsFileDescriptor(file);
	if (tfile &lt; 0)
		return NULL;
	if (!PyCallable_Check(func)) {
		PyErr_SetString(PyExc_TypeError, "bad argument list");
		return NULL;
	}

	data = NewFHCD(func, file, tfile);
	if (data == NULL)
		return NULL;

	/* Ought to check for null Tcl_File object... */
	ENTER_TCL
	Tcl_CreateFileHandler(tfile, mask, FileHandler, (ClientData) data);
	LEAVE_TCL
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="ekr.20041012114208.67">static PyObject *
Tkapp_DeleteFileHandler(PyObject *self, PyObject *args)
{
	PyObject *file;
	int tfile;
  
	if (!PyArg_ParseTuple(args, "O:deletefilehandler", &amp;file))
		return NULL;
	tfile = PyObject_AsFileDescriptor(file);
	if (tfile &lt; 0)
		return NULL;

	DeleteFHCD(tfile);

	/* Ought to check for null Tcl_File object... */
	ENTER_TCL
	Tcl_DeleteFileHandler(tfile);
	LEAVE_TCL
	Py_INCREF(Py_None);
	return Py_None;
}

# endif /* HAVE_CREATEFILEHANDLER */</t>
<t tx="ekr.20041012114208.68"></t>
<t tx="ekr.20041012114208.69">/**** Tktt Object (timer token) ****/

staticforward PyTypeObject Tktt_Type;

typedef struct {
	PyObject_HEAD
	Tcl_TimerToken token;
	PyObject *func;
} TkttObject;</t>
<t tx="ekr.20041012114208.70">static PyObject *
Tktt_DeleteTimerHandler(PyObject *self, PyObject *args)
{
	TkttObject *v = (TkttObject *)self;
	PyObject *func = v-&gt;func;

	if (!PyArg_ParseTuple(args, ":deletetimerhandler"))
		return NULL;
	if (v-&gt;token != NULL) {
		Tcl_DeleteTimerHandler(v-&gt;token);
		v-&gt;token = NULL;
	}
	if (func != NULL) {
		v-&gt;func = NULL;
		Py_DECREF(func);
		Py_DECREF(v); /* See Tktt_New() */
	}
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="ekr.20041012114208.71">static PyMethodDef Tktt_methods[] =
{
	{"deletetimerhandler", Tktt_DeleteTimerHandler, 1},
	{NULL, NULL}
};

static TkttObject *
Tktt_New(PyObject *func)
{
	TkttObject *v;
  
	v = PyObject_New(TkttObject, &amp;Tktt_Type);
	if (v == NULL)
		return NULL;

	Py_INCREF(func);
	v-&gt;token = NULL;
	v-&gt;func = func;

	/* Extra reference, deleted when called or when handler is deleted */
	Py_INCREF(v);
	return v;
}
</t>
<t tx="ekr.20041012114208.72">static void
Tktt_Dealloc(PyObject *self)
{
	TkttObject *v = (TkttObject *)self;
	PyObject *func = v-&gt;func;

	Py_XDECREF(func);

	PyObject_Del(self);
}
</t>
<t tx="ekr.20041012114208.73">static PyObject *
Tktt_Repr(PyObject *self)
{
	TkttObject *v = (TkttObject *)self;
	char buf[100];

	PyOS_snprintf(buf, sizeof(buf), "&lt;tktimertoken at %p%s&gt;", v,
	                v-&gt;func == NULL ? ", handler deleted" : "");
	return PyString_FromString(buf);
}
</t>
<t tx="ekr.20041012114208.74">static PyObject *
Tktt_GetAttr(PyObject *self, char *name)
{
	return Py_FindMethod(Tktt_methods, self, name);
}
</t>
<t tx="ekr.20041012114208.75">static PyTypeObject Tktt_Type =
{
	PyObject_HEAD_INIT(NULL)
	0,				     /*ob_size */
	"tktimertoken",			     /*tp_name */
	sizeof(TkttObject),		     /*tp_basicsize */
	0,				     /*tp_itemsize */
	Tktt_Dealloc,			     /*tp_dealloc */
	0,				     /*tp_print */
	Tktt_GetAttr,			     /*tp_getattr */
	0,				     /*tp_setattr */
	0,				     /*tp_compare */
	Tktt_Repr,			     /*tp_repr */
	0,				     /*tp_as_number */
	0,				     /*tp_as_sequence */
	0,				     /*tp_as_mapping */
	0,				     /*tp_hash */
};



/** Timer Handler **/

static void
TimerHandler(ClientData clientData)
{
	TkttObject *v = (TkttObject *)clientData;
	PyObject *func = v-&gt;func;
	PyObject *res;

	if (func == NULL)
		return;

	v-&gt;func = NULL;

	ENTER_PYTHON

	res  = PyEval_CallObject(func, NULL);
	Py_DECREF(func);
	Py_DECREF(v); /* See Tktt_New() */

	if (res == NULL) {
		errorInCmd = 1;
		PyErr_Fetch(&amp;excInCmd, &amp;valInCmd, &amp;trbInCmd);
	}
	else
		Py_DECREF(res);

	LEAVE_PYTHON
}
</t>
<t tx="ekr.20041012114208.76">static PyObject *
Tkapp_CreateTimerHandler(PyObject *self, PyObject *args)
{
	int milliseconds;
	PyObject *func;
	TkttObject *v;

	if (!PyArg_ParseTuple(args, "iO:createtimerhandler",
			      &amp;milliseconds, &amp;func))
		return NULL;
	if (!PyCallable_Check(func)) {
		PyErr_SetString(PyExc_TypeError, "bad argument list");
		return NULL;
	}
	v = Tktt_New(func);
	v-&gt;token = Tcl_CreateTimerHandler(milliseconds, TimerHandler,
					  (ClientData)v);

	return (PyObject *) v;
}
</t>
<t tx="ekr.20041012114208.77">@ * Event Loop *</t>
<t tx="ekr.20041012114208.78">static PyObject *
Tkapp_MainLoop(PyObject *self, PyObject *args)
{
	int threshold = 0;
#ifdef WITH_THREAD
	PyThreadState *tstate = PyThreadState_Get();
#endif

	if (!PyArg_ParseTuple(args, "|i:mainloop", &amp;threshold))
		return NULL;

	quitMainLoop = 0;
	while (Tk_GetNumMainWindows() &gt; threshold &amp;&amp;
	       !quitMainLoop &amp;&amp;
	       !errorInCmd)
	{
		int result;

#ifdef WITH_THREAD
		Py_BEGIN_ALLOW_THREADS
		PyThread_acquire_lock(tcl_lock, 1);
		tcl_tstate = tstate;
		result = Tcl_DoOneEvent(TCL_DONT_WAIT);
		tcl_tstate = NULL;
		PyThread_release_lock(tcl_lock);
		if (result == 0)
			Sleep(20);
		Py_END_ALLOW_THREADS
#else
		result = Tcl_DoOneEvent(0);
#endif

		if (PyErr_CheckSignals() != 0)
			return NULL;
		if (result &lt; 0)
			break;
	}
	quitMainLoop = 0;

	if (errorInCmd) {
		errorInCmd = 0;
		PyErr_Restore(excInCmd, valInCmd, trbInCmd);
		excInCmd = valInCmd = trbInCmd = NULL;
		return NULL;
	}
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="ekr.20041012114208.79">static PyObject *
Tkapp_DoOneEvent(PyObject *self, PyObject *args)
{
	int flags = 0;
	int rv;

	if (!PyArg_ParseTuple(args, "|i:dooneevent", &amp;flags))
		return NULL;

	ENTER_TCL
	rv = Tcl_DoOneEvent(flags);
	LEAVE_TCL
	return Py_BuildValue("i", rv);
}
</t>
<t tx="ekr.20041012114208.80">static PyObject *
Tkapp_Quit(PyObject *self, PyObject *args)
{

	if (!PyArg_ParseTuple(args, ":quit"))
		return NULL;

	quitMainLoop = 1;
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="ekr.20041012114208.81">static PyObject *
Tkapp_InterpAddr(PyObject *self, PyObject *args)
{

	if (!PyArg_ParseTuple(args, ":interpaddr"))
		return NULL;

	return PyInt_FromLong((long)Tkapp_Interp(self));
}
</t>
<t tx="ekr.20041012114208.82">/**** Tkapp Type Methods ****/</t>
<t tx="ekr.20041012114208.83">static void
Tkapp_Dealloc(PyObject *self)
{
	ENTER_TCL
	Tcl_DeleteInterp(Tkapp_Interp(self));
	LEAVE_TCL
	PyObject_Del(self);
	DisableEventHook();
}
</t>
<t tx="ekr.20041012114208.84">static PyObject *
Tkapp_GetAttr(PyObject *self, char *name)
{
	return Py_FindMethod(Tkapp_methods, self, name);
}
</t>
<t tx="ekr.20041012114208.85">/**** Tkinter Module ****/</t>
<t tx="ekr.20041012114208.86">static PyTypeObject Tkapp_Type =
{
	PyObject_HEAD_INIT(NULL)
	0,				     /*ob_size */
	"tkapp",			     /*tp_name */
	sizeof(TkappObject),		     /*tp_basicsize */
	0,				     /*tp_itemsize */
	Tkapp_Dealloc,			     /*tp_dealloc */
	0,				     /*tp_print */
	Tkapp_GetAttr,			     /*tp_getattr */
	0,				     /*tp_setattr */
	0,				     /*tp_compare */
	0,				     /*tp_repr */
	0,				     /*tp_as_number */
	0,				     /*tp_as_sequence */
	0,				     /*tp_as_mapping */
	0,				     /*tp_hash */
};

typedef struct {
	PyObject* tuple;
	int size; /* current size */
	int maxsize; /* allocated size */
} FlattenContext;</t>
<t tx="ekr.20041012114208.87">static int
_bump(FlattenContext* context, int size)
{
	/* expand tuple to hold (at least) size new items.
	   return true if successful, false if an exception was raised */

	int maxsize = context-&gt;maxsize * 2;

	if (maxsize &lt; context-&gt;size + size)
		maxsize = context-&gt;size + size;

	context-&gt;maxsize = maxsize;

	return _PyTuple_Resize(&amp;context-&gt;tuple, maxsize) &gt;= 0;
}
</t>
<t tx="ekr.20041012114208.88">static int
_flatten1(FlattenContext* context, PyObject* item, int depth)
{
	/* add tuple or list to argument tuple (recursively) */

	int i, size;

	if (depth &gt; 1000) {
		PyErr_SetString(PyExc_ValueError,
				"nesting too deep in _flatten");
		return 0;
	} else if (PyList_Check(item)) {
		size = PyList_GET_SIZE(item);
		/* preallocate (assume no nesting) */
		if (context-&gt;size + size &gt; context-&gt;maxsize &amp;&amp;
		    !_bump(context, size))
			return 0;
		/* copy items to output tuple */
		for (i = 0; i &lt; size; i++) {
			PyObject *o = PyList_GET_ITEM(item, i);
			if (PyList_Check(o) || PyTuple_Check(o)) {
				if (!_flatten1(context, o, depth + 1))
					return 0;
			} else if (o != Py_None) {
				if (context-&gt;size + 1 &gt; context-&gt;maxsize &amp;&amp;
				    !_bump(context, 1))
					return 0;
				Py_INCREF(o);
				PyTuple_SET_ITEM(context-&gt;tuple,
						 context-&gt;size++, o);
			}
		}
	} else if (PyTuple_Check(item)) {
		/* same, for tuples */
		size = PyTuple_GET_SIZE(item);
		if (context-&gt;size + size &gt; context-&gt;maxsize &amp;&amp;
		    !_bump(context, size))
			return 0;
		for (i = 0; i &lt; size; i++) {
			PyObject *o = PyTuple_GET_ITEM(item, i);
			if (PyList_Check(o) || PyTuple_Check(o)) {
				if (!_flatten1(context, o, depth + 1))
					return 0;
			} else if (o != Py_None) {
				if (context-&gt;size + 1 &gt; context-&gt;maxsize &amp;&amp;
				    !_bump(context, 1))
					return 0;
				Py_INCREF(o);
				PyTuple_SET_ITEM(context-&gt;tuple,
						 context-&gt;size++, o);
			}
		}
	} else {
		PyErr_SetString(PyExc_TypeError, "argument must be sequence");
		return 0;
	}
	return 1;
}
</t>
<t tx="ekr.20041012114208.89">static PyObject *
Tkinter_Flatten(PyObject* self, PyObject* args)
{
	FlattenContext context;
	PyObject* item;

	if (!PyArg_ParseTuple(args, "O:_flatten", &amp;item))
		return NULL;

	context.maxsize = PySequence_Size(item);
	if (context.maxsize &lt;= 0)
		return PyTuple_New(0);
	
	context.tuple = PyTuple_New(context.maxsize);
	if (!context.tuple)
		return NULL;
	
	context.size = 0;

	if (!_flatten1(&amp;context, item,0))
		return NULL;

	if (_PyTuple_Resize(&amp;context.tuple, context.size))
		return NULL;

	return context.tuple;
}
</t>
<t tx="ekr.20041012114208.90">static PyObject *
Tkinter_Create(PyObject *self, PyObject *args)
{
	char *screenName = NULL;
	char *baseName = NULL;
	char *className = NULL;
	int interactive = 0;

	baseName = strrchr(Py_GetProgramName(), '/');
	if (baseName != NULL)
		baseName++;
	else
		baseName = Py_GetProgramName();
	className = "Tk";
  
	if (!PyArg_ParseTuple(args, "|zssi:create",
			      &amp;screenName, &amp;baseName, &amp;className,
			      &amp;interactive))
		return NULL;

	return (PyObject *) Tkapp_New(screenName, baseName, className, 
				      interactive);
}
</t>
<t tx="ekr.20041012114208.91">static PyMethodDef moduleMethods[] =
{
	{"_flatten",           Tkinter_Flatten, 1},
	{"create",             Tkinter_Create, 1},
#ifdef HAVE_CREATEFILEHANDLER
	{"createfilehandler",  Tkapp_CreateFileHandler, 1},
	{"deletefilehandler",  Tkapp_DeleteFileHandler, 1},
#endif
	{"createtimerhandler", Tkapp_CreateTimerHandler, 1},
	{"mainloop",           Tkapp_MainLoop, 1},
	{"dooneevent",         Tkapp_DoOneEvent, 1},
	{"quit",               Tkapp_Quit, 1},
	{NULL,                 NULL}
};
</t>
<t tx="ekr.20041012114208.92">#ifdef WAIT_FOR_STDIN

static int stdin_ready = 0;

#ifndef MS_WINDOWS
static void
MyFileProc(void *clientData, int mask)
{
	stdin_ready = 1;
}
# endif</t>
<t tx="ekr.20041012114208.93">static PyThreadState *event_tstate = NULL;

static int
EventHook(void)
{
#ifndef MS_WINDOWS
	int tfile;
#endif
#ifdef WITH_THREAD
	PyEval_RestoreThread(event_tstate);
#endif
	stdin_ready = 0;
	errorInCmd = 0;
#ifndef MS_WINDOWS
	tfile = fileno(stdin);
	Tcl_CreateFileHandler(tfile, TCL_READABLE, MyFileProc, NULL);
#endif
	while (!errorInCmd &amp;&amp; !stdin_ready) {
		int result;
#ifdef MS_WINDOWS
		if (_kbhit()) {
			stdin_ready = 1;
			break;
		}
#endif
#if defined(WITH_THREAD) || defined(MS_WINDOWS)
		Py_BEGIN_ALLOW_THREADS
		PyThread_acquire_lock(tcl_lock, 1);
		tcl_tstate = event_tstate;

		result = Tcl_DoOneEvent(TCL_DONT_WAIT);

		tcl_tstate = NULL;
		PyThread_release_lock(tcl_lock);
		if (result == 0)
			Sleep(20);
		Py_END_ALLOW_THREADS
#else
		result = Tcl_DoOneEvent(0);
#endif

		if (result &lt; 0)
			break;
	}
#ifndef MS_WINDOWS
	Tcl_DeleteFileHandler(tfile);
#endif
	if (errorInCmd) {
		errorInCmd = 0;
		PyErr_Restore(excInCmd, valInCmd, trbInCmd);
		excInCmd = valInCmd = trbInCmd = NULL;
		PyErr_Print();
	}
#ifdef WITH_THREAD
	PyEval_SaveThread();
#endif
	return 0;
}
# endif</t>
<t tx="ekr.20041012114208.94">static void
EnableEventHook(void)
{
#ifdef WAIT_FOR_STDIN
	if (PyOS_InputHook == NULL) {
#ifdef WITH_THREAD
		event_tstate = PyThreadState_Get();
#endif
		PyOS_InputHook = EventHook;
	}
#endif
}
</t>
<t tx="ekr.20041012114208.95">static void
DisableEventHook(void)
{
#ifdef WAIT_FOR_STDIN
	if (Tk_GetNumMainWindows() == 0 &amp;&amp; PyOS_InputHook == EventHook) {
		PyOS_InputHook = NULL;
	}
#endif
}
</t>
<t tx="ekr.20041012114208.96">@ all errors will be checked in one fell swoop in init_tkinter()
@c

static void
ins_long(PyObject *d, char *name, long val)
{
	PyObject *v = PyInt_FromLong(val);
	if (v) {
		PyDict_SetItemString(d, name, v);
		Py_DECREF(v);
	}
}
</t>
<t tx="ekr.20041012114208.97">static void
ins_string(PyObject *d, char *name, char *val)
{
	PyObject *v = PyString_FromString(val);
	if (v) {
		PyDict_SetItemString(d, name, v);
		Py_DECREF(v);
	}
}
</t>
<t tx="ekr.20041012114208.98">DL_EXPORT(void)
init_tkinter(void)
{
	PyObject *m, *d;

	Tkapp_Type.ob_type = &amp;PyType_Type;

#ifdef WITH_THREAD
	tcl_lock = PyThread_allocate_lock();
#endif

	m = Py_InitModule("_tkinter", moduleMethods);

	d = PyModule_GetDict(m);
	Tkinter_TclError = Py_BuildValue("s", "TclError");
	PyDict_SetItemString(d, "TclError", Tkinter_TclError);

	ins_long(d, "READABLE", TCL_READABLE);
	ins_long(d, "WRITABLE", TCL_WRITABLE);
	ins_long(d, "EXCEPTION", TCL_EXCEPTION);
	ins_long(d, "WINDOW_EVENTS", TCL_WINDOW_EVENTS);
	ins_long(d, "FILE_EVENTS", TCL_FILE_EVENTS);
	ins_long(d, "TIMER_EVENTS", TCL_TIMER_EVENTS);
	ins_long(d, "IDLE_EVENTS", TCL_IDLE_EVENTS);
	ins_long(d, "ALL_EVENTS", TCL_ALL_EVENTS);
	ins_long(d, "DONT_WAIT", TCL_DONT_WAIT);
	ins_string(d, "TK_VERSION", TK_VERSION);
	ins_string(d, "TCL_VERSION", TCL_VERSION);

	PyDict_SetItemString(d, "TkappType", (PyObject *)&amp;Tkapp_Type);

	Tktt_Type.ob_type = &amp;PyType_Type;
	PyDict_SetItemString(d, "TkttType", (PyObject *)&amp;Tktt_Type);


#ifdef TK_AQUA
	/* Tk_MacOSXSetupTkNotifier must be called before Tcl's subsystems
	 * start waking up.  Note that Tcl_FindExecutable will do this, this
	 * code must be above it! The original warning from
	 * tkMacOSXAppInit.c is copied below.
	 *
	 * NB - You have to swap in the Tk Notifier BEFORE you start up the
	 * Tcl interpreter for now.  It probably should work to do this
	 * in the other order, but for now it doesn't seem to.
	 *
	 */
	Tk_MacOSXSetupTkNotifier();
#endif


	/* This helps the dynamic loader; in Unicode aware Tcl versions
	   it also helps Tcl find its encodings. */
	Tcl_FindExecutable(Py_GetProgramName());

	if (PyErr_Occurred())
		return;

#if 0
	/* This was not a good idea; through &lt;Destroy&gt; bindings,
	   Tcl_Finalize() may invoke Python code but at that point the
	   interpreter and thread state have already been destroyed! */
	Py_AtExit(Tcl_Finalize);
#endif

#ifdef macintosh
	/*
	** Part of this code is stolen from MacintoshInit in tkMacAppInit.
	** Most of the initializations in that routine (toolbox init calls and
	** such) have already been done for us, so we only need these.
	*/
	tcl_macQdPtr = &amp;qd;

	Tcl_MacSetEventProc(PyMacConvertEvent);
#if GENERATINGCFM
	mac_addlibresources();
#endif /* GENERATINGCFM */
#endif /* macintosh */
}
</t>
<t tx="ekr.20041012114208.99"># ifdef macintosh
	&lt;&lt; mac stuff &gt;&gt;
# if GENERATINGCFM
	&lt;&lt; mac generating cfm stuff &gt;&gt;
#endif /* GENERATINGCFM */
#endif /* macintosh */</t>
<t tx="ekr.20041012114208.100"></t>
<t tx="ekr.20041012114208.101">@ ** Anyone who embeds Tcl/Tk on the Mac must define panic().
@c

void
panic(char * format, ...)
{
	va_list varg;
	
	va_start(varg, format);
	
	vfprintf(stderr, format, varg);
	(void) fflush(stderr);
	
	va_end(varg);

	Py_FatalError("Tcl/Tk panic");
}
</t>
<t tx="ekr.20041012114208.102">@ ** Pass events to SIOUX before passing them to Tk.
@c

static int
PyMacConvertEvent(EventRecord *eventPtr)
{
	WindowPtr frontwin;
	/*
	** Sioux eats too many events, so we don't pass it everything.  We
	** always pass update events to Sioux, and we only pass other events if
	** the Sioux window is frontmost. This means that Tk menus don't work
	** in that case, but at least we can scroll the sioux window.
	** Note that the SIOUXIsAppWindow() routine we use here is not really
	** part of the external interface of Sioux...
	*/
	frontwin = FrontWindow();
	if ( eventPtr-&gt;what == updateEvt || SIOUXIsAppWindow(frontwin) ) {
		if (SIOUXHandleOneEvent(eventPtr))
			return 0; /* Nothing happened to the Tcl event queue */
	}
	return TkMacConvertEvent(eventPtr);
}
</t>
<t tx="ekr.20041012114208.103"></t>
<t tx="ekr.20041012114208.104">// ** Additional Mac specific code for dealing with shared libraries.
#include &lt;Resources.h&gt;
#include &lt;CodeFragments.h&gt;

static int loaded_from_shlib = 0;
static FSSpec library_fss;

/*
** If this module is dynamically loaded the following routine should
** be the init routine. It takes care of adding the shared library to
** the resource-file chain, so that the tk routines can find their
** resources.
*/
OSErr pascal
init_tkinter_shlib(CFragInitBlockPtr data)
{
	__initialize();
	if ( data == nil ) return noErr;
	if ( data-&gt;fragLocator.where == kDataForkCFragLocator ) {
		library_fss = *data-&gt;fragLocator.u.onDisk.fileSpec;
		loaded_from_shlib = 1;
	} else if ( data-&gt;fragLocator.where == kResourceCFragLocator ) {
		library_fss = *data-&gt;fragLocator.u.inSegs.fileSpec;
		loaded_from_shlib = 1;
	}
	return noErr;
}
</t>
<t tx="ekr.20041012114208.105">@ ** Insert the library resources into the search path. Put them after ** the resources from the application. Again, we ignore errors.
@c

static
mac_addlibresources(void)
{
	if ( !loaded_from_shlib ) 
		return;
	(void)FSpOpenResFile(&amp;library_fss, fsRdPerm);
}


</t>
<t tx="ekr.20041012114208.106">@language python

&lt;&lt; Tkinter doc string &gt;&gt;
&lt;&lt; Tkinter declarations &gt;&gt;

@others
@ignore

</t>
<t tx="ekr.20041012114208.107">__version__ = "$Revision: 1.152 $"

import sys
if sys.platform == "win32":
    import FixTk # Attempt to configure Tcl/Tk without requiring PATH
import _tkinter # If this fails your Python may not be configured for Tk

tkinter = _tkinter # b/w compat for export
TclError = _tkinter.TclError
from types import *
from Tkconstants import *
try:
    import MacOS; _MacOS = MacOS; del MacOS
except ImportError:
    _MacOS = None

TkVersion = float(_tkinter.TK_VERSION)
TclVersion = float(_tkinter.TCL_VERSION)

READABLE = _tkinter.READABLE
WRITABLE = _tkinter.WRITABLE
EXCEPTION = _tkinter.EXCEPTION

# These are not always defined, e.g. not on Win32 with Tk 8.0 :-(
try: _tkinter.createfilehandler
except AttributeError: _tkinter.createfilehandler = None
try: _tkinter.deletefilehandler
except AttributeError: _tkinter.deletefilehandler = None</t>
<t tx="ekr.20041012114208.108"></t>
<t tx="ekr.20041012114208.109">class Tk(Misc, Wm):

	"""Toplevel widget of Tk which represents mostly the main window
	of an appliation. It has an associated Tcl interpreter."""

	_w = '.'

	@others
</t>
<t tx="ekr.20041012114208.110">def __init__(self, screenName=None, baseName=None, className='Tk'):
    """Return a new Toplevel widget on screen SCREENNAME. A new Tcl interpreter will
    be created. BASENAME will be used for the identification of the profile file (see
    readprofile).
    It is constructed from sys.argv[0] without extensions if None is given. CLASSNAME
    is the name of the widget class."""
    global _default_root
    self.master = None
    self.children = {}
    if baseName is None:
        import sys, os
        baseName = os.path.basename(sys.argv[0])
        baseName, ext = os.path.splitext(baseName)
        if ext not in ('.py', '.pyc', '.pyo'):
            baseName = baseName + ext
    self.tk = _tkinter.create(screenName, baseName, className)
    if _MacOS:
        # Disable event scanning except for Command-Period
        _MacOS.SchedParams(1, 0)
        # Work around nasty MacTk bug
        # XXX Is this one still needed?
        self.update()
    # Version sanity checks
    tk_version = self.tk.getvar('tk_version')
    if tk_version != _tkinter.TK_VERSION:
        raise RuntimeError, \
        "tk.h version (%s) doesn't match libtk.a version (%s)" \
        % (_tkinter.TK_VERSION, tk_version)
    tcl_version = self.tk.getvar('tcl_version')
    if tcl_version != _tkinter.TCL_VERSION:
        raise RuntimeError, \
        "tcl.h version (%s) doesn't match libtcl.a version (%s)" \
        % (_tkinter.TCL_VERSION, tcl_version)
    if TkVersion &lt; 4.0:
        raise RuntimeError, \
        "Tk 4.0 or higher is required; found Tk %s" \
        % str(TkVersion)
    self.tk.createcommand('tkerror', _tkerror)
    self.tk.createcommand('exit', _exit)
    self.readprofile(baseName, className)
    if _support_default_root and not _default_root:
        _default_root = self
    self.protocol("WM_DELETE_WINDOW", self.destroy)
</t>
<t tx="ekr.20041012114208.111">def destroy(self):

    """Destroy this and all descendants widgets. This will
    end the application of this Tcl interpreter."""

    for c in self.children.values(): c.destroy()
    self.tk.call('destroy', self._w)
    Misc.destroy(self)
    global _default_root
    if _support_default_root and _default_root is self:
        _default_root = None
</t>
<t tx="ekr.20041012114208.112">def readprofile(self, baseName, className):

    """Internal function. It reads BASENAME.tcl and CLASSNAME.tcl into
    the Tcl Interpreter and calls execfile on BASENAME.py and CLASSNAME.py if
    such a file exists in the home directory."""
	
    import os
    if os.environ.has_key('HOME'): home = os.environ['HOME']
    else: home = os.curdir
    class_tcl = os.path.join(home, '.%s.tcl' % className)
    class_py = os.path.join(home, '.%s.py' % className)
    base_tcl = os.path.join(home, '.%s.tcl' % baseName)
    base_py = os.path.join(home, '.%s.py' % baseName)
    dir = {'self': self}
    exec 'from Tkinter import *' in dir
    if os.path.isfile(class_tcl):
        self.tk.call('source', class_tcl)
    if os.path.isfile(class_py):
        execfile(class_py, dir)
    if os.path.isfile(base_tcl):
        self.tk.call('source', base_tcl)
    if os.path.isfile(base_py):
        execfile(base_py, dir)
</t>
<t tx="ekr.20041012114208.113">def report_callback_exception(self, exc, val, tb):

    """Internal function. It reports exception on sys.stderr."""
	
    import traceback, sys
    sys.stderr.write("Exception in Tkinter callback\n")
    sys.last_type = exc
    sys.last_value = val
    sys.last_traceback = tb
    traceback.print_exception(exc, val, tb)
</t>
<t tx="ekr.20041012114208.114">class Wm:

	"""Provides functions for the communication with the window manager."""

	@others
</t>
<t tx="ekr.20041012114208.115">def wm_aspect(self,
          minNumer=None, minDenom=None,
          maxNumer=None, maxDenom=None):
		  
    """Instruct the window manager to set the aspect ratio (width/height)
    of this widget to be between MINNUMER/MINDENOM and MAXNUMER/MAXDENOM. Return a tuple
    of the actual values if no argument is given."""
	
    return self._getints(
        self.tk.call('wm', 'aspect', self._w,
                 minNumer, minDenom,
                 maxNumer, maxDenom))

aspect = wm_aspect</t>
<t tx="ekr.20041012114208.116">def wm_client(self, name=None):

    """Store NAME in WM_CLIENT_MACHINE property of this widget. Return
    current value."""
	
    return self.tk.call('wm', 'client', self._w, name)

client = wm_client</t>
<t tx="ekr.20041012114208.117">def wm_colormapwindows(self, *wlist):

    """Store list of window names (WLIST) into WM_COLORMAPWINDOWS property
    of this widget. This list contains windows whose colormaps differ from their
    parents. Return current list of widgets if WLIST is empty."""
	
    if len(wlist) &gt; 1:
        wlist = (wlist,) # Tk needs a list of windows here
    args = ('wm', 'colormapwindows', self._w) + wlist
    return map(self._nametowidget, self.tk.call(args))

colormapwindows = wm_colormapwindows</t>
<t tx="ekr.20041012114208.118">def wm_command(self, value=None):

    """Store VALUE in WM_COMMAND property. It is the command
    which shall be used to invoke the application. Return current
    command if VALUE is None."""
	
    return self.tk.call('wm', 'command', self._w, value)

command = wm_command</t>
<t tx="ekr.20041012114208.119">def wm_deiconify(self):

    """Deiconify this widget. If it was never mapped it will not be mapped.
    On Windows it will raise this widget and give it the focus."""
	
    return self.tk.call('wm', 'deiconify', self._w)

deiconify = wm_deiconify</t>
<t tx="ekr.20041012114208.120">def wm_focusmodel(self, model=None):

    """Set focus model to MODEL. "active" means that this widget will claim
    the focus itself, "passive" means that the window manager shall give
    the focus. Return current focus model if MODEL is None."""
	
    return self.tk.call('wm', 'focusmodel', self._w, model)

focusmodel = wm_focusmodel</t>
<t tx="ekr.20041012114208.121">

def wm_frame(self):
    """Return identifier for decorative frame of this widget if present."""
    return self.tk.call('wm', 'frame', self._w)
</t>
<t tx="ekr.20041012114208.122">frame = wm_frame

def wm_geometry(self, newGeometry=None):
    """Set geometry to NEWGEOMETRY of the form =widthxheight+x+y. Return
    current value if None is given."""
    return self.tk.call('wm', 'geometry', self._w, newGeometry)
</t>
<t tx="ekr.20041012114208.123">geometry = wm_geometry

def wm_grid(self,
     baseWidth=None, baseHeight=None,
     widthInc=None, heightInc=None):
    """Instruct the window manager that this widget shall only be
    resized on grid boundaries. WIDTHINC and HEIGHTINC are the width and
    height of a grid unit in pixels. BASEWIDTH and BASEHEIGHT are the
    number of grid units requested in Tk_GeometryRequest."""
    return self._getints(self.tk.call(
        'wm', 'grid', self._w,
        baseWidth, baseHeight, widthInc, heightInc))
</t>
<t tx="ekr.20041012114208.124">grid = wm_grid

def wm_group(self, pathName=None):
    """Set the group leader widgets for related widgets to PATHNAME. Return
    the group leader of this widget if None is given."""
    return self.tk.call('wm', 'group', self._w, pathName)
</t>
<t tx="ekr.20041012114208.125">group = wm_group

def wm_iconbitmap(self, bitmap=None):
    """Set bitmap for the iconified widget to BITMAP. Return
    the bitmap if None is given."""
    return self.tk.call('wm', 'iconbitmap', self._w, bitmap)
</t>
<t tx="ekr.20041012114208.126">iconbitmap = wm_iconbitmap

def wm_iconify(self):
    """Display widget as icon."""
    return self.tk.call('wm', 'iconify', self._w)
</t>
<t tx="ekr.20041012114208.127">iconify = wm_iconify

def wm_iconmask(self, bitmap=None):
    """Set mask for the icon bitmap of this widget. Return the
    mask if None is given."""
    return self.tk.call('wm', 'iconmask', self._w, bitmap)
</t>
<t tx="ekr.20041012114208.128">iconmask = wm_iconmask

def wm_iconname(self, newName=None):
    """Set the name of the icon for this widget. Return the name if
    None is given."""
    return self.tk.call('wm', 'iconname', self._w, newName)
</t>
<t tx="ekr.20041012114208.129">iconname = wm_iconname

def wm_iconposition(self, x=None, y=None):
    """Set the position of the icon of this widget to X and Y. Return
    a tuple of the current values of X and X if None is given."""
    return self._getints(self.tk.call(
        'wm', 'iconposition', self._w, x, y))
</t>
<t tx="ekr.20041012114208.130">iconposition = wm_iconposition

def wm_iconwindow(self, pathName=None):
    """Set widget PATHNAME to be displayed instead of icon. Return the current
    value if None is given."""
    return self.tk.call('wm', 'iconwindow', self._w, pathName)
</t>
<t tx="ekr.20041012114208.131">iconwindow = wm_iconwindow

def wm_maxsize(self, width=None, height=None):
    """Set max WIDTH and HEIGHT for this widget. If the window is gridded
    the values are given in grid units. Return the current values if None
    is given."""
    return self._getints(self.tk.call(
        'wm', 'maxsize', self._w, width, height))
</t>
<t tx="ekr.20041012114208.132">maxsize = wm_maxsize

def wm_minsize(self, width=None, height=None):
    """Set min WIDTH and HEIGHT for this widget. If the window is gridded
    the values are given in grid units. Return the current values if None
    is given."""
    return self._getints(self.tk.call(
        'wm', 'minsize', self._w, width, height))
</t>
<t tx="ekr.20041012114208.133">minsize = wm_minsize

def wm_overrideredirect(self, boolean=None):
    """Instruct the window manager to ignore this widget
    if BOOLEAN is given with 1. Return the current value if None
    is given."""
    return self._getboolean(self.tk.call(
        'wm', 'overrideredirect', self._w, boolean))
</t>
<t tx="ekr.20041012114208.134">overrideredirect = wm_overrideredirect

def wm_positionfrom(self, who=None):
    """Instruct the window manager that the position of this widget shall
    be defined by the user if WHO is "user", and by its own policy if WHO is
    "program"."""
    return self.tk.call('wm', 'positionfrom', self._w, who)
</t>
<t tx="ekr.20041012114208.135">positionfrom = wm_positionfrom

def wm_protocol(self, name=None, func=None):
    """Bind function FUNC to command NAME for this widget.
    Return the function bound to NAME if None is given. NAME could be
    e.g. "WM_SAVE_YOURSELF" or "WM_DELETE_WINDOW"."""
    if callable(func):
        command = self._register(func)
    else:
        command = func
    return self.tk.call(
        'wm', 'protocol', self._w, name, command)
</t>
<t tx="ekr.20041012114208.136">protocol = wm_protocol

def wm_resizable(self, width=None, height=None):
    """Instruct the window manager whether this width can be resized
    in WIDTH or HEIGHT. Both values are boolean values."""
    return self.tk.call('wm', 'resizable', self._w, width, height)
</t>
<t tx="ekr.20041012114208.137">resizable = wm_resizable

def wm_sizefrom(self, who=None):
    """Instruct the window manager that the size of this widget shall
    be defined by the user if WHO is "user", and by its own policy if WHO is
    "program"."""
    return self.tk.call('wm', 'sizefrom', self._w, who)
</t>
<t tx="ekr.20041012114208.138">sizefrom = wm_sizefrom

def wm_state(self, newstate=None):
    """Query or set the state of this widget as one of normal, icon,
    iconic (see wm_iconwindow), withdrawn, or zoomed (Windows only)."""
    return self.tk.call('wm', 'state', self._w, newstate)
</t>
<t tx="ekr.20041012114208.139">state = wm_state

def wm_title(self, string=None):
    """Set the title of this widget."""
    return self.tk.call('wm', 'title', self._w, string)
</t>
<t tx="ekr.20041012114208.140">title = wm_title

def wm_transient(self, master=None):
    """Instruct the window manager that this widget is transient
    with regard to widget MASTER."""
    return self.tk.call('wm', 'transient', self._w, master)
</t>
<t tx="ekr.20041012114208.141">transient = wm_transient

def wm_withdraw(self):
    """Withdraw this widget from the screen such that it is unmapped
    and forgotten by the window manager. Re-draw it with wm_deiconify."""
    return self.tk.call('wm', 'withdraw', self._w)
</t>
<t tx="ekr.20041012114208.142"></t>
<t tx="ekr.20041012114208.143"></t>
<t tx="ekr.20041012114208.144">class Event:
	&lt;&lt; class Event docstring &gt;&gt;
	pass
	_support_default_root = 1
	_default_root = None

	@others
</t>
<t tx="ekr.20041012114208.145">"""Container for the properties of an event.

Instances of this type are generated if one of the following events occurs:

KeyPress, KeyRelease - for keyboard events
ButtonPress, ButtonRelease, Motion, Enter, Leave, MouseWheel - for mouse events
Visibility, Unmap, Map, Expose, FocusIn, FocusOut, Circulate,
Colormap, Gravity, Reparent, Property, Destroy, Activate,
Deactivate - for window events.

If a callback function for one of these events is registered
using bind, bind_all, bind_class, or tag_bind, the callback is
called with an Event as first argument. It will have the
following attributes (in braces are the event types for which
the attribute is valid):

    serial - serial number of event
num - mouse button pressed (ButtonPress, ButtonRelease)
focus - whether the window has the focus (Enter, Leave)
height - height of the exposed window (Configure, Expose)
width - width of the exposed window (Configure, Expose)
keycode - keycode of the pressed key (KeyPress, KeyRelease)
state - state of the event as a number (ButtonPress, ButtonRelease,
                        Enter, KeyPress, KeyRelease,
                        Leave, Motion)
state - state as a string (Visibility)
time - when the event occurred
x - x-position of the mouse
y - y-position of the mouse
x_root - x-position of the mouse on the screen
         (ButtonPress, ButtonRelease, KeyPress, KeyRelease, Motion)
y_root - y-position of the mouse on the screen
         (ButtonPress, ButtonRelease, KeyPress, KeyRelease, Motion)
char - pressed character (KeyPress, KeyRelease)
send_event - see X/Windows documentation
keysym - keysym of the the event as a string (KeyPress, KeyRelease)
keysym_num - keysym of the event as a number (KeyPress, KeyRelease)
type - type of the event as a number
widget - widget in which the event occurred
delta - delta of wheel movement (MouseWheel)
"""

</t>
<t tx="ekr.20041012114208.146">def NoDefaultRoot():

    """Inhibit setting of default root window.

    Call this function to inhibit that the first instance of
    Tk is used for windows without an explicit parent window.
    """
	
    global _support_default_root
    _support_default_root = 0
    global _default_root
    _default_root = None
    del _default_root
</t>
<t tx="ekr.20041012114208.147">def _tkerror(err):

    """Internal function."""
	
    pass
</t>
<t tx="ekr.20041012114208.148">def _exit(code='0'):

    """Internal function. Calling it will throw the exception SystemExit."""
	
    raise SystemExit, code
</t>
<t tx="ekr.20041012114208.149">class CallWrapper:
	"""Internal class. Stores function to call when some user
	defined Tcl function is called e.g. after an event occurred."""
	@others
</t>
<t tx="ekr.20041012114208.150">def __init__(self, func, subst, widget):
    """Store FUNC, SUBST and WIDGET as members."""
    self.func = func
    self.subst = subst
    self.widget = widget
</t>
<t tx="ekr.20041012114208.151">def __call__(self, *args):
    """Apply first function SUBST to arguments, than FUNC."""
    try:
        if self.subst:
            args = apply(self.subst, args)
        return apply(self.func, args)
    except SystemExit, msg:
        raise SystemExit, msg
    except:
        self.widget._report_exception()
</t>
<t tx="ekr.20041012114208.152"></t>
<t tx="ekr.20041012114208.153">_varnum = 0

class Variable:
	"""Internal class. Base class to define value holders for e.g. buttons."""
	_default = ""

	@others
</t>
<t tx="ekr.20041012114208.154">def __init__(self, master=None):
    """Construct a variable with an optional MASTER as master widget.
    The variable is named PY_VAR_number in Tcl.
    """
    global _varnum
    if not master:
        master = _default_root
    self._master = master
    self._tk = master.tk
    self._name = 'PY_VAR' + `_varnum`
    _varnum = _varnum + 1
    self.set(self._default)
</t>
<t tx="ekr.20041012114208.155">def __del__(self):
    """Unset the variable in Tcl."""
    self._tk.globalunsetvar(self._name)
</t>
<t tx="ekr.20041012114208.156">def __str__(self):
    """Return the name of the variable in Tcl."""
    return self._name
</t>
<t tx="ekr.20041012114208.157">def set(self, value):
    """Set the variable to VALUE."""
    return self._tk.globalsetvar(self._name, value)
</t>
<t tx="ekr.20041012114208.158">def trace_variable(self, mode, callback):
    """Define a trace callback for the variable.

    MODE is one of "r", "w", "u" for read, write, undefine.
    CALLBACK must be a function which is called when
    the variable is read, written or undefined.

    Return the name of the callback.
    """
    cbname = self._master._register(callback)
    self._tk.call("trace", "variable", self._name, mode, cbname)
    return cbname
</t>
<t tx="ekr.20041012114208.159">trace = trace_variable
def trace_vdelete(self, mode, cbname):
    """Delete the trace callback for a variable.

    MODE is one of "r", "w", "u" for read, write, undefine.
    CBNAME is the name of the callback returned from trace_variable or trace.
    """
    self._tk.call("trace", "vdelete", self._name, mode, cbname)
    self._master.deletecommand(cbname)
</t>
<t tx="ekr.20041012114208.160">def trace_vinfo(self):
    """Return all trace callback information."""
    return map(self._tk.split, self._tk.splitlist(
        self._tk.call("trace", "vinfo", self._name)))
</t>
<t tx="ekr.20041012114208.161">class StringVar(Variable):
	@others
</t>
<t tx="ekr.20041012114208.162">"""Value holder for strings variables."""
_default = ""
</t>
<t tx="ekr.20041012114208.163">def __init__(self, master=None):
    """Construct a string variable.

    MASTER can be given as master widget."""
    Variable.__init__(self, master)
</t>
<t tx="ekr.20041012114208.164">def get(self):
    """Return value of variable as string."""
    return self._tk.globalgetvar(self._name)
</t>
<t tx="ekr.20041012114208.165">class IntVar(Variable):
	@others

</t>
<t tx="ekr.20041012114208.166">"""Value holder for integer variables."""
_default = 0
</t>
<t tx="ekr.20041012114208.167">def __init__(self, master=None):
    """Construct an integer variable.

    MASTER can be given as master widget."""
    Variable.__init__(self, master)
</t>
<t tx="ekr.20041012114208.168">def get(self):
    """Return the value of the variable as an integer."""
    return getint(self._tk.globalgetvar(self._name))
</t>
<t tx="ekr.20041012114208.169">class DoubleVar(Variable):
	@others
</t>
<t tx="ekr.20041012114208.170">"""Value holder for float variables."""
_default = 0.0
</t>
<t tx="ekr.20041012114208.171">def __init__(self, master=None):
    """Construct a float variable.

    MASTER can be given as a master widget."""
    Variable.__init__(self, master)
</t>
<t tx="ekr.20041012114208.172">def get(self):
    """Return the value of the variable as a float."""
    return getdouble(self._tk.globalgetvar(self._name))
</t>
<t tx="ekr.20041012114208.173">class BooleanVar(Variable):
	@others
</t>
<t tx="ekr.20041012114208.174">"""Value holder for boolean variables."""
_default = "false"
</t>
<t tx="ekr.20041012114208.175">def __init__(self, master=None):
    """Construct a boolean variable.

    MASTER can be given as a master widget."""
    Variable.__init__(self, master)
</t>
<t tx="ekr.20041012114208.176">def get(self):
    """Return the value of the variable as 0 or 1."""
    return self._tk.getboolean(self._tk.globalgetvar(self._name))
</t>
<t tx="ekr.20041012114208.177"># Methods defined on both toplevel and interior widgets

class Misc:
	"""Internal class.
	Base class which defines methods common for interior widgets."""

	# XXX font command?
	_tclCommands = None # EKR: _register sets this ivar

	@others
</t>
<t tx="ekr.20041012114208.178">def destroy(self):

    """Internal function.

    Delete all Tcl commands created for
    this widget in the Tcl interpreter."""

    if self._tclCommands is not None:
        for name in self._tclCommands:
            #print '- Tkinter: deleted command', name
            self.tk.deletecommand(name)
        self._tclCommands = None
</t>
<t tx="ekr.20041012114208.179">def deletecommand(self, name):
    """Internal function.

    Delete the Tcl command provided in NAME."""
    #print '- Tkinter: deleted command', name
    self.tk.deletecommand(name)
    try:
        self._tclCommands.remove(name)
    except ValueError:
        pass
</t>
<t tx="ekr.20041012114208.180">def tk_strictMotif(self, boolean=None):
    """Set Tcl internal variable, whether the look and feel
    should adhere to Motif.

    A parameter of 1 means adhere to Motif (e.g. no color
    change if mouse passes over slider).
    Returns the set value."""
    return self.tk.getboolean(self.tk.call(
        'set', 'tk_strictMotif', boolean))
</t>
<t tx="ekr.20041012114208.181">def tk_bisque(self):
    """Change the color scheme to light brown as used in Tk 3.6 and before."""
    self.tk.call('tk_bisque')
</t>
<t tx="ekr.20041012114208.182">def tk_setPalette(self, *args, **kw):
    """Set a new color scheme for all widget elements.

    A single color as argument will cause that all colors of Tk
    widget elements are derived from this.
    Alternatively several keyword parameters and its associated
    colors can be given. The following keywords are valid:
    activeBackground, foreground, selectColor,
    activeForeground, highlightBackground, selectBackground,
    background, highlightColor, selectForeground,
    disabledForeground, insertBackground, troughColor."""
    self.tk.call(('tk_setPalette',)
          + _flatten(args) + _flatten(kw.items()))
</t>
<t tx="ekr.20041012114208.183">def tk_menuBar(self, *args):
    """Do not use. Needed in Tk 3.6 and earlier."""
    pass # obsolete since Tk 4.0
</t>
<t tx="ekr.20041012114208.184">def wait_variable(self, name='PY_VAR'):
    """Wait until the variable is modified.

    A parameter of type IntVar, StringVar, DoubleVar or
    BooleanVar must be given."""

    self.tk.call('tkwait', 'variable', name)

waitvar = wait_variable # XXX b/w compat</t>
<t tx="ekr.20041012114208.185">def wait_window(self, window=None):
    """Wait until a WIDGET is destroyed.

    If no parameter is given self is used."""
    if window is None:
        window = self
    self.tk.call('tkwait', 'window', window._w)
</t>
<t tx="ekr.20041012114208.186">def wait_visibility(self, window=None):
    """Wait until the visibility of a WIDGET changes
    (e.g. it appears).

    If no parameter is given self is used."""
    if window is None:
        window = self
    self.tk.call('tkwait', 'visibility', window._w)
</t>
<t tx="ekr.20041012114208.187">def setvar(self, name='PY_VAR', value='1'):

    """Set Tcl variable NAME to VALUE."""
	
    self.tk.setvar(name, value)
</t>
<t tx="ekr.20041012114208.188">def getvar(self, name='PY_VAR'):

    """Return value of Tcl variable NAME."""

    return self.tk.getvar(name)
</t>
<t tx="ekr.20041012114208.189">getint = int
getdouble = float

def getboolean(self, s):

    """Return 0 or 1 for Tcl boolean values true and false given as parameter."""

    return self.tk.getboolean(s)
</t>
<t tx="ekr.20041012114208.190">def focus_set(self):

    """Direct input focus to this widget.

    If the application currently does not have the focus
    this widget will get the focus if the application gets
    the focus through the window manager."""
	
    self.tk.call('focus', self._w)

focus = focus_set # XXX b/w compat?</t>
<t tx="ekr.20041012114208.191">def focus_force(self):

    """Direct input focus to this widget even if the
    application does not have the focus. Use with
    caution!"""
	
    self.tk.call('focus', '-force', self._w)
</t>
<t tx="ekr.20041012114208.192">def focus_get(self):
    """Return the widget which has currently the focus in the
    application.

    Use focus_displayof to allow working with several
    displays. Return None if application does not have
    the focus."""
    name = self.tk.call('focus')
    if name == 'none' or not name: return None
    return self._nametowidget(name)
</t>
<t tx="ekr.20041012114208.193">def focus_displayof(self):
    """Return the widget which has currently the focus on the
    display where this widget is located.

    Return None if the application does not have the focus."""
    name = self.tk.call('focus', '-displayof', self._w)
    if name == 'none' or not name: return None
    return self._nametowidget(name)
</t>
<t tx="ekr.20041012114208.194">def focus_lastfor(self):

    """Return the widget which would have the focus if top level
    for this widget gets the focus from the window manager."""
	
    name = self.tk.call('focus', '-lastfor', self._w)
    if name == 'none' or not name: return None
    return self._nametowidget(name)
</t>
<t tx="ekr.20041012114208.195">def tk_focusFollowsMouse(self):

    """The widget under mouse will get automatically focus. Can not
    be disabled easily."""

    self.tk.call('tk_focusFollowsMouse')
</t>
<t tx="ekr.20041012114208.196">def tk_focusNext(self):

    """Return the next widget in the focus order which follows
    widget which has currently the focus.

    The focus order first goes to the next child, then to
    the children of the child recursively and then to the
    next sibling which is higher in the stacking order.  A
    widget is omitted if it has the takefocus resource set
    to 0."""
	
    name = self.tk.call('tk_focusNext', self._w)
    if not name: return None
    return self._nametowidget(name)
</t>
<t tx="ekr.20041012114208.197">def tk_focusPrev(self):

    """Return previous widget in the focus order. See tk_focusNext for details."""
	
    name = self.tk.call('tk_focusPrev', self._w)
    if not name: return None
    return self._nametowidget(name)
</t>
<t tx="ekr.20041012114208.198">def after(self, ms, func=None, *args):
    """Call function once after given time.

    MS specifies the time in milliseconds. FUNC gives the
    function which shall be called. Additional parameters
    are given as parameters to the function call.  Return
    identifier to cancel scheduling with after_cancel."""
    if not func:
        # I'd rather use time.sleep(ms*0.001)
        self.tk.call('after', ms)
    else:
        # XXX Disgusting hack to clean up after calling func
        tmp = []
        def callit(func=func, args=args, self=self, tmp=tmp):
            try:
                apply(func, args)
            finally:
                try:
                    self.deletecommand(tmp[0])
                except TclError:
                    pass
        name = self._register(callit)
        tmp.append(name)
        return self.tk.call('after', ms, name)
</t>
<t tx="ekr.20041012114208.199">def after_idle(self, func, *args):
    """Call FUNC once if the Tcl main loop has no event to
    process.

    Return an identifier to cancel the scheduling with
    after_cancel."""
    return apply(self.after, ('idle', func) + args)
</t>
<t tx="ekr.20041012114208.200">def after_cancel(self, id):
    """Cancel scheduling of function identified with ID.

    Identifier returned by after or after_idle must be
    given as first parameter."""
    self.tk.call('after', 'cancel', id)
</t>
<t tx="ekr.20041012114208.201">def bell(self, displayof=0):
    """Ring a display's bell."""
    self.tk.call(('bell',) + self._displayof(displayof))
</t>
<t tx="ekr.20041012114208.202"># Clipboard handling:
def clipboard_clear(self, **kw):
    """Clear the data in the Tk clipboard.

    A widget specified for the optional displayof keyword
    argument specifies the target display."""
    if not kw.has_key('displayof'): kw['displayof'] = self._w
    self.tk.call(('clipboard', 'clear') + self._options(kw))
</t>
<t tx="ekr.20041012114208.203">def clipboard_append(self, string, **kw):
    """Append STRING to the Tk clipboard.

    A widget specified at the optional displayof keyword
    argument specifies the target display. The clipboard
    can be retrieved with selection_get."""
    if not kw.has_key('displayof'): kw['displayof'] = self._w
    self.tk.call(('clipboard', 'append') + self._options(kw)
          + ('--', string))
</t>
<t tx="ekr.20041012114208.204"># XXX grab current w/o window argument
def grab_current(self):
    """Return widget which has currently the grab in this application
    or None."""
    name = self.tk.call('grab', 'current', self._w)
    if not name: return None
    return self._nametowidget(name)
</t>
<t tx="ekr.20041012114208.205">def grab_release(self):
    """Release grab for this widget if currently set."""
    self.tk.call('grab', 'release', self._w)
</t>
<t tx="ekr.20041012114208.206">def grab_set(self):
    """Set grab for this widget.

    A grab directs all events to this and descendant
    widgets in the application."""
    self.tk.call('grab', 'set', self._w)
</t>
<t tx="ekr.20041012114208.207">&lt;&lt; class Misc methods &gt;&gt;=

def grab_set_global(self):
    """Set global grab for this widget.

    A global grab directs all events to this and
    descendant widgets on the display. Use with caution -
    other applications do not get events anymore."""
    self.tk.call('grab', 'set', '-global', self._w)
</t>
<t tx="ekr.20041012114208.208">&lt;&lt; class Misc methods &gt;&gt;=

def grab_status(self):
    """Return None, "local" or "global" if this widget has
    no, a local or a global grab."""
    status = self.tk.call('grab', 'status', self._w)
    if status == 'none': status = None
    return status
</t>
<t tx="ekr.20041012114208.209">&lt;&lt; class Misc methods &gt;&gt;=

def lower(self, belowThis=None):
    """Lower this widget in the stacking order."""
    self.tk.call('lower', self._w, belowThis)
</t>
<t tx="ekr.20041012114208.210">def option_add(self, pattern, value, priority = None):
    """Set a VALUE (second parameter) for an option
    PATTERN (first parameter).

    An optional third parameter gives the numeric priority
    (defaults to 80)."""
    self.tk.call('option', 'add', pattern, value, priority)
</t>
<t tx="ekr.20041012114208.211">&lt;&lt; class Misc methods &gt;&gt;=

def option_clear(self):
    """Clear the option database.

    It will be reloaded if option_add is called."""
    self.tk.call('option', 'clear')
</t>
<t tx="ekr.20041012114208.212">&lt;&lt; class Misc methods &gt;&gt;=

def option_get(self, name, className):
    """Return the value for an option NAME for this widget
    with CLASSNAME.

    Values with higher priority override lower values."""
    return self.tk.call('option', 'get', self._w, name, className)
</t>
<t tx="ekr.20041012114208.213">&lt;&lt; class Misc methods &gt;&gt;=

def option_readfile(self, fileName, priority = None):
    """Read file FILENAME into the option database.

    An optional second parameter gives the numeric
    priority."""
    self.tk.call('option', 'readfile', fileName, priority)
</t>
<t tx="ekr.20041012114208.214">def selection_clear(self, **kw):
    """Clear the current X selection."""
    if not kw.has_key('displayof'): kw['displayof'] = self._w
    self.tk.call(('selection', 'clear') + self._options(kw))
</t>
<t tx="ekr.20041012114208.215">def selection_get(self, **kw):
    """Return the contents of the current X selection.

    A keyword parameter selection specifies the name of
    the selection and defaults to PRIMARY.  A keyword
    parameter displayof specifies a widget on the display
    to use."""
    if not kw.has_key('displayof'): kw['displayof'] = self._w
    return self.tk.call(('selection', 'get') + self._options(kw))
</t>
<t tx="ekr.20041012114208.216">def selection_handle(self, command, **kw):
    """Specify a function COMMAND to call if the X
    selection owned by this widget is queried by another
    application.

    This function must return the contents of the
    selection. The function will be called with the
    arguments OFFSET and LENGTH which allows the chunking
    of very long selections. The following keyword
    parameters can be provided:
    selection - name of the selection (default PRIMARY),
    type - type of the selection (e.g. STRING, FILE_NAME)."""
    name = self._register(command)
    self.tk.call(('selection', 'handle') + self._options(kw)
          + (self._w, name))
</t>
<t tx="ekr.20041012114208.217">def selection_own(self, **kw):
    """Become owner of X selection.

    A keyword parameter selection specifies the name of
    the selection (default PRIMARY)."""
    self.tk.call(('selection', 'own') +
             self._options(kw) + (self._w,))
</t>
<t tx="ekr.20041012114208.218">&lt;&lt; class Misc methods &gt;&gt;=

def selection_own_get(self, **kw):
    """Return owner of X selection.

    The following keyword parameter can
    be provided:
    selection - name of the selection (default PRIMARY),
    type - type of the selection (e.g. STRING, FILE_NAME)."""
    if not kw.has_key('displayof'): kw['displayof'] = self._w
    name = self.tk.call(('selection', 'own') + self._options(kw))
    if not name: return None
    return self._nametowidget(name)
</t>
<t tx="ekr.20041012114208.219">&lt;&lt; class Misc methods &gt;&gt;=

def send(self, interp, cmd, *args):
    """Send Tcl command CMD to different interpreter INTERP to be executed."""
    return self.tk.call(('send', interp, cmd) + args)
</t>
<t tx="ekr.20041012114208.220">&lt;&lt; class Misc methods &gt;&gt;=

def lower(self, belowThis=None):
    """Lower this widget in the stacking order."""
    self.tk.call('lower', self._w, belowThis)
</t>
<t tx="ekr.20041012114208.221">&lt;&lt; class Misc methods &gt;&gt;=

def tkraise(self, aboveThis=None):
    """Raise this widget in the stacking order."""
    self.tk.call('raise', self._w, aboveThis)
</t>
<t tx="ekr.20041012114208.222">&lt;&lt; class Misc methods &gt;&gt;=

lift = tkraise
def colormodel(self, value=None):
    """Useless. Not implemented in Tk."""
    return self.tk.call('tk', 'colormodel', self._w, value)
</t>
<t tx="ekr.20041012114208.223"></t>
<t tx="ekr.20041012114208.224">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_atom(self, name, displayof=0):
    """Return integer which represents atom NAME."""
    args = ('winfo', 'atom') + self._displayof(displayof) + (name,)
    return getint(self.tk.call(args))
</t>
<t tx="ekr.20041012114208.225">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_atomname(self, id, displayof=0):
    """Return name of atom with identifier ID."""
    args = ('winfo', 'atomname') \
           + self._displayof(displayof) + (id,)
    return self.tk.call(args)
</t>
<t tx="ekr.20041012114208.226">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_cells(self):
    """Return number of cells in the colormap for this widget."""
    return getint(
        self.tk.call('winfo', 'cells', self._w))
</t>
<t tx="ekr.20041012114208.227">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_children(self):
    """Return a list of all widgets which are children of this widget."""
    return map(self._nametowidget,
           self.tk.splitlist(self.tk.call(
               'winfo', 'children', self._w)))
</t>
<t tx="ekr.20041012114208.228">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_class(self):
    """Return window class name of this widget."""
    return self.tk.call('winfo', 'class', self._w)
</t>
<t tx="ekr.20041012114208.229">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_colormapfull(self):
    """Return true if at the last color request the colormap was full."""
    return self.tk.getboolean(
        self.tk.call('winfo', 'colormapfull', self._w))
</t>
<t tx="ekr.20041012114208.230">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_containing(self, rootX, rootY, displayof=0):
    """Return the widget which is at the root coordinates ROOTX, ROOTY."""
    args = ('winfo', 'containing') \
           + self._displayof(displayof) + (rootX, rootY)
    name = self.tk.call(args)
    if not name: return None
    return self._nametowidget(name)
</t>
<t tx="ekr.20041012114208.231">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_depth(self):
    """Return the number of bits per pixel."""
    return getint(self.tk.call('winfo', 'depth', self._w))
</t>
<t tx="ekr.20041012114208.232">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_exists(self):
    """Return true if this widget exists."""
    return getint(
        self.tk.call('winfo', 'exists', self._w))
</t>
<t tx="ekr.20041012114208.233">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_fpixels(self, number):
    """Return the number of pixels for the given distance NUMBER
    (e.g. "3c") as float."""
    return getdouble(self.tk.call(
        'winfo', 'fpixels', self._w, number))
</t>
<t tx="ekr.20041012114208.234">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_geometry(self):
    """Return geometry string for this widget in the form "widthxheight+X+Y"."""
    return self.tk.call('winfo', 'geometry', self._w)
</t>
<t tx="ekr.20041012114208.235">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_height(self):
    """Return height of this widget."""
    return getint(
        self.tk.call('winfo', 'height', self._w))
</t>
<t tx="ekr.20041012114208.236">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_id(self):
    """Return identifier ID for this widget."""
    return self.tk.getint(
        self.tk.call('winfo', 'id', self._w))
</t>
<t tx="ekr.20041012114208.237">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_interps(self, displayof=0):
    """Return the name of all Tcl interpreters for this display."""
    args = ('winfo', 'interps') + self._displayof(displayof)
    return self.tk.splitlist(self.tk.call(args))
</t>
<t tx="ekr.20041012114208.238">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_ismapped(self):
    """Return true if this widget is mapped."""
    return getint(
        self.tk.call('winfo', 'ismapped', self._w))
</t>
<t tx="ekr.20041012114208.239">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_manager(self):
    """Return the window mananger name for this widget."""
    return self.tk.call('winfo', 'manager', self._w)
</t>
<t tx="ekr.20041012114208.240">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_name(self):
    """Return the name of this widget."""
    return self.tk.call('winfo', 'name', self._w)
</t>
<t tx="ekr.20041012114208.241">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_parent(self):
    """Return the name of the parent of this widget."""
    return self.tk.call('winfo', 'parent', self._w)
</t>
<t tx="ekr.20041012114208.242">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_pathname(self, id, displayof=0):
    """Return the pathname of the widget given by ID."""
    args = ('winfo', 'pathname') \
           + self._displayof(displayof) + (id,)
    return self.tk.call(args)
</t>
<t tx="ekr.20041012114208.243">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_pixels(self, number):
    """Rounded integer value of winfo_fpixels."""
    return getint(
        self.tk.call('winfo', 'pixels', self._w, number))
</t>
<t tx="ekr.20041012114208.244">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_pointerx(self):
    """Return the x coordinate of the pointer on the root window."""
    return getint(
        self.tk.call('winfo', 'pointerx', self._w))
</t>
<t tx="ekr.20041012114208.245">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_pointerxy(self):
    """Return a tuple of x and y coordinates of the pointer on the root window."""
    return self._getints(
        self.tk.call('winfo', 'pointerxy', self._w))
</t>
<t tx="ekr.20041012114208.246">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_pointery(self):
    """Return the y coordinate of the pointer on the root window."""
    return getint(
        self.tk.call('winfo', 'pointery', self._w))
</t>
<t tx="ekr.20041012114208.247">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_reqheight(self):
    """Return requested height of this widget."""
    return getint(
        self.tk.call('winfo', 'reqheight', self._w))
</t>
<t tx="ekr.20041012114208.248">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_reqwidth(self):
    """Return requested width of this widget."""
    return getint(
        self.tk.call('winfo', 'reqwidth', self._w))
</t>
<t tx="ekr.20041012114208.249">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_rgb(self, color):
    """Return tuple of decimal values for red, green, blue for
    COLOR in this widget."""
    return self._getints(
        self.tk.call('winfo', 'rgb', self._w, color))
</t>
<t tx="ekr.20041012114208.250">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_rootx(self):
    """Return x coordinate of upper left corner of this widget on the
    root window."""
    return getint(
        self.tk.call('winfo', 'rootx', self._w))
</t>
<t tx="ekr.20041012114208.251">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_rooty(self):
    """Return y coordinate of upper left corner of this widget on the
    root window."""
    return getint(
        self.tk.call('winfo', 'rooty', self._w))
</t>
<t tx="ekr.20041012114208.252">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_screen(self):
    """Return the screen name of this widget."""
    return self.tk.call('winfo', 'screen', self._w)
</t>
<t tx="ekr.20041012114208.253">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_screencells(self):
    """Return the number of the cells in the colormap of the screen
    of this widget."""
    return getint(
        self.tk.call('winfo', 'screencells', self._w))
</t>
<t tx="ekr.20041012114208.254">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_screendepth(self):
    """Return the number of bits per pixel of the root window of the
    screen of this widget."""
    return getint(
        self.tk.call('winfo', 'screendepth', self._w))
</t>
<t tx="ekr.20041012114208.255">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_screenheight(self):
    """Return the number of pixels of the height of the screen of this widget
    in pixel."""
    return getint(
        self.tk.call('winfo', 'screenheight', self._w))
</t>
<t tx="ekr.20041012114208.256">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_screenmmheight(self):
    """Return the number of pixels of the height of the screen of
    this widget in mm."""
    return getint(
        self.tk.call('winfo', 'screenmmheight', self._w))
</t>
<t tx="ekr.20041012114208.257">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_screenmmwidth(self):
    """Return the number of pixels of the width of the screen of
    this widget in mm."""
    return getint(
        self.tk.call('winfo', 'screenmmwidth', self._w))
</t>
<t tx="ekr.20041012114208.258">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_screenvisual(self):
    """Return one of the strings directcolor, grayscale, pseudocolor,
    staticcolor, staticgray, or truecolor for the default
    colormodel of this screen."""
    return self.tk.call('winfo', 'screenvisual', self._w)
</t>
<t tx="ekr.20041012114208.259">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_screenwidth(self):
    """Return the number of pixels of the width of the screen of
    this widget in pixel."""
    return getint(
        self.tk.call('winfo', 'screenwidth', self._w))
</t>
<t tx="ekr.20041012114208.260">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_server(self):
    """Return information of the X-Server of the screen of this widget in
    the form "XmajorRminor vendor vendorVersion"."""
    return self.tk.call('winfo', 'server', self._w)
</t>
<t tx="ekr.20041012114208.261">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_toplevel(self):
    """Return the toplevel widget of this widget."""
    return self._nametowidget(self.tk.call(
        'winfo', 'toplevel', self._w))
</t>
<t tx="ekr.20041012114208.262">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_viewable(self):
    """Return true if the widget and all its higher ancestors are mapped."""
    return getint(
        self.tk.call('winfo', 'viewable', self._w))
</t>
<t tx="ekr.20041012114208.263">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_visual(self):
    """Return one of the strings directcolor, grayscale, pseudocolor,
    staticcolor, staticgray, or truecolor for the
    colormodel of this widget."""
    return self.tk.call('winfo', 'visual', self._w)
</t>
<t tx="ekr.20041012114208.264">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_visualid(self):
    """Return the X identifier for the visual for this widget."""
    return self.tk.call('winfo', 'visualid', self._w)
</t>
<t tx="ekr.20041012114208.265">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_visualsavailable(self, includeids=0):
    """Return a list of all visuals available for the screen
    of this widget.

    Each item in the list consists of a visual name (see winfo_visual), a
    depth and if INCLUDEIDS=1 is given also the X identifier."""
    data = self.tk.split(
        self.tk.call('winfo', 'visualsavailable', self._w,
                 includeids and 'includeids' or None))
    if type(data) is StringType:
        data = [self.tk.split(data)]
    return map(self.__winfo_parseitem, data)
</t>
<t tx="ekr.20041012114208.266">&lt;&lt; class Misc methods &gt;&gt;=

def __winfo_parseitem(self, t):
    """Internal function."""
    return t[:1] + tuple(map(self.__winfo_getint, t[1:]))
</t>
<t tx="ekr.20041012114208.267">&lt;&lt; class Misc methods &gt;&gt;=

def __winfo_getint(self, x):
    """Internal function."""
    return int(x, 0)
</t>
<t tx="ekr.20041012114208.268">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_vrootheight(self):
    """Return the height of the virtual root window associated with this
    widget in pixels. If there is no virtual root window return the
    height of the screen."""
    return getint(
        self.tk.call('winfo', 'vrootheight', self._w))
</t>
<t tx="ekr.20041012114208.269">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_vrootwidth(self):
    """Return the width of the virtual root window associated with this
    widget in pixel. If there is no virtual root window return the
    width of the screen."""
    return getint(
        self.tk.call('winfo', 'vrootwidth', self._w))
</t>
<t tx="ekr.20041012114208.270">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_vrootx(self):
    """Return the x offset of the virtual root relative to the root
    window of the screen of this widget."""
    return getint(
        self.tk.call('winfo', 'vrootx', self._w))
</t>
<t tx="ekr.20041012114208.271">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_vrooty(self):
    """Return the y offset of the virtual root relative to the root
    window of the screen of this widget."""
    return getint(
        self.tk.call('winfo', 'vrooty', self._w))
</t>
<t tx="ekr.20041012114208.272">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_width(self):
    """Return the width of this widget."""
    return getint(
        self.tk.call('winfo', 'width', self._w))
</t>
<t tx="ekr.20041012114208.273">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_x(self):
    """Return the x coordinate of the upper left corner of this widget
    in the parent."""
    return getint(
        self.tk.call('winfo', 'x', self._w))
</t>
<t tx="ekr.20041012114208.274">&lt;&lt; class Misc methods &gt;&gt;=

def winfo_y(self):
    """Return the y coordinate of the upper left corner of this widget
    in the parent."""
    return getint(
        self.tk.call('winfo', 'y', self._w))
</t>
<t tx="ekr.20041012114208.275">&lt;&lt; class Misc methods &gt;&gt;=

def update(self):
    """Enter event loop until all pending events have been processed by Tcl."""
    self.tk.call('update')
</t>
<t tx="ekr.20041012114208.276">&lt;&lt; class Misc methods &gt;&gt;=

def update_idletasks(self):
    """Enter event loop until all idle callbacks have been called. This
    will update the display of windows but not process events caused by
    the user."""
    self.tk.call('update', 'idletasks')
</t>
<t tx="ekr.20041012114208.277">&lt;&lt; class Misc methods &gt;&gt;=

def bindtags(self, tagList=None):
    """Set or get the list of bindtags for this widget.

    With no argument return the list of all bindtags associated with
    this widget. With a list of strings as argument the bindtags are
    set to this list. The bindtags determine in which order events are
    processed (see bind)."""
    if tagList is None:
        return self.tk.splitlist(
            self.tk.call('bindtags', self._w))
    else:
        self.tk.call('bindtags', self._w, tagList)
</t>
<t tx="ekr.20041012114208.278">&lt;&lt; class Misc methods &gt;&gt;=

def _bind(self, what, sequence, func, add, needcleanup=1):
    """Internal function."""
    if type(func) is StringType:
        self.tk.call(what + (sequence, func))
    elif func:
        funcid = self._register(func, self._substitute,
                    needcleanup)
        cmd = ('%sif {"[%s %s]" == "break"} break\n'
               %
               (add and '+' or '',
            funcid,
            " ".join(self._subst_format)))
        self.tk.call(what + (sequence, cmd))
        return funcid
    elif sequence:
        return self.tk.call(what + (sequence,))
    else:
        return self.tk.splitlist(self.tk.call(what))
</t>
<t tx="ekr.20041012114208.279">&lt;&lt; class Misc methods &gt;&gt;=

def bind(self, sequence=None, func=None, add=None):
    """Bind to this widget at event SEQUENCE a call to function FUNC.

    SEQUENCE is a string of concatenated event
    patterns. An event pattern is of the form
    &lt;MODIFIER-MODIFIER-TYPE-DETAIL&gt; where MODIFIER is one
    of Control, Mod2, M2, Shift, Mod3, M3, Lock, Mod4, M4,
    Button1, B1, Mod5, M5 Button2, B2, Meta, M, Button3,
    B3, Alt, Button4, B4, Double, Button5, B5 Triple,
    Mod1, M1. TYPE is one of Activate, Enter, Map,
    ButtonPress, Button, Expose, Motion, ButtonRelease
    FocusIn, MouseWheel, Circulate, FocusOut, Property,
    Colormap, Gravity Reparent, Configure, KeyPress, Key,
    Unmap, Deactivate, KeyRelease Visibility, Destroy,
    Leave and DETAIL is the button number for ButtonPress,
    ButtonRelease and DETAIL is the Keysym for KeyPress and
    KeyRelease. Examples are
    &lt;Control-Button-1&gt; for pressing Control and mouse button 1 or
    &lt;Alt-A&gt; for pressing A and the Alt key (KeyPress can be omitted).
    An event pattern can also be a virtual event of the form
    &lt;&lt;AString&gt;&gt; where AString can be arbitrary. This
    event can be generated by event_generate.
    If events are concatenated they must appear shortly
    after each other.

    FUNC will be called if the event sequence occurs with an
    instance of Event as argument. If the return value of FUNC is
    "break" no further bound function is invoked.

    An additional boolean parameter ADD specifies whether FUNC will
    be called additionally to the other bound function or whether
    it will replace the previous function.

    Bind will return an identifier to allow deletion of the bound function with
    unbind without memory leak.

    If FUNC or SEQUENCE is omitted the bound function or list
    of bound events are returned."""

    return self._bind(('bind', self._w), sequence, func, add)
</t>
<t tx="ekr.20041012114208.280">def unbind(self, sequence, funcid=None):

    """Unbind for this widget for event SEQUENCE  the
    function identified with FUNCID."""

    self.tk.call('bind', self._w, sequence, '')
    if funcid:
        self.deletecommand(funcid)
</t>
<t tx="ekr.20041012114208.281">def bind_all(self, sequence=None, func=None, add=None):

    """Bind to all widgets at an event SEQUENCE a call to function FUNC.
    An additional boolean parameter ADD specifies whether FUNC will
    be called additionally to the other bound function or whether
    it will replace the previous function. See bind for the return value."""

    return self._bind(('bind', 'all'), sequence, func, add, 0)
</t>
<t tx="ekr.20041012114208.282">def unbind_all(self, sequence):

    """Unbind for all widgets for event SEQUENCE all functions."""
	
    self.tk.call('bind', 'all' , sequence, '')
</t>
<t tx="ekr.20041012114208.283">def bind_class(self, className, sequence=None, func=None, add=None):

    """Bind to widgets with bindtag CLASSNAME at event
    SEQUENCE a call of function FUNC. An additional
    boolean parameter ADD specifies whether FUNC will be
    called additionally to the other bound function or
    whether it will replace the previous function. See bind for
    the return value."""

    return self._bind(('bind', className), sequence, func, add, 0)
</t>
<t tx="ekr.20041012114208.284">def unbind_class(self, className, sequence):

    """Unbind for a all widgets with bindtag CLASSNAME for event SEQUENCE
    all functions."""

    self.tk.call('bind', className , sequence, '')
</t>
<t tx="ekr.20041012114208.285">def mainloop(self, n=0):

    """Call the mainloop of Tk."""

    self.tk.mainloop(n)
</t>
<t tx="ekr.20041012114208.286">def quit(self):

    """Quit the Tcl interpreter. All widgets will be destroyed."""

    self.tk.quit()
</t>
<t tx="ekr.20041012114208.287">def _getints(self, string):

    """Internal function."""

    if string:
        return tuple(map(getint, self.tk.splitlist(string)))
</t>
<t tx="ekr.20041012114208.288">def _getdoubles(self, string):

    """Internal function."""

    if string:
        return tuple(map(getdouble, self.tk.splitlist(string)))
</t>
<t tx="ekr.20041012114208.289">def _getboolean(self, string):

    """Internal function."""

    if string:
        return self.tk.getboolean(string)
</t>
<t tx="ekr.20041012114208.290">def _displayof(self, displayof):
    """Internal function."""
    if displayof:
        return ('-displayof', displayof)
    if displayof is None:
        return ('-displayof', self._w)
    return ()
</t>
<t tx="ekr.20041012114208.291">def _options(self, cnf, kw = None):
    """Internal function."""
    if kw:
        cnf = _cnfmerge((cnf, kw))
    else:
        cnf = _cnfmerge(cnf)
    res = ()
    for k, v in cnf.items():
        if v is not None:
            if k[-1] == '_': k = k[:-1]
            if callable(v):
                v = self._register(v)
            res = res + ('-'+k, v)
    return res
</t>
<t tx="ekr.20041012114208.292">def nametowidget(self, name):

    """Return the Tkinter instance of a widget identified by
    its Tcl name NAME."""

    w = self
    if name[0] == '.':
        w = w._root()
        name = name[1:]
    while name:
        i = name.find('.')
        if i &gt;= 0:
            name, tail = name[:i], name[i+1:]
        else:
            tail = ''
        w = w.children[name]
        name = tail
    return w

_nametowidget = nametowidget</t>
<t tx="ekr.20041012114208.293">def _register(self, func, subst=None, needcleanup=1):
    """Return a newly created Tcl function. If this
    function is called, the Python function FUNC will
    be executed. An optional function SUBST can
    be given which will be executed before FUNC."""
    f = CallWrapper(func, subst, self).__call__
    name = `id(f)`
    try:
        func = func.im_func
    except AttributeError:
        pass
    try:
        name = name + func.__name__
    except AttributeError:
        pass
    self.tk.createcommand(name, f)
    if needcleanup:
        if self._tclCommands is None:
            self._tclCommands = []
        self._tclCommands.append(name)
    #print '+ Tkinter created command', name
    return name
	
register = _register
</t>
<t tx="ekr.20041012114208.294">def _root(self):

    """Internal function."""

    w = self
    while w.master: w = w.master
    return w
</t>
<t tx="ekr.20041012114208.295">_subst_format = ('%#', '%b', '%f', '%h', '%k',
         '%s', '%t', '%w', '%x', '%y',
         '%A', '%E', '%K', '%N', '%W', '%T', '%X', '%Y', '%D')

def _substitute(self, *args):
    """Internal function."""
    if len(args) != len(self._subst_format): return args
    getboolean = self.tk.getboolean
    getint = int
    nsign, b, f, h, k, s, t, w, x, y, A, E, K, N, W, T, X, Y, D = args
    # Missing: (a, c, d, m, o, v, B, R)
    e = Event()
    e.serial = getint(nsign)
    e.num = getint(b)
    try: e.focus = getboolean(f)
    except TclError: pass
    e.height = getint(h)
    e.keycode = getint(k)
    # For Visibility events, event state is a string and
    # not an integer:
    try:
        e.state = getint(s)
    except ValueError:
        e.state = s
    e.time = getint(t)
    e.width = getint(w)
    e.x = getint(x)
    e.y = getint(y)
    e.char = A
    try: e.send_event = getboolean(E)
    except TclError: pass
    e.keysym = K
    e.keysym_num = getint(N)
    e.type = T
    try:
        e.widget = self._nametowidget(W)
    except KeyError:
        e.widget = W
    e.x_root = getint(X)
    e.y_root = getint(Y)
    try:
        e.delta = getint(D)
    except ValueError:
        e.delta = 0
    return (e,)
</t>
<t tx="ekr.20041012114208.296">def _report_exception(self):
    """Internal function."""
    import sys
    exc, val, tb = sys.exc_type, sys.exc_value, sys.exc_traceback
    root = self._root()
    root.report_callback_exception(exc, val, tb)
</t>
<t tx="ekr.20041012114208.297"># These used to be defined in Widget:
def configure(self, cnf=None, **kw):
    """Configure resources of a widget.

    The values for resources are specified as keyword
    arguments. To get an overview about
    the allowed keyword arguments call the method keys.
    """
    # XXX ought to generalize this so tag_config etc. can use it
    if kw:
        cnf = _cnfmerge((cnf, kw))
    elif cnf:
        cnf = _cnfmerge(cnf)
    if cnf is None:
        cnf = {}
        for x in self.tk.split(
            self.tk.call(self._w, 'configure')):
            cnf[x[0][1:]] = (x[0][1:],) + x[1:]
        return cnf
    if type(cnf) is StringType:
        x = self.tk.split(self.tk.call(
            self._w, 'configure', '-'+cnf))
        return (x[0][1:],) + x[1:]
    self.tk.call((self._w, 'configure')
          + self._options(cnf))
		  
config = configure
</t>
<t tx="ekr.20041012114208.298">def cget(self, key):

    """Return the resource value for a KEY given as string."""
	
    return self.tk.call(self._w, 'cget', '-' + key)

__getitem__ = cget</t>
<t tx="ekr.20041012114208.299">def __setitem__(self, key, value):

    self.configure({key: value})
</t>
<t tx="ekr.20041012114208.300">def keys(self):

    """Return a list of all resource names of this widget."""
	
    return map(lambda x: x[0][1:],
           self.tk.split(self.tk.call(self._w, 'configure')))
</t>
<t tx="ekr.20041012114208.301">def __str__(self):

    """Return the window path name of this widget."""

    return self._w
</t>
<t tx="ekr.20041012114208.302"></t>
<t tx="ekr.20041012114208.303"># Pack methods that apply to the master
_noarg_ = ['_noarg_']

def pack_propagate(self, flag=_noarg_):
    """Set or get the status for propagation of geometry information.

    A boolean argument specifies whether the geometry information
    of the slaves will determine the size of this widget. If no argument
    is given the current setting will be returned.
    """
    if flag is Misc._noarg_:
        return self._getboolean(self.tk.call(
            'pack', 'propagate', self._w))
    else:
        self.tk.call('pack', 'propagate', self._w, flag)
		
propagate = pack_propagate

</t>
<t tx="ekr.20041012114208.304">
def pack_slaves(self):
    """Return a list of all slaves of this widget
    in its packing order."""
    return map(self._nametowidget,
           self.tk.splitlist(
               self.tk.call('pack', 'slaves', self._w)))
</t>
<t tx="ekr.20041012114208.305">&lt;&lt; class Misc methods &gt;&gt;=

slaves = pack_slaves
# Place method that applies to the master
def place_slaves(self):
    """Return a list of all slaves of this widget
    in its packing order."""
    return map(self._nametowidget,
           self.tk.splitlist(
               self.tk.call(
                   'place', 'slaves', self._w)))
</t>
<t tx="ekr.20041012114208.306"></t>
<t tx="ekr.20041012114208.307"># Grid methods that apply to the master

def grid_bbox(self, column=None, row=None, col2=None, row2=None):
    """Return a tuple of integer coordinates for the bounding
    box of this widget controlled by the geometry manager grid.

    If COLUMN, ROW is given the bounding box applies from
    the cell with row and column 0 to the specified
    cell. If COL2 and ROW2 are given the bounding box
    starts at that cell.

    The returned integers specify the offset of the upper left
    corner in the master widget and the width and height.
    """
    args = ('grid', 'bbox', self._w)
    if column is not None and row is not None:
        args = args + (column, row)
    if col2 is not None and row2 is not None:
        args = args + (col2, row2)
    return self._getints(apply(self.tk.call, args)) or None
	
bbox = grid_bbox
</t>
<t tx="ekr.20041012114208.308">def _grid_configure(self, command, index, cnf, kw):
    """Internal function."""
    if type(cnf) is StringType and not kw:
        if cnf[-1:] == '_':
            cnf = cnf[:-1]
        if cnf[:1] != '-':
            cnf = '-'+cnf
        options = (cnf,)
    else:
        options = self._options(cnf, kw)
    if not options:
        res = self.tk.call('grid',
                   command, self._w, index)
        words = self.tk.splitlist(res)
        dict = {}
        for i in range(0, len(words), 2):
            key = words[i][1:]
            value = words[i+1]
            if not value:
                value = None
            elif '.' in value:
                value = getdouble(value)
            else:
                value = getint(value)
            dict[key] = value
        return dict
    res = self.tk.call(
              ('grid', command, self._w, index)
              + options)
    if len(options) == 1:
        if not res: return None
        # In Tk 7.5, -width can be a float
        if '.' in res: return getdouble(res)
        return getint(res)
</t>
<t tx="ekr.20041012114208.309">def grid_columnconfigure(self, index, cnf={}, **kw):
    """Configure column INDEX of a grid.

    Valid resources are minsize (minimum size of the column),
    weight (how much does additional space propagate to this column)
    and pad (how much space to let additionally)."""
    return self._grid_configure('columnconfigure', index, cnf, kw)

columnconfigure = grid_columnconfigure</t>
<t tx="ekr.20041012114208.310">def grid_propagate(self, flag=_noarg_):
    """Set or get the status for propagation of geometry information.

    A boolean argument specifies whether the geometry information
    of the slaves will determine the size of this widget. If no argument
    is given, the current setting will be returned.
    """
    if flag is Misc._noarg_:
        return self._getboolean(self.tk.call(
            'grid', 'propagate', self._w))
    else:
        self.tk.call('grid', 'propagate', self._w, flag)
</t>
<t tx="ekr.20041012114208.311">def grid_rowconfigure(self, index, cnf={}, **kw):
    """Configure row INDEX of a grid.

    Valid resources are minsize (minimum size of the row),
    weight (how much does additional space propagate to this row)
    and pad (how much space to let additionally)."""

    return self._grid_configure('rowconfigure', index, cnf, kw)

rowconfigure = grid_rowconfigure</t>
<t tx="ekr.20041012114208.312">def grid_size(self):

    """Return a tuple of the number of column and rows in the grid."""
	
    return self._getints(
        self.tk.call('grid', 'size', self._w)) or None

size = grid_size</t>
<t tx="ekr.20041012114208.313">

def grid_slaves(self, row=None, column=None):
    """Return a list of all slaves of this widget
    in its packing order."""
    args = ()
    if row is not None:
        args = args + ('-row', row)
    if column is not None:
        args = args + ('-column', column)
    return map(self._nametowidget,
           self.tk.splitlist(self.tk.call(
               ('grid', 'slaves', self._w) + args)))
</t>
<t tx="ekr.20041012114208.314"></t>
<t tx="ekr.20041012114208.315"># Support for the "event" command, new in Tk 4.2.
# By Case Roole.

def event_add(self, virtual, *sequences):
    """Bind a virtual event VIRTUAL (of the form &lt;&lt;Name&gt;&gt;)
    to an event SEQUENCE such that the virtual event is triggered
    whenever SEQUENCE occurs."""
    args = ('event', 'add', virtual) + sequences
    self.tk.call(args)
</t>
<t tx="ekr.20041012114208.316">&lt;&lt; class Misc methods &gt;&gt;=

def event_delete(self, virtual, *sequences):
    """Unbind a virtual event VIRTUAL from SEQUENCE."""
    args = ('event', 'delete', virtual) + sequences
    self.tk.call(args)
</t>
<t tx="ekr.20041012114208.317">&lt;&lt; class Misc methods &gt;&gt;=

def event_generate(self, sequence, **kw):
    """Generate an event SEQUENCE. Additional
    keyword arguments specify parameter of the event
    (e.g. x, y, rootx, rooty)."""
    args = ('event', 'generate', self._w, sequence)
    for k, v in kw.items():
        args = args + ('-%s' % k, str(v))
    self.tk.call(args)
</t>
<t tx="ekr.20041012114208.318">&lt;&lt; class Misc methods &gt;&gt;=

def event_info(self, virtual=None):
    """Return a list of all virtual events or the information
    about the SEQUENCE bound to the virtual event VIRTUAL."""
    return self.tk.splitlist(
        self.tk.call('event', 'info', virtual))
</t>
<t tx="ekr.20041012114208.319"></t>
<t tx="ekr.20041012114208.320"># Image related commands

def image_names(self):
    """Return a list of all existing image names."""
    return self.tk.call('image', 'names')
</t>
<t tx="ekr.20041012114208.321">&lt;&lt; class Misc methods &gt;&gt;=

def image_types(self):
    """Return a list of all available image types (e.g. phote bitmap)."""
    return self.tk.call('image', 'types')
</t>
<t tx="ekr.20041012114208.322">@ Ideally, the classes Pack, Place and Grid disappear, the pack/place/grid methods are defined on the Widget class, and everybody uses w.pack_whatever(...) instead of Pack.whatever(w,...), with pack(), place() and grid() being short for pack_configure(), place_configure() and grid_columnconfigure(), and forget() being short for pack_forget().

As a practical matter, I'm afraid that there is too much code out there that may be using the Pack, Place or Grid class, so I leave them intact -- but only as backwards compatibility features.  Also note that those methods that take a master as argument (e.g. pack_propagate) have been moved to the Misc class (which now incorporates all methods common between toplevel and interior widgets).  Again, for compatibility, these are copied into the Pack, Place or Grid class.</t>
<t tx="ekr.20041012114208.323">class Pack:

	"""Geometry manager Pack.
	Base class to use the methods pack_* in every widget."""

	@others

</t>
<t tx="ekr.20041012114208.324">def pack_configure(self, cnf={}, **kw):
    """Pack a widget in the parent widget. Use as options:
    after=widget - pack it after you have packed widget
    anchor=NSEW (or subset) - position widget according to
                              given direction
            before=widget - pack it before you will pack widget
    expand=1 or 0 - expand widget if parent size grows
    fill=NONE or X or Y or BOTH - fill widget if widget grows
    in=master - use master to contain this widget
    ipadx=amount - add internal padding in x direction
    ipady=amount - add internal padding in y direction
    padx=amount - add padding in x direction
    pady=amount - add padding in y direction
    side=TOP or BOTTOM or LEFT or RIGHT -  where to add this widget.
    """
    self.tk.call(
          ('pack', 'configure', self._w)
          + self._options(cnf, kw))
		  
pack = configure = config = pack_configure
</t>
<t tx="ekr.20041012114208.325">def pack_forget(self):
    """Unmap this widget and do not use it for the packing order."""
    self.tk.call('pack', 'forget', self._w)

forget = pack_forget</t>
<t tx="ekr.20041012114208.326">def pack_info(self):
    """Return information about the packing options
    for this widget."""
    words = self.tk.splitlist(
        self.tk.call('pack', 'info', self._w))
    dict = {}
    for i in range(0, len(words), 2):
        key = words[i][1:]
        value = words[i+1]
        if value[:1] == '.':
            value = self._nametowidget(value)
        dict[key] = value
    return dict
</t>
<t tx="ekr.20041012114208.327">class Place:

	"""Geometry manager Place.
	Base class to use the methods place_* in every widget."""

	@others
</t>
<t tx="ekr.20041012114208.328">def place_configure(self, cnf={}, **kw):
    """Place a widget in the parent widget. Use as options:
    in=master - master relative to which the widget is placed.
    x=amount - locate anchor of this widget at position x of master
    y=amount - locate anchor of this widget at position y of master
    relx=amount - locate anchor of this widget between 0.0 and 1.0
                  relative to width of master (1.0 is right edge)
        rely=amount - locate anchor of this widget between 0.0 and 1.0
                  relative to height of master (1.0 is bottom edge)
        anchor=NSEW (or subset) - position anchor according to given direction
    width=amount - width of this widget in pixel
    height=amount - height of this widget in pixel
    relwidth=amount - width of this widget between 0.0 and 1.0
                      relative to width of master (1.0 is the same width
              as the master)
        relheight=amount - height of this widget between 0.0 and 1.0
                       relative to height of master (1.0 is the same
               height as the master)
        bordermode="inside" or "outside" - whether to take border width of master widget
                                           into account
        """
    for k in ['in_']:
        if kw.has_key(k):
            kw[k[:-1]] = kw[k]
            del kw[k]
    self.tk.call(
          ('place', 'configure', self._w)
          + self._options(cnf, kw))
		  
place = configure = config = place_configure
</t>
<t tx="ekr.20041012114208.329">def place_forget(self):

    """Unmap this widget."""
	
    self.tk.call('place', 'forget', self._w)

forget = place_forget</t>
<t tx="ekr.20041012114208.330">def place_info(self):

    """Return information about the placing options
    for this widget."""

    words = self.tk.splitlist(
        self.tk.call('place', 'info', self._w))
    dict = {}
    for i in range(0, len(words), 2):
        key = words[i][1:]
        value = words[i+1]
        if value[:1] == '.':
            value = self._nametowidget(value)
        dict[key] = value
    return dict
</t>
<t tx="ekr.20041012114208.331"># Thanks to Masazumi Yoshikawa (yosikawa@isi.edu)

class Grid:

	"""Geometry manager Grid.
	Base class to use the methods grid_* in every widget."""

	@others
</t>
<t tx="ekr.20041012114208.332">def grid_configure(self, cnf={}, **kw):
    """Position a widget in the parent widget in a grid. Use as options:
    column=number - use cell identified with given column (starting with 0)
    columnspan=number - this widget will span several columns
    in=master - use master to contain this widget
    ipadx=amount - add internal padding in x direction
    ipady=amount - add internal padding in y direction
    padx=amount - add padding in x direction
    pady=amount - add padding in y direction
    row=number - use cell identified with given row (starting with 0)
    rowspan=number - this widget will span several rows
    sticky=NSEW - if cell is larger on which sides will this
                  widget stick to the cell boundary
    """
    self.tk.call(
          ('grid', 'configure', self._w)
          + self._options(cnf, kw))
		  
grid = configure = config = grid_configure
bbox = grid_bbox = Misc.grid_bbox
columnconfigure = grid_columnconfigure = Misc.grid_columnconfigure
</t>
<t tx="ekr.20041012114208.333">def grid_forget(self):

    """Unmap this widget."""

    self.tk.call('grid', 'forget', self._w)
	
forget = grid_forget
</t>
<t tx="ekr.20041012114208.334">def grid_remove(self):

    """Unmap this widget but remember the grid options."""

    self.tk.call('grid', 'remove', self._w)
</t>
<t tx="ekr.20041012114208.335">def grid_info(self):

    """Return information about the options
    for positioning this widget in a grid."""

    words = self.tk.splitlist(
        self.tk.call('grid', 'info', self._w))
    dict = {}
    for i in range(0, len(words), 2):
        key = words[i][1:]
        value = words[i+1]
        if value[:1] == '.':
            value = self._nametowidget(value)
        dict[key] = value
    return dict
	
info = grid_info
</t>
<t tx="ekr.20041012114208.336">def grid_location(self, x, y):

    """Return a tuple of column and row which identify the cell
    at which the pixel at position X and Y inside the master
    widget is located."""

    return self._getints(
        self.tk.call(
            'grid', 'location', self._w, x, y)) or None

location = grid_location
propagate = grid_propagate = Misc.grid_propagate
rowconfigure = grid_rowconfigure = Misc.grid_rowconfigure
size = grid_size = Misc.grid_size
slaves = grid_slaves = Misc.grid_slaves</t>
<t tx="ekr.20041012114208.337">class Widget(BaseWidget, Pack, Place, Grid):
	"""Internal class.

	Base class for a widget which can be positioned with the geometry managers
	Pack, Place or Grid."""
	pass</t>
<t tx="ekr.20041012114208.338">class BaseWidget(Misc):

	"""Internal class."""

	@others</t>
<t tx="ekr.20041012114208.339">def _setup(self, master, cnf):
    """Internal function. Sets up information about children."""
    if _support_default_root:
        global _default_root
        if not master:
            if not _default_root:
                _default_root = Tk()
            master = _default_root
    self.master = master
    self.tk = master.tk
    name = None
    if cnf.has_key('name'):
        name = cnf['name']
        del cnf['name']
    if not name:
        name = `id(self)`
    self._name = name
    if master._w=='.':
        self._w = '.' + name
    else:
        self._w = master._w + '.' + name
    self.children = {}
    if self.master.children.has_key(self._name):
        self.master.children[self._name].destroy()
    self.master.children[self._name] = self
</t>
<t tx="ekr.20041012114208.340">def __init__(self, master, widgetName, cnf={}, kw={}, extra=()):

    """Construct a widget with the parent widget MASTER, a name WIDGETNAME
    and appropriate options."""

    if kw:
        cnf = _cnfmerge((cnf, kw))
    self.widgetName = widgetName
    BaseWidget._setup(self, master, cnf)
    classes = []
    for k in cnf.keys():
        if type(k) is ClassType:
            classes.append((k, cnf[k]))
            del cnf[k]
    self.tk.call(
        (widgetName, self._w) + extra + self._options(cnf))
    for k, v in classes:
        k.configure(self, v)
</t>
<t tx="ekr.20041012114208.341">def destroy(self):

    """Destroy this and all descendants widgets."""
	
    for c in self.children.values(): c.destroy()
    if self.master.children.has_key(self._name):
        del self.master.children[self._name]
    self.tk.call('destroy', self._w)
    Misc.destroy(self)
</t>
<t tx="ekr.20041012114208.342">def _do(self, name, args=()):

    # XXX Obsolete -- better use self.tk.call directly!
    return self.tk.call((self._w, name) + args)
</t>
<t tx="ekr.20041012114208.343">class Toplevel(BaseWidget, Wm):

	"""Toplevel widget, e.g. for dialogs."""

	@others

</t>
<t tx="ekr.20041012114208.344">def __init__(self, master=None, cnf={}, **kw):
    """Construct a toplevel widget with the parent MASTER.

    Valid resource names: background, bd, bg, borderwidth, class,
    colormap, container, cursor, height, highlightbackground,
    highlightcolor, highlightthickness, menu, relief, screen, takefocus,
    use, visual, width."""
    if kw:
        cnf = _cnfmerge((cnf, kw))
    extra = ()
    for wmkey in ['screen', 'class_', 'class', 'visual',
              'colormap']:
        if cnf.has_key(wmkey):
            val = cnf[wmkey]
            # TBD: a hack needed because some keys
            # are not valid as keyword arguments
            if wmkey[-1] == '_': opt = '-'+wmkey[:-1]
            else: opt = '-'+wmkey
            extra = extra + (opt, val)
            del cnf[wmkey]
    BaseWidget.__init__(self, master, 'toplevel', cnf, {}, extra)
    root = self._root()
    self.iconname(root.iconname())
    self.title(root.title())
    self.protocol("WM_DELETE_WINDOW", self.destroy)
</t>
<t tx="ekr.20041012114208.345">class Button(Widget):

	"""Button widget."""

	@others

</t>
<t tx="ekr.20041012114208.346">def __init__(self, master=None, cnf={}, **kw):

    """Construct a button widget with the parent MASTER.

    Valid resource names: activebackground, activeforeground, anchor,
    background, bd, bg, bitmap, borderwidth, command, cursor, default,
    disabledforeground, fg, font, foreground, height,
    highlightbackground, highlightcolor, highlightthickness, image,
    justify, padx, pady, relief, state, takefocus, text, textvariable,
    underline, width, wraplength."""

    Widget.__init__(self, master, 'button', cnf, kw)
</t>
<t tx="ekr.20041012114208.347">def tkButtonEnter(self, *dummy):

    self.tk.call('tkButtonEnter', self._w)
</t>
<t tx="ekr.20041012114208.348">def tkButtonLeave(self, *dummy):

    self.tk.call('tkButtonLeave', self._w)
</t>
<t tx="ekr.20041012114208.349">def tkButtonDown(self, *dummy):

    self.tk.call('tkButtonDown', self._w)
</t>
<t tx="ekr.20041012114208.350">def tkButtonUp(self, *dummy):

    self.tk.call('tkButtonUp', self._w)
</t>
<t tx="ekr.20041012114208.351">def tkButtonInvoke(self, *dummy):

    self.tk.call('tkButtonInvoke', self._w)
</t>
<t tx="ekr.20041012114208.352">def flash(self):

    self.tk.call(self._w, 'flash')
</t>
<t tx="ekr.20041012114208.353">def invoke(self):

    return self.tk.call(self._w, 'invoke')
</t>
<t tx="ekr.20041012114208.354">class Canvas(Widget):

	"""Canvas widget to display graphical elements like lines or text."""
	
	@others
</t>
<t tx="ekr.20041012114208.355">def __init__(self, master=None, cnf={}, **kw):

    """Construct a canvas widget with the parent MASTER.

    Valid resource names: background, bd, bg, borderwidth, closeenough,
    confine, cursor, height, highlightbackground, highlightcolor,
    highlightthickness, insertbackground, insertborderwidth,
    insertofftime, insertontime, insertwidth, offset, relief,
    scrollregion, selectbackground, selectborderwidth, selectforeground,
    state, takefocus, width, xscrollcommand, xscrollincrement,
    yscrollcommand, yscrollincrement."""

    Widget.__init__(self, master, 'canvas', cnf, kw)
</t>
<t tx="ekr.20041012114208.356"></t>
<t tx="ekr.20041012114208.357">def addtag(self, *args):

    """Internal function."""
    self.tk.call((self._w, 'addtag') + args)
</t>
<t tx="ekr.20041012114208.358">def addtag_above(self, newtag, tagOrId):

    """Add tag NEWTAG to all items above TAGORID."""
    self.addtag(newtag, 'above', tagOrId)
</t>
<t tx="ekr.20041012114208.359">def addtag_all(self, newtag):
    """Add tag NEWTAG to all items."""
    self.addtag(newtag, 'all')
</t>
<t tx="ekr.20041012114208.360">def addtag_below(self, newtag, tagOrId):
    """Add tag NEWTAG to all items below TAGORID."""
    self.addtag(newtag, 'below', tagOrId)
</t>
<t tx="ekr.20041012114208.361">def addtag_closest(self, newtag, x, y, halo=None, start=None):

    """Add tag NEWTAG to item which is closest to pixel at X, Y.
    If several match take the top-most.
    All items closer than HALO are considered overlapping (all are
    closests). If START is specified the next below this tag is taken."""

    self.addtag(newtag, 'closest', x, y, halo, start)
</t>
<t tx="ekr.20041012114208.362">def addtag_enclosed(self, newtag, x1, y1, x2, y2):
    """Add tag NEWTAG to all items in the rectangle defined
    by X1,Y1,X2,Y2."""
    self.addtag(newtag, 'enclosed', x1, y1, x2, y2)
</t>
<t tx="ekr.20041012114208.363">def addtag_overlapping(self, newtag, x1, y1, x2, y2):
    """Add tag NEWTAG to all items which overlap the rectangle
    defined by X1,Y1,X2,Y2."""
    self.addtag(newtag, 'overlapping', x1, y1, x2, y2)
</t>
<t tx="ekr.20041012114208.364">def addtag_withtag(self, newtag, tagOrId):
    """Add tag NEWTAG to all items with TAGORID."""
    self.addtag(newtag, 'withtag', tagOrId)
</t>
<t tx="ekr.20041012114208.365">&lt;&lt; class Canvas methods &gt;&gt;=

def bbox(self, *args):
    """Return a tuple of X1,Y1,X2,Y2 coordinates for a rectangle
    which encloses all items with tags specified as arguments."""
    return self._getints(
        self.tk.call((self._w, 'bbox') + args)) or None
</t>
<t tx="ekr.20041012114208.366">&lt;&lt; class Canvas methods &gt;&gt;=

def tag_unbind(self, tagOrId, sequence, funcid=None):
    """Unbind for all items with TAGORID for event SEQUENCE  the
    function identified with FUNCID."""
    self.tk.call(self._w, 'bind', tagOrId, sequence, '')
    if funcid:
        self.deletecommand(funcid)
</t>
<t tx="ekr.20041012114208.367">&lt;&lt; class Canvas methods &gt;&gt;=

def tag_bind(self, tagOrId, sequence=None, func=None, add=None):
    """Bind to all items with TAGORID at event SEQUENCE a call to function FUNC.

    An additional boolean parameter ADD specifies whether FUNC will be
    called additionally to the other bound function or whether it will
    replace the previous function. See bind for the return value."""
    return self._bind((self._w, 'bind', tagOrId),
              sequence, func, add)
</t>
<t tx="ekr.20041012114208.368">&lt;&lt; class Canvas methods &gt;&gt;=

def canvasx(self, screenx, gridspacing=None):
    """Return the canvas x coordinate of pixel position SCREENX rounded
    to nearest multiple of GRIDSPACING units."""
    return getdouble(self.tk.call(
        self._w, 'canvasx', screenx, gridspacing))
</t>
<t tx="ekr.20041012114208.369">&lt;&lt; class Canvas methods &gt;&gt;=

def canvasy(self, screeny, gridspacing=None):
    """Return the canvas y coordinate of pixel position SCREENY rounded
    to nearest multiple of GRIDSPACING units."""
    return getdouble(self.tk.call(
        self._w, 'canvasy', screeny, gridspacing))
</t>
<t tx="ekr.20041012114208.370">&lt;&lt; class Canvas methods &gt;&gt;=

def coords(self, *args):
    """Return a list of coordinates for the item given in ARGS."""
    # XXX Should use _flatten on args
    return map(getdouble,
                       self.tk.splitlist(
               self.tk.call((self._w, 'coords') + args)))
</t>
<t tx="ekr.20041012114208.371"></t>
<t tx="ekr.20041012114208.372">&lt;&lt; class Canvas methods &gt;&gt;=

def _create(self, itemType, args, kw): # Args: (val, val, ..., cnf={})
    """Internal function."""
    args = _flatten(args)
    cnf = args[-1]
    if type(cnf) in (DictionaryType, TupleType):
        args = args[:-1]
    else:
        cnf = {}
    return getint(apply(
        self.tk.call,
        (self._w, 'create', itemType)
        + args + self._options(cnf, kw)))
</t>
<t tx="ekr.20041012114208.373">&lt;&lt; class Canvas methods &gt;&gt;=

def create_arc(self, *args, **kw):
    """Create arc shaped region with coordinates x1,y1,x2,y2."""
    return self._create('arc', args, kw)
</t>
<t tx="ekr.20041012114208.374">&lt;&lt; class Canvas methods &gt;&gt;=

def create_bitmap(self, *args, **kw):
    """Create bitmap with coordinates x1,y1."""
    return self._create('bitmap', args, kw)
</t>
<t tx="ekr.20041012114208.375">&lt;&lt; class Canvas methods &gt;&gt;=

def create_image(self, *args, **kw):
    """Create image item with coordinates x1,y1."""
    return self._create('image', args, kw)
</t>
<t tx="ekr.20041012114208.376">&lt;&lt; class Canvas methods &gt;&gt;=

def create_line(self, *args, **kw):
    """Create line with coordinates x1,y1,...,xn,yn."""
    return self._create('line', args, kw)
</t>
<t tx="ekr.20041012114208.377">&lt;&lt; class Canvas methods &gt;&gt;=

def create_oval(self, *args, **kw):
    """Create oval with coordinates x1,y1,x2,y2."""
    return self._create('oval', args, kw)
</t>
<t tx="ekr.20041012114208.378">&lt;&lt; class Canvas methods &gt;&gt;=

def create_polygon(self, *args, **kw):
    """Create polygon with coordinates x1,y1,...,xn,yn."""
    return self._create('polygon', args, kw)
</t>
<t tx="ekr.20041012114208.379">&lt;&lt; class Canvas methods &gt;&gt;=

def create_rectangle(self, *args, **kw):
    """Create rectangle with coordinates x1,y1,x2,y2."""
    return self._create('rectangle', args, kw)
</t>
<t tx="ekr.20041012114208.380">&lt;&lt; class Canvas methods &gt;&gt;=

def create_text(self, *args, **kw):
    """Create text with coordinates x1,y1."""
    return self._create('text', args, kw)
</t>
<t tx="ekr.20041012114208.381">&lt;&lt; class Canvas methods &gt;&gt;=

def create_window(self, *args, **kw):
    """Create window with coordinates x1,y1,x2,y2."""
    return self._create('window', args, kw)
</t>
<t tx="ekr.20041012114208.382">&lt;&lt; class Canvas methods &gt;&gt;=

def dchars(self, *args):
    """Delete characters of text items identified by tag or id in ARGS (possibly
    several times) from FIRST to LAST character (including)."""
    self.tk.call((self._w, 'dchars') + args)
</t>
<t tx="ekr.20041012114208.383">&lt;&lt; class Canvas methods &gt;&gt;=

def delete(self, *args):
    """Delete items identified by all tag or ids contained in ARGS."""
    self.tk.call((self._w, 'delete') + args)
</t>
<t tx="ekr.20041012114208.384">&lt;&lt; class Canvas methods &gt;&gt;=

def dtag(self, *args):
    """Delete tag or id given as last arguments in ARGS from items
    identified by first argument in ARGS."""
    self.tk.call((self._w, 'dtag') + args)
</t>
<t tx="ekr.20041012114208.385"></t>
<t tx="ekr.20041012114208.386">&lt;&lt; class Canvas methods &gt;&gt;=

def find(self, *args):
    """Internal function."""
    return self._getints(
        self.tk.call((self._w, 'find') + args)) or ()
</t>
<t tx="ekr.20041012114208.387">&lt;&lt; class Canvas methods &gt;&gt;=

def find_above(self, tagOrId):
    """Return items above TAGORID."""
    return self.find('above', tagOrId)
</t>
<t tx="ekr.20041012114208.388">&lt;&lt; class Canvas methods &gt;&gt;=

def find_all(self):
    """Return all items."""
    return self.find('all')
</t>
<t tx="ekr.20041012114208.389">&lt;&lt; class Canvas methods &gt;&gt;=

def find_below(self, tagOrId):
    """Return all items below TAGORID."""
    return self.find('below', tagOrId)
</t>
<t tx="ekr.20041012114208.390">&lt;&lt; class Canvas methods &gt;&gt;=

def find_closest(self, x, y, halo=None, start=None):
    """Return item which is closest to pixel at X, Y.
    If several match take the top-most.
    All items closer than HALO are considered overlapping (all are
    closests). If START is specified the next below this tag is taken."""
    return self.find('closest', x, y, halo, start)
</t>
<t tx="ekr.20041012114208.391">&lt;&lt; class Canvas methods &gt;&gt;=

def find_enclosed(self, x1, y1, x2, y2):
    """Return all items in rectangle defined
    by X1,Y1,X2,Y2."""
    return self.find('enclosed', x1, y1, x2, y2)
</t>
<t tx="ekr.20041012114208.392">&lt;&lt; class Canvas methods &gt;&gt;=

def find_overlapping(self, x1, y1, x2, y2):
    """Return all items which overlap the rectangle
    defined by X1,Y1,X2,Y2."""
    return self.find('overlapping', x1, y1, x2, y2)
</t>
<t tx="ekr.20041012114208.393">&lt;&lt; class Canvas methods &gt;&gt;=

def find_withtag(self, tagOrId):
    """Return all items with TAGORID."""
    return self.find('withtag', tagOrId)
</t>
<t tx="ekr.20041012114208.394">&lt;&lt; class Canvas methods &gt;&gt;=

def focus(self, *args):
    """Set focus to the first item specified in ARGS."""
    return self.tk.call((self._w, 'focus') + args)
</t>
<t tx="ekr.20041012114208.395">&lt;&lt; class Canvas methods &gt;&gt;=

def gettags(self, *args):
    """Return tags associated with the first item specified in ARGS."""
    return self.tk.splitlist(
        self.tk.call((self._w, 'gettags') + args))
</t>
<t tx="ekr.20041012114208.396">&lt;&lt; class Canvas methods &gt;&gt;=

def icursor(self, *args):
    """Set cursor at position POS in the item identified by TAGORID.
    In ARGS TAGORID must be first."""
    self.tk.call((self._w, 'icursor') + args)
</t>
<t tx="ekr.20041012114208.397">def index(self, *args):
    """Return position of cursor as integer in item specified in ARGS."""
    return getint(self.tk.call((self._w, 'index') + args))
</t>
<t tx="ekr.20041012114208.398">&lt;&lt; class Canvas methods &gt;&gt;=

def insert(self, *args):
    """Insert TEXT in item TAGORID at position POS. ARGS must
    be TAGORID POS TEXT."""
    self.tk.call((self._w, 'insert') + args)
</t>
<t tx="ekr.20041012114208.399">&lt;&lt; class Canvas methods &gt;&gt;=

def itemcget(self, tagOrId, option):
    """Return the resource value for an OPTION for item TAGORID."""
    return self.tk.call(
        (self._w, 'itemcget') + (tagOrId, '-'+option))
</t>
<t tx="ekr.20041012114208.400">def itemconfigure(self, tagOrId, cnf=None, **kw):
    """Configure resources of an item TAGORID.

    The values for resources are specified as keyword
    arguments. To get an overview about
    the allowed keyword arguments call the method without arguments.
    """
    if cnf is None and not kw:
        cnf = {}
        for x in self.tk.split(
            self.tk.call(self._w,
                     'itemconfigure', tagOrId)):
            cnf[x[0][1:]] = (x[0][1:],) + x[1:]
        return cnf
    if type(cnf) == StringType and not kw:
        x = self.tk.split(self.tk.call(
            self._w, 'itemconfigure', tagOrId, '-'+cnf))
        return (x[0][1:],) + x[1:]
    self.tk.call((self._w, 'itemconfigure', tagOrId) +
             self._options(cnf, kw))
			 
itemconfig = itemconfigure
</t>
<t tx="ekr.20041012114208.401">
# lower, tkraise/lift hide Misc.lower, Misc.tkraise/lift,
# so the preferred name for them is tag_lower, tag_raise
# (similar to tag_bind, and similar to the Text widget);
# unfortunately can't delete the old ones yet (maybe in 1.6)
def tag_lower(self, *args):
    """Lower an item TAGORID given in ARGS
    (optional below another item)."""
    self.tk.call((self._w, 'lower') + args)
</t>
<t tx="ekr.20041012114208.402">&lt;&lt; class Canvas methods &gt;&gt;=

lower = tag_lower
def move(self, *args):
    """Move an item TAGORID given in ARGS."""
    self.tk.call((self._w, 'move') + args)
</t>
<t tx="ekr.20041012114208.403">&lt;&lt; class Canvas methods &gt;&gt;=

def postscript(self, cnf={}, **kw):
    """Print the contents of the canvas to a postscript
    file. Valid options: colormap, colormode, file, fontmap,
    height, pageanchor, pageheight, pagewidth, pagex, pagey,
    rotate, witdh, x, y."""
    return self.tk.call((self._w, 'postscript') +
                self._options(cnf, kw))
</t>
<t tx="ekr.20041012114208.404">&lt;&lt; class Canvas methods &gt;&gt;=

def tag_raise(self, *args):
    """Raise an item TAGORID given in ARGS
    (optional above another item)."""
    self.tk.call((self._w, 'raise') + args)
</t>
<t tx="ekr.20041012114208.405">&lt;&lt; class Canvas methods &gt;&gt;=

lift = tkraise = tag_raise
def scale(self, *args):
    """Scale item TAGORID with XORIGIN, YORIGIN, XSCALE, YSCALE."""
    self.tk.call((self._w, 'scale') + args)
</t>
<t tx="ekr.20041012114208.406"></t>
<t tx="ekr.20041012114208.407">&lt;&lt; class Canvas methods &gt;&gt;=

def scan_mark(self, x, y):
    """Remember the current X, Y coordinates."""
    self.tk.call(self._w, 'scan', 'mark', x, y)
</t>
<t tx="ekr.20041012114208.408">&lt;&lt; class Canvas methods &gt;&gt;=

def scan_dragto(self, x, y):
    """Adjust the view of the canvas to 10 times the
    difference between X and Y and the coordinates given in
    scan_mark."""
    self.tk.call(self._w, 'scan', 'dragto', x, y)
</t>
<t tx="ekr.20041012114208.409"></t>
<t tx="ekr.20041012114208.410">&lt;&lt; class Canvas methods &gt;&gt;=

def select_adjust(self, tagOrId, index):
    """Adjust the end of the selection near the cursor of an item TAGORID to index."""
    self.tk.call(self._w, 'select', 'adjust', tagOrId, index)
</t>
<t tx="ekr.20041012114208.411">&lt;&lt; class Canvas methods &gt;&gt;=

def select_clear(self):
    """Clear the selection if it is in this widget."""
    self.tk.call(self._w, 'select', 'clear')
</t>
<t tx="ekr.20041012114208.412">&lt;&lt; class Canvas methods &gt;&gt;=

def select_from(self, tagOrId, index):
    """Set the fixed end of a selection in item TAGORID to INDEX."""
    self.tk.call(self._w, 'select', 'from', tagOrId, index)
</t>
<t tx="ekr.20041012114208.413">&lt;&lt; class Canvas methods &gt;&gt;=

def select_item(self):
    """Return the item which has the selection."""
    self.tk.call(self._w, 'select', 'item')
</t>
<t tx="ekr.20041012114208.414">&lt;&lt; class Canvas methods &gt;&gt;=

def select_to(self, tagOrId, index):
    """Set the variable end of a selection in item TAGORID to INDEX."""
    self.tk.call(self._w, 'select', 'to', tagOrId, index)
</t>
<t tx="ekr.20041012114208.415">def type(self, tagOrId):

    """Return the type of the item TAGORID."""

    return self.tk.call(self._w, 'type', tagOrId) or None
</t>
<t tx="ekr.20041012114208.416"></t>
<t tx="ekr.20041012114208.417">&lt;&lt; class Canvas methods &gt;&gt;=

def xview(self, *args):
    """Query and change horizontal position of the view."""
    if not args:
        return self._getdoubles(self.tk.call(self._w, 'xview'))
    self.tk.call((self._w, 'xview') + args)
</t>
<t tx="ekr.20041012114208.418">&lt;&lt; class Canvas methods &gt;&gt;=

def xview_moveto(self, fraction):
    """Adjusts the view in the window so that FRACTION of the
    total width of the canvas is off-screen to the left."""
    self.tk.call(self._w, 'xview', 'moveto', fraction)
</t>
<t tx="ekr.20041012114208.419">&lt;&lt; class Canvas methods &gt;&gt;=

def xview_scroll(self, number, what):
    """Shift the x-view according to NUMBER which is measured in "units" or "pages" (WHAT)."""
    self.tk.call(self._w, 'xview', 'scroll', number, what)
</t>
<t tx="ekr.20041012114208.420">&lt;&lt; class Canvas methods &gt;&gt;=

def yview(self, *args):
    """Query and change vertical position of the view."""
    if not args:
        return self._getdoubles(self.tk.call(self._w, 'yview'))
    self.tk.call((self._w, 'yview') + args)
</t>
<t tx="ekr.20041012114208.421">&lt;&lt; class Canvas methods &gt;&gt;=

def yview_moveto(self, fraction):
    """Adjusts the view in the window so that FRACTION of the
    total height of the canvas is off-screen to the top."""
    self.tk.call(self._w, 'yview', 'moveto', fraction)
</t>
<t tx="ekr.20041012114208.422">&lt;&lt; class Canvas methods &gt;&gt;=

def yview_scroll(self, number, what):
    """Shift the y-view according to NUMBER which is measured in "units" or "pages" (WHAT)."""
    self.tk.call(self._w, 'yview', 'scroll', number, what)
</t>
<t tx="ekr.20041012114208.423">class Checkbutton(Widget):

	"""Checkbutton widget which is either in on- or off-state."""

	@others</t>
<t tx="ekr.20041012114208.424">def __init__(self, master=None, cnf={}, **kw):

    """Construct a checkbutton widget with the parent MASTER.

    Valid resource names: activebackground, activeforeground, anchor,
    background, bd, bg, bitmap, borderwidth, command, cursor,
    disabledforeground, fg, font, foreground, height,
    highlightbackground, highlightcolor, highlightthickness, image,
    indicatoron, justify, offvalue, onvalue, padx, pady, relief,
    selectcolor, selectimage, state, takefocus, text, textvariable,
    underline, variable, width, wraplength."""
	
    Widget.__init__(self, master, 'checkbutton', cnf, kw)
</t>
<t tx="ekr.20041012114208.425">def deselect(self):

    """Put the button in off-state."""
	
    self.tk.call(self._w, 'deselect')
</t>
<t tx="ekr.20041012114208.426">def flash(self):

    """Flash the button."""
	
    self.tk.call(self._w, 'flash')
</t>
<t tx="ekr.20041012114208.427">def invoke(self):

    """Toggle the button and invoke a command if given as resource."""
	
    return self.tk.call(self._w, 'invoke')
</t>
<t tx="ekr.20041012114208.428">def select(self):

    """Put the button in on-state."""
	
    self.tk.call(self._w, 'select')
</t>
<t tx="ekr.20041012114208.429">def toggle(self):

    """Toggle the button."""
	
    self.tk.call(self._w, 'toggle')
</t>
<t tx="ekr.20041012114208.430">class Entry(Widget):

	"""Entry widget which allows to display simple text."""

	@others</t>
<t tx="ekr.20041012114208.431">&lt;&lt; class Entry methods &gt;&gt;=

def __init__(self, master=None, cnf={}, **kw):
    """Construct an entry widget with the parent MASTER.

    Valid resource names: background, bd, bg, borderwidth, cursor,
    exportselection, fg, font, foreground, highlightbackground,
    highlightcolor, highlightthickness, insertbackground,
    insertborderwidth, insertofftime, insertontime, insertwidth,
    invalidcommand, invcmd, justify, relief, selectbackground,
    selectborderwidth, selectforeground, show, state, takefocus,
    textvariable, validate, validatecommand, vcmd, width,
    xscrollcommand."""
    Widget.__init__(self, master, 'entry', cnf, kw)
</t>
<t tx="ekr.20041012114208.432">&lt;&lt; class Entry methods &gt;&gt;=

def delete(self, first, last=None):
    """Delete text from FIRST to LAST (not included)."""
    self.tk.call(self._w, 'delete', first, last)
</t>
<t tx="ekr.20041012114208.433">&lt;&lt; class Entry methods &gt;&gt;=

def get(self):
    """Return the text."""
    return self.tk.call(self._w, 'get')
</t>
<t tx="ekr.20041012114208.434">&lt;&lt; class Entry methods &gt;&gt;=

def icursor(self, index):
    """Insert cursor at INDEX."""
    self.tk.call(self._w, 'icursor', index)
</t>
<t tx="ekr.20041012114208.435">&lt;&lt; class Entry methods &gt;&gt;=

def index(self, index):
    """Return position of cursor."""
    return getint(self.tk.call(
        self._w, 'index', index))
</t>
<t tx="ekr.20041012114208.436">&lt;&lt; class Entry methods &gt;&gt;=

def insert(self, index, string):
    """Insert STRING at INDEX."""
    self.tk.call(self._w, 'insert', index, string)
</t>
<t tx="ekr.20041012114208.437">&lt;&lt; class Entry methods &gt;&gt;=

def scan_mark(self, x):
    """Remember the current X, Y coordinates."""
    self.tk.call(self._w, 'scan', 'mark', x)
</t>
<t tx="ekr.20041012114208.438">&lt;&lt; class Entry methods &gt;&gt;=

def scan_dragto(self, x):
    """Adjust the view of the canvas to 10 times the
    difference between X and Y and the coordinates given in
    scan_mark."""
    self.tk.call(self._w, 'scan', 'dragto', x)
</t>
<t tx="ekr.20041012114208.439">&lt;&lt; class Entry methods &gt;&gt;=

def selection_adjust(self, index):
    """Adjust the end of the selection near the cursor to INDEX."""
    self.tk.call(self._w, 'selection', 'adjust', index)
</t>
<t tx="ekr.20041012114208.440">&lt;&lt; class Entry methods &gt;&gt;=

select_adjust = selection_adjust
def selection_clear(self):
    """Clear the selection if it is in this widget."""
    self.tk.call(self._w, 'selection', 'clear')
</t>
<t tx="ekr.20041012114208.441">&lt;&lt; class Entry methods &gt;&gt;=

select_clear = selection_clear
def selection_from(self, index):
    """Set the fixed end of a selection to INDEX."""
    self.tk.call(self._w, 'selection', 'from', index)
</t>
<t tx="ekr.20041012114208.442">&lt;&lt; class Entry methods &gt;&gt;=

select_from = selection_from
def selection_present(self):
    """Return whether the widget has the selection."""
    return self.tk.getboolean(
        self.tk.call(self._w, 'selection', 'present'))
</t>
<t tx="ekr.20041012114208.443">&lt;&lt; class Entry methods &gt;&gt;=

select_present = selection_present
def selection_range(self, start, end):
    """Set the selection from START to END (not included)."""
    self.tk.call(self._w, 'selection', 'range', start, end)
</t>
<t tx="ekr.20041012114208.444">&lt;&lt; class Entry methods &gt;&gt;=

select_range = selection_range
def selection_to(self, index):
    """Set the variable end of a selection to INDEX."""
    self.tk.call(self._w, 'selection', 'to', index)
</t>
<t tx="ekr.20041012114208.445">&lt;&lt; class Entry methods &gt;&gt;=

select_to = selection_to
def xview(self, index):
    """Query and change horizontal position of the view."""
    self.tk.call(self._w, 'xview', index)
</t>
<t tx="ekr.20041012114208.446">&lt;&lt; class Entry methods &gt;&gt;=

def xview_moveto(self, fraction):
    """Adjust the view in the window so that FRACTION of the
    total width of the entry is off-screen to the left."""
    self.tk.call(self._w, 'xview', 'moveto', fraction)
</t>
<t tx="ekr.20041012114208.447">&lt;&lt; class Entry methods &gt;&gt;=

def xview_scroll(self, number, what):
    """Shift the x-view according to NUMBER which is measured in "units" or "pages" (WHAT)."""
    self.tk.call(self._w, 'xview', 'scroll', number, what)
</t>
<t tx="ekr.20041012114208.448">class Frame(Widget):
	
	"""Frame widget which may contain other widgets and can have a 3D border."""

	@others</t>
<t tx="ekr.20041012114208.449">&lt;&lt; class Frame methods &gt;&gt;=

def __init__(self, master=None, cnf={}, **kw):
    """Construct a frame widget with the parent MASTER.

    Valid resource names: background, bd, bg, borderwidth, class,
    colormap, container, cursor, height, highlightbackground,
    highlightcolor, highlightthickness, relief, takefocus, visual, width."""
    cnf = _cnfmerge((cnf, kw))
    extra = ()
    if cnf.has_key('class_'):
        extra = ('-class', cnf['class_'])
        del cnf['class_']
    elif cnf.has_key('class'):
        extra = ('-class', cnf['class'])
        del cnf['class']
    Widget.__init__(self, master, 'frame', cnf, {}, extra)
</t>
<t tx="ekr.20041012114208.450">class Label(Widget):
	
	"""Label widget which can display text and bitmaps."""

	@others</t>
<t tx="ekr.20041012114208.451">&lt;&lt; class Label methods &gt;&gt;=

def __init__(self, master=None, cnf={}, **kw):
    """Construct a label widget with the parent MASTER.

    Valid resource names: anchor, background, bd, bg, bitmap,
    borderwidth, cursor, fg, font, foreground, height,
    highlightbackground, highlightcolor, highlightthickness, image,
    justify, padx, pady, relief, takefocus, text, textvariable,
    underline, width, wraplength."""
    Widget.__init__(self, master, 'label', cnf, kw)
</t>
<t tx="ekr.20041012114208.452">class Listbox(Widget):
	
	"""Listbox widget which can display a list of strings."""

	@others</t>
<t tx="ekr.20041012114208.453">&lt;&lt; class Listbox methods &gt;&gt;=

def __init__(self, master=None, cnf={}, **kw):
    """Construct a listbox widget with the parent MASTER.

    Valid resource names: background, bd, bg, borderwidth, cursor,
    exportselection, fg, font, foreground, height, highlightbackground,
    highlightcolor, highlightthickness, relief, selectbackground,
    selectborderwidth, selectforeground, selectmode, setgrid, takefocus,
    width, xscrollcommand, yscrollcommand, listvariable."""
    Widget.__init__(self, master, 'listbox', cnf, kw)
</t>
<t tx="ekr.20041012114208.454">&lt;&lt; class Listbox methods &gt;&gt;=

def activate(self, index):
    """Activate item identified by INDEX."""
    self.tk.call(self._w, 'activate', index)
</t>
<t tx="ekr.20041012114208.455">&lt;&lt; class Listbox methods &gt;&gt;=

def bbox(self, *args):
    """Return a tuple of X1,Y1,X2,Y2 coordinates for a rectangle
    which encloses the item identified by index in ARGS."""
    return self._getints(
        self.tk.call((self._w, 'bbox') + args)) or None
</t>
<t tx="ekr.20041012114208.456">&lt;&lt; class Listbox methods &gt;&gt;=

def curselection(self):
    """Return list of indices of currently selected item."""
    # XXX Ought to apply self._getints()...
    return self.tk.splitlist(self.tk.call(
        self._w, 'curselection'))
</t>
<t tx="ekr.20041012114208.457">&lt;&lt; class Listbox methods &gt;&gt;=

def delete(self, first, last=None):
    """Delete items from FIRST to LAST (not included)."""
    self.tk.call(self._w, 'delete', first, last)
</t>
<t tx="ekr.20041012114208.458">&lt;&lt; class Listbox methods &gt;&gt;=

def get(self, first, last=None):
    """Get list of items from FIRST to LAST (not included)."""
    if last:
        return self.tk.splitlist(self.tk.call(
            self._w, 'get', first, last))
    else:
        return self.tk.call(self._w, 'get', first)
</t>
<t tx="ekr.20041012114208.459">&lt;&lt; class Listbox methods &gt;&gt;=

def index(self, index):
    """Return index of item identified with INDEX."""
    i = self.tk.call(self._w, 'index', index)
    if i == 'none': return None
    return getint(i)
</t>
<t tx="ekr.20041012114208.460">&lt;&lt; class Listbox methods &gt;&gt;=

def insert(self, index, *elements):
    """Insert ELEMENTS at INDEX."""
    self.tk.call((self._w, 'insert', index) + elements)
</t>
<t tx="ekr.20041012114208.461">&lt;&lt; class Listbox methods &gt;&gt;=

def nearest(self, y):
    """Get index of item which is nearest to y coordinate Y."""
    return getint(self.tk.call(
        self._w, 'nearest', y))
</t>
<t tx="ekr.20041012114208.462">&lt;&lt; class Listbox methods &gt;&gt;=

def scan_mark(self, x, y):
    """Remember the current X, Y coordinates."""
    self.tk.call(self._w, 'scan', 'mark', x, y)
</t>
<t tx="ekr.20041012114208.463">&lt;&lt; class Listbox methods &gt;&gt;=

def scan_dragto(self, x, y):
    """Adjust the view of the listbox to 10 times the
    difference between X and Y and the coordinates given in
    scan_mark."""
    self.tk.call(self._w, 'scan', 'dragto', x, y)
</t>
<t tx="ekr.20041012114208.464">&lt;&lt; class Listbox methods &gt;&gt;=

def see(self, index):
    """Scroll such that INDEX is visible."""
    self.tk.call(self._w, 'see', index)
</t>
<t tx="ekr.20041012114208.465">&lt;&lt; class Listbox methods &gt;&gt;=

def selection_anchor(self, index):
    """Set the fixed end oft the selection to INDEX."""
    self.tk.call(self._w, 'selection', 'anchor', index)
</t>
<t tx="ekr.20041012114208.466">&lt;&lt; class Listbox methods &gt;&gt;=

select_anchor = selection_anchor
def selection_clear(self, first, last=None):
    """Clear the selection from FIRST to LAST (not included)."""
    self.tk.call(self._w,
             'selection', 'clear', first, last)
</t>
<t tx="ekr.20041012114208.467">&lt;&lt; class Listbox methods &gt;&gt;=

select_clear = selection_clear
def selection_includes(self, index):
    """Return 1 if INDEX is part of the selection."""
    return self.tk.getboolean(self.tk.call(
        self._w, 'selection', 'includes', index))
</t>
<t tx="ekr.20041012114208.468">&lt;&lt; class Listbox methods &gt;&gt;=

select_includes = selection_includes
def selection_set(self, first, last=None):
    """Set the selection from FIRST to LAST (not included) without
    changing the currently selected elements."""
    self.tk.call(self._w, 'selection', 'set', first, last)
</t>
<t tx="ekr.20041012114208.469">&lt;&lt; class Listbox methods &gt;&gt;=

select_set = selection_set
def size(self):
    """Return the number of elements in the listbox."""
    return getint(self.tk.call(self._w, 'size'))
</t>
<t tx="ekr.20041012114208.470">&lt;&lt; class Listbox methods &gt;&gt;=

def xview(self, *what):
    """Query and change horizontal position of the view."""
    if not what:
        return self._getdoubles(self.tk.call(self._w, 'xview'))
    self.tk.call((self._w, 'xview') + what)
</t>
<t tx="ekr.20041012114208.471">&lt;&lt; class Listbox methods &gt;&gt;=

def xview_moveto(self, fraction):
    """Adjust the view in the window so that FRACTION of the
    total width of the entry is off-screen to the left."""
    self.tk.call(self._w, 'xview', 'moveto', fraction)
</t>
<t tx="ekr.20041012114208.472">&lt;&lt; class Listbox methods &gt;&gt;=

def xview_scroll(self, number, what):
    """Shift the x-view according to NUMBER which is measured in "units" or "pages" (WHAT)."""
    self.tk.call(self._w, 'xview', 'scroll', number, what)
</t>
<t tx="ekr.20041012114208.473">&lt;&lt; class Listbox methods &gt;&gt;=

def yview(self, *what):
    """Query and change vertical position of the view."""
    if not what:
        return self._getdoubles(self.tk.call(self._w, 'yview'))
    self.tk.call((self._w, 'yview') + what)
</t>
<t tx="ekr.20041012114208.474">&lt;&lt; class Listbox methods &gt;&gt;=

def yview_moveto(self, fraction):
    """Adjust the view in the window so that FRACTION of the
    total width of the entry is off-screen to the top."""
    self.tk.call(self._w, 'yview', 'moveto', fraction)
</t>
<t tx="ekr.20041012114208.475">&lt;&lt; class Listbox methods &gt;&gt;=

def yview_scroll(self, number, what):
    """Shift the y-view according to NUMBER which is measured in "units" or "pages" (WHAT)."""
    self.tk.call(self._w, 'yview', 'scroll', number, what)
</t>
<t tx="ekr.20041012114208.476">class Menu(Widget):
	
	"""Menu widget which allows to display menu bars, pull-down menus and pop-up menus."""

	@others</t>
<t tx="ekr.20041012114208.477">&lt;&lt; class Menu methods &gt;&gt;=

def __init__(self, master=None, cnf={}, **kw):
    """Construct menu widget with the parent MASTER.

    Valid resource names: activebackground, activeborderwidth,
    activeforeground, background, bd, bg, borderwidth, cursor,
    disabledforeground, fg, font, foreground, postcommand, relief,
    selectcolor, takefocus, tearoff, tearoffcommand, title, type."""
    Widget.__init__(self, master, 'menu', cnf, kw)
</t>
<t tx="ekr.20041012114208.478">&lt;&lt; class Menu methods &gt;&gt;=

def tk_bindForTraversal(self):
    pass # obsolete since Tk 4.0
</t>
<t tx="ekr.20041012114208.479">&lt;&lt; class Menu methods &gt;&gt;=

def tk_mbPost(self):
    self.tk.call('tk_mbPost', self._w)
</t>
<t tx="ekr.20041012114208.480">&lt;&lt; class Menu methods &gt;&gt;=

def tk_mbUnpost(self):
    self.tk.call('tk_mbUnpost')
</t>
<t tx="ekr.20041012114208.481">&lt;&lt; class Menu methods &gt;&gt;=

def tk_traverseToMenu(self, char):
    self.tk.call('tk_traverseToMenu', self._w, char)
</t>
<t tx="ekr.20041012114208.482">&lt;&lt; class Menu methods &gt;&gt;=

def tk_traverseWithinMenu(self, char):
    self.tk.call('tk_traverseWithinMenu', self._w, char)
</t>
<t tx="ekr.20041012114208.483">&lt;&lt; class Menu methods &gt;&gt;=

def tk_getMenuButtons(self):
    return self.tk.call('tk_getMenuButtons', self._w)
</t>
<t tx="ekr.20041012114208.484">&lt;&lt; class Menu methods &gt;&gt;=

def tk_nextMenu(self, count):
    self.tk.call('tk_nextMenu', count)
</t>
<t tx="ekr.20041012114208.485">&lt;&lt; class Menu methods &gt;&gt;=

def tk_nextMenuEntry(self, count):
    self.tk.call('tk_nextMenuEntry', count)
</t>
<t tx="ekr.20041012114208.486">&lt;&lt; class Menu methods &gt;&gt;=

def tk_invokeMenu(self):
    self.tk.call('tk_invokeMenu', self._w)
</t>
<t tx="ekr.20041012114208.487">&lt;&lt; class Menu methods &gt;&gt;=

def tk_firstMenu(self):
    self.tk.call('tk_firstMenu', self._w)
</t>
<t tx="ekr.20041012114208.488">&lt;&lt; class Menu methods &gt;&gt;=

def tk_mbButtonDown(self):
    self.tk.call('tk_mbButtonDown', self._w)
</t>
<t tx="ekr.20041012114208.489">&lt;&lt; class Menu methods &gt;&gt;=

def tk_popup(self, x, y, entry=""):
    """Post the menu at position X,Y with entry ENTRY."""
    self.tk.call('tk_popup', self._w, x, y, entry)
</t>
<t tx="ekr.20041012114208.490">&lt;&lt; class Menu methods &gt;&gt;=

def activate(self, index):
    """Activate entry at INDEX."""
    self.tk.call(self._w, 'activate', index)
</t>
<t tx="ekr.20041012114208.491">&lt;&lt; class Menu methods &gt;&gt;=

def add(self, itemType, cnf={}, **kw):
    """Internal function."""
    self.tk.call((self._w, 'add', itemType) +
             self._options(cnf, kw))
</t>
<t tx="ekr.20041012114208.492">&lt;&lt; class Menu methods &gt;&gt;=

def add_cascade(self, cnf={}, **kw):
    """Add hierarchical menu item."""
    self.add('cascade', cnf or kw)
</t>
<t tx="ekr.20041012114208.493">&lt;&lt; class Menu methods &gt;&gt;=

def add_checkbutton(self, cnf={}, **kw):
    """Add checkbutton menu item."""
    self.add('checkbutton', cnf or kw)
</t>
<t tx="ekr.20041012114208.494">&lt;&lt; class Menu methods &gt;&gt;=

def add_command(self, cnf={}, **kw):
    """Add command menu item."""
    self.add('command', cnf or kw)
</t>
<t tx="ekr.20041012114208.495">&lt;&lt; class Menu methods &gt;&gt;=

def add_radiobutton(self, cnf={}, **kw):
    """Addd radio menu item."""
    self.add('radiobutton', cnf or kw)
</t>
<t tx="ekr.20041012114208.496">&lt;&lt; class Menu methods &gt;&gt;=

def add_separator(self, cnf={}, **kw):
    """Add separator."""
    self.add('separator', cnf or kw)
</t>
<t tx="ekr.20041012114208.497">&lt;&lt; class Menu methods &gt;&gt;=

def insert(self, index, itemType, cnf={}, **kw):
    """Internal function."""
    self.tk.call((self._w, 'insert', index, itemType) +
             self._options(cnf, kw))
</t>
<t tx="ekr.20041012114208.498">&lt;&lt; class Menu methods &gt;&gt;=

def insert_cascade(self, index, cnf={}, **kw):
    """Add hierarchical menu item at INDEX."""
    self.insert(index, 'cascade', cnf or kw)
</t>
<t tx="ekr.20041012114208.499">&lt;&lt; class Menu methods &gt;&gt;=

def insert_checkbutton(self, index, cnf={}, **kw):
    """Add checkbutton menu item at INDEX."""
    self.insert(index, 'checkbutton', cnf or kw)
</t>
<t tx="ekr.20041012114208.500">&lt;&lt; class Menu methods &gt;&gt;=

def insert_command(self, index, cnf={}, **kw):
    """Add command menu item at INDEX."""
    self.insert(index, 'command', cnf or kw)
</t>
<t tx="ekr.20041012114208.501">&lt;&lt; class Menu methods &gt;&gt;=

def insert_radiobutton(self, index, cnf={}, **kw):
    """Addd radio menu item at INDEX."""
    self.insert(index, 'radiobutton', cnf or kw)
</t>
<t tx="ekr.20041012114208.502">&lt;&lt; class Menu methods &gt;&gt;=

def insert_separator(self, index, cnf={}, **kw):
    """Add separator at INDEX."""
    self.insert(index, 'separator', cnf or kw)
</t>
<t tx="ekr.20041012114208.503">&lt;&lt; class Menu methods &gt;&gt;=

def delete(self, index1, index2=None):
    """Delete menu items between INDEX1 and INDEX2 (not included)."""
    self.tk.call(self._w, 'delete', index1, index2)
</t>
<t tx="ekr.20041012114208.504">&lt;&lt; class Menu methods &gt;&gt;=

def entrycget(self, index, option):
    """Return the resource value of an menu item for OPTION at INDEX."""
    return self.tk.call(self._w, 'entrycget', index, '-' + option)
</t>
<t tx="ekr.20041012114208.505">&lt;&lt; class Menu methods &gt;&gt;=

def entryconfigure(self, index, cnf=None, **kw):
    """Configure a menu item at INDEX."""
    if cnf is None and not kw:
        cnf = {}
        for x in self.tk.split(self.tk.call(
            (self._w, 'entryconfigure', index))):
            cnf[x[0][1:]] = (x[0][1:],) + x[1:]
        return cnf
    if type(cnf) == StringType and not kw:
        x = self.tk.split(self.tk.call(
            (self._w, 'entryconfigure', index, '-'+cnf)))
        return (x[0][1:],) + x[1:]
    self.tk.call((self._w, 'entryconfigure', index)
          + self._options(cnf, kw))
</t>
<t tx="ekr.20041012114208.506">&lt;&lt; class Menu methods &gt;&gt;=

entryconfig = entryconfigure
def index(self, index):
    """Return the index of a menu item identified by INDEX."""
    i = self.tk.call(self._w, 'index', index)
    if i == 'none': return None
    return getint(i)
</t>
<t tx="ekr.20041012114208.507">&lt;&lt; class Menu methods &gt;&gt;=

def invoke(self, index):
    """Invoke a menu item identified by INDEX and execute
    the associated command."""
    return self.tk.call(self._w, 'invoke', index)
</t>
<t tx="ekr.20041012114208.508">&lt;&lt; class Menu methods &gt;&gt;=

def post(self, x, y):
    """Display a menu at position X,Y."""
    self.tk.call(self._w, 'post', x, y)
</t>
<t tx="ekr.20041012114208.509">&lt;&lt; class Menu methods &gt;&gt;=

def type(self, index):
    """Return the type of the menu item at INDEX."""
    return self.tk.call(self._w, 'type', index)
</t>
<t tx="ekr.20041012114208.510">&lt;&lt; class Menu methods &gt;&gt;=

def unpost(self):
    """Unmap a menu."""
    self.tk.call(self._w, 'unpost')
</t>
<t tx="ekr.20041012114208.511">&lt;&lt; class Menu methods &gt;&gt;=

def yposition(self, index):
    """Return the y-position of the topmost pixel of the menu item at INDEX."""
    return getint(self.tk.call(
        self._w, 'yposition', index))
</t>
<t tx="ekr.20041012114208.512">class Menubutton(Widget):
	
	"""Menubutton widget, obsolete since Tk8.0."""

	@others</t>
<t tx="ekr.20041012114208.513">def __init__(self, master=None, cnf={}, **kw):

    Widget.__init__(self, master, 'menubutton', cnf, kw)
</t>
<t tx="ekr.20041012114208.514">class Message(Widget):
	
	"""Message widget to display multiline text. Obsolete since Label does it too."""

	@others</t>
<t tx="ekr.20041012114208.515">def __init__(self, master=None, cnf={}, **kw):

    Widget.__init__(self, master, 'message', cnf, kw)
</t>
<t tx="ekr.20041012114208.516">class Radiobutton(Widget):
	
	"""Radiobutton widget which shows only one of several buttons in on-state."""

	@others</t>
<t tx="ekr.20041012114208.517">def __init__(self, master=None, cnf={}, **kw):

    """Construct a radiobutton widget with the parent MASTER.

    Valid resource names: activebackground, activeforeground, anchor,
    background, bd, bg, bitmap, borderwidth, command, cursor,
    disabledforeground, fg, font, foreground, height,
    highlightbackground, highlightcolor, highlightthickness, image,
    indicatoron, justify, padx, pady, relief, selectcolor, selectimage,
    state, takefocus, text, textvariable, underline, value, variable,
    width, wraplength."""

    Widget.__init__(self, master, 'radiobutton', cnf, kw)
</t>
<t tx="ekr.20041012114208.518">&lt;&lt; class Radiobutton methods &gt;&gt;=

def deselect(self):
    """Put the button in off-state."""

    self.tk.call(self._w, 'deselect')
</t>
<t tx="ekr.20041012114208.519">&lt;&lt; class Radiobutton methods &gt;&gt;=

def flash(self):
    """Flash the button."""
    self.tk.call(self._w, 'flash')
</t>
<t tx="ekr.20041012114208.520">&lt;&lt; class Radiobutton methods &gt;&gt;=

def invoke(self):
    """Toggle the button and invoke a command if given as resource."""
    return self.tk.call(self._w, 'invoke')
</t>
<t tx="ekr.20041012114208.521">&lt;&lt; class Radiobutton methods &gt;&gt;=

def select(self):
    """Put the button in on-state."""
    self.tk.call(self._w, 'select')
</t>
<t tx="ekr.20041012114208.522">class Scale(Widget):
	
	"""Scale widget which can display a numerical scale."""

	@others</t>
<t tx="ekr.20041012114208.523">def __init__(self, master=None, cnf={}, **kw):

    """Construct a scale widget with the parent MASTER.

    Valid resource names: activebackground, background, bigincrement, bd,
    bg, borderwidth, command, cursor, digits, fg, font, foreground, from,
    highlightbackground, highlightcolor, highlightthickness, label,
    length, orient, relief, repeatdelay, repeatinterval, resolution,
    showvalue, sliderlength, sliderrelief, state, takefocus,
    tickinterval, to, troughcolor, variable, width."""
	
    Widget.__init__(self, master, 'scale', cnf, kw)
</t>
<t tx="ekr.20041012114208.524">&lt;&lt; class Scale methods &gt;&gt;=

def get(self):
    """Get the current value as integer or float."""
    value = self.tk.call(self._w, 'get')
    try:
        return getint(value)
    except ValueError:
        return getdouble(value)
</t>
<t tx="ekr.20041012114208.525">&lt;&lt; class Scale methods &gt;&gt;=

def set(self, value):
    """Set the value to VALUE."""
    self.tk.call(self._w, 'set', value)
</t>
<t tx="ekr.20041012114208.526">&lt;&lt; class Scale methods &gt;&gt;=

def coords(self, value=None):
    """Return a tuple (X,Y) of the point along the centerline of the
    trough that corresponds to VALUE or the current value if None is
    given."""

    return self._getints(self.tk.call(self._w, 'coords', value))
</t>
<t tx="ekr.20041012114208.527">&lt;&lt; class Scale methods &gt;&gt;=

def identify(self, x, y):
    """Return where the point X,Y lies. Valid return values are "slider",
    "though1" and "though2"."""
    return self.tk.call(self._w, 'identify', x, y)
</t>
<t tx="ekr.20041012114208.528">class Scrollbar(Widget):
	
	"""Scrollbar widget which displays a slider at a certain position."""

	@others</t>
<t tx="ekr.20041012114208.529">def __init__(self, master=None, cnf={}, **kw):

    """Construct a scrollbar widget with the parent MASTER.

    Valid resource names: activebackground, activerelief,
    background, bd, bg, borderwidth, command, cursor,
    elementborderwidth, highlightbackground,
    highlightcolor, highlightthickness, jump, orient,
    relief, repeatdelay, repeatinterval, takefocus,
    troughcolor, width."""
	
    Widget.__init__(self, master, 'scrollbar', cnf, kw)
</t>
<t tx="ekr.20041012114208.530">&lt;&lt; class Scrollbar methods &gt;&gt;=

def activate(self, index):
    """Display the element at INDEX with activebackground and activerelief.
    INDEX can be "arrow1","slider" or "arrow2"."""
    self.tk.call(self._w, 'activate', index)
</t>
<t tx="ekr.20041012114208.531">&lt;&lt; class Scrollbar methods &gt;&gt;=

def delta(self, deltax, deltay):
    """Return the fractional change of the scrollbar setting if it
    would be moved by DELTAX or DELTAY pixels."""
    return getdouble(
        self.tk.call(self._w, 'delta', deltax, deltay))
</t>
<t tx="ekr.20041012114208.532">&lt;&lt; class Scrollbar methods &gt;&gt;=

def fraction(self, x, y):
    """Return the fractional value which corresponds to a slider
    position of X,Y."""
    return getdouble(self.tk.call(self._w, 'fraction', x, y))
</t>
<t tx="ekr.20041012114208.533">&lt;&lt; class Scrollbar methods &gt;&gt;=

def identify(self, x, y):
    """Return the element under position X,Y as one of
    "arrow1","slider","arrow2" or ""."""
    return self.tk.call(self._w, 'identify', x, y)
</t>
<t tx="ekr.20041012114208.534">&lt;&lt; class Scrollbar methods &gt;&gt;=

def get(self):
    """Return the current fractional values (upper and lower end)
    of the slider position."""
    return self._getdoubles(self.tk.call(self._w, 'get'))
</t>
<t tx="ekr.20041012114208.535">&lt;&lt; class Scrollbar methods &gt;&gt;=

def set(self, *args):
    """Set the fractional values of the slider position (upper and
    lower ends as value between 0 and 1)."""
    self.tk.call((self._w, 'set') + args)
</t>
<t tx="ekr.20041012114208.536">class Text(Widget):
	
	"""Text widget which can display text in various forms."""
	# XXX Add dump()

	@others</t>
<t tx="ekr.20041012114208.537">&lt;&lt; class Text methods &gt;&gt;=

def __init__(self, master=None, cnf={}, **kw):

    """Construct a text widget with the parent MASTER.

    Valid resource names: background, bd, bg, borderwidth, cursor,
    exportselection, fg, font, foreground, height,
    highlightbackground, highlightcolor, highlightthickness,
    insertbackground, insertborderwidth, insertofftime,
    insertontime, insertwidth, padx, pady, relief,
    selectbackground, selectborderwidth, selectforeground,
    setgrid, spacing1, spacing2, spacing3, state, tabs, takefocus,
    width, wrap, xscrollcommand, yscrollcommand."""

    Widget.__init__(self, master, 'text', cnf, kw)
</t>
<t tx="ekr.20041012114208.538">&lt;&lt; class Text methods &gt;&gt;=

def debug(self, boolean=None):

    """Turn on the internal consistency checks of the B-Tree inside the text
    widget according to BOOLEAN."""
	
    return self.tk.getboolean(self.tk.call(
        self._w, 'debug', boolean))
</t>
<t tx="ekr.20041012114208.539"></t>
<t tx="ekr.20041012114208.540">&lt;&lt; class Text methods &gt;&gt;=

def tk_textSelectTo(self, index):
    self.tk.call('tk_textSelectTo', self._w, index)
</t>
<t tx="ekr.20041012114208.541">&lt;&lt; class Text methods &gt;&gt;=

def tk_textBackspace(self):
    self.tk.call('tk_textBackspace', self._w)
</t>
<t tx="ekr.20041012114208.542">&lt;&lt; class Text methods &gt;&gt;=

def tk_textIndexCloser(self, a, b, c):
    self.tk.call('tk_textIndexCloser', self._w, a, b, c)
</t>
<t tx="ekr.20041012114208.543">&lt;&lt; class Text methods &gt;&gt;=

def tk_textResetAnchor(self, index):
    self.tk.call('tk_textResetAnchor', self._w, index)
</t>
<t tx="ekr.20041012114208.544"></t>
<t tx="ekr.20041012114208.545">&lt;&lt; class Text methods &gt;&gt;=

def compare(self, index1, op, index2):

    """Return whether between index INDEX1 and index INDEX2 the
    relation OP is satisfied. OP is one of &lt;, &lt;=, ==, &gt;=, &gt;, or !=."""

    return self.tk.getboolean(self.tk.call(
        self._w, 'compare', index1, op, index2))
</t>
<t tx="ekr.20041012114208.546">def delete(self, index1, index2=None):

    """Delete the characters between INDEX1 and INDEX2 (not included)."""

    self.tk.call(self._w, 'delete', index1, index2)
</t>
<t tx="ekr.20041012114208.547">def get(self, index1, index2=None):

    """Return the text from INDEX1 to INDEX2 (not included)."""
	
    return self.tk.call(self._w, 'get', index1, index2)
</t>
<t tx="ekr.20041012114208.548">def index(self, index):

    """Return the index in the form line.char for INDEX."""
	
    return self.tk.call(self._w, 'index', index)
</t>
<t tx="ekr.20041012114208.549">&lt;&lt; class Text methods &gt;&gt;=

def insert(self, index, chars, *args):
    """Insert CHARS before the characters at INDEX. An additional
    tag can be given in ARGS. Additional CHARS and tags can follow in ARGS."""
    self.tk.call((self._w, 'insert', index, chars) + args)
</t>
<t tx="ekr.20041012114208.550"></t>
<t tx="ekr.20041012114208.551">&lt;&lt; class Text methods &gt;&gt;=

# (Image commands are new in 8.0)
def image_cget(self, index, option):
    """Return the value of OPTION of an embedded image at INDEX."""
    if option[:1] != "-":
        option = "-" + option
    if option[-1:] == "_":
        option = option[:-1]
    return self.tk.call(self._w, "image", "cget", index, option)
</t>
<t tx="ekr.20041012114208.552">&lt;&lt; class Text methods &gt;&gt;=

def image_configure(self, index, cnf={}, **kw):
    """Configure an embedded image at INDEX."""
    if not cnf and not kw:
        cnf = {}
        for x in self.tk.split(
                self.tk.call(
                self._w, "image", "configure", index)):
            cnf[x[0][1:]] = (x[0][1:],) + x[1:]
        return cnf
    apply(self.tk.call,
          (self._w, "image", "configure", index)
          + self._options(cnf, kw))
</t>
<t tx="ekr.20041012114208.553">&lt;&lt; class Text methods &gt;&gt;=

def image_create(self, index, cnf={}, **kw):
    """Create an embedded image at INDEX."""
    return apply(self.tk.call,
             (self._w, "image", "create", index)
             + self._options(cnf, kw))
</t>
<t tx="ekr.20041012114208.554">&lt;&lt; class Text methods &gt;&gt;=

def image_names(self):
    """Return all names of embedded images in this widget."""
    return self.tk.call(self._w, "image", "names")
</t>
<t tx="ekr.20041012114208.555"></t>
<t tx="ekr.20041012114208.556">&lt;&lt; class Text methods &gt;&gt;=

def mark_gravity(self, markName, direction=None):
    """Change the gravity of a mark MARKNAME to DIRECTION (LEFT or RIGHT).
    Return the current value if None is given for DIRECTION."""
    return self.tk.call(
        (self._w, 'mark', 'gravity', markName, direction))
</t>
<t tx="ekr.20041012114208.557">&lt;&lt; class Text methods &gt;&gt;=

def mark_names(self):
    """Return all mark names."""
    return self.tk.splitlist(self.tk.call(
        self._w, 'mark', 'names'))
</t>
<t tx="ekr.20041012114208.558">&lt;&lt; class Text methods &gt;&gt;=

def mark_set(self, markName, index):
    """Set mark MARKNAME before the character at INDEX."""
    self.tk.call(self._w, 'mark', 'set', markName, index)
</t>
<t tx="ekr.20041012114208.559">&lt;&lt; class Text methods &gt;&gt;=

def mark_unset(self, *markNames):
    """Delete all marks in MARKNAMES."""
    self.tk.call((self._w, 'mark', 'unset') + markNames)
</t>
<t tx="ekr.20041012114208.560">&lt;&lt; class Text methods &gt;&gt;=

def mark_next(self, index):
    """Return the name of the next mark after INDEX."""
    return self.tk.call(self._w, 'mark', 'next', index) or None
</t>
<t tx="ekr.20041012114208.561">&lt;&lt; class Text methods &gt;&gt;=

def mark_previous(self, index):
    """Return the name of the previous mark before INDEX."""
    return self.tk.call(self._w, 'mark', 'previous', index) or None
</t>
<t tx="ekr.20041012114208.562"></t>
<t tx="ekr.20041012114208.563">def scan_mark(self, x, y):

    """Remember the current X, Y coordinates."""

    self.tk.call(self._w, 'scan', 'mark', x, y)
</t>
<t tx="ekr.20041012114208.564">def scan_dragto(self, x, y):

    """Adjust the view of the text to 10 times the
    difference between X and Y and the coordinates given in
    scan_mark."""

    self.tk.call(self._w, 'scan', 'dragto', x, y)
</t>
<t tx="ekr.20041012114208.565">def search(self, pattern, index, stopindex=None,
       forwards=None, backwards=None, exact=None,
       regexp=None, nocase=None, count=None):
	   
    """Search PATTERN beginning from INDEX until STOPINDEX.
    Return the index of the first character of a match or an empty string."""
	
    args = [self._w, 'search']
    if forwards: args.append('-forwards')
    if backwards: args.append('-backwards')
    if exact: args.append('-exact')
    if regexp: args.append('-regexp')
    if nocase: args.append('-nocase')
    if count: args.append('-count'); args.append(count)
    if pattern[0] == '-': args.append('--')
    args.append(pattern)
    args.append(index)
    if stopindex: args.append(stopindex)
    return self.tk.call(tuple(args))
</t>
<t tx="ekr.20041012114208.566"></t>
<t tx="ekr.20041012114208.567">&lt;&lt; class Text methods &gt;&gt;=

def tag_add(self, tagName, index1, *args):
    """Add tag TAGNAME to all characters between INDEX1 and index2 in ARGS.
    Additional pairs of indices may follow in ARGS."""
    self.tk.call(
        (self._w, 'tag', 'add', tagName, index1) + args)
</t>
<t tx="ekr.20041012114208.568">&lt;&lt; class Text methods &gt;&gt;=

def tag_unbind(self, tagName, sequence, funcid=None):
    """Unbind for all characters with TAGNAME for event SEQUENCE  the
    function identified with FUNCID."""
    self.tk.call(self._w, 'tag', 'bind', tagName, sequence, '')
    if funcid:
        self.deletecommand(funcid)
</t>
<t tx="ekr.20041012114208.569">&lt;&lt; class Text methods &gt;&gt;=

def tag_bind(self, tagName, sequence, func, add=None):
    """Bind to all characters with TAGNAME at event SEQUENCE a call to function FUNC.

    An additional boolean parameter ADD specifies whether FUNC will be
    called additionally to the other bound function or whether it will
    replace the previous function. See bind for the return value."""
    return self._bind((self._w, 'tag', 'bind', tagName),
              sequence, func, add)
</t>
<t tx="ekr.20041012114208.570">&lt;&lt; class Text methods &gt;&gt;=

def tag_cget(self, tagName, option):
    """Return the value of OPTION for tag TAGNAME."""
    if option[:1] != '-':
        option = '-' + option
    if option[-1:] == '_':
        option = option[:-1]
    return self.tk.call(self._w, 'tag', 'cget', tagName, option)
</t>
<t tx="ekr.20041012114208.571">&lt;&lt; class Text methods &gt;&gt;=

def tag_configure(self, tagName, cnf={}, **kw):
    """Configure a tag TAGNAME."""
    if type(cnf) == StringType:
        x = self.tk.split(self.tk.call(
            self._w, 'tag', 'configure', tagName, '-'+cnf))
        return (x[0][1:],) + x[1:]
    self.tk.call(
          (self._w, 'tag', 'configure', tagName)
          + self._options(cnf, kw))
</t>
<t tx="ekr.20041012114208.572">&lt;&lt; class Text methods &gt;&gt;=

tag_config = tag_configure
def tag_delete(self, *tagNames):
    """Delete all tags in TAGNAMES."""
    self.tk.call((self._w, 'tag', 'delete') + tagNames)
</t>
<t tx="ekr.20041012114208.573">&lt;&lt; class Text methods &gt;&gt;=

def tag_lower(self, tagName, belowThis=None):
    """Change the priority of tag TAGNAME such that it is lower
    than the priority of BELOWTHIS."""
    self.tk.call(self._w, 'tag', 'lower', tagName, belowThis)
</t>
<t tx="ekr.20041012114208.574">&lt;&lt; class Text methods &gt;&gt;=

def tag_names(self, index=None):
    """Return a list of all tag names."""
    return self.tk.splitlist(
        self.tk.call(self._w, 'tag', 'names', index))
</t>
<t tx="ekr.20041012114208.575">&lt;&lt; class Text methods &gt;&gt;=

def tag_nextrange(self, tagName, index1, index2=None):
    """Return a list of start and end index for the first sequence of
    characters between INDEX1 and INDEX2 which all have tag TAGNAME.
    The text is searched forward from INDEX1."""
    return self.tk.splitlist(self.tk.call(
        self._w, 'tag', 'nextrange', tagName, index1, index2))
</t>
<t tx="ekr.20041012114208.576">&lt;&lt; class Text methods &gt;&gt;=

def tag_prevrange(self, tagName, index1, index2=None):
    """Return a list of start and end index for the first sequence of
    characters between INDEX1 and INDEX2 which all have tag TAGNAME.
    The text is searched backwards from INDEX1."""
    return self.tk.splitlist(self.tk.call(
        self._w, 'tag', 'prevrange', tagName, index1, index2))
</t>
<t tx="ekr.20041012114208.577">&lt;&lt; class Text methods &gt;&gt;=

def tag_raise(self, tagName, aboveThis=None):
    """Change the priority of tag TAGNAME such that it is higher
    than the priority of ABOVETHIS."""
    self.tk.call(
        self._w, 'tag', 'raise', tagName, aboveThis)
</t>
<t tx="ekr.20041012114208.578">&lt;&lt; class Text methods &gt;&gt;=

def tag_ranges(self, tagName):
    """Return a list of ranges of text which have tag TAGNAME."""
    return self.tk.splitlist(self.tk.call(
        self._w, 'tag', 'ranges', tagName))
</t>
<t tx="ekr.20041012114208.579">&lt;&lt; class Text methods &gt;&gt;=

def tag_remove(self, tagName, index1, index2=None):
    """Remove tag TAGNAME from all characters between INDEX1 and INDEX2."""
    self.tk.call(
        self._w, 'tag', 'remove', tagName, index1, index2)
</t>
<t tx="ekr.20041012114208.580"></t>
<t tx="ekr.20041012114208.581">&lt;&lt; class Text methods &gt;&gt;=

def bbox(self, *args):
    """Return a tuple of (x,y,width,height) which gives the bounding
    box of the visible part of the character at the index in ARGS."""
    return self._getints(
        self.tk.call((self._w, 'bbox') + args)) or None
</t>
<t tx="ekr.20041012114208.582">&lt;&lt; class Text methods &gt;&gt;=

def dlineinfo(self, index):

    """Return tuple (x,y,width,height,baseline) giving the bounding box
    and baseline position of the visible part of the line containing
    the character at INDEX."""

    return self._getints(self.tk.call(self._w, 'dlineinfo', index))
</t>
<t tx="ekr.20041012114208.583">def see(self, index):

    """Scroll such that the character at INDEX is visible."""
	
    self.tk.call(self._w, 'see', index)
</t>
<t tx="ekr.20041012114208.584"></t>
<t tx="ekr.20041012114208.585">&lt;&lt; class Text methods &gt;&gt;=

def window_cget(self, index, option):
    """Return the value of OPTION of an embedded window at INDEX."""
    if option[:1] != '-':
        option = '-' + option
    if option[-1:] == '_':
        option = option[:-1]
    return self.tk.call(self._w, 'window', 'cget', index, option)
</t>
<t tx="ekr.20041012114208.586">&lt;&lt; class Text methods &gt;&gt;=

def window_configure(self, index, cnf={}, **kw):
    """Configure an embedded window at INDEX."""
    if type(cnf) == StringType:
        x = self.tk.split(self.tk.call(
            self._w, 'window', 'configure',
            index, '-'+cnf))
        return (x[0][1:],) + x[1:]
    self.tk.call(
          (self._w, 'window', 'configure', index)
          + self._options(cnf, kw))
</t>
<t tx="ekr.20041012114208.587">&lt;&lt; class Text methods &gt;&gt;=

window_config = window_configure
def window_create(self, index, cnf={}, **kw):
    """Create a window at INDEX."""
    self.tk.call(
          (self._w, 'window', 'create', index)
          + self._options(cnf, kw))
</t>
<t tx="ekr.20041012114208.588">&lt;&lt; class Text methods &gt;&gt;=

def window_names(self):
    """Return all names of embedded windows in this widget."""
    return self.tk.splitlist(
        self.tk.call(self._w, 'window', 'names'))
</t>
<t tx="ekr.20041012114208.589"></t>
<t tx="ekr.20041012114208.590">&lt;&lt; class Text methods &gt;&gt;=

def xview(self, *what):
    """Query and change horizontal position of the view."""
    if not what:
        return self._getdoubles(self.tk.call(self._w, 'xview'))
    self.tk.call((self._w, 'xview') + what)
</t>
<t tx="ekr.20041012114208.591">&lt;&lt; class Text methods &gt;&gt;=

def xview_moveto(self, fraction):
    """Adjusts the view in the window so that FRACTION of the
    total width of the canvas is off-screen to the left."""
    self.tk.call(self._w, 'xview', 'moveto', fraction)
</t>
<t tx="ekr.20041012114208.592">&lt;&lt; class Text methods &gt;&gt;=

def xview_scroll(self, number, what):
    """Shift the x-view according to NUMBER which is measured
    in "units" or "pages" (WHAT)."""
    self.tk.call(self._w, 'xview', 'scroll', number, what)
</t>
<t tx="ekr.20041012114208.593">&lt;&lt; class Text methods &gt;&gt;=

def yview(self, *what):
    """Query and change vertical position of the view."""
    if not what:
        return self._getdoubles(self.tk.call(self._w, 'yview'))
    self.tk.call((self._w, 'yview') + what)
</t>
<t tx="ekr.20041012114208.594">&lt;&lt; class Text methods &gt;&gt;=

def yview_moveto(self, fraction):
    """Adjusts the view in the window so that FRACTION of the
    total height of the canvas is off-screen to the top."""
    self.tk.call(self._w, 'yview', 'moveto', fraction)
</t>
<t tx="ekr.20041012114208.595">&lt;&lt; class Text methods &gt;&gt;=

def yview_scroll(self, number, what):
    """Shift the y-view according to NUMBER which is measured
    in "units" or "pages" (WHAT)."""
    self.tk.call(self._w, 'yview', 'scroll', number, what)
</t>
<t tx="ekr.20041012114208.596">&lt;&lt; class Text methods &gt;&gt;=

def yview_pickplace(self, *what):
    """Obsolete function, use see."""
    self.tk.call((self._w, 'yview', '-pickplace') + what)
</t>
<t tx="ekr.20041012114208.597">class _setit:

	"""Internal class. It wraps the command in the widget OptionMenu."""

	@others
</t>
<t tx="ekr.20041012114208.598">def __init__(self, var, value, callback=None):

    self.__value = value
    self.__var = var
    self.__callback = callback
</t>
<t tx="ekr.20041012114208.599">def __call__(self, *args):

    self.__var.set(self.__value)
    if self.__callback:
        apply(self.__callback, (self.__value,)+args)
</t>
<t tx="ekr.20041012114208.600">class OptionMenu(Menubutton):

	"""OptionMenu which allows the user to select a value from a menu."""

	@others
</t>
<t tx="ekr.20041012114208.601">def __init__(self, master, variable, value, *values, **kwargs):

    """Construct an optionmenu widget with the parent MASTER, with
    the resource textvariable set to VARIABLE, the initially selected
    value VALUE, the other menu values VALUES and an additional
    keyword argument command."""

    kw = {"borderwidth": 2, "textvariable": variable,
          "indicatoron": 1, "relief": RAISED, "anchor": "c",
          "highlightthickness": 2}
    Widget.__init__(self, master, "menubutton", kw)
    self.widgetName = 'tk_optionMenu'
    menu = self.__menu = Menu(self, name="menu", tearoff=0)
    self.menuname = menu._w
    # 'command' is the only supported keyword
    callback = kwargs.get('command')
    if kwargs.has_key('command'):
        del kwargs['command']
    if kwargs:
        raise TclError, 'unknown option -'+kwargs.keys()[0]
    menu.add_command(label=value,
             command=_setit(variable, value, callback))
    for v in values:
        menu.add_command(label=v,
                 command=_setit(variable, v, callback))
    self["menu"] = menu
</t>
<t tx="ekr.20041012114208.602">def __getitem__(self, name):

    if name == 'menu':
        return self.__menu
    return Widget.__getitem__(self, name)
</t>
<t tx="ekr.20041012114208.603">def destroy(self):

    """Destroy this widget and the associated menu."""

    Menubutton.destroy(self)
    self.__menu = None
</t>
<t tx="ekr.20041012114208.604"></t>
<t tx="ekr.20041012114208.605">class Image:

	"""Base class for images."""
	_last_id = 0

	@others
</t>
<t tx="ekr.20041012114208.606">def __init__(self, imgtype, name=None, cnf={}, master=None, **kw):

    self.name = None
    if not master:
        master = _default_root
        if not master:
            raise RuntimeError, 'Too early to create image'
    self.tk = master.tk
    if not name:
        Image._last_id += 1
        name = "pyimage" +`Image._last_id` # tk itself would use image&lt;x&gt;
        # The following is needed for systems where id(x)
        # can return a negative number, such as Linux/m68k:
        if name[0] == '-': name = '_' + name[1:]
    if kw and cnf: cnf = _cnfmerge((cnf, kw))
    elif kw: cnf = kw
    options = ()
    for k, v in cnf.items():
        if callable(v):
            v = self._register(v)
        options = options + ('-'+k, v)
    self.tk.call(('image', 'create', imgtype, name,) + options)
    self.name = name
</t>
<t tx="ekr.20041012114208.607">def __str__(self):

	return self.name
</t>
<t tx="ekr.20041012114208.608">def __del__(self):

    if self.name:
        try:
            self.tk.call('image', 'delete', self.name)
        except TclError:
            # May happen if the root was destroyed
            pass
</t>
<t tx="ekr.20041012114208.609">def __setitem__(self, key, value):

    self.tk.call(self.name, 'configure', '-'+key, value)
</t>
<t tx="ekr.20041012114208.610">def __getitem__(self, key):

    return self.tk.call(self.name, 'configure', '-'+key)
</t>
<t tx="ekr.20041012114208.611">def configure(self, **kw):

    """Configure the image."""

    res = ()
    for k, v in _cnfmerge(kw).items():
        if v is not None:
            if k[-1] == '_': k = k[:-1]
            if callable(v):
                v = self._register(v)
            res = res + ('-'+k, v)
    self.tk.call((self.name, 'config') + res)

config = configure</t>
<t tx="ekr.20041012114208.612">def height(self):

    """Return the height of the image."""

    return getint(
        self.tk.call('image', 'height', self.name))
</t>
<t tx="ekr.20041012114208.613">def type(self):

    """Return the type of the imgage, e.g. "photo" or "bitmap"."""

    return self.tk.call('image', 'type', self.name)
</t>
<t tx="ekr.20041012114208.614">def width(self):

    """Return the width of the image."""
	
    return getint(
        self.tk.call('image', 'width', self.name))
</t>
<t tx="ekr.20041012114208.615">class PhotoImage(Image):

	"""Widget which can display colored images in GIF, PPM/PGM format."""

	@others
</t>
<t tx="ekr.20041012114208.616">def __init__(self, name=None, cnf={}, master=None, **kw):

    """Create an image with NAME.

    Valid resource names: data, format, file, gamma, height, palette,
    width."""

    apply(Image.__init__, (self, 'photo', name, cnf, master), kw)
</t>
<t tx="ekr.20041012114208.617">def blank(self):

    """Display a transparent image."""

    self.tk.call(self.name, 'blank')
</t>
<t tx="ekr.20041012114208.618">def cget(self, option):

    """Return the value of OPTION."""

    return self.tk.call(self.name, 'cget', '-' + option)
</t>
<t tx="ekr.20041012114208.619"># XXX config

def __getitem__(self, key):\

    return self.tk.call(self.name, 'cget', '-' + key)
</t>
<t tx="ekr.20041012114208.620"># XXX copy -from, -to, ...?

def copy(self):

    """Return a new PhotoImage with the same image as this widget."""

    destImage = PhotoImage()
    self.tk.call(destImage, 'copy', self.name)
    return destImage
</t>
<t tx="ekr.20041012114208.621">def zoom(self,x,y=''):

    """Return a new PhotoImage with the same image as this widget
    but zoom it with X and Y."""

    destImage = PhotoImage()
    if y=='': y=x
    self.tk.call(destImage, 'copy', self.name, '-zoom',x,y)
    return destImage
</t>
<t tx="ekr.20041012114208.622">def subsample(self,x,y=''):

    """Return a new PhotoImage based on the same image as this widget
    but use only every Xth or Yth pixel."""

    destImage = PhotoImage()
    if y=='': y=x
    self.tk.call(destImage, 'copy', self.name, '-subsample',x,y)
    return destImage
</t>
<t tx="ekr.20041012114208.623">def get(self, x, y):

    """Return the color (red, green, blue) of the pixel at X,Y."""

    return self.tk.call(self.name, 'get', x, y)
</t>
<t tx="ekr.20041012114208.624">def put(self, data, to=None):

    """Put row formated colors to image starting from
    position TO, e.g. image.put("{red green} {blue yellow}", to=(4,6))"""

    args = (self.name, 'put', data)
    if to:
        if to[0] == '-to':
            to = to[1:]
        args = args + ('-to',) + tuple(to)
    self.tk.call(args)
</t>
<t tx="ekr.20041012114208.625"># XXX read

def write(self, filename, format=None, from_coords=None):

    """Write image to file FILENAME in FORMAT starting from
    position FROM_COORDS."""

    args = (self.name, 'write', filename)
    if format:
        args = args + ('-format', format)
    if from_coords:
        args = args + ('-from',) + tuple(from_coords)
    self.tk.call(args)
</t>
<t tx="ekr.20041012114208.626">class BitmapImage(Image):

	"""Widget which can display a bitmap."""

	@others
</t>
<t tx="ekr.20041012114208.627">def __init__(self, name=None, cnf={}, master=None, **kw):

    """Create a bitmap with NAME.

    Valid resource names: background, data, file, foreground, maskdata, maskfile."""

    apply(Image.__init__, (self, 'bitmap', name, cnf, master), kw)
</t>
<t tx="ekr.20041012114208.628"></t>
<t tx="ekr.20041012114208.629">class Studbutton(Button):
	@others

</t>
<t tx="ekr.20041012114208.630">def __init__(self, master=None, cnf={}, **kw):

    Widget.__init__(self, master, 'studbutton', cnf, kw)
    self.bind('&lt;Any-Enter&gt;',       self.tkButtonEnter)
    self.bind('&lt;Any-Leave&gt;',       self.tkButtonLeave)
    self.bind('&lt;1&gt;',               self.tkButtonDown)
    self.bind('&lt;ButtonRelease-1&gt;', self.tkButtonUp)
</t>
<t tx="ekr.20041012114208.631">class Tributton(Button):
	@others

</t>
<t tx="ekr.20041012114208.632">def __init__(self, master=None, cnf={}, **kw):

    Widget.__init__(self, master, 'tributton', cnf, kw)
    self.bind('&lt;Any-Enter&gt;',       self.tkButtonEnter)
    self.bind('&lt;Any-Leave&gt;',       self.tkButtonLeave)
    self.bind('&lt;1&gt;',               self.tkButtonDown)
    self.bind('&lt;ButtonRelease-1&gt;', self.tkButtonUp)
    self['fg']               = self['bg']
    self['activebackground'] = self['bg']
</t>
<t tx="ekr.20041012114208.633"></t>
<t tx="ekr.20041012114208.634">def _cnfmerge(cnfs):

    """Internal function."""

    if type(cnfs) is DictionaryType:
        return cnfs
    elif type(cnfs) in (NoneType, StringType):
        return cnfs
    else:
        cnf = {}
        for c in _flatten(cnfs):
            try:
                cnf.update(c)
            except (AttributeError, TypeError), msg:
                print "_cnfmerge: fallback due to:", msg
                for k, v in c.items():
                    cnf[k] = v
        return cnf

# EKR: use _tkinter._cnfmerge if available, otherwise use the code above.
try: _cnfmerge = _tkinter._cnfmerge
except AttributeError: pass
</t>
<t tx="ekr.20041012114208.635">def _flatten(tuple):

    """Internal function."""

    res = ()
    for item in tuple:
        if type(item) in (TupleType, ListType):
            res = res + _flatten(item)
        elif item is not None:
            res = res + (item,)
    return res

try: _flatten = _tkinter._flatten
except AttributeError: pass
</t>
<t tx="ekr.20041012114208.636">def _test():

    root = Tk()
    text = "This is Tcl/Tk version %s" % TclVersion
    if TclVersion &gt;= 8.1:
        try:
            text = text + unicode("\nThis should be a cedilla: \347",
                                  "iso-8859-1")
        except NameError:
            pass # no unicode support
    label = Label(root, text=text)
    label.pack()
    test = Button(root, text="Click me!",
              command=lambda root=root: root.test.configure(
                  text="[%s]" % root.test['text']))
    test.pack()
    root.test = test
    quit = Button(root, text="QUIT", command=root.destroy)
    quit.pack()
    # The following three commands are needed so the window pops
    # up on top on Windows...
    root.iconify()
    root.update()
    root.deiconify()
    root.mainloop()
</t>
<t tx="ekr.20041012114208.637">getint = int
getdouble = float

def getboolean(s):

    """Convert true and false to integer values 1 and 0."""
	
    return _default_root.tk.getboolean(s)
</t>
<t tx="ekr.20041012114208.638">def image_names():

	return _default_root.tk.call('image', 'names')

</t>
<t tx="ekr.20041012114208.639">def image_types():

	return _default_root.tk.call('image', 'types')</t>
<t tx="ekr.20041012114208.640">@ XXX I don't like these -- take them away
</t>
<t tx="ekr.20041012114208.641">def AtEnd():

	return 'end'
</t>
<t tx="ekr.20041012114208.642">def AtInsert(*args):

	s = 'insert'
	for a in args:
		if a: s = s + (' ' + a)
	return s
</t>
<t tx="ekr.20041012114208.643">def AtSelFirst():

	return 'sel.first'
</t>
<t tx="ekr.20041012114208.644">def AtSelLast():

	return 'sel.last'
</t>
<t tx="ekr.20041012114208.645">def At(x, y=None):

	if y is None:
		return '@' + `x`
	else:
		return '@' + `x` + ',' + `y`
</t>
<t tx="ekr.20041012114208.646">def mainloop(n=0):

    """Run the main loop of Tcl."""

    _default_root.tk.mainloop(n)
</t>
</tnodes>
</leo_file>
