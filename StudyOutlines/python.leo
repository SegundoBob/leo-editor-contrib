<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="2322" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="24" left="119" height="816" width="937"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences allow_rich_text="0">
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="T1"><vh>Read me</vh></v>
<v t="T2"><vh>EKR notes</vh>
<v t="T3"><vh>How to disassemble files</vh></v>
<v t="T4"><vh>Python Library Reference</vh>
<v t="T5"><vh>2.1.8 Other built-in objects </vh>
<v t="T6"><vh>2.1.8.1 Modules</vh></v>
<v t="T7"><vh>2.1.8.5 Code Objects</vh></v>
<v t="T8"><vh>2.1.8.2 Classes and Class Instances</vh></v>
</v>
<v t="T9"><vh>Built-in functions</vh></v>
</v>
<v t="T10"><vh>Python Reference Manual</vh>
<v t="T11"><vh>3.2 The standard type hierarchy</vh>
<v t="T12"><vh>None</vh></v>
<v t="T13"><vh>NotImplemented</vh></v>
<v t="T14"><vh>Ellipsis </vh></v>
<v t="T15"><vh>Numbers</vh></v>
<v t="T16"><vh>Sequences</vh></v>
<v t="T17"><vh>Mappings </vh></v>
<v t="T18"><vh>Callable types</vh></v>
<v t="T19"><vh>Modules</vh></v>
<v t="T20"><vh>Classes </vh></v>
<v t="T21"><vh>Class instances </vh></v>
<v t="T22"><vh>Files</vh></v>
<v t="T23"><vh>Internal types</vh>
<v t="T24"><vh>Code objects (co_xxx below, see also func_code)</vh></v>
<v t="T25"><vh>Frame objects </vh></v>
<v t="T26"><vh>Traceback objects</vh></v>
<v t="T27"><vh>NewHeadline</vh></v>
</v>
</v>
<v t="T28"><vh>7.5 Function definitions </vh></v>
<v t="T29"><vh>7.6 Class definitions </vh></v>
<v t="T30"><vh>17.10.1 Python Byte Code Instructions </vh>
<v t="T31"><vh>&lt;&lt; arithmetic &amp; compare ops &gt;&gt;</vh>
<v t="T32"><vh>&lt;&lt; unary ops &gt;&gt;</vh></v>
<v t="T33"><vh>&lt;&lt; binary ops &gt;&gt;</vh></v>
<v t="T34"><vh>&lt;&lt; inplace (stack) binary ops &gt;&gt;</vh></v>
</v>
<v t="T35"><vh>&lt;&lt; block, class, closure, function ops &gt;&gt;</vh></v>
<v t="T36"><vh>&lt;&lt; call ops &gt;&gt;</vh></v>
<v t="T37"><vh>&lt;&lt; del ops &gt;&gt; (what does this do in C++?)</vh></v>
<v t="T38"><vh>&lt;&lt; exception ops &gt;&gt;</vh></v>
<v t="T39"><vh>&lt;&lt; import ops &gt;&gt;</vh></v>
<v t="T40"><vh>&lt;&lt; jump ops &gt;&gt;</vh></v>
<v t="T41"><vh>&lt;&lt; load/store ops &gt;&gt;</vh></v>
<v t="T42"><vh>&lt;&lt; loop ops &gt;&gt;</vh></v>
<v t="T43"><vh>&lt;&lt; print ops &gt;&gt;</vh></v>
<v t="T44"><vh>&lt;&lt; stack ops &gt;&gt; (includes build &amp; constants)</vh></v>
<v t="T45"><vh>&lt;&lt; string ops &gt;&gt;</vh></v>
</v>
</v>
<v t="T46"><vh>C API</vh>
<v t="T47"><vh>1.2.1 Reference Counts </vh>
<v t="T48"><vh>1.2.1.1 Reference Count Details</vh></v>
</v>
</v>
<v t="T49"><vh>email re moving periodic things out of main loop</vh></v>
</v>
<v t="T50"><vh>Includes</vh>
<v t="T51"><vh>classobject.h</vh></v>
<v t="T52"><vh>compile.h</vh></v>
<v t="T53"><vh>dictobject.h</vh></v>
<v t="T54"><vh>For interpt</vh>
<v t="T55"><vh>ceval.h</vh></v>
<v t="T56" a="C"><vh>opcode.h</vh></v>
<v t="T57"><vh>compile.h</vh></v>
<v t="T58"><vh>frameobject.h</vh></v>
</v>
<v t="T59"><vh>object.h</vh></v>
<v t="T60"><vh>Python.h</vh>
<v t="T61"><vh>&lt;&lt; enable compiler features &gt;&gt;</vh></v>
<v t="T62"><vh>&lt;&lt; include nearly all Python header files &gt;&gt;</vh></v>
</v>
<v t="T63"><vh>pythonrun.h</vh></v>
<v t="T64"><vh>symtable.h</vh></v>
<v t="T65"><vh>token.h</vh></v>
<v t="T66"><vh>tupleobject.h</vh></v>
</v>
<v t="T67"><vh>Objects</vh>
<v t="T68"><vh>abstract.c</vh>
<v t="T69"><vh>type_error</vh></v>
<v t="T70"><vh>null_error</vh></v>
<v t="T71"><vh>PyObject... (note: does _not_ include "object protocol" methods)</vh>
<v t="T72"><vh>PyObject_Cmp</vh></v>
<v t="T73"><vh>PyObject_Type</vh></v>
<v t="T74"><vh>PyObject_Size</vh></v>
<v t="T75"><vh>PyObject_Length</vh></v>
<v t="T76"><vh>PyObject_GetItem</vh></v>
<v t="T77"><vh>PyObject_SetItem</vh></v>
<v t="T78"><vh>PyObject_DelItem</vh></v>
<v t="T79"><vh>PyObject_AsCharBuffer</vh></v>
<v t="T80"><vh>PyObject_CheckReadBuffer</vh></v>
<v t="T81"><vh>PyObject_AsReadBuffer</vh></v>
<v t="T82"><vh>PyObject_AsWriteBuffer</vh></v>
</v>
<v t="T83"><vh>PyNumber &amp; allies...</vh>
<v t="T84"><vh>PyNumber_Check</vh></v>
<v t="T85"><vh>binary_op1</vh></v>
<v t="T86"><vh>binary_op</vh></v>
<v t="T87"><vh>ternary_op</vh></v>
<v t="T88"><vh>BINARY_FUNC</vh></v>
<v t="T89"><vh>PyNumber_Add</vh></v>
<v t="T90"><vh>PyNumber_FloorDivide</vh></v>
<v t="T91"><vh>PyNumber_TrueDivide</vh></v>
<v t="T92"><vh>PyNumber_Remainder</vh></v>
<v t="T93"><vh>PyNumber_Power</vh></v>
<v t="T94"><vh>binary_iop</vh></v>
<v t="T95"><vh>INPLACE_BINOP</vh></v>
<v t="T96"><vh>PyNumber_InPlaceFloorDivide</vh></v>
<v t="T97"><vh>PyNumber_InPlaceTrueDivide</vh></v>
<v t="T98"><vh>PyNumber_InPlaceAdd</vh></v>
<v t="T99"><vh>PyNumber_InPlaceMultiply</vh></v>
<v t="T100"><vh>PyNumber_InPlaceRemainder</vh></v>
<v t="T101"><vh>PyNumber_InPlacePower</vh></v>
<v t="T102"><vh>PyNumber_Negative</vh></v>
<v t="T103"><vh>PyNumber_Positive</vh></v>
<v t="T104"><vh>PyNumber_Invert</vh></v>
<v t="T105"><vh>PyNumber_Absolute</vh></v>
<v t="T106"><vh>int_from_string</vh></v>
<v t="T107"><vh>PyNumber_Int</vh></v>
<v t="T108"><vh>long_from_string</vh></v>
<v t="T109"><vh>PyNumber_Long</vh></v>
<v t="T110"><vh>PyNumber_Float</vh></v>
</v>
<v t="T111"><vh>PySequence...</vh>
<v t="T112"><vh>PySequence_Check</vh></v>
<v t="T113"><vh>PySequence_Size</vh></v>
<v t="T114"><vh>PySequence_Length</vh></v>
<v t="T115"><vh>PySequence_Concat</vh></v>
<v t="T116"><vh>PySequence_Repeat</vh></v>
<v t="T117"><vh>PySequence_InPlaceConcat</vh></v>
<v t="T118"><vh>PySequence_InPlaceRepeat</vh></v>
<v t="T119"><vh>PySequence_GetItem</vh></v>
<v t="T120"><vh>sliceobj_from_intint</vh></v>
<v t="T121"><vh>PySequence_GetSlice</vh></v>
<v t="T122"><vh>PySequence_SetItem</vh></v>
<v t="T123"><vh>PySequence_DelItem</vh></v>
<v t="T124"><vh>PySequence_SetSlice</vh></v>
<v t="T125"><vh>PySequence_DelSlice</vh></v>
<v t="T126"><vh>PySequence_Tuple</vh></v>
<v t="T127"><vh>PySequence_List</vh></v>
<v t="T128"><vh>PySequence_Fast</vh></v>
<v t="T129"><vh>_PySequence_IterSearch</vh></v>
<v t="T130"><vh>PySequence_Count</vh></v>
<v t="T131"><vh>PySequence_Contains</vh></v>
<v t="T132"><vh>PySequence_In</vh></v>
<v t="T133"><vh>PySequence_Index</vh></v>
</v>
<v t="T134"><vh>PyMapping...</vh>
<v t="T135"><vh>PyMapping_Check</vh></v>
<v t="T136"><vh>PyMapping_Size</vh></v>
<v t="T137"><vh>PyMapping_Length</vh></v>
<v t="T138"><vh>PyMapping_GetItemString</vh></v>
<v t="T139"><vh>PyMapping_SetItemString</vh></v>
<v t="T140"><vh>PyMapping_HasKeyString</vh></v>
<v t="T141"><vh>PyMapping_HasKey</vh></v>
</v>
<v t="T142"><vh>PyObjectCall... &amp; allies</vh>
<v t="T143"><vh>PyObject_Call...</vh>
<v t="T144"><vh>PyObject_CallObject</vh></v>
<v t="T145" a="C"><vh>PyObject_Call (abstract.c)</vh></v>
<v t="T146"><vh>PyObject_CallFunction</vh></v>
<v t="T147"><vh>PyObject_CallMethod</vh></v>
<v t="T148"><vh>objargs_mktuple</vh></v>
<v t="T149"><vh>PyObject_CallMethodObjArgs</vh></v>
<v t="T150"><vh>PyObject_CallFunctionObjArgs</vh></v>
</v>
<v t="T151"><vh>abstract_get_bases</vh></v>
<v t="T152"><vh>abstract_issubclass</vh></v>
<v t="T153"><vh>PyObject_IsInstance</vh></v>
<v t="T154"><vh>PyObject_IsSubclass</vh></v>
<v t="T155"><vh>Iterators...</vh>
<v t="T156"><vh>PyObject_GetIter</vh></v>
<v t="T157"><vh>PyIter_Next</vh></v>
</v>
</v>
</v>
<v t="T158"><vh>cobject.c</vh>
<v t="T159"><vh>&lt;&lt; cobject #includes &gt;&gt;</vh></v>
<v t="T160"><vh>&lt;&lt; cobject declarations &gt;&gt;</vh></v>
<v t="T161"><vh>PyCObject_FromVoidPtr</vh></v>
<v t="T162"><vh>PyCObject_FromVoidPtrAndDesc</vh></v>
<v t="T163"><vh>PyCObject_AsVoidPtr</vh></v>
<v t="T164"><vh>PyCObject_GetDesc</vh></v>
<v t="T165"><vh>PyCObject_Import</vh></v>
<v t="T166"><vh>PyCObject_dealloc</vh></v>
</v>
<v t="T167"><vh>frameobject.c</vh>
<v t="T168"><vh>&lt;&lt; frameobject #includes &gt;&gt;</vh></v>
<v t="T169"><vh>&lt;&lt; frameobject declarations &gt;&gt;</vh></v>
<v t="T170"><vh>frame_getlocals</vh></v>
<v t="T171"><vh>frame_dealloc</vh></v>
<v t="T172"><vh>frame_traverse</vh></v>
<v t="T173"><vh>frame_clear</vh></v>
<v t="T174"><vh>PyFrame_New</vh></v>
<v t="T175"><vh>PyFrame_BlockSetup</vh></v>
<v t="T176"><vh>PyFrame_BlockPop</vh></v>
<v t="T177"><vh>map_to_dict</vh></v>
<v t="T178"><vh>dict_to_map</vh></v>
<v t="T179"><vh>PyFrame_FastToLocals</vh></v>
<v t="T180"><vh>PyFrame_LocalsToFast</vh></v>
<v t="T181"><vh>PyFrame_Fini</vh></v>
</v>
<v t="T182"><vh>funcobject.c</vh>
<v t="T183"><vh>PyFunction_New</vh></v>
<v t="T184"><vh>PyFunction_GetCode</vh></v>
<v t="T185"><vh>PyFunction_GetGlobals</vh></v>
<v t="T186"><vh>PyFunction_GetDefaults</vh></v>
<v t="T187"><vh>PyFunction_SetDefaults</vh></v>
<v t="T188"><vh>PyFunction_GetClosure</vh></v>
<v t="T189"><vh>PyFunction_SetClosure</vh></v>
<v t="T190"><vh>static helpers...</vh>
<v t="T191"><vh>restricted</vh></v>
<v t="T192"><vh>func_get_dict</vh></v>
<v t="T193"><vh>func_set_dict</vh></v>
<v t="T194"><vh>func_get_code</vh></v>
<v t="T195"><vh>func_set_code</vh></v>
<v t="T196"><vh>func_get_defaults</vh></v>
<v t="T197"><vh>func_set_defaults</vh></v>
<v t="T198"><vh>func_dealloc</vh></v>
<v t="T199"><vh>func_repr</vh></v>
<v t="T200"><vh>func_traverse</vh></v>
<v t="T201"><vh>function_call</vh></v>
<v t="T202"><vh>func_descr_get</vh></v>
</v>
<v t="T203"><vh>PyFunction_Type</vh></v>
<v t="T204"><vh>Class methods...</vh>
<v t="T205"><vh>Class method objet</vh></v>
<v t="T206"><vh>cm_dealloc</vh></v>
<v t="T207"><vh>cm_descr_get</vh></v>
<v t="T208"><vh>cm_init</vh></v>
<v t="T209"><vh>PyClassMethod_New</vh></v>
</v>
<v t="T210"><vh>Static methods...</vh>
<v t="T211"><vh>Static method objects</vh></v>
<v t="T212"><vh>sm_dealloc</vh></v>
<v t="T213"><vh>sm_descr_get</vh></v>
<v t="T214"><vh>sm_init</vh></v>
<v t="T215"><vh>PyStaticMethod_New</vh></v>
</v>
</v>
<v t="T216"><vh>listobject.c</vh>
<v t="T217"><vh>&lt;&lt; listobject #includes &gt;&gt;</vh></v>
<v t="T218"><vh>roundupsize</vh></v>
<v t="T219"><vh>PyList_New</vh></v>
<v t="T220"><vh>PyList_Size</vh></v>
<v t="T221"><vh>PyList_GetItem</vh></v>
<v t="T222"><vh>PyList_SetItem</vh></v>
<v t="T223"><vh>ins1</vh></v>
<v t="T224"><vh>PyList_Insert</vh></v>
<v t="T225"><vh>PyList_Append</vh></v>
<v t="T226"><vh>list_dealloc</vh></v>
<v t="T227"><vh>list_print</vh></v>
<v t="T228"><vh>list_repr</vh></v>
<v t="T229"><vh>list_length</vh></v>
<v t="T230"><vh>list_contains</vh></v>
<v t="T231"><vh>list_item</vh></v>
<v t="T232"><vh>list_slice</vh></v>
<v t="T233"><vh>PyList_GetSlice</vh></v>
<v t="T234"><vh>list_concat</vh></v>
<v t="T235"><vh>list_repeat</vh></v>
<v t="T236"><vh>list_ass_slice</vh></v>
<v t="T237"><vh>PyList_SetSlice</vh></v>
<v t="T238"><vh>list_inplace_repeat</vh></v>
<v t="T239"><vh>list_ass_item</vh></v>
<v t="T240"><vh>ins</vh></v>
<v t="T241"><vh>listinsert</vh></v>
<v t="T242"><vh>listappend</vh></v>
<v t="T243"><vh>listextend_internal</vh></v>
<v t="T244"><vh>list_inplace_concat</vh></v>
<v t="T245"><vh>listextend</vh></v>
<v t="T246"><vh>listpop</vh></v>
<v t="T247"><vh>docompare</vh></v>
<v t="T248"><vh>binarysort</vh></v>
<v t="T249"><vh>samplesortslice</vh></v>
<v t="T250"><vh>listsort</vh></v>
<v t="T251"><vh>PyList_Sort</vh></v>
<v t="T252"><vh>_listreverse</vh></v>
<v t="T253"><vh>listreverse</vh></v>
<v t="T254"><vh>PyList_Reverse</vh></v>
<v t="T255"><vh>PyList_AsTuple</vh></v>
<v t="T256"><vh>listindex</vh></v>
<v t="T257"><vh>listcount</vh></v>
<v t="T258"><vh>listremove</vh></v>
<v t="T259"><vh>list_traverse</vh></v>
<v t="T260"><vh>list_clear</vh></v>
<v t="T261"><vh>list_richcompare</vh></v>
<v t="T262"><vh>list_fill</vh></v>
<v t="T263"><vh>list_init</vh></v>
<v t="T264"><vh>list_nohash</vh></v>
<v t="T265"><vh>immutable_list_op</vh></v>
<v t="T266"><vh>immutable_list_ass</vh></v>
</v>
<v t="T267" a="C"><vh>object.c (Contains PyObject protocol)</vh>
<v t="T268"><vh>&lt;&lt; #includes &gt;&gt;</vh></v>
<v t="T269"><vh>Counts...</vh>
<v t="T270"><vh>dump_counts</vh></v>
<v t="T271"><vh>get_counts</vh></v>
<v t="T272"><vh>inc_count</vh></v>
</v>
<v t="T273"><vh>PyObject_Init</vh></v>
<v t="T274"><vh>PyObject_InitVar</vh></v>
<v t="T275"><vh>_PyObject_New</vh></v>
<v t="T276"><vh>_PyObject_NewVar</vh></v>
<v t="T277"><vh>_PyObject_Del</vh></v>
<v t="T278"><vh>PyObject_Print</vh></v>
<v t="T279"><vh>_PyObject_Dump</vh></v>
<v t="T280"><vh>PyObject_Repr</vh></v>
<v t="T281"><vh>PyObject_Str</vh></v>
<v t="T282"><vh>PyObject_Unicode</vh></v>
<v t="T283"><vh>try_rich_compare</vh></v>
<v t="T284"><vh>try_rich_compare_bool</vh></v>
<v t="T285"><vh>try_rich_to_3way_compare</vh></v>
<v t="T286"><vh>try_3way_compare</vh></v>
<v t="T287"><vh>default_3way_compare</vh></v>
<v t="T288"><vh>do_cmp</vh></v>
<v t="T289"><vh>get_inprogress_dict</vh></v>
<v t="T290"><vh>check_recursion</vh></v>
<v t="T291"><vh>delete_token</vh></v>
<v t="T292"><vh>PyObject_Compare</vh></v>
<v t="T293"><vh>convert_3way_to_object</vh></v>
<v t="T294"><vh>try_3way_to_rich_compare</vh></v>
<v t="T295"><vh>do_richcmp</vh></v>
<v t="T296"><vh>PyObject_RichCompare</vh></v>
<v t="T297"><vh>PyObject_RichCompareBool</vh></v>
<v t="T298"><vh>_Py_HashDouble</vh></v>
<v t="T299"><vh>_Py_HashPointer</vh></v>
<v t="T300"><vh>PyObject_Hash</vh></v>
<v t="T301"><vh>PyObject_GetAttrString</vh></v>
<v t="T302"><vh>PyObject_HasAttrString</vh></v>
<v t="T303"><vh>PyObject_SetAttrString</vh></v>
<v t="T304" a="C"><vh>PyObject_GetAttr  -- EKR: a crucial routine ??</vh></v>
<v t="T305"><vh>PyObject_HasAttr</vh></v>
<v t="T306"><vh>PyObject_SetAttr</vh></v>
<v t="T307"><vh>_PyObject_GetDictPtr</vh></v>
<v t="T308"><vh>PyObject_GenericGetAttr</vh></v>
<v t="T309"><vh>PyObject_GenericSetAttr</vh></v>
<v t="T310"><vh>PyObject_IsTrue</vh></v>
<v t="T311"><vh>PyObject_Not</vh></v>
<v t="T312"><vh>PyNumber_CoerceEx</vh></v>
<v t="T313"><vh>PyNumber_Coerce</vh></v>
<v t="T314"><vh>PyCallable_Check</vh></v>
<v t="T315"><vh>merge_class_dict</vh></v>
<v t="T316"><vh>merge_list_attr</vh></v>
<v t="T317"><vh>PyObject_Dir</vh></v>
<v t="T318"><vh>none_repr</vh></v>
<v t="T319"><vh>none_dealloc</vh></v>
<v t="T320"><vh>NotImplemented_repr</vh></v>
<v t="T321"><vh>_Py_ReadyTypes</vh></v>
<v t="T322"><vh>_Py_ResetReferences</vh></v>
<v t="T323"><vh>_Py_NewReference</vh></v>
<v t="T324"><vh>_Py_ForgetReference</vh></v>
<v t="T325"><vh>_Py_Dealloc</vh></v>
<v t="T326"><vh>_Py_PrintReferences</vh></v>
<v t="T327"><vh>_Py_GetObjects</vh></v>
<v t="T328"><vh>PyMem_Malloc</vh></v>
<v t="T329"><vh>PyMem_Realloc</vh></v>
<v t="T330"><vh>PyMem_Free</vh></v>
<v t="T331"><vh>PyObject_Malloc</vh></v>
<v t="T332"><vh>PyObject_Realloc</vh></v>
<v t="T333"><vh>PyObject_Free</vh></v>
<v t="T334"><vh>Py_ReprEnter</vh></v>
<v t="T335"><vh>Py_ReprLeave</vh></v>
<v t="T336"><vh>_PyTrash_deposit_object</vh></v>
<v t="T337"><vh>_PyTrash_destroy_chain</vh></v>
</v>
<v t="T338"><vh>tupleobject.c</vh>
<v t="T339"><vh>&lt;&lt; tupleobject #includes &gt;&gt;</vh></v>
<v t="T340"><vh>&lt;&lt; tupleobject declarations &gt;&gt;</vh></v>
<v t="T341"><vh>PyTuple_New</vh></v>
<v t="T342"><vh>PyTuple_Size</vh></v>
<v t="T343"><vh>PyTuple_GetItem</vh></v>
<v t="T344"><vh>PyTuple_SetItem</vh></v>
<v t="T345"><vh>tupledealloc</vh></v>
<v t="T346"><vh>tupleprint</vh></v>
<v t="T347"><vh>tuplerepr</vh></v>
<v t="T348"><vh>tuplehash</vh></v>
<v t="T349"><vh>tuplelength</vh></v>
<v t="T350"><vh>tuplecontains</vh></v>
<v t="T351"><vh>tupleitem</vh></v>
<v t="T352"><vh>tupleslice</vh></v>
<v t="T353"><vh>PyTuple_GetSlice</vh></v>
<v t="T354"><vh>tupleconcat</vh></v>
<v t="T355"><vh>tuplerepeat</vh></v>
<v t="T356"><vh>tupletraverse</vh></v>
<v t="T357"><vh>tuplerichcompare</vh></v>
<v t="T358"><vh>tuple_new</vh></v>
<v t="T359"><vh>tuple_subtype_new</vh></v>
<v t="T360"><vh>_PyTuple_Resize</vh></v>
<v t="T361"><vh>PyTuple_Fini</vh></v>
</v>
<v t="T362"><vh>listobject.c</vh>
<v t="T363"><vh>&lt;&lt; listobject #includes &gt;&gt;</vh></v>
<v t="T364"><vh>roundupsize</vh></v>
<v t="T365"><vh>PyList_New</vh></v>
<v t="T366"><vh>PyList_Size</vh></v>
<v t="T367"><vh>PyList_GetItem</vh></v>
<v t="T368"><vh>PyList_SetItem</vh></v>
<v t="T369"><vh>ins1</vh></v>
<v t="T370"><vh>PyList_Insert</vh></v>
<v t="T371"><vh>PyList_Append</vh></v>
<v t="T372"><vh>list_dealloc</vh></v>
<v t="T373"><vh>list_print</vh></v>
<v t="T374"><vh>list_repr</vh></v>
<v t="T375"><vh>list_length</vh></v>
<v t="T376"><vh>list_contains</vh></v>
<v t="T377"><vh>list_item</vh></v>
<v t="T378"><vh>list_slice</vh></v>
<v t="T379"><vh>PyList_GetSlice</vh></v>
<v t="T380"><vh>list_concat</vh></v>
<v t="T381"><vh>list_repeat</vh></v>
<v t="T382"><vh>list_ass_slice</vh></v>
<v t="T383"><vh>PyList_SetSlice</vh></v>
<v t="T384"><vh>list_inplace_repeat</vh></v>
<v t="T385"><vh>list_ass_item</vh></v>
<v t="T386"><vh>ins</vh></v>
<v t="T387"><vh>listinsert</vh></v>
<v t="T388"><vh>listappend</vh></v>
<v t="T389"><vh>listextend_internal</vh></v>
<v t="T390"><vh>list_inplace_concat</vh></v>
<v t="T391"><vh>listextend</vh></v>
<v t="T392"><vh>listpop</vh></v>
<v t="T393"><vh>docompare</vh></v>
<v t="T394"><vh>binarysort</vh></v>
<v t="T395"><vh>samplesortslice</vh></v>
<v t="T396"><vh>listsort</vh></v>
<v t="T397"><vh>PyList_Sort</vh></v>
<v t="T398"><vh>_listreverse</vh></v>
<v t="T399"><vh>listreverse</vh></v>
<v t="T400"><vh>PyList_Reverse</vh></v>
<v t="T401"><vh>PyList_AsTuple</vh></v>
<v t="T402"><vh>listindex</vh></v>
<v t="T403"><vh>listcount</vh></v>
<v t="T404"><vh>listremove</vh></v>
<v t="T405"><vh>list_traverse</vh></v>
<v t="T406"><vh>list_clear</vh></v>
<v t="T407"><vh>list_richcompare</vh></v>
<v t="T408"><vh>list_fill</vh></v>
<v t="T409"><vh>list_init</vh></v>
<v t="T410"><vh>list_nohash</vh></v>
<v t="T411"><vh>immutable_list_op</vh></v>
<v t="T412"><vh>immutable_list_ass</vh></v>
</v>
<v t="T413"><vh>fileobject.c</vh>
<v t="T414"><vh>&lt;&lt; fileobject #includes &gt;&gt;</vh></v>
<v t="T415"><vh>&lt;&lt; fileobject declarations &gt;&gt;</vh></v>
<v t="T416"><vh>PyFile_AsFile</vh></v>
<v t="T417"><vh>PyFile_Name</vh></v>
<v t="T418"><vh>fill_file_fields</vh></v>
<v t="T419"><vh>open_the_file</vh></v>
<v t="T420"><vh>PyFile_FromFile</vh></v>
<v t="T421"><vh>PyFile_FromString</vh></v>
<v t="T422"><vh>PyFile_SetBufSize</vh></v>
<v t="T423"><vh>err_closed</vh></v>
<v t="T424"><vh>file_dealloc</vh></v>
<v t="T425"><vh>file_repr</vh></v>
<v t="T426"><vh>file_close</vh></v>
<v t="T427"><vh>_portable_fseek</vh></v>
<v t="T428"><vh>_portable_ftell</vh></v>
<v t="T429"><vh>file_seek</vh></v>
<v t="T430"><vh>file_truncate</vh></v>
<v t="T431"><vh>file_tell</vh></v>
<v t="T432"><vh>file_fileno</vh></v>
<v t="T433"><vh>file_flush</vh></v>
<v t="T434"><vh>file_isatty</vh></v>
<v t="T435"><vh>new_buffersize</vh></v>
<v t="T436"><vh>file_read</vh></v>
<v t="T437"><vh>file_readinto</vh></v>
<v t="T438"><vh>getline_via_fgets</vh></v>
<v t="T439"><vh>get_line</vh></v>
<v t="T440"><vh>PyFile_GetLine</vh></v>
<v t="T441"><vh>file_readline</vh></v>
<v t="T442"><vh>file_xreadlines</vh></v>
<v t="T443"><vh>file_readlines</vh></v>
<v t="T444"><vh>file_write</vh></v>
<v t="T445"><vh>file_writelines</vh></v>
<v t="T446"><vh>get_closed</vh></v>
<v t="T447"><vh>file_getiter</vh></v>
<v t="T448"><vh>file_new</vh></v>
<v t="T449"><vh>file_init</vh></v>
<v t="T450"><vh>PyFile_SoftSpace</vh></v>
<v t="T451"><vh>PyFile_WriteObject</vh></v>
<v t="T452"><vh>PyFile_WriteString</vh></v>
<v t="T453"><vh>PyObject_AsFileDescriptor</vh></v>
</v>
</v>
<v t="T454"><vh>Lib</vh>
<v t="T455"><vh>dis.py</vh>
<v t="T456"><vh>dis (disassemble classes, methods, functions or code)</vh></v>
<v t="T457"><vh>distb (disassemble a traceback)</vh></v>
<v t="T458"><vh>disassemble (disassemble code)</vh></v>
<v t="T459"><vh>findlabels</vh></v>
<v t="T460"><vh>Routines that define opcodes</vh>
<v t="T461"><vh>create tables (at import time)</vh></v>
<v t="T462"><vh>def_op</vh></v>
<v t="T463"><vh>name_op</vh></v>
<v t="T464"><vh>jrel_op</vh></v>
<v t="T465"><vh>jabs_op</vh></v>
</v>
<v t="T466"><vh>Initialize tables &amp; constants (at import time)</vh></v>
<v t="T467"><vh>_test</vh></v>
</v>
</v>
<v t="T468"><vh>Modules</vh>
<v t="T469"><vh>@file python.c</vh>
<v t="T470"><vh>main</vh></v>
</v>
<v t="T471"><vh>@file parsermodule.c</vh>
<v t="T472"><vh>&lt;&lt; parsermodule #includes &gt;&gt;</vh></v>
<v t="T473"><vh>&lt;&lt; parsermodule declarations &gt;&gt;</vh></v>
<v t="T474"><vh>node2tuple</vh></v>
<v t="T475"><vh>parser_compare_nodes</vh></v>
<v t="T476"><vh>parser_compare</vh></v>
<v t="T477"><vh>parser_newstobject</vh></v>
<v t="T478"><vh>parser_free</vh></v>
<v t="T479"><vh>parser_st2tuple</vh></v>
<v t="T480"><vh>parser_st2list</vh></v>
<v t="T481"><vh>parser_compilest</vh></v>
<v t="T482"><vh>parser_isexpr</vh></v>
<v t="T483"><vh>parser_issuite</vh></v>
<v t="T484"><vh>parser_getattr</vh></v>
<v t="T485"><vh>err_string</vh></v>
<v t="T486"><vh>parser_do_parse</vh></v>
<v t="T487"><vh>parser_expr</vh></v>
<v t="T488"><vh>parser_suite</vh></v>
<v t="T489"><vh>parser_tuple2st</vh></v>
<v t="T490"><vh>build_node_children</vh></v>
<v t="T491"><vh>build_node_tree</vh></v>
<v t="T492"><vh>validate_ntype</vh></v>
<v t="T493"><vh>validate_numnodes</vh></v>
<v t="T494"><vh>validate_terminal</vh></v>
<v t="T495"><vh>validate_repeating_list</vh></v>
<v t="T496"><vh>validate_class</vh></v>
<v t="T497"><vh>validate_if</vh></v>
<v t="T498"><vh>validate_parameters</vh></v>
<v t="T499"><vh>validate_suite</vh></v>
<v t="T500"><vh>validate_testlist</vh></v>
<v t="T501"><vh>validate_testlist_safe</vh></v>
<v t="T502"><vh>validate_varargslist_trailer</vh></v>
<v t="T503"><vh>validate_varargslist</vh></v>
<v t="T504"><vh>validate_list_iter</vh></v>
<v t="T505"><vh>validate_list_for</vh></v>
<v t="T506"><vh>validate_list_if</vh></v>
<v t="T507"><vh>validate_fpdef</vh></v>
<v t="T508"><vh>validate_fplist</vh></v>
<v t="T509"><vh>validate_stmt</vh></v>
<v t="T510"><vh>validate_simple_stmt</vh></v>
<v t="T511"><vh>validate_small_stmt</vh></v>
<v t="T512"><vh>validate_compound_stmt</vh></v>
<v t="T513"><vh>validate_expr_stmt</vh></v>
<v t="T514"><vh>validate_print_stmt</vh></v>
<v t="T515"><vh>validate_del_stmt</vh></v>
<v t="T516"><vh>validate_return_stmt</vh></v>
<v t="T517"><vh>validate_raise_stmt</vh></v>
<v t="T518"><vh>validate_yield_stmt</vh></v>
<v t="T519"><vh>validate_import_as_name</vh></v>
<v t="T520"><vh>validate_dotted_name</vh></v>
<v t="T521"><vh>validate_dotted_as_name</vh></v>
<v t="T522"><vh>validate_import_stmt</vh></v>
<v t="T523"><vh>validate_global_stmt</vh></v>
<v t="T524"><vh>validate_exec_stmt</vh></v>
<v t="T525"><vh>validate_assert_stmt</vh></v>
<v t="T526"><vh>validate_while</vh></v>
<v t="T527"><vh>validate_for</vh></v>
<v t="T528"><vh>validate_try</vh></v>
<v t="T529"><vh>validate_except_clause</vh></v>
<v t="T530"><vh>validate_test</vh></v>
<v t="T531"><vh>validate_and_test</vh></v>
<v t="T532"><vh>validate_not_test</vh></v>
<v t="T533"><vh>validate_comparison</vh></v>
<v t="T534"><vh>validate_comp_op</vh></v>
<v t="T535"><vh>validate_expr</vh></v>
<v t="T536"><vh>validate_xor_expr</vh></v>
<v t="T537"><vh>validate_and_expr</vh></v>
<v t="T538"><vh>validate_chain_two_ops</vh></v>
<v t="T539"><vh>validate_shift_expr</vh></v>
<v t="T540"><vh>validate_arith_expr</vh></v>
<v t="T541"><vh>validate_term</vh></v>
<v t="T542"><vh>validate_factor</vh></v>
<v t="T543"><vh>validate_power</vh></v>
<v t="T544"><vh>validate_atom</vh></v>
<v t="T545"><vh>validate_listmaker</vh></v>
<v t="T546"><vh>validate_funcdef</vh></v>
<v t="T547"><vh>validate_lambdef</vh></v>
<v t="T548"><vh>validate_arglist</vh></v>
<v t="T549"><vh>validate_argument</vh></v>
<v t="T550"><vh>validate_trailer</vh></v>
<v t="T551"><vh>validate_subscriptlist</vh></v>
<v t="T552"><vh>validate_subscript</vh></v>
<v t="T553"><vh>validate_sliceop</vh></v>
<v t="T554"><vh>validate_exprlist</vh></v>
<v t="T555"><vh>validate_dictmaker</vh></v>
<v t="T556"><vh>validate_eval_input</vh></v>
<v t="T557"><vh>validate_node</vh></v>
<v t="T558"><vh>validate_expr_tree</vh></v>
<v t="T559"><vh>validate_file_input</vh></v>
<v t="T560"><vh>parser__pickler</vh></v>
<v t="T561"><vh>DL_EXPORT</vh></v>
</v>
<v t="T562"><vh>sysmodule.c (Python)</vh>
<v t="T563"><vh>&lt;&lt; sysmodule declarations &gt;&gt;</vh></v>
<v t="T564"><vh>PySys_GetObject</vh></v>
<v t="T565"><vh>PySys_GetFile</vh></v>
<v t="T566"><vh>PySys_SetObject</vh></v>
<v t="T567"><vh>sys_displayhook</vh></v>
<v t="T568"><vh>sys_excepthook</vh></v>
<v t="T569"><vh>sys_exc_info</vh></v>
<v t="T570"><vh>sys_exit</vh></v>
<v t="T571"><vh>sys_getdefaultencoding</vh></v>
<v t="T572"><vh>sys_setdefaultencoding</vh></v>
<v t="T573"><vh>trace_init</vh></v>
<v t="T574"><vh>call_trampoline</vh></v>
<v t="T575"><vh>profile_trampoline</vh></v>
<v t="T576"><vh>trace_trampoline</vh></v>
<v t="T577"><vh>sys_settrace</vh></v>
<v t="T578"><vh>sys_setprofile</vh></v>
<v t="T579"><vh>sys_setcheckinterval</vh></v>
<v t="T580"><vh>sys_setrecursionlimit</vh></v>
<v t="T581"><vh>sys_getrecursionlimit</vh></v>
<v t="T582"><vh>sys_setdlopenflags</vh></v>
<v t="T583"><vh>sys_getdlopenflags</vh></v>
<v t="T584"><vh>sys_mdebug</vh></v>
<v t="T585"><vh>sys_getrefcount</vh></v>
<v t="T586"><vh>sys_gettotalrefcount</vh></v>
<v t="T587"><vh>sys_getcounts</vh></v>
<v t="T588"><vh>sys_getframe</vh></v>
<v t="T589"><vh>list_builtin_module_names</vh></v>
<v t="T590"><vh>PySys_ResetWarnOptions</vh></v>
<v t="T591"><vh>PySys_AddWarnOption</vh></v>
<v t="T592"><vh>_PySys_Init</vh></v>
<v t="T593"><vh>makepathobject</vh></v>
<v t="T594"><vh>PySys_SetPath</vh></v>
<v t="T595"><vh>makeargvobject</vh></v>
<v t="T596"><vh>PySys_SetArgv</vh></v>
<v t="T597"><vh>mywrite</vh></v>
<v t="T598"><vh>PySys_WriteStdout</vh></v>
<v t="T599"><vh>PySys_WriteStderr</vh></v>
</v>
<v t="T600"><vh>symtablemodule.c</vh>
<v t="T601"><vh>symtable_symtable</vh></v>
<v t="T602"><vh>symtable_methods &amp; init_symtable</vh></v>
</v>
<v t="T603"><vh>import.c (Python)</vh>
<v t="T604"><vh>&lt;&lt; import #includes &gt;&gt;</vh></v>
<v t="T605"><vh>&lt;&lt; import declarations &gt;&gt;</vh></v>
<v t="T606"><vh>_PyImport_Init</vh></v>
<v t="T607"><vh>_PyImport_Fini</vh></v>
<v t="T608"><vh>lock_import</vh></v>
<v t="T609"><vh>unlock_import</vh></v>
<v t="T610"><vh>imp_lock_held</vh></v>
<v t="T611"><vh>PyImport_GetModuleDict</vh></v>
<v t="T612"><vh>PyImport_Cleanup</vh></v>
<v t="T613"><vh>PyImport_GetMagicNumber</vh></v>
<v t="T614"><vh>_PyImport_FixupExtension</vh></v>
<v t="T615"><vh>_PyImport_FindExtension</vh></v>
<v t="T616"><vh>PyImport_AddModule</vh></v>
<v t="T617"><vh>PyImport_ExecCodeModule</vh></v>
<v t="T618"><vh>PyImport_ExecCodeModuleEx</vh></v>
<v t="T619"><vh>make_compiled_pathname</vh></v>
<v t="T620"><vh>check_compiled_module</vh></v>
<v t="T621"><vh>read_compiled_module</vh></v>
<v t="T622"><vh>load_compiled_module</vh></v>
<v t="T623"><vh>parse_source_module</vh></v>
<v t="T624"><vh>open_exclusive</vh></v>
<v t="T625"><vh>write_compiled_module</vh></v>
<v t="T626"><vh>load_source_module</vh></v>
<v t="T627"><vh>load_package</vh></v>
<v t="T628"><vh>is_builtin</vh></v>
</v>
</v>
<v t="T629"><vh>Strings</vh>
<v t="T630"><vh>stringobject.h</vh></v>
<v t="T631"><vh>stringobject.c (the real code)</vh>
<v t="T632"><vh>&lt;&lt; stringobject declarations &gt;&gt;</vh></v>
<v t="T633"><vh>PyString_FromStringAndSize</vh></v>
<v t="T634"><vh>PyString_FromString</vh></v>
<v t="T635"><vh>PyString_FromFormatV</vh></v>
<v t="T636"><vh>PyString_FromFormat</vh></v>
<v t="T637"><vh>PyString_Decode</vh></v>
<v t="T638"><vh>PyString_AsDecodedObject</vh></v>
<v t="T639"><vh>PyString_AsDecodedString</vh></v>
<v t="T640"><vh>PyString_Encode</vh></v>
<v t="T641"><vh>PyString_AsEncodedObject</vh></v>
<v t="T642"><vh>PyString_AsEncodedString</vh></v>
<v t="T643"><vh>string_dealloc</vh></v>
<v t="T644"><vh>string_getsize</vh></v>
<v t="T645"><vh>string_getbuffer</vh></v>
<v t="T646"><vh>PyString_Size</vh></v>
<v t="T647"><vh>PyString_AsString</vh></v>
<v t="T648"><vh>PyString_AsStringAndSize</vh></v>
<v t="T649"><vh>string_print</vh></v>
<v t="T650"><vh>string_repr</vh></v>
<v t="T651"><vh>string_str</vh></v>
<v t="T652"><vh>string_length</vh></v>
<v t="T653"><vh>string_concat</vh></v>
<v t="T654"><vh>string_repeat</vh></v>
<v t="T655"><vh>string_slice</vh></v>
<v t="T656"><vh>string_contains</vh></v>
<v t="T657"><vh>string_item</vh></v>
<v t="T658"><vh>string_richcompare</vh></v>
<v t="T659"><vh>_PyString_Eq</vh></v>
<v t="T660"><vh>string_hash</vh></v>
<v t="T661"><vh>string_buffer_getreadbuf</vh></v>
<v t="T662"><vh>string_buffer_getwritebuf</vh></v>
<v t="T663"><vh>string_buffer_getsegcount</vh></v>
<v t="T664"><vh>string_buffer_getcharbuf</vh></v>
<v t="T665"><vh>split_whitespace</vh></v>
<v t="T666"><vh>string_split</vh></v>
<v t="T667"><vh>string_join</vh></v>
<v t="T668"><vh>_PyString_Join</vh></v>
<v t="T669"><vh>string_find_internal</vh></v>
<v t="T670"><vh>string_find</vh></v>
<v t="T671"><vh>string_index</vh></v>
<v t="T672"><vh>string_rfind</vh></v>
<v t="T673"><vh>string_rindex</vh></v>
<v t="T674"><vh>do_strip</vh></v>
<v t="T675"><vh>string_strip</vh></v>
<v t="T676"><vh>string_lstrip</vh></v>
<v t="T677"><vh>string_rstrip</vh></v>
<v t="T678"><vh>string_lower</vh></v>
<v t="T679"><vh>string_upper</vh></v>
<v t="T680"><vh>string_title</vh></v>
<v t="T681"><vh>string_capitalize</vh></v>
<v t="T682"><vh>string_count</vh></v>
<v t="T683"><vh>string_swapcase</vh></v>
<v t="T684"><vh>string_translate</vh></v>
<v t="T685"><vh>mymemfind</vh></v>
<v t="T686"><vh>mymemcnt</vh></v>
<v t="T687"><vh>mymemreplace</vh></v>
<v t="T688"><vh>string_replace</vh></v>
<v t="T689"><vh>string_startswith</vh></v>
<v t="T690"><vh>string_endswith</vh></v>
<v t="T691"><vh>string_encode</vh></v>
<v t="T692"><vh>string_decode</vh></v>
<v t="T693"><vh>string_expandtabs</vh></v>
<v t="T694"><vh>pad</vh></v>
<v t="T695"><vh>string_ljust</vh></v>
<v t="T696"><vh>string_rjust</vh></v>
<v t="T697"><vh>string_center</vh></v>
<v t="T698"><vh>string_isspace</vh></v>
<v t="T699"><vh>string_isalpha</vh></v>
<v t="T700"><vh>string_isalnum</vh></v>
<v t="T701"><vh>string_isdigit</vh></v>
<v t="T702"><vh>string_islower</vh></v>
<v t="T703"><vh>string_isupper</vh></v>
<v t="T704"><vh>string_istitle</vh></v>
<v t="T705"><vh>string_splitlines</vh></v>
<v t="T706"><vh>string_methods []</vh></v>
<v t="T707"><vh>string_new</vh></v>
<v t="T708"><vh>str_subtype_new</vh></v>
<v t="T709"><vh>PyString_Concat</vh></v>
<v t="T710"><vh>PyString_ConcatAndDel</vh></v>
<v t="T711"><vh>_PyString_Resize</vh></v>
<v t="T712"><vh>getnextarg</vh></v>
<v t="T713"><vh>formatfloat</vh></v>
<v t="T714"><vh>_PyString_FormatLong</vh></v>
<v t="T715"><vh>formatint</vh></v>
<v t="T716"><vh>formatchar</vh></v>
<v t="T717"><vh>PyString_Format</vh></v>
<v t="T718"><vh>Interning...</vh>
<v t="T719"><vh>&lt;&lt; intern methods &gt;&gt;</vh>
<v t="T720"><vh>PyString_InternInPlace</vh></v>
<v t="T721"><vh>PyString_InternFromString</vh></v>
</v>
</v>
<v t="T722"><vh>PyString_Fini</vh></v>
<v t="T723"><vh>_Py_ReleaseInternedStrings</vh></v>
</v>
<v t="T724"><vh>string.py (just uses stringobject code)</vh>
<v t="T725"><vh>&lt;&lt; string declarations &gt;&gt;</vh></v>
<v t="T726"><vh>lower</vh></v>
<v t="T727"><vh>upper</vh></v>
<v t="T728"><vh>swapcase</vh></v>
<v t="T729"><vh>strip</vh></v>
<v t="T730"><vh>lstrip</vh></v>
<v t="T731"><vh>rstrip</vh></v>
<v t="T732"><vh>split</vh></v>
<v t="T733"><vh>join</vh></v>
<v t="T734"><vh>index</vh></v>
<v t="T735"><vh>rindex</vh></v>
<v t="T736"><vh>count</vh></v>
<v t="T737"><vh>find</vh></v>
<v t="T738"><vh>rfind</vh></v>
<v t="T739"><vh>atof</vh></v>
<v t="T740"><vh>atoi</vh></v>
<v t="T741"><vh>atol</vh></v>
<v t="T742"><vh>ljust</vh></v>
<v t="T743"><vh>rjust</vh></v>
<v t="T744"><vh>center</vh></v>
<v t="T745"><vh>zfill</vh></v>
<v t="T746"><vh>expandtabs</vh></v>
<v t="T747"><vh>translate</vh></v>
<v t="T748"><vh>capitalize</vh></v>
<v t="T749"><vh>capwords</vh></v>
<v t="T750"><vh>maketrans</vh></v>
<v t="T751"><vh>replace</vh></v>
</v>
<v t="T752"><vh>stropmodule.c (old)</vh>
<v t="T753"><vh>split_whitespace</vh></v>
<v t="T754"><vh>strop_splitfields</vh></v>
<v t="T755"><vh>strop_joinfields</vh></v>
<v t="T756"><vh>strop_find</vh></v>
<v t="T757"><vh>strop_rfind</vh></v>
<v t="T758"><vh>do_strip</vh></v>
<v t="T759"><vh>strop_strip</vh></v>
<v t="T760"><vh>strop_lstrip</vh></v>
<v t="T761"><vh>strop_rstrip</vh></v>
<v t="T762"><vh>strop_lower</vh></v>
<v t="T763"><vh>strop_upper</vh></v>
<v t="T764"><vh>strop_capitalize</vh></v>
<v t="T765"><vh>strop_expandtabs</vh></v>
<v t="T766"><vh>strop_count</vh></v>
<v t="T767"><vh>strop_swapcase</vh></v>
<v t="T768"><vh>strop_atoi</vh></v>
<v t="T769"><vh>strop_atol</vh></v>
<v t="T770"><vh>strop_atof</vh></v>
<v t="T771"><vh>strop_maketrans</vh></v>
<v t="T772"><vh>strop_translate</vh></v>
<v t="T773"><vh>mymemfind</vh></v>
<v t="T774"><vh>mymemcnt</vh></v>
<v t="T775"><vh>mymemreplace</vh></v>
<v t="T776"><vh>strop_replace</vh></v>
<v t="T777"><vh>DL_EXPORT</vh></v>
</v>
</v>
<v t="T778"><vh>Import </vh>
<v t="T779"><vh>Code</vh>
<v t="T780" a="C"><vh>PyEval_CallObjectWithKeywords</vh></v>
<v t="T781" a="C"><vh>PyEval_CallObject (ceval)</vh></v>
<v t="T145" a="C"><vh>PyObject_Call (abstract.c)</vh></v>
</v>
<v t="T782"><vh>@file c:/prog/test/importTest.py</vh></v>
<v t="T783"><vh>post 1</vh></v>
<v t="T784"><vh>re imports</vh>
<v t="T785"><vh>Language reference</vh></v>
<v t="T786"><vh>Interpreter code</vh>
<v t="T787"><vh>helper routines in ceval.c</vh>
<v t="T788"><vh>PyFrame_FastToLocals and PyFrame_LocalsToFast</vh></v>
</v>
</v>
<v t="T789"><vh>Understanding the import code</vh></v>
</v>
<v t="T790" a="C"><vh>&lt;&lt; import cases &gt;&gt;</vh></v>
<v t="T791" a="C"><vh>import...</vh>
<v t="T792"><vh>import_from</vh></v>
<v t="T793"><vh>import_all_from</vh></v>
</v>
</v>
<v t="T794"><vh>(Speed related)</vh>
<v t="T795"><vh>Interpreter</vh>
<v t="T796"><vh>The real main line</vh></v>
<v t="T797"><vh>Common cases simplified</vh>
<v t="T798"><vh>Macros (expanded)</vh></v>
<v t="T799"><vh>line number</vh></v>
<v t="T800"><vh>load</vh></v>
<v t="T801"><vh>store</vh></v>
</v>
<v t="T802" a="C"><vh>&lt;&lt; define macros &gt;&gt;</vh></v>
<v t="T803" a="C"><vh>&lt;&lt; set_lineno case &gt;&gt;</vh></v>
<v t="T804" a="C"><vh>&lt;&lt; load cases &gt;&gt;</vh></v>
<v t="T805" a="C"><vh>&lt;&lt; store cases &gt;&gt;</vh></v>
<v t="T806" a="C"><vh>&lt;&lt; flow-of-control cases &gt;&gt;</vh></v>
</v>
<v t="T807"><vh>Objects</vh>
<v t="T304" a="C"><vh>PyObject_GetAttr  -- EKR: a crucial routine ??</vh></v>
<v t="T267" a="C"><vh>object.c (Contains PyObject protocol)</vh>
<v t="T268"><vh>&lt;&lt; #includes &gt;&gt;</vh></v>
<v t="T269"><vh>Counts...</vh>
<v t="T270"><vh>dump_counts</vh></v>
<v t="T271"><vh>get_counts</vh></v>
<v t="T272"><vh>inc_count</vh></v>
</v>
<v t="T273"><vh>PyObject_Init</vh></v>
<v t="T274"><vh>PyObject_InitVar</vh></v>
<v t="T275"><vh>_PyObject_New</vh></v>
<v t="T276"><vh>_PyObject_NewVar</vh></v>
<v t="T277"><vh>_PyObject_Del</vh></v>
<v t="T278"><vh>PyObject_Print</vh></v>
<v t="T279"><vh>_PyObject_Dump</vh></v>
<v t="T280"><vh>PyObject_Repr</vh></v>
<v t="T281"><vh>PyObject_Str</vh></v>
<v t="T282"><vh>PyObject_Unicode</vh></v>
<v t="T283"><vh>try_rich_compare</vh></v>
<v t="T284"><vh>try_rich_compare_bool</vh></v>
<v t="T285"><vh>try_rich_to_3way_compare</vh></v>
<v t="T286"><vh>try_3way_compare</vh></v>
<v t="T287"><vh>default_3way_compare</vh></v>
<v t="T288"><vh>do_cmp</vh></v>
<v t="T289"><vh>get_inprogress_dict</vh></v>
<v t="T290"><vh>check_recursion</vh></v>
<v t="T291"><vh>delete_token</vh></v>
<v t="T292"><vh>PyObject_Compare</vh></v>
<v t="T293"><vh>convert_3way_to_object</vh></v>
<v t="T294"><vh>try_3way_to_rich_compare</vh></v>
<v t="T295"><vh>do_richcmp</vh></v>
<v t="T296"><vh>PyObject_RichCompare</vh></v>
<v t="T297"><vh>PyObject_RichCompareBool</vh></v>
<v t="T298"><vh>_Py_HashDouble</vh></v>
<v t="T299"><vh>_Py_HashPointer</vh></v>
<v t="T300"><vh>PyObject_Hash</vh></v>
<v t="T301"><vh>PyObject_GetAttrString</vh></v>
<v t="T302"><vh>PyObject_HasAttrString</vh></v>
<v t="T303"><vh>PyObject_SetAttrString</vh></v>
<v t="T304" a="C"><vh>PyObject_GetAttr  -- EKR: a crucial routine ??</vh></v>
<v t="T305"><vh>PyObject_HasAttr</vh></v>
<v t="T306"><vh>PyObject_SetAttr</vh></v>
<v t="T307"><vh>_PyObject_GetDictPtr</vh></v>
<v t="T308"><vh>PyObject_GenericGetAttr</vh></v>
<v t="T309"><vh>PyObject_GenericSetAttr</vh></v>
<v t="T310"><vh>PyObject_IsTrue</vh></v>
<v t="T311"><vh>PyObject_Not</vh></v>
<v t="T312"><vh>PyNumber_CoerceEx</vh></v>
<v t="T313"><vh>PyNumber_Coerce</vh></v>
<v t="T314"><vh>PyCallable_Check</vh></v>
<v t="T315"><vh>merge_class_dict</vh></v>
<v t="T316"><vh>merge_list_attr</vh></v>
<v t="T317"><vh>PyObject_Dir</vh></v>
<v t="T318"><vh>none_repr</vh></v>
<v t="T319"><vh>none_dealloc</vh></v>
<v t="T320"><vh>NotImplemented_repr</vh></v>
<v t="T321"><vh>_Py_ReadyTypes</vh></v>
<v t="T322"><vh>_Py_ResetReferences</vh></v>
<v t="T323"><vh>_Py_NewReference</vh></v>
<v t="T324"><vh>_Py_ForgetReference</vh></v>
<v t="T325"><vh>_Py_Dealloc</vh></v>
<v t="T326"><vh>_Py_PrintReferences</vh></v>
<v t="T327"><vh>_Py_GetObjects</vh></v>
<v t="T328"><vh>PyMem_Malloc</vh></v>
<v t="T329"><vh>PyMem_Realloc</vh></v>
<v t="T330"><vh>PyMem_Free</vh></v>
<v t="T331"><vh>PyObject_Malloc</vh></v>
<v t="T332"><vh>PyObject_Realloc</vh></v>
<v t="T333"><vh>PyObject_Free</vh></v>
<v t="T334"><vh>Py_ReprEnter</vh></v>
<v t="T335"><vh>Py_ReprLeave</vh></v>
<v t="T336"><vh>_PyTrash_deposit_object</vh></v>
<v t="T337"><vh>_PyTrash_destroy_chain</vh></v>
</v>
</v>
</v>
<v t="T808"><vh>Python (interp)</vh>
<v t="T809" a="M"><vh>ceval.c (main interpreter)</vh>
<v t="T810"><vh>&lt;&lt; ceval #includes &gt;&gt;</vh></v>
<v t="T811"><vh>&lt;&lt; ceval declarations &gt;&gt;</vh>
<v t="T812"><vh>&lt;&lt; declare static functions &gt;&gt;</vh></v>
<v t="T813"><vh>&lt;&lt; define error messages &gt;&gt;</vh></v>
</v>
<v t="T814" a="M"><vh>eval_frame (main interp)</vh>
<v t="T815"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="T802" a="C"><vh>&lt;&lt; define macros &gt;&gt;</vh></v>
<v t="T816"><vh>&lt;&lt; initialize &gt;&gt;</vh>
<v t="T817"><vh>&lt;&lt; initialize tracing &gt;&gt;</vh></v>
</v>
<v t="T818"><vh>&lt;&lt; start loop &gt;&gt;</vh>
<v t="T819"><vh>&lt;&lt; handle periodic things &gt;&gt;</vh></v>
<v t="T820"><vh>&lt;&lt; set f-&gt;f_lasti if debugging or tracing &gt;&gt;</vh></v>
<v t="T821"><vh>&lt;&lt; handle tracing and profiling &gt;&gt;</vh></v>
</v>
<v t="T822"><vh>&lt;&lt; opcode cases &gt;&gt;</vh>
<v t="T823"><vh>&lt;&lt; arithmetic cases &gt;&gt;</vh></v>
<v t="T824"><vh>&lt;&lt; build, const, unpack cases &gt;&gt;</vh></v>
<v t="T825"><vh>&lt;&lt; call cases &gt;&gt;</vh></v>
<v t="T826"><vh>&lt;&lt; compare cases &gt;&gt;</vh></v>
<v t="T827"><vh>&lt;&lt; default case &gt;&gt;</vh></v>
<v t="T828"><vh>&lt;&lt; delete cases &gt;&gt;</vh></v>
<v t="T829"><vh>&lt;&lt; extended arg case &gt;&gt;</vh></v>
<v t="T806" a="C"><vh>&lt;&lt; flow-of-control cases &gt;&gt;</vh></v>
<v t="T790" a="C"><vh>&lt;&lt; import cases &gt;&gt;</vh></v>
<v t="T830"><vh>&lt;&lt; jump case &gt;&gt;</vh></v>
<v t="T804" a="C"><vh>&lt;&lt; load cases &gt;&gt;</vh></v>
<v t="T831"><vh>&lt;&lt; make cases &gt;&gt;</vh></v>
<v t="T832"><vh>&lt;&lt; print cases &gt;&gt;</vh></v>
<v t="T803" a="C"><vh>&lt;&lt; set_lineno case &gt;&gt;</vh></v>
<v t="T833"><vh>&lt;&lt; stack cases &gt;&gt;</vh></v>
<v t="T805" a="C"><vh>&lt;&lt; store cases &gt;&gt;</vh></v>
<v t="T834"><vh>&lt;&lt; string cases &gt;&gt;</vh></v>
<v t="T835"><vh>&lt;&lt; subscript cases &gt;&gt;</vh></v>
</v>
<v t="T836"><vh>&lt;&lt; end loop &gt;&gt;</vh></v>
<v t="T837"><vh>&lt;&lt; finalize &gt;&gt;</vh></v>
</v>
<v t="T838"><vh>PyEval... Helpers that may be called externally</vh>
<v t="T839"><vh>Asynchronous callbacks</vh>
<v t="T840"><vh>Py_AddPendingCall</vh></v>
<v t="T841"><vh>Py_MakePendingCalls</vh></v>
</v>
<v t="T780" a="C"><vh>PyEval_CallObjectWithKeywords</vh></v>
<v t="T781" a="C"><vh>PyEval_CallObject (ceval)</vh></v>
<v t="T842"><vh>PyEval_EvalCode &amp; why_code</vh></v>
<v t="T843"><vh>PyEval_EvalCodeEx</vh></v>
<v t="T844"><vh>PyEval... Getters &amp; Setters &amp; Py_Get/SetRecursionLimit</vh>
<v t="T845"><vh>Py_GetRecursionLimit</vh></v>
<v t="T846"><vh>Py_SetRecursionLimit</vh></v>
<v t="T847"><vh>PyEval_GetBuiltins</vh></v>
<v t="T848"><vh>PyEval_GetFrame</vh></v>
<v t="T849"><vh>PyEval_GetFuncDesc</vh></v>
<v t="T850"><vh>PyEval_GetFuncName</vh></v>
<v t="T851"><vh>PyEval_GetGlobals</vh></v>
<v t="T852"><vh>PyEval_GetLocals</vh></v>
<v t="T853"><vh>PyEval_GetRestricted</vh></v>
<v t="T854"><vh>PyEval_SetProfile</vh></v>
<v t="T855"><vh>PyEval_SetTrace</vh></v>
</v>
<v t="T856"><vh>PyEval_MergeCompilerFlags</vh></v>
<v t="T857"><vh>PyEval...Threads...</vh>
<v t="T858"><vh>PyEval_InitThreads</vh></v>
<v t="T859"><vh>PyEval_AcquireLock</vh></v>
<v t="T860"><vh>PyEval_ReleaseLock</vh></v>
<v t="T861"><vh>PyEval_AcquireThread</vh></v>
<v t="T862"><vh>PyEval_ReleaseThread</vh></v>
<v t="T863"><vh>PyEval_ReInitThreads</vh></v>
<v t="T864"><vh>PyEval_SaveThread</vh></v>
<v t="T865"><vh>PyEval_RestoreThread</vh></v>
</v>
</v>
<v t="T866"><vh>static methods</vh>
<v t="T867"><vh>_Py_GetDXProfile</vh></v>
<v t="T868"><vh>build_class</vh></v>
<v t="T869"><vh>cmp_outcome</vh></v>
<v t="T870"><vh>exceptions &amp; errors...</vh>
<v t="T871"><vh>do_raise</vh></v>
<v t="T872"><vh>format_exc_check_arg</vh></v>
<v t="T873"><vh>reset_exc_info</vh></v>
<v t="T874"><vh>set_exc_info</vh></v>
</v>
<v t="T875"><vh>exec_statement</vh></v>
<v t="T876"><vh>function calls...</vh>
<v t="T877"><vh>fast_cfunction</vh></v>
<v t="T878"><vh>fast_function</vh></v>
<v t="T879"><vh>update_keyword_args</vh></v>
<v t="T880"><vh>update_star_args</vh></v>
<v t="T881"><vh>load_args (calls PyTuple_SET_ITEM)</vh></v>
<v t="T882"><vh>do_call (calls PyObject_Call)</vh></v>
<v t="T883"><vh>ext_do_call (expensive)</vh></v>
</v>
<v t="T884"><vh>gen_ ... (generators and iterators)</vh>
<v t="T885"><vh>gen_new</vh></v>
<v t="T886"><vh>gen_traverse</vh></v>
<v t="T887"><vh>gen_dealloc</vh></v>
<v t="T888"><vh>gen_iternext</vh></v>
<v t="T889"><vh>gen_next</vh></v>
<v t="T890"><vh>gen_getiter</vh></v>
</v>
<v t="T891"><vh>getarray</vh></v>
<v t="T791" a="C"><vh>import...</vh>
<v t="T792"><vh>import_from</vh></v>
<v t="T793"><vh>import_all_from</vh></v>
</v>
<v t="T892"><vh>loop_subscript</vh></v>
<v t="T893"><vh>slices...</vh>
<v t="T894"><vh>_PyEval_SliceIndex</vh></v>
<v t="T895"><vh>apply_slice</vh></v>
<v t="T896"><vh>assign_slice</vh></v>
</v>
<v t="T897"><vh>tracing...</vh>
<v t="T898"><vh>prtrace</vh></v>
<v t="T899"><vh>call_exc_trace</vh></v>
<v t="T900"><vh>call_trace_protected</vh></v>
<v t="T901"><vh>call_trace</vh></v>
<v t="T902"><vh>Py_FlushLine</vh></v>
</v>
<v t="T903"><vh>unpack_iterable</vh></v>
</v>
</v>
<v t="T904"><vh>frozenmain.c</vh>
<v t="T905"><vh>&lt;&lt; frozenmain #includes &gt;&gt;</vh></v>
<v t="T906"><vh>&lt;&lt; frozenmain declarations &gt;&gt;</vh></v>
<v t="T907"><vh>Py_FrozenMain</vh></v>
</v>
<v t="T908"><vh>import.c</vh>
<v t="T909"><vh>&lt;&lt; import #includes &gt;&gt;</vh></v>
<v t="T910"><vh>&lt;&lt; import declarations &gt;&gt;</vh></v>
<v t="T911"><vh>_PyImport_Init</vh></v>
<v t="T912"><vh>_PyImport_Fini</vh></v>
<v t="T913"><vh>lock_import</vh></v>
<v t="T914"><vh>unlock_import</vh></v>
<v t="T915"><vh>imp_lock_held</vh></v>
<v t="T916"><vh>PyImport_GetModuleDict</vh></v>
<v t="T917"><vh>PyImport_Cleanup</vh></v>
<v t="T918"><vh>PyImport_GetMagicNumber</vh></v>
<v t="T919"><vh>_PyImport_FixupExtension</vh></v>
<v t="T920"><vh>_PyImport_FindExtension</vh></v>
<v t="T921"><vh>PyImport_AddModule</vh></v>
<v t="T922"><vh>PyImport_ExecCodeModule</vh></v>
<v t="T923"><vh>PyImport_ExecCodeModuleEx</vh></v>
<v t="T924"><vh>make_compiled_pathname</vh></v>
<v t="T925"><vh>check_compiled_module</vh></v>
<v t="T926"><vh>read_compiled_module</vh></v>
<v t="T927"><vh>load_compiled_module</vh></v>
<v t="T928"><vh>parse_source_module</vh></v>
<v t="T929"><vh>open_exclusive</vh></v>
<v t="T930"><vh>write_compiled_module</vh></v>
<v t="T931"><vh>load_source_module</vh></v>
<v t="T932"><vh>load_package</vh></v>
<v t="T933"><vh>is_builtin</vh></v>
</v>
<v t="T934"><vh>pythonrun.c (contains compile &amp; parse entries)</vh>
<v t="T935"><vh>&lt;&lt; pythonrun #includes &gt;&gt;</vh></v>
<v t="T936"><vh>&lt;&lt; pythonrun declarations &gt;&gt;</vh></v>
<v t="T937"><vh>Start and end...</vh>
<v t="T938"><vh>Py_IsInitialized</vh></v>
<v t="T939"><vh>add_flag</vh></v>
<v t="T940"><vh>Py_Initialize</vh></v>
<v t="T941"><vh>Py_Finalize</vh></v>
<v t="T942"><vh>Py_NewInterpreter</vh></v>
<v t="T943"><vh>Py_EndInterpreter</vh></v>
<v t="T944"><vh>Py_SetProgramName</vh></v>
<v t="T945"><vh>Py_GetProgramName</vh></v>
<v t="T946"><vh>Py_SetPythonHome</vh></v>
<v t="T947"><vh>Py_GetPythonHome</vh></v>
<v t="T948"><vh>initmain</vh></v>
<v t="T949"><vh>initsite</vh></v>
</v>
<v t="T950"><vh>PyRun... &amp; run... &amp; errors</vh>
<v t="T951"><vh>PyRun_AnyFile</vh></v>
<v t="T952"><vh>PyRun_AnyFileFlags</vh></v>
<v t="T953"><vh>PyRun_AnyFileEx</vh></v>
<v t="T954"><vh>PyRun_AnyFileExFlags</vh></v>
<v t="T955"><vh>PyRun_InteractiveLoop</vh></v>
<v t="T956"><vh>PyRun_InteractiveLoopFlags</vh></v>
<v t="T957"><vh>PyRun_InteractiveOne</vh></v>
<v t="T958"><vh>PyRun_InteractiveOneFlags</vh></v>
<v t="T959"><vh>PyRun_SimpleFile</vh></v>
<v t="T960"><vh>maybe_pyc_file</vh></v>
<v t="T961"><vh>PyRun_SimpleFileEx</vh></v>
<v t="T962"><vh>PyRun_SimpleFileExFlags</vh></v>
<v t="T963"><vh>PyRun_SimpleString</vh></v>
<v t="T964"><vh>PyRun_SimpleStringFlags</vh></v>
<v t="T965"><vh>Errors...</vh>
<v t="T966"><vh>parse_syntax_error</vh></v>
<v t="T967"><vh>PyErr_Print</vh></v>
<v t="T968"><vh>print_error_text</vh></v>
<v t="T969"><vh>handle_system_exit</vh></v>
<v t="T970"><vh>PyErr_PrintEx</vh></v>
<v t="T971"><vh>PyErr_Display</vh></v>
</v>
<v t="T972"><vh>PyRun_String</vh></v>
<v t="T973"><vh>PyRun_File</vh></v>
<v t="T974"><vh>PyRun_FileEx</vh></v>
<v t="T975"><vh>PyRun_StringFlags</vh></v>
<v t="T976"><vh>PyRun_FileFlags</vh></v>
<v t="T977"><vh>PyRun_FileExFlags</vh></v>
<v t="T978"><vh>run_err_node</vh></v>
<v t="T979"><vh>run_node</vh></v>
<v t="T980"><vh>run_pyc_file</vh></v>
</v>
<v t="T981"><vh>Compile and parse</vh>
<v t="T982"><vh>Py_CompileString</vh></v>
<v t="T983"><vh>Py_CompileStringFlags (called from compile builtin)</vh></v>
<v t="T984"><vh>Py_SymtableString</vh></v>
<v t="T985"><vh>PyParser_SimpleParseFileFlags</vh></v>
<v t="T986"><vh>PyParser_SimpleParseFile</vh></v>
<v t="T987"><vh>PyParser_SimpleParseStringFlags</vh></v>
<v t="T988"><vh>PyParser_SimpleParseString</vh></v>
</v>
<v t="T989"><vh>General errors</vh>
<v t="T990"><vh>err_input</vh></v>
<v t="T991"><vh>Py_FatalError</vh></v>
<v t="T992"><vh>Py_AtExit</vh></v>
<v t="T993"><vh>call_sys_exitfunc</vh></v>
<v t="T994"><vh>call_ll_exitfuncs</vh></v>
<v t="T995"><vh>Py_Exit</vh></v>
</v>
<v t="T996"><vh>Signals...</vh>
<v t="T997"><vh>initsigs</vh></v>
<v t="T998"><vh>_Py_AskYesNo</vh></v>
<v t="T999"><vh>isatty</vh></v>
<v t="T1000"><vh>Py_FdIsInteractive</vh></v>
<v t="T1001"><vh>PyOS_CheckStack</vh></v>
<v t="T1002"><vh>PyOS_getsig</vh></v>
<v t="T1003"><vh>PyOS_setsig</vh></v>
</v>
</v>
</v>
<v t="T1004"><vh>bltinmodule.c (Python)</vh>
<v t="T1005"><vh>&lt;&lt; bltinmodule #includes &gt;&gt;</vh></v>
<v t="T1006"><vh>&lt;&lt; bltinmodule declarations &gt;&gt;</vh></v>
<v t="T1007"><vh>builtin___import__</vh></v>
<v t="T1008"><vh>builtin_abs</vh></v>
<v t="T1009"><vh>builtin_apply</vh></v>
<v t="T1010"><vh>builtin_bool</vh></v>
<v t="T1011"><vh>builtin_buffer</vh></v>
<v t="T1012"><vh>builtin_callable</vh></v>
<v t="T1013"><vh>builtin_filter</vh></v>
<v t="T1014"><vh>builtin_chr</vh></v>
<v t="T1015"><vh>builtin_unichr</vh></v>
<v t="T1016"><vh>builtin_cmp</vh></v>
<v t="T1017"><vh>builtin_coerce</vh></v>
<v t="T1018" a="C"><vh>builtin_compile (calls Py_CompileStringFlags)</vh></v>
<v t="T1019"><vh>builtin_dir</vh></v>
<v t="T1020"><vh>builtin_divmod</vh></v>
<v t="T1021"><vh>builtin_eval</vh></v>
<v t="T1022"><vh>builtin_execfile</vh></v>
<v t="T1023"><vh>builtin_getattr</vh></v>
<v t="T1024"><vh>builtin_globals</vh></v>
<v t="T1025"><vh>builtin_hasattr</vh></v>
<v t="T1026"><vh>builtin_id</vh></v>
<v t="T1027"><vh>builtin_map</vh></v>
<v t="T1028"><vh>builtin_setattr</vh></v>
<v t="T1029"><vh>builtin_delattr</vh></v>
<v t="T1030"><vh>builtin_hash</vh></v>
<v t="T1031"><vh>builtin_hex</vh></v>
<v t="T1032"><vh>builtin_input</vh></v>
<v t="T1033"><vh>builtin_intern</vh></v>
<v t="T1034"><vh>builtin_iter</vh></v>
<v t="T1035"><vh>builtin_len</vh></v>
<v t="T1036"><vh>builtin_slice</vh></v>
<v t="T1037"><vh>builtin_locals</vh></v>
<v t="T1038"><vh>min_max</vh></v>
<v t="T1039"><vh>builtin_min</vh></v>
<v t="T1040"><vh>builtin_max</vh></v>
<v t="T1041"><vh>builtin_oct</vh></v>
<v t="T1042"><vh>builtin_ord</vh></v>
<v t="T1043"><vh>builtin_pow</vh></v>
<v t="T1044"><vh>get_len_of_range</vh></v>
<v t="T1045"><vh>builtin_range</vh></v>
<v t="T1046"><vh>builtin_xrange</vh></v>
<v t="T1047"><vh>builtin_raw_input</vh></v>
<v t="T1048"><vh>builtin_reduce</vh></v>
<v t="T1049"><vh>builtin_reload</vh></v>
<v t="T1050"><vh>builtin_repr</vh></v>
<v t="T1051"><vh>builtin_round</vh></v>
<v t="T1052"><vh>builtin_vars</vh></v>
<v t="T1053"><vh>builtin_isinstance</vh></v>
<v t="T1054"><vh>builtin_issubclass</vh></v>
<v t="T1055"><vh>builtin_zip</vh></v>
<v t="T1056"><vh>_PyBuiltin_Init</vh></v>
<v t="T1057"><vh>filtertuple</vh></v>
<v t="T1058"><vh>filterstring</vh></v>
</v>
<v t="T1059"><vh>Compiler</vh>
<v t="T1060"><vh>Headers for compiler</vh>
<v t="T1061"><vh>compile.h (contains PyCodeObject)</vh></v>
<v t="T1062"><vh>node.h (parse tree nodes)</vh></v>
<v t="T56" a="C"><vh>opcode.h</vh></v>
</v>
<v t="T1063" a="C"><vh>jcompile (The compiler main line -- calls compile node) (compile.c)</vh></v>
<v t="T1064" a="C"><vh>compile_node (compile.c -- top level interface)</vh></v>
<v t="T1065" a="C"><vh>com_file_input  (compile.c)</vh></v>
<v t="T1018" a="C"><vh>builtin_compile (calls Py_CompileStringFlags)</vh></v>
<v t="T1066"><vh>compile.c (Python) PyNode_Compile...</vh>
<v t="T1067"><vh>&lt;&lt; compile #includes &gt;&gt;</vh></v>
<v t="T1068"><vh>&lt;&lt; compile declarations &gt;&gt;</vh></v>
<v t="T1069"><vh>code_ ...</vh>
<v t="T1070"><vh>code_dealloc</vh></v>
<v t="T1071"><vh>code_repr</vh></v>
<v t="T1072"><vh>code_compare</vh></v>
<v t="T1073"><vh>code_hash</vh></v>
</v>
<v t="T1074"><vh>PyCode_Type table</vh></v>
<v t="T1075"><vh>all_name_chars</vh></v>
<v t="T1076"><vh>intern_strings</vh></v>
<v t="T1077"><vh>PyCode_New</vh></v>
<v t="T1078"><vh>About the compiler</vh></v>
<v t="T1079"><vh>About c_lnotab</vh></v>
<v t="T1080"><vh>struct compiling</vh></v>
<v t="T1081"><vh>is_free</vh></v>
<v t="T1082"><vh>com_error</vh></v>
<v t="T1083"><vh>Interface to block stack</vh>
<v t="T1084"><vh>block_push</vh></v>
<v t="T1085"><vh>block_pop</vh></v>
</v>
<v t="T1086"><vh>Prototype forward declarations...</vh></v>
<v t="T1087"><vh>do_pad</vh></v>
<v t="T1088"><vh>dump</vh></v>
<v t="T1089"><vh>com_ ... (parsers and code generators)</vh>
<v t="T1090"><vh>init &amp; done</vh>
<v t="T1091"><vh>com_init</vh></v>
<v t="T1092"><vh>com_free</vh></v>
<v t="T1093"><vh>com_push</vh></v>
<v t="T1094"><vh>com_pop</vh></v>
<v t="T1095"><vh>com_done</vh></v>
</v>
<v t="T1096"><vh>code generators...</vh>
<v t="T1097"><vh>com_check_size</vh></v>
<v t="T1098"><vh>com_addbyte</vh></v>
<v t="T1099"><vh>com_addint</vh></v>
<v t="T1100"><vh>com_add_lnotab</vh></v>
<v t="T1101"><vh>com_set_lineno</vh></v>
<v t="T1102"><vh>com_addoparg</vh></v>
<v t="T1103"><vh>com_addfwref</vh></v>
<v t="T1104"><vh>com_backpatch</vh></v>
<v t="T1105"><vh>com_add</vh></v>
<v t="T1106"><vh>com_addconst</vh></v>
<v t="T1107"><vh>com_addname</vh></v>
<v t="T1108"><vh>mangle</vh></v>
<v t="T1109"><vh>com_addop_name</vh></v>
<v t="T1110"><vh>com_lookup_arg</vh></v>
<v t="T1111"><vh>com_addop_varname</vh></v>
<v t="T1112"><vh>com_addopname</vh></v>
</v>
<v t="T1113"><vh>misc parsers...</vh>
<v t="T1114"><vh>parsenumber</vh></v>
<v t="T1115"><vh>parsestr</vh></v>
<v t="T1116"><vh>parsestrplus</vh></v>
<v t="T1117"><vh>com_list_for</vh></v>
<v t="T1118"><vh>com_list_if</vh></v>
<v t="T1119"><vh>com_list_iter</vh></v>
<v t="T1120"><vh>com_list_comprehension</vh></v>
<v t="T1121"><vh>com_listmaker</vh></v>
<v t="T1122"><vh>com_dictmaker</vh></v>
<v t="T1123"><vh>com_atom</vh></v>
<v t="T1124"><vh>com_slice</vh></v>
<v t="T1125"><vh>com_augassign_slice</vh></v>
<v t="T1126"><vh>com_argument</vh></v>
<v t="T1127"><vh>com_call_function</vh></v>
<v t="T1128"><vh>com_select_member</vh></v>
<v t="T1129"><vh>com_sliceobj</vh></v>
<v t="T1130"><vh>com_subscript</vh></v>
<v t="T1131"><vh>com_subscriptlist</vh></v>
<v t="T1132"><vh>com_apply_trailer</vh></v>
</v>
<v t="T1133"><vh>expressions...</vh>
<v t="T1134"><vh>com_power</vh></v>
<v t="T1135"><vh>com_invert_constant</vh></v>
<v t="T1136"><vh>is_float_zero</vh></v>
<v t="T1137"><vh>com_factor</vh></v>
<v t="T1138"><vh>com_term</vh></v>
<v t="T1139"><vh>com_arith_expr</vh></v>
<v t="T1140"><vh>com_shift_expr</vh></v>
<v t="T1141"><vh>com_and_expr</vh></v>
<v t="T1142"><vh>com_xor_expr</vh></v>
<v t="T1143"><vh>com_expr</vh></v>
<v t="T1144"><vh>cmp_type</vh></v>
<v t="T1145"><vh>com_comparison</vh></v>
<v t="T1146"><vh>com_not_test</vh></v>
<v t="T1147"><vh>com_and_test</vh></v>
<v t="T1148"><vh>com_make_closure</vh></v>
<v t="T1149"><vh>com_test</vh></v>
<v t="T1150"><vh>com_list</vh></v>
</v>
<v t="T1151"><vh>statements...</vh>
<v t="T1152"><vh>com_augassign_attr</vh></v>
<v t="T1153"><vh>com_assign_attr</vh></v>
<v t="T1154"><vh>com_assign_trailer</vh></v>
<v t="T1155"><vh>com_assign_sequence</vh></v>
<v t="T1156"><vh>com_augassign_name</vh></v>
<v t="T1157"><vh>com_assign_name</vh></v>
<v t="T1158"><vh>com_assign</vh></v>
<v t="T1159"><vh>com_augassign</vh></v>
<v t="T1160"><vh>com_expr_stmt</vh></v>
<v t="T1161"><vh>com_assert_stmt</vh></v>
<v t="T1162"><vh>com_print_stmt</vh></v>
<v t="T1163"><vh>com_return_stmt</vh></v>
<v t="T1164"><vh>com_yield_stmt</vh></v>
<v t="T1165"><vh>com_raise_stmt</vh></v>
<v t="T1166"><vh>com_from_import</vh></v>
<v t="T1167"><vh>com_import_stmt</vh></v>
<v t="T1168"><vh>com_exec_stmt</vh></v>
<v t="T1169"><vh>is_constant_false</vh></v>
<v t="T1170"><vh>look_for_offending_return</vh></v>
<v t="T1171"><vh>com_if_stmt</vh></v>
<v t="T1172"><vh>com_while_stmt</vh></v>
<v t="T1173"><vh>com_for_stmt</vh></v>
<v t="T1174"><vh>com_try_except</vh></v>
<v t="T1175"><vh>com_try_finally</vh></v>
<v t="T1176"><vh>com_try_stmt</vh></v>
<v t="T1177"><vh>get_rawdocstring</vh></v>
<v t="T1178"><vh>get_docstring</vh></v>
<v t="T1179"><vh>com_suite</vh></v>
<v t="T1180"><vh>com_continue_stmt</vh></v>
</v>
<v t="T1181"><vh>functions and classes</vh>
<v t="T1182"><vh>com_argdefs</vh></v>
<v t="T1183"><vh>com_funcdef</vh></v>
<v t="T1184"><vh>com_bases</vh></v>
<v t="T1185"><vh>com_classdef</vh></v>
<v t="T1186"><vh>com_node</vh></v>
<v t="T1187"><vh>com_fpdef</vh></v>
<v t="T1188"><vh>com_fplist</vh></v>
<v t="T1189"><vh>com_arglist</vh></v>
</v>
<v t="T1065" a="C"><vh>com_file_input  (compile.c)</vh></v>
</v>
<v t="T1190"><vh>top level node interface:  compile..., PyNode...  i,jcompile</vh>
<v t="T1191"><vh>compile_funcdef</vh></v>
<v t="T1192"><vh>compile_lambdef</vh></v>
<v t="T1193"><vh>compile_classdef</vh></v>
<v t="T1064" a="C"><vh>compile_node (compile.c -- top level interface)</vh></v>
<v t="T1194"><vh>dict_keys_inorder</vh></v>
<v t="T1195"><vh>PyNode_Compile</vh></v>
<v t="T1196"><vh>PyNode_CompileFlags</vh></v>
<v t="T1197"><vh>PyNode_CompileSymtable</vh></v>
<v t="T1198"><vh>icompile</vh></v>
<v t="T1063" a="C"><vh>jcompile (The compiler main line -- calls compile node) (compile.c)</vh></v>
<v t="T1199"><vh>PyCode_Addr2Line</vh></v>
<v t="T1200"><vh>get_ref_type</vh></v>
<v t="T1201"><vh>issue_warning</vh></v>
</v>
<v t="T1202"><vh>symtable...</vh>
<v t="T1203"><vh>symtable_warn</vh></v>
<v t="T1204"><vh>symtable_build</vh></v>
<v t="T1205"><vh>symtable_init_compiling_symbols</vh></v>
<v t="T1206"><vh>symtable_init_info</vh></v>
<v t="T1207"><vh>symtable_resolve_free</vh></v>
<v t="T1208"><vh>symtable_cellvar_offsets</vh></v>
<v t="T1209"><vh>symtable_freevar_offsets</vh></v>
<v t="T1210"><vh>symtable_check_unoptimized</vh></v>
<v t="T1211"><vh>symtable_update_flags</vh></v>
<v t="T1212"><vh>symtable_load_symbols</vh></v>
<v t="T1213"><vh>symtable_init</vh></v>
<v t="T1214"><vh>PySymtable_Free</vh></v>
<v t="T1215"><vh>symtable_update_free_vars</vh></v>
<v t="T1216"><vh>symtable_check_global</vh></v>
<v t="T1217"><vh>symtable_undo_free</vh></v>
<v t="T1218"><vh>symtable_exit_scope</vh></v>
<v t="T1219"><vh>symtable_enter_scope</vh></v>
<v t="T1220"><vh>symtable_lookup</vh></v>
<v t="T1221"><vh>symtable_add_def</vh></v>
<v t="T1222"><vh>symtable_add_def_o</vh></v>
<v t="T1223"><vh>look_for_yield</vh></v>
<v t="T1224"><vh>symtable_node</vh></v>
<v t="T1225"><vh>symtable_funcdef</vh></v>
<v t="T1226"><vh>symtable_default_args</vh></v>
<v t="T1227"><vh>symtable_params</vh></v>
<v t="T1228"><vh>symtable_params_fplist</vh></v>
<v t="T1229"><vh>symtable_global</vh></v>
<v t="T1230"><vh>symtable_list_comprehension</vh></v>
<v t="T1231"><vh>symtable_import</vh></v>
<v t="T1232"><vh>symtable_assign</vh></v>
</v>
</v>
<v t="T1233"><vh>Lib/Compiler</vh>
<v t="T1234"><vh>ast.py</vh>
<v t="T1235"><vh>&lt;&lt; functions &gt;&gt;</vh>
<v t="T1236"><vh>flatten</vh></v>
<v t="T1237"><vh>flatten_nodes</vh></v>
<v t="T1238"><vh>asList</vh></v>
</v>
<v t="T1239"><vh>class Node</vh>
<v t="T1240"><vh>getType</vh></v>
<v t="T1241"><vh>getChildNodes</vh></v>
</v>
<v t="T1242"><vh>class EmptyNode</vh></v>
<v t="T1243"><vh>class Slice</vh>
<v t="T1244"><vh>__init__</vh></v>
<v t="T1245"><vh>getChildren</vh></v>
<v t="T1246"><vh>getChildNodes</vh></v>
<v t="T1247"><vh>__repr__</vh></v>
</v>
<v t="T1248"><vh>class Const</vh>
<v t="T1249"><vh>__init__</vh></v>
<v t="T1250"><vh>getChildren</vh></v>
<v t="T1251"><vh>getChildNodes</vh></v>
<v t="T1252"><vh>__repr__</vh></v>
</v>
<v t="T1253"><vh>class Raise</vh>
<v t="T1254"><vh>__init__</vh></v>
<v t="T1255"><vh>getChildren</vh></v>
<v t="T1256"><vh>getChildNodes</vh></v>
<v t="T1257"><vh>__repr__</vh></v>
</v>
<v t="T1258"><vh>class For</vh>
<v t="T1259"><vh>__init__</vh></v>
<v t="T1260"><vh>getChildren</vh></v>
<v t="T1261"><vh>getChildNodes</vh></v>
<v t="T1262"><vh>__repr__</vh></v>
</v>
<v t="T1263"><vh>class AssTuple</vh>
<v t="T1264"><vh>&lt;&lt; class AssTuple declarations &gt;&gt;</vh></v>
<v t="T1265"><vh>&lt;&lt; class AssTuple methods &gt;&gt;</vh>
<v t="T1266"><vh>__init__</vh></v>
<v t="T1267"><vh>getChildren</vh></v>
<v t="T1268"><vh>getChildNodes</vh></v>
<v t="T1269"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1270"><vh>class Mul</vh>
<v t="T1271"><vh>&lt;&lt; class Mul declarations &gt;&gt;</vh></v>
<v t="T1272"><vh>&lt;&lt; class Mul methods &gt;&gt;</vh>
<v t="T1273"><vh>__init__</vh></v>
<v t="T1274"><vh>getChildren</vh></v>
<v t="T1275"><vh>getChildNodes</vh></v>
<v t="T1276"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1277"><vh>class Invert</vh>
<v t="T1278"><vh>&lt;&lt; class Invert declarations &gt;&gt;</vh></v>
<v t="T1279"><vh>&lt;&lt; class Invert methods &gt;&gt;</vh>
<v t="T1280"><vh>__init__</vh></v>
<v t="T1281"><vh>getChildren</vh></v>
<v t="T1282"><vh>getChildNodes</vh></v>
<v t="T1283"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1284"><vh>class RightShift</vh>
<v t="T1285"><vh>&lt;&lt; class RightShift declarations &gt;&gt;</vh></v>
<v t="T1286"><vh>&lt;&lt; class RightShift methods &gt;&gt;</vh>
<v t="T1287"><vh>__init__</vh></v>
<v t="T1288"><vh>getChildren</vh></v>
<v t="T1289"><vh>getChildNodes</vh></v>
<v t="T1290"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1291"><vh>class AssList</vh>
<v t="T1292"><vh>&lt;&lt; class AssList declarations &gt;&gt;</vh></v>
<v t="T1293"><vh>&lt;&lt; class AssList methods &gt;&gt;</vh>
<v t="T1294"><vh>__init__</vh></v>
<v t="T1295"><vh>getChildren</vh></v>
<v t="T1296"><vh>getChildNodes</vh></v>
<v t="T1297"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1298"><vh>class From</vh>
<v t="T1299"><vh>&lt;&lt; class From declarations &gt;&gt;</vh></v>
<v t="T1300"><vh>&lt;&lt; class From methods &gt;&gt;</vh>
<v t="T1301"><vh>__init__</vh></v>
<v t="T1302"><vh>getChildren</vh></v>
<v t="T1303"><vh>getChildNodes</vh></v>
<v t="T1304"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1305"><vh>class Getattr</vh>
<v t="T1306"><vh>&lt;&lt; class Getattr declarations &gt;&gt;</vh></v>
<v t="T1307"><vh>&lt;&lt; class Getattr methods &gt;&gt;</vh>
<v t="T1308"><vh>__init__</vh></v>
<v t="T1309"><vh>getChildren</vh></v>
<v t="T1310"><vh>getChildNodes</vh></v>
<v t="T1311"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1312"><vh>class Dict</vh>
<v t="T1313"><vh>&lt;&lt; class Dict declarations &gt;&gt;</vh></v>
<v t="T1314"><vh>&lt;&lt; class Dict methods &gt;&gt;</vh>
<v t="T1315"><vh>__init__</vh></v>
<v t="T1316"><vh>getChildren</vh></v>
<v t="T1317"><vh>getChildNodes</vh></v>
<v t="T1318"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1319"><vh>class Module</vh>
<v t="T1320"><vh>&lt;&lt; class Module declarations &gt;&gt;</vh></v>
<v t="T1321"><vh>&lt;&lt; class Module methods &gt;&gt;</vh>
<v t="T1322"><vh>__init__</vh></v>
<v t="T1323"><vh>getChildren</vh></v>
<v t="T1324"><vh>getChildNodes</vh></v>
<v t="T1325"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1326"><vh>class Expression</vh>
<v t="T1327"><vh>&lt;&lt; class Expression declarations &gt;&gt;</vh></v>
<v t="T1328"><vh>&lt;&lt; class Expression methods &gt;&gt;</vh>
<v t="T1329"><vh>__init__</vh></v>
<v t="T1330"><vh>getChildren</vh></v>
<v t="T1331"><vh>getChildNodes</vh></v>
<v t="T1332"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1333"><vh>class UnaryAdd</vh>
<v t="T1334"><vh>&lt;&lt; class UnaryAdd declarations &gt;&gt;</vh></v>
<v t="T1335"><vh>&lt;&lt; class UnaryAdd methods &gt;&gt;</vh>
<v t="T1336"><vh>__init__</vh></v>
<v t="T1337"><vh>getChildren</vh></v>
<v t="T1338"><vh>getChildNodes</vh></v>
<v t="T1339"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1340"><vh>class Ellipsis</vh>
<v t="T1341"><vh>&lt;&lt; class Ellipsis declarations &gt;&gt;</vh></v>
<v t="T1342"><vh>&lt;&lt; class Ellipsis methods &gt;&gt;</vh>
<v t="T1343"><vh>__init__</vh></v>
<v t="T1344"><vh>getChildren</vh></v>
<v t="T1345"><vh>getChildNodes</vh></v>
<v t="T1346"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1347"><vh>class Print</vh>
<v t="T1348"><vh>&lt;&lt; class Print declarations &gt;&gt;</vh></v>
<v t="T1349"><vh>&lt;&lt; class Print methods &gt;&gt;</vh>
<v t="T1350"><vh>__init__</vh></v>
<v t="T1351"><vh>getChildren</vh></v>
<v t="T1352"><vh>getChildNodes</vh></v>
<v t="T1353"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1354"><vh>class Import</vh>
<v t="T1355"><vh>&lt;&lt; class Import declarations &gt;&gt;</vh></v>
<v t="T1356"><vh>&lt;&lt; class Import methods &gt;&gt;</vh>
<v t="T1357"><vh>__init__</vh></v>
<v t="T1358"><vh>getChildren</vh></v>
<v t="T1359"><vh>getChildNodes</vh></v>
<v t="T1360"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1361"><vh>class Subscript</vh>
<v t="T1362"><vh>&lt;&lt; class Subscript declarations &gt;&gt;</vh></v>
<v t="T1363"><vh>&lt;&lt; class Subscript methods &gt;&gt;</vh>
<v t="T1364"><vh>__init__</vh></v>
<v t="T1365"><vh>getChildren</vh></v>
<v t="T1366"><vh>getChildNodes</vh></v>
<v t="T1367"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1368"><vh>class TryExcept</vh>
<v t="T1369"><vh>&lt;&lt; class TryExcept declarations &gt;&gt;</vh></v>
<v t="T1370"><vh>&lt;&lt; class TryExcept methods &gt;&gt;</vh>
<v t="T1371"><vh>__init__</vh></v>
<v t="T1372"><vh>getChildren</vh></v>
<v t="T1373"><vh>getChildNodes</vh></v>
<v t="T1374"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1375"><vh>class Or</vh>
<v t="T1376"><vh>&lt;&lt; class Or declarations &gt;&gt;</vh></v>
<v t="T1377"><vh>&lt;&lt; class Or methods &gt;&gt;</vh>
<v t="T1378"><vh>__init__</vh></v>
<v t="T1379"><vh>getChildren</vh></v>
<v t="T1380"><vh>getChildNodes</vh></v>
<v t="T1381"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1382"><vh>class Name</vh>
<v t="T1383"><vh>&lt;&lt; class Name declarations &gt;&gt;</vh></v>
<v t="T1384"><vh>&lt;&lt; class Name methods &gt;&gt;</vh>
<v t="T1385"><vh>__init__</vh></v>
<v t="T1386"><vh>getChildren</vh></v>
<v t="T1387"><vh>getChildNodes</vh></v>
<v t="T1388"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1389"><vh>class Function</vh>
<v t="T1390"><vh>&lt;&lt; class Function declarations &gt;&gt;</vh></v>
<v t="T1391"><vh>&lt;&lt; class Function methods &gt;&gt;</vh>
<v t="T1392"><vh>__init__</vh></v>
<v t="T1393"><vh>getChildren</vh></v>
<v t="T1394"><vh>getChildNodes</vh></v>
<v t="T1395"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1396"><vh>class Assert</vh>
<v t="T1397"><vh>&lt;&lt; class Assert declarations &gt;&gt;</vh></v>
<v t="T1398"><vh>&lt;&lt; class Assert methods &gt;&gt;</vh>
<v t="T1399"><vh>__init__</vh></v>
<v t="T1400"><vh>getChildren</vh></v>
<v t="T1401"><vh>getChildNodes</vh></v>
<v t="T1402"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1403"><vh>class Return</vh>
<v t="T1404"><vh>&lt;&lt; class Return declarations &gt;&gt;</vh></v>
<v t="T1405"><vh>&lt;&lt; class Return methods &gt;&gt;</vh>
<v t="T1406"><vh>__init__</vh></v>
<v t="T1407"><vh>getChildren</vh></v>
<v t="T1408"><vh>getChildNodes</vh></v>
<v t="T1409"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1410"><vh>class Power</vh>
<v t="T1411"><vh>&lt;&lt; class Power declarations &gt;&gt;</vh></v>
<v t="T1412"><vh>&lt;&lt; class Power methods &gt;&gt;</vh>
<v t="T1413"><vh>__init__</vh></v>
<v t="T1414"><vh>getChildren</vh></v>
<v t="T1415"><vh>getChildNodes</vh></v>
<v t="T1416"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1417"><vh>class Exec</vh>
<v t="T1418"><vh>&lt;&lt; class Exec declarations &gt;&gt;</vh></v>
<v t="T1419"><vh>&lt;&lt; class Exec methods &gt;&gt;</vh>
<v t="T1420"><vh>__init__</vh></v>
<v t="T1421"><vh>getChildren</vh></v>
<v t="T1422"><vh>getChildNodes</vh></v>
<v t="T1423"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1424"><vh>class Stmt</vh>
<v t="T1425"><vh>&lt;&lt; class Stmt declarations &gt;&gt;</vh></v>
<v t="T1426"><vh>&lt;&lt; class Stmt methods &gt;&gt;</vh>
<v t="T1427"><vh>__init__</vh></v>
<v t="T1428"><vh>getChildren</vh></v>
<v t="T1429"><vh>getChildNodes</vh></v>
<v t="T1430"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1431"><vh>class Sliceobj</vh>
<v t="T1432"><vh>&lt;&lt; class Sliceobj declarations &gt;&gt;</vh></v>
<v t="T1433"><vh>&lt;&lt; class Sliceobj methods &gt;&gt;</vh>
<v t="T1434"><vh>__init__</vh></v>
<v t="T1435"><vh>getChildren</vh></v>
<v t="T1436"><vh>getChildNodes</vh></v>
<v t="T1437"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1438"><vh>class Break</vh>
<v t="T1439"><vh>&lt;&lt; class Break declarations &gt;&gt;</vh></v>
<v t="T1440"><vh>&lt;&lt; class Break methods &gt;&gt;</vh>
<v t="T1441"><vh>__init__</vh></v>
<v t="T1442"><vh>getChildren</vh></v>
<v t="T1443"><vh>getChildNodes</vh></v>
<v t="T1444"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1445"><vh>class Bitand</vh>
<v t="T1446"><vh>&lt;&lt; class Bitand declarations &gt;&gt;</vh></v>
<v t="T1447"><vh>&lt;&lt; class Bitand methods &gt;&gt;</vh>
<v t="T1448"><vh>__init__</vh></v>
<v t="T1449"><vh>getChildren</vh></v>
<v t="T1450"><vh>getChildNodes</vh></v>
<v t="T1451"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1452"><vh>class FloorDiv</vh>
<v t="T1453"><vh>&lt;&lt; class FloorDiv declarations &gt;&gt;</vh></v>
<v t="T1454"><vh>&lt;&lt; class FloorDiv methods &gt;&gt;</vh>
<v t="T1455"><vh>__init__</vh></v>
<v t="T1456"><vh>getChildren</vh></v>
<v t="T1457"><vh>getChildNodes</vh></v>
<v t="T1458"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1459"><vh>class TryFinally</vh>
<v t="T1460"><vh>&lt;&lt; class TryFinally declarations &gt;&gt;</vh></v>
<v t="T1461"><vh>&lt;&lt; class TryFinally methods &gt;&gt;</vh>
<v t="T1462"><vh>__init__</vh></v>
<v t="T1463"><vh>getChildren</vh></v>
<v t="T1464"><vh>getChildNodes</vh></v>
<v t="T1465"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1466"><vh>class Not</vh>
<v t="T1467"><vh>&lt;&lt; class Not declarations &gt;&gt;</vh></v>
<v t="T1468"><vh>&lt;&lt; class Not methods &gt;&gt;</vh>
<v t="T1469"><vh>__init__</vh></v>
<v t="T1470"><vh>getChildren</vh></v>
<v t="T1471"><vh>getChildNodes</vh></v>
<v t="T1472"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1473"><vh>class Class</vh>
<v t="T1474"><vh>&lt;&lt; class Class declarations &gt;&gt;</vh></v>
<v t="T1475"><vh>&lt;&lt; class Class methods &gt;&gt;</vh>
<v t="T1476"><vh>__init__</vh></v>
<v t="T1477"><vh>getChildren</vh></v>
<v t="T1478"><vh>getChildNodes</vh></v>
<v t="T1479"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1480"><vh>class Mod</vh>
<v t="T1481"><vh>&lt;&lt; class Mod declarations &gt;&gt;</vh></v>
<v t="T1482"><vh>&lt;&lt; class Mod methods &gt;&gt;</vh>
<v t="T1483"><vh>__init__</vh></v>
<v t="T1484"><vh>getChildren</vh></v>
<v t="T1485"><vh>getChildNodes</vh></v>
<v t="T1486"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1487"><vh>class Printnl</vh>
<v t="T1488"><vh>&lt;&lt; class Printnl declarations &gt;&gt;</vh></v>
<v t="T1489"><vh>&lt;&lt; class Printnl methods &gt;&gt;</vh>
<v t="T1490"><vh>__init__</vh></v>
<v t="T1491"><vh>getChildren</vh></v>
<v t="T1492"><vh>getChildNodes</vh></v>
<v t="T1493"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1494"><vh>class Tuple</vh>
<v t="T1495"><vh>&lt;&lt; class Tuple declarations &gt;&gt;</vh></v>
<v t="T1496"><vh>&lt;&lt; class Tuple methods &gt;&gt;</vh>
<v t="T1497"><vh>__init__</vh></v>
<v t="T1498"><vh>getChildren</vh></v>
<v t="T1499"><vh>getChildNodes</vh></v>
<v t="T1500"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1501"><vh>class AssAttr</vh>
<v t="T1502"><vh>&lt;&lt; class AssAttr declarations &gt;&gt;</vh></v>
<v t="T1503"><vh>&lt;&lt; class AssAttr methods &gt;&gt;</vh>
<v t="T1504"><vh>__init__</vh></v>
<v t="T1505"><vh>getChildren</vh></v>
<v t="T1506"><vh>getChildNodes</vh></v>
<v t="T1507"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1508"><vh>class Keyword</vh>
<v t="T1509"><vh>&lt;&lt; class Keyword declarations &gt;&gt;</vh></v>
<v t="T1510"><vh>&lt;&lt; class Keyword methods &gt;&gt;</vh>
<v t="T1511"><vh>__init__</vh></v>
<v t="T1512"><vh>getChildren</vh></v>
<v t="T1513"><vh>getChildNodes</vh></v>
<v t="T1514"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1515"><vh>class AugAssign</vh>
<v t="T1516"><vh>&lt;&lt; class AugAssign declarations &gt;&gt;</vh></v>
<v t="T1517"><vh>&lt;&lt; class AugAssign methods &gt;&gt;</vh>
<v t="T1518"><vh>__init__</vh></v>
<v t="T1519"><vh>getChildren</vh></v>
<v t="T1520"><vh>getChildNodes</vh></v>
<v t="T1521"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1522"><vh>class List</vh>
<v t="T1523"><vh>&lt;&lt; class List declarations &gt;&gt;</vh></v>
<v t="T1524"><vh>&lt;&lt; class List methods &gt;&gt;</vh>
<v t="T1525"><vh>__init__</vh></v>
<v t="T1526"><vh>getChildren</vh></v>
<v t="T1527"><vh>getChildNodes</vh></v>
<v t="T1528"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1529"><vh>class Yield</vh>
<v t="T1530"><vh>&lt;&lt; class Yield declarations &gt;&gt;</vh></v>
<v t="T1531"><vh>&lt;&lt; class Yield methods &gt;&gt;</vh>
<v t="T1532"><vh>__init__</vh></v>
<v t="T1533"><vh>getChildren</vh></v>
<v t="T1534"><vh>getChildNodes</vh></v>
<v t="T1535"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1536"><vh>class LeftShift</vh>
<v t="T1537"><vh>&lt;&lt; class LeftShift declarations &gt;&gt;</vh></v>
<v t="T1538"><vh>&lt;&lt; class LeftShift methods &gt;&gt;</vh>
<v t="T1539"><vh>__init__</vh></v>
<v t="T1540"><vh>getChildren</vh></v>
<v t="T1541"><vh>getChildNodes</vh></v>
<v t="T1542"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1543"><vh>class AssName</vh>
<v t="T1544"><vh>&lt;&lt; class AssName declarations &gt;&gt;</vh></v>
<v t="T1545"><vh>&lt;&lt; class AssName methods &gt;&gt;</vh>
<v t="T1546"><vh>__init__</vh></v>
<v t="T1547"><vh>getChildren</vh></v>
<v t="T1548"><vh>getChildNodes</vh></v>
<v t="T1549"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1550"><vh>class While</vh>
<v t="T1551"><vh>&lt;&lt; class While declarations &gt;&gt;</vh></v>
<v t="T1552"><vh>&lt;&lt; class While methods &gt;&gt;</vh>
<v t="T1553"><vh>__init__</vh></v>
<v t="T1554"><vh>getChildren</vh></v>
<v t="T1555"><vh>getChildNodes</vh></v>
<v t="T1556"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1557"><vh>class Continue</vh>
<v t="T1558"><vh>&lt;&lt; class Continue declarations &gt;&gt;</vh></v>
<v t="T1559"><vh>&lt;&lt; class Continue methods &gt;&gt;</vh>
<v t="T1560"><vh>__init__</vh></v>
<v t="T1561"><vh>getChildren</vh></v>
<v t="T1562"><vh>getChildNodes</vh></v>
<v t="T1563"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1564"><vh>class Backquote</vh>
<v t="T1565"><vh>&lt;&lt; class Backquote declarations &gt;&gt;</vh></v>
<v t="T1566"><vh>&lt;&lt; class Backquote methods &gt;&gt;</vh>
<v t="T1567"><vh>__init__</vh></v>
<v t="T1568"><vh>getChildren</vh></v>
<v t="T1569"><vh>getChildNodes</vh></v>
<v t="T1570"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1571"><vh>class Discard</vh>
<v t="T1572"><vh>&lt;&lt; class Discard declarations &gt;&gt;</vh></v>
<v t="T1573"><vh>&lt;&lt; class Discard methods &gt;&gt;</vh>
<v t="T1574"><vh>__init__</vh></v>
<v t="T1575"><vh>getChildren</vh></v>
<v t="T1576"><vh>getChildNodes</vh></v>
<v t="T1577"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1578"><vh>class Div</vh>
<v t="T1579"><vh>&lt;&lt; class Div declarations &gt;&gt;</vh></v>
<v t="T1580"><vh>&lt;&lt; class Div methods &gt;&gt;</vh>
<v t="T1581"><vh>__init__</vh></v>
<v t="T1582"><vh>getChildren</vh></v>
<v t="T1583"><vh>getChildNodes</vh></v>
<v t="T1584"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1585"><vh>class Assign</vh>
<v t="T1586"><vh>&lt;&lt; class Assign declarations &gt;&gt;</vh></v>
<v t="T1587"><vh>&lt;&lt; class Assign methods &gt;&gt;</vh>
<v t="T1588"><vh>__init__</vh></v>
<v t="T1589"><vh>getChildren</vh></v>
<v t="T1590"><vh>getChildNodes</vh></v>
<v t="T1591"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1592"><vh>class Lambda</vh>
<v t="T1593"><vh>&lt;&lt; class Lambda declarations &gt;&gt;</vh></v>
<v t="T1594"><vh>&lt;&lt; class Lambda methods &gt;&gt;</vh>
<v t="T1595"><vh>__init__</vh></v>
<v t="T1596"><vh>getChildren</vh></v>
<v t="T1597"><vh>getChildNodes</vh></v>
<v t="T1598"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1599"><vh>class And</vh>
<v t="T1600"><vh>&lt;&lt; class And declarations &gt;&gt;</vh></v>
<v t="T1601"><vh>&lt;&lt; class And methods &gt;&gt;</vh>
<v t="T1602"><vh>__init__</vh></v>
<v t="T1603"><vh>getChildren</vh></v>
<v t="T1604"><vh>getChildNodes</vh></v>
<v t="T1605"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1606"><vh>class Compare</vh>
<v t="T1607"><vh>&lt;&lt; class Compare declarations &gt;&gt;</vh></v>
<v t="T1608"><vh>&lt;&lt; class Compare methods &gt;&gt;</vh>
<v t="T1609"><vh>__init__</vh></v>
<v t="T1610"><vh>getChildren</vh></v>
<v t="T1611"><vh>getChildNodes</vh></v>
<v t="T1612"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1613"><vh>class Bitor</vh>
<v t="T1614"><vh>&lt;&lt; class Bitor declarations &gt;&gt;</vh></v>
<v t="T1615"><vh>&lt;&lt; class Bitor methods &gt;&gt;</vh>
<v t="T1616"><vh>__init__</vh></v>
<v t="T1617"><vh>getChildren</vh></v>
<v t="T1618"><vh>getChildNodes</vh></v>
<v t="T1619"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1620"><vh>class Bitxor</vh>
<v t="T1621"><vh>&lt;&lt; class Bitxor declarations &gt;&gt;</vh></v>
<v t="T1622"><vh>&lt;&lt; class Bitxor methods &gt;&gt;</vh>
<v t="T1623"><vh>__init__</vh></v>
<v t="T1624"><vh>getChildren</vh></v>
<v t="T1625"><vh>getChildNodes</vh></v>
<v t="T1626"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1627"><vh>class CallFunc</vh>
<v t="T1628"><vh>&lt;&lt; class CallFunc declarations &gt;&gt;</vh></v>
<v t="T1629"><vh>&lt;&lt; class CallFunc methods &gt;&gt;</vh>
<v t="T1630"><vh>__init__</vh></v>
<v t="T1631"><vh>getChildren</vh></v>
<v t="T1632"><vh>getChildNodes</vh></v>
<v t="T1633"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1634"><vh>class Global</vh>
<v t="T1635"><vh>&lt;&lt; class Global declarations &gt;&gt;</vh></v>
<v t="T1636"><vh>&lt;&lt; class Global methods &gt;&gt;</vh>
<v t="T1637"><vh>__init__</vh></v>
<v t="T1638"><vh>getChildren</vh></v>
<v t="T1639"><vh>getChildNodes</vh></v>
<v t="T1640"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1641"><vh>class Add</vh>
<v t="T1642"><vh>&lt;&lt; class Add declarations &gt;&gt;</vh></v>
<v t="T1643"><vh>&lt;&lt; class Add methods &gt;&gt;</vh>
<v t="T1644"><vh>__init__</vh></v>
<v t="T1645"><vh>getChildren</vh></v>
<v t="T1646"><vh>getChildNodes</vh></v>
<v t="T1647"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1648"><vh>class ListCompIf</vh>
<v t="T1649"><vh>&lt;&lt; class ListCompIf declarations &gt;&gt;</vh></v>
<v t="T1650"><vh>&lt;&lt; class ListCompIf methods &gt;&gt;</vh>
<v t="T1651"><vh>__init__</vh></v>
<v t="T1652"><vh>getChildren</vh></v>
<v t="T1653"><vh>getChildNodes</vh></v>
<v t="T1654"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1655"><vh>class Sub</vh>
<v t="T1656"><vh>&lt;&lt; class Sub declarations &gt;&gt;</vh></v>
<v t="T1657"><vh>&lt;&lt; class Sub methods &gt;&gt;</vh>
<v t="T1658"><vh>__init__</vh></v>
<v t="T1659"><vh>getChildren</vh></v>
<v t="T1660"><vh>getChildNodes</vh></v>
<v t="T1661"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1662"><vh>class Pass</vh>
<v t="T1663"><vh>&lt;&lt; class Pass declarations &gt;&gt;</vh></v>
<v t="T1664"><vh>&lt;&lt; class Pass methods &gt;&gt;</vh>
<v t="T1665"><vh>__init__</vh></v>
<v t="T1666"><vh>getChildren</vh></v>
<v t="T1667"><vh>getChildNodes</vh></v>
<v t="T1668"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1669"><vh>class UnarySub</vh>
<v t="T1670"><vh>&lt;&lt; class UnarySub declarations &gt;&gt;</vh></v>
<v t="T1671"><vh>&lt;&lt; class UnarySub methods &gt;&gt;</vh>
<v t="T1672"><vh>__init__</vh></v>
<v t="T1673"><vh>getChildren</vh></v>
<v t="T1674"><vh>getChildNodes</vh></v>
<v t="T1675"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1676"><vh>class If</vh>
<v t="T1677"><vh>&lt;&lt; class If declarations &gt;&gt;</vh></v>
<v t="T1678"><vh>&lt;&lt; class If methods &gt;&gt;</vh>
<v t="T1679"><vh>__init__</vh></v>
<v t="T1680"><vh>getChildren</vh></v>
<v t="T1681"><vh>getChildNodes</vh></v>
<v t="T1682"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1683"><vh>class ListComp</vh>
<v t="T1684"><vh>&lt;&lt; class ListComp declarations &gt;&gt;</vh></v>
<v t="T1685"><vh>&lt;&lt; class ListComp methods &gt;&gt;</vh>
<v t="T1686"><vh>__init__</vh></v>
<v t="T1687"><vh>getChildren</vh></v>
<v t="T1688"><vh>getChildNodes</vh></v>
<v t="T1689"><vh>__repr__</vh></v>
</v>
</v>
<v t="T1690"><vh>class ListCompFor</vh>
<v t="T1691"><vh>&lt;&lt; class ListCompFor declarations &gt;&gt;</vh></v>
<v t="T1692"><vh>&lt;&lt; class ListCompFor methods &gt;&gt;</vh>
<v t="T1693"><vh>__init__</vh></v>
<v t="T1694"><vh>getChildren</vh></v>
<v t="T1695"><vh>getChildNodes</vh></v>
<v t="T1696"><vh>__repr__</vh></v>
</v>
</v>
</v>
<v t="T1697"><vh>consts.py</vh></v>
<v t="T1698"><vh>future.py</vh>
<v t="T1699"><vh>is_future</vh></v>
<v t="T1700"><vh>class FutureParser</vh>
<v t="T1701"><vh>__init__</vh></v>
<v t="T1702"><vh>visitModule</vh></v>
<v t="T1703"><vh>check_stmt</vh></v>
<v t="T1704"><vh>get_features</vh></v>
</v>
<v t="T1705"><vh>class BadFutureParser</vh>
<v t="T1706"><vh>visitFrom</vh></v>
</v>
<v t="T1707"><vh>find_futures</vh></v>
</v>
<v t="T1708"><vh>misc.py</vh>
<v t="T1709"><vh>flatten</vh></v>
<v t="T1710"><vh>class Set</vh>
<v t="T1711"><vh>__init__</vh></v>
<v t="T1712"><vh>__len__</vh></v>
<v t="T1713"><vh>__contains__</vh></v>
<v t="T1714"><vh>add</vh></v>
<v t="T1715"><vh>elements</vh></v>
<v t="T1716"><vh>has_elt</vh></v>
<v t="T1717"><vh>remove</vh></v>
<v t="T1718"><vh>copy</vh></v>
</v>
<v t="T1719"><vh>class Stack</vh>
<v t="T1720"><vh>__init__</vh></v>
<v t="T1721"><vh>__len__</vh></v>
<v t="T1722"><vh>push</vh></v>
<v t="T1723"><vh>top</vh></v>
<v t="T1724"><vh>__getitem__</vh></v>
</v>
<v t="T1725"><vh>mangle</vh></v>
<v t="T1726"><vh>set_filename</vh></v>
</v>
<v t="T1727"><vh>pyassem.py</vh>
<v t="T1728"><vh>xxx_sort</vh></v>
<v t="T1729"><vh>class FlowGraph</vh>
<v t="T1730"><vh>&lt;&lt; class FlowGraph methods &gt;&gt;</vh>
<v t="T1731"><vh>__init__</vh></v>
<v t="T1732"><vh>startBlock</vh></v>
<v t="T1733"><vh>nextBlock</vh></v>
<v t="T1734"><vh>newBlock</vh></v>
<v t="T1735"><vh>startExitBlock</vh></v>
<v t="T1736"><vh>_enable_debug</vh></v>
<v t="T1737"><vh>_disable_debug</vh></v>
<v t="T1738"><vh>emit</vh></v>
<v t="T1739"><vh>getBlocksInOrder</vh></v>
<v t="T1740"><vh>fixupOrder</vh></v>
<v t="T1741"><vh>fixupOrderHonorNext</vh></v>
<v t="T1742"><vh>fixupOrderForward</vh></v>
<v t="T1743"><vh>getBlocks</vh></v>
<v t="T1744"><vh>getRoot</vh></v>
<v t="T1745"><vh>getContainedGraphs</vh></v>
</v>
</v>
<v t="T1746"><vh>dfs_postorder</vh></v>
<v t="T1747"><vh>class Block</vh>
<v t="T1748"><vh>&lt;&lt; class Block declarations &gt;&gt;</vh></v>
<v t="T1749"><vh>&lt;&lt; class Block methods &gt;&gt;</vh>
<v t="T1750"><vh>__init__</vh></v>
<v t="T1751"><vh>__repr__</vh></v>
<v t="T1752"><vh>__str__</vh></v>
<v t="T1753"><vh>emit</vh></v>
<v t="T1754"><vh>getInstructions</vh></v>
<v t="T1755"><vh>addInEdge</vh></v>
<v t="T1756"><vh>addOutEdge</vh></v>
<v t="T1757"><vh>addNext</vh></v>
<v t="T1758"><vh>pruneNext</vh></v>
<v t="T1759"><vh>get_children</vh></v>
<v t="T1760"><vh>getContainedGraphs</vh></v>
</v>
</v>
<v t="T1761"><vh>class PyFlowGraph</vh>
<v t="T1762"><vh>&lt;&lt; class PyFlowGraph declarations &gt;&gt;</vh></v>
<v t="T1763"><vh>&lt;&lt; class PyFlowGraph methods &gt;&gt;</vh>
<v t="T1764"><vh>__init__</vh></v>
<v t="T1765"><vh>setDocstring</vh></v>
<v t="T1766"><vh>setFlag</vh></v>
<v t="T1767"><vh>checkFlag</vh></v>
<v t="T1768"><vh>setFreeVars</vh></v>
<v t="T1769"><vh>setCellVars</vh></v>
<v t="T1770"><vh>getCode</vh></v>
<v t="T1771"><vh>dump</vh></v>
<v t="T1772"><vh>computeStackDepth</vh></v>
<v t="T1773"><vh>flattenGraph</vh></v>
<v t="T1774"><vh>convertArgs</vh></v>
<v t="T1775"><vh>sort_cellvars</vh></v>
<v t="T1776"><vh>_lookupName</vh></v>
<v t="T1777"><vh>_convert_LOAD_CONST</vh></v>
<v t="T1778"><vh>_convert_LOAD_FAST</vh></v>
<v t="T1779"><vh>_convert_LOAD_NAME</vh></v>
<v t="T1780"><vh>_convert_NAME</vh></v>
<v t="T1781"><vh>_convert_DEREF</vh></v>
<v t="T1782"><vh>_convert_LOAD_CLOSURE</vh></v>
<v t="T1783"><vh>_convert_COMPARE_OP</vh></v>
<v t="T1784"><vh>makeByteCode</vh></v>
<v t="T1785"><vh>newCodeObject</vh></v>
<v t="T1786"><vh>getConsts</vh></v>
</v>
</v>
<v t="T1787"><vh>isJump</vh></v>
<v t="T1788"><vh>class TupleArg</vh>
<v t="T1789"><vh>&lt;&lt; class TupleArg declarations &gt;&gt;</vh></v>
<v t="T1790"><vh>&lt;&lt; class TupleArg methods &gt;&gt;</vh>
<v t="T1791"><vh>__init__</vh></v>
<v t="T1792"><vh>__repr__</vh></v>
<v t="T1793"><vh>getName</vh></v>
</v>
</v>
<v t="T1794"><vh>getArgCount</vh></v>
<v t="T1795"><vh>twobyte</vh></v>
<v t="T1796"><vh>class LineAddrTable</vh>
<v t="T1797"><vh>&lt;&lt; class LineAddrTable declarations &gt;&gt;</vh></v>
<v t="T1798"><vh>&lt;&lt; class LineAddrTable methods &gt;&gt;</vh>
<v t="T1799"><vh>__init__</vh></v>
<v t="T1800"><vh>addCode</vh></v>
<v t="T1801"><vh>nextLine</vh></v>
<v t="T1802"><vh>getCode</vh></v>
<v t="T1803"><vh>getTable</vh></v>
</v>
</v>
<v t="T1804"><vh>class StackDepthTracker</vh>
<v t="T1805"><vh>&lt;&lt; class StackDepthTracker declarations &gt;&gt;</vh></v>
<v t="T1806"><vh>&lt;&lt; class StackDepthTracker methods &gt;&gt;</vh>
<v t="T1807"><vh>findDepth</vh></v>
<v t="T1808"><vh>UNPACK_SEQUENCE</vh></v>
<v t="T1809"><vh>BUILD_TUPLE</vh></v>
<v t="T1810"><vh>BUILD_LIST</vh></v>
<v t="T1811"><vh>CALL_FUNCTION</vh></v>
<v t="T1812"><vh>CALL_FUNCTION_VAR</vh></v>
<v t="T1813"><vh>CALL_FUNCTION_KW</vh></v>
<v t="T1814"><vh>CALL_FUNCTION_VAR_KW</vh></v>
<v t="T1815"><vh>MAKE_FUNCTION</vh></v>
<v t="T1816"><vh>MAKE_CLOSURE</vh></v>
<v t="T1817"><vh>BUILD_SLICE</vh></v>
<v t="T1818"><vh>DUP_TOPX</vh></v>
</v>
</v>
</v>
<v t="T1819"><vh>pycodegen.py</vh>
<v t="T1820"><vh>&lt;&lt; pycodegen declarations &gt;&gt;</vh></v>
<v t="T1821"><vh>class BlockStack</vh>
<v t="T1822"><vh>&lt;&lt; class BlockStack declarations &gt;&gt;</vh></v>
<v t="T1823"><vh>&lt;&lt; class BlockStack methods &gt;&gt;</vh>
<v t="T1824"><vh>__init__</vh></v>
</v>
</v>
<v t="T1825"><vh>compileFile</vh></v>
<v t="T1826"><vh>compile</vh></v>
<v t="T1827"><vh>class AbstractCompileMode</vh>
<v t="T1828"><vh>&lt;&lt; class AbstractCompileMode declarations &gt;&gt;</vh></v>
<v t="T1829"><vh>&lt;&lt; class AbstractCompileMode methods &gt;&gt;</vh>
<v t="T1830"><vh>__init__</vh></v>
<v t="T1831"><vh>_get_tree</vh></v>
<v t="T1832"><vh>compile</vh></v>
<v t="T1833"><vh>getCode</vh></v>
</v>
</v>
<v t="T1834"><vh>class Expression</vh>
<v t="T1835"><vh>&lt;&lt; class Expression declarations &gt;&gt;</vh></v>
<v t="T1836"><vh>&lt;&lt; class Expression methods &gt;&gt;</vh>
<v t="T1837"><vh>compile</vh></v>
</v>
</v>
<v t="T1838"><vh>class Interactive</vh>
<v t="T1839"><vh>&lt;&lt; class Interactive declarations &gt;&gt;</vh></v>
<v t="T1840"><vh>&lt;&lt; class Interactive methods &gt;&gt;</vh>
<v t="T1841"><vh>compile</vh></v>
</v>
</v>
<v t="T1842"><vh>class Module</vh>
<v t="T1843"><vh>&lt;&lt; class Module declarations &gt;&gt;</vh></v>
<v t="T1844"><vh>&lt;&lt; class Module methods &gt;&gt;</vh>
<v t="T1845"><vh>compile</vh></v>
<v t="T1846"><vh>dump</vh></v>
<v t="T1847"><vh>getPycHeader</vh></v>
</v>
</v>
<v t="T1848"><vh>class LocalNameFinder</vh>
<v t="T1849"><vh>&lt;&lt; class LocalNameFinder declarations &gt;&gt;</vh></v>
<v t="T1850"><vh>&lt;&lt; class LocalNameFinder methods &gt;&gt;</vh>
<v t="T1851"><vh>__init__</vh></v>
<v t="T1852"><vh>getLocals</vh></v>
<v t="T1853"><vh>visitDict</vh></v>
<v t="T1854"><vh>visitGlobal</vh></v>
<v t="T1855"><vh>visitFunction</vh></v>
<v t="T1856"><vh>visitLambda</vh></v>
<v t="T1857"><vh>visitImport</vh></v>
<v t="T1858"><vh>visitFrom</vh></v>
<v t="T1859"><vh>visitClass</vh></v>
<v t="T1860"><vh>visitAssName</vh></v>
</v>
</v>
<v t="T1861"><vh>is_constant_false</vh></v>
<v t="T1862"><vh>class CodeGenerator</vh>
<v t="T1863"><vh>&lt;&lt; class CodeGenerator declarations &gt;&gt;</vh></v>
<v t="T1864"><vh>&lt;&lt; class CodeGenerator methods &gt;&gt;</vh>
<v t="T1865"><vh>__init__</vh></v>
<v t="T1866"><vh>initClass</vh></v>
<v t="T1867"><vh>checkClass</vh></v>
<v t="T1868"><vh>_setupGraphDelegation</vh></v>
<v t="T1869"><vh>getCode</vh></v>
<v t="T1870"><vh>mangle</vh></v>
<v t="T1871"><vh>parseSymbols</vh></v>
<v t="T1872"><vh>get_module</vh></v>
<v t="T1873"><vh>isLocalName</vh></v>
<v t="T1874"><vh>storeName</vh></v>
<v t="T1875"><vh>loadName</vh></v>
<v t="T1876"><vh>delName</vh></v>
<v t="T1877"><vh>_nameOp</vh></v>
<v t="T1878"><vh>_implicitNameOp</vh></v>
<v t="T1879"><vh>set_lineno</vh></v>
<v t="T1880"><vh>visitModule</vh></v>
<v t="T1881"><vh>visitExpression</vh></v>
<v t="T1882"><vh>visitFunction</vh></v>
<v t="T1883"><vh>visitLambda</vh></v>
<v t="T1884"><vh>_visitFuncOrLambda</vh></v>
<v t="T1885"><vh>visitClass</vh></v>
<v t="T1886"><vh>visitIf</vh></v>
<v t="T1887"><vh>visitWhile</vh></v>
<v t="T1888"><vh>visitFor</vh></v>
<v t="T1889"><vh>visitBreak</vh></v>
<v t="T1890"><vh>visitContinue</vh></v>
<v t="T1891"><vh>visitTest</vh></v>
<v t="T1892"><vh>visitAnd</vh></v>
<v t="T1893"><vh>visitOr</vh></v>
<v t="T1894"><vh>visitCompare</vh></v>
<v t="T1895"><vh>visitListComp</vh></v>
<v t="T1896"><vh>visitListCompFor</vh></v>
<v t="T1897"><vh>visitListCompIf</vh></v>
<v t="T1898"><vh>visitAssert</vh></v>
<v t="T1899"><vh>visitRaise</vh></v>
<v t="T1900"><vh>visitTryExcept</vh></v>
<v t="T1901"><vh>visitTryFinally</vh></v>
<v t="T1902"><vh>visitDiscard</vh></v>
<v t="T1903"><vh>visitConst</vh></v>
<v t="T1904"><vh>visitKeyword</vh></v>
<v t="T1905"><vh>visitGlobal</vh></v>
<v t="T1906"><vh>visitName</vh></v>
<v t="T1907"><vh>visitPass</vh></v>
<v t="T1908"><vh>visitImport</vh></v>
<v t="T1909"><vh>visitFrom</vh></v>
<v t="T1910"><vh>_resolveDots</vh></v>
<v t="T1911"><vh>visitGetattr</vh></v>
<v t="T1912"><vh>visitAssign</vh></v>
<v t="T1913"><vh>visitAssName</vh></v>
<v t="T1914"><vh>visitAssAttr</vh></v>
<v t="T1915"><vh>_visitAssSequence</vh></v>
<v t="T1916"><vh>visitAssTuple</vh></v>
<v t="T1917"><vh>visitAugAssign</vh></v>
<v t="T1918"><vh>visitAugName</vh></v>
<v t="T1919"><vh>visitAugGetattr</vh></v>
<v t="T1920"><vh>visitAugSlice</vh></v>
<v t="T1921"><vh>visitAugSubscript</vh></v>
<v t="T1922"><vh>visitExec</vh></v>
<v t="T1923"><vh>visitCallFunc</vh></v>
<v t="T1924"><vh>visitPrint</vh></v>
<v t="T1925"><vh>visitPrintnl</vh></v>
<v t="T1926"><vh>visitReturn</vh></v>
<v t="T1927"><vh>visitYield</vh></v>
<v t="T1928"><vh>visitSlice</vh></v>
<v t="T1929"><vh>visitSubscript</vh></v>
<v t="T1930"><vh>binaryOp</vh></v>
<v t="T1931"><vh>visitAdd</vh></v>
<v t="T1932"><vh>visitSub</vh></v>
<v t="T1933"><vh>visitMul</vh></v>
<v t="T1934"><vh>visitDiv</vh></v>
<v t="T1935"><vh>visitFloorDiv</vh></v>
<v t="T1936"><vh>visitMod</vh></v>
<v t="T1937"><vh>visitPower</vh></v>
<v t="T1938"><vh>visitLeftShift</vh></v>
<v t="T1939"><vh>visitRightShift</vh></v>
<v t="T1940"><vh>unaryOp</vh></v>
<v t="T1941"><vh>visitInvert</vh></v>
<v t="T1942"><vh>visitUnarySub</vh></v>
<v t="T1943"><vh>visitUnaryAdd</vh></v>
<v t="T1944"><vh>visitUnaryInvert</vh></v>
<v t="T1945"><vh>visitNot</vh></v>
<v t="T1946"><vh>visitBackquote</vh></v>
<v t="T1947"><vh>bitOp</vh></v>
<v t="T1948"><vh>visitBitand</vh></v>
<v t="T1949"><vh>visitBitor</vh></v>
<v t="T1950"><vh>visitBitxor</vh></v>
<v t="T1951"><vh>visitEllipsis</vh></v>
<v t="T1952"><vh>visitTuple</vh></v>
<v t="T1953"><vh>visitList</vh></v>
<v t="T1954"><vh>visitSliceobj</vh></v>
<v t="T1955"><vh>visitDict</vh></v>
</v>
</v>
<v t="T1956"><vh>class NestedScopeMixin</vh>
<v t="T1957"><vh>&lt;&lt; class NestedScopeMixin declarations &gt;&gt;</vh></v>
<v t="T1958"><vh>&lt;&lt; class NestedScopeMixin methods &gt;&gt;</vh>
<v t="T1959"><vh>initClass</vh></v>
</v>
</v>
<v t="T1960"><vh>class ModuleCodeGenerator</vh>
<v t="T1961"><vh>&lt;&lt; class ModuleCodeGenerator declarations &gt;&gt;</vh></v>
<v t="T1962"><vh>&lt;&lt; class ModuleCodeGenerator methods &gt;&gt;</vh>
<v t="T1963"><vh>__init__</vh></v>
<v t="T1964"><vh>get_module</vh></v>
</v>
</v>
<v t="T1965"><vh>class ExpressionCodeGenerator</vh>
<v t="T1966"><vh>&lt;&lt; class ExpressionCodeGenerator declarations &gt;&gt;</vh></v>
<v t="T1967"><vh>&lt;&lt; class ExpressionCodeGenerator methods &gt;&gt;</vh>
<v t="T1968"><vh>__init__</vh></v>
<v t="T1969"><vh>get_module</vh></v>
</v>
</v>
<v t="T1970"><vh>class InteractiveCodeGenerator</vh>
<v t="T1971"><vh>&lt;&lt; class InteractiveCodeGenerator declarations &gt;&gt;</vh></v>
<v t="T1972"><vh>&lt;&lt; class InteractiveCodeGenerator methods &gt;&gt;</vh>
<v t="T1973"><vh>__init__</vh></v>
<v t="T1974"><vh>get_module</vh></v>
<v t="T1975"><vh>visitDiscard</vh></v>
</v>
</v>
<v t="T1976"><vh>class AbstractFunctionCode</vh>
<v t="T1977"><vh>&lt;&lt; class AbstractFunctionCode declarations &gt;&gt;</vh></v>
<v t="T1978"><vh>&lt;&lt; class AbstractFunctionCode methods &gt;&gt;</vh>
<v t="T1979"><vh>__init__</vh></v>
<v t="T1980"><vh>get_module</vh></v>
<v t="T1981"><vh>finish</vh></v>
<v t="T1982"><vh>generateArgUnpack</vh></v>
<v t="T1983"><vh>unpackSequence</vh></v>
</v>
</v>
<v t="T1984"><vh>class FunctionCodeGenerator</vh>
<v t="T1985"><vh>&lt;&lt; class FunctionCodeGenerator declarations &gt;&gt;</vh></v>
<v t="T1986"><vh>&lt;&lt; class FunctionCodeGenerator methods &gt;&gt;</vh>
<v t="T1987"><vh>__init__</vh></v>
</v>
</v>
<v t="T1988"><vh>class AbstractClassCode</vh>
<v t="T1989"><vh>&lt;&lt; class AbstractClassCode methods &gt;&gt;</vh>
<v t="T1990"><vh>__init__</vh></v>
<v t="T1991"><vh>get_module</vh></v>
<v t="T1992"><vh>finish</vh></v>
</v>
</v>
<v t="T1993"><vh>class ClassCodeGenerator</vh>
<v t="T1994"><vh>&lt;&lt; class ClassCodeGenerator declarations &gt;&gt;</vh></v>
<v t="T1995"><vh>&lt;&lt; class ClassCodeGenerator methods &gt;&gt;</vh>
<v t="T1996"><vh>__init__</vh></v>
</v>
</v>
<v t="T1997"><vh>generateArgList</vh></v>
<v t="T1998"><vh>findOp</vh></v>
<v t="T1999"><vh>class OpFinder</vh>
<v t="T2000"><vh>&lt;&lt; class OpFinder methods &gt;&gt;</vh>
<v t="T2001"><vh>__init__</vh></v>
<v t="T2002"><vh>visitAssName</vh></v>
</v>
</v>
<v t="T2003"><vh>class Delegator</vh>
<v t="T2004"><vh>&lt;&lt; class Delegator declarations &gt;&gt;</vh></v>
<v t="T2005"><vh>&lt;&lt; class Delegator methods &gt;&gt;</vh>
<v t="T2006"><vh>__init__</vh></v>
<v t="T2007"><vh>__getattr__</vh></v>
</v>
</v>
<v t="T2008"><vh>class AugGetattr</vh>
<v t="T2009"><vh>&lt;&lt; class AugGetattr declarations &gt;&gt;</vh></v>
</v>
<v t="T2010"><vh>class AugName</vh>
<v t="T2011"><vh>&lt;&lt; class AugName declarations &gt;&gt;</vh></v>
</v>
<v t="T2012"><vh>class AugSlice</vh>
<v t="T2013"><vh>&lt;&lt; class AugSlice declarations &gt;&gt;</vh></v>
</v>
<v t="T2014"><vh>class AugSubscript</vh>
<v t="T2015"><vh>&lt;&lt; class AugSubscript declarations &gt;&gt;</vh></v>
</v>
<v t="T2016"><vh>wrap_aug</vh></v>
</v>
<v t="T2017"><vh>symbols.py</vh>
<v t="T2018"><vh>&lt;&lt; symbols declarations &gt;&gt;</vh></v>
<v t="T2019"><vh>class Scope</vh>
<v t="T2020"><vh>&lt;&lt; class Scope declarations &gt;&gt;</vh></v>
<v t="T2021"><vh>&lt;&lt; class Scope methods &gt;&gt;</vh>
<v t="T2022"><vh>__init__</vh></v>
<v t="T2023"><vh>__repr__</vh></v>
<v t="T2024"><vh>mangle</vh></v>
<v t="T2025"><vh>add_def</vh></v>
<v t="T2026"><vh>add_use</vh></v>
<v t="T2027"><vh>add_global</vh></v>
<v t="T2028"><vh>add_param</vh></v>
<v t="T2029"><vh>get_names</vh></v>
<v t="T2030"><vh>add_child</vh></v>
<v t="T2031"><vh>get_children</vh></v>
<v t="T2032"><vh>DEBUG</vh></v>
<v t="T2033"><vh>check_name</vh></v>
<v t="T2034"><vh>get_free_vars</vh></v>
<v t="T2035"><vh>handle_children</vh></v>
<v t="T2036"><vh>force_global</vh></v>
<v t="T2037"><vh>add_frees</vh></v>
<v t="T2038"><vh>get_cell_vars</vh></v>
</v>
</v>
<v t="T2039"><vh>class ModuleScope</vh>
<v t="T2040"><vh>&lt;&lt; class ModuleScope declarations &gt;&gt;</vh></v>
<v t="T2041"><vh>&lt;&lt; class ModuleScope methods &gt;&gt;</vh>
<v t="T2042"><vh>__init__</vh></v>
</v>
</v>
<v t="T2043"><vh>class FunctionScope</vh>
<v t="T2044"><vh>&lt;&lt; class FunctionScope declarations &gt;&gt;</vh></v>
</v>
<v t="T2045"><vh>class LambdaScope</vh>
<v t="T2046"><vh>&lt;&lt; class LambdaScope declarations &gt;&gt;</vh></v>
<v t="T2047"><vh>&lt;&lt; class LambdaScope methods &gt;&gt;</vh>
<v t="T2048"><vh>__init__</vh></v>
</v>
</v>
<v t="T2049"><vh>class ClassScope</vh>
<v t="T2050"><vh>&lt;&lt; class ClassScope declarations &gt;&gt;</vh></v>
<v t="T2051"><vh>&lt;&lt; class ClassScope methods &gt;&gt;</vh>
<v t="T2052"><vh>__init__</vh></v>
</v>
</v>
<v t="T2053"><vh>class SymbolVisitor</vh>
<v t="T2054"><vh>&lt;&lt; class SymbolVisitor methods &gt;&gt;</vh>
<v t="T2055"><vh>__init__</vh></v>
<v t="T2056"><vh>visitModule</vh></v>
<v t="T2057"><vh>visitFunction</vh></v>
<v t="T2058"><vh>visitLambda</vh></v>
<v t="T2059"><vh>_do_args</vh></v>
<v t="T2060"><vh>handle_free_vars</vh></v>
<v t="T2061"><vh>visitClass</vh></v>
<v t="T2062"><vh>visitName</vh></v>
<v t="T2063"><vh>visitFor</vh></v>
<v t="T2064"><vh>visitFrom</vh></v>
<v t="T2065"><vh>visitImport</vh></v>
<v t="T2066"><vh>visitGlobal</vh></v>
<v t="T2067"><vh>visitAssign</vh></v>
<v t="T2068"><vh>visitAssName</vh></v>
<v t="T2069"><vh>visitAssAttr</vh></v>
<v t="T2070"><vh>visitSubscript</vh></v>
<v t="T2071"><vh>visitSlice</vh></v>
<v t="T2072"><vh>visitAugAssign</vh></v>
<v t="T2073"><vh>visitIf</vh></v>
<v t="T2074"><vh>visitYield</vh></v>
</v>
</v>
<v t="T2075"><vh>sort</vh></v>
<v t="T2076"><vh>list_eq</vh></v>
<v t="T2077"><vh>get_names</vh></v>
</v>
<v t="T2078"><vh>syntax.py</vh>
<v t="T2079"><vh>check</vh></v>
<v t="T2080"><vh>class SyntaxErrorChecker</vh>
<v t="T2081"><vh>&lt;&lt; class SyntaxErrorChecker methods &gt;&gt;</vh>
<v t="T2082"><vh>__init__</vh></v>
<v t="T2083"><vh>error</vh></v>
<v t="T2084"><vh>visitAssign</vh></v>
</v>
</v>
</v>
<v t="T2085"><vh>transformer.py</vh>
<v t="T2086"><vh>&lt;&lt; transformer declarations &gt;&gt;</vh></v>
<v t="T2087"><vh>parseFile</vh></v>
<v t="T2088"><vh>parse</vh></v>
<v t="T2089"><vh>asList</vh></v>
<v t="T2090"><vh>Node</vh></v>
<v t="T2091"><vh>class Transformer</vh>
<v t="T2092"><vh>&lt;&lt; class Transformer methods &gt;&gt;</vh>
<v t="T2093"><vh>__init__</vh></v>
<v t="T2094"><vh>transform</vh></v>
<v t="T2095"><vh>parsesuite</vh></v>
<v t="T2096"><vh>parseexpr</vh></v>
<v t="T2097"><vh>parsefile</vh></v>
<v t="T2098"><vh>compile_node</vh></v>
<v t="T2099"><vh>single_input</vh></v>
<v t="T2100"><vh>file_input</vh></v>
<v t="T2101"><vh>eval_input</vh></v>
<v t="T2102"><vh>funcdef</vh></v>
<v t="T2103"><vh>lambdef</vh></v>
<v t="T2104"><vh>classdef</vh></v>
<v t="T2105"><vh>stmt</vh></v>
<v t="T2106"><vh>simple_stmt</vh></v>
<v t="T2107"><vh>parameters</vh></v>
<v t="T2108"><vh>varargslist</vh></v>
<v t="T2109"><vh>fpdef</vh></v>
<v t="T2110"><vh>fplist</vh></v>
<v t="T2111"><vh>dotted_name</vh></v>
<v t="T2112"><vh>comp_op</vh></v>
<v t="T2113"><vh>trailer</vh></v>
<v t="T2114"><vh>sliceop</vh></v>
<v t="T2115"><vh>argument</vh></v>
<v t="T2116"><vh>expr_stmt</vh></v>
<v t="T2117"><vh>print_stmt</vh></v>
<v t="T2118"><vh>del_stmt</vh></v>
<v t="T2119"><vh>pass_stmt</vh></v>
<v t="T2120"><vh>break_stmt</vh></v>
<v t="T2121"><vh>continue_stmt</vh></v>
<v t="T2122"><vh>return_stmt</vh></v>
<v t="T2123"><vh>yield_stmt</vh></v>
<v t="T2124"><vh>raise_stmt</vh></v>
<v t="T2125"><vh>import_stmt</vh></v>
<v t="T2126"><vh>global_stmt</vh></v>
<v t="T2127"><vh>exec_stmt</vh></v>
<v t="T2128"><vh>assert_stmt</vh></v>
<v t="T2129"><vh>if_stmt</vh></v>
<v t="T2130"><vh>while_stmt</vh></v>
<v t="T2131"><vh>for_stmt</vh></v>
<v t="T2132"><vh>try_stmt</vh></v>
<v t="T2133"><vh>suite</vh></v>
<v t="T2134"><vh>testlist</vh></v>
<v t="T2135"><vh>test</vh></v>
<v t="T2136"><vh>and_test</vh></v>
<v t="T2137"><vh>not_test</vh></v>
<v t="T2138"><vh>comparison</vh></v>
<v t="T2139"><vh>expr</vh></v>
<v t="T2140"><vh>xor_expr</vh></v>
<v t="T2141"><vh>and_expr</vh></v>
<v t="T2142"><vh>shift_expr</vh></v>
<v t="T2143"><vh>arith_expr</vh></v>
<v t="T2144"><vh>term</vh></v>
<v t="T2145"><vh>factor</vh></v>
<v t="T2146"><vh>power</vh></v>
<v t="T2147"><vh>atom</vh></v>
<v t="T2148"><vh>atom_lpar</vh></v>
<v t="T2149"><vh>atom_lsqb</vh></v>
<v t="T2150"><vh>atom_lbrace</vh></v>
<v t="T2151"><vh>atom_backquote</vh></v>
<v t="T2152"><vh>atom_number</vh></v>
<v t="T2153"><vh>atom_string</vh></v>
<v t="T2154"><vh>atom_name</vh></v>
<v t="T2155"><vh>lookup_node</vh></v>
<v t="T2156"><vh>com_node</vh></v>
<v t="T2157"><vh>com_NEWLINE</vh></v>
<v t="T2158"><vh>com_arglist</vh></v>
<v t="T2159"><vh>com_fpdef</vh></v>
<v t="T2160"><vh>com_fplist</vh></v>
<v t="T2161"><vh>com_dotted_name</vh></v>
<v t="T2162"><vh>com_dotted_as_name</vh></v>
<v t="T2163"><vh>com_import_as_name</vh></v>
<v t="T2164"><vh>com_bases</vh></v>
<v t="T2165"><vh>com_try_finally</vh></v>
<v t="T2166"><vh>com_try_except</vh></v>
<v t="T2167"><vh>com_augassign_op</vh></v>
<v t="T2168"><vh>com_augassign</vh></v>
<v t="T2169"><vh>com_assign</vh></v>
<v t="T2170"><vh>com_assign_tuple</vh></v>
<v t="T2171"><vh>com_assign_list</vh></v>
<v t="T2172"><vh>com_assign_name</vh></v>
<v t="T2173"><vh>com_assign_trailer</vh></v>
<v t="T2174"><vh>com_assign_attr</vh></v>
<v t="T2175"><vh>com_binary</vh></v>
<v t="T2176"><vh>com_stmt</vh></v>
<v t="T2177"><vh>com_append_stmt</vh></v>
<v t="T2178"><vh>com_list_constructor</vh></v>
<v t="T2179"><vh>com_list_constructor</vh></v>
<v t="T2180"><vh>com_dictmaker</vh></v>
<v t="T2181"><vh>com_apply_trailer</vh></v>
<v t="T2182"><vh>com_select_member</vh></v>
<v t="T2183"><vh>com_call_function</vh></v>
<v t="T2184"><vh>com_argument</vh></v>
<v t="T2185"><vh>com_subscriptlist</vh></v>
<v t="T2186"><vh>com_subscript</vh></v>
<v t="T2187"><vh>com_sliceobj</vh></v>
<v t="T2188"><vh>com_slice</vh></v>
<v t="T2189"><vh>get_docstring</vh></v>
</v>
</v>
<v t="T2190"><vh>debug_tree</vh></v>
</v>
<v t="T2191"><vh>visitor.py</vh>
<v t="T2192"><vh>class ASTVisitor</vh>
<v t="T2193"><vh>&lt;&lt; about ASTVisitor &gt;&gt;</vh></v>
<v t="T2194"><vh>&lt;&lt; class ASTVisitor methods &gt;&gt;</vh>
<v t="T2195"><vh>__init__</vh></v>
<v t="T2196"><vh>default</vh></v>
<v t="T2197"><vh>dispatch</vh></v>
<v t="T2198"><vh>preorder</vh></v>
</v>
</v>
<v t="T2199"><vh>class ExampleASTVisitor</vh>
<v t="T2200"><vh>&lt;&lt; about ExampleASTVisitor &gt;&gt;</vh></v>
<v t="T2201"><vh>&lt;&lt; class ExampleASTVisitor methods &gt;&gt;</vh>
<v t="T2202"><vh>dispatch</vh></v>
</v>
</v>
<v t="T2203"><vh>walk</vh></v>
<v t="T2204"><vh>dumpNode</vh></v>
</v>
</v>
<v t="T2205"><vh>inspect.py (lib) Ka-Ping Yee</vh>
<v t="T2206"><vh>Type checking...</vh>
<v t="T2207"><vh>ismodule</vh></v>
<v t="T2208"><vh>isclass</vh></v>
<v t="T2209"><vh>ismethod</vh></v>
<v t="T2210"><vh>ismethoddescriptor</vh></v>
<v t="T2211"><vh>isfunction</vh></v>
<v t="T2212"><vh>istraceback</vh></v>
<v t="T2213"><vh>isframe</vh></v>
<v t="T2214"><vh>iscode</vh></v>
<v t="T2215"><vh>isbuiltin</vh></v>
<v t="T2216"><vh>isroutine</vh></v>
<v t="T2217"><vh>getmembers</vh></v>
<v t="T2218"><vh>classify_class_attrs</vh></v>
</v>
<v t="T2219"><vh>Class helpers...</vh>
<v t="T2220"><vh>_searchbases</vh></v>
<v t="T2221"><vh>getmro</vh></v>
</v>
<v t="T2222"><vh>Source code extraction...</vh>
<v t="T2223"><vh>indentsize</vh></v>
<v t="T2224"><vh>getdoc</vh></v>
<v t="T2225"><vh>getfile</vh></v>
<v t="T2226"><vh>getmoduleinfo</vh></v>
<v t="T2227"><vh>getmodulename</vh></v>
<v t="T2228"><vh>getsourcefile</vh></v>
<v t="T2229"><vh>getabsfile</vh></v>
<v t="T2230"><vh>getmodule</vh></v>
<v t="T2231"><vh>findsource</vh></v>
<v t="T2232"><vh>getcomments</vh></v>
<v t="T2233"><vh>class ListReader</vh>
<v t="T2234"><vh>__init__</vh></v>
<v t="T2235"><vh>readline</vh></v>
</v>
<v t="T2236"><vh>class EndOfBlock</vh></v>
<v t="T2237"><vh>class BlockFinder</vh>
<v t="T2238"><vh>__init__</vh></v>
<v t="T2239"><vh>tokeneater</vh></v>
</v>
<v t="T2240"><vh>getblock</vh></v>
<v t="T2241"><vh>getsourcelines</vh></v>
<v t="T2242"><vh>getsource</vh></v>
</v>
<v t="T2243"><vh>Class tree extraction...</vh>
<v t="T2244"><vh>walktree</vh></v>
<v t="T2245"><vh>getclasstree</vh></v>
<v t="T2246"><vh>getargs</vh></v>
<v t="T2247"><vh>getargspec</vh></v>
<v t="T2248"><vh>getargvalues</vh></v>
<v t="T2249"><vh>joinseq</vh></v>
<v t="T2250"><vh>strseq</vh></v>
<v t="T2251"><vh>formatargspec</vh></v>
<v t="T2252"><vh>formatargvalues</vh></v>
</v>
<v t="T2253"><vh>Stack frame extraction...</vh>
<v t="T2254"><vh>getframeinfo</vh></v>
<v t="T2255" a="C"><vh>getlineno</vh></v>
<v t="T2256"><vh>getouterframes</vh></v>
<v t="T2257"><vh>getinnerframes</vh></v>
<v t="T2258"><vh>currentframe</vh></v>
<v t="T2259"><vh>stack</vh></v>
<v t="T2260"><vh>trace</vh></v>
</v>
</v>
<v t="T2261"><vh>tokenize.py (lib) Ka-Ping Yee</vh>
<v t="T2262"><vh>&lt;&lt; tokenize declarations &gt;&gt;</vh></v>
<v t="T2263"><vh>Define data</vh>
<v t="T2264"><vh>group</vh></v>
<v t="T2265"><vh>any</vh></v>
<v t="T2266"><vh>maybe</vh></v>
<v t="T2267"><vh>data</vh></v>
</v>
<v t="T2268"><vh>class TokenError</vh></v>
<v t="T2269"><vh>class StopTokenizing</vh></v>
<v t="T2270"><vh>printtoken</vh></v>
<v t="T2271"><vh>tokenize</vh></v>
<v t="T2272"><vh>tokenize_loop</vh></v>
<v t="T2273"><vh>generate_tokens</vh>
<v t="T2274"><vh>&lt;&lt; handle continued string &gt;&gt;</vh></v>
<v t="T2275"><vh>&lt;&lt; handle new statement &gt;&gt;</vh></v>
<v t="T2276"><vh>&lt;&lt; handle continued statement &gt;&gt;</vh></v>
<v t="T2277"><vh>&lt;&lt; scan for tokens &gt;&gt;</vh>
<v t="T2278"><vh>&lt;&lt; handle triple-quoted string &gt;&gt;</vh></v>
<v t="T2279"><vh>&lt;&lt; handle continued string &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="T2280"><vh>py_compile.py (lib) (calls builtin compile)</vh>
<v t="T2281"><vh>wr_long</vh></v>
<v t="T2282"><vh>compile (just calls __builtin__.compile)</vh></v>
</v>
<v t="T2283"><vh>imputil.py (lib)</vh>
<v t="T2284"><vh>&lt;&lt; to do &gt;&gt;</vh></v>
<v t="T2285"><vh>&lt;&lt; imputil declarations &gt;&gt;</vh></v>
<v t="T2286"><vh>class ImportManager</vh>
<v t="T2287"><vh>install</vh></v>
<v t="T2288"><vh>uninstall</vh></v>
<v t="T2289"><vh>add_suffix</vh></v>
<v t="T2290"><vh>private methods</vh>
<v t="T2291"><vh>__init__</vh></v>
<v t="T2292"><vh>_import_hook</vh></v>
<v t="T2293"><vh>_determine_import_context</vh></v>
<v t="T2294"><vh>_import_top_module</vh></v>
<v t="T2295"><vh>_reload_hook</vh></v>
</v>
</v>
<v t="T2296"><vh>class Importer</vh>
<v t="T2297"><vh>import_top</vh></v>
<v t="T2298"><vh>_finish_import</vh></v>
<v t="T2299"><vh>_import_one</vh></v>
<v t="T2300"><vh>_process_result</vh></v>
<v t="T2301"><vh>_load_tail</vh></v>
<v t="T2302"><vh>_import_fromlist</vh></v>
<v t="T2303"><vh>_do_import</vh></v>
<v t="T2304"><vh>get_code</vh></v>
</v>
<v t="T2305"><vh>_compile</vh></v>
<v t="T2306"><vh>_os_bootstrap</vh></v>
<v t="T2307"><vh>_os_path_isdir</vh></v>
<v t="T2308"><vh>_timestamp</vh></v>
<v t="T2309"><vh>class BuiltinImporter</vh>
<v t="T2310"><vh>get_code</vh></v>
</v>
<v t="T2311"><vh>class _FilesystemImporter</vh>
<v t="T2312"><vh>__init__</vh></v>
<v t="T2313"><vh>add_suffix</vh></v>
<v t="T2314"><vh>import_from_dir</vh></v>
<v t="T2315"><vh>get_code</vh></v>
<v t="T2316"><vh>_import_pathname</vh></v>
</v>
<v t="T2317"><vh>py_suffix_importer</vh></v>
<v t="T2318"><vh>class DynLoadSuffixImporter</vh>
<v t="T2319"><vh>__init__</vh></v>
<v t="T2320"><vh>import_file</vh></v>
</v>
<v t="T2321"><vh>_print_importers</vh></v>
<v t="T2322"><vh>_test_revamp</vh></v>
</v>
</v>
<v a="EV"><vh>This non-ascii text caused problems in previous versions of this file</vh>
<v t="T2255" a="C"><vh>getlineno</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="T1">@nocolor

8/24/02

I use this file to study the Python system.  It shows how one can organize even a large project into a single outline.  Doing so makes it much easier to find things.  I haven't changed this example outline:  it shows the aspects of Python in which I am most interested, and ignores the rest.

The marked nodes show Python's main interpreter loop.  Organizing this loop into sections greatly clarifies it.

Warning:  As distributed, all @file nodes are descendents of @ignore nodes.  This is on purpose.  Do _not_ try to recreate the actual source files from this file!</t>
<t tx="T2">@nocolor

2.1.8 Other Built-in Types 

The imp module allows access to import internals.

Section 17: Python Language Services
	17.10: Dis
		17.10.1 Python Byte Code Instructions

</t>
<t tx="T3">import dis, types
import leoAtFile
c = leoAtFile.atFile
dis.dis(c)

But it is even easier to do:

def f():
	whatever

dis.dis(f)</t>
<t tx="T4"></t>
<t tx="T5">2.1.8.1 Modules 
2.1.8.2 Classes and Class Instances 
2.1.8.3 Functions 
2.1.8.4 Methods 
2.1.8.5 Code Objects 
2.1.8.6 Type Objects 
2.1.8.7 The Null Object 
2.1.8.8 The Ellipsis Object 
2.1.8.9 File Objects  
2.1.8.10 Internal Objects </t>
<t tx="T6">2.1.8.1 Modules

The only special operation on a module is attribute access: m.name, where m is a module and name accesses a name defined in m's symbol table.

Module attributes can be assigned to. (Note that the import statement is not, strictly speaking, an operation on a module object; import foo does not require a module object named foo to exist, rather it requires an (external) definition for a module named foo somewhere.) 

A special member of every module is __dict__. This is the dictionary containing the module's symbol table. Modifying this dictionary will actually change the module's symbol table, but direct assignment to the __dict__ attribute is not possible (you can write m.__dict__['a'] = 1, which defines m.a to be 1, but you can't write m.__dict__ = {}. 

Modules built into the interpreter are written like this: &lt;module 'sys' (built-in)&gt;. If loaded from a file, they are written as &lt;module 'os' from '/usr/local/lib/python2.2/os.pyc'&gt;.</t>
<t tx="T7">2.1.8.5 Code Objects 
  
Code objects are used by the implementation to represent ``pseudo-compiled'' executable Python code such as a function body. They differ from function objects because they don't contain a reference to their global execution environment.

Code objects are returned by the built-in compile() function and can be extracted from function objects through their func_code attribute.

EKR:

functionObject.func_code</t>
<t tx="T8">2.1.8.2 Classes and Class Instances

See chapters 3 and 7 of the Python Reference Manual for these</t>
<t tx="T9">callable(object)

Return true if the object argument appears callable, false if not.

filter(function, list)

Construct a list from those elements of list for which function returns true. list may be either a sequence, a container which supports iteration, or an iterator, If list is a string or a tuple, the result also has that type; otherwise it is always a list. If function is None, the identity function is assumed, that is, all elements of list that are false (zero or empty) are removed. 

getattr(object, name[, default])

Return the value of the named attributed of object. name must be a string. If the string is the name of one of the object's attributes, the result is the value of that attribute. For example, getattr(x, 'foobar') is equivalent to x.foobar. If the named attribute does not exist, default is returned if provided, otherwise AttributeError is raised.

hasattr(object, name)

The arguments are an object and a string. The result is 1 if the string is the name of one of the object's attributes, 0 if not. (This is implemented by calling getattr(object, name) and seeing whether it raises an exception or not.) 

isinstance(object, class)

Return true if the object argument is an instance of the class argument, or of a (direct or indirect) subclass thereof. Also return true if class is a type object and object is an object of that type. If object is not a class instance or a object of the given type, the function always returns false. If class is neither a class object nor a type object, a TypeError exception is raised. 

issubclass(class1, class2)

Return true if class1 is a subclass (direct or indirect) of class2. A class is considered a subclass of itself. If either argument is not a class object, a TypeError exception is raised.</t>
<t tx="T10"></t>
<t tx="T11">3.2 The standard type hierarchy

Below is a list of the types that are built into Python. Extension modules written in C can define additional types. Future versions of Python may add types to the type hierarchy (e.g., rational numbers, efficiently stored arrays of integers, etc.).   

Some of the type descriptions below contain a paragraph listing `special attributes.' These are attributes that provide access to the implementation and are not intended for general use. Their definition may change in the future.

There are also some `generic' special attributes, not listed with the individual objects:
__methods__ is a list of the method names of a built-in object, if it has any;
__members__ is a list of the data attribute names of a built-in object, if it has any. </t>
<t tx="T12">None

This type has a single value. There is a single object with this value. This object is accessed through the built-in name None. It is used to signify the absence of a value in many situations, e.g., it is returned from functions that don't explicitly return anything. Its truth value is false.</t>
<t tx="T13">NotImplemented

This type has a single value. There is a single object with this value. This object is accessed through the built-in name NotImplemented. Numeric methods and rich comparison methods may return this value if they do not implement the operation for the operands provided. (The interpreter will then try the reflected operation, or some other fallback, depending on the operator.) Its truth value is true.</t>
<t tx="T14">Ellipsis

This type has a single value. There is a single object with this value. This object is accessed through the built-in name Ellipsis. It is used to indicate the presence of the "..." syntax in a slice. Its truth value is true.</t>
<t tx="T15">Numbers

These are created by numeric literals and returned as results by arithmetic operators and arithmetic built-in functions. Numeric objects are immutable; once created their value never changes. Python numbers are of course strongly related to mathematical numbers, but subject to the limitations of numerical representation in computers. 

Python distinguishes between integers, floating point numbers, and complex numbers: 

Integers 
These represent elements from the mathematical set of whole numbers. 
There are two types of integers: 

Plain integers 
These represent numbers in the range -2147483648 through 2147483647. (The range may be larger on machines with a larger natural word size, but not smaller.) When the result of an operation would fall outside this range, the exception OverflowError is raised. For the purpose of shift and mask operations, integers are assumed to have a binary, 2's complement notation using 32 or more bits, and hiding no bits from the user (i.e., all 4294967296 different bit patterns correspond to different values).   

Long integers 
These represent numbers in an unlimited range, subject to available (virtual) memory only. For the purpose of shift and mask operations, a binary representation is assumed, and negative numbers are represented in a variant of 2's complement which gives the illusion of an infinite string of sign bits extending to the left. 

The rules for integer representation are intended to give the most meaningful interpretation of shift and mask operations involving negative integers and the least surprises when switching between the plain and long integer domains. For any operation except left shift, if it yields a result in the plain integer domain without causing overflow, it will yield the same result in the long integer domain or when using mixed operands. 

Floating point numbers 
These represent machine-level double precision floating point numbers. You are at the mercy of the underlying machine architecture and C implementation for the accepted range and handling of overflow. Python does not support single-precision floating point numbers; the savings in processor and memory usage that are usually the reason for using these is dwarfed by the overhead of using objects in Python, so there is no reason to complicate the language with two kinds of floating point numbers. 

Complex numbers 
These represent complex numbers as a pair of machine-level double precision floating point numbers. The same caveats apply as for floating point numbers. The real and imaginary value of a complex number z can be retrieved through the attributes z.real and z.imag.</t>
<t tx="T16">Sequences

These represent finite ordered sets indexed by non-negative numbers. The built-in function len() returns the number of items of a sequence. When the length of a sequence is n, the index set contains the numbers 0, 1, ..., n-1. Item i of sequence a is selected by a[i].

Sequences also support slicing: a[i:j] selects all items with index k such that i &lt;= k &lt; j. When used as an expression, a slice is a sequence of the same type. This implies that the index set is renumbered so that it starts at 0.

Immutable sequences

An object of an immutable sequence type cannot change once it is created. (If the object contains references to other objects, these other objects may be mutable and may be changed; however, the collection of objects directly referenced by an immutable object cannot change.) 
The following types are immutable sequences: 

Strings 
The items of a string are characters. There is no separate character type; a character is represented by a string of one item. Characters represent (at least) 8-bit bytes. The built-in functions chr() and ord() convert between characters and nonnegative integers representing the byte values. Bytes with the values 0-127 usually represent the corresponding ASCII values, but the interpretation of values is up to the program. The string data type is also used to represent arrays of bytes, e.g., to hold data read from a file. 
(On systems whose native character set is not ASCII, strings may use EBCDIC in their internal representation, provided the functions chr() and ord() implement a mapping between ASCII and EBCDIC, and string comparison preserves the ASCII order. Or perhaps someone can propose a better rule?) 

Unicode 
The items of a Unicode object are Unicode characters. A Unicode character is represented by a Unicode object of one item and can hold a 16-bit value representing a Unicode ordinal. The built-in functions unichr() and ord() convert between characters and nonnegative integers representing the Unicode ordinals as defined in the Unicode Standard 3.0. Conversion from and to other encodings are possible through the Unicode method encode and the built-in function unicode()  

Tuples 
The items of a tuple are arbitrary Python objects. Tuples of two or more items are formed by comma-separated lists of expressions. A tuple of one item (a `singleton') can be formed by affixing a comma to an expression (an expression by itself does not create a tuple, since parentheses must be usable for grouping of expressions). An empty tuple can be formed by an empty pair of parentheses. 

Mutable sequences

Mutable sequences can be changed after they are created. The subscription and slicing notations can be used as the target of assignment and del (delete) statements. 
There is currently a single mutable sequence type: 

Lists 
The items of a list are arbitrary Python objects. Lists are formed by placing a comma-separated list of expressions in square brackets. (Note that there are no special cases needed to form lists of length 0 or 1.) 

The extension module array provides an additional example of a mutable sequence type. </t>
<t tx="T17">Mappings

These represent finite sets of objects indexed by arbitrary index sets. The subscript notation a[k] selects the item indexed by k from the mapping a; this can be used in expressions and as the target of assignments or del statements. The built-in function len() returns the number of items in a mapping.
 
There is currently a single intrinsic mapping type: 

Dictionaries 
These represent finite sets of objects indexed by nearly arbitrary values. The only types of values not acceptable as keys are values containing lists or dictionaries or other mutable types that are compared by value rather than by object identity, the reason being that the efficient implementation of dictionaries requires a key's hash value to remain constant. Numeric types used for keys obey the normal rules for numeric comparison: if two numbers compare equal (e.g., 1 and 1.0) then they can be used interchangeably to index the same dictionary entry.

Dictionaries are mutable; they are created by the {...} notation (see section 5.2.5, ``Dictionary Displays''). 

The extension modules dbm  gdbm  bsddb provide additional examples of mapping types.</t>
<t tx="T18">Callable types

These are the types to which the function call operation (see section 5.3.4, ``Calls'') can be applied: 

User-defined functions 
A user-defined function object is created by a function definition (see section 7.5, ``Function definitions''). It should be called with an argument list containing the same number of items as the function's formal parameter list. 
Special attributes: func_doc or __doc__ is the function's documentation string, or None if unavailable; func_name or __name__ is the function's name; func_defaults is a tuple containing default argument values for those arguments that have defaults, or None if no arguments have a default value; func_code is the code object representing the compiled function body; func_globals is (a reference to) the dictionary that holds the function's global variables -- it defines the global namespace of the module in which the function was defined; func_dict or __dict__ contains the namespace supporting arbitrary function attributes; func_closure is None or a tuple of cells that contain binding for the function's free variables. 

Of these, func_code, func_defaults, func_closure, func_doc/__doc__, and func_dict/__dict__ may be writable; the others can never be changed. Additional information about a function's definition can be retrieved from its code object; see the description of internal types below. 

In Python 2.1, the func_closure slot is always None unless nested scopes are enabled. (See the appendix.) 

User-defined methods 
A user-defined method object combines a class, a class instance (or None) and any callable object (normally a user-defined function). 
Special read-only attributes: im_self is the class instance object, im_func is the function object; im_class is the class that defined the method (which may be a base class of the class of which im_self is an instance); __doc__ is the method's documentation (same as im_func.__doc__); __name__ is the method name (same as im_func.__name__).   

Methods also support accessing (but not setting) the arbitrary function attributes on the underlying function object. 

User-defined method objects are created in two ways: when getting an attribute of a class that is a user-defined function object, or when getting an attribute of a class instance that is a user-defined function object defined by the class of the instance. In the former case (class attribute), the im_self attribute is None, and the method object is said to be unbound; in the latter case (instance attribute), im_self is the instance, and the method object is said to be bound. For instance, when C is a class which contains a definition for a function f(), C.f does not yield the function object f; rather, it yields an unbound method object m where m.im_class is C, m.im_func is f(), and m.im_self is None. When x is a C instance, x.f yields a bound method object m where m.im_class is C, m.im_func is f(), and m.im_self is x.   

When an unbound user-defined method object is called, the underlying function (im_func) is called, with the restriction that the first argument must be an instance of the proper class (im_class) or of a derived class thereof. 

When a bound user-defined method object is called, the underlying function (im_func) is called, inserting the class instance (im_self) in front of the argument list. For instance, when C is a class which contains a definition for a function f(), and x is an instance of C, calling x.f(1) is equivalent to calling C.f(x, 1). 

Note that the transformation from function object to (unbound or bound) method object happens each time the attribute is retrieved from the class or instance. In some cases, a fruitful optimization is to assign the attribute to a local variable and call that local variable. Also notice that this transformation only happens for user-defined functions; other callable objects (and all non-callable objects) are retrieved without transformation. It is also important to note that user-defined functions which are attributes of a class instance are not converted to bound methods; this only happens when the function is an attribute of the class. 

Built-in functions 
A built-in function object is a wrapper around a C function. Examples of built-in functions are len() and math.sin() (math is a standard built-in module). The number and type of the arguments are determined by the C function. Special read-only attributes: __doc__ is the function's documentation string, or None if unavailable; __name__ is the function's name; __self__ is set to None (but see the next item). 

Built-in methods 
This is really a different disguise of a built-in function, this time containing an object passed to the C function as an implicit extra argument. An example of a built-in method is list.append(), assuming list is a list object. In this case, the special read-only attribute __self__ is set to the object denoted by list.

Classes 
Class objects are described below. When a class object is called, a new class instance (also described below) is created and returned. This implies a call to the class's __init__() method if it has one. Any arguments are passed on to the __init__() method. If there is no __init__() method, the class must be called without arguments.    

Class instances 
Class instances are described below. Class instances are callable only when the class has a __call__() method; x(arguments) is a shorthand for x.__call__(arguments).</t>
<t tx="T19">Modules 
Modules are imported by the import statement (see section 6.11, ``The import statement''). A module object has a namespace implemented by a dictionary object (this is the dictionary referenced by the func_globals attribute of functions defined in the module). Attribute references are translated to lookups in this dictionary, e.g., m.x is equivalent to m.__dict__["x"]. A module object does not contain the code object used to initialize the module (since it isn't needed once the initialization is done). 
Attribute assignment updates the module's namespace dictionary, e.g., "m.x = 1" is equivalent to "m.__dict__["x"] = 1". 

Special read-only attribute: __dict__ is the module's namespace as a dictionary object.   

Predefined (writable) attributes: __name__ is the module's name; __doc__ is the module's documentation string, or None if unavailable; __file__ is the pathname of the file from which the module was loaded, if it was loaded from a file. The __file__ attribute is not present for C modules that are statically linked into the interpreter; for extension modules loaded dynamically from a shared library, it is the pathname of the shared library file.    
</t>
<t tx="T20">Classes 
Class objects are created by class definitions (see section 7.6, ``Class definitions''). A class has a namespace implemented by a dictionary object. Class attribute references are translated to lookups in this dictionary, e.g., "C.x" is translated to "C.__dict__["x"]". When the attribute name is not found there, the attribute search continues in the base classes. The search is depth-first, left-to-right in the order of occurrence in the base class list. When a class attribute reference would yield a user-defined function object, it is transformed into an unbound user-defined method object (see above). The im_class attribute of this method object is the class in which the function object was found, not necessarily the class for which the attribute reference was initiated. 
Class attribute assignments update the class's dictionary, never the dictionary of a base class. 

A class object can be called (see above) to yield a class instance (see below). 

Special attributes: __name__ is the class name; __module__ is the module name in which the class was defined; __dict__ is the dictionary containing the class's namespace; __bases__ is a tuple (possibly empty or a singleton) containing the base classes, in the order of their occurrence in the base class list; __doc__ is the class's documentation string, or None if undefined.   
</t>
<t tx="T21">Class instances 
A class instance is created by calling a class object (see above). A class instance has a namespace implemented as a dictionary which is the first place in which attribute references are searched. When an attribute is not found there, and the instance's class has an attribute by that name, the search continues with the class attributes. If a class attribute is found that is a user-defined function object (and in no other case), it is transformed into an unbound user-defined method object (see above). The im_class attribute of this method object is the class in which the function object was found, not necessarily the class of the instance for which the attribute reference was initiated. If no class attribute is found, and the object's class has a __getattr__() method, that is called to satisfy the lookup. 
Attribute assignments and deletions update the instance's dictionary, never a class's dictionary. If the class has a __setattr__() or __delattr__() method, this is called instead of updating the instance dictionary directly. 

Class instances can pretend to be numbers, sequences, or mappings if they have methods with certain special names. See section 3.3, ``Special method names.'' 

Special attributes: __dict__ is the attribute dictionary; __class__ is the instance's class.   

</t>
<t tx="T22">Files 
A file object represents an open file. File objects are created by the open() built-in function, and also by  os.popen(), os.fdopen(), and the makefile() method of socket objects (and perhaps by other functions or methods provided by extension modules). The objects sys.stdin, sys.stdout and sys.stderr are initialized to file objects corresponding to the interpreter's standard input, output and error streams. See the Python Library Reference for complete documentation of file objects.   </t>
<t tx="T23">Internal types

A few types used internally by the interpreter are exposed to the user. Their definitions may change with future versions of the interpreter, but they are mentioned here for completeness.</t>
<t tx="T24">@nocolor

Code objects

Code objects represent byte-compiled executable Python code, or bytecode.

The difference between a code object and a function object is that the function object contains an explicit reference to the function's globals (the module in which it was defined), while a code object contains no context; also the default argument values are stored in the function object, not in the code object (because they represent values calculated at run-time). Unlike function objects, code objects are immutable and contain no references (directly or indirectly) to mutable objects.

Special read-only attributes:

co_name gives the function name;
co_argcount is the number of positional arguments (including arguments with default values);
co_nlocals is the number of local variables used by the function (including arguments);
co_varnames is a tuple containing the names of the local variables (starting with the argument names); co_cellvars is a tuple containing the names of local variables that are referenced by nested functions; co_freevars is a tuple containing the names of local variables that are neither local nor global;
	The co_cellvars and co_freevars are present in Python 2.1 when nested scopes are not enabled,
	but the code itself does not use or create cells.
co_code is a string representing the sequence of bytecode instructions;
co_consts is a tuple containing the literals used by the bytecode;
	If a code object represents a function, the first item in co_consts is
	the documentation string of the function, or None if undefined. 
co_names is a tuple containing the names used by the bytecode;
co_filename is the filename from which the code was compiled;
co_firstlineno is the first line number of the function;
co_lnotab is a string encoding the mapping from byte code offsets to line numbers
	(for details see the source code of the interpreter);
co_stacksize is the required stack size (including local variables);
co_flags is an integer encoding a number of flags for the interpreter.
	The following flag bits are defined for co_flags:
	other bits are used internally or reserved for future use;
	bit 0x04 is set if the function uses the "*arguments" syntax to
		accept an arbitrary number of positional arguments;
	bit 0x08 is set if the function uses the "**keywords" syntax to accept arbitrary keyword arguments;
	bit 0x10 is set if the function was compiled with nested scopes enabled.</t>
<t tx="T25">Frame objects

Frame objects represent execution frames. They may occur in traceback objects (see below).

Special read-only attributes:

f_back: the previous stack frame (towards the caller),
	or None if this is the bottom stack frame;
f_code: the code object being executed in this frame;
f_locals: the dictionary used to look up local variables;
f_globals: used for global variables;
f_builtins: used for built-in (intrinsic) names;
f_restricted: true if the function is executing in restricted execution mode;
f_lineno: the line number
f_lasti: the precise instruction, an index into the bytecode string of the code object.   

Special writable attributes: f_trace, if not None, is a function called at the start of each source code line (this is used by the debugger); f_exc_type, f_exc_value, f_exc_traceback represent the most recent exception caught in this frame.   
</t>
<t tx="T26">Traceback objects

Traceback objects represent a stack trace of an exception. A traceback object is created when an exception occurs. When the search for an exception handler unwinds the execution stack, at each unwound level a traceback object is inserted in front of the current traceback. When an exception handler is entered, the stack trace is made available to the program. (See section 7.4, ``The try statement.'') It is accessible as sys.exc_traceback, and also as the third item of the tuple returned by sys.exc_info(). The latter is the preferred interface, since it works correctly when the program is using multiple threads. When the program contains no suitable handler, the stack trace is written (nicely formatted) to the standard error stream; if the interpreter is interactive, it is also made available to the user as sys.last_traceback.
   
Special read-only attributes:
tb_next is the next level in the stack trace
	(towards the frame where the exception occurred), or None if there is no next level;
tb_frame points to the execution frame of the current level;
tb_lineno gives the line number where the exception occurred;
tb_lasti indicates the precise instruction.

The line number and last instruction in the traceback may differ from the line number of its frame object if the exception occurred in a try statement with no matching except clause or with a finally clause.</t>
<t tx="T27">Slice objects

Slice objects are used to represent slices when extended slice syntax is used. This is a slice using two colons, or multiple slices or ellipses separated by commas, e.g., a[i:j:step], a[i:j, k:l], or a[..., i:j]). They are also created by the built-in slice() function. 
Special read-only attributes: start is the lower bound; stop is the upper bound; step is the step value; each is None if omitted. These attributes can have any type.</t>
<t tx="T28">7.5 Function definitions 
  
A function definition defines a user-defined function object (see section 3.2):   

A function definition is an executable statement. Its execution binds the function name in the current local namespace to a function object (a wrapper around the executable code for the function). This function object contains a reference to the current global namespace as the global namespace to be used when the function is called.   

The function definition does not execute the function body; this gets executed only when the function is called. 

When one or more top-level parameters have the form parameter = expression, the function is said to have ``default parameter values.'' For a parameter with a default value, the corresponding argument may be omitted from a call, in which case the parameter's default value is substituted. If a parameter has a default value, all following parameters must also have a default value -- this is a syntactic restriction that is not expressed by the grammar.   

Default parameter values are evaluated when the function definition is executed. This means that the expression is evaluated once, when the function is defined, and that that same ``pre-computed'' value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use None as the default, and explicitly test for it in the body of the function, e.g.: 

def whats_on_the_telly(penguin=None):
    if penguin is None:
        penguin = []
    penguin.append("property of the zoo")
    return penguin

Function call semantics are described in more detail in section 5.3.4. A function call always assigns values to all parameters mentioned in the parameter list, either from position arguments, from keyword arguments, or from default values. If the form ``*identifier'' is present, it is initialized to a tuple receiving any excess positional parameters, defaulting to the empty tuple. If the form ``**identifier'' is present, it is initialized to a new dictionary receiving any excess keyword arguments, defaulting to a new empty dictionary. 

It is also possible to create anonymous functions (functions not bound to a name), for immediate use in expressions. This uses lambda forms, described in section 5.10. Note that the lambda form is merely a shorthand for a simplified function definition; a function defined in a ``def'' statement can be passed around or assigned to another name just like a function defined by a lambda form. The ``def'' form is actually more powerful since it allows the execution of multiple statements.   

Programmer's note: a ``def'' form executed inside a function definition defines a local function that can be returned or passed around. The semantics of name resolution in the nested function will change in Python 2.2. See the appendix for a description of the new semantics. </t>
<t tx="T29">7.6 Class definitions 
  
A class definition defines a class object (see section 3.2):   

A class definition is an executable statement. It first evaluates the inheritance list, if present. Each item in the inheritance list should evaluate to a class object. The class's suite is then executed in a new execution frame (see section 4.1), using a newly created local namespace and the original global namespace. (Usually, the suite contains only function definitions.) When the class's suite finishes execution, its execution frame is discarded but its local namespace is saved. A class object is then created using the inheritance list for the base classes and the saved local namespace for the attribute dictionary. The class name is bound to this class object in the original local namespace.   

Programmer's note: variables defined in the class definition are class variables; they are shared by all instances. To define instance variables, they must be given a value in the the __init__() method or in another method. Both class and instance variables are accessible through the notation ``self.name'', and an instance variable hides a class variable with the same name when accessed in this way. Class variables with immutable values can be used as defaults for instance variables.</t>
<t tx="T30">@nocolor
@color
17.10.1 Python Byte Code Instructions

The Python compiler currently generates the following byte code instructions.

An argument is two bytes, with the more significant byte last.

STOP_CODE 
Indicates end-of-code to the compiler, not used by the interpreter.

SET_LINENO    lineno 
Sets the current line number to lineno.

&lt;&lt; arithmetic &amp; compare ops &gt;&gt;
&lt;&lt; block, class, closure, function ops &gt;&gt;
&lt;&lt; call ops &gt;&gt;
&lt;&lt; del ops &gt;&gt;
&lt;&lt; exception ops &gt;&gt;
&lt;&lt; import ops &gt;&gt;
&lt;&lt; jump ops &gt;&gt;
&lt;&lt; load/store ops &gt;&gt;
&lt;&lt; loop ops &gt;&gt;
&lt;&lt; print ops &gt;&gt;
&lt;&lt; stack ops &gt;&gt; # includes constants &amp; build values.
&lt;&lt; string ops &gt;&gt;</t>
<t tx="T31">@nocolor
@color

COMPARE_OP  opname 
Performs a boolean operation. The operation name can be found in cmp_op[opname].

&lt;&lt; unary ops &gt;&gt;
&lt;&lt; binary ops &gt;&gt;
&lt;&lt; inplace (stack) binary ops &gt;&gt;</t>
<t tx="T32">UNARY_POSITIVE 
Implements TOS = +TOS. 

UNARY_NEGATIVE 
Implements TOS = -TOS. 

UNARY_NOT 
Implements TOS = not TOS. 

UNARY_CONVERT 
Implements TOS = `TOS`. 

UNARY_INVERT 
Implements TOS = ~TOS.</t>
<t tx="T33">Binary operations remove the top of the stack (TOS) and the second top-most stack item (TOS1) from the stack. They perform the operation, and put the result back on the stack.

BINARY_POWER 
Implements TOS = TOS1 ** TOS. 

BINARY_MULTIPLY 
Implements TOS = TOS1 * TOS. 

BINARY_DIVIDE 
Implements TOS = TOS1 / TOS. 

BINARY_MODULO 
Implements TOS = TOS1 % TOS. 

BINARY_ADD 
Implements TOS = TOS1 + TOS. 

BINARY_SUBTRACT 
Implements TOS = TOS1 - TOS. 

BINARY_SUBSCR 
Implements TOS = TOS1[TOS]. 

BINARY_LSHIFT 
Implements TOS = TOS1 &lt;&lt; TOS. 

BINARY_RSHIFT 
Implements TOS = TOS1 &gt;&gt; TOS. 

BINARY_AND 
Implements TOS = TOS1 &amp; TOS. 

BINARY_XOR 
Implements TOS = TOS1 ^ TOS. 

BINARY_OR 
Implements TOS = TOS1 | TOS. </t>
<t tx="T34">In-place operations are like binary operations, in that they remove TOS and TOS1, and push the result back on the stack, but the operation is done in-place when TOS1 supports it, and the resulting TOS may be (but does not have to be) the original TOS1.

INPLACE_POWER 
Implements in-place TOS = TOS1 ** TOS.

INPLACE_MULTIPLY 
Implements in-place TOS = TOS1 * TOS. 

INPLACE_DIVIDE 
Implements in-place TOS = TOS1 / TOS. 

INPLACE_MODULO 
Implements in-place TOS = TOS1 % TOS. 

INPLACE_ADD 
Implements in-place TOS = TOS1 + TOS. 

INPLACE_SUBTRACT 
Implements in-place TOS = TOS1 - TOS. 

INPLACE_LSHIFT 
Implements in-place TOS = TOS1 &lt;&lt; TOS. 

INPLACE_RSHIFT 
Implements in-place TOS = TOS1 &gt;&gt; TOS. 

INPLACE_AND 
Implements in-place TOS = TOS1 &amp; TOS. 

INPLACE_XOR 
Implements in-place TOS = TOS1 ^ TOS. 

INPLACE_OR 
Implements in-place TOS = TOS1 | TOS. 
The slice opcodes take up to three parameters.</t>
<t tx="T35">BUILD_CLASS 
Creates a new class object. TOS is the methods dictionary, TOS1 the tuple of the names of the base classes, and TOS2 the class name.

EXEC_STMT 
Implements exec TOS2,TOS1,TOS. The compiler fills missing optional parameters with None.

MAKE_FUNCTION    argc 
Pushes a new function object on the stack. TOS is the code associated with the function. The function object is defined to have argc default parameters, which are found below TOS. 

MAKE_CLOSURE    argc 
Creates a new function object, sets its func_closure slot, and pushes it on the stack. TOS is the code associated with the function. If the code object has N free variables, the next N items on the stack are the cells for these variables. The function also has argc default parameters, where are found before the cells.

POP_BLOCK 
Removes one block from the block stack. Per frame, there is a stack of blocks, denoting nested loops, try statements, and such. 

RETURN_VALUE 
Returns with TOS to the caller of the function. </t>
<t tx="T36">CALL_FUNCTION  argc 
Calls a function.
The low byte of argc indicates the number of positional parameters,
the high byte the number of keyword parameters.
On the stack, the opcode finds the keyword parameters first.
For each keyword argument, the value is on top of the key.
Below the keyword parameters, the positional parameters are on the stack,
with the right-most parameter on top.
Below the parameters, the function object to call is on the stack.

CALL_FUNCTION_VAR  argc 
Calls a function. argc is interpreted as in CALL_FUNCTION.
The top element on the stack contains the variable argument list,
followed by keyword and positional arguments. 

CALL_FUNCTION_KW  argc 
Calls a function. argc is interpreted as in CALL_FUNCTION.
The top element on the stack contains the keyword arguments dictionary,
followed by explicit keyword and positional arguments. 

CALL_FUNCTION_VAR_KW  argc 
Calls a function. argc is interpreted as in CALL_FUNCTION.
The top element on the stack contains the keyword arguments dictionary,
followed by the variable-arguments tuple,
followed by explicit keyword and positional arguments.</t>
<t tx="T37">DELETE_ATTR  namei 
Implements del TOS.name, using namei as index into co_names. 

DELETE_FAST  var_num 
Deletes local co_varnames[var_num].

DELETE_GLOBAL namei 
Works as DELETE_NAME, but deletes a global name.

DELETE_NAME  namei 
Implements del name, where namei is the index into co_names attribute of the code object.

DELETE_SUBSCR 
Implements del TOS1[TOS].</t>
<t tx="T38">SETUP_EXCEPT  delta 
Pushes a try block from a try-except clause onto the block stack. delta points to the first except block. 

SETUP_FINALLY  delta 
Pushes a try block from a try-except clause onto the block stack. delta points to the finally block.

END_FINALLY 
Terminates a finally clause. The interpreter recalls whether the exception has to be re-raised, or whether the function returns, and continues with the outer-next block.

RAISE_VARARGS  argc 
Raises an exception. argc indicates the number of parameters to the raise statement, ranging from 0 to 3. The handler will find the traceback as TOS2, the parameter as TOS1, and the exception as TOS. </t>
<t tx="T39">IMPORT_FROM  namei 
Loads the attribute co_names[namei] from the module found in TOS. The resulting object is pushed onto the stack, to be subsequently stored by a STORE_FAST instruction.

IMPORT_NAME  namei 
Imports the module co_names[namei]. The module object is pushed onto the stack. The current namespace is not affected: for a proper import statement, a subsequent STORE_FAST instruction modifies the namespace. 

IMPORT_STAR 
Loads all symbols not starting with "_" directly from the module TOS to the local namespace. The module is popped after loading all names. This opcode implements from module import *.</t>
<t tx="T40">JUMP_FORWARD    delta 
Increments byte code counter by delta. 

JUMP_IF_TRUE    delta 
If TOS is true, increment the byte code counter by delta. TOS is left on the stack. 

JUMP_IF_FALSE    delta 
If TOS is false, increment the byte code counter by delta. TOS is not changed. 

JUMP_ABSOLUTE    target 
Set byte code counter to target.</t>
<t tx="T41">EXTENDED_ARG  ext 
Prefixes any opcode which has an argument too big to fit into the default two bytes. ext holds two additional bytes which, taken together with the subsequent opcode's argument, comprise a four-byte argument, ext being the two most-significant bytes. 

LOAD_ATTR  namei 
Replaces TOS with getattr(TOS, co_names[namei].

LOAD_CLOSURE  i 
Pushes a reference to the cell contained in slot i of the cell and free variable storage.
The name of the variable is co_cellvars[i] if i is less than the length of co_cellvars.
Otherwise it is co_freevars[i - len(co_cellvars)]. 

LOAD_DEREF  i 
Loads the cell contained in slot i of the cell and free variable storage.
Pushes a reference to the object the cell contains on the stack. 

LOAD_FAST  var_num 
Pushes a reference to the local co_varnames[var_num] onto the stack.

LOAD_GLOBAL  namei 
Loads the global named co_names[namei] onto the stack.

LOAD_LOCALS 
Pushes a reference to the locals of the current scope on the stack. This is used in the code for a class definition: After the class body is evaluated, the locals are passed to the class definition.

LOAD_NAME  namei 
Pushes the value associated with "co_names[namei]" onto the stack.

STORE_ATTR  namei 
Implements TOS.name = TOS1, where namei is the index of name in co_names.

STORE_DEREF  i 
Stores TOS into the cell contained in slot i of the cell and free variable storage. 

STORE_FAST  var_num 
Stores TOS into the local co_varnames[var_num]. 

STORE_NAME  namei 
Implements name = TOS. namei is the index of name in the attribute co_names of the code object. The compiler tries to use STORE_LOCAL or STORE_GLOBAL if possible. 

STORE_GLOBAL  namei 
Works as STORE_NAME, but stores the name as a global.</t>
<t tx="T42">BREAK_LOOP 
Terminates a loop due to a break statement.

FOR_LOOP    delta 
Iterate over a sequence. TOS is the current index, TOS1 the sequence. First, the next element is computed. If the sequence is exhausted, increment byte code counter by delta. Otherwise, push the sequence, the incremented counter, and the current item onto the stack. 

SETUP_LOOP    delta 
Pushes a block for a loop onto the block stack. The block spans from the current instruction with a size of delta bytes. </t>
<t tx="T43">PRINT_EXPR 
Implements the expression statement for the interactive mode. TOS is removed from the stack and printed. In non-interactive mode, an expression statement is terminated with POP_STACK. 

PRINT_ITEM 
Prints TOS to the file-like object bound to sys.stdout. There is one such instruction for each item in the print statement. 

PRINT_ITEM_TO 
Like PRINT_ITEM, but prints the item second from TOS to the file-like object at TOS. This is used by the extended print statement. 

PRINT_NEWLINE 
Prints a new line on sys.stdout. This is generated as the last operation of a print statement, unless the statement ends with a comma. 

PRINT_NEWLINE_TO 
Like PRINT_NEWLINE, but prints the new line on the file-like object on the TOS. This is used by the extended print statement.</t>
<t tx="T44">BUILD_LIST    count 
Works as BUILD_TUPLE, but creates a list. 

BUILD_MAP    zero 
Pushes a new empty dictionary object onto the stack. The argument is ignored and set to zero by the compiler.

BUILD_TUPLE    count 
Creates a tuple consuming count items from the stack, and pushes the resulting tuple onto the stack. 

DUP_TOP 
Duplicates the reference on top of the stack. 
Unary Operations take the top of the stack, apply the operation, and push the result back on the stack.

DUP_TOPX    count 
Duplicate count items, keeping them in the same order. Due to implementation limits, count should be between 1 and 5 inclusive.

LOAD_CONST    consti 
Pushes "co_consts[consti]" onto the stack. 

POP_TOP 
Removes the top-of-stack (TOS) item. 

ROT_TWO 
Swaps the two top-most stack items. 

ROT_THREE 
Lifts second and third stack item one position up, moves top down to position three. 

ROT_FOUR 
Lifts second, third and forth stack item one position up, moves top down to position four.

STORE_SUBSCR 
Implements TOS1[TOS] = TOS2. 

UNPACK_SEQUENCE    count 
Unpacks TOS into count individual values, which are put onto the stack right-to-left. </t>
<t tx="T45">BUILD_SLICE    argc 
Pushes a slice object on the stack. argc must be 2 or 3.
If it is 2, slice(TOS1, TOS) is pushed;
if it is 3, slice(TOS2, TOS1, TOS) is pushed.
See the slice() built-in function for more information.

SLICE+0 
Implements TOS = TOS[:]. 

SLICE+1 
Implements TOS = TOS1[TOS:]. 

SLICE+2 
Implements TOS = TOS1[:TOS1]. 

SLICE+3 
Implements TOS = TOS2[TOS1:TOS]. 
Slice assignment needs even an additional parameter. As any statement, they put nothing on the stack. 

STORE_SLICE+0 
Implements TOS[:] = TOS1. 

STORE_SLICE+1 
Implements TOS1[TOS:] = TOS2. 

STORE_SLICE+2 
Implements TOS1[:TOS] = TOS2. 

STORE_SLICE+3 
Implements TOS2[TOS1:TOS] = TOS3. 

DELETE_SLICE+0 
Implements del TOS[:]. 

DELETE_SLICE+1 
Implements del TOS1[TOS:]. 

DELETE_SLICE+2 
Implements del TOS1[:TOS]. 

DELETE_SLICE+3 
Implements del TOS2[TOS1:TOS].</t>
<t tx="T46"></t>
<t tx="T47">1.2.1 Reference Counts

The reference count is important because today's computers have a finite (and often severely limited) memory size; it counts how many different places there are that have a reference to an object. Such a place could be another object, or a global (or static) C variable, or a local variable in some C function. When an object's reference count becomes zero, the object is deallocated. If it contains references to other objects, their reference count is decremented. Those other objects may be deallocated in turn, if this decrement makes their reference count become zero, and so on. (There's an obvious problem with objects that reference each other here; for now, the solution is ``don't do that.'') 

Reference counts are always manipulated explicitly. The normal way is to use the macro Py_INCREF() to increment an object's reference count by one, and Py_DECREF() to decrement it by one. The Py_DECREF() macro is considerably more complex than the incref one, since it must check whether the reference count becomes zero and then cause the object's deallocator to be called. The deallocator is a function pointer contained in the object's type structure. The type-specific deallocator takes care of decrementing the reference counts for other objects contained in the object if this is a compound object type, such as a list, as well as performing any additional finalization that's needed. There's no chance that the reference count can overflow; at least as many bits are used to hold the reference count as there are distinct memory locations in virtual memory (assuming sizeof(long) &gt;= sizeof(char*)). Thus, the reference count increment is a simple operation. 

It is not necessary to increment an object's reference count for every local variable that contains a pointer to an object. In theory, the object's reference count goes up by one when the variable is made to point to it and it goes down by one when the variable goes out of scope. However, these two cancel each other out, so at the end the reference count hasn't changed. The only real reason to use the reference count is to prevent the object from being deallocated as long as our variable is pointing to it. If we know that there is at least one other reference to the object that lives at least as long as our variable, there is no need to increment the reference count temporarily. An important situation where this arises is in objects that are passed as arguments to C functions in an extension module that are called from Python; the call mechanism guarantees to hold a reference to every argument for the duration of the call. 

However, a common pitfall is to extract an object from a list and hold on to it for a while without incrementing its reference count. Some other operation might conceivably remove the object from the list, decrementing its reference count and possible deallocating it. The real danger is that innocent-looking operations may invoke arbitrary Python code which could do this; there is a code path which allows control to flow back to the user from a Py_DECREF(), so almost any operation is potentially dangerous. 

A safe approach is to always use the generic operations (functions whose name begins with "PyObject_", "PyNumber_", "PySequence_" or "PyMapping_"). These operations always increment the reference count of the object they return. This leaves the caller with the responsibility to call Py_DECREF() when they are done with the result; this soon becomes second nature.</t>
<t tx="T48">1.2.1.1 Reference Count Details

The reference count behavior of functions in the Python/C API is best explained in terms of ownership of references. Note that we talk of owning references, never of owning objects; objects are always shared!

When a function owns a reference, it has to dispose of it properly -- either by passing ownership on (usually to its caller) or by calling Py_DECREF() or Py_XDECREF(). When a function passes ownership of a reference on to its caller, the caller is said to receive a new reference. When no ownership is transferred, the caller is said to borrow the reference. Nothing needs to be done for a borrowed reference. 

Conversely, when a calling function passes it a reference to an object, there are two possibilities: the function steals a reference to the object, or it does not.

Few functions steal references; the two notable exceptions are PyList_SetItem() and PyTuple_SetItem()  which steal a reference to the item (but not to the tuple or list into which the item is put!). These functions were designed to steal a reference because of a common idiom for populating a tuple or list with newly created objects; for example, the code to create the tuple (1, 2, "three") could look like this (forgetting about error handling for the moment; a better way to code this is shown below): 

PyObject *t;

t = PyTuple_New(3);
PyTuple_SetItem(t, 0, PyInt_FromLong(1L));
PyTuple_SetItem(t, 1, PyInt_FromLong(2L));
PyTuple_SetItem(t, 2, PyString_FromString("three"));

Incidentally, PyTuple_SetItem() is the only way to set tuple items; PySequence_SetItem() and PyObject_SetItem() refuse to do this since tuples are an immutable data type. You should only use PyTuple_SetItem() for tuples that you are creating yourself. 

Equivalent code for populating a list can be written using PyList_New() and PyList_SetItem(). Such code can also use PySequence_SetItem(); this illustrates the difference between the two (the extra Py_DECREF() calls): 

PyObject *l, *x;

l = PyList_New(3);
x = PyInt_FromLong(1L);
PySequence_SetItem(l, 0, x); Py_DECREF(x);
x = PyInt_FromLong(2L);
PySequence_SetItem(l, 1, x); Py_DECREF(x);
x = PyString_FromString("three");
PySequence_SetItem(l, 2, x); Py_DECREF(x);

You might find it strange that the ``recommended'' approach takes more code. However, in practice, you will rarely use these ways of creating and populating a tuple or list. There's a generic function, Py_BuildValue(), that can create most common objects from C values, directed by a format string. For example, the above two blocks of code could be replaced by the following (which also takes care of the error checking): 

PyObject *t, *l;

t = Py_BuildValue("(iis)", 1, 2, "three");
l = Py_BuildValue("[iis]", 1, 2, "three");

It is much more common to use PyObject_SetItem() and friends with items whose references you are only borrowing, like arguments that were passed in to the function you are writing. In that case, their behaviour regarding reference counts is much saner, since you don't have to increment a reference count so you can give a reference away (``have it be stolen''). For example, this function sets all items of a list (actually, any mutable sequence) to a given item: 

int set_all(PyObject *target, PyObject *item)
{
    int i, n;

    n = PyObject_Length(target);
    if (n &lt; 0)
        return -1;
    for (i = 0; i &lt; n; i++) {
        if (PyObject_SetItem(target, i, item) &lt; 0)
            return -1;
    }
    return 0;
}

The situation is slightly different for function return values. While passing a reference to most functions does not change your ownership responsibilities for that reference, many functions that return a referece to an object give you ownership of the reference. The reason is simple: in many cases, the returned object is created on the fly, and the reference you get is the only reference to the object.

** Therefore, the generic functions that return object references, like PyObject_GetItem() and PySequence_GetItem(), always return a new reference (the caller becomes the owner of the reference). 

It is important to realize that whether you own a reference returned by a function depends on which function you call only -- the plumage (the type of the type of the object passed as an argument to the function) doesn't enter into it! Thus, if you extract an item from a list using PyList_GetItem(), you don't own the reference -- but if you obtain the same item from the same list using PySequence_GetItem() (which happens to take exactly the same arguments), you do own a reference to the returned object. 

Here is an example of how you could write a function that computes the sum of the items in a list of integers; once using PyList_GetItem() and once using PySequence_GetItem()  

long sum_list(PyObject *list)
{
    int i, n;
    long total = 0;
    PyObject *item;

    n = PyList_Size(list);
    if (n &lt; 0)
        return -1; /* Not a list */
    for (i = 0; i &lt; n; i++) {
        item = PyList_GetItem(list, i); /* Can't fail */
        if (!PyInt_Check(item)) continue; /* Skip non-integers */
        total += PyInt_AsLong(item);
    }
    return total;
}


long sum_sequence(PyObject *sequence)
{
    int i, n;
    long total = 0;
    PyObject *item;
    n = PySequence_Length(sequence);
    if (n &lt; 0)
        return -1; /* Has no length */
    for (i = 0; i &lt; n; i++) {
        item = PySequence_GetItem(sequence, i);
        if (item == NULL)
            return -1; /* Not a sequence, or other failure */
        if (PyInt_Check(item))
            total += PyInt_AsLong(item);
        Py_DECREF(item); /* Discard reference ownership */
    }
    return total;
}</t>
<t tx="T49">@nocolor

NOTE:  This won't work because line numbers don't always exist.

It may be possible to speed up the Python interpreter 3% to 5% with a trivial modification.

When stripped of conditionals, the main loop of the Python 2.2.1 interpreter
is as follows. (I've added comments to show C code equivalent to the
expansions of the macros.  Actual expansion may be slightly different.)

[begin code]

why = WHY_NOT; err = 0;
w = NULL; x = Py_None; /* Not a reference, just anything non-NULL */
for (;;) {

  if (things_to_do || --tstate-&gt;ticker &lt; 0)
    { /* handle periodic things */ }

  opcode = NEXTOP();    // opcode = *next_instr++

  if (HAS_ARG(opcode))  // if (opcode &gt;= HAVE_ARGUMENT) {
    oparg = NEXTARG();  //   next_instr += 2;
                        //   oparg = ((next_instr[-1] &lt;&lt; 8) +
                        //      next_instr[-2]) }
  switch (opcode)
  { /* opcode cases */ }

  if (why == WHY_NOT)
    if (err == 0 &amp;&amp; x != NULL)
      continue; /* Normal, fast path */

} // end for

[end code]

BTW, many common cases end with "continue", so even the trailing code
following the opcode switch doesn't necessarily contribute that much to program running time.

In short, this is a very tight loop.  But can't it be improved? The byte
code is littered with SET_LINENO opcodes.  Has anyone considered moving the
test:

if (things_to_do || --tstate-&gt;ticker &lt; 0)
    { /* handle periodic things */ } // not usually executed.

out of the main loop an into the case for SET_LINENO? The code might be
executed slightly less regularly, but would that matter?  This would seem to
be a real improvement precisely because the main loop is already so tight.

The only problem I can think of is that there would be some loop that does
not involve any SET_LINENO opcode at all.  Can anyone come up with such an
example?  Is there any other reason for moving the "periodic things" test
out of the main loop? Even if there were places where a loop contains no SET_LINENO opcode, it might be worthwhile to have the compiler insert an DO_PERIODIC_THINGS opcode in the bytecode for the loop.

How much time might we expect to save? Let us look at the most favorable case first.  As it happens, the SET_LINENO case of the main loop takes about the _least_ amount of time to execute (on average) so the speedup relative to this case will be the _greatest_.  Here is the code that typically gets executed:

case SET_LINENO:
  f-&gt;f_lineno = oparg;
  if (tstate-&gt;c_tracefunc == NULL || tstate-&gt;tracing)
    continue;  // typically _is_ executed.
  // typically _not_ executed.
      
As a rough estimate, let us just count C instructions in the loop through this case:

  if (things_to_do || --tstate-&gt;ticker &lt; 0)
    { /* typically not executed. */ }
  opcode = *next_instr++
  if (opcode &gt;= HAVE_ARGUMENT) {
    next_instr += 2;
    oparg = ((next_instr[-1] &lt;&lt; 8) + next_instr[-2])
  }
  switch (opcode)
  {
    case SET_LINENO:
      f-&gt;f_lineno = oparg;
      if (tstate-&gt;c_tracefunc == NULL || tstate-&gt;tracing)
        continue;  // typically _is_ executed.
      // typically not executed.
  }
  
Depending on how you count, there are 8-10 instruction here, so saving the line:
    
    if (things_to_do || --tstate-&gt;ticker &lt; 0)
    
May save up to 10% to 15% of the time through this loop.  This is a very rough estimate, and the actual value may be less.  Notice that code marked "typically not executed" has little effect on "amortized" time.

Are typical opcodes much more expensive than the simplest SET_LINENO case?  I wrote a simple program based on dis to count the static occurrences of bytecodes.  The results of running this program on most of the modules of Leo are as follows:

 18686 LOAD_FAST
 14276 SET_LINENO
  9635 LOAD_CONST
  9555 POP_TOP
  6721 LOAD_GLOBAL **
  5890 CALL_FUNCTION **
  5657 STORE_FAST
  3957 JUMP_IF_FALSE
  3473 RETURN_VALUE
  2887 JUMP_FORWARD
  2777 COMPARE_OP
  2229 LOAD_ATTR **
  1109 INPLACE_ADD
   887 BUILD_TUPLE
   876 BINARY_SUBSCR
   839 BINARY_ADD
   818 POP_BLOCK
   756 JUMP_IF_TRUE
   730 JUMP_ABSOLUTE
   729 SETUP_LOOP
   283 UNARY_NOT
   ...
total 96454
   
Dynamic execution frequencies will not match these static frequencies exactly, but I see no reason to suppose they will be wildly different.  If anyone has real dynamic data, I would like to see it :-) 

Typical "fast" opcodes are LOAD_FAST and LOAD_CONST.  The code for them is as follows:

case LOAD_FAST:
	x = GETLOCAL(oparg);            // x = fastlocals[oparg]
	if (x == NULL) {                // if (x == NULL) ...
		/* Typically not executed. */
	}
	Py_INCREF(x);                   // x-&gt;ob_refcnt++
	PUSH(x);                        // *stack_pointer++ = x
	if (x != NULL) continue;
	break;  // Typically not executed.
    
case LOAD_CONST:
  x = GETCONST(oparg); // x = f-&gt;f_code-&gt;co_consts-&gt;ob_item[oparg]
  Py_INCREF(x);        // x-&gt;ob_refcnt++
  PUSH(x);             // *stack_pointer++ = x
  continue;
    
Again we can see that eliminating:
    
  if (things_to_do || --tstate-&gt;ticker &lt; 0)
  
from the main loop might save up to 10% of the time taken to execute these instructions.

Some opcodes _will_ take much longer than others to execute.  I have marked the "heavy hitters" above with **.  Suppose we say that the heavy hitters will take at least 10 times longer than the other opcodes to execute, so we shall add 10 times their total count to the total count of 95454 shown above.  The new total then becomes roughly 300,000 rather than 100,000, so perhaps by this very rough estimate we might save 3-5% rather than 10-15%.

Still, this is a real savings. What do you think?

Edward

P.S.  The code needed to execute the "periodic" tasks in the SET_LINENO case might be simpler than the code in the main loop, because we would execute the periodic tasks _every time_ the SET_LINENO is seen.  This new code will have little effect on the overall timing.

P.P.S. The "do periodic things" code is:

@ Doing this every time through the loop would add too much overhead, so we do it only every Nth instruction.  We also do it if ``things_to_do'' is set, i.e. when an asynchronous event needs attention (e.g. a signal handler or async I/O handler); see Py_AddPendingCall() and Py_MakePendingCalls() above.
@c

tstate-&gt;ticker = tstate-&gt;interp-&gt;checkinterval;
if (things_to_do) {
	if (Py_MakePendingCalls() &lt; 0) {
		why = WHY_EXCEPTION;
		goto on_error;
	}
}

#if !defined(HAVE_SIGNAL_H) || defined(macintosh)
	/* If we have true signals, the signal handler
	   will call Py_AddPendingCall() so we don't
	   have to call sigcheck().  On the Mac and
	   DOS, alas, we have to call it. */
	if (PyErr_CheckSignals()) {
		why = WHY_EXCEPTION;
		goto on_error;
	}
#endif

#ifdef WITH_THREAD
	if (interpreter_lock) {
		/* Give another thread a chance */

		if (PyThreadState_Swap(NULL) != tstate)
			Py_FatalError("ceval: tstate mix-up");
		PyThread_release_lock(interpreter_lock);

		/* Other threads may run now */

		PyThread_acquire_lock(interpreter_lock, 1);
		if (PyThreadState_Swap(tstate) != NULL)
			Py_FatalError("ceval: orphan tstate");
	}
#endif

It's not clear how expensive this code will be when executed.  It depends on preprocessor options and run-time variables.  Again, dynamic data would be helpful.

E.K.R.
</t>
<t tx="T50">@ignore
@language c</t>
<t tx="T51">/* Class object interface */

/* Revealing some structures (not for general use) */

#ifndef Py_CLASSOBJECT_H
#define Py_CLASSOBJECT_H
#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    PyObject_HEAD
    PyObject	*cl_bases;	/* A tuple of class objects */
    PyObject	*cl_dict;	/* A dictionary */
    PyObject	*cl_name;	/* A string */
    /* The following three are functions or NULL */
    PyObject	*cl_getattr;
    PyObject	*cl_setattr;
    PyObject	*cl_delattr;
} PyClassObject;

typedef struct {
    PyObject_HEAD
    PyClassObject *in_class;	/* The class object */
    PyObject	  *in_dict;	/* A dictionary */
    PyObject	  *in_weakreflist; /* List of weak references */
} PyInstanceObject;

typedef struct {
    PyObject_HEAD
    PyObject *im_func;   /* The callable object implementing the method */
    PyObject *im_self;   /* The instance it is bound to, or NULL */
    PyObject *im_class;  /* The class that asked for the method */
    PyObject *im_weakreflist; /* List of weak references */
} PyMethodObject;

extern DL_IMPORT(PyTypeObject) PyClass_Type, PyInstance_Type, PyMethod_Type;

#define PyClass_Check(op) ((op)-&gt;ob_type == &amp;PyClass_Type)
#define PyInstance_Check(op) ((op)-&gt;ob_type == &amp;PyInstance_Type)
#define PyMethod_Check(op) ((op)-&gt;ob_type == &amp;PyMethod_Type)

extern DL_IMPORT(PyObject *) PyClass_New(PyObject *, PyObject *, PyObject *);
extern DL_IMPORT(PyObject *) PyInstance_New(PyObject *, PyObject *,
                                            PyObject *);
extern DL_IMPORT(PyObject *) PyInstance_NewRaw(PyObject *, PyObject *);
extern DL_IMPORT(PyObject *) PyMethod_New(PyObject *, PyObject *, PyObject *);

extern DL_IMPORT(PyObject *) PyMethod_Function(PyObject *);
extern DL_IMPORT(PyObject *) PyMethod_Self(PyObject *);
extern DL_IMPORT(PyObject *) PyMethod_Class(PyObject *);

/* Macros for direct access to these values. Type checks are *not*
   done, so use with care. */
#define PyMethod_GET_FUNCTION(meth) \
        (((PyMethodObject *)meth) -&gt; im_func)
#define PyMethod_GET_SELF(meth) \
	(((PyMethodObject *)meth) -&gt; im_self)
#define PyMethod_GET_CLASS(meth) \
	(((PyMethodObject *)meth) -&gt; im_class)

extern DL_IMPORT(int) PyClass_IsSubclass(PyObject *, PyObject *);


#ifdef __cplusplus
}
#endif
#endif /* !Py_CLASSOBJECT_H */
</t>
<t tx="T52">/* Definitions for bytecode */

#ifndef Py_COMPILE_H
#define Py_COMPILE_H
#ifdef __cplusplus
extern "C" {
#endif

/* Bytecode object */
typedef struct {
    PyObject_HEAD
    int co_argcount;		/* #arguments, except *args */
    int co_nlocals;		/* #local variables */
    int co_stacksize;		/* #entries needed for evaluation stack */
    int co_flags;		/* CO_..., see below */
    PyObject *co_code;		/* instruction opcodes */
    PyObject *co_consts;	/* list (constants used) */
    PyObject *co_names;		/* list of strings (names used) */
    PyObject *co_varnames;	/* tuple of strings (local variable names) */
    PyObject *co_freevars;	/* tuple of strings (free variable names) */
    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */
    /* The rest doesn't count for hash/cmp */
    PyObject *co_filename;	/* string (where it was loaded from) */
    PyObject *co_name;		/* string (name, for reference) */
    int co_firstlineno;		/* first source line number */
    PyObject *co_lnotab;	/* string (encoding addr&lt;-&gt;lineno mapping) */
} PyCodeObject;

/* Masks for co_flags above */
#define CO_OPTIMIZED	0x0001
#define CO_NEWLOCALS	0x0002
#define CO_VARARGS	0x0004
#define CO_VARKEYWORDS	0x0008
#define CO_NESTED       0x0010
#define CO_GENERATOR    0x0020
/* XXX Temporary hack.  Until generators are a permanent part of the
   language, we need a way for a code object to record that generators
   were *possible* when it was compiled.  This is so code dynamically
   compiled *by* a code object knows whether to allow yield stmts.  In
   effect, this passes on the "from __future__ import generators" state
   in effect when the code block was compiled. */
#define CO_GENERATOR_ALLOWED    0x1000
#define CO_FUTURE_DIVISION    	0x2000

extern DL_IMPORT(PyTypeObject) PyCode_Type;

#define PyCode_Check(op) ((op)-&gt;ob_type == &amp;PyCode_Type)
#define PyCode_GetNumFree(op) (PyTuple_GET_SIZE((op)-&gt;co_freevars))

#define CO_MAXBLOCKS 20 /* Max static block nesting within a function */

/* Public interface */
struct _node; /* Declare the existence of this type */
DL_IMPORT(PyCodeObject *) PyNode_Compile(struct _node *, char *);
DL_IMPORT(PyCodeObject *) PyCode_New(
	int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *,
	PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *); 
        /* same as struct above */
DL_IMPORT(int) PyCode_Addr2Line(PyCodeObject *, int);

/* Future feature support */

typedef struct {
    int ff_found_docstring;
    int ff_last_lineno;
    int ff_features;
} PyFutureFeatures;

DL_IMPORT(PyFutureFeatures *) PyNode_Future(struct _node *, char *);
DL_IMPORT(PyCodeObject *) PyNode_CompileFlags(struct _node *, char *,
					      PyCompilerFlags *);

#define FUTURE_NESTED_SCOPES "nested_scopes"
#define FUTURE_GENERATORS "generators"
#define FUTURE_DIVISION "division"

/* for internal use only */
#define _PyCode_GETCODEPTR(co, pp) \
	((*(co)-&gt;co_code-&gt;ob_type-&gt;tp_as_buffer-&gt;bf_getreadbuffer) \
	 ((co)-&gt;co_code, 0, (void **)(pp)))

#ifdef __cplusplus
}
#endif
#endif /* !Py_COMPILE_H */
</t>
<t tx="T53">#ifndef Py_DICTOBJECT_H
#define Py_DICTOBJECT_H
#ifdef __cplusplus
extern "C" {
#endif


/* Dictionary object type -- mapping from hashable object to object */

/*
There are three kinds of slots in the table:

1. Unused.  me_key == me_value == NULL
   Does not hold an active (key, value) pair now and never did.  Unused can
   transition to Active upon key insertion.  This is the only case in which
   me_key is NULL, and is each slot's initial state.

2. Active.  me_key != NULL and me_key != dummy and me_value != NULL
   Holds an active (key, value) pair.  Active can transition to Dummy upon
   key deletion.  This is the only case in which me_value != NULL.

3. Dummy.  me_key == dummy and me_value == NULL
   Previously held an active (key, value) pair, but that was deleted and an
   active pair has not yet overwritten the slot.  Dummy can transition to
   Active upon key insertion.  Dummy slots cannot be made Unused again
   (cannot have me_key set to NULL), else the probe sequence in case of
   collision would have no way to know they were once active.

Note: .popitem() abuses the me_hash field of an Unused or Dummy slot to
hold a search finger.  The me_hash field of Unused or Dummy slots has no
meaning otherwise.
*/

/* PyDict_MINSIZE is the minimum size of a dictionary.  This many slots are
 * allocated directly in the dict object (in the ma_smalltable member).
 * It must be a power of 2, and at least 4.  8 allows dicts with no more
 * than 5 active entries to live in ma_smalltable (and so avoid an
 * additional malloc); instrumentation suggested this suffices for the
 * majority of dicts (consisting mostly of usually-small instance dicts and
 * usually-small dicts created to pass keyword arguments).
 */
#define PyDict_MINSIZE 8

typedef struct {
	long me_hash;      /* cached hash code of me_key */
	PyObject *me_key;
	PyObject *me_value;
#ifdef USE_CACHE_ALIGNED
	long	aligner;
#endif
} PyDictEntry;

/*
To ensure the lookup algorithm terminates, there must be at least one Unused
slot (NULL key) in the table.
The value ma_fill is the number of non-NULL keys (sum of Active and Dummy);
ma_used is the number of non-NULL, non-dummy keys (== the number of non-NULL
values == the number of Active items).
To avoid slowing down lookups on a near-full table, we resize the table when
it's two-thirds full.
*/
typedef struct _dictobject PyDictObject;
struct _dictobject {
	PyObject_HEAD
	int ma_fill;  /* # Active + # Dummy */
	int ma_used;  /* # Active */

	/* The table contains ma_mask + 1 slots, and that's a power of 2.
	 * We store the mask instead of the size because the mask is more
	 * frequently needed.
	 */
	int ma_mask;

	/* ma_table points to ma_smalltable for small tables, else to
	 * additional malloc'ed memory.  ma_table is never NULL!  This rule
	 * saves repeated runtime null-tests in the workhorse getitem and
	 * setitem calls.
	 */
	PyDictEntry *ma_table;
	PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
	PyDictEntry ma_smalltable[PyDict_MINSIZE];
};

extern DL_IMPORT(PyTypeObject) PyDict_Type;

#define PyDict_Check(op) PyObject_TypeCheck(op, &amp;PyDict_Type)

extern DL_IMPORT(PyObject *) PyDict_New(void);
extern DL_IMPORT(PyObject *) PyDict_GetItem(PyObject *mp, PyObject *key);
extern DL_IMPORT(int) PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item);
extern DL_IMPORT(int) PyDict_DelItem(PyObject *mp, PyObject *key);
extern DL_IMPORT(void) PyDict_Clear(PyObject *mp);
extern DL_IMPORT(int) PyDict_Next
	(PyObject *mp, int *pos, PyObject **key, PyObject **value);
extern DL_IMPORT(PyObject *) PyDict_Keys(PyObject *mp);
extern DL_IMPORT(PyObject *) PyDict_Values(PyObject *mp);
extern DL_IMPORT(PyObject *) PyDict_Items(PyObject *mp);
extern DL_IMPORT(int) PyDict_Size(PyObject *mp);
extern DL_IMPORT(PyObject *) PyDict_Copy(PyObject *mp);

/* PyDict_Update(mp, other) is equivalent to PyDict_Merge(mp, other, 1). */
extern DL_IMPORT(int) PyDict_Update(PyObject *mp, PyObject *other);

/* PyDict_Merge updates/merges from a mapping object (an object that
   supports PyMapping_Keys() and PyObject_GetItem()).  If override is true,
   the last occurrence of a key wins, else the first.  The Python
   dict.update(other) is equivalent to PyDict_Merge(dict, other, 1).
*/
extern DL_IMPORT(int) PyDict_Merge(PyObject *mp,
				   PyObject *other,
				   int override);

/* PyDict_MergeFromSeq2 updates/merges from an iterable object producing
   iterable objects of length 2.  If override is true, the last occurrence
   of a key wins, else the first.  The Python dict constructor dict(seq2)
   is equivalent to dict={}; PyDict_MergeFromSeq(dict, seq2, 1).
*/
extern DL_IMPORT(int) PyDict_MergeFromSeq2(PyObject *d,
					   PyObject *seq2,
					   int override);

extern DL_IMPORT(PyObject *) PyDict_GetItemString(PyObject *dp, char *key);
extern DL_IMPORT(int) PyDict_SetItemString(PyObject *dp, char *key, PyObject *item);
extern DL_IMPORT(int) PyDict_DelItemString(PyObject *dp, char *key);

#ifdef __cplusplus
}
#endif
#endif /* !Py_DICTOBJECT_H */
</t>
<t tx="T54">#include "frameobject.h"
#include "eval.h"
#include "structmember.h"
</t>
<t tx="T55">#ifndef Py_CEVAL_H
#define Py_CEVAL_H
#ifdef __cplusplus
extern "C" {
#endif


/* Interface to random parts in ceval.c */

DL_IMPORT(PyObject *) PyEval_CallObjectWithKeywords
	(PyObject *, PyObject *, PyObject *);

/* DLL-level Backwards compatibility: */
#undef PyEval_CallObject
DL_IMPORT(PyObject *) PyEval_CallObject(PyObject *, PyObject *);

/* Inline this */
#define PyEval_CallObject(func,arg) \
        PyEval_CallObjectWithKeywords(func, arg, (PyObject *)NULL)

DL_IMPORT(PyObject *) PyEval_CallFunction(PyObject *obj, char *format, ...);
DL_IMPORT(PyObject *) PyEval_CallMethod(PyObject *obj,
                                        char *methodname, char *format, ...);

DL_IMPORT(void) PyEval_SetProfile(Py_tracefunc, PyObject *);
DL_IMPORT(void) PyEval_SetTrace(Py_tracefunc, PyObject *);

DL_IMPORT(PyObject *) PyEval_GetBuiltins(void);
DL_IMPORT(PyObject *) PyEval_GetGlobals(void);
DL_IMPORT(PyObject *) PyEval_GetLocals(void);
DL_IMPORT(PyObject *) PyEval_GetOwner(void);
DL_IMPORT(PyObject *) PyEval_GetFrame(void);
DL_IMPORT(int) PyEval_GetRestricted(void);

/* Look at the current frame's (if any) code's co_flags, and turn on
   the corresponding compiler flags in cf-&gt;cf_flags.  Return 1 if any
   flag was set, else return 0. */
DL_IMPORT(int) PyEval_MergeCompilerFlags(PyCompilerFlags *cf);

DL_IMPORT(int) Py_FlushLine(void);

DL_IMPORT(int) Py_AddPendingCall(int (*func)(void *), void *arg);
DL_IMPORT(int) Py_MakePendingCalls(void);

DL_IMPORT(void) Py_SetRecursionLimit(int);
DL_IMPORT(int) Py_GetRecursionLimit(void);

DL_IMPORT(char *) PyEval_GetFuncName(PyObject *);
DL_IMPORT(char *) PyEval_GetFuncDesc(PyObject *);

/* Interface for threads.

   A module that plans to do a blocking system call (or something else
   that lasts a long time and doesn't touch Python data) can allow other
   threads to run as follows:

	...preparations here...
	Py_BEGIN_ALLOW_THREADS
	...blocking system call here...
	Py_END_ALLOW_THREADS
	...interpret result here...

   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a
   {}-surrounded block.
   To leave the block in the middle (e.g., with return), you must insert
   a line containing Py_BLOCK_THREADS before the return, e.g.

	if (...premature_exit...) {
		Py_BLOCK_THREADS
		PyErr_SetFromErrno(PyExc_IOError);
		return NULL;
	}

   An alternative is:

	Py_BLOCK_THREADS
	if (...premature_exit...) {
		PyErr_SetFromErrno(PyExc_IOError);
		return NULL;
	}
	Py_UNBLOCK_THREADS

   For convenience, that the value of 'errno' is restored across
   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.

   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND
   Py_END_ALLOW_THREADS!!!

   The function PyEval_InitThreads() should be called only from
   initthread() in "threadmodule.c".

   Note that not yet all candidates have been converted to use this
   mechanism!
*/

extern DL_IMPORT(PyThreadState *) PyEval_SaveThread(void);
extern DL_IMPORT(void) PyEval_RestoreThread(PyThreadState *);

#ifdef WITH_THREAD

extern DL_IMPORT(void) PyEval_InitThreads(void);
extern DL_IMPORT(void) PyEval_AcquireLock(void);
extern DL_IMPORT(void) PyEval_ReleaseLock(void);
extern DL_IMPORT(void) PyEval_AcquireThread(PyThreadState *tstate);
extern DL_IMPORT(void) PyEval_ReleaseThread(PyThreadState *tstate);
extern DL_IMPORT(void) PyEval_ReInitThreads(void);

#define Py_BEGIN_ALLOW_THREADS { \
			PyThreadState *_save; \
			_save = PyEval_SaveThread();
#define Py_BLOCK_THREADS	PyEval_RestoreThread(_save);
#define Py_UNBLOCK_THREADS	_save = PyEval_SaveThread();
#define Py_END_ALLOW_THREADS	PyEval_RestoreThread(_save); \
		 }

#else /* !WITH_THREAD */

#define Py_BEGIN_ALLOW_THREADS {
#define Py_BLOCK_THREADS
#define Py_UNBLOCK_THREADS
#define Py_END_ALLOW_THREADS }

#endif /* !WITH_THREAD */

extern DL_IMPORT(int) _PyEval_SliceIndex(PyObject *, int *);


#ifdef __cplusplus
}
#endif
#endif /* !Py_CEVAL_H */
</t>
<t tx="T56">#ifndef Py_OPCODE_H
#define Py_OPCODE_H
#ifdef __cplusplus
extern "C" {
#endif

/* Instruction opcodes for compiled code */

#define STOP_CODE	0
#define POP_TOP		1
#define ROT_TWO		2
#define ROT_THREE	3
#define DUP_TOP		4
#define ROT_FOUR	5

#define UNARY_POSITIVE	10
#define UNARY_NEGATIVE	11
#define UNARY_NOT	12
#define UNARY_CONVERT	13

#define UNARY_INVERT	15

#define BINARY_POWER	19

#define BINARY_MULTIPLY	20
#define BINARY_DIVIDE	21
#define BINARY_MODULO	22
#define BINARY_ADD	23
#define BINARY_SUBTRACT	24
#define BINARY_SUBSCR	25
#define BINARY_FLOOR_DIVIDE 26
#define BINARY_TRUE_DIVIDE 27
#define INPLACE_FLOOR_DIVIDE 28
#define INPLACE_TRUE_DIVIDE 29

#define SLICE		30
/* Also uses 31-33 */

#define STORE_SLICE	40
/* Also uses 41-43 */

#define DELETE_SLICE	50
/* Also uses 51-53 */

#define INPLACE_ADD	55
#define INPLACE_SUBTRACT	56
#define INPLACE_MULTIPLY	57
#define INPLACE_DIVIDE	58
#define INPLACE_MODULO	59
#define STORE_SUBSCR	60
#define DELETE_SUBSCR	61

#define BINARY_LSHIFT	62
#define BINARY_RSHIFT	63
#define BINARY_AND	64
#define BINARY_XOR	65
#define BINARY_OR	66
#define INPLACE_POWER	67
#define GET_ITER	68

#define PRINT_EXPR	70
#define PRINT_ITEM	71
#define PRINT_NEWLINE	72
#define PRINT_ITEM_TO   73
#define PRINT_NEWLINE_TO 74
#define INPLACE_LSHIFT	75
#define INPLACE_RSHIFT	76
#define INPLACE_AND	77
#define INPLACE_XOR	78
#define INPLACE_OR	79
#define BREAK_LOOP	80

#define LOAD_LOCALS	82
#define RETURN_VALUE	83
#define IMPORT_STAR	84
#define EXEC_STMT	85
#define YIELD_VALUE	86

#define POP_BLOCK	87
#define END_FINALLY	88
#define BUILD_CLASS	89

#define HAVE_ARGUMENT	90	/* Opcodes from here have an argument: */

#define STORE_NAME	90	/* Index in name list */
#define DELETE_NAME	91	/* "" */
#define UNPACK_SEQUENCE	92	/* Number of sequence items */
#define FOR_ITER	93

#define STORE_ATTR	95	/* Index in name list */
#define DELETE_ATTR	96	/* "" */
#define STORE_GLOBAL	97	/* "" */
#define DELETE_GLOBAL	98	/* "" */
#define DUP_TOPX	99	/* number of items to duplicate */
#define LOAD_CONST	100	/* Index in const list */
#define LOAD_NAME	101	/* Index in name list */
#define BUILD_TUPLE	102	/* Number of tuple items */
#define BUILD_LIST	103	/* Number of list items */
#define BUILD_MAP	104	/* Always zero for now */
#define LOAD_ATTR	105	/* Index in name list */
#define COMPARE_OP	106	/* Comparison operator */
#define IMPORT_NAME	107	/* Index in name list */
#define IMPORT_FROM	108	/* Index in name list */

#define JUMP_FORWARD	110	/* Number of bytes to skip */
#define JUMP_IF_FALSE	111	/* "" */
#define JUMP_IF_TRUE	112	/* "" */
#define JUMP_ABSOLUTE	113	/* Target byte offset from beginning of code */
#define FOR_LOOP	114	/* Number of bytes to skip */

#define LOAD_GLOBAL	116	/* Index in name list */

#define CONTINUE_LOOP	119	/* Start of loop (absolute) */
#define SETUP_LOOP	120	/* Target address (absolute) */
#define SETUP_EXCEPT	121	/* "" */
#define SETUP_FINALLY	122	/* "" */

#define LOAD_FAST	124	/* Local variable number */
#define STORE_FAST	125	/* Local variable number */
#define DELETE_FAST	126	/* Local variable number */

#define SET_LINENO	127	/* Current line number */

#define RAISE_VARARGS	130	/* Number of raise arguments (1, 2 or 3) */
/* CALL_FUNCTION_XXX opcodes defined below depend on this definition */
#define CALL_FUNCTION	131	/* #args + (#kwargs&lt;&lt;8) */
#define MAKE_FUNCTION	132	/* #defaults */
#define BUILD_SLICE 	133	/* Number of items */

#define MAKE_CLOSURE    134     /* #free vars */
#define LOAD_CLOSURE    135     /* Load free variable from closure */
#define LOAD_DEREF      136     /* Load and dereference from closure cell */ 
#define STORE_DEREF     137     /* Store into cell */ 

/* The next 3 opcodes must be contiguous and satisfy
   (CALL_FUNCTION_VAR - CALL_FUNCTION) &amp; 3 == 1  */
#define CALL_FUNCTION_VAR          140	/* #args + (#kwargs&lt;&lt;8) */
#define CALL_FUNCTION_KW           141	/* #args + (#kwargs&lt;&lt;8) */
#define CALL_FUNCTION_VAR_KW       142	/* #args + (#kwargs&lt;&lt;8) */

/* Support for opargs more than 16 bits long */
#define EXTENDED_ARG  143

/* Comparison operator codes (argument to COMPARE_OP) */
enum cmp_op {LT=Py_LT, LE=Py_LE, EQ=Py_EQ, NE=Py_NE, GT=Py_GT, GE=Py_GE,
	     IN, NOT_IN, IS, IS_NOT, EXC_MATCH, BAD};

#define HAS_ARG(op) ((op) &gt;= HAVE_ARGUMENT)

#ifdef __cplusplus
}
#endif
#endif /* !Py_OPCODE_H */
</t>
<t tx="T57">
/* Definitions for bytecode */

#ifndef Py_COMPILE_H
#define Py_COMPILE_H
#ifdef __cplusplus
extern "C" {
#endif

/* Bytecode object */
typedef struct {
    PyObject_HEAD
    int co_argcount;		/* #arguments, except *args */
    int co_nlocals;		/* #local variables */
    int co_stacksize;		/* #entries needed for evaluation stack */
    int co_flags;		/* CO_..., see below */
    PyObject *co_code;		/* instruction opcodes */
    PyObject *co_consts;	/* list (constants used) */
    PyObject *co_names;		/* list of strings (names used) */
    PyObject *co_varnames;	/* tuple of strings (local variable names) */
    PyObject *co_freevars;	/* tuple of strings (free variable names) */
    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */
    /* The rest doesn't count for hash/cmp */
    PyObject *co_filename;	/* string (where it was loaded from) */
    PyObject *co_name;		/* string (name, for reference) */
    int co_firstlineno;		/* first source line number */
    PyObject *co_lnotab;	/* string (encoding addr&lt;-&gt;lineno mapping) */
} PyCodeObject;

/* Masks for co_flags above */
#define CO_OPTIMIZED	0x0001
#define CO_NEWLOCALS	0x0002
#define CO_VARARGS	0x0004
#define CO_VARKEYWORDS	0x0008
#define CO_NESTED       0x0010
#define CO_GENERATOR    0x0020
/* XXX Temporary hack.  Until generators are a permanent part of the
   language, we need a way for a code object to record that generators
   were *possible* when it was compiled.  This is so code dynamically
   compiled *by* a code object knows whether to allow yield stmts.  In
   effect, this passes on the "from __future__ import generators" state
   in effect when the code block was compiled. */
#define CO_GENERATOR_ALLOWED    0x1000
#define CO_FUTURE_DIVISION    	0x2000

extern DL_IMPORT(PyTypeObject) PyCode_Type;

#define PyCode_Check(op) ((op)-&gt;ob_type == &amp;PyCode_Type)
#define PyCode_GetNumFree(op) (PyTuple_GET_SIZE((op)-&gt;co_freevars))

#define CO_MAXBLOCKS 20 /* Max static block nesting within a function */

/* Public interface */
struct _node; /* Declare the existence of this type */
DL_IMPORT(PyCodeObject *) PyNode_Compile(struct _node *, char *);
DL_IMPORT(PyCodeObject *) PyCode_New(
	int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *,
	PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *); 
        /* same as struct above */
DL_IMPORT(int) PyCode_Addr2Line(PyCodeObject *, int);

/* Future feature support */

typedef struct {
    int ff_found_docstring;
    int ff_last_lineno;
    int ff_features;
} PyFutureFeatures;

DL_IMPORT(PyFutureFeatures *) PyNode_Future(struct _node *, char *);
DL_IMPORT(PyCodeObject *) PyNode_CompileFlags(struct _node *, char *,
					      PyCompilerFlags *);

#define FUTURE_NESTED_SCOPES "nested_scopes"
#define FUTURE_GENERATORS "generators"
#define FUTURE_DIVISION "division"

/* for internal use only */
#define _PyCode_GETCODEPTR(co, pp) \
	((*(co)-&gt;co_code-&gt;ob_type-&gt;tp_as_buffer-&gt;bf_getreadbuffer) \
	 ((co)-&gt;co_code, 0, (void **)(pp)))

#ifdef __cplusplus
}
#endif
#endif /* !Py_COMPILE_H */
</t>
<t tx="T58">
/* Frame object interface */

#ifndef Py_FRAMEOBJECT_H
#define Py_FRAMEOBJECT_H
#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    int b_type;			/* what kind of block this is */
    int b_handler;		/* where to jump to find handler */
    int b_level;		/* value stack level to pop to */
} PyTryBlock;

typedef struct _frame {
    PyObject_VAR_HEAD
    struct _frame *f_back;	/* previous frame, or NULL */
    PyCodeObject *f_code;	/* code segment */
    PyObject *f_builtins;	/* builtin symbol table (PyDictObject) */
    PyObject *f_globals;	/* global symbol table (PyDictObject) */
    PyObject *f_locals;		/* local symbol table (PyDictObject) */
    PyObject **f_valuestack;	/* points after the last local */
    /* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.
       Frame evaluation usually NULLs it, but a frame that yields sets it
       to the current stack top. */
    PyObject **f_stacktop;
    PyObject *f_trace;		/* Trace function */
    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;
    PyThreadState *f_tstate;
    int f_lasti;		/* Last instruction if called */
    int f_lineno;		/* Current line number */
    int f_restricted;		/* Flag set if restricted operations
				   in this scope */
    int f_iblock;		/* index in f_blockstack */
    PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */
    int f_nlocals;		/* number of locals */
    int f_ncells;
    int f_nfreevars;
    int f_stacksize;		/* size of value stack */
    PyObject *f_localsplus[1];	/* locals+stack, dynamically sized */
} PyFrameObject;


/* Standard object interface */

extern DL_IMPORT(PyTypeObject) PyFrame_Type;

#define PyFrame_Check(op) ((op)-&gt;ob_type == &amp;PyFrame_Type)

DL_IMPORT(PyFrameObject *) PyFrame_New(PyThreadState *, PyCodeObject *,
                                       PyObject *, PyObject *);


/* The rest of the interface is specific for frame objects */

/* Tuple access macros */

#ifndef Py_DEBUG
#define GETITEM(v, i) PyTuple_GET_ITEM((PyTupleObject *)(v), (i))
#define GETITEMNAME(v, i) \
	PyString_AS_STRING((PyStringObject *)GETITEM((v), (i)))
#else
#define GETITEM(v, i) PyTuple_GetItem((v), (i))
#define GETITEMNAME(v, i) PyString_AsString(GETITEM(v, i))
#endif

#define GETUSTRINGVALUE(s) ((unsigned char *)PyString_AS_STRING(s))

/* Code access macros */

#define Getconst(f, i)	(GETITEM((f)-&gt;f_code-&gt;co_consts, (i)))
#define Getname(f, i)	(GETITEMNAME((f)-&gt;f_code-&gt;co_names, (i)))
#define Getnamev(f, i)	(GETITEM((f)-&gt;f_code-&gt;co_names, (i)))


/* Block management functions */

DL_IMPORT(void) PyFrame_BlockSetup(PyFrameObject *, int, int, int);
DL_IMPORT(PyTryBlock *) PyFrame_BlockPop(PyFrameObject *);

/* Extend the value stack */

DL_IMPORT(PyObject **) PyFrame_ExtendStack(PyFrameObject *, int, int);

/* Conversions between "fast locals" and locals in dictionary */

DL_IMPORT(void) PyFrame_LocalsToFast(PyFrameObject *, int);
DL_IMPORT(void) PyFrame_FastToLocals(PyFrameObject *);

#ifdef __cplusplus
}
#endif
#endif /* !Py_FRAMEOBJECT_H */
</t>
<t tx="T59">#ifndef Py_OBJECT_H
#define Py_OBJECT_H
#ifdef __cplusplus
extern "C" {
#endif


/* Object and type object interface */

/*
Objects are structures allocated on the heap.  Special rules apply to
the use of objects to ensure they are properly garbage-collected.
Objects are never allocated statically or on the stack; they must be
accessed through special macros and functions only.  (Type objects are
exceptions to the first rule; the standard types are represented by
statically initialized type objects.)

An object has a 'reference count' that is increased or decreased when a
pointer to the object is copied or deleted; when the reference count
reaches zero there are no references to the object left and it can be
removed from the heap.

An object has a 'type' that determines what it represents and what kind
of data it contains.  An object's type is fixed when it is created.
Types themselves are represented as objects; an object contains a
pointer to the corresponding type object.  The type itself has a type
pointer pointing to the object representing the type 'type', which
contains a pointer to itself!).

Objects do not float around in memory; once allocated an object keeps
the same size and address.  Objects that must hold variable-size data
can contain pointers to variable-size parts of the object.  Not all
objects of the same type have the same size; but the size cannot change
after allocation.  (These restrictions are made so a reference to an
object can be simply a pointer -- moving an object would require
updating all the pointers, and changing an object's size would require
moving it if there was another object right next to it.)

Objects are always accessed through pointers of the type 'PyObject *'.
The type 'PyObject' is a structure that only contains the reference count
and the type pointer.  The actual memory allocated for an object
contains other data that can only be accessed after casting the pointer
to a pointer to a longer structure type.  This longer type must start
with the reference count and type fields; the macro PyObject_HEAD should be
used for this (to accommodate for future changes).  The implementation
of a particular object type can cast the object pointer to the proper
type and back.

A standard interface exists for objects that contain an array of items
whose size is determined when the object is allocated.
*/

#ifdef Py_DEBUG

/* Turn on heavy reference debugging */
#define Py_TRACE_REFS

/* Turn on reference counting */
#define Py_REF_DEBUG

#endif /* Py_DEBUG */

#ifdef Py_TRACE_REFS

	#define PyObject_HEAD \
		struct _object *_ob_next, *_ob_prev; \
		int ob_refcnt; \
		struct _typeobject *ob_type;

	#define PyObject_HEAD_INIT(type) 0, 0, 1, type,

#else /* !Py_TRACE_REFS */

	#define PyObject_HEAD \
		int ob_refcnt; \
		struct _typeobject *ob_type;
		
	#define PyObject_HEAD_INIT(type) 1, type,

#endif /* !Py_TRACE_REFS */

#define PyObject_VAR_HEAD \
	PyObject_HEAD \
	int ob_size; /* Number of items in variable part */
 
typedef struct _object {
	PyObject_HEAD
} PyObject;

typedef struct {
	PyObject_VAR_HEAD
} PyVarObject;


/*
Type objects contain a string containing the type name (to help somewhat
in debugging), the allocation parameters (see newobj() and newvarobj()),
and methods for accessing objects of the type.  Methods are optional,a
nil pointer meaning that particular kind of access is not available for
this type.  The Py_DECREF() macro uses the tp_dealloc method without
checking for a nil pointer; it should always be implemented except if
the implementation can guarantee that the reference count will never
reach zero (e.g., for type objects).

NB: the methods for certain type groups are now contained in separate
method blocks.
*/

typedef PyObject * (*unaryfunc)(PyObject *);
typedef PyObject * (*binaryfunc)(PyObject *, PyObject *);
typedef PyObject * (*ternaryfunc)(PyObject *, PyObject *, PyObject *);
typedef int (*inquiry)(PyObject *);
typedef int (*coercion)(PyObject **, PyObject **);
typedef PyObject *(*intargfunc)(PyObject *, int);
typedef PyObject *(*intintargfunc)(PyObject *, int, int);
typedef int(*intobjargproc)(PyObject *, int, PyObject *);
typedef int(*intintobjargproc)(PyObject *, int, int, PyObject *);
typedef int(*objobjargproc)(PyObject *, PyObject *, PyObject *);
typedef int (*getreadbufferproc)(PyObject *, int, void **);
typedef int (*getwritebufferproc)(PyObject *, int, void **);
typedef int (*getsegcountproc)(PyObject *, int *);
typedef int (*getcharbufferproc)(PyObject *, int, const char **);
typedef int (*objobjproc)(PyObject *, PyObject *);
typedef int (*visitproc)(PyObject *, void *);
typedef int (*traverseproc)(PyObject *, visitproc, void *);

typedef struct {
	/* For numbers without flag bit Py_TPFLAGS_CHECKTYPES set, all
	   arguments are guaranteed to be of the object's type (modulo
	   coercion hacks that is -- i.e. if the type's coercion function
	   returns other types, then these are allowed as well).  Numbers that
	   have the Py_TPFLAGS_CHECKTYPES flag bit set should check *both*
	   arguments for proper type and implement the necessary conversions
	   in the slot functions themselves. */

	binaryfunc nb_add;
	binaryfunc nb_subtract;
	binaryfunc nb_multiply;
	binaryfunc nb_divide;
	binaryfunc nb_remainder;
	binaryfunc nb_divmod;
	ternaryfunc nb_power;
	unaryfunc nb_negative;
	unaryfunc nb_positive;
	unaryfunc nb_absolute;
	inquiry nb_nonzero;
	unaryfunc nb_invert;
	binaryfunc nb_lshift;
	binaryfunc nb_rshift;
	binaryfunc nb_and;
	binaryfunc nb_xor;
	binaryfunc nb_or;
	coercion nb_coerce;
	unaryfunc nb_int;
	unaryfunc nb_long;
	unaryfunc nb_float;
	unaryfunc nb_oct;
	unaryfunc nb_hex;
	/* Added in release 2.0 */
	binaryfunc nb_inplace_add;
	binaryfunc nb_inplace_subtract;
	binaryfunc nb_inplace_multiply;
	binaryfunc nb_inplace_divide;
	binaryfunc nb_inplace_remainder;
	ternaryfunc nb_inplace_power;
	binaryfunc nb_inplace_lshift;
	binaryfunc nb_inplace_rshift;
	binaryfunc nb_inplace_and;
	binaryfunc nb_inplace_xor;
	binaryfunc nb_inplace_or;

	/* Added in release 2.2 */
	/* The following require the Py_TPFLAGS_HAVE_CLASS flag */
	binaryfunc nb_floor_divide;
	binaryfunc nb_true_divide;
	binaryfunc nb_inplace_floor_divide;
	binaryfunc nb_inplace_true_divide;
} PyNumberMethods;

typedef struct {
	inquiry sq_length;
	binaryfunc sq_concat;
	intargfunc sq_repeat;
	intargfunc sq_item;
	intintargfunc sq_slice;
	intobjargproc sq_ass_item;
	intintobjargproc sq_ass_slice;
	objobjproc sq_contains;
	/* Added in release 2.0 */
	binaryfunc sq_inplace_concat;
	intargfunc sq_inplace_repeat;
} PySequenceMethods;

typedef struct {
	inquiry mp_length;
	binaryfunc mp_subscript;
	objobjargproc mp_ass_subscript;
} PyMappingMethods;

typedef struct {
	getreadbufferproc bf_getreadbuffer;
	getwritebufferproc bf_getwritebuffer;
	getsegcountproc bf_getsegcount;
	getcharbufferproc bf_getcharbuffer;
} PyBufferProcs;
	

typedef void (*destructor)(PyObject *);
typedef int (*printfunc)(PyObject *, FILE *, int);
typedef PyObject *(*getattrfunc)(PyObject *, char *);
typedef PyObject *(*getattrofunc)(PyObject *, PyObject *);
typedef int (*setattrfunc)(PyObject *, char *, PyObject *);
typedef int (*setattrofunc)(PyObject *, PyObject *, PyObject *);
typedef int (*cmpfunc)(PyObject *, PyObject *);
typedef PyObject *(*reprfunc)(PyObject *);
typedef long (*hashfunc)(PyObject *);
typedef PyObject *(*richcmpfunc) (PyObject *, PyObject *, int);
typedef PyObject *(*getiterfunc) (PyObject *);
typedef PyObject *(*iternextfunc) (PyObject *);
typedef PyObject *(*descrgetfunc) (PyObject *, PyObject *, PyObject *);
typedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);
typedef int (*initproc)(PyObject *, PyObject *, PyObject *);
typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);
typedef PyObject *(*allocfunc)(struct _typeobject *, int);

typedef struct _typeobject {
	PyObject_VAR_HEAD
	char *tp_name; /* For printing, in format "&lt;module&gt;.&lt;name&gt;" */
	int tp_basicsize, tp_itemsize; /* For allocation */
	
	/* Methods to implement standard operations */
	
	destructor tp_dealloc;
	printfunc tp_print;
	getattrfunc tp_getattr;
	setattrfunc tp_setattr;
	cmpfunc tp_compare;
	reprfunc tp_repr;
	
	/* Method suites for standard classes */
	
	PyNumberMethods *tp_as_number;
	PySequenceMethods *tp_as_sequence;
	PyMappingMethods *tp_as_mapping;

	/* More standard operations (here for binary compatibility) */

	hashfunc tp_hash;
	ternaryfunc tp_call;
	reprfunc tp_str;
	getattrofunc tp_getattro;
	setattrofunc tp_setattro;

	/* Functions to access object as input/output buffer */
	PyBufferProcs *tp_as_buffer;
	
	/* Flags to define presence of optional/expanded features */
	long tp_flags;

	char *tp_doc; /* Documentation string */

	/* Assigned meaning in release 2.0 */
	/* call function for all accessible objects */
	traverseproc tp_traverse;
	
	/* delete references to contained objects */
	inquiry tp_clear;

	/* Assigned meaning in release 2.1 */
	/* rich comparisons */
	richcmpfunc tp_richcompare;

	/* weak reference enabler */
	long tp_weaklistoffset;

	/* Added in release 2.2 */
	/* Iterators */
	getiterfunc tp_iter;
	iternextfunc tp_iternext;

	/* Attribute descriptor and subclassing stuff */
	struct PyMethodDef *tp_methods;
	struct PyMemberDef *tp_members;
	struct PyGetSetDef *tp_getset;
	struct _typeobject *tp_base;
	PyObject *tp_dict;
	descrgetfunc tp_descr_get;
	descrsetfunc tp_descr_set;
	long tp_dictoffset;
	initproc tp_init;
	allocfunc tp_alloc;
	newfunc tp_new;
	destructor tp_free; /* Low-level free-memory routine */
	inquiry tp_is_gc; /* For PyObject_IS_GC */
	PyObject *tp_bases;
	PyObject *tp_mro; /* method resolution order */
	PyObject *tp_cache;
	PyObject *tp_subclasses;
	PyObject *tp_weaklist;

#ifdef COUNT_ALLOCS
	/* these must be last and never explicitly initialized */
	int tp_allocs;
	int tp_frees;
	int tp_maxalloc;
	struct _typeobject *tp_next;
#endif
} PyTypeObject;


/* Generic type check */
extern DL_IMPORT(int) PyType_IsSubtype(PyTypeObject *, PyTypeObject *);
#define PyObject_TypeCheck(ob, tp) \
	((ob)-&gt;ob_type == (tp) || PyType_IsSubtype((ob)-&gt;ob_type, (tp)))

extern DL_IMPORT(PyTypeObject) PyType_Type; /* built-in 'type' */
extern DL_IMPORT(PyTypeObject) PyBaseObject_Type; /* built-in 'object' */
extern DL_IMPORT(PyTypeObject) PySuper_Type; /* built-in 'super' */

#define PyType_Check(op) PyObject_TypeCheck(op, &amp;PyType_Type)
#define PyType_CheckExact(op) ((op)-&gt;ob_type == &amp;PyType_Type)

extern DL_IMPORT(int) PyType_Ready(PyTypeObject *);
extern DL_IMPORT(PyObject *) PyType_GenericAlloc(PyTypeObject *, int);
extern DL_IMPORT(PyObject *) PyType_GenericNew(PyTypeObject *,
					       PyObject *, PyObject *);
extern DL_IMPORT(PyObject *) _PyType_Lookup(PyTypeObject *, PyObject *);

/* Generic operations on objects */
extern DL_IMPORT(int) PyObject_Print(PyObject *, FILE *, int);
extern DL_IMPORT(void) _PyObject_Dump(PyObject *);
extern DL_IMPORT(PyObject *) PyObject_Repr(PyObject *);
extern DL_IMPORT(PyObject *) PyObject_Str(PyObject *);
#ifdef Py_USING_UNICODE
extern DL_IMPORT(PyObject *) PyObject_Unicode(PyObject *);
#endif
extern DL_IMPORT(int) PyObject_Compare(PyObject *, PyObject *);
extern DL_IMPORT(PyObject *) PyObject_RichCompare(PyObject *, PyObject *, int);
extern DL_IMPORT(int) PyObject_RichCompareBool(PyObject *, PyObject *, int);
extern DL_IMPORT(PyObject *) PyObject_GetAttrString(PyObject *, char *);
extern DL_IMPORT(int) PyObject_SetAttrString(PyObject *, char *, PyObject *);
extern DL_IMPORT(int) PyObject_HasAttrString(PyObject *, char *);
extern DL_IMPORT(PyObject *) PyObject_GetAttr(PyObject *, PyObject *);
extern DL_IMPORT(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
extern DL_IMPORT(int) PyObject_HasAttr(PyObject *, PyObject *);
extern DL_IMPORT(PyObject **) _PyObject_GetDictPtr(PyObject *);
extern DL_IMPORT(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);
extern DL_IMPORT(int) PyObject_GenericSetAttr(PyObject *,
					      PyObject *, PyObject *);
extern DL_IMPORT(long) PyObject_Hash(PyObject *);
extern DL_IMPORT(int) PyObject_IsTrue(PyObject *);
extern DL_IMPORT(int) PyObject_Not(PyObject *);
extern DL_IMPORT(int) PyCallable_Check(PyObject *);
extern DL_IMPORT(int) PyNumber_Coerce(PyObject **, PyObject **);
extern DL_IMPORT(int) PyNumber_CoerceEx(PyObject **, PyObject **);

extern DL_IMPORT(void) PyObject_ClearWeakRefs(PyObject *);

/* A slot function whose address we need to compare */
extern int _PyObject_SlotCompare(PyObject *, PyObject *);


/* PyObject_Dir(obj) acts like Python __builtin__.dir(obj), returning a
   list of strings.  PyObject_Dir(NULL) is like __builtin__.dir(),
   returning the names of the current locals.  In this case, if there are
   no current locals, NULL is returned, and PyErr_Occurred() is false.
*/
extern DL_IMPORT(PyObject *) PyObject_Dir(PyObject *);


/* Helpers for printing recursive container types */
extern DL_IMPORT(int) Py_ReprEnter(PyObject *);
extern DL_IMPORT(void) Py_ReprLeave(PyObject *);

/* Helpers for hash functions */
extern DL_IMPORT(long) _Py_HashDouble(double);
extern DL_IMPORT(long) _Py_HashPointer(void*);

/* Helper for passing objects to printf and the like */
#define PyObject_REPR(obj) PyString_AS_STRING(PyObject_Repr(obj))

/* Flag bits for printing: */
#define Py_PRINT_RAW	1	/* No string quotes etc. */

/*

Type flags (tp_flags)

These flags are used to extend the type structure in a backwards-compatible
fashion. Extensions can use the flags to indicate (and test) when a given
type structure contains a new feature. The Python core will use these when
introducing new functionality between major revisions (to avoid mid-version
changes in the PYTHON_API_VERSION).

Arbitration of the flag bit positions will need to be coordinated among
all extension writers who publically release their extensions (this will
be fewer than you might expect!)..

Python 1.5.2 introduced the bf_getcharbuffer slot into PyBufferProcs.

Type definitions should use Py_TPFLAGS_DEFAULT for their tp_flags value.

Code can use PyType_HasFeature(type_ob, flag_value) to test whether the
given type object has a specified feature.

*/

/* PyBufferProcs contains bf_getcharbuffer */
#define Py_TPFLAGS_HAVE_GETCHARBUFFER  (1L&lt;&lt;0)

/* PySequenceMethods contains sq_contains */
#define Py_TPFLAGS_HAVE_SEQUENCE_IN (1L&lt;&lt;1)

/* This is here for backwards compatibility.  Extensions that use the old GC
 * API will still compile but the objects will not be tracked by the GC. */
#define Py_TPFLAGS_GC 0 /* used to be (1L&lt;&lt;2) */

/* PySequenceMethods and PyNumberMethods contain in-place operators */
#define Py_TPFLAGS_HAVE_INPLACEOPS (1L&lt;&lt;3)

/* PyNumberMethods do their own coercion */
#define Py_TPFLAGS_CHECKTYPES (1L&lt;&lt;4)

/* tp_richcompare is defined */
#define Py_TPFLAGS_HAVE_RICHCOMPARE (1L&lt;&lt;5)

/* Objects which are weakly referencable if their tp_weaklistoffset is &gt;0 */
#define Py_TPFLAGS_HAVE_WEAKREFS (1L&lt;&lt;6)

/* tp_iter is defined */
#define Py_TPFLAGS_HAVE_ITER (1L&lt;&lt;7)

/* New members introduced by Python 2.2 exist */
#define Py_TPFLAGS_HAVE_CLASS (1L&lt;&lt;8)

/* Set if the type object is dynamically allocated */
#define Py_TPFLAGS_HEAPTYPE (1L&lt;&lt;9)

/* Set if the type allows subclassing */
#define Py_TPFLAGS_BASETYPE (1L&lt;&lt;10)

/* Set if the type is 'ready' -- fully initialized */
#define Py_TPFLAGS_READY (1L&lt;&lt;12)

/* Set while the type is being 'readied', to prevent recursive ready calls */
#define Py_TPFLAGS_READYING (1L&lt;&lt;13)

/* Objects support garbage collection (see objimp.h) */
#ifdef WITH_CYCLE_GC
#define Py_TPFLAGS_HAVE_GC (1L&lt;&lt;14)
#else
#define Py_TPFLAGS_HAVE_GC 0
#endif

#define Py_TPFLAGS_DEFAULT  ( \
                             Py_TPFLAGS_HAVE_GETCHARBUFFER | \
                             Py_TPFLAGS_HAVE_SEQUENCE_IN | \
                             Py_TPFLAGS_HAVE_INPLACEOPS | \
                             Py_TPFLAGS_HAVE_RICHCOMPARE | \
                             Py_TPFLAGS_HAVE_WEAKREFS | \
                             Py_TPFLAGS_HAVE_ITER | \
                             Py_TPFLAGS_HAVE_CLASS | \
                            0)

#define PyType_HasFeature(t,f)  (((t)-&gt;tp_flags &amp; (f)) != 0)


/*
The macros Py_INCREF(op) and Py_DECREF(op) are used to increment or decrement
reference counts.  Py_DECREF calls the object's deallocator function; for
objects that don't contain references to other objects or heap memory
this can be the standard function free().  Both macros can be used
wherever a void expression is allowed.  The argument shouldn't be a
NIL pointer.  The macro _Py_NewReference(op) is used only to initialize
reference counts to 1; it is defined here for convenience.

We assume that the reference count field can never overflow; this can
be proven when the size of the field is the same as the pointer size
but even with a 16-bit reference count field it is pretty unlikely so
we ignore the possibility.  (If you are paranoid, make it a long.)

Type objects should never be deallocated; the type pointer in an object
is not considered to be a reference to the type object, to save
complications in the deallocation function.  (This is actually a
decision that's up to the implementer of each new type so if you want,
you can count such references to the type object.)

*** WARNING*** The Py_DECREF macro must have a side-effect-free argument
since it may evaluate its argument multiple times.  (The alternative
would be to mace it a proper function or assign it to a global temporary
variable first, both of which are slower; and in a multi-threaded
environment the global variable trick is not safe.)
*/

#ifdef Py_TRACE_REFS
#ifndef Py_REF_DEBUG
#define Py_REF_DEBUG
#endif
#endif

#ifdef Py_TRACE_REFS
extern DL_IMPORT(void) _Py_Dealloc(PyObject *);
extern DL_IMPORT(void) _Py_NewReference(PyObject *);
extern DL_IMPORT(void) _Py_ForgetReference(PyObject *);
extern DL_IMPORT(void) _Py_PrintReferences(FILE *);
extern DL_IMPORT(void) _Py_ResetReferences(void);
#endif

#ifndef Py_TRACE_REFS
#ifdef COUNT_ALLOCS
#define _Py_Dealloc(op) ((op)-&gt;ob_type-&gt;tp_frees++, (*(op)-&gt;ob_type-&gt;tp_dealloc)((PyObject *)(op)))
#define _Py_ForgetReference(op) ((op)-&gt;ob_type-&gt;tp_frees++)
#else /* !COUNT_ALLOCS */
#define _Py_Dealloc(op) (*(op)-&gt;ob_type-&gt;tp_dealloc)((PyObject *)(op))
#define _Py_ForgetReference(op) /*empty*/
#endif /* !COUNT_ALLOCS */
#endif /* !Py_TRACE_REFS */

#ifdef COUNT_ALLOCS
extern DL_IMPORT(void) inc_count(PyTypeObject *);
#endif

#ifdef Py_REF_DEBUG

extern DL_IMPORT(long) _Py_RefTotal;

#ifndef Py_TRACE_REFS
#ifdef COUNT_ALLOCS
#define _Py_NewReference(op) (inc_count((op)-&gt;ob_type), _Py_RefTotal++, (op)-&gt;ob_refcnt = 1)
#else
#define _Py_NewReference(op) (_Py_RefTotal++, (op)-&gt;ob_refcnt = 1)
#endif
#endif /* !Py_TRACE_REFS */

#define Py_INCREF(op) (_Py_RefTotal++, (op)-&gt;ob_refcnt++)
  /* under Py_REF_DEBUG: also log negative ref counts after Py_DECREF() !! */
#define Py_DECREF(op)							\
       if (--_Py_RefTotal, 0 &lt; (--((op)-&gt;ob_refcnt))) ;			\
       else if (0 == (op)-&gt;ob_refcnt) _Py_Dealloc( (PyObject*)(op));	\
       else (void)fprintf( stderr, "%s:%i negative ref count %i\n",	\
		           __FILE__, __LINE__, (op)-&gt;ob_refcnt)
#else /* !Py_REF_DEBUG */

#ifdef COUNT_ALLOCS
#define _Py_NewReference(op) (inc_count((op)-&gt;ob_type), (op)-&gt;ob_refcnt = 1)
#else
#define _Py_NewReference(op) ((op)-&gt;ob_refcnt = 1)
#endif

#define Py_INCREF(op) ((op)-&gt;ob_refcnt++)
#define Py_DECREF(op) \
	if (--(op)-&gt;ob_refcnt != 0) \
		; \
	else \
		_Py_Dealloc((PyObject *)(op))
#endif /* !Py_REF_DEBUG */

/* Macros to use in case the object pointer may be NULL: */

#define Py_XINCREF(op) if ((op) == NULL) ; else Py_INCREF(op)
#define Py_XDECREF(op) if ((op) == NULL) ; else Py_DECREF(op)

/*
_Py_NoneStruct is an object of undefined type which can be used in contexts
where NULL (nil) is not suitable (since NULL often means 'error').

Don't forget to apply Py_INCREF() when returning this value!!!
*/

extern DL_IMPORT(PyObject) _Py_NoneStruct; /* Don't use this directly */

#define Py_None (&amp;_Py_NoneStruct)

/*
Py_NotImplemented is a singleton used to signal that an operation is
not implemented for a given type combination.
*/

extern DL_IMPORT(PyObject) _Py_NotImplementedStruct; /* Don't use this directly */

#define Py_NotImplemented (&amp;_Py_NotImplementedStruct)

/* Rich comparison opcodes */
#define Py_LT 0
#define Py_LE 1
#define Py_EQ 2
#define Py_NE 3
#define Py_GT 4
#define Py_GE 5

/*
A common programming style in Python requires the forward declaration
of static, initialized structures, e.g. for a type object that is used
by the functions whose address must be used in the initializer.
Some compilers (notably SCO ODT 3.0, I seem to remember early AIX as
well) botch this if you use the static keyword for both declarations
(they allocate two objects, and use the first, uninitialized one until
the second declaration is encountered).  Therefore, the forward
declaration should use the 'forwardstatic' keyword.  This expands to
static on most systems, but to extern on a few.  The actual storage
and name will still be static because the second declaration is
static, so no linker visible symbols will be generated.  (Standard C
compilers take offense to the extern forward declaration of a static
object, so I can't just put extern in all cases. :-( )
*/

#ifdef BAD_STATIC_FORWARD
#define staticforward extern
#define statichere static
#else /* !BAD_STATIC_FORWARD */
#define staticforward static
#define statichere static
#endif /* !BAD_STATIC_FORWARD */


/*
More conventions
================

Argument Checking
-----------------

Functions that take objects as arguments normally don't check for nil
arguments, but they do check the type of the argument, and return an
error if the function doesn't apply to the type.

Failure Modes
-------------

Functions may fail for a variety of reasons, including running out of
memory.  This is communicated to the caller in two ways: an error string
is set (see errors.h), and the function result differs: functions that
normally return a pointer return NULL for failure, functions returning
an integer return -1 (which could be a legal return value too!), and
other functions return 0 for success and -1 for failure.
Callers should always check for errors before using the result.

Reference Counts
----------------

It takes a while to get used to the proper usage of reference counts.

Functions that create an object set the reference count to 1; such new
objects must be stored somewhere or destroyed again with Py_DECREF().
Functions that 'store' objects such as PyTuple_SetItem() and
PyDict_SetItemString()
don't increment the reference count of the object, since the most
frequent use is to store a fresh object.  Functions that 'retrieve'
objects such as PyTuple_GetItem() and PyDict_GetItemString() also
don't increment
the reference count, since most frequently the object is only looked at
quickly.  Thus, to retrieve an object and store it again, the caller
must call Py_INCREF() explicitly.

NOTE: functions that 'consume' a reference count like
PyList_SetItemString() even consume the reference if the object wasn't
stored, to simplify error handling.

It seems attractive to make other functions that take an object as
argument consume a reference count; however this may quickly get
confusing (even the current practice is already confusing).  Consider
it carefully, it may save lots of calls to Py_INCREF() and Py_DECREF() at
times.
*/

/*
  trashcan
  CT 2k0130
  non-recursively destroy nested objects

  CT 2k0223
  redefinition for better locality and less overhead.

  Objects that want to be recursion safe need to use
  the macro's 
		Py_TRASHCAN_SAFE_BEGIN(name)
  and
		Py_TRASHCAN_SAFE_END(name)
  surrounding their actual deallocation code.

  It would be nice to do this using the thread state.
  Also, we could do an exact stack measure then.
  Unfortunately, deallocations also take place when
  the thread state is undefined.

  CT 2k0422 complete rewrite.
  There is no need to allocate new objects.
  Everything is done vialob_refcnt and ob_type now.
  Adding support for free-threading should be easy, too.
*/

#define PyTrash_UNWIND_LEVEL 50

#define Py_TRASHCAN_SAFE_BEGIN(op) \
	{ \
		++_PyTrash_delete_nesting; \
		if (_PyTrash_delete_nesting &lt; PyTrash_UNWIND_LEVEL) { \

#define Py_TRASHCAN_SAFE_END(op) \
		;} \
		else \
			_PyTrash_deposit_object((PyObject*)op);\
		--_PyTrash_delete_nesting; \
		if (_PyTrash_delete_later &amp;&amp; _PyTrash_delete_nesting &lt;= 0) \
			_PyTrash_destroy_chain(); \
	} \

extern DL_IMPORT(void) _PyTrash_deposit_object(PyObject*);
extern DL_IMPORT(void) _PyTrash_destroy_chain(void);

extern DL_IMPORT(int) _PyTrash_delete_nesting;
extern DL_IMPORT(PyObject *) _PyTrash_delete_later;

/* swap the "xx" to check the speed loss */

#define xxPy_TRASHCAN_SAFE_BEGIN(op) 
#define xxPy_TRASHCAN_SAFE_END(op) ;

#ifdef __cplusplus
}
#endif
#endif /* !Py_OBJECT_H */</t>
<t tx="T60">#ifndef Py_PYTHON_H
#define Py_PYTHON_H
/* Since this is a "meta-include" file, no #ifdef __cplusplus / extern "C" { */

&lt;&lt; enable compiler features &gt;&gt;
&lt;&lt; include nearly all Python header files &gt;&gt;

#define PyArg_GetInt(v, a)	PyArg_Parse((v), "i", (a))
#define PyArg_NoArgs(v)		PyArg_Parse(v, "")

/* Convert a possibly signed character to a nonnegative int */
/* XXX This assumes characters are 8 bits wide */
#ifdef __CHAR_UNSIGNED__
#define Py_CHARMASK(c)		(c)
#else
#define Py_CHARMASK(c)		((c) &amp; 0xff)
#endif

#include "pyfpe.h"

/* These definitions must match corresponding definitions in graminit.h.
   There's code in compile.c that checks that they are the same. */
#define Py_single_input 256
#define Py_file_input 257
#define Py_eval_input 258

#ifdef HAVE_PTH
/* GNU pth user-space thread support */
#include &lt;pth.h&gt;
#endif

#endif /* !Py_PYTHON_H */</t>
<t tx="T61">/* Enable compiler features; switching on C lib defines doesn't work
   here, because the symbols haven't necessarily been defined yet. */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE	1
#endif

/* Forcing SUSv2 compatibility still produces problems on some
   platforms, True64 and SGI IRIX begin two of them, so for now the
   define is switched off. */
#if 0
#ifndef _XOPEN_SOURCE
# define _XOPEN_SOURCE	500
#endif
#endif</t>
<t tx="T62">/* Include nearly all Python header files */

#include "patchlevel.h"
#include "pyconfig.h"

#ifdef HAVE_LIMITS_H
#include &lt;limits.h&gt;
#endif

/* pyconfig.h may or may not define DL_IMPORT */
#ifndef DL_IMPORT	/* declarations for DLL import/export */
#define DL_IMPORT(RTYPE) RTYPE
#endif
#ifndef DL_EXPORT	/* declarations for DLL import/export */
#define DL_EXPORT(RTYPE) RTYPE
#endif

#if defined(__sgi) &amp;&amp; defined(WITH_THREAD) &amp;&amp; !defined(_SGI_MP_SOURCE)
#define _SGI_MP_SOURCE
#endif

#include &lt;stdio.h&gt;
#ifndef NULL
#   error "Python.h requires that stdio.h define NULL."
#endif

#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#ifdef HAVE_STDLIB_H
#include &lt;stdlib.h&gt;
#endif

/* CAUTION:  Build setups should ensure that NDEBUG is defined on the
 * compiler command line when building Python in release mode; else
 * assert() calls won't be removed.
 */
#include &lt;assert.h&gt;

#include "pyport.h"

#include "pymem.h"

#include "object.h"
#include "objimpl.h"

#include "pydebug.h"

#include "unicodeobject.h"
#include "intobject.h"
#include "longobject.h"
#include "floatobject.h"
#ifndef WITHOUT_COMPLEX
#include "complexobject.h"
#endif
#include "rangeobject.h"
#include "stringobject.h"
#include "bufferobject.h"
#include "tupleobject.h"
#include "listobject.h"
#include "dictobject.h"
#include "methodobject.h"
#include "moduleobject.h"
#include "funcobject.h"
#include "classobject.h"
#include "fileobject.h"
#include "cobject.h"
#include "traceback.h"
#include "sliceobject.h"
#include "cellobject.h"
#include "iterobject.h"
#include "descrobject.h"
#include "weakrefobject.h"

#include "codecs.h"
#include "pyerrors.h"

#include "pystate.h"

#include "modsupport.h"
#include "pythonrun.h"
#include "ceval.h"
#include "sysmodule.h"
#include "intrcheck.h"
#include "import.h"

#include "abstract.h"</t>
<t tx="T63">/* Interfaces to parse and execute pieces of python code */

#ifndef Py_PYTHONRUN_H
#define Py_PYTHONRUN_H
#ifdef __cplusplus
extern "C" {
#endif

#define PyCF_MASK (CO_GENERATOR_ALLOWED | CO_FUTURE_DIVISION)
#define PyCF_MASK_OBSOLETE (CO_NESTED)

typedef struct {
	int cf_flags;  /* bitmask of CO_xxx flags relevant to future */
} PyCompilerFlags;

DL_IMPORT(void) Py_SetProgramName(char *);
DL_IMPORT(char *) Py_GetProgramName(void);

DL_IMPORT(void) Py_SetPythonHome(char *);
DL_IMPORT(char *) Py_GetPythonHome(void);

DL_IMPORT(void) Py_Initialize(void);
DL_IMPORT(void) Py_Finalize(void);
DL_IMPORT(int) Py_IsInitialized(void);
DL_IMPORT(PyThreadState *) Py_NewInterpreter(void);
DL_IMPORT(void) Py_EndInterpreter(PyThreadState *);

DL_IMPORT(int) PyRun_AnyFile(FILE *, char *);
DL_IMPORT(int) PyRun_AnyFileEx(FILE *, char *, int);

DL_IMPORT(int) PyRun_AnyFileFlags(FILE *, char *, PyCompilerFlags *);
DL_IMPORT(int) PyRun_AnyFileExFlags(FILE *, char *, int, PyCompilerFlags *);

DL_IMPORT(int) PyRun_SimpleString(char *);
DL_IMPORT(int) PyRun_SimpleStringFlags(char *, PyCompilerFlags *);
DL_IMPORT(int) PyRun_SimpleFile(FILE *, char *);
DL_IMPORT(int) PyRun_SimpleFileEx(FILE *, char *, int);
DL_IMPORT(int) PyRun_SimpleFileExFlags(FILE *, char *, int, PyCompilerFlags *);
DL_IMPORT(int) PyRun_InteractiveOne(FILE *, char *);
DL_IMPORT(int) PyRun_InteractiveOneFlags(FILE *, char *, PyCompilerFlags *);
DL_IMPORT(int) PyRun_InteractiveLoop(FILE *, char *);
DL_IMPORT(int) PyRun_InteractiveLoopFlags(FILE *, char *, PyCompilerFlags *);

DL_IMPORT(struct _node *) PyParser_SimpleParseString(char *, int);
DL_IMPORT(struct _node *) PyParser_SimpleParseFile(FILE *, char *, int);
DL_IMPORT(struct _node *) PyParser_SimpleParseStringFlags(char *, int, int);
DL_IMPORT(struct _node *) PyParser_SimpleParseFileFlags(FILE *, char *,
							int, int);

DL_IMPORT(PyObject *) PyRun_String(char *, int, PyObject *, PyObject *);
DL_IMPORT(PyObject *) PyRun_File(FILE *, char *, int, PyObject *, PyObject *);
DL_IMPORT(PyObject *) PyRun_FileEx(FILE *, char *, int,
				   PyObject *, PyObject *, int);
DL_IMPORT(PyObject *) PyRun_StringFlags(char *, int, PyObject *, PyObject *,
					PyCompilerFlags *);
DL_IMPORT(PyObject *) PyRun_FileFlags(FILE *, char *, int, PyObject *, 
				      PyObject *, PyCompilerFlags *);
DL_IMPORT(PyObject *) PyRun_FileExFlags(FILE *, char *, int, PyObject *, 
					PyObject *, int, PyCompilerFlags *);

DL_IMPORT(PyObject *) Py_CompileString(char *, char *, int);
DL_IMPORT(PyObject *) Py_CompileStringFlags(char *, char *, int,
					    PyCompilerFlags *);
DL_IMPORT(struct symtable *) Py_SymtableString(char *, char *, int);

DL_IMPORT(void) PyErr_Print(void);
DL_IMPORT(void) PyErr_PrintEx(int);
DL_IMPORT(void) PyErr_Display(PyObject *, PyObject *, PyObject *);

DL_IMPORT(int) Py_AtExit(void (*func)(void));

DL_IMPORT(void) Py_Exit(int);

DL_IMPORT(int) Py_FdIsInteractive(FILE *, char *);

/* In getpath.c */
DL_IMPORT(char *) Py_GetProgramFullPath(void);
DL_IMPORT(char *) Py_GetPrefix(void);
DL_IMPORT(char *) Py_GetExecPrefix(void);
DL_IMPORT(char *) Py_GetPath(void);

/* In their own files */
DL_IMPORT(const char *) Py_GetVersion(void);
DL_IMPORT(const char *) Py_GetPlatform(void);
DL_IMPORT(const char *) Py_GetCopyright(void);
DL_IMPORT(const char *) Py_GetCompiler(void);
DL_IMPORT(const char *) Py_GetBuildInfo(void);

/* Internal -- various one-time initializations */
DL_IMPORT(PyObject *) _PyBuiltin_Init(void);
DL_IMPORT(PyObject *) _PySys_Init(void);
DL_IMPORT(void) _PyImport_Init(void);
DL_IMPORT(void) _PyExc_Init(void);

/* Various internal finalizers */
DL_IMPORT(void) _PyExc_Fini(void);
DL_IMPORT(void) _PyImport_Fini(void);
DL_IMPORT(void) PyMethod_Fini(void);
DL_IMPORT(void) PyFrame_Fini(void);
DL_IMPORT(void) PyCFunction_Fini(void);
DL_IMPORT(void) PyTuple_Fini(void);
DL_IMPORT(void) PyString_Fini(void);
DL_IMPORT(void) PyInt_Fini(void);
DL_IMPORT(void) PyFloat_Fini(void);
DL_IMPORT(void) PyOS_FiniInterrupts(void);

/* Stuff with no proper home (yet) */
DL_IMPORT(char *) PyOS_Readline(char *);
extern DL_IMPORT(int) (*PyOS_InputHook)(void);
extern DL_IMPORT(char) *(*PyOS_ReadlineFunctionPointer)(char *);

/* Stack size, in "pointers" (so we get extra safety margins
   on 64-bit platforms).  On a 32-bit platform, this translates
   to a 8k margin. */
#define PYOS_STACK_MARGIN 2048

#if defined(WIN32) &amp;&amp; !defined(MS_WIN64) &amp;&amp; defined(_MSC_VER)
/* Enable stack checking under Microsoft C */
#define USE_STACKCHECK
#endif

#ifdef USE_STACKCHECK
/* Check that we aren't overflowing our stack */
DL_IMPORT(int) PyOS_CheckStack(void);
#endif

/* Signals */
typedef void (*PyOS_sighandler_t)(int);
DL_IMPORT(PyOS_sighandler_t) PyOS_getsig(int);
DL_IMPORT(PyOS_sighandler_t) PyOS_setsig(int, PyOS_sighandler_t);


#ifdef __cplusplus
}
#endif
#endif /* !Py_PYTHONRUN_H */
</t>
<t tx="T64">#ifndef Py_SYMTABLE_H
#define Py_SYMTABLE_H
#ifdef __cplusplus
extern "C" {
#endif

/* A symbol table is constructed each time PyNode_Compile() is
   called.  The table walks the entire parse tree and identifies each
   use or definition of a variable. 

   The symbol table contains a dictionary for each code block in a
   module: The symbol dictionary for the block.  They keys of these
   dictionaries are the name of all variables used or defined in the
   block; the integer values are used to store several flags,
   e.g. DEF_PARAM indicates that a variable is a parameter to a
   function. 
*/

struct _symtable_entry;

struct symtable {
	int st_pass;             /* pass == 1 or 2 */
	char *st_filename;       /* name of file being compiled */
	struct _symtable_entry *st_cur; /* current symbol table entry */
	PyObject *st_symbols;    /* dictionary of symbol table entries */
        PyObject *st_stack;      /* stack of namespace info */
	PyObject *st_global;     /* borrowed ref to MODULE in st_symbols */
	int st_nscopes;          /* number of scopes */
	int st_errors;           /* number of errors */
	char *st_private;        /* name of current class or NULL */
	int st_tmpname;          /* temporary name counter */
	PyFutureFeatures *st_future; /* module's future features */
};

typedef struct _symtable_entry {
	PyObject_HEAD
	PyObject *ste_id;        /* int: key in st_symbols) */
	PyObject *ste_symbols;   /* dict: name to flags) */
	PyObject *ste_name;      /* string: name of scope */
	PyObject *ste_varnames;  /* list of variable names */
	PyObject *ste_children;  /* list of child ids */
	int ste_type;            /* module, class, or function */
	int ste_lineno;          /* first line of scope */
	int ste_optimized;       /* true if namespace can't be optimized */
	int ste_nested;          /* true if scope is nested */
	int ste_child_free;      /* true if a child scope has free variables,
				    including free refs to globals */
	int ste_generator;       /* true if namespace is a generator */
	int ste_opt_lineno;      /* lineno of last exec or import * */
	struct symtable *ste_table;
} PySymtableEntryObject;

extern DL_IMPORT(PyTypeObject) PySymtableEntry_Type;

#define PySymtableEntry_Check(op) ((op)-&gt;ob_type == &amp;PySymtableEntry_Type)

extern DL_IMPORT(PyObject *) PySymtableEntry_New(struct symtable *,
						 char *, int, int);

DL_IMPORT(struct symtable *) PyNode_CompileSymtable(struct _node *, char *);
DL_IMPORT(void) PySymtable_Free(struct symtable *);


#define TOP "global"

/* Flags for def-use information */

#define DEF_GLOBAL 1           /* global stmt */
#define DEF_LOCAL 2            /* assignment in code block */
#define DEF_PARAM 2&lt;&lt;1         /* formal parameter */
#define USE 2&lt;&lt;2               /* name is used */
#define DEF_STAR 2&lt;&lt;3          /* parameter is star arg */
#define DEF_DOUBLESTAR 2&lt;&lt;4    /* parameter is star-star arg */
#define DEF_INTUPLE 2&lt;&lt;5       /* name defined in tuple in parameters */
#define DEF_FREE 2&lt;&lt;6          /* name used but not defined in nested scope */
#define DEF_FREE_GLOBAL 2&lt;&lt;7   /* free variable is actually implicit global */
#define DEF_FREE_CLASS 2&lt;&lt;8    /* free variable from class's method */
#define DEF_IMPORT 2&lt;&lt;9        /* assignment occurred via import */

#define DEF_BOUND (DEF_LOCAL | DEF_PARAM | DEF_IMPORT)

#define TYPE_FUNCTION 1
#define TYPE_CLASS 2
#define TYPE_MODULE 3

#define LOCAL 1
#define GLOBAL_EXPLICIT 2
#define GLOBAL_IMPLICIT 3
#define FREE 4
#define CELL 5

#define OPT_IMPORT_STAR 1
#define OPT_EXEC 2
#define OPT_BARE_EXEC 4

#ifdef __cplusplus
}
#endif
#endif /* !Py_SYMTABLE_H */
</t>
<t tx="T65">
/* Token types */

#ifndef Py_TOKEN_H
#define Py_TOKEN_H
#ifdef __cplusplus
extern "C" {
#endif

#define ENDMARKER	0
#define NAME		1
#define NUMBER		2
#define STRING		3
#define NEWLINE		4
#define INDENT		5
#define DEDENT		6
#define LPAR		7
#define RPAR		8
#define LSQB		9
#define RSQB		10
#define COLON		11
#define COMMA		12
#define SEMI		13
#define PLUS		14
#define MINUS		15
#define STAR		16
#define SLASH		17
#define VBAR		18
#define AMPER		19
#define LESS		20
#define GREATER		21
#define EQUAL		22
#define DOT		23
#define PERCENT		24
#define BACKQUOTE	25
#define LBRACE		26
#define RBRACE		27
#define EQEQUAL		28
#define NOTEQUAL	29
#define LESSEQUAL	30
#define GREATEREQUAL	31
#define TILDE		32
#define CIRCUMFLEX	33
#define LEFTSHIFT	34
#define RIGHTSHIFT	35
#define DOUBLESTAR	36
#define PLUSEQUAL	37
#define MINEQUAL	38
#define STAREQUAL	39
#define SLASHEQUAL	40
#define PERCENTEQUAL	41
#define AMPEREQUAL	42
#define VBAREQUAL	43
#define CIRCUMFLEXEQUAL	44
#define LEFTSHIFTEQUAL	45
#define RIGHTSHIFTEQUAL	46
#define DOUBLESTAREQUAL	47
#define DOUBLESLASH	48
#define DOUBLESLASHEQUAL 49
/* Don't forget to update the table _PyParser_TokenNames in tokenizer.c! */
#define OP		50
#define ERRORTOKEN	51
#define N_TOKENS	52

/* Special definitions for cooperation with parser */

#define NT_OFFSET		256

#define ISTERMINAL(x)		((x) &lt; NT_OFFSET)
#define ISNONTERMINAL(x)	((x) &gt;= NT_OFFSET)
#define ISEOF(x)		((x) == ENDMARKER)


extern DL_IMPORT(char *) _PyParser_TokenNames[]; /* Token names */
extern DL_IMPORT(int) PyToken_OneChar(int);
extern DL_IMPORT(int) PyToken_TwoChars(int, int);
extern DL_IMPORT(int) PyToken_ThreeChars(int, int, int);

#ifdef __cplusplus
}
#endif
#endif /* !Py_TOKEN_H */
</t>
<t tx="T66">
/* Tuple object interface */

#ifndef Py_TUPLEOBJECT_H
#define Py_TUPLEOBJECT_H
#ifdef __cplusplus
extern "C" {
#endif

/*
Another generally useful object type is an tuple of object pointers.
This is a mutable type: the tuple items can be changed (but not their
number).  Out-of-range indices or non-tuple objects are ignored.

*** WARNING *** PyTuple_SetItem does not increment the new item's reference
count, but does decrement the reference count of the item it replaces,
if not nil.  It does *decrement* the reference count if it is *not*
inserted in the tuple.  Similarly, PyTuple_GetItem does not increment the
returned item's reference count.
*/

typedef struct {
    PyObject_VAR_HEAD
    PyObject *ob_item[1];
} PyTupleObject;

extern DL_IMPORT(PyTypeObject) PyTuple_Type;

#define PyTuple_Check(op) PyObject_TypeCheck(op, &amp;PyTuple_Type)
#define PyTuple_CheckExact(op) ((op)-&gt;ob_type == &amp;PyTuple_Type)

extern DL_IMPORT(PyObject *) PyTuple_New(int size);
extern DL_IMPORT(int)        PyTuple_Size(PyObject *);
extern DL_IMPORT(PyObject *) PyTuple_GetItem(PyObject *, int);
extern DL_IMPORT(int)        PyTuple_SetItem(PyObject *, int, PyObject *);
extern DL_IMPORT(PyObject *) PyTuple_GetSlice(PyObject *, int, int);
extern DL_IMPORT(int)       _PyTuple_Resize(PyObject **, int);

/* Macro, trading safety for speed */
#define PyTuple_GET_ITEM(op, i) (((PyTupleObject *)(op))-&gt;ob_item[i])
#define PyTuple_GET_SIZE(op)    (((PyTupleObject *)(op))-&gt;ob_size)

/* Macro, *only* to be used to fill in brand new tuples */
#define PyTuple_SET_ITEM(op, i, v) (((PyTupleObject *)(op))-&gt;ob_item[i] = v)

#ifdef __cplusplus
}
#endif
#endif /* !Py_TUPLEOBJECT_H */
</t>
<t tx="T67">@ignore
@language c</t>
<t tx="T68">/* Abstract Object Interface (many thanks to Jim Fulton) */

#include "Python.h"
#include &lt;ctype.h&gt;
#include "structmember.h" /* we need the offsetof() macro from there */
#include "longintrepr.h"

@others
</t>
<t tx="T69">#define NEW_STYLE_NUMBER(o) PyType_HasFeature((o)-&gt;ob_type, \
				Py_TPFLAGS_CHECKTYPES)

/* Shorthands to return certain errors */

static PyObject *
type_error(const char *msg)
{
	PyErr_SetString(PyExc_TypeError, msg);
	return NULL;
}
</t>
<t tx="T70">static PyObject *
null_error(void)
{
	if (!PyErr_Occurred())
		PyErr_SetString(PyExc_SystemError,
				"null argument to internal routine");
	return NULL;
}
</t>
<t tx="T71"></t>
<t tx="T72">@ Operations on any object */
@c

int
PyObject_Cmp(PyObject *o1, PyObject *o2, int *result)
{
	int r;

	if (o1 == NULL || o2 == NULL) {
		null_error();
		return -1;
	}
	r = PyObject_Compare(o1, o2);
	if (PyErr_Occurred())
		return -1;
	*result = r;
	return 0;
}
</t>
<t tx="T73">PyObject *
PyObject_Type(PyObject *o)
{
	PyObject *v;

	if (o == NULL)
		return null_error();
	v = (PyObject *)o-&gt;ob_type;
	Py_INCREF(v);
	return v;
}
</t>
<t tx="T74">int
PyObject_Size(PyObject *o)
{
	PySequenceMethods *m;

	if (o == NULL) {
		null_error();
		return -1;
	}

	m = o-&gt;ob_type-&gt;tp_as_sequence;
	if (m &amp;&amp; m-&gt;sq_length)
		return m-&gt;sq_length(o);

	return PyMapping_Size(o);
}
</t>
<t tx="T75">#undef PyObject_Length
int
PyObject_Length(PyObject *o)
{
	return PyObject_Size(o);
}
</t>
<t tx="T76">#define PyObject_Length PyObject_Size

PyObject *
PyObject_GetItem(PyObject *o, PyObject *key)
{
	PyMappingMethods *m;

	if (o == NULL || key == NULL)
		return null_error();

	m = o-&gt;ob_type-&gt;tp_as_mapping;
	if (m &amp;&amp; m-&gt;mp_subscript)
		return m-&gt;mp_subscript(o, key);

	if (o-&gt;ob_type-&gt;tp_as_sequence) {
		if (PyInt_Check(key))
			return PySequence_GetItem(o, PyInt_AsLong(key));
		else if (PyLong_Check(key)) {
			long key_value = PyLong_AsLong(key);
			if (key_value == -1 &amp;&amp; PyErr_Occurred())
				return NULL;
			return PySequence_GetItem(o, key_value);
		}
		else if (o-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_item)
			return type_error("sequence index must be integer");
	}

	return type_error("unsubscriptable object");
}
</t>
<t tx="T77">int
PyObject_SetItem(PyObject *o, PyObject *key, PyObject *value)
{
	PyMappingMethods *m;

	if (o == NULL || key == NULL || value == NULL) {
		null_error();
		return -1;
	}
	m = o-&gt;ob_type-&gt;tp_as_mapping;
	if (m &amp;&amp; m-&gt;mp_ass_subscript)
		return m-&gt;mp_ass_subscript(o, key, value);

	if (o-&gt;ob_type-&gt;tp_as_sequence) {
		if (PyInt_Check(key))
			return PySequence_SetItem(o, PyInt_AsLong(key), value);
		else if (PyLong_Check(key)) {
			long key_value = PyLong_AsLong(key);
			if (key_value == -1 &amp;&amp; PyErr_Occurred())
				return -1;
			return PySequence_SetItem(o, key_value, value);
		}
		else if (o-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_ass_item) {
			type_error("sequence index must be integer");
			return -1;
		}
	}

	type_error("object does not support item assignment");
	return -1;
}
</t>
<t tx="T78">int
PyObject_DelItem(PyObject *o, PyObject *key)
{
	PyMappingMethods *m;

	if (o == NULL || key == NULL) {
		null_error();
		return -1;
	}
	m = o-&gt;ob_type-&gt;tp_as_mapping;
	if (m &amp;&amp; m-&gt;mp_ass_subscript)
		return m-&gt;mp_ass_subscript(o, key, (PyObject*)NULL);

	if (o-&gt;ob_type-&gt;tp_as_sequence) {
		if (PyInt_Check(key))
			return PySequence_DelItem(o, PyInt_AsLong(key));
		else if (PyLong_Check(key)) {
			long key_value = PyLong_AsLong(key);
			if (key_value == -1 &amp;&amp; PyErr_Occurred())
				return -1;
			return PySequence_DelItem(o, key_value);
		}
		else if (o-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_ass_item) {
			type_error("sequence index must be integer");
			return -1;
		}
	}

	type_error("object does not support item deletion");
	return -1;
}
</t>
<t tx="T79">int PyObject_AsCharBuffer(PyObject *obj,
			  const char **buffer,
			  int *buffer_len)
{
	PyBufferProcs *pb;
	const char *pp;
	int len;

	if (obj == NULL || buffer == NULL || buffer_len == NULL) {
		null_error();
		return -1;
	}
	pb = obj-&gt;ob_type-&gt;tp_as_buffer;
	if (pb == NULL ||
	     pb-&gt;bf_getcharbuffer == NULL ||
	     pb-&gt;bf_getsegcount == NULL) {
		PyErr_SetString(PyExc_TypeError,
				"expected a character buffer object");
		return -1;
	}
	if ((*pb-&gt;bf_getsegcount)(obj,NULL) != 1) {
		PyErr_SetString(PyExc_TypeError,
				"expected a single-segment buffer object");
		return -1;
	}
	len = (*pb-&gt;bf_getcharbuffer)(obj, 0, &amp;pp);
	if (len &lt; 0)
		return -1;
	*buffer = pp;
	*buffer_len = len;
	return 0;
}
</t>
<t tx="T80">int
PyObject_CheckReadBuffer(PyObject *obj)
{
	PyBufferProcs *pb = obj-&gt;ob_type-&gt;tp_as_buffer;

	if (pb == NULL ||
	    pb-&gt;bf_getreadbuffer == NULL ||
	    pb-&gt;bf_getsegcount == NULL ||
	    (*pb-&gt;bf_getsegcount)(obj, NULL) != 1)
		return 0;
	return 1;
}
</t>
<t tx="T81">int PyObject_AsReadBuffer(PyObject *obj,
			  const void **buffer,
			  int *buffer_len)
{
	PyBufferProcs *pb;
	void *pp;
	int len;

	if (obj == NULL || buffer == NULL || buffer_len == NULL) {
		null_error();
		return -1;
	}
	pb = obj-&gt;ob_type-&gt;tp_as_buffer;
	if (pb == NULL ||
	     pb-&gt;bf_getreadbuffer == NULL ||
	     pb-&gt;bf_getsegcount == NULL) {
		PyErr_SetString(PyExc_TypeError,
				"expected a readable buffer object");
		return -1;
	}
	if ((*pb-&gt;bf_getsegcount)(obj, NULL) != 1) {
		PyErr_SetString(PyExc_TypeError,
				"expected a single-segment buffer object");
		return -1;
	}
	len = (*pb-&gt;bf_getreadbuffer)(obj, 0, &amp;pp);
	if (len &lt; 0)
		return -1;
	*buffer = pp;
	*buffer_len = len;
	return 0;
}
</t>
<t tx="T82">int PyObject_AsWriteBuffer(PyObject *obj,
			   void **buffer,
			   int *buffer_len)
{
	PyBufferProcs *pb;
	void*pp;
	int len;

	if (obj == NULL || buffer == NULL || buffer_len == NULL) {
		null_error();
		return -1;
	}
	pb = obj-&gt;ob_type-&gt;tp_as_buffer;
	if (pb == NULL ||
	     pb-&gt;bf_getwritebuffer == NULL ||
	     pb-&gt;bf_getsegcount == NULL) {
		PyErr_SetString(PyExc_TypeError,
				"expected a writeable buffer object");
		return -1;
	}
	if ((*pb-&gt;bf_getsegcount)(obj, NULL) != 1) {
		PyErr_SetString(PyExc_TypeError,
				"expected a single-segment buffer object");
		return -1;
	}
	len = (*pb-&gt;bf_getwritebuffer)(obj,0,&amp;pp);
	if (len &lt; 0)
		return -1;
	*buffer = pp;
	*buffer_len = len;
	return 0;
}
</t>
<t tx="T83"></t>
<t tx="T84">@ Operations on numbers */
@c

int
PyNumber_Check(PyObject *o)
{
	return o &amp;&amp; o-&gt;ob_type-&gt;tp_as_number;
}
</t>
<t tx="T85">@ Binary operators
New style number protocol support
@c

#define NB_SLOT(x) offsetof(PyNumberMethods, x)
#define NB_BINOP(nb_methods, slot) \
		((binaryfunc*)(&amp; ((char*)nb_methods)[slot] ))
#define NB_TERNOP(nb_methods, slot) \
		((ternaryfunc*)(&amp; ((char*)nb_methods)[slot] ))

/*
  Calling scheme used for binary operations:

  v	w	Action
  -------------------------------------------------------------------
  new	new	w.op(v,w)[*], v.op(v,w), w.op(v,w)
  new	old	v.op(v,w), coerce(v,w), v.op(v,w)
  old	new	w.op(v,w), coerce(v,w), v.op(v,w)
  old	old	coerce(v,w), v.op(v,w)

  [*] only when v-&gt;ob_type != w-&gt;ob_type &amp;&amp; w-&gt;ob_type is a subclass of
      v-&gt;ob_type

  Legend:
  -------
  * new == new style number
  * old == old style number
  * Action indicates the order in which operations are tried until either
    a valid result is produced or an error occurs.

 */

static PyObject *
binary_op1(PyObject *v, PyObject *w, const int op_slot)
{
	PyObject *x;
	binaryfunc slotv = NULL;
	binaryfunc slotw = NULL;

	if (v-&gt;ob_type-&gt;tp_as_number != NULL &amp;&amp; NEW_STYLE_NUMBER(v))
		slotv = *NB_BINOP(v-&gt;ob_type-&gt;tp_as_number, op_slot);
		
	if (w-&gt;ob_type != v-&gt;ob_type &amp;&amp;
	    w-&gt;ob_type-&gt;tp_as_number != NULL &amp;&amp; NEW_STYLE_NUMBER(w)) {
		slotw = *NB_BINOP(w-&gt;ob_type-&gt;tp_as_number, op_slot);
		if (slotw == slotv)
			slotw = NULL;
	}
	
	if (slotv) {
		if (slotw &amp;&amp; PyType_IsSubtype(w-&gt;ob_type, v-&gt;ob_type)) {
			x = slotw(v, w);
			if (x != Py_NotImplemented)
				return x;
			Py_DECREF(x); /* can't do it */
			slotw = NULL;
		}
		x = slotv(v, w);
		if (x != Py_NotImplemented)
			return x;
		Py_DECREF(x); /* can't do it */
	}
	
	if (slotw) {
		x = slotw(v, w);
		if (x != Py_NotImplemented)
			return x;
		Py_DECREF(x); /* can't do it */
	}
	
	if (!NEW_STYLE_NUMBER(v) || !NEW_STYLE_NUMBER(w)) {
		int err = PyNumber_CoerceEx(&amp;v, &amp;w);
		if (err &lt; 0) {
			return NULL;
		}
		if (err == 0) {
			PyNumberMethods *mv = v-&gt;ob_type-&gt;tp_as_number;
			if (mv) {
				binaryfunc slot;
				slot = *NB_BINOP(mv, op_slot);
				if (slot) {
					PyObject *x = slot(v, w);
					Py_DECREF(v);
					Py_DECREF(w);
					return x;
				}
			}
			/* CoerceEx incremented the reference counts */
			Py_DECREF(v);
			Py_DECREF(w);
		}
	}

	Py_INCREF(Py_NotImplemented);
	return Py_NotImplemented;
}
</t>
<t tx="T86">static PyObject *
binary_op(PyObject *v, PyObject *w, const int op_slot, const char *op_name)
{
	PyObject *result = binary_op1(v, w, op_slot);
	if (result == Py_NotImplemented) {
		Py_DECREF(Py_NotImplemented);
		PyErr_Format(
			PyExc_TypeError, 
			"unsupported operand type(s) for %s: '%s' and '%s'",
			op_name,
			v-&gt;ob_type-&gt;tp_name,
			w-&gt;ob_type-&gt;tp_name);
		return NULL;
	}
	return result;
}
</t>
<t tx="T87">@ Calling scheme used for ternary operations: *** In some cases, w.op is called before v.op; see binary_op1. *** v w z Action ------------------------------------------------------------------- new new new v.op(v,w,z), w.op(v,w,z), z.op(v,w,z) new old new v.op(v,w,z), z.op(v,w,z), coerce(v,w,z), v.op(v,w,z) old new new w.op(v,w,z), z.op(v,w,z), coerce(v,w,z), v.op(v,w,z) old old new z.op(v,w,z), coerce(v,w,z), v.op(v,w,z) new new old v.op(v,w,z), w.op(v,w,z), coerce(v,w,z), v.op(v,w,z) new old old v.op(v,w,z), coerce(v,w,z), v.op(v,w,z) old new old w.op(v,w,z), coerce(v,w,z), v.op(v,w,z) old old old coerce(v,w,z), v.op(v,w,z) Legend: ------- * new == new style number * old == old style number * Action indicates the order in which operations are tried until either a valid result is produced or an error occurs. * coerce(v,w,z) actually does: coerce(v,w), coerce(v,z), coerce(w,z) and only if z != Py_None; if z == Py_None, then it is treated as absent variable and only coerce(v,w) is tried. */
@c

static PyObject *
ternary_op(PyObject *v,
	   PyObject *w,
	   PyObject *z,
	   const int op_slot,
	   const char *op_name)
{
	PyNumberMethods *mv, *mw, *mz;
	PyObject *x = NULL;
	ternaryfunc slotv = NULL;
	ternaryfunc slotw = NULL;
	ternaryfunc slotz = NULL;
	
	mv = v-&gt;ob_type-&gt;tp_as_number;
	mw = w-&gt;ob_type-&gt;tp_as_number;
	if (mv != NULL &amp;&amp; NEW_STYLE_NUMBER(v))
		slotv = *NB_TERNOP(mv, op_slot);
	if (w-&gt;ob_type != v-&gt;ob_type &amp;&amp;
	    mv != NULL &amp;&amp; NEW_STYLE_NUMBER(w)) {
		slotw = *NB_TERNOP(mw, op_slot);
		if (slotw == slotv)
			slotw = NULL;
	}
	if (slotv) {
		if (slotw &amp;&amp; PyType_IsSubtype(w-&gt;ob_type, v-&gt;ob_type)) {
			x = slotw(v, w, z);
			if (x != Py_NotImplemented)
				return x;
			Py_DECREF(x); /* can't do it */
			slotw = NULL;
		}
		x = slotv(v, w, z);
		if (x != Py_NotImplemented)
			return x;
		Py_DECREF(x); /* can't do it */
	}
	if (slotw) {
		x = slotw(v, w, z);
		if (x != Py_NotImplemented)
			return x;
		Py_DECREF(x); /* can't do it */
	}
	mz = z-&gt;ob_type-&gt;tp_as_number;
	if (mz != NULL &amp;&amp; NEW_STYLE_NUMBER(z)) {
		slotz = *NB_TERNOP(mz, op_slot);
		if (slotz == slotv || slotz == slotw)
			slotz = NULL;
		if (slotz) {
			x = slotz(v, w, z);
			if (x != Py_NotImplemented)
				return x;
			Py_DECREF(x); /* can't do it */
		}
	}

	if (!NEW_STYLE_NUMBER(v) || !NEW_STYLE_NUMBER(w) ||
			(z != Py_None &amp;&amp; !NEW_STYLE_NUMBER(z))) {
		/* we have an old style operand, coerce */
		PyObject *v1, *z1, *w2, *z2;
		int c;
		
		c = PyNumber_Coerce(&amp;v, &amp;w);
		if (c != 0)
			goto error3;

		/* Special case: if the third argument is None, it is
		   treated as absent argument and not coerced. */
		if (z == Py_None) {
			if (v-&gt;ob_type-&gt;tp_as_number) {
				slotz = *NB_TERNOP(v-&gt;ob_type-&gt;tp_as_number,
						   op_slot);
				if (slotz)
					x = slotz(v, w, z);
				else
					c = -1;
			}
			else
				c = -1;
			goto error2;
		}
		v1 = v;
		z1 = z;
		c = PyNumber_Coerce(&amp;v1, &amp;z1);
		if (c != 0)
			goto error2;
		w2 = w;
		z2 = z1;
		c = PyNumber_Coerce(&amp;w2, &amp;z2);
		if (c != 0)
			goto error1;

		if (v1-&gt;ob_type-&gt;tp_as_number != NULL) {
			slotv = *NB_TERNOP(v1-&gt;ob_type-&gt;tp_as_number,
					   op_slot);
			if (slotv)
				x = slotv(v1, w2, z2);
			else
				c = -1;
		}
		else
			c = -1;

		Py_DECREF(w2);
		Py_DECREF(z2);
	error1:
		Py_DECREF(v1);
		Py_DECREF(z1);
	error2:
		Py_DECREF(v);
		Py_DECREF(w);
	error3:
		if (c &gt;= 0)
			return x;
	}

	if (z == Py_None)
		PyErr_Format(
			PyExc_TypeError,
			"unsupported operand type(s) for ** or pow(): "
			"'%s' and '%s'",
			v-&gt;ob_type-&gt;tp_name,
			w-&gt;ob_type-&gt;tp_name);
	else
		PyErr_Format(
			PyExc_TypeError,
			"unsupported operand type(s) for pow(): "
			"'%s', '%s', '%s'",
			v-&gt;ob_type-&gt;tp_name,
			w-&gt;ob_type-&gt;tp_name,
			z-&gt;ob_type-&gt;tp_name);
	return NULL;
}
</t>
<t tx="T88">#define BINARY_FUNC(func, op, op_name) \
    PyObject * \
    func(PyObject *v, PyObject *w) { \
	    return binary_op(v, w, NB_SLOT(op), op_name); \
    }

BINARY_FUNC(PyNumber_Or, nb_or, "|")
BINARY_FUNC(PyNumber_Xor, nb_xor, "^")
BINARY_FUNC(PyNumber_And, nb_and, "&amp;")
BINARY_FUNC(PyNumber_Lshift, nb_lshift, "&lt;&lt;")
BINARY_FUNC(PyNumber_Rshift, nb_rshift, "&gt;&gt;")
BINARY_FUNC(PyNumber_Subtract, nb_subtract, "-")
BINARY_FUNC(PyNumber_Multiply, nb_multiply, "*")
BINARY_FUNC(PyNumber_Divide, nb_divide, "/")
BINARY_FUNC(PyNumber_Divmod, nb_divmod, "divmod()")</t>
<t tx="T89">PyObject *
PyNumber_Add(PyObject *v, PyObject *w)
{
	PyObject *result = binary_op1(v, w, NB_SLOT(nb_add));
	if (result == Py_NotImplemented) {
		PySequenceMethods *m = v-&gt;ob_type-&gt;tp_as_sequence;
		Py_DECREF(Py_NotImplemented);
		if (m &amp;&amp; m-&gt;sq_concat) {
			result = (*m-&gt;sq_concat)(v, w);
		}
                else {
                    PyErr_Format(
			    PyExc_TypeError,
			    "unsupported operand types for +: '%s' and '%s'",
			    v-&gt;ob_type-&gt;tp_name,
			    w-&gt;ob_type-&gt;tp_name);
                    result = NULL;
                }
	}
	return result;
}
</t>
<t tx="T90">PyObject *
PyNumber_FloorDivide(PyObject *v, PyObject *w)
{
	/* XXX tp_flags test */
	return binary_op(v, w, NB_SLOT(nb_floor_divide), "//");
}
</t>
<t tx="T91">PyObject *
PyNumber_TrueDivide(PyObject *v, PyObject *w)
{
	/* XXX tp_flags test */
	return binary_op(v, w, NB_SLOT(nb_true_divide), "/");
}
</t>
<t tx="T92">PyObject *
PyNumber_Remainder(PyObject *v, PyObject *w)
{
	if (PyString_Check(v))
		return PyString_Format(v, w);
#ifdef Py_USING_UNICODE
	else if (PyUnicode_Check(v))
		return PyUnicode_Format(v, w);
#endif
	return binary_op(v, w, NB_SLOT(nb_remainder), "%");
}
</t>
<t tx="T93">PyObject *
PyNumber_Power(PyObject *v, PyObject *w, PyObject *z)
{
	return ternary_op(v, w, z, NB_SLOT(nb_power), "** or pow()");
}
</t>
<t tx="T94">@ Binary in-place operators */
The in-place operators are defined to fall back to the 'normal', non in-place operations, if the in-place methods are not in place. - If the left hand object has the appropriate struct members, and they are filled, call the appropriate function and return the result. No coercion is done on the arguments; the left-hand object is the one the operation is performed on, and it's up to the function to deal with the right-hand object. - Otherwise, in-place modification is not supported. Handle it exactly as a non in-place operation of the same kind. */
@c

#define HASINPLACE(t) PyType_HasFeature((t)-&gt;ob_type, Py_TPFLAGS_HAVE_INPLACEOPS)

static PyObject *
binary_iop(PyObject *v, PyObject *w, const int iop_slot, const int op_slot,
		const char *op_name)
{
	PyNumberMethods *mv = v-&gt;ob_type-&gt;tp_as_number;
	if (mv != NULL &amp;&amp; HASINPLACE(v)) {
		binaryfunc *slot = NB_BINOP(mv, iop_slot);
		if (*slot) {
			PyObject *x = (*slot)(v, w);
			if (x != Py_NotImplemented) {
				return x;
			}
			Py_DECREF(x);
		}
	}
	return binary_op(v, w, op_slot, op_name);
}
</t>
<t tx="T95">#define INPLACE_BINOP(func, iop, op, op_name) \
	PyObject * \
	func(PyObject *v, PyObject *w) { \
		return binary_iop(v, w, NB_SLOT(iop), NB_SLOT(op), op_name); \
	}

INPLACE_BINOP(PyNumber_InPlaceOr, nb_inplace_or, nb_or, "|=")
INPLACE_BINOP(PyNumber_InPlaceXor, nb_inplace_xor, nb_xor, "^=")
INPLACE_BINOP(PyNumber_InPlaceAnd, nb_inplace_and, nb_and, "&amp;=")
INPLACE_BINOP(PyNumber_InPlaceLshift, nb_inplace_lshift, nb_lshift, "&lt;&lt;=")
INPLACE_BINOP(PyNumber_InPlaceRshift, nb_inplace_rshift, nb_rshift, "&gt;&gt;=")
INPLACE_BINOP(PyNumber_InPlaceSubtract, nb_inplace_subtract, nb_subtract, "-=")
INPLACE_BINOP(PyNumber_InPlaceDivide, nb_inplace_divide, nb_divide, "/=")</t>
<t tx="T96">PyObject *
PyNumber_InPlaceFloorDivide(PyObject *v, PyObject *w)
{
	/* XXX tp_flags test */
	return binary_iop(v, w, NB_SLOT(nb_inplace_floor_divide),
			  NB_SLOT(nb_floor_divide), "//=");
}
</t>
<t tx="T97">PyObject *
PyNumber_InPlaceTrueDivide(PyObject *v, PyObject *w)
{
	/* XXX tp_flags test */
	return binary_iop(v, w, NB_SLOT(nb_inplace_true_divide),
			  NB_SLOT(nb_true_divide), "/=");
}
</t>
<t tx="T98">PyObject *
PyNumber_InPlaceAdd(PyObject *v, PyObject *w)
{
	binaryfunc f = NULL;

	if (v-&gt;ob_type-&gt;tp_as_sequence != NULL) {
		if (HASINPLACE(v))
			f = v-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_inplace_concat;
		if (f == NULL)
			f = v-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_concat;
		if (f != NULL)
			return (*f)(v, w);
	}
	return binary_iop(v, w, NB_SLOT(nb_inplace_add), NB_SLOT(nb_add), "+=");
}
</t>
<t tx="T99">PyObject *
PyNumber_InPlaceMultiply(PyObject *v, PyObject *w)
{
	PyObject * (*g)(PyObject *, int) = NULL;
	if (HASINPLACE(v) &amp;&amp; v-&gt;ob_type-&gt;tp_as_sequence &amp;&amp;
		(g = v-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_inplace_repeat)) {
		long n;
		if (PyInt_Check(w)) {
			n  = PyInt_AsLong(w);
		}
		else if (PyLong_Check(w)) {
			n = PyLong_AsLong(w);
			if (n == -1 &amp;&amp; PyErr_Occurred())
				return NULL;
		}
		else {
			return type_error("can't multiply sequence to non-int");
		}
		return (*g)(v, (int)n);
	}
	return binary_iop(v, w, NB_SLOT(nb_inplace_multiply),
				NB_SLOT(nb_multiply), "*=");
}
</t>
<t tx="T100">PyObject *
PyNumber_InPlaceRemainder(PyObject *v, PyObject *w)
{
	if (PyString_Check(v))
		return PyString_Format(v, w);
#ifdef Py_USING_UNICODE
	else if (PyUnicode_Check(v))
		return PyUnicode_Format(v, w);
#endif
	else
		return binary_iop(v, w, NB_SLOT(nb_inplace_remainder),
					NB_SLOT(nb_remainder), "%=");
}
</t>
<t tx="T101">PyObject *
PyNumber_InPlacePower(PyObject *v, PyObject *w, PyObject *z)
{
	if (HASINPLACE(v) &amp;&amp; v-&gt;ob_type-&gt;tp_as_number &amp;&amp;
	    v-&gt;ob_type-&gt;tp_as_number-&gt;nb_inplace_power != NULL) {
		return ternary_op(v, w, z, NB_SLOT(nb_inplace_power), "**=");
	}
	else {
		return ternary_op(v, w, z, NB_SLOT(nb_power), "**=");
	}
}
</t>
<t tx="T102">@ Unary operators and functions */
@c

PyObject *
PyNumber_Negative(PyObject *o)
{
	PyNumberMethods *m;

	if (o == NULL)
		return null_error();
	m = o-&gt;ob_type-&gt;tp_as_number;
	if (m &amp;&amp; m-&gt;nb_negative)
		return (*m-&gt;nb_negative)(o);

	return type_error("bad operand type for unary -");
}
</t>
<t tx="T103">PyObject *
PyNumber_Positive(PyObject *o)
{
	PyNumberMethods *m;

	if (o == NULL)
		return null_error();
	m = o-&gt;ob_type-&gt;tp_as_number;
	if (m &amp;&amp; m-&gt;nb_positive)
		return (*m-&gt;nb_positive)(o);

	return type_error("bad operand type for unary +");
}
</t>
<t tx="T104">PyObject *
PyNumber_Invert(PyObject *o)
{
	PyNumberMethods *m;

	if (o == NULL)
		return null_error();
	m = o-&gt;ob_type-&gt;tp_as_number;
	if (m &amp;&amp; m-&gt;nb_invert)
		return (*m-&gt;nb_invert)(o);

	return type_error("bad operand type for unary ~");
}
</t>
<t tx="T105">PyObject *
PyNumber_Absolute(PyObject *o)
{
	PyNumberMethods *m;

	if (o == NULL)
		return null_error();
	m = o-&gt;ob_type-&gt;tp_as_number;
	if (m &amp;&amp; m-&gt;nb_absolute)
		return m-&gt;nb_absolute(o);

	return type_error("bad operand type for abs()");
}
</t>
<t tx="T106">@ Add a check for embedded NULL-bytes in the argument. */
@c

static PyObject *
int_from_string(const char *s, int len)
{
	char *end;
	PyObject *x;

	x = PyInt_FromString((char*)s, &amp;end, 10);
	if (x == NULL)
		return NULL;
	if (end != s + len) {
		PyErr_SetString(PyExc_ValueError,
				"null byte in argument for int()");
		Py_DECREF(x);
		return NULL;
	}
	return x;
}
</t>
<t tx="T107">PyObject *
PyNumber_Int(PyObject *o)
{
	PyNumberMethods *m;
	const char *buffer;
	int buffer_len;

	if (o == NULL)
		return null_error();
	if (PyInt_CheckExact(o)) {
		Py_INCREF(o);
		return o;
	}
	if (PyInt_Check(o)) {
		PyIntObject *io = (PyIntObject*)o;
		return PyInt_FromLong(io-&gt;ob_ival);
	}
	if (PyString_Check(o))
		return int_from_string(PyString_AS_STRING(o), 
				       PyString_GET_SIZE(o));
#ifdef Py_USING_UNICODE
	if (PyUnicode_Check(o))
		return PyInt_FromUnicode(PyUnicode_AS_UNICODE(o),
					 PyUnicode_GET_SIZE(o),
					 10);
#endif
	m = o-&gt;ob_type-&gt;tp_as_number;
	if (m &amp;&amp; m-&gt;nb_int)
		return m-&gt;nb_int(o);
	if (!PyObject_AsCharBuffer(o, &amp;buffer, &amp;buffer_len))
		return int_from_string((char*)buffer, buffer_len);

	return type_error("object can't be converted to int");
}
</t>
<t tx="T108">@ Add a check for embedded NULL-bytes in the argument. */
@c

static PyObject *
long_from_string(const char *s, int len)
{
	char *end;
	PyObject *x;

	x = PyLong_FromString((char*)s, &amp;end, 10);
	if (x == NULL)
		return NULL;
	if (end != s + len) {
		PyErr_SetString(PyExc_ValueError,
				"null byte in argument for long()");
		Py_DECREF(x);
		return NULL;
	}
	return x;
}
</t>
<t tx="T109">PyObject *
PyNumber_Long(PyObject *o)
{
	PyNumberMethods *m;
	const char *buffer;
	int buffer_len;

	if (o == NULL)
		return null_error();
	if (PyLong_CheckExact(o)) {
		Py_INCREF(o);
		return o;
	}
	if (PyLong_Check(o))
		return _PyLong_Copy((PyLongObject *)o);
	if (PyString_Check(o))
		/* need to do extra error checking that PyLong_FromString() 
		 * doesn't do.  In particular long('9.5') must raise an
		 * exception, not truncate the float.
		 */
		return long_from_string(PyString_AS_STRING(o),
					PyString_GET_SIZE(o));
#ifdef Py_USING_UNICODE
	if (PyUnicode_Check(o))
		/* The above check is done in PyLong_FromUnicode(). */
		return PyLong_FromUnicode(PyUnicode_AS_UNICODE(o),
					  PyUnicode_GET_SIZE(o),
					  10);
#endif
	m = o-&gt;ob_type-&gt;tp_as_number;
	if (m &amp;&amp; m-&gt;nb_long)
		return m-&gt;nb_long(o);
	if (!PyObject_AsCharBuffer(o, &amp;buffer, &amp;buffer_len))
		return long_from_string(buffer, buffer_len);

	return type_error("object can't be converted to long");
}
</t>
<t tx="T110">PyObject *
PyNumber_Float(PyObject *o)
{
	PyNumberMethods *m;

	if (o == NULL)
		return null_error();
	if (PyFloat_CheckExact(o)) {
		Py_INCREF(o);
		return o;
	}
	if (PyFloat_Check(o)) {
		PyFloatObject *po = (PyFloatObject *)o;
		return PyFloat_FromDouble(po-&gt;ob_fval);
	}
	if (!PyString_Check(o)) {
		m = o-&gt;ob_type-&gt;tp_as_number;
		if (m &amp;&amp; m-&gt;nb_float)
			return m-&gt;nb_float(o);
	}
	return PyFloat_FromString(o, NULL);
}
</t>
<t tx="T111"></t>
<t tx="T112">@ Operations on sequences */
@c

int
PySequence_Check(PyObject *s)
{
	return s != NULL &amp;&amp; s-&gt;ob_type-&gt;tp_as_sequence &amp;&amp;
		s-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_item != NULL;
}
</t>
<t tx="T113">int
PySequence_Size(PyObject *s)
{
	PySequenceMethods *m;

	if (s == NULL) {
		null_error();
		return -1;
	}

	m = s-&gt;ob_type-&gt;tp_as_sequence;
	if (m &amp;&amp; m-&gt;sq_length)
		return m-&gt;sq_length(s);

	type_error("len() of unsized object");
	return -1;
}
</t>
<t tx="T114">#undef PySequence_Length
int
PySequence_Length(PyObject *s)
{
	return PySequence_Size(s);
}
</t>
<t tx="T115">#define PySequence_Length PySequence_Size

PyObject *
PySequence_Concat(PyObject *s, PyObject *o)
{
	PySequenceMethods *m;

	if (s == NULL || o == NULL)
		return null_error();

	m = s-&gt;ob_type-&gt;tp_as_sequence;
	if (m &amp;&amp; m-&gt;sq_concat)
		return m-&gt;sq_concat(s, o);

	return type_error("object can't be concatenated");
}
</t>
<t tx="T116">PyObject *
PySequence_Repeat(PyObject *o, int count)
{
	PySequenceMethods *m;

	if (o == NULL)
		return null_error();

	m = o-&gt;ob_type-&gt;tp_as_sequence;
	if (m &amp;&amp; m-&gt;sq_repeat)
		return m-&gt;sq_repeat(o, count);

	return type_error("object can't be repeated");
}
</t>
<t tx="T117">PyObject *
PySequence_InPlaceConcat(PyObject *s, PyObject *o)
{
	PySequenceMethods *m;

	if (s == NULL || o == NULL)
		return null_error();

	m = s-&gt;ob_type-&gt;tp_as_sequence;
	if (m &amp;&amp; HASINPLACE(s) &amp;&amp; m-&gt;sq_inplace_concat)
		return m-&gt;sq_inplace_concat(s, o);
	if (m &amp;&amp; m-&gt;sq_concat)
		return m-&gt;sq_concat(s, o);

	return type_error("object can't be concatenated");
}
</t>
<t tx="T118">PyObject *
PySequence_InPlaceRepeat(PyObject *o, int count)
{
	PySequenceMethods *m;

	if (o == NULL)
		return null_error();

	m = o-&gt;ob_type-&gt;tp_as_sequence;
	if (m &amp;&amp; HASINPLACE(o) &amp;&amp; m-&gt;sq_inplace_repeat)
		return m-&gt;sq_inplace_repeat(o, count);
	if (m &amp;&amp; m-&gt;sq_repeat)
		return m-&gt;sq_repeat(o, count);

	return type_error("object can't be repeated");
}
</t>
<t tx="T119">PyObject *
PySequence_GetItem(PyObject *s, int i)
{
	PySequenceMethods *m;

	if (s == NULL)
		return null_error();

	m = s-&gt;ob_type-&gt;tp_as_sequence;
	if (m &amp;&amp; m-&gt;sq_item) {
		if (i &lt; 0) {
			if (m-&gt;sq_length) {
				int l = (*m-&gt;sq_length)(s);
				if (l &lt; 0)
					return NULL;
				i += l;
			}
		}
		return m-&gt;sq_item(s, i);
	}

	return type_error("unindexable object");
}
</t>
<t tx="T120">static PyObject *
sliceobj_from_intint(int i, int j)
{
	PyObject *start, *end, *slice;
	start = PyInt_FromLong((long)i);
	if (!start)
		return NULL;
	end = PyInt_FromLong((long)j);
	if (!end) {
		Py_DECREF(start);
		return NULL;
	}
	slice = PySlice_New(start, end, NULL);
	Py_DECREF(start);
	Py_DECREF(end);
	return slice;
}
</t>
<t tx="T121">PyObject *
PySequence_GetSlice(PyObject *s, int i1, int i2)
{
	PySequenceMethods *m;
	PyMappingMethods *mp;

	if (!s) return null_error();

	m = s-&gt;ob_type-&gt;tp_as_sequence;
	if (m &amp;&amp; m-&gt;sq_slice) {
		if (i1 &lt; 0 || i2 &lt; 0) {
			if (m-&gt;sq_length) {
				int l = (*m-&gt;sq_length)(s);
				if (l &lt; 0)
					return NULL;
				if (i1 &lt; 0)
					i1 += l;
				if (i2 &lt; 0)
					i2 += l;
			}
		}
		return m-&gt;sq_slice(s, i1, i2);
	} else if ((mp = s-&gt;ob_type-&gt;tp_as_mapping) &amp;&amp; mp-&gt;mp_subscript) {
		PyObject *res;
		PyObject *slice = sliceobj_from_intint(i1, i2);
		if (!slice)
			return NULL;
		res = mp-&gt;mp_subscript(s, slice);
		Py_DECREF(slice);
		return res;
	}

	return type_error("unsliceable object");
}
</t>
<t tx="T122">int
PySequence_SetItem(PyObject *s, int i, PyObject *o)
{
	PySequenceMethods *m;

	if (s == NULL) {
		null_error();
		return -1;
	}

	m = s-&gt;ob_type-&gt;tp_as_sequence;
	if (m &amp;&amp; m-&gt;sq_ass_item) {
		if (i &lt; 0) {
			if (m-&gt;sq_length) {
				int l = (*m-&gt;sq_length)(s);
				if (l &lt; 0)
					return -1;
				i += l;
			}
		}
		return m-&gt;sq_ass_item(s, i, o);
	}

	type_error("object doesn't support item assignment");
	return -1;
}
</t>
<t tx="T123">int
PySequence_DelItem(PyObject *s, int i)
{
	PySequenceMethods *m;

	if (s == NULL) {
		null_error();
		return -1;
	}

	m = s-&gt;ob_type-&gt;tp_as_sequence;
	if (m &amp;&amp; m-&gt;sq_ass_item) {
		if (i &lt; 0) {
			if (m-&gt;sq_length) {
				int l = (*m-&gt;sq_length)(s);
				if (l &lt; 0)
					return -1;
				i += l;
			}
		}
		return m-&gt;sq_ass_item(s, i, (PyObject *)NULL);
	}

	type_error("object doesn't support item deletion");
	return -1;
}
</t>
<t tx="T124">int
PySequence_SetSlice(PyObject *s, int i1, int i2, PyObject *o)
{
	PySequenceMethods *m;
	PyMappingMethods *mp;

	if (s == NULL) {
		null_error();
		return -1;
	}

	m = s-&gt;ob_type-&gt;tp_as_sequence;
	if (m &amp;&amp; m-&gt;sq_ass_slice) {
		if (i1 &lt; 0 || i2 &lt; 0) {
			if (m-&gt;sq_length) {
				int l = (*m-&gt;sq_length)(s);
				if (l &lt; 0)
					return -1;
				if (i1 &lt; 0)
					i1 += l;
				if (i2 &lt; 0)
					i2 += l;
			}
		}
		return m-&gt;sq_ass_slice(s, i1, i2, o);
	} else if ((mp = s-&gt;ob_type-&gt;tp_as_mapping) &amp;&amp; mp-&gt;mp_ass_subscript) {
		int res;
		PyObject *slice = sliceobj_from_intint(i1, i2);
		if (!slice)
			return -1;
		res = mp-&gt;mp_ass_subscript(s, slice, o);
		Py_DECREF(slice);
		return res;
	}

	type_error("object doesn't support slice assignment");
	return -1;
}
</t>
<t tx="T125">int
PySequence_DelSlice(PyObject *s, int i1, int i2)
{
	PySequenceMethods *m;

	if (s == NULL) {
		null_error();
		return -1;
	}

	m = s-&gt;ob_type-&gt;tp_as_sequence;
	if (m &amp;&amp; m-&gt;sq_ass_slice) {
		if (i1 &lt; 0 || i2 &lt; 0) {
			if (m-&gt;sq_length) {
				int l = (*m-&gt;sq_length)(s);
				if (l &lt; 0)
					return -1;
				if (i1 &lt; 0)
					i1 += l;
				if (i2 &lt; 0)
					i2 += l;
			}
		}
		return m-&gt;sq_ass_slice(s, i1, i2, (PyObject *)NULL);
	}
	type_error("object doesn't support slice deletion");
	return -1;
}
</t>
<t tx="T126">PyObject *
PySequence_Tuple(PyObject *v)
{
	PyObject *it;  /* iter(v) */
	int n;         /* guess for result tuple size */
	PyObject *result;
	int j;

	if (v == NULL)
		return null_error();

	/* Special-case the common tuple and list cases, for efficiency. */
	if (PyTuple_CheckExact(v)) {
		/* Note that we can't know whether it's safe to return
		   a tuple *subclass* instance as-is, hence the restriction
		   to exact tuples here.  In contrast, lists always make
		   a copy, so there's no need for exactness below. */
		Py_INCREF(v);
		return v;
	}
	if (PyList_Check(v))
		return PyList_AsTuple(v);

	/* Get iterator. */
	it = PyObject_GetIter(v);
	if (it == NULL)
		return NULL;

	/* Guess result size and allocate space. */
	n = PySequence_Size(v);
	if (n &lt; 0) {
		PyErr_Clear();
		n = 10;  /* arbitrary */
	}
	result = PyTuple_New(n);
	if (result == NULL)
		goto Fail;

	/* Fill the tuple. */
	for (j = 0; ; ++j) {
		PyObject *item = PyIter_Next(it);
		if (item == NULL) {
			if (PyErr_Occurred())
				goto Fail;
			break;
		}
		if (j &gt;= n) {
			if (n &lt; 500)
				n += 10;
			else
				n += 100;
			if (_PyTuple_Resize(&amp;result, n) != 0) {
				Py_DECREF(item);
				goto Fail;
			}
		}
		PyTuple_SET_ITEM(result, j, item);
	}

	/* Cut tuple back if guess was too large. */
	if (j &lt; n &amp;&amp;
	    _PyTuple_Resize(&amp;result, j) != 0)
		goto Fail;

	Py_DECREF(it);
	return result;

Fail:
	Py_XDECREF(result);
	Py_DECREF(it);
	return NULL;
}
</t>
<t tx="T127">PyObject *
PySequence_List(PyObject *v)
{
	PyObject *it;      /* iter(v) */
	PyObject *result;  /* result list */
	int n;		   /* guess for result list size */
	int i;

	if (v == NULL)
		return null_error();

	/* Special-case list(a_list), for speed. */
	if (PyList_Check(v))
		return PyList_GetSlice(v, 0, PyList_GET_SIZE(v));

	/* Get iterator.  There may be some low-level efficiency to be gained
	 * by caching the tp_iternext slot instead of using PyIter_Next()
	 * later, but premature optimization is the root etc.
	 */
	it = PyObject_GetIter(v);
	if (it == NULL)
		return NULL;

	/* Guess a result list size. */
	n = -1;	 /* unknown */
	if (PySequence_Check(v) &amp;&amp;
	    v-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_length) {
		n = PySequence_Size(v);
		if (n &lt; 0)
			PyErr_Clear();
	}
	if (n &lt; 0)
		n = 8;	/* arbitrary */
	result = PyList_New(n);
	if (result == NULL) {
		Py_DECREF(it);
		return NULL;
	}

	/* Run iterator to exhaustion. */
	for (i = 0; ; i++) {
		PyObject *item = PyIter_Next(it);
		if (item == NULL) {
			if (PyErr_Occurred()) {
				Py_DECREF(result);
				result = NULL;
			}
			break;
		}
		if (i &lt; n)
			PyList_SET_ITEM(result, i, item); /* steals ref */
		else {
			int status = PyList_Append(result, item);
			Py_DECREF(item);  /* append creates a new ref */
			if (status &lt; 0) {
				Py_DECREF(result);
				result = NULL;
				break;
			}
		}
	}

	/* Cut back result list if initial guess was too large. */
	if (i &lt; n &amp;&amp; result != NULL) {
		if (PyList_SetSlice(result, i, n, (PyObject *)NULL) != 0) {
			Py_DECREF(result);
			result = NULL;
		}
	}
	Py_DECREF(it);
	return result;
}
</t>
<t tx="T128">PyObject *
PySequence_Fast(PyObject *v, const char *m)
{
	if (v == NULL)
		return null_error();

	if (PyList_Check(v) || PyTuple_Check(v)) {
		Py_INCREF(v);
		return v;
	}

	v = PySequence_Tuple(v);
	if (v == NULL &amp;&amp; PyErr_ExceptionMatches(PyExc_TypeError))
		return type_error(m);

	return v;
}
</t>
<t tx="T129">@ Iterate over seq. Result depends on the operation: PY_ITERSEARCH_COUNT: -1 if error, else # of times obj appears in seq. PY_ITERSEARCH_INDEX: 0-based index of first occurence of obj in seq; set ValueError and return -1 if none found; also return -1 on error. Py_ITERSEARCH_CONTAINS: return 1 if obj in seq, else 0; -1 on error. */
@c

int
_PySequence_IterSearch(PyObject *seq, PyObject *obj, int operation)
{
	int n;
	int wrapped;  /* for PY_ITERSEARCH_INDEX, true iff n wrapped around */
	PyObject *it;  /* iter(seq) */

	if (seq == NULL || obj == NULL) {
		null_error();
		return -1;
	}

	it = PyObject_GetIter(seq);
	if (it == NULL) {
		type_error("iterable argument required");
		return -1;
	}

	n = wrapped = 0;
	for (;;) {
		int cmp;
		PyObject *item = PyIter_Next(it);
		if (item == NULL) {
			if (PyErr_Occurred())
				goto Fail;
			break;
		}

		cmp = PyObject_RichCompareBool(obj, item, Py_EQ);
		Py_DECREF(item);
		if (cmp &lt; 0)
			goto Fail;
		if (cmp &gt; 0) {
			switch (operation) {
			case PY_ITERSEARCH_COUNT:
				++n;
				if (n &lt;= 0) {
					PyErr_SetString(PyExc_OverflowError,
				                "count exceeds C int size");
					goto Fail;
				}
				break;

			case PY_ITERSEARCH_INDEX:
				if (wrapped) {
					PyErr_SetString(PyExc_OverflowError,
			                	"index exceeds C int size");
					goto Fail;
				}
				goto Done;

			case PY_ITERSEARCH_CONTAINS:
				n = 1;
				goto Done;

			default:
				assert(!"unknown operation");
			}
		}

		if (operation == PY_ITERSEARCH_INDEX) {
			++n;
			if (n &lt;= 0)
				wrapped = 1;
		}
	}

	if (operation != PY_ITERSEARCH_INDEX)
		goto Done;

	PyErr_SetString(PyExc_ValueError,
		        "sequence.index(x): x not in sequence");
	/* fall into failure code */
Fail:
	n = -1;
	/* fall through */
Done:
	Py_DECREF(it);
	return n;

}
</t>
<t tx="T130">@ Return # of times o appears in s. */
@c

int
PySequence_Count(PyObject *s, PyObject *o)
{
	return _PySequence_IterSearch(s, o, PY_ITERSEARCH_COUNT);
}
</t>
<t tx="T131">@ Return -1 if error; 1 if ob in seq; 0 if ob not in seq. * Use sq_contains if possible, else defer to _PySequence_IterSearch(). */
@c

int
PySequence_Contains(PyObject *seq, PyObject *ob)
{
	if (PyType_HasFeature(seq-&gt;ob_type, Py_TPFLAGS_HAVE_SEQUENCE_IN)) {
		PySequenceMethods *sqm = seq-&gt;ob_type-&gt;tp_as_sequence;
	        if (sqm != NULL &amp;&amp; sqm-&gt;sq_contains != NULL)
			return (*sqm-&gt;sq_contains)(seq, ob);
	}
	return _PySequence_IterSearch(seq, ob, PY_ITERSEARCH_CONTAINS);
}
</t>
<t tx="T132">@ Backwards compatibility */
@c

#undef PySequence_In
int
PySequence_In(PyObject *w, PyObject *v)
{
	return PySequence_Contains(w, v);
}
</t>
<t tx="T133">int
PySequence_Index(PyObject *s, PyObject *o)
{
	return _PySequence_IterSearch(s, o, PY_ITERSEARCH_INDEX);
}
</t>
<t tx="T134"></t>
<t tx="T135">@ Operations on mappings */
@c

int
PyMapping_Check(PyObject *o)
{
	return o &amp;&amp; o-&gt;ob_type-&gt;tp_as_mapping &amp;&amp;
		o-&gt;ob_type-&gt;tp_as_mapping-&gt;mp_subscript;
}
</t>
<t tx="T136">int
PyMapping_Size(PyObject *o)
{
	PyMappingMethods *m;

	if (o == NULL) {
		null_error();
		return -1;
	}

	m = o-&gt;ob_type-&gt;tp_as_mapping;
	if (m &amp;&amp; m-&gt;mp_length)
		return m-&gt;mp_length(o);

	type_error("len() of unsized object");
	return -1;
}
</t>
<t tx="T137">#undef PyMapping_Length
int
PyMapping_Length(PyObject *o)
{
	return PyMapping_Size(o);
}
</t>
<t tx="T138">#define PyMapping_Length PyMapping_Size

PyObject *
PyMapping_GetItemString(PyObject *o, char *key)
{
	PyObject *okey, *r;

	if (key == NULL)
		return null_error();

	okey = PyString_FromString(key);
	if (okey == NULL)
		return NULL;
	r = PyObject_GetItem(o, okey);
	Py_DECREF(okey);
	return r;
}
</t>
<t tx="T139">int
PyMapping_SetItemString(PyObject *o, char *key, PyObject *value)
{
	PyObject *okey;
	int r;

	if (key == NULL) {
		null_error();
		return -1;
	}

	okey = PyString_FromString(key);
	if (okey == NULL)
		return -1;
	r = PyObject_SetItem(o, okey, value);
	Py_DECREF(okey);
	return r;
}
</t>
<t tx="T140">int
PyMapping_HasKeyString(PyObject *o, char *key)
{
	PyObject *v;

	v = PyMapping_GetItemString(o, key);
	if (v) {
		Py_DECREF(v);
		return 1;
	}
	PyErr_Clear();
	return 0;
}
</t>
<t tx="T141">int
PyMapping_HasKey(PyObject *o, PyObject *key)
{
	PyObject *v;

	v = PyObject_GetItem(o, key);
	if (v) {
		Py_DECREF(v);
		return 1;
	}
	PyErr_Clear();
	return 0;
}
</t>
<t tx="T142"></t>
<t tx="T143"></t>
<t tx="T144">@ Operations on callable objects */
XXX PyCallable_Check() is in object.c */
@c

PyObject *
PyObject_CallObject(PyObject *o, PyObject *a)
{
	return PyEval_CallObjectWithKeywords(o, a, NULL);
}
</t>
<t tx="T145">PyObject *
PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw)
{
        ternaryfunc call;

	if ((call = func-&gt;ob_type-&gt;tp_call) != NULL) {
		PyObject *result = (*call)(func, arg, kw);
		if (result == NULL &amp;&amp; !PyErr_Occurred())
			PyErr_SetString(
				PyExc_SystemError,
				"NULL result without error in PyObject_Call");
		return result;
	}
	PyErr_Format(PyExc_TypeError, "'%s' object is not callable",
		     func-&gt;ob_type-&gt;tp_name);
	return NULL;
}
</t>
<t tx="T146">PyObject *
PyObject_CallFunction(PyObject *callable, char *format, ...)
{
	va_list va;
	PyObject *args, *retval;

	if (callable == NULL)
		return null_error();

	if (format &amp;&amp; *format) {
		va_start(va, format);
		args = Py_VaBuildValue(format, va);
		va_end(va);
	}
	else
		args = PyTuple_New(0);

	if (args == NULL)
		return NULL;

	if (!PyTuple_Check(args)) {
		PyObject *a;

		a = PyTuple_New(1);
		if (a == NULL)
			return NULL;
		if (PyTuple_SetItem(a, 0, args) &lt; 0)
			return NULL;
		args = a;
	}
	retval = PyObject_CallObject(callable, args);

	Py_DECREF(args);

	return retval;
}
</t>
<t tx="T147">PyObject *
PyObject_CallMethod(PyObject *o, char *name, char *format, ...)
{
	va_list va;
	PyObject *args, *func = 0, *retval;

	if (o == NULL || name == NULL)
		return null_error();

	func = PyObject_GetAttrString(o, name);
	if (func == NULL) {
		PyErr_SetString(PyExc_AttributeError, name);
		return 0;
	}

	if (!PyCallable_Check(func))
		return type_error("call of non-callable attribute");

	if (format &amp;&amp; *format) {
		va_start(va, format);
		args = Py_VaBuildValue(format, va);
		va_end(va);
	}
	else
		args = PyTuple_New(0);

	if (!args)
		return NULL;

	if (!PyTuple_Check(args)) {
		PyObject *a;

		a = PyTuple_New(1);
		if (a == NULL)
			return NULL;
		if (PyTuple_SetItem(a, 0, args) &lt; 0)
			return NULL;
		args = a;
	}

	retval = PyObject_CallObject(func, args);

	Py_DECREF(args);
	Py_DECREF(func);

	return retval;
}
</t>
<t tx="T148">static PyObject *
objargs_mktuple(va_list va)
{
	int i, n = 0;
	va_list countva;
	PyObject *result, *tmp;

#ifdef VA_LIST_IS_ARRAY
	memcpy(countva, va, sizeof(va_list));
#else
	countva = va;
#endif

	while (((PyObject *)va_arg(countva, PyObject *)) != NULL)
		++n;
	result = PyTuple_New(n);
	if (result != NULL &amp;&amp; n &gt; 0) {
		for (i = 0; i &lt; n; ++i) {
			tmp = (PyObject *)va_arg(va, PyObject *);
			PyTuple_SET_ITEM(result, i, tmp);
			Py_INCREF(tmp);
		}
	}
	return result;
}
</t>
<t tx="T149">PyObject *
PyObject_CallMethodObjArgs(PyObject *callable, PyObject *name, ...)
{
	PyObject *args, *tmp;
	va_list vargs;

	if (callable == NULL || name == NULL)
		return null_error();

	callable = PyObject_GetAttr(callable, name);
	if (callable == NULL)
		return NULL;

	/* count the args */
	va_start(vargs, name);
	args = objargs_mktuple(vargs);
	va_end(vargs);
	if (args == NULL) {
		Py_DECREF(callable);
		return NULL;
	}
	tmp = PyObject_Call(callable, args, NULL);
	Py_DECREF(args);
	Py_DECREF(callable);

	return tmp;
}
</t>
<t tx="T150">PyObject *
PyObject_CallFunctionObjArgs(PyObject *callable, ...)
{
	PyObject *args, *tmp;
	va_list vargs;

	if (callable == NULL)
		return null_error();

	/* count the args */
	va_start(vargs, callable);
	args = objargs_mktuple(vargs);
	va_end(vargs);
	if (args == NULL)
		return NULL;
	tmp = PyObject_Call(callable, args, NULL);
	Py_DECREF(args);

	return tmp;
}
</t>
<t tx="T151">@ isinstance(), issubclass() */
@c

static PyObject *
abstract_get_bases(PyObject *cls)
{
	static PyObject *__bases__ = NULL;
	PyObject *bases;

	if (__bases__ == NULL) {
		__bases__ = PyString_FromString("__bases__");
		if (__bases__ == NULL)
			return NULL;
	}

	bases = PyObject_GetAttr(cls, __bases__);
	if (bases == NULL || !PyTuple_Check(bases)) {
	        Py_XDECREF(bases);
		return NULL;
	}

	return bases;
}
</t>
<t tx="T152">static int
abstract_issubclass(PyObject *derived, PyObject *cls)
{
	PyObject *bases;
	int i, n;
	int r = 0;


	if (derived == cls)
		return 1;

	bases = abstract_get_bases(derived);
	if (bases == NULL)
		return 0;

	n = PyTuple_GET_SIZE(bases);
	for (i = 0; i &lt; n; i++) {
		r = abstract_issubclass(PyTuple_GET_ITEM(bases, i), cls);
		if (r != 0)
			break;
	}

	Py_DECREF(bases);

	return r;
}
</t>
<t tx="T153">int
PyObject_IsInstance(PyObject *inst, PyObject *cls)
{
	PyObject *icls;
	static PyObject *__class__ = NULL;
	int retval = 0;

	if (PyClass_Check(cls) &amp;&amp; PyInstance_Check(inst)) {
		PyObject *inclass =
			(PyObject*)((PyInstanceObject*)inst)-&gt;in_class;
		retval = PyClass_IsSubclass(inclass, cls);
	}
	else if (PyType_Check(cls)) {
		retval = PyObject_TypeCheck(inst, (PyTypeObject *)cls);
	}
	else if (PyTuple_Check(cls)) {
		/* Not a general sequence -- that opens up the road to
		   recursion and stack overflow. */
		int i, n;

		n = PyTuple_GET_SIZE(cls);
		for (i = 0; i &lt; n; i++) {
			retval = PyObject_IsInstance(
				inst, PyTuple_GET_ITEM(cls, i));
			if (retval != 0)
				break;
		}
		return retval;
	}
	else {
		PyObject *cls_bases = abstract_get_bases(cls);
		if (cls_bases == NULL) {
			PyErr_SetString(PyExc_TypeError, 
				"isinstance() arg 2 must be a class or type");
			return -1;
		} 
		Py_DECREF(cls_bases);
		if (__class__ == NULL) {
			__class__ = PyString_FromString("__class__");
			if (__class__ == NULL)
				return -1;
		}
		icls = PyObject_GetAttr(inst, __class__);
		if (icls == NULL) {
			PyErr_Clear();
			retval = 0;
		}
		else {
			retval = abstract_issubclass(icls, cls);
			Py_DECREF(icls);
		}
	}

	return retval;
}
</t>
<t tx="T154">int
PyObject_IsSubclass(PyObject *derived, PyObject *cls)
{
	int retval;

	if (!PyClass_Check(derived) || !PyClass_Check(cls)) {
		PyObject *derived_bases;
		PyObject *cls_bases;
	       
		derived_bases = abstract_get_bases(derived);
		if (derived_bases == NULL) {
			PyErr_SetString(PyExc_TypeError, 
					"issubclass() arg 1 must be a class");
			return -1;
		}
		Py_DECREF(derived_bases);

		cls_bases = abstract_get_bases(cls);
		if (cls_bases == NULL) {
			PyErr_SetString(PyExc_TypeError, 
					"issubclass() arg 2 must be a class");
			return -1;
		}
		Py_DECREF(cls_bases);

		retval = abstract_issubclass(derived, cls);
	}
	else {
		/* shortcut */
	  	if (!(retval = (derived == cls)))
			retval = PyClass_IsSubclass(derived, cls);
	}

	return retval;
}
</t>
<t tx="T155"></t>
<t tx="T156">PyObject *
PyObject_GetIter(PyObject *o)
{
	PyTypeObject *t = o-&gt;ob_type;
	getiterfunc f = NULL;
	if (PyType_HasFeature(t, Py_TPFLAGS_HAVE_ITER))
		f = t-&gt;tp_iter;
	if (f == NULL) {
		if (PySequence_Check(o))
			return PySeqIter_New(o);
		PyErr_SetString(PyExc_TypeError, 
				"iteration over non-sequence");
		return NULL;
	}
	else {
		PyObject *res = (*f)(o);
		if (res != NULL &amp;&amp; !PyIter_Check(res)) {
			PyErr_Format(PyExc_TypeError,
				     "iter() returned non-iterator "
				     "of type '%.100s'",
				     res-&gt;ob_type-&gt;tp_name);
			Py_DECREF(res);
			res = NULL;
		}
		return res;
	}
}
</t>
<t tx="T157">@ Return next item. * If an error occurs, return NULL. PyErr_Occurred() will be true. * If the iteration terminates normally, return NULL and clear the * PyExc_StopIteration exception (if it was set). PyErr_Occurred() * will be false. * Else return the next object. PyErr_Occurred() will be false. */
@c

PyObject *
PyIter_Next(PyObject *iter)
{
	PyObject *result;
	if (!PyIter_Check(iter)) {
		PyErr_Format(PyExc_TypeError,
			     "'%.100s' object is not an iterator",
			     iter-&gt;ob_type-&gt;tp_name);
		return NULL;
	}
	result = (*iter-&gt;ob_type-&gt;tp_iternext)(iter);
	if (result == NULL &amp;&amp;
	    PyErr_Occurred() &amp;&amp;
	    PyErr_ExceptionMatches(PyExc_StopIteration))
		PyErr_Clear();
	return result;
}
</t>
<t tx="T158">@language c
/* Wrap void* pointers to be passed between C modules */

&lt;&lt; cobject #includes &gt;&gt;
&lt;&lt; cobject declarations &gt;&gt;
@others


static char PyCObject_Type__doc__[] = 
"C objects to be exported from one extension module to another\n\
\n\
C objects are used for communication between extension modules.  They\n\
provide a way for an extension module to export a C interface to other\n\
extension modules, so that extension modules can use the Python import\n\
mechanism to link to one another.";

PyTypeObject PyCObject_Type = {
    PyObject_HEAD_INIT(&amp;PyType_Type)
    0,					/*ob_size*/
    "PyCObject",			/*tp_name*/
    sizeof(PyCObject),			/*tp_basicsize*/
    0,					/*tp_itemsize*/
    /* methods */
    (destructor)PyCObject_dealloc,	/*tp_dealloc*/
    (printfunc)0,			/*tp_print*/
    (getattrfunc)0,			/*tp_getattr*/
    (setattrfunc)0,			/*tp_setattr*/
    (cmpfunc)0,				/*tp_compare*/
    (reprfunc)0,			/*tp_repr*/
    0,					/*tp_as_number*/
    0,					/*tp_as_sequence*/
    0,					/*tp_as_mapping*/
    (hashfunc)0,			/*tp_hash*/
    (ternaryfunc)0,			/*tp_call*/
    (reprfunc)0,			/*tp_str*/

    /* Space for future expansion */
    0L,0L,0L,0L,
    PyCObject_Type__doc__ 		/* Documentation string */
};
</t>
<t tx="T159">#include "Python.h"
</t>
<t tx="T160">

/* Declarations for objects of type PyCObject */

typedef void (*destructor1)(void *);
typedef void (*destructor2)(void *, void*);

typedef struct {
    PyObject_HEAD
    void *cobject;
    void *desc;
    void (*destructor)(void *);
} PyCObject;
</t>
<t tx="T161">PyObject *
PyCObject_FromVoidPtr(void *cobj, void (*destr)(void *))
{
    PyCObject *self;

    self = PyObject_NEW(PyCObject, &amp;PyCObject_Type);
    if (self == NULL)
        return NULL;
    self-&gt;cobject=cobj;
    self-&gt;destructor=destr;
    self-&gt;desc=NULL;

    return (PyObject *)self;
}
</t>
<t tx="T162">PyObject *
PyCObject_FromVoidPtrAndDesc(void *cobj, void *desc,
                             void (*destr)(void *, void *))
{
    PyCObject *self;

    if (!desc) {
        PyErr_SetString(PyExc_TypeError,
                        "PyCObject_FromVoidPtrAndDesc called with null"
                        " description");
        return NULL;
    }
    self = PyObject_NEW(PyCObject, &amp;PyCObject_Type);
    if (self == NULL)
        return NULL;
    self-&gt;cobject=cobj;
    self-&gt;destructor=(destructor1)destr;
    self-&gt;desc=desc;

    return (PyObject *)self;
}
</t>
<t tx="T163">void *
PyCObject_AsVoidPtr(PyObject *self)
{
    if (self) {
        if (self-&gt;ob_type == &amp;PyCObject_Type)
            return ((PyCObject *)self)-&gt;cobject;
        PyErr_SetString(PyExc_TypeError,
                        "PyCObject_AsVoidPtr with non-C-object");
    }
    if (!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
                        "PyCObject_AsVoidPtr called with null pointer");
    return NULL;
}
</t>
<t tx="T164">void *
PyCObject_GetDesc(PyObject *self)
{
    if (self) {
        if (self-&gt;ob_type == &amp;PyCObject_Type)
            return ((PyCObject *)self)-&gt;desc;
        PyErr_SetString(PyExc_TypeError,
                        "PyCObject_GetDesc with non-C-object");
    }
    if (!PyErr_Occurred())
        PyErr_SetString(PyExc_TypeError,
                        "PyCObject_GetDesc called with null pointer");
    return NULL;
}
</t>
<t tx="T165">void *
PyCObject_Import(char *module_name, char *name)
{
    PyObject *m, *c;
    void *r = NULL;

    if ((m = PyImport_ImportModule(module_name))) {
        if ((c = PyObject_GetAttrString(m,name))) {
            r = PyCObject_AsVoidPtr(c);
            Py_DECREF(c);
	}
        Py_DECREF(m);
    }
    return r;
}
</t>
<t tx="T166">static void
PyCObject_dealloc(PyCObject *self)
{
    if (self-&gt;destructor) {
        if(self-&gt;desc)
            ((destructor2)(self-&gt;destructor))(self-&gt;cobject, self-&gt;desc);
        else
            (self-&gt;destructor)(self-&gt;cobject);
    }
    PyObject_DEL(self);
}
</t>
<t tx="T167">@language c
/* Frame object implementation */

&lt;&lt; frameobject #includes &gt;&gt;
&lt;&lt; frameobject declarations &gt;&gt;
@others
</t>
<t tx="T168">#include "Python.h"

#include "compile.h"
#include "frameobject.h"
#include "opcode.h"
#include "structmember.h"
</t>
<t tx="T169">
#define OFF(x) offsetof(PyFrameObject, x)

static PyMemberDef frame_memberlist[] = {
	{"f_back",	T_OBJECT,	OFF(f_back),	RO},
	{"f_code",	T_OBJECT,	OFF(f_code),	RO},
	{"f_builtins",	T_OBJECT,	OFF(f_builtins),RO},
	{"f_globals",	T_OBJECT,	OFF(f_globals),	RO},
	{"f_lasti",	T_INT,		OFF(f_lasti),	RO},
	{"f_lineno",	T_INT,		OFF(f_lineno),	RO},
	{"f_restricted",T_INT,		OFF(f_restricted),RO},
	{"f_trace",	T_OBJECT,	OFF(f_trace)},
	{"f_exc_type",	T_OBJECT,	OFF(f_exc_type)},
	{"f_exc_value",	T_OBJECT,	OFF(f_exc_value)},
	{"f_exc_traceback", T_OBJECT,	OFF(f_exc_traceback)},
	{NULL}	/* Sentinel */
};
</t>
<t tx="T170">static PyObject *
frame_getlocals(PyFrameObject *f, void *closure)
{
	PyFrame_FastToLocals(f);
	Py_INCREF(f-&gt;f_locals);
	return f-&gt;f_locals;
}
</t>
<t tx="T171">static PyGetSetDef frame_getsetlist[] = {
	{"f_locals",	(getter)frame_getlocals, NULL, NULL},
	{0}
};

/* Stack frames are allocated and deallocated at a considerable rate.
   In an attempt to improve the speed of function calls, we maintain a
   separate free list of stack frames (just like integers are
   allocated in a special way -- see intobject.c).  When a stack frame
   is on the free list, only the following members have a meaning:
	ob_type		== &amp;Frametype
	f_back		next item on free list, or NULL
	f_nlocals	number of locals
	f_stacksize	size of value stack
        ob_size         size of localsplus
   Note that the value and block stacks are preserved -- this can save
   another malloc() call or two (and two free() calls as well!).
   Also note that, unlike for integers, each frame object is a
   malloc'ed object in its own right -- it is only the actual calls to
   malloc() that we are trying to save here, not the administration.
   After all, while a typical program may make millions of calls, a
   call depth of more than 20 or 30 is probably already exceptional
   unless the program contains run-away recursion.  I hope.
*/

static PyFrameObject *free_list = NULL;

static void
frame_dealloc(PyFrameObject *f)
{
	int i, slots;
	PyObject **fastlocals;
	PyObject **p;

 	PyObject_GC_UnTrack(f);
	Py_TRASHCAN_SAFE_BEGIN(f)
	/* Kill all local variables */
	slots = f-&gt;f_nlocals + f-&gt;f_ncells + f-&gt;f_nfreevars;
	fastlocals = f-&gt;f_localsplus;
	for (i = slots; --i &gt;= 0; ++fastlocals) {
		Py_XDECREF(*fastlocals);
	}

	/* Free stack */
	if (f-&gt;f_stacktop != NULL) {
		for (p = f-&gt;f_valuestack; p &lt; f-&gt;f_stacktop; p++)
			Py_XDECREF(*p);
	}
	
	Py_XDECREF(f-&gt;f_back);
	Py_XDECREF(f-&gt;f_code);
	Py_XDECREF(f-&gt;f_builtins);
	Py_XDECREF(f-&gt;f_globals);
	Py_XDECREF(f-&gt;f_locals);
	Py_XDECREF(f-&gt;f_trace);
	Py_XDECREF(f-&gt;f_exc_type);
	Py_XDECREF(f-&gt;f_exc_value);
	Py_XDECREF(f-&gt;f_exc_traceback);
	f-&gt;f_back = free_list;
	free_list = f;
	Py_TRASHCAN_SAFE_END(f)
}
</t>
<t tx="T172">static int
frame_traverse(PyFrameObject *f, visitproc visit, void *arg)
{
	PyObject **fastlocals, **p;
	int i, err, slots;
#define VISIT(o) if (o) {if ((err = visit((PyObject *)(o), arg))) return err;}

	VISIT(f-&gt;f_back);
	VISIT(f-&gt;f_code);
	VISIT(f-&gt;f_builtins);
	VISIT(f-&gt;f_globals);
	VISIT(f-&gt;f_locals);
	VISIT(f-&gt;f_trace);
	VISIT(f-&gt;f_exc_type);
	VISIT(f-&gt;f_exc_value);
	VISIT(f-&gt;f_exc_traceback);

	/* locals */
	slots = f-&gt;f_nlocals + f-&gt;f_ncells + f-&gt;f_nfreevars;
	fastlocals = f-&gt;f_localsplus;
	for (i = slots; --i &gt;= 0; ++fastlocals) {
		VISIT(*fastlocals);
	}

	/* stack */
	if (f-&gt;f_stacktop != NULL) {
		for (p = f-&gt;f_valuestack; p &lt; f-&gt;f_stacktop; p++)
			VISIT(*p);
	}
	return 0;
}
</t>
<t tx="T173">static void
frame_clear(PyFrameObject *f)
{
	PyObject **fastlocals, **p;
	int i, slots;

	Py_XDECREF(f-&gt;f_exc_type);
	f-&gt;f_exc_type = NULL;

	Py_XDECREF(f-&gt;f_exc_value);
	f-&gt;f_exc_value = NULL;

	Py_XDECREF(f-&gt;f_exc_traceback);
	f-&gt;f_exc_traceback = NULL;

	Py_XDECREF(f-&gt;f_trace);
	f-&gt;f_trace = NULL;

	/* locals */
	slots = f-&gt;f_nlocals + f-&gt;f_ncells + f-&gt;f_nfreevars;
	fastlocals = f-&gt;f_localsplus;
	for (i = slots; --i &gt;= 0; ++fastlocals) {
		if (*fastlocals != NULL) {
			Py_XDECREF(*fastlocals);
			*fastlocals = NULL;
		}
	}

	/* stack */
	if (f-&gt;f_stacktop != NULL) {
		for (p = f-&gt;f_valuestack; p &lt; f-&gt;f_stacktop; p++) {
			Py_XDECREF(*p);
			*p = NULL;
		}
	}
}
</t>
<t tx="T174">PyTypeObject PyFrame_Type = {
	PyObject_HEAD_INIT(&amp;PyType_Type)
	0,
	"frame",
	sizeof(PyFrameObject),
	sizeof(PyObject *),
	(destructor)frame_dealloc, 		/* tp_dealloc */
	0,					/* tp_print */
	0, 					/* tp_getattr */
	0,			 		/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,					/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	PyObject_GenericGetAttr,		/* tp_getattro */
	PyObject_GenericSetAttr,		/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */
	0,             				/* tp_doc */
 	(traverseproc)frame_traverse,		/* tp_traverse */
	(inquiry)frame_clear,			/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	frame_memberlist,			/* tp_members */
	frame_getsetlist,			/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
};

PyFrameObject *
PyFrame_New(PyThreadState *tstate, PyCodeObject *code, PyObject *globals, 
	    PyObject *locals)
{
	PyFrameObject *back = tstate-&gt;frame;
	static PyObject *builtin_object;
	PyFrameObject *f;
	PyObject *builtins;
	int extras, ncells, nfrees;

	if (builtin_object == NULL) {
		builtin_object = PyString_InternFromString("__builtins__");
		if (builtin_object == NULL)
			return NULL;
	}
	if ((back != NULL &amp;&amp; !PyFrame_Check(back)) ||
	    code == NULL || !PyCode_Check(code) ||
	    globals == NULL || !PyDict_Check(globals) ||
	    (locals != NULL &amp;&amp; !PyDict_Check(locals))) {
		PyErr_BadInternalCall();
		return NULL;
	}
	ncells = PyTuple_GET_SIZE(code-&gt;co_cellvars);
	nfrees = PyTuple_GET_SIZE(code-&gt;co_freevars);
	extras = code-&gt;co_stacksize + code-&gt;co_nlocals + ncells + nfrees;
	if (back == NULL || back-&gt;f_globals != globals) {
		builtins = PyDict_GetItem(globals, builtin_object);
		if (builtins != NULL &amp;&amp; PyModule_Check(builtins))
			builtins = PyModule_GetDict(builtins);
	}
	else {
		/* If we share the globals, we share the builtins.
		   Save a lookup and a call. */
		builtins = back-&gt;f_builtins;
	}
	if (builtins != NULL &amp;&amp; !PyDict_Check(builtins))
		builtins = NULL;
	if (free_list == NULL) {
		f = PyObject_GC_NewVar(PyFrameObject, &amp;PyFrame_Type, extras);
		if (f == NULL)
			return NULL;
	}
	else {
		f = free_list;
		free_list = free_list-&gt;f_back;
		if (f-&gt;ob_size &lt; extras) {
			f = PyObject_GC_Resize(PyFrameObject, f, extras);
			if (f == NULL)
				return NULL;
		}
		else
			extras = f-&gt;ob_size;
		_Py_NewReference((PyObject *)f);
	}
	if (builtins == NULL) {
		/* No builtins!  Make up a minimal one. */
		builtins = PyDict_New();
		if (builtins == NULL || /* Give them 'None', at least. */
		    PyDict_SetItemString(builtins, "None", Py_None) &lt; 0) {
			Py_DECREF(f);
			return NULL;
		}
	}
	else
		Py_XINCREF(builtins);
	f-&gt;f_builtins = builtins;
	Py_XINCREF(back);
	f-&gt;f_back = back;
	Py_INCREF(code);
	f-&gt;f_code = code;
	Py_INCREF(globals);
	f-&gt;f_globals = globals;
	if (code-&gt;co_flags &amp; CO_NEWLOCALS) {
		if (code-&gt;co_flags &amp; CO_OPTIMIZED)
			locals = NULL; /* Let fast_2_locals handle it */
		else {
			locals = PyDict_New();
			if (locals == NULL) {
				Py_DECREF(f);
				return NULL;
			}
		}
	}
	else {
		if (locals == NULL)
			locals = globals;
		Py_INCREF(locals);
	}
	f-&gt;f_locals = locals;
	f-&gt;f_trace = NULL;
	f-&gt;f_exc_type = f-&gt;f_exc_value = f-&gt;f_exc_traceback = NULL;
	f-&gt;f_tstate = tstate;

	f-&gt;f_lasti = 0;
	f-&gt;f_lineno = code-&gt;co_firstlineno;
	f-&gt;f_restricted = (builtins != tstate-&gt;interp-&gt;builtins);
	f-&gt;f_iblock = 0;
	f-&gt;f_nlocals = code-&gt;co_nlocals;
	f-&gt;f_stacksize = code-&gt;co_stacksize;
	f-&gt;f_ncells = ncells;
	f-&gt;f_nfreevars = nfrees;

	while (--extras &gt;= 0)
		f-&gt;f_localsplus[extras] = NULL;

	f-&gt;f_valuestack = f-&gt;f_localsplus + (f-&gt;f_nlocals + ncells + nfrees);
	f-&gt;f_stacktop = f-&gt;f_valuestack;
	_PyObject_GC_TRACK(f);
	return f;
}
</t>
<t tx="T175">@ Block management
@c

void
PyFrame_BlockSetup(PyFrameObject *f, int type, int handler, int level)
{
	PyTryBlock *b;
	if (f-&gt;f_iblock &gt;= CO_MAXBLOCKS)
		Py_FatalError("XXX block stack overflow");
	b = &amp;f-&gt;f_blockstack[f-&gt;f_iblock++];
	b-&gt;b_type = type;
	b-&gt;b_level = level;
	b-&gt;b_handler = handler;
}
</t>
<t tx="T176">PyTryBlock *
PyFrame_BlockPop(PyFrameObject *f)
{
	PyTryBlock *b;
	if (f-&gt;f_iblock &lt;= 0)
		Py_FatalError("XXX block stack underflow");
	b = &amp;f-&gt;f_blockstack[--f-&gt;f_iblock];
	return b;
}
</t>
<t tx="T177">@ Convert between "fast" version of locals and dictionary version
@c

static void
map_to_dict(PyObject *map, int nmap, PyObject *dict, PyObject **values,
	    int deref)
{
	int j;
	for (j = nmap; --j &gt;= 0; ) {
		PyObject *key = PyTuple_GET_ITEM(map, j);
		PyObject *value = values[j];
		if (deref)
			value = PyCell_GET(value);
		if (value == NULL) {
			if (PyDict_DelItem(dict, key) != 0)
				PyErr_Clear();
		}
		else {
			if (PyDict_SetItem(dict, key, value) != 0)
				PyErr_Clear();
		}
	}
}
</t>
<t tx="T178">static void
dict_to_map(PyObject *map, int nmap, PyObject *dict, PyObject **values,
	    int deref, int clear)
{
	int j;
	for (j = nmap; --j &gt;= 0; ) {
		PyObject *key = PyTuple_GET_ITEM(map, j);
		PyObject *value = PyDict_GetItem(dict, key);
		if (deref) {
			if (value || clear) {
				if (PyCell_GET(values[j]) != value) {
					if (PyCell_Set(values[j], value) &lt; 0)
						PyErr_Clear();
				}
			}
		} else if (value != NULL || clear) {
			if (values[j] != value) {
				Py_XINCREF(value);
				Py_XDECREF(values[j]);
				values[j] = value;
			}
		}
	}
}
</t>
<t tx="T179">void
PyFrame_FastToLocals(PyFrameObject *f)
{
	/* Merge fast locals into f-&gt;f_locals */
	PyObject *locals, *map;
	PyObject **fast;
	PyObject *error_type, *error_value, *error_traceback;
	int j;
	if (f == NULL)
		return;
	locals = f-&gt;f_locals;
	if (locals == NULL) {
		locals = f-&gt;f_locals = PyDict_New();
		if (locals == NULL) {
			PyErr_Clear(); /* Can't report it :-( */
			return;
		}
	}
	if (f-&gt;f_nlocals == 0)
		return;
	map = f-&gt;f_code-&gt;co_varnames;
	if (!PyDict_Check(locals) || !PyTuple_Check(map))
		return;
	PyErr_Fetch(&amp;error_type, &amp;error_value, &amp;error_traceback);
	fast = f-&gt;f_localsplus;
	j = PyTuple_Size(map);
	if (j &gt; f-&gt;f_nlocals)
		j = f-&gt;f_nlocals;
	map_to_dict(map, j, locals, fast, 0);
	if (f-&gt;f_ncells || f-&gt;f_nfreevars) {
		if (!(PyTuple_Check(f-&gt;f_code-&gt;co_cellvars)
		      &amp;&amp; PyTuple_Check(f-&gt;f_code-&gt;co_freevars))) {
			Py_DECREF(locals);
			return;
		}
		map_to_dict(f-&gt;f_code-&gt;co_cellvars, 
			    PyTuple_GET_SIZE(f-&gt;f_code-&gt;co_cellvars),
			    locals, fast + f-&gt;f_nlocals, 1);
		map_to_dict(f-&gt;f_code-&gt;co_freevars, 
			    PyTuple_GET_SIZE(f-&gt;f_code-&gt;co_freevars),
			    locals, fast + f-&gt;f_nlocals + f-&gt;f_ncells, 1);
	}
	PyErr_Restore(error_type, error_value, error_traceback);
}
</t>
<t tx="T180">void
PyFrame_LocalsToFast(PyFrameObject *f, int clear)
{
	/* Merge f-&gt;f_locals into fast locals */
	PyObject *locals, *map;
	PyObject **fast;
	PyObject *error_type, *error_value, *error_traceback;
	int j;
	if (f == NULL)
		return;
	locals = f-&gt;f_locals;
	map = f-&gt;f_code-&gt;co_varnames;
	if (locals == NULL || f-&gt;f_code-&gt;co_nlocals == 0)
		return;
	if (!PyDict_Check(locals) || !PyTuple_Check(map))
		return;
	PyErr_Fetch(&amp;error_type, &amp;error_value, &amp;error_traceback);
	fast = f-&gt;f_localsplus;
	j = PyTuple_Size(map);
	if (j &gt; f-&gt;f_nlocals)
		j = f-&gt;f_nlocals;
	dict_to_map(f-&gt;f_code-&gt;co_varnames, j, locals, fast, 0, clear);
	if (f-&gt;f_ncells || f-&gt;f_nfreevars) {
		if (!(PyTuple_Check(f-&gt;f_code-&gt;co_cellvars)
		      &amp;&amp; PyTuple_Check(f-&gt;f_code-&gt;co_freevars)))
			return;
		dict_to_map(f-&gt;f_code-&gt;co_cellvars, 
			    PyTuple_GET_SIZE(f-&gt;f_code-&gt;co_cellvars),
			    locals, fast + f-&gt;f_nlocals, 1, clear);
		dict_to_map(f-&gt;f_code-&gt;co_freevars, 
			    PyTuple_GET_SIZE(f-&gt;f_code-&gt;co_freevars),
			    locals, fast + f-&gt;f_nlocals + f-&gt;f_ncells, 1, clear);
	}
	PyErr_Restore(error_type, error_value, error_traceback);
}
</t>
<t tx="T181">@ Clear out the free list
@c

void
PyFrame_Fini(void)
{
	while (free_list != NULL) {
		PyFrameObject *f = free_list;
		free_list = free_list-&gt;f_back;
		PyObject_GC_Del(f);
	}
}
</t>
<t tx="T182">@language c
/* Function object implementation */

#include "Python.h"
#include "compile.h"
#include "eval.h"
#include "structmember.h"

@others
</t>
<t tx="T183">PyObject *
PyFunction_New(PyObject *code, PyObject *globals)
{
	PyFunctionObject *op = PyObject_GC_New(PyFunctionObject,
					    &amp;PyFunction_Type);
	if (op != NULL) {
		PyObject *doc;
		PyObject *consts;
		op-&gt;func_weakreflist = NULL;
		Py_INCREF(code);
		op-&gt;func_code = code;
		Py_INCREF(globals);
		op-&gt;func_globals = globals;
		op-&gt;func_name = ((PyCodeObject *)code)-&gt;co_name;
		Py_INCREF(op-&gt;func_name);
		op-&gt;func_defaults = NULL; /* No default arguments */
		op-&gt;func_closure = NULL;
		consts = ((PyCodeObject *)code)-&gt;co_consts;
		if (PyTuple_Size(consts) &gt;= 1) {
			doc = PyTuple_GetItem(consts, 0);
			if (!PyString_Check(doc) &amp;&amp; !PyUnicode_Check(doc))
				doc = Py_None;
		}
		else
			doc = Py_None;
		Py_INCREF(doc);
		op-&gt;func_doc = doc;
		op-&gt;func_dict = NULL;
	}
	else
		return NULL;
	_PyObject_GC_TRACK(op);
	return (PyObject *)op;
}
</t>
<t tx="T184">PyObject *
PyFunction_GetCode(PyObject *op)
{
	if (!PyFunction_Check(op)) {
		PyErr_BadInternalCall();
		return NULL;
	}
	return ((PyFunctionObject *) op) -&gt; func_code;
}
</t>
<t tx="T185">PyObject *
PyFunction_GetGlobals(PyObject *op)
{
	if (!PyFunction_Check(op)) {
		PyErr_BadInternalCall();
		return NULL;
	}
	return ((PyFunctionObject *) op) -&gt; func_globals;
}
</t>
<t tx="T186">PyObject *
PyFunction_GetDefaults(PyObject *op)
{
	if (!PyFunction_Check(op)) {
		PyErr_BadInternalCall();
		return NULL;
	}
	return ((PyFunctionObject *) op) -&gt; func_defaults;
}
</t>
<t tx="T187">int
PyFunction_SetDefaults(PyObject *op, PyObject *defaults)
{
	if (!PyFunction_Check(op)) {
		PyErr_BadInternalCall();
		return -1;
	}
	if (defaults == Py_None)
		defaults = NULL;
	else if (PyTuple_Check(defaults)) {
		Py_XINCREF(defaults);
	}
	else {
		PyErr_SetString(PyExc_SystemError, "non-tuple default args");
		return -1;
	}
	Py_XDECREF(((PyFunctionObject *) op) -&gt; func_defaults);
	((PyFunctionObject *) op) -&gt; func_defaults = defaults;
	return 0;
}
</t>
<t tx="T188">PyObject *
PyFunction_GetClosure(PyObject *op)
{
	if (!PyFunction_Check(op)) {
		PyErr_BadInternalCall();
		return NULL;
	}
	return ((PyFunctionObject *) op) -&gt; func_closure;
}
</t>
<t tx="T189">int
PyFunction_SetClosure(PyObject *op, PyObject *closure)
{
	if (!PyFunction_Check(op)) {
		PyErr_BadInternalCall();
		return -1;
	}
	if (closure == Py_None)
		closure = NULL;
	else if (PyTuple_Check(closure)) {
		Py_XINCREF(closure);
	}
	else {
		PyErr_SetString(PyExc_SystemError, "non-tuple closure");
		return -1;
	}
	Py_XDECREF(((PyFunctionObject *) op) -&gt; func_closure);
	((PyFunctionObject *) op) -&gt; func_closure = closure;
	return 0;
}
</t>
<t tx="T190"></t>
<t tx="T191">@ Methods
@c

#define OFF(x) offsetof(PyFunctionObject, x)

#define RR ()

static PyMemberDef func_memberlist[] = {
        {"func_closure",  T_OBJECT,     OFF(func_closure),
	 RESTRICTED|READONLY},
        {"func_doc",      T_OBJECT,     OFF(func_doc), WRITE_RESTRICTED},
        {"__doc__",       T_OBJECT,     OFF(func_doc), WRITE_RESTRICTED},
        {"func_globals",  T_OBJECT,     OFF(func_globals),
	 RESTRICTED|READONLY},
        {"func_name",     T_OBJECT,     OFF(func_name),         READONLY},
        {"__name__",      T_OBJECT,     OFF(func_name),         READONLY},
        {NULL}  /* Sentinel */
};

static int
restricted(void)
{
	if (!PyEval_GetRestricted())
		return 0;
	PyErr_SetString(PyExc_RuntimeError,
		"function attributes not accessible in restricted mode");
	return 1;
}
</t>
<t tx="T192">static PyObject *
func_get_dict(PyFunctionObject *op)
{
	if (restricted())
		return NULL;
	if (op-&gt;func_dict == NULL) {
		op-&gt;func_dict = PyDict_New();
		if (op-&gt;func_dict == NULL)
			return NULL;
	}
	Py_INCREF(op-&gt;func_dict);
	return op-&gt;func_dict;
}
</t>
<t tx="T193">static int
func_set_dict(PyFunctionObject *op, PyObject *value)
{
	PyObject *tmp;

	if (restricted())
		return -1;
	/* It is illegal to del f.func_dict */
	if (value == NULL) {
		PyErr_SetString(PyExc_TypeError,
				"function's dictionary may not be deleted");
		return -1;
	}
	/* Can only set func_dict to a dictionary */
	if (!PyDict_Check(value)) {
		PyErr_SetString(PyExc_TypeError,
				"setting function's dictionary to a non-dict");
		return -1;
	}
	tmp = op-&gt;func_dict;
	Py_INCREF(value);
	op-&gt;func_dict = value;
	Py_XDECREF(tmp);
	return 0;
}
</t>
<t tx="T194">static PyObject *
func_get_code(PyFunctionObject *op)
{
	if (restricted())
		return NULL;
	Py_INCREF(op-&gt;func_code);
	return op-&gt;func_code;
}
</t>
<t tx="T195">static int
func_set_code(PyFunctionObject *op, PyObject *value)
{
	PyObject *tmp;

	if (restricted())
		return -1;
	/* Not legal to del f.func_code or to set it to anything
	 * other than a code object. */
	if (value == NULL || !PyCode_Check(value)) {
		PyErr_SetString(PyExc_TypeError,
				"func_code must be set to a code object");
		return -1;
	}
	tmp = op-&gt;func_code;
	Py_INCREF(value);
	op-&gt;func_code = value;
	Py_DECREF(tmp);
	return 0;
}
</t>
<t tx="T196">static PyObject *
func_get_defaults(PyFunctionObject *op)
{
	if (restricted())
		return NULL;
	if (op-&gt;func_defaults == NULL) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	Py_INCREF(op-&gt;func_defaults);
	return op-&gt;func_defaults;
}
</t>
<t tx="T197">static int
func_set_defaults(PyFunctionObject *op, PyObject *value)
{
	PyObject *tmp;

	if (restricted())
		return -1;
	/* Legal to del f.func_defaults.
	 * Can only set func_defaults to NULL or a tuple. */
	if (value == Py_None)
		value = NULL;
	if (value != NULL &amp;&amp; !PyTuple_Check(value)) {
		PyErr_SetString(PyExc_TypeError,
				"func_defaults must be set to a tuple object");
		return -1;
	}
	tmp = op-&gt;func_defaults;
	Py_XINCREF(value);
	op-&gt;func_defaults = value;
	Py_XDECREF(tmp);
	return 0;
}
</t>
<t tx="T198">static PyGetSetDef func_getsetlist[] = {
        {"func_code", (getter)func_get_code, (setter)func_set_code},
        {"func_defaults", (getter)func_get_defaults,
	 (setter)func_set_defaults},
	{"func_dict", (getter)func_get_dict, (setter)func_set_dict},
	{"__dict__", (getter)func_get_dict, (setter)func_set_dict},
	{NULL} /* Sentinel */
};

static void
func_dealloc(PyFunctionObject *op)
{
	_PyObject_GC_UNTRACK(op);
	if (op-&gt;func_weakreflist != NULL)
		PyObject_ClearWeakRefs((PyObject *) op);
	Py_DECREF(op-&gt;func_code);
	Py_DECREF(op-&gt;func_globals);
	Py_DECREF(op-&gt;func_name);
	Py_XDECREF(op-&gt;func_defaults);
	Py_XDECREF(op-&gt;func_doc);
	Py_XDECREF(op-&gt;func_dict);
	Py_XDECREF(op-&gt;func_closure);
	PyObject_GC_Del(op);
}
</t>
<t tx="T199">static PyObject*
func_repr(PyFunctionObject *op)
{
	if (op-&gt;func_name == Py_None)
		return PyString_FromFormat("&lt;anonymous function at %p&gt;", op);

	return PyString_FromFormat("&lt;function %s at %p&gt;",
				   PyString_AsString(op-&gt;func_name),
				   op);
}
</t>
<t tx="T200">static int
func_traverse(PyFunctionObject *f, visitproc visit, void *arg)
{
	int err;
	if (f-&gt;func_code) {
		err = visit(f-&gt;func_code, arg);
		if (err)
			return err;
	}
	if (f-&gt;func_globals) {
		err = visit(f-&gt;func_globals, arg);
		if (err)
			return err;
	}
	if (f-&gt;func_defaults) {
		err = visit(f-&gt;func_defaults, arg);
		if (err)
			return err;
	}
	if (f-&gt;func_doc) {
		err = visit(f-&gt;func_doc, arg);
		if (err)
			return err;
	}
	if (f-&gt;func_name) {
		err = visit(f-&gt;func_name, arg);
		if (err)
			return err;
	}
	if (f-&gt;func_dict) {
		err = visit(f-&gt;func_dict, arg);
		if (err)
			return err;
	}
	if (f-&gt;func_closure) {
		err = visit(f-&gt;func_closure, arg);
		if (err)
			return err;
	}
	return 0;
}
</t>
<t tx="T201">static PyObject *
function_call(PyObject *func, PyObject *arg, PyObject *kw)
{
	PyObject *result;
	PyObject *argdefs;
	PyObject **d, **k;
	int nk, nd;

	argdefs = PyFunction_GET_DEFAULTS(func);
	if (argdefs != NULL &amp;&amp; PyTuple_Check(argdefs)) {
		d = &amp;PyTuple_GET_ITEM((PyTupleObject *)argdefs, 0);
		nd = PyTuple_Size(argdefs);
	}
	else {
		d = NULL;
		nd = 0;
	}

	if (kw != NULL &amp;&amp; PyDict_Check(kw)) {
		int pos, i;
		nk = PyDict_Size(kw);
		k = PyMem_NEW(PyObject *, 2*nk);
		if (k == NULL) {
			PyErr_NoMemory();
			return NULL;
		}
		pos = i = 0;
		while (PyDict_Next(kw, &amp;pos, &amp;k[i], &amp;k[i+1]))
			i += 2;
		nk = i/2;
		/* XXX This is broken if the caller deletes dict items! */
	}
	else {
		k = NULL;
		nk = 0;
	}

	result = PyEval_EvalCodeEx(
		(PyCodeObject *)PyFunction_GET_CODE(func),
		PyFunction_GET_GLOBALS(func), (PyObject *)NULL,
		&amp;PyTuple_GET_ITEM(arg, 0), PyTuple_Size(arg),
		k, nk, d, nd,
		PyFunction_GET_CLOSURE(func));

	if (k != NULL)
		PyMem_DEL(k);

	return result;
}
</t>
<t tx="T202">@ Bind a function to an object
@c

static PyObject *
func_descr_get(PyObject *func, PyObject *obj, PyObject *type)
{
	if (obj == Py_None)
		obj = NULL;
	return PyMethod_New(func, obj, type);
}
</t>
<t tx="T203">PyTypeObject PyFunction_Type = {
	PyObject_HEAD_INIT(&amp;PyType_Type)
	0,
	"function",
	sizeof(PyFunctionObject),
	0,
	(destructor)func_dealloc,		/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	(reprfunc)func_repr,			/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,					/* tp_as_mapping */
	0,					/* tp_hash */
	function_call,				/* tp_call */
	0,					/* tp_str */
	PyObject_GenericGetAttr,		/* tp_getattro */
	PyObject_GenericSetAttr,		/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */
	0,					/* tp_doc */
	(traverseproc)func_traverse,		/* tp_traverse */
	0,					/* tp_clear */
	0,					/* tp_richcompare */
	offsetof(PyFunctionObject, func_weakreflist), /* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	func_memberlist,			/* tp_members */
	func_getsetlist,			/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	func_descr_get,				/* tp_descr_get */
	0,					/* tp_descr_set */
	offsetof(PyFunctionObject, func_dict),	/* tp_dictoffset */
};
</t>
<t tx="T204"></t>
<t tx="T205">@ A class method receives the class as implicit first argument, just like an instance method receives the instance.

To declare a class method, use this idiom:

 class C:
	 def f(cls, arg1, arg2, ...): ...
 f = classmethod(f)

It can be called either on the class (e.g. C.f()) or on an instance (e.g. C().f()); the instance is ignored except for its class. If a class method is called for a derived class, the derived class object is passed as the implied first argument.

Class methods are different than C++ or Java static methods. If you want those, see static methods below.
@c

typedef struct {
	PyObject_HEAD
	PyObject *cm_callable;
} classmethod;</t>
<t tx="T206">static void
cm_dealloc(classmethod *cm)
{
	Py_XDECREF(cm-&gt;cm_callable);
	cm-&gt;ob_type-&gt;tp_free((PyObject *)cm);
}
</t>
<t tx="T207">static PyObject *
cm_descr_get(PyObject *self, PyObject *obj, PyObject *type)
{
	classmethod *cm = (classmethod *)self;

	if (cm-&gt;cm_callable == NULL) {
		PyErr_SetString(PyExc_RuntimeError,
				"uninitialized classmethod object");
		return NULL;
	}
 	return PyMethod_New(cm-&gt;cm_callable,
			    type, (PyObject *)(type-&gt;ob_type));
}
</t>
<t tx="T208">static int
cm_init(PyObject *self, PyObject *args, PyObject *kwds)
{
	classmethod *cm = (classmethod *)self;
	PyObject *callable;

	if (!PyArg_ParseTuple(args, "O:callable", &amp;callable))
		return -1;
	Py_INCREF(callable);
	cm-&gt;cm_callable = callable;
	return 0;
}
</t>
<t tx="T209">static char classmethod_doc[] =
"classmethod(function) -&gt; method\n\
\n\
Convert a function to be a class method.\n\
\n\
A class method receives the class as implicit first argument,\n\
just like an instance method receives the instance.\n\
To declare a class method, use this idiom:\n\
\n\
  class C:\n\
      def f(cls, arg1, arg2, ...): ...\n\
      f = classmethod(f)\n\
\n\
It can be called either on the class (e.g. C.f()) or on an instance\n\
(e.g. C().f()).  The instance is ignored except for its class.\n\
If a class method is called for a derived class, the derived class\n\
object is passed as the implied first argument.\n\
\n\
Class methods are different than C++ or Java static methods.\n\
If you want those, see the staticmethod builtin.";

PyTypeObject PyClassMethod_Type = {
	PyObject_HEAD_INIT(&amp;PyType_Type)
	0,
	"classmethod",
	sizeof(classmethod),
	0,
	(destructor)cm_dealloc,			/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,					/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	PyObject_GenericGetAttr,		/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
	classmethod_doc,			/* tp_doc */
	0,					/* tp_traverse */
	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	0,					/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	cm_descr_get,				/* tp_descr_get */
	0,					/* tp_descr_set */
	0,					/* tp_dictoffset */
	cm_init,				/* tp_init */
	PyType_GenericAlloc,			/* tp_alloc */
	PyType_GenericNew,			/* tp_new */
	_PyObject_Del,				/* tp_free */
};

PyObject *
PyClassMethod_New(PyObject *callable)
{
	classmethod *cm = (classmethod *)
		PyType_GenericAlloc(&amp;PyClassMethod_Type, 0);
	if (cm != NULL) {
		Py_INCREF(callable);
		cm-&gt;cm_callable = callable;
	}
	return (PyObject *)cm;
}
</t>
<t tx="T210"></t>
<t tx="T211">@ Static method object

A static method does not receive an implicit first argument.  To declare a static method, use this idiom:

class C:
	def f(arg1, arg2, ...): ...
f = staticmethod(f)

It can be called either on the class (e.g. C.f()) or on an instance  (e.g. C().f()); the instance is ignored except for its class.   Static methods in Python are similar to those found in Java or C++.  For a more advanced concept, see class methods above.
@c

typedef struct {
	PyObject_HEAD
	PyObject *sm_callable;
} staticmethod;</t>
<t tx="T212">static void
sm_dealloc(staticmethod *sm)
{
	Py_XDECREF(sm-&gt;sm_callable);
	sm-&gt;ob_type-&gt;tp_free((PyObject *)sm);
}
</t>
<t tx="T213">static PyObject *
sm_descr_get(PyObject *self, PyObject *obj, PyObject *type)
{
	staticmethod *sm = (staticmethod *)self;

	if (sm-&gt;sm_callable == NULL) {
		PyErr_SetString(PyExc_RuntimeError,
				"uninitialized staticmethod object");
		return NULL;
	}
	Py_INCREF(sm-&gt;sm_callable);
	return sm-&gt;sm_callable;
}
</t>
<t tx="T214">static int
sm_init(PyObject *self, PyObject *args, PyObject *kwds)
{
	staticmethod *sm = (staticmethod *)self;
	PyObject *callable;

	if (!PyArg_ParseTuple(args, "O:callable", &amp;callable))
		return -1;
	Py_INCREF(callable);
	sm-&gt;sm_callable = callable;
	return 0;
}
</t>
<t tx="T215">static char staticmethod_doc[] =
"staticmethod(function) -&gt; method\n\
\n\
Convert a function to be a static method.\n\
\n\
A static method does not receive an implicit first argument.\n\
To declare a static method, use this idiom:\n\
\n\
     class C:\n\
         def f(arg1, arg2, ...): ...\n\
	 f = staticmethod(f)\n\
\n\
It can be called either on the class (e.g. C.f()) or on an instance\n\
(e.g. C().f()).  The instance is ignored except for its class.\n\
\n\
Static methods in Python are similar to those found in Java or C++.\n\
For a more advanced concept, see the classmethod builtin.";

PyTypeObject PyStaticMethod_Type = {
	PyObject_HEAD_INIT(&amp;PyType_Type)
	0,
	"staticmethod",
	sizeof(staticmethod),
	0,
	(destructor)sm_dealloc,			/* tp_dealloc */
	0,					/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,					/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	PyObject_GenericGetAttr,		/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
	staticmethod_doc,			/* tp_doc */
	0,					/* tp_traverse */
	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	0,					/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	sm_descr_get,				/* tp_descr_get */
	0,					/* tp_descr_set */
	0,					/* tp_dictoffset */
	sm_init,				/* tp_init */
	PyType_GenericAlloc,			/* tp_alloc */
	PyType_GenericNew,			/* tp_new */
	_PyObject_Del,				/* tp_free */
};

PyObject *
PyStaticMethod_New(PyObject *callable)
{
	staticmethod *sm = (staticmethod *)
		PyType_GenericAlloc(&amp;PyStaticMethod_Type, 0);
	if (sm != NULL) {
		Py_INCREF(callable);
		sm-&gt;sm_callable = callable;
	}
	return (PyObject *)sm;
}
</t>
<t tx="T216">@language c
/* List object implementation */

&lt;&lt; listobject #includes &gt;&gt;
@others

static PySequenceMethods immutable_list_as_sequence = {
	(inquiry)list_length,			/* sq_length */
	(binaryfunc)list_concat,		/* sq_concat */
	(intargfunc)list_repeat,		/* sq_repeat */
	(intargfunc)list_item,			/* sq_item */
	(intintargfunc)list_slice,		/* sq_slice */
	(intobjargproc)immutable_list_ass,	/* sq_ass_item */
	(intintobjargproc)immutable_list_ass,	/* sq_ass_slice */
	(objobjproc)list_contains,		/* sq_contains */
};

static PyTypeObject immutable_list_type = {
	PyObject_HEAD_INIT(&amp;PyType_Type)
	0,
	"list (immutable, during sort)",
	sizeof(PyListObject),
	0,
	0, /* Cannot happen */			/* tp_dealloc */
	(printfunc)list_print,			/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0, /* Won't be called */		/* tp_compare */
	(reprfunc)list_repr,			/* tp_repr */
	0,					/* tp_as_number */
	&amp;immutable_list_as_sequence,		/* tp_as_sequence */
	0,					/* tp_as_mapping */
	list_nohash,				/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	PyObject_GenericGetAttr,		/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */
 	list_doc,				/* tp_doc */
 	(traverseproc)list_traverse,		/* tp_traverse */
	0,					/* tp_clear */
	list_richcompare,			/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	immutable_list_methods,			/* tp_methods */
	0,					/* tp_members */
	0,					/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,					/* tp_descr_get */
	0,					/* tp_descr_set */
	0,					/* tp_init */
	/* NOTE: This is *not* the standard list_type struct! */
};
</t>
<t tx="T217">#include "Python.h"
</t>
<t tx="T218">#ifdef STDC_HEADERS
#include &lt;stddef.h&gt;
#else
#include &lt;sys/types.h&gt;		/* For size_t */
#endif

static int
roundupsize(int n)
{
	unsigned int nbits = 0;
	unsigned int n2 = (unsigned int)n &gt;&gt; 5;

	/* Round up: 
	 * If n &lt;       256, to a multiple of        8.
	 * If n &lt;      2048, to a multiple of       64.
	 * If n &lt;     16384, to a multiple of      512.
	 * If n &lt;    131072, to a multiple of     4096.
	 * If n &lt;   1048576, to a multiple of    32768.
	 * If n &lt;   8388608, to a multiple of   262144.
	 * If n &lt;  67108864, to a multiple of  2097152.
	 * If n &lt; 536870912, to a multiple of 16777216.
	 * ...
	 * If n &lt; 2**(5+3*i), to a multiple of 2**(3*i).
	 *
	 * This over-allocates proportional to the list size, making room
	 * for additional growth.  The over-allocation is mild, but is
	 * enough to give linear-time amortized behavior over a long
	 * sequence of appends() in the presence of a poorly-performing
	 * system realloc() (which is a reality, e.g., across all flavors
	 * of Windows, with Win9x behavior being particularly bad -- and
	 * we've still got address space fragmentation problems on Win9x
	 * even with this scheme, although it requires much longer lists to
	 * provoke them than it used to).
	 */
	do {
		n2 &gt;&gt;= 3;
		nbits += 3;
	} while (n2);
	return ((n &gt;&gt; nbits) + 1) &lt;&lt; nbits;
 }
</t>
<t tx="T219">#define NRESIZE(var, type, nitems) PyMem_RESIZE(var, type, roundupsize(nitems))

PyObject *
PyList_New(int size)
{
	int i;
	PyListObject *op;
	size_t nbytes;
	if (size &lt; 0) {
		PyErr_BadInternalCall();
		return NULL;
	}
	nbytes = size * sizeof(PyObject *);
	/* Check for overflow */
	if (nbytes / sizeof(PyObject *) != (size_t)size) {
		return PyErr_NoMemory();
	}
	op = PyObject_GC_New(PyListObject, &amp;PyList_Type);
	if (op == NULL) {
		return NULL;
	}
	if (size &lt;= 0) {
		op-&gt;ob_item = NULL;
	}
	else {
		op-&gt;ob_item = (PyObject **) PyMem_MALLOC(nbytes);
		if (op-&gt;ob_item == NULL) {
			return PyErr_NoMemory();
		}
	}
	op-&gt;ob_size = size;
	for (i = 0; i &lt; size; i++)
		op-&gt;ob_item[i] = NULL;
	_PyObject_GC_TRACK(op);
	return (PyObject *) op;
}
</t>
<t tx="T220">int
PyList_Size(PyObject *op)
{
	if (!PyList_Check(op)) {
		PyErr_BadInternalCall();
		return -1;
	}
	else
		return ((PyListObject *)op) -&gt; ob_size;
}
</t>
<t tx="T221">static PyObject *indexerr;

PyObject *
PyList_GetItem(PyObject *op, int i)
{
	if (!PyList_Check(op)) {
		PyErr_BadInternalCall();
		return NULL;
	}
	if (i &lt; 0 || i &gt;= ((PyListObject *)op) -&gt; ob_size) {
		if (indexerr == NULL)
			indexerr = PyString_FromString(
				"list index out of range");
		PyErr_SetObject(PyExc_IndexError, indexerr);
		return NULL;
	}
	return ((PyListObject *)op) -&gt; ob_item[i];
}
</t>
<t tx="T222">int
PyList_SetItem(register PyObject *op, register int i,
               register PyObject *newitem)
{
	register PyObject *olditem;
	register PyObject **p;
	if (!PyList_Check(op)) {
		Py_XDECREF(newitem);
		PyErr_BadInternalCall();
		return -1;
	}
	if (i &lt; 0 || i &gt;= ((PyListObject *)op) -&gt; ob_size) {
		Py_XDECREF(newitem);
		PyErr_SetString(PyExc_IndexError,
				"list assignment index out of range");
		return -1;
	}
	p = ((PyListObject *)op) -&gt; ob_item + i;
	olditem = *p;
	*p = newitem;
	Py_XDECREF(olditem);
	return 0;
}
</t>
<t tx="T223">static int
ins1(PyListObject *self, int where, PyObject *v)
{
	int i;
	PyObject **items;
	if (v == NULL) {
		PyErr_BadInternalCall();
		return -1;
	}
	if (self-&gt;ob_size == INT_MAX) {
		PyErr_SetString(PyExc_OverflowError,
			"cannot add more objects to list");
		return -1;
	}
	items = self-&gt;ob_item;
	NRESIZE(items, PyObject *, self-&gt;ob_size+1);
	if (items == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (where &lt; 0)
		where = 0;
	if (where &gt; self-&gt;ob_size)
		where = self-&gt;ob_size;
	for (i = self-&gt;ob_size; --i &gt;= where; )
		items[i+1] = items[i];
	Py_INCREF(v);
	items[where] = v;
	self-&gt;ob_item = items;
	self-&gt;ob_size++;
	return 0;
}
</t>
<t tx="T224">int
PyList_Insert(PyObject *op, int where, PyObject *newitem)
{
	if (!PyList_Check(op)) {
		PyErr_BadInternalCall();
		return -1;
	}
	return ins1((PyListObject *)op, where, newitem);
}
</t>
<t tx="T225">int
PyList_Append(PyObject *op, PyObject *newitem)
{
	if (!PyList_Check(op)) {
		PyErr_BadInternalCall();
		return -1;
	}
	return ins1((PyListObject *)op,
		(int) ((PyListObject *)op)-&gt;ob_size, newitem);
}
</t>
<t tx="T226">@ Methods
@c

static void
list_dealloc(PyListObject *op)
{
	int i;
	Py_TRASHCAN_SAFE_BEGIN(op)
	_PyObject_GC_UNTRACK(op);
	if (op-&gt;ob_item != NULL) {
		/* Do it backwards, for Christian Tismer.
		   There's a simple test case where somehow this reduces
		   thrashing when a *very* large list is created and
		   immediately deleted. */
		i = op-&gt;ob_size;
		while (--i &gt;= 0) {
			Py_XDECREF(op-&gt;ob_item[i]);
		}
		PyMem_FREE(op-&gt;ob_item);
	}
	op-&gt;ob_type-&gt;tp_free((PyObject *)op);
	Py_TRASHCAN_SAFE_END(op)
}
</t>
<t tx="T227">static int
list_print(PyListObject *op, FILE *fp, int flags)
{
	int i;

	i = Py_ReprEnter((PyObject*)op);
	if (i != 0) {
		if (i &lt; 0)
			return i;
		fprintf(fp, "[...]");
		return 0;
	}
	fprintf(fp, "[");
	for (i = 0; i &lt; op-&gt;ob_size; i++) {
		if (i &gt; 0)
			fprintf(fp, ", ");
		if (PyObject_Print(op-&gt;ob_item[i], fp, 0) != 0) {
			Py_ReprLeave((PyObject *)op);
			return -1;
		}
	}
	fprintf(fp, "]");
	Py_ReprLeave((PyObject *)op);
	return 0;
}
</t>
<t tx="T228">static PyObject *
list_repr(PyListObject *v)
{
	int i;
	PyObject *s, *temp;
	PyObject *pieces = NULL, *result = NULL;

	i = Py_ReprEnter((PyObject*)v);
	if (i != 0) {
		return i &gt; 0 ? PyString_FromString("[...]") : NULL;
	}

	if (v-&gt;ob_size == 0) {
		result = PyString_FromString("[]");
		goto Done;
	}

	pieces = PyList_New(0);
	if (pieces == NULL)
		goto Done;

	/* Do repr() on each element.  Note that this may mutate the list,
	   so must refetch the list size on each iteration. */
	for (i = 0; i &lt; v-&gt;ob_size; ++i) {
		int status;
		s = PyObject_Repr(v-&gt;ob_item[i]);
		if (s == NULL)
			goto Done;
		status = PyList_Append(pieces, s);
		Py_DECREF(s);  /* append created a new ref */
		if (status &lt; 0)
			goto Done;
	}

	/* Add "[]" decorations to the first and last items. */
	assert(PyList_GET_SIZE(pieces) &gt; 0);
	s = PyString_FromString("[");
	if (s == NULL)
		goto Done;
	temp = PyList_GET_ITEM(pieces, 0);
	PyString_ConcatAndDel(&amp;s, temp);
	PyList_SET_ITEM(pieces, 0, s);
	if (s == NULL)
		goto Done;

	s = PyString_FromString("]");
	if (s == NULL)
		goto Done;
	temp = PyList_GET_ITEM(pieces, PyList_GET_SIZE(pieces) - 1);
	PyString_ConcatAndDel(&amp;temp, s);
	PyList_SET_ITEM(pieces, PyList_GET_SIZE(pieces) - 1, temp);
	if (temp == NULL)
		goto Done;

	/* Paste them all together with ", " between. */
	s = PyString_FromString(", ");
	if (s == NULL)
		goto Done;
	result = _PyString_Join(s, pieces);
	Py_DECREF(s);	

Done:
	Py_XDECREF(pieces);
	Py_ReprLeave((PyObject *)v);
	return result;
}
</t>
<t tx="T229">static int
list_length(PyListObject *a)
{
	return a-&gt;ob_size;
}
</t>
<t tx="T230">static int
list_contains(PyListObject *a, PyObject *el)
{
	int i;

	for (i = 0; i &lt; a-&gt;ob_size; ++i) {
		int cmp = PyObject_RichCompareBool(el, PyList_GET_ITEM(a, i),
						   Py_EQ);
		if (cmp &gt; 0)
			return 1;
		else if (cmp &lt; 0)
			return -1;
	}
	return 0;
}
</t>
<t tx="T231">static PyObject *
list_item(PyListObject *a, int i)
{
	if (i &lt; 0 || i &gt;= a-&gt;ob_size) {
		if (indexerr == NULL)
			indexerr = PyString_FromString(
				"list index out of range");
		PyErr_SetObject(PyExc_IndexError, indexerr);
		return NULL;
	}
	Py_INCREF(a-&gt;ob_item[i]);
	return a-&gt;ob_item[i];
}
</t>
<t tx="T232">static PyObject *
list_slice(PyListObject *a, int ilow, int ihigh)
{
	PyListObject *np;
	int i;
	if (ilow &lt; 0)
		ilow = 0;
	else if (ilow &gt; a-&gt;ob_size)
		ilow = a-&gt;ob_size;
	if (ihigh &lt; ilow)
		ihigh = ilow;
	else if (ihigh &gt; a-&gt;ob_size)
		ihigh = a-&gt;ob_size;
	np = (PyListObject *) PyList_New(ihigh - ilow);
	if (np == NULL)
		return NULL;
	for (i = ilow; i &lt; ihigh; i++) {
		PyObject *v = a-&gt;ob_item[i];
		Py_INCREF(v);
		np-&gt;ob_item[i - ilow] = v;
	}
	return (PyObject *)np;
}
</t>
<t tx="T233">PyObject *
PyList_GetSlice(PyObject *a, int ilow, int ihigh)
{
	if (!PyList_Check(a)) {
		PyErr_BadInternalCall();
		return NULL;
	}
	return list_slice((PyListObject *)a, ilow, ihigh);
}
</t>
<t tx="T234">static PyObject *
list_concat(PyListObject *a, PyObject *bb)
{
	int size;
	int i;
	PyListObject *np;
	if (!PyList_Check(bb)) {
		PyErr_Format(PyExc_TypeError,
			  "can only concatenate list (not \"%.200s\") to list",
			  bb-&gt;ob_type-&gt;tp_name);
		return NULL;
	}
#define b ((PyListObject *)bb)
	size = a-&gt;ob_size + b-&gt;ob_size;
	np = (PyListObject *) PyList_New(size);
	if (np == NULL) {
		return NULL;
	}
	for (i = 0; i &lt; a-&gt;ob_size; i++) {
		PyObject *v = a-&gt;ob_item[i];
		Py_INCREF(v);
		np-&gt;ob_item[i] = v;
	}
	for (i = 0; i &lt; b-&gt;ob_size; i++) {
		PyObject *v = b-&gt;ob_item[i];
		Py_INCREF(v);
		np-&gt;ob_item[i + a-&gt;ob_size] = v;
	}
	return (PyObject *)np;
#undef b
}
</t>
<t tx="T235">static PyObject *
list_repeat(PyListObject *a, int n)
{
	int i, j;
	int size;
	PyListObject *np;
	PyObject **p;
	if (n &lt; 0)
		n = 0;
	size = a-&gt;ob_size * n;
	np = (PyListObject *) PyList_New(size);
	if (np == NULL)
		return NULL;
	p = np-&gt;ob_item;
	for (i = 0; i &lt; n; i++) {
		for (j = 0; j &lt; a-&gt;ob_size; j++) {
			*p = a-&gt;ob_item[j];
			Py_INCREF(*p);
			p++;
		}
	}
	return (PyObject *) np;
}
</t>
<t tx="T236">static int
list_ass_slice(PyListObject *a, int ilow, int ihigh, PyObject *v)
{
	/* Because [X]DECREF can recursively invoke list operations on
	   this list, we must postpone all [X]DECREF activity until
	   after the list is back in its canonical shape.  Therefore
	   we must allocate an additional array, 'recycle', into which
	   we temporarily copy the items that are deleted from the
	   list. :-( */
	PyObject **recycle, **p;
	PyObject **item;
	int n; /* Size of replacement list */
	int d; /* Change in size */
	int k; /* Loop index */
#define b ((PyListObject *)v)
	if (v == NULL)
		n = 0;
	else if (PyList_Check(v)) {
		n = b-&gt;ob_size;
		if (a == b) {
			/* Special case "a[i:j] = a" -- copy b first */
			int ret;
			v = list_slice(b, 0, n);
			ret = list_ass_slice(a, ilow, ihigh, v);
			Py_DECREF(v);
			return ret;
		}
	}
	else {
		PyErr_Format(PyExc_TypeError,
			     "must assign list (not \"%.200s\") to slice",
			     v-&gt;ob_type-&gt;tp_name);
		return -1;
	}
	if (ilow &lt; 0)
		ilow = 0;
	else if (ilow &gt; a-&gt;ob_size)
		ilow = a-&gt;ob_size;
	if (ihigh &lt; ilow)
		ihigh = ilow;
	else if (ihigh &gt; a-&gt;ob_size)
		ihigh = a-&gt;ob_size;
	item = a-&gt;ob_item;
	d = n - (ihigh-ilow);
	if (ihigh &gt; ilow)
		p = recycle = PyMem_NEW(PyObject *, (ihigh-ilow));
	else
		p = recycle = NULL;
	if (d &lt;= 0) { /* Delete -d items; recycle ihigh-ilow items */
		for (k = ilow; k &lt; ihigh; k++)
			*p++ = item[k];
		if (d &lt; 0) {
			for (/*k = ihigh*/; k &lt; a-&gt;ob_size; k++)
				item[k+d] = item[k];
			a-&gt;ob_size += d;
			NRESIZE(item, PyObject *, a-&gt;ob_size); /* Can't fail */
			a-&gt;ob_item = item;
		}
	}
	else { /* Insert d items; recycle ihigh-ilow items */
		NRESIZE(item, PyObject *, a-&gt;ob_size + d);
		if (item == NULL) {
			if (recycle != NULL)
				PyMem_DEL(recycle);
			PyErr_NoMemory();
			return -1;
		}
		for (k = a-&gt;ob_size; --k &gt;= ihigh; )
			item[k+d] = item[k];
		for (/*k = ihigh-1*/; k &gt;= ilow; --k)
			*p++ = item[k];
		a-&gt;ob_item = item;
		a-&gt;ob_size += d;
	}
	for (k = 0; k &lt; n; k++, ilow++) {
		PyObject *w = b-&gt;ob_item[k];
		Py_XINCREF(w);
		item[ilow] = w;
	}
	if (recycle) {
		while (--p &gt;= recycle)
			Py_XDECREF(*p);
		PyMem_DEL(recycle);
	}
	if (a-&gt;ob_size == 0 &amp;&amp; a-&gt;ob_item != NULL) {
		PyMem_FREE(a-&gt;ob_item);
		a-&gt;ob_item = NULL;
	}
	return 0;
#undef b
}
</t>
<t tx="T237">int
PyList_SetSlice(PyObject *a, int ilow, int ihigh, PyObject *v)
{
	if (!PyList_Check(a)) {
		PyErr_BadInternalCall();
		return -1;
	}
	return list_ass_slice((PyListObject *)a, ilow, ihigh, v);
}
</t>
<t tx="T238">static PyObject *
list_inplace_repeat(PyListObject *self, int n)
{
	PyObject **items;
	int size, i, j;


	size = PyList_GET_SIZE(self);
	if (size == 0) {
		Py_INCREF(self);
		return (PyObject *)self;
	}

	items = self-&gt;ob_item;

	if (n &lt; 1) {
		self-&gt;ob_item = NULL;
		self-&gt;ob_size = 0;
		for (i = 0; i &lt; size; i++)
			Py_XDECREF(items[i]);
		PyMem_DEL(items);
		Py_INCREF(self);
		return (PyObject *)self;
	}

	NRESIZE(items, PyObject*, size*n);
	if (items == NULL) {
		PyErr_NoMemory();
		goto finally;
	}
	self-&gt;ob_item = items;
	for (i = 1; i &lt; n; i++) { /* Start counting at 1, not 0 */
		for (j = 0; j &lt; size; j++) {
			PyObject *o = PyList_GET_ITEM(self, j);
			Py_INCREF(o);
			PyList_SET_ITEM(self, self-&gt;ob_size++, o);
		}
	}
	Py_INCREF(self);
	return (PyObject *)self;
  finally:
  	return NULL;
}
</t>
<t tx="T239">static int
list_ass_item(PyListObject *a, int i, PyObject *v)
{
	PyObject *old_value;
	if (i &lt; 0 || i &gt;= a-&gt;ob_size) {
		PyErr_SetString(PyExc_IndexError,
				"list assignment index out of range");
		return -1;
	}
	if (v == NULL)
		return list_ass_slice(a, i, i+1, v);
	Py_INCREF(v);
	old_value = a-&gt;ob_item[i];
	a-&gt;ob_item[i] = v;
	Py_DECREF(old_value); 
	return 0;
}
</t>
<t tx="T240">static PyObject *
ins(PyListObject *self, int where, PyObject *v)
{
	if (ins1(self, where, v) != 0)
		return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T241">static PyObject *
listinsert(PyListObject *self, PyObject *args)
{
	int i;
	PyObject *v;
	if (!PyArg_ParseTuple(args, "iO:insert", &amp;i, &amp;v))
		return NULL;
	return ins(self, i, v);
}
</t>
<t tx="T242">static PyObject *
listappend(PyListObject *self, PyObject *v)
{
	return ins(self, (int) self-&gt;ob_size, v);
}
</t>
<t tx="T243">static int
listextend_internal(PyListObject *self, PyObject *b)
{
	PyObject **items;
	int selflen = PyList_GET_SIZE(self);
	int blen;
	register int i;

	if (PyObject_Size(b) == 0) {
		/* short circuit when b is empty */
		Py_DECREF(b);
		return 0;
	}

	if (self == (PyListObject*)b) {
		/* as in list_ass_slice() we must special case the
		 * situation: a.extend(a)
		 *
		 * XXX: I think this way ought to be faster than using
		 * list_slice() the way list_ass_slice() does.
		 */
		Py_DECREF(b);
		b = PyList_New(selflen);
		if (!b)
			return -1;
		for (i = 0; i &lt; selflen; i++) {
			PyObject *o = PyList_GET_ITEM(self, i);
			Py_INCREF(o);
			PyList_SET_ITEM(b, i, o);
		}
	}

	blen = PyObject_Size(b);

	/* resize a using idiom */
	items = self-&gt;ob_item;
	NRESIZE(items, PyObject*, selflen + blen);
	if (items == NULL) {
		PyErr_NoMemory();
		Py_DECREF(b);
		return -1;
	}

	self-&gt;ob_item = items;

	/* populate the end of self with b's items */
	for (i = 0; i &lt; blen; i++) {
		PyObject *o = PySequence_Fast_GET_ITEM(b, i);
		Py_INCREF(o);
		PyList_SET_ITEM(self, self-&gt;ob_size++, o);
	}
	Py_DECREF(b);
	return 0;
}
</t>
<t tx="T244">static PyObject *
list_inplace_concat(PyListObject *self, PyObject *other)
{
	other = PySequence_Fast(other, "argument to += must be iterable");
	if (!other)
		return NULL;

	if (listextend_internal(self, other) &lt; 0)
		return NULL;

	Py_INCREF(self);
	return (PyObject *)self;
}
</t>
<t tx="T245">static PyObject *
listextend(PyListObject *self, PyObject *b)
{

	b = PySequence_Fast(b, "list.extend() argument must be iterable");
	if (!b)
		return NULL;

	if (listextend_internal(self, b) &lt; 0)
		return NULL;

	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T246">static PyObject *
listpop(PyListObject *self, PyObject *args)
{
	int i = -1;
	PyObject *v;
	if (!PyArg_ParseTuple(args, "|i:pop", &amp;i))
		return NULL;
	if (self-&gt;ob_size == 0) {
		/* Special-case most common failure cause */
		PyErr_SetString(PyExc_IndexError, "pop from empty list");
		return NULL;
	}
	if (i &lt; 0)
		i += self-&gt;ob_size;
	if (i &lt; 0 || i &gt;= self-&gt;ob_size) {
		PyErr_SetString(PyExc_IndexError, "pop index out of range");
		return NULL;
	}
	v = self-&gt;ob_item[i];
	Py_INCREF(v);
	if (list_ass_slice(self, i, i+1, (PyObject *)NULL) != 0) {
		Py_DECREF(v);
		return NULL;
	}
	return v;
}
</t>
<t tx="T247">@ New quicksort implementation for arrays of object pointers.  Thanks to discussions with Tim Peters.
CMPERROR is returned by our comparison function when an error  occurred. This is the largest negative integer (0x80000000 on a  32-bit system).
@c

#define CMPERROR ( (int) ((unsigned int)1 &lt;&lt; (8*sizeof(int) - 1)) )

/* Comparison function.  Takes care of calling a user-supplied
   comparison function (any callable Python object).  Calls the
   standard comparison function, PyObject_Compare(), if the user-
   supplied function is NULL. */

static int
docompare(PyObject *x, PyObject *y, PyObject *compare)
{
	PyObject *args, *res;
	int i;

	if (compare == NULL) {
		/* NOTE: we rely on the fact here that the sorting algorithm
		   only ever checks whether k&lt;0, i.e., whether x&lt;y.  So we
		   invoke the rich comparison function with Py_LT ('&lt;'), and
		   return -1 when it returns true and 0 when it returns
		   false. */
		i = PyObject_RichCompareBool(x, y, Py_LT);
		if (i &lt; 0)
			return CMPERROR;
		else
			return -i;
	}

	args = Py_BuildValue("(OO)", x, y);
	if (args == NULL)
		return CMPERROR;
	res = PyEval_CallObject(compare, args);
	Py_DECREF(args);
	if (res == NULL)
		return CMPERROR;
	if (!PyInt_Check(res)) {
		Py_DECREF(res);
		PyErr_SetString(PyExc_TypeError,
				"comparison function must return int");
		return CMPERROR;
	}
	i = PyInt_AsLong(res);
	Py_DECREF(res);
	if (i &lt; 0)
		return -1;
	if (i &gt; 0)
		return 1;
	return 0;
}
</t>
<t tx="T248">@ MINSIZE is the smallest array that will get a full-blown samplesort  treatment; smaller arrays are sorted using binary insertion. It must  be at least 7 for the samplesort implementation to work. Binary  insertion does fewer compares, but can suffer O(N**2) data movement.  The more expensive compares, the larger MINSIZE should be.
@c

#define MINSIZE 100

/* MINPARTITIONSIZE is the smallest array slice samplesort will bother to
   partition; smaller slices are passed to binarysort.  It must be at
   least 2, and no larger than MINSIZE.  Setting it higher reduces the #
   of compares slowly, but increases the amount of data movement quickly.
   The value here was chosen assuming a compare costs ~25x more than
   swapping a pair of memory-resident pointers -- but under that assumption,
   changing the value by a few dozen more or less has aggregate effect
   under 1%.  So the value is crucial, but not touchy &lt;wink&gt;. */
#define MINPARTITIONSIZE 40

/* MAXMERGE is the largest number of elements we'll always merge into
   a known-to-be sorted chunk via binary insertion, regardless of the
   size of that chunk.  Given a chunk of N sorted elements, and a group
   of K unknowns, the largest K for which it's better to do insertion
   (than a full-blown sort) is a complicated function of N and K mostly
   involving the expected number of compares and data moves under each
   approach, and the relative cost of those operations on a specific
   architecure.  The fixed value here is conservative, and should be a
   clear win regardless of architecture or N. */
#define MAXMERGE 15

/* STACKSIZE is the size of our work stack.  A rough estimate is that
   this allows us to sort arrays of size N where
   N / ln(N) = MINPARTITIONSIZE * 2**STACKSIZE, so 60 is more than enough
   for arrays of size 2**64.  Because we push the biggest partition
   first, the worst case occurs when all subarrays are always partitioned
   exactly in two. */
#define STACKSIZE 60


#define SETK(X,Y) if ((k = docompare(X,Y,compare))==CMPERROR) goto fail

/* binarysort is the best method for sorting small arrays: it does
   few compares, but can do data movement quadratic in the number of
   elements.
   [lo, hi) is a contiguous slice of a list, and is sorted via
   binary insertion.
   On entry, must have lo &lt;= start &lt;= hi, and that [lo, start) is already
   sorted (pass start == lo if you don't know!).
   If docompare complains (returns CMPERROR) return -1, else 0.
   Even in case of error, the output slice will be some permutation of
   the input (nothing is lost or duplicated).
*/

static int
binarysort(PyObject **lo, PyObject **hi, PyObject **start, PyObject *compare)
     /* compare -- comparison function object, or NULL for default */
{
	/* assert lo &lt;= start &lt;= hi
	   assert [lo, start) is sorted */
	register int k;
	register PyObject **l, **p, **r;
	register PyObject *pivot;

	if (lo == start)
		++start;
	for (; start &lt; hi; ++start) {
		/* set l to where *start belongs */
		l = lo;
		r = start;
		pivot = *r;
		do {
			p = l + ((r - l) &gt;&gt; 1);
			SETK(pivot, *p);
			if (k &lt; 0)
				r = p;
			else
				l = p + 1;
		} while (l &lt; r);
		/* Pivot should go at l -- slide over to make room.
		   Caution: using memmove is much slower under MSVC 5;
		   we're not usually moving many slots. */
		for (p = start; p &gt; l; --p)
			*p = *(p-1);
		*l = pivot;
	}
	return 0;

 fail:
	return -1;
}
</t>
<t tx="T249">@ samplesortslice is the sorting workhorse.  [lo, hi) is a contiguous slice of a list, to be sorted in place.  On entry, must have lo &lt;= hi,  If docompare complains (returns CMPERROR) return -1, else 0.  Even in case of error, the output slice will be some permutation of  the input (nothing is lost or duplicated).   samplesort is basically quicksort on steroids: a power of 2 close  to n/ln(n) is computed, and that many elements (less 1) are picked at  random from the array and sorted. These 2**k - 1 elements are then  used as preselected pivots for an equal number of quicksort  partitioning steps, partitioning the slice into 2**k chunks each of  size about ln(n). These small final chunks are then usually handled  by binarysort. Note that when k=1, this is roughly the same as an  ordinary quicksort using a random pivot, and when k=2 this is roughly  a median-of-3 quicksort. From that view, using k ~= lg(n/ln(n)) makes  this a "median of n/ln(n)" quicksort. You can also view it as a kind  of bucket sort, where 2**k-1 bucket boundaries are picked dynamically.   The large number of samples makes a quadratic-time case almost  impossible, and asymptotically drives the average-case number of  compares from quicksort's 2 N ln N (or 12/7 N ln N for the median-of-  3 variant) down to N lg N.   We also play lots of low-level tricks to cut the number of compares.    Very obscure: To avoid using extra memory, the PPs are stored in the  array and shuffled around as partitioning proceeds. At the start of a  partitioning step, we'll have 2**m-1 (for some m) PPs in sorted order,  adjacent (either on the left or the right!) to a chunk of X elements  that are to be partitioned: P X or X P. In either case we need to  shuffle things *in place* so that the 2**(m-1) smaller PPs are on the  left, followed by the PP to be used for this step (that's the middle  of the PPs), followed by X, followed by the 2**(m-1) larger PPs:    P X or X P -&gt; Psmall pivot X Plarge  and the order of the PPs must not be altered. It can take a while  to realize this isn't trivial! It can take even longer &lt;wink&gt; to  understand why the simple code below works, using only 2**(m-1) swaps.  The key is that the order of the X elements isn't necessarily  preserved: X can end up as some cyclic permutation of its original  order. That's OK, because X is unsorted anyway. If the order of X  had to be preserved too, the simplest method I know of using O(1)  scratch storage requires len(X) + 2**(m-1) swaps, spread over 2 passes.  Since len(X) is typically several times larger than 2**(m-1), that  would slow things down.
@c

struct SamplesortStackNode {
	/* Represents a slice of the array, from (&amp; including) lo up
	   to (but excluding) hi.  "extra" additional &amp; adjacent elements
	   are pre-selected pivots (PPs), spanning [lo-extra, lo) if
	   extra &gt; 0, or [hi, hi-extra) if extra &lt; 0.  The PPs are
	   already sorted, but nothing is known about the other elements
	   in [lo, hi). |extra| is always one less than a power of 2.
	   When extra is 0, we're out of PPs, and the slice must be
	   sorted by some other means. */
	PyObject **lo;
	PyObject **hi;
	int extra;
};

/* The number of PPs we want is 2**k - 1, where 2**k is as close to
   N / ln(N) as possible.  So k ~= lg(N / ln(N)).  Calling libm routines
   is undesirable, so cutoff values are canned in the "cutoff" table
   below:  cutoff[i] is the smallest N such that k == CUTOFFBASE + i. */
#define CUTOFFBASE 4
static long cutoff[] = {
	43,        /* smallest N such that k == 4 */
	106,       /* etc */
	250,
	576,
	1298,
	2885,
	6339,
	13805,
	29843,
	64116,
	137030,
	291554,
	617916,
	1305130,
	2748295,
	5771662,
	12091672,
	25276798,
	52734615,
	109820537,
	228324027,
	473977813,
	982548444,   /* smallest N such that k == 26 */
	2034159050   /* largest N that fits in signed 32-bit; k == 27 */
};

static int
samplesortslice(PyObject **lo, PyObject **hi, PyObject *compare)
     /* compare -- comparison function object, or NULL for default */
{
	register PyObject **l, **r;
	register PyObject *tmp, *pivot;
	register int k;
	int n, extra, top, extraOnRight;
	struct SamplesortStackNode stack[STACKSIZE];

	/* assert lo &lt;= hi */
	n = hi - lo;

	/* ----------------------------------------------------------
	 * Special cases
	 * --------------------------------------------------------*/
	if (n &lt; 2)
		return 0;

	/* Set r to the largest value such that [lo,r) is sorted.
	   This catches the already-sorted case, the all-the-same
	   case, and the appended-a-few-elements-to-a-sorted-list case.
	   If the array is unsorted, we're very likely to get out of
	   the loop fast, so the test is cheap if it doesn't pay off.
	*/
	/* assert lo &lt; hi */
	for (r = lo+1; r &lt; hi; ++r) {
		SETK(*r, *(r-1));
		if (k &lt; 0)
			break;
	}
	/* [lo,r) is sorted, [r,hi) unknown.  Get out cheap if there are
	   few unknowns, or few elements in total. */
	if (hi - r &lt;= MAXMERGE || n &lt; MINSIZE)
		return binarysort(lo, hi, r, compare);

	/* Check for the array already being reverse-sorted.  Typical
	   benchmark-driven silliness &lt;wink&gt;. */
	/* assert lo &lt; hi */
	for (r = lo+1; r &lt; hi; ++r) {
		SETK(*(r-1), *r);
		if (k &lt; 0)
			break;
	}
	if (hi - r &lt;= MAXMERGE) {
		/* Reverse the reversed prefix, then insert the tail */
		PyObject **originalr = r;
		l = lo;
		do {
			--r;
			tmp = *l; *l = *r; *r = tmp;
			++l;
		} while (l &lt; r);
		return binarysort(lo, hi, originalr, compare);
	}

	/* ----------------------------------------------------------
	 * Normal case setup: a large array without obvious pattern.
	 * --------------------------------------------------------*/

	/* extra := a power of 2 ~= n/ln(n), less 1.
	   First find the smallest extra s.t. n &lt; cutoff[extra] */
	for (extra = 0;
	     extra &lt; sizeof(cutoff) / sizeof(cutoff[0]);
	     ++extra) {
		if (n &lt; cutoff[extra])
			break;
		/* note that if we fall out of the loop, the value of
		   extra still makes *sense*, but may be smaller than
		   we would like (but the array has more than ~= 2**31
		   elements in this case!) */ 
	}
	/* Now k == extra - 1 + CUTOFFBASE.  The smallest value k can
	   have is CUTOFFBASE-1, so
	   assert MINSIZE &gt;= 2**(CUTOFFBASE-1) - 1 */
	extra = (1 &lt;&lt; (extra - 1 + CUTOFFBASE)) - 1;
	/* assert extra &gt; 0 and n &gt;= extra */

	/* Swap that many values to the start of the array.  The
	   selection of elements is pseudo-random, but the same on
	   every run (this is intentional! timing algorithm changes is
	   a pain if timing varies across runs).  */
	{
		unsigned int seed = n / extra;  /* arbitrary */
		unsigned int i;
		for (i = 0; i &lt; (unsigned)extra; ++i) {
			/* j := random int in [i, n) */
			unsigned int j;
			seed = seed * 69069 + 7;
			j = i + seed % (n - i);
			tmp = lo[i]; lo[i] = lo[j]; lo[j] = tmp;
		}
	}

	/* Recursively sort the preselected pivots. */
	if (samplesortslice(lo, lo + extra, compare) &lt; 0)
		goto fail;

	top = 0;          /* index of available stack slot */
	lo += extra;      /* point to first unknown */
	extraOnRight = 0; /* the PPs are at the left end */

	/* ----------------------------------------------------------
	 * Partition [lo, hi), and repeat until out of work.
	 * --------------------------------------------------------*/
	for (;;) {
		/* assert lo &lt;= hi, so n &gt;= 0 */
		n = hi - lo;

		/* We may not want, or may not be able, to partition:
		   If n is small, it's quicker to insert.
		   If extra is 0, we're out of pivots, and *must* use
		   another method.
		*/
		if (n &lt; MINPARTITIONSIZE || extra == 0) {
			if (n &gt;= MINSIZE) {
				/* assert extra == 0
				   This is rare, since the average size
				   of a final block is only about
				   ln(original n). */
				if (samplesortslice(lo, hi, compare) &lt; 0)
					goto fail;
			}
			else {
				/* Binary insertion should be quicker,
				   and we can take advantage of the PPs
				   already being sorted. */
				if (extraOnRight &amp;&amp; extra) {
					/* swap the PPs to the left end */
					k = extra;
					do {
						tmp = *lo;
						*lo = *hi;
						*hi = tmp;
						++lo; ++hi;
					} while (--k);
				}
				if (binarysort(lo - extra, hi, lo,
					       compare) &lt; 0)
					goto fail;
			}

			/* Find another slice to work on. */
			if (--top &lt; 0)
				break;   /* no more -- done! */
			lo = stack[top].lo;
			hi = stack[top].hi;
			extra = stack[top].extra;
			extraOnRight = 0;
			if (extra &lt; 0) {
				extraOnRight = 1;
				extra = -extra;
			}
			continue;
		}

		/* Pretend the PPs are indexed 0, 1, ..., extra-1.
		   Then our preselected pivot is at (extra-1)/2, and we
		   want to move the PPs before that to the left end of
		   the slice, and the PPs after that to the right end.
		   The following section changes extra, lo, hi, and the
		   slice such that:
		   [lo-extra, lo) contains the smaller PPs.
		   *lo == our PP.
		   (lo, hi) contains the unknown elements.
		   [hi, hi+extra) contains the larger PPs.
		*/
		k = extra &gt;&gt;= 1;  /* num PPs to move */ 
		if (extraOnRight) {
			/* Swap the smaller PPs to the left end.
			   Note that this loop actually moves k+1 items:
			   the last is our PP */
			do {
				tmp = *lo; *lo = *hi; *hi = tmp;
				++lo; ++hi;
			} while (k--);
		}
		else {
			/* Swap the larger PPs to the right end. */
			while (k--) {
				--lo; --hi;
				tmp = *lo; *lo = *hi; *hi = tmp;
			}
		}
		--lo;   /* *lo is now our PP */
		pivot = *lo;

		/* Now an almost-ordinary quicksort partition step.
		   Note that most of the time is spent here!
		   Only odd thing is that we partition into &lt; and &gt;=,
		   instead of the usual &lt;= and &gt;=.  This helps when
		   there are lots of duplicates of different values,
		   because it eventually tends to make subfiles
		   "pure" (all duplicates), and we special-case for
		   duplicates later. */
		l = lo + 1;
		r = hi - 1;
		/* assert lo &lt; l &lt; r &lt; hi (small n weeded out above) */

		do {
			/* slide l right, looking for key &gt;= pivot */
			do {
				SETK(*l, pivot);
				if (k &lt; 0)
					++l;
				else
					break;
			} while (l &lt; r);

			/* slide r left, looking for key &lt; pivot */
			while (l &lt; r) {
				register PyObject *rval = *r--;
				SETK(rval, pivot);
				if (k &lt; 0) {
					/* swap and advance */
					r[1] = *l;
					*l++ = rval;
					break;
				}
			}

		} while (l &lt; r);

		/* assert lo &lt; r &lt;= l &lt; hi
		   assert r == l or r+1 == l
		   everything to the left of l is &lt; pivot, and
		   everything to the right of r is &gt;= pivot */

		if (l == r) {
			SETK(*r, pivot);
			if (k &lt; 0)
				++l;
			else
				--r;
		}
		/* assert lo &lt;= r and r+1 == l and l &lt;= hi
		   assert r == lo or a[r] &lt; pivot
		   assert a[lo] is pivot
		   assert l == hi or a[l] &gt;= pivot
		   Swap the pivot into "the middle", so we can henceforth
		   ignore it.
		*/
		*lo = *r;
		*r = pivot;

		/* The following is true now, &amp; will be preserved:
		   All in [lo,r) are &lt; pivot
		   All in [r,l) == pivot (&amp; so can be ignored)
		   All in [l,hi) are &gt;= pivot */

		/* Check for duplicates of the pivot.  One compare is
		   wasted if there are no duplicates, but can win big
		   when there are.
		   Tricky: we're sticking to "&lt;" compares, so deduce
		   equality indirectly.  We know pivot &lt;= *l, so they're
		   equal iff not pivot &lt; *l.
		*/
		while (l &lt; hi) {
			/* pivot &lt;= *l known */
			SETK(pivot, *l);
			if (k &lt; 0)
				break;
			else
				/* &lt;= and not &lt; implies == */
				++l;
		}

		/* assert lo &lt;= r &lt; l &lt;= hi
		   Partitions are [lo, r) and [l, hi) */

		/* push fattest first; remember we still have extra PPs
		   to the left of the left chunk and to the right of
		   the right chunk! */
		/* assert top &lt; STACKSIZE */
		if (r - lo &lt;= hi - l) {
			/* second is bigger */
			stack[top].lo = l;
			stack[top].hi = hi;
			stack[top].extra = -extra;
			hi = r;
			extraOnRight = 0;
		}
		else {
			/* first is bigger */
			stack[top].lo = lo;
			stack[top].hi = r;
			stack[top].extra = extra;
			lo = l;
			extraOnRight = 1;
		}
		++top;

	}   /* end of partitioning loop */

	return 0;

 fail:
	return -1;
}
</t>
<t tx="T250">#undef SETK

staticforward PyTypeObject immutable_list_type;

static PyObject *
listsort(PyListObject *self, PyObject *args)
{
	int err;
	PyObject *compare = NULL;
	PyTypeObject *savetype;

	if (args != NULL) {
		if (!PyArg_ParseTuple(args, "|O:sort", &amp;compare))
			return NULL;
	}
	savetype = self-&gt;ob_type;
	self-&gt;ob_type = &amp;immutable_list_type;
	err = samplesortslice(self-&gt;ob_item,
			      self-&gt;ob_item + self-&gt;ob_size,
			      compare);
	self-&gt;ob_type = savetype;
	if (err &lt; 0)
		return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T251">int
PyList_Sort(PyObject *v)
{
	if (v == NULL || !PyList_Check(v)) {
		PyErr_BadInternalCall();
		return -1;
	}
	v = listsort((PyListObject *)v, (PyObject *)NULL);
	if (v == NULL)
		return -1;
	Py_DECREF(v);
	return 0;
}
</t>
<t tx="T252">static void
_listreverse(PyListObject *self)
{
	register PyObject **p, **q;
	register PyObject *tmp;
	
	if (self-&gt;ob_size &gt; 1) {
		for (p = self-&gt;ob_item, q = self-&gt;ob_item + self-&gt;ob_size - 1;
		     p &lt; q;
		     p++, q--)
		{
			tmp = *p;
			*p = *q;
			*q = tmp;
		}
	}
}
</t>
<t tx="T253">static PyObject *
listreverse(PyListObject *self)
{
	_listreverse(self);
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T254">int
PyList_Reverse(PyObject *v)
{
	if (v == NULL || !PyList_Check(v)) {
		PyErr_BadInternalCall();
		return -1;
	}
	_listreverse((PyListObject *)v);
	return 0;
}
</t>
<t tx="T255">PyObject *
PyList_AsTuple(PyObject *v)
{
	PyObject *w;
	PyObject **p;
	int n;
	if (v == NULL || !PyList_Check(v)) {
		PyErr_BadInternalCall();
		return NULL;
	}
	n = ((PyListObject *)v)-&gt;ob_size;
	w = PyTuple_New(n);
	if (w == NULL)
		return NULL;
	p = ((PyTupleObject *)w)-&gt;ob_item;
	memcpy((void *)p,
	       (void *)((PyListObject *)v)-&gt;ob_item,
	       n*sizeof(PyObject *));
	while (--n &gt;= 0) {
		Py_INCREF(*p);
		p++;
	}
	return w;
}
</t>
<t tx="T256">static PyObject *
listindex(PyListObject *self, PyObject *v)
{
	int i;

	for (i = 0; i &lt; self-&gt;ob_size; i++) {
		int cmp = PyObject_RichCompareBool(self-&gt;ob_item[i], v, Py_EQ);
		if (cmp &gt; 0)
			return PyInt_FromLong((long)i);
		else if (cmp &lt; 0)
			return NULL;
	}
	PyErr_SetString(PyExc_ValueError, "list.index(x): x not in list");
	return NULL;
}
</t>
<t tx="T257">static PyObject *
listcount(PyListObject *self, PyObject *v)
{
	int count = 0;
	int i;

	for (i = 0; i &lt; self-&gt;ob_size; i++) {
		int cmp = PyObject_RichCompareBool(self-&gt;ob_item[i], v, Py_EQ);
		if (cmp &gt; 0)
			count++;
		else if (cmp &lt; 0)
			return NULL;
	}
	return PyInt_FromLong((long)count);
}
</t>
<t tx="T258">static PyObject *
listremove(PyListObject *self, PyObject *v)
{
	int i;

	for (i = 0; i &lt; self-&gt;ob_size; i++) {
		int cmp = PyObject_RichCompareBool(self-&gt;ob_item[i], v, Py_EQ);
		if (cmp &gt; 0) {
			if (list_ass_slice(self, i, i+1,
					   (PyObject *)NULL) != 0)
				return NULL;
			Py_INCREF(Py_None);
			return Py_None;
		}
		else if (cmp &lt; 0)
			return NULL;
	}
	PyErr_SetString(PyExc_ValueError, "list.remove(x): x not in list");
	return NULL;
}
</t>
<t tx="T259">static int
list_traverse(PyListObject *o, visitproc visit, void *arg)
{
	int i, err;
	PyObject *x;

	for (i = o-&gt;ob_size; --i &gt;= 0; ) {
		x = o-&gt;ob_item[i];
		if (x != NULL) {
			err = visit(x, arg);
			if (err)
				return err;
		}
	}
	return 0;
}
</t>
<t tx="T260">static int
list_clear(PyListObject *lp)
{
	(void) PyList_SetSlice((PyObject *)lp, 0, lp-&gt;ob_size, 0);
	return 0;
}
</t>
<t tx="T261">static PyObject *
list_richcompare(PyObject *v, PyObject *w, int op)
{
	PyListObject *vl, *wl;
	int i;

	if (!PyList_Check(v) || !PyList_Check(w)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}

	vl = (PyListObject *)v;
	wl = (PyListObject *)w;

	if (vl-&gt;ob_size != wl-&gt;ob_size &amp;&amp; (op == Py_EQ || op == Py_NE)) {
		/* Shortcut: if the lengths differ, the lists differ */
		PyObject *res;
		if (op == Py_EQ)
			res = Py_False;
		else
			res = Py_True;
		Py_INCREF(res);
		return res;
	}

	/* Search for the first index where items are different */
	for (i = 0; i &lt; vl-&gt;ob_size &amp;&amp; i &lt; wl-&gt;ob_size; i++) {
		int k = PyObject_RichCompareBool(vl-&gt;ob_item[i],
						 wl-&gt;ob_item[i], Py_EQ);
		if (k &lt; 0)
			return NULL;
		if (!k)
			break;
	}

	if (i &gt;= vl-&gt;ob_size || i &gt;= wl-&gt;ob_size) {
		/* No more items to compare -- compare sizes */
		int vs = vl-&gt;ob_size;
		int ws = wl-&gt;ob_size;
		int cmp;
		PyObject *res;
		switch (op) {
		case Py_LT: cmp = vs &lt;  ws; break;
		case Py_LE: cmp = vs &lt;= ws; break;
		case Py_EQ: cmp = vs == ws; break;
		case Py_NE: cmp = vs != ws; break;
		case Py_GT: cmp = vs &gt;  ws; break;
		case Py_GE: cmp = vs &gt;= ws; break;
		default: return NULL; /* cannot happen */
		}
		if (cmp)
			res = Py_True;
		else
			res = Py_False;
		Py_INCREF(res);
		return res;
	}

	/* We have an item that differs -- shortcuts for EQ/NE */
	if (op == Py_EQ) {
		Py_INCREF(Py_False);
		return Py_False;
	}
	if (op == Py_NE) {
		Py_INCREF(Py_True);
		return Py_True;
	}

	/* Compare the final item again using the proper operator */
	return PyObject_RichCompare(vl-&gt;ob_item[i], wl-&gt;ob_item[i], op);
}
</t>
<t tx="T262">@ Adapted from newer code by Tim
@c

static int
list_fill(PyListObject *result, PyObject *v)
{
	PyObject *it;      /* iter(v) */
	int n;		   /* guess for result list size */
	int i;

	n = result-&gt;ob_size;

	/* Special-case list(a_list), for speed. */
	if (PyList_Check(v)) {
		if (v == (PyObject *)result)
			return 0; /* source is destination, we're done */
		return list_ass_slice(result, 0, n, v);
	}

	/* Empty previous contents */
	if (n != 0) {
		if (list_ass_slice(result, 0, n, (PyObject *)NULL) != 0)
			return -1;
	}

	/* Get iterator.  There may be some low-level efficiency to be gained
	 * by caching the tp_iternext slot instead of using PyIter_Next()
	 * later, but premature optimization is the root etc.
	 */
	it = PyObject_GetIter(v);
	if (it == NULL)
		return -1;

	/* Guess a result list size. */
	n = -1;	 /* unknown */
	if (PySequence_Check(v) &amp;&amp;
	    v-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_length) {
		n = PySequence_Size(v);
		if (n &lt; 0)
			PyErr_Clear();
	}
	if (n &lt; 0)
		n = 8;	/* arbitrary */
	NRESIZE(result-&gt;ob_item, PyObject*, n);
	if (result-&gt;ob_item == NULL)
		goto error;
	for (i = 0; i &lt; n; i++)
		result-&gt;ob_item[i] = NULL;
	result-&gt;ob_size = n;

	/* Run iterator to exhaustion. */
	for (i = 0; ; i++) {
		PyObject *item = PyIter_Next(it);
		if (item == NULL) {
			if (PyErr_Occurred())
				goto error;
			break;
		}
		if (i &lt; n)
			PyList_SET_ITEM(result, i, item); /* steals ref */
		else {
			int status = ins1(result, result-&gt;ob_size, item);
			Py_DECREF(item);  /* append creates a new ref */
			if (status &lt; 0)
				goto error;
		}
	}

	/* Cut back result list if initial guess was too large. */
	if (i &lt; n &amp;&amp; result != NULL) {
		if (list_ass_slice(result, i, n, (PyObject *)NULL) != 0)
			goto error;
	}
	Py_DECREF(it);
	return 0;

  error:
	Py_DECREF(it);
	return -1;
}
</t>
<t tx="T263">static int
list_init(PyListObject *self, PyObject *args, PyObject *kw)
{
	PyObject *arg = NULL;
	static char *kwlist[] = {"sequence", 0};

	if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:list", kwlist, &amp;arg))
		return -1;
	if (arg != NULL)
		return list_fill(self, arg);
	if (self-&gt;ob_size &gt; 0)
		return list_ass_slice(self, 0, self-&gt;ob_size, (PyObject*)NULL);
	return 0;
}
</t>
<t tx="T264">static long
list_nohash(PyObject *self)
{
	PyErr_SetString(PyExc_TypeError, "list objects are unhashable");
	return -1;
}
</t>
<t tx="T265">static char append_doc[] =
"L.append(object) -- append object to end";
static char extend_doc[] =
"L.extend(list) -- extend list by appending list elements";
static char insert_doc[] =
"L.insert(index, object) -- insert object before index";
static char pop_doc[] =
"L.pop([index]) -&gt; item -- remove and return item at index (default last)";
static char remove_doc[] =
"L.remove(value) -- remove first occurrence of value";
static char index_doc[] =
"L.index(value) -&gt; integer -- return index of first occurrence of value";
static char count_doc[] =
"L.count(value) -&gt; integer -- return number of occurrences of value";
static char reverse_doc[] =
"L.reverse() -- reverse *IN PLACE*";
static char sort_doc[] =
"L.sort([cmpfunc]) -- sort *IN PLACE*; if given, cmpfunc(x, y) -&gt; -1, 0, 1";

static PyMethodDef list_methods[] = {
	{"append",	(PyCFunction)listappend,  METH_O, append_doc},
	{"insert",	(PyCFunction)listinsert,  METH_VARARGS, insert_doc},
	{"extend",      (PyCFunction)listextend,  METH_O, extend_doc},
	{"pop",		(PyCFunction)listpop, 	  METH_VARARGS, pop_doc},
	{"remove",	(PyCFunction)listremove,  METH_O, remove_doc},
	{"index",	(PyCFunction)listindex,   METH_O, index_doc},
	{"count",	(PyCFunction)listcount,   METH_O, count_doc},
	{"reverse",	(PyCFunction)listreverse, METH_NOARGS, reverse_doc},
	{"sort",	(PyCFunction)listsort, 	  METH_VARARGS, sort_doc},
	{NULL,		NULL}		/* sentinel */
};

static PySequenceMethods list_as_sequence = {
	(inquiry)list_length,			/* sq_length */
	(binaryfunc)list_concat,		/* sq_concat */
	(intargfunc)list_repeat,		/* sq_repeat */
	(intargfunc)list_item,			/* sq_item */
	(intintargfunc)list_slice,		/* sq_slice */
	(intobjargproc)list_ass_item,		/* sq_ass_item */
	(intintobjargproc)list_ass_slice,	/* sq_ass_slice */
	(objobjproc)list_contains,		/* sq_contains */
	(binaryfunc)list_inplace_concat,	/* sq_inplace_concat */
	(intargfunc)list_inplace_repeat,	/* sq_inplace_repeat */
};

static char list_doc[] =
"list() -&gt; new list\n"
"list(sequence) -&gt; new list initialized from sequence's items";

PyTypeObject PyList_Type = {
	PyObject_HEAD_INIT(&amp;PyType_Type)
	0,
	"list",
	sizeof(PyListObject),
	0,
	(destructor)list_dealloc,		/* tp_dealloc */
	(printfunc)list_print,			/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	(reprfunc)list_repr,			/* tp_repr */
	0,					/* tp_as_number */
	&amp;list_as_sequence,			/* tp_as_sequence */
	0,					/* tp_as_mapping */
	list_nohash,				/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	PyObject_GenericGetAttr,		/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
		Py_TPFLAGS_BASETYPE,		/* tp_flags */
 	list_doc,				/* tp_doc */
 	(traverseproc)list_traverse,		/* tp_traverse */
 	(inquiry)list_clear,			/* tp_clear */
	list_richcompare,			/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	list_methods,				/* tp_methods */
	0,					/* tp_members */
	0,					/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,					/* tp_descr_get */
	0,					/* tp_descr_set */
	0,					/* tp_dictoffset */
	(initproc)list_init,			/* tp_init */
	PyType_GenericAlloc,			/* tp_alloc */
	PyType_GenericNew,			/* tp_new */
	_PyObject_GC_Del,			/* tp_free */
};


/* During a sort, we really can't have anyone modifying the list; it could
   cause core dumps.  Thus, we substitute a dummy type that raises an
   explanatory exception when a modifying operation is used.  Caveat:
   comparisons may behave differently; but I guess it's a bad idea anyway to
   compare a list that's being sorted... */

static PyObject *
immutable_list_op(void)
{
	PyErr_SetString(PyExc_TypeError,
			"a list cannot be modified while it is being sorted");
	return NULL;
}
</t>
<t tx="T266">static PyMethodDef immutable_list_methods[] = {
	{"append",	(PyCFunction)immutable_list_op, METH_VARARGS},
	{"insert",	(PyCFunction)immutable_list_op, METH_VARARGS},
	{"extend",      (PyCFunction)immutable_list_op,  METH_O},
	{"pop",		(PyCFunction)immutable_list_op, METH_VARARGS},
	{"remove",	(PyCFunction)immutable_list_op, METH_VARARGS},
	{"index",	(PyCFunction)listindex,         METH_O},
	{"count",	(PyCFunction)listcount,         METH_O},
	{"reverse",	(PyCFunction)immutable_list_op, METH_VARARGS},
	{"sort",	(PyCFunction)immutable_list_op, METH_VARARGS},
	{NULL,		NULL}		/* sentinel */
};

static int
immutable_list_ass(void)
{
	immutable_list_op();
	return -1;
}
</t>
<t tx="T267">@language c
/* Generic object operations; and implementation of None (NoObject) */

&lt;&lt; #includes &gt;&gt;

@others

#ifdef WITH_PYMALLOC
#include "obmalloc.c"
#endif
</t>
<t tx="T268">#include "Python.h"

#ifdef macintosh
#include "macglue.h"
#endif

/* just for trashcan: */
#include "compile.h"
#include "frameobject.h"
#include "traceback.h"

#if defined( Py_TRACE_REFS ) || defined( Py_REF_DEBUG )
DL_IMPORT(long) _Py_RefTotal;
#endif

DL_IMPORT(int) Py_DivisionWarningFlag;

</t>
<t tx="T269">/* Object allocation routines used by NEWOBJ and NEWVAROBJ macros.
   These are used by the individual routines for object creation.
   Do not call them otherwise, they do not initialize the object! */

#ifdef COUNT_ALLOCS
@others
#endif</t>
<t tx="T270">static PyTypeObject *type_list;
extern int tuple_zero_allocs, fast_tuple_allocs;
extern int quick_int_allocs, quick_neg_int_allocs;
extern int null_strings, one_strings;
void
dump_counts(void)
{
	PyTypeObject *tp;

	for (tp = type_list; tp; tp = tp-&gt;tp_next)
		fprintf(stderr, "%s alloc'd: %d, freed: %d, max in use: %d\n",
			tp-&gt;tp_name, tp-&gt;tp_allocs, tp-&gt;tp_frees,
			tp-&gt;tp_maxalloc);
	fprintf(stderr, "fast tuple allocs: %d, empty: %d\n",
		fast_tuple_allocs, tuple_zero_allocs);
	fprintf(stderr, "fast int allocs: pos: %d, neg: %d\n",
		quick_int_allocs, quick_neg_int_allocs);
	fprintf(stderr, "null strings: %d, 1-strings: %d\n",
		null_strings, one_strings);
}
</t>
<t tx="T271">PyObject *
get_counts(void)
{
	PyTypeObject *tp;
	PyObject *result;
	PyObject *v;

	result = PyList_New(0);
	if (result == NULL)
		return NULL;
	for (tp = type_list; tp; tp = tp-&gt;tp_next) {
		v = Py_BuildValue("(siii)", tp-&gt;tp_name, tp-&gt;tp_allocs,
				  tp-&gt;tp_frees, tp-&gt;tp_maxalloc);
		if (v == NULL) {
			Py_DECREF(result);
			return NULL;
		}
		if (PyList_Append(result, v) &lt; 0) {
			Py_DECREF(v);
			Py_DECREF(result);
			return NULL;
		}
		Py_DECREF(v);
	}
	return result;
}
</t>
<t tx="T272">void
inc_count(PyTypeObject *tp)
{
	if (tp-&gt;tp_allocs == 0) {
		/* first time; insert in linked list */
		if (tp-&gt;tp_next != NULL) /* sanity check */
			Py_FatalError("XXX inc_count sanity check");
		tp-&gt;tp_next = type_list;
		type_list = tp;
	}
	tp-&gt;tp_allocs++;
	if (tp-&gt;tp_allocs - tp-&gt;tp_frees &gt; tp-&gt;tp_maxalloc)
		tp-&gt;tp_maxalloc = tp-&gt;tp_allocs - tp-&gt;tp_frees;
}
</t>
<t tx="T273">PyObject *
PyObject_Init(PyObject *op, PyTypeObject *tp)
{
	if (op == NULL) {
		PyErr_SetString(PyExc_SystemError,
				"NULL object passed to PyObject_Init");
		return op;
  	}
	/* Any changes should be reflected in PyObject_INIT (objimpl.h) */
	op-&gt;ob_type = tp;
	_Py_NewReference(op);
	return op;
}
</t>
<t tx="T274">PyVarObject *
PyObject_InitVar(PyVarObject *op, PyTypeObject *tp, int size)
{
	if (op == NULL) {
		PyErr_SetString(PyExc_SystemError,
				"NULL object passed to PyObject_InitVar");
		return op;
	}
	/* Any changes should be reflected in PyObject_INIT_VAR */
	op-&gt;ob_size = size;
	op-&gt;ob_type = tp;
	_Py_NewReference((PyObject *)op);
	return op;
}
</t>
<t tx="T275">PyObject *
_PyObject_New(PyTypeObject *tp)
{
	PyObject *op;
	op = (PyObject *) PyObject_MALLOC(_PyObject_SIZE(tp));
	if (op == NULL)
		return PyErr_NoMemory();
	return PyObject_INIT(op, tp);
}
</t>
<t tx="T276">PyVarObject *
_PyObject_NewVar(PyTypeObject *tp, int nitems)
{
	PyVarObject *op;
	const size_t size = _PyObject_VAR_SIZE(tp, nitems);
	op = (PyVarObject *) PyObject_MALLOC(size);
	if (op == NULL)
		return (PyVarObject *)PyErr_NoMemory();
	return PyObject_INIT_VAR(op, tp, nitems);
}
</t>
<t tx="T277">void
_PyObject_Del(PyObject *op)
{
	PyObject_FREE(op);
}
</t>
<t tx="T278">int
PyObject_Print(PyObject *op, FILE *fp, int flags)
{
	int ret = 0;
	if (PyErr_CheckSignals())
		return -1;
#ifdef USE_STACKCHECK
	if (PyOS_CheckStack()) {
		PyErr_SetString(PyExc_MemoryError, "stack overflow");
		return -1;
	}
#endif
	clearerr(fp); /* Clear any previous error condition */
	if (op == NULL) {
		fprintf(fp, "&lt;nil&gt;");
	}
	else {
		if (op-&gt;ob_refcnt &lt;= 0)
			fprintf(fp, "&lt;refcnt %u at %p&gt;",
				op-&gt;ob_refcnt, op);
		else if (op-&gt;ob_type-&gt;tp_print == NULL) {
			PyObject *s;
			if (flags &amp; Py_PRINT_RAW)
				s = PyObject_Str(op);
			else
				s = PyObject_Repr(op);
			if (s == NULL)
				ret = -1;
			else {
				ret = PyObject_Print(s, fp, Py_PRINT_RAW);
			}
			Py_XDECREF(s);
		}
		else
			ret = (*op-&gt;ob_type-&gt;tp_print)(op, fp, flags);
	}
	if (ret == 0) {
		if (ferror(fp)) {
			PyErr_SetFromErrno(PyExc_IOError);
			clearerr(fp);
			ret = -1;
		}
	}
	return ret;
}
</t>
<t tx="T279">@ For debugging convenience. See Misc/gdbinit for some useful gdb hooks
@c

void _PyObject_Dump(PyObject* op) 
{
	if (op == NULL)
		fprintf(stderr, "NULL\n");
	else {
		fprintf(stderr, "object  : ");
		(void)PyObject_Print(op, stderr, 0);
		fprintf(stderr, "\n"
			"type    : %s\n"
			"refcount: %d\n"
			"address : %p\n",
			op-&gt;ob_type==NULL ? "NULL" : op-&gt;ob_type-&gt;tp_name,
			op-&gt;ob_refcnt,
			op);
	}
}
</t>
<t tx="T280">PyObject *
PyObject_Repr(PyObject *v)
{
	if (PyErr_CheckSignals())
		return NULL;
#ifdef USE_STACKCHECK
	if (PyOS_CheckStack()) {
		PyErr_SetString(PyExc_MemoryError, "stack overflow");
		return NULL;
	}
#endif
	if (v == NULL)
		return PyString_FromString("&lt;NULL&gt;");
	else if (v-&gt;ob_type-&gt;tp_repr == NULL)
		return PyString_FromFormat("&lt;%s object at %p&gt;",
					   v-&gt;ob_type-&gt;tp_name, v);
	else {
		PyObject *res;
		res = (*v-&gt;ob_type-&gt;tp_repr)(v);
		if (res == NULL)
			return NULL;
#ifdef Py_USING_UNICODE
		if (PyUnicode_Check(res)) {
			PyObject* str;
			str = PyUnicode_AsUnicodeEscapeString(res);
			Py_DECREF(res);
			if (str)
				res = str;
			else
				return NULL;
		}
#endif
		if (!PyString_Check(res)) {
			PyErr_Format(PyExc_TypeError,
				     "__repr__ returned non-string (type %.200s)",
				     res-&gt;ob_type-&gt;tp_name);
			Py_DECREF(res);
			return NULL;
		}
		return res;
	}
}
</t>
<t tx="T281">PyObject *
PyObject_Str(PyObject *v)
{
	PyObject *res;
	
	if (v == NULL)
		return PyString_FromString("&lt;NULL&gt;");
	if (PyString_CheckExact(v)) {
		Py_INCREF(v);
		return v;
	}
	if (v-&gt;ob_type-&gt;tp_str == NULL)
		return PyObject_Repr(v);

	res = (*v-&gt;ob_type-&gt;tp_str)(v);
	if (res == NULL)
		return NULL;
#ifdef Py_USING_UNICODE
	if (PyUnicode_Check(res)) {
		PyObject* str;
		str = PyUnicode_AsEncodedString(res, NULL, NULL);
		Py_DECREF(res);
		if (str)
			res = str;
		else
		    	return NULL;
	}
#endif
	if (!PyString_Check(res)) {
		PyErr_Format(PyExc_TypeError,
			     "__str__ returned non-string (type %.200s)",
			     res-&gt;ob_type-&gt;tp_name);
		Py_DECREF(res);
		return NULL;
	}
	return res;
}
</t>
<t tx="T282">#ifdef Py_USING_UNICODE
PyObject *
PyObject_Unicode(PyObject *v)
{
	PyObject *res;
	
	if (v == NULL)
		res = PyString_FromString("&lt;NULL&gt;");
	if (PyUnicode_CheckExact(v)) {
		Py_INCREF(v);
		return v;
	}
	if (PyUnicode_Check(v)) {
		/* For a Unicode subtype that's not a Unicode object,
		   return a true Unicode object with the same data. */
		return PyUnicode_FromUnicode(PyUnicode_AS_UNICODE(v),
					     PyUnicode_GET_SIZE(v));
	}
	if (PyString_Check(v)) {
		Py_INCREF(v);
	    	res = v;
    	}
	else {
		PyObject *func;
		static PyObject *unicodestr;
		/* XXX As soon as we have a tp_unicode slot, we should
		       check this before trying the __unicode__
		       method. */
		if (unicodestr == NULL) {
			unicodestr= PyString_InternFromString(
						       "__unicode__");
			if (unicodestr == NULL)
				return NULL;
		}
		func = PyObject_GetAttr(v, unicodestr);
		if (func != NULL) {
		    	res = PyEval_CallObject(func, (PyObject *)NULL);
			Py_DECREF(func);
		}
		else {
			PyErr_Clear();
			if (v-&gt;ob_type-&gt;tp_str != NULL)
				res = (*v-&gt;ob_type-&gt;tp_str)(v);
			else
				res = PyObject_Repr(v);
		}
	}
	if (res == NULL)
		return NULL;
	if (!PyUnicode_Check(res)) {
		PyObject *str;
		str = PyUnicode_FromEncodedObject(res, NULL, "strict");
		Py_DECREF(res);
		if (str)
			res = str;
		else
		    	return NULL;
	}
	return res;
}
</t>
<t tx="T283">#endif


/* Macro to get the tp_richcompare field of a type if defined */
#define RICHCOMPARE(t) (PyType_HasFeature((t), Py_TPFLAGS_HAVE_RICHCOMPARE) \
                         ? (t)-&gt;tp_richcompare : NULL)

/* Map rich comparison operators to their swapped version, e.g. LT --&gt; GT */
static int swapped_op[] = {Py_GT, Py_GE, Py_EQ, Py_NE, Py_LT, Py_LE};

/* Try a genuine rich comparison, returning an object.  Return:
   NULL for exception;
   NotImplemented if this particular rich comparison is not implemented or
     undefined;
   some object not equal to NotImplemented if it is implemented
     (this latter object may not be a Boolean).
*/
static PyObject *
try_rich_compare(PyObject *v, PyObject *w, int op)
{
	richcmpfunc f;
	PyObject *res;

	if (v-&gt;ob_type != w-&gt;ob_type &amp;&amp;
	    PyType_IsSubtype(w-&gt;ob_type, v-&gt;ob_type) &amp;&amp;
	    (f = RICHCOMPARE(w-&gt;ob_type)) != NULL) {
		res = (*f)(w, v, swapped_op[op]);
		if (res != Py_NotImplemented)
			return res;
		Py_DECREF(res);
	}
	if ((f = RICHCOMPARE(v-&gt;ob_type)) != NULL) {
		res = (*f)(v, w, op);
		if (res != Py_NotImplemented)
			return res;
		Py_DECREF(res);
	}
	if ((f = RICHCOMPARE(w-&gt;ob_type)) != NULL) {
		return (*f)(w, v, swapped_op[op]);
	}
	res = Py_NotImplemented;
	Py_INCREF(res);
	return res;
}
</t>
<t tx="T284">@ Try a genuine rich comparison, returning an int. Return:  -1 for exception (including the case where try_rich_compare() returns an    object that's not a Boolean);   0 if the outcome is false;   1 if the outcome is true;   2 if this particular rich comparison is not implemented or undefined.
@c

static int
try_rich_compare_bool(PyObject *v, PyObject *w, int op)
{
	PyObject *res;
	int ok;

	if (RICHCOMPARE(v-&gt;ob_type) == NULL &amp;&amp; RICHCOMPARE(w-&gt;ob_type) == NULL)
		return 2; /* Shortcut, avoid INCREF+DECREF */
	res = try_rich_compare(v, w, op);
	if (res == NULL)
		return -1;
	if (res == Py_NotImplemented) {
		Py_DECREF(res);
		return 2;
	}
	ok = PyObject_IsTrue(res);
	Py_DECREF(res);
	return ok;
}
</t>
<t tx="T285">@ Try rich comparisons to determine a 3-way comparison. Return:  -2 for an exception;  -1 if v &lt; w;   0 if v == w;   1 if v &gt; w;   2 if this particular rich comparison is not implemented or undefined.
@c

static int
try_rich_to_3way_compare(PyObject *v, PyObject *w)
{
	static struct { int op; int outcome; } tries[3] = {
		/* Try this operator, and if it is true, use this outcome: */
		{Py_EQ, 0},
		{Py_LT, -1},
		{Py_GT, 1},
	};
	int i;

	if (RICHCOMPARE(v-&gt;ob_type) == NULL &amp;&amp; RICHCOMPARE(w-&gt;ob_type) == NULL)
		return 2; /* Shortcut */

	for (i = 0; i &lt; 3; i++) {
		switch (try_rich_compare_bool(v, w, tries[i].op)) {
		case -1:
			return -2;
		case 1:
			return tries[i].outcome;
		}
	}

	return 2;
}
</t>
<t tx="T286">@ Try a 3-way comparison, returning an int. Return:  -2 for an exception;  -1 if v &lt; w;   0 if v == w;   1 if v &gt; w;   2 if this particular 3-way comparison is not implemented or undefined.
@c

static int
try_3way_compare(PyObject *v, PyObject *w)
{
	int c;
	cmpfunc f;

	/* Comparisons involving instances are given to instance_compare,
	   which has the same return conventions as this function. */

	f = v-&gt;ob_type-&gt;tp_compare;
	if (PyInstance_Check(v))
		return (*f)(v, w);
	if (PyInstance_Check(w))
		return (*w-&gt;ob_type-&gt;tp_compare)(v, w);

	/* If both have the same (non-NULL) tp_compare, use it. */
	if (f != NULL &amp;&amp; f == w-&gt;ob_type-&gt;tp_compare) {
		c = (*f)(v, w);
		if (c &lt; 0 &amp;&amp; PyErr_Occurred())
			return -1;
		return c &lt; 0 ? -1 : c &gt; 0 ? 1 : 0;
	}

	/* If either tp_compare is _PyObject_SlotCompare, that's safe. */
	if (f == _PyObject_SlotCompare ||
	    w-&gt;ob_type-&gt;tp_compare == _PyObject_SlotCompare)
		return _PyObject_SlotCompare(v, w);

	/* Try coercion; if it fails, give up */
	c = PyNumber_CoerceEx(&amp;v, &amp;w);
	if (c &lt; 0)
		return -2;
	if (c &gt; 0)
		return 2;

	/* Try v's comparison, if defined */
	if ((f = v-&gt;ob_type-&gt;tp_compare) != NULL) {
		c = (*f)(v, w);
		Py_DECREF(v);
		Py_DECREF(w);
		if (c &lt; 0 &amp;&amp; PyErr_Occurred())
			return -2;
		return c &lt; 0 ? -1 : c &gt; 0 ? 1 : 0;
	}

	/* Try w's comparison, if defined */
	if ((f = w-&gt;ob_type-&gt;tp_compare) != NULL) {
		c = (*f)(w, v); /* swapped! */
		Py_DECREF(v);
		Py_DECREF(w);
		if (c &lt; 0 &amp;&amp; PyErr_Occurred())
			return -2;
		return c &lt; 0 ? 1 : c &gt; 0 ? -1 : 0; /* negated! */
	}

	/* No comparison defined */
	Py_DECREF(v);
	Py_DECREF(w);
	return 2;
}
</t>
<t tx="T287">@ Final fallback 3-way comparison, returning an int. Return:  -2 if an error occurred;  -1 if v &lt; w;   0 if v == w;   1 if v &gt; w.
@c

static int
default_3way_compare(PyObject *v, PyObject *w)
{
	int c;
	char *vname, *wname;

	if (v-&gt;ob_type == w-&gt;ob_type) {
		/* When comparing these pointers, they must be cast to
		 * integer types (i.e. Py_uintptr_t, our spelling of C9X's
		 * uintptr_t).  ANSI specifies that pointer compares other
		 * than == and != to non-related structures are undefined.
		 */
		Py_uintptr_t vv = (Py_uintptr_t)v;
		Py_uintptr_t ww = (Py_uintptr_t)w;
		return (vv &lt; ww) ? -1 : (vv &gt; ww) ? 1 : 0;
	}

#ifdef Py_USING_UNICODE
	/* Special case for Unicode */
	if (PyUnicode_Check(v) || PyUnicode_Check(w)) {
		c = PyUnicode_Compare(v, w);
		if (!PyErr_Occurred())
			return c;
		/* TypeErrors are ignored: if Unicode coercion fails due
		   to one of the arguments not having the right type, we
		   continue as defined by the coercion protocol (see
		   above).  Luckily, decoding errors are reported as
		   ValueErrors and are not masked by this technique. */
		if (!PyErr_ExceptionMatches(PyExc_TypeError))
			return -2;
		PyErr_Clear();
	}
#endif

	/* None is smaller than anything */
	if (v == Py_None)
		return -1;
	if (w == Py_None)
		return 1;

	/* different type: compare type names */
	if (v-&gt;ob_type-&gt;tp_as_number)
		vname = "";
	else
		vname = v-&gt;ob_type-&gt;tp_name;
	if (w-&gt;ob_type-&gt;tp_as_number)
		wname = "";
	else
		wname = w-&gt;ob_type-&gt;tp_name;
	c = strcmp(vname, wname);
	if (c &lt; 0)
		return -1;
	if (c &gt; 0)
		return 1;
	/* Same type name, or (more likely) incomparable numeric types */
	return ((Py_uintptr_t)(v-&gt;ob_type) &lt; (
		Py_uintptr_t)(w-&gt;ob_type)) ? -1 : 1;
}
</t>
<t tx="T288">#define CHECK_TYPES(o) PyType_HasFeature((o)-&gt;ob_type, Py_TPFLAGS_CHECKTYPES)

/* Do a 3-way comparison, by hook or by crook.  Return:
   -2 for an exception;
   -1 if v &lt;  w;
    0 if v == w;
    1 if v &gt;  w;
   If the object implements a tp_compare function, it returns
   whatever this function returns (whether with an exception or not).
*/
static int
do_cmp(PyObject *v, PyObject *w)
{
	int c;
	cmpfunc f;

	if (v-&gt;ob_type == w-&gt;ob_type
	    &amp;&amp; (f = v-&gt;ob_type-&gt;tp_compare) != NULL) {
		c = (*f)(v, w);
		if (c != 2 || !PyInstance_Check(v))
			return c;
	}
	c = try_rich_to_3way_compare(v, w);
	if (c &lt; 2)
		return c;
	c = try_3way_compare(v, w);
	if (c &lt; 2)
		return c;
	return default_3way_compare(v, w);
}
</t>
<t tx="T289">@ compare_nesting is incremented before calling compare (for  some types) and decremented on exit. If the count exceeds the  nesting limit, enable code to detect circular data structures.   This is a tunable parameter that should only affect the performance  of comparisons, nothing else. Setting it high makes comparing deeply  nested non-cyclical data structures faster, but makes comparing cyclical  data structures slower.
@c

#define NESTING_LIMIT 20

static int compare_nesting = 0;

static PyObject*
get_inprogress_dict(void)
{
	static PyObject *key;
	PyObject *tstate_dict, *inprogress;

	if (key == NULL) {
		key = PyString_InternFromString("cmp_state");
		if (key == NULL)
			return NULL;
	}

	tstate_dict = PyThreadState_GetDict();
	if (tstate_dict == NULL) {
		PyErr_BadInternalCall();
		return NULL;
	} 

	inprogress = PyDict_GetItem(tstate_dict, key); 
	if (inprogress == NULL) {
		inprogress = PyDict_New();
		if (inprogress == NULL)
			return NULL;
		if (PyDict_SetItem(tstate_dict, key, inprogress) == -1) {
		    Py_DECREF(inprogress);
		    return NULL;
		}
		Py_DECREF(inprogress);
	}

	return inprogress;
}
</t>
<t tx="T290">static PyObject *
check_recursion(PyObject *v, PyObject *w, int op)
{
	PyObject *inprogress;
	PyObject *token;
	Py_uintptr_t iv = (Py_uintptr_t)v;
	Py_uintptr_t iw = (Py_uintptr_t)w;
	PyObject *x, *y, *z;

	inprogress = get_inprogress_dict();
	if (inprogress == NULL)
		return NULL;

	token = PyTuple_New(3);
	if (token == NULL)
		return NULL;

	if (iv &lt;= iw) {
		PyTuple_SET_ITEM(token, 0, x = PyLong_FromVoidPtr((void *)v));
		PyTuple_SET_ITEM(token, 1, y = PyLong_FromVoidPtr((void *)w));
		if (op &gt;= 0)
			op = swapped_op[op];
	} else {
		PyTuple_SET_ITEM(token, 0, x = PyLong_FromVoidPtr((void *)w));
		PyTuple_SET_ITEM(token, 1, y = PyLong_FromVoidPtr((void *)v));
	}
	PyTuple_SET_ITEM(token, 2, z = PyInt_FromLong((long)op));
	if (x == NULL || y == NULL || z == NULL) {
		Py_DECREF(token);
		return NULL;
	}

	if (PyDict_GetItem(inprogress, token) != NULL) {
		Py_DECREF(token);
		return Py_None; /* Without INCREF! */
	}

	if (PyDict_SetItem(inprogress, token, token) &lt; 0) {
		Py_DECREF(token);
		return NULL;
	}

	return token;
}
</t>
<t tx="T291">static void
delete_token(PyObject *token)
{
	PyObject *inprogress;

	if (token == NULL || token == Py_None)
		return;
	inprogress = get_inprogress_dict();
	if (inprogress == NULL)
		PyErr_Clear();
	else
		PyDict_DelItem(inprogress, token);
	Py_DECREF(token);
}
</t>
<t tx="T292">@ Compare v to w. Return  -1 if v &lt; w or exception (PyErr_Occurred() true in latter case).   0 if v == w.   1 if v &gt; w.  XXX The docs (C API manual) say the return value is undefined in case  XXX of error.
@c

int
PyObject_Compare(PyObject *v, PyObject *w)
{
	PyTypeObject *vtp;
	int result;

#if defined(USE_STACKCHECK)
	if (PyOS_CheckStack()) {
		PyErr_SetString(PyExc_MemoryError, "Stack overflow");
		return -1;
	}
#endif
	if (v == NULL || w == NULL) {
		PyErr_BadInternalCall();
		return -1;
	}
	if (v == w)
		return 0;
	vtp = v-&gt;ob_type;
	compare_nesting++;
	if (compare_nesting &gt; NESTING_LIMIT &amp;&amp;
		(vtp-&gt;tp_as_mapping
		 || (vtp-&gt;tp_as_sequence
		     &amp;&amp; !PyString_Check(v)
		     &amp;&amp; !PyTuple_Check(v)))) {
		/* try to detect circular data structures */
		PyObject *token = check_recursion(v, w, -1);

		if (token == NULL) {
			result = -1;
		}
		else if (token == Py_None) {
			/* already comparing these objects.  assume
			   they're equal until shown otherwise */
                        result = 0;
		}
		else {
			result = do_cmp(v, w);
			delete_token(token);
		}
	}
	else {
		result = do_cmp(v, w);
	}
	compare_nesting--;
	return result &lt; 0 ? -1 : result;
}
</t>
<t tx="T293">@ Return (new reference to) Py_True or Py_False.
@c

static PyObject *
convert_3way_to_object(int op, int c)
{
	PyObject *result;
	switch (op) {
	case Py_LT: c = c &lt;  0; break;
	case Py_LE: c = c &lt;= 0; break;
	case Py_EQ: c = c == 0; break;
	case Py_NE: c = c != 0; break;
	case Py_GT: c = c &gt;  0; break;
	case Py_GE: c = c &gt;= 0; break;
	}
	result = c ? Py_True : Py_False;
	Py_INCREF(result);
	return result;
}
</t>
<t tx="T294">@ We want a rich comparison but don't have one. Try a 3-way cmp instead.  Return  NULL   if error  Py_True  if v op w  Py_False if not (v op w)
@c

static PyObject *
try_3way_to_rich_compare(PyObject *v, PyObject *w, int op)
{
	int c;

	c = try_3way_compare(v, w);
	if (c &gt;= 2)
		c = default_3way_compare(v, w);
	if (c &lt;= -2)
		return NULL;
	return convert_3way_to_object(op, c);
}
</t>
<t tx="T295">@ Do rich comparison on v and w. Return  NULL   if error  Else a new reference to an object other than Py_NotImplemented, usually(?):  Py_True  if v op w  Py_False if not (v op w)
@c

static PyObject *
do_richcmp(PyObject *v, PyObject *w, int op)
{
	PyObject *res;

	res = try_rich_compare(v, w, op);
	if (res != Py_NotImplemented)
		return res;
	Py_DECREF(res);

	return try_3way_to_rich_compare(v, w, op);
}
</t>
<t tx="T296">@ Return:  NULL for exception;  some object not equal to NotImplemented if it is implemented   (this latter object may not be a Boolean).
@c

PyObject *
PyObject_RichCompare(PyObject *v, PyObject *w, int op)
{
	PyObject *res;

	assert(Py_LT &lt;= op &amp;&amp; op &lt;= Py_GE);

	compare_nesting++;
	if (compare_nesting &gt; NESTING_LIMIT &amp;&amp;
		(v-&gt;ob_type-&gt;tp_as_mapping
		 || (v-&gt;ob_type-&gt;tp_as_sequence
		     &amp;&amp; !PyString_Check(v)
		     &amp;&amp; !PyTuple_Check(v)))) {

		/* try to detect circular data structures */
		PyObject *token = check_recursion(v, w, op);
		if (token == NULL) {
			res = NULL;
			goto Done;
		}
		else if (token == Py_None) {
			/* already comparing these objects with this operator.
			   assume they're equal until shown otherwise */
			if (op == Py_EQ)
				res = Py_True;
			else if (op == Py_NE)
				res = Py_False;
			else {
				PyErr_SetString(PyExc_ValueError,
					"can't order recursive values");
				res = NULL;
			}
			Py_XINCREF(res);
		}
		else {
			res = do_richcmp(v, w, op);
			delete_token(token);
		}
		goto Done;
	}

	/* No nesting extremism.
	   If the types are equal, and not old-style instances, try to
	   get out cheap (don't bother with coercions etc.). */
	if (v-&gt;ob_type == w-&gt;ob_type &amp;&amp; !PyInstance_Check(v)) {
		cmpfunc fcmp;
		richcmpfunc frich = RICHCOMPARE(v-&gt;ob_type);
		/* If the type has richcmp, try it first.  try_rich_compare
		   tries it two-sided, which is not needed since we've a
		   single type only. */
		if (frich != NULL) {
			res = (*frich)(v, w, op);
			if (res != Py_NotImplemented)
				goto Done;
			Py_DECREF(res);
		}
		/* No richcmp, or this particular richmp not implemented.
		   Try 3-way cmp. */
		fcmp = v-&gt;ob_type-&gt;tp_compare;
		if (fcmp != NULL) {
			int c = (*fcmp)(v, w);
			if (c &lt; 0 &amp;&amp; PyErr_Occurred()) {
				res = NULL;
				goto Done;
			}
			res = convert_3way_to_object(op, c);
			goto Done;
		}
	}

	/* Fast path not taken, or couldn't deliver a useful result. */
	res = do_richcmp(v, w, op);
Done:
	compare_nesting--;
	return res;
}
</t>
<t tx="T297">@ Return -1 if error; 1 if v op w; 0 if not (v op w).
@c

int
PyObject_RichCompareBool(PyObject *v, PyObject *w, int op)
{
	PyObject *res = PyObject_RichCompare(v, w, op);
	int ok;

	if (res == NULL)
		return -1;
	ok = PyObject_IsTrue(res);
	Py_DECREF(res);
	return ok;
}
</t>
<t tx="T298">@ Set of hash utility functions to help maintaining the invariant that iff a==b then hash(a)==hash(b)   All the utility functions (_Py_Hash*()) return "-1" to signify an error.
@c

long
_Py_HashDouble(double v)
{
	double intpart, fractpart;
	int expo;
	long hipart;
	long x;		/* the final hash value */
	/* This is designed so that Python numbers of different types
	 * that compare equal hash to the same value; otherwise comparisons
	 * of mapping keys will turn out weird.
	 */

#ifdef MPW /* MPW C modf expects pointer to extended as second argument */
{
	extended e;
	fractpart = modf(v, &amp;e);
	intpart = e;
}
#else
	fractpart = modf(v, &amp;intpart);
#endif
	if (fractpart == 0.0) {
		/* This must return the same hash as an equal int or long. */
		if (intpart &gt; LONG_MAX || -intpart &gt; LONG_MAX) {
			/* Convert to long and use its hash. */
			PyObject *plong;	/* converted to Python long */
			if (Py_IS_INFINITY(intpart))
				/* can't convert to long int -- arbitrary */
				v = v &lt; 0 ? -271828.0 : 314159.0;
			plong = PyLong_FromDouble(v);
			if (plong == NULL)
				return -1;
			x = PyObject_Hash(plong);
			Py_DECREF(plong);
			return x;
		}
		/* Fits in a C long == a Python int, so is its own hash. */
		x = (long)intpart;
		if (x == -1)
			x = -2;
		return x;
	}
	/* The fractional part is non-zero, so we don't have to worry about
	 * making this match the hash of some other type.
	 * Use frexp to get at the bits in the double.
	 * Since the VAX D double format has 56 mantissa bits, which is the
	 * most of any double format in use, each of these parts may have as
	 * many as (but no more than) 56 significant bits.
	 * So, assuming sizeof(long) &gt;= 4, each part can be broken into two
	 * longs; frexp and multiplication are used to do that.
	 * Also, since the Cray double format has 15 exponent bits, which is
	 * the most of any double format in use, shifting the exponent field
	 * left by 15 won't overflow a long (again assuming sizeof(long) &gt;= 4).
	 */
	v = frexp(v, &amp;expo);
	v *= 2147483648.0;	/* 2**31 */
	hipart = (long)v;	/* take the top 32 bits */
	v = (v - (double)hipart) * 2147483648.0; /* get the next 32 bits */
	x = hipart + (long)v + (expo &lt;&lt; 15);
	if (x == -1)
		x = -2;
	return x;
}
</t>
<t tx="T299">long
_Py_HashPointer(void *p)
{
#if SIZEOF_LONG &gt;= SIZEOF_VOID_P
	return (long)p;
#else
	/* convert to a Python long and hash that */
	PyObject* longobj;
	long x;
	
	if ((longobj = PyLong_FromVoidPtr(p)) == NULL) {
		x = -1;
		goto finally;
	}
	x = PyObject_Hash(longobj);
	
finally:
	Py_XDECREF(longobj);
	return x;
#endif
}
</t>
<t tx="T300">long
PyObject_Hash(PyObject *v)
{
	PyTypeObject *tp = v-&gt;ob_type;
	if (tp-&gt;tp_hash != NULL)
		return (*tp-&gt;tp_hash)(v);
	if (tp-&gt;tp_compare == NULL &amp;&amp; RICHCOMPARE(tp) == NULL) {
		return _Py_HashPointer(v); /* Use address as hash value */
	}
	/* If there's a cmp but no hash defined, the object can't be hashed */
	PyErr_SetString(PyExc_TypeError, "unhashable type");
	return -1;
}
</t>
<t tx="T301">PyObject *
PyObject_GetAttrString(PyObject *v, char *name)
{
	PyObject *w, *res;

	if (v-&gt;ob_type-&gt;tp_getattr != NULL)
		return (*v-&gt;ob_type-&gt;tp_getattr)(v, name);
	w = PyString_InternFromString(name);
	if (w == NULL)
		return NULL;
	res = PyObject_GetAttr(v, w);
	Py_XDECREF(w);
	return res;
}
</t>
<t tx="T302">int
PyObject_HasAttrString(PyObject *v, char *name)
{
	PyObject *res = PyObject_GetAttrString(v, name);
	if (res != NULL) {
		Py_DECREF(res);
		return 1;
	}
	PyErr_Clear();
	return 0;
}
</t>
<t tx="T303">int
PyObject_SetAttrString(PyObject *v, char *name, PyObject *w)
{
	PyObject *s;
	int res;

	if (v-&gt;ob_type-&gt;tp_setattr != NULL)
		return (*v-&gt;ob_type-&gt;tp_setattr)(v, name, w);
	s = PyString_InternFromString(name);
	if (s == NULL)
		return -1;
	res = PyObject_SetAttr(v, s, w);
	Py_XDECREF(s);
	return res;
}
</t>
<t tx="T304">PyObject *
PyObject_GetAttr(PyObject *v, PyObject *name)
{
	PyTypeObject *tp = v-&gt;ob_type;

#ifdef Py_USING_UNICODE
	/* The Unicode to string conversion is done here because the
	   existing tp_getattro slots expect a string object as name
	   and we wouldn't want to break those. */
	if (PyUnicode_Check(name)) {
		name = _PyUnicode_AsDefaultEncodedString(name, NULL);
		if (name == NULL)
			return NULL;
	}
	else
#endif
	if (!PyString_Check(name)) {
		PyErr_SetString(PyExc_TypeError,
				"attribute name must be string");
		return NULL;
	}
	if (tp-&gt;tp_getattro != NULL)
		return (*tp-&gt;tp_getattro)(v, name);
	if (tp-&gt;tp_getattr != NULL)
		return (*tp-&gt;tp_getattr)(v, PyString_AS_STRING(name));
	PyErr_Format(PyExc_AttributeError,
		     "'%.50s' object has no attribute '%.400s'",
		     tp-&gt;tp_name, PyString_AS_STRING(name));
	return NULL;
}
</t>
<t tx="T305">int
PyObject_HasAttr(PyObject *v, PyObject *name)
{
	PyObject *res = PyObject_GetAttr(v, name);
	if (res != NULL) {
		Py_DECREF(res);
		return 1;
	}
	PyErr_Clear();
	return 0;
}
</t>
<t tx="T306">int
PyObject_SetAttr(PyObject *v, PyObject *name, PyObject *value)
{
	PyTypeObject *tp = v-&gt;ob_type;
	int err;

#ifdef Py_USING_UNICODE
	/* The Unicode to string conversion is done here because the
	   existing tp_setattro slots expect a string object as name
	   and we wouldn't want to break those. */
	if (PyUnicode_Check(name)) {
		name = PyUnicode_AsEncodedString(name, NULL, NULL);
		if (name == NULL)
			return -1;
	}
	else 
#endif
	if (!PyString_Check(name)){
		PyErr_SetString(PyExc_TypeError,
				"attribute name must be string");
		return -1;
	}
	else
		Py_INCREF(name);

	PyString_InternInPlace(&amp;name);
	if (tp-&gt;tp_setattro != NULL) {
		err = (*tp-&gt;tp_setattro)(v, name, value);
		Py_DECREF(name);
		return err;
	}
	if (tp-&gt;tp_setattr != NULL) {
		err = (*tp-&gt;tp_setattr)(v, PyString_AS_STRING(name), value);
		Py_DECREF(name);
		return err;
	}
	Py_DECREF(name);
	if (tp-&gt;tp_getattr == NULL &amp;&amp; tp-&gt;tp_getattro == NULL)
		PyErr_Format(PyExc_TypeError,
			     "'%.100s' object has no attributes "
			     "(%s .%.100s)",
			     tp-&gt;tp_name,
			     value==NULL ? "del" : "assign to",
			     PyString_AS_STRING(name));
	else
		PyErr_Format(PyExc_TypeError,
			     "'%.100s' object has only read-only attributes "
			     "(%s .%.100s)",
			     tp-&gt;tp_name,
			     value==NULL ? "del" : "assign to",
			     PyString_AS_STRING(name));
	return -1;
}
</t>
<t tx="T307">@ Helper to get a pointer to an object's __dict__ slot, if any
@c

PyObject **
_PyObject_GetDictPtr(PyObject *obj)
{
	long dictoffset;
	PyTypeObject *tp = obj-&gt;ob_type;

	if (!(tp-&gt;tp_flags &amp; Py_TPFLAGS_HAVE_CLASS))
		return NULL;
	dictoffset = tp-&gt;tp_dictoffset;
	if (dictoffset == 0)
		return NULL;
	if (dictoffset &lt; 0) {
		int tsize;
		size_t size;

		tsize = ((PyVarObject *)obj)-&gt;ob_size;
		if (tsize &lt; 0)
			tsize = -tsize;
		size = _PyObject_VAR_SIZE(tp, tsize);

		dictoffset += (long)size;
		assert(dictoffset &gt; 0);
		assert(dictoffset % SIZEOF_VOID_P == 0);
	}
	return (PyObject **) ((char *)obj + dictoffset);
}
</t>
<t tx="T308">@ Generic GetAttr functions - put these in your tp_[gs]etattro slot
@c

PyObject *
PyObject_GenericGetAttr(PyObject *obj, PyObject *name)
{
	PyTypeObject *tp = obj-&gt;ob_type;
	PyObject *descr;
	PyObject *res = NULL;
	descrgetfunc f;
	PyObject **dictptr;

#ifdef Py_USING_UNICODE
	/* The Unicode to string conversion is done here because the
	   existing tp_setattro slots expect a string object as name
	   and we wouldn't want to break those. */
	if (PyUnicode_Check(name)) {
		name = PyUnicode_AsEncodedString(name, NULL, NULL);
		if (name == NULL)
			return NULL;
	}
	else 
#endif
	if (!PyString_Check(name)){
		PyErr_SetString(PyExc_TypeError,
				"attribute name must be string");
		return NULL;
	}
	else
		Py_INCREF(name);

	if (tp-&gt;tp_dict == NULL) {
		if (PyType_Ready(tp) &lt; 0)
			goto done;
	}

	descr = _PyType_Lookup(tp, name);
	f = NULL;
	if (descr != NULL) {
		f = descr-&gt;ob_type-&gt;tp_descr_get;
		if (f != NULL &amp;&amp; PyDescr_IsData(descr)) {
			res = f(descr, obj, (PyObject *)obj-&gt;ob_type);
			goto done;
		}
	}

	dictptr = _PyObject_GetDictPtr(obj);
	if (dictptr != NULL) {
		PyObject *dict = *dictptr;
		if (dict != NULL) {
			res = PyDict_GetItem(dict, name);
			if (res != NULL) {
				Py_INCREF(res);
				goto done;
			}
		}
	}

	if (f != NULL) {
		res = f(descr, obj, (PyObject *)obj-&gt;ob_type);
		goto done;
	}

	if (descr != NULL) {
		Py_INCREF(descr);
		res = descr;
		goto done;
	}

	PyErr_Format(PyExc_AttributeError,
		     "'%.50s' object has no attribute '%.400s'",
		     tp-&gt;tp_name, PyString_AS_STRING(name));
  done:
	Py_DECREF(name);
	return res;
}
</t>
<t tx="T309">int
PyObject_GenericSetAttr(PyObject *obj, PyObject *name, PyObject *value)
{
	PyTypeObject *tp = obj-&gt;ob_type;
	PyObject *descr;
	descrsetfunc f;
	PyObject **dictptr;
	int res = -1;

#ifdef Py_USING_UNICODE
	/* The Unicode to string conversion is done here because the
	   existing tp_setattro slots expect a string object as name
	   and we wouldn't want to break those. */
	if (PyUnicode_Check(name)) {
		name = PyUnicode_AsEncodedString(name, NULL, NULL);
		if (name == NULL)
			return -1;
	}
	else 
#endif
	if (!PyString_Check(name)){
		PyErr_SetString(PyExc_TypeError,
				"attribute name must be string");
		return -1;
	}
	else
		Py_INCREF(name);

	if (tp-&gt;tp_dict == NULL) {
		if (PyType_Ready(tp) &lt; 0)
			goto done;
	}

	descr = _PyType_Lookup(tp, name);
	f = NULL;
	if (descr != NULL) {
		f = descr-&gt;ob_type-&gt;tp_descr_set;
		if (f != NULL &amp;&amp; PyDescr_IsData(descr)) {
			res = f(descr, obj, value);
			goto done;
		}
	}

	dictptr = _PyObject_GetDictPtr(obj);
	if (dictptr != NULL) {
		PyObject *dict = *dictptr;
		if (dict == NULL &amp;&amp; value != NULL) {
			dict = PyDict_New();
			if (dict == NULL)
				goto done;
			*dictptr = dict;
		}
		if (dict != NULL) {
			if (value == NULL)
				res = PyDict_DelItem(dict, name);
			else
				res = PyDict_SetItem(dict, name, value);
			if (res &lt; 0 &amp;&amp; PyErr_ExceptionMatches(PyExc_KeyError))
				PyErr_SetObject(PyExc_AttributeError, name);
			goto done;
		}
	}

	if (f != NULL) {
		res = f(descr, obj, value);
		goto done;
	}

	if (descr == NULL) {
		PyErr_Format(PyExc_AttributeError,
			     "'%.50s' object has no attribute '%.400s'",
			     tp-&gt;tp_name, PyString_AS_STRING(name));
		goto done;
	}

	PyErr_Format(PyExc_AttributeError,
		     "'%.50s' object attribute '%.400s' is read-only",
		     tp-&gt;tp_name, PyString_AS_STRING(name));
  done:
	Py_DECREF(name);
	return res;
}
</t>
<t tx="T310">@ Test a value used as condition, e.g., in a for or if statement.  Return -1 if an error occurred
@c

int
PyObject_IsTrue(PyObject *v)
{
	int res;
	if (v == Py_None)
		res = 0;
	else if (v-&gt;ob_type-&gt;tp_as_number != NULL &amp;&amp;
		 v-&gt;ob_type-&gt;tp_as_number-&gt;nb_nonzero != NULL)
		res = (*v-&gt;ob_type-&gt;tp_as_number-&gt;nb_nonzero)(v);
	else if (v-&gt;ob_type-&gt;tp_as_mapping != NULL &amp;&amp;
		 v-&gt;ob_type-&gt;tp_as_mapping-&gt;mp_length != NULL)
		res = (*v-&gt;ob_type-&gt;tp_as_mapping-&gt;mp_length)(v);
	else if (v-&gt;ob_type-&gt;tp_as_sequence != NULL &amp;&amp;
		 v-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_length != NULL)
		res = (*v-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_length)(v);
	else
		res = 1;
	if (res &gt; 0)
		res = 1;
	return res;
}
</t>
<t tx="T311">@ equivalent of 'not v'   Return -1 if an error occurred
@c

int
PyObject_Not(PyObject *v)
{
	int res;
	res = PyObject_IsTrue(v);
	if (res &lt; 0)
		return res;
	return res == 0;
}
</t>
<t tx="T312">@ Coerce two numeric types to the "larger" one.  Increment the reference count on each argument.  Return value:  -1 if an error occurred;  0 if the coercion succeeded (and then the reference counts are increased);  1 if no coercion is possible (and no error is raised).
@c

int
PyNumber_CoerceEx(PyObject **pv, PyObject **pw)
{
	register PyObject *v = *pv;
	register PyObject *w = *pw;
	int res;

	if (v-&gt;ob_type == w-&gt;ob_type &amp;&amp; !PyInstance_Check(v)) {
		Py_INCREF(v);
		Py_INCREF(w);
		return 0;
	}
	if (v-&gt;ob_type-&gt;tp_as_number &amp;&amp; v-&gt;ob_type-&gt;tp_as_number-&gt;nb_coerce) {
		res = (*v-&gt;ob_type-&gt;tp_as_number-&gt;nb_coerce)(pv, pw);
		if (res &lt;= 0)
			return res;
	}
	if (w-&gt;ob_type-&gt;tp_as_number &amp;&amp; w-&gt;ob_type-&gt;tp_as_number-&gt;nb_coerce) {
		res = (*w-&gt;ob_type-&gt;tp_as_number-&gt;nb_coerce)(pw, pv);
		if (res &lt;= 0)
			return res;
	}
	return 1;
}
</t>
<t tx="T313">@ Coerce two numeric types to the "larger" one.  Increment the reference count on each argument.  Return -1 and raise an exception if no coercion is possible  (and then no reference count is incremented).
@c

int
PyNumber_Coerce(PyObject **pv, PyObject **pw)
{
	int err = PyNumber_CoerceEx(pv, pw);
	if (err &lt;= 0)
		return err;
	PyErr_SetString(PyExc_TypeError, "number coercion failed");
	return -1;
}
</t>
<t tx="T314">@ Test whether an object can be called
@c

int
PyCallable_Check(PyObject *x)
{
	if (x == NULL)
		return 0;
	if (PyInstance_Check(x)) {
		PyObject *call = PyObject_GetAttrString(x, "__call__");
		if (call == NULL) {
			PyErr_Clear();
			return 0;
		}
		/* Could test recursively but don't, for fear of endless
		   recursion if some joker sets self.__call__ = self */
		Py_DECREF(call);
		return 1;
	}
	else {
		return x-&gt;ob_type-&gt;tp_call != NULL;
	}
}
</t>
<t tx="T315">@ Helper for PyObject_Dir.  Merge the __dict__ of aclass into dict, and recursively also all  the __dict__s of aclass's base classes. The order of merging isn't  defined, as it's expected that only the final set of dict keys is  interesting.  Return 0 on success, -1 on error.
@c

static int
merge_class_dict(PyObject* dict, PyObject* aclass)
{
	PyObject *classdict;
	PyObject *bases;

	assert(PyDict_Check(dict));
	assert(aclass);

	/* Merge in the type's dict (if any). */
	classdict = PyObject_GetAttrString(aclass, "__dict__");
	if (classdict == NULL)
		PyErr_Clear();
	else {
		int status = PyDict_Update(dict, classdict);
		Py_DECREF(classdict);
		if (status &lt; 0)
			return -1;
	}

	/* Recursively merge in the base types' (if any) dicts. */
	bases = PyObject_GetAttrString(aclass, "__bases__");
	if (bases == NULL)
		PyErr_Clear();
	else {
		int i, n;
		assert(PyTuple_Check(bases));
		n = PyTuple_GET_SIZE(bases);
		for (i = 0; i &lt; n; i++) {
			PyObject *base = PyTuple_GET_ITEM(bases, i);
			if (merge_class_dict(dict, base) &lt; 0) {
				Py_DECREF(bases);
				return -1;
			}
		}
		Py_DECREF(bases);
	}
	return 0;
}
</t>
<t tx="T316">@ Helper for PyObject_Dir.  If obj has an attr named attrname that's a list, merge its string  elements into keys of dict.  Return 0 on success, -1 on error. Errors due to not finding the attr,  or the attr not being a list, are suppressed.
@c

static int
merge_list_attr(PyObject* dict, PyObject* obj, char *attrname)
{
	PyObject *list;
	int result = 0;

	assert(PyDict_Check(dict));
	assert(obj);
	assert(attrname);

	list = PyObject_GetAttrString(obj, attrname);
	if (list == NULL)
		PyErr_Clear();

	else if (PyList_Check(list)) {
		int i;
		for (i = 0; i &lt; PyList_GET_SIZE(list); ++i) {
			PyObject *item = PyList_GET_ITEM(list, i);
			if (PyString_Check(item)) {
				result = PyDict_SetItem(dict, item, Py_None);
				if (result &lt; 0)
					break;
			}
		}
	}

	Py_XDECREF(list);
	return result;
}
</t>
<t tx="T317">@ Like __builtin__.dir(arg). See bltinmodule.c's builtin_dir for the  docstring, which should be kept in synch with this implementation.
@c

PyObject *
PyObject_Dir(PyObject *arg)
{
	/* Set exactly one of these non-NULL before the end. */
	PyObject *result = NULL;	/* result list */
	PyObject *masterdict = NULL;	/* result is masterdict.keys() */

	/* If NULL arg, return the locals. */
	if (arg == NULL) {
		PyObject *locals = PyEval_GetLocals();
		if (locals == NULL)
			goto error;
		result = PyDict_Keys(locals);
		if (result == NULL)
			goto error;
	}

	/* Elif this is some form of module, we only want its dict. */
	else if (PyModule_Check(arg)) {
		masterdict = PyObject_GetAttrString(arg, "__dict__");
		if (masterdict == NULL)
			goto error;
		if (!PyDict_Check(masterdict)) {
			PyErr_SetString(PyExc_TypeError,
					"module.__dict__ is not a dictionary");
			goto error;
		}
	}

	/* Elif some form of type or class, grab its dict and its bases.
	   We deliberately don't suck up its __class__, as methods belonging
	   to the metaclass would probably be more confusing than helpful. */
	else if (PyType_Check(arg) || PyClass_Check(arg)) {
		masterdict = PyDict_New();
		if (masterdict == NULL)
			goto error;
		if (merge_class_dict(masterdict, arg) &lt; 0)
			goto error;
	}

	/* Else look at its dict, and the attrs reachable from its class. */
	else {
		PyObject *itsclass;
		/* Create a dict to start with.  CAUTION:  Not everything
		   responding to __dict__ returns a dict! */
		masterdict = PyObject_GetAttrString(arg, "__dict__");
		if (masterdict == NULL) {
			PyErr_Clear();
			masterdict = PyDict_New();
		}
		else if (!PyDict_Check(masterdict)) {
			Py_DECREF(masterdict);
			masterdict = PyDict_New();
		}
		else {
			/* The object may have returned a reference to its
			   dict, so copy it to avoid mutating it. */
			PyObject *temp = PyDict_Copy(masterdict);
			Py_DECREF(masterdict);
			masterdict = temp;
		}
		if (masterdict == NULL)
			goto error;

		/* Merge in __members__ and __methods__ (if any).
		   XXX Would like this to go away someday; for now, it's
		   XXX needed to get at im_self etc of method objects. */
		if (merge_list_attr(masterdict, arg, "__members__") &lt; 0)
			goto error;
		if (merge_list_attr(masterdict, arg, "__methods__") &lt; 0)
			goto error;

		/* Merge in attrs reachable from its class.
		   CAUTION:  Not all objects have a __class__ attr. */
		itsclass = PyObject_GetAttrString(arg, "__class__");
		if (itsclass == NULL)
			PyErr_Clear();
		else {
			int status = merge_class_dict(masterdict, itsclass);
			Py_DECREF(itsclass);
			if (status &lt; 0)
				goto error;
		}
	}

	assert((result == NULL) ^ (masterdict == NULL));
	if (masterdict != NULL) {
		/* The result comes from its keys. */
		assert(result == NULL);
		result = PyDict_Keys(masterdict);
		if (result == NULL)
			goto error;
	}

	assert(result);
	if (PyList_Sort(result) != 0)
		goto error;
	else
		goto normal_return;

  error:
	Py_XDECREF(result);
	result = NULL;
	/* fall through */
  normal_return:
  	Py_XDECREF(masterdict);
	return result;
}
</t>
<t tx="T318">@ NoObject is usable as a non-NULL undefined value, used by the macro None. There is (and should be!) no way to create other objects of this type, so there is exactly one (which is indestructible, by the way). (XXX This type and the type of NotImplemented below should be unified.)
ARGSUSED
@c

static PyObject *
none_repr(PyObject *op)
{
	return PyString_FromString("None");
}
</t>
<t tx="T319">@ ARGUSED
@c

static void
none_dealloc(PyObject* ignore) 
{
	/* This should never get called, but we also don't want to SEGV if
	 * we accidently decref None out of existance.
	 */
	abort();
}
</t>
<t tx="T320">static PyTypeObject PyNone_Type = {
	PyObject_HEAD_INIT(&amp;PyType_Type)
	0,
	"NoneType",
	0,
	0,
	(destructor)none_dealloc,	     /*tp_dealloc*/ /*never called*/
	0,		/*tp_print*/
	0,		/*tp_getattr*/
	0,		/*tp_setattr*/
	0,		/*tp_compare*/
	(reprfunc)none_repr, /*tp_repr*/
	0,		/*tp_as_number*/
	0,		/*tp_as_sequence*/
	0,		/*tp_as_mapping*/
	0,		/*tp_hash */
};

PyObject _Py_NoneStruct = {
	PyObject_HEAD_INIT(&amp;PyNone_Type)
};

/* NotImplemented is an object that can be used to signal that an
   operation is not implemented for the given type combination. */

static PyObject *
NotImplemented_repr(PyObject *op)
{
	return PyString_FromString("NotImplemented");
}
</t>
<t tx="T321">static PyTypeObject PyNotImplemented_Type = {
	PyObject_HEAD_INIT(&amp;PyType_Type)
	0,
	"NotImplementedType",
	0,
	0,
	(destructor)none_dealloc,	     /*tp_dealloc*/ /*never called*/
	0,		/*tp_print*/
	0,		/*tp_getattr*/
	0,		/*tp_setattr*/
	0,		/*tp_compare*/
	(reprfunc)NotImplemented_repr, /*tp_repr*/
	0,		/*tp_as_number*/
	0,		/*tp_as_sequence*/
	0,		/*tp_as_mapping*/
	0,		/*tp_hash */
};

PyObject _Py_NotImplementedStruct = {
	PyObject_HEAD_INIT(&amp;PyNotImplemented_Type)
};

void
_Py_ReadyTypes(void)
{
	if (PyType_Ready(&amp;PyType_Type) &lt; 0)
		Py_FatalError("Can't initialize 'type'");

	if (PyType_Ready(&amp;PyList_Type) &lt; 0)
		Py_FatalError("Can't initialize 'list'");

	if (PyType_Ready(&amp;PyNone_Type) &lt; 0)
		Py_FatalError("Can't initialize type(None)");

	if (PyType_Ready(&amp;PyNotImplemented_Type) &lt; 0)
		Py_FatalError("Can't initialize type(NotImplemented)");
}
</t>
<t tx="T322">#ifdef Py_TRACE_REFS

static PyObject refchain = {&amp;refchain, &amp;refchain};

void
_Py_ResetReferences(void)
{
	refchain._ob_prev = refchain._ob_next = &amp;refchain;
	_Py_RefTotal = 0;
}
</t>
<t tx="T323">void
_Py_NewReference(PyObject *op)
{
	_Py_RefTotal++;
	op-&gt;ob_refcnt = 1;
	op-&gt;_ob_next = refchain._ob_next;
	op-&gt;_ob_prev = &amp;refchain;
	refchain._ob_next-&gt;_ob_prev = op;
	refchain._ob_next = op;
#ifdef COUNT_ALLOCS
	inc_count(op-&gt;ob_type);
#endif
}
</t>
<t tx="T324">void
_Py_ForgetReference(register PyObject *op)
{
#ifdef SLOW_UNREF_CHECK
        register PyObject *p;
#endif
	if (op-&gt;ob_refcnt &lt; 0)
		Py_FatalError("UNREF negative refcnt");
	if (op == &amp;refchain ||
	    op-&gt;_ob_prev-&gt;_ob_next != op || op-&gt;_ob_next-&gt;_ob_prev != op)
		Py_FatalError("UNREF invalid object");
#ifdef SLOW_UNREF_CHECK
	for (p = refchain._ob_next; p != &amp;refchain; p = p-&gt;_ob_next) {
		if (p == op)
			break;
	}
	if (p == &amp;refchain) /* Not found */
		Py_FatalError("UNREF unknown object");
#endif
	op-&gt;_ob_next-&gt;_ob_prev = op-&gt;_ob_prev;
	op-&gt;_ob_prev-&gt;_ob_next = op-&gt;_ob_next;
	op-&gt;_ob_next = op-&gt;_ob_prev = NULL;
#ifdef COUNT_ALLOCS
	op-&gt;ob_type-&gt;tp_frees++;
#endif
}
</t>
<t tx="T325">void
_Py_Dealloc(PyObject *op)
{
	destructor dealloc = op-&gt;ob_type-&gt;tp_dealloc;
	_Py_ForgetReference(op);
	(*dealloc)(op);
}
</t>
<t tx="T326">void
_Py_PrintReferences(FILE *fp)
{
	PyObject *op;
	fprintf(fp, "Remaining objects:\n");
	for (op = refchain._ob_next; op != &amp;refchain; op = op-&gt;_ob_next) {
		fprintf(fp, "[%d] ", op-&gt;ob_refcnt);
		if (PyObject_Print(op, fp, 0) != 0)
			PyErr_Clear();
		putc('\n', fp);
	}
}
</t>
<t tx="T327">PyObject *
_Py_GetObjects(PyObject *self, PyObject *args)
{
	int i, n;
	PyObject *t = NULL;
	PyObject *res, *op;

	if (!PyArg_ParseTuple(args, "i|O", &amp;n, &amp;t))
		return NULL;
	op = refchain._ob_next;
	res = PyList_New(0);
	if (res == NULL)
		return NULL;
	for (i = 0; (n == 0 || i &lt; n) &amp;&amp; op != &amp;refchain; i++) {
		while (op == self || op == args || op == res || op == t ||
		       (t != NULL &amp;&amp; op-&gt;ob_type != (PyTypeObject *) t)) {
			op = op-&gt;_ob_next;
			if (op == &amp;refchain)
				return res;
		}
		if (PyList_Append(res, op) &lt; 0) {
			Py_DECREF(res);
			return NULL;
		}
		op = op-&gt;_ob_next;
	}
	return res;
}
</t>
<t tx="T328">#endif


/* Hack to force loading of cobject.o */
PyTypeObject *_Py_cobject_hack = &amp;PyCObject_Type;


/* Hack to force loading of abstract.o */
int (*_Py_abstract_hack)(PyObject *) = &amp;PyObject_Size;


/* Python's malloc wrappers (see pymem.h) */

void *
PyMem_Malloc(size_t nbytes)
{
#if _PyMem_EXTRA &gt; 0
	if (nbytes == 0)
		nbytes = _PyMem_EXTRA;
#endif
	return PyMem_MALLOC(nbytes);
}
</t>
<t tx="T329">void *
PyMem_Realloc(void *p, size_t nbytes)
{
	/* See comment near MALLOC_ZERO_RETURNS_NULL in pyport.h. */
	return PyMem_REALLOC(p, nbytes ? nbytes : 1);
}
</t>
<t tx="T330">void
PyMem_Free(void *p)
{
	PyMem_FREE(p);
}
</t>
<t tx="T331">@ Python's object malloc wrappers (see objimpl.h)
@c

void *
PyObject_Malloc(size_t nbytes)
{
	return PyObject_MALLOC(nbytes);
}
</t>
<t tx="T332">void *
PyObject_Realloc(void *p, size_t nbytes)
{
	return PyObject_REALLOC(p, nbytes);
}
</t>
<t tx="T333">void
PyObject_Free(void *p)
{
	PyObject_FREE(p);
}
</t>
<t tx="T334">@ These methods are used to control infinite recursion in repr, str, print,  etc. Container objects that may recursively contain themselves,  e.g. builtin dictionaries and lists, should used Py_ReprEnter() and  Py_ReprLeave() to avoid infinite recursion.   Py_ReprEnter() returns 0 the first time it is called for a particular  object and 1 every time thereafter. It returns -1 if an exception  occurred. Py_ReprLeave() has no return value.   See dictobject.c and listobject.c for examples of use.
@c

#define KEY "Py_Repr"

int
Py_ReprEnter(PyObject *obj)
{
	PyObject *dict;
	PyObject *list;
	int i;

	dict = PyThreadState_GetDict();
	if (dict == NULL)
		return -1;
	list = PyDict_GetItemString(dict, KEY);
	if (list == NULL) {
		list = PyList_New(0);
		if (list == NULL)
			return -1;
		if (PyDict_SetItemString(dict, KEY, list) &lt; 0)
			return -1;
		Py_DECREF(list);
	}
	i = PyList_GET_SIZE(list);
	while (--i &gt;= 0) {
		if (PyList_GET_ITEM(list, i) == obj)
			return 1;
	}
	PyList_Append(list, obj);
	return 0;
}
</t>
<t tx="T335">void
Py_ReprLeave(PyObject *obj)
{
	PyObject *dict;
	PyObject *list;
	int i;

	dict = PyThreadState_GetDict();
	if (dict == NULL)
		return;
	list = PyDict_GetItemString(dict, KEY);
	if (list == NULL || !PyList_Check(list))
		return;
	i = PyList_GET_SIZE(list);
	/* Count backwards because we always expect obj to be list[-1] */
	while (--i &gt;= 0) {
		if (PyList_GET_ITEM(list, i) == obj) {
			PyList_SetSlice(list, i, i + 1, NULL);
			break;
		}
	}
}
</t>
<t tx="T336">@ trashcan  CT 2k0130  non-recursively destroy nested objects  CT 2k0223  everything is now done in a macro.  CT 2k0305  modified to use functions, after Tim Peter's suggestion.  CT 2k0309  modified to restore a possible error.  CT 2k0325  added better safe than sorry check for threadstate  CT 2k0422  complete rewrite. We now build a chain via ob_type  and save the limited number of types in ob_refcnt.  This is perfect since we don't need any memory.  A patch for free-threading would need just a lock.
@c

#define Py_TRASHCAN_TUPLE       1
#define Py_TRASHCAN_LIST        2
#define Py_TRASHCAN_DICT        3
#define Py_TRASHCAN_FRAME       4
#define Py_TRASHCAN_TRACEBACK   5
/* extend here if other objects want protection */

int _PyTrash_delete_nesting = 0;

PyObject * _PyTrash_delete_later = NULL;

void
_PyTrash_deposit_object(PyObject *op)
{
	int typecode;

	if (PyTuple_Check(op))
		typecode = Py_TRASHCAN_TUPLE;
	else if (PyList_Check(op))
		typecode = Py_TRASHCAN_LIST;
	else if (PyDict_Check(op))
		typecode = Py_TRASHCAN_DICT;
	else if (PyFrame_Check(op))
		typecode = Py_TRASHCAN_FRAME;
	else if (PyTraceBack_Check(op))
		typecode = Py_TRASHCAN_TRACEBACK;
	else /* We have a bug here -- those are the only types in GC */ {
		Py_FatalError("Type not supported in GC -- internal bug");
		return; /* pacify compiler -- execution never here */
	}
	op-&gt;ob_refcnt = typecode;

	op-&gt;ob_type = (PyTypeObject*)_PyTrash_delete_later;
	_PyTrash_delete_later = op;
}
</t>
<t tx="T337">void
_PyTrash_destroy_chain(void)
{
	while (_PyTrash_delete_later) {
		PyObject *shredder = _PyTrash_delete_later;
		_PyTrash_delete_later = (PyObject*) shredder-&gt;ob_type;

		switch (shredder-&gt;ob_refcnt) {
		case Py_TRASHCAN_TUPLE:
			shredder-&gt;ob_type = &amp;PyTuple_Type;
			break;
		case Py_TRASHCAN_LIST:
			shredder-&gt;ob_type = &amp;PyList_Type;
			break;
		case Py_TRASHCAN_DICT:
			shredder-&gt;ob_type = &amp;PyDict_Type;
			break;
		case Py_TRASHCAN_FRAME:
			shredder-&gt;ob_type = &amp;PyFrame_Type;
			break;
		case Py_TRASHCAN_TRACEBACK:
			shredder-&gt;ob_type = &amp;PyTraceBack_Type;
			break;
		}
		_Py_NewReference(shredder);

		++_PyTrash_delete_nesting;
		Py_DECREF(shredder);
		--_PyTrash_delete_nesting;
	}
}
</t>
<t tx="T338">@language c
/* Tuple object implementation */

&lt;&lt; tupleobject #includes &gt;&gt;
&lt;&lt; tupleobject declarations &gt;&gt;
@others
</t>
<t tx="T339">#include "Python.h"
</t>
<t tx="T340">
/* Speed optimization to avoid frequent malloc/free of small tuples */
#ifndef MAXSAVESIZE
#define MAXSAVESIZE	20  /* Largest tuple to save on free list */
#endif
#ifndef MAXSAVEDTUPLES 
#define MAXSAVEDTUPLES  2000  /* Maximum number of tuples of each size to save */
#endif

#if MAXSAVESIZE &gt; 0
/* Entries 1 up to MAXSAVESIZE are free lists, entry 0 is the empty
   tuple () of which at most one instance will be allocated.
*/
static PyTupleObject *free_tuples[MAXSAVESIZE];
static int num_free_tuples[MAXSAVESIZE];
#endif
#ifdef COUNT_ALLOCS
int fast_tuple_allocs;
int tuple_zero_allocs;
</t>
<t tx="T341">#endif

PyObject *
PyTuple_New(register int size)
{
	register int i;
	register PyTupleObject *op;
	if (size &lt; 0) {
		PyErr_BadInternalCall();
		return NULL;
	}
#if MAXSAVESIZE &gt; 0
	if (size == 0 &amp;&amp; free_tuples[0]) {
		op = free_tuples[0];
		Py_INCREF(op);
#ifdef COUNT_ALLOCS
		tuple_zero_allocs++;
#endif
		return (PyObject *) op;
	}
	if (0 &lt; size &amp;&amp; size &lt; MAXSAVESIZE &amp;&amp;
	    (op = free_tuples[size]) != NULL)
	{
		free_tuples[size] = (PyTupleObject *) op-&gt;ob_item[0];
		num_free_tuples[size]--;
#ifdef COUNT_ALLOCS
		fast_tuple_allocs++;
#endif
		/* PyObject_InitVar is inlined */
#ifdef Py_TRACE_REFS
		op-&gt;ob_size = size;
		op-&gt;ob_type = &amp;PyTuple_Type;
#endif
		_Py_NewReference((PyObject *)op);
	}
	else
#endif
	{
		int nbytes = size * sizeof(PyObject *);
		/* Check for overflow */
		if (nbytes / sizeof(PyObject *) != (size_t)size ||
		    (nbytes += sizeof(PyTupleObject) - sizeof(PyObject *))
		    &lt;= 0)
		{
			return PyErr_NoMemory();
		}
		op = PyObject_GC_NewVar(PyTupleObject, &amp;PyTuple_Type, size);
		if (op == NULL)
			return NULL;
	}
	for (i = 0; i &lt; size; i++)
		op-&gt;ob_item[i] = NULL;
#if MAXSAVESIZE &gt; 0
	if (size == 0) {
		free_tuples[0] = op;
		++num_free_tuples[0];
		Py_INCREF(op);	/* extra INCREF so that this is never freed */
	}
#endif
	_PyObject_GC_TRACK(op);
	return (PyObject *) op;
}
</t>
<t tx="T342">int
PyTuple_Size(register PyObject *op)
{
	if (!PyTuple_Check(op)) {
		PyErr_BadInternalCall();
		return -1;
	}
	else
		return ((PyTupleObject *)op)-&gt;ob_size;
}
</t>
<t tx="T343">PyObject *
PyTuple_GetItem(register PyObject *op, register int i)
{
	if (!PyTuple_Check(op)) {
		PyErr_BadInternalCall();
		return NULL;
	}
	if (i &lt; 0 || i &gt;= ((PyTupleObject *)op) -&gt; ob_size) {
		PyErr_SetString(PyExc_IndexError, "tuple index out of range");
		return NULL;
	}
	return ((PyTupleObject *)op) -&gt; ob_item[i];
}
</t>
<t tx="T344">int
PyTuple_SetItem(register PyObject *op, register int i, PyObject *newitem)
{
	register PyObject *olditem;
	register PyObject **p;
	if (!PyTuple_Check(op) || op-&gt;ob_refcnt != 1) {
		Py_XDECREF(newitem);
		PyErr_BadInternalCall();
		return -1;
	}
	if (i &lt; 0 || i &gt;= ((PyTupleObject *)op) -&gt; ob_size) {
		Py_XDECREF(newitem);
		PyErr_SetString(PyExc_IndexError,
				"tuple assignment index out of range");
		return -1;
	}
	p = ((PyTupleObject *)op) -&gt; ob_item + i;
	olditem = *p;
	*p = newitem;
	Py_XDECREF(olditem);
	return 0;
}
</t>
<t tx="T345">@ Methods
@c

static void
tupledealloc(register PyTupleObject *op)
{
	register int i;
	register int len =  op-&gt;ob_size;
	PyObject_GC_UnTrack(op);
	Py_TRASHCAN_SAFE_BEGIN(op)
	if (len &gt; 0) {
		i = len;
		while (--i &gt;= 0)
			Py_XDECREF(op-&gt;ob_item[i]);
#if MAXSAVESIZE &gt; 0
		if (len &lt; MAXSAVESIZE &amp;&amp;
		    num_free_tuples[len] &lt; MAXSAVEDTUPLES &amp;&amp;
		    op-&gt;ob_type == &amp;PyTuple_Type)
		{
			op-&gt;ob_item[0] = (PyObject *) free_tuples[len];
			num_free_tuples[len]++;
			free_tuples[len] = op;
			goto done; /* return */
		}
#endif
	}
	op-&gt;ob_type-&gt;tp_free((PyObject *)op);
done:
	Py_TRASHCAN_SAFE_END(op)
}
</t>
<t tx="T346">static int
tupleprint(PyTupleObject *op, FILE *fp, int flags)
{
	int i;
	fprintf(fp, "(");
	for (i = 0; i &lt; op-&gt;ob_size; i++) {
		if (i &gt; 0)
			fprintf(fp, ", ");
		if (PyObject_Print(op-&gt;ob_item[i], fp, 0) != 0)
			return -1;
	}
	if (op-&gt;ob_size == 1)
		fprintf(fp, ",");
	fprintf(fp, ")");
	return 0;
}
</t>
<t tx="T347">static PyObject *
tuplerepr(PyTupleObject *v)
{
	int i, n;
	PyObject *s, *temp;
	PyObject *pieces, *result = NULL;

	n = v-&gt;ob_size;
	if (n == 0)
		return PyString_FromString("()");

	pieces = PyTuple_New(n);
	if (pieces == NULL)
		return NULL;

	/* Do repr() on each element. */
	for (i = 0; i &lt; n; ++i) {
		s = PyObject_Repr(v-&gt;ob_item[i]);
		if (s == NULL)
			goto Done;
		PyTuple_SET_ITEM(pieces, i, s);
	}

	/* Add "()" decorations to the first and last items. */
	assert(n &gt; 0);
	s = PyString_FromString("(");
	if (s == NULL)
		goto Done;
	temp = PyTuple_GET_ITEM(pieces, 0);
	PyString_ConcatAndDel(&amp;s, temp);
	PyTuple_SET_ITEM(pieces, 0, s);
	if (s == NULL)
		goto Done;

	s = PyString_FromString(n == 1 ? ",)" : ")");
	if (s == NULL)
		goto Done;
	temp = PyTuple_GET_ITEM(pieces, n-1);
	PyString_ConcatAndDel(&amp;temp, s);
	PyTuple_SET_ITEM(pieces, n-1, temp);
	if (temp == NULL)
		goto Done;

	/* Paste them all together with ", " between. */
	s = PyString_FromString(", ");
	if (s == NULL)
		goto Done;
	result = _PyString_Join(s, pieces);
	Py_DECREF(s);	

Done:
	Py_DECREF(pieces);
	return result;
}
</t>
<t tx="T348">static long
tuplehash(PyTupleObject *v)
{
	register long x, y;
	register int len = v-&gt;ob_size;
	register PyObject **p;
	x = 0x345678L;
	p = v-&gt;ob_item;
	while (--len &gt;= 0) {
		y = PyObject_Hash(*p++);
		if (y == -1)
			return -1;
		x = (1000003*x) ^ y;
	}
	x ^= v-&gt;ob_size;
	if (x == -1)
		x = -2;
	return x;
}
</t>
<t tx="T349">static int
tuplelength(PyTupleObject *a)
{
	return a-&gt;ob_size;
}
</t>
<t tx="T350">static int
tuplecontains(PyTupleObject *a, PyObject *el)
{
	int i, cmp;

	for (i = 0; i &lt; a-&gt;ob_size; ++i) {
		cmp = PyObject_RichCompareBool(el, PyTuple_GET_ITEM(a, i),
					       Py_EQ);
		if (cmp &gt; 0)
			return 1;
		else if (cmp &lt; 0)
			return -1;
	}
	return 0;
}
</t>
<t tx="T351">static PyObject *
tupleitem(register PyTupleObject *a, register int i)
{
	if (i &lt; 0 || i &gt;= a-&gt;ob_size) {
		PyErr_SetString(PyExc_IndexError, "tuple index out of range");
		return NULL;
	}
	Py_INCREF(a-&gt;ob_item[i]);
	return a-&gt;ob_item[i];
}
</t>
<t tx="T352">static PyObject *
tupleslice(register PyTupleObject *a, register int ilow, register int ihigh)
{
	register PyTupleObject *np;
	register int i;
	if (ilow &lt; 0)
		ilow = 0;
	if (ihigh &gt; a-&gt;ob_size)
		ihigh = a-&gt;ob_size;
	if (ihigh &lt; ilow)
		ihigh = ilow;
	if (ilow == 0 &amp;&amp; ihigh == a-&gt;ob_size &amp;&amp; PyTuple_CheckExact(a)) {
		Py_INCREF(a);
		return (PyObject *)a;
	}
	np = (PyTupleObject *)PyTuple_New(ihigh - ilow);
	if (np == NULL)
		return NULL;
	for (i = ilow; i &lt; ihigh; i++) {
		PyObject *v = a-&gt;ob_item[i];
		Py_INCREF(v);
		np-&gt;ob_item[i - ilow] = v;
	}
	return (PyObject *)np;
}
</t>
<t tx="T353">PyObject *
PyTuple_GetSlice(PyObject *op, int i, int j)
{
	if (op == NULL || !PyTuple_Check(op)) {
		PyErr_BadInternalCall();
		return NULL;
	}
	return tupleslice((PyTupleObject *)op, i, j);
}
</t>
<t tx="T354">static PyObject *
tupleconcat(register PyTupleObject *a, register PyObject *bb)
{
	register int size;
	register int i;
	PyTupleObject *np;
	if (!PyTuple_Check(bb)) {
		PyErr_Format(PyExc_TypeError,
       		     "can only concatenate tuple (not \"%.200s\") to tuple",
			     bb-&gt;ob_type-&gt;tp_name);
		return NULL;
	}
#define b ((PyTupleObject *)bb)
	size = a-&gt;ob_size + b-&gt;ob_size;
	np = (PyTupleObject *) PyTuple_New(size);
	if (np == NULL) {
		return NULL;
	}
	for (i = 0; i &lt; a-&gt;ob_size; i++) {
		PyObject *v = a-&gt;ob_item[i];
		Py_INCREF(v);
		np-&gt;ob_item[i] = v;
	}
	for (i = 0; i &lt; b-&gt;ob_size; i++) {
		PyObject *v = b-&gt;ob_item[i];
		Py_INCREF(v);
		np-&gt;ob_item[i + a-&gt;ob_size] = v;
	}
	return (PyObject *)np;
#undef b
}
</t>
<t tx="T355">static PyObject *
tuplerepeat(PyTupleObject *a, int n)
{
	int i, j;
	int size;
	PyTupleObject *np;
	PyObject **p;
	if (n &lt; 0)
		n = 0;
	if (a-&gt;ob_size == 0 || n == 1) {
		if (PyTuple_CheckExact(a)) {
			/* Since tuples are immutable, we can return a shared
			   copy in this case */
			Py_INCREF(a);
			return (PyObject *)a;
		}
		if (a-&gt;ob_size == 0)
			return PyTuple_New(0);
	}
	size = a-&gt;ob_size * n;
	if (size/a-&gt;ob_size != n)
		return PyErr_NoMemory();
	np = (PyTupleObject *) PyTuple_New(size);
	if (np == NULL)
		return NULL;
	p = np-&gt;ob_item;
	for (i = 0; i &lt; n; i++) {
		for (j = 0; j &lt; a-&gt;ob_size; j++) {
			*p = a-&gt;ob_item[j];
			Py_INCREF(*p);
			p++;
		}
	}
	return (PyObject *) np;
}
</t>
<t tx="T356">static int
tupletraverse(PyTupleObject *o, visitproc visit, void *arg)
{
	int i, err;
	PyObject *x;

	for (i = o-&gt;ob_size; --i &gt;= 0; ) {
		x = o-&gt;ob_item[i];
		if (x != NULL) {
			err = visit(x, arg);
			if (err)
				return err;
		}
	}
	return 0;
}
</t>
<t tx="T357">static PyObject *
tuplerichcompare(PyObject *v, PyObject *w, int op)
{
	PyTupleObject *vt, *wt;
	int i;
	int vlen, wlen;

	if (!PyTuple_Check(v) || !PyTuple_Check(w)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}

	vt = (PyTupleObject *)v;
	wt = (PyTupleObject *)w;

	vlen = vt-&gt;ob_size;
	wlen = wt-&gt;ob_size;

	/* Note:  the corresponding code for lists has an "early out" test
	 * here when op is EQ or NE and the lengths differ.  That pays there,
	 * but Tim was unable to find any real code where EQ/NE tuple
	 * compares don't have the same length, so testing for it here would
	 * have cost without benefit.
	 */

	/* Search for the first index where items are different.
	 * Note that because tuples are immutable, it's safe to reuse
	 * vlen and wlen across the comparison calls.
	 */
	for (i = 0; i &lt; vlen &amp;&amp; i &lt; wlen; i++) {
		int k = PyObject_RichCompareBool(vt-&gt;ob_item[i],
						 wt-&gt;ob_item[i], Py_EQ);
		if (k &lt; 0)
			return NULL;
		if (!k)
			break;
	}

	if (i &gt;= vlen || i &gt;= wlen) {
		/* No more items to compare -- compare sizes */
		int cmp;
		PyObject *res;
		switch (op) {
		case Py_LT: cmp = vlen &lt;  wlen; break;
		case Py_LE: cmp = vlen &lt;= wlen; break;
		case Py_EQ: cmp = vlen == wlen; break;
		case Py_NE: cmp = vlen != wlen; break;
		case Py_GT: cmp = vlen &gt;  wlen; break;
		case Py_GE: cmp = vlen &gt;= wlen; break;
		default: return NULL; /* cannot happen */
		}
		if (cmp)
			res = Py_True;
		else
			res = Py_False;
		Py_INCREF(res);
		return res;
	}

	/* We have an item that differs -- shortcuts for EQ/NE */
	if (op == Py_EQ) {
		Py_INCREF(Py_False);
		return Py_False;
	}
	if (op == Py_NE) {
		Py_INCREF(Py_True);
		return Py_True;
	}

	/* Compare the final item again using the proper operator */
	return PyObject_RichCompare(vt-&gt;ob_item[i], wt-&gt;ob_item[i], op);
}
</t>
<t tx="T358">staticforward PyObject *
tuple_subtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds);

static PyObject *
tuple_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
	PyObject *arg = NULL;
	static char *kwlist[] = {"sequence", 0};

	if (type != &amp;PyTuple_Type)
		return tuple_subtype_new(type, args, kwds);
	if (!PyArg_ParseTupleAndKeywords(args, kwds, "|O:tuple", kwlist, &amp;arg))
		return NULL;

	if (arg == NULL)
		return PyTuple_New(0);
	else
		return PySequence_Tuple(arg);
}
</t>
<t tx="T359">static PyObject *
tuple_subtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
	PyObject *tmp, *new, *item;
	int i, n;

	assert(PyType_IsSubtype(type, &amp;PyTuple_Type));
	tmp = tuple_new(&amp;PyTuple_Type, args, kwds);
	if (tmp == NULL)
		return NULL;
	assert(PyTuple_Check(tmp));
	new = type-&gt;tp_alloc(type, n = PyTuple_GET_SIZE(tmp));
	if (new == NULL)
		return NULL;
	for (i = 0; i &lt; n; i++) {
		item = PyTuple_GET_ITEM(tmp, i);
		Py_INCREF(item);
		PyTuple_SET_ITEM(new, i, item);
	}
	Py_DECREF(tmp);
	return new;
}
</t>
<t tx="T360">static char tuple_doc[] =
"tuple() -&gt; an empty tuple\n"
"tuple(sequence) -&gt; tuple initialized from sequence's items\n"
"\n"
"If the argument is a tuple, the return value is the same object.";

static PySequenceMethods tuple_as_sequence = {
	(inquiry)tuplelength,			/* sq_length */
	(binaryfunc)tupleconcat,		/* sq_concat */
	(intargfunc)tuplerepeat,		/* sq_repeat */
	(intargfunc)tupleitem,			/* sq_item */
	(intintargfunc)tupleslice,		/* sq_slice */
	0,					/* sq_ass_item */
	0,					/* sq_ass_slice */
	(objobjproc)tuplecontains,		/* sq_contains */
};

PyTypeObject PyTuple_Type = {
	PyObject_HEAD_INIT(&amp;PyType_Type)
	0,
	"tuple",
	sizeof(PyTupleObject) - sizeof(PyObject *),
	sizeof(PyObject *),
	(destructor)tupledealloc,		/* tp_dealloc */
	(printfunc)tupleprint,			/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	(reprfunc)tuplerepr,			/* tp_repr */
	0,					/* tp_as_number */
	&amp;tuple_as_sequence,			/* tp_as_sequence */
	0,					/* tp_as_mapping */
	(hashfunc)tuplehash,			/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	PyObject_GenericGetAttr,		/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
		Py_TPFLAGS_BASETYPE,		/* tp_flags */
	tuple_doc,				/* tp_doc */
 	(traverseproc)tupletraverse,		/* tp_traverse */
	0,					/* tp_clear */
	tuplerichcompare,			/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	0,					/* tp_methods */
	0,					/* tp_members */
	0,					/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,					/* tp_descr_get */
	0,					/* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	tuple_new,				/* tp_new */
	_PyObject_GC_Del,			/* tp_free */
};

/* The following function breaks the notion that tuples are immutable:
   it changes the size of a tuple.  We get away with this only if there
   is only one module referencing the object.  You can also think of it
   as creating a new tuple object and destroying the old one, only more
   efficiently.  In any case, don't use this if the tuple may already be
   known to some other part of the code. */

int
_PyTuple_Resize(PyObject **pv, int newsize)
{
	register PyTupleObject *v;
	register PyTupleObject *sv;
	int i;
	int oldsize;

	v = (PyTupleObject *) *pv;
	if (v == NULL || v-&gt;ob_type != &amp;PyTuple_Type ||
	    (v-&gt;ob_size != 0 &amp;&amp; v-&gt;ob_refcnt != 1)) {
		*pv = 0;
		Py_XDECREF(v);
		PyErr_BadInternalCall();
		return -1;
	}
	oldsize = v-&gt;ob_size;
	if (oldsize == newsize)
		return 0;

	if (oldsize == 0) {
		/* Empty tuples are often shared, so we should never 
		   resize them in-place even if we do own the only
		   (current) reference */
		Py_DECREF(v);
		*pv = PyTuple_New(newsize);
		return *pv == NULL ? -1 : 0;
	}

	/* XXX UNREF/NEWREF interface should be more symmetrical */
#ifdef Py_REF_DEBUG
	--_Py_RefTotal;
#endif
	_PyObject_GC_UNTRACK(v);
	_Py_ForgetReference((PyObject *) v);
	/* DECREF items deleted by shrinkage */
	for (i = newsize; i &lt; oldsize; i++) {
		Py_XDECREF(v-&gt;ob_item[i]);
		v-&gt;ob_item[i] = NULL;
	}
	sv = PyObject_GC_Resize(PyTupleObject, v, newsize);
	if (sv == NULL) {
		*pv = NULL;
		PyObject_GC_Del(v);
		return -1;
	}
	_Py_NewReference((PyObject *) sv);
	/* Zero out items added by growing */
	for (i = oldsize; i &lt; newsize; i++)
		sv-&gt;ob_item[i] = NULL;
	*pv = (PyObject *) sv;
	_PyObject_GC_TRACK(sv);
	return 0;
}
</t>
<t tx="T361">void
PyTuple_Fini(void)
{
#if MAXSAVESIZE &gt; 0
	int i;

	Py_XDECREF(free_tuples[0]);
	free_tuples[0] = NULL;

	for (i = 1; i &lt; MAXSAVESIZE; i++) {
		PyTupleObject *p, *q;
		p = free_tuples[i];
		free_tuples[i] = NULL;
		while (p) {
			q = p;
			p = (PyTupleObject *)(p-&gt;ob_item[0]);
			PyObject_GC_Del(q);
		}
	}
#endif
}
</t>
<t tx="T362">@language c
/* List object implementation */

&lt;&lt; listobject #includes &gt;&gt;
@others

static PySequenceMethods immutable_list_as_sequence = {
	(inquiry)list_length,			/* sq_length */
	(binaryfunc)list_concat,		/* sq_concat */
	(intargfunc)list_repeat,		/* sq_repeat */
	(intargfunc)list_item,			/* sq_item */
	(intintargfunc)list_slice,		/* sq_slice */
	(intobjargproc)immutable_list_ass,	/* sq_ass_item */
	(intintobjargproc)immutable_list_ass,	/* sq_ass_slice */
	(objobjproc)list_contains,		/* sq_contains */
};

static PyTypeObject immutable_list_type = {
	PyObject_HEAD_INIT(&amp;PyType_Type)
	0,
	"list (immutable, during sort)",
	sizeof(PyListObject),
	0,
	0, /* Cannot happen */			/* tp_dealloc */
	(printfunc)list_print,			/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0, /* Won't be called */		/* tp_compare */
	(reprfunc)list_repr,			/* tp_repr */
	0,					/* tp_as_number */
	&amp;immutable_list_as_sequence,		/* tp_as_sequence */
	0,					/* tp_as_mapping */
	list_nohash,				/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	PyObject_GenericGetAttr,		/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */
 	list_doc,				/* tp_doc */
 	(traverseproc)list_traverse,		/* tp_traverse */
	0,					/* tp_clear */
	list_richcompare,			/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	immutable_list_methods,			/* tp_methods */
	0,					/* tp_members */
	0,					/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,					/* tp_descr_get */
	0,					/* tp_descr_set */
	0,					/* tp_init */
	/* NOTE: This is *not* the standard list_type struct! */
};
</t>
<t tx="T363">#include "Python.h"
</t>
<t tx="T364">#ifdef STDC_HEADERS
#include &lt;stddef.h&gt;
#else
#include &lt;sys/types.h&gt;		/* For size_t */
#endif

static int
roundupsize(int n)
{
	unsigned int nbits = 0;
	unsigned int n2 = (unsigned int)n &gt;&gt; 5;

	/* Round up: 
	 * If n &lt;       256, to a multiple of        8.
	 * If n &lt;      2048, to a multiple of       64.
	 * If n &lt;     16384, to a multiple of      512.
	 * If n &lt;    131072, to a multiple of     4096.
	 * If n &lt;   1048576, to a multiple of    32768.
	 * If n &lt;   8388608, to a multiple of   262144.
	 * If n &lt;  67108864, to a multiple of  2097152.
	 * If n &lt; 536870912, to a multiple of 16777216.
	 * ...
	 * If n &lt; 2**(5+3*i), to a multiple of 2**(3*i).
	 *
	 * This over-allocates proportional to the list size, making room
	 * for additional growth.  The over-allocation is mild, but is
	 * enough to give linear-time amortized behavior over a long
	 * sequence of appends() in the presence of a poorly-performing
	 * system realloc() (which is a reality, e.g., across all flavors
	 * of Windows, with Win9x behavior being particularly bad -- and
	 * we've still got address space fragmentation problems on Win9x
	 * even with this scheme, although it requires much longer lists to
	 * provoke them than it used to).
	 */
	do {
		n2 &gt;&gt;= 3;
		nbits += 3;
	} while (n2);
	return ((n &gt;&gt; nbits) + 1) &lt;&lt; nbits;
 }
</t>
<t tx="T365">#define NRESIZE(var, type, nitems) PyMem_RESIZE(var, type, roundupsize(nitems))

PyObject *
PyList_New(int size)
{
	int i;
	PyListObject *op;
	size_t nbytes;
	if (size &lt; 0) {
		PyErr_BadInternalCall();
		return NULL;
	}
	nbytes = size * sizeof(PyObject *);
	/* Check for overflow */
	if (nbytes / sizeof(PyObject *) != (size_t)size) {
		return PyErr_NoMemory();
	}
	op = PyObject_GC_New(PyListObject, &amp;PyList_Type);
	if (op == NULL) {
		return NULL;
	}
	if (size &lt;= 0) {
		op-&gt;ob_item = NULL;
	}
	else {
		op-&gt;ob_item = (PyObject **) PyMem_MALLOC(nbytes);
		if (op-&gt;ob_item == NULL) {
			return PyErr_NoMemory();
		}
	}
	op-&gt;ob_size = size;
	for (i = 0; i &lt; size; i++)
		op-&gt;ob_item[i] = NULL;
	_PyObject_GC_TRACK(op);
	return (PyObject *) op;
}
</t>
<t tx="T366">int
PyList_Size(PyObject *op)
{
	if (!PyList_Check(op)) {
		PyErr_BadInternalCall();
		return -1;
	}
	else
		return ((PyListObject *)op) -&gt; ob_size;
}
</t>
<t tx="T367">static PyObject *indexerr;

PyObject *
PyList_GetItem(PyObject *op, int i)
{
	if (!PyList_Check(op)) {
		PyErr_BadInternalCall();
		return NULL;
	}
	if (i &lt; 0 || i &gt;= ((PyListObject *)op) -&gt; ob_size) {
		if (indexerr == NULL)
			indexerr = PyString_FromString(
				"list index out of range");
		PyErr_SetObject(PyExc_IndexError, indexerr);
		return NULL;
	}
	return ((PyListObject *)op) -&gt; ob_item[i];
}
</t>
<t tx="T368">int
PyList_SetItem(register PyObject *op, register int i,
               register PyObject *newitem)
{
	register PyObject *olditem;
	register PyObject **p;
	if (!PyList_Check(op)) {
		Py_XDECREF(newitem);
		PyErr_BadInternalCall();
		return -1;
	}
	if (i &lt; 0 || i &gt;= ((PyListObject *)op) -&gt; ob_size) {
		Py_XDECREF(newitem);
		PyErr_SetString(PyExc_IndexError,
				"list assignment index out of range");
		return -1;
	}
	p = ((PyListObject *)op) -&gt; ob_item + i;
	olditem = *p;
	*p = newitem;
	Py_XDECREF(olditem);
	return 0;
}
</t>
<t tx="T369">static int
ins1(PyListObject *self, int where, PyObject *v)
{
	int i;
	PyObject **items;
	if (v == NULL) {
		PyErr_BadInternalCall();
		return -1;
	}
	if (self-&gt;ob_size == INT_MAX) {
		PyErr_SetString(PyExc_OverflowError,
			"cannot add more objects to list");
		return -1;
	}
	items = self-&gt;ob_item;
	NRESIZE(items, PyObject *, self-&gt;ob_size+1);
	if (items == NULL) {
		PyErr_NoMemory();
		return -1;
	}
	if (where &lt; 0)
		where = 0;
	if (where &gt; self-&gt;ob_size)
		where = self-&gt;ob_size;
	for (i = self-&gt;ob_size; --i &gt;= where; )
		items[i+1] = items[i];
	Py_INCREF(v);
	items[where] = v;
	self-&gt;ob_item = items;
	self-&gt;ob_size++;
	return 0;
}
</t>
<t tx="T370">int
PyList_Insert(PyObject *op, int where, PyObject *newitem)
{
	if (!PyList_Check(op)) {
		PyErr_BadInternalCall();
		return -1;
	}
	return ins1((PyListObject *)op, where, newitem);
}
</t>
<t tx="T371">int
PyList_Append(PyObject *op, PyObject *newitem)
{
	if (!PyList_Check(op)) {
		PyErr_BadInternalCall();
		return -1;
	}
	return ins1((PyListObject *)op,
		(int) ((PyListObject *)op)-&gt;ob_size, newitem);
}
</t>
<t tx="T372">@ Methods
@c

static void
list_dealloc(PyListObject *op)
{
	int i;
	PyObject_GC_UnTrack(op);
	Py_TRASHCAN_SAFE_BEGIN(op)
	if (op-&gt;ob_item != NULL) {
		/* Do it backwards, for Christian Tismer.
		   There's a simple test case where somehow this reduces
		   thrashing when a *very* large list is created and
		   immediately deleted. */
		i = op-&gt;ob_size;
		while (--i &gt;= 0) {
			Py_XDECREF(op-&gt;ob_item[i]);
		}
		PyMem_FREE(op-&gt;ob_item);
	}
	op-&gt;ob_type-&gt;tp_free((PyObject *)op);
	Py_TRASHCAN_SAFE_END(op)
}
</t>
<t tx="T373">static int
list_print(PyListObject *op, FILE *fp, int flags)
{
	int i;

	i = Py_ReprEnter((PyObject*)op);
	if (i != 0) {
		if (i &lt; 0)
			return i;
		fprintf(fp, "[...]");
		return 0;
	}
	fprintf(fp, "[");
	for (i = 0; i &lt; op-&gt;ob_size; i++) {
		if (i &gt; 0)
			fprintf(fp, ", ");
		if (PyObject_Print(op-&gt;ob_item[i], fp, 0) != 0) {
			Py_ReprLeave((PyObject *)op);
			return -1;
		}
	}
	fprintf(fp, "]");
	Py_ReprLeave((PyObject *)op);
	return 0;
}
</t>
<t tx="T374">static PyObject *
list_repr(PyListObject *v)
{
	int i;
	PyObject *s, *temp;
	PyObject *pieces = NULL, *result = NULL;

	i = Py_ReprEnter((PyObject*)v);
	if (i != 0) {
		return i &gt; 0 ? PyString_FromString("[...]") : NULL;
	}

	if (v-&gt;ob_size == 0) {
		result = PyString_FromString("[]");
		goto Done;
	}

	pieces = PyList_New(0);
	if (pieces == NULL)
		goto Done;

	/* Do repr() on each element.  Note that this may mutate the list,
	   so must refetch the list size on each iteration. */
	for (i = 0; i &lt; v-&gt;ob_size; ++i) {
		int status;
		s = PyObject_Repr(v-&gt;ob_item[i]);
		if (s == NULL)
			goto Done;
		status = PyList_Append(pieces, s);
		Py_DECREF(s);  /* append created a new ref */
		if (status &lt; 0)
			goto Done;
	}

	/* Add "[]" decorations to the first and last items. */
	assert(PyList_GET_SIZE(pieces) &gt; 0);
	s = PyString_FromString("[");
	if (s == NULL)
		goto Done;
	temp = PyList_GET_ITEM(pieces, 0);
	PyString_ConcatAndDel(&amp;s, temp);
	PyList_SET_ITEM(pieces, 0, s);
	if (s == NULL)
		goto Done;

	s = PyString_FromString("]");
	if (s == NULL)
		goto Done;
	temp = PyList_GET_ITEM(pieces, PyList_GET_SIZE(pieces) - 1);
	PyString_ConcatAndDel(&amp;temp, s);
	PyList_SET_ITEM(pieces, PyList_GET_SIZE(pieces) - 1, temp);
	if (temp == NULL)
		goto Done;

	/* Paste them all together with ", " between. */
	s = PyString_FromString(", ");
	if (s == NULL)
		goto Done;
	result = _PyString_Join(s, pieces);
	Py_DECREF(s);	

Done:
	Py_XDECREF(pieces);
	Py_ReprLeave((PyObject *)v);
	return result;
}
</t>
<t tx="T375">static int
list_length(PyListObject *a)
{
	return a-&gt;ob_size;
}
</t>
<t tx="T376">static int
list_contains(PyListObject *a, PyObject *el)
{
	int i;

	for (i = 0; i &lt; a-&gt;ob_size; ++i) {
		int cmp = PyObject_RichCompareBool(el, PyList_GET_ITEM(a, i),
						   Py_EQ);
		if (cmp &gt; 0)
			return 1;
		else if (cmp &lt; 0)
			return -1;
	}
	return 0;
}
</t>
<t tx="T377">static PyObject *
list_item(PyListObject *a, int i)
{
	if (i &lt; 0 || i &gt;= a-&gt;ob_size) {
		if (indexerr == NULL)
			indexerr = PyString_FromString(
				"list index out of range");
		PyErr_SetObject(PyExc_IndexError, indexerr);
		return NULL;
	}
	Py_INCREF(a-&gt;ob_item[i]);
	return a-&gt;ob_item[i];
}
</t>
<t tx="T378">static PyObject *
list_slice(PyListObject *a, int ilow, int ihigh)
{
	PyListObject *np;
	int i;
	if (ilow &lt; 0)
		ilow = 0;
	else if (ilow &gt; a-&gt;ob_size)
		ilow = a-&gt;ob_size;
	if (ihigh &lt; ilow)
		ihigh = ilow;
	else if (ihigh &gt; a-&gt;ob_size)
		ihigh = a-&gt;ob_size;
	np = (PyListObject *) PyList_New(ihigh - ilow);
	if (np == NULL)
		return NULL;
	for (i = ilow; i &lt; ihigh; i++) {
		PyObject *v = a-&gt;ob_item[i];
		Py_INCREF(v);
		np-&gt;ob_item[i - ilow] = v;
	}
	return (PyObject *)np;
}
</t>
<t tx="T379">PyObject *
PyList_GetSlice(PyObject *a, int ilow, int ihigh)
{
	if (!PyList_Check(a)) {
		PyErr_BadInternalCall();
		return NULL;
	}
	return list_slice((PyListObject *)a, ilow, ihigh);
}
</t>
<t tx="T380">static PyObject *
list_concat(PyListObject *a, PyObject *bb)
{
	int size;
	int i;
	PyListObject *np;
	if (!PyList_Check(bb)) {
		PyErr_Format(PyExc_TypeError,
			  "can only concatenate list (not \"%.200s\") to list",
			  bb-&gt;ob_type-&gt;tp_name);
		return NULL;
	}
#define b ((PyListObject *)bb)
	size = a-&gt;ob_size + b-&gt;ob_size;
	np = (PyListObject *) PyList_New(size);
	if (np == NULL) {
		return NULL;
	}
	for (i = 0; i &lt; a-&gt;ob_size; i++) {
		PyObject *v = a-&gt;ob_item[i];
		Py_INCREF(v);
		np-&gt;ob_item[i] = v;
	}
	for (i = 0; i &lt; b-&gt;ob_size; i++) {
		PyObject *v = b-&gt;ob_item[i];
		Py_INCREF(v);
		np-&gt;ob_item[i + a-&gt;ob_size] = v;
	}
	return (PyObject *)np;
#undef b
}
</t>
<t tx="T381">static PyObject *
list_repeat(PyListObject *a, int n)
{
	int i, j;
	int size;
	PyListObject *np;
	PyObject **p;
	if (n &lt; 0)
		n = 0;
	size = a-&gt;ob_size * n;
	np = (PyListObject *) PyList_New(size);
	if (np == NULL)
		return NULL;
	p = np-&gt;ob_item;
	for (i = 0; i &lt; n; i++) {
		for (j = 0; j &lt; a-&gt;ob_size; j++) {
			*p = a-&gt;ob_item[j];
			Py_INCREF(*p);
			p++;
		}
	}
	return (PyObject *) np;
}
</t>
<t tx="T382">static int
list_ass_slice(PyListObject *a, int ilow, int ihigh, PyObject *v)
{
	/* Because [X]DECREF can recursively invoke list operations on
	   this list, we must postpone all [X]DECREF activity until
	   after the list is back in its canonical shape.  Therefore
	   we must allocate an additional array, 'recycle', into which
	   we temporarily copy the items that are deleted from the
	   list. :-( */
	PyObject **recycle, **p;
	PyObject **item;
	int n; /* Size of replacement list */
	int d; /* Change in size */
	int k; /* Loop index */
#define b ((PyListObject *)v)
	if (v == NULL)
		n = 0;
	else if (PyList_Check(v)) {
		n = b-&gt;ob_size;
		if (a == b) {
			/* Special case "a[i:j] = a" -- copy b first */
			int ret;
			v = list_slice(b, 0, n);
			ret = list_ass_slice(a, ilow, ihigh, v);
			Py_DECREF(v);
			return ret;
		}
	}
	else {
		PyErr_Format(PyExc_TypeError,
			     "must assign list (not \"%.200s\") to slice",
			     v-&gt;ob_type-&gt;tp_name);
		return -1;
	}
	if (ilow &lt; 0)
		ilow = 0;
	else if (ilow &gt; a-&gt;ob_size)
		ilow = a-&gt;ob_size;
	if (ihigh &lt; ilow)
		ihigh = ilow;
	else if (ihigh &gt; a-&gt;ob_size)
		ihigh = a-&gt;ob_size;
	item = a-&gt;ob_item;
	d = n - (ihigh-ilow);
	if (ihigh &gt; ilow)
		p = recycle = PyMem_NEW(PyObject *, (ihigh-ilow));
	else
		p = recycle = NULL;
	if (d &lt;= 0) { /* Delete -d items; recycle ihigh-ilow items */
		for (k = ilow; k &lt; ihigh; k++)
			*p++ = item[k];
		if (d &lt; 0) {
			for (/*k = ihigh*/; k &lt; a-&gt;ob_size; k++)
				item[k+d] = item[k];
			a-&gt;ob_size += d;
			NRESIZE(item, PyObject *, a-&gt;ob_size); /* Can't fail */
			a-&gt;ob_item = item;
		}
	}
	else { /* Insert d items; recycle ihigh-ilow items */
		NRESIZE(item, PyObject *, a-&gt;ob_size + d);
		if (item == NULL) {
			if (recycle != NULL)
				PyMem_DEL(recycle);
			PyErr_NoMemory();
			return -1;
		}
		for (k = a-&gt;ob_size; --k &gt;= ihigh; )
			item[k+d] = item[k];
		for (/*k = ihigh-1*/; k &gt;= ilow; --k)
			*p++ = item[k];
		a-&gt;ob_item = item;
		a-&gt;ob_size += d;
	}
	for (k = 0; k &lt; n; k++, ilow++) {
		PyObject *w = b-&gt;ob_item[k];
		Py_XINCREF(w);
		item[ilow] = w;
	}
	if (recycle) {
		while (--p &gt;= recycle)
			Py_XDECREF(*p);
		PyMem_DEL(recycle);
	}
	if (a-&gt;ob_size == 0 &amp;&amp; a-&gt;ob_item != NULL) {
		PyMem_FREE(a-&gt;ob_item);
		a-&gt;ob_item = NULL;
	}
	return 0;
#undef b
}
</t>
<t tx="T383">int
PyList_SetSlice(PyObject *a, int ilow, int ihigh, PyObject *v)
{
	if (!PyList_Check(a)) {
		PyErr_BadInternalCall();
		return -1;
	}
	return list_ass_slice((PyListObject *)a, ilow, ihigh, v);
}
</t>
<t tx="T384">static PyObject *
list_inplace_repeat(PyListObject *self, int n)
{
	PyObject **items;
	int size, i, j;


	size = PyList_GET_SIZE(self);
	if (size == 0) {
		Py_INCREF(self);
		return (PyObject *)self;
	}

	items = self-&gt;ob_item;

	if (n &lt; 1) {
		self-&gt;ob_item = NULL;
		self-&gt;ob_size = 0;
		for (i = 0; i &lt; size; i++)
			Py_XDECREF(items[i]);
		PyMem_DEL(items);
		Py_INCREF(self);
		return (PyObject *)self;
	}

	NRESIZE(items, PyObject*, size*n);
	if (items == NULL) {
		PyErr_NoMemory();
		goto finally;
	}
	self-&gt;ob_item = items;
	for (i = 1; i &lt; n; i++) { /* Start counting at 1, not 0 */
		for (j = 0; j &lt; size; j++) {
			PyObject *o = PyList_GET_ITEM(self, j);
			Py_INCREF(o);
			PyList_SET_ITEM(self, self-&gt;ob_size++, o);
		}
	}
	Py_INCREF(self);
	return (PyObject *)self;
  finally:
  	return NULL;
}
</t>
<t tx="T385">static int
list_ass_item(PyListObject *a, int i, PyObject *v)
{
	PyObject *old_value;
	if (i &lt; 0 || i &gt;= a-&gt;ob_size) {
		PyErr_SetString(PyExc_IndexError,
				"list assignment index out of range");
		return -1;
	}
	if (v == NULL)
		return list_ass_slice(a, i, i+1, v);
	Py_INCREF(v);
	old_value = a-&gt;ob_item[i];
	a-&gt;ob_item[i] = v;
	Py_DECREF(old_value); 
	return 0;
}
</t>
<t tx="T386">static PyObject *
ins(PyListObject *self, int where, PyObject *v)
{
	if (ins1(self, where, v) != 0)
		return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T387">static PyObject *
listinsert(PyListObject *self, PyObject *args)
{
	int i;
	PyObject *v;
	if (!PyArg_ParseTuple(args, "iO:insert", &amp;i, &amp;v))
		return NULL;
	return ins(self, i, v);
}
</t>
<t tx="T388">static PyObject *
listappend(PyListObject *self, PyObject *v)
{
	return ins(self, (int) self-&gt;ob_size, v);
}
</t>
<t tx="T389">static int
listextend_internal(PyListObject *self, PyObject *b)
{
	PyObject **items;
	int selflen = PyList_GET_SIZE(self);
	int blen;
	register int i;

	if (PyObject_Size(b) == 0) {
		/* short circuit when b is empty */
		Py_DECREF(b);
		return 0;
	}

	if (self == (PyListObject*)b) {
		/* as in list_ass_slice() we must special case the
		 * situation: a.extend(a)
		 *
		 * XXX: I think this way ought to be faster than using
		 * list_slice() the way list_ass_slice() does.
		 */
		Py_DECREF(b);
		b = PyList_New(selflen);
		if (!b)
			return -1;
		for (i = 0; i &lt; selflen; i++) {
			PyObject *o = PyList_GET_ITEM(self, i);
			Py_INCREF(o);
			PyList_SET_ITEM(b, i, o);
		}
	}

	blen = PyObject_Size(b);

	/* resize a using idiom */
	items = self-&gt;ob_item;
	NRESIZE(items, PyObject*, selflen + blen);
	if (items == NULL) {
		PyErr_NoMemory();
		Py_DECREF(b);
		return -1;
	}

	self-&gt;ob_item = items;

	/* populate the end of self with b's items */
	for (i = 0; i &lt; blen; i++) {
		PyObject *o = PySequence_Fast_GET_ITEM(b, i);
		Py_INCREF(o);
		PyList_SET_ITEM(self, self-&gt;ob_size++, o);
	}
	Py_DECREF(b);
	return 0;
}
</t>
<t tx="T390">static PyObject *
list_inplace_concat(PyListObject *self, PyObject *other)
{
	other = PySequence_Fast(other, "argument to += must be iterable");
	if (!other)
		return NULL;

	if (listextend_internal(self, other) &lt; 0)
		return NULL;

	Py_INCREF(self);
	return (PyObject *)self;
}
</t>
<t tx="T391">static PyObject *
listextend(PyListObject *self, PyObject *b)
{

	b = PySequence_Fast(b, "list.extend() argument must be iterable");
	if (!b)
		return NULL;

	if (listextend_internal(self, b) &lt; 0)
		return NULL;

	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T392">static PyObject *
listpop(PyListObject *self, PyObject *args)
{
	int i = -1;
	PyObject *v;
	if (!PyArg_ParseTuple(args, "|i:pop", &amp;i))
		return NULL;
	if (self-&gt;ob_size == 0) {
		/* Special-case most common failure cause */
		PyErr_SetString(PyExc_IndexError, "pop from empty list");
		return NULL;
	}
	if (i &lt; 0)
		i += self-&gt;ob_size;
	if (i &lt; 0 || i &gt;= self-&gt;ob_size) {
		PyErr_SetString(PyExc_IndexError, "pop index out of range");
		return NULL;
	}
	v = self-&gt;ob_item[i];
	Py_INCREF(v);
	if (list_ass_slice(self, i, i+1, (PyObject *)NULL) != 0) {
		Py_DECREF(v);
		return NULL;
	}
	return v;
}
</t>
<t tx="T393">@ New quicksort implementation for arrays of object pointers.  Thanks to discussions with Tim Peters.
CMPERROR is returned by our comparison function when an error  occurred. This is the largest negative integer (0x80000000 on a  32-bit system).
@c

#define CMPERROR ( (int) ((unsigned int)1 &lt;&lt; (8*sizeof(int) - 1)) )

/* Comparison function.  Takes care of calling a user-supplied
   comparison function (any callable Python object).  Calls the
   standard comparison function, PyObject_Compare(), if the user-
   supplied function is NULL. */

static int
docompare(PyObject *x, PyObject *y, PyObject *compare)
{
	PyObject *args, *res;
	int i;

	if (compare == NULL) {
		/* NOTE: we rely on the fact here that the sorting algorithm
		   only ever checks whether k&lt;0, i.e., whether x&lt;y.  So we
		   invoke the rich comparison function with Py_LT ('&lt;'), and
		   return -1 when it returns true and 0 when it returns
		   false. */
		i = PyObject_RichCompareBool(x, y, Py_LT);
		if (i &lt; 0)
			return CMPERROR;
		else
			return -i;
	}

	args = Py_BuildValue("(OO)", x, y);
	if (args == NULL)
		return CMPERROR;
	res = PyEval_CallObject(compare, args);
	Py_DECREF(args);
	if (res == NULL)
		return CMPERROR;
	if (!PyInt_Check(res)) {
		Py_DECREF(res);
		PyErr_SetString(PyExc_TypeError,
				"comparison function must return int");
		return CMPERROR;
	}
	i = PyInt_AsLong(res);
	Py_DECREF(res);
	if (i &lt; 0)
		return -1;
	if (i &gt; 0)
		return 1;
	return 0;
}
</t>
<t tx="T394">@ MINSIZE is the smallest array that will get a full-blown samplesort  treatment; smaller arrays are sorted using binary insertion. It must  be at least 7 for the samplesort implementation to work. Binary  insertion does fewer compares, but can suffer O(N**2) data movement.  The more expensive compares, the larger MINSIZE should be.
@c

#define MINSIZE 100

/* MINPARTITIONSIZE is the smallest array slice samplesort will bother to
   partition; smaller slices are passed to binarysort.  It must be at
   least 2, and no larger than MINSIZE.  Setting it higher reduces the #
   of compares slowly, but increases the amount of data movement quickly.
   The value here was chosen assuming a compare costs ~25x more than
   swapping a pair of memory-resident pointers -- but under that assumption,
   changing the value by a few dozen more or less has aggregate effect
   under 1%.  So the value is crucial, but not touchy &lt;wink&gt;. */
#define MINPARTITIONSIZE 40

/* MAXMERGE is the largest number of elements we'll always merge into
   a known-to-be sorted chunk via binary insertion, regardless of the
   size of that chunk.  Given a chunk of N sorted elements, and a group
   of K unknowns, the largest K for which it's better to do insertion
   (than a full-blown sort) is a complicated function of N and K mostly
   involving the expected number of compares and data moves under each
   approach, and the relative cost of those operations on a specific
   architecure.  The fixed value here is conservative, and should be a
   clear win regardless of architecture or N. */
#define MAXMERGE 15

/* STACKSIZE is the size of our work stack.  A rough estimate is that
   this allows us to sort arrays of size N where
   N / ln(N) = MINPARTITIONSIZE * 2**STACKSIZE, so 60 is more than enough
   for arrays of size 2**64.  Because we push the biggest partition
   first, the worst case occurs when all subarrays are always partitioned
   exactly in two. */
#define STACKSIZE 60


#define SETK(X,Y) if ((k = docompare(X,Y,compare))==CMPERROR) goto fail

/* binarysort is the best method for sorting small arrays: it does
   few compares, but can do data movement quadratic in the number of
   elements.
   [lo, hi) is a contiguous slice of a list, and is sorted via
   binary insertion.
   On entry, must have lo &lt;= start &lt;= hi, and that [lo, start) is already
   sorted (pass start == lo if you don't know!).
   If docompare complains (returns CMPERROR) return -1, else 0.
   Even in case of error, the output slice will be some permutation of
   the input (nothing is lost or duplicated).
*/

static int
binarysort(PyObject **lo, PyObject **hi, PyObject **start, PyObject *compare)
     /* compare -- comparison function object, or NULL for default */
{
	/* assert lo &lt;= start &lt;= hi
	   assert [lo, start) is sorted */
	register int k;
	register PyObject **l, **p, **r;
	register PyObject *pivot;

	if (lo == start)
		++start;
	for (; start &lt; hi; ++start) {
		/* set l to where *start belongs */
		l = lo;
		r = start;
		pivot = *r;
		do {
			p = l + ((r - l) &gt;&gt; 1);
			SETK(pivot, *p);
			if (k &lt; 0)
				r = p;
			else
				l = p + 1;
		} while (l &lt; r);
		/* Pivot should go at l -- slide over to make room.
		   Caution: using memmove is much slower under MSVC 5;
		   we're not usually moving many slots. */
		for (p = start; p &gt; l; --p)
			*p = *(p-1);
		*l = pivot;
	}
	return 0;

 fail:
	return -1;
}
</t>
<t tx="T395">@ samplesortslice is the sorting workhorse.  [lo, hi) is a contiguous slice of a list, to be sorted in place.  On entry, must have lo &lt;= hi,  If docompare complains (returns CMPERROR) return -1, else 0.  Even in case of error, the output slice will be some permutation of  the input (nothing is lost or duplicated).   samplesort is basically quicksort on steroids: a power of 2 close  to n/ln(n) is computed, and that many elements (less 1) are picked at  random from the array and sorted. These 2**k - 1 elements are then  used as preselected pivots for an equal number of quicksort  partitioning steps, partitioning the slice into 2**k chunks each of  size about ln(n). These small final chunks are then usually handled  by binarysort. Note that when k=1, this is roughly the same as an  ordinary quicksort using a random pivot, and when k=2 this is roughly  a median-of-3 quicksort. From that view, using k ~= lg(n/ln(n)) makes  this a "median of n/ln(n)" quicksort. You can also view it as a kind  of bucket sort, where 2**k-1 bucket boundaries are picked dynamically.   The large number of samples makes a quadratic-time case almost  impossible, and asymptotically drives the average-case number of  compares from quicksort's 2 N ln N (or 12/7 N ln N for the median-of-  3 variant) down to N lg N.   We also play lots of low-level tricks to cut the number of compares.    Very obscure: To avoid using extra memory, the PPs are stored in the  array and shuffled around as partitioning proceeds. At the start of a  partitioning step, we'll have 2**m-1 (for some m) PPs in sorted order,  adjacent (either on the left or the right!) to a chunk of X elements  that are to be partitioned: P X or X P. In either case we need to  shuffle things *in place* so that the 2**(m-1) smaller PPs are on the  left, followed by the PP to be used for this step (that's the middle  of the PPs), followed by X, followed by the 2**(m-1) larger PPs:    P X or X P -&gt; Psmall pivot X Plarge  and the order of the PPs must not be altered. It can take a while  to realize this isn't trivial! It can take even longer &lt;wink&gt; to  understand why the simple code below works, using only 2**(m-1) swaps.  The key is that the order of the X elements isn't necessarily  preserved: X can end up as some cyclic permutation of its original  order. That's OK, because X is unsorted anyway. If the order of X  had to be preserved too, the simplest method I know of using O(1)  scratch storage requires len(X) + 2**(m-1) swaps, spread over 2 passes.  Since len(X) is typically several times larger than 2**(m-1), that  would slow things down.
@c

struct SamplesortStackNode {
	/* Represents a slice of the array, from (&amp; including) lo up
	   to (but excluding) hi.  "extra" additional &amp; adjacent elements
	   are pre-selected pivots (PPs), spanning [lo-extra, lo) if
	   extra &gt; 0, or [hi, hi-extra) if extra &lt; 0.  The PPs are
	   already sorted, but nothing is known about the other elements
	   in [lo, hi). |extra| is always one less than a power of 2.
	   When extra is 0, we're out of PPs, and the slice must be
	   sorted by some other means. */
	PyObject **lo;
	PyObject **hi;
	int extra;
};

/* The number of PPs we want is 2**k - 1, where 2**k is as close to
   N / ln(N) as possible.  So k ~= lg(N / ln(N)).  Calling libm routines
   is undesirable, so cutoff values are canned in the "cutoff" table
   below:  cutoff[i] is the smallest N such that k == CUTOFFBASE + i. */
#define CUTOFFBASE 4
static long cutoff[] = {
	43,        /* smallest N such that k == 4 */
	106,       /* etc */
	250,
	576,
	1298,
	2885,
	6339,
	13805,
	29843,
	64116,
	137030,
	291554,
	617916,
	1305130,
	2748295,
	5771662,
	12091672,
	25276798,
	52734615,
	109820537,
	228324027,
	473977813,
	982548444,   /* smallest N such that k == 26 */
	2034159050   /* largest N that fits in signed 32-bit; k == 27 */
};

static int
samplesortslice(PyObject **lo, PyObject **hi, PyObject *compare)
     /* compare -- comparison function object, or NULL for default */
{
	register PyObject **l, **r;
	register PyObject *tmp, *pivot;
	register int k;
	int n, extra, top, extraOnRight;
	struct SamplesortStackNode stack[STACKSIZE];

	/* assert lo &lt;= hi */
	n = hi - lo;

	/* ----------------------------------------------------------
	 * Special cases
	 * --------------------------------------------------------*/
	if (n &lt; 2)
		return 0;

	/* Set r to the largest value such that [lo,r) is sorted.
	   This catches the already-sorted case, the all-the-same
	   case, and the appended-a-few-elements-to-a-sorted-list case.
	   If the array is unsorted, we're very likely to get out of
	   the loop fast, so the test is cheap if it doesn't pay off.
	*/
	/* assert lo &lt; hi */
	for (r = lo+1; r &lt; hi; ++r) {
		SETK(*r, *(r-1));
		if (k &lt; 0)
			break;
	}
	/* [lo,r) is sorted, [r,hi) unknown.  Get out cheap if there are
	   few unknowns, or few elements in total. */
	if (hi - r &lt;= MAXMERGE || n &lt; MINSIZE)
		return binarysort(lo, hi, r, compare);

	/* Check for the array already being reverse-sorted.  Typical
	   benchmark-driven silliness &lt;wink&gt;. */
	/* assert lo &lt; hi */
	for (r = lo+1; r &lt; hi; ++r) {
		SETK(*(r-1), *r);
		if (k &lt; 0)
			break;
	}
	if (hi - r &lt;= MAXMERGE) {
		/* Reverse the reversed prefix, then insert the tail */
		PyObject **originalr = r;
		l = lo;
		do {
			--r;
			tmp = *l; *l = *r; *r = tmp;
			++l;
		} while (l &lt; r);
		return binarysort(lo, hi, originalr, compare);
	}

	/* ----------------------------------------------------------
	 * Normal case setup: a large array without obvious pattern.
	 * --------------------------------------------------------*/

	/* extra := a power of 2 ~= n/ln(n), less 1.
	   First find the smallest extra s.t. n &lt; cutoff[extra] */
	for (extra = 0;
	     extra &lt; sizeof(cutoff) / sizeof(cutoff[0]);
	     ++extra) {
		if (n &lt; cutoff[extra])
			break;
		/* note that if we fall out of the loop, the value of
		   extra still makes *sense*, but may be smaller than
		   we would like (but the array has more than ~= 2**31
		   elements in this case!) */ 
	}
	/* Now k == extra - 1 + CUTOFFBASE.  The smallest value k can
	   have is CUTOFFBASE-1, so
	   assert MINSIZE &gt;= 2**(CUTOFFBASE-1) - 1 */
	extra = (1 &lt;&lt; (extra - 1 + CUTOFFBASE)) - 1;
	/* assert extra &gt; 0 and n &gt;= extra */

	/* Swap that many values to the start of the array.  The
	   selection of elements is pseudo-random, but the same on
	   every run (this is intentional! timing algorithm changes is
	   a pain if timing varies across runs).  */
	{
		unsigned int seed = n / extra;  /* arbitrary */
		unsigned int i;
		for (i = 0; i &lt; (unsigned)extra; ++i) {
			/* j := random int in [i, n) */
			unsigned int j;
			seed = seed * 69069 + 7;
			j = i + seed % (n - i);
			tmp = lo[i]; lo[i] = lo[j]; lo[j] = tmp;
		}
	}

	/* Recursively sort the preselected pivots. */
	if (samplesortslice(lo, lo + extra, compare) &lt; 0)
		goto fail;

	top = 0;          /* index of available stack slot */
	lo += extra;      /* point to first unknown */
	extraOnRight = 0; /* the PPs are at the left end */

	/* ----------------------------------------------------------
	 * Partition [lo, hi), and repeat until out of work.
	 * --------------------------------------------------------*/
	for (;;) {
		/* assert lo &lt;= hi, so n &gt;= 0 */
		n = hi - lo;

		/* We may not want, or may not be able, to partition:
		   If n is small, it's quicker to insert.
		   If extra is 0, we're out of pivots, and *must* use
		   another method.
		*/
		if (n &lt; MINPARTITIONSIZE || extra == 0) {
			if (n &gt;= MINSIZE) {
				/* assert extra == 0
				   This is rare, since the average size
				   of a final block is only about
				   ln(original n). */
				if (samplesortslice(lo, hi, compare) &lt; 0)
					goto fail;
			}
			else {
				/* Binary insertion should be quicker,
				   and we can take advantage of the PPs
				   already being sorted. */
				if (extraOnRight &amp;&amp; extra) {
					/* swap the PPs to the left end */
					k = extra;
					do {
						tmp = *lo;
						*lo = *hi;
						*hi = tmp;
						++lo; ++hi;
					} while (--k);
				}
				if (binarysort(lo - extra, hi, lo,
					       compare) &lt; 0)
					goto fail;
			}

			/* Find another slice to work on. */
			if (--top &lt; 0)
				break;   /* no more -- done! */
			lo = stack[top].lo;
			hi = stack[top].hi;
			extra = stack[top].extra;
			extraOnRight = 0;
			if (extra &lt; 0) {
				extraOnRight = 1;
				extra = -extra;
			}
			continue;
		}

		/* Pretend the PPs are indexed 0, 1, ..., extra-1.
		   Then our preselected pivot is at (extra-1)/2, and we
		   want to move the PPs before that to the left end of
		   the slice, and the PPs after that to the right end.
		   The following section changes extra, lo, hi, and the
		   slice such that:
		   [lo-extra, lo) contains the smaller PPs.
		   *lo == our PP.
		   (lo, hi) contains the unknown elements.
		   [hi, hi+extra) contains the larger PPs.
		*/
		k = extra &gt;&gt;= 1;  /* num PPs to move */ 
		if (extraOnRight) {
			/* Swap the smaller PPs to the left end.
			   Note that this loop actually moves k+1 items:
			   the last is our PP */
			do {
				tmp = *lo; *lo = *hi; *hi = tmp;
				++lo; ++hi;
			} while (k--);
		}
		else {
			/* Swap the larger PPs to the right end. */
			while (k--) {
				--lo; --hi;
				tmp = *lo; *lo = *hi; *hi = tmp;
			}
		}
		--lo;   /* *lo is now our PP */
		pivot = *lo;

		/* Now an almost-ordinary quicksort partition step.
		   Note that most of the time is spent here!
		   Only odd thing is that we partition into &lt; and &gt;=,
		   instead of the usual &lt;= and &gt;=.  This helps when
		   there are lots of duplicates of different values,
		   because it eventually tends to make subfiles
		   "pure" (all duplicates), and we special-case for
		   duplicates later. */
		l = lo + 1;
		r = hi - 1;
		/* assert lo &lt; l &lt; r &lt; hi (small n weeded out above) */

		do {
			/* slide l right, looking for key &gt;= pivot */
			do {
				SETK(*l, pivot);
				if (k &lt; 0)
					++l;
				else
					break;
			} while (l &lt; r);

			/* slide r left, looking for key &lt; pivot */
			while (l &lt; r) {
				register PyObject *rval = *r--;
				SETK(rval, pivot);
				if (k &lt; 0) {
					/* swap and advance */
					r[1] = *l;
					*l++ = rval;
					break;
				}
			}

		} while (l &lt; r);

		/* assert lo &lt; r &lt;= l &lt; hi
		   assert r == l or r+1 == l
		   everything to the left of l is &lt; pivot, and
		   everything to the right of r is &gt;= pivot */

		if (l == r) {
			SETK(*r, pivot);
			if (k &lt; 0)
				++l;
			else
				--r;
		}
		/* assert lo &lt;= r and r+1 == l and l &lt;= hi
		   assert r == lo or a[r] &lt; pivot
		   assert a[lo] is pivot
		   assert l == hi or a[l] &gt;= pivot
		   Swap the pivot into "the middle", so we can henceforth
		   ignore it.
		*/
		*lo = *r;
		*r = pivot;

		/* The following is true now, &amp; will be preserved:
		   All in [lo,r) are &lt; pivot
		   All in [r,l) == pivot (&amp; so can be ignored)
		   All in [l,hi) are &gt;= pivot */

		/* Check for duplicates of the pivot.  One compare is
		   wasted if there are no duplicates, but can win big
		   when there are.
		   Tricky: we're sticking to "&lt;" compares, so deduce
		   equality indirectly.  We know pivot &lt;= *l, so they're
		   equal iff not pivot &lt; *l.
		*/
		while (l &lt; hi) {
			/* pivot &lt;= *l known */
			SETK(pivot, *l);
			if (k &lt; 0)
				break;
			else
				/* &lt;= and not &lt; implies == */
				++l;
		}

		/* assert lo &lt;= r &lt; l &lt;= hi
		   Partitions are [lo, r) and [l, hi) */

		/* push fattest first; remember we still have extra PPs
		   to the left of the left chunk and to the right of
		   the right chunk! */
		/* assert top &lt; STACKSIZE */
		if (r - lo &lt;= hi - l) {
			/* second is bigger */
			stack[top].lo = l;
			stack[top].hi = hi;
			stack[top].extra = -extra;
			hi = r;
			extraOnRight = 0;
		}
		else {
			/* first is bigger */
			stack[top].lo = lo;
			stack[top].hi = r;
			stack[top].extra = extra;
			lo = l;
			extraOnRight = 1;
		}
		++top;

	}   /* end of partitioning loop */

	return 0;

 fail:
	return -1;
}
</t>
<t tx="T396">#undef SETK

staticforward PyTypeObject immutable_list_type;

static PyObject *
listsort(PyListObject *self, PyObject *args)
{
	int err;
	PyObject *compare = NULL;
	PyTypeObject *savetype;

	if (args != NULL) {
		if (!PyArg_ParseTuple(args, "|O:sort", &amp;compare))
			return NULL;
	}
	savetype = self-&gt;ob_type;
	self-&gt;ob_type = &amp;immutable_list_type;
	err = samplesortslice(self-&gt;ob_item,
			      self-&gt;ob_item + self-&gt;ob_size,
			      compare);
	self-&gt;ob_type = savetype;
	if (err &lt; 0)
		return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T397">int
PyList_Sort(PyObject *v)
{
	if (v == NULL || !PyList_Check(v)) {
		PyErr_BadInternalCall();
		return -1;
	}
	v = listsort((PyListObject *)v, (PyObject *)NULL);
	if (v == NULL)
		return -1;
	Py_DECREF(v);
	return 0;
}
</t>
<t tx="T398">static void
_listreverse(PyListObject *self)
{
	register PyObject **p, **q;
	register PyObject *tmp;
	
	if (self-&gt;ob_size &gt; 1) {
		for (p = self-&gt;ob_item, q = self-&gt;ob_item + self-&gt;ob_size - 1;
		     p &lt; q;
		     p++, q--)
		{
			tmp = *p;
			*p = *q;
			*q = tmp;
		}
	}
}
</t>
<t tx="T399">static PyObject *
listreverse(PyListObject *self)
{
	_listreverse(self);
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T400">int
PyList_Reverse(PyObject *v)
{
	if (v == NULL || !PyList_Check(v)) {
		PyErr_BadInternalCall();
		return -1;
	}
	_listreverse((PyListObject *)v);
	return 0;
}
</t>
<t tx="T401">PyObject *
PyList_AsTuple(PyObject *v)
{
	PyObject *w;
	PyObject **p;
	int n;
	if (v == NULL || !PyList_Check(v)) {
		PyErr_BadInternalCall();
		return NULL;
	}
	n = ((PyListObject *)v)-&gt;ob_size;
	w = PyTuple_New(n);
	if (w == NULL)
		return NULL;
	p = ((PyTupleObject *)w)-&gt;ob_item;
	memcpy((void *)p,
	       (void *)((PyListObject *)v)-&gt;ob_item,
	       n*sizeof(PyObject *));
	while (--n &gt;= 0) {
		Py_INCREF(*p);
		p++;
	}
	return w;
}
</t>
<t tx="T402">static PyObject *
listindex(PyListObject *self, PyObject *v)
{
	int i;

	for (i = 0; i &lt; self-&gt;ob_size; i++) {
		int cmp = PyObject_RichCompareBool(self-&gt;ob_item[i], v, Py_EQ);
		if (cmp &gt; 0)
			return PyInt_FromLong((long)i);
		else if (cmp &lt; 0)
			return NULL;
	}
	PyErr_SetString(PyExc_ValueError, "list.index(x): x not in list");
	return NULL;
}
</t>
<t tx="T403">static PyObject *
listcount(PyListObject *self, PyObject *v)
{
	int count = 0;
	int i;

	for (i = 0; i &lt; self-&gt;ob_size; i++) {
		int cmp = PyObject_RichCompareBool(self-&gt;ob_item[i], v, Py_EQ);
		if (cmp &gt; 0)
			count++;
		else if (cmp &lt; 0)
			return NULL;
	}
	return PyInt_FromLong((long)count);
}
</t>
<t tx="T404">static PyObject *
listremove(PyListObject *self, PyObject *v)
{
	int i;

	for (i = 0; i &lt; self-&gt;ob_size; i++) {
		int cmp = PyObject_RichCompareBool(self-&gt;ob_item[i], v, Py_EQ);
		if (cmp &gt; 0) {
			if (list_ass_slice(self, i, i+1,
					   (PyObject *)NULL) != 0)
				return NULL;
			Py_INCREF(Py_None);
			return Py_None;
		}
		else if (cmp &lt; 0)
			return NULL;
	}
	PyErr_SetString(PyExc_ValueError, "list.remove(x): x not in list");
	return NULL;
}
</t>
<t tx="T405">static int
list_traverse(PyListObject *o, visitproc visit, void *arg)
{
	int i, err;
	PyObject *x;

	for (i = o-&gt;ob_size; --i &gt;= 0; ) {
		x = o-&gt;ob_item[i];
		if (x != NULL) {
			err = visit(x, arg);
			if (err)
				return err;
		}
	}
	return 0;
}
</t>
<t tx="T406">static int
list_clear(PyListObject *lp)
{
	(void) PyList_SetSlice((PyObject *)lp, 0, lp-&gt;ob_size, 0);
	return 0;
}
</t>
<t tx="T407">static PyObject *
list_richcompare(PyObject *v, PyObject *w, int op)
{
	PyListObject *vl, *wl;
	int i;

	if (!PyList_Check(v) || !PyList_Check(w)) {
		Py_INCREF(Py_NotImplemented);
		return Py_NotImplemented;
	}

	vl = (PyListObject *)v;
	wl = (PyListObject *)w;

	if (vl-&gt;ob_size != wl-&gt;ob_size &amp;&amp; (op == Py_EQ || op == Py_NE)) {
		/* Shortcut: if the lengths differ, the lists differ */
		PyObject *res;
		if (op == Py_EQ)
			res = Py_False;
		else
			res = Py_True;
		Py_INCREF(res);
		return res;
	}

	/* Search for the first index where items are different */
	for (i = 0; i &lt; vl-&gt;ob_size &amp;&amp; i &lt; wl-&gt;ob_size; i++) {
		int k = PyObject_RichCompareBool(vl-&gt;ob_item[i],
						 wl-&gt;ob_item[i], Py_EQ);
		if (k &lt; 0)
			return NULL;
		if (!k)
			break;
	}

	if (i &gt;= vl-&gt;ob_size || i &gt;= wl-&gt;ob_size) {
		/* No more items to compare -- compare sizes */
		int vs = vl-&gt;ob_size;
		int ws = wl-&gt;ob_size;
		int cmp;
		PyObject *res;
		switch (op) {
		case Py_LT: cmp = vs &lt;  ws; break;
		case Py_LE: cmp = vs &lt;= ws; break;
		case Py_EQ: cmp = vs == ws; break;
		case Py_NE: cmp = vs != ws; break;
		case Py_GT: cmp = vs &gt;  ws; break;
		case Py_GE: cmp = vs &gt;= ws; break;
		default: return NULL; /* cannot happen */
		}
		if (cmp)
			res = Py_True;
		else
			res = Py_False;
		Py_INCREF(res);
		return res;
	}

	/* We have an item that differs -- shortcuts for EQ/NE */
	if (op == Py_EQ) {
		Py_INCREF(Py_False);
		return Py_False;
	}
	if (op == Py_NE) {
		Py_INCREF(Py_True);
		return Py_True;
	}

	/* Compare the final item again using the proper operator */
	return PyObject_RichCompare(vl-&gt;ob_item[i], wl-&gt;ob_item[i], op);
}
</t>
<t tx="T408">@ Adapted from newer code by Tim
@c

static int
list_fill(PyListObject *result, PyObject *v)
{
	PyObject *it;      /* iter(v) */
	int n;		   /* guess for result list size */
	int i;

	n = result-&gt;ob_size;

	/* Special-case list(a_list), for speed. */
	if (PyList_Check(v)) {
		if (v == (PyObject *)result)
			return 0; /* source is destination, we're done */
		return list_ass_slice(result, 0, n, v);
	}

	/* Empty previous contents */
	if (n != 0) {
		if (list_ass_slice(result, 0, n, (PyObject *)NULL) != 0)
			return -1;
	}

	/* Get iterator.  There may be some low-level efficiency to be gained
	 * by caching the tp_iternext slot instead of using PyIter_Next()
	 * later, but premature optimization is the root etc.
	 */
	it = PyObject_GetIter(v);
	if (it == NULL)
		return -1;

	/* Guess a result list size. */
	n = -1;	 /* unknown */
	if (PySequence_Check(v) &amp;&amp;
	    v-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_length) {
		n = PySequence_Size(v);
		if (n &lt; 0)
			PyErr_Clear();
	}
	if (n &lt; 0)
		n = 8;	/* arbitrary */
	NRESIZE(result-&gt;ob_item, PyObject*, n);
	if (result-&gt;ob_item == NULL)
		goto error;
	for (i = 0; i &lt; n; i++)
		result-&gt;ob_item[i] = NULL;
	result-&gt;ob_size = n;

	/* Run iterator to exhaustion. */
	for (i = 0; ; i++) {
		PyObject *item = PyIter_Next(it);
		if (item == NULL) {
			if (PyErr_Occurred())
				goto error;
			break;
		}
		if (i &lt; n)
			PyList_SET_ITEM(result, i, item); /* steals ref */
		else {
			int status = ins1(result, result-&gt;ob_size, item);
			Py_DECREF(item);  /* append creates a new ref */
			if (status &lt; 0)
				goto error;
		}
	}

	/* Cut back result list if initial guess was too large. */
	if (i &lt; n &amp;&amp; result != NULL) {
		if (list_ass_slice(result, i, n, (PyObject *)NULL) != 0)
			goto error;
	}
	Py_DECREF(it);
	return 0;

  error:
	Py_DECREF(it);
	return -1;
}
</t>
<t tx="T409">static int
list_init(PyListObject *self, PyObject *args, PyObject *kw)
{
	PyObject *arg = NULL;
	static char *kwlist[] = {"sequence", 0};

	if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:list", kwlist, &amp;arg))
		return -1;
	if (arg != NULL)
		return list_fill(self, arg);
	if (self-&gt;ob_size &gt; 0)
		return list_ass_slice(self, 0, self-&gt;ob_size, (PyObject*)NULL);
	return 0;
}
</t>
<t tx="T410">static long
list_nohash(PyObject *self)
{
	PyErr_SetString(PyExc_TypeError, "list objects are unhashable");
	return -1;
}
</t>
<t tx="T411">static char append_doc[] =
"L.append(object) -- append object to end";
static char extend_doc[] =
"L.extend(list) -- extend list by appending list elements";
static char insert_doc[] =
"L.insert(index, object) -- insert object before index";
static char pop_doc[] =
"L.pop([index]) -&gt; item -- remove and return item at index (default last)";
static char remove_doc[] =
"L.remove(value) -- remove first occurrence of value";
static char index_doc[] =
"L.index(value) -&gt; integer -- return index of first occurrence of value";
static char count_doc[] =
"L.count(value) -&gt; integer -- return number of occurrences of value";
static char reverse_doc[] =
"L.reverse() -- reverse *IN PLACE*";
static char sort_doc[] =
"L.sort([cmpfunc]) -- sort *IN PLACE*; if given, cmpfunc(x, y) -&gt; -1, 0, 1";

static PyMethodDef list_methods[] = {
	{"append",	(PyCFunction)listappend,  METH_O, append_doc},
	{"insert",	(PyCFunction)listinsert,  METH_VARARGS, insert_doc},
	{"extend",      (PyCFunction)listextend,  METH_O, extend_doc},
	{"pop",		(PyCFunction)listpop, 	  METH_VARARGS, pop_doc},
	{"remove",	(PyCFunction)listremove,  METH_O, remove_doc},
	{"index",	(PyCFunction)listindex,   METH_O, index_doc},
	{"count",	(PyCFunction)listcount,   METH_O, count_doc},
	{"reverse",	(PyCFunction)listreverse, METH_NOARGS, reverse_doc},
	{"sort",	(PyCFunction)listsort, 	  METH_VARARGS, sort_doc},
	{NULL,		NULL}		/* sentinel */
};

static PySequenceMethods list_as_sequence = {
	(inquiry)list_length,			/* sq_length */
	(binaryfunc)list_concat,		/* sq_concat */
	(intargfunc)list_repeat,		/* sq_repeat */
	(intargfunc)list_item,			/* sq_item */
	(intintargfunc)list_slice,		/* sq_slice */
	(intobjargproc)list_ass_item,		/* sq_ass_item */
	(intintobjargproc)list_ass_slice,	/* sq_ass_slice */
	(objobjproc)list_contains,		/* sq_contains */
	(binaryfunc)list_inplace_concat,	/* sq_inplace_concat */
	(intargfunc)list_inplace_repeat,	/* sq_inplace_repeat */
};

static char list_doc[] =
"list() -&gt; new list\n"
"list(sequence) -&gt; new list initialized from sequence's items";

PyTypeObject PyList_Type = {
	PyObject_HEAD_INIT(&amp;PyType_Type)
	0,
	"list",
	sizeof(PyListObject),
	0,
	(destructor)list_dealloc,		/* tp_dealloc */
	(printfunc)list_print,			/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	(reprfunc)list_repr,			/* tp_repr */
	0,					/* tp_as_number */
	&amp;list_as_sequence,			/* tp_as_sequence */
	0,					/* tp_as_mapping */
	list_nohash,				/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	PyObject_GenericGetAttr,		/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
		Py_TPFLAGS_BASETYPE,		/* tp_flags */
 	list_doc,				/* tp_doc */
 	(traverseproc)list_traverse,		/* tp_traverse */
 	(inquiry)list_clear,			/* tp_clear */
	list_richcompare,			/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	list_methods,				/* tp_methods */
	0,					/* tp_members */
	0,					/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,					/* tp_descr_get */
	0,					/* tp_descr_set */
	0,					/* tp_dictoffset */
	(initproc)list_init,			/* tp_init */
	PyType_GenericAlloc,			/* tp_alloc */
	PyType_GenericNew,			/* tp_new */
	_PyObject_GC_Del,			/* tp_free */
};


/* During a sort, we really can't have anyone modifying the list; it could
   cause core dumps.  Thus, we substitute a dummy type that raises an
   explanatory exception when a modifying operation is used.  Caveat:
   comparisons may behave differently; but I guess it's a bad idea anyway to
   compare a list that's being sorted... */

static PyObject *
immutable_list_op(void)
{
	PyErr_SetString(PyExc_TypeError,
			"a list cannot be modified while it is being sorted");
	return NULL;
}
</t>
<t tx="T412">static PyMethodDef immutable_list_methods[] = {
	{"append",	(PyCFunction)immutable_list_op, METH_VARARGS},
	{"insert",	(PyCFunction)immutable_list_op, METH_VARARGS},
	{"extend",      (PyCFunction)immutable_list_op,  METH_O},
	{"pop",		(PyCFunction)immutable_list_op, METH_VARARGS},
	{"remove",	(PyCFunction)immutable_list_op, METH_VARARGS},
	{"index",	(PyCFunction)listindex,         METH_O},
	{"count",	(PyCFunction)listcount,         METH_O},
	{"reverse",	(PyCFunction)immutable_list_op, METH_VARARGS},
	{"sort",	(PyCFunction)immutable_list_op, METH_VARARGS},
	{NULL,		NULL}		/* sentinel */
};

static int
immutable_list_ass(void)
{
	immutable_list_op();
	return -1;
}
</t>
<t tx="T413">@language c
/* File object implementation */

&lt;&lt; fileobject #includes &gt;&gt;
&lt;&lt; fileobject declarations &gt;&gt;
@others
</t>
<t tx="T414">#include "Python.h"
#include "structmember.h"
</t>
<t tx="T415">
#ifndef DONT_HAVE_SYS_TYPES_H
#include &lt;sys/types.h&gt;
#endif /* DONT_HAVE_SYS_TYPES_H */

#ifdef MS_WIN32
#define fileno _fileno
/* can (almost fully) duplicate with _chsize, see file_truncate */
#define HAVE_FTRUNCATE
#endif

#ifdef macintosh
#ifdef USE_GUSI
#define HAVE_FTRUNCATE
#endif
#endif

#ifdef __MWERKS__
/* Mwerks fopen() doesn't always set errno */
#define NO_FOPEN_ERRNO
#endif

#define BUF(v) PyString_AS_STRING((PyStringObject *)v)

#ifndef DONT_HAVE_ERRNO_H
#include &lt;errno.h&gt;
#endif


typedef struct {
	PyObject_HEAD
	FILE *f_fp;
	PyObject *f_name;
	PyObject *f_mode;
	int (*f_close)(FILE *);
	int f_softspace; /* Flag used by 'print' command */
	int f_binary; /* Flag which indicates whether the file is open
			 open in binary (1) or test (0) mode */
} PyFileObject;
</t>
<t tx="T416">FILE *
PyFile_AsFile(PyObject *f)
{
	if (f == NULL || !PyFile_Check(f))
		return NULL;
	else
		return ((PyFileObject *)f)-&gt;f_fp;
}
</t>
<t tx="T417">PyObject *
PyFile_Name(PyObject *f)
{
	if (f == NULL || !PyFile_Check(f))
		return NULL;
	else
		return ((PyFileObject *)f)-&gt;f_name;
}
</t>
<t tx="T418">static PyObject *
fill_file_fields(PyFileObject *f, FILE *fp, char *name, char *mode,
		 int (*close)(FILE *))
{
	assert(f != NULL);
	assert(PyFile_Check(f));
	assert(f-&gt;f_fp == NULL);

	Py_DECREF(f-&gt;f_name);
	Py_DECREF(f-&gt;f_mode);
	f-&gt;f_name = PyString_FromString(name);
	f-&gt;f_mode = PyString_FromString(mode);

	f-&gt;f_close = close;
	f-&gt;f_softspace = 0;
	f-&gt;f_binary = strchr(mode,'b') != NULL;

	if (f-&gt;f_name == NULL || f-&gt;f_mode == NULL)
		return NULL;
	f-&gt;f_fp = fp;
	return (PyObject *) f;
}
</t>
<t tx="T419">static PyObject *
open_the_file(PyFileObject *f, char *name, char *mode)
{
	assert(f != NULL);
	assert(PyFile_Check(f));
	assert(name != NULL);
	assert(mode != NULL);
	assert(f-&gt;f_fp == NULL);

	/* rexec.py can't stop a user from getting the file() constructor --
	   all they have to do is get *any* file object f, and then do
	   type(f).  Here we prevent them from doing damage with it. */
	if (PyEval_GetRestricted()) {
		PyErr_SetString(PyExc_IOError,
			"file() constructor not accessible in restricted mode");
		return NULL;
	}
	errno = 0;
#ifdef HAVE_FOPENRF
	if (*mode == '*') {
		FILE *fopenRF();
		f-&gt;f_fp = fopenRF(name, mode+1);
	}
	else
#endif
	{
		Py_BEGIN_ALLOW_THREADS
		f-&gt;f_fp = fopen(name, mode);
		Py_END_ALLOW_THREADS
	}
	if (f-&gt;f_fp == NULL) {
#ifdef NO_FOPEN_ERRNO
		/* Metroworks only, wich does not always sets errno */
		if (errno == 0) {
			PyObject *v;
			v = Py_BuildValue("(is)", 0, "Cannot open file");
			if (v != NULL) {
				PyErr_SetObject(PyExc_IOError, v);
				Py_DECREF(v);
			}
			return NULL;
		}
#endif
#ifdef _MSC_VER
		/* MSVC 6 (Microsoft) leaves errno at 0 for bad mode strings,
		 * across all Windows flavors.  When it sets EINVAL varies
		 * across Windows flavors, the exact conditions aren't
		 * documented, and the answer lies in the OS's implementation
		 * of Win32's CreateFile function (whose source is secret).
		 * Seems the best we can do is map EINVAL to ENOENT.
		 */
		if (errno == 0)	/* bad mode string */
			errno = EINVAL;
		else if (errno == EINVAL) /* unknown, but not a mode string */
			errno = ENOENT;
#endif
		if (errno == EINVAL)
			PyErr_Format(PyExc_IOError, "invalid mode: %s",
				     mode);
		else
			PyErr_SetFromErrnoWithFilename(PyExc_IOError, name);
		f = NULL;
	}
	return (PyObject *)f;
}
</t>
<t tx="T420">PyObject *
PyFile_FromFile(FILE *fp, char *name, char *mode, int (*close)(FILE *))
{
	PyFileObject *f = (PyFileObject *)PyFile_Type.tp_new(&amp;PyFile_Type,
							     NULL, NULL);
	if (f != NULL) {
		if (fill_file_fields(f, fp, name, mode, close) == NULL) {
			Py_DECREF(f);
			f = NULL;
		}
	}
	return (PyObject *) f;
}
</t>
<t tx="T421">PyObject *
PyFile_FromString(char *name, char *mode)
{
	extern int fclose(FILE *);
	PyFileObject *f;

	f = (PyFileObject *)PyFile_FromFile((FILE *)NULL, name, mode, fclose);
	if (f != NULL) {
		if (open_the_file(f, name, mode) == NULL) {
			Py_DECREF(f);
			f = NULL;
		}
	}
	return (PyObject *)f;
}
</t>
<t tx="T422">void
PyFile_SetBufSize(PyObject *f, int bufsize)
{
	if (bufsize &gt;= 0) {
#ifdef HAVE_SETVBUF
		int type;
		switch (bufsize) {
		case 0:
			type = _IONBF;
			break;
		case 1:
			type = _IOLBF;
			bufsize = BUFSIZ;
			break;
		default:
			type = _IOFBF;
		}
		setvbuf(((PyFileObject *)f)-&gt;f_fp, (char *)NULL,
			type, bufsize);
#else /* !HAVE_SETVBUF */
		if (bufsize &lt;= 1)
			setbuf(((PyFileObject *)f)-&gt;f_fp, (char *)NULL);
#endif /* !HAVE_SETVBUF */
	}
}
</t>
<t tx="T423">static PyObject *
err_closed(void)
{
	PyErr_SetString(PyExc_ValueError, "I/O operation on closed file");
	return NULL;
}
</t>
<t tx="T424">@ Methods
@c

static void
file_dealloc(PyFileObject *f)
{
	if (f-&gt;f_fp != NULL &amp;&amp; f-&gt;f_close != NULL) {
		Py_BEGIN_ALLOW_THREADS
		(*f-&gt;f_close)(f-&gt;f_fp);
		Py_END_ALLOW_THREADS
	}
	Py_XDECREF(f-&gt;f_name);
	Py_XDECREF(f-&gt;f_mode);
	f-&gt;ob_type-&gt;tp_free((PyObject *)f);
}
</t>
<t tx="T425">static PyObject *
file_repr(PyFileObject *f)
{
	return PyString_FromFormat("&lt;%s file '%s', mode '%s' at %p&gt;",
				   f-&gt;f_fp == NULL ? "closed" : "open",
				   PyString_AsString(f-&gt;f_name),
				   PyString_AsString(f-&gt;f_mode),
				   f);
}
</t>
<t tx="T426">static PyObject *
file_close(PyFileObject *f)
{
	int sts = 0;
	if (f-&gt;f_fp != NULL) {
		if (f-&gt;f_close != NULL) {
			Py_BEGIN_ALLOW_THREADS
			errno = 0;
			sts = (*f-&gt;f_close)(f-&gt;f_fp);
			Py_END_ALLOW_THREADS
		}
		f-&gt;f_fp = NULL;
	}
	if (sts == EOF)
		return PyErr_SetFromErrno(PyExc_IOError);
	if (sts != 0)
		return PyInt_FromLong((long)sts);
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T427">@ Our very own off_t-like type, 64-bit if possible
@c

#if !defined(HAVE_LARGEFILE_SUPPORT)
typedef off_t Py_off_t;
#elif SIZEOF_OFF_T &gt;= 8
typedef off_t Py_off_t;
#elif SIZEOF_FPOS_T &gt;= 8
typedef fpos_t Py_off_t;
#else
#error "Large file support, but neither off_t nor fpos_t is large enough."
#endif


/* a portable fseek() function
   return 0 on success, non-zero on failure (with errno set) */
static int
_portable_fseek(FILE *fp, Py_off_t offset, int whence)
{
#if !defined(HAVE_LARGEFILE_SUPPORT)
	return fseek(fp, offset, whence);
#elif defined(HAVE_FSEEKO) &amp;&amp; SIZEOF_OFF_T &gt;= 8
	return fseeko(fp, offset, whence);
#elif defined(HAVE_FSEEK64)
	return fseek64(fp, offset, whence);
#elif defined(__BEOS__)
	return _fseek(fp, offset, whence);
#elif SIZEOF_FPOS_T &gt;= 8
	/* lacking a 64-bit capable fseek(), use a 64-bit capable fsetpos()
	   and fgetpos() to implement fseek()*/
	fpos_t pos;
	switch (whence) {
	case SEEK_END:
#ifdef MS_WINDOWS
		fflush(fp);
		if (_lseeki64(fileno(fp), 0, 2) == -1)
			return -1;
#else
		if (fseek(fp, 0, SEEK_END) != 0)
			return -1;
#endif
		/* fall through */
	case SEEK_CUR:
		if (fgetpos(fp, &amp;pos) != 0)
			return -1;
		offset += pos;
		break;
	/* case SEEK_SET: break; */
	}
	return fsetpos(fp, &amp;offset);
#else
#error "Large file support, but no way to fseek."
#endif
}
</t>
<t tx="T428">@ a portable ftell() function  Return -1 on failure with errno set appropriately, current file  position on success
@c

static Py_off_t
_portable_ftell(FILE* fp)
{
#if !defined(HAVE_LARGEFILE_SUPPORT)
	return ftell(fp);
#elif defined(HAVE_FTELLO) &amp;&amp; SIZEOF_OFF_T &gt;= 8
	return ftello(fp);
#elif defined(HAVE_FTELL64)
	return ftell64(fp);
#elif SIZEOF_FPOS_T &gt;= 8
	fpos_t pos;
	if (fgetpos(fp, &amp;pos) != 0)
		return -1;
	return pos;
#else
#error "Large file support, but no way to ftell."
#endif
}
</t>
<t tx="T429">static PyObject *
file_seek(PyFileObject *f, PyObject *args)
{
	int whence;
	int ret;
	Py_off_t offset;
	PyObject *offobj;

	if (f-&gt;f_fp == NULL)
		return err_closed();
	whence = 0;
	if (!PyArg_ParseTuple(args, "O|i:seek", &amp;offobj, &amp;whence))
		return NULL;
#if !defined(HAVE_LARGEFILE_SUPPORT)
	offset = PyInt_AsLong(offobj);
#else
	offset = PyLong_Check(offobj) ?
		PyLong_AsLongLong(offobj) : PyInt_AsLong(offobj);
#endif
	if (PyErr_Occurred())
		return NULL;

	Py_BEGIN_ALLOW_THREADS
	errno = 0;
	ret = _portable_fseek(f-&gt;f_fp, offset, whence);
	Py_END_ALLOW_THREADS

	if (ret != 0) {
		PyErr_SetFromErrno(PyExc_IOError);
		clearerr(f-&gt;f_fp);
		return NULL;
	}
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T430">#ifdef HAVE_FTRUNCATE
static PyObject *
file_truncate(PyFileObject *f, PyObject *args)
{
	int ret;
	Py_off_t newsize;
	PyObject *newsizeobj;

	if (f-&gt;f_fp == NULL)
		return err_closed();
	newsizeobj = NULL;
	if (!PyArg_ParseTuple(args, "|O:truncate", &amp;newsizeobj))
		return NULL;
	if (newsizeobj != NULL) {
#if !defined(HAVE_LARGEFILE_SUPPORT)
		newsize = PyInt_AsLong(newsizeobj);
#else
		newsize = PyLong_Check(newsizeobj) ?
				PyLong_AsLongLong(newsizeobj) :
				PyInt_AsLong(newsizeobj);
#endif
		if (PyErr_Occurred())
			return NULL;
	} else {
		/* Default to current position*/
		Py_BEGIN_ALLOW_THREADS
		errno = 0;
		newsize = _portable_ftell(f-&gt;f_fp);
		Py_END_ALLOW_THREADS
		if (newsize == -1) {
		        PyErr_SetFromErrno(PyExc_IOError);
			clearerr(f-&gt;f_fp);
			return NULL;
		}
	}
	Py_BEGIN_ALLOW_THREADS
	errno = 0;
	ret = fflush(f-&gt;f_fp);
	Py_END_ALLOW_THREADS
	if (ret != 0) goto onioerror;

#ifdef MS_WIN32
	/* can use _chsize; if, however, the newsize overflows 32-bits then
	   _chsize is *not* adequate; in this case, an OverflowError is raised */
	if (newsize &gt; LONG_MAX) {
		PyErr_SetString(PyExc_OverflowError,
			"the new size is too long for _chsize (it is limited to 32-bit values)");
		return NULL;
	} else {
		Py_BEGIN_ALLOW_THREADS
		errno = 0;
		ret = _chsize(fileno(f-&gt;f_fp), (long)newsize);
		Py_END_ALLOW_THREADS
		if (ret != 0) goto onioerror;
	}
#else
	Py_BEGIN_ALLOW_THREADS
	errno = 0;
	ret = ftruncate(fileno(f-&gt;f_fp), newsize);
	Py_END_ALLOW_THREADS
	if (ret != 0) goto onioerror;
#endif /* !MS_WIN32 */

	Py_INCREF(Py_None);
	return Py_None;

onioerror:
	PyErr_SetFromErrno(PyExc_IOError);
	clearerr(f-&gt;f_fp);
	return NULL;
}
</t>
<t tx="T431">#endif /* HAVE_FTRUNCATE */

static PyObject *
file_tell(PyFileObject *f)
{
	Py_off_t pos;

	if (f-&gt;f_fp == NULL)
		return err_closed();
	Py_BEGIN_ALLOW_THREADS
	errno = 0;
	pos = _portable_ftell(f-&gt;f_fp);
	Py_END_ALLOW_THREADS
	if (pos == -1) {
		PyErr_SetFromErrno(PyExc_IOError);
		clearerr(f-&gt;f_fp);
		return NULL;
	}
#if !defined(HAVE_LARGEFILE_SUPPORT)
	return PyInt_FromLong(pos);
#else
	return PyLong_FromLongLong(pos);
#endif
}
</t>
<t tx="T432">static PyObject *
file_fileno(PyFileObject *f)
{
	if (f-&gt;f_fp == NULL)
		return err_closed();
	return PyInt_FromLong((long) fileno(f-&gt;f_fp));
}
</t>
<t tx="T433">static PyObject *
file_flush(PyFileObject *f)
{
	int res;

	if (f-&gt;f_fp == NULL)
		return err_closed();
	Py_BEGIN_ALLOW_THREADS
	errno = 0;
	res = fflush(f-&gt;f_fp);
	Py_END_ALLOW_THREADS
	if (res != 0) {
		PyErr_SetFromErrno(PyExc_IOError);
		clearerr(f-&gt;f_fp);
		return NULL;
	}
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T434">static PyObject *
file_isatty(PyFileObject *f)
{
	long res;
	if (f-&gt;f_fp == NULL)
		return err_closed();
	Py_BEGIN_ALLOW_THREADS
	res = isatty((int)fileno(f-&gt;f_fp));
	Py_END_ALLOW_THREADS
	return PyInt_FromLong(res);
}
</t>
<t tx="T435">#if BUFSIZ &lt; 8192
#define SMALLCHUNK 8192
#else
#define SMALLCHUNK BUFSIZ
#endif

#if SIZEOF_INT &lt; 4
#define BIGCHUNK  (512 * 32)
#else
#define BIGCHUNK  (512 * 1024)
#endif

static size_t
new_buffersize(PyFileObject *f, size_t currentsize)
{
#ifdef HAVE_FSTAT
	off_t pos, end;
	struct stat st;
	if (fstat(fileno(f-&gt;f_fp), &amp;st) == 0) {
		end = st.st_size;
		/* The following is not a bug: we really need to call lseek()
		   *and* ftell().  The reason is that some stdio libraries
		   mistakenly flush their buffer when ftell() is called and
		   the lseek() call it makes fails, thereby throwing away
		   data that cannot be recovered in any way.  To avoid this,
		   we first test lseek(), and only call ftell() if lseek()
		   works.  We can't use the lseek() value either, because we
		   need to take the amount of buffered data into account.
		   (Yet another reason why stdio stinks. :-) */
#ifdef USE_GUSI2
		pos = lseek(fileno(f-&gt;f_fp), 1L, SEEK_CUR);
		pos = lseek(fileno(f-&gt;f_fp), -1L, SEEK_CUR);
#else
		pos = lseek(fileno(f-&gt;f_fp), 0L, SEEK_CUR);
#endif
		if (pos &gt;= 0) {
			pos = ftell(f-&gt;f_fp);
		}
		if (pos &lt; 0)
			clearerr(f-&gt;f_fp);
		if (end &gt; pos &amp;&amp; pos &gt;= 0)
			return currentsize + end - pos + 1;
		/* Add 1 so if the file were to grow we'd notice. */
	}
#endif
	if (currentsize &gt; SMALLCHUNK) {
		/* Keep doubling until we reach BIGCHUNK;
		   then keep adding BIGCHUNK. */
		if (currentsize &lt;= BIGCHUNK)
			return currentsize + currentsize;
		else
			return currentsize + BIGCHUNK;
	}
	return currentsize + SMALLCHUNK;
}
</t>
<t tx="T436">static PyObject *
file_read(PyFileObject *f, PyObject *args)
{
	long bytesrequested = -1;
	size_t bytesread, buffersize, chunksize;
	PyObject *v;

	if (f-&gt;f_fp == NULL)
		return err_closed();
	if (!PyArg_ParseTuple(args, "|l:read", &amp;bytesrequested))
		return NULL;
	if (bytesrequested &lt; 0)
		buffersize = new_buffersize(f, (size_t)0);
	else
		buffersize = bytesrequested;
	if (buffersize &gt; INT_MAX) {
		PyErr_SetString(PyExc_OverflowError,
			"requested number of bytes is more than a Python string can hold");
		return NULL;
	}
	v = PyString_FromStringAndSize((char *)NULL, buffersize);
	if (v == NULL)
		return NULL;
	bytesread = 0;
	for (;;) {
		Py_BEGIN_ALLOW_THREADS
		errno = 0;
		chunksize = fread(BUF(v) + bytesread, 1,
				  buffersize - bytesread, f-&gt;f_fp);
		Py_END_ALLOW_THREADS
		if (chunksize == 0) {
			if (!ferror(f-&gt;f_fp))
				break;
			PyErr_SetFromErrno(PyExc_IOError);
			clearerr(f-&gt;f_fp);
			Py_DECREF(v);
			return NULL;
		}
		bytesread += chunksize;
		if (bytesread &lt; buffersize)
			break;
		if (bytesrequested &lt; 0) {
			buffersize = new_buffersize(f, buffersize);
			if (_PyString_Resize(&amp;v, buffersize) &lt; 0)
				return NULL;
		}
	}
	if (bytesread != buffersize)
		_PyString_Resize(&amp;v, bytesread);
	return v;
}
</t>
<t tx="T437">static PyObject *
file_readinto(PyFileObject *f, PyObject *args)
{
	char *ptr;
	int ntodo;
	size_t ndone, nnow;

	if (f-&gt;f_fp == NULL)
		return err_closed();
	if (!PyArg_Parse(args, "w#", &amp;ptr, &amp;ntodo))
		return NULL;
	ndone = 0;
	while (ntodo &gt; 0) {
		Py_BEGIN_ALLOW_THREADS
		errno = 0;
		nnow = fread(ptr+ndone, 1, ntodo, f-&gt;f_fp);
		Py_END_ALLOW_THREADS
		if (nnow == 0) {
			if (!ferror(f-&gt;f_fp))
				break;
			PyErr_SetFromErrno(PyExc_IOError);
			clearerr(f-&gt;f_fp);
			return NULL;
		}
		ndone += nnow;
		ntodo -= nnow;
	}
	return PyInt_FromLong((long)ndone);
}
</t>
<t tx="T438">@ ************************************************************************* Routine to get next line using platform fgets(). Under MSVC 6: + MS threadsafe getc is very slow (multiple layers of function calls before+  after each character, to lock+unlock the stream). + The stream-locking functions are MS-internal -- can't access them from user  code. + There's nothing Tim could find in the MS C or platform SDK libraries that  can worm around this. + MS fgets locks/unlocks only once per line; it's the only hook we have. So we use fgets for speed(!), despite that it's painful. MS realloc is also slow. Reports from other platforms on this method vs getc_unlocked (which MS doesn't have): Linux a wash Solaris a wash Tru64 Unix getline_via_fgets significantly faster CAUTION: The C std isn't clear about this: in those cases where fgets writes something into the buffer, can it write into any position beyond the required trailing null byte? MSVC 6 fgets does not, and no platform is (yet) known on which it does; and it would be a strange way to code fgets. Still, getline_via_fgets may not work correctly if it does. The std test test_bufio.py should fail if platform fgets() routinely writes beyond the trailing null byte. #define DONT_USE_FGETS_IN_GETLINE to disable this code. *************************************************************************
Use this routine if told to, or by default on non-get_unlocked() * platforms unless told not to. Yikes! Let's spell that out: * On a platform with getc_unlocked(): *   By default, use getc_unlocked(). *   If you want to use fgets() instead, #define USE_FGETS_IN_GETLINE. * On a platform without getc_unlocked(): *   By default, use fgets(). *   If you don't want to use fgets(), #define DONT_USE_FGETS_IN_GETLINE.
@c

#if !defined(USE_FGETS_IN_GETLINE) &amp;&amp; !defined(HAVE_GETC_UNLOCKED)
#define USE_FGETS_IN_GETLINE
#endif

#if defined(DONT_USE_FGETS_IN_GETLINE) &amp;&amp; defined(USE_FGETS_IN_GETLINE)
#undef USE_FGETS_IN_GETLINE
#endif

#ifdef USE_FGETS_IN_GETLINE
static PyObject*
getline_via_fgets(FILE *fp)
{
/* INITBUFSIZE is the maximum line length that lets us get away with the fast
 * no-realloc, one-fgets()-call path.  Boosting it isn't free, because we have
 * to fill this much of the buffer with a known value in order to figure out
 * how much of the buffer fgets() overwrites.  So if INITBUFSIZE is larger
 * than "most" lines, we waste time filling unused buffer slots.  100 is
 * surely adequate for most peoples' email archives, chewing over source code,
 * etc -- "regular old text files".
 * MAXBUFSIZE is the maximum line length that lets us get away with the less
 * fast (but still zippy) no-realloc, two-fgets()-call path.  See above for
 * cautions about boosting that.  300 was chosen because the worst real-life
 * text-crunching job reported on Python-Dev was a mail-log crawler where over
 * half the lines were 254 chars.
 * INCBUFSIZE is the amount by which we grow the buffer, if MAXBUFSIZE isn't
 * enough.  It doesn't much matter what this is set to: we only get here for
 * absurdly long lines anyway.
 */
#define INITBUFSIZE 100
#define MAXBUFSIZE 300
#define INCBUFSIZE 1000
	char* p;	/* temp */
	char buf[MAXBUFSIZE];
	PyObject* v;	/* the string object result */
	char* pvfree;	/* address of next free slot */
	char* pvend;    /* address one beyond last free slot */
	size_t nfree;	/* # of free buffer slots; pvend-pvfree */
	size_t total_v_size;  /* total # of slots in buffer */

	/* Optimize for normal case:  avoid _PyString_Resize if at all
	 * possible via first reading into stack buffer "buf".
	 */
	total_v_size = INITBUFSIZE;	/* start small and pray */
	pvfree = buf;
	for (;;) {
		Py_BEGIN_ALLOW_THREADS
		pvend = buf + total_v_size;
		nfree = pvend - pvfree;
		memset(pvfree, '\n', nfree);
		p = fgets(pvfree, nfree, fp);
		Py_END_ALLOW_THREADS

		if (p == NULL) {
			clearerr(fp);
			if (PyErr_CheckSignals())
				return NULL;
			v = PyString_FromStringAndSize(buf, pvfree - buf);
			return v;
		}
		/* fgets read *something* */
		p = memchr(pvfree, '\n', nfree);
		if (p != NULL) {
			/* Did the \n come from fgets or from us?
			 * Since fgets stops at the first \n, and then writes
			 * \0, if it's from fgets a \0 must be next.  But if
			 * that's so, it could not have come from us, since
			 * the \n's we filled the buffer with have only more
			 * \n's to the right.
			 */
			if (p+1 &lt; pvend &amp;&amp; *(p+1) == '\0') {
				/* It's from fgets:  we win!  In particular,
				 * we haven't done any mallocs yet, and can
				 * build the final result on the first try.
				 */
				++p;	/* include \n from fgets */
			}
			else {
				/* Must be from us:  fgets didn't fill the
				 * buffer and didn't find a newline, so it
				 * must be the last and newline-free line of
				 * the file.
				 */
				assert(p &gt; pvfree &amp;&amp; *(p-1) == '\0');
				--p;	/* don't include \0 from fgets */
			}
			v = PyString_FromStringAndSize(buf, p - buf);
			return v;
		}
		/* yuck:  fgets overwrote all the newlines, i.e. the entire
		 * buffer.  So this line isn't over yet, or maybe it is but
		 * we're exactly at EOF.  If we haven't already, try using the
		 * rest of the stack buffer.
		 */
		assert(*(pvend-1) == '\0');
		if (pvfree == buf) {
			pvfree = pvend - 1;	/* overwrite trailing null */
			total_v_size = MAXBUFSIZE;
		}
		else
			break;
	}

	/* The stack buffer isn't big enough; malloc a string object and read
	 * into its buffer.
	 */
	total_v_size = MAXBUFSIZE + INCBUFSIZE;
	v = PyString_FromStringAndSize((char*)NULL, (int)total_v_size);
	if (v == NULL)
		return v;
	/* copy over everything except the last null byte */
	memcpy(BUF(v), buf, MAXBUFSIZE-1);
	pvfree = BUF(v) + MAXBUFSIZE - 1;

	/* Keep reading stuff into v; if it ever ends successfully, break
	 * after setting p one beyond the end of the line.  The code here is
	 * very much like the code above, except reads into v's buffer; see
	 * the code above for detailed comments about the logic.
	 */
	for (;;) {
		Py_BEGIN_ALLOW_THREADS
		pvend = BUF(v) + total_v_size;
		nfree = pvend - pvfree;
		memset(pvfree, '\n', nfree);
		p = fgets(pvfree, nfree, fp);
		Py_END_ALLOW_THREADS

		if (p == NULL) {
			clearerr(fp);
			if (PyErr_CheckSignals()) {
				Py_DECREF(v);
				return NULL;
			}
			p = pvfree;
			break;
		}
		p = memchr(pvfree, '\n', nfree);
		if (p != NULL) {
			if (p+1 &lt; pvend &amp;&amp; *(p+1) == '\0') {
				/* \n came from fgets */
				++p;
				break;
			}
			/* \n came from us; last line of file, no newline */
			assert(p &gt; pvfree &amp;&amp; *(p-1) == '\0');
			--p;
			break;
		}
		/* expand buffer and try again */
		assert(*(pvend-1) == '\0');
		total_v_size += INCBUFSIZE;
		if (total_v_size &gt; INT_MAX) {
			PyErr_SetString(PyExc_OverflowError,
			    "line is longer than a Python string can hold");
			Py_DECREF(v);
			return NULL;
		}
		if (_PyString_Resize(&amp;v, (int)total_v_size) &lt; 0)
			return NULL;
		/* overwrite the trailing null byte */
		pvfree = BUF(v) + (total_v_size - INCBUFSIZE - 1);
	}
	if (BUF(v) + total_v_size != p)
		_PyString_Resize(&amp;v, p - BUF(v));
	return v;
#undef INITBUFSIZE
#undef MAXBUFSIZE
#undef INCBUFSIZE
}
</t>
<t tx="T439">#endif	/* ifdef USE_FGETS_IN_GETLINE */

/* Internal routine to get a line.
   Size argument interpretation:
   &gt; 0: max length;
   &lt;= 0: read arbitrary line
*/

#ifdef HAVE_GETC_UNLOCKED
#define GETC(f) getc_unlocked(f)
#define FLOCKFILE(f) flockfile(f)
#define FUNLOCKFILE(f) funlockfile(f)
#else
#define GETC(f) getc(f)
#define FLOCKFILE(f)
#define FUNLOCKFILE(f)
#endif

static PyObject *
get_line(PyFileObject *f, int n)
{
	FILE *fp = f-&gt;f_fp;
	int c;
	char *buf, *end;
	size_t n1, n2;
	PyObject *v;

#ifdef USE_FGETS_IN_GETLINE
	if (n &lt;= 0)
		return getline_via_fgets(fp);
#endif
	n2 = n &gt; 0 ? n : 100;
	v = PyString_FromStringAndSize((char *)NULL, n2);
	if (v == NULL)
		return NULL;
	buf = BUF(v);
	end = buf + n2;

	for (;;) {
		Py_BEGIN_ALLOW_THREADS
		FLOCKFILE(fp);
		while ((c = GETC(fp)) != EOF &amp;&amp;
		       (*buf++ = c) != '\n' &amp;&amp;
			buf != end)
			;
		FUNLOCKFILE(fp);
		Py_END_ALLOW_THREADS
		if (c == '\n')
			break;
		if (c == EOF) {
			if (ferror(fp)) {
				PyErr_SetFromErrno(PyExc_IOError);
				clearerr(fp);
				Py_DECREF(v);
				return NULL;
			}
			clearerr(fp);
			if (PyErr_CheckSignals()) {
				Py_DECREF(v);
				return NULL;
			}
			break;
		}
		/* Must be because buf == end */
		if (n &gt; 0)
			break;
		n1 = n2;
		n2 += 1000;
		if (n2 &gt; INT_MAX) {
			PyErr_SetString(PyExc_OverflowError,
			    "line is longer than a Python string can hold");
			Py_DECREF(v);
			return NULL;
		}
		if (_PyString_Resize(&amp;v, n2) &lt; 0)
			return NULL;
		buf = BUF(v) + n1;
		end = BUF(v) + n2;
	}

	n1 = buf - BUF(v);
	if (n1 != n2)
		_PyString_Resize(&amp;v, n1);
	return v;
}
</t>
<t tx="T440">@ External C interface
@c

PyObject *
PyFile_GetLine(PyObject *f, int n)
{
	PyObject *result;

	if (f == NULL) {
		PyErr_BadInternalCall();
		return NULL;
	}

	if (PyFile_Check(f)) {
		if (((PyFileObject*)f)-&gt;f_fp == NULL)
			return err_closed();
		result = get_line((PyFileObject *)f, n);
	}
	else {
		PyObject *reader;
		PyObject *args;

		reader = PyObject_GetAttrString(f, "readline");
		if (reader == NULL)
			return NULL;
		if (n &lt;= 0)
			args = Py_BuildValue("()");
		else
			args = Py_BuildValue("(i)", n);
		if (args == NULL) {
			Py_DECREF(reader);
			return NULL;
		}
		result = PyEval_CallObject(reader, args);
		Py_DECREF(reader);
		Py_DECREF(args);
		if (result != NULL &amp;&amp; !PyString_Check(result)) {
			Py_DECREF(result);
			result = NULL;
			PyErr_SetString(PyExc_TypeError,
				   "object.readline() returned non-string");
		}
	}

	if (n &lt; 0 &amp;&amp; result != NULL &amp;&amp; PyString_Check(result)) {
		char *s = PyString_AS_STRING(result);
		int len = PyString_GET_SIZE(result);
		if (len == 0) {
			Py_DECREF(result);
			result = NULL;
			PyErr_SetString(PyExc_EOFError,
					"EOF when reading a line");
		}
		else if (s[len-1] == '\n') {
			if (result-&gt;ob_refcnt == 1)
				_PyString_Resize(&amp;result, len-1);
			else {
				PyObject *v;
				v = PyString_FromStringAndSize(s, len-1);
				Py_DECREF(result);
				result = v;
			}
		}
	}
	return result;
}
</t>
<t tx="T441">@ Python method
@c

static PyObject *
file_readline(PyFileObject *f, PyObject *args)
{
	int n = -1;

	if (f-&gt;f_fp == NULL)
		return err_closed();
	if (!PyArg_ParseTuple(args, "|i:readline", &amp;n))
		return NULL;
	if (n == 0)
		return PyString_FromString("");
	if (n &lt; 0)
		n = 0;
	return get_line(f, n);
}
</t>
<t tx="T442">static PyObject *
file_xreadlines(PyFileObject *f)
{
	static PyObject* xreadlines_function = NULL;

	if (!xreadlines_function) {
		PyObject *xreadlines_module =
			PyImport_ImportModule("xreadlines");
		if(!xreadlines_module)
			return NULL;

		xreadlines_function = PyObject_GetAttrString(xreadlines_module,
							     "xreadlines");
		Py_DECREF(xreadlines_module);
		if(!xreadlines_function)
			return NULL;
	}
	return PyObject_CallFunction(xreadlines_function, "(O)", f);
}
</t>
<t tx="T443">static PyObject *
file_readlines(PyFileObject *f, PyObject *args)
{
	long sizehint = 0;
	PyObject *list;
	PyObject *line;
	char small_buffer[SMALLCHUNK];
	char *buffer = small_buffer;
	size_t buffersize = SMALLCHUNK;
	PyObject *big_buffer = NULL;
	size_t nfilled = 0;
	size_t nread;
	size_t totalread = 0;
	char *p, *q, *end;
	int err;
	int shortread = 0;

	if (f-&gt;f_fp == NULL)
		return err_closed();
	if (!PyArg_ParseTuple(args, "|l:readlines", &amp;sizehint))
		return NULL;
	if ((list = PyList_New(0)) == NULL)
		return NULL;
	for (;;) {
		if (shortread)
			nread = 0;
		else {
			Py_BEGIN_ALLOW_THREADS
			errno = 0;
			nread = fread(buffer+nfilled, 1,
				      buffersize-nfilled, f-&gt;f_fp);
			Py_END_ALLOW_THREADS
			shortread = (nread &lt; buffersize-nfilled);
		}
		if (nread == 0) {
			sizehint = 0;
			if (!ferror(f-&gt;f_fp))
				break;
			PyErr_SetFromErrno(PyExc_IOError);
			clearerr(f-&gt;f_fp);
		  error:
			Py_DECREF(list);
			list = NULL;
			goto cleanup;
		}
		totalread += nread;
		p = memchr(buffer+nfilled, '\n', nread);
		if (p == NULL) {
			/* Need a larger buffer to fit this line */
			nfilled += nread;
			buffersize *= 2;
			if (buffersize &gt; INT_MAX) {
				PyErr_SetString(PyExc_OverflowError,
			    "line is longer than a Python string can hold");
				goto error;
			}
			if (big_buffer == NULL) {
				/* Create the big buffer */
				big_buffer = PyString_FromStringAndSize(
					NULL, buffersize);
				if (big_buffer == NULL)
					goto error;
				buffer = PyString_AS_STRING(big_buffer);
				memcpy(buffer, small_buffer, nfilled);
			}
			else {
				/* Grow the big buffer */
				_PyString_Resize(&amp;big_buffer, buffersize);
				buffer = PyString_AS_STRING(big_buffer);
			}
			continue;
		}
		end = buffer+nfilled+nread;
		q = buffer;
		do {
			/* Process complete lines */
			p++;
			line = PyString_FromStringAndSize(q, p-q);
			if (line == NULL)
				goto error;
			err = PyList_Append(list, line);
			Py_DECREF(line);
			if (err != 0)
				goto error;
			q = p;
			p = memchr(q, '\n', end-q);
		} while (p != NULL);
		/* Move the remaining incomplete line to the start */
		nfilled = end-q;
		memmove(buffer, q, nfilled);
		if (sizehint &gt; 0)
			if (totalread &gt;= (size_t)sizehint)
				break;
	}
	if (nfilled != 0) {
		/* Partial last line */
		line = PyString_FromStringAndSize(buffer, nfilled);
		if (line == NULL)
			goto error;
		if (sizehint &gt; 0) {
			/* Need to complete the last line */
			PyObject *rest = get_line(f, 0);
			if (rest == NULL) {
				Py_DECREF(line);
				goto error;
			}
			PyString_Concat(&amp;line, rest);
			Py_DECREF(rest);
			if (line == NULL)
				goto error;
		}
		err = PyList_Append(list, line);
		Py_DECREF(line);
		if (err != 0)
			goto error;
	}
  cleanup:
	if (big_buffer) {
		Py_DECREF(big_buffer);
	}
	return list;
}
</t>
<t tx="T444">static PyObject *
file_write(PyFileObject *f, PyObject *args)
{
	char *s;
	int n, n2;
	if (f-&gt;f_fp == NULL)
		return err_closed();
	if (!PyArg_ParseTuple(args, f-&gt;f_binary ? "s#" : "t#", &amp;s, &amp;n))
		return NULL;
	f-&gt;f_softspace = 0;
	Py_BEGIN_ALLOW_THREADS
	errno = 0;
	n2 = fwrite(s, 1, n, f-&gt;f_fp);
	Py_END_ALLOW_THREADS
	if (n2 != n) {
		PyErr_SetFromErrno(PyExc_IOError);
		clearerr(f-&gt;f_fp);
		return NULL;
	}
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T445">static PyObject *
file_writelines(PyFileObject *f, PyObject *seq)
{
#define CHUNKSIZE 1000
	PyObject *list, *line;
	PyObject *it;	/* iter(seq) */
	PyObject *result;
	int i, j, index, len, nwritten, islist;

	assert(seq != NULL);
	if (f-&gt;f_fp == NULL)
		return err_closed();

	result = NULL;
	list = NULL;
	islist = PyList_Check(seq);
	if  (islist)
		it = NULL;
	else {
		it = PyObject_GetIter(seq);
		if (it == NULL) {
			PyErr_SetString(PyExc_TypeError,
				"writelines() requires an iterable argument");
			return NULL;
		}
		/* From here on, fail by going to error, to reclaim "it". */
		list = PyList_New(CHUNKSIZE);
		if (list == NULL)
			goto error;
	}

	/* Strategy: slurp CHUNKSIZE lines into a private list,
	   checking that they are all strings, then write that list
	   without holding the interpreter lock, then come back for more. */
	for (index = 0; ; index += CHUNKSIZE) {
		if (islist) {
			Py_XDECREF(list);
			list = PyList_GetSlice(seq, index, index+CHUNKSIZE);
			if (list == NULL)
				goto error;
			j = PyList_GET_SIZE(list);
		}
		else {
			for (j = 0; j &lt; CHUNKSIZE; j++) {
				line = PyIter_Next(it);
				if (line == NULL) {
					if (PyErr_Occurred())
						goto error;
					break;
				}
				PyList_SetItem(list, j, line);
			}
		}
		if (j == 0)
			break;

		/* Check that all entries are indeed strings. If not,
		   apply the same rules as for file.write() and
		   convert the results to strings. This is slow, but
		   seems to be the only way since all conversion APIs
		   could potentially execute Python code. */
		for (i = 0; i &lt; j; i++) {
			PyObject *v = PyList_GET_ITEM(list, i);
			if (!PyString_Check(v)) {
			    	const char *buffer;
			    	int len;
				if (((f-&gt;f_binary &amp;&amp;
				      PyObject_AsReadBuffer(v,
					      (const void**)&amp;buffer,
							    &amp;len)) ||
				     PyObject_AsCharBuffer(v,
							   &amp;buffer,
							   &amp;len))) {
					PyErr_SetString(PyExc_TypeError,
				"writelines() argument must be a sequence of strings");
					goto error;
				}
				line = PyString_FromStringAndSize(buffer,
								  len);
				if (line == NULL)
					goto error;
				Py_DECREF(v);
				PyList_SET_ITEM(list, i, line);
			}
		}

		/* Since we are releasing the global lock, the
		   following code may *not* execute Python code. */
		Py_BEGIN_ALLOW_THREADS
		f-&gt;f_softspace = 0;
		errno = 0;
		for (i = 0; i &lt; j; i++) {
		    	line = PyList_GET_ITEM(list, i);
			len = PyString_GET_SIZE(line);
			nwritten = fwrite(PyString_AS_STRING(line),
					  1, len, f-&gt;f_fp);
			if (nwritten != len) {
				Py_BLOCK_THREADS
				PyErr_SetFromErrno(PyExc_IOError);
				clearerr(f-&gt;f_fp);
				goto error;
			}
		}
		Py_END_ALLOW_THREADS

		if (j &lt; CHUNKSIZE)
			break;
	}

	Py_INCREF(Py_None);
	result = Py_None;
  error:
	Py_XDECREF(list);
  	Py_XDECREF(it);
	return result;
#undef CHUNKSIZE
}
</t>
<t tx="T446">static char readline_doc[] =
"readline([size]) -&gt; next line from the file, as a string.\n"
"\n"
"Retain newline.  A non-negative size argument limits the maximum\n"
"number of bytes to return (an incomplete line may be returned then).\n"
"Return an empty string at EOF.";

static char read_doc[] =
"read([size]) -&gt; read at most size bytes, returned as a string.\n"
"\n"
"If the size argument is negative or omitted, read until EOF is reached.";

static char write_doc[] =
"write(str) -&gt; None.  Write string str to file.\n"
"\n"
"Note that due to buffering, flush() or close() may be needed before\n"
"the file on disk reflects the data written.";

static char fileno_doc[] =
"fileno() -&gt; integer \"file descriptor\".\n"
"\n"
"This is needed for lower-level file interfaces, such os.read().";

static char seek_doc[] =
"seek(offset[, whence]) -&gt; None.  Move to new file position.\n"
"\n"
"Argument offset is a byte count.  Optional argument whence defaults to\n"
"0 (offset from start of file, offset should be &gt;= 0); other values are 1\n"
"(move relative to current position, positive or negative), and 2 (move\n"
"relative to end of file, usually negative, although many platforms allow\n"
"seeking beyond the end of a file).\n"
"\n"
"Note that not all file objects are seekable.";

#ifdef HAVE_FTRUNCATE
static char truncate_doc[] =
"truncate([size]) -&gt; None.  Truncate the file to at most size bytes.\n"
"\n"
"Size defaults to the current file position, as returned by tell().";
#endif

static char tell_doc[] =
"tell() -&gt; current file position, an integer (may be a long integer).";

static char readinto_doc[] =
"readinto() -&gt; Undocumented.  Don't use this; it may go away.";

static char readlines_doc[] =
"readlines([size]) -&gt; list of strings, each a line from the file.\n"
"\n"
"Call readline() repeatedly and return a list of the lines so read.\n"
"The optional size argument, if given, is an approximate bound on the\n"
"total number of bytes in the lines returned.";

static char xreadlines_doc[] =
"xreadlines() -&gt; next line from the file, as a string.\n"
"\n"
"Equivalent to xreadlines.xreadlines(file).  This is like readline(), but\n"
"often quicker, due to reading ahead internally.";

static char writelines_doc[] =
"writelines(sequence_of_strings) -&gt; None.  Write the strings to the file.\n"
"\n"
"Note that newlines are not added.  The sequence can be any iterable object\n"
"producing strings. This is equivalent to calling write() for each string.";

static char flush_doc[] =
"flush() -&gt; None.  Flush the internal I/O buffer.";

static char close_doc[] =
"close() -&gt; None or (perhaps) an integer.  Close the file.\n"
"\n"
"Sets data attribute .closed to true.  A closed file cannot be used for\n"
"further I/O operations.  close() may be called more than once without\n"
"error.  Some kinds of file objects (for example, opened by popen())\n"
"may return an exit status upon closing.";

static char isatty_doc[] =
"isatty() -&gt; true or false.  True if the file is connected to a tty device.";

static PyMethodDef file_methods[] = {
	{"readline",	(PyCFunction)file_readline,   METH_VARARGS, readline_doc},
	{"read",	(PyCFunction)file_read,       METH_VARARGS, read_doc},
	{"write",	(PyCFunction)file_write,      METH_VARARGS, write_doc},
	{"fileno",	(PyCFunction)file_fileno,     METH_NOARGS,  fileno_doc},
	{"seek",	(PyCFunction)file_seek,       METH_VARARGS, seek_doc},
#ifdef HAVE_FTRUNCATE
	{"truncate",	(PyCFunction)file_truncate,   METH_VARARGS, truncate_doc},
#endif
	{"tell",	(PyCFunction)file_tell,       METH_NOARGS,  tell_doc},
	{"readinto",	(PyCFunction)file_readinto,   METH_OLDARGS, readinto_doc},
	{"readlines",	(PyCFunction)file_readlines,  METH_VARARGS, readlines_doc},
	{"xreadlines",	(PyCFunction)file_xreadlines, METH_NOARGS,  xreadlines_doc},
	{"writelines",	(PyCFunction)file_writelines, METH_O,	    writelines_doc},
	{"flush",	(PyCFunction)file_flush,      METH_NOARGS,  flush_doc},
	{"close",	(PyCFunction)file_close,      METH_NOARGS,  close_doc},
	{"isatty",	(PyCFunction)file_isatty,     METH_NOARGS,  isatty_doc},
	{NULL,		NULL}		/* sentinel */
};

#define OFF(x) offsetof(PyFileObject, x)

static PyMemberDef file_memberlist[] = {
	{"softspace",	T_INT,		OFF(f_softspace), 0,
	 "flag indicating that a space needs to be printed; used by print"},
	{"mode",	T_OBJECT,	OFF(f_mode),	RO,
	 "file mode ('r', 'w', 'a', possibly with 'b' or '+' added)"},
	{"name",	T_OBJECT,	OFF(f_name),	RO,
	 "file name"},
	/* getattr(f, "closed") is implemented without this table */
	{NULL}	/* Sentinel */
};

static PyObject *
get_closed(PyFileObject *f, void *closure)
{
	return PyInt_FromLong((long)(f-&gt;f_fp == 0));
}
</t>
<t tx="T447">static PyGetSetDef file_getsetlist[] = {
	{"closed", (getter)get_closed, NULL, "flag set if the file is closed"},
	{0},
};

static PyObject *
file_getiter(PyObject *f)
{
	return PyObject_CallMethod(f, "xreadlines", "");
}
</t>
<t tx="T448">static PyObject *
file_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
	PyObject *self;
	static PyObject *not_yet_string;

	assert(type != NULL &amp;&amp; type-&gt;tp_alloc != NULL);

	if (not_yet_string == NULL) {
		not_yet_string = PyString_FromString("&lt;uninitialized file&gt;");
		if (not_yet_string == NULL)
			return NULL;
	}

	self = type-&gt;tp_alloc(type, 0);
	if (self != NULL) {
		/* Always fill in the name and mode, so that nobody else
		   needs to special-case NULLs there. */
		Py_INCREF(not_yet_string);
		((PyFileObject *)self)-&gt;f_name = not_yet_string;
		Py_INCREF(not_yet_string);
		((PyFileObject *)self)-&gt;f_mode = not_yet_string;
	}
	return self;
}
</t>
<t tx="T449">static int
file_init(PyObject *self, PyObject *args, PyObject *kwds)
{
	PyFileObject *foself = (PyFileObject *)self;
	int ret = 0;
	static char *kwlist[] = {"name", "mode", "buffering", 0};
	char *name = NULL;
	char *mode = "r";
	int bufsize = -1;

	assert(PyFile_Check(self));
	if (foself-&gt;f_fp != NULL) {
		/* Have to close the existing file first. */
		PyObject *closeresult = file_close(foself);
		if (closeresult == NULL)
			return -1;
		Py_DECREF(closeresult);
	}

	if (!PyArg_ParseTupleAndKeywords(args, kwds, "et|si:file", kwlist,
					 Py_FileSystemDefaultEncoding, &amp;name,
					 &amp;mode, &amp;bufsize))
		return -1;
	if (fill_file_fields(foself, NULL, name, mode, fclose) == NULL)
		goto Error;
	if (open_the_file(foself, name, mode) == NULL)
		goto Error;
	PyFile_SetBufSize(self, bufsize);
	goto Done;

Error:
	ret = -1;
	/* fall through */
Done:
	PyMem_Free(name); /* free the encoded string */
	return ret;
}
</t>
<t tx="T450">static char file_doc[] =
"file(name[, mode[, buffering]]) -&gt; file object\n"
"\n"
"Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),\n"
"writing or appending.  The file will be created if it doesn't exist\n"
"when opened for writing or appending; it will be truncated when\n"
"opened for writing.  Add a 'b' to the mode for binary files.\n"
"Add a '+' to the mode to allow simultaneous reading and writing.\n"
"If the buffering argument is given, 0 means unbuffered, 1 means line\n"
"buffered, and larger numbers specify the buffer size.\n"
"Note:  open() is an alias for file().\n";

PyTypeObject PyFile_Type = {
	PyObject_HEAD_INIT(&amp;PyType_Type)
	0,
	"file",
	sizeof(PyFileObject),
	0,
	(destructor)file_dealloc,		/* tp_dealloc */
	0,					/* tp_print */
	0,			 		/* tp_getattr */
	0,			 		/* tp_setattr */
	0,					/* tp_compare */
	(reprfunc)file_repr, 			/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,					/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	PyObject_GenericGetAttr,		/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
	file_doc,				/* tp_doc */
	0,					/* tp_traverse */
	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	file_getiter,				/* tp_iter */
	0,					/* tp_iternext */
	file_methods,				/* tp_methods */
	file_memberlist,			/* tp_members */
	file_getsetlist,			/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,					/* tp_descr_get */
	0,					/* tp_descr_set */
	0,					/* tp_dictoffset */
	(initproc)file_init,			/* tp_init */
	PyType_GenericAlloc,			/* tp_alloc */
	file_new,				/* tp_new */
	_PyObject_Del,				/* tp_free */
};

/* Interface for the 'soft space' between print items. */

int
PyFile_SoftSpace(PyObject *f, int newflag)
{
	int oldflag = 0;
	if (f == NULL) {
		/* Do nothing */
	}
	else if (PyFile_Check(f)) {
		oldflag = ((PyFileObject *)f)-&gt;f_softspace;
		((PyFileObject *)f)-&gt;f_softspace = newflag;
	}
	else {
		PyObject *v;
		v = PyObject_GetAttrString(f, "softspace");
		if (v == NULL)
			PyErr_Clear();
		else {
			if (PyInt_Check(v))
				oldflag = PyInt_AsLong(v);
			Py_DECREF(v);
		}
		v = PyInt_FromLong((long)newflag);
		if (v == NULL)
			PyErr_Clear();
		else {
			if (PyObject_SetAttrString(f, "softspace", v) != 0)
				PyErr_Clear();
			Py_DECREF(v);
		}
	}
	return oldflag;
}
</t>
<t tx="T451">@ Interfaces to write objects/strings to file-like objects
@c

int
PyFile_WriteObject(PyObject *v, PyObject *f, int flags)
{
	PyObject *writer, *value, *args, *result;
	if (f == NULL) {
		PyErr_SetString(PyExc_TypeError, "writeobject with NULL file");
		return -1;
	}
	else if (PyFile_Check(f)) {
		FILE *fp = PyFile_AsFile(f);
		if (fp == NULL) {
			err_closed();
			return -1;
		}
		return PyObject_Print(v, fp, flags);
	}
	writer = PyObject_GetAttrString(f, "write");
	if (writer == NULL)
		return -1;
	if (flags &amp; Py_PRINT_RAW) {
                if (PyUnicode_Check(v)) {
                        value = v;
                        Py_INCREF(value);
                } else
                        value = PyObject_Str(v);
	}
        else
		value = PyObject_Repr(v);
	if (value == NULL) {
		Py_DECREF(writer);
		return -1;
	}
	args = Py_BuildValue("(O)", value);
	if (args == NULL) {
		Py_DECREF(value);
		Py_DECREF(writer);
		return -1;
	}
	result = PyEval_CallObject(writer, args);
	Py_DECREF(args);
	Py_DECREF(value);
	Py_DECREF(writer);
	if (result == NULL)
		return -1;
	Py_DECREF(result);
	return 0;
}
</t>
<t tx="T452">int
PyFile_WriteString(const char *s, PyObject *f)
{
	if (f == NULL) {
		/* Should be caused by a pre-existing error */
		if (!PyErr_Occurred())
			PyErr_SetString(PyExc_SystemError,
					"null file for PyFile_WriteString");
		return -1;
	}
	else if (PyFile_Check(f)) {
		FILE *fp = PyFile_AsFile(f);
		if (fp == NULL) {
			err_closed();
			return -1;
		}
		fputs(s, fp);
		return 0;
	}
	else if (!PyErr_Occurred()) {
		PyObject *v = PyString_FromString(s);
		int err;
		if (v == NULL)
			return -1;
		err = PyFile_WriteObject(v, f, Py_PRINT_RAW);
		Py_DECREF(v);
		return err;
	}
	else
		return -1;
}
</t>
<t tx="T453">@ Try to get a file-descriptor from a Python object. If the object  is an integer or long integer, its value is returned. If not, the  object's fileno() method is called if it exists; the method must return  an integer or long integer, which is returned as the file descriptor value.  -1 is returned on failure.
@c

int PyObject_AsFileDescriptor(PyObject *o)
{
	int fd;
	PyObject *meth;

	if (PyInt_Check(o)) {
		fd = PyInt_AsLong(o);
	}
	else if (PyLong_Check(o)) {
		fd = PyLong_AsLong(o);
	}
	else if ((meth = PyObject_GetAttrString(o, "fileno")) != NULL)
	{
		PyObject *fno = PyEval_CallObject(meth, NULL);
		Py_DECREF(meth);
		if (fno == NULL)
			return -1;

		if (PyInt_Check(fno)) {
			fd = PyInt_AsLong(fno);
			Py_DECREF(fno);
		}
		else if (PyLong_Check(fno)) {
			fd = PyLong_AsLong(fno);
			Py_DECREF(fno);
		}
		else {
			PyErr_SetString(PyExc_TypeError,
					"fileno() returned a non-integer");
			Py_DECREF(fno);
			return -1;
		}
	}
	else {
		PyErr_SetString(PyExc_TypeError,
				"argument must be an int, or have a fileno() method.");
		return -1;
	}

	if (fd &lt; 0) {
		PyErr_Format(PyExc_ValueError,
			     "file descriptor cannot be a negative integer (%i)",
			     fd);
		return -1;
	}
	return fd;
}
</t>
<t tx="T454">@ignore
@language c</t>
<t tx="T455">@language python

"""Disassembler of Python byte code into mnemonics."""

import sys
import types

__all__ = ["dis","disassemble","distb","disco","opname","cmp_op",
           "hasconst","hasname","hasjrel","hasjabs","haslocal",
           "hascompare", "hasfree"]

@others

if __name__ == "__main__":
    _test()
</t>
<t tx="T456">def dis(x=None):
    """Disassemble classes, methods, functions, or code.

    With no argument, disassemble the last traceback.

    """
    if not x:
        distb()
        return
    if type(x) is types.InstanceType:
        x = x.__class__
    if hasattr(x, 'im_func'):
        x = x.im_func
    if hasattr(x, 'func_code'):
        x = x.func_code
    if hasattr(x, '__dict__'):
        items = x.__dict__.items()
        items.sort()
        for name, x1 in items:
            if type(x1) in (types.MethodType,
                            types.FunctionType,
                            types.CodeType):
                print "Disassembly of %s:" % name
                try:
                    dis(x1)
                except TypeError, msg:
                    print "Sorry:", msg
                print
    elif hasattr(x, 'co_code'):
        disassemble(x)
    else:
        raise TypeError, \
              "don't know how to disassemble %s objects" % \
              type(x).__name__
</t>
<t tx="T457">def distb(tb=None):
    """Disassemble a traceback (default: last traceback)."""
    if not tb:
        try:
            tb = sys.last_traceback
        except AttributeError:
            raise RuntimeError, "no last traceback to disassemble"
        while tb.tb_next: tb = tb.tb_next
    disassemble(tb.tb_frame.f_code, tb.tb_lasti)
</t>
<t tx="T458">def disassemble(co, lasti=-1):
	
    """Disassemble a code object."""
    code = co.co_code
    labels = findlabels(code)
    n = len(code)
    i = 0
    extended_arg = 0
    free = None
    while i &lt; n:
        c = code[i]
        op = ord(c)
        if op == SET_LINENO and i &gt; 0: print # Extra blank line
        if i == lasti: print '--&gt;',
        else: print '   ',
        if i in labels: print '&gt;&gt;',
        else: print '  ',
        print `i`.rjust(4),
        print opname[op].ljust(20),
        i = i+1
        if op &gt;= HAVE_ARGUMENT:
            oparg = ord(code[i]) + ord(code[i+1])*256 + extended_arg
            extended_arg = 0
            i = i+2
            if op == EXTENDED_ARG:
                extended_arg = oparg*65536L
            print `oparg`.rjust(5),
            if op in hasconst:
                print '(' + `co.co_consts[oparg]` + ')',
            elif op in hasname:
                print '(' + co.co_names[oparg] + ')',
            elif op in hasjrel:
                print '(to ' + `i + oparg` + ')',
            elif op in haslocal:
                print '(' + co.co_varnames[oparg] + ')',
            elif op in hascompare:
                print '(' + cmp_op[oparg] + ')',
            elif op in hasfree:
                if free is None:
                    free = co.co_cellvars + co.co_freevars
                print '(' + free[oparg] + ')',
        print</t>
<t tx="T459">disco = disassemble                     # XXX For backwards compatibility

def findlabels(code):
    """Detect all offsets in a byte code which are jump targets.

    Return the list of offsets.

    """
    labels = []
    n = len(code)
    i = 0
    while i &lt; n:
        c = code[i]
        op = ord(c)
        i = i+1
        if op &gt;= HAVE_ARGUMENT:
            oparg = ord(code[i]) + ord(code[i+1])*256
            i = i+2
            label = -1
            if op in hasjrel:
                label = i+oparg
            elif op in hasjabs:
                label = oparg
            if label &gt;= 0:
                if label not in labels:
                    labels.append(label)
    return labels
</t>
<t tx="T460"></t>
<t tx="T461">cmp_op = ('&lt;', '&lt;=', '==', '!=', '&gt;', '&gt;=', 'in', 'not in', 'is',
        'is not', 'exception match', 'BAD')

hasconst = []
hasname = []
hasjrel = []
hasjabs = []
haslocal = []
hascompare = []
hasfree = []

opname = [''] * 256
for op in range(256): opname[op] = '&lt;' + `op` + '&gt;'</t>
<t tx="T462">def def_op(name, op):
    opname[op] = name
</t>
<t tx="T463">def name_op(name, op):
    opname[op] = name
    hasname.append(op)
</t>
<t tx="T464">def jrel_op(name, op):
    opname[op] = name
    hasjrel.append(op)
</t>
<t tx="T465">def jabs_op(name, op):
    opname[op] = name
    hasjabs.append(op)
</t>
<t tx="T466"># Instruction opcodes for compiled code

def_op('STOP_CODE', 0)
def_op('POP_TOP', 1)
def_op('ROT_TWO', 2)
def_op('ROT_THREE', 3)
def_op('DUP_TOP', 4)
def_op('ROT_FOUR', 5)

def_op('UNARY_POSITIVE', 10)
def_op('UNARY_NEGATIVE', 11)
def_op('UNARY_NOT', 12)
def_op('UNARY_CONVERT', 13)

def_op('UNARY_INVERT', 15)

def_op('BINARY_POWER', 19)

def_op('BINARY_MULTIPLY', 20)
def_op('BINARY_DIVIDE', 21)
def_op('BINARY_MODULO', 22)
def_op('BINARY_ADD', 23)
def_op('BINARY_SUBTRACT', 24)
def_op('BINARY_SUBSCR', 25)
def_op('BINARY_FLOOR_DIVIDE', 26)
def_op('BINARY_TRUE_DIVIDE', 27)
def_op('INPLACE_FLOOR_DIVIDE', 28)
def_op('INPLACE_TRUE_DIVIDE', 29)

def_op('SLICE+0', 30)
def_op('SLICE+1', 31)
def_op('SLICE+2', 32)
def_op('SLICE+3', 33)

def_op('STORE_SLICE+0', 40)
def_op('STORE_SLICE+1', 41)
def_op('STORE_SLICE+2', 42)
def_op('STORE_SLICE+3', 43)

def_op('DELETE_SLICE+0', 50)
def_op('DELETE_SLICE+1', 51)
def_op('DELETE_SLICE+2', 52)
def_op('DELETE_SLICE+3', 53)

def_op('INPLACE_ADD', 55)
def_op('INPLACE_SUBTRACT', 56)
def_op('INPLACE_MULTIPLY', 57)
def_op('INPLACE_DIVIDE', 58)
def_op('INPLACE_MODULO', 59)
def_op('STORE_SUBSCR', 60)
def_op('DELETE_SUBSCR', 61)

def_op('BINARY_LSHIFT', 62)
def_op('BINARY_RSHIFT', 63)
def_op('BINARY_AND', 64)
def_op('BINARY_XOR', 65)
def_op('BINARY_OR', 66)
def_op('INPLACE_POWER', 67)
def_op('GET_ITER', 68)

def_op('PRINT_EXPR', 70)
def_op('PRINT_ITEM', 71)
def_op('PRINT_NEWLINE', 72)
def_op('PRINT_ITEM_TO', 73)
def_op('PRINT_NEWLINE_TO', 74)
def_op('INPLACE_LSHIFT', 75)
def_op('INPLACE_RSHIFT', 76)
def_op('INPLACE_AND', 77)
def_op('INPLACE_XOR', 78)
def_op('INPLACE_OR', 79)
def_op('BREAK_LOOP', 80)

def_op('LOAD_LOCALS', 82)
def_op('RETURN_VALUE', 83)
def_op('IMPORT_STAR', 84)
def_op('EXEC_STMT', 85)
def_op('YIELD_STMT', 86)

def_op('POP_BLOCK', 87)
def_op('END_FINALLY', 88)
def_op('BUILD_CLASS', 89)

HAVE_ARGUMENT = 90              # Opcodes from here have an argument:

name_op('STORE_NAME', 90)       # Index in name list
name_op('DELETE_NAME', 91)      # ""
def_op('UNPACK_SEQUENCE', 92)   # Number of tuple items
jrel_op('FOR_ITER', 93)

name_op('STORE_ATTR', 95)       # Index in name list
name_op('DELETE_ATTR', 96)      # ""
name_op('STORE_GLOBAL', 97)     # ""
name_op('DELETE_GLOBAL', 98)    # ""
def_op('DUP_TOPX', 99)          # number of items to duplicate
def_op('LOAD_CONST', 100)       # Index in const list
hasconst.append(100)
name_op('LOAD_NAME', 101)       # Index in name list
def_op('BUILD_TUPLE', 102)      # Number of tuple items
def_op('BUILD_LIST', 103)       # Number of list items
def_op('BUILD_MAP', 104)        # Always zero for now
name_op('LOAD_ATTR', 105)       # Index in name list
def_op('COMPARE_OP', 106)       # Comparison operator
hascompare.append(106)
name_op('IMPORT_NAME', 107)     # Index in name list
name_op('IMPORT_FROM', 108)     # Index in name list

jrel_op('JUMP_FORWARD', 110)    # Number of bytes to skip
jrel_op('JUMP_IF_FALSE', 111)   # ""
jrel_op('JUMP_IF_TRUE', 112)    # ""
jabs_op('JUMP_ABSOLUTE', 113)   # Target byte offset from beginning of code
jrel_op('FOR_LOOP', 114)        # Number of bytes to skip

name_op('LOAD_GLOBAL', 116)     # Index in name list

jabs_op('CONTINUE_LOOP', 119)   # Target address
jrel_op('SETUP_LOOP', 120)      # Distance to target address
jrel_op('SETUP_EXCEPT', 121)    # ""
jrel_op('SETUP_FINALLY', 122)   # ""

def_op('LOAD_FAST', 124)        # Local variable number
haslocal.append(124)
def_op('STORE_FAST', 125)       # Local variable number
haslocal.append(125)
def_op('DELETE_FAST', 126)      # Local variable number
haslocal.append(126)

def_op('SET_LINENO', 127)       # Current line number
SET_LINENO = 127

def_op('RAISE_VARARGS', 130)    # Number of raise arguments (1, 2, or 3)
def_op('CALL_FUNCTION', 131)    # #args + (#kwargs &lt;&lt; 8)
def_op('MAKE_FUNCTION', 132)    # Number of args with default values
def_op('BUILD_SLICE', 133)      # Number of items

def_op('MAKE_CLOSURE', 134)
def_op('LOAD_CLOSURE', 135)
hasfree.append(135)
def_op('LOAD_DEREF', 136)
hasfree.append(136)
def_op('STORE_DEREF', 137)
hasfree.append(137)

def_op('CALL_FUNCTION_VAR', 140)     # #args + (#kwargs &lt;&lt; 8)
def_op('CALL_FUNCTION_KW', 141)      # #args + (#kwargs &lt;&lt; 8)
def_op('CALL_FUNCTION_VAR_KW', 142)  # #args + (#kwargs &lt;&lt; 8)

def_op('EXTENDED_ARG', 143)
EXTENDED_ARG = 143</t>
<t tx="T467">def _test():
    """Simple test program to disassemble a file."""
    if sys.argv[1:]:
        if sys.argv[2:]:
            sys.stderr.write("usage: python dis.py [-|file]\n")
            sys.exit(2)
        fn = sys.argv[1]
        if not fn or fn == "-":
            fn = None
    else:
        fn = None
    if not fn:
        f = sys.stdin
    else:
        f = open(fn)
    source = f.read()
    if fn:
        f.close()
    else:
        fn = "&lt;stdin&gt;"
    code = compile(source, fn, "exec")
    dis(code)</t>
<t tx="T468">@ignore
@language c</t>
<t tx="T469">@language c

/* Minimal main program -- everything is loaded from the library */

#include "Python.h"

extern DL_EXPORT(int) Py_Main(int, char **);

@others</t>
<t tx="T470">int
main(int argc, char **argv)
{
	return Py_Main(argc, argv);
}
</t>
<t tx="T471">@language c
/*  parsermodule.c
 *
 *  Copyright 1995-1996 by Fred L. Drake, Jr. and Virginia Polytechnic
 *  Institute and State University, Blacksburg, Virginia, USA.
 *  Portions copyright 1991-1995 by Stichting Mathematisch Centrum,
 *  Amsterdam, The Netherlands.  Copying is permitted under the terms
 *  associated with the main Python distribution, with the additional
 *  restriction that this additional notice be included and maintained
 *  on all distributed copies.
 *
 *  This module serves to replace the original parser module written
 *  by Guido.  The functionality is not matched precisely, but the
 *  original may be implemented on top of this.  This is desirable
 *  since the source of the text to be parsed is now divorced from
 *  this interface.
 *
 *  Unlike the prior interface, the ability to give a parse tree
 *  produced by Python code as a tuple to the compiler is enabled by
 *  this module.  See the documentation for more details.
 *
 *  I've added some annotations that help with the lint code-checking
 *  program, but they're not complete by a long shot.  The real errors
 *  that lint detects are gone, but there are still warnings with
 *  Py_[X]DECREF() and Py_[X]INCREF() macros.  The lint annotations
 *  look like "NOTE(...)".
 */

&lt;&lt; parsermodule #includes &gt;&gt;
&lt;&lt; parsermodule declarations &gt;&gt;
@others
</t>
<t tx="T472">#include "Python.h"                     /* general Python API             */
#include "graminit.h"                   /* symbols defined in the grammar */
#include "node.h"                       /* internal parser structure      */
#include "errcode.h"                    /* error codes for PyNode_*()     */
#include "token.h"                      /* token definitions              */
</t>
<t tx="T473">                                        /* ISTERMINAL() / ISNONTERMINAL() */
#include "compile.h"                    /* PyNode_Compile()               */

#ifdef lint
#include &lt;note.h&gt;
#else
#define NOTE(x)
#endif

#ifdef macintosh
char *strdup(char *);
#endif

/*  String constants used to initialize module attributes.
 *
 */
static char*
parser_copyright_string
= "Copyright 1995-1996 by Virginia Polytechnic Institute &amp; State\n\
University, Blacksburg, Virginia, USA, and Fred L. Drake, Jr., Reston,\n\
Virginia, USA.  Portions copyright 1991-1995 by Stichting Mathematisch\n\
Centrum, Amsterdam, The Netherlands.";


static char*
parser_doc_string
= "This is an interface to Python's internal parser.";

static char*
parser_version_string = "0.5";


typedef PyObject* (*SeqMaker) (int length);
typedef int (*SeqInserter) (PyObject* sequence,
                            int index,
                            PyObject* element);
</t>
<t tx="T474">@ The function below is copyrighted by Stichting Mathematisch Centrum. The * original copyright statement is included below, and continues to apply * in full to the function immediately following. All other material is * original, copyrighted by Fred L. Drake, Jr. and Virginia Polytechnic * Institute and State University. Changes were made to comply with the * new naming conventions. Added arguments to provide support for creating * lists as well as tuples, and optionally including the line numbers.
@c

static PyObject*
node2tuple(node *n,                     /* node to convert               */
           SeqMaker mkseq,              /* create sequence               */
           SeqInserter addelem,         /* func. to add elem. in seq.    */
           int lineno)                  /* include line numbers?         */
{
    if (n == NULL) {
        Py_INCREF(Py_None);
        return (Py_None);
    }
    if (ISNONTERMINAL(TYPE(n))) {
        int i;
        PyObject *v;
        PyObject *w;

        v = mkseq(1 + NCH(n));
        if (v == NULL)
            return (v);
        w = PyInt_FromLong(TYPE(n));
        if (w == NULL) {
            Py_DECREF(v);
            return ((PyObject*) NULL);
        }
        (void) addelem(v, 0, w);
        for (i = 0; i &lt; NCH(n); i++) {
            w = node2tuple(CHILD(n, i), mkseq, addelem, lineno);
            if (w == NULL) {
                Py_DECREF(v);
                return ((PyObject*) NULL);
            }
            (void) addelem(v, i+1, w);
        }
        return (v);
    }
    else if (ISTERMINAL(TYPE(n))) {
        PyObject *result = mkseq(2 + lineno);
        if (result != NULL) {
            (void) addelem(result, 0, PyInt_FromLong(TYPE(n)));
            (void) addelem(result, 1, PyString_FromString(STR(n)));
            if (lineno == 1)
                (void) addelem(result, 2, PyInt_FromLong(n-&gt;n_lineno));
        }
        return (result);
    }
    else {
        PyErr_SetString(PyExc_SystemError,
                        "unrecognized parse tree node type");
        return ((PyObject*) NULL);
    }
}
</t>
<t tx="T475">@ * End of material copyrighted by Stichting Mathematisch Centrum.
There are two types of intermediate objects we're interested in: * 'eval' and 'exec' types. These constants can be used in the st_type * field of the object type to identify which any given object represents. * These should probably go in an external header to allow other extensions * to use them, but then, we really should be using C++ too. ;-)
@c

#define PyST_EXPR  1
#define PyST_SUITE 2


/*  These are the internal objects and definitions required to implement the
 *  ST type.  Most of the internal names are more reminiscent of the 'old'
 *  naming style, but the code uses the new naming convention.
 */

static PyObject*
parser_error = 0;


typedef struct {
    PyObject_HEAD                       /* standard object header           */
    node* st_node;                      /* the node* returned by the parser */
    int   st_type;                      /* EXPR or SUITE ?                  */
} PyST_Object;


staticforward void
parser_free(PyST_Object *st);

staticforward int
parser_compare(PyST_Object *left, PyST_Object *right);

staticforward PyObject *
parser_getattr(PyObject *self, char *name);


static
PyTypeObject PyST_Type = {
    PyObject_HEAD_INIT(NULL)
    0,
    "parser.st",                        /* tp_name              */
    (int) sizeof(PyST_Object),          /* tp_basicsize         */
    0,                                  /* tp_itemsize          */
    (destructor)parser_free,            /* tp_dealloc           */
    0,                                  /* tp_print             */
    parser_getattr,                     /* tp_getattr           */
    0,                                  /* tp_setattr           */
    (cmpfunc)parser_compare,            /* tp_compare           */
    0,                                  /* tp_repr              */
    0,                                  /* tp_as_number         */
    0,                                  /* tp_as_sequence       */
    0,                                  /* tp_as_mapping        */
    0,                                  /* tp_hash              */
    0,                                  /* tp_call              */
    0,                                  /* tp_str               */
    0,                                  /* tp_getattro          */
    0,                                  /* tp_setattro          */

    /* Functions to access object as input/output buffer */
    0,                                  /* tp_as_buffer         */

    Py_TPFLAGS_DEFAULT,                 /* tp_flags             */

    /* __doc__ */
    "Intermediate representation of a Python parse tree."
};  /* PyST_Type */


static int
parser_compare_nodes(node *left, node *right)
{
    int j;

    if (TYPE(left) &lt; TYPE(right))
        return (-1);

    if (TYPE(right) &lt; TYPE(left))
        return (1);

    if (ISTERMINAL(TYPE(left)))
        return (strcmp(STR(left), STR(right)));

    if (NCH(left) &lt; NCH(right))
        return (-1);

    if (NCH(right) &lt; NCH(left))
        return (1);

    for (j = 0; j &lt; NCH(left); ++j) {
        int v = parser_compare_nodes(CHILD(left, j), CHILD(right, j));

        if (v != 0)
            return (v);
    }
    return (0);
}
</t>
<t tx="T476">@ int parser_compare(PyST_Object* left, PyST_Object* right) * * Comparison function used by the Python operators ==, !=, &lt;, &gt;, &lt;=, &gt;= * This really just wraps a call to parser_compare_nodes() with some easy * checks and protection code. *
@c

static int
parser_compare(PyST_Object *left, PyST_Object *right)
{
    if (left == right)
        return (0);

    if ((left == 0) || (right == 0))
        return (-1);

    return (parser_compare_nodes(left-&gt;st_node, right-&gt;st_node));
}
</t>
<t tx="T477">@ parser_newstobject(node* st) * * Allocates a new Python object representing an ST. This is simply the * 'wrapper' object that holds a node* and allows it to be passed around in * Python code. *
@c

static PyObject*
parser_newstobject(node *st, int type)
{
    PyST_Object* o = PyObject_New(PyST_Object, &amp;PyST_Type);

    if (o != 0) {
        o-&gt;st_node = st;
        o-&gt;st_type = type;
    }
    else {
        PyNode_Free(st);
    }
    return ((PyObject*)o);
}
</t>
<t tx="T478">@ void parser_free(PyST_Object* st) * * This is called by a del statement that reduces the reference count to 0. *
@c

static void
parser_free(PyST_Object *st)
{
    PyNode_Free(st-&gt;st_node);
    PyObject_Del(st);
}
</t>
<t tx="T479">@ parser_st2tuple(PyObject* self, PyObject* args, PyObject* kw) * * This provides conversion from a node* to a tuple object that can be * returned to the Python-level caller. The ST object is not modified. *
@c

static PyObject*
parser_st2tuple(PyST_Object *self, PyObject *args, PyObject *kw)
{
    PyObject *line_option = 0;
    PyObject *res = 0;
    int ok;

    static char *keywords[] = {"ast", "line_info", NULL};

    if (self == NULL) {
        ok = PyArg_ParseTupleAndKeywords(args, kw, "O!|O:st2tuple", keywords,
                                         &amp;PyST_Type, &amp;self, &amp;line_option);
    }
    else
        ok = PyArg_ParseTupleAndKeywords(args, kw, "|O:totuple", &amp;keywords[1],
                                         &amp;line_option);
    if (ok != 0) {
        int lineno = 0;
        if (line_option != NULL) {
            lineno = (PyObject_IsTrue(line_option) != 0) ? 1 : 0;
        }
        /*
         *  Convert ST into a tuple representation.  Use Guido's function,
         *  since it's known to work already.
         */
        res = node2tuple(((PyST_Object*)self)-&gt;st_node,
                         PyTuple_New, PyTuple_SetItem, lineno);
    }
    return (res);
}
</t>
<t tx="T480">@ parser_st2list(PyObject* self, PyObject* args, PyObject* kw) * * This provides conversion from a node* to a list object that can be * returned to the Python-level caller. The ST object is not modified. *
@c

static PyObject*
parser_st2list(PyST_Object *self, PyObject *args, PyObject *kw)
{
    PyObject *line_option = 0;
    PyObject *res = 0;
    int ok;

    static char *keywords[] = {"ast", "line_info", NULL};

    if (self == NULL)
        ok = PyArg_ParseTupleAndKeywords(args, kw, "O!|O:st2list", keywords,
                                         &amp;PyST_Type, &amp;self, &amp;line_option);
    else
        ok = PyArg_ParseTupleAndKeywords(args, kw, "|O:tolist", &amp;keywords[1],
                                         &amp;line_option);
    if (ok) {
        int lineno = 0;
        if (line_option != 0) {
            lineno = PyObject_IsTrue(line_option) ? 1 : 0;
        }
        /*
         *  Convert ST into a tuple representation.  Use Guido's function,
         *  since it's known to work already.
         */
        res = node2tuple(self-&gt;st_node,
                         PyList_New, PyList_SetItem, lineno);
    }
    return (res);
}
</t>
<t tx="T481">@ parser_compilest(PyObject* self, PyObject* args) * * This function creates code objects from the parse tree represented by * the passed-in data object. An optional file name is passed in as well. *
@c

static PyObject*
parser_compilest(PyST_Object *self, PyObject *args, PyObject *kw)
{
    PyObject*     res = 0;
    char*         str = "&lt;syntax-tree&gt;";
    int ok;

    static char *keywords[] = {"ast", "filename", NULL};

    if (self == NULL)
        ok = PyArg_ParseTupleAndKeywords(args, kw, "O!|s:compilest", keywords,
                                         &amp;PyST_Type, &amp;self, &amp;str);
    else
        ok = PyArg_ParseTupleAndKeywords(args, kw, "|s:compile", &amp;keywords[1],
                                         &amp;str);

    if (ok)
        res = (PyObject *)PyNode_Compile(self-&gt;st_node, str);

    return (res);
}
</t>
<t tx="T482">@ PyObject* parser_isexpr(PyObject* self, PyObject* args) * PyObject* parser_issuite(PyObject* self, PyObject* args) * * Checks the passed-in ST object to determine if it is an expression or * a statement suite, respectively. The return is a Python truth value. *
@c

static PyObject*
parser_isexpr(PyST_Object *self, PyObject *args, PyObject *kw)
{
    PyObject* res = 0;
    int ok;

    static char *keywords[] = {"ast", NULL};

    if (self == NULL)
        ok = PyArg_ParseTupleAndKeywords(args, kw, "O!:isexpr", keywords,
                                         &amp;PyST_Type, &amp;self);
    else
        ok = PyArg_ParseTupleAndKeywords(args, kw, ":isexpr", &amp;keywords[1]);

    if (ok) {
        /* Check to see if the ST represents an expression or not. */
        res = (self-&gt;st_type == PyST_EXPR) ? Py_True : Py_False;
        Py_INCREF(res);
    }
    return (res);
}
</t>
<t tx="T483">static PyObject*
parser_issuite(PyST_Object *self, PyObject *args, PyObject *kw)
{
    PyObject* res = 0;
    int ok;

    static char *keywords[] = {"ast", NULL};

    if (self == NULL)
        ok = PyArg_ParseTupleAndKeywords(args, kw, "O!:issuite", keywords,
                                         &amp;PyST_Type, &amp;self);
    else
        ok = PyArg_ParseTupleAndKeywords(args, kw, ":issuite", &amp;keywords[1]);

    if (ok) {
        /* Check to see if the ST represents an expression or not. */
        res = (self-&gt;st_type == PyST_EXPR) ? Py_False : Py_True;
        Py_INCREF(res);
    }
    return (res);
}
</t>
<t tx="T484">#define PUBLIC_METHOD_TYPE (METH_VARARGS|METH_KEYWORDS)

static PyMethodDef
parser_methods[] = {
    {"compile",         (PyCFunction)parser_compilest,  PUBLIC_METHOD_TYPE,
        "Compile this ST object into a code object."},
    {"isexpr",          (PyCFunction)parser_isexpr,     PUBLIC_METHOD_TYPE,
        "Determines if this ST object was created from an expression."},
    {"issuite",         (PyCFunction)parser_issuite,    PUBLIC_METHOD_TYPE,
        "Determines if this ST object was created from a suite."},
    {"tolist",          (PyCFunction)parser_st2list,    PUBLIC_METHOD_TYPE,
        "Creates a list-tree representation of this ST."},
    {"totuple",         (PyCFunction)parser_st2tuple,   PUBLIC_METHOD_TYPE,
        "Creates a tuple-tree representation of this ST."},

    {NULL, NULL, 0, NULL}
};


static PyObject*
parser_getattr(PyObject *self, char *name)
{
    return (Py_FindMethod(parser_methods, self, name));
}
</t>
<t tx="T485">@ err_string(char* message) * * Sets the error string for an exception of type ParserError. *
@c

static void
err_string(char *message)
{
    PyErr_SetString(parser_error, message);
}
</t>
<t tx="T486">@ PyObject* parser_do_parse(PyObject* args, int type) * * Internal function to actually execute the parse and return the result if * successful, or set an exception if not. *
@c

static PyObject*
parser_do_parse(PyObject *args, PyObject *kw, char *argspec, int type)
{
    char*     string = 0;
    PyObject* res    = 0;

    static char *keywords[] = {"source", NULL};

    if (PyArg_ParseTupleAndKeywords(args, kw, argspec, keywords, &amp;string)) {
        node* n = PyParser_SimpleParseString(string,
                                             (type == PyST_EXPR)
                                             ? eval_input : file_input);

        if (n != 0)
            res = parser_newstobject(n, type);
        else
            err_string("could not parse string");
    }
    return (res);
}
</t>
<t tx="T487">@ PyObject* parser_expr(PyObject* self, PyObject* args) * PyObject* parser_suite(PyObject* self, PyObject* args) * * External interfaces to the parser itself. Which is called determines if * the parser attempts to recognize an expression ('eval' form) or statement * suite ('exec' form). The real work is done by parser_do_parse() above. *
@c

static PyObject*
parser_expr(PyST_Object *self, PyObject *args, PyObject *kw)
{
    NOTE(ARGUNUSED(self))
    return (parser_do_parse(args, kw, "s:expr", PyST_EXPR));
}
</t>
<t tx="T488">static PyObject*
parser_suite(PyST_Object *self, PyObject *args, PyObject *kw)
{
    NOTE(ARGUNUSED(self))
    return (parser_do_parse(args, kw, "s:suite", PyST_SUITE));
}
</t>
<t tx="T489">@ This is the messy part of the code. Conversion from a tuple to an ST * object requires that the input tuple be valid without having to rely on * catching an exception from the compiler. This is done to allow the * compiler itself to remain fast, since most of its input will come from * the parser directly, and therefore be known to be syntactically correct. * This validation is done to ensure that we don't core dump the compile * phase, returning an exception instead. * * Two aspects can be broken out in this code: creating a node tree from * the tuple passed in, and verifying that it is indeed valid. It may be * advantageous to expand the number of ST types to include funcdefs and * lambdadefs to take advantage of the optimizer, recognizing those STs * here. They are not necessary, and not quite as useful in a raw form. * For now, let's get expressions and suites working reliably.
@c

staticforward node* build_node_tree(PyObject *tuple);
staticforward int   validate_expr_tree(node *tree);
staticforward int   validate_file_input(node *tree);


/*  PyObject* parser_tuple2st(PyObject* self, PyObject* args)
 *
 *  This is the public function, called from the Python code.  It receives a
 *  single tuple object from the caller, and creates an ST object if the
 *  tuple can be validated.  It does this by checking the first code of the
 *  tuple, and, if acceptable, builds the internal representation.  If this
 *  step succeeds, the internal representation is validated as fully as
 *  possible with the various validate_*() routines defined below.
 *
 *  This function must be changed if support is to be added for PyST_FRAGMENT
 *  ST objects.
 *
 */
static PyObject*
parser_tuple2st(PyST_Object *self, PyObject *args, PyObject *kw)
{
    NOTE(ARGUNUSED(self))
    PyObject *st = 0;
    PyObject *tuple;
    node *tree;

    static char *keywords[] = {"sequence", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kw, "O:sequence2st", keywords,
                                     &amp;tuple))
        return (0);
    if (!PySequence_Check(tuple)) {
        PyErr_SetString(PyExc_ValueError,
                        "sequence2st() requires a single sequence argument");
        return (0);
    }
    /*
     *  Convert the tree to the internal form before checking it.
     */
    tree = build_node_tree(tuple);
    if (tree != 0) {
        int start_sym = TYPE(tree);
        if (start_sym == eval_input) {
            /*  Might be an eval form.  */
            if (validate_expr_tree(tree))
                st = parser_newstobject(tree, PyST_EXPR);
            else
                PyNode_Free(tree);
        }
        else if (start_sym == file_input) {
            /*  This looks like an exec form so far.  */
            if (validate_file_input(tree))
                st = parser_newstobject(tree, PyST_SUITE);
            else
                PyNode_Free(tree);
        }
        else {
            /*  This is a fragment, at best. */
            PyNode_Free(tree);
            err_string("parse tree does not use a valid start symbol");
        }
    }
    /*  Make sure we throw an exception on all errors.  We should never
     *  get this, but we'd do well to be sure something is done.
     */
    if (st == NULL &amp;&amp; !PyErr_Occurred())
        err_string("unspecified ST error occurred");

    return st;
}
</t>
<t tx="T490">@ node* build_node_children() * * Iterate across the children of the current non-terminal node and build * their structures. If successful, return the root of this portion of * the tree, otherwise, 0. Any required exception will be specified already, * and no memory will have been deallocated. *
@c

static node*
build_node_children(PyObject *tuple, node *root, int *line_num)
{
    int len = PyObject_Size(tuple);
    int i, err;

    for (i = 1; i &lt; len; ++i) {
        /* elem must always be a sequence, however simple */
        PyObject* elem = PySequence_GetItem(tuple, i);
        int ok = elem != NULL;
        long  type = 0;
        char *strn = 0;

        if (ok)
            ok = PySequence_Check(elem);
        if (ok) {
            PyObject *temp = PySequence_GetItem(elem, 0);
            if (temp == NULL)
                ok = 0;
            else {
                ok = PyInt_Check(temp);
                if (ok)
                    type = PyInt_AS_LONG(temp);
                Py_DECREF(temp);
            }
        }
        if (!ok) {
            PyErr_SetObject(parser_error,
                            Py_BuildValue("os", elem,
                                          "Illegal node construct."));
            Py_XDECREF(elem);
            return (0);
        }
        if (ISTERMINAL(type)) {
            int len = PyObject_Size(elem);
            PyObject *temp;

            if ((len != 2) &amp;&amp; (len != 3)) {
                err_string("terminal nodes must have 2 or 3 entries");
                return 0;
            }
            temp = PySequence_GetItem(elem, 1);
            if (temp == NULL)
                return 0;
            if (!PyString_Check(temp)) {
                PyErr_Format(parser_error,
                             "second item in terminal node must be a string,"
                             " found %s",
                             ((PyTypeObject*)PyObject_Type(temp))-&gt;tp_name);
                Py_DECREF(temp);
                return 0;
            }
            if (len == 3) {
                PyObject *o = PySequence_GetItem(elem, 2);
                if (o != NULL) {
                    if (PyInt_Check(o))
                        *line_num = PyInt_AS_LONG(o);
                    else {
                        PyErr_Format(parser_error,
                                     "third item in terminal node must be an"
                                     " integer, found %s",
                                ((PyTypeObject*)PyObject_Type(temp))-&gt;tp_name);
                        Py_DECREF(o);
                        Py_DECREF(temp);
                        return 0;
                    }
                    Py_DECREF(o);
                }
            }
            len = PyString_GET_SIZE(temp) + 1;
            strn = (char *)PyMem_MALLOC(len);
            if (strn != NULL)
                (void) memcpy(strn, PyString_AS_STRING(temp), len);
            Py_DECREF(temp);
        }
        else if (!ISNONTERMINAL(type)) {
            /*
             *  It has to be one or the other; this is an error.
             *  Throw an exception.
             */
            PyErr_SetObject(parser_error,
                            Py_BuildValue("os", elem, "unknown node type."));
            Py_XDECREF(elem);
            return (0);
        }
        err = PyNode_AddChild(root, type, strn, *line_num);
        if (err == E_NOMEM) {
            PyMem_DEL(strn);
            return (node *) PyErr_NoMemory();
        }
        if (err == E_OVERFLOW) {
            PyMem_DEL(strn);
            PyErr_SetString(PyExc_ValueError,
                            "unsupported number of child nodes");
            return NULL;
        }

        if (ISNONTERMINAL(type)) {
            node* new_child = CHILD(root, i - 1);

            if (new_child != build_node_children(elem, new_child, line_num)) {
                Py_XDECREF(elem);
                return (0);
            }
        }
        else if (type == NEWLINE) {     /* It's true:  we increment the     */
            ++(*line_num);              /* line number *after* the newline! */
        }
        Py_XDECREF(elem);
    }
    return (root);
}
</t>
<t tx="T491">static node*
build_node_tree(PyObject *tuple)
{
    node* res = 0;
    PyObject *temp = PySequence_GetItem(tuple, 0);
    long num = -1;

    if (temp != NULL)
        num = PyInt_AsLong(temp);
    Py_XDECREF(temp);
    if (ISTERMINAL(num)) {
        /*
         *  The tuple is simple, but it doesn't start with a start symbol.
         *  Throw an exception now and be done with it.
         */
        tuple = Py_BuildValue("os", tuple,
                    "Illegal syntax-tree; cannot start with terminal symbol.");
        PyErr_SetObject(parser_error, tuple);
    }
    else if (ISNONTERMINAL(num)) {
        /*
         *  Not efficient, but that can be handled later.
         */
        int line_num = 0;

        res = PyNode_New(num);
        if (res != NULL) {
            if (res != build_node_children(tuple, res, &amp;line_num)) {
                PyNode_Free(res);
                res = NULL;
            }
        }
    }
    else
        /*  The tuple is illegal -- if the number is neither TERMINAL nor
         *  NONTERMINAL, we can't use it.  Not sure the implementation
         *  allows this condition, but the API doesn't preclude it.
         */
        PyErr_SetObject(parser_error,
                        Py_BuildValue("os", tuple,
                                      "Illegal component tuple."));

    return (res);
}
</t>
<t tx="T492">@ * Validation routines used within the validation section:
@c

staticforward int validate_terminal(node *terminal, int type, char *string);

#define validate_ampersand(ch)  validate_terminal(ch,      AMPER, "&amp;")
#define validate_circumflex(ch) validate_terminal(ch, CIRCUMFLEX, "^")
#define validate_colon(ch)      validate_terminal(ch,      COLON, ":")
#define validate_comma(ch)      validate_terminal(ch,      COMMA, ",")
#define validate_dedent(ch)     validate_terminal(ch,     DEDENT, "")
#define validate_equal(ch)      validate_terminal(ch,      EQUAL, "=")
#define validate_indent(ch)     validate_terminal(ch,     INDENT, (char*)NULL)
#define validate_lparen(ch)     validate_terminal(ch,       LPAR, "(")
#define validate_newline(ch)    validate_terminal(ch,    NEWLINE, (char*)NULL)
#define validate_rparen(ch)     validate_terminal(ch,       RPAR, ")")
#define validate_semi(ch)       validate_terminal(ch,       SEMI, ";")
#define validate_star(ch)       validate_terminal(ch,       STAR, "*")
#define validate_vbar(ch)       validate_terminal(ch,       VBAR, "|")
#define validate_doublestar(ch) validate_terminal(ch, DOUBLESTAR, "**")
#define validate_dot(ch)        validate_terminal(ch,        DOT, ".")
#define validate_name(ch, str)  validate_terminal(ch,       NAME, str)

#define VALIDATER(n)    static int validate_##n(node *tree)

VALIDATER(node);                VALIDATER(small_stmt);
VALIDATER(class);               VALIDATER(node);
VALIDATER(parameters);          VALIDATER(suite);
VALIDATER(testlist);            VALIDATER(varargslist);
VALIDATER(fpdef);               VALIDATER(fplist);
VALIDATER(stmt);                VALIDATER(simple_stmt);
VALIDATER(expr_stmt);           VALIDATER(power);
VALIDATER(print_stmt);          VALIDATER(del_stmt);
VALIDATER(return_stmt);         VALIDATER(list_iter);
VALIDATER(raise_stmt);          VALIDATER(import_stmt);
VALIDATER(global_stmt);         VALIDATER(list_if);
VALIDATER(assert_stmt);         VALIDATER(list_for);
VALIDATER(exec_stmt);           VALIDATER(compound_stmt);
VALIDATER(while);               VALIDATER(for);
VALIDATER(try);                 VALIDATER(except_clause);
VALIDATER(test);                VALIDATER(and_test);
VALIDATER(not_test);            VALIDATER(comparison);
VALIDATER(comp_op);             VALIDATER(expr);
VALIDATER(xor_expr);            VALIDATER(and_expr);
VALIDATER(shift_expr);          VALIDATER(arith_expr);
VALIDATER(term);                VALIDATER(factor);
VALIDATER(atom);                VALIDATER(lambdef);
VALIDATER(trailer);             VALIDATER(subscript);
VALIDATER(subscriptlist);       VALIDATER(sliceop);
VALIDATER(exprlist);            VALIDATER(dictmaker);
VALIDATER(arglist);             VALIDATER(argument);
VALIDATER(listmaker);           VALIDATER(yield_stmt);

#undef VALIDATER

#define is_even(n)      (((n) &amp; 1) == 0)
#define is_odd(n)       (((n) &amp; 1) == 1)


static int
validate_ntype(node *n, int t)
{
    if (TYPE(n) != t) {
        PyErr_Format(parser_error, "Expected node type %d, got %d.",
                     t, TYPE(n));
        return 0;
    }
    return 1;
}
</t>
<t tx="T493">@ Verifies that the number of child nodes is exactly 'num', raising * an exception if it isn't. The exception message does not indicate * the exact number of nodes, allowing this to be used to raise the * "right" exception when the wrong number of nodes is present in a * specific variant of a statement's syntax. This is commonly used * in that fashion.
@c

static int
validate_numnodes(node *n, int num, const char *const name)
{
    if (NCH(n) != num) {
        PyErr_Format(parser_error,
                     "Illegal number of children for %s node.", name);
        return 0;
    }
    return 1;
}
</t>
<t tx="T494">static int
validate_terminal(node *terminal, int type, char *string)
{
    int res = (validate_ntype(terminal, type)
               &amp;&amp; ((string == 0) || (strcmp(string, STR(terminal)) == 0)));

    if (!res &amp;&amp; !PyErr_Occurred()) {
        PyErr_Format(parser_error,
                     "Illegal terminal: expected \"%s\"", string);
    }
    return (res);
}
</t>
<t tx="T495">@ X (',' X) [',']
@c

static int
validate_repeating_list(node *tree, int ntype, int (*vfunc)(node *),
                        const char *const name)
{
    int nch = NCH(tree);
    int res = (nch &amp;&amp; validate_ntype(tree, ntype)
               &amp;&amp; vfunc(CHILD(tree, 0)));

    if (!res &amp;&amp; !PyErr_Occurred())
        (void) validate_numnodes(tree, 1, name);
    else {
        if (is_even(nch))
            res = validate_comma(CHILD(tree, --nch));
        if (res &amp;&amp; nch &gt; 1) {
            int pos = 1;
            for ( ; res &amp;&amp; pos &lt; nch; pos += 2)
                res = (validate_comma(CHILD(tree, pos))
                       &amp;&amp; vfunc(CHILD(tree, pos + 1)));
        }
    }
    return (res);
}
</t>
<t tx="T496">@ validate_class() * * classdef: *   'class' NAME ['(' testlist ')'] ':' suite
@c

static int
validate_class(node *tree)
{
    int nch = NCH(tree);
    int res = validate_ntype(tree, classdef) &amp;&amp; ((nch == 4) || (nch == 7));

    if (res) {
        res = (validate_name(CHILD(tree, 0), "class")
               &amp;&amp; validate_ntype(CHILD(tree, 1), NAME)
               &amp;&amp; validate_colon(CHILD(tree, nch - 2))
               &amp;&amp; validate_suite(CHILD(tree, nch - 1)));
    }
    else
        (void) validate_numnodes(tree, 4, "class");
    if (res &amp;&amp; (nch == 7)) {
        res = (validate_lparen(CHILD(tree, 2))
               &amp;&amp; validate_testlist(CHILD(tree, 3))
               &amp;&amp; validate_rparen(CHILD(tree, 4)));
    }
    return (res);
}
</t>
<t tx="T497">@ if_stmt: *   'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
@c

static int
validate_if(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, if_stmt)
               &amp;&amp; (nch &gt;= 4)
               &amp;&amp; validate_name(CHILD(tree, 0), "if")
               &amp;&amp; validate_test(CHILD(tree, 1))
               &amp;&amp; validate_colon(CHILD(tree, 2))
               &amp;&amp; validate_suite(CHILD(tree, 3)));

    if (res &amp;&amp; ((nch % 4) == 3)) {
        /*  ... 'else' ':' suite  */
        res = (validate_name(CHILD(tree, nch - 3), "else")
               &amp;&amp; validate_colon(CHILD(tree, nch - 2))
               &amp;&amp; validate_suite(CHILD(tree, nch - 1)));
        nch -= 3;
    }
    else if (!res &amp;&amp; !PyErr_Occurred())
        (void) validate_numnodes(tree, 4, "if");
    if ((nch % 4) != 0)
        /* Will catch the case for nch &lt; 4 */
        res = validate_numnodes(tree, 0, "if");
    else if (res &amp;&amp; (nch &gt; 4)) {
        /*  ... ('elif' test ':' suite)+ ...  */
        int j = 4;
        while ((j &lt; nch) &amp;&amp; res) {
            res = (validate_name(CHILD(tree, j), "elif")
                   &amp;&amp; validate_colon(CHILD(tree, j + 2))
                   &amp;&amp; validate_test(CHILD(tree, j + 1))
                   &amp;&amp; validate_suite(CHILD(tree, j + 3)));
            j += 4;
        }
    }
    return (res);
}
</t>
<t tx="T498">@ parameters: *   '(' [varargslist] ')' *
@c

static int
validate_parameters(node *tree)
{
    int nch = NCH(tree);
    int res = validate_ntype(tree, parameters) &amp;&amp; ((nch == 2) || (nch == 3));

    if (res) {
        res = (validate_lparen(CHILD(tree, 0))
               &amp;&amp; validate_rparen(CHILD(tree, nch - 1)));
        if (res &amp;&amp; (nch == 3))
            res = validate_varargslist(CHILD(tree, 1));
    }
    else {
        (void) validate_numnodes(tree, 2, "parameters");
    }
    return (res);
}
</t>
<t tx="T499">@ validate_suite() * * suite: *   simple_stmt *  | NEWLINE INDENT stmt+ DEDENT
@c

static int
validate_suite(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, suite) &amp;&amp; ((nch == 1) || (nch &gt;= 4)));

    if (res &amp;&amp; (nch == 1))
        res = validate_simple_stmt(CHILD(tree, 0));
    else if (res) {
        /*  NEWLINE INDENT stmt+ DEDENT  */
        res = (validate_newline(CHILD(tree, 0))
               &amp;&amp; validate_indent(CHILD(tree, 1))
               &amp;&amp; validate_stmt(CHILD(tree, 2))
               &amp;&amp; validate_dedent(CHILD(tree, nch - 1)));

        if (res &amp;&amp; (nch &gt; 4)) {
            int i = 3;
            --nch;                      /* forget the DEDENT     */
            for ( ; res &amp;&amp; (i &lt; nch); ++i)
                res = validate_stmt(CHILD(tree, i));
        }
        else if (nch &lt; 4)
            res = validate_numnodes(tree, 4, "suite");
    }
    return (res);
}
</t>
<t tx="T500">static int
validate_testlist(node *tree)
{
    return (validate_repeating_list(tree, testlist,
                                    validate_test, "testlist"));
}
</t>
<t tx="T501">static int
validate_testlist_safe(node *tree)
{
    return (validate_repeating_list(tree, testlist_safe,
                                    validate_test, "testlist_safe"));
}
</t>
<t tx="T502">@ '*' NAME [',' '**' NAME] | '**' NAME
@c

static int
validate_varargslist_trailer(node *tree, int start)
{
    int nch = NCH(tree);
    int res = 0;
    int sym;

    if (nch &lt;= start) {
        err_string("expected variable argument trailer for varargslist");
        return 0;
    }
    sym = TYPE(CHILD(tree, start));
    if (sym == STAR) {
        /*
         *  ('*' NAME [',' '**' NAME]
         */
        if (nch-start == 2)
            res = validate_name(CHILD(tree, start+1), NULL);
        else if (nch-start == 5)
            res = (validate_name(CHILD(tree, start+1), NULL)
                   &amp;&amp; validate_comma(CHILD(tree, start+2))
                   &amp;&amp; validate_doublestar(CHILD(tree, start+3))
                   &amp;&amp; validate_name(CHILD(tree, start+4), NULL));
    }
    else if (sym == DOUBLESTAR) {
        /*
         *  '**' NAME
         */
        if (nch-start == 2)
            res = validate_name(CHILD(tree, start+1), NULL);
    }
    if (!res)
        err_string("illegal variable argument trailer for varargslist");
    return res;
}
</t>
<t tx="T503">@ validate_varargslist() * * varargslist: *   (fpdef ['=' test] ',')* *      ('*' NAME [',' '**' NAME] *     | '**' NAME) *  | fpdef ['=' test] (',' fpdef ['=' test])* [','] *
@c

static int
validate_varargslist(node *tree)
{
    int nch = NCH(tree);
    int res = validate_ntype(tree, varargslist) &amp;&amp; (nch != 0);
    int sym;

    if (!res)
        return 0;
    if (nch &lt; 1) {
        err_string("varargslist missing child nodes");
        return 0;
    }
    sym = TYPE(CHILD(tree, 0));
    if (sym == STAR || sym == DOUBLESTAR)
        /* whole thing matches:
         *      '*' NAME [',' '**' NAME] | '**' NAME
         */
        res = validate_varargslist_trailer(tree, 0);
    else if (sym == fpdef) {
        int i = 0;

        sym = TYPE(CHILD(tree, nch-1));
        if (sym == NAME) {
            /*
             *   (fpdef ['=' test] ',')+
             *       ('*' NAME [',' '**' NAME]
             *     | '**' NAME)
             */
            /* skip over (fpdef ['=' test] ',')+ */
            while (res &amp;&amp; (i+2 &lt;= nch)) {
                res = validate_fpdef(CHILD(tree, i));
                ++i;
                if (res &amp;&amp; TYPE(CHILD(tree, i)) == EQUAL &amp;&amp; (i+2 &lt;= nch)) {
                    res = (validate_equal(CHILD(tree, i))
                           &amp;&amp; validate_test(CHILD(tree, i+1)));
                    if (res)
                        i += 2;
                }
                if (res &amp;&amp; i &lt; nch) {
                    res = validate_comma(CHILD(tree, i));
                    ++i;
                    if (res &amp;&amp; i &lt; nch
                        &amp;&amp; (TYPE(CHILD(tree, i)) == DOUBLESTAR
                            || TYPE(CHILD(tree, i)) == STAR))
                        break;
                }
            }
            /* ... '*' NAME [',' '**' NAME] | '**' NAME
             * i --^^^
             */
            if (res)
                res = validate_varargslist_trailer(tree, i);
        }
        else {
            /*
             *  fpdef ['=' test] (',' fpdef ['=' test])* [',']
             */
            /* strip trailing comma node */
            if (sym == COMMA) {
                res = validate_comma(CHILD(tree, nch-1));
                if (!res)
                    return 0;
                --nch;
            }
            /*
             *  fpdef ['=' test] (',' fpdef ['=' test])*
             */
            res = validate_fpdef(CHILD(tree, 0));
            ++i;
            if (res &amp;&amp; (i+2 &lt;= nch) &amp;&amp; TYPE(CHILD(tree, i)) == EQUAL) {
                res = (validate_equal(CHILD(tree, i))
                       &amp;&amp; validate_test(CHILD(tree, i+1)));
                i += 2;
            }
            /*
             *  ... (',' fpdef ['=' test])*
             *  i ---^^^
             */
            while (res &amp;&amp; (nch - i) &gt;= 2) {
                res = (validate_comma(CHILD(tree, i))
                       &amp;&amp; validate_fpdef(CHILD(tree, i+1)));
                i += 2;
                if (res &amp;&amp; (nch - i) &gt;= 2 &amp;&amp; TYPE(CHILD(tree, i)) == EQUAL) {
                    res = (validate_equal(CHILD(tree, i))
                           &amp;&amp; validate_test(CHILD(tree, i+1)));
                    i += 2;
                }
            }
            if (res &amp;&amp; nch - i != 0) {
                res = 0;
                err_string("illegal formation for varargslist");
            }
        }
    }
    return res;
}
</t>
<t tx="T504">@ list_iter: list_for | list_if
@c

static int
validate_list_iter(node *tree)
{
    int res = (validate_ntype(tree, list_iter)
               &amp;&amp; validate_numnodes(tree, 1, "list_iter"));
    if (res &amp;&amp; TYPE(CHILD(tree, 0)) == list_for)
        res = validate_list_for(CHILD(tree, 0));
    else
        res = validate_list_if(CHILD(tree, 0));

    return res;
}
</t>
<t tx="T505">@ list_for: 'for' exprlist 'in' testlist [list_iter]
@c

static int
validate_list_for(node *tree)
{
    int nch = NCH(tree);
    int res;

    if (nch == 5)
        res = validate_list_iter(CHILD(tree, 4));
    else
        res = validate_numnodes(tree, 4, "list_for");

    if (res)
        res = (validate_name(CHILD(tree, 0), "for")
               &amp;&amp; validate_exprlist(CHILD(tree, 1))
               &amp;&amp; validate_name(CHILD(tree, 2), "in")
               &amp;&amp; validate_testlist_safe(CHILD(tree, 3)));

    return res;
}
</t>
<t tx="T506">@ list_if: 'if' test [list_iter]
@c

static int
validate_list_if(node *tree)
{
    int nch = NCH(tree);
    int res;

    if (nch == 3)
        res = validate_list_iter(CHILD(tree, 2));
    else
        res = validate_numnodes(tree, 2, "list_if");

    if (res)
        res = (validate_name(CHILD(tree, 0), "if")
               &amp;&amp; validate_test(CHILD(tree, 1)));

    return res;
}
</t>
<t tx="T507">@ validate_fpdef() * * fpdef: *   NAME *  | '(' fplist ')'
@c

static int
validate_fpdef(node *tree)
{
    int nch = NCH(tree);
    int res = validate_ntype(tree, fpdef);

    if (res) {
        if (nch == 1)
            res = validate_ntype(CHILD(tree, 0), NAME);
        else if (nch == 3)
            res = (validate_lparen(CHILD(tree, 0))
                   &amp;&amp; validate_fplist(CHILD(tree, 1))
                   &amp;&amp; validate_rparen(CHILD(tree, 2)));
        else
            res = validate_numnodes(tree, 1, "fpdef");
    }
    return (res);
}
</t>
<t tx="T508">static int
validate_fplist(node *tree)
{
    return (validate_repeating_list(tree, fplist,
                                    validate_fpdef, "fplist"));
}
</t>
<t tx="T509">@ simple_stmt | compound_stmt *
@c

static int
validate_stmt(node *tree)
{
    int res = (validate_ntype(tree, stmt)
               &amp;&amp; validate_numnodes(tree, 1, "stmt"));

    if (res) {
        tree = CHILD(tree, 0);

        if (TYPE(tree) == simple_stmt)
            res = validate_simple_stmt(tree);
        else
            res = validate_compound_stmt(tree);
    }
    return (res);
}
</t>
<t tx="T510">@ small_stmt (';' small_stmt)* [';'] NEWLINE *
@c

static int
validate_simple_stmt(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, simple_stmt)
               &amp;&amp; (nch &gt;= 2)
               &amp;&amp; validate_small_stmt(CHILD(tree, 0))
               &amp;&amp; validate_newline(CHILD(tree, nch - 1)));

    if (nch &lt; 2)
        res = validate_numnodes(tree, 2, "simple_stmt");
    --nch;                              /* forget the NEWLINE    */
    if (res &amp;&amp; is_even(nch))
        res = validate_semi(CHILD(tree, --nch));
    if (res &amp;&amp; (nch &gt; 2)) {
        int i;

        for (i = 1; res &amp;&amp; (i &lt; nch); i += 2)
            res = (validate_semi(CHILD(tree, i))
                   &amp;&amp; validate_small_stmt(CHILD(tree, i + 1)));
    }
    return (res);
}
</t>
<t tx="T511">static int
validate_small_stmt(node *tree)
{
    int nch = NCH(tree);
    int res = validate_numnodes(tree, 1, "small_stmt");

    if (res) {
        int ntype = TYPE(CHILD(tree, 0));

        if (  (ntype == expr_stmt)
              || (ntype == print_stmt)
              || (ntype == del_stmt)
              || (ntype == pass_stmt)
              || (ntype == flow_stmt)
              || (ntype == import_stmt)
              || (ntype == global_stmt)
              || (ntype == assert_stmt)
              || (ntype == exec_stmt))
            res = validate_node(CHILD(tree, 0));
        else {
            res = 0;
            err_string("illegal small_stmt child type");
        }
    }
    else if (nch == 1) {
        res = 0;
        PyErr_Format(parser_error,
                     "Unrecognized child node of small_stmt: %d.",
                     TYPE(CHILD(tree, 0)));
    }
    return (res);
}
</t>
<t tx="T512">@ compound_stmt: *   if_stmt | while_stmt | for_stmt | try_stmt | funcdef | classdef
@c

static int
validate_compound_stmt(node *tree)
{
    int res = (validate_ntype(tree, compound_stmt)
               &amp;&amp; validate_numnodes(tree, 1, "compound_stmt"));
    int ntype;

    if (!res)
        return (0);

    tree = CHILD(tree, 0);
    ntype = TYPE(tree);
    if (  (ntype == if_stmt)
          || (ntype == while_stmt)
          || (ntype == for_stmt)
          || (ntype == try_stmt)
          || (ntype == funcdef)
          || (ntype == classdef))
        res = validate_node(tree);
    else {
        res = 0;
        PyErr_Format(parser_error,
                     "Illegal compound statement type: %d.", TYPE(tree));
    }
    return (res);
}
</t>
<t tx="T513">static int
validate_expr_stmt(node *tree)
{
    int j;
    int nch = NCH(tree);
    int res = (validate_ntype(tree, expr_stmt)
               &amp;&amp; is_odd(nch)
               &amp;&amp; validate_testlist(CHILD(tree, 0)));

    if (res &amp;&amp; nch == 3
        &amp;&amp; TYPE(CHILD(tree, 1)) == augassign) {
        res = (validate_numnodes(CHILD(tree, 1), 1, "augassign")
               &amp;&amp; validate_testlist(CHILD(tree, 2)));

        if (res) {
            char *s = STR(CHILD(CHILD(tree, 1), 0));

            res = (strcmp(s, "+=") == 0
                   || strcmp(s, "-=") == 0
                   || strcmp(s, "*=") == 0
                   || strcmp(s, "/=") == 0
                   || strcmp(s, "%=") == 0
                   || strcmp(s, "&amp;=") == 0
                   || strcmp(s, "|=") == 0
                   || strcmp(s, "^=") == 0
                   || strcmp(s, "&lt;&lt;=") == 0
                   || strcmp(s, "&gt;&gt;=") == 0
                   || strcmp(s, "**=") == 0);
            if (!res)
                err_string("illegal augmmented assignment operator");
        }
    }
    else {
        for (j = 1; res &amp;&amp; (j &lt; nch); j += 2)
            res = (validate_equal(CHILD(tree, j))
                   &amp;&amp; validate_testlist(CHILD(tree, j + 1)));
    }
    return (res);
}
</t>
<t tx="T514">@ print_stmt: * *   'print' ( [ test (',' test)* [','] ] *       | '&gt;&gt;' test [ (',' test)+ [','] ] )
@c

static int
validate_print_stmt(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, print_stmt)
               &amp;&amp; (nch &gt; 0)
               &amp;&amp; validate_name(CHILD(tree, 0), "print"));

    if (res &amp;&amp; nch &gt; 1) {
        int sym = TYPE(CHILD(tree, 1));
        int i = 1;
        int allow_trailing_comma = 1;

        if (sym == test)
            res = validate_test(CHILD(tree, i++));
        else {
            if (nch &lt; 3)
                res = validate_numnodes(tree, 3, "print_stmt");
            else {
                res = (validate_ntype(CHILD(tree, i), RIGHTSHIFT)
                       &amp;&amp; validate_test(CHILD(tree, i+1)));
                i += 2;
                allow_trailing_comma = 0;
            }
        }
        if (res) {
            /*  ... (',' test)* [',']  */
            while (res &amp;&amp; i+2 &lt;= nch) {
                res = (validate_comma(CHILD(tree, i))
                       &amp;&amp; validate_test(CHILD(tree, i+1)));
                allow_trailing_comma = 1;
                i += 2;
            }
            if (res &amp;&amp; !allow_trailing_comma)
                res = validate_numnodes(tree, i, "print_stmt");
            else if (res &amp;&amp; i &lt; nch)
                res = validate_comma(CHILD(tree, i));
        }
    }
    return (res);
}
</t>
<t tx="T515">static int
validate_del_stmt(node *tree)
{
    return (validate_numnodes(tree, 2, "del_stmt")
            &amp;&amp; validate_name(CHILD(tree, 0), "del")
            &amp;&amp; validate_exprlist(CHILD(tree, 1)));
}
</t>
<t tx="T516">static int
validate_return_stmt(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, return_stmt)
               &amp;&amp; ((nch == 1) || (nch == 2))
               &amp;&amp; validate_name(CHILD(tree, 0), "return"));

    if (res &amp;&amp; (nch == 2))
        res = validate_testlist(CHILD(tree, 1));

    return (res);
}
</t>
<t tx="T517">static int
validate_raise_stmt(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, raise_stmt)
               &amp;&amp; ((nch == 1) || (nch == 2) || (nch == 4) || (nch == 6)));

    if (res) {
        res = validate_name(CHILD(tree, 0), "raise");
        if (res &amp;&amp; (nch &gt;= 2))
            res = validate_test(CHILD(tree, 1));
        if (res &amp;&amp; nch &gt; 2) {
            res = (validate_comma(CHILD(tree, 2))
                   &amp;&amp; validate_test(CHILD(tree, 3)));
            if (res &amp;&amp; (nch &gt; 4))
                res = (validate_comma(CHILD(tree, 4))
                       &amp;&amp; validate_test(CHILD(tree, 5)));
        }
    }
    else
        (void) validate_numnodes(tree, 2, "raise");
    if (res &amp;&amp; (nch == 4))
        res = (validate_comma(CHILD(tree, 2))
               &amp;&amp; validate_test(CHILD(tree, 3)));

    return (res);
}
</t>
<t tx="T518">@ yield_stmt: 'yield' testlist
@c

static int
validate_yield_stmt(node *tree)
{
    return (validate_ntype(tree, yield_stmt)
            &amp;&amp; validate_numnodes(tree, 2, "yield_stmt")
            &amp;&amp; validate_name(CHILD(tree, 0), "yield")
            &amp;&amp; validate_testlist(CHILD(tree, 1)));
}
</t>
<t tx="T519">static int
validate_import_as_name(node *tree)
{
    int nch = NCH(tree);
    int ok = validate_ntype(tree, import_as_name);

    if (ok) {
        if (nch == 1)
            ok = validate_name(CHILD(tree, 0), NULL);
        else if (nch == 3)
            ok = (validate_name(CHILD(tree, 0), NULL)
                  &amp;&amp; validate_name(CHILD(tree, 1), "as")
                  &amp;&amp; validate_name(CHILD(tree, 2), NULL));
        else
            ok = validate_numnodes(tree, 3, "import_as_name");
    }
    return ok;
}
</t>
<t tx="T520">@ dotted_name: NAME ("." NAME)*
@c

static int
validate_dotted_name(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, dotted_name)
               &amp;&amp; is_odd(nch)
               &amp;&amp; validate_name(CHILD(tree, 0), NULL));
    int i;

    for (i = 1; res &amp;&amp; (i &lt; nch); i += 2) {
        res = (validate_dot(CHILD(tree, i))
               &amp;&amp; validate_name(CHILD(tree, i+1), NULL));
    }
    return res;
}
</t>
<t tx="T521">@ dotted_as_name: dotted_name [NAME NAME]
@c

static int
validate_dotted_as_name(node *tree)
{
    int nch = NCH(tree);
    int res = validate_ntype(tree, dotted_as_name);

    if (res) {
        if (nch == 1)
            res = validate_dotted_name(CHILD(tree, 0));
        else if (nch == 3)
            res = (validate_dotted_name(CHILD(tree, 0))
                   &amp;&amp; validate_name(CHILD(tree, 1), "as")
                   &amp;&amp; validate_name(CHILD(tree, 2), NULL));
        else {
            res = 0;
            err_string("illegal number of children for dotted_as_name");
        }
    }
    return res;
}
</t>
<t tx="T522">@ import_stmt: * *  'import' dotted_as_name (',' dotted_as_name)* * | 'from' dotted_name 'import' ('*' | import_as_name (',' import_as_name)*)
@c

static int
validate_import_stmt(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, import_stmt)
               &amp;&amp; (nch &gt;= 2) &amp;&amp; is_even(nch)
               &amp;&amp; validate_ntype(CHILD(tree, 0), NAME));

    if (res &amp;&amp; (strcmp(STR(CHILD(tree, 0)), "import") == 0)) {
        int j;

        res = validate_dotted_as_name(CHILD(tree, 1));
        for (j = 2; res &amp;&amp; (j &lt; nch); j += 2)
            res = (validate_comma(CHILD(tree, j))
                   &amp;&amp; validate_dotted_as_name(CHILD(tree, j + 1)));
    }
    else if (res &amp;&amp; (res = validate_name(CHILD(tree, 0), "from"))) {
        res = ((nch &gt;= 4) &amp;&amp; is_even(nch)
               &amp;&amp; validate_dotted_name(CHILD(tree, 1))
               &amp;&amp; validate_name(CHILD(tree, 2), "import"));
        if (nch == 4) {
            if (TYPE(CHILD(tree, 3)) == import_as_name)
                res = validate_import_as_name(CHILD(tree, 3));
            else
                res = validate_star(CHILD(tree, 3));
        }
        else {
            /*  'from' dotted_name 'import' import_as_name
             *      (',' import_as_name)+
             */
            int j;
            res = validate_import_as_name(CHILD(tree, 3));
            for (j = 4; res &amp;&amp; (j &lt; nch); j += 2)
                res = (validate_comma(CHILD(tree, j))
                       &amp;&amp; validate_import_as_name(CHILD(tree, j + 1)));
        }
    }
    else
        res = 0;

    return (res);
}
</t>
<t tx="T523">static int
validate_global_stmt(node *tree)
{
    int j;
    int nch = NCH(tree);
    int res = (validate_ntype(tree, global_stmt)
               &amp;&amp; is_even(nch) &amp;&amp; (nch &gt;= 2));

    if (res)
        res = (validate_name(CHILD(tree, 0), "global")
               &amp;&amp; validate_ntype(CHILD(tree, 1), NAME));
    for (j = 2; res &amp;&amp; (j &lt; nch); j += 2)
        res = (validate_comma(CHILD(tree, j))
               &amp;&amp; validate_ntype(CHILD(tree, j + 1), NAME));

    return (res);
}
</t>
<t tx="T524">@ exec_stmt: * * 'exec' expr ['in' test [',' test]]
@c

static int
validate_exec_stmt(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, exec_stmt)
               &amp;&amp; ((nch == 2) || (nch == 4) || (nch == 6))
               &amp;&amp; validate_name(CHILD(tree, 0), "exec")
               &amp;&amp; validate_expr(CHILD(tree, 1)));

    if (!res &amp;&amp; !PyErr_Occurred())
        err_string("illegal exec statement");
    if (res &amp;&amp; (nch &gt; 2))
        res = (validate_name(CHILD(tree, 2), "in")
               &amp;&amp; validate_test(CHILD(tree, 3)));
    if (res &amp;&amp; (nch == 6))
        res = (validate_comma(CHILD(tree, 4))
               &amp;&amp; validate_test(CHILD(tree, 5)));

    return (res);
}
</t>
<t tx="T525">@ assert_stmt: * * 'assert' test [',' test]
@c

static int
validate_assert_stmt(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, assert_stmt)
               &amp;&amp; ((nch == 2) || (nch == 4))
               &amp;&amp; (validate_name(CHILD(tree, 0), "__assert__") ||
                   validate_name(CHILD(tree, 0), "assert"))
               &amp;&amp; validate_test(CHILD(tree, 1)));

    if (!res &amp;&amp; !PyErr_Occurred())
        err_string("illegal assert statement");
    if (res &amp;&amp; (nch &gt; 2))
        res = (validate_comma(CHILD(tree, 2))
               &amp;&amp; validate_test(CHILD(tree, 3)));

    return (res);
}
</t>
<t tx="T526">static int
validate_while(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, while_stmt)
               &amp;&amp; ((nch == 4) || (nch == 7))
               &amp;&amp; validate_name(CHILD(tree, 0), "while")
               &amp;&amp; validate_test(CHILD(tree, 1))
               &amp;&amp; validate_colon(CHILD(tree, 2))
               &amp;&amp; validate_suite(CHILD(tree, 3)));

    if (res &amp;&amp; (nch == 7))
        res = (validate_name(CHILD(tree, 4), "else")
               &amp;&amp; validate_colon(CHILD(tree, 5))
               &amp;&amp; validate_suite(CHILD(tree, 6)));

    return (res);
}
</t>
<t tx="T527">static int
validate_for(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, for_stmt)
               &amp;&amp; ((nch == 6) || (nch == 9))
               &amp;&amp; validate_name(CHILD(tree, 0), "for")
               &amp;&amp; validate_exprlist(CHILD(tree, 1))
               &amp;&amp; validate_name(CHILD(tree, 2), "in")
               &amp;&amp; validate_testlist(CHILD(tree, 3))
               &amp;&amp; validate_colon(CHILD(tree, 4))
               &amp;&amp; validate_suite(CHILD(tree, 5)));

    if (res &amp;&amp; (nch == 9))
        res = (validate_name(CHILD(tree, 6), "else")
               &amp;&amp; validate_colon(CHILD(tree, 7))
               &amp;&amp; validate_suite(CHILD(tree, 8)));

    return (res);
}
</t>
<t tx="T528">@ try_stmt: *   'try' ':' suite (except_clause ':' suite)+ ['else' ':' suite] *  | 'try' ':' suite 'finally' ':' suite *
@c

static int
validate_try(node *tree)
{
    int nch = NCH(tree);
    int pos = 3;
    int res = (validate_ntype(tree, try_stmt)
               &amp;&amp; (nch &gt;= 6) &amp;&amp; ((nch % 3) == 0));

    if (res)
        res = (validate_name(CHILD(tree, 0), "try")
               &amp;&amp; validate_colon(CHILD(tree, 1))
               &amp;&amp; validate_suite(CHILD(tree, 2))
               &amp;&amp; validate_colon(CHILD(tree, nch - 2))
               &amp;&amp; validate_suite(CHILD(tree, nch - 1)));
    else if (!PyErr_Occurred()) {
        const char* name = "except";
        if (TYPE(CHILD(tree, nch - 3)) != except_clause)
            name = STR(CHILD(tree, nch - 3));

        PyErr_Format(parser_error,
                     "Illegal number of children for try/%s node.", name);
    }
    /*  Skip past except_clause sections:  */
    while (res &amp;&amp; (TYPE(CHILD(tree, pos)) == except_clause)) {
        res = (validate_except_clause(CHILD(tree, pos))
               &amp;&amp; validate_colon(CHILD(tree, pos + 1))
               &amp;&amp; validate_suite(CHILD(tree, pos + 2)));
        pos += 3;
    }
    if (res &amp;&amp; (pos &lt; nch)) {
        res = validate_ntype(CHILD(tree, pos), NAME);
        if (res &amp;&amp; (strcmp(STR(CHILD(tree, pos)), "finally") == 0))
            res = (validate_numnodes(tree, 6, "try/finally")
                   &amp;&amp; validate_colon(CHILD(tree, 4))
                   &amp;&amp; validate_suite(CHILD(tree, 5)));
        else if (res) {
            if (nch == (pos + 3)) {
                res = ((strcmp(STR(CHILD(tree, pos)), "except") == 0)
                       || (strcmp(STR(CHILD(tree, pos)), "else") == 0));
                if (!res)
                    err_string("illegal trailing triple in try statement");
            }
            else if (nch == (pos + 6)) {
                res = (validate_name(CHILD(tree, pos), "except")
                       &amp;&amp; validate_colon(CHILD(tree, pos + 1))
                       &amp;&amp; validate_suite(CHILD(tree, pos + 2))
                       &amp;&amp; validate_name(CHILD(tree, pos + 3), "else"));
            }
            else
                res = validate_numnodes(tree, pos + 3, "try/except");
        }
    }
    return (res);
}
</t>
<t tx="T529">static int
validate_except_clause(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, except_clause)
               &amp;&amp; ((nch == 1) || (nch == 2) || (nch == 4))
               &amp;&amp; validate_name(CHILD(tree, 0), "except"));

    if (res &amp;&amp; (nch &gt; 1))
        res = validate_test(CHILD(tree, 1));
    if (res &amp;&amp; (nch == 4))
        res = (validate_comma(CHILD(tree, 2))
               &amp;&amp; validate_test(CHILD(tree, 3)));

    return (res);
}
</t>
<t tx="T530">static int
validate_test(node *tree)
{
    int nch = NCH(tree);
    int res = validate_ntype(tree, test) &amp;&amp; is_odd(nch);

    if (res &amp;&amp; (TYPE(CHILD(tree, 0)) == lambdef))
        res = ((nch == 1)
               &amp;&amp; validate_lambdef(CHILD(tree, 0)));
    else if (res) {
        int pos;
        res = validate_and_test(CHILD(tree, 0));
        for (pos = 1; res &amp;&amp; (pos &lt; nch); pos += 2)
            res = (validate_name(CHILD(tree, pos), "or")
                   &amp;&amp; validate_and_test(CHILD(tree, pos + 1)));
    }
    return (res);
}
</t>
<t tx="T531">static int
validate_and_test(node *tree)
{
    int pos;
    int nch = NCH(tree);
    int res = (validate_ntype(tree, and_test)
               &amp;&amp; is_odd(nch)
               &amp;&amp; validate_not_test(CHILD(tree, 0)));

    for (pos = 1; res &amp;&amp; (pos &lt; nch); pos += 2)
        res = (validate_name(CHILD(tree, pos), "and")
               &amp;&amp; validate_not_test(CHILD(tree, 0)));

    return (res);
}
</t>
<t tx="T532">static int
validate_not_test(node *tree)
{
    int nch = NCH(tree);
    int res = validate_ntype(tree, not_test) &amp;&amp; ((nch == 1) || (nch == 2));

    if (res) {
        if (nch == 2)
            res = (validate_name(CHILD(tree, 0), "not")
                   &amp;&amp; validate_not_test(CHILD(tree, 1)));
        else if (nch == 1)
            res = validate_comparison(CHILD(tree, 0));
    }
    return (res);
}
</t>
<t tx="T533">static int
validate_comparison(node *tree)
{
    int pos;
    int nch = NCH(tree);
    int res = (validate_ntype(tree, comparison)
               &amp;&amp; is_odd(nch)
               &amp;&amp; validate_expr(CHILD(tree, 0)));

    for (pos = 1; res &amp;&amp; (pos &lt; nch); pos += 2)
        res = (validate_comp_op(CHILD(tree, pos))
               &amp;&amp; validate_expr(CHILD(tree, pos + 1)));

    return (res);
}
</t>
<t tx="T534">static int
validate_comp_op(node *tree)
{
    int res = 0;
    int nch = NCH(tree);

    if (!validate_ntype(tree, comp_op))
        return (0);
    if (nch == 1) {
        /*
         *  Only child will be a terminal with a well-defined symbolic name
         *  or a NAME with a string of either 'is' or 'in'
         */
        tree = CHILD(tree, 0);
        switch (TYPE(tree)) {
            case LESS:
            case GREATER:
            case EQEQUAL:
            case EQUAL:
            case LESSEQUAL:
            case GREATEREQUAL:
            case NOTEQUAL:
              res = 1;
              break;
            case NAME:
              res = ((strcmp(STR(tree), "in") == 0)
                     || (strcmp(STR(tree), "is") == 0));
              if (!res) {
                  PyErr_Format(parser_error,
                               "illegal operator '%s'", STR(tree));
              }
              break;
          default:
              err_string("illegal comparison operator type");
              break;
        }
    }
    else if ((res = validate_numnodes(tree, 2, "comp_op")) != 0) {
        res = (validate_ntype(CHILD(tree, 0), NAME)
               &amp;&amp; validate_ntype(CHILD(tree, 1), NAME)
               &amp;&amp; (((strcmp(STR(CHILD(tree, 0)), "is") == 0)
                    &amp;&amp; (strcmp(STR(CHILD(tree, 1)), "not") == 0))
                   || ((strcmp(STR(CHILD(tree, 0)), "not") == 0)
                       &amp;&amp; (strcmp(STR(CHILD(tree, 1)), "in") == 0))));
        if (!res &amp;&amp; !PyErr_Occurred())
            err_string("unknown comparison operator");
    }
    return (res);
}
</t>
<t tx="T535">static int
validate_expr(node *tree)
{
    int j;
    int nch = NCH(tree);
    int res = (validate_ntype(tree, expr)
               &amp;&amp; is_odd(nch)
               &amp;&amp; validate_xor_expr(CHILD(tree, 0)));

    for (j = 2; res &amp;&amp; (j &lt; nch); j += 2)
        res = (validate_xor_expr(CHILD(tree, j))
               &amp;&amp; validate_vbar(CHILD(tree, j - 1)));

    return (res);
}
</t>
<t tx="T536">static int
validate_xor_expr(node *tree)
{
    int j;
    int nch = NCH(tree);
    int res = (validate_ntype(tree, xor_expr)
               &amp;&amp; is_odd(nch)
               &amp;&amp; validate_and_expr(CHILD(tree, 0)));

    for (j = 2; res &amp;&amp; (j &lt; nch); j += 2)
        res = (validate_circumflex(CHILD(tree, j - 1))
               &amp;&amp; validate_and_expr(CHILD(tree, j)));

    return (res);
}
</t>
<t tx="T537">static int
validate_and_expr(node *tree)
{
    int pos;
    int nch = NCH(tree);
    int res = (validate_ntype(tree, and_expr)
               &amp;&amp; is_odd(nch)
               &amp;&amp; validate_shift_expr(CHILD(tree, 0)));

    for (pos = 1; res &amp;&amp; (pos &lt; nch); pos += 2)
        res = (validate_ampersand(CHILD(tree, pos))
               &amp;&amp; validate_shift_expr(CHILD(tree, pos + 1)));

    return (res);
}
</t>
<t tx="T538">static int
validate_chain_two_ops(node *tree, int (*termvalid)(node *), int op1, int op2)
 {
    int pos = 1;
    int nch = NCH(tree);
    int res = (is_odd(nch)
               &amp;&amp; (*termvalid)(CHILD(tree, 0)));

    for ( ; res &amp;&amp; (pos &lt; nch); pos += 2) {
        if (TYPE(CHILD(tree, pos)) != op1)
            res = validate_ntype(CHILD(tree, pos), op2);
        if (res)
            res = (*termvalid)(CHILD(tree, pos + 1));
    }
    return (res);
}
</t>
<t tx="T539">static int
validate_shift_expr(node *tree)
{
    return (validate_ntype(tree, shift_expr)
            &amp;&amp; validate_chain_two_ops(tree, validate_arith_expr,
                                      LEFTSHIFT, RIGHTSHIFT));
}
</t>
<t tx="T540">static int
validate_arith_expr(node *tree)
{
    return (validate_ntype(tree, arith_expr)
            &amp;&amp; validate_chain_two_ops(tree, validate_term, PLUS, MINUS));
}
</t>
<t tx="T541">static int
validate_term(node *tree)
{
    int pos = 1;
    int nch = NCH(tree);
    int res = (validate_ntype(tree, term)
               &amp;&amp; is_odd(nch)
               &amp;&amp; validate_factor(CHILD(tree, 0)));

    for ( ; res &amp;&amp; (pos &lt; nch); pos += 2)
        res = (((TYPE(CHILD(tree, pos)) == STAR)
               || (TYPE(CHILD(tree, pos)) == SLASH)
               || (TYPE(CHILD(tree, pos)) == PERCENT))
               &amp;&amp; validate_factor(CHILD(tree, pos + 1)));

    return (res);
}
</t>
<t tx="T542">@ factor: * * factor: ('+'|'-'|'~') factor | power
@c

static int
validate_factor(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, factor)
               &amp;&amp; (((nch == 2)
                    &amp;&amp; ((TYPE(CHILD(tree, 0)) == PLUS)
                        || (TYPE(CHILD(tree, 0)) == MINUS)
                        || (TYPE(CHILD(tree, 0)) == TILDE))
                    &amp;&amp; validate_factor(CHILD(tree, 1)))
                   || ((nch == 1)
                       &amp;&amp; validate_power(CHILD(tree, 0)))));
    return (res);
}
</t>
<t tx="T543">@ power: * * power: atom trailer* ('**' factor)*
@c

static int
validate_power(node *tree)
{
    int pos = 1;
    int nch = NCH(tree);
    int res = (validate_ntype(tree, power) &amp;&amp; (nch &gt;= 1)
               &amp;&amp; validate_atom(CHILD(tree, 0)));

    while (res &amp;&amp; (pos &lt; nch) &amp;&amp; (TYPE(CHILD(tree, pos)) == trailer))
        res = validate_trailer(CHILD(tree, pos++));
    if (res &amp;&amp; (pos &lt; nch)) {
        if (!is_even(nch - pos)) {
            err_string("illegal number of nodes for 'power'");
            return (0);
        }
        for ( ; res &amp;&amp; (pos &lt; (nch - 1)); pos += 2)
            res = (validate_doublestar(CHILD(tree, pos))
                   &amp;&amp; validate_factor(CHILD(tree, pos + 1)));
    }
    return (res);
}
</t>
<t tx="T544">static int
validate_atom(node *tree)
{
    int pos;
    int nch = NCH(tree);
    int res = validate_ntype(tree, atom);

    if (res &amp;&amp; nch &lt; 1)
        res = validate_numnodes(tree, nch+1, "atom");
    if (res) {
        switch (TYPE(CHILD(tree, 0))) {
          case LPAR:
            res = ((nch &lt;= 3)
                   &amp;&amp; (validate_rparen(CHILD(tree, nch - 1))));

            if (res &amp;&amp; (nch == 3))
                res = validate_testlist(CHILD(tree, 1));
            break;
          case LSQB:
            if (nch == 2)
                res = validate_ntype(CHILD(tree, 1), RSQB);
            else if (nch == 3)
                res = (validate_listmaker(CHILD(tree, 1))
                       &amp;&amp; validate_ntype(CHILD(tree, 2), RSQB));
            else {
                res = 0;
                err_string("illegal list display atom");
            }
            break;
          case LBRACE:
            res = ((nch &lt;= 3)
                   &amp;&amp; validate_ntype(CHILD(tree, nch - 1), RBRACE));

            if (res &amp;&amp; (nch == 3))
                res = validate_dictmaker(CHILD(tree, 1));
            break;
          case BACKQUOTE:
            res = ((nch == 3)
                   &amp;&amp; validate_testlist(CHILD(tree, 1))
                   &amp;&amp; validate_ntype(CHILD(tree, 2), BACKQUOTE));
            break;
          case NAME:
          case NUMBER:
            res = (nch == 1);
            break;
          case STRING:
            for (pos = 1; res &amp;&amp; (pos &lt; nch); ++pos)
                res = validate_ntype(CHILD(tree, pos), STRING);
            break;
          default:
            res = 0;
            break;
        }
    }
    return (res);
}
</t>
<t tx="T545">@ listmaker: *  test ( list_for | (',' test)* [','] )
@c

static int
validate_listmaker(node *tree)
{
    int nch = NCH(tree);
    int ok = nch;

    if (nch == 0)
        err_string("missing child nodes of listmaker");
    else
        ok = validate_test(CHILD(tree, 0));

    /*
     *  list_iter | (',' test)* [',']
     */
    if (nch == 2 &amp;&amp; TYPE(CHILD(tree, 1)) == list_for)
        ok = validate_list_for(CHILD(tree, 1));
    else {
        /*  (',' test)* [',']  */
        int i = 1;
        while (ok &amp;&amp; nch - i &gt;= 2) {
            ok = (validate_comma(CHILD(tree, i))
                  &amp;&amp; validate_test(CHILD(tree, i+1)));
            i += 2;
        }
        if (ok &amp;&amp; i == nch-1)
            ok = validate_comma(CHILD(tree, i));
        else if (i != nch) {
            ok = 0;
            err_string("illegal trailing nodes for listmaker");
        }
    }
    return ok;
}
</t>
<t tx="T546">@ funcdef: *   'def' NAME parameters ':' suite *
@c

static int
validate_funcdef(node *tree)
{
    return (validate_ntype(tree, funcdef)
            &amp;&amp; validate_numnodes(tree, 5, "funcdef")
            &amp;&amp; validate_name(CHILD(tree, 0), "def")
            &amp;&amp; validate_ntype(CHILD(tree, 1), NAME)
            &amp;&amp; validate_colon(CHILD(tree, 3))
            &amp;&amp; validate_parameters(CHILD(tree, 2))
            &amp;&amp; validate_suite(CHILD(tree, 4)));
}
</t>
<t tx="T547">static int
validate_lambdef(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, lambdef)
               &amp;&amp; ((nch == 3) || (nch == 4))
               &amp;&amp; validate_name(CHILD(tree, 0), "lambda")
               &amp;&amp; validate_colon(CHILD(tree, nch - 2))
               &amp;&amp; validate_test(CHILD(tree, nch - 1)));

    if (res &amp;&amp; (nch == 4))
        res = validate_varargslist(CHILD(tree, 1));
    else if (!res &amp;&amp; !PyErr_Occurred())
        (void) validate_numnodes(tree, 3, "lambdef");

    return (res);
}
</t>
<t tx="T548">@ arglist: * * (argument ',')* (argument [','] | '*' test [',' '**' test] | '**' test)
@c

static int
validate_arglist(node *tree)
{
    int nch = NCH(tree);
    int i = 0;
    int ok = 1;

    if (nch &lt;= 0)
        /* raise the right error from having an invalid number of children */
        return validate_numnodes(tree, nch + 1, "arglist");

    while (ok &amp;&amp; nch-i &gt;= 2) {
        /* skip leading (argument ',') */
        ok = (validate_argument(CHILD(tree, i))
              &amp;&amp; validate_comma(CHILD(tree, i+1)));
        if (ok)
            i += 2;
        else
            PyErr_Clear();
    }
    ok = 1;
    if (nch-i &gt; 0) {
        /*
         * argument | '*' test [',' '**' test] | '**' test
         */
        int sym = TYPE(CHILD(tree, i));

        if (sym == argument) {
            ok = validate_argument(CHILD(tree, i));
            if (ok &amp;&amp; i+1 != nch) {
                err_string("illegal arglist specification"
                           " (extra stuff on end)");
                ok = 0;
            }
        }
        else if (sym == STAR) {
            ok = validate_star(CHILD(tree, i));
            if (ok &amp;&amp; (nch-i == 2))
                ok = validate_test(CHILD(tree, i+1));
            else if (ok &amp;&amp; (nch-i == 5))
                ok = (validate_test(CHILD(tree, i+1))
                      &amp;&amp; validate_comma(CHILD(tree, i+2))
                      &amp;&amp; validate_doublestar(CHILD(tree, i+3))
                      &amp;&amp; validate_test(CHILD(tree, i+4)));
            else {
                err_string("illegal use of '*' in arglist");
                ok = 0;
            }
        }
        else if (sym == DOUBLESTAR) {
            if (nch-i == 2)
                ok = (validate_doublestar(CHILD(tree, i))
                      &amp;&amp; validate_test(CHILD(tree, i+1)));
            else {
                err_string("illegal use of '**' in arglist");
                ok = 0;
            }
        }
        else {
            err_string("illegal arglist specification");
            ok = 0;
        }
    }
    return (ok);
}
</t>
<t tx="T549">@ argument: * * [test '='] test
@c

static int
validate_argument(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, argument)
               &amp;&amp; ((nch == 1) || (nch == 3))
               &amp;&amp; validate_test(CHILD(tree, 0)));

    if (res &amp;&amp; (nch == 3))
        res = (validate_equal(CHILD(tree, 1))
               &amp;&amp; validate_test(CHILD(tree, 2)));

    return (res);
}
</t>
<t tx="T550">@ trailer: * * '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
@c

static int
validate_trailer(node *tree)
{
    int nch = NCH(tree);
    int res = validate_ntype(tree, trailer) &amp;&amp; ((nch == 2) || (nch == 3));

    if (res) {
        switch (TYPE(CHILD(tree, 0))) {
          case LPAR:
            res = validate_rparen(CHILD(tree, nch - 1));
            if (res &amp;&amp; (nch == 3))
                res = validate_arglist(CHILD(tree, 1));
            break;
          case LSQB:
            res = (validate_numnodes(tree, 3, "trailer")
                   &amp;&amp; validate_subscriptlist(CHILD(tree, 1))
                   &amp;&amp; validate_ntype(CHILD(tree, 2), RSQB));
            break;
          case DOT:
            res = (validate_numnodes(tree, 2, "trailer")
                   &amp;&amp; validate_ntype(CHILD(tree, 1), NAME));
            break;
          default:
            res = 0;
            break;
        }
    }
    else {
        (void) validate_numnodes(tree, 2, "trailer");
    }
    return (res);
}
</t>
<t tx="T551">@ subscriptlist: * * subscript (',' subscript)* [',']
@c

static int
validate_subscriptlist(node *tree)
{
    return (validate_repeating_list(tree, subscriptlist,
                                    validate_subscript, "subscriptlist"));
}
</t>
<t tx="T552">@ subscript: * * '.' '.' '.' | test | [test] ':' [test] [sliceop]
@c

static int
validate_subscript(node *tree)
{
    int offset = 0;
    int nch = NCH(tree);
    int res = validate_ntype(tree, subscript) &amp;&amp; (nch &gt;= 1) &amp;&amp; (nch &lt;= 4);

    if (!res) {
        if (!PyErr_Occurred())
            err_string("invalid number of arguments for subscript node");
        return (0);
    }
    if (TYPE(CHILD(tree, 0)) == DOT)
        /* take care of ('.' '.' '.') possibility */
        return (validate_numnodes(tree, 3, "subscript")
                &amp;&amp; validate_dot(CHILD(tree, 0))
                &amp;&amp; validate_dot(CHILD(tree, 1))
                &amp;&amp; validate_dot(CHILD(tree, 2)));
    if (nch == 1) {
        if (TYPE(CHILD(tree, 0)) == test)
            res = validate_test(CHILD(tree, 0));
        else
            res = validate_colon(CHILD(tree, 0));
        return (res);
    }
    /*  Must be [test] ':' [test] [sliceop],
     *  but at least one of the optional components will
     *  be present, but we don't know which yet.
     */
    if ((TYPE(CHILD(tree, 0)) != COLON) || (nch == 4)) {
        res = validate_test(CHILD(tree, 0));
        offset = 1;
    }
    if (res)
        res = validate_colon(CHILD(tree, offset));
    if (res) {
        int rem = nch - ++offset;
        if (rem) {
            if (TYPE(CHILD(tree, offset)) == test) {
                res = validate_test(CHILD(tree, offset));
                ++offset;
                --rem;
            }
            if (res &amp;&amp; rem)
                res = validate_sliceop(CHILD(tree, offset));
        }
    }
    return (res);
}
</t>
<t tx="T553">static int
validate_sliceop(node *tree)
{
    int nch = NCH(tree);
    int res = ((nch == 1) || validate_numnodes(tree, 2, "sliceop"))
              &amp;&amp; validate_ntype(tree, sliceop);
    if (!res &amp;&amp; !PyErr_Occurred()) {
        res = validate_numnodes(tree, 1, "sliceop");
    }
    if (res)
        res = validate_colon(CHILD(tree, 0));
    if (res &amp;&amp; (nch == 2))
        res = validate_test(CHILD(tree, 1));

    return (res);
}
</t>
<t tx="T554">static int
validate_exprlist(node *tree)
{
    return (validate_repeating_list(tree, exprlist,
                                    validate_expr, "exprlist"));
}
</t>
<t tx="T555">static int
validate_dictmaker(node *tree)
{
    int nch = NCH(tree);
    int res = (validate_ntype(tree, dictmaker)
               &amp;&amp; (nch &gt;= 3)
               &amp;&amp; validate_test(CHILD(tree, 0))
               &amp;&amp; validate_colon(CHILD(tree, 1))
               &amp;&amp; validate_test(CHILD(tree, 2)));

    if (res &amp;&amp; ((nch % 4) == 0))
        res = validate_comma(CHILD(tree, --nch));
    else if (res)
        res = ((nch % 4) == 3);

    if (res &amp;&amp; (nch &gt; 3)) {
        int pos = 3;
        /*  ( ',' test ':' test )*  */
        while (res &amp;&amp; (pos &lt; nch)) {
            res = (validate_comma(CHILD(tree, pos))
                   &amp;&amp; validate_test(CHILD(tree, pos + 1))
                   &amp;&amp; validate_colon(CHILD(tree, pos + 2))
                   &amp;&amp; validate_test(CHILD(tree, pos + 3)));
            pos += 4;
        }
    }
    return (res);
}
</t>
<t tx="T556">static int
validate_eval_input(node *tree)
{
    int pos;
    int nch = NCH(tree);
    int res = (validate_ntype(tree, eval_input)
               &amp;&amp; (nch &gt;= 2)
               &amp;&amp; validate_testlist(CHILD(tree, 0))
               &amp;&amp; validate_ntype(CHILD(tree, nch - 1), ENDMARKER));

    for (pos = 1; res &amp;&amp; (pos &lt; (nch - 1)); ++pos)
        res = validate_ntype(CHILD(tree, pos), NEWLINE);

    return (res);
}
</t>
<t tx="T557">static int
validate_node(node *tree)
{
    int   nch  = 0;                     /* num. children on current node  */
    int   res  = 1;                     /* result value                   */
    node* next = 0;                     /* node to process after this one */

    while (res &amp;&amp; (tree != 0)) {
        nch  = NCH(tree);
        next = 0;
        switch (TYPE(tree)) {
            /*
             *  Definition nodes.
             */
          case funcdef:
            res = validate_funcdef(tree);
            break;
          case classdef:
            res = validate_class(tree);
            break;
            /*
             *  "Trivial" parse tree nodes.
             *  (Why did I call these trivial?)
             */
          case stmt:
            res = validate_stmt(tree);
            break;
          case small_stmt:
            /*
             *  expr_stmt | print_stmt | del_stmt | pass_stmt | flow_stmt
             *  | import_stmt | global_stmt | exec_stmt | assert_stmt
             */
            res = validate_small_stmt(tree);
            break;
          case flow_stmt:
            res  = (validate_numnodes(tree, 1, "flow_stmt")
                    &amp;&amp; ((TYPE(CHILD(tree, 0)) == break_stmt)
                        || (TYPE(CHILD(tree, 0)) == continue_stmt)
                        || (TYPE(CHILD(tree, 0)) == yield_stmt)
                        || (TYPE(CHILD(tree, 0)) == return_stmt)
                        || (TYPE(CHILD(tree, 0)) == raise_stmt)));
            if (res)
                next = CHILD(tree, 0);
            else if (nch == 1)
                err_string("illegal flow_stmt type");
            break;
          case yield_stmt:
            res = validate_yield_stmt(tree);
            break;
            /*
             *  Compound statements.
             */
          case simple_stmt:
            res = validate_simple_stmt(tree);
            break;
          case compound_stmt:
            res = validate_compound_stmt(tree);
            break;
            /*
             *  Fundamental statements.
             */
          case expr_stmt:
            res = validate_expr_stmt(tree);
            break;
          case print_stmt:
            res = validate_print_stmt(tree);
            break;
          case del_stmt:
            res = validate_del_stmt(tree);
            break;
          case pass_stmt:
            res = (validate_numnodes(tree, 1, "pass")
                   &amp;&amp; validate_name(CHILD(tree, 0), "pass"));
            break;
          case break_stmt:
            res = (validate_numnodes(tree, 1, "break")
                   &amp;&amp; validate_name(CHILD(tree, 0), "break"));
            break;
          case continue_stmt:
            res = (validate_numnodes(tree, 1, "continue")
                   &amp;&amp; validate_name(CHILD(tree, 0), "continue"));
            break;
          case return_stmt:
            res = validate_return_stmt(tree);
            break;
          case raise_stmt:
            res = validate_raise_stmt(tree);
            break;
          case import_stmt:
            res = validate_import_stmt(tree);
            break;
          case global_stmt:
            res = validate_global_stmt(tree);
            break;
          case exec_stmt:
            res = validate_exec_stmt(tree);
            break;
          case assert_stmt:
            res = validate_assert_stmt(tree);
            break;
          case if_stmt:
            res = validate_if(tree);
            break;
          case while_stmt:
            res = validate_while(tree);
            break;
          case for_stmt:
            res = validate_for(tree);
            break;
          case try_stmt:
            res = validate_try(tree);
            break;
          case suite:
            res = validate_suite(tree);
            break;
            /*
             *  Expression nodes.
             */
          case testlist:
            res = validate_testlist(tree);
            break;
          case test:
            res = validate_test(tree);
            break;
          case and_test:
            res = validate_and_test(tree);
            break;
          case not_test:
            res = validate_not_test(tree);
            break;
          case comparison:
            res = validate_comparison(tree);
            break;
          case exprlist:
            res = validate_exprlist(tree);
            break;
          case comp_op:
            res = validate_comp_op(tree);
            break;
          case expr:
            res = validate_expr(tree);
            break;
          case xor_expr:
            res = validate_xor_expr(tree);
            break;
          case and_expr:
            res = validate_and_expr(tree);
            break;
          case shift_expr:
            res = validate_shift_expr(tree);
            break;
          case arith_expr:
            res = validate_arith_expr(tree);
            break;
          case term:
            res = validate_term(tree);
            break;
          case factor:
            res = validate_factor(tree);
            break;
          case power:
            res = validate_power(tree);
            break;
          case atom:
            res = validate_atom(tree);
            break;

          default:
            /* Hopefully never reached! */
            err_string("unrecognized node type");
            res = 0;
            break;
        }
        tree = next;
    }
    return (res);
}
</t>
<t tx="T558">static int
validate_expr_tree(node *tree)
{
    int res = validate_eval_input(tree);

    if (!res &amp;&amp; !PyErr_Occurred())
        err_string("could not validate expression tuple");

    return (res);
}
</t>
<t tx="T559">@ file_input: *   (NEWLINE | stmt)* ENDMARKER
@c

static int
validate_file_input(node *tree)
{
    int j;
    int nch = NCH(tree) - 1;
    int res = ((nch &gt;= 0)
               &amp;&amp; validate_ntype(CHILD(tree, nch), ENDMARKER));

    for (j = 0; res &amp;&amp; (j &lt; nch); ++j) {
        if (TYPE(CHILD(tree, j)) == stmt)
            res = validate_stmt(CHILD(tree, j));
        else
            res = validate_newline(CHILD(tree, j));
    }
    /*  This stays in to prevent any internal failures from getting to the
     *  user.  Hopefully, this won't be needed.  If a user reports getting
     *  this, we have some debugging to do.
     */
    if (!res &amp;&amp; !PyErr_Occurred())
        err_string("VALIDATION FAILURE: report this to the maintainer!");

    return (res);
}
</t>
<t tx="T560">static PyObject*
pickle_constructor = NULL;


static PyObject*
parser__pickler(PyObject *self, PyObject *args)
{
    NOTE(ARGUNUSED(self))
    PyObject *result = NULL;
    PyObject *st = NULL;
    PyObject *empty_dict = NULL;

    if (PyArg_ParseTuple(args, "O!:_pickler", &amp;PyST_Type, &amp;st)) {
        PyObject *newargs;
        PyObject *tuple;

        if ((empty_dict = PyDict_New()) == NULL)
            goto finally;
        if ((newargs = Py_BuildValue("Oi", st, 1)) == NULL)
            goto finally;
        tuple = parser_st2tuple((PyST_Object*)NULL, newargs, empty_dict);
        if (tuple != NULL) {
            result = Py_BuildValue("O(O)", pickle_constructor, tuple);
            Py_DECREF(tuple);
        }
        Py_DECREF(empty_dict);
        Py_DECREF(newargs);
    }
  finally:
    Py_XDECREF(empty_dict);

    return (result);
}
</t>
<t tx="T561">@ Functions exported by this module. Most of this should probably * be converted into an ST object with methods, but that is better * done directly in Python, allowing subclasses to be created directly. * We'd really have to write a wrapper around it all anyway to allow * inheritance.
@c

static PyMethodDef parser_functions[] =  {
    {"ast2tuple",       (PyCFunction)parser_st2tuple,  PUBLIC_METHOD_TYPE,
        "Creates a tuple-tree representation of an ST."},
    {"ast2list",        (PyCFunction)parser_st2list,   PUBLIC_METHOD_TYPE,
        "Creates a list-tree representation of an ST."},
    {"compileast",      (PyCFunction)parser_compilest, PUBLIC_METHOD_TYPE,
        "Compiles an ST object into a code object."},
    {"compilest",      (PyCFunction)parser_compilest,  PUBLIC_METHOD_TYPE,
        "Compiles an ST object into a code object."},
    {"expr",            (PyCFunction)parser_expr,      PUBLIC_METHOD_TYPE,
        "Creates an ST object from an expression."},
    {"isexpr",          (PyCFunction)parser_isexpr,    PUBLIC_METHOD_TYPE,
        "Determines if an ST object was created from an expression."},
    {"issuite",         (PyCFunction)parser_issuite,   PUBLIC_METHOD_TYPE,
        "Determines if an ST object was created from a suite."},
    {"suite",           (PyCFunction)parser_suite,     PUBLIC_METHOD_TYPE,
        "Creates an ST object from a suite."},
    {"sequence2ast",    (PyCFunction)parser_tuple2st,  PUBLIC_METHOD_TYPE,
        "Creates an ST object from a tree representation."},
    {"sequence2st",     (PyCFunction)parser_tuple2st,  PUBLIC_METHOD_TYPE,
        "Creates an ST object from a tree representation."},
    {"st2tuple",        (PyCFunction)parser_st2tuple,  PUBLIC_METHOD_TYPE,
        "Creates a tuple-tree representation of an ST."},
    {"st2list",         (PyCFunction)parser_st2list,   PUBLIC_METHOD_TYPE,
        "Creates a list-tree representation of an ST."},
    {"tuple2ast",       (PyCFunction)parser_tuple2st,  PUBLIC_METHOD_TYPE,
        "Creates an ST object from a tree representation."},
    {"tuple2st",        (PyCFunction)parser_tuple2st,  PUBLIC_METHOD_TYPE,
        "Creates an ST object from a tree representation."},

    /* private stuff: support pickle module */
    {"_pickler",        (PyCFunction)parser__pickler,  METH_VARARGS,
        "Returns the pickle magic to allow ST objects to be pickled."},

    {NULL, NULL, 0, NULL}
    };


DL_EXPORT(void) initparser(void);  /* supply a prototype */

DL_EXPORT(void)
initparser(void)
{
    PyObject *module, *copyreg;

    PyST_Type.ob_type = &amp;PyType_Type;
    module = Py_InitModule("parser", parser_functions);

    if (parser_error == 0)
        parser_error = PyErr_NewException("parser.ParserError", NULL, NULL);

    if ((parser_error == 0)
        || (PyModule_AddObject(module, "ParserError", parser_error) != 0)) {
        /* caller will check PyErr_Occurred() */
        return;
    }
    Py_INCREF(&amp;PyST_Type);
    PyModule_AddObject(module, "ASTType", (PyObject*)&amp;PyST_Type);
    Py_INCREF(&amp;PyST_Type);
    PyModule_AddObject(module, "STType", (PyObject*)&amp;PyST_Type);

    PyModule_AddStringConstant(module, "__copyright__",
                               parser_copyright_string);
    PyModule_AddStringConstant(module, "__doc__",
                               parser_doc_string);
    PyModule_AddStringConstant(module, "__version__",
                               parser_version_string);

    /* Register to support pickling.
     * If this fails, the import of this module will fail because an
     * exception will be raised here; should we clear the exception?
     */
    copyreg = PyImport_ImportModule("copy_reg");
    if (copyreg != NULL) {
        PyObject *func, *pickler;

        func = PyObject_GetAttrString(copyreg, "pickle");
        pickle_constructor = PyObject_GetAttrString(module, "sequence2st");
        pickler = PyObject_GetAttrString(module, "_pickler");
        Py_XINCREF(pickle_constructor);
        if ((func != NULL) &amp;&amp; (pickle_constructor != NULL)
            &amp;&amp; (pickler != NULL)) {
            PyObject *res;

            res = PyObject_CallFunction(func, "OOO", &amp;PyST_Type, pickler,
                                        pickle_constructor);
            Py_XDECREF(res);
        }
        Py_XDECREF(func);
        Py_XDECREF(pickle_constructor);
        Py_XDECREF(pickler);
        Py_DECREF(copyreg);
    }
}
</t>
<t tx="T562">@language c
/* System module */

/*
Various bits of information used by the interpreter are collected in
module 'sys'.
Function member:
- exit(sts): raise SystemExit
Data members:
- stdin, stdout, stderr: standard file objects
- modules: the table of modules (dictionary)
- path: module search path (list of strings)
- argv: script arguments (list of strings)
- ps1, ps2: optional primary and secondary prompts (strings)
*/

#include "Python.h"
#include "compile.h"
#include "frameobject.h"

#include "osdefs.h"

&lt;&lt; sysmodule declarations &gt;&gt;
@others
</t>
<t tx="T563">#ifdef MS_COREDLL
extern void *PyWin_DLLhModule;
/* A string loaded from the DLL at startup: */
extern const char *PyWin_DLLVersionString;
</t>
<t tx="T564">#endif

PyObject *
PySys_GetObject(char *name)
{
	PyThreadState *tstate = PyThreadState_Get();
	PyObject *sd = tstate-&gt;interp-&gt;sysdict;
	if (sd == NULL)
		return NULL;
	return PyDict_GetItemString(sd, name);
}
</t>
<t tx="T565">FILE *
PySys_GetFile(char *name, FILE *def)
{
	FILE *fp = NULL;
	PyObject *v = PySys_GetObject(name);
	if (v != NULL &amp;&amp; PyFile_Check(v))
		fp = PyFile_AsFile(v);
	if (fp == NULL)
		fp = def;
	return fp;
}
</t>
<t tx="T566">int
PySys_SetObject(char *name, PyObject *v)
{
	PyThreadState *tstate = PyThreadState_Get();
	PyObject *sd = tstate-&gt;interp-&gt;sysdict;
	if (v == NULL) {
		if (PyDict_GetItemString(sd, name) == NULL)
			return 0;
		else
			return PyDict_DelItemString(sd, name);
	}
	else
		return PyDict_SetItemString(sd, name, v);
}
</t>
<t tx="T567">static PyObject *
sys_displayhook(PyObject *self, PyObject *o)
{
	PyObject *outf;
	PyInterpreterState *interp = PyThreadState_Get()-&gt;interp;
	PyObject *modules = interp-&gt;modules;
	PyObject *builtins = PyDict_GetItemString(modules, "__builtin__");

	if (builtins == NULL) {
		PyErr_SetString(PyExc_RuntimeError, "lost __builtin__");
		return NULL;
	}

	/* Print value except if None */
	/* After printing, also assign to '_' */
	/* Before, set '_' to None to avoid recursion */
	if (o == Py_None) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	if (PyObject_SetAttrString(builtins, "_", Py_None) != 0)
		return NULL;
	if (Py_FlushLine() != 0)
		return NULL;
	outf = PySys_GetObject("stdout");
	if (outf == NULL) {
		PyErr_SetString(PyExc_RuntimeError, "lost sys.stdout");
		return NULL;
	}
	if (PyFile_WriteObject(o, outf, 0) != 0)
		return NULL;
	PyFile_SoftSpace(outf, 1);
	if (Py_FlushLine() != 0)
		return NULL;
	if (PyObject_SetAttrString(builtins, "_", o) != 0)
		return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T568">static char displayhook_doc[] =
"displayhook(object) -&gt; None\n"
"\n"
"Print an object to sys.stdout and also save it in __builtin__._\n";

static PyObject *
sys_excepthook(PyObject* self, PyObject* args)
{
	PyObject *exc, *value, *tb;
	if (!PyArg_UnpackTuple(args, "excepthook", 3, 3, &amp;exc, &amp;value, &amp;tb))
		return NULL;
	PyErr_Display(exc, value, tb);
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T569">static char excepthook_doc[] =
"excepthook(exctype, value, traceback) -&gt; None\n"
"\n"
"Handle an exception by displaying it with a traceback on sys.stderr.\n";

static PyObject *
sys_exc_info(PyObject *self)
{
	PyThreadState *tstate;
	tstate = PyThreadState_Get();
	return Py_BuildValue(
		"(OOO)",
		tstate-&gt;exc_type != NULL ? tstate-&gt;exc_type : Py_None,
		tstate-&gt;exc_value != NULL ? tstate-&gt;exc_value : Py_None,
		tstate-&gt;exc_traceback != NULL ?
			tstate-&gt;exc_traceback : Py_None);
}
</t>
<t tx="T570">static char exc_info_doc[] =
"exc_info() -&gt; (type, value, traceback)\n\
\n\
Return information about the exception that is currently being handled.\n\
This should be called from inside an except clause only.";

static PyObject *
sys_exit(PyObject *self, PyObject *args)
{
	/* Raise SystemExit so callers may catch it or clean up. */
	PyErr_SetObject(PyExc_SystemExit, args);
	return NULL;
}
</t>
<t tx="T571">static char exit_doc[] =
"exit([status])\n\
\n\
Exit the interpreter by raising SystemExit(status).\n\
If the status is omitted or None, it defaults to zero (i.e., success).\n\
If the status is numeric, it will be used as the system exit status.\n\
If it is another kind of object, it will be printed and the system\n\
exit status will be one (i.e., failure).";

#ifdef Py_USING_UNICODE

static PyObject *
sys_getdefaultencoding(PyObject *self)
{
	return PyString_FromString(PyUnicode_GetDefaultEncoding());
}
</t>
<t tx="T572">static char getdefaultencoding_doc[] =
"getdefaultencoding() -&gt; string\n\
\n\
Return the current default string encoding used by the Unicode \n\
implementation.";

static PyObject *
sys_setdefaultencoding(PyObject *self, PyObject *args)
{
	char *encoding;
	if (!PyArg_ParseTuple(args, "s:setdefaultencoding", &amp;encoding))
		return NULL;
	if (PyUnicode_SetDefaultEncoding(encoding))
	    	return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T573">static char setdefaultencoding_doc[] =
"setdefaultencoding(encoding)\n\
\n\
Set the current default string encoding used by the Unicode implementation.";

#endif

/*
 * Cached interned string objects used for calling the profile and
 * trace functions.  Initialized by trace_init().
 */
static PyObject *whatstrings[4] = {NULL, NULL, NULL, NULL};

static int
trace_init(void)
{
	static char *whatnames[4] = {"call", "exception", "line", "return"};
	PyObject *name;
	int i;
	for (i = 0; i &lt; 4; ++i) {
		if (whatstrings[i] == NULL) {
			name = PyString_InternFromString(whatnames[i]);
			if (name == NULL)
				return -1;
			whatstrings[i] = name;
                }
	}
	return 0;
}
</t>
<t tx="T574">static PyObject *
call_trampoline(PyThreadState *tstate, PyObject* callback,
		PyFrameObject *frame, int what, PyObject *arg)
{
	PyObject *args = PyTuple_New(3);
	PyObject *whatstr;
	PyObject *result;

	if (args == NULL)
		return NULL;
	Py_INCREF(frame);
	whatstr = whatstrings[what];
	Py_INCREF(whatstr);
	if (arg == NULL)
		arg = Py_None;
	Py_INCREF(arg);
	PyTuple_SET_ITEM(args, 0, (PyObject *)frame);
	PyTuple_SET_ITEM(args, 1, whatstr);
	PyTuple_SET_ITEM(args, 2, arg);

	/* call the Python-level function */
	PyFrame_FastToLocals(frame);
	result = PyEval_CallObject(callback, args);
	PyFrame_LocalsToFast(frame, 1);
	if (result == NULL)
		PyTraceBack_Here(frame);

	/* cleanup */
	Py_DECREF(args);
	return result;
}
</t>
<t tx="T575">static int
profile_trampoline(PyObject *self, PyFrameObject *frame,
		   int what, PyObject *arg)
{
	PyThreadState *tstate = frame-&gt;f_tstate;
	PyObject *result;

	if (arg == NULL)
		arg = Py_None;
	result = call_trampoline(tstate, self, frame, what, arg);
	if (result == NULL) {
		PyEval_SetProfile(NULL, NULL);
		return -1;
	}
	Py_DECREF(result);
	return 0;
}
</t>
<t tx="T576">static int
trace_trampoline(PyObject *self, PyFrameObject *frame,
		 int what, PyObject *arg)
{
	PyThreadState *tstate = frame-&gt;f_tstate;
	PyObject *callback;
	PyObject *result;

	if (what == PyTrace_CALL)
		callback = self;
	else
		callback = frame-&gt;f_trace;
	if (callback == NULL)
		return 0;
	result = call_trampoline(tstate, callback, frame, what, arg);
	if (result == NULL) {
		PyEval_SetTrace(NULL, NULL);
		Py_XDECREF(frame-&gt;f_trace);
		frame-&gt;f_trace = NULL;
		return -1;
	}
	if (result != Py_None) {
		PyObject *temp = frame-&gt;f_trace;
		frame-&gt;f_trace = NULL;
		Py_XDECREF(temp);
		frame-&gt;f_trace = result;
	}
	else {
		Py_DECREF(result);
	}
	return 0;
}
</t>
<t tx="T577">static PyObject *
sys_settrace(PyObject *self, PyObject *args)
{
	if (trace_init() == -1)
		return NULL;
	if (args == Py_None)
		PyEval_SetTrace(NULL, NULL);
	else
		PyEval_SetTrace(trace_trampoline, args);
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T578">static char settrace_doc[] =
"settrace(function)\n\
\n\
Set the global debug tracing function.  It will be called on each\n\
function call.  See the debugger chapter in the library manual.";

static PyObject *
sys_setprofile(PyObject *self, PyObject *args)
{
	if (trace_init() == -1)
		return NULL;
	if (args == Py_None)
		PyEval_SetProfile(NULL, NULL);
	else
		PyEval_SetProfile(profile_trampoline, args);
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T579">static char setprofile_doc[] =
"setprofile(function)\n\
\n\
Set the profiling function.  It will be called on each function call\n\
and return.  See the profiler chapter in the library manual.";

static PyObject *
sys_setcheckinterval(PyObject *self, PyObject *args)
{
	PyThreadState *tstate = PyThreadState_Get();
	if (!PyArg_ParseTuple(args, "i:setcheckinterval", &amp;tstate-&gt;interp-&gt;checkinterval))
		return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T580">static char setcheckinterval_doc[] =
"setcheckinterval(n)\n\
\n\
Tell the Python interpreter to check for asynchronous events every\n\
n instructions.  This also affects how often thread switches occur.";

static PyObject *
sys_setrecursionlimit(PyObject *self, PyObject *args)
{
	int new_limit;
	if (!PyArg_ParseTuple(args, "i:setrecursionlimit", &amp;new_limit))
		return NULL;
	if (new_limit &lt;= 0) {
		PyErr_SetString(PyExc_ValueError, 
				"recursion limit must be positive");  
		return NULL;
	}
	Py_SetRecursionLimit(new_limit);
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T581">static char setrecursionlimit_doc[] =
"setrecursionlimit(n)\n\
\n\
Set the maximum depth of the Python interpreter stack to n.  This\n\
limit prevents infinite recursion from causing an overflow of the C\n\
stack and crashing Python.  The highest possible limit is platform-\n\
dependent.";

static PyObject *
sys_getrecursionlimit(PyObject *self)
{
	return PyInt_FromLong(Py_GetRecursionLimit());
}
</t>
<t tx="T582">static char getrecursionlimit_doc[] =
"getrecursionlimit()\n\
\n\
Return the current value of the recursion limit, the maximum depth\n\
of the Python interpreter stack.  This limit prevents infinite\n\
recursion from causing an overflow of the C stack and crashing Python.";

#ifdef HAVE_DLOPEN
static PyObject *
sys_setdlopenflags(PyObject *self, PyObject *args)
{
	int new_val;
        PyThreadState *tstate = PyThreadState_Get();
	if (!PyArg_ParseTuple(args, "i:setdlopenflags", &amp;new_val))
		return NULL;
        if (!tstate)
		return NULL;
        tstate-&gt;interp-&gt;dlopenflags = new_val;
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T583">static char setdlopenflags_doc[] =
"setdlopenflags(n) -&gt; None\n\
\n\
Set the flags that will be used for dlopen() calls. Among other\n\
things, this will enable a lazy resolving of symbols when importing\n\
a module, if called as sys.setdlopenflags(0)\n\
To share symbols across extension modules, call as\n\
sys.setdlopenflags(dl.RTLD_NOW|dl.RTLD_GLOBAL)";

static PyObject *
sys_getdlopenflags(PyObject *self, PyObject *args)
{
        PyThreadState *tstate = PyThreadState_Get();
        if (!tstate)
		return NULL;
        return PyInt_FromLong(tstate-&gt;interp-&gt;dlopenflags);
}
</t>
<t tx="T584">static char getdlopenflags_doc[] =
"getdlopenflags() -&gt; int\n\
\n\
Return the current value of the flags that are used for dlopen()\n\
calls. The flag constants are defined in the dl module.";
#endif

#ifdef USE_MALLOPT
/* Link with -lmalloc (or -lmpc) on an SGI */
#include &lt;malloc.h&gt;

static PyObject *
sys_mdebug(PyObject *self, PyObject *args)
{
	int flag;
	if (!PyArg_ParseTuple(args, "i:mdebug", &amp;flag))
		return NULL;
	mallopt(M_DEBUG, flag);
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T585">#endif /* USE_MALLOPT */

static PyObject *
sys_getrefcount(PyObject *self, PyObject *arg)
{
	return PyInt_FromLong(arg-&gt;ob_refcnt);
}
</t>
<t tx="T586">#ifdef Py_TRACE_REFS
static PyObject *
sys_gettotalrefcount(PyObject *self)
{
	extern long _Py_RefTotal;
	return PyInt_FromLong(_Py_RefTotal);
}
</t>
<t tx="T587">#endif /* Py_TRACE_REFS */

static char getrefcount_doc[] =
"getrefcount(object) -&gt; integer\n\
\n\
Return the current reference count for the object.  This includes the\n\
temporary reference in the argument list, so it is at least 2.";

#ifdef COUNT_ALLOCS
static PyObject *
sys_getcounts(PyObject *self)
{
	extern PyObject *get_counts(void);

	return get_counts();
}
#endif</t>
<t tx="T588">static char getframe_doc[] =
"_getframe([depth]) -&gt; frameobject\n\
\n\
Return a frame object from the call stack.  If optional integer depth is\n\
given, return the frame object that many calls below the top of the stack.\n\
If that is deeper than the call stack, ValueError is raised.  The default\n\
for depth is zero, returning the frame at the top of the call stack.\n\
\n\
This function should be used for internal and specialized\n\
purposes only.";

static PyObject *
sys_getframe(PyObject *self, PyObject *args)
{
	PyFrameObject *f = PyThreadState_Get()-&gt;frame;
	int depth = -1;

	if (!PyArg_ParseTuple(args, "|i:_getframe", &amp;depth))
		return NULL;

	while (depth &gt; 0 &amp;&amp; f != NULL) {
		f = f-&gt;f_back;
		--depth;
	}
	if (f == NULL) {
		PyErr_SetString(PyExc_ValueError,
				"call stack is not deep enough");
		return NULL;
	}
	Py_INCREF(f);
	return (PyObject*)f;
}
</t>
<t tx="T589">#ifdef Py_TRACE_REFS
/* Defined in objects.c because it uses static globals if that file */
extern PyObject *_Py_GetObjects(PyObject *, PyObject *);
#endif

#ifdef DYNAMIC_EXECUTION_PROFILE
/* Defined in ceval.c because it uses static globals if that file */
extern PyObject *_Py_GetDXProfile(PyObject *,  PyObject *);
#endif

static PyMethodDef sys_methods[] = {
	/* Might as well keep this in alphabetic order */
	{"displayhook",	sys_displayhook, METH_O, displayhook_doc},
	{"exc_info",	(PyCFunction)sys_exc_info, METH_NOARGS, exc_info_doc},
	{"excepthook",	sys_excepthook, METH_VARARGS, excepthook_doc},
	{"exit",	sys_exit, METH_OLDARGS, exit_doc},
#ifdef Py_USING_UNICODE
	{"getdefaultencoding", (PyCFunction)sys_getdefaultencoding, METH_NOARGS,
	 getdefaultencoding_doc}, 
#endif
#ifdef HAVE_DLOPEN
	{"getdlopenflags", (PyCFunction)sys_getdlopenflags, METH_NOARGS, 
	 getdlopenflags_doc},
#endif
#ifdef COUNT_ALLOCS
	{"getcounts",	(PyCFunction)sys_getcounts, METH_NOARGS},
#endif
#ifdef DYNAMIC_EXECUTION_PROFILE
	{"getdxp",	_Py_GetDXProfile, METH_VARARGS},
#endif
#ifdef Py_TRACE_REFS
	{"getobjects",	_Py_GetObjects, METH_VARARGS},
	{"gettotalrefcount", (PyCFunction)sys_gettotalrefcount, METH_NOARGS},
#endif
	{"getrefcount",	(PyCFunction)sys_getrefcount, METH_O, getrefcount_doc},
	{"getrecursionlimit", (PyCFunction)sys_getrecursionlimit, METH_NOARGS,
	 getrecursionlimit_doc},
	{"_getframe", sys_getframe, METH_VARARGS, getframe_doc},
#ifdef USE_MALLOPT
	{"mdebug",	sys_mdebug, METH_VARARGS},
#endif
#ifdef Py_USING_UNICODE
	{"setdefaultencoding", sys_setdefaultencoding, METH_VARARGS,
	 setdefaultencoding_doc}, 
#endif
	{"setcheckinterval",	sys_setcheckinterval, METH_VARARGS,
	 setcheckinterval_doc}, 
#ifdef HAVE_DLOPEN
	{"setdlopenflags", sys_setdlopenflags, METH_VARARGS, 
	 setdlopenflags_doc},
#endif
	{"setprofile",	sys_setprofile, METH_O, setprofile_doc},
	{"setrecursionlimit", sys_setrecursionlimit, METH_VARARGS,
	 setrecursionlimit_doc},
	{"settrace",	sys_settrace, METH_O, settrace_doc},
	{NULL,		NULL}		/* sentinel */
};

static PyObject *
list_builtin_module_names(void)
{
	PyObject *list = PyList_New(0);
	int i;
	if (list == NULL)
		return NULL;
	for (i = 0; PyImport_Inittab[i].name != NULL; i++) {
		PyObject *name = PyString_FromString(
			PyImport_Inittab[i].name);
		if (name == NULL)
			break;
		PyList_Append(list, name);
		Py_DECREF(name);
	}
	if (PyList_Sort(list) != 0) {
		Py_DECREF(list);
		list = NULL;
	}
	if (list) {
		PyObject *v = PyList_AsTuple(list);
		Py_DECREF(list);
		list = v;
	}
	return list;
}
</t>
<t tx="T590">static PyObject *warnoptions = NULL;

void
PySys_ResetWarnOptions(void)
{
	if (warnoptions == NULL || !PyList_Check(warnoptions))
		return;
	PyList_SetSlice(warnoptions, 0, PyList_GET_SIZE(warnoptions), NULL);
}
</t>
<t tx="T591">void
PySys_AddWarnOption(char *s)
{
	PyObject *str;

	if (warnoptions == NULL || !PyList_Check(warnoptions)) {
		Py_XDECREF(warnoptions);
		warnoptions = PyList_New(0);
		if (warnoptions == NULL)
			return;
	}
	str = PyString_FromString(s);
	if (str != NULL) {
		PyList_Append(warnoptions, str);
		Py_DECREF(str);
	}
}
</t>
<t tx="T592">@ XXX This doc string is too long to be a single string literal in VC++ 5.0.  Two literals concatenated works just fine. If you have a K&amp;R compiler  or other abomination that however *does* understand longer strings,  get rid of the !!! comment in the middle and the quotes that surround it.
@c

static char sys_doc[] =
"This module provides access to some objects used or maintained by the\n\
interpreter and to functions that interact strongly with the interpreter.\n\
\n\
Dynamic objects:\n\
\n\
argv -- command line arguments; argv[0] is the script pathname if known\n\
path -- module search path; path[0] is the script directory, else ''\n\
modules -- dictionary of loaded modules\n\
\n\
displayhook -- called to show results in an interactive session\n\
excepthook -- called to handle any uncaught exception other than SystemExit\n\
  To customize printing in an interactive session or to install a custom\n\
  top-level exception handler, assign other functions to replace these.\n\
\n\
exitfunc -- if sys.exitfunc exists, this routine is called when Python exits\n\
  Assigning to sys.exitfunc is deprecated; use the atexit module instead.\n\
\n\
stdin -- standard input file object; used by raw_input() and input()\n\
stdout -- standard output file object; used by the print statement\n\
stderr -- standard error object; used for error messages\n\
  By assigning other file objects (or objects that behave like files)\n\
  to these, it is possible to redirect all of the interpreter's I/O.\n\
\n\
last_type -- type of last uncaught exception\n\
last_value -- value of last uncaught exception\n\
last_traceback -- traceback of last uncaught exception\n\
  These three are only available in an interactive session after a\n\
  traceback has been printed.\n\
\n\
exc_type -- type of exception currently being handled\n\
exc_value -- value of exception currently being handled\n\
exc_traceback -- traceback of exception currently being handled\n\
  The function exc_info() should be used instead of these three,\n\
  because it is thread-safe.\n\
"
#ifndef MS_WIN16
/* concatenating string here */
"\n\
Static objects:\n\
\n\
maxint -- the largest supported integer (the smallest is -maxint-1)\n\
maxunicode -- the largest supported character\n\
builtin_module_names -- tuple of module names built into this interpreter\n\
version -- the version of this interpreter as a string\n\
version_info -- version information as a tuple\n\
hexversion -- version information encoded as a single integer\n\
copyright -- copyright notice pertaining to this interpreter\n\
platform -- platform identifier\n\
executable -- pathname of this Python interpreter\n\
prefix -- prefix used to find the Python library\n\
exec_prefix -- prefix used to find the machine-specific Python library\n\
"
#ifdef MS_WINDOWS
/* concatenating string here */
"dllhandle -- [Windows only] integer handle of the Python DLL\n\
winver -- [Windows only] version number of the Python DLL\n\
"
#endif /* MS_WINDOWS */
"__stdin__ -- the original stdin; don't touch!\n\
__stdout__ -- the original stdout; don't touch!\n\
__stderr__ -- the original stderr; don't touch!\n\
__displayhook__ -- the original displayhook; don't touch!\n\
__excepthook__ -- the original excepthook; don't touch!\n\
\n\
Functions:\n\
\n\
displayhook() -- print an object to the screen, and save it in __builtin__._\n\
excepthook() -- print an exception and its traceback to sys.stderr\n\
exc_info() -- return thread-safe information about the current exception\n\
exit() -- exit the interpreter by raising SystemExit\n\
getdlopenflags() -- returns flags to be used for dlopen() calls\n\
getrefcount() -- return the reference count for an object (plus one :-)\n\
getrecursionlimit() -- return the max recursion depth for the interpreter\n\
setcheckinterval() -- control how often the interpreter checks for events\n\
setdlopenflags() -- set the flags to be used for dlopen() calls\n\
setprofile() -- set the global profiling function\n\
setrecursionlimit() -- set the max recursion depth for the interpreter\n\
settrace() -- set the global debug tracing function\n\
"
#endif /* MS_WIN16 */
/* end of sys_doc */ ;

PyObject *
_PySys_Init(void)
{
	PyObject *m, *v, *sysdict;
	PyObject *sysin, *sysout, *syserr;
	char *s;

	m = Py_InitModule3("sys", sys_methods, sys_doc);
	sysdict = PyModule_GetDict(m);

	sysin = PyFile_FromFile(stdin, "&lt;stdin&gt;", "r", NULL);
	sysout = PyFile_FromFile(stdout, "&lt;stdout&gt;", "w", NULL);
	syserr = PyFile_FromFile(stderr, "&lt;stderr&gt;", "w", NULL);
	if (PyErr_Occurred())
		return NULL;
	PyDict_SetItemString(sysdict, "stdin", sysin);
	PyDict_SetItemString(sysdict, "stdout", sysout);
	PyDict_SetItemString(sysdict, "stderr", syserr);
	/* Make backup copies for cleanup */
	PyDict_SetItemString(sysdict, "__stdin__", sysin);
	PyDict_SetItemString(sysdict, "__stdout__", sysout);
	PyDict_SetItemString(sysdict, "__stderr__", syserr);
	PyDict_SetItemString(sysdict, "__displayhook__",
                             PyDict_GetItemString(sysdict, "displayhook"));
	PyDict_SetItemString(sysdict, "__excepthook__",
                             PyDict_GetItemString(sysdict, "excepthook"));
	Py_XDECREF(sysin);
	Py_XDECREF(sysout);
	Py_XDECREF(syserr);
	PyDict_SetItemString(sysdict, "version",
			     v = PyString_FromString(Py_GetVersion()));
	Py_XDECREF(v);
	PyDict_SetItemString(sysdict, "hexversion",
			     v = PyInt_FromLong(PY_VERSION_HEX));
	Py_XDECREF(v);
	/*
	 * These release level checks are mutually exclusive and cover
	 * the field, so don't get too fancy with the pre-processor!
	 */
#if PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_ALPHA
	s = "alpha";
#elif PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_BETA
	s = "beta";
#elif PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_GAMMA
	s = "candidate";
#elif PY_RELEASE_LEVEL == PY_RELEASE_LEVEL_FINAL
	s = "final";
#endif
	PyDict_SetItemString(sysdict, "version_info",
			     v = Py_BuildValue("iiisi", PY_MAJOR_VERSION,
					       PY_MINOR_VERSION,
					       PY_MICRO_VERSION, s,
					       PY_RELEASE_SERIAL));
	Py_XDECREF(v);
	PyDict_SetItemString(sysdict, "copyright",
			     v = PyString_FromString(Py_GetCopyright()));
	Py_XDECREF(v);
	PyDict_SetItemString(sysdict, "platform",
			     v = PyString_FromString(Py_GetPlatform()));
	Py_XDECREF(v);
	PyDict_SetItemString(sysdict, "executable",
			     v = PyString_FromString(Py_GetProgramFullPath()));
	Py_XDECREF(v);
	PyDict_SetItemString(sysdict, "prefix",
			     v = PyString_FromString(Py_GetPrefix()));
	Py_XDECREF(v);
	PyDict_SetItemString(sysdict, "exec_prefix",
		   v = PyString_FromString(Py_GetExecPrefix()));
	Py_XDECREF(v);
	PyDict_SetItemString(sysdict, "maxint",
			     v = PyInt_FromLong(PyInt_GetMax()));
	Py_XDECREF(v);
#ifdef Py_USING_UNICODE
	PyDict_SetItemString(sysdict, "maxunicode",
			     v = PyInt_FromLong(PyUnicode_GetMax()));
	Py_XDECREF(v);
#endif
	PyDict_SetItemString(sysdict, "builtin_module_names",
		   v = list_builtin_module_names());
	Py_XDECREF(v);
	{
		/* Assumes that longs are at least 2 bytes long.
		   Should be safe! */
		unsigned long number = 1;
		char *value;

		s = (char *) &amp;number;
		if (s[0] == 0)
			value = "big";
		else
			value = "little";
		PyDict_SetItemString(sysdict, "byteorder",
				     v = PyString_FromString(value));
		Py_XDECREF(v);
	}
#ifdef MS_COREDLL
	PyDict_SetItemString(sysdict, "dllhandle",
			     v = PyLong_FromVoidPtr(PyWin_DLLhModule));
	Py_XDECREF(v);
	PyDict_SetItemString(sysdict, "winver",
			     v = PyString_FromString(PyWin_DLLVersionString));
	Py_XDECREF(v);
#endif
	if (warnoptions == NULL) {
		warnoptions = PyList_New(0);
	}
	else {
		Py_INCREF(warnoptions);
	}
	if (warnoptions != NULL) {
		PyDict_SetItemString(sysdict, "warnoptions", warnoptions);
	}
	
	if (PyErr_Occurred())
		return NULL;
	return m;
}
</t>
<t tx="T593">static PyObject *
makepathobject(char *path, int delim)
{
	int i, n;
	char *p;
	PyObject *v, *w;
	
	n = 1;
	p = path;
	while ((p = strchr(p, delim)) != NULL) {
		n++;
		p++;
	}
	v = PyList_New(n);
	if (v == NULL)
		return NULL;
	for (i = 0; ; i++) {
		p = strchr(path, delim);
		if (p == NULL)
			p = strchr(path, '\0'); /* End of string */
		w = PyString_FromStringAndSize(path, (int) (p - path));
		if (w == NULL) {
			Py_DECREF(v);
			return NULL;
		}
		PyList_SetItem(v, i, w);
		if (*p == '\0')
			break;
		path = p+1;
	}
	return v;
}
</t>
<t tx="T594">void
PySys_SetPath(char *path)
{
	PyObject *v;
	if ((v = makepathobject(path, DELIM)) == NULL)
		Py_FatalError("can't create sys.path");
	if (PySys_SetObject("path", v) != 0)
		Py_FatalError("can't assign sys.path");
	Py_DECREF(v);
}
</t>
<t tx="T595">static PyObject *
makeargvobject(int argc, char **argv)
{
	PyObject *av;
	if (argc &lt;= 0 || argv == NULL) {
		/* Ensure at least one (empty) argument is seen */
		static char *empty_argv[1] = {""};
		argv = empty_argv;
		argc = 1;
	}
	av = PyList_New(argc);
	if (av != NULL) {
		int i;
		for (i = 0; i &lt; argc; i++) {
			PyObject *v = PyString_FromString(argv[i]);
			if (v == NULL) {
				Py_DECREF(av);
				av = NULL;
				break;
			}
			PyList_SetItem(av, i, v);
		}
	}
	return av;
}
</t>
<t tx="T596">void
PySys_SetArgv(int argc, char **argv)
{
	PyObject *av = makeargvobject(argc, argv);
	PyObject *path = PySys_GetObject("path");
	if (av == NULL)
		Py_FatalError("no mem for sys.argv");
	if (PySys_SetObject("argv", av) != 0)
		Py_FatalError("can't assign sys.argv");
	if (path != NULL) {
		char *argv0 = argv[0];
		char *p = NULL;
		int n = 0;
		PyObject *a;
#ifdef HAVE_READLINK
		char link[MAXPATHLEN+1];
		char argv0copy[2*MAXPATHLEN+1];
		int nr = 0;
		if (argc &gt; 0 &amp;&amp; argv0 != NULL)
			nr = readlink(argv0, link, MAXPATHLEN);
		if (nr &gt; 0) {
			/* It's a symlink */
			link[nr] = '\0';
			if (link[0] == SEP)
				argv0 = link; /* Link to absolute path */
			else if (strchr(link, SEP) == NULL)
				; /* Link without path */
			else {
				/* Must join(dirname(argv0), link) */
				char *q = strrchr(argv0, SEP);
				if (q == NULL)
					argv0 = link; /* argv0 without path */
				else {
					/* Must make a copy */
					strcpy(argv0copy, argv0);
					q = strrchr(argv0copy, SEP);
					strcpy(q+1, link);
					argv0 = argv0copy;
				}
			}
		}
#endif /* HAVE_READLINK */
#if SEP == '\\' /* Special case for MS filename syntax */
		if (argc &gt; 0 &amp;&amp; argv0 != NULL) {
			char *q;
			p = strrchr(argv0, SEP);
			/* Test for alternate separator */
			q = strrchr(p ? p : argv0, '/');
			if (q != NULL)
				p = q;
			if (p != NULL) {
				n = p + 1 - argv0;
				if (n &gt; 1 &amp;&amp; p[-1] != ':')
					n--; /* Drop trailing separator */
			}
		}
#else /* All other filename syntaxes */
		if (argc &gt; 0 &amp;&amp; argv0 != NULL)
			p = strrchr(argv0, SEP);
		if (p != NULL) {
#ifndef RISCOS
			n = p + 1 - argv0;
#else /* don't include trailing separator */
			n = p - argv0;
#endif /* RISCOS */
#if SEP == '/' /* Special case for Unix filename syntax */
			if (n &gt; 1)
				n--; /* Drop trailing separator */
#endif /* Unix */
		}
#endif /* All others */
		a = PyString_FromStringAndSize(argv0, n);
		if (a == NULL)
			Py_FatalError("no mem for sys.path insertion");
		if (PyList_Insert(path, 0, a) &lt; 0)
			Py_FatalError("sys.path.insert(0) failed");
		Py_DECREF(a);
	}
	Py_DECREF(av);
}
</t>
<t tx="T597">@ APIs to write to sys.stdout or sys.stderr using a printf-like interface.  Adapted from code submitted by Just van Rossum.   PySys_WriteStdout(format, ...)  PySys_WriteStderr(format, ...)    The first function writes to sys.stdout; the second to sys.stderr. When    there is a problem, they write to the real (C level) stdout or stderr;    no exceptions are raised.    Both take a printf-style format string as their first argument followed    by a variable length argument list determined by the format string.    *** WARNING ***    The format should limit the total size of the formatted output string to    1000 bytes. In particular, this means that no unrestricted "%s" formats    should occur; these should be limited using "%.&lt;N&gt;s where &lt;N&gt; is a    decimal number calculated so that &lt;N&gt; plus the maximum size of other    formatted text does not exceed 1000 bytes. Also watch out for "%f",    which can print hundreds of digits for very large numbers.
@c

static void
mywrite(char *name, FILE *fp, const char *format, va_list va)
{
	PyObject *file;
	PyObject *error_type, *error_value, *error_traceback;

	PyErr_Fetch(&amp;error_type, &amp;error_value, &amp;error_traceback);
	file = PySys_GetObject(name);
	if (file == NULL || PyFile_AsFile(file) == fp)
		vfprintf(fp, format, va);
	else {
		char buffer[1001];
		const int written = PyOS_vsnprintf(buffer, sizeof(buffer),
						   format, va);
		if (PyFile_WriteString(buffer, file) != 0) {
			PyErr_Clear();
			fputs(buffer, fp);
		}
		if (written &lt; 0 || written &gt;= sizeof(buffer)) {
			const char *truncated = "... truncated";
			if (PyFile_WriteString(truncated, file) != 0) {
				PyErr_Clear();
				fputs(truncated, fp);
			}
		}
	}
	PyErr_Restore(error_type, error_value, error_traceback);
}
</t>
<t tx="T598">void
PySys_WriteStdout(const char *format, ...)
{
	va_list va;

	va_start(va, format);
	mywrite("stdout", stdout, format, va);
	va_end(va);
}
</t>
<t tx="T599">void
PySys_WriteStderr(const char *format, ...)
{
	va_list va;

	va_start(va, format);
	mywrite("stderr", stderr, format, va);
	va_end(va);
}
</t>
<t tx="T600">@language c

#include "Python.h"

#include "compile.h"
#include "symtable.h"

@others
</t>
<t tx="T601">static PyObject *
symtable_symtable(PyObject *self, PyObject *args)
{
	struct symtable *st;
	PyObject *t;

	char *str;
	char *filename;
	char *startstr;
	int start;

	if (!PyArg_ParseTuple(args, "sss:symtable", &amp;str, &amp;filename, 
			      &amp;startstr))
		return NULL;
	if (strcmp(startstr, "exec") == 0)
		start = Py_file_input;
	else if (strcmp(startstr, "eval") == 0)
		start = Py_eval_input;
	else if (strcmp(startstr, "single") == 0)
		start = Py_single_input;
	else {
		PyErr_SetString(PyExc_ValueError,
		   "symtable() arg 3 must be 'exec' or 'eval' or 'single'");
		return NULL;
	}
	st = Py_SymtableString(str, filename, start);
	if (st == NULL)
		return NULL;
	t = Py_BuildValue("O", st-&gt;st_symbols);
	PyMem_Free((void *)st-&gt;st_future);
	PySymtable_Free(st);
	return t;
}
</t>
<t tx="T602">static PyMethodDef symtable_methods[] = {
	{"symtable",	symtable_symtable,	METH_VARARGS,
	 "Return symbol and scope dictionaries used internally by compiler."},
	{NULL,		NULL}		/* sentinel */
};

DL_EXPORT(void)
init_symtable(void)
{
	PyObject *m;

	m = Py_InitModule("_symtable", symtable_methods);
	PyModule_AddIntConstant(m, "USE", USE);
	PyModule_AddIntConstant(m, "DEF_GLOBAL", DEF_GLOBAL);
	PyModule_AddIntConstant(m, "DEF_LOCAL", DEF_LOCAL);
	PyModule_AddIntConstant(m, "DEF_PARAM", DEF_PARAM);
	PyModule_AddIntConstant(m, "DEF_STAR", DEF_STAR);
	PyModule_AddIntConstant(m, "DEF_DOUBLESTAR", DEF_DOUBLESTAR);
	PyModule_AddIntConstant(m, "DEF_INTUPLE", DEF_INTUPLE);
	PyModule_AddIntConstant(m, "DEF_FREE", DEF_FREE);
	PyModule_AddIntConstant(m, "DEF_FREE_GLOBAL", DEF_FREE_GLOBAL);
	PyModule_AddIntConstant(m, "DEF_FREE_CLASS", DEF_FREE_CLASS);
	PyModule_AddIntConstant(m, "DEF_IMPORT", DEF_IMPORT);
	PyModule_AddIntConstant(m, "DEF_BOUND", DEF_BOUND);

	PyModule_AddIntConstant(m, "TYPE_FUNCTION", TYPE_FUNCTION);
	PyModule_AddIntConstant(m, "TYPE_CLASS", TYPE_CLASS);
	PyModule_AddIntConstant(m, "TYPE_MODULE", TYPE_MODULE);

	PyModule_AddIntConstant(m, "OPT_IMPORT_STAR", OPT_IMPORT_STAR);
	PyModule_AddIntConstant(m, "OPT_EXEC", OPT_EXEC);
	PyModule_AddIntConstant(m, "OPT_BARE_EXEC", OPT_BARE_EXEC);

	PyModule_AddIntConstant(m, "LOCAL", LOCAL);
	PyModule_AddIntConstant(m, "GLOBAL_EXPLICIT", GLOBAL_EXPLICIT);
	PyModule_AddIntConstant(m, "GLOBAL_IMPLICIT", GLOBAL_IMPLICIT);
	PyModule_AddIntConstant(m, "FREE", FREE);
	PyModule_AddIntConstant(m, "CELL", CELL);
}
</t>
<t tx="T603">@language c
/* Module definition and import implementation */

&lt;&lt; import #includes &gt;&gt;
&lt;&lt; import declarations &gt;&gt;

@others

/* Search the path (default sys.path) for a module.  Return the
   corresponding filedescr struct, and (via return arguments) the
   pathname and an open file.  Return NULL if the module is not found. */

#ifdef MS_COREDLL
extern FILE *PyWin_FindRegisteredModule(const char *, struct filedescr **,
					char *, int);
#endif

static int case_ok(char *, int, int, char *);
static int find_init_module(char *); /* Forward */

static struct filedescr *
find_module(char *realname, PyObject *path, char *buf, size_t buflen,
	    FILE **p_fp)
{
	int i, npath;
	size_t len, namelen;
	struct filedescr *fdp = NULL;
	FILE *fp = NULL;
#ifndef RISCOS
	struct stat statbuf;
#endif
	static struct filedescr fd_frozen = {"", "", PY_FROZEN};
	static struct filedescr fd_builtin = {"", "", C_BUILTIN};
	static struct filedescr fd_package = {"", "", PKG_DIRECTORY};
	char name[MAXPATHLEN+1];

	if (strlen(realname) &gt; MAXPATHLEN) {
		PyErr_SetString(PyExc_OverflowError,
				"module name is too long");
		return NULL;
	}
	strcpy(name, realname);

	if (path != NULL &amp;&amp; PyString_Check(path)) {
		/* The only type of submodule allowed inside a "frozen"
		   package are other frozen modules or packages. */
		if (PyString_Size(path) + 1 + strlen(name) &gt;= (size_t)buflen) {
			PyErr_SetString(PyExc_ImportError,
					"full frozen module name too long");
			return NULL;
		}
		strcpy(buf, PyString_AsString(path));
		strcat(buf, ".");
		strcat(buf, name);
		strcpy(name, buf);
#ifdef macintosh
		/* Freezing on the mac works different, and the modules are
		** actually on sys.path. So we don't take the quick exit but
		** continue with the normal flow.
		*/
		path = NULL;
#else
		if (find_frozen(name) != NULL) {
			strcpy(buf, name);
			return &amp;fd_frozen;
		}
		PyErr_Format(PyExc_ImportError,
			     "No frozen submodule named %.200s", name);
		return NULL;
#endif
	}
	if (path == NULL) {
		if (is_builtin(name)) {
			strcpy(buf, name);
			return &amp;fd_builtin;
		}
		if ((find_frozen(name)) != NULL) {
			strcpy(buf, name);
			return &amp;fd_frozen;
		}

#ifdef MS_COREDLL
		fp = PyWin_FindRegisteredModule(name, &amp;fdp, buf, buflen);
		if (fp != NULL) {
			*p_fp = fp;
			return fdp;
		}
#endif
		path = PySys_GetObject("path");
	}
	if (path == NULL || !PyList_Check(path)) {
		PyErr_SetString(PyExc_ImportError,
				"sys.path must be a list of directory names");
		return NULL;
	}
	npath = PyList_Size(path);
	namelen = strlen(name);
	for (i = 0; i &lt; npath; i++) {
		PyObject *v = PyList_GetItem(path, i);
		if (!PyString_Check(v))
			continue;
		len = PyString_Size(v);
		if (len + 2 + namelen + MAXSUFFIXSIZE &gt;= buflen)
			continue; /* Too long */
		strcpy(buf, PyString_AsString(v));
		if (strlen(buf) != len)
			continue; /* v contains '\0' */
#ifdef macintosh
#ifdef INTERN_STRINGS
		/*
		** Speedup: each sys.path item is interned, and
		** FindResourceModule remembers which items refer to
		** folders (so we don't have to bother trying to look
		** into them for resources).
		*/
		PyString_InternInPlace(&amp;PyList_GET_ITEM(path, i));
		v = PyList_GET_ITEM(path, i);
#endif
		if (PyMac_FindResourceModule((PyStringObject *)v, name, buf)) {
			static struct filedescr resfiledescr =
				{"", "", PY_RESOURCE};

			return &amp;resfiledescr;
		}
		if (PyMac_FindCodeResourceModule((PyStringObject *)v, name, buf)) {
			static struct filedescr resfiledescr =
				{"", "", PY_CODERESOURCE};

			return &amp;resfiledescr;
		}
#endif
		if (len &gt; 0 &amp;&amp; buf[len-1] != SEP
#ifdef ALTSEP
		    &amp;&amp; buf[len-1] != ALTSEP
#endif
		    )
			buf[len++] = SEP;
		strcpy(buf+len, name);
		len += namelen;

		/* Check for package import (buf holds a directory name,
		   and there's an __init__ module in that directory */
#ifdef HAVE_STAT
		if (stat(buf, &amp;statbuf) == 0 &amp;&amp;       /* it exists */
		    S_ISDIR(statbuf.st_mode) &amp;&amp;       /* it's a directory */
		    find_init_module(buf) &amp;&amp;          /* it has __init__.py */
		    case_ok(buf, len, namelen, name)) /* and case matches */
			return &amp;fd_package;
#else
		/* XXX How are you going to test for directories? */
#ifdef RISCOS
		if (isdir(buf) &amp;&amp;
		    find_init_module(buf) &amp;&amp;
		    case_ok(buf, len, namelen, name))
			return &amp;fd_package;
#endif
#endif
#ifdef macintosh
		fdp = PyMac_FindModuleExtension(buf, &amp;len, name);
		if (fdp) {
#else
		for (fdp = _PyImport_Filetab; fdp-&gt;suffix != NULL; fdp++) {
			strcpy(buf+len, fdp-&gt;suffix);
			if (Py_VerboseFlag &gt; 1)
				PySys_WriteStderr("# trying %s\n", buf);
#endif /* !macintosh */
			fp = fopen(buf, fdp-&gt;mode);
			if (fp != NULL) {
				if (case_ok(buf, len, namelen, name))
					break;
				else {	 /* continue search */
					fclose(fp);
					fp = NULL;
				}
			}
		}
		if (fp != NULL)
			break;
	}
	if (fp == NULL) {
		PyErr_Format(PyExc_ImportError,
			     "No module named %.200s", name);
		return NULL;
	}
	*p_fp = fp;
	return fdp;
}

/* case_ok(char* buf, int len, int namelen, char* name)
 * The arguments here are tricky, best shown by example:
 *    /a/b/c/d/e/f/g/h/i/j/k/some_long_module_name.py\0
 *    ^                      ^                   ^    ^
 *    |--------------------- buf ---------------------|
 *    |------------------- len ------------------|
 *                           |------ name -------|
 *                           |----- namelen -----|
 * buf is the full path, but len only counts up to (&amp; exclusive of) the
 * extension.  name is the module name, also exclusive of extension.
 *
 * We've already done a successful stat() or fopen() on buf, so know that
 * there's some match, possibly case-insensitive.
 *
 * case_ok() is to return 1 if there's a case-sensitive match for
 * name, else 0.  case_ok() is also to return 1 if envar PYTHONCASEOK
 * exists.
 *
 * case_ok() is used to implement case-sensitive import semantics even
 * on platforms with case-insensitive filesystems.  It's trivial to implement
 * for case-sensitive filesystems.  It's pretty much a cross-platform
 * nightmare for systems with case-insensitive filesystems.
 */

/* First we may need a pile of platform-specific header files; the sequence
 * of #if's here should match the sequence in the body of case_ok().
 */
#if defined(MS_WIN32) || defined(__CYGWIN__)
#include &lt;windows.h&gt;
#ifdef __CYGWIN__
#include &lt;sys/cygwin.h&gt;
#endif

#elif defined(DJGPP)
#include &lt;dir.h&gt;

#elif defined(macintosh)
#include &lt;TextUtils.h&gt;
#ifdef USE_GUSI1
#include "TFileSpec.h"		/* for Path2FSSpec() */
#endif

#elif defined(__MACH__) &amp;&amp; defined(__APPLE__) &amp;&amp; defined(HAVE_DIRENT_H)
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;

#elif defined(RISCOS)
#include "oslib/osfscontrol.h"
#endif

static int
case_ok(char *buf, int len, int namelen, char *name)
{
/* Pick a platform-specific implementation; the sequence of #if's here should
 * match the sequence just above.
 */

/* MS_WIN32 || __CYGWIN__ */
#if defined(MS_WIN32) || defined(__CYGWIN__)
	WIN32_FIND_DATA data;
	HANDLE h;
#ifdef __CYGWIN__
	char tempbuf[MAX_PATH];
#endif

	if (Py_GETENV("PYTHONCASEOK") != NULL)
		return 1;

#ifdef __CYGWIN__
	cygwin32_conv_to_win32_path(buf, tempbuf);
	h = FindFirstFile(tempbuf, &amp;data);
#else
	h = FindFirstFile(buf, &amp;data);
#endif
	if (h == INVALID_HANDLE_VALUE) {
		PyErr_Format(PyExc_NameError,
		  "Can't find file for module %.100s\n(filename %.300s)",
		  name, buf);
		return 0;
	}
	FindClose(h);
	return strncmp(data.cFileName, name, namelen) == 0;

/* DJGPP */
#elif defined(DJGPP)
	struct ffblk ffblk;
	int done;

	if (Py_GETENV("PYTHONCASEOK") != NULL)
		return 1;

	done = findfirst(buf, &amp;ffblk, FA_ARCH|FA_RDONLY|FA_HIDDEN|FA_DIREC);
	if (done) {
		PyErr_Format(PyExc_NameError,
		  "Can't find file for module %.100s\n(filename %.300s)",
		  name, buf);
		return 0;
	}
	return strncmp(ffblk.ff_name, name, namelen) == 0;

/* macintosh */
#elif defined(macintosh)
	FSSpec fss;
	OSErr err;

	if (Py_GETENV("PYTHONCASEOK") != NULL)
		return 1;

#ifndef USE_GUSI1
	err = FSMakeFSSpec(0, 0, Pstring(buf), &amp;fss);
#else
	/* GUSI's Path2FSSpec() resolves all possible aliases nicely on
	   the way, which is fine for all directories, but here we need
	   the original name of the alias file (say, Dlg.ppc.slb, not
	   toolboxmodules.ppc.slb). */
	char *colon;
	err = Path2FSSpec(buf, &amp;fss);
	if (err == noErr) {
		colon = strrchr(buf, ':'); /* find filename */
		if (colon != NULL)
			err = FSMakeFSSpec(fss.vRefNum, fss.parID,
					   Pstring(colon+1), &amp;fss);
		else
			err = FSMakeFSSpec(fss.vRefNum, fss.parID,
					   fss.name, &amp;fss);
	}
#endif
	if (err) {
		PyErr_Format(PyExc_NameError,
		     "Can't find file for module %.100s\n(filename %.300s)",
		     name, buf);
		return 0;
	}
	return fss.name[0] &gt;= namelen &amp;&amp;
	       strncmp(name, (char *)fss.name+1, namelen) == 0;

/* new-fangled macintosh (macosx) */
#elif defined(__MACH__) &amp;&amp; defined(__APPLE__) &amp;&amp; defined(HAVE_DIRENT_H)
	DIR *dirp;
	struct dirent *dp;
	char dirname[MAXPATHLEN + 1];
	const int dirlen = len - namelen - 1; /* don't want trailing SEP */

	if (Py_GETENV("PYTHONCASEOK") != NULL)
		return 1;

	/* Copy the dir component into dirname; substitute "." if empty */
	if (dirlen &lt;= 0) {
		dirname[0] = '.';
		dirname[1] = '\0';
	}
	else {
		assert(dirlen &lt;= MAXPATHLEN);
		memcpy(dirname, buf, dirlen);
		dirname[dirlen] = '\0';
	}
	/* Open the directory and search the entries for an exact match. */
	dirp = opendir(dirname);
	if (dirp) {
		char *nameWithExt = buf + len - namelen;
		while ((dp = readdir(dirp)) != NULL) {
			const int thislen =
#ifdef _DIRENT_HAVE_D_NAMELEN
						dp-&gt;d_namlen;
#else
						strlen(dp-&gt;d_name);
#endif
			if (thislen &gt;= namelen &amp;&amp;
			    strcmp(dp-&gt;d_name, nameWithExt) == 0) {
				(void)closedir(dirp);
				return 1; /* Found */
			}
		}
		(void)closedir(dirp);
	}
	return 0 ; /* Not found */

/* RISC OS */
#elif defined(RISCOS)
	char canon[MAXPATHLEN+1]; /* buffer for the canonical form of the path */
	char buf2[MAXPATHLEN+2];
	char *nameWithExt = buf+len-namelen;
	int canonlen;
	os_error *e;

	if (Py_GETENV("PYTHONCASEOK") != NULL)
		return 1;

	/* workaround:
	   append wildcard, otherwise case of filename wouldn't be touched */
	strcpy(buf2, buf);
	strcat(buf2, "*");

	e = xosfscontrol_canonicalise_path(buf2,canon,0,0,MAXPATHLEN+1,&amp;canonlen);
	canonlen = MAXPATHLEN+1-canonlen;
	if (e || canonlen&lt;=0 || canonlen&gt;(MAXPATHLEN+1) )
		return 0;
	if (strcmp(nameWithExt, canon+canonlen-strlen(nameWithExt))==0)
		return 1; /* match */

	return 0;

/* assuming it's a case-sensitive filesystem, so there's nothing to do! */
#else
	return 1;

#endif
}


#ifdef HAVE_STAT
/* Helper to look for __init__.py or __init__.py[co] in potential package */
static int
find_init_module(char *buf)
{
	const size_t save_len = strlen(buf);
	size_t i = save_len;
	char *pname;  /* pointer to start of __init__ */
	struct stat statbuf;

/*	For calling case_ok(buf, len, namelen, name):
 *	/a/b/c/d/e/f/g/h/i/j/k/some_long_module_name.py\0
 *	^                      ^                   ^    ^
 *	|--------------------- buf ---------------------|
 *	|------------------- len ------------------|
 *	                       |------ name -------|
 *	                       |----- namelen -----|
 */
	if (save_len + 13 &gt;= MAXPATHLEN)
		return 0;
	buf[i++] = SEP;
	pname = buf + i;
	strcpy(pname, "__init__.py");
	if (stat(buf, &amp;statbuf) == 0) {
		if (case_ok(buf,
			    save_len + 9,	/* len("/__init__") */
		            8,   		/* len("__init__") */
		            pname)) {
			buf[save_len] = '\0';
			return 1;
		}
	}
	i += strlen(pname);
	strcpy(buf+i, Py_OptimizeFlag ? "o" : "c");
	if (stat(buf, &amp;statbuf) == 0) {
		if (case_ok(buf,
			    save_len + 9,	/* len("/__init__") */
		            8,   		/* len("__init__") */
		            pname)) {
			buf[save_len] = '\0';
			return 1;
		}
	}
	buf[save_len] = '\0';
	return 0;
}

#else

#ifdef RISCOS
static int
find_init_module(buf)
	char *buf;
{
	int save_len = strlen(buf);
	int i = save_len;

	if (save_len + 13 &gt;= MAXPATHLEN)
		return 0;
	buf[i++] = SEP;
	strcpy(buf+i, "__init__/py");
	if (isfile(buf)) {
		buf[save_len] = '\0';
		return 1;
	}

	if (Py_OptimizeFlag)
		strcpy(buf+i, "o");
	else
		strcpy(buf+i, "c");
	if (isfile(buf)) {
		buf[save_len] = '\0';
		return 1;
	}
	buf[save_len] = '\0';
	return 0;
}
#endif /*RISCOS*/

#endif /* HAVE_STAT */


static int init_builtin(char *); /* Forward */

/* Load an external module using the default search path and return
   its module object WITH INCREMENTED REFERENCE COUNT */

static PyObject *
load_module(char *name, FILE *fp, char *buf, int type)
{
	PyObject *modules;
	PyObject *m;
	int err;

	/* First check that there's an open file (if we need one)  */
	switch (type) {
	case PY_SOURCE:
	case PY_COMPILED:
		if (fp == NULL) {
			PyErr_Format(PyExc_ValueError,
			   "file object required for import (type code %d)",
				     type);
			return NULL;
		}
	}

	switch (type) {

	case PY_SOURCE:
		m = load_source_module(name, buf, fp);
		break;

	case PY_COMPILED:
		m = load_compiled_module(name, buf, fp);
		break;

#ifdef HAVE_DYNAMIC_LOADING
	case C_EXTENSION:
		m = _PyImport_LoadDynamicModule(name, buf, fp);
		break;
#endif

#ifdef macintosh
	case PY_RESOURCE:
		m = PyMac_LoadResourceModule(name, buf);
		break;
	case PY_CODERESOURCE:
		m = PyMac_LoadCodeResourceModule(name, buf);
		break;
#endif

	case PKG_DIRECTORY:
		m = load_package(name, buf);
		break;

	case C_BUILTIN:
	case PY_FROZEN:
		if (buf != NULL &amp;&amp; buf[0] != '\0')
			name = buf;
		if (type == C_BUILTIN)
			err = init_builtin(name);
		else
			err = PyImport_ImportFrozenModule(name);
		if (err &lt; 0)
			return NULL;
		if (err == 0) {
			PyErr_Format(PyExc_ImportError,
				     "Purported %s module %.200s not found",
				     type == C_BUILTIN ?
						"builtin" : "frozen",
				     name);
			return NULL;
		}
		modules = PyImport_GetModuleDict();
		m = PyDict_GetItemString(modules, name);
		if (m == NULL) {
			PyErr_Format(
				PyExc_ImportError,
				"%s module %.200s not properly initialized",
				type == C_BUILTIN ?
					"builtin" : "frozen",
				name);
			return NULL;
		}
		Py_INCREF(m);
		break;

	default:
		PyErr_Format(PyExc_ImportError,
			     "Don't know how to import %.200s (type code %d)",
			      name, type);
		m = NULL;

	}

	return m;
}


/* Initialize a built-in module.
   Return 1 for succes, 0 if the module is not found, and -1 with
   an exception set if the initialization failed. */

static int
init_builtin(char *name)
{
	struct _inittab *p;

	if (_PyImport_FindExtension(name, name) != NULL)
		return 1;

	for (p = PyImport_Inittab; p-&gt;name != NULL; p++) {
		if (strcmp(name, p-&gt;name) == 0) {
			if (p-&gt;initfunc == NULL) {
				PyErr_Format(PyExc_ImportError,
				    "Cannot re-init internal module %.200s",
				    name);
				return -1;
			}
			if (Py_VerboseFlag)
				PySys_WriteStderr("import %s # builtin\n", name);
			(*p-&gt;initfunc)();
			if (PyErr_Occurred())
				return -1;
			if (_PyImport_FixupExtension(name, name) == NULL)
				return -1;
			return 1;
		}
	}
	return 0;
}


/* Frozen modules */

static struct _frozen *
find_frozen(char *name)
{
	struct _frozen *p;

	for (p = PyImport_FrozenModules; ; p++) {
		if (p-&gt;name == NULL)
			return NULL;
		if (strcmp(p-&gt;name, name) == 0)
			break;
	}
	return p;
}

static PyObject *
get_frozen_object(char *name)
{
	struct _frozen *p = find_frozen(name);
	int size;

	if (p == NULL) {
		PyErr_Format(PyExc_ImportError,
			     "No such frozen object named %.200s",
			     name);
		return NULL;
	}
	if (p-&gt;code == NULL) {
		PyErr_Format(PyExc_ImportError,
			     "Excluded frozen object named %.200s",
			     name);
		return NULL;
	}
	size = p-&gt;size;
	if (size &lt; 0)
		size = -size;
	return PyMarshal_ReadObjectFromString((char *)p-&gt;code, size);
}

/* Initialize a frozen module.
   Return 1 for succes, 0 if the module is not found, and -1 with
   an exception set if the initialization failed.
   This function is also used from frozenmain.c */

int
PyImport_ImportFrozenModule(char *name)
{
	struct _frozen *p = find_frozen(name);
	PyObject *co;
	PyObject *m;
	int ispackage;
	int size;

	if (p == NULL)
		return 0;
	if (p-&gt;code == NULL) {
		PyErr_Format(PyExc_ImportError,
			     "Excluded frozen object named %.200s",
			     name);
		return -1;
	}
	size = p-&gt;size;
	ispackage = (size &lt; 0);
	if (ispackage)
		size = -size;
	if (Py_VerboseFlag)
		PySys_WriteStderr("import %s # frozen%s\n",
			name, ispackage ? " package" : "");
	co = PyMarshal_ReadObjectFromString((char *)p-&gt;code, size);
	if (co == NULL)
		return -1;
	if (!PyCode_Check(co)) {
		Py_DECREF(co);
		PyErr_Format(PyExc_TypeError,
			     "frozen object %.200s is not a code object",
			     name);
		return -1;
	}
	if (ispackage) {
		/* Set __path__ to the package name */
		PyObject *d, *s;
		int err;
		m = PyImport_AddModule(name);
		if (m == NULL)
			return -1;
		d = PyModule_GetDict(m);
		s = PyString_InternFromString(name);
		if (s == NULL)
			return -1;
		err = PyDict_SetItemString(d, "__path__", s);
		Py_DECREF(s);
		if (err != 0)
			return err;
	}
	m = PyImport_ExecCodeModuleEx(name, co, "&lt;frozen&gt;");
	Py_DECREF(co);
	if (m == NULL)
		return -1;
	Py_DECREF(m);
	return 1;
}


/* Import a module, either built-in, frozen, or external, and return
   its module object WITH INCREMENTED REFERENCE COUNT */

PyObject *
PyImport_ImportModule(char *name)
{
	PyObject *pname;
	PyObject *result;

	pname = PyString_FromString(name);
	result = PyImport_Import(pname);
	Py_DECREF(pname);
	return result;
}

/* Forward declarations for helper routines */
static PyObject *get_parent(PyObject *globals, char *buf, int *p_buflen);
static PyObject *load_next(PyObject *mod, PyObject *altmod,
			   char **p_name, char *buf, int *p_buflen);
static int mark_miss(char *name);
static int ensure_fromlist(PyObject *mod, PyObject *fromlist,
			   char *buf, int buflen, int recursive);
static PyObject * import_submodule(PyObject *mod, char *name, char *fullname);

/* The Magnum Opus of dotted-name import :-) */

static PyObject *
import_module_ex(char *name, PyObject *globals, PyObject *locals,
		 PyObject *fromlist)
{
	char buf[MAXPATHLEN+1];
	int buflen = 0;
	PyObject *parent, *head, *next, *tail;

	parent = get_parent(globals, buf, &amp;buflen);
	if (parent == NULL)
		return NULL;

	head = load_next(parent, Py_None, &amp;name, buf, &amp;buflen);
	if (head == NULL)
		return NULL;

	tail = head;
	Py_INCREF(tail);
	while (name) {
		next = load_next(tail, tail, &amp;name, buf, &amp;buflen);
		Py_DECREF(tail);
		if (next == NULL) {
			Py_DECREF(head);
			return NULL;
		}
		tail = next;
	}

	if (fromlist != NULL) {
		if (fromlist == Py_None || !PyObject_IsTrue(fromlist))
			fromlist = NULL;
	}

	if (fromlist == NULL) {
		Py_DECREF(tail);
		return head;
	}

	Py_DECREF(head);
	if (!ensure_fromlist(tail, fromlist, buf, buflen, 0)) {
		Py_DECREF(tail);
		return NULL;
	}

	return tail;
}

PyObject *
PyImport_ImportModuleEx(char *name, PyObject *globals, PyObject *locals,
			PyObject *fromlist)
{
	PyObject *result;
	lock_import();
	result = import_module_ex(name, globals, locals, fromlist);
	unlock_import();
	return result;
}

static PyObject *
get_parent(PyObject *globals, char *buf, int *p_buflen)
{
	static PyObject *namestr = NULL;
	static PyObject *pathstr = NULL;
	PyObject *modname, *modpath, *modules, *parent;

	if (globals == NULL || !PyDict_Check(globals))
		return Py_None;

	if (namestr == NULL) {
		namestr = PyString_InternFromString("__name__");
		if (namestr == NULL)
			return NULL;
	}
	if (pathstr == NULL) {
		pathstr = PyString_InternFromString("__path__");
		if (pathstr == NULL)
			return NULL;
	}

	*buf = '\0';
	*p_buflen = 0;
	modname = PyDict_GetItem(globals, namestr);
	if (modname == NULL || !PyString_Check(modname))
		return Py_None;

	modpath = PyDict_GetItem(globals, pathstr);
	if (modpath != NULL) {
		int len = PyString_GET_SIZE(modname);
		if (len &gt; MAXPATHLEN) {
			PyErr_SetString(PyExc_ValueError,
					"Module name too long");
			return NULL;
		}
		strcpy(buf, PyString_AS_STRING(modname));
		*p_buflen = len;
	}
	else {
		char *start = PyString_AS_STRING(modname);
		char *lastdot = strrchr(start, '.');
		size_t len;
		if (lastdot == NULL)
			return Py_None;
		len = lastdot - start;
		if (len &gt;= MAXPATHLEN) {
			PyErr_SetString(PyExc_ValueError,
					"Module name too long");
			return NULL;
		}
		strncpy(buf, start, len);
		buf[len] = '\0';
		*p_buflen = len;
	}

	modules = PyImport_GetModuleDict();
	parent = PyDict_GetItemString(modules, buf);
	if (parent == NULL)
		parent = Py_None;
	return parent;
	/* We expect, but can't guarantee, if parent != None, that:
	   - parent.__name__ == buf
	   - parent.__dict__ is globals
	   If this is violated...  Who cares? */
}

/* altmod is either None or same as mod */
static PyObject *
load_next(PyObject *mod, PyObject *altmod, char **p_name, char *buf,
	  int *p_buflen)
{
	char *name = *p_name;
	char *dot = strchr(name, '.');
	size_t len;
	char *p;
	PyObject *result;

	if (dot == NULL) {
		*p_name = NULL;
		len = strlen(name);
	}
	else {
		*p_name = dot+1;
		len = dot-name;
	}
	if (len == 0) {
		PyErr_SetString(PyExc_ValueError,
				"Empty module name");
		return NULL;
	}

	p = buf + *p_buflen;
	if (p != buf)
		*p++ = '.';
	if (p+len-buf &gt;= MAXPATHLEN) {
		PyErr_SetString(PyExc_ValueError,
				"Module name too long");
		return NULL;
	}
	strncpy(p, name, len);
	p[len] = '\0';
	*p_buflen = p+len-buf;

	result = import_submodule(mod, p, buf);
	if (result == Py_None &amp;&amp; altmod != mod) {
		Py_DECREF(result);
		/* Here, altmod must be None and mod must not be None */
		result = import_submodule(altmod, p, p);
		if (result != NULL &amp;&amp; result != Py_None) {
			if (mark_miss(buf) != 0) {
				Py_DECREF(result);
				return NULL;
			}
			strncpy(buf, name, len);
			buf[len] = '\0';
			*p_buflen = len;
		}
	}
	if (result == NULL)
		return NULL;

	if (result == Py_None) {
		Py_DECREF(result);
		PyErr_Format(PyExc_ImportError,
			     "No module named %.200s", name);
		return NULL;
	}

	return result;
}

static int
mark_miss(char *name)
{
	PyObject *modules = PyImport_GetModuleDict();
	return PyDict_SetItemString(modules, name, Py_None);
}

static int
ensure_fromlist(PyObject *mod, PyObject *fromlist, char *buf, int buflen,
		int recursive)
{
	int i;

	if (!PyObject_HasAttrString(mod, "__path__"))
		return 1;

	for (i = 0; ; i++) {
		PyObject *item = PySequence_GetItem(fromlist, i);
		int hasit;
		if (item == NULL) {
			if (PyErr_ExceptionMatches(PyExc_IndexError)) {
				PyErr_Clear();
				return 1;
			}
			return 0;
		}
		if (!PyString_Check(item)) {
			PyErr_SetString(PyExc_TypeError,
					"Item in ``from list'' not a string");
			Py_DECREF(item);
			return 0;
		}
		if (PyString_AS_STRING(item)[0] == '*') {
			PyObject *all;
			Py_DECREF(item);
			/* See if the package defines __all__ */
			if (recursive)
				continue; /* Avoid endless recursion */
			all = PyObject_GetAttrString(mod, "__all__");
			if (all == NULL)
				PyErr_Clear();
			else {
				if (!ensure_fromlist(mod, all, buf, buflen, 1))
					return 0;
				Py_DECREF(all);
			}
			continue;
		}
		hasit = PyObject_HasAttr(mod, item);
		if (!hasit) {
			char *subname = PyString_AS_STRING(item);
			PyObject *submod;
			char *p;
			if (buflen + strlen(subname) &gt;= MAXPATHLEN) {
				PyErr_SetString(PyExc_ValueError,
						"Module name too long");
				Py_DECREF(item);
				return 0;
			}
			p = buf + buflen;
			*p++ = '.';
			strcpy(p, subname);
			submod = import_submodule(mod, subname, buf);
			Py_XDECREF(submod);
			if (submod == NULL) {
				Py_DECREF(item);
				return 0;
			}
		}
		Py_DECREF(item);
	}

	/* NOTREACHED */
}

static PyObject *
import_submodule(PyObject *mod, char *subname, char *fullname)
{
	PyObject *modules = PyImport_GetModuleDict();
	PyObject *m, *res = NULL;

	/* Require:
	   if mod == None: subname == fullname
	   else: mod.__name__ + "." + subname == fullname
	*/

	if ((m = PyDict_GetItemString(modules, fullname)) != NULL) {
		Py_INCREF(m);
	}
	else {
		PyObject *path;
		char buf[MAXPATHLEN+1];
		struct filedescr *fdp;
		FILE *fp = NULL;

		if (mod == Py_None)
			path = NULL;
		else {
			path = PyObject_GetAttrString(mod, "__path__");
			if (path == NULL) {
				PyErr_Clear();
				Py_INCREF(Py_None);
				return Py_None;
			}
		}

		buf[0] = '\0';
		fdp = find_module(subname, path, buf, MAXPATHLEN+1, &amp;fp);
		Py_XDECREF(path);
		if (fdp == NULL) {
			if (!PyErr_ExceptionMatches(PyExc_ImportError))
				return NULL;
			PyErr_Clear();
			Py_INCREF(Py_None);
			return Py_None;
		}
		m = load_module(fullname, fp, buf, fdp-&gt;type);
		if (fp)
			fclose(fp);
		if (mod != Py_None) {
			/* Irrespective of the success of this load, make a
			   reference to it in the parent package module.
			   A copy gets saved in the modules dictionary
			   under the full name, so get a reference from
			   there, if need be.  (The exception is when
			   the load failed with a SyntaxError -- then
			   there's no trace in sys.modules.  In that case,
			   of course, do nothing extra.) */
			res = m;
			if (res == NULL)
				res = PyDict_GetItemString(modules, fullname);
			if (res != NULL &amp;&amp;
			    PyObject_SetAttrString(mod, subname, res) &lt; 0) {
				Py_XDECREF(m);
				m = NULL;
			}
		}
	}

	return m;
}


/* Re-import a module of any kind and return its module object, WITH
   INCREMENTED REFERENCE COUNT */

PyObject *
PyImport_ReloadModule(PyObject *m)
{
	PyObject *modules = PyImport_GetModuleDict();
	PyObject *path = NULL;
	char *name, *subname;
	char buf[MAXPATHLEN+1];
	struct filedescr *fdp;
	FILE *fp = NULL;

	if (m == NULL || !PyModule_Check(m)) {
		PyErr_SetString(PyExc_TypeError,
				"reload() argument must be module");
		return NULL;
	}
	name = PyModule_GetName(m);
	if (name == NULL)
		return NULL;
	if (m != PyDict_GetItemString(modules, name)) {
		PyErr_Format(PyExc_ImportError,
			     "reload(): module %.200s not in sys.modules",
			     name);
		return NULL;
	}
	subname = strrchr(name, '.');
	if (subname == NULL)
		subname = name;
	else {
		PyObject *parentname, *parent;
		parentname = PyString_FromStringAndSize(name, (subname-name));
		if (parentname == NULL)
			return NULL;
		parent = PyDict_GetItem(modules, parentname);
		Py_DECREF(parentname);
		if (parent == NULL) {
			PyErr_Format(PyExc_ImportError,
			    "reload(): parent %.200s not in sys.modules",
			    name);
			return NULL;
		}
		subname++;
		path = PyObject_GetAttrString(parent, "__path__");
		if (path == NULL)
			PyErr_Clear();
	}
	buf[0] = '\0';
	fdp = find_module(subname, path, buf, MAXPATHLEN+1, &amp;fp);
	Py_XDECREF(path);
	if (fdp == NULL)
		return NULL;
	m = load_module(name, fp, buf, fdp-&gt;type);
	if (fp)
		fclose(fp);
	return m;
}


/* Higher-level import emulator which emulates the "import" statement
   more accurately -- it invokes the __import__() function from the
   builtins of the current globals.  This means that the import is
   done using whatever import hooks are installed in the current
   environment, e.g. by "rexec".
   A dummy list ["__doc__"] is passed as the 4th argument so that
   e.g. PyImport_Import(PyString_FromString("win32com.client.gencache"))
   will return &lt;module "gencache"&gt; instead of &lt;module "win32com"&gt;. */

PyObject *
PyImport_Import(PyObject *module_name)
{
	static PyObject *silly_list = NULL;
	static PyObject *builtins_str = NULL;
	static PyObject *import_str = NULL;
	PyObject *globals = NULL;
	PyObject *import = NULL;
	PyObject *builtins = NULL;
	PyObject *r = NULL;

	/* Initialize constant string objects */
	if (silly_list == NULL) {
		import_str = PyString_InternFromString("__import__");
		if (import_str == NULL)
			return NULL;
		builtins_str = PyString_InternFromString("__builtins__");
		if (builtins_str == NULL)
			return NULL;
		silly_list = Py_BuildValue("[s]", "__doc__");
		if (silly_list == NULL)
			return NULL;
	}

	/* Get the builtins from current globals */
	globals = PyEval_GetGlobals();
	if (globals != NULL) {
	        Py_INCREF(globals);
		builtins = PyObject_GetItem(globals, builtins_str);
		if (builtins == NULL)
			goto err;
	}
	else {
		/* No globals -- use standard builtins, and fake globals */
		PyErr_Clear();

		builtins = PyImport_ImportModuleEx("__builtin__",
						   NULL, NULL, NULL);
		if (builtins == NULL)
			return NULL;
		globals = Py_BuildValue("{OO}", builtins_str, builtins);
		if (globals == NULL)
			goto err;
	}

	/* Get the __import__ function from the builtins */
	if (PyDict_Check(builtins)) {
		import = PyObject_GetItem(builtins, import_str);
		if (import == NULL)
			PyErr_SetObject(PyExc_KeyError, import_str);
	}
	else
		import = PyObject_GetAttr(builtins, import_str);
	if (import == NULL)
		goto err;

	/* Call the _import__ function with the proper argument list */
	r = PyObject_CallFunction(import, "OOOO",
				  module_name, globals, globals, silly_list);

  err:
	Py_XDECREF(globals);
	Py_XDECREF(builtins);
	Py_XDECREF(import);

	return r;
}


/* Module 'imp' provides Python access to the primitives used for
   importing modules.
*/

static PyObject *
imp_get_magic(PyObject *self, PyObject *args)
{
	char buf[4];

	if (!PyArg_ParseTuple(args, ":get_magic"))
		return NULL;
	buf[0] = (char) ((pyc_magic &gt;&gt;  0) &amp; 0xff);
	buf[1] = (char) ((pyc_magic &gt;&gt;  8) &amp; 0xff);
	buf[2] = (char) ((pyc_magic &gt;&gt; 16) &amp; 0xff);
	buf[3] = (char) ((pyc_magic &gt;&gt; 24) &amp; 0xff);

	return PyString_FromStringAndSize(buf, 4);
}

static PyObject *
imp_get_suffixes(PyObject *self, PyObject *args)
{
	PyObject *list;
	struct filedescr *fdp;

	if (!PyArg_ParseTuple(args, ":get_suffixes"))
		return NULL;
	list = PyList_New(0);
	if (list == NULL)
		return NULL;
	for (fdp = _PyImport_Filetab; fdp-&gt;suffix != NULL; fdp++) {
		PyObject *item = Py_BuildValue("ssi",
				       fdp-&gt;suffix, fdp-&gt;mode, fdp-&gt;type);
		if (item == NULL) {
			Py_DECREF(list);
			return NULL;
		}
		if (PyList_Append(list, item) &lt; 0) {
			Py_DECREF(list);
			Py_DECREF(item);
			return NULL;
		}
		Py_DECREF(item);
	}
	return list;
}

static PyObject *
call_find_module(char *name, PyObject *path)
{
	extern int fclose(FILE *);
	PyObject *fob, *ret;
	struct filedescr *fdp;
	char pathname[MAXPATHLEN+1];
	FILE *fp = NULL;

	pathname[0] = '\0';
	if (path == Py_None)
		path = NULL;
	fdp = find_module(name, path, pathname, MAXPATHLEN+1, &amp;fp);
	if (fdp == NULL)
		return NULL;
	if (fp != NULL) {
		fob = PyFile_FromFile(fp, pathname, fdp-&gt;mode, fclose);
		if (fob == NULL) {
			fclose(fp);
			return NULL;
		}
	}
	else {
		fob = Py_None;
		Py_INCREF(fob);
	}
	ret = Py_BuildValue("Os(ssi)",
		      fob, pathname, fdp-&gt;suffix, fdp-&gt;mode, fdp-&gt;type);
	Py_DECREF(fob);
	return ret;
}

static PyObject *
imp_find_module(PyObject *self, PyObject *args)
{
	char *name;
	PyObject *path = NULL;
	if (!PyArg_ParseTuple(args, "s|O:find_module", &amp;name, &amp;path))
		return NULL;
	return call_find_module(name, path);
}

static PyObject *
imp_init_builtin(PyObject *self, PyObject *args)
{
	char *name;
	int ret;
	PyObject *m;
	if (!PyArg_ParseTuple(args, "s:init_builtin", &amp;name))
		return NULL;
	ret = init_builtin(name);
	if (ret &lt; 0)
		return NULL;
	if (ret == 0) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	m = PyImport_AddModule(name);
	Py_XINCREF(m);
	return m;
}

static PyObject *
imp_init_frozen(PyObject *self, PyObject *args)
{
	char *name;
	int ret;
	PyObject *m;
	if (!PyArg_ParseTuple(args, "s:init_frozen", &amp;name))
		return NULL;
	ret = PyImport_ImportFrozenModule(name);
	if (ret &lt; 0)
		return NULL;
	if (ret == 0) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	m = PyImport_AddModule(name);
	Py_XINCREF(m);
	return m;
}

static PyObject *
imp_get_frozen_object(PyObject *self, PyObject *args)
{
	char *name;

	if (!PyArg_ParseTuple(args, "s:get_frozen_object", &amp;name))
		return NULL;
	return get_frozen_object(name);
}

static PyObject *
imp_is_builtin(PyObject *self, PyObject *args)
{
	char *name;
	if (!PyArg_ParseTuple(args, "s:is_builtin", &amp;name))
		return NULL;
	return PyInt_FromLong(is_builtin(name));
}

static PyObject *
imp_is_frozen(PyObject *self, PyObject *args)
{
	char *name;
	struct _frozen *p;
	if (!PyArg_ParseTuple(args, "s:is_frozen", &amp;name))
		return NULL;
	p = find_frozen(name);
	return PyInt_FromLong((long) (p == NULL ? 0 : p-&gt;size));
}

static FILE *
get_file(char *pathname, PyObject *fob, char *mode)
{
	FILE *fp;
	if (fob == NULL) {
		fp = fopen(pathname, mode);
		if (fp == NULL)
			PyErr_SetFromErrno(PyExc_IOError);
	}
	else {
		fp = PyFile_AsFile(fob);
		if (fp == NULL)
			PyErr_SetString(PyExc_ValueError,
					"bad/closed file object");
	}
	return fp;
}

static PyObject *
imp_load_compiled(PyObject *self, PyObject *args)
{
	char *name;
	char *pathname;
	PyObject *fob = NULL;
	PyObject *m;
	FILE *fp;
	if (!PyArg_ParseTuple(args, "ss|O!:load_compiled", &amp;name, &amp;pathname,
			      &amp;PyFile_Type, &amp;fob))
		return NULL;
	fp = get_file(pathname, fob, "rb");
	if (fp == NULL)
		return NULL;
	m = load_compiled_module(name, pathname, fp);
	if (fob == NULL)
		fclose(fp);
	return m;
}

#ifdef HAVE_DYNAMIC_LOADING

static PyObject *
imp_load_dynamic(PyObject *self, PyObject *args)
{
	char *name;
	char *pathname;
	PyObject *fob = NULL;
	PyObject *m;
	FILE *fp = NULL;
	if (!PyArg_ParseTuple(args, "ss|O!:load_dynamic", &amp;name, &amp;pathname,
			      &amp;PyFile_Type, &amp;fob))
		return NULL;
	if (fob) {
		fp = get_file(pathname, fob, "r");
		if (fp == NULL)
			return NULL;
	}
	m = _PyImport_LoadDynamicModule(name, pathname, fp);
	return m;
}

#endif /* HAVE_DYNAMIC_LOADING */

static PyObject *
imp_load_source(PyObject *self, PyObject *args)
{
	char *name;
	char *pathname;
	PyObject *fob = NULL;
	PyObject *m;
	FILE *fp;
	if (!PyArg_ParseTuple(args, "ss|O!:load_source", &amp;name, &amp;pathname,
			      &amp;PyFile_Type, &amp;fob))
		return NULL;
	fp = get_file(pathname, fob, "r");
	if (fp == NULL)
		return NULL;
	m = load_source_module(name, pathname, fp);
	if (fob == NULL)
		fclose(fp);
	return m;
}

#ifdef macintosh
static PyObject *
imp_load_resource(PyObject *self, PyObject *args)
{
	char *name;
	char *pathname;
	PyObject *m;

	if (!PyArg_ParseTuple(args, "ss:load_resource", &amp;name, &amp;pathname))
		return NULL;
	m = PyMac_LoadResourceModule(name, pathname);
	return m;
}
#endif /* macintosh */

static PyObject *
imp_load_module(PyObject *self, PyObject *args)
{
	char *name;
	PyObject *fob;
	char *pathname;
	char *suffix; /* Unused */
	char *mode;
	int type;
	FILE *fp;

	if (!PyArg_ParseTuple(args, "sOs(ssi):load_module",
			      &amp;name, &amp;fob, &amp;pathname,
			      &amp;suffix, &amp;mode, &amp;type))
		return NULL;
	if (*mode &amp;&amp; (*mode != 'r' || strchr(mode, '+') != NULL)) {
		PyErr_Format(PyExc_ValueError,
			     "invalid file open mode %.200s", mode);
		return NULL;
	}
	if (fob == Py_None)
		fp = NULL;
	else {
		if (!PyFile_Check(fob)) {
			PyErr_SetString(PyExc_ValueError,
				"load_module arg#2 should be a file or None");
			return NULL;
		}
		fp = get_file(pathname, fob, mode);
		if (fp == NULL)
			return NULL;
	}
	return load_module(name, fp, pathname, type);
}

static PyObject *
imp_load_package(PyObject *self, PyObject *args)
{
	char *name;
	char *pathname;
	if (!PyArg_ParseTuple(args, "ss:load_package", &amp;name, &amp;pathname))
		return NULL;
	return load_package(name, pathname);
}

static PyObject *
imp_new_module(PyObject *self, PyObject *args)
{
	char *name;
	if (!PyArg_ParseTuple(args, "s:new_module", &amp;name))
		return NULL;
	return PyModule_New(name);
}

/* Doc strings */

static char doc_imp[] = "\
This module provides the components needed to build your own\n\
__import__ function.  Undocumented functions are obsolete.\n\
";

static char doc_find_module[] = "\
find_module(name, [path]) -&gt; (file, filename, (suffix, mode, type))\n\
Search for a module.  If path is omitted or None, search for a\n\
built-in, frozen or special module and continue search in sys.path.\n\
The module name cannot contain '.'; to search for a submodule of a\n\
package, pass the submodule name and the package's __path__.\
";

static char doc_load_module[] = "\
load_module(name, file, filename, (suffix, mode, type)) -&gt; module\n\
Load a module, given information returned by find_module().\n\
The module name must include the full package name, if any.\
";

static char doc_get_magic[] = "\
get_magic() -&gt; string\n\
Return the magic number for .pyc or .pyo files.\
";

static char doc_get_suffixes[] = "\
get_suffixes() -&gt; [(suffix, mode, type), ...]\n\
Return a list of (suffix, mode, type) tuples describing the files\n\
that find_module() looks for.\
";

static char doc_new_module[] = "\
new_module(name) -&gt; module\n\
Create a new module.  Do not enter it in sys.modules.\n\
The module name must include the full package name, if any.\
";

static char doc_lock_held[] = "\
lock_held() -&gt; 0 or 1\n\
Return 1 if the import lock is currently held.\n\
On platforms without threads, return 0.\
";

static PyMethodDef imp_methods[] = {
	{"find_module",		imp_find_module,	1, doc_find_module},
	{"get_magic",		imp_get_magic,		1, doc_get_magic},
	{"get_suffixes",	imp_get_suffixes,	1, doc_get_suffixes},
	{"load_module",		imp_load_module,	1, doc_load_module},
	{"new_module",		imp_new_module,		1, doc_new_module},
	{"lock_held",		imp_lock_held,		1, doc_lock_held},
	/* The rest are obsolete */
	{"get_frozen_object",	imp_get_frozen_object,	1},
	{"init_builtin",	imp_init_builtin,	1},
	{"init_frozen",		imp_init_frozen,	1},
	{"is_builtin",		imp_is_builtin,		1},
	{"is_frozen",		imp_is_frozen,		1},
	{"load_compiled",	imp_load_compiled,	1},
#ifdef HAVE_DYNAMIC_LOADING
	{"load_dynamic",	imp_load_dynamic,	1},
#endif
	{"load_package",	imp_load_package,	1},
#ifdef macintosh
	{"load_resource",	imp_load_resource,	1},
#endif
	{"load_source",		imp_load_source,	1},
	{NULL,			NULL}		/* sentinel */
};

static int
setint(PyObject *d, char *name, int value)
{
	PyObject *v;
	int err;

	v = PyInt_FromLong((long)value);
	err = PyDict_SetItemString(d, name, v);
	Py_XDECREF(v);
	return err;
}

void
initimp(void)
{
	PyObject *m, *d;

	m = Py_InitModule4("imp", imp_methods, doc_imp,
			   NULL, PYTHON_API_VERSION);
	d = PyModule_GetDict(m);

	if (setint(d, "SEARCH_ERROR", SEARCH_ERROR) &lt; 0) goto failure;
	if (setint(d, "PY_SOURCE", PY_SOURCE) &lt; 0) goto failure;
	if (setint(d, "PY_COMPILED", PY_COMPILED) &lt; 0) goto failure;
	if (setint(d, "C_EXTENSION", C_EXTENSION) &lt; 0) goto failure;
	if (setint(d, "PY_RESOURCE", PY_RESOURCE) &lt; 0) goto failure;
	if (setint(d, "PKG_DIRECTORY", PKG_DIRECTORY) &lt; 0) goto failure;
	if (setint(d, "C_BUILTIN", C_BUILTIN) &lt; 0) goto failure;
	if (setint(d, "PY_FROZEN", PY_FROZEN) &lt; 0) goto failure;
	if (setint(d, "PY_CODERESOURCE", PY_CODERESOURCE) &lt; 0) goto failure;

  failure:
	;
}


/* API for embedding applications that want to add their own entries
   to the table of built-in modules.  This should normally be called
   *before* Py_Initialize().  When the table resize fails, -1 is
   returned and the existing table is unchanged.

   After a similar function by Just van Rossum. */

int
PyImport_ExtendInittab(struct _inittab *newtab)
{
	static struct _inittab *our_copy = NULL;
	struct _inittab *p;
	int i, n;

	/* Count the number of entries in both tables */
	for (n = 0; newtab[n].name != NULL; n++)
		;
	if (n == 0)
		return 0; /* Nothing to do */
	for (i = 0; PyImport_Inittab[i].name != NULL; i++)
		;

	/* Allocate new memory for the combined table */
	p = our_copy;
	PyMem_RESIZE(p, struct _inittab, i+n+1);
	if (p == NULL)
		return -1;

	/* Copy the tables into the new memory */
	if (our_copy != PyImport_Inittab)
		memcpy(p, PyImport_Inittab, (i+1) * sizeof(struct _inittab));
	PyImport_Inittab = our_copy = p;
	memcpy(p+i, newtab, (n+1) * sizeof(struct _inittab));

	return 0;
}

/* Shorthand to add a single entry given a name and a function */

int
PyImport_AppendInittab(char *name, void (*initfunc)(void))
{
	struct _inittab newtab[2];

	memset(newtab, '\0', sizeof newtab);

	newtab[0].name = name;
	newtab[0].initfunc = initfunc;

	return PyImport_ExtendInittab(newtab);
}
</t>
<t tx="T604">#include "Python.h"

#include "node.h"
#include "token.h"
#include "errcode.h"
#include "marshal.h"
#include "compile.h"
#include "eval.h"
#include "osdefs.h"
#include "importdl.h"

#ifdef macintosh
#include "macglue.h"
#endif

#ifdef HAVE_FCNTL_H
#include &lt;fcntl.h&gt;
#endif</t>
<t tx="T605">extern time_t PyOS_GetLastModificationTime(char *, FILE *);
						/* In getmtime.c */

/* Magic word to reject .pyc files generated by other Python versions */
/* Change for each incompatible change */
/* The value of CR and LF is incorporated so if you ever read or write
   a .pyc file in text mode the magic number will be wrong; also, the
   Apple MPW compiler swaps their values, botching string constants.
   XXX That probably isn't important anymore.
*/
/* XXX Perhaps the magic number should be frozen and a version field
   added to the .pyc file header? */
/* New way to come up with the low 16 bits of the magic number:
      (YEAR-1995) * 10000 +  MONTH * 100 + DAY
   where MONTH and DAY are 1-based.
   XXX Whatever the "old way" may have been isn't documented.
   XXX This scheme breaks in 2002, as (2002-1995)*10000 = 70000 doesn't
       fit in 16 bits.
   XXX Later, sometimes 1 gets added to MAGIC in order to record that
       the Unicode -U option is in use.  IMO (Tim's), that's a Bad Idea
       (quite apart from that the -U option doesn't work so isn't used
       anyway).
*/
#define MAGIC (60717 | ((long)'\r'&lt;&lt;16) | ((long)'\n'&lt;&lt;24))

/* Magic word as global; note that _PyImport_Init() can change the
   value of this global to accommodate for alterations of how the
   compiler works which are enabled by command line switches. */
static long pyc_magic = MAGIC;

/* See _PyImport_FixupExtension() below */
static PyObject *extensions = NULL;

/* This table is defined in config.c: */
extern struct _inittab _PyImport_Inittab[];

struct _inittab *PyImport_Inittab = _PyImport_Inittab;

/* these tables define the module suffixes that Python recognizes */
struct filedescr * _PyImport_Filetab = NULL;

#ifdef RISCOS
static const struct filedescr _PyImport_StandardFiletab[] = {
	{"/py", "r", PY_SOURCE},
	{"/pyc", "rb", PY_COMPILED},
	{0, 0}
};
#else
static const struct filedescr _PyImport_StandardFiletab[] = {
	{".py", "r", PY_SOURCE},
#ifdef MS_WIN32
	{".pyw", "r", PY_SOURCE},
#endif
	{".pyc", "rb", PY_COMPILED},
	{0, 0}
};
</t>
<t tx="T606">#endif

/* Initialize things */

void
_PyImport_Init(void)
{
	const struct filedescr *scan;
	struct filedescr *filetab;
	int countD = 0;
	int countS = 0;

	/* prepare _PyImport_Filetab: copy entries from
	   _PyImport_DynLoadFiletab and _PyImport_StandardFiletab.
	 */
	for (scan = _PyImport_DynLoadFiletab; scan-&gt;suffix != NULL; ++scan)
		++countD;
	for (scan = _PyImport_StandardFiletab; scan-&gt;suffix != NULL; ++scan)
		++countS;
	filetab = PyMem_NEW(struct filedescr, countD + countS + 1);
	memcpy(filetab, _PyImport_DynLoadFiletab,
	       countD * sizeof(struct filedescr));
	memcpy(filetab + countD, _PyImport_StandardFiletab,
	       countS * sizeof(struct filedescr));
	filetab[countD + countS].suffix = NULL;

	_PyImport_Filetab = filetab;

	if (Py_OptimizeFlag) {
		/* Replace ".pyc" with ".pyo" in _PyImport_Filetab */
		for (; filetab-&gt;suffix != NULL; filetab++) {
#ifndef RISCOS
			if (strcmp(filetab-&gt;suffix, ".pyc") == 0)
				filetab-&gt;suffix = ".pyo";
#else
			if (strcmp(filetab-&gt;suffix, "/pyc") == 0)
				filetab-&gt;suffix = "/pyo";
#endif
		}
	}

	if (Py_UnicodeFlag) {
		/* Fix the pyc_magic so that byte compiled code created
		   using the all-Unicode method doesn't interfere with
		   code created in normal operation mode. */
		pyc_magic = MAGIC + 1;
	}
}
</t>
<t tx="T607">void
_PyImport_Fini(void)
{
	Py_XDECREF(extensions);
	extensions = NULL;
	PyMem_DEL(_PyImport_Filetab);
	_PyImport_Filetab = NULL;
}
</t>
<t tx="T608">@ Locking primitives to prevent parallel imports of the same module  in different threads to return with a partially loaded module.  These calls are serialized by the global interpreter lock.
@c

#ifdef WITH_THREAD

#include "pythread.h"

static PyThread_type_lock import_lock = 0;
static long import_lock_thread = -1;
static int import_lock_level = 0;

static void
lock_import(void)
{
	long me = PyThread_get_thread_ident();
	if (me == -1)
		return; /* Too bad */
	if (import_lock == NULL)
		import_lock = PyThread_allocate_lock();
	if (import_lock_thread == me) {
		import_lock_level++;
		return;
	}
	if (import_lock_thread != -1 || !PyThread_acquire_lock(import_lock, 0)) {
		PyThreadState *tstate = PyEval_SaveThread();
		PyThread_acquire_lock(import_lock, 1);
		PyEval_RestoreThread(tstate);
	}
	import_lock_thread = me;
	import_lock_level = 1;
}
</t>
<t tx="T609">static void
unlock_import(void)
{
	long me = PyThread_get_thread_ident();
	if (me == -1)
		return; /* Too bad */
	if (import_lock_thread != me)
		Py_FatalError("unlock_import: not holding the import lock");
	import_lock_level--;
	if (import_lock_level == 0) {
		import_lock_thread = -1;
		PyThread_release_lock(import_lock);
	}
}
</t>
<t tx="T610">#else

#define lock_import()
#define unlock_import()

#endif

static PyObject *
imp_lock_held(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ":lock_held"))
		return NULL;
#ifdef WITH_THREAD
	return PyInt_FromLong(import_lock_thread != -1);
#else
	return PyInt_FromLong(0);
#endif
}
</t>
<t tx="T611">@ Helper for sys
@c

PyObject *
PyImport_GetModuleDict(void)
{
	PyInterpreterState *interp = PyThreadState_Get()-&gt;interp;
	if (interp-&gt;modules == NULL)
		Py_FatalError("PyImport_GetModuleDict: no module dictionary!");
	return interp-&gt;modules;
}
</t>
<t tx="T612">@ List of names to clear in sys
@c

static char* sys_deletes[] = {
	"path", "argv", "ps1", "ps2", "exitfunc",
	"exc_type", "exc_value", "exc_traceback",
	"last_type", "last_value", "last_traceback",
	NULL
};

static char* sys_files[] = {
	"stdin", "__stdin__",
	"stdout", "__stdout__",
	"stderr", "__stderr__",
	NULL
};


/* Un-initialize things, as good as we can */

void
PyImport_Cleanup(void)
{
	int pos, ndone;
	char *name;
	PyObject *key, *value, *dict;
	PyInterpreterState *interp = PyThreadState_Get()-&gt;interp;
	PyObject *modules = interp-&gt;modules;

	if (modules == NULL)
		return; /* Already done */

	/* Delete some special variables first.  These are common
	   places where user values hide and people complain when their
	   destructors fail.  Since the modules containing them are
	   deleted *last* of all, they would come too late in the normal
	   destruction order.  Sigh. */

	value = PyDict_GetItemString(modules, "__builtin__");
	if (value != NULL &amp;&amp; PyModule_Check(value)) {
		dict = PyModule_GetDict(value);
		if (Py_VerboseFlag)
			PySys_WriteStderr("# clear __builtin__._\n");
		PyDict_SetItemString(dict, "_", Py_None);
	}
	value = PyDict_GetItemString(modules, "sys");
	if (value != NULL &amp;&amp; PyModule_Check(value)) {
		char **p;
		PyObject *v;
		dict = PyModule_GetDict(value);
		for (p = sys_deletes; *p != NULL; p++) {
			if (Py_VerboseFlag)
				PySys_WriteStderr("# clear sys.%s\n", *p);
			PyDict_SetItemString(dict, *p, Py_None);
		}
		for (p = sys_files; *p != NULL; p+=2) {
			if (Py_VerboseFlag)
				PySys_WriteStderr("# restore sys.%s\n", *p);
			v = PyDict_GetItemString(dict, *(p+1));
			if (v == NULL)
				v = Py_None;
			PyDict_SetItemString(dict, *p, v);
		}
	}

	/* First, delete __main__ */
	value = PyDict_GetItemString(modules, "__main__");
	if (value != NULL &amp;&amp; PyModule_Check(value)) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# cleanup __main__\n");
		_PyModule_Clear(value);
		PyDict_SetItemString(modules, "__main__", Py_None);
	}

	/* The special treatment of __builtin__ here is because even
	   when it's not referenced as a module, its dictionary is
	   referenced by almost every module's __builtins__.  Since
	   deleting a module clears its dictionary (even if there are
	   references left to it), we need to delete the __builtin__
	   module last.  Likewise, we don't delete sys until the very
	   end because it is implicitly referenced (e.g. by print).

	   Also note that we 'delete' modules by replacing their entry
	   in the modules dict with None, rather than really deleting
	   them; this avoids a rehash of the modules dictionary and
	   also marks them as "non existent" so they won't be
	   re-imported. */

	/* Next, repeatedly delete modules with a reference count of
	   one (skipping __builtin__ and sys) and delete them */
	do {
		ndone = 0;
		pos = 0;
		while (PyDict_Next(modules, &amp;pos, &amp;key, &amp;value)) {
			if (value-&gt;ob_refcnt != 1)
				continue;
			if (PyString_Check(key) &amp;&amp; PyModule_Check(value)) {
				name = PyString_AS_STRING(key);
				if (strcmp(name, "__builtin__") == 0)
					continue;
				if (strcmp(name, "sys") == 0)
					continue;
				if (Py_VerboseFlag)
					PySys_WriteStderr(
						"# cleanup[1] %s\n", name);
				_PyModule_Clear(value);
				PyDict_SetItem(modules, key, Py_None);
				ndone++;
			}
		}
	} while (ndone &gt; 0);

	/* Next, delete all modules (still skipping __builtin__ and sys) */
	pos = 0;
	while (PyDict_Next(modules, &amp;pos, &amp;key, &amp;value)) {
		if (PyString_Check(key) &amp;&amp; PyModule_Check(value)) {
			name = PyString_AS_STRING(key);
			if (strcmp(name, "__builtin__") == 0)
				continue;
			if (strcmp(name, "sys") == 0)
				continue;
			if (Py_VerboseFlag)
				PySys_WriteStderr("# cleanup[2] %s\n", name);
			_PyModule_Clear(value);
			PyDict_SetItem(modules, key, Py_None);
		}
	}

	/* Next, delete sys and __builtin__ (in that order) */
	value = PyDict_GetItemString(modules, "sys");
	if (value != NULL &amp;&amp; PyModule_Check(value)) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# cleanup sys\n");
		_PyModule_Clear(value);
		PyDict_SetItemString(modules, "sys", Py_None);
	}
	value = PyDict_GetItemString(modules, "__builtin__");
	if (value != NULL &amp;&amp; PyModule_Check(value)) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# cleanup __builtin__\n");
		_PyModule_Clear(value);
		PyDict_SetItemString(modules, "__builtin__", Py_None);
	}

	/* Finally, clear and delete the modules directory */
	PyDict_Clear(modules);
	interp-&gt;modules = NULL;
	Py_DECREF(modules);
}
</t>
<t tx="T613">@ Helper for pythonrun.c -- return magic number
@c

long
PyImport_GetMagicNumber(void)
{
	return pyc_magic;
}
</t>
<t tx="T614">@ Magic for extension modules (built-in as well as dynamically  loaded). To prevent initializing an extension module more than  once, we keep a static dictionary 'extensions' keyed by module name  (for built-in modules) or by filename (for dynamically loaded  modules), containing these modules. A copy of the module's  dictionary is stored by calling _PyImport_FixupExtension()  immediately after the module initialization function succeeds. A  copy can be retrieved from there by calling  _PyImport_FindExtension().
@c

PyObject *
_PyImport_FixupExtension(char *name, char *filename)
{
	PyObject *modules, *mod, *dict, *copy;
	if (extensions == NULL) {
		extensions = PyDict_New();
		if (extensions == NULL)
			return NULL;
	}
	modules = PyImport_GetModuleDict();
	mod = PyDict_GetItemString(modules, name);
	if (mod == NULL || !PyModule_Check(mod)) {
		PyErr_Format(PyExc_SystemError,
		  "_PyImport_FixupExtension: module %.200s not loaded", name);
		return NULL;
	}
	dict = PyModule_GetDict(mod);
	if (dict == NULL)
		return NULL;
	copy = PyDict_Copy(dict);
	if (copy == NULL)
		return NULL;
	PyDict_SetItemString(extensions, filename, copy);
	Py_DECREF(copy);
	return copy;
}
</t>
<t tx="T615">PyObject *
_PyImport_FindExtension(char *name, char *filename)
{
	PyObject *dict, *mod, *mdict;
	if (extensions == NULL)
		return NULL;
	dict = PyDict_GetItemString(extensions, filename);
	if (dict == NULL)
		return NULL;
	mod = PyImport_AddModule(name);
	if (mod == NULL)
		return NULL;
	mdict = PyModule_GetDict(mod);
	if (mdict == NULL)
		return NULL;
	if (PyDict_Update(mdict, dict))
		return NULL;
	if (Py_VerboseFlag)
		PySys_WriteStderr("import %s # previously loaded (%s)\n",
			name, filename);
	return mod;
}
</t>
<t tx="T616">@ Get the module object corresponding to a module name.  First check the modules dictionary if there's one there,  if not, create a new one and insert in in the modules dictionary.  Because the former action is most common, THIS DOES NOT RETURN A  'NEW' REFERENCE!
@c

PyObject *
PyImport_AddModule(char *name)
{
	PyObject *modules = PyImport_GetModuleDict();
	PyObject *m;

	if ((m = PyDict_GetItemString(modules, name)) != NULL &amp;&amp;
	    PyModule_Check(m))
		return m;
	m = PyModule_New(name);
	if (m == NULL)
		return NULL;
	if (PyDict_SetItemString(modules, name, m) != 0) {
		Py_DECREF(m);
		return NULL;
	}
	Py_DECREF(m); /* Yes, it still exists, in modules! */

	return m;
}
</t>
<t tx="T617">@ Execute a code object in a module and return the module object  WITH INCREMENTED REFERENCE COUNT
@c

PyObject *
PyImport_ExecCodeModule(char *name, PyObject *co)
{
	return PyImport_ExecCodeModuleEx(name, co, (char *)NULL);
}
</t>
<t tx="T618">PyObject *
PyImport_ExecCodeModuleEx(char *name, PyObject *co, char *pathname)
{
	PyObject *modules = PyImport_GetModuleDict();
	PyObject *m, *d, *v;

	m = PyImport_AddModule(name);
	if (m == NULL)
		return NULL;
	d = PyModule_GetDict(m);
	if (PyDict_GetItemString(d, "__builtins__") == NULL) {
		if (PyDict_SetItemString(d, "__builtins__",
					 PyEval_GetBuiltins()) != 0)
			return NULL;
	}
	/* Remember the filename as the __file__ attribute */
	v = NULL;
	if (pathname != NULL) {
		v = PyString_FromString(pathname);
		if (v == NULL)
			PyErr_Clear();
	}
	if (v == NULL) {
		v = ((PyCodeObject *)co)-&gt;co_filename;
		Py_INCREF(v);
	}
	if (PyDict_SetItemString(d, "__file__", v) != 0)
		PyErr_Clear(); /* Not important enough to report */
	Py_DECREF(v);

	v = PyEval_EvalCode((PyCodeObject *)co, d, d);
	if (v == NULL)
		return NULL;
	Py_DECREF(v);

	if ((m = PyDict_GetItemString(modules, name)) == NULL) {
		PyErr_Format(PyExc_ImportError,
			     "Loaded module %.200s not found in sys.modules",
			     name);
		return NULL;
	}

	Py_INCREF(m);

	return m;
}
</t>
<t tx="T619">@ Given a pathname for a Python source file, fill a buffer with the  pathname for the corresponding compiled file. Return the pathname  for the compiled file, or NULL if there's no space in the buffer.  Doesn't set an exception.
@c

static char *
make_compiled_pathname(char *pathname, char *buf, size_t buflen)
{
	size_t len = strlen(pathname);
	if (len+2 &gt; buflen)
		return NULL;

#ifdef MS_WIN32
	/* Treat .pyw as if it were .py.  The case of ".pyw" must match
	   that used in _PyImport_StandardFiletab. */
	if (len &gt;= 4 &amp;&amp; strcmp(&amp;pathname[len-4], ".pyw") == 0)
		--len;	/* pretend 'w' isn't there */
#endif
	memcpy(buf, pathname, len);
	buf[len] = Py_OptimizeFlag ? 'o' : 'c';
	buf[len+1] = '\0';

	return buf;
}
</t>
<t tx="T620">@ Given a pathname for a Python source file, its time of last  modification, and a pathname for a compiled file, check whether the  compiled file represents the same version of the source. If so,  return a FILE pointer for the compiled file, positioned just after  the header; if not, return NULL.  Doesn't set an exception.
@c

static FILE *
check_compiled_module(char *pathname, long mtime, char *cpathname)
{
	FILE *fp;
	long magic;
	long pyc_mtime;

	fp = fopen(cpathname, "rb");
	if (fp == NULL)
		return NULL;
	magic = PyMarshal_ReadLongFromFile(fp);
	if (magic != pyc_magic) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# %s has bad magic\n", cpathname);
		fclose(fp);
		return NULL;
	}
	pyc_mtime = PyMarshal_ReadLongFromFile(fp);
	if (pyc_mtime != mtime) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# %s has bad mtime\n", cpathname);
		fclose(fp);
		return NULL;
	}
	if (Py_VerboseFlag)
		PySys_WriteStderr("# %s matches %s\n", cpathname, pathname);
	return fp;
}
</t>
<t tx="T621">@ Read a code object from a file and check it for validity
@c

static PyCodeObject *
read_compiled_module(char *cpathname, FILE *fp)
{
	PyObject *co;

	co = PyMarshal_ReadLastObjectFromFile(fp);
	/* Ugly: rd_object() may return NULL with or without error */
	if (co == NULL || !PyCode_Check(co)) {
		if (!PyErr_Occurred())
			PyErr_Format(PyExc_ImportError,
			    "Non-code object in %.200s", cpathname);
		Py_XDECREF(co);
		return NULL;
	}
	return (PyCodeObject *)co;
}
</t>
<t tx="T622">@ Load a module from a compiled file, execute it, and return its  module object WITH INCREMENTED REFERENCE COUNT
@c

static PyObject *
load_compiled_module(char *name, char *cpathname, FILE *fp)
{
	long magic;
	PyCodeObject *co;
	PyObject *m;

	magic = PyMarshal_ReadLongFromFile(fp);
	if (magic != pyc_magic) {
		PyErr_Format(PyExc_ImportError,
			     "Bad magic number in %.200s", cpathname);
		return NULL;
	}
	(void) PyMarshal_ReadLongFromFile(fp);
	co = read_compiled_module(cpathname, fp);
	if (co == NULL)
		return NULL;
	if (Py_VerboseFlag)
		PySys_WriteStderr("import %s # precompiled from %s\n",
			name, cpathname);
	m = PyImport_ExecCodeModuleEx(name, (PyObject *)co, cpathname);
	Py_DECREF(co);

	return m;
}
</t>
<t tx="T623">@ Parse a source file and return the corresponding code object
@c

static PyCodeObject *
parse_source_module(char *pathname, FILE *fp)
{
	PyCodeObject *co;
	node *n;

	n = PyParser_SimpleParseFile(fp, pathname, Py_file_input);
	if (n == NULL)
		return NULL;
	co = PyNode_Compile(n, pathname);
	PyNode_Free(n);

	return co;
}
</t>
<t tx="T624">@ Helper to open a bytecode file for writing in exclusive mode
@c

static FILE *
open_exclusive(char *filename)
{
#if defined(O_EXCL)&amp;&amp;defined(O_CREAT)&amp;&amp;defined(O_WRONLY)&amp;&amp;defined(O_TRUNC)
	/* Use O_EXCL to avoid a race condition when another process tries to
	   write the same file.  When that happens, our open() call fails,
	   which is just fine (since it's only a cache).
	   XXX If the file exists and is writable but the directory is not
	   writable, the file will never be written.  Oh well.
	*/
	int fd;
	(void) unlink(filename);
	fd = open(filename, O_EXCL|O_CREAT|O_WRONLY|O_TRUNC
#ifdef O_BINARY
				|O_BINARY   /* necessary for Windows */
#endif

			, 0666);
	if (fd &lt; 0)
		return NULL;
	return fdopen(fd, "wb");
#else
	/* Best we can do -- on Windows this can't happen anyway */
	return fopen(filename, "wb");
#endif
}
</t>
<t tx="T625">@ Write a compiled module to a file, placing the time of last  modification of its source into the header.  Errors are ignored, if a write error occurs an attempt is made to  remove the file.
@c

static void
write_compiled_module(PyCodeObject *co, char *cpathname, long mtime)
{
	FILE *fp;

	fp = open_exclusive(cpathname);
	if (fp == NULL) {
		if (Py_VerboseFlag)
			PySys_WriteStderr(
				"# can't create %s\n", cpathname);
		return;
	}
	PyMarshal_WriteLongToFile(pyc_magic, fp);
	/* First write a 0 for mtime */
	PyMarshal_WriteLongToFile(0L, fp);
	PyMarshal_WriteObjectToFile((PyObject *)co, fp);
	if (ferror(fp)) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# can't write %s\n", cpathname);
		/* Don't keep partial file */
		fclose(fp);
		(void) unlink(cpathname);
		return;
	}
	/* Now write the true mtime */
	fseek(fp, 4L, 0);
	PyMarshal_WriteLongToFile(mtime, fp);
	fflush(fp);
	fclose(fp);
	if (Py_VerboseFlag)
		PySys_WriteStderr("# wrote %s\n", cpathname);
#ifdef macintosh
	PyMac_setfiletype(cpathname, 'Pyth', 'PYC ');
#endif
}
</t>
<t tx="T626">@ Load a source module from a given file and return its module  object WITH INCREMENTED REFERENCE COUNT. If there's a matching  byte-compiled file, use that instead.
@c

static PyObject *
load_source_module(char *name, char *pathname, FILE *fp)
{
	time_t mtime;
	FILE *fpc;
	char buf[MAXPATHLEN+1];
	char *cpathname;
	PyCodeObject *co;
	PyObject *m;

	mtime = PyOS_GetLastModificationTime(pathname, fp);
	if (mtime == (time_t)(-1))
		return NULL;
#if SIZEOF_TIME_T &gt; 4
	/* Python's .pyc timestamp handling presumes that the timestamp fits
	   in 4 bytes. This will be fine until sometime in the year 2038,
	   when a 4-byte signed time_t will overflow.
	 */
	if (mtime &gt;&gt; 32) {
		PyErr_SetString(PyExc_OverflowError,
			"modification time overflows a 4 byte field");
		return NULL;
	}
#endif
	cpathname = make_compiled_pathname(pathname, buf,
					   (size_t)MAXPATHLEN + 1);
	if (cpathname != NULL &amp;&amp;
	    (fpc = check_compiled_module(pathname, mtime, cpathname))) {
		co = read_compiled_module(cpathname, fpc);
		fclose(fpc);
		if (co == NULL)
			return NULL;
		if (Py_VerboseFlag)
			PySys_WriteStderr("import %s # precompiled from %s\n",
				name, cpathname);
		pathname = cpathname;
	}
	else {
		co = parse_source_module(pathname, fp);
		if (co == NULL)
			return NULL;
		if (Py_VerboseFlag)
			PySys_WriteStderr("import %s # from %s\n",
				name, pathname);
		write_compiled_module(co, cpathname, mtime);
	}
	m = PyImport_ExecCodeModuleEx(name, (PyObject *)co, pathname);
	Py_DECREF(co);

	return m;
}
</t>
<t tx="T627">@ Forward
@c

static PyObject *load_module(char *, FILE *, char *, int);
static struct filedescr *find_module(char *, PyObject *,
				     char *, size_t, FILE **);
static struct _frozen *find_frozen(char *name);

/* Load a package and return its module object WITH INCREMENTED
   REFERENCE COUNT */

static PyObject *
load_package(char *name, char *pathname)
{
	PyObject *m, *d, *file, *path;
	int err;
	char buf[MAXPATHLEN+1];
	FILE *fp = NULL;
	struct filedescr *fdp;

	m = PyImport_AddModule(name);
	if (m == NULL)
		return NULL;
	if (Py_VerboseFlag)
		PySys_WriteStderr("import %s # directory %s\n",
			name, pathname);
	d = PyModule_GetDict(m);
	file = PyString_FromString(pathname);
	if (file == NULL)
		return NULL;
	path = Py_BuildValue("[O]", file);
	if (path == NULL) {
		Py_DECREF(file);
		return NULL;
	}
	err = PyDict_SetItemString(d, "__file__", file);
	if (err == 0)
		err = PyDict_SetItemString(d, "__path__", path);
	if (err != 0) {
		m = NULL;
		goto cleanup;
	}
	buf[0] = '\0';
	fdp = find_module("__init__", path, buf, sizeof(buf), &amp;fp);
	if (fdp == NULL) {
		if (PyErr_ExceptionMatches(PyExc_ImportError)) {
			PyErr_Clear();
		}
		else
			m = NULL;
		goto cleanup;
	}
	m = load_module(name, fp, buf, fdp-&gt;type);
	if (fp != NULL)
		fclose(fp);
  cleanup:
	Py_XDECREF(path);
	Py_XDECREF(file);
	return m;
}</t>
<t tx="T628">@ Helper to test for built-in module
@c

static int
is_builtin(char *name)
{
	int i;
	for (i = 0; PyImport_Inittab[i].name != NULL; i++) {
		if (strcmp(name, PyImport_Inittab[i].name) == 0) {
			if (PyImport_Inittab[i].initfunc == NULL)
				return -1;
			else
				return 1;
		}
	}
	return 0;
}
</t>
<t tx="T629">@language c
@ignore</t>
<t tx="T630">
/* String object interface */

#ifndef Py_STRINGOBJECT_H
#define Py_STRINGOBJECT_H
#ifdef __cplusplus
extern "C" {
#endif

#include &lt;stdarg.h&gt;

/*
Type PyStringObject represents a character string.  An extra zero byte is
reserved at the end to ensure it is zero-terminated, but a size is
present so strings with null bytes in them can be represented.  This
is an immutable object type.

There are functions to create new string objects, to test
an object for string-ness, and to get the
string value.  The latter function returns a null pointer
if the object is not of the proper type.
There is a variant that takes an explicit size as well as a
variant that assumes a zero-terminated string.  Note that none of the
functions should be applied to nil objects.
*/

/* Two speedup hacks.  Caching the hash saves recalculation of a
   string's hash value.  Interning strings (which requires hash
   caching) tries to ensure that only one string object with a given
   value exists, so equality tests are one pointer comparison.
   Together, these can speed the interpreter up by as much as 20%.
   Each costs the size of a long or pointer per string object.  In
   addition, interned strings live until the end of times.  If you are
   concerned about memory footprint, simply comment the #define out
   here (and rebuild everything!). */
#define CACHE_HASH
#ifdef CACHE_HASH
#define INTERN_STRINGS
#endif

typedef struct {
    PyObject_VAR_HEAD
#ifdef CACHE_HASH
    long ob_shash;
#endif
#ifdef INTERN_STRINGS
    PyObject *ob_sinterned;
#endif
    char ob_sval[1];
} PyStringObject;

extern DL_IMPORT(PyTypeObject) PyString_Type;

#define PyString_Check(op) PyObject_TypeCheck(op, &amp;PyString_Type)
#define PyString_CheckExact(op) ((op)-&gt;ob_type == &amp;PyString_Type)

extern DL_IMPORT(PyObject *) PyString_FromStringAndSize(const char *, int);
extern DL_IMPORT(PyObject *) PyString_FromString(const char *);
extern DL_IMPORT(PyObject *) PyString_FromFormatV(const char*, va_list)
				__attribute__((format(printf, 1, 0)));
extern DL_IMPORT(PyObject *) PyString_FromFormat(const char*, ...)
				__attribute__((format(printf, 1, 2)));
extern DL_IMPORT(int) PyString_Size(PyObject *);
extern DL_IMPORT(char *) PyString_AsString(PyObject *);
extern DL_IMPORT(void) PyString_Concat(PyObject **, PyObject *);
extern DL_IMPORT(void) PyString_ConcatAndDel(PyObject **, PyObject *);
extern DL_IMPORT(int) _PyString_Resize(PyObject **, int);
extern DL_IMPORT(int) _PyString_Eq(PyObject *, PyObject*);
extern DL_IMPORT(PyObject *) PyString_Format(PyObject *, PyObject *);
extern DL_IMPORT(PyObject *) _PyString_FormatLong(PyObject*, int, int,
						  int, char**, int*);

#ifdef INTERN_STRINGS
extern DL_IMPORT(void) PyString_InternInPlace(PyObject **);
extern DL_IMPORT(PyObject *) PyString_InternFromString(const char *);
extern DL_IMPORT(void) _Py_ReleaseInternedStrings(void);
#else
#define PyString_InternInPlace(p)
#define PyString_InternFromString(cp) PyString_FromString(cp)
#define _Py_ReleaseInternedStrings()
#endif

/* Macro, trading safety for speed */
#define PyString_AS_STRING(op) (((PyStringObject *)(op))-&gt;ob_sval)
#define PyString_GET_SIZE(op)  (((PyStringObject *)(op))-&gt;ob_size)

/* _PyString_Join(sep, x) is like sep.join(x).  sep must be PyStringObject*,
   x must be an iterable object. */
extern DL_IMPORT(PyObject *) _PyString_Join(PyObject *sep, PyObject *x);

/* --- Generic Codecs ----------------------------------------------------- */

/* Create an object by decoding the encoded string s of the
   given size. */

extern DL_IMPORT(PyObject*) PyString_Decode(
    const char *s,              /* encoded string */
    int size,                   /* size of buffer */
    const char *encoding,       /* encoding */
    const char *errors          /* error handling */
    );

/* Encodes a char buffer of the given size and returns a 
   Python object. */

extern DL_IMPORT(PyObject*) PyString_Encode(
    const char *s,              /* string char buffer */
    int size,                   /* number of chars to encode */
    const char *encoding,       /* encoding */
    const char *errors          /* error handling */
    );

/* Encodes a string object and returns the result as Python 
   object. */

extern DL_IMPORT(PyObject*) PyString_AsEncodedObject(
    PyObject *str,	 	/* string object */
    const char *encoding,	/* encoding */
    const char *errors		/* error handling */
    );

/* Encodes a string object and returns the result as Python string
   object.   
   
   If the codec returns an Unicode object, the object is converted
   back to a string using the default encoding.

   DEPRECATED - use PyString_AsEncodedObject() instead. */

extern DL_IMPORT(PyObject*) PyString_AsEncodedString(
    PyObject *str,	 	/* string object */
    const char *encoding,	/* encoding */
    const char *errors		/* error handling */
    );

/* Decodes a string object and returns the result as Python 
   object. */

extern DL_IMPORT(PyObject*) PyString_AsDecodedObject(
    PyObject *str,	 	/* string object */
    const char *encoding,	/* encoding */
    const char *errors		/* error handling */
    );

/* Decodes a string object and returns the result as Python string
   object.  
   
   If the codec returns an Unicode object, the object is converted
   back to a string using the default encoding.

   DEPRECATED - use PyString_AsDecodedObject() instead. */

extern DL_IMPORT(PyObject*) PyString_AsDecodedString(
    PyObject *str,	 	/* string object */
    const char *encoding,	/* encoding */
    const char *errors		/* error handling */
    );

/* Provides access to the internal data buffer and size of a string
   object or the default encoded version of an Unicode object. Passing
   NULL as *len parameter will force the string buffer to be
   0-terminated (passing a string with embedded NULL characters will
   cause an exception).  */

extern DL_IMPORT(int) PyString_AsStringAndSize(
    register PyObject *obj,	/* string or Unicode object */
    register char **s,		/* pointer to buffer variable */
    register int *len		/* pointer to length variable or NULL
				   (only possible for 0-terminated
				   strings) */
    );
    

#ifdef __cplusplus
}
#endif
#endif /* !Py_STRINGOBJECT_H */
</t>
<t tx="T631">@language c

/* String object implementation */

#include "Python.h"
#include &lt;ctype.h&gt;

&lt;&lt; stringobject declarations &gt;&gt;

@others</t>
<t tx="T632">#ifdef COUNT_ALLOCS
	int null_strings, one_strings;
#endif

#if !defined(HAVE_LIMITS_H) &amp;&amp; !defined(UCHAR_MAX)
	#define UCHAR_MAX 255
#endif

static PyStringObject *characters[UCHAR_MAX + 1];

#ifndef DONT_SHARE_SHORT_STRINGS
	static PyStringObject *nullstring;
#endif</t>
<t tx="T633">/*
   PyString_FromStringAndSize() and PyString_FromString() try in certain cases
   to share string objects.  When the size of the string is zero, these 
   routines always return a pointer to the same string object; when the size 
   is one, they return a pointer to an already existing object if the contents
   of the string is known.  For PyString_FromString() this is always the case,
   for PyString_FromStringAndSize() this is the case when the first argument 
   in not NULL.

   A common practice of allocating a string and then filling it in or changing
   it must be done carefully.  It is only allowed to change the contents of 
   the string if the object was gotten from PyString_FromStringAndSize() with 
   a NULL first argument, because in the future these routines may try to do 
   even more sharing of objects.

   The string in the  `str' parameter does not have to be null-character 
   terminated.  (Therefore it is safe to construct a substring by using 
   `PyString_FromStringAndSize(origstring, substrlen)'.)

   The parameter `size' denotes number of characters to allocate, not
   counting the null terminating character.  If the `str' argument is
   not NULL, then it points to a of length `size'. For
   PyString_FromString, this string must be null-terminated.

   The member `op-&gt;ob_size' denotes the number of bytes of data in the string, 
   not counting the null terminating character, and is therefore equal to the 
   `size' parameter.
*/
PyObject *
PyString_FromStringAndSize(const char *str, int size)
{
	register PyStringObject *op;
#ifndef DONT_SHARE_SHORT_STRINGS
	if (size == 0 &amp;&amp; (op = nullstring) != NULL) {
#ifdef COUNT_ALLOCS
		null_strings++;
#endif
		Py_INCREF(op);
		return (PyObject *)op;
	}
	if (size == 1 &amp;&amp; str != NULL &amp;&amp;
	    (op = characters[*str &amp; UCHAR_MAX]) != NULL)
	{
#ifdef COUNT_ALLOCS
		one_strings++;
#endif
		Py_INCREF(op);
		return (PyObject *)op;
	}
#endif /* DONT_SHARE_SHORT_STRINGS */

	/* PyObject_NewVar is inlined */
	op = (PyStringObject *)
		PyObject_MALLOC(sizeof(PyStringObject) + size * sizeof(char));
	if (op == NULL)
		return PyErr_NoMemory();
	PyObject_INIT_VAR(op, &amp;PyString_Type, size);
#ifdef CACHE_HASH
	op-&gt;ob_shash = -1;
#endif
#ifdef INTERN_STRINGS
	op-&gt;ob_sinterned = NULL;
#endif
	if (str != NULL)
		memcpy(op-&gt;ob_sval, str, size);
	op-&gt;ob_sval[size] = '\0';
#ifndef DONT_SHARE_SHORT_STRINGS
	if (size == 0) {
		PyObject *t = (PyObject *)op;
		PyString_InternInPlace(&amp;t);
		op = (PyStringObject *)t;
		nullstring = op;
		Py_INCREF(op);
	} else if (size == 1 &amp;&amp; str != NULL) {
		PyObject *t = (PyObject *)op;
		PyString_InternInPlace(&amp;t);
		op = (PyStringObject *)t;
		characters[*str &amp; UCHAR_MAX] = op;
		Py_INCREF(op);
	}
#endif
	return (PyObject *) op;
}
</t>
<t tx="T634">PyObject *
PyString_FromString(const char *str)
{
	register size_t size;
	register PyStringObject *op;

	assert(str != NULL);
	size = strlen(str);
	if (size &gt; INT_MAX) {
		PyErr_SetString(PyExc_OverflowError,
			"string is too long for a Python string");
		return NULL;
	}
#ifndef DONT_SHARE_SHORT_STRINGS
	if (size == 0 &amp;&amp; (op = nullstring) != NULL) {
#ifdef COUNT_ALLOCS
		null_strings++;
#endif
		Py_INCREF(op);
		return (PyObject *)op;
	}
	if (size == 1 &amp;&amp; (op = characters[*str &amp; UCHAR_MAX]) != NULL) {
#ifdef COUNT_ALLOCS
		one_strings++;
#endif
		Py_INCREF(op);
		return (PyObject *)op;
	}
#endif /* DONT_SHARE_SHORT_STRINGS */

	/* PyObject_NewVar is inlined */
	op = (PyStringObject *)
		PyObject_MALLOC(sizeof(PyStringObject) + size * sizeof(char));
	if (op == NULL)
		return PyErr_NoMemory();
	PyObject_INIT_VAR(op, &amp;PyString_Type, size);
#ifdef CACHE_HASH
	op-&gt;ob_shash = -1;
#endif
#ifdef INTERN_STRINGS
	op-&gt;ob_sinterned = NULL;
#endif
	memcpy(op-&gt;ob_sval, str, size+1);
#ifndef DONT_SHARE_SHORT_STRINGS
	if (size == 0) {
		PyObject *t = (PyObject *)op;
		PyString_InternInPlace(&amp;t);
		op = (PyStringObject *)t;
		nullstring = op;
		Py_INCREF(op);
	} else if (size == 1) {
		PyObject *t = (PyObject *)op;
		PyString_InternInPlace(&amp;t);
		op = (PyStringObject *)t;
		characters[*str &amp; UCHAR_MAX] = op;
		Py_INCREF(op);
	}
#endif
	return (PyObject *) op;
}
</t>
<t tx="T635">PyObject *
PyString_FromFormatV(const char *format, va_list vargs)
{
	va_list count;
	int n = 0;
	const char* f;
	char *s;
	PyObject* string;

#ifdef VA_LIST_IS_ARRAY
	memcpy(count, vargs, sizeof(va_list));
#else
	count = vargs;
#endif
	/* step 1: figure out how large a buffer we need */
	for (f = format; *f; f++) {
		if (*f == '%') {
			const char* p = f;
			while (*++f &amp;&amp; *f != '%' &amp;&amp; !isalpha(Py_CHARMASK(*f)))
				;

			/* skip the 'l' in %ld, since it doesn't change the
			   width.  although only %d is supported (see
			   "expand" section below), others can be easily
			   added */
			if (*f == 'l' &amp;&amp; *(f+1) == 'd')
				++f;
			
			switch (*f) {
			case 'c':
				(void)va_arg(count, int);
				/* fall through... */
			case '%':
				n++;
				break;
			case 'd': case 'i': case 'x':
				(void) va_arg(count, int);
				/* 20 bytes is enough to hold a 64-bit
				   integer.  Decimal takes the most space.
				   This isn't enough for octal. */
				n += 20;
				break;
			case 's':
				s = va_arg(count, char*);
				n += strlen(s);
				break;
			case 'p':
				(void) va_arg(count, int);
				/* maximum 64-bit pointer representation:
				 * 0xffffffffffffffff
				 * so 19 characters is enough.
				 * XXX I count 18 -- what's the extra for?
				 */
				n += 19;
				break;
			default:
				/* if we stumble upon an unknown
				   formatting code, copy the rest of
				   the format string to the output
				   string. (we cannot just skip the
				   code, since there's no way to know
				   what's in the argument list) */ 
				n += strlen(p);
				goto expand;
			}
		} else
			n++;
	}
 expand:
	/* step 2: fill the buffer */
	/* Since we've analyzed how much space we need for the worst case,
	   use sprintf directly instead of the slower PyOS_snprintf. */
	string = PyString_FromStringAndSize(NULL, n);
	if (!string)
		return NULL;
	
	s = PyString_AsString(string);

	for (f = format; *f; f++) {
		if (*f == '%') {
			const char* p = f++;
			int i, longflag = 0;
			/* parse the width.precision part (we're only
			   interested in the precision value, if any) */
			n = 0;
			while (isdigit(Py_CHARMASK(*f)))
				n = (n*10) + *f++ - '0';
			if (*f == '.') {
				f++;
				n = 0;
				while (isdigit(Py_CHARMASK(*f)))
					n = (n*10) + *f++ - '0';
			}
			while (*f &amp;&amp; *f != '%' &amp;&amp; !isalpha(Py_CHARMASK(*f)))
				f++;
			/* handle the long flag, but only for %ld.  others
			   can be added when necessary. */
			if (*f == 'l' &amp;&amp; *(f+1) == 'd') {
				longflag = 1;
				++f;
			}
			
			switch (*f) {
			case 'c':
				*s++ = va_arg(vargs, int);
				break;
			case 'd':
				if (longflag)
					sprintf(s, "%ld", va_arg(vargs, long));
				else
					sprintf(s, "%d", va_arg(vargs, int));
				s += strlen(s);
				break;
			case 'i':
				sprintf(s, "%i", va_arg(vargs, int));
				s += strlen(s);
				break;
			case 'x':
				sprintf(s, "%x", va_arg(vargs, int));
				s += strlen(s);
				break;
			case 's':
				p = va_arg(vargs, char*);
				i = strlen(p);
				if (n &gt; 0 &amp;&amp; i &gt; n)
					i = n;
				memcpy(s, p, i);
				s += i;
				break;
			case 'p':
				sprintf(s, "%p", va_arg(vargs, void*));
				/* %p is ill-defined:  ensure leading 0x. */
				if (s[1] == 'X')
					s[1] = 'x';
				else if (s[1] != 'x') {
					memmove(s+2, s, strlen(s)+1);
					s[0] = '0';
					s[1] = 'x';
				}
				s += strlen(s);
				break;
			case '%':
				*s++ = '%';
				break;
			default:
				strcpy(s, p);
				s += strlen(s);
				goto end;
			}
		} else
			*s++ = *f;
	}
	
 end:
	_PyString_Resize(&amp;string, s - PyString_AS_STRING(string));
	return string;
}
</t>
<t tx="T636">PyObject *
PyString_FromFormat(const char *format, ...) 
{
	PyObject* ret;
	va_list vargs;

#ifdef HAVE_STDARG_PROTOTYPES
	va_start(vargs, format);
#else
	va_start(vargs);
#endif
	ret = PyString_FromFormatV(format, vargs);
	va_end(vargs);
	return ret;
}
</t>
<t tx="T637">PyObject *PyString_Decode(const char *s,
			  int size,
			  const char *encoding,
			  const char *errors)
{
    PyObject *v, *str;

    str = PyString_FromStringAndSize(s, size);
    if (str == NULL)
	return NULL;
    v = PyString_AsDecodedString(str, encoding, errors);
    Py_DECREF(str);
    return v;
}
</t>
<t tx="T638">PyObject *PyString_AsDecodedObject(PyObject *str,
				   const char *encoding,
				   const char *errors)
{
    PyObject *v;

    if (!PyString_Check(str)) {
        PyErr_BadArgument();
        goto onError;
    }

    if (encoding == NULL) {
#ifdef Py_USING_UNICODE
	encoding = PyUnicode_GetDefaultEncoding();
#else
	PyErr_SetString(PyExc_ValueError, "no encoding specified");
	goto onError;
#endif
    }

    /* Decode via the codec registry */
    v = PyCodec_Decode(str, encoding, errors);
    if (v == NULL)
        goto onError;

    return v;

 onError:
    return NULL;
}
</t>
<t tx="T639">PyObject *PyString_AsDecodedString(PyObject *str,
				   const char *encoding,
				   const char *errors)
{
    PyObject *v;

    v = PyString_AsDecodedObject(str, encoding, errors);
    if (v == NULL)
        goto onError;

#ifdef Py_USING_UNICODE
    /* Convert Unicode to a string using the default encoding */
    if (PyUnicode_Check(v)) {
	PyObject *temp = v;
	v = PyUnicode_AsEncodedString(v, NULL, NULL);
	Py_DECREF(temp);
	if (v == NULL)
	    goto onError;
    }
#endif
    if (!PyString_Check(v)) {
        PyErr_Format(PyExc_TypeError,
                     "decoder did not return a string object (type=%.400s)",
                     v-&gt;ob_type-&gt;tp_name);
        Py_DECREF(v);
        goto onError;
    }

    return v;

 onError:
    return NULL;
}
</t>
<t tx="T640">PyObject *PyString_Encode(const char *s,
			  int size,
			  const char *encoding,
			  const char *errors)
{
    PyObject *v, *str;

    str = PyString_FromStringAndSize(s, size);
    if (str == NULL)
	return NULL;
    v = PyString_AsEncodedString(str, encoding, errors);
    Py_DECREF(str);
    return v;
}
</t>
<t tx="T641">PyObject *PyString_AsEncodedObject(PyObject *str,
				   const char *encoding,
				   const char *errors)
{
    PyObject *v;

    if (!PyString_Check(str)) {
        PyErr_BadArgument();
        goto onError;
    }

    if (encoding == NULL) {
#ifdef Py_USING_UNICODE
	encoding = PyUnicode_GetDefaultEncoding();
#else
	PyErr_SetString(PyExc_ValueError, "no encoding specified");
	goto onError;
#endif
    }

    /* Encode via the codec registry */
    v = PyCodec_Encode(str, encoding, errors);
    if (v == NULL)
        goto onError;

    return v;

 onError:
    return NULL;
}
</t>
<t tx="T642">PyObject *PyString_AsEncodedString(PyObject *str,
				   const char *encoding,
				   const char *errors)
{
    PyObject *v;

    v = PyString_AsEncodedObject(str, encoding, errors);
    if (v == NULL)
        goto onError;

#ifdef Py_USING_UNICODE
    /* Convert Unicode to a string using the default encoding */
    if (PyUnicode_Check(v)) {
	PyObject *temp = v;
	v = PyUnicode_AsEncodedString(v, NULL, NULL);
	Py_DECREF(temp);
	if (v == NULL)
	    goto onError;
    }
#endif
    if (!PyString_Check(v)) {
        PyErr_Format(PyExc_TypeError,
                     "encoder did not return a string object (type=%.400s)",
                     v-&gt;ob_type-&gt;tp_name);
        Py_DECREF(v);
        goto onError;
    }

    return v;

 onError:
    return NULL;
}
</t>
<t tx="T643">static void
string_dealloc(PyObject *op)
{
	op-&gt;ob_type-&gt;tp_free(op);
}
</t>
<t tx="T644">static int
string_getsize(register PyObject *op)
{
    	char *s;
    	int len;
	if (PyString_AsStringAndSize(op, &amp;s, &amp;len))
		return -1;
	return len;
}
</t>
<t tx="T645">static /*const*/ char *
string_getbuffer(register PyObject *op)
{
    	char *s;
    	int len;
	if (PyString_AsStringAndSize(op, &amp;s, &amp;len))
		return NULL;
	return s;
}
</t>
<t tx="T646">int
PyString_Size(register PyObject *op)
{
	if (!PyString_Check(op))
		return string_getsize(op);
	return ((PyStringObject *)op) -&gt; ob_size;
}
</t>
<t tx="T647">@ const
@c

char *
PyString_AsString(register PyObject *op)
{
	if (!PyString_Check(op))
		return string_getbuffer(op);
	return ((PyStringObject *)op) -&gt; ob_sval;
}
</t>
<t tx="T648">int
PyString_AsStringAndSize(register PyObject *obj,
			 register char **s,
			 register int *len)
{
	if (s == NULL) {
		PyErr_BadInternalCall();
		return -1;
	}

	if (!PyString_Check(obj)) {
#ifdef Py_USING_UNICODE
		if (PyUnicode_Check(obj)) {
			obj = _PyUnicode_AsDefaultEncodedString(obj, NULL);
			if (obj == NULL)
				return -1;
		}
		else 
#endif
		{
			PyErr_Format(PyExc_TypeError,
				     "expected string or Unicode object, "
				     "%.200s found", obj-&gt;ob_type-&gt;tp_name);
			return -1;
		}
	}

	*s = PyString_AS_STRING(obj);
	if (len != NULL)
		*len = PyString_GET_SIZE(obj);
	else if ((int)strlen(*s) != PyString_GET_SIZE(obj)) {
		PyErr_SetString(PyExc_TypeError,
				"expected string without null bytes");
		return -1;
	}
	return 0;
}
</t>
<t tx="T649">@ Methods
@c

static int
string_print(PyStringObject *op, FILE *fp, int flags)
{
	int i;
	char c;
	int quote;

	/* XXX Ought to check for interrupts when writing long strings */
	if (! PyString_CheckExact(op)) {
		int ret;
		/* A str subclass may have its own __str__ method. */
		op = (PyStringObject *) PyObject_Str((PyObject *)op);
		if (op == NULL)
			return -1;
		ret = string_print(op, fp, flags);
		Py_DECREF(op);
		return ret;
	}
	if (flags &amp; Py_PRINT_RAW) {
		fwrite(op-&gt;ob_sval, 1, (int) op-&gt;ob_size, fp);
		return 0;
	}

	/* figure out which quote to use; single is preferred */
	quote = '\'';
	if (strchr(op-&gt;ob_sval, '\'') &amp;&amp; !strchr(op-&gt;ob_sval, '"'))
		quote = '"';

	fputc(quote, fp);
	for (i = 0; i &lt; op-&gt;ob_size; i++) {
		c = op-&gt;ob_sval[i];
		if (c == quote || c == '\\')
			fprintf(fp, "\\%c", c);
                else if (c == '\t')
                        fprintf(fp, "\\t");
                else if (c == '\n')
                        fprintf(fp, "\\n");
                else if (c == '\r')
                        fprintf(fp, "\\r");
		else if (c &lt; ' ' || c &gt;= 0x7f)
			fprintf(fp, "\\x%02x", c &amp; 0xff);
		else
			fputc(c, fp);
	}
	fputc(quote, fp);
	return 0;
}
</t>
<t tx="T650">static PyObject *
string_repr(register PyStringObject *op)
{
	size_t newsize = 2 + 4 * op-&gt;ob_size * sizeof(char);
	PyObject *v;
	if (newsize &gt; INT_MAX) {
		PyErr_SetString(PyExc_OverflowError,
			"string is too large to make repr");
	}
	v = PyString_FromStringAndSize((char *)NULL, newsize);
	if (v == NULL) {
		return NULL;
	}
	else {
		register int i;
		register char c;
		register char *p;
		int quote;

		/* figure out which quote to use; single is preferred */
		quote = '\'';
		if (strchr(op-&gt;ob_sval, '\'') &amp;&amp; !strchr(op-&gt;ob_sval, '"'))
			quote = '"';

		p = PyString_AS_STRING(v);
		*p++ = quote;
		for (i = 0; i &lt; op-&gt;ob_size; i++) {
			/* There's at least enough room for a hex escape
			   and a closing quote. */
			assert(newsize - (p - PyString_AS_STRING(v)) &gt;= 5);
			c = op-&gt;ob_sval[i];
			if (c == quote || c == '\\')
				*p++ = '\\', *p++ = c;
			else if (c == '\t')
				*p++ = '\\', *p++ = 't';
			else if (c == '\n')
				*p++ = '\\', *p++ = 'n';
			else if (c == '\r')
				*p++ = '\\', *p++ = 'r';
			else if (c &lt; ' ' || c &gt;= 0x7f) {
				/* For performance, we don't want to call
				   PyOS_snprintf here (extra layers of
				   function call). */
				sprintf(p, "\\x%02x", c &amp; 0xff);
                                p += 4;
			}
			else
				*p++ = c;
		}
		assert(newsize - (p - PyString_AS_STRING(v)) &gt;= 1);
		*p++ = quote;
		*p = '\0';
		_PyString_Resize(
			&amp;v, (int) (p - PyString_AS_STRING(v)));
		return v;
	}
}
</t>
<t tx="T651">static PyObject *
string_str(PyObject *s)
{
	assert(PyString_Check(s));
	if (PyString_CheckExact(s)) {
		Py_INCREF(s);
		return s;
	}
	else {
		/* Subtype -- return genuine string with the same value. */
		PyStringObject *t = (PyStringObject *) s;
		return PyString_FromStringAndSize(t-&gt;ob_sval, t-&gt;ob_size);
	}
}
</t>
<t tx="T652">static int
string_length(PyStringObject *a)
{
	return a-&gt;ob_size;
}
</t>
<t tx="T653">static PyObject *
string_concat(register PyStringObject *a, register PyObject *bb)
{
	register unsigned int size;
	register PyStringObject *op;
	if (!PyString_Check(bb)) {
#ifdef Py_USING_UNICODE
		if (PyUnicode_Check(bb))
		    return PyUnicode_Concat((PyObject *)a, bb);
#endif
		PyErr_Format(PyExc_TypeError,
			     "cannot concatenate 'str' and '%.200s' objects",
			     bb-&gt;ob_type-&gt;tp_name);
		return NULL;
	}
#define b ((PyStringObject *)bb)
	/* Optimize cases with empty left or right operand */
	if ((a-&gt;ob_size == 0 || b-&gt;ob_size == 0) &amp;&amp;
	    PyString_CheckExact(a) &amp;&amp; PyString_CheckExact(b)) {
		if (a-&gt;ob_size == 0) {
			Py_INCREF(bb);
			return bb;
		}
		Py_INCREF(a);
		return (PyObject *)a;
	}
	size = a-&gt;ob_size + b-&gt;ob_size;
	/* PyObject_NewVar is inlined */
	op = (PyStringObject *)
		PyObject_MALLOC(sizeof(PyStringObject) + size * sizeof(char));
	if (op == NULL)
		return PyErr_NoMemory();
	PyObject_INIT_VAR(op, &amp;PyString_Type, size);
#ifdef CACHE_HASH
	op-&gt;ob_shash = -1;
#endif
#ifdef INTERN_STRINGS
	op-&gt;ob_sinterned = NULL;
#endif
	memcpy(op-&gt;ob_sval, a-&gt;ob_sval, (int) a-&gt;ob_size);
	memcpy(op-&gt;ob_sval + a-&gt;ob_size, b-&gt;ob_sval, (int) b-&gt;ob_size);
	op-&gt;ob_sval[size] = '\0';
	return (PyObject *) op;
#undef b
}
</t>
<t tx="T654">static PyObject *
string_repeat(register PyStringObject *a, register int n)
{
	register int i;
	register int size;
	register PyStringObject *op;
	size_t nbytes;
	if (n &lt; 0)
		n = 0;
	/* watch out for overflows:  the size can overflow int,
	 * and the # of bytes needed can overflow size_t
	 */
	size = a-&gt;ob_size * n;
	if (n &amp;&amp; size / n != a-&gt;ob_size) {
		PyErr_SetString(PyExc_OverflowError,
			"repeated string is too long");
		return NULL;
	}
	if (size == a-&gt;ob_size &amp;&amp; PyString_CheckExact(a)) {
		Py_INCREF(a);
		return (PyObject *)a;
	}
	nbytes = size * sizeof(char);
	if (nbytes / sizeof(char) != (size_t)size ||
	    nbytes + sizeof(PyStringObject) &lt;= nbytes) {
		PyErr_SetString(PyExc_OverflowError,
			"repeated string is too long");
		return NULL;
	}
	op = (PyStringObject *)
		PyObject_MALLOC(sizeof(PyStringObject) + nbytes);
	if (op == NULL)
		return PyErr_NoMemory();
	PyObject_INIT_VAR(op, &amp;PyString_Type, size);
#ifdef CACHE_HASH
	op-&gt;ob_shash = -1;
#endif
#ifdef INTERN_STRINGS
	op-&gt;ob_sinterned = NULL;
#endif
	for (i = 0; i &lt; size; i += a-&gt;ob_size)
		memcpy(op-&gt;ob_sval+i, a-&gt;ob_sval, (int) a-&gt;ob_size);
	op-&gt;ob_sval[size] = '\0';
	return (PyObject *) op;
}
</t>
<t tx="T655">@ String slice a[i:j] consists of characters a[i] ... a[j-1]
@c

static PyObject *
string_slice(register PyStringObject *a, register int i, register int j)
     /* j -- may be negative! */
{
	if (i &lt; 0)
		i = 0;
	if (j &lt; 0)
		j = 0; /* Avoid signed/unsigned bug in next line */
	if (j &gt; a-&gt;ob_size)
		j = a-&gt;ob_size;
	if (i == 0 &amp;&amp; j == a-&gt;ob_size &amp;&amp; PyString_CheckExact(a)) {
		/* It's the same as a */
		Py_INCREF(a);
		return (PyObject *)a;
	}
	if (j &lt; i)
		j = i;
	return PyString_FromStringAndSize(a-&gt;ob_sval + i, (int) (j-i));
}
</t>
<t tx="T656">static int
string_contains(PyObject *a, PyObject *el)
{
	register char *s, *end;
	register char c;
#ifdef Py_USING_UNICODE
	if (PyUnicode_Check(el))
		return PyUnicode_Contains(a, el);
#endif
	if (!PyString_Check(el) || PyString_Size(el) != 1) {
		PyErr_SetString(PyExc_TypeError,
		    "'in &lt;string&gt;' requires character as left operand");
		return -1;
	}
	c = PyString_AsString(el)[0];
	s = PyString_AsString(a);
	end = s + PyString_Size(a);
	while (s &lt; end) {
		if (c == *s++)
			return 1;
	}
	return 0;
}
</t>
<t tx="T657">static PyObject *
string_item(PyStringObject *a, register int i)
{
	PyObject *v;
	char *pchar;
	if (i &lt; 0 || i &gt;= a-&gt;ob_size) {
		PyErr_SetString(PyExc_IndexError, "string index out of range");
		return NULL;
	}
	pchar = a-&gt;ob_sval + i;
	v = (PyObject *)characters[*pchar &amp; UCHAR_MAX];
	if (v == NULL)
		v = PyString_FromStringAndSize(pchar, 1);
	else {
#ifdef COUNT_ALLOCS
		one_strings++;
#endif
		Py_INCREF(v);
	}
	return v;
}
</t>
<t tx="T658">static PyObject*
string_richcompare(PyStringObject *a, PyStringObject *b, int op)
{
	int c;
	int len_a, len_b;
	int min_len;
	PyObject *result;

	/* Make sure both arguments are strings. */
	if (!(PyString_Check(a) &amp;&amp; PyString_Check(b))) {
		result = Py_NotImplemented;
		goto out;
	}
	if (a == b) {
		switch (op) {
		case Py_EQ:case Py_LE:case Py_GE:
			result = Py_True;
			goto out;
		case Py_NE:case Py_LT:case Py_GT:
			result = Py_False;
			goto out;
		}
	}
	if (op == Py_EQ) {
		/* Supporting Py_NE here as well does not save
		   much time, since Py_NE is rarely used.  */
		if (a-&gt;ob_size == b-&gt;ob_size
		    &amp;&amp; (a-&gt;ob_sval[0] == b-&gt;ob_sval[0]
			&amp;&amp; memcmp(a-&gt;ob_sval, b-&gt;ob_sval, 
				  a-&gt;ob_size) == 0)) {
			result = Py_True;
		} else {
			result = Py_False;
		}
		goto out;
	}
	len_a = a-&gt;ob_size; len_b = b-&gt;ob_size;
	min_len = (len_a &lt; len_b) ? len_a : len_b;
	if (min_len &gt; 0) {
		c = Py_CHARMASK(*a-&gt;ob_sval) - Py_CHARMASK(*b-&gt;ob_sval);
		if (c==0)
			c = memcmp(a-&gt;ob_sval, b-&gt;ob_sval, min_len);
	}else
		c = 0;
	if (c == 0)
		c = (len_a &lt; len_b) ? -1 : (len_a &gt; len_b) ? 1 : 0;
	switch (op) {
	case Py_LT: c = c &lt;  0; break;
	case Py_LE: c = c &lt;= 0; break;
	case Py_EQ: assert(0);  break; /* unreachable */
	case Py_NE: c = c != 0; break;
	case Py_GT: c = c &gt;  0; break;
	case Py_GE: c = c &gt;= 0; break;
	default:
		result = Py_NotImplemented;
		goto out;
	}
	result = c ? Py_True : Py_False;
  out:
	Py_INCREF(result);
	return result;
}
</t>
<t tx="T659">int
_PyString_Eq(PyObject *o1, PyObject *o2)
{
	PyStringObject *a, *b;
	a = (PyStringObject*)o1;
	b = (PyStringObject*)o2;
        return a-&gt;ob_size == b-&gt;ob_size
          &amp;&amp; *a-&gt;ob_sval == *b-&gt;ob_sval
          &amp;&amp; memcmp(a-&gt;ob_sval, b-&gt;ob_sval, a-&gt;ob_size) == 0;
}
</t>
<t tx="T660">static long
string_hash(PyStringObject *a)
{
	register int len;
	register unsigned char *p;
	register long x;

#ifdef CACHE_HASH
	if (a-&gt;ob_shash != -1)
		return a-&gt;ob_shash;
#ifdef INTERN_STRINGS
	if (a-&gt;ob_sinterned != NULL)
		return (a-&gt;ob_shash =
			((PyStringObject *)(a-&gt;ob_sinterned))-&gt;ob_shash);
#endif
#endif
	len = a-&gt;ob_size;
	p = (unsigned char *) a-&gt;ob_sval;
	x = *p &lt;&lt; 7;
	while (--len &gt;= 0)
		x = (1000003*x) ^ *p++;
	x ^= a-&gt;ob_size;
	if (x == -1)
		x = -2;
#ifdef CACHE_HASH
	a-&gt;ob_shash = x;
#endif
	return x;
}
</t>
<t tx="T661">static int
string_buffer_getreadbuf(PyStringObject *self, int index, const void **ptr)
{
	if ( index != 0 ) {
		PyErr_SetString(PyExc_SystemError,
				"accessing non-existent string segment");
		return -1;
	}
	*ptr = (void *)self-&gt;ob_sval;
	return self-&gt;ob_size;
}
</t>
<t tx="T662">static int
string_buffer_getwritebuf(PyStringObject *self, int index, const void **ptr)
{
	PyErr_SetString(PyExc_TypeError,
			"Cannot use string as modifiable buffer");
	return -1;
}
</t>
<t tx="T663">static int
string_buffer_getsegcount(PyStringObject *self, int *lenp)
{
	if ( lenp )
		*lenp = self-&gt;ob_size;
	return 1;
}
</t>
<t tx="T664">static int
string_buffer_getcharbuf(PyStringObject *self, int index, const char **ptr)
{
	if ( index != 0 ) {
		PyErr_SetString(PyExc_SystemError,
				"accessing non-existent string segment");
		return -1;
	}
	*ptr = self-&gt;ob_sval;
	return self-&gt;ob_size;
}
</t>
<t tx="T665">static PySequenceMethods string_as_sequence = {
	(inquiry)string_length, /*sq_length*/
	(binaryfunc)string_concat, /*sq_concat*/
	(intargfunc)string_repeat, /*sq_repeat*/
	(intargfunc)string_item, /*sq_item*/
	(intintargfunc)string_slice, /*sq_slice*/
	0,		/*sq_ass_item*/
	0,		/*sq_ass_slice*/
	(objobjproc)string_contains /*sq_contains*/
};

static PyBufferProcs string_as_buffer = {
	(getreadbufferproc)string_buffer_getreadbuf,
	(getwritebufferproc)string_buffer_getwritebuf,
	(getsegcountproc)string_buffer_getsegcount,
	(getcharbufferproc)string_buffer_getcharbuf,
};



#define LEFTSTRIP 0
#define RIGHTSTRIP 1
#define BOTHSTRIP 2


static PyObject *
split_whitespace(const char *s, int len, int maxsplit)
{
	int i, j, err;
	PyObject* item;
	PyObject *list = PyList_New(0);

	if (list == NULL)
		return NULL;

	for (i = j = 0; i &lt; len; ) {
		while (i &lt; len &amp;&amp; isspace(Py_CHARMASK(s[i])))
			i++;
		j = i;
		while (i &lt; len &amp;&amp; !isspace(Py_CHARMASK(s[i])))
			i++;
		if (j &lt; i) {
			if (maxsplit-- &lt;= 0)
				break;
			item = PyString_FromStringAndSize(s+j, (int)(i-j));
			if (item == NULL)
				goto finally;
			err = PyList_Append(list, item);
			Py_DECREF(item);
			if (err &lt; 0)
				goto finally;
			while (i &lt; len &amp;&amp; isspace(Py_CHARMASK(s[i])))
				i++;
			j = i;
		}
	}
	if (j &lt; len) {
		item = PyString_FromStringAndSize(s+j, (int)(len - j));
		if (item == NULL)
			goto finally;
		err = PyList_Append(list, item);
		Py_DECREF(item);
		if (err &lt; 0)
			goto finally;
	}
	return list;
  finally:
	Py_DECREF(list);
	return NULL;
}
</t>
<t tx="T666">static char split__doc__[] =
"S.split([sep [,maxsplit]]) -&gt; list of strings\n\
\n\
Return a list of the words in the string S, using sep as the\n\
delimiter string.  If maxsplit is given, at most maxsplit\n\
splits are done. If sep is not specified, any whitespace string\n\
is a separator.";

static PyObject *
string_split(PyStringObject *self, PyObject *args)
{
	int len = PyString_GET_SIZE(self), n, i, j, err;
	int maxsplit = -1;
	const char *s = PyString_AS_STRING(self), *sub;
	PyObject *list, *item, *subobj = Py_None;

	if (!PyArg_ParseTuple(args, "|Oi:split", &amp;subobj, &amp;maxsplit))
		return NULL;
	if (maxsplit &lt; 0)
		maxsplit = INT_MAX;
	if (subobj == Py_None)
		return split_whitespace(s, len, maxsplit);
	if (PyString_Check(subobj)) {
		sub = PyString_AS_STRING(subobj);
		n = PyString_GET_SIZE(subobj);
	}
#ifdef Py_USING_UNICODE
	else if (PyUnicode_Check(subobj))
		return PyUnicode_Split((PyObject *)self, subobj, maxsplit);
#endif
	else if (PyObject_AsCharBuffer(subobj, &amp;sub, &amp;n))
		return NULL;
	if (n == 0) {
		PyErr_SetString(PyExc_ValueError, "empty separator");
		return NULL;
	}

	list = PyList_New(0);
	if (list == NULL)
		return NULL;

	i = j = 0;
	while (i+n &lt;= len) {
		if (s[i] == sub[0] &amp;&amp; memcmp(s+i, sub, n) == 0) {
			if (maxsplit-- &lt;= 0)
				break;
			item = PyString_FromStringAndSize(s+j, (int)(i-j));
			if (item == NULL)
				goto fail;
			err = PyList_Append(list, item);
			Py_DECREF(item);
			if (err &lt; 0)
				goto fail;
			i = j = i + n;
		}
		else
			i++;
	}
	item = PyString_FromStringAndSize(s+j, (int)(len-j));
	if (item == NULL)
		goto fail;
	err = PyList_Append(list, item);
	Py_DECREF(item);
	if (err &lt; 0)
		goto fail;

	return list;

 fail:
	Py_DECREF(list);
	return NULL;
}
</t>
<t tx="T667">static char join__doc__[] =
"S.join(sequence) -&gt; string\n\
\n\
Return a string which is the concatenation of the strings in the\n\
sequence.  The separator between elements is S.";

static PyObject *
string_join(PyStringObject *self, PyObject *orig)
{
	char *sep = PyString_AS_STRING(self);
	const int seplen = PyString_GET_SIZE(self);
	PyObject *res = NULL;
	char *p;
	int seqlen = 0;
	size_t sz = 0;
	int i;
	PyObject *seq, *item;

	seq = PySequence_Fast(orig, "");
	if (seq == NULL) {
		if (PyErr_ExceptionMatches(PyExc_TypeError))
			PyErr_Format(PyExc_TypeError,
				     "sequence expected, %.80s found",
				     orig-&gt;ob_type-&gt;tp_name);
		return NULL;
	}

	seqlen = PySequence_Size(seq);
	if (seqlen == 0) {
		Py_DECREF(seq);
		return PyString_FromString("");
	}
	if (seqlen == 1) {
		item = PySequence_Fast_GET_ITEM(seq, 0);
		if (!PyString_Check(item) &amp;&amp; !PyUnicode_Check(item)) {
			PyErr_Format(PyExc_TypeError,
				     "sequence item 0: expected string,"
				     " %.80s found",
				     item-&gt;ob_type-&gt;tp_name);
			Py_DECREF(seq);
			return NULL;
		}
		Py_INCREF(item);
		Py_DECREF(seq);
		return item;
	}

	/* There are at least two things to join.  Do a pre-pass to figure out
	 * the total amount of space we'll need (sz), see whether any argument
	 * is absurd, and defer to the Unicode join if appropriate.
	 */
	for (i = 0; i &lt; seqlen; i++) {
		const size_t old_sz = sz;
		item = PySequence_Fast_GET_ITEM(seq, i);
		if (!PyString_Check(item)){
#ifdef Py_USING_UNICODE
			if (PyUnicode_Check(item)) {
				/* Defer to Unicode join.
				 * CAUTION:  There's no gurantee that the
				 * original sequence can be iterated over
				 * again, so we must pass seq here.
				 */
				PyObject *result;
				result = PyUnicode_Join((PyObject *)self, seq);
				Py_DECREF(seq);
				return result;
			}
#endif
			PyErr_Format(PyExc_TypeError,
				     "sequence item %i: expected string,"
				     " %.80s found",
				     i, item-&gt;ob_type-&gt;tp_name);
			Py_DECREF(seq);
			return NULL;
		}
		sz += PyString_GET_SIZE(item);
		if (i != 0)
			sz += seplen;
		if (sz &lt; old_sz || sz &gt; INT_MAX) {
			PyErr_SetString(PyExc_OverflowError,
				"join() is too long for a Python string");
			Py_DECREF(seq);
			return NULL;
		}
	}

	/* Allocate result space. */
	res = PyString_FromStringAndSize((char*)NULL, (int)sz);
	if (res == NULL) {
		Py_DECREF(seq);
		return NULL;
	}

	/* Catenate everything. */
	p = PyString_AS_STRING(res);
	for (i = 0; i &lt; seqlen; ++i) {
		size_t n;
		item = PySequence_Fast_GET_ITEM(seq, i);
		n = PyString_GET_SIZE(item);
		memcpy(p, PyString_AS_STRING(item), n);
		p += n;
		if (i &lt; seqlen - 1) {
			memcpy(p, sep, seplen);
			p += seplen;
		}
	}

	Py_DECREF(seq);
	return res;
}
</t>
<t tx="T668">PyObject *
_PyString_Join(PyObject *sep, PyObject *x)
{
	assert(sep != NULL &amp;&amp; PyString_Check(sep));
	assert(x != NULL);
	return string_join((PyStringObject *)sep, x);
}
</t>
<t tx="T669">static long
string_find_internal(PyStringObject *self, PyObject *args, int dir)
{
	const char *s = PyString_AS_STRING(self), *sub;
	int len = PyString_GET_SIZE(self);
	int n, i = 0, last = INT_MAX;
	PyObject *subobj;

	if (!PyArg_ParseTuple(args, "O|O&amp;O&amp;:find/rfind/index/rindex",
		&amp;subobj, _PyEval_SliceIndex, &amp;i, _PyEval_SliceIndex, &amp;last))
		return -2;
	if (PyString_Check(subobj)) {
		sub = PyString_AS_STRING(subobj);
		n = PyString_GET_SIZE(subobj);
	}
#ifdef Py_USING_UNICODE
	else if (PyUnicode_Check(subobj))
		return PyUnicode_Find((PyObject *)self, subobj, i, last, 1);
#endif
	else if (PyObject_AsCharBuffer(subobj, &amp;sub, &amp;n))
		return -2;

	if (last &gt; len)
		last = len;
	if (last &lt; 0)
		last += len;
	if (last &lt; 0)
		last = 0;
	if (i &lt; 0)
		i += len;
	if (i &lt; 0)
		i = 0;

	if (dir &gt; 0) {
		if (n == 0 &amp;&amp; i &lt;= last)
			return (long)i;
		last -= n;
		for (; i &lt;= last; ++i)
			if (s[i] == sub[0] &amp;&amp; memcmp(&amp;s[i], sub, n) == 0)
				return (long)i;
	}
	else {
		int j;

        	if (n == 0 &amp;&amp; i &lt;= last)
			return (long)last;
		for (j = last-n; j &gt;= i; --j)
			if (s[j] == sub[0] &amp;&amp; memcmp(&amp;s[j], sub, n) == 0)
				return (long)j;
	}

	return -1;
}
</t>
<t tx="T670">static char find__doc__[] =
"S.find(sub [,start [,end]]) -&gt; int\n\
\n\
Return the lowest index in S where substring sub is found,\n\
such that sub is contained within s[start,end].  Optional\n\
arguments start and end are interpreted as in slice notation.\n\
\n\
Return -1 on failure.";

static PyObject *
string_find(PyStringObject *self, PyObject *args)
{
	long result = string_find_internal(self, args, +1);
	if (result == -2)
		return NULL;
	return PyInt_FromLong(result);
}
</t>
<t tx="T671">static char index__doc__[] =
"S.index(sub [,start [,end]]) -&gt; int\n\
\n\
Like S.find() but raise ValueError when the substring is not found.";

static PyObject *
string_index(PyStringObject *self, PyObject *args)
{
	long result = string_find_internal(self, args, +1);
	if (result == -2)
		return NULL;
	if (result == -1) {
		PyErr_SetString(PyExc_ValueError,
				"substring not found in string.index");
		return NULL;
	}
	return PyInt_FromLong(result);
}
</t>
<t tx="T672">static char rfind__doc__[] =
"S.rfind(sub [,start [,end]]) -&gt; int\n\
\n\
Return the highest index in S where substring sub is found,\n\
such that sub is contained within s[start,end].  Optional\n\
arguments start and end are interpreted as in slice notation.\n\
\n\
Return -1 on failure.";

static PyObject *
string_rfind(PyStringObject *self, PyObject *args)
{
	long result = string_find_internal(self, args, -1);
	if (result == -2)
		return NULL;
	return PyInt_FromLong(result);
}
</t>
<t tx="T673">static char rindex__doc__[] =
"S.rindex(sub [,start [,end]]) -&gt; int\n\
\n\
Like S.rfind() but raise ValueError when the substring is not found.";

static PyObject *
string_rindex(PyStringObject *self, PyObject *args)
{
	long result = string_find_internal(self, args, -1);
	if (result == -2)
		return NULL;
	if (result == -1) {
		PyErr_SetString(PyExc_ValueError,
				"substring not found in string.rindex");
		return NULL;
	}
	return PyInt_FromLong(result);
}
</t>
<t tx="T674">static PyObject *
do_strip(PyStringObject *self, int striptype)
{
	char *s = PyString_AS_STRING(self);
	int len = PyString_GET_SIZE(self), i, j;

	i = 0;
	if (striptype != RIGHTSTRIP) {
		while (i &lt; len &amp;&amp; isspace(Py_CHARMASK(s[i]))) {
			i++;
		}
	}

	j = len;
	if (striptype != LEFTSTRIP) {
		do {
			j--;
		} while (j &gt;= i &amp;&amp; isspace(Py_CHARMASK(s[j])));
		j++;
	}

	if (i == 0 &amp;&amp; j == len &amp;&amp; PyString_CheckExact(self)) {
		Py_INCREF(self);
		return (PyObject*)self;
	}
	else
		return PyString_FromStringAndSize(s+i, j-i);
}
</t>
<t tx="T675">static char strip__doc__[] =
"S.strip() -&gt; string\n\
\n\
Return a copy of the string S with leading and trailing\n\
whitespace removed.";

static PyObject *
string_strip(PyStringObject *self)
{
	return do_strip(self, BOTHSTRIP);
}
</t>
<t tx="T676">static char lstrip__doc__[] =
"S.lstrip() -&gt; string\n\
\n\
Return a copy of the string S with leading whitespace removed.";

static PyObject *
string_lstrip(PyStringObject *self)
{
	return do_strip(self, LEFTSTRIP);
}
</t>
<t tx="T677">static char rstrip__doc__[] =
"S.rstrip() -&gt; string\n\
\n\
Return a copy of the string S with trailing whitespace removed.";

static PyObject *
string_rstrip(PyStringObject *self)
{
	return do_strip(self, RIGHTSTRIP);
}
</t>
<t tx="T678">static char lower__doc__[] =
"S.lower() -&gt; string\n\
\n\
Return a copy of the string S converted to lowercase.";

static PyObject *
string_lower(PyStringObject *self)
{
	char *s = PyString_AS_STRING(self), *s_new;
	int i, n = PyString_GET_SIZE(self);
	PyObject *new;

	new = PyString_FromStringAndSize(NULL, n);
	if (new == NULL)
		return NULL;
	s_new = PyString_AsString(new);
	for (i = 0; i &lt; n; i++) {
		int c = Py_CHARMASK(*s++);
		if (isupper(c)) {
			*s_new = tolower(c);
		} else
			*s_new = c;
		s_new++;
	}
	return new;
}
</t>
<t tx="T679">static char upper__doc__[] =
"S.upper() -&gt; string\n\
\n\
Return a copy of the string S converted to uppercase.";

static PyObject *
string_upper(PyStringObject *self)
{
	char *s = PyString_AS_STRING(self), *s_new;
	int i, n = PyString_GET_SIZE(self);
	PyObject *new;

	new = PyString_FromStringAndSize(NULL, n);
	if (new == NULL)
		return NULL;
	s_new = PyString_AsString(new);
	for (i = 0; i &lt; n; i++) {
		int c = Py_CHARMASK(*s++);
		if (islower(c)) {
			*s_new = toupper(c);
		} else
			*s_new = c;
		s_new++;
	}
	return new;
}
</t>
<t tx="T680">static char title__doc__[] =
"S.title() -&gt; string\n\
\n\
Return a titlecased version of S, i.e. words start with uppercase\n\
characters, all remaining cased characters have lowercase.";

static PyObject*
string_title(PyStringObject *self)
{
	char *s = PyString_AS_STRING(self), *s_new;
	int i, n = PyString_GET_SIZE(self);
	int previous_is_cased = 0;
	PyObject *new;

	new = PyString_FromStringAndSize(NULL, n);
	if (new == NULL)
		return NULL;
	s_new = PyString_AsString(new);
	for (i = 0; i &lt; n; i++) {
		int c = Py_CHARMASK(*s++);
		if (islower(c)) {
			if (!previous_is_cased)
			    c = toupper(c);
			previous_is_cased = 1;
		} else if (isupper(c)) {
			if (previous_is_cased)
			    c = tolower(c);
			previous_is_cased = 1;
		} else
			previous_is_cased = 0;
		*s_new++ = c;
	}
	return new;
}
</t>
<t tx="T681">static char capitalize__doc__[] =
"S.capitalize() -&gt; string\n\
\n\
Return a copy of the string S with only its first character\n\
capitalized.";

static PyObject *
string_capitalize(PyStringObject *self)
{
	char *s = PyString_AS_STRING(self), *s_new;
	int i, n = PyString_GET_SIZE(self);
	PyObject *new;

	new = PyString_FromStringAndSize(NULL, n);
	if (new == NULL)
		return NULL;
	s_new = PyString_AsString(new);
	if (0 &lt; n) {
		int c = Py_CHARMASK(*s++);
		if (islower(c))
			*s_new = toupper(c);
		else
			*s_new = c;
		s_new++;
	}
	for (i = 1; i &lt; n; i++) {
		int c = Py_CHARMASK(*s++);
		if (isupper(c))
			*s_new = tolower(c);
		else
			*s_new = c;
		s_new++;
	}
	return new;
}
</t>
<t tx="T682">static char count__doc__[] =
"S.count(sub[, start[, end]]) -&gt; int\n\
\n\
Return the number of occurrences of substring sub in string\n\
S[start:end].  Optional arguments start and end are\n\
interpreted as in slice notation.";

static PyObject *
string_count(PyStringObject *self, PyObject *args)
{
	const char *s = PyString_AS_STRING(self), *sub;
	int len = PyString_GET_SIZE(self), n;
	int i = 0, last = INT_MAX;
	int m, r;
	PyObject *subobj;

	if (!PyArg_ParseTuple(args, "O|O&amp;O&amp;:count", &amp;subobj,
		_PyEval_SliceIndex, &amp;i, _PyEval_SliceIndex, &amp;last))
		return NULL;

	if (PyString_Check(subobj)) {
		sub = PyString_AS_STRING(subobj);
		n = PyString_GET_SIZE(subobj);
	}
#ifdef Py_USING_UNICODE
	else if (PyUnicode_Check(subobj)) {
		int count;
		count = PyUnicode_Count((PyObject *)self, subobj, i, last);
		if (count == -1)
			return NULL;
		else
		    	return PyInt_FromLong((long) count);
	}
#endif
	else if (PyObject_AsCharBuffer(subobj, &amp;sub, &amp;n))
		return NULL;

	if (last &gt; len)
		last = len;
	if (last &lt; 0)
		last += len;
	if (last &lt; 0)
		last = 0;
	if (i &lt; 0)
		i += len;
	if (i &lt; 0)
		i = 0;
	m = last + 1 - n;
	if (n == 0)
		return PyInt_FromLong((long) (m-i));

	r = 0;
	while (i &lt; m) {
		if (!memcmp(s+i, sub, n)) {
			r++;
			i += n;
		} else {
			i++;
		}
	}
	return PyInt_FromLong((long) r);
}
</t>
<t tx="T683">static char swapcase__doc__[] =
"S.swapcase() -&gt; string\n\
\n\
Return a copy of the string S with uppercase characters\n\
converted to lowercase and vice versa.";

static PyObject *
string_swapcase(PyStringObject *self)
{
	char *s = PyString_AS_STRING(self), *s_new;
	int i, n = PyString_GET_SIZE(self);
	PyObject *new;

	new = PyString_FromStringAndSize(NULL, n);
	if (new == NULL)
		return NULL;
	s_new = PyString_AsString(new);
	for (i = 0; i &lt; n; i++) {
		int c = Py_CHARMASK(*s++);
		if (islower(c)) {
			*s_new = toupper(c);
		}
		else if (isupper(c)) {
			*s_new = tolower(c);
		}
		else
			*s_new = c;
		s_new++;
	}
	return new;
}
</t>
<t tx="T684">static char translate__doc__[] =
"S.translate(table [,deletechars]) -&gt; string\n\
\n\
Return a copy of the string S, where all characters occurring\n\
in the optional argument deletechars are removed, and the\n\
remaining characters have been mapped through the given\n\
translation table, which must be a string of length 256.";

static PyObject *
string_translate(PyStringObject *self, PyObject *args)
{
	register char *input, *output;
	register const char *table;
	register int i, c, changed = 0;
	PyObject *input_obj = (PyObject*)self;
	const char *table1, *output_start, *del_table=NULL;
	int inlen, tablen, dellen = 0;
	PyObject *result;
	int trans_table[256];
	PyObject *tableobj, *delobj = NULL;

	if (!PyArg_ParseTuple(args, "O|O:translate",
			      &amp;tableobj, &amp;delobj))
		return NULL;

	if (PyString_Check(tableobj)) {
		table1 = PyString_AS_STRING(tableobj);
		tablen = PyString_GET_SIZE(tableobj);
	}
#ifdef Py_USING_UNICODE
	else if (PyUnicode_Check(tableobj)) {
		/* Unicode .translate() does not support the deletechars
		   parameter; instead a mapping to None will cause characters
		   to be deleted. */
		if (delobj != NULL) {
			PyErr_SetString(PyExc_TypeError,
			"deletions are implemented differently for unicode");
			return NULL;
		}
		return PyUnicode_Translate((PyObject *)self, tableobj, NULL);
	}
#endif
	else if (PyObject_AsCharBuffer(tableobj, &amp;table1, &amp;tablen))
		return NULL;

	if (delobj != NULL) {
		if (PyString_Check(delobj)) {
			del_table = PyString_AS_STRING(delobj);
			dellen = PyString_GET_SIZE(delobj);
		}
#ifdef Py_USING_UNICODE
		else if (PyUnicode_Check(delobj)) {
			PyErr_SetString(PyExc_TypeError,
			"deletions are implemented differently for unicode");
			return NULL;
		}
#endif
		else if (PyObject_AsCharBuffer(delobj, &amp;del_table, &amp;dellen))
			return NULL;

		if (tablen != 256) {
			PyErr_SetString(PyExc_ValueError,
			  "translation table must be 256 characters long");
			return NULL;
		}
	}
	else {
		del_table = NULL;
		dellen = 0;
	}

	table = table1;
	inlen = PyString_Size(input_obj);
	result = PyString_FromStringAndSize((char *)NULL, inlen);
	if (result == NULL)
		return NULL;
	output_start = output = PyString_AsString(result);
	input = PyString_AsString(input_obj);

	if (dellen == 0) {
		/* If no deletions are required, use faster code */
		for (i = inlen; --i &gt;= 0; ) {
			c = Py_CHARMASK(*input++);
			if (Py_CHARMASK((*output++ = table[c])) != c)
				changed = 1;
		}
		if (changed || !PyString_CheckExact(input_obj))
			return result;
		Py_DECREF(result);
		Py_INCREF(input_obj);
		return input_obj;
	}

	for (i = 0; i &lt; 256; i++)
		trans_table[i] = Py_CHARMASK(table[i]);

	for (i = 0; i &lt; dellen; i++)
		trans_table[(int) Py_CHARMASK(del_table[i])] = -1;

	for (i = inlen; --i &gt;= 0; ) {
		c = Py_CHARMASK(*input++);
		if (trans_table[c] != -1)
			if (Py_CHARMASK(*output++ = (char)trans_table[c]) == c)
				continue;
		changed = 1;
	}
	if (!changed &amp;&amp; PyString_CheckExact(input_obj)) {
		Py_DECREF(result);
		Py_INCREF(input_obj);
		return input_obj;
	}
	/* Fix the size of the resulting string */
	if (inlen &gt; 0 &amp;&amp;_PyString_Resize(&amp;result, output-output_start))
		return NULL;
	return result;
}
</t>
<t tx="T685">@ What follows is used for implementing replace(). Perry Stoll.
mymemfind  strstr replacement for arbitrary blocks of memory.  Locates the first occurrence in the memory pointed to by MEM of the  contents of memory pointed to by PAT. Returns the index into MEM if  found, or -1 if not found. If len of PAT is greater than length of  MEM, the function returns -1.
@c

static int
mymemfind(const char *mem, int len, const char *pat, int pat_len)
{
	register int ii;

	/* pattern can not occur in the last pat_len-1 chars */
	len -= pat_len;

	for (ii = 0; ii &lt;= len; ii++) {
		if (mem[ii] == pat[0] &amp;&amp; memcmp(&amp;mem[ii], pat, pat_len) == 0) {
			return ii;
		}
	}
	return -1;
}
</t>
<t tx="T686">@ mymemcnt   Return the number of distinct times PAT is found in MEM.  meaning mem=1111 and pat==11 returns 2.      mem=11111 and pat==11 also return 2.
@c

static int
mymemcnt(const char *mem, int len, const char *pat, int pat_len)
{
	register int offset = 0;
	int nfound = 0;

	while (len &gt;= 0) {
		offset = mymemfind(mem, len, pat, pat_len);
		if (offset == -1)
			break;
		mem += offset + pat_len;
		len -= offset + pat_len;
		nfound++;
	}
	return nfound;
}
</t>
<t tx="T687">@ mymemreplace
Return a string in which all occurrences of PAT in memory STR are  replaced with SUB.
If length of PAT is less than length of STR or there are no occurrences of PAT in STR,
then the original string is returned.
Otherwise, a new  string is allocated here and returned.

on return, out_len is:
the length of output string, or
-1 if the input string is returned, or
unchanged if an error occurs (no memory).

return value is: the new string allocated locally, or NULL if an error occurred.
@c

static char *
mymemreplace(const char *str, int len,		/* input string */
             const char *pat, int pat_len,	/* pattern string to find */
             const char *sub, int sub_len,	/* substitution string */
             int count,				/* number of replacements */
	     int *out_len)
{
	char *out_s;
	char *new_s;
	int nfound, offset, new_len;

	if (len == 0 || pat_len &gt; len)
		goto return_same;

	/* find length of output string */
	nfound = mymemcnt(str, len, pat, pat_len);
	if (count &lt; 0)
		count = INT_MAX;
	else if (nfound &gt; count)
		nfound = count;
	if (nfound == 0)
		goto return_same;

	new_len = len + nfound*(sub_len - pat_len);
	if (new_len == 0) {
		/* Have to allocate something for the caller to free(). */
		out_s = (char *)PyMem_MALLOC(1);
		if (out_s == NULL)
			return NULL;
		out_s[0] = '\0';
	}
	else {
		assert(new_len &gt; 0);
		new_s = (char *)PyMem_MALLOC(new_len);
		if (new_s == NULL)
			return NULL;
		out_s = new_s;

		for (; count &gt; 0 &amp;&amp; len &gt; 0; --count) {
			/* find index of next instance of pattern */
			offset = mymemfind(str, len, pat, pat_len);
			if (offset == -1)
				break;

			/* copy non matching part of input string */
			memcpy(new_s, str, offset);
			str += offset + pat_len;
			len -= offset + pat_len;

			/* copy substitute into the output string */
			new_s += offset;
			memcpy(new_s, sub, sub_len);
			new_s += sub_len;
		}
		/* copy any remaining values into output string */
		if (len &gt; 0)
			memcpy(new_s, str, len);
	}
	*out_len = new_len;
	return out_s;

  return_same:
	*out_len = -1;
	return (char *)str; /* cast away const */
}
</t>
<t tx="T688">static char replace__doc__[] =
"S.replace (old, new[, maxsplit]) -&gt; string\n\
\n\
Return a copy of string S with all occurrences of substring\n\
old replaced by new.  If the optional argument maxsplit is\n\
given, only the first maxsplit occurrences are replaced.";

static PyObject *
string_replace(PyStringObject *self, PyObject *args)
{
	const char *str = PyString_AS_STRING(self), *sub, *repl;
	char *new_s;
	const int len = PyString_GET_SIZE(self);
	int sub_len, repl_len, out_len;
	int count = -1;
	PyObject *new;
	PyObject *subobj, *replobj;

	if (!PyArg_ParseTuple(args, "OO|i:replace",
			      &amp;subobj, &amp;replobj, &amp;count))
		return NULL;

	if (PyString_Check(subobj)) {
		sub = PyString_AS_STRING(subobj);
		sub_len = PyString_GET_SIZE(subobj);
	}
#ifdef Py_USING_UNICODE
	else if (PyUnicode_Check(subobj))
		return PyUnicode_Replace((PyObject *)self,
					 subobj, replobj, count);
#endif
	else if (PyObject_AsCharBuffer(subobj, &amp;sub, &amp;sub_len))
		return NULL;

	if (PyString_Check(replobj)) {
		repl = PyString_AS_STRING(replobj);
		repl_len = PyString_GET_SIZE(replobj);
	}
#ifdef Py_USING_UNICODE
	else if (PyUnicode_Check(replobj))
		return PyUnicode_Replace((PyObject *)self,
					 subobj, replobj, count);
#endif
	else if (PyObject_AsCharBuffer(replobj, &amp;repl, &amp;repl_len))
		return NULL;

	if (sub_len &lt;= 0) {
		PyErr_SetString(PyExc_ValueError, "empty pattern string");
		return NULL;
	}
	new_s = mymemreplace(str,len,sub,sub_len,repl,repl_len,count,&amp;out_len);
	if (new_s == NULL) {
		PyErr_NoMemory();
		return NULL;
	}
	if (out_len == -1) {
		if (PyString_CheckExact(self)) {
			/* we're returning another reference to self */
			new = (PyObject*)self;
			Py_INCREF(new);
		}
		else {
			new = PyString_FromStringAndSize(str, len);
			if (new == NULL)
				return NULL;
		}
	}
	else {
		new = PyString_FromStringAndSize(new_s, out_len);
		PyMem_FREE(new_s);
	}
	return new;
}
</t>
<t tx="T689">static char startswith__doc__[] =
"S.startswith(prefix[, start[, end]]) -&gt; int\n\
\n\
Return 1 if S starts with the specified prefix, otherwise return 0.  With\n\
optional start, test S beginning at that position.  With optional end, stop\n\
comparing S at that position.";

static PyObject *
string_startswith(PyStringObject *self, PyObject *args)
{
	const char* str = PyString_AS_STRING(self);
	int len = PyString_GET_SIZE(self);
	const char* prefix;
	int plen;
	int start = 0;
	int end = -1;
	PyObject *subobj;

	if (!PyArg_ParseTuple(args, "O|O&amp;O&amp;:startswith", &amp;subobj,
		_PyEval_SliceIndex, &amp;start, _PyEval_SliceIndex, &amp;end))
		return NULL;
	if (PyString_Check(subobj)) {
		prefix = PyString_AS_STRING(subobj);
		plen = PyString_GET_SIZE(subobj);
	}
#ifdef Py_USING_UNICODE
	else if (PyUnicode_Check(subobj)) {
	    	int rc;
		rc = PyUnicode_Tailmatch((PyObject *)self,
					  subobj, start, end, -1);
		if (rc == -1)
			return NULL;
		else
			return PyInt_FromLong((long) rc);
	}
#endif
	else if (PyObject_AsCharBuffer(subobj, &amp;prefix, &amp;plen))
		return NULL;

	/* adopt Java semantics for index out of range.  it is legal for
	 * offset to be == plen, but this only returns true if prefix is
	 * the empty string.
	 */
	if (start &lt; 0 || start+plen &gt; len)
		return PyInt_FromLong(0);

	if (!memcmp(str+start, prefix, plen)) {
		/* did the match end after the specified end? */
		if (end &lt; 0)
			return PyInt_FromLong(1);
		else if (end - start &lt; plen)
			return PyInt_FromLong(0);
		else
			return PyInt_FromLong(1);
	}
	else return PyInt_FromLong(0);
}
</t>
<t tx="T690">static char endswith__doc__[] =
"S.endswith(suffix[, start[, end]]) -&gt; int\n\
\n\
Return 1 if S ends with the specified suffix, otherwise return 0.  With\n\
optional start, test S beginning at that position.  With optional end, stop\n\
comparing S at that position.";

static PyObject *
string_endswith(PyStringObject *self, PyObject *args)
{
	const char* str = PyString_AS_STRING(self);
	int len = PyString_GET_SIZE(self);
	const char* suffix;
	int slen;
	int start = 0;
	int end = -1;
	int lower, upper;
	PyObject *subobj;

	if (!PyArg_ParseTuple(args, "O|O&amp;O&amp;:endswith", &amp;subobj,
		_PyEval_SliceIndex, &amp;start, _PyEval_SliceIndex, &amp;end))
		return NULL;
	if (PyString_Check(subobj)) {
		suffix = PyString_AS_STRING(subobj);
		slen = PyString_GET_SIZE(subobj);
	}
#ifdef Py_USING_UNICODE
	else if (PyUnicode_Check(subobj)) {
	    	int rc;
		rc = PyUnicode_Tailmatch((PyObject *)self,
					  subobj, start, end, +1);
		if (rc == -1)
			return NULL;
		else
			return PyInt_FromLong((long) rc);
	}
#endif
	else if (PyObject_AsCharBuffer(subobj, &amp;suffix, &amp;slen))
		return NULL;

	if (start &lt; 0 || start &gt; len || slen &gt; len)
		return PyInt_FromLong(0);

	upper = (end &gt;= 0 &amp;&amp; end &lt;= len) ? end : len;
	lower = (upper - slen) &gt; start ? (upper - slen) : start;

	if (upper-lower &gt;= slen &amp;&amp; !memcmp(str+lower, suffix, slen))
		return PyInt_FromLong(1);
	else return PyInt_FromLong(0);
}
</t>
<t tx="T691">static char encode__doc__[] =
"S.encode([encoding[,errors]]) -&gt; object\n\
\n\
Encodes S using the codec registered for encoding. encoding defaults\n\
to the default encoding. errors may be given to set a different error\n\
handling scheme. Default is 'strict' meaning that encoding errors raise\n\
a ValueError. Other possible values are 'ignore' and 'replace'.";

static PyObject *
string_encode(PyStringObject *self, PyObject *args)
{
    char *encoding = NULL;
    char *errors = NULL;
    if (!PyArg_ParseTuple(args, "|ss:encode", &amp;encoding, &amp;errors))
        return NULL;
    return PyString_AsEncodedObject((PyObject *)self, encoding, errors);
}
</t>
<t tx="T692">static char decode__doc__[] =
"S.decode([encoding[,errors]]) -&gt; object\n\
\n\
Decodes S using the codec registered for encoding. encoding defaults\n\
to the default encoding. errors may be given to set a different error\n\
handling scheme. Default is 'strict' meaning that encoding errors raise\n\
a ValueError. Other possible values are 'ignore' and 'replace'.";

static PyObject *
string_decode(PyStringObject *self, PyObject *args)
{
    char *encoding = NULL;
    char *errors = NULL;
    if (!PyArg_ParseTuple(args, "|ss:decode", &amp;encoding, &amp;errors))
        return NULL;
    return PyString_AsDecodedObject((PyObject *)self, encoding, errors);
}
</t>
<t tx="T693">static char expandtabs__doc__[] =
"S.expandtabs([tabsize]) -&gt; string\n\
\n\
Return a copy of S where all tab characters are expanded using spaces.\n\
If tabsize is not given, a tab size of 8 characters is assumed.";

static PyObject*
string_expandtabs(PyStringObject *self, PyObject *args)
{
    const char *e, *p;
    char *q;
    int i, j;
    PyObject *u;
    int tabsize = 8;

    if (!PyArg_ParseTuple(args, "|i:expandtabs", &amp;tabsize))
	return NULL;

    /* First pass: determine size of output string */
    i = j = 0;
    e = PyString_AS_STRING(self) + PyString_GET_SIZE(self);
    for (p = PyString_AS_STRING(self); p &lt; e; p++)
        if (*p == '\t') {
	    if (tabsize &gt; 0)
		j += tabsize - (j % tabsize);
	}
        else {
            j++;
            if (*p == '\n' || *p == '\r') {
                i += j;
                j = 0;
            }
        }

    /* Second pass: create output string and fill it */
    u = PyString_FromStringAndSize(NULL, i + j);
    if (!u)
        return NULL;

    j = 0;
    q = PyString_AS_STRING(u);

    for (p = PyString_AS_STRING(self); p &lt; e; p++)
        if (*p == '\t') {
	    if (tabsize &gt; 0) {
		i = tabsize - (j % tabsize);
		j += i;
		while (i--)
		    *q++ = ' ';
	    }
	}
	else {
            j++;
	    *q++ = *p;
            if (*p == '\n' || *p == '\r')
                j = 0;
        }

    return u;
}
</t>
<t tx="T694">static PyObject *
pad(PyStringObject *self, int left, int right, char fill)
{
    PyObject *u;

    if (left &lt; 0)
        left = 0;
    if (right &lt; 0)
        right = 0;

    if (left == 0 &amp;&amp; right == 0 &amp;&amp; PyString_CheckExact(self)) {
        Py_INCREF(self);
        return (PyObject *)self;
    }

    u = PyString_FromStringAndSize(NULL,
				   left + PyString_GET_SIZE(self) + right);
    if (u) {
        if (left)
            memset(PyString_AS_STRING(u), fill, left);
        memcpy(PyString_AS_STRING(u) + left,
	       PyString_AS_STRING(self),
	       PyString_GET_SIZE(self));
        if (right)
            memset(PyString_AS_STRING(u) + left + PyString_GET_SIZE(self),
		   fill, right);
    }

    return u;
}
</t>
<t tx="T695">static char ljust__doc__[] =
"S.ljust(width) -&gt; string\n"
"\n"
"Return S left justified in a string of length width. Padding is\n"
"done using spaces.";

static PyObject *
string_ljust(PyStringObject *self, PyObject *args)
{
    int width;
    if (!PyArg_ParseTuple(args, "i:ljust", &amp;width))
        return NULL;

    if (PyString_GET_SIZE(self) &gt;= width &amp;&amp; PyString_CheckExact(self)) {
        Py_INCREF(self);
        return (PyObject*) self;
    }

    return pad(self, 0, width - PyString_GET_SIZE(self), ' ');
}
</t>
<t tx="T696">static char rjust__doc__[] =
"S.rjust(width) -&gt; string\n"
"\n"
"Return S right justified in a string of length width. Padding is\n"
"done using spaces.";

static PyObject *
string_rjust(PyStringObject *self, PyObject *args)
{
    int width;
    if (!PyArg_ParseTuple(args, "i:rjust", &amp;width))
        return NULL;

    if (PyString_GET_SIZE(self) &gt;= width &amp;&amp; PyString_CheckExact(self)) {
        Py_INCREF(self);
        return (PyObject*) self;
    }

    return pad(self, width - PyString_GET_SIZE(self), 0, ' ');
}
</t>
<t tx="T697">static char center__doc__[] =
"S.center(width) -&gt; string\n"
"\n"
"Return S centered in a string of length width. Padding is done\n"
"using spaces.";

static PyObject *
string_center(PyStringObject *self, PyObject *args)
{
    int marg, left;
    int width;

    if (!PyArg_ParseTuple(args, "i:center", &amp;width))
        return NULL;

    if (PyString_GET_SIZE(self) &gt;= width &amp;&amp; PyString_CheckExact(self)) {
        Py_INCREF(self);
        return (PyObject*) self;
    }

    marg = width - PyString_GET_SIZE(self);
    left = marg / 2 + (marg &amp; width &amp; 1);

    return pad(self, left, marg - left, ' ');
}
</t>
<t tx="T698">static char isspace__doc__[] =
"S.isspace() -&gt; int\n"
"\n"
"Return 1 if there are only whitespace characters in S,\n"
"0 otherwise.";

static PyObject*
string_isspace(PyStringObject *self)
{
    register const unsigned char *p
        = (unsigned char *) PyString_AS_STRING(self);
    register const unsigned char *e;

    /* Shortcut for single character strings */
    if (PyString_GET_SIZE(self) == 1 &amp;&amp;
	isspace(*p))
	return PyInt_FromLong(1);

    /* Special case for empty strings */
    if (PyString_GET_SIZE(self) == 0)
	return PyInt_FromLong(0);

    e = p + PyString_GET_SIZE(self);
    for (; p &lt; e; p++) {
	if (!isspace(*p))
	    return PyInt_FromLong(0);
    }
    return PyInt_FromLong(1);
}
</t>
<t tx="T699">static char isalpha__doc__[] =
"S.isalpha() -&gt; int\n\
\n\
Return 1 if  all characters in S are alphabetic\n\
and there is at least one character in S, 0 otherwise.";

static PyObject*
string_isalpha(PyStringObject *self)
{
    register const unsigned char *p
        = (unsigned char *) PyString_AS_STRING(self);
    register const unsigned char *e;

    /* Shortcut for single character strings */
    if (PyString_GET_SIZE(self) == 1 &amp;&amp;
	isalpha(*p))
	return PyInt_FromLong(1);

    /* Special case for empty strings */
    if (PyString_GET_SIZE(self) == 0)
	return PyInt_FromLong(0);

    e = p + PyString_GET_SIZE(self);
    for (; p &lt; e; p++) {
	if (!isalpha(*p))
	    return PyInt_FromLong(0);
    }
    return PyInt_FromLong(1);
}
</t>
<t tx="T700">static char isalnum__doc__[] =
"S.isalnum() -&gt; int\n\
\n\
Return 1 if  all characters in S are alphanumeric\n\
and there is at least one character in S, 0 otherwise.";

static PyObject*
string_isalnum(PyStringObject *self)
{
    register const unsigned char *p
        = (unsigned char *) PyString_AS_STRING(self);
    register const unsigned char *e;

    /* Shortcut for single character strings */
    if (PyString_GET_SIZE(self) == 1 &amp;&amp;
	isalnum(*p))
	return PyInt_FromLong(1);

    /* Special case for empty strings */
    if (PyString_GET_SIZE(self) == 0)
	return PyInt_FromLong(0);

    e = p + PyString_GET_SIZE(self);
    for (; p &lt; e; p++) {
	if (!isalnum(*p))
	    return PyInt_FromLong(0);
    }
    return PyInt_FromLong(1);
}
</t>
<t tx="T701">static char isdigit__doc__[] =
"S.isdigit() -&gt; int\n\
\n\
Return 1 if there are only digit characters in S,\n\
0 otherwise.";

static PyObject*
string_isdigit(PyStringObject *self)
{
    register const unsigned char *p
        = (unsigned char *) PyString_AS_STRING(self);
    register const unsigned char *e;

    /* Shortcut for single character strings */
    if (PyString_GET_SIZE(self) == 1 &amp;&amp;
	isdigit(*p))
	return PyInt_FromLong(1);

    /* Special case for empty strings */
    if (PyString_GET_SIZE(self) == 0)
	return PyInt_FromLong(0);

    e = p + PyString_GET_SIZE(self);
    for (; p &lt; e; p++) {
	if (!isdigit(*p))
	    return PyInt_FromLong(0);
    }
    return PyInt_FromLong(1);
}
</t>
<t tx="T702">static char islower__doc__[] =
"S.islower() -&gt; int\n\
\n\
Return 1 if  all cased characters in S are lowercase and there is\n\
at least one cased character in S, 0 otherwise.";

static PyObject*
string_islower(PyStringObject *self)
{
    register const unsigned char *p
        = (unsigned char *) PyString_AS_STRING(self);
    register const unsigned char *e;
    int cased;

    /* Shortcut for single character strings */
    if (PyString_GET_SIZE(self) == 1)
	return PyInt_FromLong(islower(*p) != 0);

    /* Special case for empty strings */
    if (PyString_GET_SIZE(self) == 0)
	return PyInt_FromLong(0);

    e = p + PyString_GET_SIZE(self);
    cased = 0;
    for (; p &lt; e; p++) {
	if (isupper(*p))
	    return PyInt_FromLong(0);
	else if (!cased &amp;&amp; islower(*p))
	    cased = 1;
    }
    return PyInt_FromLong(cased);
}
</t>
<t tx="T703">static char isupper__doc__[] =
"S.isupper() -&gt; int\n\
\n\
Return 1 if  all cased characters in S are uppercase and there is\n\
at least one cased character in S, 0 otherwise.";

static PyObject*
string_isupper(PyStringObject *self)
{
    register const unsigned char *p
        = (unsigned char *) PyString_AS_STRING(self);
    register const unsigned char *e;
    int cased;

    /* Shortcut for single character strings */
    if (PyString_GET_SIZE(self) == 1)
	return PyInt_FromLong(isupper(*p) != 0);

    /* Special case for empty strings */
    if (PyString_GET_SIZE(self) == 0)
	return PyInt_FromLong(0);

    e = p + PyString_GET_SIZE(self);
    cased = 0;
    for (; p &lt; e; p++) {
	if (islower(*p))
	    return PyInt_FromLong(0);
	else if (!cased &amp;&amp; isupper(*p))
	    cased = 1;
    }
    return PyInt_FromLong(cased);
}
</t>
<t tx="T704">static char istitle__doc__[] =
"S.istitle() -&gt; int\n\
\n\
Return 1 if S is a titlecased string, i.e. uppercase characters\n\
may only follow uncased characters and lowercase characters only cased\n\
ones. Return 0 otherwise.";

static PyObject*
string_istitle(PyStringObject *self, PyObject *uncased)
{
    register const unsigned char *p
        = (unsigned char *) PyString_AS_STRING(self);
    register const unsigned char *e;
    int cased, previous_is_cased;

    /* Shortcut for single character strings */
    if (PyString_GET_SIZE(self) == 1)
	return PyInt_FromLong(isupper(*p) != 0);

    /* Special case for empty strings */
    if (PyString_GET_SIZE(self) == 0)
	return PyInt_FromLong(0);

    e = p + PyString_GET_SIZE(self);
    cased = 0;
    previous_is_cased = 0;
    for (; p &lt; e; p++) {
	register const unsigned char ch = *p;

	if (isupper(ch)) {
	    if (previous_is_cased)
		return PyInt_FromLong(0);
	    previous_is_cased = 1;
	    cased = 1;
	}
	else if (islower(ch)) {
	    if (!previous_is_cased)
		return PyInt_FromLong(0);
	    previous_is_cased = 1;
	    cased = 1;
	}
	else
	    previous_is_cased = 0;
    }
    return PyInt_FromLong(cased);
}
</t>
<t tx="T705">static char splitlines__doc__[] =
"S.splitlines([keepends]) -&gt; list of strings\n\
\n\
Return a list of the lines in S, breaking at line boundaries.\n\
Line breaks are not included in the resulting list unless keepends\n\
is given and true.";

#define SPLIT_APPEND(data, left, right)					\
	str = PyString_FromStringAndSize(data + left, right - left);	\
	if (!str)							\
	    goto onError;						\
	if (PyList_Append(list, str)) {					\
	    Py_DECREF(str);						\
	    goto onError;						\
	}								\
        else								\
            Py_DECREF(str);

static PyObject*
string_splitlines(PyStringObject *self, PyObject *args)
{
    register int i;
    register int j;
    int len;
    int keepends = 0;
    PyObject *list;
    PyObject *str;
    char *data;

    if (!PyArg_ParseTuple(args, "|i:splitlines", &amp;keepends))
        return NULL;

    data = PyString_AS_STRING(self);
    len = PyString_GET_SIZE(self);

    list = PyList_New(0);
    if (!list)
        goto onError;

    for (i = j = 0; i &lt; len; ) {
	int eol;

	/* Find a line and append it */
	while (i &lt; len &amp;&amp; data[i] != '\n' &amp;&amp; data[i] != '\r')
	    i++;

	/* Skip the line break reading CRLF as one line break */
	eol = i;
	if (i &lt; len) {
	    if (data[i] == '\r' &amp;&amp; i + 1 &lt; len &amp;&amp;
		data[i+1] == '\n')
		i += 2;
	    else
		i++;
	    if (keepends)
		eol = i;
	}
	SPLIT_APPEND(data, j, eol);
	j = i;
    }
    if (j &lt; len) {
	SPLIT_APPEND(data, j, len);
    }

    return list;

 onError:
    Py_DECREF(list);
    return NULL;
}

#undef SPLIT_APPEND
</t>
<t tx="T706">static PyMethodDef
string_methods[] = {
	/* Counterparts of the obsolete stropmodule functions; except
	   string.maketrans(). */
	{"join",       (PyCFunction)string_join,   METH_O, join__doc__},
	{"split",       (PyCFunction)string_split, METH_VARARGS, split__doc__},
	{"lower",      (PyCFunction)string_lower,  METH_NOARGS, lower__doc__},
	{"upper",       (PyCFunction)string_upper, METH_NOARGS, upper__doc__},
	{"islower", (PyCFunction)string_islower, METH_NOARGS, islower__doc__},
	{"isupper", (PyCFunction)string_isupper, METH_NOARGS, isupper__doc__},
	{"isspace", (PyCFunction)string_isspace, METH_NOARGS, isspace__doc__},
	{"isdigit", (PyCFunction)string_isdigit, METH_NOARGS, isdigit__doc__},
	{"istitle", (PyCFunction)string_istitle, METH_NOARGS, istitle__doc__},
	{"isalpha", (PyCFunction)string_isalpha, METH_NOARGS, isalpha__doc__},
	{"isalnum", (PyCFunction)string_isalnum, METH_NOARGS, isalnum__doc__},
	{"capitalize", (PyCFunction)string_capitalize,  METH_NOARGS, capitalize__doc__},
	{"count",      (PyCFunction)string_count,       METH_VARARGS, count__doc__},
	{"endswith",   (PyCFunction)string_endswith,    METH_VARARGS, endswith__doc__},
	{"find",       (PyCFunction)string_find,        METH_VARARGS, find__doc__},
	{"index",      (PyCFunction)string_index,       METH_VARARGS, index__doc__},
	{"lstrip",     (PyCFunction)string_lstrip,      METH_NOARGS, lstrip__doc__},
	{"replace",     (PyCFunction)string_replace,    METH_VARARGS, replace__doc__},
	{"rfind",       (PyCFunction)string_rfind,      METH_VARARGS, rfind__doc__},
	{"rindex",      (PyCFunction)string_rindex,     METH_VARARGS, rindex__doc__},
	{"rstrip",      (PyCFunction)string_rstrip,     METH_NOARGS, rstrip__doc__},
	{"startswith",  (PyCFunction)string_startswith, METH_VARARGS, startswith__doc__},
	{"strip",       (PyCFunction)string_strip,      METH_NOARGS, strip__doc__},
	{"swapcase",    (PyCFunction)string_swapcase,   METH_NOARGS, swapcase__doc__},
	{"translate",   (PyCFunction)string_translate,  METH_VARARGS, translate__doc__},
	{"title",       (PyCFunction)string_title,      METH_NOARGS, title__doc__},
	{"ljust",       (PyCFunction)string_ljust,      METH_VARARGS, ljust__doc__},
	{"rjust",       (PyCFunction)string_rjust,      METH_VARARGS, rjust__doc__},
	{"center",      (PyCFunction)string_center,     METH_VARARGS, center__doc__},
	{"encode",      (PyCFunction)string_encode,     METH_VARARGS, encode__doc__},
	{"decode",      (PyCFunction)string_decode,     METH_VARARGS, decode__doc__},
	{"expandtabs",  (PyCFunction)string_expandtabs, METH_VARARGS, expandtabs__doc__},
	{"splitlines",  (PyCFunction)string_splitlines, METH_VARARGS, splitlines__doc__},
#if 0
	{"zfill",       (PyCFunction)string_zfill,      METH_VARARGS, zfill__doc__},
#endif
	{NULL,     NULL}		     /* sentinel */
};</t>
<t tx="T707">staticforward PyObject *
str_subtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds);

static PyObject *
string_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
	PyObject *x = NULL;
	static char *kwlist[] = {"object", 0};

	if (type != &amp;PyString_Type)
		return str_subtype_new(type, args, kwds);

	if (!PyArg_ParseTupleAndKeywords(args, kwds, "|O:str", kwlist, &amp;x))
		return NULL;

	if (x == NULL)
		return PyString_FromString("");

	return PyObject_Str(x);
}
</t>
<t tx="T708">static PyObject *
str_subtype_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
	PyObject *tmp, *pnew;
	int n;

	assert(PyType_IsSubtype(type, &amp;PyString_Type));
	tmp = string_new(&amp;PyString_Type, args, kwds);
	if (tmp == NULL)
		return NULL;

	assert(PyString_CheckExact(tmp));
	n = PyString_GET_SIZE(tmp);
	pnew = type-&gt;tp_alloc(type, n);

	if (pnew != NULL) {
		memcpy(PyString_AS_STRING(pnew), PyString_AS_STRING(tmp), n+1);
		#ifdef CACHE_HASH
			((PyStringObject *)pnew)-&gt;ob_shash =
				((PyStringObject *)tmp)-&gt;ob_shash;
		#endif

		#ifdef INTERN_STRINGS
			((PyStringObject *)pnew)-&gt;ob_sinterned =
				((PyStringObject *)tmp)-&gt;ob_sinterned;
		#endif
	}
	Py_DECREF(tmp);
	return pnew;
}</t>
<t tx="T709">static char string_doc[] =
"str(object) -&gt; string\n\
\n\
Return a nice string representation of the object.\n\
If the argument is a string, the return value is the same object.";

PyTypeObject PyString_Type = {
	PyObject_HEAD_INIT(&amp;PyType_Type)
	0,
	"str",
	sizeof(PyStringObject),
	sizeof(char),
 	(destructor)string_dealloc, 		/* tp_dealloc */
	(printfunc)string_print, 		/* tp_print */
	0,					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	(reprfunc)string_repr, 			/* tp_repr */
	0,					/* tp_as_number */
	&amp;string_as_sequence,			/* tp_as_sequence */
	0,					/* tp_as_mapping */
	(hashfunc)string_hash, 			/* tp_hash */
	0,					/* tp_call */
	(reprfunc)string_str,			/* tp_str */
	PyObject_GenericGetAttr,		/* tp_getattro */
	0,					/* tp_setattro */
	&amp;string_as_buffer,			/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
	string_doc,				/* tp_doc */
	0,					/* tp_traverse */
	0,					/* tp_clear */
	(richcmpfunc)string_richcompare,	/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	0,					/* tp_iter */
	0,					/* tp_iternext */
	string_methods,				/* tp_methods */
	0,					/* tp_members */
	0,					/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
	0,					/* tp_descr_get */
	0,					/* tp_descr_set */
	0,					/* tp_dictoffset */
	0,					/* tp_init */
	0,					/* tp_alloc */
	string_new,				/* tp_new */
	_PyObject_Del,				/* tp_free */
};

void
PyString_Concat(register PyObject **pv, register PyObject *w)
{
	register PyObject *v;
	if (*pv == NULL)
		return;
	if (w == NULL || !PyString_Check(*pv)) {
		Py_DECREF(*pv);
		*pv = NULL;
		return;
	}
	v = string_concat((PyStringObject *) *pv, w);
	Py_DECREF(*pv);
	*pv = v;
}
</t>
<t tx="T710">void
PyString_ConcatAndDel(register PyObject **pv, register PyObject *w)
{
	PyString_Concat(pv, w);
	Py_XDECREF(w);
}
</t>
<t tx="T711">@ The following function breaks the notion that strings are immutable:  it changes the size of a string. We get away with this only if there  is only one module referencing the object. You can also think of it  as creating a new string object and destroying the old one, only  more efficiently. In any case, don't use this if the string may  already be known to some other part of the code...
@c

int
_PyString_Resize(PyObject **pv, int newsize)
{
	register PyObject *v;
	register PyStringObject *sv;
	v = *pv;
	if (!PyString_Check(v) || v-&gt;ob_refcnt != 1) {
		*pv = 0;
		Py_DECREF(v);
		PyErr_BadInternalCall();
		return -1;
	}
	/* XXX UNREF/NEWREF interface should be more symmetrical */
#ifdef Py_REF_DEBUG
	--_Py_RefTotal;
#endif
	_Py_ForgetReference(v);
	*pv = (PyObject *)
		PyObject_REALLOC((char *)v,
			sizeof(PyStringObject) + newsize * sizeof(char));
	if (*pv == NULL) {
		PyObject_DEL(v);
		PyErr_NoMemory();
		return -1;
	}
	_Py_NewReference(*pv);
	sv = (PyStringObject *) *pv;
	sv-&gt;ob_size = newsize;
	sv-&gt;ob_sval[newsize] = '\0';
	return 0;
}
</t>
<t tx="T712">@ Helpers for formatstring
@c

static PyObject *
getnextarg(PyObject *args, int arglen, int *p_argidx)
{
	int argidx = *p_argidx;
	if (argidx &lt; arglen) {
		(*p_argidx)++;
		if (arglen &lt; 0)
			return args;
		else
			return PyTuple_GetItem(args, argidx);
	}
	PyErr_SetString(PyExc_TypeError,
			"not enough arguments for format string");
	return NULL;
}
</t>
<t tx="T713">@ Format codes * F_LJUST '-' * F_SIGN '+' * F_BLANK ' ' * F_ALT '#' * F_ZERO '0'
@c

#define F_LJUST (1&lt;&lt;0)
#define F_SIGN	(1&lt;&lt;1)
#define F_BLANK (1&lt;&lt;2)
#define F_ALT	(1&lt;&lt;3)
#define F_ZERO	(1&lt;&lt;4)

static int
formatfloat(char *buf, size_t buflen, int flags,
            int prec, int type, PyObject *v)
{
	/* fmt = '%#.' + `prec` + `type`
	   worst case length = 3 + 10 (len of INT_MAX) + 1 = 14 (use 20)*/
	char fmt[20];
	double x;
	if (!PyArg_Parse(v, "d;float argument required", &amp;x))
		return -1;
	if (prec &lt; 0)
		prec = 6;
	if (type == 'f' &amp;&amp; fabs(x)/1e25 &gt;= 1e25)
		type = 'g';
	PyOS_snprintf(fmt, sizeof(fmt), "%%%s.%d%c",
		      (flags&amp;F_ALT) ? "#" : "",
		      prec, type);
	/* worst case length calc to ensure no buffer overrun:
	     fmt = %#.&lt;prec&gt;g
	     buf = '-' + [0-9]*prec + '.' + 'e+' + (longest exp
	        for any double rep.)
	     len = 1 + prec + 1 + 2 + 5 = 9 + prec
	   If prec=0 the effective precision is 1 (the leading digit is
	   always given), therefore increase by one to 10+prec. */
	if (buflen &lt;= (size_t)10 + (size_t)prec) {
		PyErr_SetString(PyExc_OverflowError,
			"formatted float is too long (precision too large?)");
		return -1;
	}
	PyOS_snprintf(buf, buflen, fmt, x);
	return strlen(buf);
}
</t>
<t tx="T714">@ _PyString_FormatLong emulates the format codes d, u, o, x and X, and * the F_ALT flag, for Python's long (unbounded) ints. It's not used for * Python's regular ints. * Return value: a new PyString*, or NULL if error. * . *pbuf is set to point into it, *   *plen set to the # of chars following that. *   Caller must decref it when done using pbuf. *   The string starting at *pbuf is of the form *     "-"? ("0x" | "0X")? digit+ *   "0x"/"0X" are present only for x and X conversions, with F_ALT *     set in flags. The case of hex digits will be correct, *   There will be at least prec digits, zero-filled on the left if *     necessary to get that many. * val object to be converted * flags bitmask of format flags; only F_ALT is looked at * prec minimum number of digits; 0-fill on left if needed * type a character in [duoxX]; u acts the same as d * * CAUTION: o, x and X conversions on regular ints can never * produce a '-' sign, but can for Python's unbounded ints.
@c

PyObject*
_PyString_FormatLong(PyObject *val, int flags, int prec, int type,
		     char **pbuf, int *plen)
{
	PyObject *result = NULL;
	char *buf;
	int i;
	int sign;	/* 1 if '-', else 0 */
	int len;	/* number of characters */
	int numdigits;	/* len == numnondigits + numdigits */
	int numnondigits = 0;

	switch (type) {
	case 'd':
	case 'u':
		result = val-&gt;ob_type-&gt;tp_str(val);
		break;
	case 'o':
		result = val-&gt;ob_type-&gt;tp_as_number-&gt;nb_oct(val);
		break;
	case 'x':
	case 'X':
		numnondigits = 2;
		result = val-&gt;ob_type-&gt;tp_as_number-&gt;nb_hex(val);
		break;
	default:
		assert(!"'type' not in [duoxX]");
	}
	if (!result)
		return NULL;

	/* To modify the string in-place, there can only be one reference. */
	if (result-&gt;ob_refcnt != 1) {
		PyErr_BadInternalCall();
		return NULL;
	}
	buf = PyString_AsString(result);
	len = PyString_Size(result);
	if (buf[len-1] == 'L') {
		--len;
		buf[len] = '\0';
	}
	sign = buf[0] == '-';
	numnondigits += sign;
	numdigits = len - numnondigits;
	assert(numdigits &gt; 0);

	/* Get rid of base marker unless F_ALT */
	if ((flags &amp; F_ALT) == 0) {
		/* Need to skip 0x, 0X or 0. */
		int skipped = 0;
		switch (type) {
		case 'o':
			assert(buf[sign] == '0');
			/* If 0 is only digit, leave it alone. */
			if (numdigits &gt; 1) {
				skipped = 1;
				--numdigits;
			}
			break;
		case 'x':
		case 'X':
			assert(buf[sign] == '0');
			assert(buf[sign + 1] == 'x');
			skipped = 2;
			numnondigits -= 2;
			break;
		}
		if (skipped) {
			buf += skipped;
			len -= skipped;
			if (sign)
				buf[0] = '-';
		}
		assert(len == numnondigits + numdigits);
		assert(numdigits &gt; 0);
	}

	/* Fill with leading zeroes to meet minimum width. */
	if (prec &gt; numdigits) {
		PyObject *r1 = PyString_FromStringAndSize(NULL,
					numnondigits + prec);
		char *b1;
		if (!r1) {
			Py_DECREF(result);
			return NULL;
		}
		b1 = PyString_AS_STRING(r1);
		for (i = 0; i &lt; numnondigits; ++i)
			*b1++ = *buf++;
		for (i = 0; i &lt; prec - numdigits; i++)
			*b1++ = '0';
		for (i = 0; i &lt; numdigits; i++)
			*b1++ = *buf++;
		*b1 = '\0';
		Py_DECREF(result);
		result = r1;
		buf = PyString_AS_STRING(result);
		len = numnondigits + prec;
	}

	/* Fix up case for hex conversions. */
	switch (type) {
	case 'x':
		/* Need to convert all upper case letters to lower case. */
		for (i = 0; i &lt; len; i++)
			if (buf[i] &gt;= 'A' &amp;&amp; buf[i] &lt;= 'F')
				buf[i] += 'a'-'A';
		break;
	case 'X':
		/* Need to convert 0x to 0X (and -0x to -0X). */
		if (buf[sign + 1] == 'x')
			buf[sign + 1] = 'X';
		break;
	}
	*pbuf = buf;
	*plen = len;
	return result;
}
</t>
<t tx="T715">static int
formatint(char *buf, size_t buflen, int flags,
          int prec, int type, PyObject *v)
{
	/* fmt = '%#.' + `prec` + 'l' + `type`
	   worst case length = 3 + 19 (worst len of INT_MAX on 64-bit machine)
	   + 1 + 1 = 24 */
	char fmt[64];	/* plenty big enough! */
	long x;
	if (!PyArg_Parse(v, "l;int argument required", &amp;x))
		return -1;
	if (prec &lt; 0)
		prec = 1;
	PyOS_snprintf(fmt, sizeof(fmt), "%%%s.%dl%c",
		      (flags&amp;F_ALT) ? "#" : "", 
		      prec, type);
	/* buf = '+'/'-'/'0'/'0x' + '[0-9]'*max(prec, len(x in octal))
	   worst case buf = '0x' + [0-9]*prec, where prec &gt;= 11 */
	if (buflen &lt;= 13 || buflen &lt;= (size_t)2 + (size_t)prec) {
		PyErr_SetString(PyExc_OverflowError,
			"formatted integer is too long (precision too large?)");
		return -1;
	}
	PyOS_snprintf(buf, buflen, fmt, x);
	/* When converting 0 under %#x or %#X, C leaves off the base marker,
	 * but we want it (for consistency with other %#x conversions, and
	 * for consistency with Python's hex() function).
	 * BUG 28-Apr-2001 tim:  At least two platform Cs (Metrowerks &amp;
	 * Compaq Tru64) violate the std by converting 0 w/ leading 0x anyway.
	 * So add it only if the platform didn't already.
	 */
	if (x == 0 &amp;&amp;
	   (flags &amp; F_ALT) &amp;&amp;
	   (type == 'x' || type == 'X') &amp;&amp;
	    buf[1] != (char)type)  /* this last always true under std C */
		{
		memmove(buf+2, buf, strlen(buf) + 1);
		buf[0] = '0';
		buf[1] = (char)type;
	}
	return strlen(buf);
}
</t>
<t tx="T716">static int
formatchar(char *buf, size_t buflen, PyObject *v)
{
	/* presume that the buffer is at least 2 characters long */
	if (PyString_Check(v)) {
		if (!PyArg_Parse(v, "c;%c requires int or char", &amp;buf[0]))
			return -1;
	}
	else {
		if (!PyArg_Parse(v, "b;%c requires int or char", &amp;buf[0]))
			return -1;
	}
	buf[1] = '\0';
	return 1;
}
</t>
<t tx="T717">@ fmt%(v1,v2,...) is roughly equivalent to sprintf(fmt, v1, v2, ...)   FORMATBUFLEN is the length of the buffer in which the floats, ints, &amp;  chars are formatted. XXX This is a magic number. Each formatting  routine does bounds checking to ensure no overflow, but a better  solution may be to malloc a buffer of appropriate size for each  format. For now, the current solution is sufficient.
@c

#define FORMATBUFLEN (size_t)120

PyObject *
PyString_Format(PyObject *format, PyObject *args)
{
	char *fmt, *res;
	int fmtcnt, rescnt, reslen, arglen, argidx;
	int args_owned = 0;
	PyObject *result, *orig_args;
#ifdef Py_USING_UNICODE
	PyObject *v, *w;
#endif
	PyObject *dict = NULL;
	if (format == NULL || !PyString_Check(format) || args == NULL) {
		PyErr_BadInternalCall();
		return NULL;
	}
	orig_args = args;
	fmt = PyString_AS_STRING(format);
	fmtcnt = PyString_GET_SIZE(format);
	reslen = rescnt = fmtcnt + 100;
	result = PyString_FromStringAndSize((char *)NULL, reslen);
	if (result == NULL)
		return NULL;
	res = PyString_AsString(result);
	if (PyTuple_Check(args)) {
		arglen = PyTuple_GET_SIZE(args);
		argidx = 0;
	}
	else {
		arglen = -1;
		argidx = -2;
	}
	if (args-&gt;ob_type-&gt;tp_as_mapping)
		dict = args;
	while (--fmtcnt &gt;= 0) {
		if (*fmt != '%') {
			if (--rescnt &lt; 0) {
				rescnt = fmtcnt + 100;
				reslen += rescnt;
				if (_PyString_Resize(&amp;result, reslen) &lt; 0)
					return NULL;
				res = PyString_AS_STRING(result)
					+ reslen - rescnt;
				--rescnt;
			}
			*res++ = *fmt++;
		}
		else {
			/* Got a format specifier */
			int flags = 0;
			int width = -1;
			int prec = -1;
			int c = '\0';
			int fill;
			PyObject *v = NULL;
			PyObject *temp = NULL;
			char *pbuf;
			int sign;
			int len;
			char formatbuf[FORMATBUFLEN]; /* For format{float,int,char}() */
#ifdef Py_USING_UNICODE
			char *fmt_start = fmt;
		        int argidx_start = argidx;
#endif

			fmt++;
			if (*fmt == '(') {
				char *keystart;
				int keylen;
				PyObject *key;
				int pcount = 1;

				if (dict == NULL) {
					PyErr_SetString(PyExc_TypeError,
						 "format requires a mapping");
					goto error;
				}
				++fmt;
				--fmtcnt;
				keystart = fmt;
				/* Skip over balanced parentheses */
				while (pcount &gt; 0 &amp;&amp; --fmtcnt &gt;= 0) {
					if (*fmt == ')')
						--pcount;
					else if (*fmt == '(')
						++pcount;
					fmt++;
				}
				keylen = fmt - keystart - 1;
				if (fmtcnt &lt; 0 || pcount &gt; 0) {
					PyErr_SetString(PyExc_ValueError,
						   "incomplete format key");
					goto error;
				}
				key = PyString_FromStringAndSize(keystart,
								 keylen);
				if (key == NULL)
					goto error;
				if (args_owned) {
					Py_DECREF(args);
					args_owned = 0;
				}
				args = PyObject_GetItem(dict, key);
				Py_DECREF(key);
				if (args == NULL) {
					goto error;
				}
				args_owned = 1;
				arglen = -1;
				argidx = -2;
			}
			while (--fmtcnt &gt;= 0) {
				switch (c = *fmt++) {
				case '-': flags |= F_LJUST; continue;
				case '+': flags |= F_SIGN; continue;
				case ' ': flags |= F_BLANK; continue;
				case '#': flags |= F_ALT; continue;
				case '0': flags |= F_ZERO; continue;
				}
				break;
			}
			if (c == '*') {
				v = getnextarg(args, arglen, &amp;argidx);
				if (v == NULL)
					goto error;
				if (!PyInt_Check(v)) {
					PyErr_SetString(PyExc_TypeError,
							"* wants int");
					goto error;
				}
				width = PyInt_AsLong(v);
				if (width &lt; 0) {
					flags |= F_LJUST;
					width = -width;
				}
				if (--fmtcnt &gt;= 0)
					c = *fmt++;
			}
			else if (c &gt;= 0 &amp;&amp; isdigit(c)) {
				width = c - '0';
				while (--fmtcnt &gt;= 0) {
					c = Py_CHARMASK(*fmt++);
					if (!isdigit(c))
						break;
					if ((width*10) / 10 != width) {
						PyErr_SetString(
							PyExc_ValueError,
							"width too big");
						goto error;
					}
					width = width*10 + (c - '0');
				}
			}
			if (c == '.') {
				prec = 0;
				if (--fmtcnt &gt;= 0)
					c = *fmt++;
				if (c == '*') {
					v = getnextarg(args, arglen, &amp;argidx);
					if (v == NULL)
						goto error;
					if (!PyInt_Check(v)) {
						PyErr_SetString(
							PyExc_TypeError,
							"* wants int");
						goto error;
					}
					prec = PyInt_AsLong(v);
					if (prec &lt; 0)
						prec = 0;
					if (--fmtcnt &gt;= 0)
						c = *fmt++;
				}
				else if (c &gt;= 0 &amp;&amp; isdigit(c)) {
					prec = c - '0';
					while (--fmtcnt &gt;= 0) {
						c = Py_CHARMASK(*fmt++);
						if (!isdigit(c))
							break;
						if ((prec*10) / 10 != prec) {
							PyErr_SetString(
							    PyExc_ValueError,
							    "prec too big");
							goto error;
						}
						prec = prec*10 + (c - '0');
					}
				}
			} /* prec */
			if (fmtcnt &gt;= 0) {
				if (c == 'h' || c == 'l' || c == 'L') {
					if (--fmtcnt &gt;= 0)
						c = *fmt++;
				}
			}
			if (fmtcnt &lt; 0) {
				PyErr_SetString(PyExc_ValueError,
						"incomplete format");
				goto error;
			}
			if (c != '%') {
				v = getnextarg(args, arglen, &amp;argidx);
				if (v == NULL)
					goto error;
			}
			sign = 0;
			fill = ' ';
			switch (c) {
			case '%':
				pbuf = "%";
				len = 1;
				break;
			case 's':
  			case 'r':
#ifdef Py_USING_UNICODE
				if (PyUnicode_Check(v)) {
					fmt = fmt_start;
					argidx = argidx_start;
					goto unicode;
				}
#endif
				if (c == 's')
					temp = PyObject_Str(v);
				else
					temp = PyObject_Repr(v);
				if (temp == NULL)
					goto error;
				if (!PyString_Check(temp)) {
					PyErr_SetString(PyExc_TypeError,
					  "%s argument has non-string str()");
					Py_DECREF(temp);
					goto error;
				}
				pbuf = PyString_AS_STRING(temp);
				len = PyString_GET_SIZE(temp);
				if (prec &gt;= 0 &amp;&amp; len &gt; prec)
					len = prec;
				break;
			case 'i':
			case 'd':
			case 'u':
			case 'o':
			case 'x':
			case 'X':
				if (c == 'i')
					c = 'd';
				if (PyLong_Check(v)) {
					temp = _PyString_FormatLong(v, flags,
						prec, c, &amp;pbuf, &amp;len);
					if (!temp)
						goto error;
					/* unbounded ints can always produce
					   a sign character! */
					sign = 1;
				}
				else {
					pbuf = formatbuf;
					len = formatint(pbuf, sizeof(formatbuf),
							flags, prec, c, v);
					if (len &lt; 0)
						goto error;
					/* only d conversion is signed */
					sign = c == 'd';
				}
				if (flags &amp; F_ZERO)
					fill = '0';
				break;
			case 'e':
			case 'E':
			case 'f':
			case 'g':
			case 'G':
				pbuf = formatbuf;
				len = formatfloat(pbuf, sizeof(formatbuf), flags, prec, c, v);
				if (len &lt; 0)
					goto error;
				sign = 1;
				if (flags &amp; F_ZERO)
					fill = '0';
				break;
			case 'c':
				pbuf = formatbuf;
				len = formatchar(pbuf, sizeof(formatbuf), v);
				if (len &lt; 0)
					goto error;
				break;
			default:
				PyErr_Format(PyExc_ValueError,
				  "unsupported format character '%c' (0x%x) "
				  "at index %i",
				  c, c, fmt - 1 - PyString_AsString(format));
				goto error;
			}
			if (sign) {
				if (*pbuf == '-' || *pbuf == '+') {
					sign = *pbuf++;
					len--;
				}
				else if (flags &amp; F_SIGN)
					sign = '+';
				else if (flags &amp; F_BLANK)
					sign = ' ';
				else
					sign = 0;
			}
			if (width &lt; len)
				width = len;
			if (rescnt &lt; width + (sign != 0)) {
				reslen -= rescnt;
				rescnt = width + fmtcnt + 100;
				reslen += rescnt;
				if (_PyString_Resize(&amp;result, reslen) &lt; 0)
					return NULL;
				res = PyString_AS_STRING(result)
					+ reslen - rescnt;
			}
			if (sign) {
				if (fill != ' ')
					*res++ = sign;
				rescnt--;
				if (width &gt; len)
					width--;
			}
			if ((flags &amp; F_ALT) &amp;&amp; (c == 'x' || c == 'X')) {
				assert(pbuf[0] == '0');
				assert(pbuf[1] == c);
				if (fill != ' ') {
					*res++ = *pbuf++;
					*res++ = *pbuf++;
				}
				rescnt -= 2;
				width -= 2;
				if (width &lt; 0)
					width = 0;
				len -= 2;
			}
			if (width &gt; len &amp;&amp; !(flags &amp; F_LJUST)) {
				do {
					--rescnt;
					*res++ = fill;
				} while (--width &gt; len);
			}
			if (fill == ' ') {
				if (sign)
					*res++ = sign;
				if ((flags &amp; F_ALT) &amp;&amp;
				    (c == 'x' || c == 'X')) {
					assert(pbuf[0] == '0');
					assert(pbuf[1] == c);
					*res++ = *pbuf++;
					*res++ = *pbuf++;
				}
			}
			memcpy(res, pbuf, len);
			res += len;
			rescnt -= len;
			while (--width &gt;= len) {
				--rescnt;
				*res++ = ' ';
			}
                        if (dict &amp;&amp; (argidx &lt; arglen) &amp;&amp; c != '%') {
                                PyErr_SetString(PyExc_TypeError,
                                           "not all arguments converted");
                                goto error;
                        }
			Py_XDECREF(temp);
		} /* '%' */
	} /* until end */
	if (argidx &lt; arglen &amp;&amp; !dict) {
		PyErr_SetString(PyExc_TypeError,
				"not all arguments converted");
		goto error;
	}
	if (args_owned) {
		Py_DECREF(args);
	}
	_PyString_Resize(&amp;result, reslen - rescnt);
	return result;

#ifdef Py_USING_UNICODE
 unicode:
	if (args_owned) {
		Py_DECREF(args);
		args_owned = 0;
	}
	/* Fiddle args right (remove the first argidx arguments) */
	if (PyTuple_Check(orig_args) &amp;&amp; argidx &gt; 0) {
		PyObject *v;
		int n = PyTuple_GET_SIZE(orig_args) - argidx;
		v = PyTuple_New(n);
		if (v == NULL)
			goto error;
		while (--n &gt;= 0) {
			PyObject *w = PyTuple_GET_ITEM(orig_args, n + argidx);
			Py_INCREF(w);
			PyTuple_SET_ITEM(v, n, w);
		}
		args = v;
	} else {
		Py_INCREF(orig_args);
		args = orig_args;
	}
	args_owned = 1;
	/* Take what we have of the result and let the Unicode formatting
	   function format the rest of the input. */
	rescnt = res - PyString_AS_STRING(result);
	if (_PyString_Resize(&amp;result, rescnt))
		goto error;
	fmtcnt = PyString_GET_SIZE(format) - \
		 (fmt - PyString_AS_STRING(format));
	format = PyUnicode_Decode(fmt, fmtcnt, NULL, NULL);
	if (format == NULL)
		goto error;
	v = PyUnicode_Format(format, args);
	Py_DECREF(format);
	if (v == NULL)
		goto error;
	/* Paste what we have (result) to what the Unicode formatting
	   function returned (v) and return the result (or error) */
	w = PyUnicode_Concat(result, v);
	Py_DECREF(result);
	Py_DECREF(v);
	Py_DECREF(args);
	return w;
#endif /* Py_USING_UNICODE */

 error:
	Py_DECREF(result);
	if (args_owned) {
		Py_DECREF(args);
	}
	return NULL;
}
</t>
<t tx="T718">#ifdef INTERN_STRINGS

/* This dictionary will leak at PyString_Fini() time.  That's acceptable
 * because PyString_Fini() specifically frees interned strings that are
 * only referenced by this dictionary.  The CVS log entry for revision 2.45
 * says:
 *
 *    Change the Fini function to only remove otherwise unreferenced
 *    strings from the interned table.  There are references in
 *    hard-to-find static variables all over the interpreter, and it's not
 *    worth trying to get rid of all those; but "uninterning" isn't fair
 *    either and may cause subtle failures later -- so we have to keep them
 *    in the interned table.
 */
static PyObject *interned;

&lt;&lt; intern methods &gt;&gt;

#endif</t>
<t tx="T719"></t>
<t tx="T720">

void
PyString_InternInPlace(PyObject **p)
{
	register PyStringObject *s = (PyStringObject *)(*p);
	PyObject *t;
	if (s == NULL || !PyString_Check(s))
		Py_FatalError("PyString_InternInPlace: strings only please!");
	if ((t = s-&gt;ob_sinterned) != NULL) {
		if (t == (PyObject *)s)
			return;
		Py_INCREF(t);
		*p = t;
		Py_DECREF(s);
		return;
	}
	if (interned == NULL) {
		interned = PyDict_New();
		if (interned == NULL)
			return;
	}
	if ((t = PyDict_GetItem(interned, (PyObject *)s)) != NULL) {
		Py_INCREF(t);
		*p = s-&gt;ob_sinterned = t;
		Py_DECREF(s);
		return;
	}
	/* Ensure that only true string objects appear in the intern dict,
	   and as the value of ob_sinterned. */
	if (PyString_CheckExact(s)) {
		t = (PyObject *)s;
		if (PyDict_SetItem(interned, t, t) == 0) {
			s-&gt;ob_sinterned = t;
			return;
		}
	}
	else {
		t = PyString_FromStringAndSize(PyString_AS_STRING(s),
						PyString_GET_SIZE(s));
		if (t != NULL) {
			if (PyDict_SetItem(interned, t, t) == 0) {
				*p = s-&gt;ob_sinterned = t;
				Py_DECREF(s);
				return;
			}
			Py_DECREF(t);
		}
	}
	PyErr_Clear();
}
</t>
<t tx="T721">PyObject *
PyString_InternFromString(const char *cp)
{
	PyObject *s = PyString_FromString(cp);
	if (s == NULL)
		return NULL;
	PyString_InternInPlace(&amp;s);
	return s;
}
</t>
<t tx="T722">void
PyString_Fini(void)
{
	int i;
	for (i = 0; i &lt; UCHAR_MAX + 1; i++) {
		Py_XDECREF(characters[i]);
		characters[i] = NULL;
	}
#ifndef DONT_SHARE_SHORT_STRINGS
	Py_XDECREF(nullstring);
	nullstring = NULL;
#endif
#ifdef INTERN_STRINGS
	if (interned) {
		int pos, changed;
		PyObject *key, *value;
		do {
			changed = 0;
			pos = 0;
			while (PyDict_Next(interned, &amp;pos, &amp;key, &amp;value)) {
				if (key-&gt;ob_refcnt == 2 &amp;&amp; key == value) {
					PyDict_DelItem(interned, key);
					changed = 1;
				}
			}
		} while (changed);
	}
#endif
}
</t>
<t tx="T723">#ifdef INTERN_STRINGS
	void _Py_ReleaseInternedStrings(void)
	{
		if (interned) {
			fprintf(stderr, "releasing interned strings\n");
			PyDict_Clear(interned);
			Py_DECREF(interned);
			interned = NULL;
		}
	}
#endif /* INTERN_STRINGS */</t>
<t tx="T724">@language python
@others
&lt;&lt; string declarations &gt;&gt;

# Try importing optional built-in module "strop" -- if it exists,
# it redefines some string operations that are 100-1000 times faster.
# It also defines values for whitespace, lowercase and uppercase
# that match &lt;ctype.h&gt;'s definitions.

try:
    from strop import maketrans, lowercase, uppercase, whitespace
    letters = lowercase + uppercase
except ImportError:
    pass                                          # Use the original versions
</t>
<t tx="T725">"""A collection of string operations (most are no longer used in Python 1.6).

Warning: most of the code you see here isn't normally used nowadays.  With
Python 1.6, many of these functions are implemented as methods on the
standard string object. They used to be implemented by a built-in module
called strop, but strop is now obsolete itself.

Public module variables:

whitespace -- a string containing all characters considered whitespace
lowercase -- a string containing all characters considered lowercase letters
uppercase -- a string containing all characters considered uppercase letters
letters -- a string containing all characters considered letters
digits -- a string containing all characters considered decimal digits
hexdigits -- a string containing all characters considered hexadecimal digits
octdigits -- a string containing all characters considered octal digits
punctuation -- a string containing all characters considered punctuation
printable -- a string containing all characters considered printable

"""

# Some strings for ctype-style character classification
whitespace = ' \t\n\r\v\f'
lowercase = 'abcdefghijklmnopqrstuvwxyz'
uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
letters = lowercase + uppercase
ascii_lowercase = lowercase
ascii_uppercase = uppercase
ascii_letters = ascii_lowercase + ascii_uppercase
digits = '0123456789'
hexdigits = digits + 'abcdef' + 'ABCDEF'
octdigits = '01234567'
punctuation = """!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~"""
printable = digits + letters + punctuation + whitespace

# Case conversion helpers
_idmap = ''
for i in range(256): _idmap = _idmap + chr(i)
del i

# Backward compatible names for exceptions
index_error = ValueError
atoi_error = ValueError
atof_error = ValueError
atol_error = ValueError

# convert UPPER CASE letters to lower case
</t>
<t tx="T726">def lower(s):
    """lower(s) -&gt; string

    Return a copy of the string s converted to lowercase.

    """
    return s.lower()
</t>
<t tx="T727"># Convert lower case letters to UPPER CASE
def upper(s):
    """upper(s) -&gt; string

    Return a copy of the string s converted to uppercase.

    """
    return s.upper()
</t>
<t tx="T728"># Swap lower case letters and UPPER CASE
def swapcase(s):
    """swapcase(s) -&gt; string

    Return a copy of the string s with upper case characters
    converted to lowercase and vice versa.

    """
    return s.swapcase()
</t>
<t tx="T729"># Strip leading and trailing tabs and spaces
def strip(s):
    """strip(s) -&gt; string

    Return a copy of the string s with leading and trailing
    whitespace removed.

    """
    return s.strip()
</t>
<t tx="T730"># Strip leading tabs and spaces
def lstrip(s):
    """lstrip(s) -&gt; string

    Return a copy of the string s with leading whitespace removed.

    """
    return s.lstrip()
</t>
<t tx="T731"># Strip trailing tabs and spaces
def rstrip(s):
    """rstrip(s) -&gt; string

    Return a copy of the string s with trailing whitespace
    removed.

    """
    return s.rstrip()
</t>
<t tx="T732"># Split a string into a list of space/tab-separated words
def split(s, sep=None, maxsplit=-1):
    """split(s [,sep [,maxsplit]]) -&gt; list of strings

    Return a list of the words in the string s, using sep as the
    delimiter string.  If maxsplit is given, splits at no more than
    maxsplit places (resulting in at most maxsplit+1 words).  If sep
    is not specified, any whitespace string is a separator.

    (split and splitfields are synonymous)

    """
    return s.split(sep, maxsplit)
</t>
<t tx="T733">splitfields = split

# Join fields with optional separator
def join(words, sep = ' '):
    """join(list [,sep]) -&gt; string

    Return a string composed of the words in list, with
    intervening occurrences of sep.  The default separator is a
    single space.

    (joinfields and join are synonymous)

    """
    return sep.join(words)
</t>
<t tx="T734">joinfields = join

# Find substring, raise exception if not found
def index(s, *args):
    """index(s, sub [,start [,end]]) -&gt; int

    Like find but raises ValueError when the substring is not found.

    """
    return s.index(*args)
</t>
<t tx="T735"># Find last substring, raise exception if not found
def rindex(s, *args):
    """rindex(s, sub [,start [,end]]) -&gt; int

    Like rfind but raises ValueError when the substring is not found.

    """
    return s.rindex(*args)
</t>
<t tx="T736"># Count non-overlapping occurrences of substring
def count(s, *args):
    """count(s, sub[, start[,end]]) -&gt; int

    Return the number of occurrences of substring sub in string
    s[start:end].  Optional arguments start and end are
    interpreted as in slice notation.

    """
    return s.count(*args)
</t>
<t tx="T737"># Find substring, return -1 if not found
def find(s, *args):
    """find(s, sub [,start [,end]]) -&gt; in

    Return the lowest index in s where substring sub is found,
    such that sub is contained within s[start,end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.

    """
    return s.find(*args)
</t>
<t tx="T738"># Find last substring, return -1 if not found
def rfind(s, *args):
    """rfind(s, sub [,start [,end]]) -&gt; int

    Return the highest index in s where substring sub is found,
    such that sub is contained within s[start,end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.

    """
    return s.rfind(*args)
</t>
<t tx="T739"># for a bit of speed
_float = float
_int = int
_long = long
_StringType = type('')

# Convert string to float
def atof(s):
    """atof(s) -&gt; float

    Return the floating point number represented by the string s.

    """
    return _float(s)
</t>
<t tx="T740"># Convert string to integer
def atoi(s , base=10):
    """atoi(s [,base]) -&gt; int

    Return the integer represented by the string s in the given
    base, which defaults to 10.  The string s must consist of one
    or more digits, possibly preceded by a sign.  If base is 0, it
    is chosen from the leading characters of s, 0 for octal, 0x or
    0X for hexadecimal.  If base is 16, a preceding 0x or 0X is
    accepted.

    """
    return _int(s, base)
</t>
<t tx="T741"># Convert string to long integer
def atol(s, base=10):
    """atol(s [,base]) -&gt; long

    Return the long integer represented by the string s in the
    given base, which defaults to 10.  The string s must consist
    of one or more digits, possibly preceded by a sign.  If base
    is 0, it is chosen from the leading characters of s, 0 for
    octal, 0x or 0X for hexadecimal.  If base is 16, a preceding
    0x or 0X is accepted.  A trailing L or l is not accepted,
    unless base is 0.

    """
    return _long(s, base)
</t>
<t tx="T742"># Left-justify a string
def ljust(s, width):
    """ljust(s, width) -&gt; string

    Return a left-justified version of s, in a field of the
    specified width, padded with spaces as needed.  The string is
    never truncated.

    """
    return s.ljust(width)
</t>
<t tx="T743"># Right-justify a string
def rjust(s, width):
    """rjust(s, width) -&gt; string

    Return a right-justified version of s, in a field of the
    specified width, padded with spaces as needed.  The string is
    never truncated.

    """
    return s.rjust(width)
</t>
<t tx="T744"># Center a string
def center(s, width):
    """center(s, width) -&gt; string

    Return a center version of s, in a field of the specified
    width. padded with spaces as needed.  The string is never
    truncated.

    """
    return s.center(width)
</t>
<t tx="T745"># Zero-fill a number, e.g., (12, 3) --&gt; '012' and (-3, 3) --&gt; '-03'
# Decadent feature: the argument may be a string or a number
# (Use of this is deprecated; it should be a string as with ljust c.s.)
def zfill(x, width):
    """zfill(x, width) -&gt; string

    Pad a numeric string x with zeros on the left, to fill a field
    of the specified width.  The string x is never truncated.

    """
    if type(x) == type(''): s = x
    else: s = `x`
    n = len(s)
    if n &gt;= width: return s
    sign = ''
    if s[0] in ('-', '+'):
        sign, s = s[0], s[1:]
    return sign + '0'*(width-n) + s
</t>
<t tx="T746"># Expand tabs in a string.
# Doesn't take non-printing chars into account, but does understand \n.
def expandtabs(s, tabsize=8):
    """expandtabs(s [,tabsize]) -&gt; string

    Return a copy of the string s with all tab characters replaced
    by the appropriate number of spaces, depending on the current
    column, and the tabsize (default 8).

    """
    return s.expandtabs(tabsize)
</t>
<t tx="T747"># Character translation through look-up table.
def translate(s, table, deletions=""):
    """translate(s,table [,deletions]) -&gt; string

    Return a copy of the string s, where all characters occurring
    in the optional argument deletions are removed, and the
    remaining characters have been mapped through the given
    translation table, which must be a string of length 256.  The
    deletions argument is not allowed for Unicode strings.

    """
    if deletions:
        return s.translate(table, deletions)
    else:
        # Add s[:0] so that if s is Unicode and table is an 8-bit string,
        # table is converted to Unicode.  This means that table *cannot*
        # be a dictionary -- for that feature, use u.translate() directly.
        return s.translate(table + s[:0])
</t>
<t tx="T748"># Capitalize a string, e.g. "aBc  dEf" -&gt; "Abc  def".
def capitalize(s):
    """capitalize(s) -&gt; string

    Return a copy of the string s with only its first character
    capitalized.

    """
    return s.capitalize()
</t>
<t tx="T749"># Capitalize the words in a string, e.g. " aBc  dEf " -&gt; "Abc Def".
# See also regsub.capwords().
def capwords(s, sep=None):
    """capwords(s, [sep]) -&gt; string

    Split the argument into words using split, capitalize each
    word using capitalize, and join the capitalized words using
    join. Note that this replaces runs of whitespace characters by
    a single space.

    """
    return join(map(capitalize, s.split(sep)), sep or ' ')
</t>
<t tx="T750"># Construct a translation string
_idmapL = None
def maketrans(fromstr, tostr):
    """maketrans(frm, to) -&gt; string

    Return a translation table (a string of 256 bytes long)
    suitable for use in string.translate.  The strings frm and to
    must be of the same length.

    """
    if len(fromstr) != len(tostr):
        raise ValueError, "maketrans arguments must have same length"
    global _idmapL
    if not _idmapL:
        _idmapL = map(None, _idmap)
    L = _idmapL[:]
    fromstr = map(ord, fromstr)
    for i in range(len(fromstr)):
        L[fromstr[i]] = tostr[i]
    return join(L, "")
</t>
<t tx="T751"># Substring replacement (global)
def replace(s, old, new, maxsplit=-1):
    """replace (str, old, new[, maxsplit]) -&gt; string

    Return a copy of string str with all occurrences of substring
    old replaced by new. If the optional argument maxsplit is
    given, only the first maxsplit occurrences are replaced.

    """
    return s.replace(old, new, maxsplit)
</t>
<t tx="T752">@language c
/* strop module */

static char strop_module__doc__[] =
"Common string manipulations, optimized for speed.\n"
"\n"
"Always use \"import string\" rather than referencing\n"
"this module directly.";

#include "Python.h"

#include &lt;ctype.h&gt;

@ XXX This file assumes that the &lt;ctype.h&gt; is*() functions  XXX are defined for all 8-bit characters!
@c

#define WARN if (PyErr_Warn(PyExc_DeprecationWarning, \
		       "strop functions are obsolete; use string methods")) \
	     return NULL

/* The lstrip(), rstrip() and strip() functions are implemented
   in do_strip(), which uses an additional parameter to indicate what
   type of strip should occur. */

#define LEFTSTRIP 0
#define RIGHTSTRIP 1
#define BOTHSTRIP 2

@others
</t>
<t tx="T753">static PyObject *
split_whitespace(char *s, int len, int maxsplit)
{
	int i = 0, j, err;
	int countsplit = 0;
	PyObject* item;
	PyObject *list = PyList_New(0);

	if (list == NULL)
		return NULL;

	while (i &lt; len) {
		while (i &lt; len &amp;&amp; isspace(Py_CHARMASK(s[i]))) {
			i = i+1;
		}
		j = i;
		while (i &lt; len &amp;&amp; !isspace(Py_CHARMASK(s[i]))) {
			i = i+1;
		}
		if (j &lt; i) {
			item = PyString_FromStringAndSize(s+j, (int)(i-j));
			if (item == NULL)
				goto finally;

			err = PyList_Append(list, item);
			Py_DECREF(item);
			if (err &lt; 0)
				goto finally;

			countsplit++;
			while (i &lt; len &amp;&amp; isspace(Py_CHARMASK(s[i]))) {
				i = i+1;
			}
			if (maxsplit &amp;&amp; (countsplit &gt;= maxsplit) &amp;&amp; i &lt; len) {
				item = PyString_FromStringAndSize(
                                        s+i, (int)(len - i));
				if (item == NULL)
					goto finally;

				err = PyList_Append(list, item);
				Py_DECREF(item);
				if (err &lt; 0)
					goto finally;

				i = len;
			}
		}
	}
	return list;
  finally:
	Py_DECREF(list);
	return NULL;
}
</t>
<t tx="T754">static char splitfields__doc__[] =
"split(s [,sep [,maxsplit]]) -&gt; list of strings\n"
"splitfields(s [,sep [,maxsplit]]) -&gt; list of strings\n"
"\n"
"Return a list of the words in the string s, using sep as the\n"
"delimiter string.  If maxsplit is nonzero, splits into at most\n"
"maxsplit words.  If sep is not specified, any whitespace string\n"
"is a separator.  Maxsplit defaults to 0.\n"
"\n"
"(split and splitfields are synonymous)";

static PyObject *
strop_splitfields(PyObject *self, PyObject *args)
{
	int len, n, i, j, err;
	int splitcount, maxsplit;
	char *s, *sub;
	PyObject *list, *item;

	WARN;
	sub = NULL;
	n = 0;
	splitcount = 0;
	maxsplit = 0;
	if (!PyArg_ParseTuple(args, "t#|z#i:split", &amp;s, &amp;len, &amp;sub, &amp;n, &amp;maxsplit))
		return NULL;
	if (sub == NULL)
		return split_whitespace(s, len, maxsplit);
	if (n == 0) {
		PyErr_SetString(PyExc_ValueError, "empty separator");
		return NULL;
	}

	list = PyList_New(0);
	if (list == NULL)
		return NULL;

	i = j = 0;
	while (i+n &lt;= len) {
		if (s[i] == sub[0] &amp;&amp; (n == 1 || memcmp(s+i, sub, n) == 0)) {
			item = PyString_FromStringAndSize(s+j, (int)(i-j));
			if (item == NULL)
				goto fail;
			err = PyList_Append(list, item);
			Py_DECREF(item);
			if (err &lt; 0)
				goto fail;
			i = j = i + n;
			splitcount++;
			if (maxsplit &amp;&amp; (splitcount &gt;= maxsplit))
				break;
		}
		else
			i++;
	}
	item = PyString_FromStringAndSize(s+j, (int)(len-j));
	if (item == NULL)
		goto fail;
	err = PyList_Append(list, item);
	Py_DECREF(item);
	if (err &lt; 0)
		goto fail;

	return list;

 fail:
	Py_DECREF(list);
	return NULL;
}
</t>
<t tx="T755">static char joinfields__doc__[] =
"join(list [,sep]) -&gt; string\n"
"joinfields(list [,sep]) -&gt; string\n"
"\n"
"Return a string composed of the words in list, with\n"
"intervening occurrences of sep.  Sep defaults to a single\n"
"space.\n"
"\n"
"(join and joinfields are synonymous)";

static PyObject *
strop_joinfields(PyObject *self, PyObject *args)
{
	PyObject *seq;
	char *sep = NULL;
	int seqlen, seplen = 0;
	int i, reslen = 0, slen = 0, sz = 100;
	PyObject *res = NULL;
	char* p = NULL;
	intargfunc getitemfunc;

	WARN;
	if (!PyArg_ParseTuple(args, "O|t#:join", &amp;seq, &amp;sep, &amp;seplen))
		return NULL;
	if (sep == NULL) {
		sep = " ";
		seplen = 1;
	}

	seqlen = PySequence_Size(seq);
	if (seqlen &lt; 0 &amp;&amp; PyErr_Occurred())
		return NULL;

	if (seqlen == 1) {
		/* Optimization if there's only one item */
		PyObject *item = PySequence_GetItem(seq, 0);
		if (item &amp;&amp; !PyString_Check(item)) {
			PyErr_SetString(PyExc_TypeError,
				 "first argument must be sequence of strings");
			Py_DECREF(item);
			return NULL;
		}
		return item;
	}

	if (!(res = PyString_FromStringAndSize((char*)NULL, sz)))
		return NULL;
	p = PyString_AsString(res);

	/* optimize for lists, since it's the most common case.  all others
	 * (tuples and arbitrary sequences) just use the sequence abstract
	 * interface.
	 */
	if (PyList_Check(seq)) {
		for (i = 0; i &lt; seqlen; i++) {
			PyObject *item = PyList_GET_ITEM(seq, i);
			if (!PyString_Check(item)) {
				PyErr_SetString(PyExc_TypeError,
				"first argument must be sequence of strings");
				Py_DECREF(res);
				return NULL;
			}
			slen = PyString_GET_SIZE(item);
			while (reslen + slen + seplen &gt;= sz) {
				if (_PyString_Resize(&amp;res, sz * 2)) {
					Py_DECREF(res);
					return NULL;
				}
				sz *= 2;
				p = PyString_AsString(res) + reslen;
			}
			if (i &gt; 0) {
				memcpy(p, sep, seplen);
				p += seplen;
				reslen += seplen;
			}
			memcpy(p, PyString_AS_STRING(item), slen);
			p += slen;
			reslen += slen;
		}
		if (_PyString_Resize(&amp;res, reslen)) {
			Py_DECREF(res);
			res = NULL;
		}
		return res;
	}

	if (seq-&gt;ob_type-&gt;tp_as_sequence == NULL ||
		 (getitemfunc = seq-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_item) == NULL)
	{
		PyErr_SetString(PyExc_TypeError,
				"first argument must be a sequence");
		return NULL;
	}
	/* This is now type safe */
	for (i = 0; i &lt; seqlen; i++) {
		PyObject *item = getitemfunc(seq, i);
		if (!item || !PyString_Check(item)) {
			PyErr_SetString(PyExc_TypeError,
				 "first argument must be sequence of strings");
			Py_DECREF(res);
			Py_XDECREF(item);
			return NULL;
		}
		slen = PyString_GET_SIZE(item);
		while (reslen + slen + seplen &gt;= sz) {
			if (_PyString_Resize(&amp;res, sz * 2)) {
				Py_DECREF(res);
				Py_DECREF(item);
				return NULL;
			}
			sz *= 2;
			p = PyString_AsString(res) + reslen;
		}
		if (i &gt; 0) {
			memcpy(p, sep, seplen);
			p += seplen;
			reslen += seplen;
		}
		memcpy(p, PyString_AS_STRING(item), slen);
		p += slen;
		reslen += slen;
		Py_DECREF(item);
	}
	if (_PyString_Resize(&amp;res, reslen)) {
		Py_DECREF(res);
		res = NULL;
	}
	return res;
}
</t>
<t tx="T756">static char find__doc__[] =
"find(s, sub [,start [,end]]) -&gt; in\n"
"\n"
"Return the lowest index in s where substring sub is found,\n"
"such that sub is contained within s[start,end].  Optional\n"
"arguments start and end are interpreted as in slice notation.\n"
"\n"
"Return -1 on failure.";

static PyObject *
strop_find(PyObject *self, PyObject *args)
{
	char *s, *sub;
	int len, n, i = 0, last = INT_MAX;

	WARN;
	if (!PyArg_ParseTuple(args, "t#t#|ii:find", &amp;s, &amp;len, &amp;sub, &amp;n, &amp;i, &amp;last))
		return NULL;

	if (last &gt; len)
		last = len;
	if (last &lt; 0)
		last += len;
	if (last &lt; 0)
		last = 0;
	if (i &lt; 0)
		i += len;
	if (i &lt; 0)
		i = 0;

	if (n == 0 &amp;&amp; i &lt;= last)
		return PyInt_FromLong((long)i);

	last -= n;
	for (; i &lt;= last; ++i)
		if (s[i] == sub[0] &amp;&amp;
		    (n == 1 || memcmp(&amp;s[i+1], &amp;sub[1], n-1) == 0))
			return PyInt_FromLong((long)i);

	return PyInt_FromLong(-1L);
}
</t>
<t tx="T757">static char rfind__doc__[] =
"rfind(s, sub [,start [,end]]) -&gt; int\n"
"\n"
"Return the highest index in s where substring sub is found,\n"
"such that sub is contained within s[start,end].  Optional\n"
"arguments start and end are interpreted as in slice notation.\n"
"\n"
"Return -1 on failure.";

static PyObject *
strop_rfind(PyObject *self, PyObject *args)
{
	char *s, *sub;
	int len, n, j;
	int i = 0, last = INT_MAX;

	WARN;
	if (!PyArg_ParseTuple(args, "t#t#|ii:rfind", &amp;s, &amp;len, &amp;sub, &amp;n, &amp;i, &amp;last))
		return NULL;

	if (last &gt; len)
		last = len;
	if (last &lt; 0)
		last += len;
	if (last &lt; 0)
		last = 0;
	if (i &lt; 0)
		i += len;
	if (i &lt; 0)
		i = 0;

	if (n == 0 &amp;&amp; i &lt;= last)
		return PyInt_FromLong((long)last);

	for (j = last-n; j &gt;= i; --j)
		if (s[j] == sub[0] &amp;&amp;
		    (n == 1 || memcmp(&amp;s[j+1], &amp;sub[1], n-1) == 0))
			return PyInt_FromLong((long)j);

	return PyInt_FromLong(-1L);
}
</t>
<t tx="T758">static PyObject *
do_strip(PyObject *args, int striptype)
{
	char *s;
	int len, i, j;


	if (!PyArg_Parse(args, "t#", &amp;s, &amp;len))
		return NULL;

	i = 0;
	if (striptype != RIGHTSTRIP) {
		while (i &lt; len &amp;&amp; isspace(Py_CHARMASK(s[i]))) {
			i++;
		}
	}

	j = len;
	if (striptype != LEFTSTRIP) {
		do {
			j--;
		} while (j &gt;= i &amp;&amp; isspace(Py_CHARMASK(s[j])));
		j++;
	}

	if (i == 0 &amp;&amp; j == len) {
		Py_INCREF(args);
		return args;
	}
	else
		return PyString_FromStringAndSize(s+i, j-i);
}
</t>
<t tx="T759">static char strip__doc__[] =
"strip(s) -&gt; string\n"
"\n"
"Return a copy of the string s with leading and trailing\n"
"whitespace removed.";

static PyObject *
strop_strip(PyObject *self, PyObject *args)
{
	WARN;
	return do_strip(args, BOTHSTRIP);
}
</t>
<t tx="T760">static char lstrip__doc__[] =
"lstrip(s) -&gt; string\n"
"\n"
"Return a copy of the string s with leading whitespace removed.";

static PyObject *
strop_lstrip(PyObject *self, PyObject *args)
{
	WARN;
	return do_strip(args, LEFTSTRIP);
}
</t>
<t tx="T761">static char rstrip__doc__[] =
"rstrip(s) -&gt; string\n"
"\n"
"Return a copy of the string s with trailing whitespace removed.";

static PyObject *
strop_rstrip(PyObject *self, PyObject *args)
{
	WARN;
	return do_strip(args, RIGHTSTRIP);
}
</t>
<t tx="T762">static char lower__doc__[] =
"lower(s) -&gt; string\n"
"\n"
"Return a copy of the string s converted to lowercase.";

static PyObject *
strop_lower(PyObject *self, PyObject *args)
{
	char *s, *s_new;
	int i, n;
	PyObject *new;
	int changed;

	WARN;
	if (!PyArg_Parse(args, "t#", &amp;s, &amp;n))
		return NULL;
	new = PyString_FromStringAndSize(NULL, n);
	if (new == NULL)
		return NULL;
	s_new = PyString_AsString(new);
	changed = 0;
	for (i = 0; i &lt; n; i++) {
		int c = Py_CHARMASK(*s++);
		if (isupper(c)) {
			changed = 1;
			*s_new = tolower(c);
		} else
			*s_new = c;
		s_new++;
	}
	if (!changed) {
		Py_DECREF(new);
		Py_INCREF(args);
		return args;
	}
	return new;
}
</t>
<t tx="T763">static char upper__doc__[] =
"upper(s) -&gt; string\n"
"\n"
"Return a copy of the string s converted to uppercase.";

static PyObject *
strop_upper(PyObject *self, PyObject *args)
{
	char *s, *s_new;
	int i, n;
	PyObject *new;
	int changed;

	WARN;
	if (!PyArg_Parse(args, "t#", &amp;s, &amp;n))
		return NULL;
	new = PyString_FromStringAndSize(NULL, n);
	if (new == NULL)
		return NULL;
	s_new = PyString_AsString(new);
	changed = 0;
	for (i = 0; i &lt; n; i++) {
		int c = Py_CHARMASK(*s++);
		if (islower(c)) {
			changed = 1;
			*s_new = toupper(c);
		} else
			*s_new = c;
		s_new++;
	}
	if (!changed) {
		Py_DECREF(new);
		Py_INCREF(args);
		return args;
	}
	return new;
}
</t>
<t tx="T764">static char capitalize__doc__[] =
"capitalize(s) -&gt; string\n"
"\n"
"Return a copy of the string s with only its first character\n"
"capitalized.";

static PyObject *
strop_capitalize(PyObject *self, PyObject *args)
{
	char *s, *s_new;
	int i, n;
	PyObject *new;
	int changed;

	WARN;
	if (!PyArg_Parse(args, "t#", &amp;s, &amp;n))
		return NULL;
	new = PyString_FromStringAndSize(NULL, n);
	if (new == NULL)
		return NULL;
	s_new = PyString_AsString(new);
	changed = 0;
	if (0 &lt; n) {
		int c = Py_CHARMASK(*s++);
		if (islower(c)) {
			changed = 1;
			*s_new = toupper(c);
		} else
			*s_new = c;
		s_new++;
	}
	for (i = 1; i &lt; n; i++) {
		int c = Py_CHARMASK(*s++);
		if (isupper(c)) {
			changed = 1;
			*s_new = tolower(c);
		} else
			*s_new = c;
		s_new++;
	}
	if (!changed) {
		Py_DECREF(new);
		Py_INCREF(args);
		return args;
	}
	return new;
}
</t>
<t tx="T765">static char expandtabs__doc__[] =
"expandtabs(string, [tabsize]) -&gt; string\n"
"\n"
"Expand tabs in a string, i.e. replace them by one or more spaces,\n"
"depending on the current column and the given tab size (default 8).\n"
"The column number is reset to zero after each newline occurring in the\n"
"string.  This doesn't understand other non-printing characters.";

static PyObject *
strop_expandtabs(PyObject *self, PyObject *args)
{
	/* Original by Fredrik Lundh */
	char* e;
	char* p;
	char* q;
	int i, j;
	PyObject* out;
	char* string;
	int stringlen;
	int tabsize = 8;

	WARN;
	/* Get arguments */
	if (!PyArg_ParseTuple(args, "s#|i:expandtabs", &amp;string, &amp;stringlen, &amp;tabsize))
		return NULL;
	if (tabsize &lt; 1) {
		PyErr_SetString(PyExc_ValueError,
				"tabsize must be at least 1");
		return NULL;
	}

	/* First pass: determine size of output string */
	i = j = 0; /* j: current column; i: total of previous lines */
	e = string + stringlen;
	for (p = string; p &lt; e; p++) {
		if (*p == '\t')
			j += tabsize - (j%tabsize);
		else {
			j++;
			if (*p == '\n') {
				i += j;
				j = 0;
			}
		}
	}

	/* Second pass: create output string and fill it */
	out = PyString_FromStringAndSize(NULL, i+j);
	if (out == NULL)
		return NULL;

	i = 0;
	q = PyString_AS_STRING(out);

	for (p = string; p &lt; e; p++) {
		if (*p == '\t') {
			j = tabsize - (i%tabsize);
			i += j;
			while (j-- &gt; 0)
				*q++ = ' ';
		} else {
			*q++ = *p;
			i++;
			if (*p == '\n')
				i = 0;
		}
	}

	return out;
}
</t>
<t tx="T766">static char count__doc__[] =
"count(s, sub[, start[, end]]) -&gt; int\n"
"\n"
"Return the number of occurrences of substring sub in string\n"
"s[start:end].  Optional arguments start and end are\n"
"interpreted as in slice notation.";

static PyObject *
strop_count(PyObject *self, PyObject *args)
{
	char *s, *sub;
	int len, n;
	int i = 0, last = INT_MAX;
	int m, r;

	WARN;
	if (!PyArg_ParseTuple(args, "t#t#|ii:count", &amp;s, &amp;len, &amp;sub, &amp;n, &amp;i, &amp;last))
		return NULL;
	if (last &gt; len)
		last = len;
	if (last &lt; 0)
		last += len;
	if (last &lt; 0)
		last = 0;
	if (i &lt; 0)
		i += len;
	if (i &lt; 0)
		i = 0;
	m = last + 1 - n;
	if (n == 0)
		return PyInt_FromLong((long) (m-i));

	r = 0;
	while (i &lt; m) {
		if (!memcmp(s+i, sub, n)) {
			r++;
			i += n;
		} else {
			i++;
		}
	}
	return PyInt_FromLong((long) r);
}
</t>
<t tx="T767">static char swapcase__doc__[] =
"swapcase(s) -&gt; string\n"
"\n"
"Return a copy of the string s with upper case characters\n"
"converted to lowercase and vice versa.";

static PyObject *
strop_swapcase(PyObject *self, PyObject *args)
{
	char *s, *s_new;
	int i, n;
	PyObject *new;
	int changed;

	WARN;
	if (!PyArg_Parse(args, "t#", &amp;s, &amp;n))
		return NULL;
	new = PyString_FromStringAndSize(NULL, n);
	if (new == NULL)
		return NULL;
	s_new = PyString_AsString(new);
	changed = 0;
	for (i = 0; i &lt; n; i++) {
		int c = Py_CHARMASK(*s++);
		if (islower(c)) {
			changed = 1;
			*s_new = toupper(c);
		}
		else if (isupper(c)) {
			changed = 1;
			*s_new = tolower(c);
		}
		else
			*s_new = c;
		s_new++;
	}
	if (!changed) {
		Py_DECREF(new);
		Py_INCREF(args);
		return args;
	}
	return new;
}
</t>
<t tx="T768">static char atoi__doc__[] =
"atoi(s [,base]) -&gt; int\n"
"\n"
"Return the integer represented by the string s in the given\n"
"base, which defaults to 10.  The string s must consist of one\n"
"or more digits, possibly preceded by a sign.  If base is 0, it\n"
"is chosen from the leading characters of s, 0 for octal, 0x or\n"
"0X for hexadecimal.  If base is 16, a preceding 0x or 0X is\n"
"accepted.";

static PyObject *
strop_atoi(PyObject *self, PyObject *args)
{
	char *s, *end;
	int base = 10;
	long x;
	char buffer[256]; /* For errors */

	WARN;
	if (!PyArg_ParseTuple(args, "s|i:atoi", &amp;s, &amp;base))
		return NULL;

	if ((base != 0 &amp;&amp; base &lt; 2) || base &gt; 36) {
		PyErr_SetString(PyExc_ValueError, "invalid base for atoi()");
		return NULL;
	}

	while (*s &amp;&amp; isspace(Py_CHARMASK(*s)))
		s++;
	errno = 0;
	if (base == 0 &amp;&amp; s[0] == '0')
		x = (long) PyOS_strtoul(s, &amp;end, base);
	else
		x = PyOS_strtol(s, &amp;end, base);
	if (end == s || !isalnum(end[-1]))
		goto bad;
	while (*end &amp;&amp; isspace(Py_CHARMASK(*end)))
		end++;
	if (*end != '\0') {
  bad:
		PyOS_snprintf(buffer, sizeof(buffer),
			      "invalid literal for atoi(): %.200s", s);
		PyErr_SetString(PyExc_ValueError, buffer);
		return NULL;
	}
	else if (errno != 0) {
		PyOS_snprintf(buffer, sizeof(buffer), 
			      "atoi() literal too large: %.200s", s);
		PyErr_SetString(PyExc_ValueError, buffer);
		return NULL;
	}
	return PyInt_FromLong(x);
}
</t>
<t tx="T769">static char atol__doc__[] =
"atol(s [,base]) -&gt; long\n"
"\n"
"Return the long integer represented by the string s in the\n"
"given base, which defaults to 10.  The string s must consist\n"
"of one or more digits, possibly preceded by a sign.  If base\n"
"is 0, it is chosen from the leading characters of s, 0 for\n"
"octal, 0x or 0X for hexadecimal.  If base is 16, a preceding\n"
"0x or 0X is accepted.  A trailing L or l is not accepted,\n"
"unless base is 0.";

static PyObject *
strop_atol(PyObject *self, PyObject *args)
{
	char *s, *end;
	int base = 10;
	PyObject *x;
	char buffer[256]; /* For errors */

	WARN;
	if (!PyArg_ParseTuple(args, "s|i:atol", &amp;s, &amp;base))
		return NULL;

	if ((base != 0 &amp;&amp; base &lt; 2) || base &gt; 36) {
		PyErr_SetString(PyExc_ValueError, "invalid base for atol()");
		return NULL;
	}

	while (*s &amp;&amp; isspace(Py_CHARMASK(*s)))
		s++;
	if (s[0] == '\0') {
		PyErr_SetString(PyExc_ValueError, "empty string for atol()");
		return NULL;
	}
	x = PyLong_FromString(s, &amp;end, base);
	if (x == NULL)
		return NULL;
	if (base == 0 &amp;&amp; (*end == 'l' || *end == 'L'))
		end++;
	while (*end &amp;&amp; isspace(Py_CHARMASK(*end)))
		end++;
	if (*end != '\0') {
		PyOS_snprintf(buffer, sizeof(buffer),
			      "invalid literal for atol(): %.200s", s);
		PyErr_SetString(PyExc_ValueError, buffer);
		Py_DECREF(x);
		return NULL;
	}
	return x;
}
</t>
<t tx="T770">static char atof__doc__[] =
"atof(s) -&gt; float\n"
"\n"
"Return the floating point number represented by the string s.";

static PyObject *
strop_atof(PyObject *self, PyObject *args)
{
	extern double strtod(const char *, char **);
	char *s, *end;
	double x;
	char buffer[256]; /* For errors */

	WARN;
	if (!PyArg_ParseTuple(args, "s:atof", &amp;s))
		return NULL;
	while (*s &amp;&amp; isspace(Py_CHARMASK(*s)))
		s++;
	if (s[0] == '\0') {
		PyErr_SetString(PyExc_ValueError, "empty string for atof()");
		return NULL;
	}
	errno = 0;
	PyFPE_START_PROTECT("strop_atof", return 0)
	x = strtod(s, &amp;end);
	PyFPE_END_PROTECT(x)
	while (*end &amp;&amp; isspace(Py_CHARMASK(*end)))
		end++;
	if (*end != '\0') {
		PyOS_snprintf(buffer, sizeof(buffer),
			      "invalid literal for atof(): %.200s", s);
		PyErr_SetString(PyExc_ValueError, buffer);
		return NULL;
	}
	else if (errno != 0) {
		PyOS_snprintf(buffer, sizeof(buffer), 
			      "atof() literal too large: %.200s", s);
		PyErr_SetString(PyExc_ValueError, buffer);
		return NULL;
	}
	return PyFloat_FromDouble(x);
}
</t>
<t tx="T771">static char maketrans__doc__[] =
"maketrans(frm, to) -&gt; string\n"
"\n"
"Return a translation table (a string of 256 bytes long)\n"
"suitable for use in string.translate.  The strings frm and to\n"
"must be of the same length.";

static PyObject *
strop_maketrans(PyObject *self, PyObject *args)
{
	unsigned char *c, *from=NULL, *to=NULL;
	int i, fromlen=0, tolen=0;
	PyObject *result;

	if (!PyArg_ParseTuple(args, "t#t#:maketrans", &amp;from, &amp;fromlen, &amp;to, &amp;tolen))
		return NULL;

	if (fromlen != tolen) {
		PyErr_SetString(PyExc_ValueError,
				"maketrans arguments must have same length");
		return NULL;
	}

	result = PyString_FromStringAndSize((char *)NULL, 256);
	if (result == NULL)
		return NULL;
	c = (unsigned char *) PyString_AS_STRING((PyStringObject *)result);
	for (i = 0; i &lt; 256; i++)
		c[i]=(unsigned char)i;
	for (i = 0; i &lt; fromlen; i++)
		c[from[i]]=to[i];

	return result;
}
</t>
<t tx="T772">static char translate__doc__[] =
"translate(s,table [,deletechars]) -&gt; string\n"
"\n"
"Return a copy of the string s, where all characters occurring\n"
"in the optional argument deletechars are removed, and the\n"
"remaining characters have been mapped through the given\n"
"translation table, which must be a string of length 256.";

static PyObject *
strop_translate(PyObject *self, PyObject *args)
{
	register char *input, *table, *output;
	register int i, c, changed = 0;
	PyObject *input_obj;
	char *table1, *output_start, *del_table=NULL;
	int inlen, tablen, dellen = 0;
	PyObject *result;
	int trans_table[256];

	WARN;
	if (!PyArg_ParseTuple(args, "St#|t#:translate", &amp;input_obj,
			      &amp;table1, &amp;tablen, &amp;del_table, &amp;dellen))
		return NULL;
	if (tablen != 256) {
		PyErr_SetString(PyExc_ValueError,
			      "translation table must be 256 characters long");
		return NULL;
	}

	table = table1;
	inlen = PyString_Size(input_obj);
	result = PyString_FromStringAndSize((char *)NULL, inlen);
	if (result == NULL)
		return NULL;
	output_start = output = PyString_AsString(result);
	input = PyString_AsString(input_obj);

	if (dellen == 0) {
		/* If no deletions are required, use faster code */
		for (i = inlen; --i &gt;= 0; ) {
			c = Py_CHARMASK(*input++);
			if (Py_CHARMASK((*output++ = table[c])) != c)
				changed = 1;
		}
		if (changed)
			return result;
		Py_DECREF(result);
		Py_INCREF(input_obj);
		return input_obj;
	}

	for (i = 0; i &lt; 256; i++)
		trans_table[i] = Py_CHARMASK(table[i]);

	for (i = 0; i &lt; dellen; i++)
		trans_table[(int) Py_CHARMASK(del_table[i])] = -1;

	for (i = inlen; --i &gt;= 0; ) {
		c = Py_CHARMASK(*input++);
		if (trans_table[c] != -1)
			if (Py_CHARMASK(*output++ = (char)trans_table[c]) == c)
				continue;
		changed = 1;
	}
	if (!changed) {
		Py_DECREF(result);
		Py_INCREF(input_obj);
		return input_obj;
	}
	/* Fix the size of the resulting string */
	if (inlen &gt; 0 &amp;&amp;_PyString_Resize(&amp;result, output-output_start))
		return NULL;
	return result;
}
</t>
<t tx="T773">@ What follows is used for implementing replace(). Perry Stoll.
mymemfind  strstr replacement for arbitrary blocks of memory.  Locates the first occurrence in the memory pointed to by MEM of the  contents of memory pointed to by PAT. Returns the index into MEM if  found, or -1 if not found. If len of PAT is greater than length of  MEM, the function returns -1.
@c

static int 
mymemfind(const char *mem, int len, const char *pat, int pat_len)
{
	register int ii;

	/* pattern can not occur in the last pat_len-1 chars */
	len -= pat_len;

	for (ii = 0; ii &lt;= len; ii++) {
		if (mem[ii] == pat[0] &amp;&amp;
		    (pat_len == 1 ||
		     memcmp(&amp;mem[ii+1], &amp;pat[1], pat_len-1) == 0)) {
			return ii;
		}
	}
	return -1;
}
</t>
<t tx="T774">@ mymemcnt   Return the number of distinct times PAT is found in MEM.  meaning mem=1111 and pat==11 returns 2.      mem=11111 and pat==11 also return 2.
@c

static int 
mymemcnt(const char *mem, int len, const char *pat, int pat_len)
{
	register int offset = 0;
	int nfound = 0;

	while (len &gt;= 0) {
		offset = mymemfind(mem, len, pat, pat_len);
		if (offset == -1)
			break;
		mem += offset + pat_len;
		len -= offset + pat_len;
		nfound++;
	}
	return nfound;
}
</t>
<t tx="T775">@ mymemreplace   Return a string in which all occurrences of PAT in memory STR are  replaced with SUB.   If length of PAT is less than length of STR or there are no occurrences  of PAT in STR, then the original string is returned. Otherwise, a new  string is allocated here and returned.   on return, out_len is:    the length of output string, or    -1 if the input string is returned, or    unchanged if an error occurs (no memory).   return value is:    the new string allocated locally, or    NULL if an error occurred.
@c

static char *
mymemreplace(const char *str, int len,		/* input string */
             const char *pat, int pat_len,	/* pattern string to find */
             const char *sub, int sub_len,	/* substitution string */
             int count,				/* number of replacements */
	     int *out_len)
{
	char *out_s;
	char *new_s;
	int nfound, offset, new_len;

	if (len == 0 || pat_len &gt; len)
		goto return_same;

	/* find length of output string */
	nfound = mymemcnt(str, len, pat, pat_len);
	if (count &lt; 0)
		count = INT_MAX;
	else if (nfound &gt; count)
		nfound = count;
	if (nfound == 0)
		goto return_same;

	new_len = len + nfound*(sub_len - pat_len);
	if (new_len == 0) {
		/* Have to allocate something for the caller to free(). */
		out_s = (char *)PyMem_MALLOC(1);
		if (out_s == NULL)
			return NULL;
		out_s[0] = '\0';
	}
	else {
		assert(new_len &gt; 0);
		new_s = (char *)PyMem_MALLOC(new_len);
		if (new_s == NULL)
			return NULL;
		out_s = new_s;

		for (; count &gt; 0 &amp;&amp; len &gt; 0; --count) {
			/* find index of next instance of pattern */
			offset = mymemfind(str, len, pat, pat_len);
			if (offset == -1)
				break;

			/* copy non matching part of input string */
			memcpy(new_s, str, offset);
			str += offset + pat_len;
			len -= offset + pat_len;

			/* copy substitute into the output string */
			new_s += offset;
			memcpy(new_s, sub, sub_len);
			new_s += sub_len;
		}
		/* copy any remaining values into output string */
		if (len &gt; 0)
			memcpy(new_s, str, len);
	}
	*out_len = new_len;
	return out_s;

  return_same:
	*out_len = -1;
	return (char *)str; /* cast away const */
}
</t>
<t tx="T776">static char replace__doc__[] =
"replace (str, old, new[, maxsplit]) -&gt; string\n"
"\n"
"Return a copy of string str with all occurrences of substring\n"
"old replaced by new. If the optional argument maxsplit is\n"
"given, only the first maxsplit occurrences are replaced.";

static PyObject *
strop_replace(PyObject *self, PyObject *args)
{
	char *str, *pat,*sub,*new_s;
	int len,pat_len,sub_len,out_len;
	int count = -1;
	PyObject *new;

	WARN;
	if (!PyArg_ParseTuple(args, "t#t#t#|i:replace",
			      &amp;str, &amp;len, &amp;pat, &amp;pat_len, &amp;sub, &amp;sub_len,
			      &amp;count))
		return NULL;
	if (pat_len &lt;= 0) {
		PyErr_SetString(PyExc_ValueError, "empty pattern string");
		return NULL;
	}
	/* CAUTION:  strop treats a replace count of 0 as infinity, unlke
	 * current (2.1) string.py and string methods.  Preserve this for
	 * ... well, hard to say for what &lt;wink&gt;.
	 */
	if (count == 0)
		count = -1;
	new_s = mymemreplace(str,len,pat,pat_len,sub,sub_len,count,&amp;out_len);
	if (new_s == NULL) {
		PyErr_NoMemory();
		return NULL;
	}
	if (out_len == -1) {
		/* we're returning another reference to the input string */
		new = PyTuple_GetItem(args, 0);
		Py_XINCREF(new);
	}
	else {
		new = PyString_FromStringAndSize(new_s, out_len);
		PyMem_FREE(new_s);
	}
	return new;
}
</t>
<t tx="T777">@ List of functions defined in the module
@c

static PyMethodDef
strop_methods[] = {
	{"atof",	strop_atof,	   METH_VARARGS, atof__doc__},
	{"atoi",	strop_atoi,	   METH_VARARGS, atoi__doc__},
	{"atol",	strop_atol,	   METH_VARARGS, atol__doc__},
	{"capitalize",	strop_capitalize,  METH_OLDARGS, capitalize__doc__},
	{"count",	strop_count,	   METH_VARARGS, count__doc__},
	{"expandtabs",	strop_expandtabs,  METH_VARARGS, expandtabs__doc__},
	{"find",	strop_find,	   METH_VARARGS, find__doc__},
	{"join",	strop_joinfields,  METH_VARARGS, joinfields__doc__},
	{"joinfields",	strop_joinfields,  METH_VARARGS, joinfields__doc__},
	{"lstrip",	strop_lstrip,	   METH_OLDARGS, lstrip__doc__},
	{"lower",	strop_lower,	   METH_OLDARGS, lower__doc__},
	{"maketrans",	strop_maketrans,   METH_VARARGS, maketrans__doc__},
	{"replace",	strop_replace,	   METH_VARARGS, replace__doc__},
	{"rfind",	strop_rfind,	   METH_VARARGS, rfind__doc__},
	{"rstrip",	strop_rstrip,	   METH_OLDARGS, rstrip__doc__},
	{"split",	strop_splitfields, METH_VARARGS, splitfields__doc__},
	{"splitfields",	strop_splitfields, METH_VARARGS, splitfields__doc__},
	{"strip",	strop_strip,	   METH_OLDARGS, strip__doc__},
	{"swapcase",	strop_swapcase,    METH_OLDARGS, swapcase__doc__},
	{"translate",	strop_translate,   METH_VARARGS, translate__doc__},
	{"upper",	strop_upper,	   METH_OLDARGS, upper__doc__},
	{NULL,		NULL}	/* sentinel */
};


DL_EXPORT(void)
initstrop(void)
{
	PyObject *m, *d, *s;
	char buf[256];
	int c, n;
	m = Py_InitModule4("strop", strop_methods, strop_module__doc__,
			   (PyObject*)NULL, PYTHON_API_VERSION);
	d = PyModule_GetDict(m);

	/* Create 'whitespace' object */
	n = 0;
	for (c = 0; c &lt; 256; c++) {
		if (isspace(c))
			buf[n++] = c;
	}
	s = PyString_FromStringAndSize(buf, n);
	if (s) {
		PyDict_SetItemString(d, "whitespace", s);
		Py_DECREF(s);
	}
	/* Create 'lowercase' object */
	n = 0;
	for (c = 0; c &lt; 256; c++) {
		if (islower(c))
			buf[n++] = c;
	}
	s = PyString_FromStringAndSize(buf, n);
	if (s) {
		PyDict_SetItemString(d, "lowercase", s);
		Py_DECREF(s);
	}

	/* Create 'uppercase' object */
	n = 0;
	for (c = 0; c &lt; 256; c++) {
		if (isupper(c))
			buf[n++] = c;
	}
	s = PyString_FromStringAndSize(buf, n);
	if (s) {
		PyDict_SetItemString(d, "uppercase", s);
		Py_DECREF(s);
	}
}
</t>
<t tx="T778">@ignore
@language c</t>
<t tx="T779">@color</t>
<t tx="T780">#define PyEval_CallObject(func,arg) \
    PyEval_CallObjectWithKeywords(func, arg, (PyObject *)NULL)

PyObject *
PyEval_CallObjectWithKeywords(PyObject *func, PyObject *arg, PyObject *kw)
{
	PyObject *result;

	if (arg == NULL)
		arg = PyTuple_New(0);
	else if (!PyTuple_Check(arg)) {
		PyErr_SetString(PyExc_TypeError,
				"argument list must be a tuple");
		return NULL;
	}
	else
		Py_INCREF(arg);

	if (kw != NULL &amp;&amp; !PyDict_Check(kw)) {
		PyErr_SetString(PyExc_TypeError,
				"keyword list must be a dictionary");
		Py_DECREF(arg);
		return NULL;
	}

	result = PyObject_Call(func, arg, kw);
	Py_DECREF(arg);
	return result;
}
</t>
<t tx="T781">@ External interface to call any callable object. The arg must be a tuple or NULL. */
@c

#undef PyEval_CallObject
/* for backward compatibility: export this interface */

PyObject *
PyEval_CallObject(PyObject *func, PyObject *arg)
{
	return PyEval_CallObjectWithKeywords(func, arg, (PyObject *)NULL);
}
</t>
<t tx="T782">import string
import string as s
from string import strip
from string import *</t>
<t tx="T783">@nocolor

I am writing this post on the theory that teaching something is the
best way to learn it myself.  If I have made any blunders I'm sure the
wizards will let me know gently :-)

Section 18, Python Language Services, of the Python Library Reference
contains information related to the interpreter and the compiler.
http://python.org/doc/current/lib/language.html

The primary documentation for opcodes appears to be in the documentation of
the dis (disassembler) module, section 18.10.1 of the Python Library
Reference: http://python.org/doc/current/lib/bytecodes.html

Although it seems very low level, I agree that looking at disassemblies is
actually very useful because you'll see what gets pushed and pulled from the
interpreter's stack by various constructs.  That in turn makes the
interpreter code much easier to figure out.

Python/ceval.c contains the interpreter proper. The cases for various
opcodes call two kinds of routines:  local (static) helper routines in
Python/ceval.c and routines of the C API. Therefore, an intimate knowledge
of just about everything in http://python.org/doc/current/api/api.html would
be good :-)

The quick way to get the documentation for the public routines is via the
P index page of the C API:
http://python.org/doc/current/api/genindex.html#letter-p
For example, PyDict_GetItemString is called early in one of the
interpreter's import cases. The documentation is accessible from the index
page, and clicking on the link takes us to
http://python.org/doc/current/api/dictObjects.html#l2h-530

However, "internal" C API routines (routines not meant to be used by the
general public) are not documented in the index.  For these, you must go to
the source.  The Include, Object, Modules and Python directories are the
first places to look for sources.  It's usually not too difficult to guess
where code is.

An earlier draft of this posting actually went step-by-step through the
interpreter code for the import cases.  I've eliminated it because it was
loooooong.  But that's where you might start:  just dive into the code and
figure out what every line does for some case you are interested in. Don't
take shortcuts: really understand every line of code--where it is defined,
where it is documented and what it really does.  As you get more experience,
you might be able to shortcut this step-by-step process, but at first I
recommend absolute thoroughness.  Anyway, that's what I am doing :-)

For the IMPORT_NAME case you'll end up at builtin___import__ in
Python/bltinmodule.c which in turn takes you to PyImport_ImportModuleEx in
Python/import.c.  The actual work is done in a helper routine called
import_module_ex.  I suspect that if you understand import_module_ex you
will understand everything there is to know about this kind of import.
Indeed, the leading comment for import_module_ex is
/* The Magnum Opus of dotted-name import :-) */</t>
<t tx="T784">@nocolor

</t>
<t tx="T785">To see how this works in practice, let's look at something interesting, like
imports.  This following will get overwhelming very quickly unless we are
absolutely clear about what the big picture is.

To get the big (and accurate) picture, we start first at the Python Language
Referece: http://python.org/doc/current/ref/ref.html
In our case, the relevant section is Section 6.12, The Import Statement.
This is essentially the code-level documentation for the interpreter cases
below. Have this documentation handy while browsing through the code.</t>
<t tx="T786">Now that we have the highest-level documentation in hand (or in our mind),
we get the documentation for the opcodes from the dis documentation and the
actual code from ceval.c

IMPORT_STAR
Loads all symbols not starting with "_" directly from the module TOS to the
local namespace. The module is popped after loading all names. This opcode
implements from module import *.

case IMPORT_STAR:
 v = POP();
 PyFrame_FastToLocals(f);
 if ((x = f-&gt;f_locals) == NULL) {
  PyErr_SetString(PyExc_SystemError,
   "no locals found during 'import *'");
  break;
 }
 err = import_all_from(x, v);
 PyFrame_LocalsToFast(f, 0);
 Py_DECREF(v);
 if (err == 0) continue;
 break;

IMPORT_NAME namei
Imports the module co_names[namei]. The module object is pushed onto the
stack. The current namespace is not affected: for a proper import statement,
a subsequent STORE_FAST instruction modifies the namespace.

case IMPORT_NAME:
 w = GETNAMEV(oparg);
 x = PyDict_GetItemString(f-&gt;f_builtins, "__import__");
 if (x == NULL) {
  PyErr_SetString(PyExc_ImportError,
    "__import__ not found");
  break;
 }
 u = POP();
 w = Py_BuildValue("(OOOO)",
      w,
      f-&gt;f_globals,
      f-&gt;f_locals == NULL ?
     Py_None : f-&gt;f_locals,
      u);
 Py_DECREF(u);
 if (w == NULL) {
  x = NULL;
  break;
 }
 x = PyEval_CallObject(x, w);
 Py_DECREF(w);
 PUSH(x);
 if (x != NULL) continue;
 break;

IMPORT_FROM namei
Loads the attribute co_names[namei] from the module found in TOS. The
resulting object is pushed onto the stack, to be subsequently stored by a
STORE_FAST instruction.

case IMPORT_FROM:
 w = GETNAMEV(oparg);
 v = TOP();
 x = import_from(v, w);
 PUSH(x);
 if (x != NULL) continue;
 break;
</t>
<t tx="T787">The IMPORT_FROM and IMPORT_STAR cases call the local helper routines called
import_from and import_star.  Here they are:

static PyObject *
import_from(PyObject *v, PyObject *name)
{
 PyObject *x;

 x = PyObject_GetAttr(v, name);
 if (x == NULL &amp;&amp; PyErr_ExceptionMatches(PyExc_AttributeError)) {
  PyErr_Format(PyExc_ImportError,
        "cannot import name %.230s",
        PyString_AsString(name));
 }
 return x;
}

static int
import_all_from(PyObject *locals, PyObject *v)
{
 PyObject *all = PyObject_GetAttrString(v, "__all__");
 PyObject *dict, *name, *value;
 int skip_leading_underscores = 0;
 int pos, err;

 if (all == NULL) {
  if (!PyErr_ExceptionMatches(PyExc_AttributeError))
   return -1; /* Unexpected error */
  PyErr_Clear();
  dict = PyObject_GetAttrString(v, "__dict__");
  if (dict == NULL) {
   if (!PyErr_ExceptionMatches(PyExc_AttributeError))
    return -1;
   PyErr_SetString(PyExc_ImportError,
   "from-import-* object has no __dict__ and no __all__");
   return -1;
  }
  all = PyMapping_Keys(dict);
  Py_DECREF(dict);
  if (all == NULL)
   return -1;
  skip_leading_underscores = 1;
 }

 for (pos = 0, err = 0; ; pos++) {
  name = PySequence_GetItem(all, pos);
  if (name == NULL) {
   if (!PyErr_ExceptionMatches(PyExc_IndexError))
    err = -1;
   else
    PyErr_Clear();
   break;
  }
  if (skip_leading_underscores &amp;&amp;
      PyString_Check(name) &amp;&amp;
      PyString_AS_STRING(name)[0] == '_')
  {
   Py_DECREF(name);
   continue;
  }
  value = PyObject_GetAttr(v, name);
  if (value == NULL)
   err = -1;
  else
   err = PyDict_SetItem(locals, name, value);
  Py_DECREF(name);
  Py_XDECREF(value);
  if (err != 0)
   break;
 }
 Py_DECREF(all);
 return err;
}</t>
<t tx="T788">The IMPORT_STAR code above contains calls to PyFrame_FastToLocals and PyFrame_LocalsToFast.  Look for such routines in
the Parser, Objects or Modules folders of the Python distribution.  The actual code for PyFrame_FastToLocals is:

void
PyFrame_FastToLocals(PyFrameObject *f)
{
 /* Merge fast locals into f-&gt;f_locals */
 PyObject *locals, *map;
 PyObject **fast;
 PyObject *error_type, *error_value, *error_traceback;
 int j;
 if (f == NULL)
  return;
 locals = f-&gt;f_locals;
 if (locals == NULL) {
  locals = f-&gt;f_locals = PyDict_New();
  if (locals == NULL) {
   PyErr_Clear(); /* Can't report it :-( */
   return;
  }
 }
 if (f-&gt;f_nlocals == 0)
  return;
 map = f-&gt;f_code-&gt;co_varnames;
 if (!PyDict_Check(locals) || !PyTuple_Check(map))
  return;
 PyErr_Fetch(&amp;error_type, &amp;error_value, &amp;error_traceback);
 fast = f-&gt;f_localsplus;
 j = PyTuple_Size(map);
 if (j &gt; f-&gt;f_nlocals)
  j = f-&gt;f_nlocals;
 map_to_dict(map, j, locals, fast, 0);
 if (f-&gt;f_ncells || f-&gt;f_nfreevars) {
  if (!(PyTuple_Check(f-&gt;f_code-&gt;co_cellvars)
        &amp;&amp; PyTuple_Check(f-&gt;f_code-&gt;co_freevars))) {
   Py_DECREF(locals);
   return;
  }
  map_to_dict(f-&gt;f_code-&gt;co_cellvars,
       PyTuple_GET_SIZE(f-&gt;f_code-&gt;co_cellvars),
       locals, fast + f-&gt;f_nlocals, 1);
  map_to_dict(f-&gt;f_code-&gt;co_freevars,
       PyTuple_GET_SIZE(f-&gt;f_code-&gt;co_freevars),
       locals, fast + f-&gt;f_nlocals + f-&gt;f_ncells, 1);
 }
 PyErr_Restore(error_type, error_value, error_traceback);
}

Once again, this code calls static helper routines like map_to_dict as well
as other public C API routines, like PyTuple_Size, but we have to stop
somewhere...</t>
<t tx="T789">How does the actual code implement the import statements?

In the IMPORT_NAME case, the guts are:

 w = GETNAMEV(oparg);
 x = PyDict_GetItemString(f-&gt;f_builtins, "__import__");
 u = POP();
 w = Py_BuildValue("(OOOO)",
      w,
      f-&gt;f_globals,
      f-&gt;f_locals == NULL ? Py_None : f-&gt;f_locals,
      u);
 x = PyEval_CallObject(x, w);

Our task is to understand exactly how and why these three statements implement import.

1. w = GETNAMEV(oparg);

w is the oparg argument to GETNAMEV, i.e., the name of the module to import.

2. x = PyDict_GetItemString(f-&gt;f_builtins, "__import__");

PyDict_GetItemString returns the entry in the f-&gt;f_builtins dict corresponding to __import__.  This will be a builtin function, not a string, as the name PyDict_GetItemString might lead one to think.  In short, x is the __import__ builtin function.

3. u = POP();

u is what was on the top of the stack. Apparently u will be an argument to __import__ ...

To find out, I created a test file containing:

  import string
  import string as s
  from string import strip
  from string import *

I used the following in the IDLE to get the raw code from the file, that is,
the code that exists _before_ the import is actually executed!

  import compile,dis
  f = open(fn)
  source = f.read()
  code = compile(source, fn, "exec")
  dis.dis(code)

the disassembly is:

          6 LOAD_CONST               0 (None)
          9 IMPORT_NAME              0 (string)
         12 STORE_NAME               0 (string)

         18 LOAD_CONST               0 (None)
         21 IMPORT_NAME              0 (string)
         24 STORE_NAME               1 (s)

         30 LOAD_CONST               1 (('strip',))
         33 IMPORT_NAME              0 (string)
         36 IMPORT_FROM              2 (strip)
         39 STORE_NAME               2 (strip)
         42 POP_TOP

         46 LOAD_CONST               2 (('*',))
         49 IMPORT_NAME              0 (string)
         52 IMPORT_STAR
         53 LOAD_CONST               0 (None)
         56 RETURN_VALUE

So the u parameter is whatever gets pushed on the stack with the LOAD_CONST
that immediately precedes the IMPORT_NAME opcode.  We see that the u
parameter is either None or a tuple of the names to be added to the
dictionary.  Also, the "as" parameter affects only the argument to the
STORE_NAME opcode that follows the IMPORT_NAME opcode.

4. w = Py_BuildValue("(OOOO)",
      w,
      f-&gt;f_globals,
      f-&gt;f_locals == NULL ? Py_None : f-&gt;f_locals,
      u);

"O" (object) [PyObject *] 
Pass a Python object untouched (except for its reference count, which is incremented by one). If the object passed in is a NULL pointer, it is assumed that this was caused because the call producing the argument found an error and set an exception. Therefore, Py_BuildValue() will return NULL but won't raise an exception. If no exception has been raised yet, PyExc_SystemError is set. 

So this creates a tuple of 4 objects (pointers)

5.  x = PyEval_CallObject(x, w);

6. The __import__ builtin.

Let's find the __import__ builtin and see what
it does with the u param.  So where do we find the __import__ builtin?  I
first tried Python/import.c.  For the PyImport_Import function I found the
following comment:

/* Higher-level import emulator which emulates the "import" statement
   more accurately -- it invokes the __import__() function from the
   builtins of the current globals.  This means that the import is
   done using whatever import hooks are installed in the current
   environment, e.g. by "rexec".
   A dummy list ["__doc__"] is passed as the 4th argument so that
   e.g. PyImport_Import(PyString_FromString("win32com.client.gencache"))
   will return &lt;module "gencache"&gt; instead of &lt;module "win32com"&gt;. */

So we are getting warm.  We'll want to remember PyImport_Import for later
study, as it will no doubt be helpful to see how the C API emulates
import... But back to the task at hand.  The code for PyImport_Import
obviously will eventually get to the builtin through a dict somewhere, but
were does it all lead?

Ah, here we are.  Python/bltinmodule.c looks like the file.  Doing a search
on __import__ yeilds:

static PyObject *
builtin___import__(PyObject *self, PyObject *args)
{
 char *name;
 PyObject *globals = NULL;
 PyObject *locals = NULL;
 PyObject *fromlist = NULL;

 if (!PyArg_ParseTuple(args, "s|OOO:__import__",
   &amp;name, &amp;globals, &amp;locals, &amp;fromlist))
  return NULL;
 return PyImport_ImportModuleEx(name, globals, locals, fromlist);
}

This is the real __import__ function.  Indeed, it exists in the builtin
methods table.

static PyMethodDef builtin_methods[] = {
  {"__import__", builtin___import__, METH_VARARGS, import_doc},
  ...
}

--------------------------------

What does the call to PyArg_ParseTuple do?


--------------------------------

So it looks like u is the "fromlist" passed to PyImport_ImportModuleEx.
Going back to Python/import.c (we weren't far off after all), we see the
following code for PyImport_ImportModuleEx:

PyObject *
PyImport_ImportModuleEx(char *name, PyObject *globals, PyObject *locals,
   PyObject *fromlist)
{
 PyObject *result;
 lock_import();
 result = import_module_ex(name, globals, locals, fromlist);
 unlock_import();
 return result;
}

and

static PyObject *
import_module_ex(char *name, PyObject *globals, PyObject *locals,
   PyObject *fromlist)
{
 char buf[MAXPATHLEN+1];
 int buflen = 0;
 PyObject *parent, *head, *next, *tail;

 parent = get_parent(globals, buf, &amp;buflen);
 if (parent == NULL)
  return NULL;

 head = load_next(parent, Py_None, &amp;name, buf, &amp;buflen);
 if (head == NULL)
  return NULL;

 tail = head;
 Py_INCREF(tail);
 while (name) {
  next = load_next(tail, tail, &amp;name, buf, &amp;buflen);
  Py_DECREF(tail);
  if (next == NULL) {
   Py_DECREF(head);
   return NULL;
  }
  tail = next;
 }

 if (fromlist != NULL) {
  if (fromlist == Py_None || !PyObject_IsTrue(fromlist))
   fromlist = NULL;
 }

 if (fromlist == NULL) {
  Py_DECREF(tail);
  return head;
 }

 Py_DECREF(head);
 if (!ensure_fromlist(tail, fromlist, buf, buflen, 0)) {
  Py_DECREF(tail);
  return NULL;
 }

 return tail;
}

etc.</t>
<t tx="T790">case IMPORT_NAME:
	w = GETNAMEV(oparg);
	x = PyDict_GetItemString(f-&gt;f_builtins, "__import__");
	if (x == NULL) {
		PyErr_SetString(PyExc_ImportError,
				"__import__ not found");
		break;
	}
	u = POP();
	w = Py_BuildValue("(OOOO)",
		    w,
		    f-&gt;f_globals,
		    f-&gt;f_locals == NULL ?
			  Py_None : f-&gt;f_locals,
		    u);
	Py_DECREF(u);
	if (w == NULL) {
		x = NULL;
		break;
	}
	x = PyEval_CallObject(x, w);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case IMPORT_STAR:
	v = POP();
	PyFrame_FastToLocals(f);
	if ((x = f-&gt;f_locals) == NULL) {
		PyErr_SetString(PyExc_SystemError,
			"no locals found during 'import *'");
		break;
	}
	err = import_all_from(x, v);
	PyFrame_LocalsToFast(f, 0);
	Py_DECREF(v);
	if (err == 0) continue;
	break;

case IMPORT_FROM:
	w = GETNAMEV(oparg);
	v = TOP();
	x = import_from(v, w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T791"></t>
<t tx="T792">static PyObject *
import_from(PyObject *v, PyObject *name)
{
	PyObject *x;

	x = PyObject_GetAttr(v, name);
	if (x == NULL &amp;&amp; PyErr_ExceptionMatches(PyExc_AttributeError)) {
		PyErr_Format(PyExc_ImportError,
			     "cannot import name %.230s",
			     PyString_AsString(name));
	}
	return x;
}
</t>
<t tx="T793">static int
import_all_from(PyObject *locals, PyObject *v)
{
	PyObject *all = PyObject_GetAttrString(v, "__all__");
	PyObject *dict, *name, *value;
	int skip_leading_underscores = 0;
	int pos, err;

	if (all == NULL) {
		if (!PyErr_ExceptionMatches(PyExc_AttributeError))
			return -1; /* Unexpected error */
		PyErr_Clear();
		dict = PyObject_GetAttrString(v, "__dict__");
		if (dict == NULL) {
			if (!PyErr_ExceptionMatches(PyExc_AttributeError))
				return -1;
			PyErr_SetString(PyExc_ImportError,
			"from-import-* object has no __dict__ and no __all__");
			return -1;
		}
		all = PyMapping_Keys(dict);
		Py_DECREF(dict);
		if (all == NULL)
			return -1;
		skip_leading_underscores = 1;
	}

	for (pos = 0, err = 0; ; pos++) {
		name = PySequence_GetItem(all, pos);
		if (name == NULL) {
			if (!PyErr_ExceptionMatches(PyExc_IndexError))
				err = -1;
			else
				PyErr_Clear();
			break;
		}
		if (skip_leading_underscores &amp;&amp;
		    PyString_Check(name) &amp;&amp;
		    PyString_AS_STRING(name)[0] == '_')
		{
			Py_DECREF(name);
			continue;
		}
		value = PyObject_GetAttr(v, name);
		if (value == NULL)
			err = -1;
		else
			err = PyDict_SetItem(locals, name, value);
		Py_DECREF(name);
		Py_XDECREF(value);
		if (err != 0)
			break;
	}
	Py_DECREF(all);
	return err;
}
</t>
<t tx="T794">@ignore
@language c</t>
<t tx="T795"></t>
<t tx="T796">why = WHY_NOT; err = 0;
w = NULL; x = Py_None;	/* Not a reference, just anything non-NULL */
for (;;) {

	if (things_to_do || --tstate-&gt;ticker &lt; 0)
		{ /* handle periodic things */ }

	opcode = NEXTOP();        // opcode = *next_instr++

	if (HAS_ARG(opcode))      // if (opcode &gt;= HAVE_ARGUMENT)
		oparg = NEXTARG();    //	{ next_instr += 2 ; oparg = ((next_instr[-1] &lt;&lt; 8) + next_instr[-2]) }

	dispatch_opcode: // EKR: only the EXTENDED_ARG case jumps here.
		
	switch (opcode)
		{ /* opcode cases */ }

	// Many common cases end with continue.
	// We only get here when cases end in break,
	// so the speed of this code is not crucial.
	if (why == WHY_NOT)
		if (err == 0 &amp;&amp; x != NULL)
			continue; /* Normal, fast path */
}</t>
<t tx="T797"></t>
<t tx="T798">// EKR: The actual macros eliminate dangling else clauses.

// EKR: from object.h

#define Py_INCREF(op) (op-&gt;ob_refcnt++)
#define Py_DECREF(op) { if (--op-&gt;ob_refcnt == 0) _Py_Dealloc(op) }

#define Py_XINCREF(op) if ((op) == NULL) ; else Py_INCREF(op)
	// if (op != NULL) op-&gt;ob_refcnt++
#define Py_XDECREF(op) if ((op) == NULL) ; else Py_DECREF(op)
	// if (op != NULL and --op-&gt;ob_refcnt == 0) _Py_Dealloc(op)
	
// EKR: from opcode.h

#define HAS_ARG(op) ((op) &gt;= HAVE_ARGUMENT)

// EKR: from frameobject.h

#define GETITEM(v, i)     PyTuple_GET_ITEM((PyTupleObject *)(v), (i))
	// v-&gt;ob_item[i]
#define GETITEMNAME(v, i) PyString_AS_STRING( (PyStringObject *) GETITEM((v),(i)) )
	// PyString_AS_STRING(v-&gt;ob_item[i])
	
#define Getconst(f, i)	(GETITEM(     (f)-&gt;f_code-&gt;co_consts, (i) ))
#define Getname(f, i)	 (GETITEMNAME( (f)-&gt;f_code-&gt;co_names,  (i) ))
#define Getnamev(f, i)	(GETITEM(     (f)-&gt;f_code-&gt;co_names,  (i) ))

// EKR: from tupleobject.h

#define PyTuple_GET_ITEM(op, i)    (((PyTupleObject *)(op))-&gt;ob_item[i])
#define PyTuple_GET_SIZE(op)       (((PyTupleObject *)(op))-&gt;ob_size)
#define PyTuple_SET_ITEM(op, i, v) (((PyTupleObject *)(op))-&gt;ob_item[i] = v)

/* Code access macros */
#define GETCONST(i)	Getconst(f, i)
	// f-&gt;f_code-&gt;co_consts-&gt;ob_item[i]
#define GETNAME(i)	 Getname (f, i)
	// PyString_AS_STRING(f-&gt;f_code-&gt;co_names-&gt;ob_item[i])
#define GETNAMEV(i)	Getnamev(f, i)
	// f-&gt;f_code-&gt;co_names-&gt;ob_item[i]
	
#define BASIC_PUSH(v)	(*stack_pointer++ = (v))
#define BASIC_POP()	  (*--stack_pointer)

#define GETLOCAL(i)	(fastlocals[i])
#define SETLOCAL(i, value)	{ Py_XDECREF(GETLOCAL(i)); GETLOCAL(i) = value; }</t>
<t tx="T799">case SET_LINENO:

	#if 0
		// This is part of the main line.
		if (things_to_do || --tstate-&gt;ticker &lt; 0)
			{ // handle periodic things }
	#endif

	f-&gt;f_lineno = oparg;
	if (tstate-&gt;c_tracefunc == NULL || tstate-&gt;tracing)
		continue;
	...
	break;</t>
<t tx="T800">case LOAD_ATTR:
	w = GETNAMEV(oparg);         // w = f-&gt;f_code-&gt;co_names-&gt;ob_item[oparg]
	v = POP();                   // v = *--stack_pointer
	x = PyObject_GetAttr(v, w);  // ***** Expensive?
	Py_DECREF(v);                // if (--v-&gt;ob_refcnt == 0) _Py_Dealloc(v)
	PUSH(x);                     // *stack_pointer++ = x
	if (x != NULL) continue;
	break;

case LOAD_CONST:
	x = GETCONST(oparg);         // x = f-&gt;f_code-&gt;co_consts-&gt;ob_item[oparg]
	Py_INCREF(x);                // x-&gt;ob_refcnt++
	PUSH(x);                     // *stack_pointer++ = x
	break;
	
case LOAD_LOCALS:
	x = f-&gt;f_locals;             // x = f-&gt;f_locals;
	if (x == NULL) {             // if (x == NULL) ...
		PyErr_SetString(...);
		break;
	}
	Py_INCREF(x);                // x-&gt;ob_refcnt++
	PUSH(x);                     // *stack_pointer++ = x
	break;
	
case LOAD_FAST:
	x = GETLOCAL(oparg);            // x = fastlocals[oparg]
	if (x == NULL) {                // if (x == NULL) ...
		format_exc_check_arg(...);
		break;
	}
	Py_INCREF(x);                   // x-&gt;ob_refcnt++
	PUSH(x);                        // *stack_pointer++ = x
	if (x != NULL) continue;
	break;
	
case LOAD_GLOBAL:
	w = GETNAMEV(oparg);                       // w = f-&gt;f_code-&gt;co_names-&gt;ob_item[oparg]
	x = PyDict_GetItem(f-&gt;f_globals, w);       // ***** Expensive??
	if (x == NULL) {										   // if (x == NULL)...
		x = PyDict_GetItem(f-&gt;f_builtins, w);
		if (x == NULL) {
			format_exc_check_arg(...)
			break;
		}
	}
	Py_INCREF(x);     											// x-&gt;ob_refcnt++
	PUSH(x);          											// *stack_pointer++ = x
	break;</t>
<t tx="T801">case STORE_FAST:
	v = POP();                                  // v = *--stack_pointer
	SETLOCAL(oparg, v);                         // Py_XDECREF(fastlocals[oparg]); fastlocals[oparg] = v;
	continue;

case STORE_GLOBAL:
	w = GETNAMEV(oparg);                        // w = f-&gt;f_code-&gt;co_names-&gt;ob_item[oparg]
	v = POP();                                  // v - *--stack_pointer
	err = PyDict_SetItem(f-&gt;f_globals, w, v);   // ***** Expensive?
	Py_DECREF(v);                               // if (--v-&gt;ob_refcnt == 0) _Py_Dealloc(v)
	break;

case STORE_NAME:
	w = GETNAMEV(oparg);                        // w = f-&gt;f_code-&gt;co_names-&gt;ob_item[oparg]
	v = POP();                                  // v - *--stack_pointer
	x = f-&gt;f_locals;                            // x = f-&gt;f_locals
	if (x == NULL) {                            // if (x == NULL) ...
		PyErr_Format(...);
		break;
	}
	err = PyDict_SetItem(x, w, v);              // ***** Expensive?
	Py_DECREF(v);                               // if (--v-&gt;ob_refcnt == 0) _Py_Dealloc(v)
	break;</t>
<t tx="T802">// EKR: from object.h

#define Py_INCREF(op) ((op)-&gt;ob_refcnt++)
#define Py_DECREF(op) { if (--op-&gt;ob_refcnt == 0) _Py_Dealloc(op) }

// EKR: from frameobject.h

#define GETITEM(v, i)     PyTuple_GET_ITEM((PyTupleObject *)(v), (i))
#define GETITEMNAME(v, i) PyString_AS_STRING( (PyStringObject *) GETITEM((v),(i)) )

#define Getconst(f, i)	(GETITEM(     (f)-&gt;f_code-&gt;co_consts, (i) ))
#define Getname(f, i)	 (GETITEMNAME( (f)-&gt;f_code-&gt;co_names,  (i) ))
#define Getnamev(f, i)	(GETITEM(     (f)-&gt;f_code-&gt;co_names,  (i) ))

// EKR: from tupleobject.h

#define PyTuple_GET_ITEM(op, i)    (((PyTupleObject *)(op))-&gt;ob_item[i])
#define PyTuple_GET_SIZE(op)       (((PyTupleObject *)(op))-&gt;ob_size)
#define PyTuple_SET_ITEM(op, i, v) (((PyTupleObject *)(op))-&gt;ob_item[i] = v)

/* Code access macros */

#define GETCONST(i)	Getconst(f, i)
#define GETNAME(i)	 Getname (f, i)
#define GETNAMEV(i)	Getnamev(f, i)
#define INSTR_OFFSET()	(next_instr - first_instr)
#define NEXTOP()	(*next_instr++)
#define NEXTARG()	(next_instr += 2, (next_instr[-1]&lt;&lt;8) + next_instr[-2])
#define JUMPTO(x)	(next_instr = first_instr + (x))
#define JUMPBY(x)	(next_instr += (x))

/* Stack manipulation macros */

#define STACK_LEVEL()	(stack_pointer - f-&gt;f_valuestack)
#define EMPTY()		(STACK_LEVEL() == 0)
#define TOP()		(stack_pointer[-1])

#define BASIC_PUSH(v)	(*stack_pointer++ = (v))
#define BASIC_POP()	  (*--stack_pointer)

#ifdef LLTRACE
	#define PUSH(v)		{ (void)(BASIC_PUSH(v), \
						   lltrace &amp;&amp; prtrace(TOP(), "push")); \
						   assert(STACK_LEVEL() &lt;= f-&gt;f_stacksize); }
	#define POP()		((void)(lltrace &amp;&amp; prtrace(TOP(), "pop")), BASIC_POP())
#else
	#define PUSH(v)		BASIC_PUSH(v)
	#define POP()		BASIC_POP()
#endif

/* Local variable macros */

#define GETLOCAL(i)	(fastlocals[i])
#define SETLOCAL(i, value)	\
	do { Py_XDECREF(GETLOCAL(i)); \
		GETLOCAL(i) = value;\
	} while (0)</t>
<t tx="T803">case SET_LINENO:
#ifdef LLTRACE
	if (lltrace)
		printf("--- %s:%d \n", filename, oparg);
#endif
	f-&gt;f_lineno = oparg;
	if (tstate-&gt;c_tracefunc == NULL || tstate-&gt;tracing)
		continue;
	/* Trace each line of code reached */
	f-&gt;f_lasti = INSTR_OFFSET();
	/* Inline call_trace() for performance: */
	tstate-&gt;tracing++;
	tstate-&gt;use_tracing = 0;
	err = (tstate-&gt;c_tracefunc)(tstate-&gt;c_traceobj, f,
				    PyTrace_LINE, Py_None);
	tstate-&gt;use_tracing = (tstate-&gt;c_tracefunc
			       || tstate-&gt;c_profilefunc);
	tstate-&gt;tracing--;
	break;</t>
<t tx="T804">case LOAD_ATTR:
	w = GETNAMEV(oparg);
	v = POP();  
	x = PyObject_GetAttr(v, w);  // Expensive?
	Py_DECREF(v);  // if (--op-&gt;ob_refcnt == 0) _Py_Dealloc(op)
	PUSH(x);  // *stack_pointer++ = x
	if (x != NULL) continue;
	break;

case LOAD_CLOSURE:
	x = freevars[oparg];
	Py_INCREF(x);  // x-&gt;ob_refcnt++
	PUSH(x); // *stack_pointer++ = x
	break;

case LOAD_CONST:
	x = GETCONST(oparg);
	Py_INCREF(x);
	PUSH(x);
	break;
	
case LOAD_DEREF:
	x = freevars[oparg];
	w = PyCell_Get(x);
	if (w == NULL) {
		if (oparg &lt; f-&gt;f_ncells) {
			v = PyTuple_GetItem(co-&gt;co_cellvars,
					       oparg);
		       format_exc_check_arg(
			       PyExc_UnboundLocalError,
			       UNBOUNDLOCAL_ERROR_MSG,
			       v);
		} else {
		       v = PyTuple_GetItem(
				      co-&gt;co_freevars,
				      oparg - f-&gt;f_ncells);
		       format_exc_check_arg(
			       PyExc_NameError,
			       UNBOUNDFREE_ERROR_MSG,
			       v);
		}
		err = -1;
		break;
	}
	PUSH(w);
	break;
	
case LOAD_LOCALS:
	if ((x = f-&gt;f_locals) == NULL) {
		PyErr_SetString(PyExc_SystemError,
				"no locals");
		break;
	}
	Py_INCREF(x);
	PUSH(x);
	break;
	
case LOAD_FAST:
	x = GETLOCAL(oparg);
	if (x == NULL) {
		format_exc_check_arg(
			PyExc_UnboundLocalError,
			UNBOUNDLOCAL_ERROR_MSG,
			PyTuple_GetItem(co-&gt;co_varnames, oparg)
			);
		break;
	}
	Py_INCREF(x);
	PUSH(x);
	if (x != NULL) continue;
	break;
	
case LOAD_GLOBAL:
	w = GETNAMEV(oparg);
	x = PyDict_GetItem(f-&gt;f_globals, w);
	if (x == NULL) {
		x = PyDict_GetItem(f-&gt;f_builtins, w);
		if (x == NULL) {
			format_exc_check_arg(
				    PyExc_NameError,
				    GLOBAL_NAME_ERROR_MSG ,w);
			break;
		}
	}
	Py_INCREF(x);
	PUSH(x);
	break;

case LOAD_NAME:
	w = GETNAMEV(oparg);
	if ((x = f-&gt;f_locals) == NULL) {
		PyErr_Format(PyExc_SystemError,
			     "no locals when loading %s",
			     PyObject_REPR(w));
		break;
	}
	x = PyDict_GetItem(x, w);
	if (x == NULL) {
		x = PyDict_GetItem(f-&gt;f_globals, w);
		if (x == NULL) {
			x = PyDict_GetItem(f-&gt;f_builtins, w);
			if (x == NULL) {
				format_exc_check_arg(
					    PyExc_NameError,
					    NAME_ERROR_MSG ,w);
				break;
			}
		}
	}
	Py_INCREF(x);
	PUSH(x);
	break;</t>
<t tx="T805">case STORE_DEREF:
	w = POP();
	x = freevars[oparg];
	PyCell_Set(x, w);
	Py_DECREF(w);
	continue;

case STORE_FAST:
	v = POP();
	SETLOCAL(oparg, v);
	continue;

case STORE_GLOBAL:
	w = GETNAMEV(oparg);
	v = POP();
	err = PyDict_SetItem(f-&gt;f_globals, w, v);
	Py_DECREF(v);
	break;

case STORE_NAME:
	w = GETNAMEV(oparg);
	v = POP();
	if ((x = f-&gt;f_locals) == NULL) {
		PyErr_Format(PyExc_SystemError,
			     "no locals found when storing %s",
			     PyObject_REPR(w));
		break;
	}
	err = PyDict_SetItem(x, w, v);
	Py_DECREF(v);
	break;</t>
<t tx="T806">case BREAK_LOOP:
	why = WHY_BREAK;
	break;

case CONTINUE_LOOP:
	retval = PyInt_FromLong(oparg);
	why = WHY_CONTINUE;
	break;
	
case EXEC_STMT:
	w = POP();
	v = POP();
	u = POP();
	err = exec_statement(f, u, v, w);
	Py_DECREF(u);
	Py_DECREF(v);
	Py_DECREF(w);
	break;

case FOR_ITER:
	/* before: [iter]; after: [iter, iter()] *or* [] */
	v = TOP();
	x = PyIter_Next(v);
	if (x != NULL) {
		PUSH(x);
		continue;
	}
	if (!PyErr_Occurred()) {
		/* iterator ended normally */
		x = v = POP();
		Py_DECREF(v);
		JUMPBY(oparg);
		continue;
	}
	break;

case FOR_LOOP:
	/* for v in s: ...
	   On entry: stack contains s, i.
	   On exit: stack contains s, i+1, s[i];
	   but if loop exhausted:
	   	s, i are popped, and we jump */
	w = POP(); /* Loop index */
	v = POP(); /* Sequence object */
	u = loop_subscript(v, w);
	if (u != NULL) {
		PUSH(v);
		x = PyInt_FromLong(PyInt_AsLong(w)+1);
		PUSH(x);
		Py_DECREF(w);
		PUSH(u);
		if (x != NULL) continue;
	}
	else {
		Py_DECREF(v);
		Py_DECREF(w);
		/* A NULL can mean "s exhausted"
		   but also an error: */
		if (PyErr_Occurred())
			why = WHY_EXCEPTION;
		else {
			JUMPBY(oparg);
			continue;
		}
	}
	break;
	
case GET_ITER:
	/* before: [obj]; after [getiter(obj)] */
	v = POP();
	x = PyObject_GetIter(v);
	Py_DECREF(v);
	if (x != NULL) {
		PUSH(x);
		continue;
	}
	break;

case RAISE_VARARGS:
	u = v = w = NULL;
	switch (oparg) {
	case 3:
		u = POP(); /* traceback */
		/* Fallthrough */
	case 2:
		v = POP(); /* value */
		/* Fallthrough */
	case 1:
		w = POP(); /* exc */
	case 0: /* Fallthrough */
		why = do_raise(w, v, u);
		break;
	default:
		PyErr_SetString(PyExc_SystemError,
			   "bad RAISE_VARARGS oparg");
		why = WHY_EXCEPTION;
		break;
	}
	break;
	
case SETUP_LOOP:
case SETUP_EXCEPT:
case SETUP_FINALLY:
	PyFrame_BlockSetup(f, opcode, INSTR_OFFSET() + oparg,
			   STACK_LEVEL());
	continue;
	
case POP_BLOCK:
	{
		PyTryBlock *b = PyFrame_BlockPop(f);
		while (STACK_LEVEL() &gt; b-&gt;b_level) {
			v = POP();
			Py_DECREF(v);
		}
	}
	break;

case END_FINALLY:
	v = POP();
	if (PyInt_Check(v)) {
		why = (enum why_code) PyInt_AsLong(v);
		if (why == WHY_RETURN ||
		    why == WHY_YIELD ||
		    why == CONTINUE_LOOP)
			retval = POP();
	}
	else if (PyString_Check(v) || PyClass_Check(v)) {
		w = POP();
		u = POP();
		PyErr_Restore(v, w, u);
		why = WHY_RERAISE;
		break;
	}
	else if (v != Py_None) {
		PyErr_SetString(PyExc_SystemError,
			"'finally' pops bad exception");
		why = WHY_EXCEPTION;
	}
	Py_DECREF(v);
	break;
	
case RETURN_VALUE:
	retval = POP();
	why = WHY_RETURN;
	break;

case YIELD_VALUE:
	retval = POP();
	f-&gt;f_stacktop = stack_pointer;
	f-&gt;f_lasti = INSTR_OFFSET();
	why = WHY_YIELD;
	break;</t>
<t tx="T807"></t>
<t tx="T808">@language c
@ignore</t>
<t tx="T809">/* Execute compiled code */

/* XXX TO DO:
   XXX speed up searching for keywords by using a dictionary
   XXX document it!
   */

&lt;&lt; ceval #includes &gt;&gt;
&lt;&lt; ceval declarations &gt;&gt;
@others

#endif
</t>
<t tx="T810">#include "Python.h"

#include "compile.h"
#include "frameobject.h"
#include "eval.h"
#include "opcode.h"
#include "structmember.h"
</t>
<t tx="T811">#ifdef macintosh
#include "macglue.h"
#endif

#include &lt;ctype.h&gt;

/* Turn this on if your compiler chokes on the big switch: */
/* #define CASE_TOO_BIG 1 */

#ifdef Py_DEBUG
	/* For debugging the interpreter: */
	#define LLTRACE  1	/* Low-level trace feature */
	#define CHECKEXC 1	/* Double-check exception checking */
#endif

typedef PyObject *(*callproc)(PyObject *, PyObject *, PyObject *);

&lt;&lt; declare static functions &gt;&gt;
&lt;&lt; define error messages &gt;&gt;

/* Dynamic execution profile */
#ifdef DYNAMIC_EXECUTION_PROFILE
	#ifdef DXPAIRS
		static long dxpairs[257][256];
		#define dxp dxpairs[256]
	#else
		static long dxp[256];
	#endif
#endif

staticforward PyTypeObject gentype;

typedef struct {
	PyObject_HEAD
	/* The gi_ prefix is intended to remind of generator-iterator. */
	PyFrameObject *gi_frame;
	/* True if generator is being executed. */ 
	int gi_running;
} genobject;</t>
<t tx="T812">/* Forward declarations */ // of private methods.
static PyObject *eval_frame(PyFrameObject *);
static PyObject *fast_function(PyObject *, PyObject ***, int, int, int);
static PyObject *fast_cfunction(PyObject *, PyObject ***, int);
static PyObject *do_call(PyObject *, PyObject ***, int, int);
static PyObject *ext_do_call(PyObject *, PyObject ***, int, int, int);
static PyObject *update_keyword_args(PyObject *, int, PyObject ***,PyObject *);
static PyObject *update_star_args(int, int, PyObject *, PyObject ***);
static PyObject *load_args(PyObject ***, int);
#define CALL_FLAG_VAR 1
#define CALL_FLAG_KW 2

#ifdef LLTRACE
	static int prtrace(PyObject *, char *);
#endif

static int call_trace(Py_tracefunc, PyObject *, PyFrameObject *,
		      int, PyObject *);
static void call_trace_protected(Py_tracefunc, PyObject *,
				 PyFrameObject *, int);
static void call_exc_trace(Py_tracefunc, PyObject *, PyFrameObject *);
static PyObject *loop_subscript(PyObject *, PyObject *);
static PyObject *apply_slice(PyObject *, PyObject *, PyObject *);
static int assign_slice(PyObject *, PyObject *,
			PyObject *, PyObject *);
static PyObject *cmp_outcome(int, PyObject *, PyObject *);
static PyObject *import_from(PyObject *, PyObject *);
static int import_all_from(PyObject *, PyObject *);
static PyObject *build_class(PyObject *, PyObject *, PyObject *);
static int exec_statement(PyFrameObject *,
			  PyObject *, PyObject *, PyObject *);
static void set_exc_info(PyThreadState *, PyObject *, PyObject *, PyObject *);
static void reset_exc_info(PyThreadState *);
static void format_exc_check_arg(PyObject *, char *, PyObject *);</t>
<t tx="T813">#define NAME_ERROR_MSG \
	"name '%.200s' is not defined"
#define GLOBAL_NAME_ERROR_MSG \
	"global name '%.200s' is not defined"
#define UNBOUNDLOCAL_ERROR_MSG \
	"local variable '%.200s' referenced before assignment"
#define UNBOUNDFREE_ERROR_MSG \
	"free variable '%.200s' referenced before assignment" \
        " in enclosing scope"</t>
<t tx="T814">/* Interpreter main loop */

static PyObject *
eval_frame(PyFrameObject *f)
{
	&lt;&lt; define vars &gt;&gt;
	&lt;&lt; define macros &gt;&gt;
	&lt;&lt; initialize &gt;&gt;
	why = WHY_NOT; err = 0;
	w = NULL; x = Py_None;	/* Not a reference, just anything non-NULL */
	for (;;) {
		&lt;&lt; start loop &gt;&gt;
		switch (opcode) {
		&lt;&lt; opcode cases &gt;&gt;
		}
		&lt;&lt; end loop &gt;&gt;
	}
	&lt;&lt; finalize &gt;&gt;
	return retval;
}</t>
<t tx="T815">#ifdef DXPAIRS
int lastopcode = 0;
#endif

PyObject **stack_pointer; /* Next free slot in value stack */

register unsigned char *next_instr;
register int opcode=0;	/* Current opcode */
register int oparg=0;	/* Current opcode argument, if any */
register enum why_code why; /* Reason for block stack unwind */
register int err;	/* Error status -- nonzero if error */

register PyObject *x;	/* Result object -- NULL if error */
register PyObject *v;	/* Temporary objects popped off stack */
register PyObject *w;
register PyObject *u;
register PyObject *t;

register PyObject *stream = NULL;    /* for PRINT opcodes */
register PyObject **fastlocals, **freevars;
PyObject *retval = NULL;	/* Return value */
PyThreadState *tstate = PyThreadState_GET();
PyCodeObject *co;
unsigned char *first_instr;

#ifdef LLTRACE
	int lltrace;
#endif

#if defined(Py_DEBUG) || defined(LLTRACE)
	/* Make it easier to find out where we are with a debugger */
	char *filename;
#endif</t>
<t tx="T816">/* Start of code */
if (f == NULL)
	return NULL;

#ifdef USE_STACKCHECK
	if (tstate-&gt;recursion_depth%10 == 0 &amp;&amp; PyOS_CheckStack()) {
		PyErr_SetString(PyExc_MemoryError, "Stack overflow");
		return NULL;
	}
#endif

/* push frame */
if (++tstate-&gt;recursion_depth &gt; recursion_limit) {
	--tstate-&gt;recursion_depth;
	PyErr_SetString(PyExc_RuntimeError,
			"maximum recursion depth exceeded");
	tstate-&gt;frame = f-&gt;f_back;
	return NULL;
}

tstate-&gt;frame = f;
co = f-&gt;f_code;
fastlocals = f-&gt;f_localsplus;
freevars = f-&gt;f_localsplus + f-&gt;f_nlocals;
_PyCode_GETCODEPTR(co, &amp;first_instr);
next_instr = first_instr + f-&gt;f_lasti;

// EKR: Get the stack pointer from the frame.
stack_pointer = f-&gt;f_stacktop;
assert(stack_pointer != NULL);
f-&gt;f_stacktop = NULL;	/* remains NULL unless yield suspends frame */

if (tstate-&gt;use_tracing) {
	&lt;&lt; initialize tracing &gt;&gt;
}

#ifdef LLTRACE
	lltrace = PyDict_GetItemString(f-&gt;f_globals,"__lltrace__") != NULL;
#endif

#if defined(Py_DEBUG) || defined(LLTRACE)
	filename = PyString_AsString(co-&gt;co_filename);
#endif</t>
<t tx="T817">@ tstate-&gt;c_tracefunc, if defined, is a function that will be called on *every* entry to a code block.  Its return value, if not None, is a function that will be called at the start of each executed line of code. (Actually, the function must return itself in order to continue tracing.)
	   
The trace functions are called with three arguments: a pointer to the current frame, a string indicating why the function is called, and an argument which depends on the situation. The global trace function is also called whenever an exception is detected.
@c

if (tstate-&gt;c_tracefunc != NULL) {
	if (call_trace(tstate-&gt;c_tracefunc, tstate-&gt;c_traceobj,
			   f, PyTrace_CALL, Py_None)) {
		/* Trace function raised an error */
		return NULL;
	}
}

@ Similar for c_profilefunc, except it needn't return itself and isn't called for "line" events.
@c

if (tstate-&gt;c_profilefunc != NULL) {
	if (call_trace(tstate-&gt;c_profilefunc,
			   tstate-&gt;c_profileobj,
			   f, PyTrace_CALL, Py_None)) {
		/* Profile function raised an error */
		return NULL;
	}
}</t>
<t tx="T818">assert(stack_pointer &gt;= f-&gt;f_valuestack);	/* else underflow */
assert(STACK_LEVEL() &lt;= f-&gt;f_stacksize);	/* else overflow */

if (things_to_do || --tstate-&gt;ticker &lt; 0) {
	&lt;&lt; handle periodic things &gt;&gt;
}

&lt;&lt; set f-&gt;f_lasti if debugging or tracing &gt;&gt;

opcode = NEXTOP();

if (HAS_ARG(opcode))
	oparg = NEXTARG();

dispatch_opcode:

&lt;&lt; handle tracing and profiling &gt;&gt;</t>
<t tx="T819">@ Doing this every time through the loop would add too much overhead, so we do it only every Nth instruction.  We also do it if ``things_to_do'' is set, i.e. when an asynchronous event needs attention (e.g. a signal handler or async I/O handler); see Py_AddPendingCall() and Py_MakePendingCalls() above.
@c

tstate-&gt;ticker = tstate-&gt;interp-&gt;checkinterval;
if (things_to_do) {
	if (Py_MakePendingCalls() &lt; 0) {
		why = WHY_EXCEPTION;
		goto on_error;
	}
}
#if !defined(HAVE_SIGNAL_H) || defined(macintosh)
	/* If we have true signals, the signal handler
	   will call Py_AddPendingCall() so we don't
	   have to call sigcheck().  On the Mac and
	   DOS, alas, we have to call it. */
	if (PyErr_CheckSignals()) {
		why = WHY_EXCEPTION;
		goto on_error;
	}
#endif

#ifdef WITH_THREAD
	if (interpreter_lock) {
		/* Give another thread a chance */

		if (PyThreadState_Swap(NULL) != tstate)
			Py_FatalError("ceval: tstate mix-up");
		PyThread_release_lock(interpreter_lock);

		/* Other threads may run now */

		PyThread_acquire_lock(interpreter_lock, 1);
		if (PyThreadState_Swap(tstate) != NULL)
			Py_FatalError("ceval: orphan tstate");
	}
#endif</t>
<t tx="T820">#if defined(Py_DEBUG) || defined(LLTRACE)
	f-&gt;f_lasti = INSTR_OFFSET();
#endif</t>
<t tx="T821">#ifdef DYNAMIC_EXECUTION_PROFILE
	#ifdef DXPAIRS
		dxpairs[lastopcode][opcode]++;
		lastopcode = opcode;
	#endif
		dxp[opcode]++;
#endif

#ifdef LLTRACE
	/* Instruction tracing */
	if (lltrace) {
		if (HAS_ARG(opcode)) {
			printf("%d: %d, %d\n",
				(int) (INSTR_OFFSET() - 3), opcode, oparg);
		}
		else {
			printf("%d: %d\n",
				(int) (INSTR_OFFSET() - 1), opcode);
		}
	}
#endif</t>
<t tx="T822">@ BEWARE! It is essential that any operation that fails sets either, x to NULL, err to nonzero, or why to anything but WHY_NOT, and that no operation that succeeds does this!

EKR: i.e., any one of the folowing denotes failure:
1. setting x to NULL,
2. setting err to nonzero,
3. setting why to anything but WHY_NOT.
@c

/* case STOP_CODE: this is an error! */

&lt;&lt; arithmetic cases &gt;&gt;
&lt;&lt; print cases &gt;&gt;
&lt;&lt; stack cases &gt;&gt;
&lt;&lt; string cases &gt;&gt;
&lt;&lt; subscript cases &gt;&gt;

#ifdef CASE_TOO_BIG
default: switch (opcode) {
#endif

&lt;&lt; build, const, unpack cases &gt;&gt;
&lt;&lt; call cases &gt;&gt;
&lt;&lt; compare cases &gt;&gt;
&lt;&lt; delete cases &gt;&gt;
&lt;&lt; extended arg case &gt;&gt;
&lt;&lt; flow-of-control cases &gt;&gt;
&lt;&lt; import cases &gt;&gt;
&lt;&lt; jump case &gt;&gt;
&lt;&lt; load cases &gt;&gt;
&lt;&lt; make cases &gt;&gt;
&lt;&lt; set_lineno case &gt;&gt;
&lt;&lt; store cases &gt;&gt;
default:
	&lt;&lt; default case &gt;&gt;

#ifdef CASE_TOO_BIG
}
#endif</t>
<t tx="T823">case UNARY_POSITIVE:
	v = POP();
	x = PyNumber_Positive(v);
	Py_DECREF(v);
	PUSH(x);
	if (x != NULL) continue;
	break;

case UNARY_NEGATIVE:
	v = POP();
	x = PyNumber_Negative(v);
	Py_DECREF(v);
	PUSH(x);
	if (x != NULL) continue;
	break;

case UNARY_NOT:
	v = POP();
	err = PyObject_IsTrue(v);
	Py_DECREF(v);
	if (err == 0) {
		Py_INCREF(Py_True);
		PUSH(Py_True);
		continue;
	}
	else if (err &gt; 0) {
		Py_INCREF(Py_False);
		PUSH(Py_False);
		err = 0;
		continue;
	}
	break;

case UNARY_CONVERT:
	v = POP();
	x = PyObject_Repr(v);
	Py_DECREF(v);
	PUSH(x);
	if (x != NULL) continue;
	break;

case UNARY_INVERT:
	v = POP();
	x = PyNumber_Invert(v);
	Py_DECREF(v);
	PUSH(x);
	if (x != NULL) continue;
	break;

case BINARY_POWER:
	w = POP();
	v = POP();
	x = PyNumber_Power(v, w, Py_None);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case BINARY_MULTIPLY:
	w = POP();
	v = POP();
	x = PyNumber_Multiply(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case BINARY_DIVIDE:
	if (!_Py_QnewFlag) {
		w = POP();
		v = POP();
		x = PyNumber_Divide(v, w);
		Py_DECREF(v);
		Py_DECREF(w);
		PUSH(x);
		if (x != NULL) continue;
		break;
	}
	/* -Qnew is in effect:  fall through to
	   BINARY_TRUE_DIVIDE */
case BINARY_TRUE_DIVIDE:
	w = POP();
	v = POP();
	x = PyNumber_TrueDivide(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case BINARY_FLOOR_DIVIDE:
	w = POP();
	v = POP();
	x = PyNumber_FloorDivide(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case BINARY_MODULO:
	w = POP();
	v = POP();
	x = PyNumber_Remainder(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case BINARY_ADD:
	w = POP();
	v = POP();
	if (PyInt_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) {
		/* INLINE: int + int */
		register long a, b, i;
		a = PyInt_AS_LONG(v);
		b = PyInt_AS_LONG(w);
		i = a + b;
		if ((i^a) &lt; 0 &amp;&amp; (i^b) &lt; 0)
			goto slow_add;
		x = PyInt_FromLong(i);
	}
	else {
	  slow_add:
		x = PyNumber_Add(v, w);
	}
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case BINARY_SUBTRACT:
	w = POP();
	v = POP();
	if (PyInt_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) {
		/* INLINE: int - int */
		register long a, b, i;
		a = PyInt_AS_LONG(v);
		b = PyInt_AS_LONG(w);
		i = a - b;
		if ((i^a) &lt; 0 &amp;&amp; (i^~b) &lt; 0)
			goto slow_sub;
		x = PyInt_FromLong(i);
	}
	else {
	  slow_sub:
		x = PyNumber_Subtract(v, w);
	}
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case BINARY_SUBSCR:
	w = POP();
	v = POP();
	if (PyList_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) {
		/* INLINE: list[int] */
		long i = PyInt_AsLong(w);
		if (i &lt; 0)
			i += PyList_GET_SIZE(v);
		if (i &lt; 0 ||
		    i &gt;= PyList_GET_SIZE(v)) {
			PyErr_SetString(PyExc_IndexError,
				"list index out of range");
			x = NULL;
		}
		else {
			x = PyList_GET_ITEM(v, i);
			Py_INCREF(x);
		}
	}
	else
		x = PyObject_GetItem(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case BINARY_LSHIFT:
	w = POP();
	v = POP();
	x = PyNumber_Lshift(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case BINARY_RSHIFT:
	w = POP();
	v = POP();
	x = PyNumber_Rshift(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case BINARY_AND:
	w = POP();
	v = POP();
	x = PyNumber_And(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case BINARY_XOR:
	w = POP();
	v = POP();
	x = PyNumber_Xor(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case BINARY_OR:
	w = POP();
	v = POP();
	x = PyNumber_Or(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case INPLACE_POWER:
	w = POP();
	v = POP();
	x = PyNumber_InPlacePower(v, w, Py_None);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case INPLACE_MULTIPLY:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceMultiply(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case INPLACE_DIVIDE:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceDivide(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case INPLACE_FLOOR_DIVIDE:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceFloorDivide(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case INPLACE_TRUE_DIVIDE:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceTrueDivide(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case INPLACE_MODULO:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceRemainder(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case INPLACE_ADD:
	w = POP();
	v = POP();
	if (PyInt_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) {
		/* INLINE: int + int */
		register long a, b, i;
		a = PyInt_AS_LONG(v);
		b = PyInt_AS_LONG(w);
		i = a + b;
		if ((i^a) &lt; 0 &amp;&amp; (i^b) &lt; 0)
			goto slow_iadd;
		x = PyInt_FromLong(i);
	}
	else {
	  slow_iadd:
		x = PyNumber_InPlaceAdd(v, w);
	}
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case INPLACE_SUBTRACT:
	w = POP();
	v = POP();
	if (PyInt_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) {
		/* INLINE: int - int */
		register long a, b, i;
		a = PyInt_AS_LONG(v);
		b = PyInt_AS_LONG(w);
		i = a - b;
		if ((i^a) &lt; 0 &amp;&amp; (i^~b) &lt; 0)
			goto slow_isub;
		x = PyInt_FromLong(i);
	}
	else {
	  slow_isub:
		x = PyNumber_InPlaceSubtract(v, w);
	}
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case INPLACE_LSHIFT:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceLshift(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case INPLACE_RSHIFT:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceRshift(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case INPLACE_AND:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceAnd(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case INPLACE_XOR:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceXor(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case INPLACE_OR:
	w = POP();
	v = POP();
	x = PyNumber_InPlaceOr(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T824">case BUILD_CLASS:
	u = POP();
	v = POP();
	w = POP();
	x = build_class(u, v, w);
	PUSH(x);
	Py_DECREF(u);
	Py_DECREF(v);
	Py_DECREF(w);
	break;
	
case BUILD_LIST:
	x = PyList_New(oparg);
	if (x != NULL) {
		for (; --oparg &gt;= 0;) {
			w = POP();
			PyList_SET_ITEM(x, oparg, w);
		}
		PUSH(x);
		continue;
	}
	break;

case BUILD_MAP:
	x = PyDict_New();
	PUSH(x);
	if (x != NULL) continue;
	break;
	
case BUILD_SLICE:
	if (oparg == 3)
		w = POP();
	else
		w = NULL;
	v = POP();
	u = POP();
	x = PySlice_New(u, v, w);
	Py_DECREF(u);
	Py_DECREF(v);
	Py_XDECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;
	
case BUILD_TUPLE:
	x = PyTuple_New(oparg);
	if (x != NULL) {
		for (; --oparg &gt;= 0;) {
			w = POP();
			PyTuple_SET_ITEM(x, oparg, w);
		}
		PUSH(x);
		continue;
	}
	break;
	
case UNPACK_SEQUENCE:
	v = POP();
	if (PyTuple_Check(v)) {
		if (PyTuple_Size(v) != oparg) {
			PyErr_SetString(PyExc_ValueError,
				 "unpack tuple of wrong size");
			why = WHY_EXCEPTION;
		}
		else {
			for (; --oparg &gt;= 0; ) {
				w = PyTuple_GET_ITEM(v, oparg);
				Py_INCREF(w);
				PUSH(w);
			}
		}
	}
	else if (PyList_Check(v)) {
		if (PyList_Size(v) != oparg) {
			PyErr_SetString(PyExc_ValueError,
				  "unpack list of wrong size");
			why = WHY_EXCEPTION;
		}
		else {
			for (; --oparg &gt;= 0; ) {
				w = PyList_GET_ITEM(v, oparg);
				Py_INCREF(w);
				PUSH(w);
			}
		}
	}
	else if (unpack_iterable(v, oparg,
				 stack_pointer + oparg))
		stack_pointer += oparg;
	else {
		if (PyErr_ExceptionMatches(PyExc_TypeError))
			PyErr_SetString(PyExc_TypeError,
				"unpack non-sequence");
		why = WHY_EXCEPTION;
	}
	Py_DECREF(v);
	break;</t>
<t tx="T825">case CALL_FUNCTION:
{
    int na = oparg &amp; 0xff;
    int nk = (oparg&gt;&gt;8) &amp; 0xff;
    int n = na + 2 * nk;
    PyObject **pfunc = stack_pointer - n - 1;
    PyObject *func = *pfunc;
    f-&gt;f_lasti = INSTR_OFFSET() - 3; /* For tracing */

    /* Always dispatch PyCFunction first, because
       these are presumed to be the most frequent
       callable object.
    */
    if (PyCFunction_Check(func)) {
	    int flags = PyCFunction_GET_FLAGS(func);
	    if (nk != 0 || (flags &amp; METH_KEYWORDS))
		    x = do_call(func, &amp;stack_pointer,
				na, nk);
	    else if (flags == METH_VARARGS) {
		    PyObject *callargs;
		    callargs = load_args(&amp;stack_pointer, na);
		    x = PyCFunction_Call(func, callargs, NULL);
		    Py_XDECREF(callargs); 
	    } else
		    x = fast_cfunction(func,
				       &amp;stack_pointer, na);
    } else {
	    if (PyMethod_Check(func)
		&amp;&amp; PyMethod_GET_SELF(func) != NULL) {
		    /* optimize access to bound methods */
		    PyObject *self = PyMethod_GET_SELF(func);
		    Py_INCREF(self);
		    func = PyMethod_GET_FUNCTION(func);
		    Py_INCREF(func);
		    Py_DECREF(*pfunc);
		    *pfunc = self;
		    na++;
		    n++;
	    } else
		    Py_INCREF(func);
	    if (PyFunction_Check(func)) {
		    x = fast_function(func, &amp;stack_pointer,
				      n, na, nk);
	    } else {
		    x = do_call(func, &amp;stack_pointer,
				na, nk);
	    }
	    Py_DECREF(func);
    }

    while (stack_pointer &gt; pfunc) {
	    w = POP();
	    Py_DECREF(w);
    }
    PUSH(x);
    if (x != NULL)
	    continue;
    break;
}

case CALL_FUNCTION_VAR:
case CALL_FUNCTION_KW:
case CALL_FUNCTION_VAR_KW:
{
    int na = oparg &amp; 0xff;
    int nk = (oparg&gt;&gt;8) &amp; 0xff;
    int flags = (opcode - CALL_FUNCTION) &amp; 3;
    int n = na + 2 * nk;
    PyObject **pfunc, *func;
    if (flags &amp; CALL_FLAG_VAR)
	    n++;
    if (flags &amp; CALL_FLAG_KW)
	    n++;
    pfunc = stack_pointer - n - 1;
    func = *pfunc;
    f-&gt;f_lasti = INSTR_OFFSET() - 3; /* For tracing */

    if (PyMethod_Check(func)
	&amp;&amp; PyMethod_GET_SELF(func) != NULL) {
	    PyObject *self = PyMethod_GET_SELF(func);
	    Py_INCREF(self);
	    func = PyMethod_GET_FUNCTION(func);
	    Py_INCREF(func);
	    Py_DECREF(*pfunc);
	    *pfunc = self;
	    na++;
	    n++;
    } else
	    Py_INCREF(func);
    x = ext_do_call(func, &amp;stack_pointer, flags, na, nk);
    Py_DECREF(func);

    while (stack_pointer &gt; pfunc) {
	    w = POP();
	    Py_DECREF(w);
    }
    PUSH(x);
    if (x != NULL)
	    continue;
    break;
}</t>
<t tx="T826">case COMPARE_OP:
	w = POP();
	v = POP();
	if (PyInt_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) {
		/* INLINE: cmp(int, int) */
		register long a, b;
		register int res;
		a = PyInt_AS_LONG(v);
		b = PyInt_AS_LONG(w);
		switch (oparg) {
		case LT: res = a &lt;  b; break;
		case LE: res = a &lt;= b; break;
		case EQ: res = a == b; break;
		case NE: res = a != b; break;
		case GT: res = a &gt;  b; break;
		case GE: res = a &gt;= b; break;
		case IS: res = v == w; break;
		case IS_NOT: res = v != w; break;
		default: goto slow_compare;
		}
		x = res ? Py_True : Py_False;
		Py_INCREF(x);
	}
	else {
	  slow_compare:
		x = cmp_outcome(oparg, v, w);
	}
	Py_DECREF(v);
	Py_DECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;</t>
<t tx="T827">fprintf(stderr,
	"XXX lineno: %d, opcode: %d\n",
	f-&gt;f_lineno, opcode);

PyErr_SetString(PyExc_SystemError, "unknown opcode");
why = WHY_EXCEPTION;
break;</t>
<t tx="T828">case DELETE_ATTR:
	w = GETNAMEV(oparg);
	v = POP();
	err = PyObject_SetAttr(v, w, (PyObject *)NULL);
					/* del v.w */
	Py_DECREF(v);
	break;
	
case DELETE_FAST:
	x = GETLOCAL(oparg);
	if (x == NULL) {
		format_exc_check_arg(
			PyExc_UnboundLocalError,
			UNBOUNDLOCAL_ERROR_MSG,
			PyTuple_GetItem(co-&gt;co_varnames, oparg)
			);
		break;
	}
	SETLOCAL(oparg, NULL);
	continue;
	
case DELETE_GLOBAL:
	w = GETNAMEV(oparg);
	if ((err = PyDict_DelItem(f-&gt;f_globals, w)) != 0)
		format_exc_check_arg(
		    PyExc_NameError, GLOBAL_NAME_ERROR_MSG, w);
	break;

case DELETE_NAME:
	w = GETNAMEV(oparg);
	if ((x = f-&gt;f_locals) == NULL) {
		PyErr_Format(PyExc_SystemError,
			     "no locals when deleting %s",
			     PyObject_REPR(w));
		break;
	}
	if ((err = PyDict_DelItem(x, w)) != 0)
		format_exc_check_arg(PyExc_NameError,
					NAME_ERROR_MSG ,w);
	break;</t>
<t tx="T829">case EXTENDED_ARG:
	opcode = NEXTOP();
	oparg = oparg&lt;&lt;16 | NEXTARG();
	goto dispatch_opcode;</t>
<t tx="T830">case JUMP_FORWARD:
	JUMPBY(oparg);
	continue;

case JUMP_IF_FALSE:
	err = PyObject_IsTrue(TOP());
	if (err &gt; 0)
		err = 0;
	else if (err == 0)
		JUMPBY(oparg);
	else
		break;
	continue;

case JUMP_IF_TRUE:
	err = PyObject_IsTrue(TOP());
	if (err &gt; 0) {
		err = 0;
		JUMPBY(oparg);
	}
	else if (err == 0)
		;
	else
		break;
	continue;

case JUMP_ABSOLUTE:
	JUMPTO(oparg);
	continue;</t>
<t tx="T831">case MAKE_FUNCTION:
	v = POP(); /* code object */
	x = PyFunction_New(v, f-&gt;f_globals);
	Py_DECREF(v);
	/* XXX Maybe this should be a separate opcode? */
	if (x != NULL &amp;&amp; oparg &gt; 0) {
		v = PyTuple_New(oparg);
		if (v == NULL) {
			Py_DECREF(x);
			x = NULL;
			break;
		}
		while (--oparg &gt;= 0) {
			w = POP();
			PyTuple_SET_ITEM(v, oparg, w);
		}
		err = PyFunction_SetDefaults(x, v);
		Py_DECREF(v);
	}
	PUSH(x);
	break;

case MAKE_CLOSURE:
{
	int nfree;
	v = POP(); /* code object */
	x = PyFunction_New(v, f-&gt;f_globals);
	nfree = PyCode_GetNumFree((PyCodeObject *)v);
	Py_DECREF(v);
	/* XXX Maybe this should be a separate opcode? */
	if (x != NULL &amp;&amp; nfree &gt; 0) {
		v = PyTuple_New(nfree);
		if (v == NULL) {
			Py_DECREF(x);
			x = NULL;
			break;
		}
		while (--nfree &gt;= 0) {
			w = POP();
			PyTuple_SET_ITEM(v, nfree, w);
		}
		err = PyFunction_SetClosure(x, v);
		Py_DECREF(v);
	}
	if (x != NULL &amp;&amp; oparg &gt; 0) {
		v = PyTuple_New(oparg);
		if (v == NULL) {
			Py_DECREF(x);
			x = NULL;
			break;
		}
		while (--oparg &gt;= 0) {
			w = POP();
			PyTuple_SET_ITEM(v, oparg, w);
		}
		err = PyFunction_SetDefaults(x, v);
		Py_DECREF(v);
	}
	PUSH(x);
	break;
}</t>
<t tx="T832">case PRINT_EXPR:
	v = POP();
	w = PySys_GetObject("displayhook");
	if (w == NULL) {
		PyErr_SetString(PyExc_RuntimeError,
				"lost sys.displayhook");
		err = -1;
		x = NULL;
	}
	if (err == 0) {
		x = Py_BuildValue("(O)", v);
		if (x == NULL)
			err = -1;
	}
	if (err == 0) {
		w = PyEval_CallObject(w, x);
		Py_XDECREF(w);
		if (w == NULL)
			err = -1;
	}
	Py_DECREF(v);
	Py_XDECREF(x);
	break;

case PRINT_ITEM_TO:
	w = stream = POP();
	/* fall through to PRINT_ITEM */

case PRINT_ITEM:
	v = POP();
	if (stream == NULL || stream == Py_None) {
		w = PySys_GetObject("stdout");
		if (w == NULL) {
			PyErr_SetString(PyExc_RuntimeError,
					"lost sys.stdout");
			err = -1;
		}
	}
	if (w != NULL &amp;&amp; PyFile_SoftSpace(w, 1))
		err = PyFile_WriteString(" ", w);
	if (err == 0)
		err = PyFile_WriteObject(v, w, Py_PRINT_RAW);
	if (err == 0) {
		/* XXX move into writeobject() ? */
	    if (PyString_Check(v)) {
		char *s = PyString_AS_STRING(v);
		int len = PyString_GET_SIZE(v);
		if (len &gt; 0 &amp;&amp;
		    isspace(Py_CHARMASK(s[len-1])) &amp;&amp;
		    s[len-1] != ' ')
			PyFile_SoftSpace(w, 0);
	    } 
#ifdef Py_USING_UNICODE
	    else if (PyUnicode_Check(v)) {
		Py_UNICODE *s = PyUnicode_AS_UNICODE(v);
		int len = PyUnicode_GET_SIZE(v);
		if (len &gt; 0 &amp;&amp;
		    Py_UNICODE_ISSPACE(s[len-1]) &amp;&amp;
		    s[len-1] != ' ')
		    PyFile_SoftSpace(w, 0);
	    }
#endif
	}
	Py_DECREF(v);
	Py_XDECREF(stream);
	stream = NULL;
	if (err == 0)
		continue;
	break;

case PRINT_NEWLINE_TO:
	w = stream = POP();
	/* fall through to PRINT_NEWLINE */

case PRINT_NEWLINE:
	if (stream == NULL || stream == Py_None) {
		w = PySys_GetObject("stdout");
		if (w == NULL)
			PyErr_SetString(PyExc_RuntimeError,
					"lost sys.stdout");
	}
	if (w != NULL) {
		err = PyFile_WriteString("\n", w);
		if (err == 0)
			PyFile_SoftSpace(w, 0);
	}
	Py_XDECREF(stream);
	stream = NULL;
	break;</t>
<t tx="T833">case POP_TOP:
	v = POP();
	Py_DECREF(v);
	continue;

case ROT_TWO:
	v = POP();
	w = POP();
	PUSH(v);
	PUSH(w);
	continue;

case ROT_THREE:
	v = POP();
	w = POP();
	x = POP();
	PUSH(v);
	PUSH(x);
	PUSH(w);
	continue;

case ROT_FOUR:
	u = POP();
	v = POP();
	w = POP();
	x = POP();
	PUSH(u);
	PUSH(x);
	PUSH(w);
	PUSH(v);
	continue;

case DUP_TOP:
	v = TOP();
	Py_INCREF(v);
	PUSH(v);
	continue;

case DUP_TOPX:
	switch (oparg) {
	case 1:
		x = TOP();
		Py_INCREF(x);
		PUSH(x);
		continue;
	case 2:
		x = POP();
		Py_INCREF(x);
		w = TOP();
		Py_INCREF(w);
		PUSH(x);
		PUSH(w);
		PUSH(x);
		continue;
	case 3:
		x = POP();
		Py_INCREF(x);
		w = POP();
		Py_INCREF(w);
		v = TOP();
		Py_INCREF(v);
		PUSH(w);
		PUSH(x);
		PUSH(v);
		PUSH(w);
		PUSH(x);
		continue;
	case 4:
		x = POP();
		Py_INCREF(x);
		w = POP();
		Py_INCREF(w);
		v = POP();
		Py_INCREF(v);
		u = TOP();
		Py_INCREF(u);
		PUSH(v);
		PUSH(w);
		PUSH(x);
		PUSH(u);
		PUSH(v);
		PUSH(w);
		PUSH(x);
		continue;
	case 5:
		x = POP();
		Py_INCREF(x);
		w = POP();
		Py_INCREF(w);
		v = POP();
		Py_INCREF(v);
		u = POP();
		Py_INCREF(u);
		t = TOP();
		Py_INCREF(t);
		PUSH(u);
		PUSH(v);
		PUSH(w);
		PUSH(x);
		PUSH(t);
		PUSH(u);
		PUSH(v);
		PUSH(w);
		PUSH(x);
		continue;
	default:
		Py_FatalError("invalid argument to DUP_TOPX"
			      " (bytecode corruption?)");
	}
	break;</t>
<t tx="T834">case SLICE+0:
case SLICE+1:
case SLICE+2:
case SLICE+3:
	if ((opcode-SLICE) &amp; 2)
		w = POP();
	else
		w = NULL;
	if ((opcode-SLICE) &amp; 1)
		v = POP();
	else
		v = NULL;
	u = POP();
	x = apply_slice(u, v, w);
	Py_DECREF(u);
	Py_XDECREF(v);
	Py_XDECREF(w);
	PUSH(x);
	if (x != NULL) continue;
	break;

case STORE_SLICE+0:
case STORE_SLICE+1:
case STORE_SLICE+2:
case STORE_SLICE+3:
	if ((opcode-STORE_SLICE) &amp; 2)
		w = POP();
	else
		w = NULL;
	if ((opcode-STORE_SLICE) &amp; 1)
		v = POP();
	else
		v = NULL;
	u = POP();
	t = POP();
	err = assign_slice(u, v, w, t); /* u[v:w] = t */
	Py_DECREF(t);
	Py_DECREF(u);
	Py_XDECREF(v);
	Py_XDECREF(w);
	if (err == 0) continue;
	break;

case DELETE_SLICE+0:
case DELETE_SLICE+1:
case DELETE_SLICE+2:
case DELETE_SLICE+3:
	if ((opcode-DELETE_SLICE) &amp; 2)
		w = POP();
	else
		w = NULL;
	if ((opcode-DELETE_SLICE) &amp; 1)
		v = POP();
	else
		v = NULL;
	u = POP();
	err = assign_slice(u, v, w, (PyObject *)NULL);
					/* del u[v:w] */
	Py_DECREF(u);
	Py_XDECREF(v);
	Py_XDECREF(w);
	if (err == 0) continue;
	break;</t>
<t tx="T835">case STORE_SUBSCR:
	w = POP();
	v = POP();
	u = POP();
	/* v[w] = u */
	err = PyObject_SetItem(v, w, u);
	Py_DECREF(u);
	Py_DECREF(v);
	Py_DECREF(w);
	if (err == 0) continue;
	break;

case DELETE_SUBSCR:
	w = POP();
	v = POP();
	/* del v[w] */
	err = PyObject_DelItem(v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	if (err == 0) continue;
	break;</t>
<t tx="T836">on_error:

/* Quickly continue if no error occurred */

if (why == WHY_NOT) {
	if (err == 0 &amp;&amp; x != NULL) {
#ifdef CHECKEXC
		/* This check is expensive! */
		if (PyErr_Occurred())
			fprintf(stderr,
				"XXX undetected error\n");
		else
#endif
			continue; /* Normal, fast path */
	}
	why = WHY_EXCEPTION;
	x = Py_None;
	err = 0;
}

/* Double-check exception status */

if (why == WHY_EXCEPTION || why == WHY_RERAISE) {
	if (!PyErr_Occurred()) {
		PyErr_SetString(PyExc_SystemError,
			"error return without exception set");
		why = WHY_EXCEPTION;
	}
}
#ifdef CHECKEXC
else {
	/* This check is expensive! */
	if (PyErr_Occurred()) {
		fprintf(stderr,
			"XXX undetected error (why=%d)\n",
			why);
		why = WHY_EXCEPTION;
	}
}
#endif

/* Log traceback info if this is a real exception */

if (why == WHY_EXCEPTION) {
	f-&gt;f_lasti = INSTR_OFFSET() - 1;
	if (HAS_ARG(opcode))
		f-&gt;f_lasti -= 2;
	PyTraceBack_Here(f);

	if (tstate-&gt;c_tracefunc != NULL)
		call_exc_trace(tstate-&gt;c_tracefunc,
			       tstate-&gt;c_traceobj, f);
}

/* For the rest, treat WHY_RERAISE as WHY_EXCEPTION */

if (why == WHY_RERAISE)
	why = WHY_EXCEPTION;

/* Unwind stacks if a (pseudo) exception occurred */

while (why != WHY_NOT &amp;&amp; why != WHY_YIELD &amp;&amp; f-&gt;f_iblock &gt; 0) {
	PyTryBlock *b = PyFrame_BlockPop(f);

	if (b-&gt;b_type == SETUP_LOOP &amp;&amp; why == WHY_CONTINUE) {
		/* For a continue inside a try block,
		   don't pop the block for the loop. */
		PyFrame_BlockSetup(f, b-&gt;b_type, b-&gt;b_handler,
				   b-&gt;b_level);
		why = WHY_NOT;
		JUMPTO(PyInt_AS_LONG(retval));
		Py_DECREF(retval);
		break;
	}

	while (STACK_LEVEL() &gt; b-&gt;b_level) {
		v = POP();
		Py_XDECREF(v);
	}
	if (b-&gt;b_type == SETUP_LOOP &amp;&amp; why == WHY_BREAK) {
		why = WHY_NOT;
		JUMPTO(b-&gt;b_handler);
		break;
	}
	if (b-&gt;b_type == SETUP_FINALLY ||
	    (b-&gt;b_type == SETUP_EXCEPT &amp;&amp;
	     why == WHY_EXCEPTION)) {
		if (why == WHY_EXCEPTION) {
			PyObject *exc, *val, *tb;
			PyErr_Fetch(&amp;exc, &amp;val, &amp;tb);
			if (val == NULL) {
				val = Py_None;
				Py_INCREF(val);
			}
			/* Make the raw exception data
			   available to the handler,
			   so a program can emulate the
			   Python main loop.  Don't do
			   this for 'finally'. */
			if (b-&gt;b_type == SETUP_EXCEPT) {
				PyErr_NormalizeException(
					&amp;exc, &amp;val, &amp;tb);
				set_exc_info(tstate,
					     exc, val, tb);
			}
			if (tb == NULL) {
				Py_INCREF(Py_None);
				PUSH(Py_None);
			} else
				PUSH(tb);
			PUSH(val);
			PUSH(exc);
		}
		else {
			if (why == WHY_RETURN ||
			    why == CONTINUE_LOOP)
				PUSH(retval);
			v = PyInt_FromLong((long)why);
			PUSH(v);
		}
		why = WHY_NOT;
		JUMPTO(b-&gt;b_handler);
		break;
	}
} /* unwind stack */

/* End the loop if we still have an error (or return) */

if (why != WHY_NOT)
	break;</t>
<t tx="T837">if (why != WHY_YIELD) {
	/* Pop remaining stack entries -- but when yielding */
	while (!EMPTY()) {
		v = POP();
		Py_XDECREF(v);
	}
}

if (why != WHY_RETURN &amp;&amp; why != WHY_YIELD)
	retval = NULL;

if (tstate-&gt;use_tracing) {
	if (tstate-&gt;c_tracefunc
	    &amp;&amp; (why == WHY_RETURN || why == WHY_YIELD)) {
		if (call_trace(tstate-&gt;c_tracefunc,
			       tstate-&gt;c_traceobj, f,
			       PyTrace_RETURN, retval)) {
			Py_XDECREF(retval);
			retval = NULL;
			why = WHY_EXCEPTION;
		}
	}
	if (tstate-&gt;c_profilefunc) {
		if (why == WHY_EXCEPTION)
			call_trace_protected(tstate-&gt;c_profilefunc,
					     tstate-&gt;c_profileobj, f,
					     PyTrace_RETURN);
		else if (call_trace(tstate-&gt;c_profilefunc,
				    tstate-&gt;c_profileobj, f,
				    PyTrace_RETURN, retval)) {
			Py_XDECREF(retval);
			retval = NULL;
			why = WHY_EXCEPTION;
		}
	}
}

reset_exc_info(tstate);

/* pop frame */
--tstate-&gt;recursion_depth;
tstate-&gt;frame = f-&gt;f_back;</t>
<t tx="T838"></t>
<t tx="T839">@ Mechanism whereby asynchronously executing callbacks (e.g. UNIX signal handlers or Mac I/O completion routines) can schedule calls to a function to be called synchronously.

The synchronous function is called with one void* argument. It should return 0 for success or -1 for failure -- failure should be accompanied by an exception. If registry succeeds, the registry function returns 0; if it fails (e.g. due to too many pending calls) it returns -1 (without setting an exception condition).

Note that because registry may occur from within signal handlers, or other asynchronous events, calling malloc() is unsafe! #ifdef WITH_THREAD Any thread can schedule pending calls, but only the main thread will execute them. #endif

XXX WARNING! ASYNCHRONOUSLY EXECUTING CODE! There are two possible race conditions:
(1) nested asynchronous registry calls;
(2) registry calls made while pending calls are being processed.

While (1) is very unlikely, (2) is a real possibility. The current code is safe against (2), but not against (1). The safety against (2) is derived from the fact that only one thread (the main thread) ever takes things out of the queue.

XXX Darn! With the advent of thread state, we should have an array of pending calls per thread in the thread state! Later...</t>
<t tx="T840">#define NPENDINGCALLS 32

static struct {
	int (*func)(void *);
	void *arg;
} pendingcalls[NPENDINGCALLS];

static volatile int pendingfirst = 0;
static volatile int pendinglast = 0;
static volatile int things_to_do = 0;

int
Py_AddPendingCall(int (*func)(void *), void *arg)
{
	static int busy = 0;
	int i, j;
	/* XXX Begin critical section */
	/* XXX If you want this to be safe against nested
	   XXX asynchronous calls, you'll have to work harder! */
	if (busy)
		return -1;
	busy = 1;
	i = pendinglast;
	j = (i + 1) % NPENDINGCALLS;
	if (j == pendingfirst)
		return -1; /* Queue full */
	pendingcalls[i].func = func;
	pendingcalls[i].arg = arg;
	pendinglast = j;
	things_to_do = 1; /* Signal main loop */
	busy = 0;
	/* XXX End critical section */
	return 0;
}</t>
<t tx="T841">int
Py_MakePendingCalls(void)
{
	static int busy = 0;
#ifdef WITH_THREAD
	if (main_thread &amp;&amp; PyThread_get_thread_ident() != main_thread)
		return 0;
#endif
	if (busy)
		return 0;
	busy = 1;
	things_to_do = 0;
	for (;;) {
		int i;
		int (*func)(void *);
		void *arg;
		i = pendingfirst;
		if (i == pendinglast)
			break; /* Queue empty */
		func = pendingcalls[i].func;
		arg = pendingcalls[i].arg;
		pendingfirst = (i + 1) % NPENDINGCALLS;
		if (func(arg) &lt; 0) {
			busy = 0;
			things_to_do = 1; /* We're not done yet */
			return -1;
		}
	}
	busy = 0;
	return 0;
}
</t>
<t tx="T842">@ Status code for main loop (reason for stack unwind) */
@c

enum why_code {
		WHY_NOT,	/* No error */
		WHY_EXCEPTION,	/* Exception occurred */
		WHY_RERAISE,	/* Exception re-raised by 'finally' */
		WHY_RETURN,	/* 'return' statement */
		WHY_BREAK,	/* 'break' statement */
		WHY_CONTINUE,	/* 'continue' statement */
		WHY_YIELD	/* 'yield' operator */
};

static enum why_code do_raise(PyObject *, PyObject *, PyObject *);
static int unpack_iterable(PyObject *, int, PyObject **);


PyObject *
PyEval_EvalCode(PyCodeObject *co, PyObject *globals, PyObject *locals)
{
	return PyEval_EvalCodeEx(co,
			  globals, locals,
			  (PyObject **)NULL, 0,
			  (PyObject **)NULL, 0,
			  (PyObject **)NULL, 0,
			  NULL);
}
</t>
<t tx="T843">PyObject *
PyEval_EvalCodeEx(PyCodeObject *co, PyObject *globals, PyObject *locals,
	   PyObject **args, int argcount, PyObject **kws, int kwcount,
	   PyObject **defs, int defcount, PyObject *closure)
{
	register PyFrameObject *f;
	register PyObject *retval = NULL;
	register PyObject **fastlocals, **freevars;
	PyThreadState *tstate = PyThreadState_GET();
	PyObject *x, *u;

	if (globals == NULL) {
		PyErr_SetString(PyExc_SystemError, 
				"PyEval_EvalCodeEx: NULL globals");
		return NULL;
	}

	f = PyFrame_New(tstate,			/*back*/
			co,			/*code*/
			globals, locals);
	if (f == NULL)
		return NULL;

	fastlocals = f-&gt;f_localsplus;
	freevars = f-&gt;f_localsplus + f-&gt;f_nlocals;

	if (co-&gt;co_argcount &gt; 0 ||
	    co-&gt;co_flags &amp; (CO_VARARGS | CO_VARKEYWORDS)) {
		int i;
		int n = argcount;
		PyObject *kwdict = NULL;
		if (co-&gt;co_flags &amp; CO_VARKEYWORDS) {
			kwdict = PyDict_New();
			if (kwdict == NULL)
				goto fail;
			i = co-&gt;co_argcount;
			if (co-&gt;co_flags &amp; CO_VARARGS)
				i++;
			SETLOCAL(i, kwdict);
		}
		if (argcount &gt; co-&gt;co_argcount) {
			if (!(co-&gt;co_flags &amp; CO_VARARGS)) {
				PyErr_Format(PyExc_TypeError,
				    "%.200s() takes %s %d "
				    "%sargument%s (%d given)",
				    PyString_AsString(co-&gt;co_name),
				    defcount ? "at most" : "exactly",
				    co-&gt;co_argcount,
				    kwcount ? "non-keyword " : "",
				    co-&gt;co_argcount == 1 ? "" : "s",
				    argcount);
				goto fail;
			}
			n = co-&gt;co_argcount;
		}
		for (i = 0; i &lt; n; i++) {
			x = args[i];
			Py_INCREF(x);
			SETLOCAL(i, x);
		}
		if (co-&gt;co_flags &amp; CO_VARARGS) {
			u = PyTuple_New(argcount - n);
			if (u == NULL)
				goto fail;
			SETLOCAL(co-&gt;co_argcount, u);
			for (i = n; i &lt; argcount; i++) {
				x = args[i];
				Py_INCREF(x);
				PyTuple_SET_ITEM(u, i-n, x);
			}
		}
		for (i = 0; i &lt; kwcount; i++) {
			PyObject *keyword = kws[2*i];
			PyObject *value = kws[2*i + 1];
			int j;
			if (keyword == NULL || !PyString_Check(keyword)) {
				PyErr_Format(PyExc_TypeError,
				    "%.200s() keywords must be strings",
				    PyString_AsString(co-&gt;co_name));
				goto fail;
			}
			/* XXX slow -- speed up using dictionary? */
			for (j = 0; j &lt; co-&gt;co_argcount; j++) {
				PyObject *nm = PyTuple_GET_ITEM(
					co-&gt;co_varnames, j);
				int cmp = PyObject_RichCompareBool(
					keyword, nm, Py_EQ);
				if (cmp &gt; 0)
					break;
				else if (cmp &lt; 0)
					goto fail;
			}
			/* Check errors from Compare */
			if (PyErr_Occurred())
				goto fail;
			if (j &gt;= co-&gt;co_argcount) {
				if (kwdict == NULL) {
					PyErr_Format(PyExc_TypeError,
					    "%.200s() got an unexpected "
					    "keyword argument '%.400s'",
					    PyString_AsString(co-&gt;co_name),
					    PyString_AsString(keyword));
					goto fail;
				}
				PyDict_SetItem(kwdict, keyword, value);
			}
			else {
				if (GETLOCAL(j) != NULL) {
					PyErr_Format(PyExc_TypeError,
					     "%.200s() got multiple "
					     "values for keyword "
					     "argument '%.400s'",
					     PyString_AsString(co-&gt;co_name),
					     PyString_AsString(keyword));
					goto fail;
				}
				Py_INCREF(value);
				SETLOCAL(j, value);
			}
		}
		if (argcount &lt; co-&gt;co_argcount) {
			int m = co-&gt;co_argcount - defcount;
			for (i = argcount; i &lt; m; i++) {
				if (GETLOCAL(i) == NULL) {
					PyErr_Format(PyExc_TypeError,
					    "%.200s() takes %s %d "
					    "%sargument%s (%d given)",
					    PyString_AsString(co-&gt;co_name),
					    ((co-&gt;co_flags &amp; CO_VARARGS) ||
					     defcount) ? "at least"
						       : "exactly",
					    m, kwcount ? "non-keyword " : "",
					    m == 1 ? "" : "s", i);
					goto fail;
				}
			}
			if (n &gt; m)
				i = n - m;
			else
				i = 0;
			for (; i &lt; defcount; i++) {
				if (GETLOCAL(m+i) == NULL) {
					PyObject *def = defs[i];
					Py_INCREF(def);
					SETLOCAL(m+i, def);
				}
			}
		}
	}
	else {
		if (argcount &gt; 0 || kwcount &gt; 0) {
			PyErr_Format(PyExc_TypeError,
				     "%.200s() takes no arguments (%d given)",
				     PyString_AsString(co-&gt;co_name),
				     argcount + kwcount);
			goto fail;
		}
	}
	/* Allocate and initialize storage for cell vars, and copy free
	   vars into frame.  This isn't too efficient right now. */
	if (f-&gt;f_ncells) {
		int i = 0, j = 0, nargs, found;
		char *cellname, *argname;
		PyObject *c;

		nargs = co-&gt;co_argcount;
		if (co-&gt;co_flags &amp; CO_VARARGS)
			nargs++;
		if (co-&gt;co_flags &amp; CO_VARKEYWORDS)
			nargs++;

		/* Check for cells that shadow args */
		for (i = 0; i &lt; f-&gt;f_ncells &amp;&amp; j &lt; nargs; ++i) {
			cellname = PyString_AS_STRING(
				PyTuple_GET_ITEM(co-&gt;co_cellvars, i));
			found = 0;
			while (j &lt; nargs) {
				argname = PyString_AS_STRING(
					PyTuple_GET_ITEM(co-&gt;co_varnames, j));
				if (strcmp(cellname, argname) == 0) {
					c = PyCell_New(GETLOCAL(j));
					if (c == NULL)
						goto fail;
					GETLOCAL(f-&gt;f_nlocals + i) = c;
					found = 1;
					break;
				}
				j++;
			}
			if (found == 0) {
				c = PyCell_New(NULL);
				if (c == NULL)
					goto fail;
				SETLOCAL(f-&gt;f_nlocals + i, c);
			}
		}
		/* Initialize any that are left */
		while (i &lt; f-&gt;f_ncells) {
			c = PyCell_New(NULL);
			if (c == NULL)
				goto fail;
			SETLOCAL(f-&gt;f_nlocals + i, c);
			i++;
		}
	}
	if (f-&gt;f_nfreevars) {
		int i;
		for (i = 0; i &lt; f-&gt;f_nfreevars; ++i) {
			PyObject *o = PyTuple_GET_ITEM(closure, i);
			Py_INCREF(o);
			freevars[f-&gt;f_ncells + i] = o;
		}
	}

	if (co-&gt;co_flags &amp; CO_GENERATOR) {
		/* Don't need to keep the reference to f_back, it will be set
		 * when the generator is resumed. */
		Py_XDECREF(f-&gt;f_back);
		f-&gt;f_back = NULL;

		/* Create a new generator that owns the ready to run frame
		 * and return that as the value. */
		return gen_new(f);
	}

        retval = eval_frame(f);

  fail: /* Jump here from prelude on failure */

	/* decref'ing the frame can cause __del__ methods to get invoked,
	   which can call back into Python.  While we're done with the
	   current Python frame (f), the associated C stack is still in use,
	   so recursion_depth must be boosted for the duration.
	*/
	assert(tstate != NULL);
	++tstate-&gt;recursion_depth;
        Py_DECREF(f);
	--tstate-&gt;recursion_depth;
	return retval;
}
</t>
<t tx="T844"></t>
<t tx="T845">@ The interpreter's recursion limit */
@c

static int recursion_limit = 1000;

int
Py_GetRecursionLimit(void)
{
	return recursion_limit;
}
</t>
<t tx="T846">void
Py_SetRecursionLimit(int new_limit)
{
	recursion_limit = new_limit;
}
</t>
<t tx="T847">PyObject *
PyEval_GetBuiltins(void)
{
	PyThreadState *tstate = PyThreadState_Get();
	PyFrameObject *current_frame = tstate-&gt;frame;
	if (current_frame == NULL)
		return tstate-&gt;interp-&gt;builtins;
	else
		return current_frame-&gt;f_builtins;
}
</t>
<t tx="T848">PyObject *
PyEval_GetFrame(void)
{
	PyFrameObject *current_frame = PyThreadState_Get()-&gt;frame;
	return (PyObject *)current_frame;
}
</t>
<t tx="T849">char *
PyEval_GetFuncDesc(PyObject *func)
{
	if (PyMethod_Check(func))
		return "()";
	else if (PyFunction_Check(func))
		return "()";
	else if (PyCFunction_Check(func))
		return "()";
	else if (PyClass_Check(func))
		return " constructor";
	else if (PyInstance_Check(func)) {
		return " instance";
	} else {
		return " object";
	}
}
</t>
<t tx="T850">char *
PyEval_GetFuncName(PyObject *func)
{
	if (PyMethod_Check(func))
		return PyEval_GetFuncName(PyMethod_GET_FUNCTION(func));
	else if (PyFunction_Check(func))
		return PyString_AsString(((PyFunctionObject*)func)-&gt;func_name);
	else if (PyCFunction_Check(func))
		return ((PyCFunctionObject*)func)-&gt;m_ml-&gt;ml_name;
	else if (PyClass_Check(func))
		return PyString_AsString(((PyClassObject*)func)-&gt;cl_name);
	else if (PyInstance_Check(func)) {
		return PyString_AsString(
			((PyInstanceObject*)func)-&gt;in_class-&gt;cl_name);
	} else {
		return func-&gt;ob_type-&gt;tp_name;
	}
}
</t>
<t tx="T851">PyObject *
PyEval_GetGlobals(void)
{
	PyFrameObject *current_frame = PyThreadState_Get()-&gt;frame;
	if (current_frame == NULL)
		return NULL;
	else
		return current_frame-&gt;f_globals;
}
</t>
<t tx="T852">PyObject *
PyEval_GetLocals(void)
{
	PyFrameObject *current_frame = PyThreadState_Get()-&gt;frame;
	if (current_frame == NULL)
		return NULL;
	PyFrame_FastToLocals(current_frame);
	return current_frame-&gt;f_locals;
}
</t>
<t tx="T853">int
PyEval_GetRestricted(void)
{
	PyFrameObject *current_frame = PyThreadState_Get()-&gt;frame;
	return current_frame == NULL ? 0 : current_frame-&gt;f_restricted;
}
</t>
<t tx="T854">void
PyEval_SetProfile(Py_tracefunc func, PyObject *arg)
{
	PyThreadState *tstate = PyThreadState_Get();
	PyObject *temp = tstate-&gt;c_profileobj;
	Py_XINCREF(arg);
	tstate-&gt;c_profilefunc = NULL;
	tstate-&gt;c_profileobj = NULL;
	tstate-&gt;use_tracing = tstate-&gt;c_tracefunc != NULL;
	Py_XDECREF(temp);
	tstate-&gt;c_profilefunc = func;
	tstate-&gt;c_profileobj = arg;
	tstate-&gt;use_tracing = (func != NULL) || (tstate-&gt;c_tracefunc != NULL);
}
</t>
<t tx="T855">void
PyEval_SetTrace(Py_tracefunc func, PyObject *arg)
{
	PyThreadState *tstate = PyThreadState_Get();
	PyObject *temp = tstate-&gt;c_traceobj;
	Py_XINCREF(arg);
	tstate-&gt;c_tracefunc = NULL;
	tstate-&gt;c_traceobj = NULL;
	tstate-&gt;use_tracing = tstate-&gt;c_profilefunc != NULL;
	Py_XDECREF(temp);
	tstate-&gt;c_tracefunc = func;
	tstate-&gt;c_traceobj = arg;
	tstate-&gt;use_tracing = ((func != NULL)
			       || (tstate-&gt;c_profilefunc != NULL));
}
</t>
<t tx="T856">int
PyEval_MergeCompilerFlags(PyCompilerFlags *cf)
{
	PyFrameObject *current_frame = PyThreadState_Get()-&gt;frame;
	int result = 0;

	if (current_frame != NULL) {
		const int codeflags = current_frame-&gt;f_code-&gt;co_flags;
		const int compilerflags = codeflags &amp; PyCF_MASK;
		if (compilerflags) {
			result = 1;
			cf-&gt;cf_flags |= compilerflags;
		}
	}
	return result;
}
</t>
<t tx="T857"></t>
<t tx="T858">static struct PyMethodDef gen_methods[] = {
	{"next",     (PyCFunction)gen_next, METH_NOARGS,
	 	"next() -- get the next value, or raise StopIteration"},
	{NULL,          NULL}   /* Sentinel */
};

static PyMemberDef gen_memberlist[] = {
	{"gi_frame",	T_OBJECT, offsetof(genobject, gi_frame),	RO},
	{"gi_running",	T_INT,    offsetof(genobject, gi_running),	RO},
	{NULL}	/* Sentinel */
};

statichere PyTypeObject gentype = {
	PyObject_HEAD_INIT(&amp;PyType_Type)
	0,					/* ob_size */
	"generator",				/* tp_name */
	sizeof(genobject) + PyGC_HEAD_SIZE,	/* tp_basicsize */
	0,					/* tp_itemsize */
	/* methods */
	(destructor)gen_dealloc, 		/* tp_dealloc */
	0,					/* tp_print */
	0, 					/* tp_getattr */
	0,					/* tp_setattr */
	0,					/* tp_compare */
	0,					/* tp_repr */
	0,					/* tp_as_number */
	0,					/* tp_as_sequence */
	0,					/* tp_as_mapping */
	0,					/* tp_hash */
	0,					/* tp_call */
	0,					/* tp_str */
	PyObject_GenericGetAttr,		/* tp_getattro */
	0,					/* tp_setattro */
	0,					/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_GC,	/* tp_flags */
 	0,					/* tp_doc */
 	(traverseproc)gen_traverse,		/* tp_traverse */
 	0,					/* tp_clear */
	0,					/* tp_richcompare */
	0,					/* tp_weaklistoffset */
	(getiterfunc)gen_getiter,		/* tp_iter */
	(iternextfunc)gen_iternext,		/* tp_iternext */
	gen_methods,				/* tp_methods */
	gen_memberlist,				/* tp_members */
	0,					/* tp_getset */
	0,					/* tp_base */
	0,					/* tp_dict */
};


#ifdef WITH_THREAD

#ifndef DONT_HAVE_ERRNO_H
#include &lt;errno.h&gt;
#endif
#include "pythread.h"

extern int _PyThread_Started; /* Flag for Py_Exit */

static PyThread_type_lock interpreter_lock = 0;
static long main_thread = 0;

void
PyEval_InitThreads(void)
{
	if (interpreter_lock)
		return;
	_PyThread_Started = 1;
	interpreter_lock = PyThread_allocate_lock();
	PyThread_acquire_lock(interpreter_lock, 1);
	main_thread = PyThread_get_thread_ident();
}
</t>
<t tx="T859">void
PyEval_AcquireLock(void)
{
	PyThread_acquire_lock(interpreter_lock, 1);
}
</t>
<t tx="T860">void
PyEval_ReleaseLock(void)
{
	PyThread_release_lock(interpreter_lock);
}
</t>
<t tx="T861">void
PyEval_AcquireThread(PyThreadState *tstate)
{
	if (tstate == NULL)
		Py_FatalError("PyEval_AcquireThread: NULL new thread state");
	PyThread_acquire_lock(interpreter_lock, 1);
	if (PyThreadState_Swap(tstate) != NULL)
		Py_FatalError(
			"PyEval_AcquireThread: non-NULL old thread state");
}
</t>
<t tx="T862">void
PyEval_ReleaseThread(PyThreadState *tstate)
{
	if (tstate == NULL)
		Py_FatalError("PyEval_ReleaseThread: NULL thread state");
	if (PyThreadState_Swap(NULL) != tstate)
		Py_FatalError("PyEval_ReleaseThread: wrong thread state");
	PyThread_release_lock(interpreter_lock);
}
</t>
<t tx="T863">@ This function is called from PyOS_AfterFork to ensure that newly created child processes don't hold locks referring to threads which are not running in the child process. (This could also be done using pthread_atfork mechanism, at least for the pthreads implementation.) */
@c

void
PyEval_ReInitThreads(void)
{
	if (!interpreter_lock)
		return;
	/*XXX Can't use PyThread_free_lock here because it does too
	  much error-checking.  Doing this cleanly would require
	  adding a new function to each thread_*.h.  Instead, just
	  create a new lock and waste a little bit of memory */
	interpreter_lock = PyThread_allocate_lock();
	PyThread_acquire_lock(interpreter_lock, 1);
	main_thread = PyThread_get_thread_ident();
}
</t>
<t tx="T864">#endif

/* Functions save_thread and restore_thread are always defined so
   dynamically loaded modules needn't be compiled separately for use
   with and without threads: */

PyThreadState *
PyEval_SaveThread(void)
{
	PyThreadState *tstate = PyThreadState_Swap(NULL);
	if (tstate == NULL)
		Py_FatalError("PyEval_SaveThread: NULL tstate");
#ifdef WITH_THREAD
	if (interpreter_lock)
		PyThread_release_lock(interpreter_lock);
#endif
	return tstate;
}
</t>
<t tx="T865">void
PyEval_RestoreThread(PyThreadState *tstate)
{
	if (tstate == NULL)
		Py_FatalError("PyEval_RestoreThread: NULL tstate");
#ifdef WITH_THREAD
	if (interpreter_lock) {
		int err = errno;
		PyThread_acquire_lock(interpreter_lock, 1);
		errno = err;
	}
#endif
	PyThreadState_Swap(tstate);
}
</t>
<t tx="T866"></t>
<t tx="T867">PyObject *
_Py_GetDXProfile(PyObject *self, PyObject *args)
{
	#ifndef DXPAIRS
		return getarray(dxp);
	#else
		int i;
		PyObject *l = PyList_New(257);
		if (l == NULL) return NULL;
		for (i = 0; i &lt; 257; i++) {
			PyObject *x = getarray(dxpairs[i]);
			if (x == NULL) {
				Py_DECREF(l);
				return NULL;
			}
			PyList_SetItem(l, i, x);
		}
		return l;
	#endif
}</t>
<t tx="T868">static PyObject *
build_class(PyObject *methods, PyObject *bases, PyObject *name)
{
	PyObject *metaclass = NULL, *result, *base;

	if (PyDict_Check(methods))
		metaclass = PyDict_GetItemString(methods, "__metaclass__");
	if (metaclass != NULL)
		Py_INCREF(metaclass);
	else if (PyTuple_Check(bases) &amp;&amp; PyTuple_GET_SIZE(bases) &gt; 0) {
		base = PyTuple_GET_ITEM(bases, 0);
		metaclass = PyObject_GetAttrString(base, "__class__");
		if (metaclass == NULL) {
			PyErr_Clear();
			metaclass = (PyObject *)base-&gt;ob_type;
			Py_INCREF(metaclass);
		}
	}
	else {
		PyObject *g = PyEval_GetGlobals();
		if (g != NULL &amp;&amp; PyDict_Check(g))
			metaclass = PyDict_GetItemString(g, "__metaclass__");
		if (metaclass == NULL)
			metaclass = (PyObject *) &amp;PyClass_Type;
		Py_INCREF(metaclass);
	}
	result = PyObject_CallFunction(metaclass, "OOO", name, bases, methods);
	Py_DECREF(metaclass);
	return result;
}
</t>
<t tx="T869">static PyObject *
cmp_outcome(int op, register PyObject *v, register PyObject *w)
{
	int res = 0;
	switch (op) {
	case IS:
	case IS_NOT:
		res = (v == w);
		if (op == (int) IS_NOT)
			res = !res;
		break;
	case IN:
	case NOT_IN:
		res = PySequence_Contains(w, v);
		if (res &lt; 0)
			return NULL;
		if (op == (int) NOT_IN)
			res = !res;
		break;
	case EXC_MATCH:
		res = PyErr_GivenExceptionMatches(v, w);
		break;
	default:
		return PyObject_RichCompare(v, w, op);
	}
	v = res ? Py_True : Py_False;
	Py_INCREF(v);
	return v;
}
</t>
<t tx="T870"></t>
<t tx="T871">@ Logic for the raise statement (too complicated for inlining). This *consumes* a reference count to each of its arguments. */
@c

static enum why_code
do_raise(PyObject *type, PyObject *value, PyObject *tb)
{
	if (type == NULL) {
		/* Reraise */
		PyThreadState *tstate = PyThreadState_Get();
		type = tstate-&gt;exc_type == NULL ? Py_None : tstate-&gt;exc_type;
		value = tstate-&gt;exc_value;
		tb = tstate-&gt;exc_traceback;
		Py_XINCREF(type);
		Py_XINCREF(value);
		Py_XINCREF(tb);
	}

	/* We support the following forms of raise:
	   raise &lt;class&gt;, &lt;classinstance&gt;
	   raise &lt;class&gt;, &lt;argument tuple&gt;
	   raise &lt;class&gt;, None
	   raise &lt;class&gt;, &lt;argument&gt;
	   raise &lt;classinstance&gt;, None
	   raise &lt;string&gt;, &lt;object&gt;
	   raise &lt;string&gt;, None

	   An omitted second argument is the same as None.

	   In addition, raise &lt;tuple&gt;, &lt;anything&gt; is the same as
	   raising the tuple's first item (and it better have one!);
	   this rule is applied recursively.

	   Finally, an optional third argument can be supplied, which
	   gives the traceback to be substituted (useful when
	   re-raising an exception after examining it).  */

	/* First, check the traceback argument, replacing None with
	   NULL. */
	if (tb == Py_None) {
		Py_DECREF(tb);
		tb = NULL;
	}
	else if (tb != NULL &amp;&amp; !PyTraceBack_Check(tb)) {
		PyErr_SetString(PyExc_TypeError,
			   "raise: arg 3 must be a traceback or None");
		goto raise_error;
	}

	/* Next, replace a missing value with None */
	if (value == NULL) {
		value = Py_None;
		Py_INCREF(value);
	}

	/* Next, repeatedly, replace a tuple exception with its first item */
	while (PyTuple_Check(type) &amp;&amp; PyTuple_Size(type) &gt; 0) {
		PyObject *tmp = type;
		type = PyTuple_GET_ITEM(type, 0);
		Py_INCREF(type);
		Py_DECREF(tmp);
	}

	if (PyString_Check(type))
		;

	else if (PyClass_Check(type))
		PyErr_NormalizeException(&amp;type, &amp;value, &amp;tb);

	else if (PyInstance_Check(type)) {
		/* Raising an instance.  The value should be a dummy. */
		if (value != Py_None) {
			PyErr_SetString(PyExc_TypeError,
			  "instance exception may not have a separate value");
			goto raise_error;
		}
		else {
			/* Normalize to raise &lt;class&gt;, &lt;instance&gt; */
			Py_DECREF(value);
			value = type;
			type = (PyObject*) ((PyInstanceObject*)type)-&gt;in_class;
			Py_INCREF(type);
		}
	}
	else {
		/* Not something you can raise.  You get an exception
		   anyway, just not what you specified :-) */
		PyErr_Format(PyExc_TypeError,
			     "exceptions must be strings, classes, or "
			     "instances, not %s", type-&gt;ob_type-&gt;tp_name);
		goto raise_error;
	}
	PyErr_Restore(type, value, tb);
	if (tb == NULL)
		return WHY_EXCEPTION;
	else
		return WHY_RERAISE;
 raise_error:
	Py_XDECREF(value);
	Py_XDECREF(type);
	Py_XDECREF(tb);
	return WHY_EXCEPTION;
}
</t>
<t tx="T872">static void
format_exc_check_arg(PyObject *exc, char *format_str, PyObject *obj)
{
	char *obj_str;

	if (!obj)
		return;

	obj_str = PyString_AsString(obj);
	if (!obj_str)
		return;

	PyErr_Format(exc, format_str, obj_str);
}
</t>
<t tx="T873">static void
reset_exc_info(PyThreadState *tstate)
{
	PyFrameObject *frame;
	PyObject *tmp_type, *tmp_value, *tmp_tb;
	frame = tstate-&gt;frame;
	if (frame-&gt;f_exc_type != NULL) {
		/* This frame caught an exception */
		tmp_type = tstate-&gt;exc_type;
		tmp_value = tstate-&gt;exc_value;
		tmp_tb = tstate-&gt;exc_traceback;
		Py_XINCREF(frame-&gt;f_exc_type);
		Py_XINCREF(frame-&gt;f_exc_value);
		Py_XINCREF(frame-&gt;f_exc_traceback);
		tstate-&gt;exc_type = frame-&gt;f_exc_type;
		tstate-&gt;exc_value = frame-&gt;f_exc_value;
		tstate-&gt;exc_traceback = frame-&gt;f_exc_traceback;
		Py_XDECREF(tmp_type);
		Py_XDECREF(tmp_value);
		Py_XDECREF(tmp_tb);
		/* For b/w compatibility */
		PySys_SetObject("exc_type", frame-&gt;f_exc_type);
		PySys_SetObject("exc_value", frame-&gt;f_exc_value);
		PySys_SetObject("exc_traceback", frame-&gt;f_exc_traceback);
	}
	tmp_type = frame-&gt;f_exc_type;
	tmp_value = frame-&gt;f_exc_value;
	tmp_tb = frame-&gt;f_exc_traceback;
	frame-&gt;f_exc_type = NULL;
	frame-&gt;f_exc_value = NULL;
	frame-&gt;f_exc_traceback = NULL;
	Py_XDECREF(tmp_type);
	Py_XDECREF(tmp_value);
	Py_XDECREF(tmp_tb);
}
</t>
<t tx="T874">static void
set_exc_info(PyThreadState *tstate,
	     PyObject *type, PyObject *value, PyObject *tb)
{
	PyFrameObject *frame;
	PyObject *tmp_type, *tmp_value, *tmp_tb;

	frame = tstate-&gt;frame;
	if (frame-&gt;f_exc_type == NULL) {
		/* This frame didn't catch an exception before */
		/* Save previous exception of this thread in this frame */
		if (tstate-&gt;exc_type == NULL) {
			Py_INCREF(Py_None);
			tstate-&gt;exc_type = Py_None;
		}
		tmp_type = frame-&gt;f_exc_type;
		tmp_value = frame-&gt;f_exc_value;
		tmp_tb = frame-&gt;f_exc_traceback;
		Py_XINCREF(tstate-&gt;exc_type);
		Py_XINCREF(tstate-&gt;exc_value);
		Py_XINCREF(tstate-&gt;exc_traceback);
		frame-&gt;f_exc_type = tstate-&gt;exc_type;
		frame-&gt;f_exc_value = tstate-&gt;exc_value;
		frame-&gt;f_exc_traceback = tstate-&gt;exc_traceback;
		Py_XDECREF(tmp_type);
		Py_XDECREF(tmp_value);
		Py_XDECREF(tmp_tb);
	}
	/* Set new exception for this thread */
	tmp_type = tstate-&gt;exc_type;
	tmp_value = tstate-&gt;exc_value;
	tmp_tb = tstate-&gt;exc_traceback;
	Py_XINCREF(type);
	Py_XINCREF(value);
	Py_XINCREF(tb);
	tstate-&gt;exc_type = type;
	tstate-&gt;exc_value = value;
	tstate-&gt;exc_traceback = tb;
	Py_XDECREF(tmp_type);
	Py_XDECREF(tmp_value);
	Py_XDECREF(tmp_tb);
	/* For b/w compatibility */
	PySys_SetObject("exc_type", type);
	PySys_SetObject("exc_value", value);
	PySys_SetObject("exc_traceback", tb);
}
</t>
<t tx="T875">static int
exec_statement(PyFrameObject *f, PyObject *prog, PyObject *globals,
	       PyObject *locals)
{
	int n;
	PyObject *v;
	int plain = 0;

	if (PyTuple_Check(prog) &amp;&amp; globals == Py_None &amp;&amp; locals == Py_None &amp;&amp;
	    ((n = PyTuple_Size(prog)) == 2 || n == 3)) {
		/* Backward compatibility hack */
		globals = PyTuple_GetItem(prog, 1);
		if (n == 3)
			locals = PyTuple_GetItem(prog, 2);
		prog = PyTuple_GetItem(prog, 0);
	}
	if (globals == Py_None) {
		globals = PyEval_GetGlobals();
		if (locals == Py_None) {
			locals = PyEval_GetLocals();
			plain = 1;
		}
	}
	else if (locals == Py_None)
		locals = globals;
	if (!PyString_Check(prog) &amp;&amp;
	    !PyUnicode_Check(prog) &amp;&amp;
	    !PyCode_Check(prog) &amp;&amp;
	    !PyFile_Check(prog)) {
		PyErr_SetString(PyExc_TypeError,
			"exec: arg 1 must be a string, file, or code object");
		return -1;
	}
	if (!PyDict_Check(globals)) {
		PyErr_SetString(PyExc_TypeError,
		    "exec: arg 2 must be a dictionary or None");
		return -1;
	}
	if (!PyDict_Check(locals)) {
		PyErr_SetString(PyExc_TypeError,
		    "exec: arg 3 must be a dictionary or None");
		return -1;
	}
	if (PyDict_GetItemString(globals, "__builtins__") == NULL)
		PyDict_SetItemString(globals, "__builtins__", f-&gt;f_builtins);
	if (PyCode_Check(prog)) {
		if (PyCode_GetNumFree((PyCodeObject *)prog) &gt; 0) {
			PyErr_SetString(PyExc_TypeError,
		"code object passed to exec may not contain free variables");
			return -1;
		}
		v = PyEval_EvalCode((PyCodeObject *) prog, globals, locals);
	}
	else if (PyFile_Check(prog)) {
		FILE *fp = PyFile_AsFile(prog);
		char *name = PyString_AsString(PyFile_Name(prog));
		PyCompilerFlags cf;
		cf.cf_flags = 0;
		if (PyEval_MergeCompilerFlags(&amp;cf))
			v = PyRun_FileFlags(fp, name, Py_file_input, globals,
					    locals, &amp;cf); 
		else
			v = PyRun_File(fp, name, Py_file_input, globals,
				       locals); 
	}
	else {
		char *str;
		PyCompilerFlags cf;
		if (PyString_AsStringAndSize(prog, &amp;str, NULL))
			return -1;
		cf.cf_flags = 0;
		if (PyEval_MergeCompilerFlags(&amp;cf))
			v = PyRun_StringFlags(str, Py_file_input, globals, 
					      locals, &amp;cf);
		else
			v = PyRun_String(str, Py_file_input, globals, locals);
	}
	if (plain)
		PyFrame_LocalsToFast(f, 0);
	if (v == NULL)
		return -1;
	Py_DECREF(v);
	return 0;
}
</t>
<t tx="T876"></t>
<t tx="T877">@ The two fast_xxx() functions optimize calls for which no argument tuple is necessary; the objects are passed directly from the stack.

fast_cfunction() is called for METH_OLDARGS functions.
fast_function()  is for functions with no special argument handling.
@c

#define EXT_POP(STACK_POINTER) (*--(STACK_POINTER))

static PyObject *
fast_cfunction(PyObject *func, PyObject ***pp_stack, int na)
{
	PyCFunction meth = PyCFunction_GET_FUNCTION(func);
	PyObject *self = PyCFunction_GET_SELF(func);
	int flags = PyCFunction_GET_FLAGS(func);

	switch (flags) {
	case METH_OLDARGS:
		if (na == 0)
			return (*meth)(self, NULL);
		else if (na == 1) {
			PyObject *arg = EXT_POP(*pp_stack);
			PyObject *result =  (*meth)(self, arg);
			Py_DECREF(arg);
			return result;
		} else {
			PyObject *args = load_args(pp_stack, na);
			PyObject *result = (*meth)(self, args);
			Py_DECREF(args);
			return result;
		}
	case METH_NOARGS:
		if (na == 0)
			return (*meth)(self, NULL);
		PyErr_Format(PyExc_TypeError,
			     "%.200s() takes no arguments (%d given)",
			     ((PyCFunctionObject*)func)-&gt;m_ml-&gt;ml_name, na);
		return NULL;
	case METH_O:
		if (na == 1) {
			PyObject *arg = EXT_POP(*pp_stack);
			PyObject *result = (*meth)(self, arg);
			Py_DECREF(arg);
			return result;
		}
		PyErr_Format(PyExc_TypeError,
			     "%.200s() takes exactly one argument (%d given)",
			     ((PyCFunctionObject*)func)-&gt;m_ml-&gt;ml_name, na);
		return NULL;
	default:
		fprintf(stderr, "%.200s() flags = %d\n", 
			((PyCFunctionObject*)func)-&gt;m_ml-&gt;ml_name, flags);
		PyErr_BadInternalCall();
		return NULL;
	}		
}
</t>
<t tx="T878">static PyObject *
fast_function(PyObject *func, PyObject ***pp_stack, int n, int na, int nk)
{
	PyObject *co = PyFunction_GET_CODE(func);
	PyObject *globals = PyFunction_GET_GLOBALS(func);
	PyObject *argdefs = PyFunction_GET_DEFAULTS(func);
	PyObject *closure = PyFunction_GET_CLOSURE(func);
	PyObject **d = NULL;
	int nd = 0;

	if (argdefs != NULL) {
		d = &amp;PyTuple_GET_ITEM(argdefs, 0);
		nd = ((PyTupleObject *)argdefs)-&gt;ob_size;
	}
	return PyEval_EvalCodeEx((PyCodeObject *)co, globals,
			  (PyObject *)NULL, (*pp_stack)-n, na,
			  (*pp_stack)-2*nk, nk, d, nd,
			  closure);
}
</t>
<t tx="T879">static PyObject *
update_keyword_args(PyObject *orig_kwdict, int nk, PyObject ***pp_stack,
                    PyObject *func)
{
	PyObject *kwdict = NULL;
	if (orig_kwdict == NULL)
		kwdict = PyDict_New();
	else {
		kwdict = PyDict_Copy(orig_kwdict);
		Py_DECREF(orig_kwdict);
	}
	if (kwdict == NULL)
		return NULL;
	while (--nk &gt;= 0) {
		int err;
		PyObject *value = EXT_POP(*pp_stack);
		PyObject *key = EXT_POP(*pp_stack);
		if (PyDict_GetItem(kwdict, key) != NULL) {
                        PyErr_Format(PyExc_TypeError,
                                     "%.200s%s got multiple values "
                                     "for keyword argument '%.200s'",
				     PyEval_GetFuncName(func),
				     PyEval_GetFuncDesc(func),
				     PyString_AsString(key));
			Py_DECREF(key);
			Py_DECREF(value);
			Py_DECREF(kwdict);
			return NULL;
		}
		err = PyDict_SetItem(kwdict, key, value);
		Py_DECREF(key);
		Py_DECREF(value);
		if (err) {
			Py_DECREF(kwdict);
			return NULL;
		}
	}
	return kwdict;
}
</t>
<t tx="T880">static PyObject *
update_star_args(int nstack, int nstar, PyObject *stararg,
		 PyObject ***pp_stack)
{
	PyObject *callargs, *w;

	callargs = PyTuple_New(nstack + nstar);
	if (callargs == NULL) {
		return NULL;
	}
	if (nstar) {
		int i;
		for (i = 0; i &lt; nstar; i++) {
			PyObject *a = PyTuple_GET_ITEM(stararg, i);
			Py_INCREF(a);
			PyTuple_SET_ITEM(callargs, nstack + i, a);
		}
	}
	while (--nstack &gt;= 0) {
		w = EXT_POP(*pp_stack);
		PyTuple_SET_ITEM(callargs, nstack, w);
	}
	return callargs;
}
</t>
<t tx="T881">static PyObject *
load_args(PyObject ***pp_stack, int na)
{
	PyObject *args = PyTuple_New(na);
	PyObject *w;

	if (args == NULL)
		return NULL;
	while (--na &gt;= 0) {
		w = EXT_POP(*pp_stack);
		PyTuple_SET_ITEM(args, na, w);
	}
	return args;
}
</t>
<t tx="T882">static PyObject *
do_call(PyObject *func, PyObject ***pp_stack, int na, int nk)
{
	PyObject *callargs = NULL;
	PyObject *kwdict = NULL;
	PyObject *result = NULL;

	if (nk &gt; 0) {
		kwdict = update_keyword_args(NULL, nk, pp_stack, func);
		if (kwdict == NULL)
			goto call_fail;
	}
	callargs = load_args(pp_stack, na);
	if (callargs == NULL)
		goto call_fail;
	result = PyObject_Call(func, callargs, kwdict);
 call_fail:
	Py_XDECREF(callargs);
	Py_XDECREF(kwdict);
	return result;
}
</t>
<t tx="T883">static PyObject *
ext_do_call(PyObject *func, PyObject ***pp_stack, int flags, int na, int nk)
{
	int nstar = 0;
	PyObject *callargs = NULL;
	PyObject *stararg = NULL;
	PyObject *kwdict = NULL;
	PyObject *result = NULL;

	if (flags &amp; CALL_FLAG_KW) {
		kwdict = EXT_POP(*pp_stack);
		if (!(kwdict &amp;&amp; PyDict_Check(kwdict))) {
			PyErr_Format(PyExc_TypeError,
				     "%s%s argument after ** "
				     "must be a dictionary",
				     PyEval_GetFuncName(func),
				     PyEval_GetFuncDesc(func));
			goto ext_call_fail;
		}
	}
	if (flags &amp; CALL_FLAG_VAR) {
		stararg = EXT_POP(*pp_stack);
		if (!PyTuple_Check(stararg)) {
			PyObject *t = NULL;
			t = PySequence_Tuple(stararg);
			if (t == NULL) {
				if (PyErr_ExceptionMatches(PyExc_TypeError)) {
					PyErr_Format(PyExc_TypeError,
						     "%s%s argument after * "
						     "must be a sequence",
						     PyEval_GetFuncName(func),
						     PyEval_GetFuncDesc(func));
				}
				goto ext_call_fail;
			}
			Py_DECREF(stararg);
			stararg = t;
		}
		nstar = PyTuple_GET_SIZE(stararg);
	}
	if (nk &gt; 0) {
		kwdict = update_keyword_args(kwdict, nk, pp_stack, func);
		if (kwdict == NULL)
			goto ext_call_fail;
	}
	callargs = update_star_args(na, nstar, stararg, pp_stack);
	if (callargs == NULL)
		goto ext_call_fail;
	result = PyObject_Call(func, callargs, kwdict);
      ext_call_fail:
	Py_XDECREF(callargs);
	Py_XDECREF(kwdict);
	Py_XDECREF(stararg);
	return result;
}
</t>
<t tx="T884"></t>
<t tx="T885">static PyObject *
gen_new(PyFrameObject *f)
{
	genobject *gen = PyObject_New(genobject, &amp;gentype);
	if (gen == NULL) {
		Py_DECREF(f);
		return NULL;
	}
	gen-&gt;gi_frame = f;
	gen-&gt;gi_running = 0;
	PyObject_GC_Init(gen);
	return (PyObject *)gen;
}
</t>
<t tx="T886">static int
gen_traverse(genobject *gen, visitproc visit, void *arg)
{
	return visit((PyObject *)gen-&gt;gi_frame, arg);
}
</t>
<t tx="T887">static void
gen_dealloc(genobject *gen)
{
	PyObject_GC_Fini(gen);
	Py_DECREF(gen-&gt;gi_frame);
	PyObject_Del(gen);
}
</t>
<t tx="T888">static PyObject *
gen_iternext(genobject *gen)
{
	PyThreadState *tstate = PyThreadState_GET();
	PyFrameObject *f = gen-&gt;gi_frame;
	PyObject *result;

	if (gen-&gt;gi_running) {
		PyErr_SetString(PyExc_ValueError,
				"generator already executing");
		return NULL;
	}
	if (f-&gt;f_stacktop == NULL)
		return NULL;

	/* Generators always return to their most recent caller, not
	 * necessarily their creator. */
	Py_XINCREF(tstate-&gt;frame);
	assert(f-&gt;f_back == NULL);
	f-&gt;f_back = tstate-&gt;frame;

	gen-&gt;gi_running = 1;
	result = eval_frame(f);
	gen-&gt;gi_running = 0;

	/* Don't keep the reference to f_back any longer than necessary.  It
	 * may keep a chain of frames alive or it could create a reference
	 * cycle. */
	Py_XDECREF(f-&gt;f_back);
	f-&gt;f_back = NULL;

	/* If the generator just returned (as opposed to yielding), signal
	 * that the generator is exhausted. */
	if (result == Py_None &amp;&amp; f-&gt;f_stacktop == NULL) {
		Py_DECREF(result);
		result = NULL;
	}

	return result;
}
</t>
<t tx="T889">static PyObject *
gen_next(genobject *gen)
{
	PyObject *result;

	result = gen_iternext(gen);

	if (result == NULL &amp;&amp; !PyErr_Occurred()) {
		PyErr_SetObject(PyExc_StopIteration, Py_None);
		return NULL;
	}

	return result;
}
</t>
<t tx="T890">static PyObject *
gen_getiter(PyObject *gen)
{
	Py_INCREF(gen);
	return gen;
}
</t>
<t tx="T891">#ifdef DYNAMIC_EXECUTION_PROFILE

static PyObject *
getarray(long a[256])
{
	int i;
	PyObject *l = PyList_New(256);
	if (l == NULL) return NULL;
	for (i = 0; i &lt; 256; i++) {
		PyObject *x = PyInt_FromLong(a[i]);
		if (x == NULL) {
			Py_DECREF(l);
			return NULL;
		}
		PyList_SetItem(l, i, x);
	}
	for (i = 0; i &lt; 256; i++)
		a[i] = 0;
	return l;
}
</t>
<t tx="T892">#define SLICE_ERROR_MSG \
	"standard sequence type does not support step size other than one"

static PyObject *
loop_subscript(PyObject *v, PyObject *w)
{
	PySequenceMethods *sq = v-&gt;ob_type-&gt;tp_as_sequence;
	int i;
	if (sq == NULL || sq-&gt;sq_item == NULL) {
		PyErr_SetString(PyExc_TypeError, "loop over non-sequence");
		return NULL;
	}
	i = PyInt_AsLong(w);
	v = (*sq-&gt;sq_item)(v, i);
	if (v)
		return v;
	if (PyErr_ExceptionMatches(PyExc_IndexError))
		PyErr_Clear();
	return NULL;
}
</t>
<t tx="T893"></t>
<t tx="T894">@ Extract a slice index from a PyInt or PyLong, and store in *pi.

Silently reduce values larger than INT_MAX to INT_MAX, and silently boost values less than -INT_MAX to 0. Return 0 on error, 1 on success.

Note: If v is NULL, return success without storing into *pi. This is because_PyEval_SliceIndex() is called by apply_slice(), which can be called by the SLICE opcode with v and/or w equal to NULL.
@c

int
_PyEval_SliceIndex(PyObject *v, int *pi)
{
	if (v != NULL) {
		long x;
		if (PyInt_Check(v)) {
			x = PyInt_AsLong(v);
		} else if (PyLong_Check(v)) {
			x = PyLong_AsLong(v);
			if (x==-1 &amp;&amp; PyErr_Occurred()) {
				PyObject *long_zero;
				int cmp;

				if (!PyErr_ExceptionMatches(
					PyExc_OverflowError)) {
					/* It's not an overflow error, so just
					   signal an error */
					return 0;
				}

				/* Clear the OverflowError */
				PyErr_Clear();

				/* It's an overflow error, so we need to
				   check the sign of the long integer,
				   set the value to INT_MAX or 0, and clear
				   the error. */

				/* Create a long integer with a value of 0 */
				long_zero = PyLong_FromLong(0L);
				if (long_zero == NULL)
					return 0;

				/* Check sign */
				cmp = PyObject_RichCompareBool(v, long_zero,
							       Py_GT);
				Py_DECREF(long_zero);
				if (cmp &lt; 0)
					return 0;
				else if (cmp &gt; 0)
					x = INT_MAX;
				else
					x = 0;
			}
		} else {
			PyErr_SetString(PyExc_TypeError,
					"slice indices must be integers");
			return 0;
		}
		/* Truncate -- very long indices are truncated anyway */
		if (x &gt; INT_MAX)
			x = INT_MAX;
		else if (x &lt; -INT_MAX)
			x = 0;
		*pi = x;
	}
	return 1;
}</t>
<t tx="T895">#undef ISINT
#define ISINT(x) ((x) == NULL || PyInt_Check(x) || PyLong_Check(x))

static PyObject *
apply_slice(PyObject *u, PyObject *v, PyObject *w) /* return u[v:w] */
{
	PyTypeObject *tp = u-&gt;ob_type;
	PySequenceMethods *sq = tp-&gt;tp_as_sequence;

	if (sq &amp;&amp; sq-&gt;sq_slice &amp;&amp; ISINT(v) &amp;&amp; ISINT(w)) {
		int ilow = 0, ihigh = INT_MAX;
		if (!_PyEval_SliceIndex(v, &amp;ilow))
			return NULL;
		if (!_PyEval_SliceIndex(w, &amp;ihigh))
			return NULL;
		return PySequence_GetSlice(u, ilow, ihigh);
	}
	else {
		PyObject *slice = PySlice_New(v, w, NULL);
		if (slice != NULL) {
			PyObject *res = PyObject_GetItem(u, slice);
			Py_DECREF(slice);
			return res;
		}
		else
			return NULL;
	}
}
</t>
<t tx="T896">static int
assign_slice(PyObject *u, PyObject *v, PyObject *w, PyObject *x)
	/* u[v:w] = x */
{
	PyTypeObject *tp = u-&gt;ob_type;
	PySequenceMethods *sq = tp-&gt;tp_as_sequence;

	if (sq &amp;&amp; sq-&gt;sq_slice &amp;&amp; ISINT(v) &amp;&amp; ISINT(w)) {
		int ilow = 0, ihigh = INT_MAX;
		if (!_PyEval_SliceIndex(v, &amp;ilow))
			return -1;
		if (!_PyEval_SliceIndex(w, &amp;ihigh))
			return -1;
		if (x == NULL)
			return PySequence_DelSlice(u, ilow, ihigh);
		else
			return PySequence_SetSlice(u, ilow, ihigh, x);
	}
	else {
		PyObject *slice = PySlice_New(v, w, NULL);
		if (slice != NULL) {
			int res;
			if (x != NULL)
				res = PyObject_SetItem(u, slice, x);
			else
				res = PyObject_DelItem(u, slice);
			Py_DECREF(slice);
			return res;
		}
		else
			return -1;
	}
}
</t>
<t tx="T897"></t>
<t tx="T898">#ifdef LLTRACE
	static int
	prtrace(PyObject *v, char *str)
	{
		printf("%s ", str);
		if (PyObject_Print(v, stdout, 0) != 0)
			PyErr_Clear(); /* Don't know what else to do */
		printf("\n");
		return 1;
	}
#endif</t>
<t tx="T899">static void
call_exc_trace(Py_tracefunc func, PyObject *self, PyFrameObject *f)
{
	PyObject *type, *value, *traceback, *arg;
	int err;
	PyErr_Fetch(&amp;type, &amp;value, &amp;traceback);
	if (value == NULL) {
		value = Py_None;
		Py_INCREF(value);
	}
	arg = Py_BuildValue("(OOO)", type, value, traceback);
	if (arg == NULL) {
		PyErr_Restore(type, value, traceback);
		return;
	}
	err = call_trace(func, self, f, PyTrace_EXCEPTION, arg);
	Py_DECREF(arg);
	if (err == 0)
		PyErr_Restore(type, value, traceback);
	else {
		Py_XDECREF(type);
		Py_XDECREF(value);
		Py_XDECREF(traceback);
	}
}
</t>
<t tx="T900">static void
call_trace_protected(Py_tracefunc func, PyObject *obj, PyFrameObject *frame,
		     int what)
{
	PyObject *type, *value, *traceback;
	int err;
	PyErr_Fetch(&amp;type, &amp;value, &amp;traceback);
	err = call_trace(func, obj, frame, what, NULL);
	if (err == 0)
		PyErr_Restore(type, value, traceback);
	else {
		Py_XDECREF(type);
		Py_XDECREF(value);
		Py_XDECREF(traceback);
	}
}
</t>
<t tx="T901">static int
call_trace(Py_tracefunc func, PyObject *obj, PyFrameObject *frame,
	   int what, PyObject *arg)
{
	register PyThreadState *tstate = frame-&gt;f_tstate;
	int result;
	if (tstate-&gt;tracing)
		return 0;
	tstate-&gt;tracing++;
	tstate-&gt;use_tracing = 0;
	result = func(obj, frame, what, arg);
	tstate-&gt;use_tracing = ((tstate-&gt;c_tracefunc != NULL)
			       || (tstate-&gt;c_profilefunc != NULL));
	tstate-&gt;tracing--;
	return result;
}
</t>
<t tx="T902">int
Py_FlushLine(void)
{
	PyObject *f = PySys_GetObject("stdout");
	if (f == NULL)
		return 0;
	if (!PyFile_SoftSpace(f, 0))
		return 0;
	return PyFile_WriteString("\n", f);
}
</t>
<t tx="T903">@ Iterate v argcnt times and store the results on the stack (via decreasing sp). Return 1 for success, 0 if error. */
@c

static int
unpack_iterable(PyObject *v, int argcnt, PyObject **sp)
{
	int i = 0;
	PyObject *it;  /* iter(v) */
	PyObject *w;

	assert(v != NULL);

	it = PyObject_GetIter(v);
	if (it == NULL)
		goto Error;

	for (; i &lt; argcnt; i++) {
		w = PyIter_Next(it);
		if (w == NULL) {
			/* Iterator done, via error or exhaustion. */
			if (!PyErr_Occurred()) {
				PyErr_Format(PyExc_ValueError,
					"need more than %d value%s to unpack",
					i, i == 1 ? "" : "s");
			}
			goto Error;
		}
		*--sp = w;
	}

	/* We better have exhausted the iterator now. */
	w = PyIter_Next(it);
	if (w == NULL) {
		if (PyErr_Occurred())
			goto Error;
		Py_DECREF(it);
		return 1;
	}
	Py_DECREF(w);
	PyErr_SetString(PyExc_ValueError, "too many values to unpack");
	/* fall through */
Error:
	for (; i &gt; 0; i--, sp++)
		Py_DECREF(*sp);
	Py_XDECREF(it);
	return 0;
}
</t>
<t tx="T904">/* Python interpreter main program for frozen scripts */

&lt;&lt; frozenmain #includes &gt;&gt;
&lt;&lt; frozenmain declarations &gt;&gt;
@others
</t>
<t tx="T905">#include "Python.h"
</t>
<t tx="T906">
#ifdef MS_WIN32
extern void PyWinFreeze_ExeInit(void);
extern void PyWinFreeze_ExeTerm(void);
extern int PyInitFrozenExtensions(void);
</t>
<t tx="T907">#endif

#ifdef HAVE_UNISTD_H
#include &lt;unistd.h&gt; /* For isatty() */
#endif

/* For isatty()'s proto. - [cjh] */
#ifdef HAVE_UNISTD_H
#include &lt;unistd.h&gt;
#endif

/* Main program */

int
Py_FrozenMain(int argc, char **argv)
{
	char *p;
	int n, sts;
	int inspect = 0;
	int unbuffered = 0;

	Py_FrozenFlag = 1; /* Suppress errors from getpath.c */

	if ((p = Py_GETENV("PYTHONINSPECT")) &amp;&amp; *p != '\0')
		inspect = 1;
	if ((p = Py_GETENV("PYTHONUNBUFFERED")) &amp;&amp; *p != '\0')
		unbuffered = 1;

	if (unbuffered) {
		setbuf(stdin, (char *)NULL);
		setbuf(stdout, (char *)NULL);
		setbuf(stderr, (char *)NULL);
	}

#ifdef MS_WIN32
	PyInitFrozenExtensions();
#endif /* MS_WIN32 */
	Py_SetProgramName(argv[0]);
	Py_Initialize();
#ifdef MS_WIN32
	PyWinFreeze_ExeInit();
#endif

	if (Py_VerboseFlag)
		fprintf(stderr, "Python %s\n%s\n",
			Py_GetVersion(), Py_GetCopyright());

	PySys_SetArgv(argc, argv);

	n = PyImport_ImportFrozenModule("__main__");
	if (n == 0)
		Py_FatalError("__main__ not frozen");
	if (n &lt; 0) {
		PyErr_Print();
		sts = 1;
	}
	else
		sts = 0;

	if (inspect &amp;&amp; isatty((int)fileno(stdin)))
		sts = PyRun_AnyFile(stdin, "&lt;stdin&gt;") != 0;

#ifdef MS_WIN32
	PyWinFreeze_ExeTerm();
#endif
	Py_Finalize();
	return sts;
}
</t>
<t tx="T908">@language c
/* Module definition and import implementation */

&lt;&lt; import #includes &gt;&gt;
&lt;&lt; import declarations &gt;&gt;
@others


/* Search the path (default sys.path) for a module.  Return the
   corresponding filedescr struct, and (via return arguments) the
   pathname and an open file.  Return NULL if the module is not found. */

#ifdef MS_COREDLL
extern FILE *PyWin_FindRegisteredModule(const char *, struct filedescr **,
					char *, int);
#endif

static int case_ok(char *, int, int, char *);
static int find_init_module(char *); /* Forward */

static struct filedescr *
find_module(char *realname, PyObject *path, char *buf, size_t buflen,
	    FILE **p_fp)
{
	int i, npath;
	size_t len, namelen;
	struct filedescr *fdp = NULL;
	FILE *fp = NULL;
#ifndef RISCOS
	struct stat statbuf;
#endif
	static struct filedescr fd_frozen = {"", "", PY_FROZEN};
	static struct filedescr fd_builtin = {"", "", C_BUILTIN};
	static struct filedescr fd_package = {"", "", PKG_DIRECTORY};
	char name[MAXPATHLEN+1];

	if (strlen(realname) &gt; MAXPATHLEN) {
		PyErr_SetString(PyExc_OverflowError,
				"module name is too long");
		return NULL;
	}
	strcpy(name, realname);

	if (path != NULL &amp;&amp; PyString_Check(path)) {
		/* The only type of submodule allowed inside a "frozen"
		   package are other frozen modules or packages. */
		if (PyString_Size(path) + 1 + strlen(name) &gt;= (size_t)buflen) {
			PyErr_SetString(PyExc_ImportError,
					"full frozen module name too long");
			return NULL;
		}
		strcpy(buf, PyString_AsString(path));
		strcat(buf, ".");
		strcat(buf, name);
		strcpy(name, buf);
#ifdef macintosh
		/* Freezing on the mac works different, and the modules are
		** actually on sys.path. So we don't take the quick exit but
		** continue with the normal flow.
		*/
		path = NULL;
#else
		if (find_frozen(name) != NULL) {
			strcpy(buf, name);
			return &amp;fd_frozen;
		}
		PyErr_Format(PyExc_ImportError,
			     "No frozen submodule named %.200s", name);
		return NULL;
#endif
	}
	if (path == NULL) {
		if (is_builtin(name)) {
			strcpy(buf, name);
			return &amp;fd_builtin;
		}
		if ((find_frozen(name)) != NULL) {
			strcpy(buf, name);
			return &amp;fd_frozen;
		}

#ifdef MS_COREDLL
		fp = PyWin_FindRegisteredModule(name, &amp;fdp, buf, buflen);
		if (fp != NULL) {
			*p_fp = fp;
			return fdp;
		}
#endif
		path = PySys_GetObject("path");
	}
	if (path == NULL || !PyList_Check(path)) {
		PyErr_SetString(PyExc_ImportError,
				"sys.path must be a list of directory names");
		return NULL;
	}
	npath = PyList_Size(path);
	namelen = strlen(name);
	for (i = 0; i &lt; npath; i++) {
		PyObject *v = PyList_GetItem(path, i);
		if (!PyString_Check(v))
			continue;
		len = PyString_Size(v);
		if (len + 2 + namelen + MAXSUFFIXSIZE &gt;= buflen)
			continue; /* Too long */
		strcpy(buf, PyString_AsString(v));
		if (strlen(buf) != len)
			continue; /* v contains '\0' */
#ifdef macintosh
#ifdef INTERN_STRINGS
		/*
		** Speedup: each sys.path item is interned, and
		** FindResourceModule remembers which items refer to
		** folders (so we don't have to bother trying to look
		** into them for resources).
		*/
		PyString_InternInPlace(&amp;PyList_GET_ITEM(path, i));
		v = PyList_GET_ITEM(path, i);
#endif
		if (PyMac_FindResourceModule((PyStringObject *)v, name, buf)) {
			static struct filedescr resfiledescr =
				{"", "", PY_RESOURCE};

			return &amp;resfiledescr;
		}
		if (PyMac_FindCodeResourceModule((PyStringObject *)v, name, buf)) {
			static struct filedescr resfiledescr =
				{"", "", PY_CODERESOURCE};

			return &amp;resfiledescr;
		}
#endif
		if (len &gt; 0 &amp;&amp; buf[len-1] != SEP
#ifdef ALTSEP
		    &amp;&amp; buf[len-1] != ALTSEP
#endif
		    )
			buf[len++] = SEP;
		strcpy(buf+len, name);
		len += namelen;

		/* Check for package import (buf holds a directory name,
		   and there's an __init__ module in that directory */
#ifdef HAVE_STAT
		if (stat(buf, &amp;statbuf) == 0 &amp;&amp;       /* it exists */
		    S_ISDIR(statbuf.st_mode) &amp;&amp;       /* it's a directory */
		    find_init_module(buf) &amp;&amp;          /* it has __init__.py */
		    case_ok(buf, len, namelen, name)) /* and case matches */
			return &amp;fd_package;
#else
		/* XXX How are you going to test for directories? */
#ifdef RISCOS
		if (isdir(buf) &amp;&amp;
		    find_init_module(buf) &amp;&amp;
		    case_ok(buf, len, namelen, name))
			return &amp;fd_package;
#endif
#endif
#ifdef macintosh
		fdp = PyMac_FindModuleExtension(buf, &amp;len, name);
		if (fdp) {
#else
		for (fdp = _PyImport_Filetab; fdp-&gt;suffix != NULL; fdp++) {
			strcpy(buf+len, fdp-&gt;suffix);
			if (Py_VerboseFlag &gt; 1)
				PySys_WriteStderr("# trying %s\n", buf);
#endif /* !macintosh */
			fp = fopen(buf, fdp-&gt;mode);
			if (fp != NULL) {
				if (case_ok(buf, len, namelen, name))
					break;
				else {	 /* continue search */
					fclose(fp);
					fp = NULL;
				}
			}
		}
		if (fp != NULL)
			break;
	}
	if (fp == NULL) {
		PyErr_Format(PyExc_ImportError,
			     "No module named %.200s", name);
		return NULL;
	}
	*p_fp = fp;
	return fdp;
}

/* case_ok(char* buf, int len, int namelen, char* name)
 * The arguments here are tricky, best shown by example:
 *    /a/b/c/d/e/f/g/h/i/j/k/some_long_module_name.py\0
 *    ^                      ^                   ^    ^
 *    |--------------------- buf ---------------------|
 *    |------------------- len ------------------|
 *                           |------ name -------|
 *                           |----- namelen -----|
 * buf is the full path, but len only counts up to (&amp; exclusive of) the
 * extension.  name is the module name, also exclusive of extension.
 *
 * We've already done a successful stat() or fopen() on buf, so know that
 * there's some match, possibly case-insensitive.
 *
 * case_ok() is to return 1 if there's a case-sensitive match for
 * name, else 0.  case_ok() is also to return 1 if envar PYTHONCASEOK
 * exists.
 *
 * case_ok() is used to implement case-sensitive import semantics even
 * on platforms with case-insensitive filesystems.  It's trivial to implement
 * for case-sensitive filesystems.  It's pretty much a cross-platform
 * nightmare for systems with case-insensitive filesystems.
 */

/* First we may need a pile of platform-specific header files; the sequence
 * of #if's here should match the sequence in the body of case_ok().
 */
#if defined(MS_WIN32) || defined(__CYGWIN__)
#include &lt;windows.h&gt;
#ifdef __CYGWIN__
#include &lt;sys/cygwin.h&gt;
#endif

#elif defined(DJGPP)
#include &lt;dir.h&gt;

#elif defined(macintosh)
#include &lt;TextUtils.h&gt;
#ifdef USE_GUSI1
#include "TFileSpec.h"		/* for Path2FSSpec() */
#endif

#elif defined(__MACH__) &amp;&amp; defined(__APPLE__) &amp;&amp; defined(HAVE_DIRENT_H)
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;

#elif defined(RISCOS)
#include "oslib/osfscontrol.h"
#endif

static int
case_ok(char *buf, int len, int namelen, char *name)
{
/* Pick a platform-specific implementation; the sequence of #if's here should
 * match the sequence just above.
 */

/* MS_WIN32 || __CYGWIN__ */
#if defined(MS_WIN32) || defined(__CYGWIN__)
	WIN32_FIND_DATA data;
	HANDLE h;
#ifdef __CYGWIN__
	char tempbuf[MAX_PATH];
#endif

	if (Py_GETENV("PYTHONCASEOK") != NULL)
		return 1;

#ifdef __CYGWIN__
	cygwin32_conv_to_win32_path(buf, tempbuf);
	h = FindFirstFile(tempbuf, &amp;data);
#else
	h = FindFirstFile(buf, &amp;data);
#endif
	if (h == INVALID_HANDLE_VALUE) {
		PyErr_Format(PyExc_NameError,
		  "Can't find file for module %.100s\n(filename %.300s)",
		  name, buf);
		return 0;
	}
	FindClose(h);
	return strncmp(data.cFileName, name, namelen) == 0;

/* DJGPP */
#elif defined(DJGPP)
	struct ffblk ffblk;
	int done;

	if (Py_GETENV("PYTHONCASEOK") != NULL)
		return 1;

	done = findfirst(buf, &amp;ffblk, FA_ARCH|FA_RDONLY|FA_HIDDEN|FA_DIREC);
	if (done) {
		PyErr_Format(PyExc_NameError,
		  "Can't find file for module %.100s\n(filename %.300s)",
		  name, buf);
		return 0;
	}
	return strncmp(ffblk.ff_name, name, namelen) == 0;

/* macintosh */
#elif defined(macintosh)
	FSSpec fss;
	OSErr err;

	if (Py_GETENV("PYTHONCASEOK") != NULL)
		return 1;

#ifndef USE_GUSI1
	err = FSMakeFSSpec(0, 0, Pstring(buf), &amp;fss);
#else
	/* GUSI's Path2FSSpec() resolves all possible aliases nicely on
	   the way, which is fine for all directories, but here we need
	   the original name of the alias file (say, Dlg.ppc.slb, not
	   toolboxmodules.ppc.slb). */
	char *colon;
	err = Path2FSSpec(buf, &amp;fss);
	if (err == noErr) {
		colon = strrchr(buf, ':'); /* find filename */
		if (colon != NULL)
			err = FSMakeFSSpec(fss.vRefNum, fss.parID,
					   Pstring(colon+1), &amp;fss);
		else
			err = FSMakeFSSpec(fss.vRefNum, fss.parID,
					   fss.name, &amp;fss);
	}
#endif
	if (err) {
		PyErr_Format(PyExc_NameError,
		     "Can't find file for module %.100s\n(filename %.300s)",
		     name, buf);
		return 0;
	}
	return fss.name[0] &gt;= namelen &amp;&amp;
	       strncmp(name, (char *)fss.name+1, namelen) == 0;

/* new-fangled macintosh (macosx) */
#elif defined(__MACH__) &amp;&amp; defined(__APPLE__) &amp;&amp; defined(HAVE_DIRENT_H)
	DIR *dirp;
	struct dirent *dp;
	char dirname[MAXPATHLEN + 1];
	const int dirlen = len - namelen - 1; /* don't want trailing SEP */

	if (Py_GETENV("PYTHONCASEOK") != NULL)
		return 1;

	/* Copy the dir component into dirname; substitute "." if empty */
	if (dirlen &lt;= 0) {
		dirname[0] = '.';
		dirname[1] = '\0';
	}
	else {
		assert(dirlen &lt;= MAXPATHLEN);
		memcpy(dirname, buf, dirlen);
		dirname[dirlen] = '\0';
	}
	/* Open the directory and search the entries for an exact match. */
	dirp = opendir(dirname);
	if (dirp) {
		char *nameWithExt = buf + len - namelen;
		while ((dp = readdir(dirp)) != NULL) {
			const int thislen =
#ifdef _DIRENT_HAVE_D_NAMELEN
						dp-&gt;d_namlen;
#else
						strlen(dp-&gt;d_name);
#endif
			if (thislen &gt;= namelen &amp;&amp;
			    strcmp(dp-&gt;d_name, nameWithExt) == 0) {
				(void)closedir(dirp);
				return 1; /* Found */
			}
		}
		(void)closedir(dirp);
	}
	return 0 ; /* Not found */

/* RISC OS */
#elif defined(RISCOS)
	char canon[MAXPATHLEN+1]; /* buffer for the canonical form of the path */
	char buf2[MAXPATHLEN+2];
	char *nameWithExt = buf+len-namelen;
	int canonlen;
	os_error *e;

	if (Py_GETENV("PYTHONCASEOK") != NULL)
		return 1;

	/* workaround:
	   append wildcard, otherwise case of filename wouldn't be touched */
	strcpy(buf2, buf);
	strcat(buf2, "*");

	e = xosfscontrol_canonicalise_path(buf2,canon,0,0,MAXPATHLEN+1,&amp;canonlen);
	canonlen = MAXPATHLEN+1-canonlen;
	if (e || canonlen&lt;=0 || canonlen&gt;(MAXPATHLEN+1) )
		return 0;
	if (strcmp(nameWithExt, canon+canonlen-strlen(nameWithExt))==0)
		return 1; /* match */

	return 0;

/* assuming it's a case-sensitive filesystem, so there's nothing to do! */
#else
	return 1;

#endif
}


#ifdef HAVE_STAT
/* Helper to look for __init__.py or __init__.py[co] in potential package */
static int
find_init_module(char *buf)
{
	const size_t save_len = strlen(buf);
	size_t i = save_len;
	char *pname;  /* pointer to start of __init__ */
	struct stat statbuf;

/*	For calling case_ok(buf, len, namelen, name):
 *	/a/b/c/d/e/f/g/h/i/j/k/some_long_module_name.py\0
 *	^                      ^                   ^    ^
 *	|--------------------- buf ---------------------|
 *	|------------------- len ------------------|
 *	                       |------ name -------|
 *	                       |----- namelen -----|
 */
	if (save_len + 13 &gt;= MAXPATHLEN)
		return 0;
	buf[i++] = SEP;
	pname = buf + i;
	strcpy(pname, "__init__.py");
	if (stat(buf, &amp;statbuf) == 0) {
		if (case_ok(buf,
			    save_len + 9,	/* len("/__init__") */
		            8,   		/* len("__init__") */
		            pname)) {
			buf[save_len] = '\0';
			return 1;
		}
	}
	i += strlen(pname);
	strcpy(buf+i, Py_OptimizeFlag ? "o" : "c");
	if (stat(buf, &amp;statbuf) == 0) {
		if (case_ok(buf,
			    save_len + 9,	/* len("/__init__") */
		            8,   		/* len("__init__") */
		            pname)) {
			buf[save_len] = '\0';
			return 1;
		}
	}
	buf[save_len] = '\0';
	return 0;
}

#else

#ifdef RISCOS
static int
find_init_module(buf)
	char *buf;
{
	int save_len = strlen(buf);
	int i = save_len;

	if (save_len + 13 &gt;= MAXPATHLEN)
		return 0;
	buf[i++] = SEP;
	strcpy(buf+i, "__init__/py");
	if (isfile(buf)) {
		buf[save_len] = '\0';
		return 1;
	}

	if (Py_OptimizeFlag)
		strcpy(buf+i, "o");
	else
		strcpy(buf+i, "c");
	if (isfile(buf)) {
		buf[save_len] = '\0';
		return 1;
	}
	buf[save_len] = '\0';
	return 0;
}
#endif /*RISCOS*/

#endif /* HAVE_STAT */


static int init_builtin(char *); /* Forward */

/* Load an external module using the default search path and return
   its module object WITH INCREMENTED REFERENCE COUNT */

static PyObject *
load_module(char *name, FILE *fp, char *buf, int type)
{
	PyObject *modules;
	PyObject *m;
	int err;

	/* First check that there's an open file (if we need one)  */
	switch (type) {
	case PY_SOURCE:
	case PY_COMPILED:
		if (fp == NULL) {
			PyErr_Format(PyExc_ValueError,
			   "file object required for import (type code %d)",
				     type);
			return NULL;
		}
	}

	switch (type) {

	case PY_SOURCE:
		m = load_source_module(name, buf, fp);
		break;

	case PY_COMPILED:
		m = load_compiled_module(name, buf, fp);
		break;

#ifdef HAVE_DYNAMIC_LOADING
	case C_EXTENSION:
		m = _PyImport_LoadDynamicModule(name, buf, fp);
		break;
#endif

#ifdef macintosh
	case PY_RESOURCE:
		m = PyMac_LoadResourceModule(name, buf);
		break;
	case PY_CODERESOURCE:
		m = PyMac_LoadCodeResourceModule(name, buf);
		break;
#endif

	case PKG_DIRECTORY:
		m = load_package(name, buf);
		break;

	case C_BUILTIN:
	case PY_FROZEN:
		if (buf != NULL &amp;&amp; buf[0] != '\0')
			name = buf;
		if (type == C_BUILTIN)
			err = init_builtin(name);
		else
			err = PyImport_ImportFrozenModule(name);
		if (err &lt; 0)
			return NULL;
		if (err == 0) {
			PyErr_Format(PyExc_ImportError,
				     "Purported %s module %.200s not found",
				     type == C_BUILTIN ?
						"builtin" : "frozen",
				     name);
			return NULL;
		}
		modules = PyImport_GetModuleDict();
		m = PyDict_GetItemString(modules, name);
		if (m == NULL) {
			PyErr_Format(
				PyExc_ImportError,
				"%s module %.200s not properly initialized",
				type == C_BUILTIN ?
					"builtin" : "frozen",
				name);
			return NULL;
		}
		Py_INCREF(m);
		break;

	default:
		PyErr_Format(PyExc_ImportError,
			     "Don't know how to import %.200s (type code %d)",
			      name, type);
		m = NULL;

	}

	return m;
}


/* Initialize a built-in module.
   Return 1 for succes, 0 if the module is not found, and -1 with
   an exception set if the initialization failed. */

static int
init_builtin(char *name)
{
	struct _inittab *p;

	if (_PyImport_FindExtension(name, name) != NULL)
		return 1;

	for (p = PyImport_Inittab; p-&gt;name != NULL; p++) {
		if (strcmp(name, p-&gt;name) == 0) {
			if (p-&gt;initfunc == NULL) {
				PyErr_Format(PyExc_ImportError,
				    "Cannot re-init internal module %.200s",
				    name);
				return -1;
			}
			if (Py_VerboseFlag)
				PySys_WriteStderr("import %s # builtin\n", name);
			(*p-&gt;initfunc)();
			if (PyErr_Occurred())
				return -1;
			if (_PyImport_FixupExtension(name, name) == NULL)
				return -1;
			return 1;
		}
	}
	return 0;
}


/* Frozen modules */

static struct _frozen *
find_frozen(char *name)
{
	struct _frozen *p;

	for (p = PyImport_FrozenModules; ; p++) {
		if (p-&gt;name == NULL)
			return NULL;
		if (strcmp(p-&gt;name, name) == 0)
			break;
	}
	return p;
}

static PyObject *
get_frozen_object(char *name)
{
	struct _frozen *p = find_frozen(name);
	int size;

	if (p == NULL) {
		PyErr_Format(PyExc_ImportError,
			     "No such frozen object named %.200s",
			     name);
		return NULL;
	}
	if (p-&gt;code == NULL) {
		PyErr_Format(PyExc_ImportError,
			     "Excluded frozen object named %.200s",
			     name);
		return NULL;
	}
	size = p-&gt;size;
	if (size &lt; 0)
		size = -size;
	return PyMarshal_ReadObjectFromString((char *)p-&gt;code, size);
}

/* Initialize a frozen module.
   Return 1 for succes, 0 if the module is not found, and -1 with
   an exception set if the initialization failed.
   This function is also used from frozenmain.c */

int
PyImport_ImportFrozenModule(char *name)
{
	struct _frozen *p = find_frozen(name);
	PyObject *co;
	PyObject *m;
	int ispackage;
	int size;

	if (p == NULL)
		return 0;
	if (p-&gt;code == NULL) {
		PyErr_Format(PyExc_ImportError,
			     "Excluded frozen object named %.200s",
			     name);
		return -1;
	}
	size = p-&gt;size;
	ispackage = (size &lt; 0);
	if (ispackage)
		size = -size;
	if (Py_VerboseFlag)
		PySys_WriteStderr("import %s # frozen%s\n",
			name, ispackage ? " package" : "");
	co = PyMarshal_ReadObjectFromString((char *)p-&gt;code, size);
	if (co == NULL)
		return -1;
	if (!PyCode_Check(co)) {
		Py_DECREF(co);
		PyErr_Format(PyExc_TypeError,
			     "frozen object %.200s is not a code object",
			     name);
		return -1;
	}
	if (ispackage) {
		/* Set __path__ to the package name */
		PyObject *d, *s;
		int err;
		m = PyImport_AddModule(name);
		if (m == NULL)
			return -1;
		d = PyModule_GetDict(m);
		s = PyString_InternFromString(name);
		if (s == NULL)
			return -1;
		err = PyDict_SetItemString(d, "__path__", s);
		Py_DECREF(s);
		if (err != 0)
			return err;
	}
	m = PyImport_ExecCodeModuleEx(name, co, "&lt;frozen&gt;");
	Py_DECREF(co);
	if (m == NULL)
		return -1;
	Py_DECREF(m);
	return 1;
}


/* Import a module, either built-in, frozen, or external, and return
   its module object WITH INCREMENTED REFERENCE COUNT */

PyObject *
PyImport_ImportModule(char *name)
{
	PyObject *pname;
	PyObject *result;

	pname = PyString_FromString(name);
	result = PyImport_Import(pname);
	Py_DECREF(pname);
	return result;
}

/* Forward declarations for helper routines */
static PyObject *get_parent(PyObject *globals, char *buf, int *p_buflen);
static PyObject *load_next(PyObject *mod, PyObject *altmod,
			   char **p_name, char *buf, int *p_buflen);
static int mark_miss(char *name);
static int ensure_fromlist(PyObject *mod, PyObject *fromlist,
			   char *buf, int buflen, int recursive);
static PyObject * import_submodule(PyObject *mod, char *name, char *fullname);

/* The Magnum Opus of dotted-name import :-) */

static PyObject *
import_module_ex(char *name, PyObject *globals, PyObject *locals,
		 PyObject *fromlist)
{
	char buf[MAXPATHLEN+1];
	int buflen = 0;
	PyObject *parent, *head, *next, *tail;

	parent = get_parent(globals, buf, &amp;buflen);
	if (parent == NULL)
		return NULL;

	head = load_next(parent, Py_None, &amp;name, buf, &amp;buflen);
	if (head == NULL)
		return NULL;

	tail = head;
	Py_INCREF(tail);
	while (name) {
		next = load_next(tail, tail, &amp;name, buf, &amp;buflen);
		Py_DECREF(tail);
		if (next == NULL) {
			Py_DECREF(head);
			return NULL;
		}
		tail = next;
	}

	if (fromlist != NULL) {
		if (fromlist == Py_None || !PyObject_IsTrue(fromlist))
			fromlist = NULL;
	}

	if (fromlist == NULL) {
		Py_DECREF(tail);
		return head;
	}

	Py_DECREF(head);
	if (!ensure_fromlist(tail, fromlist, buf, buflen, 0)) {
		Py_DECREF(tail);
		return NULL;
	}

	return tail;
}

PyObject *
PyImport_ImportModuleEx(char *name, PyObject *globals, PyObject *locals,
			PyObject *fromlist)
{
	PyObject *result;
	lock_import();
	result = import_module_ex(name, globals, locals, fromlist);
	unlock_import();
	return result;
}

static PyObject *
get_parent(PyObject *globals, char *buf, int *p_buflen)
{
	static PyObject *namestr = NULL;
	static PyObject *pathstr = NULL;
	PyObject *modname, *modpath, *modules, *parent;

	if (globals == NULL || !PyDict_Check(globals))
		return Py_None;

	if (namestr == NULL) {
		namestr = PyString_InternFromString("__name__");
		if (namestr == NULL)
			return NULL;
	}
	if (pathstr == NULL) {
		pathstr = PyString_InternFromString("__path__");
		if (pathstr == NULL)
			return NULL;
	}

	*buf = '\0';
	*p_buflen = 0;
	modname = PyDict_GetItem(globals, namestr);
	if (modname == NULL || !PyString_Check(modname))
		return Py_None;

	modpath = PyDict_GetItem(globals, pathstr);
	if (modpath != NULL) {
		int len = PyString_GET_SIZE(modname);
		if (len &gt; MAXPATHLEN) {
			PyErr_SetString(PyExc_ValueError,
					"Module name too long");
			return NULL;
		}
		strcpy(buf, PyString_AS_STRING(modname));
		*p_buflen = len;
	}
	else {
		char *start = PyString_AS_STRING(modname);
		char *lastdot = strrchr(start, '.');
		size_t len;
		if (lastdot == NULL)
			return Py_None;
		len = lastdot - start;
		if (len &gt;= MAXPATHLEN) {
			PyErr_SetString(PyExc_ValueError,
					"Module name too long");
			return NULL;
		}
		strncpy(buf, start, len);
		buf[len] = '\0';
		*p_buflen = len;
	}

	modules = PyImport_GetModuleDict();
	parent = PyDict_GetItemString(modules, buf);
	if (parent == NULL)
		parent = Py_None;
	return parent;
	/* We expect, but can't guarantee, if parent != None, that:
	   - parent.__name__ == buf
	   - parent.__dict__ is globals
	   If this is violated...  Who cares? */
}

/* altmod is either None or same as mod */
static PyObject *
load_next(PyObject *mod, PyObject *altmod, char **p_name, char *buf,
	  int *p_buflen)
{
	char *name = *p_name;
	char *dot = strchr(name, '.');
	size_t len;
	char *p;
	PyObject *result;

	if (dot == NULL) {
		*p_name = NULL;
		len = strlen(name);
	}
	else {
		*p_name = dot+1;
		len = dot-name;
	}
	if (len == 0) {
		PyErr_SetString(PyExc_ValueError,
				"Empty module name");
		return NULL;
	}

	p = buf + *p_buflen;
	if (p != buf)
		*p++ = '.';
	if (p+len-buf &gt;= MAXPATHLEN) {
		PyErr_SetString(PyExc_ValueError,
				"Module name too long");
		return NULL;
	}
	strncpy(p, name, len);
	p[len] = '\0';
	*p_buflen = p+len-buf;

	result = import_submodule(mod, p, buf);
	if (result == Py_None &amp;&amp; altmod != mod) {
		Py_DECREF(result);
		/* Here, altmod must be None and mod must not be None */
		result = import_submodule(altmod, p, p);
		if (result != NULL &amp;&amp; result != Py_None) {
			if (mark_miss(buf) != 0) {
				Py_DECREF(result);
				return NULL;
			}
			strncpy(buf, name, len);
			buf[len] = '\0';
			*p_buflen = len;
		}
	}
	if (result == NULL)
		return NULL;

	if (result == Py_None) {
		Py_DECREF(result);
		PyErr_Format(PyExc_ImportError,
			     "No module named %.200s", name);
		return NULL;
	}

	return result;
}

static int
mark_miss(char *name)
{
	PyObject *modules = PyImport_GetModuleDict();
	return PyDict_SetItemString(modules, name, Py_None);
}

static int
ensure_fromlist(PyObject *mod, PyObject *fromlist, char *buf, int buflen,
		int recursive)
{
	int i;

	if (!PyObject_HasAttrString(mod, "__path__"))
		return 1;

	for (i = 0; ; i++) {
		PyObject *item = PySequence_GetItem(fromlist, i);
		int hasit;
		if (item == NULL) {
			if (PyErr_ExceptionMatches(PyExc_IndexError)) {
				PyErr_Clear();
				return 1;
			}
			return 0;
		}
		if (!PyString_Check(item)) {
			PyErr_SetString(PyExc_TypeError,
					"Item in ``from list'' not a string");
			Py_DECREF(item);
			return 0;
		}
		if (PyString_AS_STRING(item)[0] == '*') {
			PyObject *all;
			Py_DECREF(item);
			/* See if the package defines __all__ */
			if (recursive)
				continue; /* Avoid endless recursion */
			all = PyObject_GetAttrString(mod, "__all__");
			if (all == NULL)
				PyErr_Clear();
			else {
				if (!ensure_fromlist(mod, all, buf, buflen, 1))
					return 0;
				Py_DECREF(all);
			}
			continue;
		}
		hasit = PyObject_HasAttr(mod, item);
		if (!hasit) {
			char *subname = PyString_AS_STRING(item);
			PyObject *submod;
			char *p;
			if (buflen + strlen(subname) &gt;= MAXPATHLEN) {
				PyErr_SetString(PyExc_ValueError,
						"Module name too long");
				Py_DECREF(item);
				return 0;
			}
			p = buf + buflen;
			*p++ = '.';
			strcpy(p, subname);
			submod = import_submodule(mod, subname, buf);
			Py_XDECREF(submod);
			if (submod == NULL) {
				Py_DECREF(item);
				return 0;
			}
		}
		Py_DECREF(item);
	}

	/* NOTREACHED */
}

static PyObject *
import_submodule(PyObject *mod, char *subname, char *fullname)
{
	PyObject *modules = PyImport_GetModuleDict();
	PyObject *m, *res = NULL;

	/* Require:
	   if mod == None: subname == fullname
	   else: mod.__name__ + "." + subname == fullname
	*/

	if ((m = PyDict_GetItemString(modules, fullname)) != NULL) {
		Py_INCREF(m);
	}
	else {
		PyObject *path;
		char buf[MAXPATHLEN+1];
		struct filedescr *fdp;
		FILE *fp = NULL;

		if (mod == Py_None)
			path = NULL;
		else {
			path = PyObject_GetAttrString(mod, "__path__");
			if (path == NULL) {
				PyErr_Clear();
				Py_INCREF(Py_None);
				return Py_None;
			}
		}

		buf[0] = '\0';
		fdp = find_module(subname, path, buf, MAXPATHLEN+1, &amp;fp);
		Py_XDECREF(path);
		if (fdp == NULL) {
			if (!PyErr_ExceptionMatches(PyExc_ImportError))
				return NULL;
			PyErr_Clear();
			Py_INCREF(Py_None);
			return Py_None;
		}
		m = load_module(fullname, fp, buf, fdp-&gt;type);
		if (fp)
			fclose(fp);
		if (mod != Py_None) {
			/* Irrespective of the success of this load, make a
			   reference to it in the parent package module.
			   A copy gets saved in the modules dictionary
			   under the full name, so get a reference from
			   there, if need be.  (The exception is when
			   the load failed with a SyntaxError -- then
			   there's no trace in sys.modules.  In that case,
			   of course, do nothing extra.) */
			res = m;
			if (res == NULL)
				res = PyDict_GetItemString(modules, fullname);
			if (res != NULL &amp;&amp;
			    PyObject_SetAttrString(mod, subname, res) &lt; 0) {
				Py_XDECREF(m);
				m = NULL;
			}
		}
	}

	return m;
}


/* Re-import a module of any kind and return its module object, WITH
   INCREMENTED REFERENCE COUNT */

PyObject *
PyImport_ReloadModule(PyObject *m)
{
	PyObject *modules = PyImport_GetModuleDict();
	PyObject *path = NULL;
	char *name, *subname;
	char buf[MAXPATHLEN+1];
	struct filedescr *fdp;
	FILE *fp = NULL;

	if (m == NULL || !PyModule_Check(m)) {
		PyErr_SetString(PyExc_TypeError,
				"reload() argument must be module");
		return NULL;
	}
	name = PyModule_GetName(m);
	if (name == NULL)
		return NULL;
	if (m != PyDict_GetItemString(modules, name)) {
		PyErr_Format(PyExc_ImportError,
			     "reload(): module %.200s not in sys.modules",
			     name);
		return NULL;
	}
	subname = strrchr(name, '.');
	if (subname == NULL)
		subname = name;
	else {
		PyObject *parentname, *parent;
		parentname = PyString_FromStringAndSize(name, (subname-name));
		if (parentname == NULL)
			return NULL;
		parent = PyDict_GetItem(modules, parentname);
		Py_DECREF(parentname);
		if (parent == NULL) {
			PyErr_Format(PyExc_ImportError,
			    "reload(): parent %.200s not in sys.modules",
			    name);
			return NULL;
		}
		subname++;
		path = PyObject_GetAttrString(parent, "__path__");
		if (path == NULL)
			PyErr_Clear();
	}
	buf[0] = '\0';
	fdp = find_module(subname, path, buf, MAXPATHLEN+1, &amp;fp);
	Py_XDECREF(path);
	if (fdp == NULL)
		return NULL;
	m = load_module(name, fp, buf, fdp-&gt;type);
	if (fp)
		fclose(fp);
	return m;
}


/* Higher-level import emulator which emulates the "import" statement
   more accurately -- it invokes the __import__() function from the
   builtins of the current globals.  This means that the import is
   done using whatever import hooks are installed in the current
   environment, e.g. by "rexec".
   A dummy list ["__doc__"] is passed as the 4th argument so that
   e.g. PyImport_Import(PyString_FromString("win32com.client.gencache"))
   will return &lt;module "gencache"&gt; instead of &lt;module "win32com"&gt;. */

PyObject *
PyImport_Import(PyObject *module_name)
{
	static PyObject *silly_list = NULL;
	static PyObject *builtins_str = NULL;
	static PyObject *import_str = NULL;
	PyObject *globals = NULL;
	PyObject *import = NULL;
	PyObject *builtins = NULL;
	PyObject *r = NULL;

	/* Initialize constant string objects */
	if (silly_list == NULL) {
		import_str = PyString_InternFromString("__import__");
		if (import_str == NULL)
			return NULL;
		builtins_str = PyString_InternFromString("__builtins__");
		if (builtins_str == NULL)
			return NULL;
		silly_list = Py_BuildValue("[s]", "__doc__");
		if (silly_list == NULL)
			return NULL;
	}

	/* Get the builtins from current globals */
	globals = PyEval_GetGlobals();
	if (globals != NULL) {
	        Py_INCREF(globals);
		builtins = PyObject_GetItem(globals, builtins_str);
		if (builtins == NULL)
			goto err;
	}
	else {
		/* No globals -- use standard builtins, and fake globals */
		PyErr_Clear();

		builtins = PyImport_ImportModuleEx("__builtin__",
						   NULL, NULL, NULL);
		if (builtins == NULL)
			return NULL;
		globals = Py_BuildValue("{OO}", builtins_str, builtins);
		if (globals == NULL)
			goto err;
	}

	/* Get the __import__ function from the builtins */
	if (PyDict_Check(builtins)) {
		import = PyObject_GetItem(builtins, import_str);
		if (import == NULL)
			PyErr_SetObject(PyExc_KeyError, import_str);
	}
	else
		import = PyObject_GetAttr(builtins, import_str);
	if (import == NULL)
		goto err;

	/* Call the _import__ function with the proper argument list */
	r = PyObject_CallFunction(import, "OOOO",
				  module_name, globals, globals, silly_list);

  err:
	Py_XDECREF(globals);
	Py_XDECREF(builtins);
	Py_XDECREF(import);

	return r;
}


/* Module 'imp' provides Python access to the primitives used for
   importing modules.
*/

static PyObject *
imp_get_magic(PyObject *self, PyObject *args)
{
	char buf[4];

	if (!PyArg_ParseTuple(args, ":get_magic"))
		return NULL;
	buf[0] = (char) ((pyc_magic &gt;&gt;  0) &amp; 0xff);
	buf[1] = (char) ((pyc_magic &gt;&gt;  8) &amp; 0xff);
	buf[2] = (char) ((pyc_magic &gt;&gt; 16) &amp; 0xff);
	buf[3] = (char) ((pyc_magic &gt;&gt; 24) &amp; 0xff);

	return PyString_FromStringAndSize(buf, 4);
}

static PyObject *
imp_get_suffixes(PyObject *self, PyObject *args)
{
	PyObject *list;
	struct filedescr *fdp;

	if (!PyArg_ParseTuple(args, ":get_suffixes"))
		return NULL;
	list = PyList_New(0);
	if (list == NULL)
		return NULL;
	for (fdp = _PyImport_Filetab; fdp-&gt;suffix != NULL; fdp++) {
		PyObject *item = Py_BuildValue("ssi",
				       fdp-&gt;suffix, fdp-&gt;mode, fdp-&gt;type);
		if (item == NULL) {
			Py_DECREF(list);
			return NULL;
		}
		if (PyList_Append(list, item) &lt; 0) {
			Py_DECREF(list);
			Py_DECREF(item);
			return NULL;
		}
		Py_DECREF(item);
	}
	return list;
}

static PyObject *
call_find_module(char *name, PyObject *path)
{
	extern int fclose(FILE *);
	PyObject *fob, *ret;
	struct filedescr *fdp;
	char pathname[MAXPATHLEN+1];
	FILE *fp = NULL;

	pathname[0] = '\0';
	if (path == Py_None)
		path = NULL;
	fdp = find_module(name, path, pathname, MAXPATHLEN+1, &amp;fp);
	if (fdp == NULL)
		return NULL;
	if (fp != NULL) {
		fob = PyFile_FromFile(fp, pathname, fdp-&gt;mode, fclose);
		if (fob == NULL) {
			fclose(fp);
			return NULL;
		}
	}
	else {
		fob = Py_None;
		Py_INCREF(fob);
	}
	ret = Py_BuildValue("Os(ssi)",
		      fob, pathname, fdp-&gt;suffix, fdp-&gt;mode, fdp-&gt;type);
	Py_DECREF(fob);
	return ret;
}

static PyObject *
imp_find_module(PyObject *self, PyObject *args)
{
	char *name;
	PyObject *path = NULL;
	if (!PyArg_ParseTuple(args, "s|O:find_module", &amp;name, &amp;path))
		return NULL;
	return call_find_module(name, path);
}

static PyObject *
imp_init_builtin(PyObject *self, PyObject *args)
{
	char *name;
	int ret;
	PyObject *m;
	if (!PyArg_ParseTuple(args, "s:init_builtin", &amp;name))
		return NULL;
	ret = init_builtin(name);
	if (ret &lt; 0)
		return NULL;
	if (ret == 0) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	m = PyImport_AddModule(name);
	Py_XINCREF(m);
	return m;
}

static PyObject *
imp_init_frozen(PyObject *self, PyObject *args)
{
	char *name;
	int ret;
	PyObject *m;
	if (!PyArg_ParseTuple(args, "s:init_frozen", &amp;name))
		return NULL;
	ret = PyImport_ImportFrozenModule(name);
	if (ret &lt; 0)
		return NULL;
	if (ret == 0) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	m = PyImport_AddModule(name);
	Py_XINCREF(m);
	return m;
}

static PyObject *
imp_get_frozen_object(PyObject *self, PyObject *args)
{
	char *name;

	if (!PyArg_ParseTuple(args, "s:get_frozen_object", &amp;name))
		return NULL;
	return get_frozen_object(name);
}

static PyObject *
imp_is_builtin(PyObject *self, PyObject *args)
{
	char *name;
	if (!PyArg_ParseTuple(args, "s:is_builtin", &amp;name))
		return NULL;
	return PyInt_FromLong(is_builtin(name));
}

static PyObject *
imp_is_frozen(PyObject *self, PyObject *args)
{
	char *name;
	struct _frozen *p;
	if (!PyArg_ParseTuple(args, "s:is_frozen", &amp;name))
		return NULL;
	p = find_frozen(name);
	return PyInt_FromLong((long) (p == NULL ? 0 : p-&gt;size));
}

static FILE *
get_file(char *pathname, PyObject *fob, char *mode)
{
	FILE *fp;
	if (fob == NULL) {
		fp = fopen(pathname, mode);
		if (fp == NULL)
			PyErr_SetFromErrno(PyExc_IOError);
	}
	else {
		fp = PyFile_AsFile(fob);
		if (fp == NULL)
			PyErr_SetString(PyExc_ValueError,
					"bad/closed file object");
	}
	return fp;
}

static PyObject *
imp_load_compiled(PyObject *self, PyObject *args)
{
	char *name;
	char *pathname;
	PyObject *fob = NULL;
	PyObject *m;
	FILE *fp;
	if (!PyArg_ParseTuple(args, "ss|O!:load_compiled", &amp;name, &amp;pathname,
			      &amp;PyFile_Type, &amp;fob))
		return NULL;
	fp = get_file(pathname, fob, "rb");
	if (fp == NULL)
		return NULL;
	m = load_compiled_module(name, pathname, fp);
	if (fob == NULL)
		fclose(fp);
	return m;
}

#ifdef HAVE_DYNAMIC_LOADING

static PyObject *
imp_load_dynamic(PyObject *self, PyObject *args)
{
	char *name;
	char *pathname;
	PyObject *fob = NULL;
	PyObject *m;
	FILE *fp = NULL;
	if (!PyArg_ParseTuple(args, "ss|O!:load_dynamic", &amp;name, &amp;pathname,
			      &amp;PyFile_Type, &amp;fob))
		return NULL;
	if (fob) {
		fp = get_file(pathname, fob, "r");
		if (fp == NULL)
			return NULL;
	}
	m = _PyImport_LoadDynamicModule(name, pathname, fp);
	return m;
}

#endif /* HAVE_DYNAMIC_LOADING */

static PyObject *
imp_load_source(PyObject *self, PyObject *args)
{
	char *name;
	char *pathname;
	PyObject *fob = NULL;
	PyObject *m;
	FILE *fp;
	if (!PyArg_ParseTuple(args, "ss|O!:load_source", &amp;name, &amp;pathname,
			      &amp;PyFile_Type, &amp;fob))
		return NULL;
	fp = get_file(pathname, fob, "r");
	if (fp == NULL)
		return NULL;
	m = load_source_module(name, pathname, fp);
	if (fob == NULL)
		fclose(fp);
	return m;
}

#ifdef macintosh
static PyObject *
imp_load_resource(PyObject *self, PyObject *args)
{
	char *name;
	char *pathname;
	PyObject *m;

	if (!PyArg_ParseTuple(args, "ss:load_resource", &amp;name, &amp;pathname))
		return NULL;
	m = PyMac_LoadResourceModule(name, pathname);
	return m;
}
#endif /* macintosh */

static PyObject *
imp_load_module(PyObject *self, PyObject *args)
{
	char *name;
	PyObject *fob;
	char *pathname;
	char *suffix; /* Unused */
	char *mode;
	int type;
	FILE *fp;

	if (!PyArg_ParseTuple(args, "sOs(ssi):load_module",
			      &amp;name, &amp;fob, &amp;pathname,
			      &amp;suffix, &amp;mode, &amp;type))
		return NULL;
	if (*mode &amp;&amp; (*mode != 'r' || strchr(mode, '+') != NULL)) {
		PyErr_Format(PyExc_ValueError,
			     "invalid file open mode %.200s", mode);
		return NULL;
	}
	if (fob == Py_None)
		fp = NULL;
	else {
		if (!PyFile_Check(fob)) {
			PyErr_SetString(PyExc_ValueError,
				"load_module arg#2 should be a file or None");
			return NULL;
		}
		fp = get_file(pathname, fob, mode);
		if (fp == NULL)
			return NULL;
	}
	return load_module(name, fp, pathname, type);
}

static PyObject *
imp_load_package(PyObject *self, PyObject *args)
{
	char *name;
	char *pathname;
	if (!PyArg_ParseTuple(args, "ss:load_package", &amp;name, &amp;pathname))
		return NULL;
	return load_package(name, pathname);
}

static PyObject *
imp_new_module(PyObject *self, PyObject *args)
{
	char *name;
	if (!PyArg_ParseTuple(args, "s:new_module", &amp;name))
		return NULL;
	return PyModule_New(name);
}

/* Doc strings */

static char doc_imp[] = "\
This module provides the components needed to build your own\n\
__import__ function.  Undocumented functions are obsolete.\n\
";

static char doc_find_module[] = "\
find_module(name, [path]) -&gt; (file, filename, (suffix, mode, type))\n\
Search for a module.  If path is omitted or None, search for a\n\
built-in, frozen or special module and continue search in sys.path.\n\
The module name cannot contain '.'; to search for a submodule of a\n\
package, pass the submodule name and the package's __path__.\
";

static char doc_load_module[] = "\
load_module(name, file, filename, (suffix, mode, type)) -&gt; module\n\
Load a module, given information returned by find_module().\n\
The module name must include the full package name, if any.\
";

static char doc_get_magic[] = "\
get_magic() -&gt; string\n\
Return the magic number for .pyc or .pyo files.\
";

static char doc_get_suffixes[] = "\
get_suffixes() -&gt; [(suffix, mode, type), ...]\n\
Return a list of (suffix, mode, type) tuples describing the files\n\
that find_module() looks for.\
";

static char doc_new_module[] = "\
new_module(name) -&gt; module\n\
Create a new module.  Do not enter it in sys.modules.\n\
The module name must include the full package name, if any.\
";

static char doc_lock_held[] = "\
lock_held() -&gt; 0 or 1\n\
Return 1 if the import lock is currently held.\n\
On platforms without threads, return 0.\
";

static PyMethodDef imp_methods[] = {
	{"find_module",		imp_find_module,	1, doc_find_module},
	{"get_magic",		imp_get_magic,		1, doc_get_magic},
	{"get_suffixes",	imp_get_suffixes,	1, doc_get_suffixes},
	{"load_module",		imp_load_module,	1, doc_load_module},
	{"new_module",		imp_new_module,		1, doc_new_module},
	{"lock_held",		imp_lock_held,		1, doc_lock_held},
	/* The rest are obsolete */
	{"get_frozen_object",	imp_get_frozen_object,	1},
	{"init_builtin",	imp_init_builtin,	1},
	{"init_frozen",		imp_init_frozen,	1},
	{"is_builtin",		imp_is_builtin,		1},
	{"is_frozen",		imp_is_frozen,		1},
	{"load_compiled",	imp_load_compiled,	1},
#ifdef HAVE_DYNAMIC_LOADING
	{"load_dynamic",	imp_load_dynamic,	1},
#endif
	{"load_package",	imp_load_package,	1},
#ifdef macintosh
	{"load_resource",	imp_load_resource,	1},
#endif
	{"load_source",		imp_load_source,	1},
	{NULL,			NULL}		/* sentinel */
};

static int
setint(PyObject *d, char *name, int value)
{
	PyObject *v;
	int err;

	v = PyInt_FromLong((long)value);
	err = PyDict_SetItemString(d, name, v);
	Py_XDECREF(v);
	return err;
}

void
initimp(void)
{
	PyObject *m, *d;

	m = Py_InitModule4("imp", imp_methods, doc_imp,
			   NULL, PYTHON_API_VERSION);
	d = PyModule_GetDict(m);

	if (setint(d, "SEARCH_ERROR", SEARCH_ERROR) &lt; 0) goto failure;
	if (setint(d, "PY_SOURCE", PY_SOURCE) &lt; 0) goto failure;
	if (setint(d, "PY_COMPILED", PY_COMPILED) &lt; 0) goto failure;
	if (setint(d, "C_EXTENSION", C_EXTENSION) &lt; 0) goto failure;
	if (setint(d, "PY_RESOURCE", PY_RESOURCE) &lt; 0) goto failure;
	if (setint(d, "PKG_DIRECTORY", PKG_DIRECTORY) &lt; 0) goto failure;
	if (setint(d, "C_BUILTIN", C_BUILTIN) &lt; 0) goto failure;
	if (setint(d, "PY_FROZEN", PY_FROZEN) &lt; 0) goto failure;
	if (setint(d, "PY_CODERESOURCE", PY_CODERESOURCE) &lt; 0) goto failure;

  failure:
	;
}


/* API for embedding applications that want to add their own entries
   to the table of built-in modules.  This should normally be called
   *before* Py_Initialize().  When the table resize fails, -1 is
   returned and the existing table is unchanged.

   After a similar function by Just van Rossum. */

int
PyImport_ExtendInittab(struct _inittab *newtab)
{
	static struct _inittab *our_copy = NULL;
	struct _inittab *p;
	int i, n;

	/* Count the number of entries in both tables */
	for (n = 0; newtab[n].name != NULL; n++)
		;
	if (n == 0)
		return 0; /* Nothing to do */
	for (i = 0; PyImport_Inittab[i].name != NULL; i++)
		;

	/* Allocate new memory for the combined table */
	p = our_copy;
	PyMem_RESIZE(p, struct _inittab, i+n+1);
	if (p == NULL)
		return -1;

	/* Copy the tables into the new memory */
	if (our_copy != PyImport_Inittab)
		memcpy(p, PyImport_Inittab, (i+1) * sizeof(struct _inittab));
	PyImport_Inittab = our_copy = p;
	memcpy(p+i, newtab, (n+1) * sizeof(struct _inittab));

	return 0;
}

/* Shorthand to add a single entry given a name and a function */

int
PyImport_AppendInittab(char *name, void (*initfunc)(void))
{
	struct _inittab newtab[2];

	memset(newtab, '\0', sizeof newtab);

	newtab[0].name = name;
	newtab[0].initfunc = initfunc;

	return PyImport_ExtendInittab(newtab);
}
</t>
<t tx="T909">#include "Python.h"

#include "node.h"
#include "token.h"
#include "errcode.h"
#include "marshal.h"
#include "compile.h"
#include "eval.h"
#include "osdefs.h"
#include "importdl.h"
</t>
<t tx="T910">#ifdef macintosh
#include "macglue.h"
#endif

#ifdef HAVE_FCNTL_H
#include &lt;fcntl.h&gt;
#endif

extern time_t PyOS_GetLastModificationTime(char *, FILE *);
						/* In getmtime.c */

/* Magic word to reject .pyc files generated by other Python versions */
/* Change for each incompatible change */
/* The value of CR and LF is incorporated so if you ever read or write
   a .pyc file in text mode the magic number will be wrong; also, the
   Apple MPW compiler swaps their values, botching string constants.
   XXX That probably isn't important anymore.
*/
/* XXX Perhaps the magic number should be frozen and a version field
   added to the .pyc file header? */
/* New way to come up with the low 16 bits of the magic number:
      (YEAR-1995) * 10000 +  MONTH * 100 + DAY
   where MONTH and DAY are 1-based.
   XXX Whatever the "old way" may have been isn't documented.
   XXX This scheme breaks in 2002, as (2002-1995)*10000 = 70000 doesn't
       fit in 16 bits.
   XXX Later, sometimes 1 gets added to MAGIC in order to record that
       the Unicode -U option is in use.  IMO (Tim's), that's a Bad Idea
       (quite apart from that the -U option doesn't work so isn't used
       anyway).
*/
#define MAGIC (60717 | ((long)'\r'&lt;&lt;16) | ((long)'\n'&lt;&lt;24))

/* Magic word as global; note that _PyImport_Init() can change the
   value of this global to accommodate for alterations of how the
   compiler works which are enabled by command line switches. */
static long pyc_magic = MAGIC;

/* See _PyImport_FixupExtension() below */
static PyObject *extensions = NULL;

/* This table is defined in config.c: */
extern struct _inittab _PyImport_Inittab[];

struct _inittab *PyImport_Inittab = _PyImport_Inittab;

/* these tables define the module suffixes that Python recognizes */
struct filedescr * _PyImport_Filetab = NULL;

#ifdef RISCOS
static const struct filedescr _PyImport_StandardFiletab[] = {
	{"/py", "r", PY_SOURCE},
	{"/pyc", "rb", PY_COMPILED},
	{0, 0}
};
#else
static const struct filedescr _PyImport_StandardFiletab[] = {
	{".py", "r", PY_SOURCE},
#ifdef MS_WIN32
	{".pyw", "r", PY_SOURCE},
#endif
	{".pyc", "rb", PY_COMPILED},
	{0, 0}
};
</t>
<t tx="T911">#endif

/* Initialize things */

void
_PyImport_Init(void)
{
	const struct filedescr *scan;
	struct filedescr *filetab;
	int countD = 0;
	int countS = 0;

	/* prepare _PyImport_Filetab: copy entries from
	   _PyImport_DynLoadFiletab and _PyImport_StandardFiletab.
	 */
	for (scan = _PyImport_DynLoadFiletab; scan-&gt;suffix != NULL; ++scan)
		++countD;
	for (scan = _PyImport_StandardFiletab; scan-&gt;suffix != NULL; ++scan)
		++countS;
	filetab = PyMem_NEW(struct filedescr, countD + countS + 1);
	memcpy(filetab, _PyImport_DynLoadFiletab,
	       countD * sizeof(struct filedescr));
	memcpy(filetab + countD, _PyImport_StandardFiletab,
	       countS * sizeof(struct filedescr));
	filetab[countD + countS].suffix = NULL;

	_PyImport_Filetab = filetab;

	if (Py_OptimizeFlag) {
		/* Replace ".pyc" with ".pyo" in _PyImport_Filetab */
		for (; filetab-&gt;suffix != NULL; filetab++) {
#ifndef RISCOS
			if (strcmp(filetab-&gt;suffix, ".pyc") == 0)
				filetab-&gt;suffix = ".pyo";
#else
			if (strcmp(filetab-&gt;suffix, "/pyc") == 0)
				filetab-&gt;suffix = "/pyo";
#endif
		}
	}

	if (Py_UnicodeFlag) {
		/* Fix the pyc_magic so that byte compiled code created
		   using the all-Unicode method doesn't interfere with
		   code created in normal operation mode. */
		pyc_magic = MAGIC + 1;
	}
}
</t>
<t tx="T912">void
_PyImport_Fini(void)
{
	Py_XDECREF(extensions);
	extensions = NULL;
	PyMem_DEL(_PyImport_Filetab);
	_PyImport_Filetab = NULL;
}
</t>
<t tx="T913">@ Locking primitives to prevent parallel imports of the same module  in different threads to return with a partially loaded module.  These calls are serialized by the global interpreter lock.
@c

#ifdef WITH_THREAD

#include "pythread.h"

static PyThread_type_lock import_lock = 0;
static long import_lock_thread = -1;
static int import_lock_level = 0;

static void
lock_import(void)
{
	long me = PyThread_get_thread_ident();
	if (me == -1)
		return; /* Too bad */
	if (import_lock == NULL)
		import_lock = PyThread_allocate_lock();
	if (import_lock_thread == me) {
		import_lock_level++;
		return;
	}
	if (import_lock_thread != -1 || !PyThread_acquire_lock(import_lock, 0)) {
		PyThreadState *tstate = PyEval_SaveThread();
		PyThread_acquire_lock(import_lock, 1);
		PyEval_RestoreThread(tstate);
	}
	import_lock_thread = me;
	import_lock_level = 1;
}
</t>
<t tx="T914">static void
unlock_import(void)
{
	long me = PyThread_get_thread_ident();
	if (me == -1)
		return; /* Too bad */
	if (import_lock_thread != me)
		Py_FatalError("unlock_import: not holding the import lock");
	import_lock_level--;
	if (import_lock_level == 0) {
		import_lock_thread = -1;
		PyThread_release_lock(import_lock);
	}
}
</t>
<t tx="T915">#else

#define lock_import()
#define unlock_import()

#endif

static PyObject *
imp_lock_held(PyObject *self, PyObject *args)
{
	if (!PyArg_ParseTuple(args, ":lock_held"))
		return NULL;
#ifdef WITH_THREAD
	return PyInt_FromLong(import_lock_thread != -1);
#else
	return PyInt_FromLong(0);
#endif
}
</t>
<t tx="T916">@ Helper for sys
@c

PyObject *
PyImport_GetModuleDict(void)
{
	PyInterpreterState *interp = PyThreadState_Get()-&gt;interp;
	if (interp-&gt;modules == NULL)
		Py_FatalError("PyImport_GetModuleDict: no module dictionary!");
	return interp-&gt;modules;
}
</t>
<t tx="T917">@ List of names to clear in sys
@c

static char* sys_deletes[] = {
	"path", "argv", "ps1", "ps2", "exitfunc",
	"exc_type", "exc_value", "exc_traceback",
	"last_type", "last_value", "last_traceback",
	NULL
};

static char* sys_files[] = {
	"stdin", "__stdin__",
	"stdout", "__stdout__",
	"stderr", "__stderr__",
	NULL
};


/* Un-initialize things, as good as we can */

void
PyImport_Cleanup(void)
{
	int pos, ndone;
	char *name;
	PyObject *key, *value, *dict;
	PyInterpreterState *interp = PyThreadState_Get()-&gt;interp;
	PyObject *modules = interp-&gt;modules;

	if (modules == NULL)
		return; /* Already done */

	/* Delete some special variables first.  These are common
	   places where user values hide and people complain when their
	   destructors fail.  Since the modules containing them are
	   deleted *last* of all, they would come too late in the normal
	   destruction order.  Sigh. */

	value = PyDict_GetItemString(modules, "__builtin__");
	if (value != NULL &amp;&amp; PyModule_Check(value)) {
		dict = PyModule_GetDict(value);
		if (Py_VerboseFlag)
			PySys_WriteStderr("# clear __builtin__._\n");
		PyDict_SetItemString(dict, "_", Py_None);
	}
	value = PyDict_GetItemString(modules, "sys");
	if (value != NULL &amp;&amp; PyModule_Check(value)) {
		char **p;
		PyObject *v;
		dict = PyModule_GetDict(value);
		for (p = sys_deletes; *p != NULL; p++) {
			if (Py_VerboseFlag)
				PySys_WriteStderr("# clear sys.%s\n", *p);
			PyDict_SetItemString(dict, *p, Py_None);
		}
		for (p = sys_files; *p != NULL; p+=2) {
			if (Py_VerboseFlag)
				PySys_WriteStderr("# restore sys.%s\n", *p);
			v = PyDict_GetItemString(dict, *(p+1));
			if (v == NULL)
				v = Py_None;
			PyDict_SetItemString(dict, *p, v);
		}
	}

	/* First, delete __main__ */
	value = PyDict_GetItemString(modules, "__main__");
	if (value != NULL &amp;&amp; PyModule_Check(value)) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# cleanup __main__\n");
		_PyModule_Clear(value);
		PyDict_SetItemString(modules, "__main__", Py_None);
	}

	/* The special treatment of __builtin__ here is because even
	   when it's not referenced as a module, its dictionary is
	   referenced by almost every module's __builtins__.  Since
	   deleting a module clears its dictionary (even if there are
	   references left to it), we need to delete the __builtin__
	   module last.  Likewise, we don't delete sys until the very
	   end because it is implicitly referenced (e.g. by print).

	   Also note that we 'delete' modules by replacing their entry
	   in the modules dict with None, rather than really deleting
	   them; this avoids a rehash of the modules dictionary and
	   also marks them as "non existent" so they won't be
	   re-imported. */

	/* Next, repeatedly delete modules with a reference count of
	   one (skipping __builtin__ and sys) and delete them */
	do {
		ndone = 0;
		pos = 0;
		while (PyDict_Next(modules, &amp;pos, &amp;key, &amp;value)) {
			if (value-&gt;ob_refcnt != 1)
				continue;
			if (PyString_Check(key) &amp;&amp; PyModule_Check(value)) {
				name = PyString_AS_STRING(key);
				if (strcmp(name, "__builtin__") == 0)
					continue;
				if (strcmp(name, "sys") == 0)
					continue;
				if (Py_VerboseFlag)
					PySys_WriteStderr(
						"# cleanup[1] %s\n", name);
				_PyModule_Clear(value);
				PyDict_SetItem(modules, key, Py_None);
				ndone++;
			}
		}
	} while (ndone &gt; 0);

	/* Next, delete all modules (still skipping __builtin__ and sys) */
	pos = 0;
	while (PyDict_Next(modules, &amp;pos, &amp;key, &amp;value)) {
		if (PyString_Check(key) &amp;&amp; PyModule_Check(value)) {
			name = PyString_AS_STRING(key);
			if (strcmp(name, "__builtin__") == 0)
				continue;
			if (strcmp(name, "sys") == 0)
				continue;
			if (Py_VerboseFlag)
				PySys_WriteStderr("# cleanup[2] %s\n", name);
			_PyModule_Clear(value);
			PyDict_SetItem(modules, key, Py_None);
		}
	}

	/* Next, delete sys and __builtin__ (in that order) */
	value = PyDict_GetItemString(modules, "sys");
	if (value != NULL &amp;&amp; PyModule_Check(value)) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# cleanup sys\n");
		_PyModule_Clear(value);
		PyDict_SetItemString(modules, "sys", Py_None);
	}
	value = PyDict_GetItemString(modules, "__builtin__");
	if (value != NULL &amp;&amp; PyModule_Check(value)) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# cleanup __builtin__\n");
		_PyModule_Clear(value);
		PyDict_SetItemString(modules, "__builtin__", Py_None);
	}

	/* Finally, clear and delete the modules directory */
	PyDict_Clear(modules);
	interp-&gt;modules = NULL;
	Py_DECREF(modules);
}
</t>
<t tx="T918">@ Helper for pythonrun.c -- return magic number
@c

long
PyImport_GetMagicNumber(void)
{
	return pyc_magic;
}
</t>
<t tx="T919">@ Magic for extension modules (built-in as well as dynamically  loaded). To prevent initializing an extension module more than  once, we keep a static dictionary 'extensions' keyed by module name  (for built-in modules) or by filename (for dynamically loaded  modules), containing these modules. A copy of the module's  dictionary is stored by calling _PyImport_FixupExtension()  immediately after the module initialization function succeeds. A  copy can be retrieved from there by calling  _PyImport_FindExtension().
@c

PyObject *
_PyImport_FixupExtension(char *name, char *filename)
{
	PyObject *modules, *mod, *dict, *copy;
	if (extensions == NULL) {
		extensions = PyDict_New();
		if (extensions == NULL)
			return NULL;
	}
	modules = PyImport_GetModuleDict();
	mod = PyDict_GetItemString(modules, name);
	if (mod == NULL || !PyModule_Check(mod)) {
		PyErr_Format(PyExc_SystemError,
		  "_PyImport_FixupExtension: module %.200s not loaded", name);
		return NULL;
	}
	dict = PyModule_GetDict(mod);
	if (dict == NULL)
		return NULL;
	copy = PyDict_Copy(dict);
	if (copy == NULL)
		return NULL;
	PyDict_SetItemString(extensions, filename, copy);
	Py_DECREF(copy);
	return copy;
}
</t>
<t tx="T920">PyObject *
_PyImport_FindExtension(char *name, char *filename)
{
	PyObject *dict, *mod, *mdict;
	if (extensions == NULL)
		return NULL;
	dict = PyDict_GetItemString(extensions, filename);
	if (dict == NULL)
		return NULL;
	mod = PyImport_AddModule(name);
	if (mod == NULL)
		return NULL;
	mdict = PyModule_GetDict(mod);
	if (mdict == NULL)
		return NULL;
	if (PyDict_Update(mdict, dict))
		return NULL;
	if (Py_VerboseFlag)
		PySys_WriteStderr("import %s # previously loaded (%s)\n",
			name, filename);
	return mod;
}
</t>
<t tx="T921">@ Get the module object corresponding to a module name.  First check the modules dictionary if there's one there,  if not, create a new one and insert in in the modules dictionary.  Because the former action is most common, THIS DOES NOT RETURN A  'NEW' REFERENCE!
@c

PyObject *
PyImport_AddModule(char *name)
{
	PyObject *modules = PyImport_GetModuleDict();
	PyObject *m;

	if ((m = PyDict_GetItemString(modules, name)) != NULL &amp;&amp;
	    PyModule_Check(m))
		return m;
	m = PyModule_New(name);
	if (m == NULL)
		return NULL;
	if (PyDict_SetItemString(modules, name, m) != 0) {
		Py_DECREF(m);
		return NULL;
	}
	Py_DECREF(m); /* Yes, it still exists, in modules! */

	return m;
}
</t>
<t tx="T922">@ Execute a code object in a module and return the module object  WITH INCREMENTED REFERENCE COUNT
@c

PyObject *
PyImport_ExecCodeModule(char *name, PyObject *co)
{
	return PyImport_ExecCodeModuleEx(name, co, (char *)NULL);
}
</t>
<t tx="T923">PyObject *
PyImport_ExecCodeModuleEx(char *name, PyObject *co, char *pathname)
{
	PyObject *modules = PyImport_GetModuleDict();
	PyObject *m, *d, *v;

	m = PyImport_AddModule(name);
	if (m == NULL)
		return NULL;
	d = PyModule_GetDict(m);
	if (PyDict_GetItemString(d, "__builtins__") == NULL) {
		if (PyDict_SetItemString(d, "__builtins__",
					 PyEval_GetBuiltins()) != 0)
			return NULL;
	}
	/* Remember the filename as the __file__ attribute */
	v = NULL;
	if (pathname != NULL) {
		v = PyString_FromString(pathname);
		if (v == NULL)
			PyErr_Clear();
	}
	if (v == NULL) {
		v = ((PyCodeObject *)co)-&gt;co_filename;
		Py_INCREF(v);
	}
	if (PyDict_SetItemString(d, "__file__", v) != 0)
		PyErr_Clear(); /* Not important enough to report */
	Py_DECREF(v);

	v = PyEval_EvalCode((PyCodeObject *)co, d, d);
	if (v == NULL)
		return NULL;
	Py_DECREF(v);

	if ((m = PyDict_GetItemString(modules, name)) == NULL) {
		PyErr_Format(PyExc_ImportError,
			     "Loaded module %.200s not found in sys.modules",
			     name);
		return NULL;
	}

	Py_INCREF(m);

	return m;
}
</t>
<t tx="T924">@ Given a pathname for a Python source file, fill a buffer with the  pathname for the corresponding compiled file. Return the pathname  for the compiled file, or NULL if there's no space in the buffer.  Doesn't set an exception.
@c

static char *
make_compiled_pathname(char *pathname, char *buf, size_t buflen)
{
	size_t len = strlen(pathname);
	if (len+2 &gt; buflen)
		return NULL;

#ifdef MS_WIN32
	/* Treat .pyw as if it were .py.  The case of ".pyw" must match
	   that used in _PyImport_StandardFiletab. */
	if (len &gt;= 4 &amp;&amp; strcmp(&amp;pathname[len-4], ".pyw") == 0)
		--len;	/* pretend 'w' isn't there */
#endif
	memcpy(buf, pathname, len);
	buf[len] = Py_OptimizeFlag ? 'o' : 'c';
	buf[len+1] = '\0';

	return buf;
}
</t>
<t tx="T925">@ Given a pathname for a Python source file, its time of last  modification, and a pathname for a compiled file, check whether the  compiled file represents the same version of the source. If so,  return a FILE pointer for the compiled file, positioned just after  the header; if not, return NULL.  Doesn't set an exception.
@c

static FILE *
check_compiled_module(char *pathname, long mtime, char *cpathname)
{
	FILE *fp;
	long magic;
	long pyc_mtime;

	fp = fopen(cpathname, "rb");
	if (fp == NULL)
		return NULL;
	magic = PyMarshal_ReadLongFromFile(fp);
	if (magic != pyc_magic) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# %s has bad magic\n", cpathname);
		fclose(fp);
		return NULL;
	}
	pyc_mtime = PyMarshal_ReadLongFromFile(fp);
	if (pyc_mtime != mtime) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# %s has bad mtime\n", cpathname);
		fclose(fp);
		return NULL;
	}
	if (Py_VerboseFlag)
		PySys_WriteStderr("# %s matches %s\n", cpathname, pathname);
	return fp;
}
</t>
<t tx="T926">@ Read a code object from a file and check it for validity
@c

static PyCodeObject *
read_compiled_module(char *cpathname, FILE *fp)
{
	PyObject *co;

	co = PyMarshal_ReadLastObjectFromFile(fp);
	/* Ugly: rd_object() may return NULL with or without error */
	if (co == NULL || !PyCode_Check(co)) {
		if (!PyErr_Occurred())
			PyErr_Format(PyExc_ImportError,
			    "Non-code object in %.200s", cpathname);
		Py_XDECREF(co);
		return NULL;
	}
	return (PyCodeObject *)co;
}
</t>
<t tx="T927">@ Load a module from a compiled file, execute it, and return its  module object WITH INCREMENTED REFERENCE COUNT
@c

static PyObject *
load_compiled_module(char *name, char *cpathname, FILE *fp)
{
	long magic;
	PyCodeObject *co;
	PyObject *m;

	magic = PyMarshal_ReadLongFromFile(fp);
	if (magic != pyc_magic) {
		PyErr_Format(PyExc_ImportError,
			     "Bad magic number in %.200s", cpathname);
		return NULL;
	}
	(void) PyMarshal_ReadLongFromFile(fp);
	co = read_compiled_module(cpathname, fp);
	if (co == NULL)
		return NULL;
	if (Py_VerboseFlag)
		PySys_WriteStderr("import %s # precompiled from %s\n",
			name, cpathname);
	m = PyImport_ExecCodeModuleEx(name, (PyObject *)co, cpathname);
	Py_DECREF(co);

	return m;
}
</t>
<t tx="T928">@ Parse a source file and return the corresponding code object
@c

static PyCodeObject *
parse_source_module(char *pathname, FILE *fp)
{
	PyCodeObject *co;
	node *n;

	n = PyParser_SimpleParseFile(fp, pathname, Py_file_input);
	if (n == NULL)
		return NULL;
	co = PyNode_Compile(n, pathname);
	PyNode_Free(n);

	return co;
}
</t>
<t tx="T929">@ Helper to open a bytecode file for writing in exclusive mode
@c

static FILE *
open_exclusive(char *filename)
{
#if defined(O_EXCL)&amp;&amp;defined(O_CREAT)&amp;&amp;defined(O_WRONLY)&amp;&amp;defined(O_TRUNC)
	/* Use O_EXCL to avoid a race condition when another process tries to
	   write the same file.  When that happens, our open() call fails,
	   which is just fine (since it's only a cache).
	   XXX If the file exists and is writable but the directory is not
	   writable, the file will never be written.  Oh well.
	*/
	int fd;
	(void) unlink(filename);
	fd = open(filename, O_EXCL|O_CREAT|O_WRONLY|O_TRUNC
#ifdef O_BINARY
				|O_BINARY   /* necessary for Windows */
#endif

			, 0666);
	if (fd &lt; 0)
		return NULL;
	return fdopen(fd, "wb");
#else
	/* Best we can do -- on Windows this can't happen anyway */
	return fopen(filename, "wb");
#endif
}
</t>
<t tx="T930">@ Write a compiled module to a file, placing the time of last  modification of its source into the header.  Errors are ignored, if a write error occurs an attempt is made to  remove the file.
@c

static void
write_compiled_module(PyCodeObject *co, char *cpathname, long mtime)
{
	FILE *fp;

	fp = open_exclusive(cpathname);
	if (fp == NULL) {
		if (Py_VerboseFlag)
			PySys_WriteStderr(
				"# can't create %s\n", cpathname);
		return;
	}
	PyMarshal_WriteLongToFile(pyc_magic, fp);
	/* First write a 0 for mtime */
	PyMarshal_WriteLongToFile(0L, fp);
	PyMarshal_WriteObjectToFile((PyObject *)co, fp);
	if (ferror(fp)) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# can't write %s\n", cpathname);
		/* Don't keep partial file */
		fclose(fp);
		(void) unlink(cpathname);
		return;
	}
	/* Now write the true mtime */
	fseek(fp, 4L, 0);
	PyMarshal_WriteLongToFile(mtime, fp);
	fflush(fp);
	fclose(fp);
	if (Py_VerboseFlag)
		PySys_WriteStderr("# wrote %s\n", cpathname);
#ifdef macintosh
	PyMac_setfiletype(cpathname, 'Pyth', 'PYC ');
#endif
}
</t>
<t tx="T931">@ Load a source module from a given file and return its module  object WITH INCREMENTED REFERENCE COUNT. If there's a matching  byte-compiled file, use that instead.
@c

static PyObject *
load_source_module(char *name, char *pathname, FILE *fp)
{
	time_t mtime;
	FILE *fpc;
	char buf[MAXPATHLEN+1];
	char *cpathname;
	PyCodeObject *co;
	PyObject *m;

	mtime = PyOS_GetLastModificationTime(pathname, fp);
	if (mtime == (time_t)(-1))
		return NULL;
#if SIZEOF_TIME_T &gt; 4
	/* Python's .pyc timestamp handling presumes that the timestamp fits
	   in 4 bytes. This will be fine until sometime in the year 2038,
	   when a 4-byte signed time_t will overflow.
	 */
	if (mtime &gt;&gt; 32) {
		PyErr_SetString(PyExc_OverflowError,
			"modification time overflows a 4 byte field");
		return NULL;
	}
#endif
	cpathname = make_compiled_pathname(pathname, buf,
					   (size_t)MAXPATHLEN + 1);
	if (cpathname != NULL &amp;&amp;
	    (fpc = check_compiled_module(pathname, mtime, cpathname))) {
		co = read_compiled_module(cpathname, fpc);
		fclose(fpc);
		if (co == NULL)
			return NULL;
		if (Py_VerboseFlag)
			PySys_WriteStderr("import %s # precompiled from %s\n",
				name, cpathname);
		pathname = cpathname;
	}
	else {
		co = parse_source_module(pathname, fp);
		if (co == NULL)
			return NULL;
		if (Py_VerboseFlag)
			PySys_WriteStderr("import %s # from %s\n",
				name, pathname);
		write_compiled_module(co, cpathname, mtime);
	}
	m = PyImport_ExecCodeModuleEx(name, (PyObject *)co, pathname);
	Py_DECREF(co);

	return m;
}
</t>
<t tx="T932">@ Forward
@c

static PyObject *load_module(char *, FILE *, char *, int);
static struct filedescr *find_module(char *, PyObject *,
				     char *, size_t, FILE **);
static struct _frozen *find_frozen(char *name);

/* Load a package and return its module object WITH INCREMENTED
   REFERENCE COUNT */

static PyObject *
load_package(char *name, char *pathname)
{
	PyObject *m, *d, *file, *path;
	int err;
	char buf[MAXPATHLEN+1];
	FILE *fp = NULL;
	struct filedescr *fdp;

	m = PyImport_AddModule(name);
	if (m == NULL)
		return NULL;
	if (Py_VerboseFlag)
		PySys_WriteStderr("import %s # directory %s\n",
			name, pathname);
	d = PyModule_GetDict(m);
	file = PyString_FromString(pathname);
	if (file == NULL)
		return NULL;
	path = Py_BuildValue("[O]", file);
	if (path == NULL) {
		Py_DECREF(file);
		return NULL;
	}
	err = PyDict_SetItemString(d, "__file__", file);
	if (err == 0)
		err = PyDict_SetItemString(d, "__path__", path);
	if (err != 0) {
		m = NULL;
		goto cleanup;
	}
	buf[0] = '\0';
	fdp = find_module("__init__", path, buf, sizeof(buf), &amp;fp);
	if (fdp == NULL) {
		if (PyErr_ExceptionMatches(PyExc_ImportError)) {
			PyErr_Clear();
		}
		else
			m = NULL;
		goto cleanup;
	}
	m = load_module(name, fp, buf, fdp-&gt;type);
	if (fp != NULL)
		fclose(fp);
  cleanup:
	Py_XDECREF(path);
	Py_XDECREF(file);
	return m;
}
</t>
<t tx="T933">@ Helper to test for built-in module
@c

static int
is_builtin(char *name)
{
	int i;
	for (i = 0; PyImport_Inittab[i].name != NULL; i++) {
		if (strcmp(name, PyImport_Inittab[i].name) == 0) {
			if (PyImport_Inittab[i].initfunc == NULL)
				return -1;
			else
				return 1;
		}
	}
	return 0;
}
</t>
<t tx="T934">/* Python interpreter top-level routines, including init/exit */

&lt;&lt; pythonrun #includes &gt;&gt;
&lt;&lt; pythonrun declarations &gt;&gt;
@others
</t>
<t tx="T935">#include "Python.h"

#include "grammar.h"
#include "node.h"
#include "token.h"
#include "parsetok.h"
#include "errcode.h"
#include "compile.h"
#include "symtable.h"
#include "eval.h"
#include "marshal.h"
</t>
<t tx="T936">
#ifdef HAVE_UNISTD_H
#include &lt;unistd.h&gt;
#endif

#ifdef HAVE_SIGNAL_H
#include &lt;signal.h&gt;
#endif

#ifdef MS_WIN32
#undef BYTE
#include "windows.h"
#endif

#ifdef macintosh
#include "macglue.h"
#endif
extern char *Py_GetPath(void);

extern grammar _PyParser_Grammar; /* From graminit.c */

/* Forward */
static void initmain(void);
static void initsite(void);
static PyObject *run_err_node(node *, char *, PyObject *, PyObject *,
			      PyCompilerFlags *);
static PyObject *run_node(node *, char *, PyObject *, PyObject *,
			  PyCompilerFlags *);
static PyObject *run_pyc_file(FILE *, char *, PyObject *, PyObject *,
			      PyCompilerFlags *);
static void err_input(perrdetail *);
static void initsigs(void);
static void call_sys_exitfunc(void);
static void call_ll_exitfuncs(void);

#ifdef Py_TRACE_REFS
int _Py_AskYesNo(char *prompt);
#endif

extern void _PyUnicode_Init(void);
extern void _PyUnicode_Fini(void);
extern void _PyCodecRegistry_Init(void);
extern void _PyCodecRegistry_Fini(void);

int Py_DebugFlag; /* Needed by parser.c */
int Py_VerboseFlag; /* Needed by import.c */
int Py_InteractiveFlag; /* Needed by Py_FdIsInteractive() below */
int Py_NoSiteFlag; /* Suppress 'import site' */
int Py_UseClassExceptionsFlag = 1; /* Needed by bltinmodule.c: deprecated */
int Py_FrozenFlag; /* Needed by getpath.c */
int Py_UnicodeFlag = 0; /* Needed by compile.c */
int Py_IgnoreEnvironmentFlag; /* e.g. PYTHONPATH, PYTHONHOME */
/* _XXX Py_QnewFlag should go away in 2.3.  It's true iff -Qnew is passed,
  on the command line, and is used in 2.2 by ceval.c to make all "/" divisions
  true divisions (which they will be in 2.3). */
int _Py_QnewFlag = 0;

static int initialized = 0;
</t>
<t tx="T937"></t>
<t tx="T938">@ API to access the initialized flag -- useful for esoteric use */
@c

int
Py_IsInitialized(void)
{
	return initialized;
}
</t>
<t tx="T939">@ Global initializations. Can be undone by Py_Finalize(). Don't call this twice without an intervening Py_Finalize() call. When initializations fail, a fatal error is issued and the function does not return. On return, the first thread and interpreter state have been created. Locking: you must hold the interpreter lock while calling this. (If the lock has not yet been initialized, that's equivalent to having the lock, but you cannot use multiple threads.) */
@c

static int
add_flag(int flag, const char *envs)
{
	int env = atoi(envs);
	if (flag &lt; env)
		flag = env;
	if (flag &lt; 1)
		flag = 1;
	return flag;
}
</t>
<t tx="T940">void
Py_Initialize(void)
{
	PyInterpreterState *interp;
	PyThreadState *tstate;
	PyObject *bimod, *sysmod;
	char *p;
	extern void _Py_ReadyTypes(void);

	if (initialized)
		return;
	initialized = 1;
	
	if ((p = Py_GETENV("PYTHONDEBUG")) &amp;&amp; *p != '\0')
		Py_DebugFlag = add_flag(Py_DebugFlag, p);
	if ((p = Py_GETENV("PYTHONVERBOSE")) &amp;&amp; *p != '\0')
		Py_VerboseFlag = add_flag(Py_VerboseFlag, p);
	if ((p = Py_GETENV("PYTHONOPTIMIZE")) &amp;&amp; *p != '\0')
		Py_OptimizeFlag = add_flag(Py_OptimizeFlag, p);

	interp = PyInterpreterState_New();
	if (interp == NULL)
		Py_FatalError("Py_Initialize: can't make first interpreter");

	tstate = PyThreadState_New(interp);
	if (tstate == NULL)
		Py_FatalError("Py_Initialize: can't make first thread");
	(void) PyThreadState_Swap(tstate);

	_Py_ReadyTypes();

	interp-&gt;modules = PyDict_New();
	if (interp-&gt;modules == NULL)
		Py_FatalError("Py_Initialize: can't make modules dictionary");

	/* Init codec registry */
	_PyCodecRegistry_Init();

#ifdef Py_USING_UNICODE
	/* Init Unicode implementation; relies on the codec registry */
	_PyUnicode_Init();
#endif

	bimod = _PyBuiltin_Init();
	if (bimod == NULL)
		Py_FatalError("Py_Initialize: can't initialize __builtin__");
	interp-&gt;builtins = PyModule_GetDict(bimod);
	Py_INCREF(interp-&gt;builtins);

	sysmod = _PySys_Init();
	if (sysmod == NULL)
		Py_FatalError("Py_Initialize: can't initialize sys");
	interp-&gt;sysdict = PyModule_GetDict(sysmod);
	Py_INCREF(interp-&gt;sysdict);
	_PyImport_FixupExtension("sys", "sys");
	PySys_SetPath(Py_GetPath());
	PyDict_SetItemString(interp-&gt;sysdict, "modules",
			     interp-&gt;modules);

	_PyImport_Init();

	/* initialize builtin exceptions */
	_PyExc_Init();
	_PyImport_FixupExtension("exceptions", "exceptions");

	/* phase 2 of builtins */
	_PyImport_FixupExtension("__builtin__", "__builtin__");

	initsigs(); /* Signal handling stuff, including initintr() */

	initmain(); /* Module __main__ */
	if (!Py_NoSiteFlag)
		initsite(); /* Module site */
}
</t>
<t tx="T941">#ifdef COUNT_ALLOCS
extern void dump_counts(void);
#endif

/* Undo the effect of Py_Initialize().

   Beware: if multiple interpreter and/or thread states exist, these
   are not wiped out; only the current thread and interpreter state
   are deleted.  But since everything else is deleted, those other
   interpreter and thread states should no longer be used.

   (XXX We should do better, e.g. wipe out all interpreters and
   threads.)

   Locking: as above.

*/

void
Py_Finalize(void)
{
	PyInterpreterState *interp;
	PyThreadState *tstate;

	if (!initialized)
		return;

	/* The interpreter is still entirely intact at this point, and the
	 * exit funcs may be relying on that.  In particular, if some thread
	 * or exit func is still waiting to do an import, the import machinery
	 * expects Py_IsInitialized() to return true.  So don't say the
	 * interpreter is uninitialized until after the exit funcs have run.
	 * Note that Threading.py uses an exit func to do a join on all the
	 * threads created thru it, so this also protects pending imports in
	 * the threads created via Threading.
	 */
	call_sys_exitfunc();
	initialized = 0;

	/* Get current thread state and interpreter pointer */
	tstate = PyThreadState_Get();
	interp = tstate-&gt;interp;

	/* Disable signal handling */
	PyOS_FiniInterrupts();

#ifdef Py_USING_UNICODE
	/* Cleanup Unicode implementation */
	_PyUnicode_Fini();
#endif

	/* Cleanup Codec registry */
	_PyCodecRegistry_Fini();

	/* Destroy all modules */
	PyImport_Cleanup();

	/* Destroy the database used by _PyImport_{Fixup,Find}Extension */
	_PyImport_Fini();

	/* Debugging stuff */
#ifdef COUNT_ALLOCS
	dump_counts();
#endif

#ifdef Py_REF_DEBUG
	fprintf(stderr, "[%ld refs]\n", _Py_RefTotal);
#endif

#ifdef Py_TRACE_REFS
	if (Py_GETENV("PYTHONDUMPREFS")) {
		_Py_PrintReferences(stderr);
	}
#endif /* Py_TRACE_REFS */

	/* Now we decref the exception classes.  After this point nothing
	   can raise an exception.  That's okay, because each Fini() method
	   below has been checked to make sure no exceptions are ever
	   raised.
	*/
	_PyExc_Fini();

	/* Delete current thread */
	PyInterpreterState_Clear(interp);
	PyThreadState_Swap(NULL);
	PyInterpreterState_Delete(interp);

	PyMethod_Fini();
	PyFrame_Fini();
	PyCFunction_Fini();
	PyTuple_Fini();
	PyString_Fini();
	PyInt_Fini();
	PyFloat_Fini();

	/* XXX Still allocated:
	   - various static ad-hoc pointers to interned strings
	   - int and float free list blocks
	   - whatever various modules and libraries allocate
	*/

	PyGrammar_RemoveAccelerators(&amp;_PyParser_Grammar);

	call_ll_exitfuncs();

#ifdef Py_TRACE_REFS
	_Py_ResetReferences();
#endif /* Py_TRACE_REFS */
}
</t>
<t tx="T942">@ Create and initialize a new interpreter and thread, and return the new thread. This requires that Py_Initialize() has been called first. Unsuccessful initialization yields a NULL pointer. Note that *no* exception information is available even in this case -- the exception information is held in the thread, and there is no thread. Locking: as above. */
@c

PyThreadState *
Py_NewInterpreter(void)
{
	PyInterpreterState *interp;
	PyThreadState *tstate, *save_tstate;
	PyObject *bimod, *sysmod;

	if (!initialized)
		Py_FatalError("Py_NewInterpreter: call Py_Initialize first");

	interp = PyInterpreterState_New();
	if (interp == NULL)
		return NULL;

	tstate = PyThreadState_New(interp);
	if (tstate == NULL) {
		PyInterpreterState_Delete(interp);
		return NULL;
	}

	save_tstate = PyThreadState_Swap(tstate);

	/* XXX The following is lax in error checking */

	interp-&gt;modules = PyDict_New();

	bimod = _PyImport_FindExtension("__builtin__", "__builtin__");
	if (bimod != NULL) {
		interp-&gt;builtins = PyModule_GetDict(bimod);
		Py_INCREF(interp-&gt;builtins);
	}
	sysmod = _PyImport_FindExtension("sys", "sys");
	if (bimod != NULL &amp;&amp; sysmod != NULL) {
		interp-&gt;sysdict = PyModule_GetDict(sysmod);
		Py_INCREF(interp-&gt;sysdict);
		PySys_SetPath(Py_GetPath());
		PyDict_SetItemString(interp-&gt;sysdict, "modules",
				     interp-&gt;modules);
		initmain();
		if (!Py_NoSiteFlag)
			initsite();
	}

	if (!PyErr_Occurred())
		return tstate;

	/* Oops, it didn't work.  Undo it all. */

	PyErr_Print();
	PyThreadState_Clear(tstate);
	PyThreadState_Swap(save_tstate);
	PyThreadState_Delete(tstate);
	PyInterpreterState_Delete(interp);

	return NULL;
}
</t>
<t tx="T943">@ Delete an interpreter and its last thread. This requires that the given thread state is current, that the thread has no remaining frames, and that it is its interpreter's only remaining thread. It is a fatal error to violate these constraints. (Py_Finalize() doesn't have these constraints -- it zaps everything, regardless.) Locking: as above. */
@c

void
Py_EndInterpreter(PyThreadState *tstate)
{
	PyInterpreterState *interp = tstate-&gt;interp;

	if (tstate != PyThreadState_Get())
		Py_FatalError("Py_EndInterpreter: thread is not current");
	if (tstate-&gt;frame != NULL)
		Py_FatalError("Py_EndInterpreter: thread still has a frame");
	if (tstate != interp-&gt;tstate_head || tstate-&gt;next != NULL)
		Py_FatalError("Py_EndInterpreter: not the last thread");

	PyImport_Cleanup();
	PyInterpreterState_Clear(interp);
	PyThreadState_Swap(NULL);
	PyInterpreterState_Delete(interp);
}
</t>
<t tx="T944">static char *progname = "python";

void
Py_SetProgramName(char *pn)
{
	if (pn &amp;&amp; *pn)
		progname = pn;
}
</t>
<t tx="T945">char *
Py_GetProgramName(void)
{
	return progname;
}
</t>
<t tx="T946">static char *default_home = NULL;

void
Py_SetPythonHome(char *home)
{
	default_home = home;
}
</t>
<t tx="T947">char *
Py_GetPythonHome(void)
{
	char *home = default_home;
	if (home == NULL &amp;&amp; !Py_IgnoreEnvironmentFlag)
		home = Py_GETENV("PYTHONHOME");
	return home;
}
</t>
<t tx="T948">@ Create __main__ module */
@c

static void
initmain(void)
{
	PyObject *m, *d;
	m = PyImport_AddModule("__main__");
	if (m == NULL)
		Py_FatalError("can't create __main__ module");
	d = PyModule_GetDict(m);
	if (PyDict_GetItemString(d, "__builtins__") == NULL) {
		PyObject *bimod = PyImport_ImportModule("__builtin__");
		if (bimod == NULL ||
		    PyDict_SetItemString(d, "__builtins__", bimod) != 0)
			Py_FatalError("can't add __builtins__ to __main__");
		Py_DECREF(bimod);
	}
}
</t>
<t tx="T949">@ Import the site module (not into __main__ though) */
@c

static void
initsite(void)
{
	PyObject *m, *f;
	m = PyImport_ImportModule("site");
	if (m == NULL) {
		f = PySys_GetObject("stderr");
		if (Py_VerboseFlag) {
			PyFile_WriteString(
				"'import site' failed; traceback:\n", f);
			PyErr_Print();
		}
		else {
			PyFile_WriteString(
			  "'import site' failed; use -v for traceback\n", f);
			PyErr_Clear();
		}
	}
	else {
		Py_DECREF(m);
	}
}
</t>
<t tx="T950"></t>
<t tx="T951">@ Parse input from a file and execute it */
@c

int
PyRun_AnyFile(FILE *fp, char *filename)
{
	return PyRun_AnyFileExFlags(fp, filename, 0, NULL);
}
</t>
<t tx="T952">int
PyRun_AnyFileFlags(FILE *fp, char *filename, PyCompilerFlags *flags)
{
	return PyRun_AnyFileExFlags(fp, filename, 0, flags);
}
</t>
<t tx="T953">int
PyRun_AnyFileEx(FILE *fp, char *filename, int closeit)
{
	return PyRun_AnyFileExFlags(fp, filename, closeit, NULL);
}
</t>
<t tx="T954">int
PyRun_AnyFileExFlags(FILE *fp, char *filename, int closeit, 
		     PyCompilerFlags *flags)
{
	if (filename == NULL)
		filename = "???";
	if (Py_FdIsInteractive(fp, filename)) {
		int err = PyRun_InteractiveLoopFlags(fp, filename, flags);
		if (closeit)
			fclose(fp);
		return err;
	}
	else
		return PyRun_SimpleFileExFlags(fp, filename, closeit, flags);
}
</t>
<t tx="T955">int
PyRun_InteractiveLoop(FILE *fp, char *filename)
{
	return PyRun_InteractiveLoopFlags(fp, filename, NULL);
}
</t>
<t tx="T956">int
PyRun_InteractiveLoopFlags(FILE *fp, char *filename, PyCompilerFlags *flags)
{
	PyObject *v;
	int ret;
	PyCompilerFlags local_flags;

	if (flags == NULL) {
		flags = &amp;local_flags;
		local_flags.cf_flags = 0;
	}
	v = PySys_GetObject("ps1");
	if (v == NULL) {
		PySys_SetObject("ps1", v = PyString_FromString("&gt;&gt;&gt; "));
		Py_XDECREF(v);
	}
	v = PySys_GetObject("ps2");
	if (v == NULL) {
		PySys_SetObject("ps2", v = PyString_FromString("... "));
		Py_XDECREF(v);
	}
	for (;;) {
		ret = PyRun_InteractiveOneFlags(fp, filename, flags);
#ifdef Py_REF_DEBUG
		fprintf(stderr, "[%ld refs]\n", _Py_RefTotal);
#endif
		if (ret == E_EOF)
			return 0;
		/*
		if (ret == E_NOMEM)
			return -1;
		*/
	}
}
</t>
<t tx="T957">int
PyRun_InteractiveOne(FILE *fp, char *filename)
{
	return PyRun_InteractiveOneFlags(fp, filename, NULL);
}
</t>
<t tx="T958">int
PyRun_InteractiveOneFlags(FILE *fp, char *filename, PyCompilerFlags *flags)
{
	PyObject *m, *d, *v, *w;
	node *n;
	perrdetail err;
	char *ps1 = "", *ps2 = "";

	v = PySys_GetObject("ps1");
	if (v != NULL) {
		v = PyObject_Str(v);
		if (v == NULL)
			PyErr_Clear();
		else if (PyString_Check(v))
			ps1 = PyString_AsString(v);
	}
	w = PySys_GetObject("ps2");
	if (w != NULL) {
		w = PyObject_Str(w);
		if (w == NULL)
			PyErr_Clear();
		else if (PyString_Check(w))
			ps2 = PyString_AsString(w);
	}
	n = PyParser_ParseFileFlags(fp, filename, &amp;_PyParser_Grammar,
			    	    Py_single_input, ps1, ps2, &amp;err,
			    	    (flags &amp;&amp;
			    	     flags-&gt;cf_flags &amp; CO_GENERATOR_ALLOWED) ?
			    	    	PyPARSE_YIELD_IS_KEYWORD : 0);
	Py_XDECREF(v);
	Py_XDECREF(w);
	if (n == NULL) {
		if (err.error == E_EOF) {
			if (err.text)
				PyMem_DEL(err.text);
			return E_EOF;
		}
		err_input(&amp;err);
		PyErr_Print();
		return err.error;
	}
	m = PyImport_AddModule("__main__");
	if (m == NULL)
		return -1;
	d = PyModule_GetDict(m);
	v = run_node(n, filename, d, d, flags);
	if (v == NULL) {
		PyErr_Print();
		return -1;
	}
	Py_DECREF(v);
	if (Py_FlushLine())
		PyErr_Clear();
	return 0;
}
</t>
<t tx="T959">int
PyRun_SimpleFile(FILE *fp, char *filename)
{
	return PyRun_SimpleFileEx(fp, filename, 0);
}
</t>
<t tx="T960">@ Check whether a file maybe a pyc file: Look at the extension, the file type, and, if we may close it, at the first few bytes. */
@c

static int
maybe_pyc_file(FILE *fp, char* filename, char* ext, int closeit)
{
	if (strcmp(ext, ".pyc") == 0 || strcmp(ext, ".pyo") == 0)
		return 1;

#ifdef macintosh
	/* On a mac, we also assume a pyc file for types 'PYC ' and 'APPL' */
	if (PyMac_getfiletype(filename) == 'PYC '
	    || PyMac_getfiletype(filename) == 'APPL')
		return 1;
#endif /* macintosh */

	/* Only look into the file if we are allowed to close it, since
	   it then should also be seekable. */
	if (closeit) {
		/* Read only two bytes of the magic. If the file was opened in
		   text mode, the bytes 3 and 4 of the magic (\r\n) might not
		   be read as they are on disk. */
		unsigned int halfmagic = PyImport_GetMagicNumber() &amp; 0xFFFF;
		unsigned char buf[2];
		/* Mess:  In case of -x, the stream is NOT at its start now,
		   and ungetc() was used to push back the first newline,
		   which makes the current stream position formally undefined,
		   and a x-platform nightmare.
		   Unfortunately, we have no direct way to know whether -x
		   was specified.  So we use a terrible hack:  if the current
		   stream position is not 0, we assume -x was specified, and
		   give up.  Bug 132850 on SourceForge spells out the
		   hopelessness of trying anything else (fseek and ftell
		   don't work predictably x-platform for text-mode files).
		*/
		int ispyc = 0;
		if (ftell(fp) == 0) {
			if (fread(buf, 1, 2, fp) == 2 &amp;&amp;
			    ((unsigned int)buf[1]&lt;&lt;8 | buf[0]) == halfmagic) 
				ispyc = 1;
			rewind(fp);
		}
		return ispyc;
	}
	return 0;
}</t>
<t tx="T961">int
PyRun_SimpleFileEx(FILE *fp, char *filename, int closeit)
{
	return PyRun_SimpleFileExFlags(fp, filename, closeit, NULL);
}
</t>
<t tx="T962">int
PyRun_SimpleFileExFlags(FILE *fp, char *filename, int closeit,
			PyCompilerFlags *flags)
{
	PyObject *m, *d, *v;
	char *ext;

	m = PyImport_AddModule("__main__");
	if (m == NULL)
		return -1;
	d = PyModule_GetDict(m);
	ext = filename + strlen(filename) - 4;
	if (maybe_pyc_file(fp, filename, ext, closeit)) {
		/* Try to run a pyc file. First, re-open in binary */
		if (closeit)
			fclose(fp);
		if( (fp = fopen(filename, "rb")) == NULL ) {
			fprintf(stderr, "python: Can't reopen .pyc file\n");
			return -1;
		}
		/* Turn on optimization if a .pyo file is given */
		if (strcmp(ext, ".pyo") == 0)
			Py_OptimizeFlag = 1;
		v = run_pyc_file(fp, filename, d, d, flags);
	} else {
		v = PyRun_FileExFlags(fp, filename, Py_file_input, d, d, 
				      closeit, flags);
	}
	if (v == NULL) {
		PyErr_Print();
		return -1;
	}
	Py_DECREF(v);
	if (Py_FlushLine())
		PyErr_Clear();
	return 0;
}
</t>
<t tx="T963">int
PyRun_SimpleString(char *command)
{
	return PyRun_SimpleStringFlags(command, NULL);
}
</t>
<t tx="T964">int
PyRun_SimpleStringFlags(char *command, PyCompilerFlags *flags)
{
	PyObject *m, *d, *v;
	m = PyImport_AddModule("__main__");
	if (m == NULL)
		return -1;
	d = PyModule_GetDict(m);
	v = PyRun_StringFlags(command, Py_file_input, d, d, flags);
	if (v == NULL) {
		PyErr_Print();
		return -1;
	}
	Py_DECREF(v);
	if (Py_FlushLine())
		PyErr_Clear();
	return 0;
}
</t>
<t tx="T965"></t>
<t tx="T966">static int
parse_syntax_error(PyObject *err, PyObject **message, char **filename,
		   int *lineno, int *offset, char **text)
{
	long hold;
	PyObject *v;

	/* old style errors */
	if (PyTuple_Check(err))
		return PyArg_Parse(err, "(O(ziiz))", message, filename,
				   lineno, offset, text);

	/* new style errors.  `err' is an instance */

	if (! (v = PyObject_GetAttrString(err, "msg")))
		goto finally;
	*message = v;

	if (!(v = PyObject_GetAttrString(err, "filename")))
		goto finally;
	if (v == Py_None)
		*filename = NULL;
	else if (! (*filename = PyString_AsString(v)))
		goto finally;

	Py_DECREF(v);
	if (!(v = PyObject_GetAttrString(err, "lineno")))
		goto finally;
	hold = PyInt_AsLong(v);
	Py_DECREF(v);
	v = NULL;
	if (hold &lt; 0 &amp;&amp; PyErr_Occurred())
		goto finally;
	*lineno = (int)hold;

	if (!(v = PyObject_GetAttrString(err, "offset")))
		goto finally;
	if (v == Py_None) {
		*offset = -1;
		Py_DECREF(v);
		v = NULL;
	} else {
		hold = PyInt_AsLong(v);
		Py_DECREF(v);
		v = NULL;
		if (hold &lt; 0 &amp;&amp; PyErr_Occurred())
			goto finally;
		*offset = (int)hold;
	}

	if (!(v = PyObject_GetAttrString(err, "text")))
		goto finally;
	if (v == Py_None)
		*text = NULL;
	else if (! (*text = PyString_AsString(v)))
		goto finally;
	Py_DECREF(v);
	return 1;

finally:
	Py_XDECREF(v);
	return 0;
}
</t>
<t tx="T967">void
PyErr_Print(void)
{
	PyErr_PrintEx(1);
}
</t>
<t tx="T968">static void
print_error_text(PyObject *f, int offset, char *text)
{
	char *nl;
	if (offset &gt;= 0) {
		if (offset &gt; 0 &amp;&amp; offset == (int)strlen(text))
			offset--;
		for (;;) {
			nl = strchr(text, '\n');
			if (nl == NULL || nl-text &gt;= offset)
				break;
			offset -= (nl+1-text);
			text = nl+1;
		}
		while (*text == ' ' || *text == '\t') {
			text++;
			offset--;
		}
	}
	PyFile_WriteString("    ", f);
	PyFile_WriteString(text, f);
	if (*text == '\0' || text[strlen(text)-1] != '\n')
		PyFile_WriteString("\n", f);
	if (offset == -1)
		return;
	PyFile_WriteString("    ", f);
	offset--;
	while (offset &gt; 0) {
		PyFile_WriteString(" ", f);
		offset--;
	}
	PyFile_WriteString("^\n", f);
}
</t>
<t tx="T969">static void
handle_system_exit(void)
{
        PyObject *exception, *value, *tb;
	PyErr_Fetch(&amp;exception, &amp;value, &amp;tb);
	if (Py_FlushLine())
		PyErr_Clear();
	fflush(stdout);
	if (value == NULL || value == Py_None)
		Py_Exit(0);
	if (PyInstance_Check(value)) {
		/* The error code should be in the `code' attribute. */
		PyObject *code = PyObject_GetAttrString(value, "code");
		if (code) {
			Py_DECREF(value);
			value = code;
			if (value == Py_None)
				Py_Exit(0);
		}
		/* If we failed to dig out the 'code' attribute,
		   just let the else clause below print the error. */
	}
	if (PyInt_Check(value))
		Py_Exit((int)PyInt_AsLong(value));
	else {
		PyObject_Print(value, stderr, Py_PRINT_RAW);
		PySys_WriteStderr("\n");
		Py_Exit(1);
	}
}
</t>
<t tx="T970">void
PyErr_PrintEx(int set_sys_last_vars)
{
	PyObject *exception, *v, *tb, *hook;

	if (PyErr_ExceptionMatches(PyExc_SystemExit)) {
		handle_system_exit();
	}
	PyErr_Fetch(&amp;exception, &amp;v, &amp;tb);
	PyErr_NormalizeException(&amp;exception, &amp;v, &amp;tb);
	if (exception == NULL)
		return;
	if (set_sys_last_vars) {
		PySys_SetObject("last_type", exception);
		PySys_SetObject("last_value", v);
		PySys_SetObject("last_traceback", tb);
	}
	hook = PySys_GetObject("excepthook");
	if (hook) {
		PyObject *args = Py_BuildValue("(OOO)",
                    exception, v ? v : Py_None, tb ? tb : Py_None);
		PyObject *result = PyEval_CallObject(hook, args);
		if (result == NULL) {
			PyObject *exception2, *v2, *tb2;
			if (PyErr_ExceptionMatches(PyExc_SystemExit)) {
				handle_system_exit();
			}
			PyErr_Fetch(&amp;exception2, &amp;v2, &amp;tb2);
			PyErr_NormalizeException(&amp;exception2, &amp;v2, &amp;tb2);
			if (Py_FlushLine())
				PyErr_Clear();
			fflush(stdout);
			PySys_WriteStderr("Error in sys.excepthook:\n");
			PyErr_Display(exception2, v2, tb2);
			PySys_WriteStderr("\nOriginal exception was:\n");
			PyErr_Display(exception, v, tb);
			Py_XDECREF(exception2);
			Py_XDECREF(v2);
			Py_XDECREF(tb2);
		}
		Py_XDECREF(result);
		Py_XDECREF(args);
	} else {
		PySys_WriteStderr("sys.excepthook is missing\n");
		PyErr_Display(exception, v, tb);
	}
	Py_XDECREF(exception);
	Py_XDECREF(v);
	Py_XDECREF(tb);
}
</t>
<t tx="T971">void PyErr_Display(PyObject *exception, PyObject *value, PyObject *tb)
{
	int err = 0;
	PyObject *v = value;
	PyObject *f = PySys_GetObject("stderr");
	if (f == NULL)
		fprintf(stderr, "lost sys.stderr\n");
	else {
		if (Py_FlushLine())
			PyErr_Clear();
		fflush(stdout);
		if (tb &amp;&amp; tb != Py_None)
			err = PyTraceBack_Print(tb, f);
		if (err == 0 &amp;&amp;
		    PyErr_GivenExceptionMatches(exception, PyExc_SyntaxError))
		{
			PyObject *message;
			char *filename, *text;
			int lineno, offset;
			if (!parse_syntax_error(v, &amp;message, &amp;filename,
						&amp;lineno, &amp;offset, &amp;text))
				PyErr_Clear();
			else {
				char buf[10];
				PyFile_WriteString("  File \"", f);
				if (filename == NULL)
					PyFile_WriteString("&lt;string&gt;", f);
				else
					PyFile_WriteString(filename, f);
				PyFile_WriteString("\", line ", f);
				PyOS_snprintf(buf, sizeof(buf), "%d", lineno);
				PyFile_WriteString(buf, f);
				PyFile_WriteString("\n", f);
				if (text != NULL)
					print_error_text(f, offset, text);
				v = message;
				/* Can't be bothered to check all those
				   PyFile_WriteString() calls */
				if (PyErr_Occurred())
					err = -1;
			}
		}
		if (err) {
			/* Don't do anything else */
		}
		else if (PyClass_Check(exception)) {
			PyClassObject* exc = (PyClassObject*)exception;
			PyObject* className = exc-&gt;cl_name;
			PyObject* moduleName =
			      PyDict_GetItemString(exc-&gt;cl_dict, "__module__");

			if (moduleName == NULL)
				err = PyFile_WriteString("&lt;unknown&gt;", f);
			else {
				char* modstr = PyString_AsString(moduleName);
				if (modstr &amp;&amp; strcmp(modstr, "exceptions")) 
				{
					err = PyFile_WriteString(modstr, f);
					err += PyFile_WriteString(".", f);
				}
			}
			if (err == 0) {
				if (className == NULL)
				      err = PyFile_WriteString("&lt;unknown&gt;", f);
				else
				      err = PyFile_WriteObject(className, f,
							       Py_PRINT_RAW);
			}
		}
		else
			err = PyFile_WriteObject(exception, f, Py_PRINT_RAW);
		if (err == 0) {
			if (v != NULL &amp;&amp; v != Py_None) {
				PyObject *s = PyObject_Str(v);
				/* only print colon if the str() of the
				   object is not the empty string
				*/
				if (s == NULL)
					err = -1;
				else if (!PyString_Check(s) ||
					 PyString_GET_SIZE(s) != 0)
					err = PyFile_WriteString(": ", f);
				if (err == 0)
				  err = PyFile_WriteObject(s, f, Py_PRINT_RAW);
				Py_XDECREF(s);
			}
		}
		if (err == 0)
			err = PyFile_WriteString("\n", f);
	}
	/* If an error happened here, don't show it.
	   XXX This is wrong, but too many callers rely on this behavior. */
	if (err != 0)
		PyErr_Clear();
}
</t>
<t tx="T972">PyObject *
PyRun_String(char *str, int start, PyObject *globals, PyObject *locals)
{
	return run_err_node(PyParser_SimpleParseString(str, start),
			    "&lt;string&gt;", globals, locals, NULL);
}
</t>
<t tx="T973">PyObject *
PyRun_File(FILE *fp, char *filename, int start, PyObject *globals,
	   PyObject *locals)
{
	return PyRun_FileEx(fp, filename, start, globals, locals, 0);
}
</t>
<t tx="T974">PyObject *
PyRun_FileEx(FILE *fp, char *filename, int start, PyObject *globals,
	     PyObject *locals, int closeit)
{
	node *n = PyParser_SimpleParseFile(fp, filename, start);
	if (closeit)
		fclose(fp);
	return run_err_node(n, filename, globals, locals, NULL);
}
</t>
<t tx="T975">PyObject *
PyRun_StringFlags(char *str, int start, PyObject *globals, PyObject *locals,
		  PyCompilerFlags *flags)
{
	return run_err_node(PyParser_SimpleParseStringFlags(
			str, start,
			(flags &amp;&amp; flags-&gt;cf_flags &amp; CO_GENERATOR_ALLOWED) ?
				PyPARSE_YIELD_IS_KEYWORD : 0),
			    "&lt;string&gt;", globals, locals, flags);
}
</t>
<t tx="T976">PyObject *
PyRun_FileFlags(FILE *fp, char *filename, int start, PyObject *globals,
		PyObject *locals, PyCompilerFlags *flags)
{
	return PyRun_FileExFlags(fp, filename, start, globals, locals, 0,
				 flags); 
}
</t>
<t tx="T977">PyObject *
PyRun_FileExFlags(FILE *fp, char *filename, int start, PyObject *globals,
		  PyObject *locals, int closeit, PyCompilerFlags *flags)
{
	node *n = PyParser_SimpleParseFileFlags(fp, filename, start,
			(flags &amp;&amp; flags-&gt;cf_flags &amp; CO_GENERATOR_ALLOWED) ?
				PyPARSE_YIELD_IS_KEYWORD : 0);
	if (closeit)
		fclose(fp);
	return run_err_node(n, filename, globals, locals, flags);
}
</t>
<t tx="T978">static PyObject *
run_err_node(node *n, char *filename, PyObject *globals, PyObject *locals,
	     PyCompilerFlags *flags)
{
	if (n == NULL)
		return  NULL;
	return run_node(n, filename, globals, locals, flags);
}
</t>
<t tx="T979">static PyObject *
run_node(node *n, char *filename, PyObject *globals, PyObject *locals,
	 PyCompilerFlags *flags)
{
	PyCodeObject *co;
	PyObject *v;
	co = PyNode_CompileFlags(n, filename, flags);
	PyNode_Free(n);
	if (co == NULL)
		return NULL;
	v = PyEval_EvalCode(co, globals, locals);
	Py_DECREF(co);
	return v;
}
</t>
<t tx="T980">static PyObject *
run_pyc_file(FILE *fp, char *filename, PyObject *globals, PyObject *locals,
	     PyCompilerFlags *flags)
{
	PyCodeObject *co;
	PyObject *v;
	long magic;
	long PyImport_GetMagicNumber(void);

	magic = PyMarshal_ReadLongFromFile(fp);
	if (magic != PyImport_GetMagicNumber()) {
		PyErr_SetString(PyExc_RuntimeError,
			   "Bad magic number in .pyc file");
		return NULL;
	}
	(void) PyMarshal_ReadLongFromFile(fp);
	v = PyMarshal_ReadLastObjectFromFile(fp);
	fclose(fp);
	if (v == NULL || !PyCode_Check(v)) {
		Py_XDECREF(v);
		PyErr_SetString(PyExc_RuntimeError,
			   "Bad code object in .pyc file");
		return NULL;
	}
	co = (PyCodeObject *)v;
	v = PyEval_EvalCode(co, globals, locals);
	if (v &amp;&amp; flags)
		flags-&gt;cf_flags |= (co-&gt;co_flags &amp; PyCF_MASK);
	Py_DECREF(co);
	return v;
}
</t>
<t tx="T981"></t>
<t tx="T982">PyObject *
Py_CompileString(char *str, char *filename, int start)
{
	return Py_CompileStringFlags(str, filename, start, NULL);
}
</t>
<t tx="T983">PyObject *
Py_CompileStringFlags(char *str, char *filename, int start, 
		      PyCompilerFlags *flags)
{
	node *n;
	PyCodeObject *co;
	n = PyParser_SimpleParseStringFlags(str, start,
		(flags &amp;&amp; flags-&gt;cf_flags &amp; CO_GENERATOR_ALLOWED) ?
			PyPARSE_YIELD_IS_KEYWORD : 0);
	if (n == NULL)
		return NULL;
	co = PyNode_CompileFlags(n, filename, flags);
	PyNode_Free(n);
	return (PyObject *)co;
}
</t>
<t tx="T984">struct symtable *
Py_SymtableString(char *str, char *filename, int start)
{
	node *n;
	struct symtable *st;
	n = PyParser_SimpleParseString(str, start);
	if (n == NULL)
		return NULL;
	st = PyNode_CompileSymtable(n, filename);
	PyNode_Free(n);
	return st;
}
</t>
<t tx="T985">@ Simplified interface to parsefile -- return node or set exception */
@c

node *
PyParser_SimpleParseFileFlags(FILE *fp, char *filename, int start, int flags)
{
	node *n;
	perrdetail err;
	n = PyParser_ParseFileFlags(fp, filename, &amp;_PyParser_Grammar, start,
					(char *)0, (char *)0, &amp;err, flags);
	if (n == NULL)
		err_input(&amp;err);
	return n;
}
</t>
<t tx="T986">node *
PyParser_SimpleParseFile(FILE *fp, char *filename, int start)
{
	return PyParser_SimpleParseFileFlags(fp, filename, start, 0);
}
</t>
<t tx="T987">@ Simplified interface to parsestring -- return node or set exception */
@c

node *
PyParser_SimpleParseStringFlags(char *str, int start, int flags)
{
	node *n;
	perrdetail err;
	n = PyParser_ParseStringFlags(str, &amp;_PyParser_Grammar, start, &amp;err,
				      flags);
	if (n == NULL)
		err_input(&amp;err);
	return n;
}
</t>
<t tx="T988">node *
PyParser_SimpleParseString(char *str, int start)
{
	return PyParser_SimpleParseStringFlags(str, start, 0);
}
</t>
<t tx="T989"></t>
<t tx="T990">@ Set the error appropriate to the given input error code (see errcode.h) */
@c

static void
err_input(perrdetail *err)
{
	PyObject *v, *w, *errtype;
	char *msg = NULL;
	errtype = PyExc_SyntaxError;
	v = Py_BuildValue("(ziiz)", err-&gt;filename,
			    err-&gt;lineno, err-&gt;offset, err-&gt;text);
	if (err-&gt;text != NULL) {
		PyMem_DEL(err-&gt;text);
		err-&gt;text = NULL;
	}
	switch (err-&gt;error) {
	case E_SYNTAX:
		errtype = PyExc_IndentationError;
		if (err-&gt;expected == INDENT)
			msg = "expected an indented block";
		else if (err-&gt;token == INDENT)
			msg = "unexpected indent";
		else if (err-&gt;token == DEDENT)
			msg = "unexpected unindent";
		else {
			errtype = PyExc_SyntaxError;
			msg = "invalid syntax";
		}
		break;
	case E_TOKEN:
		msg = "invalid token";
		break;
	case E_INTR:
		PyErr_SetNone(PyExc_KeyboardInterrupt);
		Py_XDECREF(v);
		return;
	case E_NOMEM:
		PyErr_NoMemory();
		Py_XDECREF(v);
		return;
	case E_EOF:
		msg = "unexpected EOF while parsing";
		break;
	case E_TABSPACE:
		errtype = PyExc_TabError;
		msg = "inconsistent use of tabs and spaces in indentation";
		break;
	case E_OVERFLOW:
		msg = "expression too long";
		break;
	case E_DEDENT:
		errtype = PyExc_IndentationError;
		msg = "unindent does not match any outer indentation level";
		break;
	case E_TOODEEP:
		errtype = PyExc_IndentationError;
		msg = "too many levels of indentation";
		break;
	default:
		fprintf(stderr, "error=%d\n", err-&gt;error);
		msg = "unknown parsing error";
		break;
	}
	w = Py_BuildValue("(sO)", msg, v);
	Py_XDECREF(v);
	PyErr_SetObject(errtype, w);
	Py_XDECREF(w);
}
</t>
<t tx="T991">@ Print fatal error message and abort */
@c

void
Py_FatalError(char *msg)
{
	fprintf(stderr, "Fatal Python error: %s\n", msg);
#ifdef macintosh
	for (;;);
#endif
#ifdef MS_WIN32
	OutputDebugString("Fatal Python error: ");
	OutputDebugString(msg);
	OutputDebugString("\n");
#ifdef _DEBUG
	DebugBreak();
#endif
#endif /* MS_WIN32 */
	abort();
}
</t>
<t tx="T992">@ Clean up and exit */
@c

#ifdef WITH_THREAD
#include "pythread.h"
int _PyThread_Started = 0; /* Set by threadmodule.c and maybe others */
#endif

#define NEXITFUNCS 32
static void (*exitfuncs[NEXITFUNCS])(void);
static int nexitfuncs = 0;

int Py_AtExit(void (*func)(void))
{
	if (nexitfuncs &gt;= NEXITFUNCS)
		return -1;
	exitfuncs[nexitfuncs++] = func;
	return 0;
}
</t>
<t tx="T993">static void
call_sys_exitfunc(void)
{
	PyObject *exitfunc = PySys_GetObject("exitfunc");

	if (exitfunc) {
		PyObject *res;
		Py_INCREF(exitfunc);
		PySys_SetObject("exitfunc", (PyObject *)NULL);
		res = PyEval_CallObject(exitfunc, (PyObject *)NULL);
		if (res == NULL) {
			if (!PyErr_ExceptionMatches(PyExc_SystemExit)) {
				PySys_WriteStderr("Error in sys.exitfunc:\n");
			}
			PyErr_Print();
		}
		Py_DECREF(exitfunc);
	}

	if (Py_FlushLine())
		PyErr_Clear();
}
</t>
<t tx="T994">static void
call_ll_exitfuncs(void)
{
	while (nexitfuncs &gt; 0)
		(*exitfuncs[--nexitfuncs])();

	fflush(stdout);
	fflush(stderr);
}
</t>
<t tx="T995">void
Py_Exit(int sts)
{
	Py_Finalize();

#ifdef macintosh
	PyMac_Exit(sts);
#else
	exit(sts);
#endif
}
</t>
<t tx="T996"></t>
<t tx="T997">static void
initsigs(void)
{
#ifdef HAVE_SIGNAL_H
#ifdef SIGPIPE
	signal(SIGPIPE, SIG_IGN);
#endif
#ifdef SIGXFZ
	signal(SIGXFZ, SIG_IGN);
#endif
#endif /* HAVE_SIGNAL_H */
	PyOS_InitInterrupts(); /* May imply initsignal() */
}
</t>
<t tx="T998">#ifdef Py_TRACE_REFS
/* Ask a yes/no question */

int
_Py_AskYesNo(char *prompt)
{
	char buf[256];
	
	fprintf(stderr, "%s [ny] ", prompt);
	if (fgets(buf, sizeof buf, stdin) == NULL)
		return 0;
	return buf[0] == 'y' || buf[0] == 'Y';
}
</t>
<t tx="T999">#ifdef MPW

/* Check for file descriptor connected to interactive device.
   Pretend that stdin is always interactive, other files never. */

int
isatty(int fd)
{
	return fd == fileno(stdin);
}

#endif</t>
<t tx="T1000">/*
 * The file descriptor fd is considered ``interactive'' if either
 *   a) isatty(fd) is TRUE, or
 *   b) the -i flag was given, and the filename associated with
 *      the descriptor is NULL or "&lt;stdin&gt;" or "???".
 */
int
Py_FdIsInteractive(FILE *fp, char *filename)
{
	if (isatty((int)fileno(fp)))
		return 1;
	if (!Py_InteractiveFlag)
		return 0;
	return (filename == NULL) ||
	       (strcmp(filename, "&lt;stdin&gt;") == 0) ||
	       (strcmp(filename, "???") == 0);
}
</t>
<t tx="T1001">#if defined(USE_STACKCHECK) 
#if defined(WIN32) &amp;&amp; defined(_MSC_VER)

/* Stack checking for Microsoft C */

#include &lt;malloc.h&gt;
#include &lt;excpt.h&gt;

/*
 * Return non-zero when we run out of memory on the stack; zero otherwise.
 */
int
PyOS_CheckStack(void)
{
	__try {
		/* _alloca throws a stack overflow exception if there's
		   not enough space left on the stack */
		_alloca(PYOS_STACK_MARGIN * sizeof(void*));
		return 0;
	} __except (EXCEPTION_EXECUTE_HANDLER) {
		/* just ignore all errors */
	}
	return 1;
}

#endif /* WIN32 &amp;&amp; _MSC_VER */

/* Alternate implementations can be added here... */

#endif /* USE_STACKCHECK */</t>
<t tx="T1002">
/* Wrappers around sigaction() or signal(). */

PyOS_sighandler_t
PyOS_getsig(int sig)
{
#ifdef HAVE_SIGACTION
	struct sigaction context;
	/* Initialize context.sa_handler to SIG_ERR which makes about as
	 * much sense as anything else.  It should get overwritten if
	 * sigaction actually succeeds and otherwise we avoid an
	 * uninitialized memory read.
	 */
	context.sa_handler = SIG_ERR;
	sigaction(sig, NULL, &amp;context);
	return context.sa_handler;
#else
	PyOS_sighandler_t handler;
	handler = signal(sig, SIG_IGN);
	signal(sig, handler);
	return handler;
#endif
}
</t>
<t tx="T1003">PyOS_sighandler_t
PyOS_setsig(int sig, PyOS_sighandler_t handler)
{
#ifdef HAVE_SIGACTION
	struct sigaction context;
	PyOS_sighandler_t oldhandler;
	/* Initialize context.sa_handler to SIG_ERR which makes about as
	 * much sense as anything else.  It should get overwritten if
	 * sigaction actually succeeds and otherwise we avoid an
	 * uninitialized memory read.
	 */
	context.sa_handler = SIG_ERR;
	sigaction(sig, NULL, &amp;context);
	oldhandler = context.sa_handler;
	context.sa_handler = handler;
	sigaction(sig, &amp;context, NULL);
	return oldhandler;
#else
	return signal(sig, handler);
#endif
}
</t>
<t tx="T1004">@language c
/* Built-in functions */

&lt;&lt; bltinmodule #includes &gt;&gt;
&lt;&lt; bltinmodule declarations &gt;&gt;
@others
</t>
<t tx="T1005">#include "Python.h"

#include "node.h"
#include "compile.h"
#include "eval.h"

#include &lt;ctype.h&gt;

#ifdef RISCOS
#include "unixstuff.h"
#endif
</t>
<t tx="T1006">/* The default encoding used by the platform file system APIs
   Can remain NULL for all platforms that don't have such a concept
*/
#if defined(MS_WIN32) &amp;&amp; defined(HAVE_USABLE_WCHAR_T)
const char *Py_FileSystemDefaultEncoding = "mbcs";
#else
const char *Py_FileSystemDefaultEncoding = NULL; /* use default */
#endif

/* Forward */
static PyObject *filterstring(PyObject *, PyObject *);
static PyObject *filtertuple (PyObject *, PyObject *);
</t>
<t tx="T1007">static PyObject *
builtin___import__(PyObject *self, PyObject *args)
{
	char *name;
	PyObject *globals = NULL;
	PyObject *locals = NULL;
	PyObject *fromlist = NULL;

	if (!PyArg_ParseTuple(args, "s|OOO:__import__",
			&amp;name, &amp;globals, &amp;locals, &amp;fromlist))
		return NULL;
	return PyImport_ImportModuleEx(name, globals, locals, fromlist);
}
</t>
<t tx="T1008">static char import_doc[] =
"__import__(name, globals, locals, fromlist) -&gt; module\n\
\n\
Import a module.  The globals are only used to determine the context;\n\
they are not modified.  The locals are currently unused.  The fromlist\n\
should be a list of names to emulate ``from name import ...'', or an\n\
empty list to emulate ``import name''.\n\
When importing a module from a package, note that __import__('A.B', ...)\n\
returns package A when fromlist is empty, but its submodule B when\n\
fromlist is not empty.";


static PyObject *
builtin_abs(PyObject *self, PyObject *v)
{
	return PyNumber_Absolute(v);
}
</t>
<t tx="T1009">static char abs_doc[] =
"abs(number) -&gt; number\n\
\n\
Return the absolute value of the argument.";


static PyObject *
builtin_apply(PyObject *self, PyObject *args)
{
	PyObject *func, *alist = NULL, *kwdict = NULL;
	PyObject *t = NULL, *retval = NULL;

	if (!PyArg_ParseTuple(args, "O|OO:apply", &amp;func, &amp;alist, &amp;kwdict))
		return NULL;
	if (alist != NULL) {
		if (!PyTuple_Check(alist)) {
			if (!PySequence_Check(alist)) {
				PyErr_Format(PyExc_TypeError,
				     "apply() arg 2 expect sequence, found %s",
					     alist-&gt;ob_type-&gt;tp_name);
				return NULL;
			}
			t = PySequence_Tuple(alist);
			if (t == NULL)
				return NULL;
			alist = t;
		}
	}
	if (kwdict != NULL &amp;&amp; !PyDict_Check(kwdict)) {
		PyErr_Format(PyExc_TypeError,
			     "apply() arg 3 expected dictionary, found %s",
			     kwdict-&gt;ob_type-&gt;tp_name);
		goto finally;
	}
	retval = PyEval_CallObjectWithKeywords(func, alist, kwdict);
  finally:
	Py_XDECREF(t);
	return retval;
}
</t>
<t tx="T1010">static char apply_doc[] =
"apply(object[, args[, kwargs]]) -&gt; value\n\
\n\
Call a callable object with positional arguments taken from the tuple args,\n\
and keyword arguments taken from the optional dictionary kwargs.\n\
Note that classes are callable, as are instances with a __call__() method.";


static PyObject *
builtin_bool(PyObject *self, PyObject *x)
{
	long b = PyObject_IsTrue(x);
	if (b &lt; 0)
		return NULL;
	if (b)
		x = Py_True;
	else
		x = Py_False;
	Py_INCREF(x);
	return x;
}
</t>
<t tx="T1011">static char bool_doc[] =
"bool(x) -&gt; integer\n\
\n\
Normalize Boolean: return True (1) when x is true, False (0) otherwise.";


static PyObject *
builtin_buffer(PyObject *self, PyObject *args)
{
	PyObject *ob;
	int offset = 0;
	int size = Py_END_OF_BUFFER;

	if ( !PyArg_ParseTuple(args, "O|ii:buffer", &amp;ob, &amp;offset, &amp;size) )
	    return NULL;
	return PyBuffer_FromObject(ob, offset, size);
}
</t>
<t tx="T1012">static char buffer_doc[] =
"buffer(object [, offset[, size]]) -&gt; object\n\
\n\
Create a new buffer object which references the given object.\n\
The buffer will reference a slice of the target object from the\n\
start of the object (or at the specified offset). The slice will\n\
extend to the end of the target object (or with the specified size).";


static PyObject *
builtin_callable(PyObject *self, PyObject *v)
{
	return PyInt_FromLong((long)PyCallable_Check(v));
}
</t>
<t tx="T1013">static char callable_doc[] =
"callable(object) -&gt; Boolean\n\
\n\
Return whether the object is callable (i.e., some kind of function).\n\
Note that classes are callable, as are instances with a __call__() method.";


static PyObject *
builtin_filter(PyObject *self, PyObject *args)
{
	PyObject *func, *seq, *result, *it;
	int len;   /* guess for result list size */
	register int j;

	if (!PyArg_ParseTuple(args, "OO:filter", &amp;func, &amp;seq))
		return NULL;

	/* Strings and tuples return a result of the same type. */
	if (PyString_Check(seq))
		return filterstring(func, seq);
	if (PyTuple_Check(seq))
		return filtertuple(func, seq);

	/* Get iterator. */
	it = PyObject_GetIter(seq);
	if (it == NULL)
		return NULL;

	/* Guess a result list size. */
	len = -1;   /* unknown */
	if (PySequence_Check(seq) &amp;&amp;
	    seq-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_length) {
		len = PySequence_Size(seq);
		if (len &lt; 0)
			PyErr_Clear();
	}
	if (len &lt; 0)
		len = 8;  /* arbitrary */

	/* Get a result list. */
	if (PyList_Check(seq) &amp;&amp; seq-&gt;ob_refcnt == 1) {
		/* Eww - can modify the list in-place. */
		Py_INCREF(seq);
		result = seq;
	}
	else {
		result = PyList_New(len);
		if (result == NULL)
			goto Fail_it;
	}

	/* Build the result list. */
	j = 0;
	for (;;) {
		PyObject *item, *good;
		int ok;

		item = PyIter_Next(it);
		if (item == NULL) {
			if (PyErr_Occurred())
				goto Fail_result_it;
			break;
		}

		if (func == Py_None) {
			good = item;
			Py_INCREF(good);
		}
		else {
			PyObject *arg = Py_BuildValue("(O)", item);
			if (arg == NULL) {
				Py_DECREF(item);
				goto Fail_result_it;
			}
			good = PyEval_CallObject(func, arg);
			Py_DECREF(arg);
			if (good == NULL) {
				Py_DECREF(item);
				goto Fail_result_it;
			}
		}
		ok = PyObject_IsTrue(good);
		Py_DECREF(good);
		if (ok) {
			if (j &lt; len)
				PyList_SET_ITEM(result, j, item);
			else {
				int status = PyList_Append(result, item);
				Py_DECREF(item);
				if (status &lt; 0)
					goto Fail_result_it;
			}
			++j;
		}
		else
			Py_DECREF(item);
	}


	/* Cut back result list if len is too big. */
	if (j &lt; len &amp;&amp; PyList_SetSlice(result, j, len, NULL) &lt; 0)
		goto Fail_result_it;

	Py_DECREF(it);
	return result;

Fail_result_it:
	Py_DECREF(result);
Fail_it:
	Py_DECREF(it);
	return NULL;
}
</t>
<t tx="T1014">static char filter_doc[] =
"filter(function or None, sequence) -&gt; list, tuple, or string\n"
"\n"
"Return those items of sequence for which function(item) is true.  If\n"
"function is None, return the items that are true.  If sequence is a tuple\n"
"or string, return the same type, else return a list.";

static PyObject *
builtin_chr(PyObject *self, PyObject *args)
{
	long x;
	char s[1];

	if (!PyArg_ParseTuple(args, "l:chr", &amp;x))
		return NULL;
	if (x &lt; 0 || x &gt;= 256) {
		PyErr_SetString(PyExc_ValueError,
				"chr() arg not in range(256)");
		return NULL;
	}
	s[0] = (char)x;
	return PyString_FromStringAndSize(s, 1);
}
</t>
<t tx="T1015">static char chr_doc[] =
"chr(i) -&gt; character\n\
\n\
Return a string of one character with ordinal i; 0 &lt;= i &lt; 256.";


#ifdef Py_USING_UNICODE
static PyObject *
builtin_unichr(PyObject *self, PyObject *args)
{
	long x;
	Py_UNICODE s[2];

	if (!PyArg_ParseTuple(args, "l:unichr", &amp;x))
		return NULL;

#ifdef Py_UNICODE_WIDE
	if (x &lt; 0 || x &gt; 0x10ffff) {
		PyErr_SetString(PyExc_ValueError,
				"unichr() arg not in range(0x110000) "
				"(wide Python build)");
		return NULL;
	}
#else
	if (x &lt; 0 || x &gt; 0xffff) {
		PyErr_SetString(PyExc_ValueError,
				"unichr() arg not in range(0x10000) "
				"(narrow Python build)");
		return NULL;
	}
#endif

	if (x &lt;= 0xffff) {
		/* UCS-2 character */
		s[0] = (Py_UNICODE) x;
		return PyUnicode_FromUnicode(s, 1);
	}
	else {
#ifndef Py_UNICODE_WIDE
		/* UCS-4 character.  store as two surrogate characters */
		x -= 0x10000L;
		s[0] = 0xD800 + (Py_UNICODE) (x &gt;&gt; 10);
		s[1] = 0xDC00 + (Py_UNICODE) (x &amp; 0x03FF);
		return PyUnicode_FromUnicode(s, 2);
#else
		s[0] = (Py_UNICODE)x;
		return PyUnicode_FromUnicode(s, 1);
#endif
	}
}
</t>
<t tx="T1016">static char unichr_doc[] =
"unichr(i) -&gt; Unicode character\n\
\n\
Return a Unicode string of one character with ordinal i; 0 &lt;= i &lt;= 0x10ffff.";
#endif


static PyObject *
builtin_cmp(PyObject *self, PyObject *args)
{
	PyObject *a, *b;
	int c;

	if (!PyArg_ParseTuple(args, "OO:cmp", &amp;a, &amp;b))
		return NULL;
	if (PyObject_Cmp(a, b, &amp;c) &lt; 0)
		return NULL;
	return PyInt_FromLong((long)c);
}
</t>
<t tx="T1017">static char cmp_doc[] =
"cmp(x, y) -&gt; integer\n\
\n\
Return negative if x&lt;y, zero if x==y, positive if x&gt;y.";


static PyObject *
builtin_coerce(PyObject *self, PyObject *args)
{
	PyObject *v, *w;
	PyObject *res;

	if (!PyArg_ParseTuple(args, "OO:coerce", &amp;v, &amp;w))
		return NULL;
	if (PyNumber_Coerce(&amp;v, &amp;w) &lt; 0)
		return NULL;
	res = Py_BuildValue("(OO)", v, w);
	Py_DECREF(v);
	Py_DECREF(w);
	return res;
}
</t>
<t tx="T1018">static char coerce_doc[] =
"coerce(x, y) -&gt; None or (x1, y1)\n\
\n\
When x and y can be coerced to values of the same type, return a tuple\n\
containing the coerced values.  When they can't be coerced, return None.";


static PyObject *
builtin_compile(PyObject *self, PyObject *args)
{
	char *str;
	char *filename;
	char *startstr;
	int start;
	int dont_inherit = 0;
	int supplied_flags = 0;
	PyCompilerFlags cf;

	if (!PyArg_ParseTuple(args, "sss|ii:compile", &amp;str, &amp;filename, 
			      &amp;startstr, &amp;supplied_flags, &amp;dont_inherit))
		return NULL;

	if (strcmp(startstr, "exec") == 0)
		start = Py_file_input;
	else if (strcmp(startstr, "eval") == 0)
		start = Py_eval_input;
	else if (strcmp(startstr, "single") == 0)
		start = Py_single_input;
	else {
		PyErr_SetString(PyExc_ValueError,
		   "compile() arg 3 must be 'exec' or 'eval' or 'single'");
		return NULL;
	}

	if (supplied_flags &amp; ~(PyCF_MASK | PyCF_MASK_OBSOLETE)) {
		PyErr_SetString(PyExc_ValueError,
				"compile(): unrecognised flags");
		return NULL;
	}
	/* XXX Warn if (supplied_flags &amp; PyCF_MASK_OBSOLETE) != 0? */

	cf.cf_flags = supplied_flags;
	if (!dont_inherit) {
		PyEval_MergeCompilerFlags(&amp;cf);
	}
	return Py_CompileStringFlags(str, filename, start, &amp;cf);
}
</t>
<t tx="T1019">static char compile_doc[] =
"compile(source, filename, mode[, flags[, dont_inherit]]) -&gt; code object\n\
\n\
Compile the source string (a Python module, statement or expression)\n\
into a code object that can be executed by the exec statement or eval().\n\
The filename will be used for run-time error messages.\n\
The mode must be 'exec' to compile a module, 'single' to compile a\n\
single (interactive) statement, or 'eval' to compile an expression.\n\
The flags argument, if present, controls which future statements influence\n\
the compilation of the code.\n\
The dont_inherit argument, if non-zero, stops the compilation inheriting\n\
the effects of any future statements in effect in the code calling\n\
compile; if absent or zero these statements do influence the compilation,\n\
in addition to any features explicitly specified.";

static PyObject *
builtin_dir(PyObject *self, PyObject *args)
{
	PyObject *arg = NULL;

	if (!PyArg_ParseTuple(args, "|O:dir", &amp;arg))
		return NULL;
	return PyObject_Dir(arg);
}
</t>
<t tx="T1020">static char dir_doc[] =
"dir([object]) -&gt; list of strings\n"
"\n"
"Return an alphabetized list of names comprising (some of) the attributes\n"
"of the given object, and of attributes reachable from it:\n"
"\n"
"No argument:  the names in the current scope.\n"
"Module object:  the module attributes.\n"
"Type or class object:  its attributes, and recursively the attributes of\n"
"    its bases.\n"
"Otherwise:  its attributes, its class's attributes, and recursively the\n"
"    attributes of its class's base classes.";

static PyObject *
builtin_divmod(PyObject *self, PyObject *args)
{
	PyObject *v, *w;

	if (!PyArg_ParseTuple(args, "OO:divmod", &amp;v, &amp;w))
		return NULL;
	return PyNumber_Divmod(v, w);
}
</t>
<t tx="T1021">static char divmod_doc[] =
"divmod(x, y) -&gt; (div, mod)\n\
\n\
Return the tuple ((x-x%y)/y, x%y).  Invariant: div*y + mod == x.";


static PyObject *
builtin_eval(PyObject *self, PyObject *args)
{
	PyObject *cmd;
	PyObject *globals = Py_None, *locals = Py_None;
	char *str;
	PyCompilerFlags cf;

	if (!PyArg_ParseTuple(args, "O|O!O!:eval",
			&amp;cmd,
			&amp;PyDict_Type, &amp;globals,
			&amp;PyDict_Type, &amp;locals))
		return NULL;
	if (globals == Py_None) {
		globals = PyEval_GetGlobals();
		if (locals == Py_None)
			locals = PyEval_GetLocals();
	}
	else if (locals == Py_None)
		locals = globals;

	if (PyDict_GetItemString(globals, "__builtins__") == NULL) {
		if (PyDict_SetItemString(globals, "__builtins__",
					 PyEval_GetBuiltins()) != 0)
			return NULL;
	}

	if (PyCode_Check(cmd)) {
		if (PyCode_GetNumFree((PyCodeObject *)cmd) &gt; 0) {
			PyErr_SetString(PyExc_TypeError,
		"code object passed to eval() may not contain free variables");
			return NULL;
		}
		return PyEval_EvalCode((PyCodeObject *) cmd, globals, locals);
	}

	if (!PyString_Check(cmd) &amp;&amp;
	    !PyUnicode_Check(cmd)) {
		PyErr_SetString(PyExc_TypeError,
			   "eval() arg 1 must be a string or code object");
		return NULL;
	}
	if (PyString_AsStringAndSize(cmd, &amp;str, NULL))
		return NULL;
	while (*str == ' ' || *str == '\t')
		str++;

	cf.cf_flags = 0;
	(void)PyEval_MergeCompilerFlags(&amp;cf);
	return PyRun_StringFlags(str, Py_eval_input, globals, locals, &amp;cf);
}
</t>
<t tx="T1022">static char eval_doc[] =
"eval(source[, globals[, locals]]) -&gt; value\n\
\n\
Evaluate the source in the context of globals and locals.\n\
The source may be a string representing a Python expression\n\
or a code object as returned by compile().\n\
The globals and locals are dictionaries, defaulting to the current\n\
globals and locals.  If only globals is given, locals defaults to it.";


static PyObject *
builtin_execfile(PyObject *self, PyObject *args)
{
	char *filename;
	PyObject *globals = Py_None, *locals = Py_None;
	PyObject *res;
	FILE* fp = NULL;
	PyCompilerFlags cf;
	int exists;
#ifndef RISCOS
	struct stat s;
#endif

	if (!PyArg_ParseTuple(args, "s|O!O!:execfile",
			&amp;filename,
			&amp;PyDict_Type, &amp;globals,
			&amp;PyDict_Type, &amp;locals))
		return NULL;
	if (globals == Py_None) {
		globals = PyEval_GetGlobals();
		if (locals == Py_None)
			locals = PyEval_GetLocals();
	}
	else if (locals == Py_None)
		locals = globals;
	if (PyDict_GetItemString(globals, "__builtins__") == NULL) {
		if (PyDict_SetItemString(globals, "__builtins__",
					 PyEval_GetBuiltins()) != 0)
			return NULL;
	}

	exists = 0;
	/* Test for existence or directory. */
#ifndef RISCOS
	if (!stat(filename, &amp;s)) {
		if (S_ISDIR(s.st_mode))
#if defined(PYOS_OS2) &amp;&amp; defined(PYCC_VACPP)
			errno = EOS2ERR;
#else
			errno = EISDIR;
#endif
		else
			exists = 1;
	}
#else
	if (object_exists(filename)) {
		if (isdir(filename))
			errno = EISDIR;
		else
			exists = 1;
	}
#endif /* RISCOS */

        if (exists) {
		Py_BEGIN_ALLOW_THREADS
		fp = fopen(filename, "r");
		Py_END_ALLOW_THREADS

		if (fp == NULL) {
			exists = 0;
		}
        }

	if (!exists) {
		PyErr_SetFromErrno(PyExc_IOError);
		return NULL;
	}
	cf.cf_flags = 0;
	if (PyEval_MergeCompilerFlags(&amp;cf))
		res = PyRun_FileExFlags(fp, filename, Py_file_input, globals,
				   locals, 1, &amp;cf);
	else
		res = PyRun_FileEx(fp, filename, Py_file_input, globals,
				   locals, 1);
	return res;
}
</t>
<t tx="T1023">static char execfile_doc[] =
"execfile(filename[, globals[, locals]])\n\
\n\
Read and execute a Python script from a file.\n\
The globals and locals are dictionaries, defaulting to the current\n\
globals and locals.  If only globals is given, locals defaults to it.";


static PyObject *
builtin_getattr(PyObject *self, PyObject *args)
{
	PyObject *v, *result, *dflt = NULL;
	PyObject *name;

	if (!PyArg_ParseTuple(args, "OO|O:getattr", &amp;v, &amp;name, &amp;dflt))
		return NULL;
#ifdef Py_USING_UNICODE
	if (PyUnicode_Check(name)) {
		name = _PyUnicode_AsDefaultEncodedString(name, NULL);
		if (name == NULL)
			return NULL;
	}
#endif

	if (!PyString_Check(name)) {
		PyErr_SetString(PyExc_TypeError,
				"attribute name must be string");
		return NULL;
	}
	result = PyObject_GetAttr(v, name);
	if (result == NULL &amp;&amp; dflt != NULL &amp;&amp;
	    PyErr_ExceptionMatches(PyExc_AttributeError))
	{
		PyErr_Clear();
		Py_INCREF(dflt);
		result = dflt;
	}
	return result;
}
</t>
<t tx="T1024">static char getattr_doc[] =
"getattr(object, name[, default]) -&gt; value\n\
\n\
Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.\n\
When a default argument is given, it is returned when the attribute doesn't\n\
exist; without it, an exception is raised in that case.";


static PyObject *
builtin_globals(PyObject *self)
{
	PyObject *d;

	d = PyEval_GetGlobals();
	Py_INCREF(d);
	return d;
}
</t>
<t tx="T1025">static char globals_doc[] =
"globals() -&gt; dictionary\n\
\n\
Return the dictionary containing the current scope's global variables.";


static PyObject *
builtin_hasattr(PyObject *self, PyObject *args)
{
	PyObject *v;
	PyObject *name;

	if (!PyArg_ParseTuple(args, "OO:hasattr", &amp;v, &amp;name))
		return NULL;
#ifdef Py_USING_UNICODE
	if (PyUnicode_Check(name)) {
		name = _PyUnicode_AsDefaultEncodedString(name, NULL);
		if (name == NULL)
			return NULL;
	}
#endif

	if (!PyString_Check(name)) {
		PyErr_SetString(PyExc_TypeError,
				"attribute name must be string");
		return NULL;
	}
	v = PyObject_GetAttr(v, name);
	if (v == NULL) {
		PyErr_Clear();
		Py_INCREF(Py_False);
		return Py_False;
	}
	Py_DECREF(v);
	Py_INCREF(Py_True);
	return Py_True;
}
</t>
<t tx="T1026">static char hasattr_doc[] =
"hasattr(object, name) -&gt; Boolean\n\
\n\
Return whether the object has an attribute with the given name.\n\
(This is done by calling getattr(object, name) and catching exceptions.)";


static PyObject *
builtin_id(PyObject *self, PyObject *v)
{
	return PyLong_FromVoidPtr(v);
}
</t>
<t tx="T1027">static char id_doc[] =
"id(object) -&gt; integer\n\
\n\
Return the identity of an object.  This is guaranteed to be unique among\n\
simultaneously existing objects.  (Hint: it's the object's memory address.)";


static PyObject *
builtin_map(PyObject *self, PyObject *args)
{
	typedef struct {
		PyObject *it;	/* the iterator object */
		int saw_StopIteration;  /* bool:  did the iterator end? */
	} sequence;

	PyObject *func, *result;
	sequence *seqs = NULL, *sqp;
	int n, len;
	register int i, j;

	n = PyTuple_Size(args);
	if (n &lt; 2) {
		PyErr_SetString(PyExc_TypeError,
				"map() requires at least two args");
		return NULL;
	}

	func = PyTuple_GetItem(args, 0);
	n--;

	if (func == Py_None &amp;&amp; n == 1) {
		/* map(None, S) is the same as list(S). */
		return PySequence_List(PyTuple_GetItem(args, 1));
	}

	/* Get space for sequence descriptors.  Must NULL out the iterator
	 * pointers so that jumping to Fail_2 later doesn't see trash.
	 */
	if ((seqs = PyMem_NEW(sequence, n)) == NULL) {
		PyErr_NoMemory();
		return NULL;
	}
	for (i = 0; i &lt; n; ++i) {
		seqs[i].it = (PyObject*)NULL;
		seqs[i].saw_StopIteration = 0;
	}

	/* Do a first pass to obtain iterators for the arguments, and set len
	 * to the largest of their lengths.
	 */
	len = 0;
	for (i = 0, sqp = seqs; i &lt; n; ++i, ++sqp) {
		PyObject *curseq;
		int curlen;

		/* Get iterator. */
		curseq = PyTuple_GetItem(args, i+1);
		sqp-&gt;it = PyObject_GetIter(curseq);
		if (sqp-&gt;it == NULL) {
			static char errmsg[] =
			    "argument %d to map() must support iteration";
			char errbuf[sizeof(errmsg) + 25];
			PyOS_snprintf(errbuf, sizeof(errbuf), errmsg, i+2);
			PyErr_SetString(PyExc_TypeError, errbuf);
			goto Fail_2;
		}

		/* Update len. */
		curlen = -1;  /* unknown */
		if (PySequence_Check(curseq) &amp;&amp;
		    curseq-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_length) {
			curlen = PySequence_Size(curseq);
			if (curlen &lt; 0)
				PyErr_Clear();
		}
		if (curlen &lt; 0)
			curlen = 8;  /* arbitrary */
			if (curlen &gt; len)
				len = curlen;
	}

	/* Get space for the result list. */
	if ((result = (PyObject *) PyList_New(len)) == NULL)
		goto Fail_2;

	/* Iterate over the sequences until all have stopped. */
	for (i = 0; ; ++i) {
		PyObject *alist, *item=NULL, *value;
		int numactive = 0;

		if (func == Py_None &amp;&amp; n == 1)
			alist = NULL;
		else if ((alist = PyTuple_New(n)) == NULL)
			goto Fail_1;

		for (j = 0, sqp = seqs; j &lt; n; ++j, ++sqp) {
			if (sqp-&gt;saw_StopIteration) {
				Py_INCREF(Py_None);
				item = Py_None;
			}
			else {
				item = PyIter_Next(sqp-&gt;it);
				if (item)
					++numactive;
				else {
					if (PyErr_Occurred()) {
						Py_XDECREF(alist);
						goto Fail_1;
					}
					Py_INCREF(Py_None);
					item = Py_None;
					sqp-&gt;saw_StopIteration = 1;
				}
			}
			if (alist)
				PyTuple_SET_ITEM(alist, j, item);
			else
				break;
		}

		if (!alist)
			alist = item;

		if (numactive == 0) {
			Py_DECREF(alist);
			break;
		}

		if (func == Py_None)
			value = alist;
		else {
			value = PyEval_CallObject(func, alist);
			Py_DECREF(alist);
			if (value == NULL)
				goto Fail_1;
		}
		if (i &gt;= len) {
			int status = PyList_Append(result, value);
			Py_DECREF(value);
			if (status &lt; 0)
				goto Fail_1;
		}
		else if (PyList_SetItem(result, i, value) &lt; 0)
		 	goto Fail_1;
	}

	if (i &lt; len &amp;&amp; PyList_SetSlice(result, i, len, NULL) &lt; 0)
		goto Fail_1;

	goto Succeed;

Fail_1:
	Py_DECREF(result);
Fail_2:
	result = NULL;
Succeed:
	assert(seqs);
	for (i = 0; i &lt; n; ++i)
		Py_XDECREF(seqs[i].it);
	PyMem_DEL(seqs);
	return result;
}
</t>
<t tx="T1028">static char map_doc[] =
"map(function, sequence[, sequence, ...]) -&gt; list\n\
\n\
Return a list of the results of applying the function to the items of\n\
the argument sequence(s).  If more than one sequence is given, the\n\
function is called with an argument list consisting of the corresponding\n\
item of each sequence, substituting None for missing values when not all\n\
sequences have the same length.  If the function is None, return a list of\n\
the items of the sequence (or a list of tuples if more than one sequence).";


static PyObject *
builtin_setattr(PyObject *self, PyObject *args)
{
	PyObject *v;
	PyObject *name;
	PyObject *value;

	if (!PyArg_ParseTuple(args, "OOO:setattr", &amp;v, &amp;name, &amp;value))
		return NULL;
	if (PyObject_SetAttr(v, name, value) != 0)
		return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T1029">static char setattr_doc[] =
"setattr(object, name, value)\n\
\n\
Set a named attribute on an object; setattr(x, 'y', v) is equivalent to\n\
``x.y = v''.";


static PyObject *
builtin_delattr(PyObject *self, PyObject *args)
{
	PyObject *v;
	PyObject *name;

	if (!PyArg_ParseTuple(args, "OO:delattr", &amp;v, &amp;name))
		return NULL;
	if (PyObject_SetAttr(v, name, (PyObject *)NULL) != 0)
		return NULL;
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="T1030">static char delattr_doc[] =
"delattr(object, name)\n\
\n\
Delete a named attribute on an object; delattr(x, 'y') is equivalent to\n\
``del x.y''.";


static PyObject *
builtin_hash(PyObject *self, PyObject *v)
{
	long x;

	x = PyObject_Hash(v);
	if (x == -1)
		return NULL;
	return PyInt_FromLong(x);
}
</t>
<t tx="T1031">static char hash_doc[] =
"hash(object) -&gt; integer\n\
\n\
Return a hash value for the object.  Two objects with the same value have\n\
the same hash value.  The reverse is not necessarily true, but likely.";


static PyObject *
builtin_hex(PyObject *self, PyObject *v)
{
	PyNumberMethods *nb;

	if ((nb = v-&gt;ob_type-&gt;tp_as_number) == NULL ||
	    nb-&gt;nb_hex == NULL) {
		PyErr_SetString(PyExc_TypeError,
			   "hex() argument can't be converted to hex");
		return NULL;
	}
	return (*nb-&gt;nb_hex)(v);
}
</t>
<t tx="T1032">static char hex_doc[] =
"hex(number) -&gt; string\n\
\n\
Return the hexadecimal representation of an integer or long integer.";


static PyObject *builtin_raw_input(PyObject *, PyObject *);

static PyObject *
builtin_input(PyObject *self, PyObject *args)
{
	PyObject *line;
	char *str;
	PyObject *res;
	PyObject *globals, *locals;

	line = builtin_raw_input(self, args);
	if (line == NULL)
		return line;
	if (!PyArg_Parse(line, "s;embedded '\\0' in input line", &amp;str))
		return NULL;
	while (*str == ' ' || *str == '\t')
			str++;
	globals = PyEval_GetGlobals();
	locals = PyEval_GetLocals();
	if (PyDict_GetItemString(globals, "__builtins__") == NULL) {
		if (PyDict_SetItemString(globals, "__builtins__",
					 PyEval_GetBuiltins()) != 0)
			return NULL;
	}
	res = PyRun_String(str, Py_eval_input, globals, locals);
	Py_DECREF(line);
	return res;
}
</t>
<t tx="T1033">static char input_doc[] =
"input([prompt]) -&gt; value\n\
\n\
Equivalent to eval(raw_input(prompt)).";


static PyObject *
builtin_intern(PyObject *self, PyObject *args)
{
	PyObject *s;
	if (!PyArg_ParseTuple(args, "S:intern", &amp;s))
		return NULL;
	Py_INCREF(s);
	PyString_InternInPlace(&amp;s);
	return s;
}
</t>
<t tx="T1034">static char intern_doc[] =
"intern(string) -&gt; string\n\
\n\
``Intern'' the given string.  This enters the string in the (global)\n\
table of interned strings whose purpose is to speed up dictionary lookups.\n\
Return the string itself or the previously interned string object with the\n\
same value.";


static PyObject *
builtin_iter(PyObject *self, PyObject *args)
{
	PyObject *v, *w = NULL;

	if (!PyArg_ParseTuple(args, "O|O:iter", &amp;v, &amp;w))
		return NULL;
	if (w == NULL)
		return PyObject_GetIter(v);
	if (!PyCallable_Check(v)) {
		PyErr_SetString(PyExc_TypeError,
				"iter(v, w): v must be callable");
		return NULL;
	}
	return PyCallIter_New(v, w);
}
</t>
<t tx="T1035">static char iter_doc[] =
"iter(collection) -&gt; iterator\n\
iter(callable, sentinel) -&gt; iterator\n\
\n\
Get an iterator from an object.  In the first form, the argument must\n\
supply its own iterator, or be a sequence.\n\
In the second form, the callable is called until it returns the sentinel.";


static PyObject *
builtin_len(PyObject *self, PyObject *v)
{
	long res;

	res = PyObject_Size(v);
	if (res &lt; 0 &amp;&amp; PyErr_Occurred())
		return NULL;
	return PyInt_FromLong(res);
}
</t>
<t tx="T1036">static char len_doc[] =
"len(object) -&gt; integer\n\
\n\
Return the number of items of a sequence or mapping.";


static PyObject *
builtin_slice(PyObject *self, PyObject *args)
{
	PyObject *start, *stop, *step;

	start = stop = step = NULL;

	if (!PyArg_ParseTuple(args, "O|OO:slice", &amp;start, &amp;stop, &amp;step))
		return NULL;

	/* This swapping of stop and start is to maintain similarity with
	   range(). */
	if (stop == NULL) {
		stop = start;
		start = NULL;
	}
	return PySlice_New(start, stop, step);
}
</t>
<t tx="T1037">static char slice_doc[] =
"slice([start,] stop[, step]) -&gt; slice object\n\
\n\
Create a slice object.  This is used for slicing by the Numeric extensions.";


static PyObject *
builtin_locals(PyObject *self)
{
	PyObject *d;

	d = PyEval_GetLocals();
	Py_INCREF(d);
	return d;
}
</t>
<t tx="T1038">static char locals_doc[] =
"locals() -&gt; dictionary\n\
\n\
Return the dictionary containing the current scope's local variables.";


static PyObject *
min_max(PyObject *args, int op)
{
	PyObject *v, *w, *x, *it;

	if (PyTuple_Size(args) &gt; 1)
		v = args;
	else if (!PyArg_ParseTuple(args, "O:min/max", &amp;v))
		return NULL;
	
	it = PyObject_GetIter(v);
	if (it == NULL)
		return NULL;

	w = NULL;  /* the result */
	for (;;) {
		x = PyIter_Next(it);
		if (x == NULL) {
			if (PyErr_Occurred()) {
				Py_XDECREF(w);
				Py_DECREF(it);
				return NULL;
			}
			break;
		}

		if (w == NULL)
			w = x;
		else {
			int cmp = PyObject_RichCompareBool(x, w, op);
			if (cmp &gt; 0) {
				Py_DECREF(w);
				w = x;
			}
			else if (cmp &lt; 0) {
				Py_DECREF(x);
				Py_DECREF(w);
				Py_DECREF(it);
				return NULL;
			}
			else
				Py_DECREF(x);
		}
	}
	if (w == NULL)
		PyErr_SetString(PyExc_ValueError,
				"min() or max() arg is an empty sequence");
	Py_DECREF(it);
	return w;
}
</t>
<t tx="T1039">static PyObject *
builtin_min(PyObject *self, PyObject *v)
{
	return min_max(v, Py_LT);
}
</t>
<t tx="T1040">static char min_doc[] =
"min(sequence) -&gt; value\n\
min(a, b, c, ...) -&gt; value\n\
\n\
With a single sequence argument, return its smallest item.\n\
With two or more arguments, return the smallest argument.";


static PyObject *
builtin_max(PyObject *self, PyObject *v)
{
	return min_max(v, Py_GT);
}
</t>
<t tx="T1041">static char max_doc[] =
"max(sequence) -&gt; value\n\
max(a, b, c, ...) -&gt; value\n\
\n\
With a single sequence argument, return its largest item.\n\
With two or more arguments, return the largest argument.";


static PyObject *
builtin_oct(PyObject *self, PyObject *v)
{
	PyNumberMethods *nb;

	if (v == NULL || (nb = v-&gt;ob_type-&gt;tp_as_number) == NULL ||
	    nb-&gt;nb_oct == NULL) {
		PyErr_SetString(PyExc_TypeError,
			   "oct() argument can't be converted to oct");
		return NULL;
	}
	return (*nb-&gt;nb_oct)(v);
}
</t>
<t tx="T1042">static char oct_doc[] =
"oct(number) -&gt; string\n\
\n\
Return the octal representation of an integer or long integer.";


static PyObject *
builtin_ord(PyObject *self, PyObject* obj)
{
	long ord;
	int size;

	if (PyString_Check(obj)) {
		size = PyString_GET_SIZE(obj);
		if (size == 1) {
			ord = (long)((unsigned char)*PyString_AS_STRING(obj));
			return PyInt_FromLong(ord);
		}
#ifdef Py_USING_UNICODE
	} else if (PyUnicode_Check(obj)) {
		size = PyUnicode_GET_SIZE(obj);
		if (size == 1) {
			ord = (long)*PyUnicode_AS_UNICODE(obj);
			return PyInt_FromLong(ord);
		}
#endif
	} else {
		PyErr_Format(PyExc_TypeError,
			     "ord() expected string of length 1, but " \
			     "%.200s found", obj-&gt;ob_type-&gt;tp_name);
		return NULL;
	}

	PyErr_Format(PyExc_TypeError,
		     "ord() expected a character, "
		     "but string of length %d found",
		     size);
	return NULL;
}
</t>
<t tx="T1043">static char ord_doc[] =
"ord(c) -&gt; integer\n\
\n\
Return the integer ordinal of a one-character string.";


static PyObject *
builtin_pow(PyObject *self, PyObject *args)
{
	PyObject *v, *w, *z = Py_None;

	if (!PyArg_ParseTuple(args, "OO|O:pow", &amp;v, &amp;w, &amp;z))
		return NULL;
	return PyNumber_Power(v, w, z);
}
</t>
<t tx="T1044">static char pow_doc[] =
"pow(x, y[, z]) -&gt; number\n\
\n\
With two arguments, equivalent to x**y.  With three arguments,\n\
equivalent to (x**y) % z, but may be more efficient (e.g. for longs).";


/* Return number of items in range/xrange (lo, hi, step).  step &gt; 0
 * required.  Return a value &lt; 0 if &amp; only if the true value is too
 * large to fit in a signed long.
 */
static long
get_len_of_range(long lo, long hi, long step)
{
	/* -------------------------------------------------------------
	If lo &gt;= hi, the range is empty.
	Else if n values are in the range, the last one is
	lo + (n-1)*step, which must be &lt;= hi-1.  Rearranging,
	n &lt;= (hi - lo - 1)/step + 1, so taking the floor of the RHS gives
	the proper value.  Since lo &lt; hi in this case, hi-lo-1 &gt;= 0, so
	the RHS is non-negative and so truncation is the same as the
	floor.  Letting M be the largest positive long, the worst case
	for the RHS numerator is hi=M, lo=-M-1, and then
	hi-lo-1 = M-(-M-1)-1 = 2*M.  Therefore unsigned long has enough
	precision to compute the RHS exactly.
	---------------------------------------------------------------*/
	long n = 0;
	if (lo &lt; hi) {
		unsigned long uhi = (unsigned long)hi;
		unsigned long ulo = (unsigned long)lo;
		unsigned long diff = uhi - ulo - 1;
		n = (long)(diff / (unsigned long)step + 1);
	}
	return n;
}
</t>
<t tx="T1045">static PyObject *
builtin_range(PyObject *self, PyObject *args)
{
	long ilow = 0, ihigh = 0, istep = 1;
	long bign;
	int i, n;

	PyObject *v;

	if (PyTuple_Size(args) &lt;= 1) {
		if (!PyArg_ParseTuple(args,
				"l;range() requires 1-3 int arguments",
				&amp;ihigh))
			return NULL;
	}
	else {
		if (!PyArg_ParseTuple(args,
				"ll|l;range() requires 1-3 int arguments",
				&amp;ilow, &amp;ihigh, &amp;istep))
			return NULL;
	}
	if (istep == 0) {
		PyErr_SetString(PyExc_ValueError, "range() arg 3 must not be zero");
		return NULL;
	}
	if (istep &gt; 0)
		bign = get_len_of_range(ilow, ihigh, istep);
	else
		bign = get_len_of_range(ihigh, ilow, -istep);
	n = (int)bign;
	if (bign &lt; 0 || (long)n != bign) {
		PyErr_SetString(PyExc_OverflowError,
				"range() result has too many items");
		return NULL;
	}
	v = PyList_New(n);
	if (v == NULL)
		return NULL;
	for (i = 0; i &lt; n; i++) {
		PyObject *w = PyInt_FromLong(ilow);
		if (w == NULL) {
			Py_DECREF(v);
			return NULL;
		}
		PyList_SET_ITEM(v, i, w);
		ilow += istep;
	}
	return v;
}
</t>
<t tx="T1046">static char range_doc[] =
"range([start,] stop[, step]) -&gt; list of integers\n\
\n\
Return a list containing an arithmetic progression of integers.\n\
range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0.\n\
When step is given, it specifies the increment (or decrement).\n\
For example, range(4) returns [0, 1, 2, 3].  The end point is omitted!\n\
These are exactly the valid indices for a list of 4 elements.";


static PyObject *
builtin_xrange(PyObject *self, PyObject *args)
{
	long ilow = 0, ihigh = 0, istep = 1;
	long n;

	if (PyTuple_Size(args) &lt;= 1) {
		if (!PyArg_ParseTuple(args,
				"l;xrange() requires 1-3 int arguments",
				&amp;ihigh))
			return NULL;
	}
	else {
		if (!PyArg_ParseTuple(args,
				"ll|l;xrange() requires 1-3 int arguments",
				&amp;ilow, &amp;ihigh, &amp;istep))
			return NULL;
	}
	if (istep == 0) {
		PyErr_SetString(PyExc_ValueError, "xrange() arg 3 must not be zero");
		return NULL;
	}
	if (istep &gt; 0)
		n = get_len_of_range(ilow, ihigh, istep);
	else
		n = get_len_of_range(ihigh, ilow, -istep);
	if (n &lt; 0) {
		PyErr_SetString(PyExc_OverflowError,
				"xrange() result has too many items");
		return NULL;
	}
	return PyRange_New(ilow, n, istep, 1);
}
</t>
<t tx="T1047">static char xrange_doc[] =
"xrange([start,] stop[, step]) -&gt; xrange object\n\
\n\
Like range(), but instead of returning a list, returns an object that\n\
generates the numbers in the range on demand.  This is slightly slower\n\
than range() but more memory efficient.";


static PyObject *
builtin_raw_input(PyObject *self, PyObject *args)
{
	PyObject *v = NULL;
	PyObject *f;

	if (!PyArg_ParseTuple(args, "|O:[raw_]input", &amp;v))
		return NULL;
	if (PyFile_AsFile(PySys_GetObject("stdin")) == stdin &amp;&amp;
	    PyFile_AsFile(PySys_GetObject("stdout")) == stdout &amp;&amp;
	    isatty(fileno(stdin)) &amp;&amp; isatty(fileno(stdout))) {
		PyObject *po;
		char *prompt;
		char *s;
		PyObject *result;
		if (v != NULL) {
			po = PyObject_Str(v);
			if (po == NULL)
				return NULL;
			prompt = PyString_AsString(po);
			if (prompt == NULL)
				return NULL;
		}
		else {
			po = NULL;
			prompt = "";
		}
		s = PyOS_Readline(prompt);
		Py_XDECREF(po);
		if (s == NULL) {
			PyErr_SetNone(PyExc_KeyboardInterrupt);
			return NULL;
		}
		if (*s == '\0') {
			PyErr_SetNone(PyExc_EOFError);
			result = NULL;
		}
		else { /* strip trailing '\n' */
			size_t len = strlen(s);
			if (len &gt; INT_MAX) {
				PyErr_SetString(PyExc_OverflowError, "input too long");
				result = NULL;
			}
			else {
				result = PyString_FromStringAndSize(s, (int)(len-1));
			}
		}
		PyMem_FREE(s);
		return result;
	}
	if (v != NULL) {
		f = PySys_GetObject("stdout");
		if (f == NULL) {
			PyErr_SetString(PyExc_RuntimeError, "lost sys.stdout");
			return NULL;
		}
		if (Py_FlushLine() != 0 ||
		    PyFile_WriteObject(v, f, Py_PRINT_RAW) != 0)
			return NULL;
	}
	f = PySys_GetObject("stdin");
	if (f == NULL) {
		PyErr_SetString(PyExc_RuntimeError, "lost sys.stdin");
		return NULL;
	}
	return PyFile_GetLine(f, -1);
}
</t>
<t tx="T1048">static char raw_input_doc[] =
"raw_input([prompt]) -&gt; string\n\
\n\
Read a string from standard input.  The trailing newline is stripped.\n\
If the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError.\n\
On Unix, GNU readline is used if enabled.  The prompt string, if given,\n\
is printed without a trailing newline before reading.";


static PyObject *
builtin_reduce(PyObject *self, PyObject *args)
{
	PyObject *seq, *func, *result = NULL, *it;

	if (!PyArg_ParseTuple(args, "OO|O:reduce", &amp;func, &amp;seq, &amp;result))
		return NULL;
	if (result != NULL)
		Py_INCREF(result);

	it = PyObject_GetIter(seq);
	if (it == NULL) {
		PyErr_SetString(PyExc_TypeError,
		    "reduce() arg 2 must support iteration");
		Py_XDECREF(result);
		return NULL;
	}

	if ((args = PyTuple_New(2)) == NULL)
		goto Fail;

	for (;;) {
		PyObject *op2;

		if (args-&gt;ob_refcnt &gt; 1) {
			Py_DECREF(args);
			if ((args = PyTuple_New(2)) == NULL)
				goto Fail;
		}

		op2 = PyIter_Next(it);
		if (op2 == NULL) {
			if (PyErr_Occurred())
				goto Fail;
 			break;
		}

		if (result == NULL)
			result = op2;
		else {
			PyTuple_SetItem(args, 0, result);
			PyTuple_SetItem(args, 1, op2);
			if ((result = PyEval_CallObject(func, args)) == NULL)
				goto Fail;
		}
	}

	Py_DECREF(args);

	if (result == NULL)
		PyErr_SetString(PyExc_TypeError,
			   "reduce() of empty sequence with no initial value");

	Py_DECREF(it);
	return result;

Fail:
	Py_XDECREF(args);
	Py_XDECREF(result);
	Py_DECREF(it);
	return NULL;
}
</t>
<t tx="T1049">static char reduce_doc[] =
"reduce(function, sequence[, initial]) -&gt; value\n\
\n\
Apply a function of two arguments cumulatively to the items of a sequence,\n\
from left to right, so as to reduce the sequence to a single value.\n\
For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates\n\
((((1+2)+3)+4)+5).  If initial is present, it is placed before the items\n\
of the sequence in the calculation, and serves as a default when the\n\
sequence is empty.";


static PyObject *
builtin_reload(PyObject *self, PyObject *v)
{
	return PyImport_ReloadModule(v);
}
</t>
<t tx="T1050">static char reload_doc[] =
"reload(module) -&gt; module\n\
\n\
Reload the module.  The module must have been successfully imported before.";


static PyObject *
builtin_repr(PyObject *self, PyObject *v)
{
	return PyObject_Repr(v);
}
</t>
<t tx="T1051">static char repr_doc[] =
"repr(object) -&gt; string\n\
\n\
Return the canonical string representation of the object.\n\
For most object types, eval(repr(object)) == object.";


static PyObject *
builtin_round(PyObject *self, PyObject *args)
{
	double x;
	double f;
	int ndigits = 0;
	int i;

	if (!PyArg_ParseTuple(args, "d|i:round", &amp;x, &amp;ndigits))
			return NULL;
	f = 1.0;
	i = abs(ndigits);
	while  (--i &gt;= 0)
		f = f*10.0;
	if (ndigits &lt; 0)
		x /= f;
	else
		x *= f;
	if (x &gt;= 0.0)
		x = floor(x + 0.5);
	else
		x = ceil(x - 0.5);
	if (ndigits &lt; 0)
		x *= f;
	else
		x /= f;
	return PyFloat_FromDouble(x);
}
</t>
<t tx="T1052">static char round_doc[] =
"round(number[, ndigits]) -&gt; floating point number\n\
\n\
Round a number to a given precision in decimal digits (default 0 digits).\n\
This always returns a floating point number.  Precision may be negative.";


static PyObject *
builtin_vars(PyObject *self, PyObject *args)
{
	PyObject *v = NULL;
	PyObject *d;

	if (!PyArg_ParseTuple(args, "|O:vars", &amp;v))
		return NULL;
	if (v == NULL) {
		d = PyEval_GetLocals();
		if (d == NULL) {
			if (!PyErr_Occurred())
				PyErr_SetString(PyExc_SystemError,
						"no locals!?");
		}
		else
			Py_INCREF(d);
	}
	else {
		d = PyObject_GetAttrString(v, "__dict__");
		if (d == NULL) {
			PyErr_SetString(PyExc_TypeError,
			    "vars() argument must have __dict__ attribute");
			return NULL;
		}
	}
	return d;
}
</t>
<t tx="T1053">static char vars_doc[] =
"vars([object]) -&gt; dictionary\n\
\n\
Without arguments, equivalent to locals().\n\
With an argument, equivalent to object.__dict__.";

static PyObject *
builtin_isinstance(PyObject *self, PyObject *args)
{
	PyObject *inst;
	PyObject *cls;
	int retval;

	if (!PyArg_ParseTuple(args, "OO:isinstance", &amp;inst, &amp;cls))
		return NULL;

	retval = PyObject_IsInstance(inst, cls);
	if (retval &lt; 0)
		return NULL;
	return PyInt_FromLong(retval);
}
</t>
<t tx="T1054">static char isinstance_doc[] =
"isinstance(object, class-or-type-or-tuple) -&gt; Boolean\n\
\n\
Return whether an object is an instance of a class or of a subclass thereof.\n\
With a type as second argument, return whether that is the object's type.\n\
The form using a tuple, isinstance(x, (A, B, ...)), is a shortcut for\n\
isinstance(x, A) or isinstance(x, B) or ... (etc.).";


static PyObject *
builtin_issubclass(PyObject *self, PyObject *args)
{
	PyObject *derived;
	PyObject *cls;
	int retval;

	if (!PyArg_ParseTuple(args, "OO:issubclass", &amp;derived, &amp;cls))
		return NULL;

	retval = PyObject_IsSubclass(derived, cls);
	if (retval &lt; 0)
		return NULL;
	return PyInt_FromLong(retval);
}
</t>
<t tx="T1055">static char issubclass_doc[] =
"issubclass(C, B) -&gt; Boolean\n\
\n\
Return whether class C is a subclass (i.e., a derived class) of class B.";


static PyObject*
builtin_zip(PyObject *self, PyObject *args)
{
	PyObject *ret;
	int itemsize = PySequence_Length(args);
	int i;
	PyObject *itlist;  /* tuple of iterators */

	if (itemsize &lt; 1) {
		PyErr_SetString(PyExc_TypeError,
				"zip() requires at least one sequence");
		return NULL;
	}
	/* args must be a tuple */
	assert(PyTuple_Check(args));

	/* allocate result list */
	if ((ret = PyList_New(0)) == NULL)
		return NULL;

	/* obtain iterators */
	itlist = PyTuple_New(itemsize);
	if (itlist == NULL)
		goto Fail_ret;
	for (i = 0; i &lt; itemsize; ++i) {
		PyObject *item = PyTuple_GET_ITEM(args, i);
		PyObject *it = PyObject_GetIter(item);
		if (it == NULL) {
			if (PyErr_ExceptionMatches(PyExc_TypeError))
				PyErr_Format(PyExc_TypeError,
				    "zip argument #%d must support iteration",
				    i+1);
			goto Fail_ret_itlist;
		}
		PyTuple_SET_ITEM(itlist, i, it);
	}

	/* build result into ret list */
	for (;;) {
		int status;
		PyObject *next = PyTuple_New(itemsize);
		if (!next)
			goto Fail_ret_itlist;

		for (i = 0; i &lt; itemsize; i++) {
			PyObject *it = PyTuple_GET_ITEM(itlist, i);
			PyObject *item = PyIter_Next(it);
			if (!item) {
				if (PyErr_Occurred()) {
					Py_DECREF(ret);
					ret = NULL;
				}
				Py_DECREF(next);
				Py_DECREF(itlist);
				return ret;
			}
			PyTuple_SET_ITEM(next, i, item);
		}

		status = PyList_Append(ret, next);
		Py_DECREF(next);
		if (status &lt; 0)
			goto Fail_ret_itlist;
	}

Fail_ret_itlist:
	Py_DECREF(itlist);
Fail_ret:
	Py_DECREF(ret);
	return NULL;
}
</t>
<t tx="T1056">static char zip_doc[] =
"zip(seq1 [, seq2 [...]]) -&gt; [(seq1[0], seq2[0] ...), (...)]\n\
\n\
Return a list of tuples, where each tuple contains the i-th element\n\
from each of the argument sequences.  The returned list is truncated\n\
in length to the length of the shortest argument sequence.";


static PyMethodDef builtin_methods[] = {
 	{"__import__",	builtin___import__, METH_VARARGS, import_doc},
 	{"abs",		builtin_abs,        METH_O, abs_doc},
 	{"apply",	builtin_apply,      METH_VARARGS, apply_doc},
	{"bool",	builtin_bool, 	    METH_O, bool_doc},
 	{"buffer",	builtin_buffer,     METH_VARARGS, buffer_doc},
 	{"callable",	builtin_callable,   METH_O, callable_doc},
 	{"chr",		builtin_chr,        METH_VARARGS, chr_doc},
 	{"cmp",		builtin_cmp,        METH_VARARGS, cmp_doc},
 	{"coerce",	builtin_coerce,     METH_VARARGS, coerce_doc},
 	{"compile",	builtin_compile,    METH_VARARGS, compile_doc},
 	{"delattr",	builtin_delattr,    METH_VARARGS, delattr_doc},
 	{"dir",		builtin_dir,        METH_VARARGS, dir_doc},
 	{"divmod",	builtin_divmod,     METH_VARARGS, divmod_doc},
 	{"eval",	builtin_eval,       METH_VARARGS, eval_doc},
 	{"execfile",	builtin_execfile,   METH_VARARGS, execfile_doc},
 	{"filter",	builtin_filter,     METH_VARARGS, filter_doc},
 	{"getattr",	builtin_getattr,    METH_VARARGS, getattr_doc},
 	{"globals",	(PyCFunction)builtin_globals,    METH_NOARGS, globals_doc},
 	{"hasattr",	builtin_hasattr,    METH_VARARGS, hasattr_doc},
 	{"hash",	builtin_hash,       METH_O, hash_doc},
 	{"hex",		builtin_hex,        METH_O, hex_doc},
 	{"id",		builtin_id,         METH_O, id_doc},
 	{"input",	builtin_input,      METH_VARARGS, input_doc},
 	{"intern",	builtin_intern,     METH_VARARGS, intern_doc},
 	{"isinstance",  builtin_isinstance, METH_VARARGS, isinstance_doc},
 	{"issubclass",  builtin_issubclass, METH_VARARGS, issubclass_doc},
 	{"iter",	builtin_iter,       METH_VARARGS, iter_doc},
 	{"len",		builtin_len,        METH_O, len_doc},
 	{"locals",	(PyCFunction)builtin_locals,     METH_NOARGS, locals_doc},
 	{"map",		builtin_map,        METH_VARARGS, map_doc},
 	{"max",		builtin_max,        METH_VARARGS, max_doc},
 	{"min",		builtin_min,        METH_VARARGS, min_doc},
 	{"oct",		builtin_oct,        METH_O, oct_doc},
 	{"ord",		builtin_ord,        METH_O, ord_doc},
 	{"pow",		builtin_pow,        METH_VARARGS, pow_doc},
 	{"range",	builtin_range,      METH_VARARGS, range_doc},
 	{"raw_input",	builtin_raw_input,  METH_VARARGS, raw_input_doc},
 	{"reduce",	builtin_reduce,     METH_VARARGS, reduce_doc},
 	{"reload",	builtin_reload,     METH_O, reload_doc},
 	{"repr",	builtin_repr,       METH_O, repr_doc},
 	{"round",	builtin_round,      METH_VARARGS, round_doc},
 	{"setattr",	builtin_setattr,    METH_VARARGS, setattr_doc},
 	{"slice",       builtin_slice,      METH_VARARGS, slice_doc},
#ifdef Py_USING_UNICODE
 	{"unichr",	builtin_unichr,     METH_VARARGS, unichr_doc},
#endif
 	{"vars",	builtin_vars,       METH_VARARGS, vars_doc},
 	{"xrange",	builtin_xrange,     METH_VARARGS, xrange_doc},
  	{"zip",         builtin_zip,        METH_VARARGS, zip_doc},
	{NULL,		NULL},
};

static char builtin_doc[] =
"Built-in functions, exceptions, and other objects.\n\
\n\
Noteworthy: None is the `nil' object; Ellipsis represents `...' in slices.";

PyObject *
_PyBuiltin_Init(void)
{
	PyObject *mod, *dict, *debug;
	mod = Py_InitModule4("__builtin__", builtin_methods,
			     builtin_doc, (PyObject *)NULL,
			     PYTHON_API_VERSION);
	if (mod == NULL)
		return NULL;
	dict = PyModule_GetDict(mod);

#define SETBUILTIN(NAME, OBJECT) \
	if (PyDict_SetItemString(dict, NAME, (PyObject *)OBJECT) &lt; 0) \
		return NULL

	SETBUILTIN("None",		Py_None);
	SETBUILTIN("Ellipsis",		Py_Ellipsis);
	SETBUILTIN("NotImplemented",	Py_NotImplemented);
	SETBUILTIN("True",		Py_True);
	SETBUILTIN("False",		Py_False);
	SETBUILTIN("classmethod",	&amp;PyClassMethod_Type);
#ifndef WITHOUT_COMPLEX
	SETBUILTIN("complex",		&amp;PyComplex_Type);
#endif
	SETBUILTIN("dict",		&amp;PyDict_Type);
	SETBUILTIN("float",		&amp;PyFloat_Type);
	SETBUILTIN("property",		&amp;PyProperty_Type);
	SETBUILTIN("int",		&amp;PyInt_Type);
	SETBUILTIN("list",		&amp;PyList_Type);
	SETBUILTIN("long",		&amp;PyLong_Type);
	SETBUILTIN("object",		&amp;PyBaseObject_Type);
	SETBUILTIN("staticmethod",	&amp;PyStaticMethod_Type);
	SETBUILTIN("str",		&amp;PyString_Type);
	SETBUILTIN("super",		&amp;PySuper_Type);
	SETBUILTIN("tuple",		&amp;PyTuple_Type);
	SETBUILTIN("type",		&amp;PyType_Type);

	/* Note that open() is just an alias of file(). */
	SETBUILTIN("open",		&amp;PyFile_Type);
	SETBUILTIN("file",		&amp;PyFile_Type);
#ifdef Py_USING_UNICODE
	SETBUILTIN("unicode",		&amp;PyUnicode_Type);
#endif
	debug = PyInt_FromLong(Py_OptimizeFlag == 0);
	if (PyDict_SetItemString(dict, "__debug__", debug) &lt; 0) {
		Py_XDECREF(debug);
		return NULL;
	}
	Py_XDECREF(debug);

	return mod;
#undef SETBUILTIN
}
</t>
<t tx="T1057">@ Helper for filter(): filter a tuple through a function
@c

static PyObject *
filtertuple(PyObject *func, PyObject *tuple)
{
	PyObject *result;
	register int i, j;
	int len = PyTuple_Size(tuple);

	if (len == 0) {
		Py_INCREF(tuple);
		return tuple;
	}

	if ((result = PyTuple_New(len)) == NULL)
		return NULL;

	for (i = j = 0; i &lt; len; ++i) {
		PyObject *item, *good;
		int ok;

		if ((item = PyTuple_GetItem(tuple, i)) == NULL)
			goto Fail_1;
		if (func == Py_None) {
			Py_INCREF(item);
			good = item;
		}
		else {
			PyObject *arg = Py_BuildValue("(O)", item);
			if (arg == NULL)
				goto Fail_1;
			good = PyEval_CallObject(func, arg);
			Py_DECREF(arg);
			if (good == NULL)
				goto Fail_1;
		}
		ok = PyObject_IsTrue(good);
		Py_DECREF(good);
		if (ok) {
			Py_INCREF(item);
			if (PyTuple_SetItem(result, j++, item) &lt; 0)
				goto Fail_1;
		}
	}

	if (_PyTuple_Resize(&amp;result, j) &lt; 0)
		return NULL;

	return result;

Fail_1:
	Py_DECREF(result);
	return NULL;
}
</t>
<t tx="T1058">@ Helper for filter(): filter a string through a function
@c

static PyObject *
filterstring(PyObject *func, PyObject *strobj)
{
	PyObject *result;
	register int i, j;
	int len = PyString_Size(strobj);

	if (func == Py_None) {
		/* No character is ever false -- share input string */
		Py_INCREF(strobj);
		return strobj;
	}
	if ((result = PyString_FromStringAndSize(NULL, len)) == NULL)
		return NULL;

	for (i = j = 0; i &lt; len; ++i) {
		PyObject *item, *arg, *good;
		int ok;

		item = (*strobj-&gt;ob_type-&gt;tp_as_sequence-&gt;sq_item)(strobj, i);
		if (item == NULL)
			goto Fail_1;
		arg = Py_BuildValue("(O)", item);
		if (arg == NULL) {
			Py_DECREF(item);
			goto Fail_1;
		}
		good = PyEval_CallObject(func, arg);
		Py_DECREF(arg);
		if (good == NULL) {
			Py_DECREF(item);
			goto Fail_1;
		}
		ok = PyObject_IsTrue(good);
		Py_DECREF(good);
		if (ok)
			PyString_AS_STRING((PyStringObject *)result)[j++] =
				PyString_AS_STRING((PyStringObject *)item)[0];
		Py_DECREF(item);
	}

	if (j &lt; len &amp;&amp; _PyString_Resize(&amp;result, j) &lt; 0)
		return NULL;

	return result;

Fail_1:
	Py_DECREF(result);
	return NULL;
}
</t>
<t tx="T1059">@ignore
@language c</t>
<t tx="T1060"></t>
<t tx="T1061">/* Definitions for bytecode */

#ifndef Py_COMPILE_H
#define Py_COMPILE_H
#ifdef __cplusplus
extern "C" {
#endif

/* Bytecode object */
typedef struct {
    PyObject_HEAD
    int co_argcount;		/* #arguments, except *args */
    int co_nlocals;		/* #local variables */
    int co_stacksize;		/* #entries needed for evaluation stack */
    int co_flags;		/* CO_..., see below */
    PyObject *co_code;		/* instruction opcodes */
    PyObject *co_consts;	/* list (constants used) */
    PyObject *co_names;		/* list of strings (names used) */
    PyObject *co_varnames;	/* tuple of strings (local variable names) */
    PyObject *co_freevars;	/* tuple of strings (free variable names) */
    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */
    /* The rest doesn't count for hash/cmp */
    PyObject *co_filename;	/* string (where it was loaded from) */
    PyObject *co_name;		/* string (name, for reference) */
    int co_firstlineno;		/* first source line number */
    PyObject *co_lnotab;	/* string (encoding addr&lt;-&gt;lineno mapping) */
} PyCodeObject;

/* Masks for co_flags above */
#define CO_OPTIMIZED	0x0001
#define CO_NEWLOCALS	0x0002
#define CO_VARARGS	0x0004
#define CO_VARKEYWORDS	0x0008
#define CO_NESTED       0x0010
#define CO_GENERATOR    0x0020
/* XXX Temporary hack.  Until generators are a permanent part of the
   language, we need a way for a code object to record that generators
   were *possible* when it was compiled.  This is so code dynamically
   compiled *by* a code object knows whether to allow yield stmts.  In
   effect, this passes on the "from __future__ import generators" state
   in effect when the code block was compiled. */
#define CO_GENERATOR_ALLOWED    0x1000
#define CO_FUTURE_DIVISION    	0x2000

extern DL_IMPORT(PyTypeObject) PyCode_Type;

#define PyCode_Check(op) ((op)-&gt;ob_type == &amp;PyCode_Type)
#define PyCode_GetNumFree(op) (PyTuple_GET_SIZE((op)-&gt;co_freevars))

#define CO_MAXBLOCKS 20 /* Max static block nesting within a function */

/* Public interface */
struct _node; /* Declare the existence of this type */
DL_IMPORT(PyCodeObject *) PyNode_Compile(struct _node *, char *);
DL_IMPORT(PyCodeObject *) PyCode_New(
	int, int, int, int, PyObject *, PyObject *, PyObject *, PyObject *,
	PyObject *, PyObject *, PyObject *, PyObject *, int, PyObject *); 
        /* same as struct above */
DL_IMPORT(int) PyCode_Addr2Line(PyCodeObject *, int);

/* Future feature support */

typedef struct {
    int ff_found_docstring;
    int ff_last_lineno;
    int ff_features;
} PyFutureFeatures;

DL_IMPORT(PyFutureFeatures *) PyNode_Future(struct _node *, char *);
DL_IMPORT(PyCodeObject *) PyNode_CompileFlags(struct _node *, char *,
					      PyCompilerFlags *);

#define FUTURE_NESTED_SCOPES "nested_scopes"
#define FUTURE_GENERATORS "generators"
#define FUTURE_DIVISION "division"

/* for internal use only */
#define _PyCode_GETCODEPTR(co, pp) \
	((*(co)-&gt;co_code-&gt;ob_type-&gt;tp_as_buffer-&gt;bf_getreadbuffer) \
	 ((co)-&gt;co_code, 0, (void **)(pp)))

#ifdef __cplusplus
}
#endif
#endif /* !Py_COMPILE_H */
</t>
<t tx="T1062">/* Parse tree node interface */

#ifndef Py_NODE_H
#define Py_NODE_H
#ifdef __cplusplus
extern "C" {
#endif

typedef struct _node {
    short		n_type;
    char		*n_str;
    int			n_lineno;
    int			n_nchildren;
    struct _node	*n_child;
} node;

extern DL_IMPORT(node *) PyNode_New(int type);
extern DL_IMPORT(int) PyNode_AddChild(node *n, int type,
                                      char *str, int lineno);
extern DL_IMPORT(void) PyNode_Free(node *n);

/* Node access functions */
#define NCH(n)		((n)-&gt;n_nchildren)
#define CHILD(n, i)	(&amp;(n)-&gt;n_child[i])
#define TYPE(n)		((n)-&gt;n_type)
#define STR(n)		((n)-&gt;n_str)

/* Assert that the type of a node is what we expect */
#define REQ(n, type) assert(TYPE(n) == (type))

extern DL_IMPORT(void) PyNode_ListTree(node *);

#ifdef __cplusplus
}
#endif
#endif /* !Py_NODE_H */
</t>
<t tx="T1063">static PyCodeObject *
jcompile(node *n, char *filename, struct compiling *base,
	 PyCompilerFlags *flags)
{
	struct compiling sc;
	PyCodeObject *co;
	if (!com_init(&amp;sc, filename))
		return NULL;
	if (base) {
		sc.c_private = base-&gt;c_private;
		sc.c_symtable = base-&gt;c_symtable;
		/* c_symtable still points to parent's symbols */
		if (base-&gt;c_nested 
		    || (sc.c_symtable-&gt;st_cur-&gt;ste_type == TYPE_FUNCTION))
			sc.c_nested = 1;
		sc.c_flags |= base-&gt;c_flags &amp; PyCF_MASK;
	} else {
		sc.c_private = NULL;
		sc.c_future = PyNode_Future(n, filename);
		if (sc.c_future == NULL) {
			com_free(&amp;sc);
			return NULL;
		}
		if (flags) {
			int merged = sc.c_future-&gt;ff_features |
				flags-&gt;cf_flags;
			sc.c_future-&gt;ff_features = merged;
			flags-&gt;cf_flags = merged;
		}
		if (symtable_build(&amp;sc, n) &lt; 0) {
			com_free(&amp;sc);
			return NULL;
		}
	}
	co = NULL;
	if (symtable_load_symbols(&amp;sc) &lt; 0) {
		sc.c_errors++;
		goto exit;
	}
	compile_node(&amp;sc, n);
	com_done(&amp;sc);
	if (sc.c_errors == 0) {
		PyObject *consts, *names, *varnames, *filename, *name,
			*freevars, *cellvars;
		consts = PyList_AsTuple(sc.c_consts);
		names = PyList_AsTuple(sc.c_names);
		varnames = PyList_AsTuple(sc.c_varnames);
		cellvars = dict_keys_inorder(sc.c_cellvars, 0);
		freevars = dict_keys_inorder(sc.c_freevars,
					     PyTuple_GET_SIZE(cellvars));
		filename = PyString_InternFromString(sc.c_filename);
		name = PyString_InternFromString(sc.c_name);
		if (!PyErr_Occurred())
			co = PyCode_New(sc.c_argcount,
					sc.c_nlocals,
					sc.c_maxstacklevel,
					sc.c_flags,
					sc.c_code,
					consts,
					names,
					varnames,
					freevars,
					cellvars,
					filename,
					name,
					sc.c_firstlineno,
					sc.c_lnotab);
		Py_XDECREF(consts);
		Py_XDECREF(names);
		Py_XDECREF(varnames);
		Py_XDECREF(freevars);
		Py_XDECREF(cellvars);
		Py_XDECREF(filename);
		Py_XDECREF(name);
	}
	else if (!PyErr_Occurred()) {
		/* This could happen if someone called PyErr_Clear() after an
		   error was reported above.  That's not supposed to happen,
		   but I just plugged one case and I'm not sure there can't be
		   others.  In that case, raise SystemError so that at least
		   it gets reported instead dumping core. */
		PyErr_SetString(PyExc_SystemError, "lost syntax error");
	}
 exit:
	if (base == NULL) {
		PySymtable_Free(sc.c_symtable);
		sc.c_symtable = NULL;
	}
	com_free(&amp;sc);
	return co;
}
</t>
<t tx="T1064">static void
compile_node(struct compiling *c, node *n)
{
	com_addoparg(c, SET_LINENO, n-&gt;n_lineno);
	
	switch (TYPE(n)) {
	
	case single_input: /* One interactive command */
		/* NEWLINE | simple_stmt | compound_stmt NEWLINE */
		c-&gt;c_interactive++;
		n = CHILD(n, 0);
		if (TYPE(n) != NEWLINE)
			com_node(c, n);
		com_addoparg(c, LOAD_CONST, com_addconst(c, Py_None));
		com_push(c, 1);
		com_addbyte(c, RETURN_VALUE);
		com_pop(c, 1);
		c-&gt;c_interactive--;
		break;
	
	case file_input: /* A whole file, or built-in function exec() */
		com_file_input(c, n);
		com_addoparg(c, LOAD_CONST, com_addconst(c, Py_None));
		com_push(c, 1);
		com_addbyte(c, RETURN_VALUE);
		com_pop(c, 1);
		break;
	
	case eval_input: /* Built-in function input() */
		com_node(c, CHILD(n, 0));
		com_addbyte(c, RETURN_VALUE);
		com_pop(c, 1);
		break;
	
	case lambdef: /* anonymous function definition */
		compile_lambdef(c, n);
		break;

	case funcdef: /* A function definition */
		compile_funcdef(c, n);
		break;
	
	case classdef: /* A class definition */
		compile_classdef(c, n);
		break;
	
	default:
		com_error(c, PyExc_SystemError,
			  "compile_node: unexpected node type");
	}
}
</t>
<t tx="T1065">static void
com_file_input(struct compiling *c, node *n)
{
	int i;
	PyObject *doc;
	REQ(n, file_input); /* (NEWLINE | stmt)* ENDMARKER */
	doc = get_docstring(c, n);
	if (doc != NULL) {
		int i = com_addconst(c, doc);
		Py_DECREF(doc);
		com_addoparg(c, LOAD_CONST, i);
		com_push(c, 1);
		com_addop_name(c, STORE_NAME, "__doc__");
		com_pop(c, 1);
	}
	for (i = 0; i &lt; NCH(n); i++) {
		node *ch = CHILD(n, i);
		if (TYPE(ch) != ENDMARKER &amp;&amp; TYPE(ch) != NEWLINE)
			com_node(c, ch);
	}
}
</t>
<t tx="T1066">@language c
/* Compile an expression node to intermediate code */

/* XXX TO DO:
   XXX add __doc__ attribute == co_doc to code object attributes?
   XXX   (it's currently the first item of the co_const tuple)
   XXX Generate simple jump for break/return outside 'try...finally'
   XXX Allow 'continue' inside finally clause of try-finally
   XXX New opcode for loading the initial index for a for loop
   XXX other JAR tricks?
*/

&lt;&lt; compile #includes &gt;&gt;
&lt;&lt; compile declarations &gt;&gt;

@others
</t>
<t tx="T1067">#include "Python.h"

#include "node.h"
#include "token.h"
#include "graminit.h"
#include "compile.h"
#include "symtable.h"
#include "opcode.h"
#include "structmember.h"

#include &lt;ctype.h&gt;
</t>
<t tx="T1068">/* Three symbols from graminit.h are also defined in Python.h, with
   Py_ prefixes to their names.  Python.h can't include graminit.h
   (which defines too many confusing symbols), but we can check here
   that they haven't changed (which is very unlikely, but possible). */
#if Py_single_input != single_input
  #error "single_input has changed -- update Py_single_input in Python.h"
#endif
#if Py_file_input != file_input
  #error "file_input has changed -- update Py_file_input in Python.h"
#endif
#if Py_eval_input != eval_input
  #error "eval_input has changed -- update Py_eval_input in Python.h"
#endif

int Py_OptimizeFlag = 0;

#define OP_DELETE 0
#define OP_ASSIGN 1
#define OP_APPLY 2

#define VAR_LOAD 0
#define VAR_STORE 1
#define VAR_DELETE 2

#define DEL_CLOSURE_ERROR \
"can not delete variable '%.400s' referenced in nested scope"

#define DUPLICATE_ARGUMENT \
"duplicate argument '%s' in function definition"

#define ILLEGAL_DYNAMIC_SCOPE \
"%.100s: exec or 'import *' makes names ambiguous in nested scope"

#define GLOBAL_AFTER_ASSIGN \
"name '%.400s' is assigned to before global declaration"

#define GLOBAL_AFTER_USE \
"name '%.400s' is used prior to global declaration"

#define LOCAL_GLOBAL \
"name '%.400s' is a function parameter and declared global"

#define LATE_FUTURE \
"from __future__ imports must occur at the beginning of the file"

#define ASSIGN_DEBUG \
"can not assign to __debug__"

#define MANGLE_LEN 256

#define OFF(x) offsetof(PyCodeObject, x)

static PyMemberDef code_memberlist[] = {
	{"co_argcount",	T_INT,		OFF(co_argcount),	READONLY},
	{"co_nlocals",	T_INT,		OFF(co_nlocals),	READONLY},
	{"co_stacksize",T_INT,		OFF(co_stacksize),	READONLY},
	{"co_flags",	T_INT,		OFF(co_flags),		READONLY},
	{"co_code",	T_OBJECT,	OFF(co_code),		READONLY},
	{"co_consts",	T_OBJECT,	OFF(co_consts),		READONLY},
	{"co_names",	T_OBJECT,	OFF(co_names),		READONLY},
	{"co_varnames",	T_OBJECT,	OFF(co_varnames),	READONLY},
	{"co_freevars",	T_OBJECT,	OFF(co_freevars),	READONLY},
	{"co_cellvars",	T_OBJECT,	OFF(co_cellvars),	READONLY},
	{"co_filename",	T_OBJECT,	OFF(co_filename),	READONLY},
	{"co_name",	T_OBJECT,	OFF(co_name),		READONLY},
	{"co_firstlineno", T_INT,	OFF(co_firstlineno),	READONLY},
	{"co_lnotab",	T_OBJECT,	OFF(co_lnotab),		READONLY},
	{NULL}	/* Sentinel */
};
</t>
<t tx="T1069"></t>
<t tx="T1070">static void
code_dealloc(PyCodeObject *co)
{
	Py_XDECREF(co-&gt;co_code);
	Py_XDECREF(co-&gt;co_consts);
	Py_XDECREF(co-&gt;co_names);
	Py_XDECREF(co-&gt;co_varnames);
	Py_XDECREF(co-&gt;co_freevars);
	Py_XDECREF(co-&gt;co_cellvars);
	Py_XDECREF(co-&gt;co_filename);
	Py_XDECREF(co-&gt;co_name);
	Py_XDECREF(co-&gt;co_lnotab);
	PyObject_DEL(co);
}
</t>
<t tx="T1071">static PyObject *
code_repr(PyCodeObject *co)
{
	char buf[500];
	int lineno = -1;
	char *filename = "???";
	char *name = "???";

	if (co-&gt;co_firstlineno != 0)
		lineno = co-&gt;co_firstlineno;
	if (co-&gt;co_filename &amp;&amp; PyString_Check(co-&gt;co_filename))
		filename = PyString_AS_STRING(co-&gt;co_filename);
	if (co-&gt;co_name &amp;&amp; PyString_Check(co-&gt;co_name))
		name = PyString_AS_STRING(co-&gt;co_name);
	PyOS_snprintf(buf, sizeof(buf),
		      "&lt;code object %.100s at %p, file \"%.300s\", line %d&gt;",
		      name, co, filename, lineno);
	return PyString_FromString(buf);
}
</t>
<t tx="T1072">static int
code_compare(PyCodeObject *co, PyCodeObject *cp)
{
	int cmp;
	cmp = PyObject_Compare(co-&gt;co_name, cp-&gt;co_name);
	if (cmp) return cmp;
	cmp = co-&gt;co_argcount - cp-&gt;co_argcount;
	if (cmp) return cmp;
	cmp = co-&gt;co_nlocals - cp-&gt;co_nlocals;
	if (cmp) return cmp;
	cmp = co-&gt;co_flags - cp-&gt;co_flags;
	if (cmp) return cmp;
	cmp = PyObject_Compare(co-&gt;co_code, cp-&gt;co_code);
	if (cmp) return cmp;
	cmp = PyObject_Compare(co-&gt;co_consts, cp-&gt;co_consts);
	if (cmp) return cmp;
	cmp = PyObject_Compare(co-&gt;co_names, cp-&gt;co_names);
	if (cmp) return cmp;
	cmp = PyObject_Compare(co-&gt;co_varnames, cp-&gt;co_varnames);
	if (cmp) return cmp;
	cmp = PyObject_Compare(co-&gt;co_freevars, cp-&gt;co_freevars);
	if (cmp) return cmp;
	cmp = PyObject_Compare(co-&gt;co_cellvars, cp-&gt;co_cellvars);
	return cmp;
}
</t>
<t tx="T1073">static long
code_hash(PyCodeObject *co)
{
	long h, h0, h1, h2, h3, h4, h5, h6;
	h0 = PyObject_Hash(co-&gt;co_name);
	if (h0 == -1) return -1;
	h1 = PyObject_Hash(co-&gt;co_code);
	if (h1 == -1) return -1;
	h2 = PyObject_Hash(co-&gt;co_consts);
	if (h2 == -1) return -1;
	h3 = PyObject_Hash(co-&gt;co_names);
	if (h3 == -1) return -1;
	h4 = PyObject_Hash(co-&gt;co_varnames);
	if (h4 == -1) return -1;
	h5 = PyObject_Hash(co-&gt;co_freevars);
	if (h5 == -1) return -1;
	h6 = PyObject_Hash(co-&gt;co_cellvars);
	if (h6 == -1) return -1;
	h = h0 ^ h1 ^ h2 ^ h3 ^ h4 ^ h5 ^ h6 ^
		co-&gt;co_argcount ^ co-&gt;co_nlocals ^ co-&gt;co_flags;
	if (h == -1) h = -2;
	return h;
}
</t>
<t tx="T1074">@ XXX code objects need to participate in GC?
@c

PyTypeObject PyCode_Type = {
	PyObject_HEAD_INIT(&amp;PyType_Type)
	0,
	"code",
	sizeof(PyCodeObject),
	0,
	(destructor)code_dealloc, 	/* tp_dealloc */
	0,				/* tp_print */
	0, 				/* tp_getattr */
	0,				/* tp_setattr */
	(cmpfunc)code_compare, 		/* tp_compare */
	(reprfunc)code_repr,		/* tp_repr */
	0,				/* tp_as_number */
	0,				/* tp_as_sequence */
	0,				/* tp_as_mapping */
	(hashfunc)code_hash, 		/* tp_hash */
	0,				/* tp_call */
	0,				/* tp_str */
	PyObject_GenericGetAttr,	/* tp_getattro */
	0,				/* tp_setattro */
	0,				/* tp_as_buffer */
	Py_TPFLAGS_DEFAULT,		/* tp_flags */
	0,				/* tp_doc */
	0,				/* tp_traverse */
	0,				/* tp_clear */
	0,				/* tp_richcompare */
	0,				/* tp_weaklistoffset */
	0,				/* tp_iter */
	0,				/* tp_iternext */
	0,				/* tp_methods */
	code_memberlist,		/* tp_members */
	0,				/* tp_getset */
	0,				/* tp_base */
	0,				/* tp_dict */
	0,				/* tp_descr_get */
	0,				/* tp_descr_set */
	0,				/* tp_dictoffset */
	0,				/* tp_init */
	0,				/* tp_alloc */
	0,				/* tp_new */
};</t>
<t tx="T1075">#define NAME_CHARS \
	"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"

/* all_name_chars(s): true iff all chars in s are valid NAME_CHARS */

static int
all_name_chars(unsigned char *s)
{
	static char ok_name_char[256];
	static unsigned char *name_chars = (unsigned char *)NAME_CHARS;

	if (ok_name_char[*name_chars] == 0) {
		unsigned char *p;
		for (p = name_chars; *p; p++)
			ok_name_char[*p] = 1;
	}
	while (*s) {
		if (ok_name_char[*s++] == 0)
			return 0;
	}
	return 1;
}
</t>
<t tx="T1076">static int
intern_strings(PyObject *tuple)
{
	int i;

	for (i = PyTuple_GET_SIZE(tuple); --i &gt;= 0; ) {
		PyObject *v = PyTuple_GET_ITEM(tuple, i);
		if (v == NULL || !PyString_Check(v)) {
			Py_FatalError("non-string found in code slot");
			PyErr_BadInternalCall();
			return -1;
		}
		PyString_InternInPlace(&amp;PyTuple_GET_ITEM(tuple, i));
	}
	return 0;
}
</t>
<t tx="T1077">PyCodeObject *
PyCode_New(int argcount, int nlocals, int stacksize, int flags,
	   PyObject *code, PyObject *consts, PyObject *names,
	   PyObject *varnames, PyObject *freevars, PyObject *cellvars,
	   PyObject *filename, PyObject *name, int firstlineno,
	   PyObject *lnotab) 
{
	PyCodeObject *co;
	int i;
	/* Check argument types */
	if (argcount &lt; 0 || nlocals &lt; 0 ||
	    code == NULL ||
	    consts == NULL || !PyTuple_Check(consts) ||
	    names == NULL || !PyTuple_Check(names) ||
	    varnames == NULL || !PyTuple_Check(varnames) ||
	    freevars == NULL || !PyTuple_Check(freevars) ||
	    cellvars == NULL || !PyTuple_Check(cellvars) ||
	    name == NULL || !PyString_Check(name) ||
	    filename == NULL || !PyString_Check(filename) ||
	    lnotab == NULL || !PyString_Check(lnotab) ||
	    !PyObject_CheckReadBuffer(code)) {
		PyErr_BadInternalCall();
		return NULL;
	}
	intern_strings(names);
	intern_strings(varnames);
	if (freevars == NULL)
		freevars = PyTuple_New(0);
	intern_strings(freevars);
	if (cellvars == NULL)
		cellvars = PyTuple_New(0);
	intern_strings(cellvars);
	/* Intern selected string constants */
	for (i = PyTuple_Size(consts); --i &gt;= 0; ) {
		PyObject *v = PyTuple_GetItem(consts, i);
		if (!PyString_Check(v))
			continue;
		if (!all_name_chars((unsigned char *)PyString_AS_STRING(v)))
			continue;
		PyString_InternInPlace(&amp;PyTuple_GET_ITEM(consts, i));
	}
	co = PyObject_NEW(PyCodeObject, &amp;PyCode_Type);
	if (co != NULL) {
		co-&gt;co_argcount = argcount;
		co-&gt;co_nlocals = nlocals;
		co-&gt;co_stacksize = stacksize;
		co-&gt;co_flags = flags;
		Py_INCREF(code);
		co-&gt;co_code = code;
		Py_INCREF(consts);
		co-&gt;co_consts = consts;
		Py_INCREF(names);
		co-&gt;co_names = names;
		Py_INCREF(varnames);
		co-&gt;co_varnames = varnames;
		Py_INCREF(freevars);
		co-&gt;co_freevars = freevars;
		Py_INCREF(cellvars);
		co-&gt;co_cellvars = cellvars;
		Py_INCREF(filename);
		co-&gt;co_filename = filename;
		Py_INCREF(name);
		co-&gt;co_name = name;
		co-&gt;co_firstlineno = firstlineno;
		Py_INCREF(lnotab);
		co-&gt;co_lnotab = lnotab;
	}
	return co;
}
</t>
<t tx="T1078">@ The compiler uses two passes to generate bytecodes.  The first pass
builds the symbol table.  The second pass generates the bytecode.

The first pass uses a single symtable struct.  The second pass uses
a compiling struct for each code block.  The compiling structs
share a reference to the symtable.

The two passes communicate via symtable_load_symbols() and via
is_local() and is_global().  The former initializes several slots
in the compiling struct: c_varnames, c_locals, c_nlocals,
c_argcount, c_globals, and c_flags.</t>
<t tx="T1079">@ All about c_lnotab.

c_lnotab is an array of unsigned bytes disguised as a Python string.  In -O
mode, SET_LINENO opcodes aren't generated, and bytecode offsets are mapped
to source code line #s (when needed for tracebacks) via c_lnotab instead.

The array is conceptually a list of
    (bytecode offset increment, line number increment)
pairs.  The details are important and delicate, best illustrated by example:

    byte code offset    source code line number
        0		    1
        6		    2
       50		    7
      350                 307
      361                 308

The first trick is that these numbers aren't stored, only the increments
from one row to the next (this doesn't really work, but it's a start):

    0, 1,  6, 1,  44, 5,  300, 300,  11, 1

The second trick is that an unsigned byte can't hold negative values, or
values larger than 255, so (a) there's a deep assumption that byte code
offsets and their corresponding line #s both increase monotonically, and (b)
if at least one column jumps by more than 255 from one row to the next, more
than one pair is written to the table. In case #b, there's no way to know
from looking at the table later how many were written.  That's the delicate
part.  A user of c_lnotab desiring to find the source line number
corresponding to a bytecode address A should do something like this

    lineno = addr = 0
    for addr_incr, line_incr in c_lnotab:
        addr += addr_incr
        if addr &gt; A:
            return lineno
        lineno += line_incr

In order for this to work, when the addr field increments by more than 255,
the line # increment in each pair generated must be 0 until the remaining addr
increment is &lt; 256.  So, in the example above, com_set_lineno should not (as
was actually done until 2.2) expand 300, 300 to 255, 255,  45, 45, but to
255, 0,  45, 255,  0, 45.</t>
<t tx="T1080">struct compiling {
	PyObject *c_code;	/* string */
	PyObject *c_consts;	/* list of objects */
	PyObject *c_const_dict; /* inverse of c_consts */
	PyObject *c_names;	/* list of strings (names) */
	PyObject *c_name_dict;  /* inverse of c_names */
	PyObject *c_globals;	/* dictionary (value=None) */
	PyObject *c_locals;	/* dictionary (value=localID) */
	PyObject *c_varnames;	/* list (inverse of c_locals) */
	PyObject *c_freevars;	/* dictionary (value=None) */
	PyObject *c_cellvars;	/* list */
	int c_nlocals;		/* index of next local */
	int c_argcount;		/* number of top-level arguments */
	int c_flags;		/* same as co_flags */
	int c_nexti;		/* index into c_code */
	int c_errors;		/* counts errors occurred */
	int c_infunction;	/* set when compiling a function */
	int c_interactive;	/* generating code for interactive command */
	int c_loops;		/* counts nested loops */
	int c_begin;		/* begin of current loop, for 'continue' */
	int c_block[CO_MAXBLOCKS]; /* stack of block types */
	int c_nblocks;		/* current block stack level */
	char *c_filename;	/* filename of current node */
	char *c_name;		/* name of object (e.g. function) */
	int c_lineno;		/* Current line number */
	int c_stacklevel;	/* Current stack level */
	int c_maxstacklevel;	/* Maximum stack level */
	int c_firstlineno;
	PyObject *c_lnotab;	/* Table mapping address to line number */
	int c_last_addr, c_last_line, c_lnotab_next;
	char *c_private;	/* for private name mangling */
	int c_tmpname;		/* temporary local name counter */
	int c_nested;		/* Is block nested funcdef or lamdef? */
	int c_closure;		/* Is nested w/freevars? */
	struct symtable *c_symtable; /* pointer to module symbol table */
        PyFutureFeatures *c_future; /* pointer to module's __future__ */
};</t>
<t tx="T1081">static int
is_free(int v)
{
	if ((v &amp; (USE | DEF_FREE))
	    &amp;&amp; !(v &amp; (DEF_LOCAL | DEF_PARAM | DEF_GLOBAL)))
		return 1;
	if (v &amp; DEF_FREE_CLASS)
		return 1;
	return 0;
}
</t>
<t tx="T1082">static void
com_error(struct compiling *c, PyObject *exc, char *msg)
{
	PyObject *t = NULL, *v = NULL, *w = NULL, *line = NULL;

	if (c == NULL) {
		/* Error occurred via symtable call to
		   is_constant_false */
		PyErr_SetString(exc, msg);
		return;
	}
	c-&gt;c_errors++;
	if (c-&gt;c_lineno &lt; 1 || c-&gt;c_interactive) { 
		/* Unknown line number or interactive input */
		PyErr_SetString(exc, msg);
		return;
	}
	v = PyString_FromString(msg);
	if (v == NULL)
		return; /* MemoryError, too bad */

	line = PyErr_ProgramText(c-&gt;c_filename, c-&gt;c_lineno);
	if (line == NULL) {
		Py_INCREF(Py_None);
		line = Py_None;
	}
	if (exc == PyExc_SyntaxError) {
		t = Py_BuildValue("(ziOO)", c-&gt;c_filename, c-&gt;c_lineno,
				  Py_None, line);
		if (t == NULL)
			goto exit;
		w = Py_BuildValue("(OO)", v, t);
		if (w == NULL)
			goto exit;
		PyErr_SetObject(exc, w);
	} else {
		/* Make sure additional exceptions are printed with
		   file and line, also. */
		PyErr_SetObject(exc, v);
		PyErr_SyntaxLocation(c-&gt;c_filename, c-&gt;c_lineno);
	}
 exit:
	Py_XDECREF(t);
	Py_XDECREF(v);
	Py_XDECREF(w);
	Py_XDECREF(line);
}
</t>
<t tx="T1083"></t>
<t tx="T1084">@ Interface to the block stack
@c

static void
block_push(struct compiling *c, int type)
{
	if (c-&gt;c_nblocks &gt;= CO_MAXBLOCKS) {
		com_error(c, PyExc_SystemError,
			  "too many statically nested blocks");
	}
	else {
		c-&gt;c_block[c-&gt;c_nblocks++] = type;
	}
}
</t>
<t tx="T1085">static void
block_pop(struct compiling *c, int type)
{
	if (c-&gt;c_nblocks &gt; 0)
		c-&gt;c_nblocks--;
	if (c-&gt;c_block[c-&gt;c_nblocks] != type &amp;&amp; c-&gt;c_errors == 0) {
		com_error(c, PyExc_SystemError, "bad block pop");
	}
}
</t>
<t tx="T1086">@ Prototype forward declarations
@c

static int com_init(struct compiling *, char *);
static void com_free(struct compiling *);
static void com_push(struct compiling *, int);
static void com_pop(struct compiling *, int);
static void com_done(struct compiling *);
static void com_node(struct compiling *, node *);
static void com_factor(struct compiling *, node *);
static void com_addbyte(struct compiling *, int);
static void com_addint(struct compiling *, int);
static void com_addoparg(struct compiling *, int, int);
static void com_addfwref(struct compiling *, int, int *);
static void com_backpatch(struct compiling *, int);
static int com_add(struct compiling *, PyObject *, PyObject *, PyObject *);
static int com_addconst(struct compiling *, PyObject *);
static int com_addname(struct compiling *, PyObject *);
static void com_addopname(struct compiling *, int, node *);
static void com_list(struct compiling *, node *, int);
static void com_list_iter(struct compiling *, node *, node *, char *);
static int com_argdefs(struct compiling *, node *);
static void com_assign(struct compiling *, node *, int, node *);
static void com_assign_name(struct compiling *, node *, int);
static PyCodeObject *icompile(node *, struct compiling *);
static PyCodeObject *jcompile(node *, char *, struct compiling *,
			      PyCompilerFlags *);
static PyObject *parsestrplus(struct compiling*, node *);
static PyObject *parsestr(struct compiling *, char *);
static node *get_rawdocstring(node *);

static int get_ref_type(struct compiling *, char *);

/* symtable operations */
static int symtable_build(struct compiling *, node *);
static int symtable_load_symbols(struct compiling *);
static struct symtable *symtable_init(void);
static void symtable_enter_scope(struct symtable *, char *, int, int);
static int symtable_exit_scope(struct symtable *);
static int symtable_add_def(struct symtable *, char *, int);
static int symtable_add_def_o(struct symtable *, PyObject *, PyObject *, int);

static void symtable_node(struct symtable *, node *);
static void symtable_funcdef(struct symtable *, node *);
static void symtable_default_args(struct symtable *, node *);
static void symtable_params(struct symtable *, node *);
static void symtable_params_fplist(struct symtable *, node *n);
static void symtable_global(struct symtable *, node *);
static void symtable_import(struct symtable *, node *);
static void symtable_assign(struct symtable *, node *, int);
static void symtable_list_comprehension(struct symtable *, node *);

static int symtable_update_free_vars(struct symtable *);
static int symtable_undo_free(struct symtable *, PyObject *, PyObject *);
static int symtable_check_global(struct symtable *, PyObject *, PyObject *);</t>
<t tx="T1087">/* helper */
static void
do_pad(int pad)
{
	int i;
	for (i = 0; i &lt; pad; ++i)
		fprintf(stderr, "  ");
}
</t>
<t tx="T1088">static void
dump(node *n, int pad, int depth)
{
	int i;
	if (depth == 0)
	    return;
	do_pad(pad);
	fprintf(stderr, "%d: %s\n", TYPE(n), STR(n));
	if (depth &gt; 0)
	    depth--;
	for (i = 0; i &lt; NCH(n); ++i)
		dump(CHILD(n, i), pad + 1, depth);
}
</t>
<t tx="T1089"></t>
<t tx="T1090"></t>
<t tx="T1091">#define DUMP(N) dump(N, 0, -1)

static int
com_init(struct compiling *c, char *filename)
{
	memset((void *)c, '\0', sizeof(struct compiling));
	if ((c-&gt;c_code = PyString_FromStringAndSize((char *)NULL,
						    1000)) == NULL)
		goto fail;
	if ((c-&gt;c_consts = PyList_New(0)) == NULL)
		goto fail;
	if ((c-&gt;c_const_dict = PyDict_New()) == NULL)
		goto fail;
	if ((c-&gt;c_names = PyList_New(0)) == NULL)
		goto fail;
	if ((c-&gt;c_name_dict = PyDict_New()) == NULL)
		goto fail;
	if ((c-&gt;c_locals = PyDict_New()) == NULL)
		goto fail;
	if ((c-&gt;c_lnotab = PyString_FromStringAndSize((char *)NULL,
						      1000)) == NULL)
		goto fail;
	c-&gt;c_globals = NULL;
	c-&gt;c_varnames = NULL;
	c-&gt;c_freevars = NULL;
	c-&gt;c_cellvars = NULL;
	c-&gt;c_nlocals = 0;
	c-&gt;c_argcount = 0;
	c-&gt;c_flags = 0;
	c-&gt;c_nexti = 0;
	c-&gt;c_errors = 0;
	c-&gt;c_infunction = 0;
	c-&gt;c_interactive = 0;
	c-&gt;c_loops = 0;
	c-&gt;c_begin = 0;
	c-&gt;c_nblocks = 0;
	c-&gt;c_filename = filename;
	c-&gt;c_name = "?";
	c-&gt;c_lineno = 0;
	c-&gt;c_stacklevel = 0;
	c-&gt;c_maxstacklevel = 0;
	c-&gt;c_firstlineno = 0;
	c-&gt;c_last_addr = 0;
	c-&gt;c_last_line = 0;
	c-&gt;c_lnotab_next = 0;
	c-&gt;c_tmpname = 0;
	c-&gt;c_nested = 0;
	c-&gt;c_closure = 0;
	c-&gt;c_symtable = NULL;
	return 1;
	
  fail:
	com_free(c);
 	return 0;
}
</t>
<t tx="T1092">static void
com_free(struct compiling *c)
{
	Py_XDECREF(c-&gt;c_code);
	Py_XDECREF(c-&gt;c_consts);
	Py_XDECREF(c-&gt;c_const_dict);
	Py_XDECREF(c-&gt;c_names);
	Py_XDECREF(c-&gt;c_name_dict);
	Py_XDECREF(c-&gt;c_globals);
	Py_XDECREF(c-&gt;c_locals);
	Py_XDECREF(c-&gt;c_varnames);
	Py_XDECREF(c-&gt;c_freevars);
	Py_XDECREF(c-&gt;c_cellvars);
	Py_XDECREF(c-&gt;c_lnotab);
	if (c-&gt;c_future)
		PyMem_Free((void *)c-&gt;c_future);
}
</t>
<t tx="T1093">static void
com_push(struct compiling *c, int n)
{
	c-&gt;c_stacklevel += n;
	if (c-&gt;c_stacklevel &gt; c-&gt;c_maxstacklevel) {
		c-&gt;c_maxstacklevel = c-&gt;c_stacklevel;
		/*
		fprintf(stderr, "%s:%s:%d max stack nexti=%d level=%d n=%d\n",
			c-&gt;c_filename, c-&gt;c_name, c-&gt;c_lineno,
			c-&gt;c_nexti, c-&gt;c_stacklevel, n);
		*/
	}
}
</t>
<t tx="T1094">static void
com_pop(struct compiling *c, int n)
{
	if (c-&gt;c_stacklevel &lt; n) 
		c-&gt;c_stacklevel = 0;
	else
		c-&gt;c_stacklevel -= n;
}
</t>
<t tx="T1095">static void
com_done(struct compiling *c)
{
	if (c-&gt;c_code != NULL)
		_PyString_Resize(&amp;c-&gt;c_code, c-&gt;c_nexti);
	if (c-&gt;c_lnotab != NULL)
		_PyString_Resize(&amp;c-&gt;c_lnotab, c-&gt;c_lnotab_next);
}
</t>
<t tx="T1096"></t>
<t tx="T1097">static int
com_check_size(PyObject **s, int offset)
{
	int len = PyString_GET_SIZE(*s);
	if (offset &gt;= len) 
		return _PyString_Resize(s, len * 2);
	return 0;
}
</t>
<t tx="T1098">static void
com_addbyte(struct compiling *c, int byte)
{
	/*fprintf(stderr, "%3d: %3d\n", c-&gt;c_nexti, byte);*/
	assert(byte &gt;= 0 &amp;&amp; byte &lt;= 255);
	assert(c-&gt;c_code);
	if (com_check_size(&amp;c-&gt;c_code, c-&gt;c_nexti)) {
		c-&gt;c_errors++;
		return;
	}
	PyString_AS_STRING(c-&gt;c_code)[c-&gt;c_nexti++] = byte;
}
</t>
<t tx="T1099">static void
com_addint(struct compiling *c, int x)
{
	com_addbyte(c, x &amp; 0xff);
	com_addbyte(c, x &gt;&gt; 8); /* XXX x should be positive */
}
</t>
<t tx="T1100">static void
com_add_lnotab(struct compiling *c, int addr, int line)
{
	char *p;
	if (c-&gt;c_lnotab == NULL)
		return;
	if (com_check_size(&amp;c-&gt;c_lnotab, c-&gt;c_lnotab_next + 2)) {
		c-&gt;c_errors++;
		return;
	}
	p = PyString_AS_STRING(c-&gt;c_lnotab) + c-&gt;c_lnotab_next;
	*p++ = addr;
	*p++ = line;
	c-&gt;c_lnotab_next += 2;
}
</t>
<t tx="T1101">static void
com_set_lineno(struct compiling *c, int lineno)
{
	c-&gt;c_lineno = lineno;
	if (c-&gt;c_firstlineno == 0) {
		c-&gt;c_firstlineno = c-&gt;c_last_line = lineno;
	}
	else {
		int incr_addr = c-&gt;c_nexti - c-&gt;c_last_addr;
		int incr_line = lineno - c-&gt;c_last_line;
		while (incr_addr &gt; 255) {
			com_add_lnotab(c, 255, 0);
			incr_addr -= 255;
		}
		while (incr_line &gt; 255) {
			com_add_lnotab(c, incr_addr, 255);
			incr_line -=255;
			incr_addr = 0;
		}
		if (incr_addr &gt; 0 || incr_line &gt; 0)
			com_add_lnotab(c, incr_addr, incr_line);
		c-&gt;c_last_addr = c-&gt;c_nexti;
		c-&gt;c_last_line = lineno;
	}
}
</t>
<t tx="T1102">static void
com_addoparg(struct compiling *c, int op, int arg)
{
	int extended_arg = arg &gt;&gt; 16;
	if (op == SET_LINENO) {
		com_set_lineno(c, arg);
		if (Py_OptimizeFlag)
			return;
	}
	if (extended_arg){
		com_addbyte(c, EXTENDED_ARG);
		com_addint(c, extended_arg);
		arg &amp;= 0xffff;
	}
	com_addbyte(c, op);
	com_addint(c, arg);
}
</t>
<t tx="T1103">static void
com_addfwref(struct compiling *c, int op, int *p_anchor)
{
	/* Compile a forward reference for backpatching */
	int here;
	int anchor;
	com_addbyte(c, op);
	here = c-&gt;c_nexti;
	anchor = *p_anchor;
	*p_anchor = here;
	com_addint(c, anchor == 0 ? 0 : here - anchor);
}
</t>
<t tx="T1104">static void
com_backpatch(struct compiling *c, int anchor)
{
	unsigned char *code = (unsigned char *) PyString_AS_STRING(c-&gt;c_code);
	int target = c-&gt;c_nexti;
	int dist;
	int prev;
	for (;;) {
		/* Make the JUMP instruction at anchor point to target */
		prev = code[anchor] + (code[anchor+1] &lt;&lt; 8);
		dist = target - (anchor+2);
		code[anchor] = dist &amp; 0xff;
		dist &gt;&gt;= 8;
		code[anchor+1] = dist;
		dist &gt;&gt;= 8;
		if (dist) {
			com_error(c, PyExc_SystemError,
				  "com_backpatch: offset too large");
			break;
		}
		if (!prev)
			break;
		anchor -= prev;
	}
}
</t>
<t tx="T1105">@ Handle literals and names uniformly
@c

static int
com_add(struct compiling *c, PyObject *list, PyObject *dict, PyObject *v)
{
	PyObject *w, *t, *np=NULL;
	long n;
	
	t = Py_BuildValue("(OO)", v, v-&gt;ob_type);
	if (t == NULL)
	    goto fail;
	w = PyDict_GetItem(dict, t);
	if (w != NULL) {
		n = PyInt_AsLong(w);
	} else {
		n = PyList_Size(list);
		np = PyInt_FromLong(n);
		if (np == NULL)
		    goto fail;
		if (PyList_Append(list, v) != 0)
		    goto fail;
		if (PyDict_SetItem(dict, t, np) != 0)
		    goto fail;
		Py_DECREF(np);
	}
	Py_DECREF(t);
	return n;
  fail:
	Py_XDECREF(np);
	Py_XDECREF(t);
	c-&gt;c_errors++;
	return 0;
}
</t>
<t tx="T1106">static int
com_addconst(struct compiling *c, PyObject *v)
{
	return com_add(c, c-&gt;c_consts, c-&gt;c_const_dict, v);
}
</t>
<t tx="T1107">static int
com_addname(struct compiling *c, PyObject *v)
{
	return com_add(c, c-&gt;c_names, c-&gt;c_name_dict, v);
}
</t>
<t tx="T1108">static int
mangle(char *p, char *name, char *buffer, size_t maxlen)
{
	/* Name mangling: __private becomes _classname__private.
	   This is independent from how the name is used. */
	size_t nlen, plen;
	if (p == NULL || name == NULL || name[0] != '_' || name[1] != '_')
		return 0;
	nlen = strlen(name);
	if (nlen+2 &gt;= maxlen)
		return 0; /* Don't mangle __extremely_long_names */
	if (name[nlen-1] == '_' &amp;&amp; name[nlen-2] == '_')
		return 0; /* Don't mangle __whatever__ */
	/* Strip leading underscores from class name */
	while (*p == '_')
		p++;
	if (*p == '\0')
		return 0; /* Don't mangle if class is just underscores */
	plen = strlen(p);
	if (plen + nlen &gt;= maxlen)
		plen = maxlen-nlen-2; /* Truncate class name if too long */
	/* buffer = "_" + p[:plen] + name # i.e. 1+plen+nlen bytes */
	buffer[0] = '_';
	strncpy(buffer+1, p, plen);
	strcpy(buffer+1+plen, name);
	return 1;
}
</t>
<t tx="T1109">static void
com_addop_name(struct compiling *c, int op, char *name)
{
	PyObject *v;
	int i;
	char buffer[MANGLE_LEN];

	if (mangle(c-&gt;c_private, name, buffer, sizeof(buffer)))
		name = buffer;
	if (name == NULL || (v = PyString_InternFromString(name)) == NULL) {
		c-&gt;c_errors++;
		i = 255;
	}
	else {
		i = com_addname(c, v);
		Py_DECREF(v);
	}
	com_addoparg(c, op, i);
}
</t>
<t tx="T1110">#define NAME_LOCAL 0
#define NAME_GLOBAL 1
#define NAME_DEFAULT 2
#define NAME_CLOSURE 3

static int
com_lookup_arg(PyObject *dict, PyObject *name)
{
	PyObject *v = PyDict_GetItem(dict, name);
	if (v == NULL)
		return -1;
	else
		return PyInt_AS_LONG(v);
}
</t>
<t tx="T1111">static void
com_addop_varname(struct compiling *c, int kind, char *name)
{
	PyObject *v;
	int i, reftype;
	int scope = NAME_DEFAULT;
	int op = STOP_CODE;
	char buffer[MANGLE_LEN];

	if (mangle(c-&gt;c_private, name, buffer, sizeof(buffer)))
		name = buffer;
	if (name == NULL || (v = PyString_InternFromString(name)) == NULL) {
		c-&gt;c_errors++;
		i = 255;
		goto done;
	}

	reftype = get_ref_type(c, name);
	switch (reftype) {
	case LOCAL:
		if (c-&gt;c_symtable-&gt;st_cur-&gt;ste_type == TYPE_FUNCTION)
			scope = NAME_LOCAL;
		break;
	case GLOBAL_EXPLICIT:
		scope = NAME_GLOBAL;
		break;
	case GLOBAL_IMPLICIT:
		if (c-&gt;c_flags &amp; CO_OPTIMIZED)
			scope = NAME_GLOBAL;
		break;
	case FREE:
	case CELL:
		scope = NAME_CLOSURE;
		break;
	}

	i = com_addname(c, v);
	if (scope == NAME_LOCAL)
		i = com_lookup_arg(c-&gt;c_locals, v);
	else if (reftype == FREE)
		i = com_lookup_arg(c-&gt;c_freevars, v);
	else if (reftype == CELL)
		i = com_lookup_arg(c-&gt;c_cellvars, v);
	if (i == -1) {
		c-&gt;c_errors++; /* XXX no exception set */
		i = 255;
		goto done;
	}
	Py_DECREF(v);

	switch (kind) {
	case VAR_LOAD:
		switch (scope) {
		case NAME_LOCAL:
			op = LOAD_FAST;
			break;
		case NAME_GLOBAL:
			op = LOAD_GLOBAL;
			break;
		case NAME_DEFAULT:
			op = LOAD_NAME;
			break;
		case NAME_CLOSURE:
			op = LOAD_DEREF;
			break;
		}
		break;
	case VAR_STORE:
		switch (scope) {
		case NAME_LOCAL:
			op = STORE_FAST;
			break;
		case NAME_GLOBAL:
			op = STORE_GLOBAL;
			break;
		case NAME_DEFAULT:
			op = STORE_NAME;
			break;
		case NAME_CLOSURE:
			op = STORE_DEREF;
			break;
		}
		break;
	case VAR_DELETE:
		switch (scope) {
		case NAME_LOCAL:
			op = DELETE_FAST;
			break;
		case NAME_GLOBAL:
			op = DELETE_GLOBAL;
			break;
		case NAME_DEFAULT:
			op = DELETE_NAME;
			break;
		case NAME_CLOSURE: {
			char buf[500];
			PyOS_snprintf(buf, sizeof(buf),
				      DEL_CLOSURE_ERROR, name);
			com_error(c, PyExc_SyntaxError, buf);
			i = 255;
			break;
		}
		}
		break;
	}
done:
	com_addoparg(c, op, i);
}
</t>
<t tx="T1112">static void
com_addopname(struct compiling *c, int op, node *n)
{
	char *name;
	char buffer[1000];
	/* XXX it is possible to write this code without the 1000
	   chars on the total length of dotted names, I just can't be
	   bothered right now */
	if (TYPE(n) == STAR)
		name = "*";
	else if (TYPE(n) == dotted_name) {
		char *p = buffer;
		int i;
		name = buffer;
		for (i = 0; i &lt; NCH(n); i += 2) {
			char *s = STR(CHILD(n, i));
			if (p + strlen(s) &gt; buffer + (sizeof buffer) - 2) {
				com_error(c, PyExc_MemoryError,
					  "dotted_name too long");
				name = NULL;
				break;
			}
			if (p != buffer)
				*p++ = '.';
			strcpy(p, s);
			p = strchr(p, '\0');
		}
	}
	else {
		REQ(n, NAME);
		name = STR(n);
	}
	com_addop_name(c, op, name);
}
</t>
<t tx="T1113"></t>
<t tx="T1114">static PyObject *
parsenumber(struct compiling *co, char *s)
{
	char *end;
	long x;
	double dx;
#ifndef WITHOUT_COMPLEX
	Py_complex c;
	int imflag;
#endif

	errno = 0;
	end = s + strlen(s) - 1;
#ifndef WITHOUT_COMPLEX
	imflag = *end == 'j' || *end == 'J';
#endif
	if (*end == 'l' || *end == 'L')
		return PyLong_FromString(s, (char **)0, 0);
	if (s[0] == '0')
		x = (long) PyOS_strtoul(s, &amp;end, 0);
	else
		x = PyOS_strtol(s, &amp;end, 0);
	if (*end == '\0') {
		if (errno != 0)
			return PyLong_FromString(s, (char **)0, 0);
		return PyInt_FromLong(x);
	}
	/* XXX Huge floats may silently fail */
#ifndef WITHOUT_COMPLEX
	if (imflag) {
		c.real = 0.;
		PyFPE_START_PROTECT("atof", return 0)
		c.imag = atof(s);
		PyFPE_END_PROTECT(c)
		return PyComplex_FromCComplex(c);
	}
	else
#endif
	{
		PyFPE_START_PROTECT("atof", return 0)
		dx = atof(s);
		PyFPE_END_PROTECT(dx)
		return PyFloat_FromDouble(dx);
	}
}
</t>
<t tx="T1115">static PyObject *
parsestr(struct compiling *com, char *s)
{
	PyObject *v;
	size_t len;
	char *buf;
	char *p;
	char *end;
	int c;
	int first = *s;
	int quote = first;
	int rawmode = 0;
#ifdef Py_USING_UNICODE
	int unicode = 0;
#endif
	if (isalpha(quote) || quote == '_') {
		if (quote == 'u' || quote == 'U') {
#ifdef Py_USING_UNICODE
			quote = *++s;
			unicode = 1;
#else
			com_error(com, PyExc_SyntaxError,
				  "Unicode literals not supported in this Python");
			return NULL;
#endif
		}
		if (quote == 'r' || quote == 'R') {
			quote = *++s;
			rawmode = 1;
		}
	}
	if (quote != '\'' &amp;&amp; quote != '\"') {
		PyErr_BadInternalCall();
		return NULL;
	}
	s++;
	len = strlen(s);
	if (len &gt; INT_MAX) {
		com_error(com, PyExc_OverflowError, 
			  "string to parse is too long");
		return NULL;
	}
	if (s[--len] != quote) {
		PyErr_BadInternalCall();
		return NULL;
	}
	if (len &gt;= 4 &amp;&amp; s[0] == quote &amp;&amp; s[1] == quote) {
		s += 2;
		len -= 2;
		if (s[--len] != quote || s[--len] != quote) {
			PyErr_BadInternalCall();
			return NULL;
		}
	}
#ifdef Py_USING_UNICODE
	if (unicode || Py_UnicodeFlag) {
		if (rawmode)
			v = PyUnicode_DecodeRawUnicodeEscape(
				 s, len, NULL);
		else
			v = PyUnicode_DecodeUnicodeEscape(
				s, len, NULL);
		if (v == NULL)
			PyErr_SyntaxLocation(com-&gt;c_filename, com-&gt;c_lineno);
		return v;
			
	}
#endif
	if (rawmode || strchr(s, '\\') == NULL)
		return PyString_FromStringAndSize(s, len);
	v = PyString_FromStringAndSize((char *)NULL, len);
	if (v == NULL)
		return NULL;
	p = buf = PyString_AsString(v);
	end = s + len;
	while (s &lt; end) {
		if (*s != '\\') {
			*p++ = *s++;
			continue;
		}
		s++;
		switch (*s++) {
		/* XXX This assumes ASCII! */
		case '\n': break;
		case '\\': *p++ = '\\'; break;
		case '\'': *p++ = '\''; break;
		case '\"': *p++ = '\"'; break;
		case 'b': *p++ = '\b'; break;
		case 'f': *p++ = '\014'; break; /* FF */
		case 't': *p++ = '\t'; break;
		case 'n': *p++ = '\n'; break;
		case 'r': *p++ = '\r'; break;
		case 'v': *p++ = '\013'; break; /* VT */
		case 'a': *p++ = '\007'; break; /* BEL, not classic C */
		case '0': case '1': case '2': case '3':
		case '4': case '5': case '6': case '7':
			c = s[-1] - '0';
			if ('0' &lt;= *s &amp;&amp; *s &lt;= '7') {
				c = (c&lt;&lt;3) + *s++ - '0';
				if ('0' &lt;= *s &amp;&amp; *s &lt;= '7')
					c = (c&lt;&lt;3) + *s++ - '0';
			}
			*p++ = c;
			break;
		case 'x':
			if (isxdigit(Py_CHARMASK(s[0])) 
			    &amp;&amp; isxdigit(Py_CHARMASK(s[1]))) {
				unsigned int x = 0;
				c = Py_CHARMASK(*s);
				s++;
				if (isdigit(c))
					x = c - '0';
				else if (islower(c))
					x = 10 + c - 'a';
				else
					x = 10 + c - 'A';
				x = x &lt;&lt; 4;
				c = Py_CHARMASK(*s);
				s++;
				if (isdigit(c))
					x += c - '0';
				else if (islower(c))
					x += 10 + c - 'a';
				else
					x += 10 + c - 'A';
				*p++ = x;
				break;
			}
			Py_DECREF(v);
			com_error(com, PyExc_ValueError, 
				  "invalid \\x escape");
			return NULL;
		default:
			*p++ = '\\';
			*p++ = s[-1];
			break;
		}
	}
	_PyString_Resize(&amp;v, (int)(p - buf));
	return v;
}
</t>
<t tx="T1116">static PyObject *
parsestrplus(struct compiling* c, node *n)
{
	PyObject *v;
	int i;
	REQ(CHILD(n, 0), STRING);
	if ((v = parsestr(c, STR(CHILD(n, 0)))) != NULL) {
		/* String literal concatenation */
		for (i = 1; i &lt; NCH(n); i++) {
		    PyObject *s;
		    s = parsestr(c, STR(CHILD(n, i)));
		    if (s == NULL)
			goto onError;
		    if (PyString_Check(v) &amp;&amp; PyString_Check(s)) {
			PyString_ConcatAndDel(&amp;v, s);
			if (v == NULL)
			    goto onError;
		    }
#ifdef Py_USING_UNICODE
		    else {
			PyObject *temp;
			temp = PyUnicode_Concat(v, s);
			Py_DECREF(s);
			if (temp == NULL)
			    goto onError;
			Py_DECREF(v);
			v = temp;
		    }
#endif
		}
	}
	return v;

 onError:
	Py_XDECREF(v);
	return NULL;
}
</t>
<t tx="T1117">static void
com_list_for(struct compiling *c, node *n, node *e, char *t)
{
	int anchor = 0;
	int save_begin = c-&gt;c_begin;

	/* list_iter: for v in expr [list_iter] */
	com_node(c, CHILD(n, 3)); /* expr */
	com_addbyte(c, GET_ITER);
	c-&gt;c_begin = c-&gt;c_nexti;
	com_addoparg(c, SET_LINENO, n-&gt;n_lineno);
	com_addfwref(c, FOR_ITER, &amp;anchor);
	com_push(c, 1);
	com_assign(c, CHILD(n, 1), OP_ASSIGN, NULL);
	c-&gt;c_loops++;
	com_list_iter(c, n, e, t);
	c-&gt;c_loops--;
	com_addoparg(c, JUMP_ABSOLUTE, c-&gt;c_begin);
	c-&gt;c_begin = save_begin;
	com_backpatch(c, anchor);
	com_pop(c, 1); /* FOR_ITER has popped this */
}</t>
<t tx="T1118">static void
com_list_if(struct compiling *c, node *n, node *e, char *t)
{
	int anchor = 0;
	int a = 0;
	/* list_iter: 'if' test [list_iter] */
	com_addoparg(c, SET_LINENO, n-&gt;n_lineno);
	com_node(c, CHILD(n, 1));
	com_addfwref(c, JUMP_IF_FALSE, &amp;a);
	com_addbyte(c, POP_TOP);
	com_pop(c, 1);
	com_list_iter(c, n, e, t);
	com_addfwref(c, JUMP_FORWARD, &amp;anchor);
	com_backpatch(c, a);
	/* We jump here with an extra entry which we now pop */
	com_addbyte(c, POP_TOP);
	com_backpatch(c, anchor);
}
</t>
<t tx="T1119">static void
com_list_iter(struct compiling *c,
	      node *p,		/* parent of list_iter node */
	      node *e,		/* element expression node */
	      char *t		/* name of result list temp local */)
{
	/* list_iter is the last child in a listmaker, list_for, or list_if */
	node *n = CHILD(p, NCH(p)-1);
	if (TYPE(n) == list_iter) {
		n = CHILD(n, 0);
		switch (TYPE(n)) {
		case list_for: 
			com_list_for(c, n, e, t);
			break;
		case list_if:
			com_list_if(c, n, e, t);
			break;
		default:
			com_error(c, PyExc_SystemError,
				  "invalid list_iter node type");
		}
	}
	else {
		com_addop_varname(c, VAR_LOAD, t);
		com_push(c, 1);
		com_node(c, e);
		com_addoparg(c, CALL_FUNCTION, 1);
		com_addbyte(c, POP_TOP);
		com_pop(c, 2);
	}
}
</t>
<t tx="T1120">static void
com_list_comprehension(struct compiling *c, node *n)
{
	/* listmaker: test list_for */
	char tmpname[30];
	PyOS_snprintf(tmpname, sizeof(tmpname), "_[%d]", ++c-&gt;c_tmpname);
	com_addoparg(c, BUILD_LIST, 0);
	com_addbyte(c, DUP_TOP); /* leave the result on the stack */
	com_push(c, 2);
	com_addop_name(c, LOAD_ATTR, "append");
	com_addop_varname(c, VAR_STORE, tmpname);
	com_pop(c, 1);
	com_list_for(c, CHILD(n, 1), CHILD(n, 0), tmpname);
	com_addop_varname(c, VAR_DELETE, tmpname);
	--c-&gt;c_tmpname;
}
</t>
<t tx="T1121">static void
com_listmaker(struct compiling *c, node *n)
{
	/* listmaker: test ( list_for | (',' test)* [','] ) */
	if (NCH(n) &gt; 1 &amp;&amp; TYPE(CHILD(n, 1)) == list_for)
		com_list_comprehension(c, n);
	else {
		int len = 0;
		int i;
		for (i = 0; i &lt; NCH(n); i += 2, len++)
			com_node(c, CHILD(n, i));
		com_addoparg(c, BUILD_LIST, len);
		com_pop(c, len-1);
	}
}
</t>
<t tx="T1122">static void
com_dictmaker(struct compiling *c, node *n)
{
	int i;
	/* dictmaker: test ':' test (',' test ':' value)* [','] */
	for (i = 0; i+2 &lt; NCH(n); i += 4) {
		/* We must arrange things just right for STORE_SUBSCR.
		   It wants the stack to look like (value) (dict) (key) */
		com_addbyte(c, DUP_TOP);
		com_push(c, 1);
		com_node(c, CHILD(n, i+2)); /* value */
		com_addbyte(c, ROT_TWO);
		com_node(c, CHILD(n, i)); /* key */
		com_addbyte(c, STORE_SUBSCR);
		com_pop(c, 3);
	}
}
</t>
<t tx="T1123">static void
com_atom(struct compiling *c, node *n)
{
	node *ch;
	PyObject *v;
	int i;
	REQ(n, atom);
	ch = CHILD(n, 0);
	switch (TYPE(ch)) {
	case LPAR:
		if (TYPE(CHILD(n, 1)) == RPAR) {
			com_addoparg(c, BUILD_TUPLE, 0);
			com_push(c, 1);
		}
		else
			com_node(c, CHILD(n, 1));
		break;
	case LSQB: /* '[' [listmaker] ']' */
		if (TYPE(CHILD(n, 1)) == RSQB) {
			com_addoparg(c, BUILD_LIST, 0);
			com_push(c, 1);
		}
		else
			com_listmaker(c, CHILD(n, 1));
		break;
	case LBRACE: /* '{' [dictmaker] '}' */
		com_addoparg(c, BUILD_MAP, 0);
		com_push(c, 1);
		if (TYPE(CHILD(n, 1)) == dictmaker)
			com_dictmaker(c, CHILD(n, 1));
		break;
	case BACKQUOTE:
		com_node(c, CHILD(n, 1));
		com_addbyte(c, UNARY_CONVERT);
		break;
	case NUMBER:
		if ((v = parsenumber(c, STR(ch))) == NULL) {
			i = 255;
		}
		else {
			i = com_addconst(c, v);
			Py_DECREF(v);
		}
		com_addoparg(c, LOAD_CONST, i);
		com_push(c, 1);
		break;
	case STRING:
		v = parsestrplus(c, n);
		if (v == NULL) {
			c-&gt;c_errors++;
			i = 255;
		}
		else {
			i = com_addconst(c, v);
			Py_DECREF(v);
		}
		com_addoparg(c, LOAD_CONST, i);
		com_push(c, 1);
		break;
	case NAME:
		com_addop_varname(c, VAR_LOAD, STR(ch));
		com_push(c, 1);
		break;
	default:
		com_error(c, PyExc_SystemError,
			  "com_atom: unexpected node type");
	}
}
</t>
<t tx="T1124">static void
com_slice(struct compiling *c, node *n, int op)
{
	if (NCH(n) == 1) {
		com_addbyte(c, op);
	}
	else if (NCH(n) == 2) {
		if (TYPE(CHILD(n, 0)) != COLON) {
			com_node(c, CHILD(n, 0));
			com_addbyte(c, op+1);
		}
		else {
			com_node(c, CHILD(n, 1));
			com_addbyte(c, op+2);
		}
		com_pop(c, 1);
	}
	else {
		com_node(c, CHILD(n, 0));
		com_node(c, CHILD(n, 2));
		com_addbyte(c, op+3);
		com_pop(c, 2);
	}
}
</t>
<t tx="T1125">static void
com_augassign_slice(struct compiling *c, node *n, int opcode, node *augn)
{
	if (NCH(n) == 1) {
		com_addbyte(c, DUP_TOP);
		com_push(c, 1);
		com_addbyte(c, SLICE);
		com_node(c, augn);
		com_addbyte(c, opcode);
		com_pop(c, 1);
		com_addbyte(c, ROT_TWO);
		com_addbyte(c, STORE_SLICE);
		com_pop(c, 2);
	} else if (NCH(n) == 2 &amp;&amp; TYPE(CHILD(n, 0)) != COLON) {
		com_node(c, CHILD(n, 0));
		com_addoparg(c, DUP_TOPX, 2);
		com_push(c, 2);
		com_addbyte(c, SLICE+1);
		com_pop(c, 1);
		com_node(c, augn);
		com_addbyte(c, opcode);
		com_pop(c, 1);
		com_addbyte(c, ROT_THREE);
		com_addbyte(c, STORE_SLICE+1);
		com_pop(c, 3);
	} else if (NCH(n) == 2) {
		com_node(c, CHILD(n, 1));
		com_addoparg(c, DUP_TOPX, 2);
		com_push(c, 2);
		com_addbyte(c, SLICE+2);
		com_pop(c, 1);
		com_node(c, augn);
		com_addbyte(c, opcode);
		com_pop(c, 1);
		com_addbyte(c, ROT_THREE);
		com_addbyte(c, STORE_SLICE+2);
		com_pop(c, 3);
	} else {
		com_node(c, CHILD(n, 0));
		com_node(c, CHILD(n, 2));
		com_addoparg(c, DUP_TOPX, 3);
		com_push(c, 3);
		com_addbyte(c, SLICE+3);
		com_pop(c, 2);
		com_node(c, augn);
		com_addbyte(c, opcode);
		com_pop(c, 1);
		com_addbyte(c, ROT_FOUR);
		com_addbyte(c, STORE_SLICE+3);
		com_pop(c, 4);
	}
}
</t>
<t tx="T1126">static void
com_argument(struct compiling *c, node *n, PyObject **pkeywords)
{
	node *m;
	REQ(n, argument); /* [test '='] test; really [keyword '='] test */
	if (NCH(n) == 1) {
		if (*pkeywords != NULL) {
			com_error(c, PyExc_SyntaxError,
				  "non-keyword arg after keyword arg");
		}
		else {
			com_node(c, CHILD(n, 0));
		}
		return;
	}
	m = n;
	do {
		m = CHILD(m, 0);
	} while (NCH(m) == 1);
	if (TYPE(m) != NAME) {
		/* f(lambda x: x[0] = 3) ends up getting parsed with
		 * LHS test = lambda x: x[0], and RHS test = 3.
		 * SF bug 132313 points out that complaining about a keyword
		 * then is very confusing.
		 */
		com_error(c, PyExc_SyntaxError,
			  TYPE(m) == lambdef ?
				  "lambda cannot contain assignment" :
				  "keyword can't be an expression");
	}
	else {
		PyObject *v = PyString_InternFromString(STR(m));
		if (v != NULL &amp;&amp; *pkeywords == NULL)
			*pkeywords = PyDict_New();
		if (v == NULL)
			c-&gt;c_errors++;
		else if (*pkeywords == NULL) {
			c-&gt;c_errors++;
			Py_DECREF(v);
		} else {
			if (PyDict_GetItem(*pkeywords, v) != NULL)
				com_error(c, PyExc_SyntaxError,
					  "duplicate keyword argument");
			else
				if (PyDict_SetItem(*pkeywords, v, v) != 0)
					c-&gt;c_errors++;
			com_addoparg(c, LOAD_CONST, com_addconst(c, v));
			com_push(c, 1);
			Py_DECREF(v);
		}
	}
	com_node(c, CHILD(n, 2));
}
</t>
<t tx="T1127">static void
com_call_function(struct compiling *c, node *n)
{
	if (TYPE(n) == RPAR) {
		com_addoparg(c, CALL_FUNCTION, 0);
	}
	else {
		PyObject *keywords = NULL;
		int i, na, nk;
		int lineno = n-&gt;n_lineno;
		int star_flag = 0;
		int starstar_flag = 0;
		int opcode;
		REQ(n, arglist);
		na = 0;
		nk = 0;
		for (i = 0; i &lt; NCH(n); i += 2) {
			node *ch = CHILD(n, i);
			if (TYPE(ch) == STAR ||
			    TYPE(ch) == DOUBLESTAR)
			  break;
			if (ch-&gt;n_lineno != lineno) {
				lineno = ch-&gt;n_lineno;
				com_addoparg(c, SET_LINENO, lineno);
			}
			com_argument(c, ch, &amp;keywords);
			if (keywords == NULL)
				na++;
			else
				nk++;
		}
		Py_XDECREF(keywords);
		while (i &lt; NCH(n)) {
		    node *tok = CHILD(n, i);
		    node *ch = CHILD(n, i+1);
		    i += 3;
		    switch (TYPE(tok)) {
		    case STAR:       star_flag = 1;     break;
		    case DOUBLESTAR: starstar_flag = 1;	break;
		    }
		    com_node(c, ch);
		}
		if (na &gt; 255 || nk &gt; 255) {
			com_error(c, PyExc_SyntaxError,
				  "more than 255 arguments");
		}
		if (star_flag || starstar_flag)
		    opcode = CALL_FUNCTION_VAR - 1 + 
			star_flag + (starstar_flag &lt;&lt; 1);
		else
		    opcode = CALL_FUNCTION;
		com_addoparg(c, opcode, na | (nk &lt;&lt; 8));
		com_pop(c, na + 2*nk + star_flag + starstar_flag);
	}
}
</t>
<t tx="T1128">static void
com_select_member(struct compiling *c, node *n)
{
	com_addopname(c, LOAD_ATTR, n);
}
</t>
<t tx="T1129">static void
com_sliceobj(struct compiling *c, node *n)
{
	int i=0;
	int ns=2; /* number of slice arguments */
	node *ch;

	/* first argument */
	if (TYPE(CHILD(n,i)) == COLON) {
		com_addoparg(c, LOAD_CONST, com_addconst(c, Py_None));
		com_push(c, 1);
		i++;
	}
	else {
		com_node(c, CHILD(n,i));
		i++;
		REQ(CHILD(n,i),COLON);
		i++;
	}
	/* second argument */
	if (i &lt; NCH(n) &amp;&amp; TYPE(CHILD(n,i)) == test) {
		com_node(c, CHILD(n,i));
		i++;
	}
	else {
		com_addoparg(c, LOAD_CONST, com_addconst(c, Py_None));
		com_push(c, 1);
	}
	/* remaining arguments */
	for (; i &lt; NCH(n); i++) {
		ns++;
		ch=CHILD(n,i);
		REQ(ch, sliceop);
		if (NCH(ch) == 1) {
			/* right argument of ':' missing */
			com_addoparg(c, LOAD_CONST, com_addconst(c, Py_None));
			com_push(c, 1);
		}
		else
			com_node(c, CHILD(ch,1));
	}
	com_addoparg(c, BUILD_SLICE, ns);
	com_pop(c, 1 + (ns == 3));
}
</t>
<t tx="T1130">static void
com_subscript(struct compiling *c, node *n)
{
	node *ch;
	REQ(n, subscript);
	ch = CHILD(n,0);
	/* check for rubber index */
	if (TYPE(ch) == DOT &amp;&amp; TYPE(CHILD(n,1)) == DOT) {
		com_addoparg(c, LOAD_CONST, com_addconst(c, Py_Ellipsis));
		com_push(c, 1);
	}
	else {
		/* check for slice */
		if ((TYPE(ch) == COLON || NCH(n) &gt; 1))
			com_sliceobj(c, n);
		else {
			REQ(ch, test);
			com_node(c, ch);
		}
	}
}
</t>
<t tx="T1131">static void
com_subscriptlist(struct compiling *c, node *n, int assigning, node *augn)
{
	int i, op;
	REQ(n, subscriptlist);
	/* Check to make backward compatible slice behavior for '[i:j]' */
	if (NCH(n) == 1) {
		node *sub = CHILD(n, 0); /* subscript */
		/* 'Basic' slice, should have exactly one colon. */
		if ((TYPE(CHILD(sub, 0)) == COLON
		     || (NCH(sub) &gt; 1 &amp;&amp; TYPE(CHILD(sub, 1)) == COLON))
		    &amp;&amp; (TYPE(CHILD(sub,NCH(sub)-1)) != sliceop))
		{
			switch (assigning) {
			case OP_DELETE:
				op = DELETE_SLICE;
				break;
			case OP_ASSIGN:
				op = STORE_SLICE;
				break;
			case OP_APPLY:
				op = SLICE;
				break;
			default:
				com_augassign_slice(c, sub, assigning, augn);
				return;
			}
			com_slice(c, sub, op);
			if (op == STORE_SLICE)
				com_pop(c, 2);
			else if (op == DELETE_SLICE)
				com_pop(c, 1);
			return;
		}
	}
	/* Else normal subscriptlist.  Compile each subscript. */
	for (i = 0; i &lt; NCH(n); i += 2)
		com_subscript(c, CHILD(n, i));
	/* Put multiple subscripts into a tuple */
	if (NCH(n) &gt; 1) {
		i = (NCH(n)+1) / 2;
		com_addoparg(c, BUILD_TUPLE, i);
		com_pop(c, i-1);
	}
	switch (assigning) {
	case OP_DELETE:
		op = DELETE_SUBSCR;
		i = 2;
		break;
	default:
	case OP_ASSIGN:
		op = STORE_SUBSCR;
		i = 3;
		break;
	case OP_APPLY:
		op = BINARY_SUBSCR;
		i = 1;
		break;
	}
	if (assigning &gt; OP_APPLY) {
		com_addoparg(c, DUP_TOPX, 2);
		com_push(c, 2);
		com_addbyte(c, BINARY_SUBSCR);
		com_pop(c, 1);
		com_node(c, augn);
		com_addbyte(c, assigning);
		com_pop(c, 1);
		com_addbyte(c, ROT_THREE);
	}
	com_addbyte(c, op);
	com_pop(c, i);
}
</t>
<t tx="T1132">static void
com_apply_trailer(struct compiling *c, node *n)
{
	REQ(n, trailer);
	switch (TYPE(CHILD(n, 0))) {
	case LPAR:
		com_call_function(c, CHILD(n, 1));
		break;
	case DOT:
		com_select_member(c, CHILD(n, 1));
		break;
	case LSQB:
		com_subscriptlist(c, CHILD(n, 1), OP_APPLY, NULL);
		break;
	default:
		com_error(c, PyExc_SystemError,
			  "com_apply_trailer: unknown trailer type");
	}
}
</t>
<t tx="T1133"></t>
<t tx="T1134">static void
com_power(struct compiling *c, node *n)
{
	int i;
	REQ(n, power);
	com_atom(c, CHILD(n, 0));
	for (i = 1; i &lt; NCH(n); i++) {
		if (TYPE(CHILD(n, i)) == DOUBLESTAR) {
			com_factor(c, CHILD(n, i+1));
			com_addbyte(c, BINARY_POWER);
			com_pop(c, 1);
			break;
		}
		else
			com_apply_trailer(c, CHILD(n, i));
	}
}
</t>
<t tx="T1135">static void
com_invert_constant(struct compiling *c, node *n)
{
	/* Compute the inverse of int and longs and use them directly,
	   but be prepared to generate code for all other
	   possibilities (invalid numbers, floats, complex).
	*/
	PyObject *num, *inv = NULL;
	int i;

	REQ(n, NUMBER);
	num = parsenumber(c, STR(n));
	if (num == NULL) 
		i = 255;
	else {
		inv = PyNumber_Invert(num);
		if (inv == NULL) {
			PyErr_Clear();
			i = com_addconst(c, num);
		} else {
			i = com_addconst(c, inv);
			Py_DECREF(inv);
		}
		Py_DECREF(num);
	}
	com_addoparg(c, LOAD_CONST, i);
	com_push(c, 1);
	if (num != NULL &amp;&amp; inv == NULL)
		com_addbyte(c, UNARY_INVERT);
}
</t>
<t tx="T1136">static int
is_float_zero(const char *p)
{
	int found_radix_point = 0;
	int ch;
	while ((ch = Py_CHARMASK(*p++)) != '\0') {
		switch (ch) {
		case '0':
			/* no reason to believe it's not 0 -- continue */
			break;

		case 'e': case 'E': case 'j': case 'J':
			/* If this was a hex constant, we already would have
			   returned 0 due to the 'x' or 'X', so 'e' or 'E'
			   must be an exponent marker, and we haven't yet
			   seen a non-zero digit, and it doesn't matter what
			   the exponent is then.  For 'j' or 'J' similarly,
			   except that this is an imaginary 0 then. */
			return 1;

		case '.':
			found_radix_point = 1;
			break;

		default:
			return 0;
		}
	}
	return found_radix_point;
}
</t>
<t tx="T1137">static void
com_factor(struct compiling *c, node *n)
{
	int childtype = TYPE(CHILD(n, 0));
	node *pfactor, *ppower, *patom, *pnum;
	REQ(n, factor);
	/* If the unary +, -, or ~ operator is applied to a constant,
	   don't generate a UNARY_xxx opcode.  Just store the
	   approriate value as a constant.  If the value is negative,
	   extend the string containing the constant and insert a
	   negative in the 0th position -- unless we're doing unary minus
	   of a floating zero!  In that case the sign is significant, but
	   the const dict can't distinguish +0.0 from -0.0.
	 */
	if ((childtype == PLUS || childtype == MINUS || childtype == TILDE)
	    &amp;&amp; NCH(n) == 2
	    &amp;&amp; TYPE((pfactor = CHILD(n, 1))) == factor
 	    &amp;&amp; NCH(pfactor) == 1
	    &amp;&amp; TYPE((ppower = CHILD(pfactor, 0))) == power
 	    &amp;&amp; NCH(ppower) == 1
	    &amp;&amp; TYPE((patom = CHILD(ppower, 0))) == atom
	    &amp;&amp; TYPE((pnum = CHILD(patom, 0))) == NUMBER
	    &amp;&amp; !(childtype == MINUS &amp;&amp; is_float_zero(STR(pnum)))) {
		if (childtype == TILDE) {
			com_invert_constant(c, pnum);
			return;
		}
		if (childtype == MINUS) {
			char *s = malloc(strlen(STR(pnum)) + 2);
			if (s == NULL) {
				com_error(c, PyExc_MemoryError, "");
				com_addbyte(c, 255);
				return;
			}
			s[0] = '-';
			strcpy(s + 1, STR(pnum));
			free(STR(pnum));
			STR(pnum) = s;
		}
		com_atom(c, patom);
	}
	else if (childtype == PLUS) {
		com_factor(c, CHILD(n, 1));
		com_addbyte(c, UNARY_POSITIVE);
	}
	else if (childtype == MINUS) {
		com_factor(c, CHILD(n, 1));
		com_addbyte(c, UNARY_NEGATIVE);
	}
	else if (childtype == TILDE) {
		com_factor(c, CHILD(n, 1));
		com_addbyte(c, UNARY_INVERT);
	}
	else {
		com_power(c, CHILD(n, 0));
	}
}
</t>
<t tx="T1138">static void
com_term(struct compiling *c, node *n)
{
	int i;
	int op;
	REQ(n, term);
	com_factor(c, CHILD(n, 0));
	for (i = 2; i &lt; NCH(n); i += 2) {
		com_factor(c, CHILD(n, i));
		switch (TYPE(CHILD(n, i-1))) {
		case STAR:
			op = BINARY_MULTIPLY;
			break;
		case SLASH:
			if (c-&gt;c_flags &amp; CO_FUTURE_DIVISION)
				op = BINARY_TRUE_DIVIDE;
			else
				op = BINARY_DIVIDE;
			break;
		case PERCENT:
			op = BINARY_MODULO;
			break;
		case DOUBLESLASH:
			op = BINARY_FLOOR_DIVIDE;
			break;
		default:
			com_error(c, PyExc_SystemError,
				  "com_term: operator not *, /, // or %");
			op = 255;
		}
		com_addbyte(c, op);
		com_pop(c, 1);
	}
}
</t>
<t tx="T1139">static void
com_arith_expr(struct compiling *c, node *n)
{
	int i;
	int op;
	REQ(n, arith_expr);
	com_term(c, CHILD(n, 0));
	for (i = 2; i &lt; NCH(n); i += 2) {
		com_term(c, CHILD(n, i));
		switch (TYPE(CHILD(n, i-1))) {
		case PLUS:
			op = BINARY_ADD;
			break;
		case MINUS:
			op = BINARY_SUBTRACT;
			break;
		default:
			com_error(c, PyExc_SystemError,
				  "com_arith_expr: operator not + or -");
			op = 255;
		}
		com_addbyte(c, op);
		com_pop(c, 1);
	}
}
</t>
<t tx="T1140">static void
com_shift_expr(struct compiling *c, node *n)
{
	int i;
	int op;
	REQ(n, shift_expr);
	com_arith_expr(c, CHILD(n, 0));
	for (i = 2; i &lt; NCH(n); i += 2) {
		com_arith_expr(c, CHILD(n, i));
		switch (TYPE(CHILD(n, i-1))) {
		case LEFTSHIFT:
			op = BINARY_LSHIFT;
			break;
		case RIGHTSHIFT:
			op = BINARY_RSHIFT;
			break;
		default:
			com_error(c, PyExc_SystemError,
				  "com_shift_expr: operator not &lt;&lt; or &gt;&gt;");
			op = 255;
		}
		com_addbyte(c, op);
		com_pop(c, 1);
	}
}
</t>
<t tx="T1141">static void
com_and_expr(struct compiling *c, node *n)
{
	int i;
	int op;
	REQ(n, and_expr);
	com_shift_expr(c, CHILD(n, 0));
	for (i = 2; i &lt; NCH(n); i += 2) {
		com_shift_expr(c, CHILD(n, i));
		if (TYPE(CHILD(n, i-1)) == AMPER) {
			op = BINARY_AND;
		}
		else {
			com_error(c, PyExc_SystemError,
				  "com_and_expr: operator not &amp;");
			op = 255;
		}
		com_addbyte(c, op);
		com_pop(c, 1);
	}
}
</t>
<t tx="T1142">static void
com_xor_expr(struct compiling *c, node *n)
{
	int i;
	int op;
	REQ(n, xor_expr);
	com_and_expr(c, CHILD(n, 0));
	for (i = 2; i &lt; NCH(n); i += 2) {
		com_and_expr(c, CHILD(n, i));
		if (TYPE(CHILD(n, i-1)) == CIRCUMFLEX) {
			op = BINARY_XOR;
		}
		else {
			com_error(c, PyExc_SystemError,
				  "com_xor_expr: operator not ^");
			op = 255;
		}
		com_addbyte(c, op);
		com_pop(c, 1);
	}
}
</t>
<t tx="T1143">static void
com_expr(struct compiling *c, node *n)
{
	int i;
	int op;
	REQ(n, expr);
	com_xor_expr(c, CHILD(n, 0));
	for (i = 2; i &lt; NCH(n); i += 2) {
		com_xor_expr(c, CHILD(n, i));
		if (TYPE(CHILD(n, i-1)) == VBAR) {
			op = BINARY_OR;
		}
		else {
			com_error(c, PyExc_SystemError,
				  "com_expr: expr operator not |");
			op = 255;
		}
		com_addbyte(c, op);
		com_pop(c, 1);
	}
}
</t>
<t tx="T1144">static enum cmp_op
cmp_type(node *n)
{
	REQ(n, comp_op);
	/* comp_op: '&lt;' | '&gt;' | '=' | '&gt;=' | '&lt;=' | '&lt;&gt;' | '!=' | '=='
	          | 'in' | 'not' 'in' | 'is' | 'is' not' */
	if (NCH(n) == 1) {
		n = CHILD(n, 0);
		switch (TYPE(n)) {
		case LESS:	return LT;
		case GREATER:	return GT;
		case EQEQUAL:			/* == */
		case EQUAL:	return EQ;
		case LESSEQUAL:	return LE;
		case GREATEREQUAL: return GE;
		case NOTEQUAL:	return NE;	/* &lt;&gt; or != */
		case NAME:	if (strcmp(STR(n), "in") == 0) return IN;
				if (strcmp(STR(n), "is") == 0) return IS;
		}
	}
	else if (NCH(n) == 2) {
		switch (TYPE(CHILD(n, 0))) {
		case NAME:	if (strcmp(STR(CHILD(n, 1)), "in") == 0)
					return NOT_IN;
				if (strcmp(STR(CHILD(n, 0)), "is") == 0)
					return IS_NOT;
		}
	}
	return BAD;
}
</t>
<t tx="T1145">static void
com_comparison(struct compiling *c, node *n)
{
	int i;
	enum cmp_op op;
	int anchor;
	REQ(n, comparison); /* comparison: expr (comp_op expr)* */
	com_expr(c, CHILD(n, 0));
	if (NCH(n) == 1)
		return;
	
	/****************************************************************
	   The following code is generated for all but the last
	   comparison in a chain:
	   
	   label:	on stack:	opcode:		jump to:
	   
			a		&lt;code to load b&gt;
			a, b		DUP_TOP
			a, b, b		ROT_THREE
			b, a, b		COMPARE_OP
			b, 0-or-1	JUMP_IF_FALSE	L1
			b, 1		POP_TOP
			b		
	
	   We are now ready to repeat this sequence for the next
	   comparison in the chain.
	   
	   For the last we generate:
	   
	   		b		&lt;code to load c&gt;
	   		b, c		COMPARE_OP
	   		0-or-1		
	   
	   If there were any jumps to L1 (i.e., there was more than one
	   comparison), we generate:
	   
	   		0-or-1		JUMP_FORWARD	L2
	   L1:		b, 0		ROT_TWO
	   		0, b		POP_TOP
	   		0
	   L2:		0-or-1
	****************************************************************/
	
	anchor = 0;
	
	for (i = 2; i &lt; NCH(n); i += 2) {
		com_expr(c, CHILD(n, i));
		if (i+2 &lt; NCH(n)) {
			com_addbyte(c, DUP_TOP);
			com_push(c, 1);
			com_addbyte(c, ROT_THREE);
		}
		op = cmp_type(CHILD(n, i-1));
		if (op == BAD) {
			com_error(c, PyExc_SystemError,
				  "com_comparison: unknown comparison op");
		}
		com_addoparg(c, COMPARE_OP, op);
		com_pop(c, 1);
		if (i+2 &lt; NCH(n)) {
			com_addfwref(c, JUMP_IF_FALSE, &amp;anchor);
			com_addbyte(c, POP_TOP);
			com_pop(c, 1);
		}
	}
	
	if (anchor) {
		int anchor2 = 0;
		com_addfwref(c, JUMP_FORWARD, &amp;anchor2);
		com_backpatch(c, anchor);
		com_addbyte(c, ROT_TWO);
		com_addbyte(c, POP_TOP);
		com_backpatch(c, anchor2);
	}
}
</t>
<t tx="T1146">static void
com_not_test(struct compiling *c, node *n)
{
	REQ(n, not_test); /* 'not' not_test | comparison */
	if (NCH(n) == 1) {
		com_comparison(c, CHILD(n, 0));
	}
	else {
		com_not_test(c, CHILD(n, 1));
		com_addbyte(c, UNARY_NOT);
	}
}
</t>
<t tx="T1147">static void
com_and_test(struct compiling *c, node *n)
{
	int i;
	int anchor;
	REQ(n, and_test); /* not_test ('and' not_test)* */
	anchor = 0;
	i = 0;
	for (;;) {
		com_not_test(c, CHILD(n, i));
		if ((i += 2) &gt;= NCH(n))
			break;
		com_addfwref(c, JUMP_IF_FALSE, &amp;anchor);
		com_addbyte(c, POP_TOP);
		com_pop(c, 1);
	}
	if (anchor)
		com_backpatch(c, anchor);
}
</t>
<t tx="T1148">static int
com_make_closure(struct compiling *c, PyCodeObject *co)
{
	int i, free = PyCode_GetNumFree(co);
	if (free == 0)
		return 0;
	for (i = 0; i &lt; free; ++i) {
		/* Bypass com_addop_varname because it will generate
		   LOAD_DEREF but LOAD_CLOSURE is needed. 
		*/
		PyObject *name = PyTuple_GET_ITEM(co-&gt;co_freevars, i);
		int arg, reftype;

		/* Special case: If a class contains a method with a
		   free variable that has the same name as a method,
		   the name will be considered free *and* local in the
		   class.  It should be handled by the closure, as
		   well as by the normal name loookup logic.
		*/
		reftype = get_ref_type(c, PyString_AS_STRING(name));	
		if (reftype == CELL)
			arg = com_lookup_arg(c-&gt;c_cellvars, name);
		else /* (reftype == FREE) */
			arg = com_lookup_arg(c-&gt;c_freevars, name);
		if (arg == -1) {
			fprintf(stderr, "lookup %s in %s %d %d\n"
				"freevars of %s: %s\n",
				PyObject_REPR(name), 
				c-&gt;c_name, 
				reftype, arg,
				PyString_AS_STRING(co-&gt;co_name),
				PyObject_REPR(co-&gt;co_freevars));
			Py_FatalError("com_make_closure()");
		}
		com_addoparg(c, LOAD_CLOSURE, arg);

	}
	com_push(c, free);
	return 1;
}
</t>
<t tx="T1149">static void
com_test(struct compiling *c, node *n)
{
	REQ(n, test); /* and_test ('or' and_test)* | lambdef */
	if (NCH(n) == 1 &amp;&amp; TYPE(CHILD(n, 0)) == lambdef) {
		PyCodeObject *co;
		int i, closure;
		int ndefs = com_argdefs(c, CHILD(n, 0));
		symtable_enter_scope(c-&gt;c_symtable, "lambda", lambdef,
				     n-&gt;n_lineno);
		co = icompile(CHILD(n, 0), c);
		if (co == NULL) {
			c-&gt;c_errors++;
			return;
		}
		symtable_exit_scope(c-&gt;c_symtable);
		i = com_addconst(c, (PyObject *)co);
		closure = com_make_closure(c, co);
		com_addoparg(c, LOAD_CONST, i);
		com_push(c, 1);
		if (closure) {
			com_addoparg(c, MAKE_CLOSURE, ndefs);
			com_pop(c, PyCode_GetNumFree(co));
		} else
			com_addoparg(c, MAKE_FUNCTION, ndefs);
		Py_DECREF(co);
		com_pop(c, ndefs);
	}
	else {
		int anchor = 0;
		int i = 0;
		for (;;) {
			com_and_test(c, CHILD(n, i));
			if ((i += 2) &gt;= NCH(n))
				break;
			com_addfwref(c, JUMP_IF_TRUE, &amp;anchor);
			com_addbyte(c, POP_TOP);
			com_pop(c, 1);
		}
		if (anchor)
			com_backpatch(c, anchor);
	}
}
</t>
<t tx="T1150">static void
com_list(struct compiling *c, node *n, int toplevel)
{
	/* exprlist: expr (',' expr)* [',']; likewise for testlist */
	if (NCH(n) == 1 &amp;&amp; !toplevel) {
		com_node(c, CHILD(n, 0));
	}
	else {
		int i;
		int len;
		len = (NCH(n) + 1) / 2;
		for (i = 0; i &lt; NCH(n); i += 2)
			com_node(c, CHILD(n, i));
		com_addoparg(c, BUILD_TUPLE, len);
		com_pop(c, len-1);
	}
}
</t>
<t tx="T1151"></t>
<t tx="T1152">@ Begin of assignment compilation
@c

static void
com_augassign_attr(struct compiling *c, node *n, int opcode, node *augn)
{
	com_addbyte(c, DUP_TOP);
	com_push(c, 1);
	com_addopname(c, LOAD_ATTR, n);
	com_node(c, augn);
	com_addbyte(c, opcode);
	com_pop(c, 1);
	com_addbyte(c, ROT_TWO);
	com_addopname(c, STORE_ATTR, n);
	com_pop(c, 2);
}
</t>
<t tx="T1153">static void
com_assign_attr(struct compiling *c, node *n, int assigning)
{
	com_addopname(c, assigning ? STORE_ATTR : DELETE_ATTR, n);
	com_pop(c, assigning ? 2 : 1);
}
</t>
<t tx="T1154">static void
com_assign_trailer(struct compiling *c, node *n, int assigning, node *augn)
{
	REQ(n, trailer);
	switch (TYPE(CHILD(n, 0))) {
	case LPAR: /* '(' [exprlist] ')' */
		com_error(c, PyExc_SyntaxError,
			  "can't assign to function call");
		break;
	case DOT: /* '.' NAME */
		if (assigning &gt; OP_APPLY)
			com_augassign_attr(c, CHILD(n, 1), assigning, augn);
		else
			com_assign_attr(c, CHILD(n, 1), assigning);
		break;
	case LSQB: /* '[' subscriptlist ']' */
		com_subscriptlist(c, CHILD(n, 1), assigning, augn);
		break;
	default:
		com_error(c, PyExc_SystemError, "unknown trailer type");
	}
}
</t>
<t tx="T1155">static void
com_assign_sequence(struct compiling *c, node *n, int assigning)
{
	int i;
	if (TYPE(n) != testlist &amp;&amp; TYPE(n) != listmaker)
		REQ(n, exprlist);
	if (assigning) {
		i = (NCH(n)+1)/2;
		com_addoparg(c, UNPACK_SEQUENCE, i);
		com_push(c, i-1);
	}
	for (i = 0; i &lt; NCH(n); i += 2)
		com_assign(c, CHILD(n, i), assigning, NULL);
}
</t>
<t tx="T1156">static void
com_augassign_name(struct compiling *c, node *n, int opcode, node *augn)
{
	REQ(n, NAME);
	com_addop_varname(c, VAR_LOAD, STR(n));
	com_push(c, 1);
	com_node(c, augn);
	com_addbyte(c, opcode);
	com_pop(c, 1);
	com_assign_name(c, n, OP_ASSIGN);
}
</t>
<t tx="T1157">static void
com_assign_name(struct compiling *c, node *n, int assigning)
{
	REQ(n, NAME);
	com_addop_varname(c, assigning ? VAR_STORE : VAR_DELETE, STR(n));
	if (assigning)
		com_pop(c, 1);
}
</t>
<t tx="T1158">static void
com_assign(struct compiling *c, node *n, int assigning, node *augn)
{
	/* Loop to avoid trivial recursion */
	for (;;) {
		switch (TYPE(n)) {
		
		case exprlist:
		case testlist:
			if (NCH(n) &gt; 1) {
				if (assigning &gt; OP_APPLY) {
					com_error(c, PyExc_SyntaxError,
				  "augmented assign to tuple not possible");
					return;
				}
				com_assign_sequence(c, n, assigning);
				return;
			}
			n = CHILD(n, 0);
			break;
		
		case test:
		case and_test:
		case not_test:
		case comparison:
		case expr:
		case xor_expr:
		case and_expr:
		case shift_expr:
		case arith_expr:
		case term:
		case factor:
			if (NCH(n) &gt; 1) {
				com_error(c, PyExc_SyntaxError,
					  "can't assign to operator");
				return;
			}
			n = CHILD(n, 0);
			break;
		
		case power: /* atom trailer* ('**' power)*
                              ('+'|'-'|'~') factor | atom trailer* */
			if (TYPE(CHILD(n, 0)) != atom) {
				com_error(c, PyExc_SyntaxError,
					  "can't assign to operator");
				return;
			}
			if (NCH(n) &gt; 1) { /* trailer or exponent present */
				int i;
				com_node(c, CHILD(n, 0));
				for (i = 1; i+1 &lt; NCH(n); i++) {
					if (TYPE(CHILD(n, i)) == DOUBLESTAR) {
						com_error(c, PyExc_SyntaxError,
						  "can't assign to operator");
						return;
					}
					com_apply_trailer(c, CHILD(n, i));
				} /* NB i is still alive */
				com_assign_trailer(c,
						CHILD(n, i), assigning, augn);
				return;
			}
			n = CHILD(n, 0);
			break;
		
		case atom:
			switch (TYPE(CHILD(n, 0))) {
			case LPAR:
				n = CHILD(n, 1);
				if (TYPE(n) == RPAR) {
					/* XXX Should allow () = () ??? */
					com_error(c, PyExc_SyntaxError,
						  "can't assign to ()");
					return;
				}
				if (assigning &gt; OP_APPLY) {
					com_error(c, PyExc_SyntaxError,
				  "augmented assign to tuple not possible");
					return;
				}
				break;
			case LSQB:
				n = CHILD(n, 1);
				if (TYPE(n) == RSQB) {
					com_error(c, PyExc_SyntaxError,
						  "can't assign to []");
					return;
				}
				if (assigning &gt; OP_APPLY) {
					com_error(c, PyExc_SyntaxError,
				  "augmented assign to list not possible");
					return;
				}
				if (NCH(n) &gt; 1 
				    &amp;&amp; TYPE(CHILD(n, 1)) == list_for) {
					com_error(c, PyExc_SyntaxError,
				  "can't assign to list comprehension");
					return;
				}
				com_assign_sequence(c, n, assigning);
				return;
			case NAME:
				if (assigning &gt; OP_APPLY)
					com_augassign_name(c, CHILD(n, 0),
							   assigning, augn);
				else
					com_assign_name(c, CHILD(n, 0),
							assigning);
				return;
			default:
				com_error(c, PyExc_SyntaxError,
					  "can't assign to literal");
				return;
			}
			break;

		case lambdef:
			com_error(c, PyExc_SyntaxError,
				  "can't assign to lambda");
			return;
		
		default:
			com_error(c, PyExc_SystemError,
				  "com_assign: bad node");
			return;
		
		}
	}
}
</t>
<t tx="T1159">static void
com_augassign(struct compiling *c, node *n)
{
	int opcode;

	switch (STR(CHILD(CHILD(n, 1), 0))[0]) {
	case '+': opcode = INPLACE_ADD; break;
	case '-': opcode = INPLACE_SUBTRACT; break;
	case '/':
		if (STR(CHILD(CHILD(n, 1), 0))[1] == '/')
			opcode = INPLACE_FLOOR_DIVIDE;
		else if (c-&gt;c_flags &amp; CO_FUTURE_DIVISION)
			opcode = INPLACE_TRUE_DIVIDE;
		else
			opcode = INPLACE_DIVIDE;
		break;
	case '%': opcode = INPLACE_MODULO; break;
	case '&lt;': opcode = INPLACE_LSHIFT; break;
	case '&gt;': opcode = INPLACE_RSHIFT; break;
	case '&amp;': opcode = INPLACE_AND; break;
	case '^': opcode = INPLACE_XOR; break;
	case '|': opcode = INPLACE_OR; break;
	case '*':
		if (STR(CHILD(CHILD(n, 1), 0))[1] == '*')
			opcode = INPLACE_POWER;
		else
			opcode = INPLACE_MULTIPLY;
		break;
	default:
		com_error(c, PyExc_SystemError, "com_augassign: bad operator");
		return;
	}
	com_assign(c, CHILD(n, 0), opcode, CHILD(n, 2));
}
</t>
<t tx="T1160">static void
com_expr_stmt(struct compiling *c, node *n)
{
	REQ(n, expr_stmt);
	/* testlist (('=' testlist)* | augassign testlist) */
	/* Forget it if we have just a doc string here */
	if (!c-&gt;c_interactive &amp;&amp; NCH(n) == 1 &amp;&amp; get_rawdocstring(n) != NULL)
		return;
 	if (NCH(n) == 1) {
		com_node(c, CHILD(n, NCH(n)-1));
		if (c-&gt;c_interactive)
			com_addbyte(c, PRINT_EXPR);
		else
			com_addbyte(c, POP_TOP);
		com_pop(c, 1);
	}
	else if (TYPE(CHILD(n,1)) == augassign)
		com_augassign(c, n);
	else {
		int i;
		com_node(c, CHILD(n, NCH(n)-1));
		for (i = 0; i &lt; NCH(n)-2; i+=2) {
			if (i+2 &lt; NCH(n)-2) {
				com_addbyte(c, DUP_TOP);
				com_push(c, 1);
			}
			com_assign(c, CHILD(n, i), OP_ASSIGN, NULL);
		}
	}
}
</t>
<t tx="T1161">static void
com_assert_stmt(struct compiling *c, node *n)
{
	int a = 0, b = 0;
	int i;
	REQ(n, assert_stmt); /* 'assert' test [',' test] */
	/* Generate code like for
	   
	   if __debug__:
	      if not &lt;test&gt;:
	         raise AssertionError [, &lt;message&gt;]

	   where &lt;message&gt; is the second test, if present.
	*/

	if (Py_OptimizeFlag)
		return;
	com_addop_name(c, LOAD_GLOBAL, "__debug__");
	com_push(c, 1);
	com_addfwref(c, JUMP_IF_FALSE, &amp;a);
	com_addbyte(c, POP_TOP);
	com_pop(c, 1);
	com_node(c, CHILD(n, 1));
	com_addfwref(c, JUMP_IF_TRUE, &amp;b);
	com_addbyte(c, POP_TOP);
	com_pop(c, 1);
	/* Raise that exception! */
	com_addop_name(c, LOAD_GLOBAL, "AssertionError");
	com_push(c, 1);
	i = NCH(n)/2; /* Either 2 or 4 */
	if (i &gt; 1)
		com_node(c, CHILD(n, 3));
	com_addoparg(c, RAISE_VARARGS, i);
	com_pop(c, i);
	/* The interpreter does not fall through */
	/* All jumps converge here */
	com_backpatch(c, a);
	com_backpatch(c, b);
	com_addbyte(c, POP_TOP);
}
</t>
<t tx="T1162">static void
com_print_stmt(struct compiling *c, node *n)
{
	int i = 1;
	node* stream = NULL;

	REQ(n, print_stmt); /* 'print' (test ',')* [test] */

	/* are we using the extended print form? */
	if (NCH(n) &gt;= 2 &amp;&amp; TYPE(CHILD(n, 1)) == RIGHTSHIFT) {
		stream = CHILD(n, 2);
		com_node(c, stream);
		/* stack: [...] =&gt; [... stream] */
		com_push(c, 1);
		if (NCH(n) &gt; 3 &amp;&amp; TYPE(CHILD(n, 3)) == COMMA)
			i = 4;
		else
			i = 3;
	}
	for (; i &lt; NCH(n); i += 2) {
		if (stream != NULL) {
			com_addbyte(c, DUP_TOP);
			/* stack: [stream] =&gt; [stream stream] */
			com_push(c, 1);
			com_node(c, CHILD(n, i));
			/* stack: [stream stream] =&gt; [stream stream obj] */
			com_addbyte(c, ROT_TWO);
			/* stack: [stream stream obj] =&gt; [stream obj stream] */
			com_addbyte(c, PRINT_ITEM_TO);
			/* stack: [stream obj stream] =&gt; [stream] */
			com_pop(c, 2);
		}
		else {
			com_node(c, CHILD(n, i));
			/* stack: [...] =&gt; [... obj] */
			com_addbyte(c, PRINT_ITEM);
			com_pop(c, 1);
		}
	}
	/* XXX Alternatively, LOAD_CONST '\n' and then PRINT_ITEM */
	if (TYPE(CHILD(n, NCH(n)-1)) == COMMA) {
		if (stream != NULL) {
			/* must pop the extra stream object off the stack */
			com_addbyte(c, POP_TOP);
			/* stack: [... stream] =&gt; [...] */
			com_pop(c, 1);
		}
	}
	else {
		if (stream != NULL) {
			/* this consumes the last stream object on stack */
			com_addbyte(c, PRINT_NEWLINE_TO);
			/* stack: [... stream] =&gt; [...] */
			com_pop(c, 1);
		}
		else
			com_addbyte(c, PRINT_NEWLINE);
	}
}
</t>
<t tx="T1163">static void
com_return_stmt(struct compiling *c, node *n)
{
	REQ(n, return_stmt); /* 'return' [testlist] */
	if (!c-&gt;c_infunction) {
		com_error(c, PyExc_SyntaxError, "'return' outside function");
	}
	if (c-&gt;c_flags &amp; CO_GENERATOR) {
		if (NCH(n) &gt; 1) {
			com_error(c, PyExc_SyntaxError,
				  "'return' with argument inside generator");
		}
	}
	if (NCH(n) &lt; 2) {
		com_addoparg(c, LOAD_CONST, com_addconst(c, Py_None));
		com_push(c, 1);
	}
	else
		com_node(c, CHILD(n, 1));
	com_addbyte(c, RETURN_VALUE);
	com_pop(c, 1);
}
</t>
<t tx="T1164">static void
com_yield_stmt(struct compiling *c, node *n)
{
	int i;
	REQ(n, yield_stmt); /* 'yield' testlist */
	if (!c-&gt;c_infunction) {
		com_error(c, PyExc_SyntaxError, "'yield' outside function");
	}
	
	for (i = 0; i &lt; c-&gt;c_nblocks; ++i) {
		if (c-&gt;c_block[i] == SETUP_FINALLY) {
			com_error(c, PyExc_SyntaxError,
				  "'yield' not allowed in a 'try' block "
				  "with a 'finally' clause");
			return;
		}
	}
	com_node(c, CHILD(n, 1));
	com_addbyte(c, YIELD_VALUE);
	com_pop(c, 1);
}
</t>
<t tx="T1165">static void
com_raise_stmt(struct compiling *c, node *n)
{
	int i;
	REQ(n, raise_stmt); /* 'raise' [test [',' test [',' test]]] */
	if (NCH(n) &gt; 1) {
		com_node(c, CHILD(n, 1));
		if (NCH(n) &gt; 3) {
			com_node(c, CHILD(n, 3));
			if (NCH(n) &gt; 5)
				com_node(c, CHILD(n, 5));
		}
	}
	i = NCH(n)/2;
	com_addoparg(c, RAISE_VARARGS, i);
	com_pop(c, i);
}
</t>
<t tx="T1166">static void
com_from_import(struct compiling *c, node *n)
{
	com_addopname(c, IMPORT_FROM, CHILD(n, 0));
	com_push(c, 1);
	if (NCH(n) &gt; 1) {
		if (strcmp(STR(CHILD(n, 1)), "as") != 0) {
			com_error(c, PyExc_SyntaxError, "invalid syntax");
			return;
		}
		com_addop_varname(c, VAR_STORE, STR(CHILD(n, 2)));
	} else
		com_addop_varname(c, VAR_STORE, STR(CHILD(n, 0)));
	com_pop(c, 1);
}
</t>
<t tx="T1167">static void
com_import_stmt(struct compiling *c, node *n)
{
	int i;
	REQ(n, import_stmt);
	/* 'import' dotted_name (',' dotted_name)* |
	   'from' dotted_name 'import' ('*' | NAME (',' NAME)*) */
	if (STR(CHILD(n, 0))[0] == 'f') {
		PyObject *tup;
		/* 'from' dotted_name 'import' ... */
		REQ(CHILD(n, 1), dotted_name);
		
		if (TYPE(CHILD(n, 3)) == STAR) {
			tup = Py_BuildValue("(s)", "*");
		} else {
			tup = PyTuple_New((NCH(n) - 2)/2);
			for (i = 3; i &lt; NCH(n); i += 2) {
				PyTuple_SET_ITEM(tup, (i-3)/2, 
					PyString_FromString(STR(
						CHILD(CHILD(n, i), 0))));
			}
		}
		com_addoparg(c, LOAD_CONST, com_addconst(c, tup));
		Py_DECREF(tup);
		com_push(c, 1);
		com_addopname(c, IMPORT_NAME, CHILD(n, 1));
		if (TYPE(CHILD(n, 3)) == STAR) 
			com_addbyte(c, IMPORT_STAR);
		else {
			for (i = 3; i &lt; NCH(n); i += 2) 
				com_from_import(c, CHILD(n, i));
			com_addbyte(c, POP_TOP);
		}
		com_pop(c, 1);
	}
	else {
		/* 'import' ... */
		for (i = 1; i &lt; NCH(n); i += 2) {
			node *subn = CHILD(n, i);
			REQ(subn, dotted_as_name);
			com_addoparg(c, LOAD_CONST, com_addconst(c, Py_None));
			com_push(c, 1);
			com_addopname(c, IMPORT_NAME, CHILD(subn, 0));
			if (NCH(subn) &gt; 1) {
				int j;
				if (strcmp(STR(CHILD(subn, 1)), "as") != 0) {
					com_error(c, PyExc_SyntaxError,
						  "invalid syntax");
					return;
				}
				for (j=2 ; j &lt; NCH(CHILD(subn, 0)); j += 2)
					com_addopname(c, LOAD_ATTR,
						      CHILD(CHILD(subn, 0),
							    j));
				com_addop_varname(c, VAR_STORE,
						  STR(CHILD(subn, 2)));
			} else
				com_addop_varname(c, VAR_STORE,
						  STR(CHILD(CHILD(subn, 0),
							    0))); 
			com_pop(c, 1);
		}
	}
}
</t>
<t tx="T1168">static void
com_exec_stmt(struct compiling *c, node *n)
{
	REQ(n, exec_stmt);
	/* exec_stmt: 'exec' expr ['in' expr [',' expr]] */
	com_node(c, CHILD(n, 1));
	if (NCH(n) &gt;= 4)
		com_node(c, CHILD(n, 3));
	else {
		com_addoparg(c, LOAD_CONST, com_addconst(c, Py_None));
		com_push(c, 1);
	}
	if (NCH(n) &gt;= 6)
		com_node(c, CHILD(n, 5));
	else {
		com_addbyte(c, DUP_TOP);
		com_push(c, 1);
	}
	com_addbyte(c, EXEC_STMT);
	com_pop(c, 3);
}
</t>
<t tx="T1169">static int
is_constant_false(struct compiling *c, node *n)
{
	PyObject *v;
	int i;
	/* argument c will be NULL when called from symtable_node() */

  /* Label to avoid tail recursion */
  next:
	switch (TYPE(n)) {

	case suite:
		if (NCH(n) == 1) {
			n = CHILD(n, 0);
			goto next;
		}
		/* Fall through */
	case file_input:
		for (i = 0; i &lt; NCH(n); i++) {
			node *ch = CHILD(n, i);
			if (TYPE(ch) == stmt) {
				n = ch;
				goto next;
			}
		}
		break;

	case stmt:
	case simple_stmt:
	case small_stmt:
		n = CHILD(n, 0);
		goto next;

	case expr_stmt:
	case testlist:
	case test:
	case and_test:
	case not_test:
	case comparison:
	case expr:
	case xor_expr:
	case and_expr:
	case shift_expr:
	case arith_expr:
	case term:
	case factor:
	case power:
	case atom:
		if (NCH(n) == 1) {
			n = CHILD(n, 0);
			goto next;
		}
		break;

	case NAME:
		if (Py_OptimizeFlag &amp;&amp; strcmp(STR(n), "__debug__") == 0)
			return 1;
		break;

	case NUMBER:
		v = parsenumber(c, STR(n));
		if (v == NULL) {
			PyErr_Clear();
			break;
		}
		i = PyObject_IsTrue(v);
		Py_DECREF(v);
		return i == 0;

	case STRING:
		v = parsestr(c, STR(n));
		if (v == NULL) {
			PyErr_Clear();
			break;
		}
		i = PyObject_IsTrue(v);
		Py_DECREF(v);
		return i == 0;

	}
	return 0;
}
</t>
<t tx="T1170">@ Look under n for a return stmt with an expression. * This hack is used to find illegal returns under "if 0:" blocks in * functions already known to be generators (as determined by the symtable * pass). * Return the offending return node if found, else NULL.
@c

static node *
look_for_offending_return(node *n)
{
	int i;

	for (i = 0; i &lt; NCH(n); ++i) {
		node *kid = CHILD(n, i);

		switch (TYPE(kid)) {
			case classdef:
			case funcdef:
			case lambdef:
				/* Stuff in nested functions &amp; classes doesn't
				   affect the code block we started in. */
				return NULL;

			case return_stmt:
				if (NCH(kid) &gt; 1)
					return kid;
				break;

			default: {
				node *bad = look_for_offending_return(kid);
				if (bad != NULL)
					return bad;
			}
		}
	}

	return NULL;
}</t>
<t tx="T1171">static void
com_if_stmt(struct compiling *c, node *n)
{
	int i;
	int anchor = 0;
	REQ(n, if_stmt);
	/*'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite] */
	for (i = 0; i+3 &lt; NCH(n); i+=4) {
		int a = 0;
		node *ch = CHILD(n, i+1);
		if (is_constant_false(c, ch)) {
			/* We're going to skip this block.  However, if this
			   is a generator, we have to check the dead code
			   anyway to make sure there aren't any return stmts
			   with expressions, in the same scope. */
			if (c-&gt;c_flags &amp; CO_GENERATOR) {
				node *p = look_for_offending_return(n);
				if (p != NULL) {
					int savelineno = c-&gt;c_lineno;
					c-&gt;c_lineno = p-&gt;n_lineno;
					com_error(c, PyExc_SyntaxError,
			  	   		"'return' with argument "
			  	   		"inside generator");
			  	   	c-&gt;c_lineno = savelineno;
				}
			}
			continue;
		}
		if (i &gt; 0)
			com_addoparg(c, SET_LINENO, ch-&gt;n_lineno);
		com_node(c, ch);
		com_addfwref(c, JUMP_IF_FALSE, &amp;a);
		com_addbyte(c, POP_TOP);
		com_pop(c, 1);
		com_node(c, CHILD(n, i+3));
		com_addfwref(c, JUMP_FORWARD, &amp;anchor);
		com_backpatch(c, a);
		/* We jump here with an extra entry which we now pop */
		com_addbyte(c, POP_TOP);
	}
	if (i+2 &lt; NCH(n))
		com_node(c, CHILD(n, i+2));
	if (anchor)
		com_backpatch(c, anchor);
}
</t>
<t tx="T1172">static void
com_while_stmt(struct compiling *c, node *n)
{
	int break_anchor = 0;
	int anchor = 0;
	int save_begin = c-&gt;c_begin;
	REQ(n, while_stmt); /* 'while' test ':' suite ['else' ':' suite] */
	com_addfwref(c, SETUP_LOOP, &amp;break_anchor);
	block_push(c, SETUP_LOOP);
	c-&gt;c_begin = c-&gt;c_nexti;
	com_addoparg(c, SET_LINENO, n-&gt;n_lineno);
	com_node(c, CHILD(n, 1));
	com_addfwref(c, JUMP_IF_FALSE, &amp;anchor);
	com_addbyte(c, POP_TOP);
	com_pop(c, 1);
	c-&gt;c_loops++;
	com_node(c, CHILD(n, 3));
	c-&gt;c_loops--;
	com_addoparg(c, JUMP_ABSOLUTE, c-&gt;c_begin);
	c-&gt;c_begin = save_begin;
	com_backpatch(c, anchor);
	/* We jump here with one entry more on the stack */
	com_addbyte(c, POP_TOP);
	com_addbyte(c, POP_BLOCK);
	block_pop(c, SETUP_LOOP);
	if (NCH(n) &gt; 4)
		com_node(c, CHILD(n, 6));
	com_backpatch(c, break_anchor);
}
</t>
<t tx="T1173">static void
com_for_stmt(struct compiling *c, node *n)
{
	int break_anchor = 0;
	int anchor = 0;
	int save_begin = c-&gt;c_begin;
	REQ(n, for_stmt);
	/* 'for' exprlist 'in' exprlist ':' suite ['else' ':' suite] */
	com_addfwref(c, SETUP_LOOP, &amp;break_anchor);
	block_push(c, SETUP_LOOP);
	com_node(c, CHILD(n, 3));
	com_addbyte(c, GET_ITER);
	c-&gt;c_begin = c-&gt;c_nexti;
	com_addoparg(c, SET_LINENO, n-&gt;n_lineno);
	com_addfwref(c, FOR_ITER, &amp;anchor);
	com_push(c, 1);
	com_assign(c, CHILD(n, 1), OP_ASSIGN, NULL);
	c-&gt;c_loops++;
	com_node(c, CHILD(n, 5));
	c-&gt;c_loops--;
	com_addoparg(c, JUMP_ABSOLUTE, c-&gt;c_begin);
	c-&gt;c_begin = save_begin;
	com_backpatch(c, anchor);
	com_pop(c, 1); /* FOR_ITER has popped this */
	com_addbyte(c, POP_BLOCK);
	block_pop(c, SETUP_LOOP);
	if (NCH(n) &gt; 8)
		com_node(c, CHILD(n, 8));
	com_backpatch(c, break_anchor);
}
</t>
<t tx="T1174">@ Code generated for "try: S finally: Sf" is as follows:    SETUP_FINALLY L  &lt;code for S&gt;  POP_BLOCK  LOAD_CONST &lt;nil&gt; L: &lt;code for Sf&gt;  END_FINALLY    The special instructions use the block stack. Each block  stack entry contains the instruction that created it (here  SETUP_FINALLY), the level of the value stack at the time the  block stack entry was created, and a label (here L).    SETUP_FINALLY: Pushes the current value stack level and the label onto the block stack.  POP_BLOCK: Pops en entry from the block stack, and pops the value stack until its level is the same as indicated on the block stack. (The label is ignored.)  END_FINALLY: Pops a variable number of entries from the *value* stack and re-raises the exception they specify. The number of entries popped depends on the (pseudo) exception type.    The block stack is unwound when an exception is raised:  when a SETUP_FINALLY entry is found, the exception is pushed  onto the value stack (and the exception condition is cleared),  and the interpreter jumps to the label gotten from the block  stack.    Code generated for "try: S except E1, V1: S1 except E2, V2: S2 ...":  (The contents of the value stack is shown in [], with the top  at the right; 'tb' is trace-back info, 'val' the exception's  associated value, and 'exc' the exception.)    Value stack Label Instruction Argument  []  SETUP_EXCEPT L1  []  &lt;code for S&gt;  []  POP_BLOCK  []  JUMP_FORWARD L0    [tb, val, exc] L1: DUP  )  [tb, val, exc, exc] &lt;evaluate E1&gt;  )  [tb, val, exc, exc, E1] COMPARE_OP EXC_MATCH ) only if E1  [tb, val, exc, 1-or-0] JUMP_IF_FALSE L2 )  [tb, val, exc, 1] POP  )  [tb, val, exc] POP  [tb, val]  &lt;assign to V1&gt; (or POP if no V1)  [tb]  POP  []  &lt;code for S1&gt;    JUMP_FORWARD L0    [tb, val, exc, 0] L2: POP  [tb, val, exc] DUP  .............................etc.......................   [tb, val, exc, 0] Ln+1: POP  [tb, val, exc]   END_FINALLY # re-raise exception    []  L0: &lt;next statement&gt;    Of course, parts are not generated if Vi or Ei is not present.
@c

static void
com_try_except(struct compiling *c, node *n)
{
	int except_anchor = 0;
	int end_anchor = 0;
	int else_anchor = 0;
	int i;
	node *ch;

	com_addfwref(c, SETUP_EXCEPT, &amp;except_anchor);
	block_push(c, SETUP_EXCEPT);
	com_node(c, CHILD(n, 2));
	com_addbyte(c, POP_BLOCK);
	block_pop(c, SETUP_EXCEPT);
	com_addfwref(c, JUMP_FORWARD, &amp;else_anchor);
	com_backpatch(c, except_anchor);
	for (i = 3;
	     i &lt; NCH(n) &amp;&amp; TYPE(ch = CHILD(n, i)) == except_clause;
	     i += 3) {
		/* except_clause: 'except' [expr [',' var]] */
		if (except_anchor == 0) {
			com_error(c, PyExc_SyntaxError,
				  "default 'except:' must be last");
			break;
		}
		except_anchor = 0;
		com_push(c, 3); /* tb, val, exc pushed by exception */
		com_addoparg(c, SET_LINENO, ch-&gt;n_lineno);
		if (NCH(ch) &gt; 1) {
			com_addbyte(c, DUP_TOP);
			com_push(c, 1);
			com_node(c, CHILD(ch, 1));
			com_addoparg(c, COMPARE_OP, EXC_MATCH);
			com_pop(c, 1);
			com_addfwref(c, JUMP_IF_FALSE, &amp;except_anchor);
			com_addbyte(c, POP_TOP);
			com_pop(c, 1);
		}
		com_addbyte(c, POP_TOP);
		com_pop(c, 1);
		if (NCH(ch) &gt; 3)
			com_assign(c, CHILD(ch, 3), OP_ASSIGN, NULL);
		else {
			com_addbyte(c, POP_TOP);
			com_pop(c, 1);
		}
		com_addbyte(c, POP_TOP);
		com_pop(c, 1);
		com_node(c, CHILD(n, i+2));
		com_addfwref(c, JUMP_FORWARD, &amp;end_anchor);
		if (except_anchor) {
			com_backpatch(c, except_anchor);
			/* We come in with [tb, val, exc, 0] on the
			   stack; one pop and it's the same as
			   expected at the start of the loop */
			com_addbyte(c, POP_TOP);
		}
	}
	/* We actually come in here with [tb, val, exc] but the
	   END_FINALLY will zap those and jump around.
	   The c_stacklevel does not reflect them so we need not pop
	   anything. */
	com_addbyte(c, END_FINALLY);
	com_backpatch(c, else_anchor);
	if (i &lt; NCH(n))
		com_node(c, CHILD(n, i+2));
	com_backpatch(c, end_anchor);
}
</t>
<t tx="T1175">static void
com_try_finally(struct compiling *c, node *n)
{
	int finally_anchor = 0;
	node *ch;

	com_addfwref(c, SETUP_FINALLY, &amp;finally_anchor);
	block_push(c, SETUP_FINALLY);
	com_node(c, CHILD(n, 2));
	com_addbyte(c, POP_BLOCK);
	block_pop(c, SETUP_FINALLY);
	block_push(c, END_FINALLY);
	com_addoparg(c, LOAD_CONST, com_addconst(c, Py_None));
	/* While the generated code pushes only one item,
	   the try-finally handling can enter here with
	   up to three items.  OK, here are the details:
	   3 for an exception, 2 for RETURN, 1 for BREAK. */
	com_push(c, 3);
	com_backpatch(c, finally_anchor);
	ch = CHILD(n, NCH(n)-1);
	com_addoparg(c, SET_LINENO, ch-&gt;n_lineno);
	com_node(c, ch);
	com_addbyte(c, END_FINALLY);
	block_pop(c, END_FINALLY);
	com_pop(c, 3); /* Matches the com_push above */
}
</t>
<t tx="T1176">static void
com_try_stmt(struct compiling *c, node *n)
{
	REQ(n, try_stmt);
	/* 'try' ':' suite (except_clause ':' suite)+ ['else' ':' suite]
	 | 'try' ':' suite 'finally' ':' suite */
	if (TYPE(CHILD(n, 3)) != except_clause)
		com_try_finally(c, n);
	else
		com_try_except(c, n);
}
</t>
<t tx="T1177">static node *
get_rawdocstring(node *n)
{
	int i;

  /* Label to avoid tail recursion */
  next:
	switch (TYPE(n)) {

	case suite:
		if (NCH(n) == 1) {
			n = CHILD(n, 0);
			goto next;
		}
		/* Fall through */
	case file_input:
		for (i = 0; i &lt; NCH(n); i++) {
			node *ch = CHILD(n, i);
			if (TYPE(ch) == stmt) {
				n = ch;
				goto next;
			}
		}
		break;

	case stmt:
	case simple_stmt:
	case small_stmt:
		n = CHILD(n, 0);
		goto next;

	case expr_stmt:
	case testlist:
	case test:
	case and_test:
	case not_test:
	case comparison:
	case expr:
	case xor_expr:
	case and_expr:
	case shift_expr:
	case arith_expr:
	case term:
	case factor:
	case power:
		if (NCH(n) == 1) {
			n = CHILD(n, 0);
			goto next;
		}
		break;

	case atom:
		if (TYPE(CHILD(n, 0)) == STRING)
			return n;
		break;

	}
	return NULL;
}
</t>
<t tx="T1178">static PyObject *
get_docstring(struct compiling *c, node *n)
{
	/* Don't generate doc-strings if run with -OO */
	if (Py_OptimizeFlag &gt; 1)
		return NULL;
	n = get_rawdocstring(n);
	if (n == NULL)
		return NULL;
	return parsestrplus(c, n);
}
</t>
<t tx="T1179">static void
com_suite(struct compiling *c, node *n)
{
	REQ(n, suite);
	/* simple_stmt | NEWLINE INDENT NEWLINE* (stmt NEWLINE*)+ DEDENT */
	if (NCH(n) == 1) {
		com_node(c, CHILD(n, 0));
	}
	else {
		int i;
		for (i = 0; i &lt; NCH(n) &amp;&amp; c-&gt;c_errors == 0; i++) {
			node *ch = CHILD(n, i);
			if (TYPE(ch) == stmt)
				com_node(c, ch);
		}
	}
}
</t>
<t tx="T1180">@ ARGSUSED
@c

static void
com_continue_stmt(struct compiling *c, node *n)
{
	int i = c-&gt;c_nblocks;
	if (i-- &gt; 0 &amp;&amp; c-&gt;c_block[i] == SETUP_LOOP) {
		com_addoparg(c, JUMP_ABSOLUTE, c-&gt;c_begin);
	}
	else if (i &lt;= 0) {
		/* at the outer level */
		com_error(c, PyExc_SyntaxError,
			  "'continue' not properly in loop");
	}
	else {
		int j;
		for (j = i-1; j &gt;= 0; --j) {
			if (c-&gt;c_block[j] == SETUP_LOOP)
				break;
		}
		if (j &gt;= 0) {
			/* there is a loop, but something interferes */
			for (; i &gt; j; --i) {
				if (c-&gt;c_block[i] == SETUP_EXCEPT ||
				    c-&gt;c_block[i] == SETUP_FINALLY) {
					com_addoparg(c, CONTINUE_LOOP,
						     c-&gt;c_begin);
					return;
				}
				if (c-&gt;c_block[i] == END_FINALLY) {
					com_error(c, PyExc_SyntaxError,
			  "'continue' not supported inside 'finally' clause");
			  		return;
			  	}
			}
		}
		com_error(c, PyExc_SyntaxError,
			  "'continue' not properly in loop");
	}
	/* XXX Could allow it inside a 'finally' clause
	   XXX if we could pop the exception still on the stack */
}
</t>
<t tx="T1181"></t>
<t tx="T1182">static int
com_argdefs(struct compiling *c, node *n)
{
	int i, nch, nargs, ndefs;
	if (TYPE(n) == lambdef) {
		/* lambdef: 'lambda' [varargslist] ':' test */
		n = CHILD(n, 1);
	}
	else {
		REQ(n, funcdef); /* funcdef: 'def' NAME parameters ... */
		n = CHILD(n, 2);
		REQ(n, parameters); /* parameters: '(' [varargslist] ')' */
		n = CHILD(n, 1);
	}
	if (TYPE(n) != varargslist)
		    return 0;
	/* varargslist:
		(fpdef ['=' test] ',')* '*' ....... |
		fpdef ['=' test] (',' fpdef ['=' test])* [','] */
	nch = NCH(n);
	nargs = 0;
	ndefs = 0;
	for (i = 0; i &lt; nch; i++) {
		int t;
		if (TYPE(CHILD(n, i)) == STAR ||
		    TYPE(CHILD(n, i)) == DOUBLESTAR)
			break;
		nargs++;
		i++;
		if (i &gt;= nch)
			t = RPAR; /* Anything except EQUAL or COMMA */
		else
			t = TYPE(CHILD(n, i));
		if (t == EQUAL) {
			i++;
			ndefs++;
			com_node(c, CHILD(n, i));
			i++;
			if (i &gt;= nch)
				break;
			t = TYPE(CHILD(n, i));
		}
		else {
			/* Treat "(a=1, b)" as an error */
			if (ndefs)
				com_error(c, PyExc_SyntaxError,
			    "non-default argument follows default argument");
		}
		if (t != COMMA)
			break;
	}
	return ndefs;
}
</t>
<t tx="T1183">static void
com_funcdef(struct compiling *c, node *n)
{
	PyObject *co;
	int ndefs;
	REQ(n, funcdef); /* funcdef: 'def' NAME parameters ':' suite */
	ndefs = com_argdefs(c, n);
	symtable_enter_scope(c-&gt;c_symtable, STR(CHILD(n, 1)), TYPE(n),
			     n-&gt;n_lineno);
	co = (PyObject *)icompile(n, c);
	symtable_exit_scope(c-&gt;c_symtable);
	if (co == NULL)
		c-&gt;c_errors++;
	else {
		int closure = com_make_closure(c, (PyCodeObject *)co);
		int i = com_addconst(c, co);
		com_addoparg(c, LOAD_CONST, i);
		com_push(c, 1);
		if (closure)
			com_addoparg(c, MAKE_CLOSURE, ndefs);
		else
			com_addoparg(c, MAKE_FUNCTION, ndefs);
		com_pop(c, ndefs);
		com_addop_varname(c, VAR_STORE, STR(CHILD(n, 1)));
		com_pop(c, 1);
		Py_DECREF(co);
	}
}
</t>
<t tx="T1184">static void
com_bases(struct compiling *c, node *n)
{
	int i;
	REQ(n, testlist);
	/* testlist: test (',' test)* [','] */
	for (i = 0; i &lt; NCH(n); i += 2)
		com_node(c, CHILD(n, i));
	i = (NCH(n)+1) / 2;
	com_addoparg(c, BUILD_TUPLE, i);
	com_pop(c, i-1);
}
</t>
<t tx="T1185">static void
com_classdef(struct compiling *c, node *n)
{
	int i;
	PyObject *v;
	PyCodeObject *co;
	char *name;

	REQ(n, classdef);
	/* classdef: class NAME ['(' testlist ')'] ':' suite */
	if ((v = PyString_InternFromString(STR(CHILD(n, 1)))) == NULL) {
		c-&gt;c_errors++;
		return;
	}
	/* Push the class name on the stack */
	i = com_addconst(c, v);
	com_addoparg(c, LOAD_CONST, i);
	com_push(c, 1);
	Py_DECREF(v);
	/* Push the tuple of base classes on the stack */
	if (TYPE(CHILD(n, 2)) != LPAR) {
		com_addoparg(c, BUILD_TUPLE, 0);
		com_push(c, 1);
	}
	else
		com_bases(c, CHILD(n, 3));
	name = STR(CHILD(n, 1));
	symtable_enter_scope(c-&gt;c_symtable, name, TYPE(n), n-&gt;n_lineno);
	co = icompile(n, c);
	symtable_exit_scope(c-&gt;c_symtable);
	if (co == NULL)
		c-&gt;c_errors++;
	else {
		int closure = com_make_closure(c, co);
		i = com_addconst(c, (PyObject *)co);
		com_addoparg(c, LOAD_CONST, i);
		com_push(c, 1);
		if (closure) {
			com_addoparg(c, MAKE_CLOSURE, 0);
			com_pop(c, PyCode_GetNumFree(co));
		} else
			com_addoparg(c, MAKE_FUNCTION, 0);
		com_addoparg(c, CALL_FUNCTION, 0);
		com_addbyte(c, BUILD_CLASS);
		com_pop(c, 2);
		com_addop_varname(c, VAR_STORE, STR(CHILD(n, 1)));
		com_pop(c, 1);
		Py_DECREF(co);
	}
}
</t>
<t tx="T1186">static void
com_node(struct compiling *c, node *n)
{
 loop:
	if (c-&gt;c_errors)
		return;
	switch (TYPE(n)) {
	
	/* Definition nodes */
	
	case funcdef:
		com_funcdef(c, n);
		break;
	case classdef:
		com_classdef(c, n);
		break;
	
	/* Trivial parse tree nodes */
	
	case stmt:
	case small_stmt:
	case flow_stmt:
		n = CHILD(n, 0);
		goto loop;

	case simple_stmt:
		/* small_stmt (';' small_stmt)* [';'] NEWLINE */
		com_addoparg(c, SET_LINENO, n-&gt;n_lineno);
		{
			int i;
			for (i = 0; i &lt; NCH(n)-1; i += 2)
				com_node(c, CHILD(n, i));
		}
		break;
	
	case compound_stmt:
		com_addoparg(c, SET_LINENO, n-&gt;n_lineno);
		n = CHILD(n, 0);
		goto loop;

	/* Statement nodes */
	
	case expr_stmt:
		com_expr_stmt(c, n);
		break;
	case print_stmt:
		com_print_stmt(c, n);
		break;
	case del_stmt: /* 'del' exprlist */
		com_assign(c, CHILD(n, 1), OP_DELETE, NULL);
		break;
	case pass_stmt:
		break;
	case break_stmt:
		if (c-&gt;c_loops == 0) {
			com_error(c, PyExc_SyntaxError,
				  "'break' outside loop");
		}
		com_addbyte(c, BREAK_LOOP);
		break;
	case continue_stmt:
		com_continue_stmt(c, n);
		break;
	case return_stmt:
		com_return_stmt(c, n);
		break;
	case yield_stmt:
		com_yield_stmt(c, n);
		break;
	case raise_stmt:
		com_raise_stmt(c, n);
		break;
	case import_stmt:
		com_import_stmt(c, n);
		break;
	case global_stmt:
		break;
	case exec_stmt:
		com_exec_stmt(c, n);
		break;
	case assert_stmt:
		com_assert_stmt(c, n);
		break;
	case if_stmt:
		com_if_stmt(c, n);
		break;
	case while_stmt:
		com_while_stmt(c, n);
		break;
	case for_stmt:
		com_for_stmt(c, n);
		break;
	case try_stmt:
		com_try_stmt(c, n);
		break;
	case suite:
		com_suite(c, n);
		break;
	
	/* Expression nodes */
	
	case testlist:
	case testlist_safe:
		com_list(c, n, 0);
		break;
	case test:
		com_test(c, n);
		break;
	case and_test:
		com_and_test(c, n);
		break;
	case not_test:
		com_not_test(c, n);
		break;
	case comparison:
		com_comparison(c, n);
		break;
	case exprlist:
		com_list(c, n, 0);
		break;
	case expr:
		com_expr(c, n);
		break;
	case xor_expr:
		com_xor_expr(c, n);
		break;
	case and_expr:
		com_and_expr(c, n);
		break;
	case shift_expr:
		com_shift_expr(c, n);
		break;
	case arith_expr:
		com_arith_expr(c, n);
		break;
	case term:
		com_term(c, n);
		break;
	case factor:
		com_factor(c, n);
		break;
	case power:
		com_power(c, n);
		break;
	case atom:
		com_atom(c, n);
		break;
	
	default:
		com_error(c, PyExc_SystemError,
			  "com_node: unexpected node type");
	}
}
</t>
<t tx="T1187">static void com_fplist(struct compiling *, node *);

static void
com_fpdef(struct compiling *c, node *n)
{
	REQ(n, fpdef); /* fpdef: NAME | '(' fplist ')' */
	if (TYPE(CHILD(n, 0)) == LPAR)
		com_fplist(c, CHILD(n, 1));
	else {
		com_addop_varname(c, VAR_STORE, STR(CHILD(n, 0)));
		com_pop(c, 1);
	}
}
</t>
<t tx="T1188">static void
com_fplist(struct compiling *c, node *n)
{
	REQ(n, fplist); /* fplist: fpdef (',' fpdef)* [','] */
	if (NCH(n) == 1) {
		com_fpdef(c, CHILD(n, 0));
	}
	else {
		int i = (NCH(n)+1)/2;
		com_addoparg(c, UNPACK_SEQUENCE, i);
		com_push(c, i-1);
		for (i = 0; i &lt; NCH(n); i += 2)
			com_fpdef(c, CHILD(n, i));
	}
}
</t>
<t tx="T1189">static void
com_arglist(struct compiling *c, node *n)
{
	int nch, i, narg;
	int complex = 0;
	char nbuf[30];
	REQ(n, varargslist);
	/* varargslist:
		(fpdef ['=' test] ',')* (fpdef ['=' test] | '*' .....) */
	nch = NCH(n);
	/* Enter all arguments in table of locals */
	for (i = 0, narg = 0; i &lt; nch; i++) {
		node *ch = CHILD(n, i);
		node *fp;
		if (TYPE(ch) == STAR || TYPE(ch) == DOUBLESTAR)
			break;
		REQ(ch, fpdef); /* fpdef: NAME | '(' fplist ')' */
		fp = CHILD(ch, 0);
		if (TYPE(fp) != NAME) {
			PyOS_snprintf(nbuf, sizeof(nbuf), ".%d", i);
			complex = 1;
		}
		narg++;
		/* all name updates handled by symtable */
		if (++i &gt;= nch)
			break;
		ch = CHILD(n, i);
		if (TYPE(ch) == EQUAL)
			i += 2;
		else
			REQ(ch, COMMA);
	}
	if (complex) {
		/* Generate code for complex arguments only after
		   having counted the simple arguments */
		int ilocal = 0;
		for (i = 0; i &lt; nch; i++) {
			node *ch = CHILD(n, i);
			node *fp;
			if (TYPE(ch) == STAR || TYPE(ch) == DOUBLESTAR)
				break;
			REQ(ch, fpdef); /* fpdef: NAME | '(' fplist ')' */
			fp = CHILD(ch, 0);
			if (TYPE(fp) != NAME) {
				com_addoparg(c, LOAD_FAST, ilocal);
				com_push(c, 1);
				com_fpdef(c, ch);
			}
			ilocal++;
			if (++i &gt;= nch)
				break;
			ch = CHILD(n, i);
			if (TYPE(ch) == EQUAL)
				i += 2;
			else
				REQ(ch, COMMA);
		}
	}
}
</t>
<t tx="T1190"></t>
<t tx="T1191">@ Top-level compile-node interface
@c

static void
compile_funcdef(struct compiling *c, node *n)
{
	PyObject *doc;
	node *ch;
	REQ(n, funcdef); /* funcdef: 'def' NAME parameters ':' suite */
	c-&gt;c_name = STR(CHILD(n, 1));
	doc = get_docstring(c, CHILD(n, 4));
	if (doc != NULL) {
		(void) com_addconst(c, doc);
		Py_DECREF(doc);
	}
	else
		(void) com_addconst(c, Py_None); /* No docstring */
	ch = CHILD(n, 2); /* parameters: '(' [varargslist] ')' */
	ch = CHILD(ch, 1); /* ')' | varargslist */
	if (TYPE(ch) == varargslist)
		com_arglist(c, ch);
	c-&gt;c_infunction = 1;
	com_node(c, CHILD(n, 4));
	c-&gt;c_infunction = 0;
	com_addoparg(c, LOAD_CONST, com_addconst(c, Py_None));
	com_push(c, 1);
	com_addbyte(c, RETURN_VALUE);
	com_pop(c, 1);
}
</t>
<t tx="T1192">static void
compile_lambdef(struct compiling *c, node *n)
{
	node *ch;
	REQ(n, lambdef); /* lambdef: 'lambda' [varargslist] ':' test */
	c-&gt;c_name = "&lt;lambda&gt;";

	ch = CHILD(n, 1);
	(void) com_addconst(c, Py_None); /* No docstring */
	if (TYPE(ch) == varargslist) {
		com_arglist(c, ch);
		ch = CHILD(n, 3);
	}
	else
		ch = CHILD(n, 2);
	com_node(c, ch);
	com_addbyte(c, RETURN_VALUE);
	com_pop(c, 1);
}
</t>
<t tx="T1193">static void
compile_classdef(struct compiling *c, node *n)
{
	node *ch;
	PyObject *doc;
	REQ(n, classdef);
	/* classdef: 'class' NAME ['(' testlist ')'] ':' suite */
	c-&gt;c_name = STR(CHILD(n, 1));
	c-&gt;c_private = c-&gt;c_name;
	/* Initialize local __module__ from global __name__ */
	com_addop_name(c, LOAD_GLOBAL, "__name__");
	com_addop_name(c, STORE_NAME, "__module__");
	ch = CHILD(n, NCH(n)-1); /* The suite */
	doc = get_docstring(c, ch);
	if (doc != NULL) {
		int i = com_addconst(c, doc);
		Py_DECREF(doc);
		com_addoparg(c, LOAD_CONST, i);
		com_push(c, 1);
		com_addop_name(c, STORE_NAME, "__doc__");
		com_pop(c, 1);
	}
	else
		(void) com_addconst(c, Py_None);
	com_node(c, ch);
	com_addbyte(c, LOAD_LOCALS);
	com_push(c, 1);
	com_addbyte(c, RETURN_VALUE);
	com_pop(c, 1);
}
</t>
<t tx="T1194">static PyObject *
dict_keys_inorder(PyObject *dict, int offset)
{
	PyObject *tuple, *k, *v;
	int i, pos = 0, size = PyDict_Size(dict);

	tuple = PyTuple_New(size);
	if (tuple == NULL)
		return NULL;
	while (PyDict_Next(dict, &amp;pos, &amp;k, &amp;v)) {
		i = PyInt_AS_LONG(v);
		Py_INCREF(k);
		assert((i - offset) &lt; size);
		PyTuple_SET_ITEM(tuple, i - offset, k);
	}
	return tuple;
}
</t>
<t tx="T1195">PyCodeObject *
PyNode_Compile(node *n, char *filename)
{
	return PyNode_CompileFlags(n, filename, NULL);
}
</t>
<t tx="T1196">PyCodeObject *
PyNode_CompileFlags(node *n, char *filename, PyCompilerFlags *flags)
{
	return jcompile(n, filename, NULL, flags);
}
</t>
<t tx="T1197">struct symtable *
PyNode_CompileSymtable(node *n, char *filename)
{
	struct symtable *st;
	PyFutureFeatures *ff;

	ff = PyNode_Future(n, filename);
	if (ff == NULL)
		return NULL;

	st = symtable_init();
	if (st == NULL) {
		PyMem_Free((void *)ff);
		return NULL;
	}
	st-&gt;st_future = ff;
	symtable_enter_scope(st, TOP, TYPE(n), n-&gt;n_lineno);
	if (st-&gt;st_errors &gt; 0)
		goto fail;
	symtable_node(st, n);
	if (st-&gt;st_errors &gt; 0)
		goto fail;
	
	return st;
 fail:
	PyMem_Free((void *)ff);
	st-&gt;st_future = NULL;
	PySymtable_Free(st);
	return NULL;
}
</t>
<t tx="T1198">static PyCodeObject *
icompile(node *n, struct compiling *base)
{
	return jcompile(n, base-&gt;c_filename, base, NULL);
}
</t>
<t tx="T1199">int
PyCode_Addr2Line(PyCodeObject *co, int addrq)
{
	int size = PyString_Size(co-&gt;co_lnotab) / 2;
	unsigned char *p = (unsigned char*)PyString_AsString(co-&gt;co_lnotab);
	int line = co-&gt;co_firstlineno;
	int addr = 0;
	while (--size &gt;= 0) {
		addr += *p++;
		if (addr &gt; addrq)
			break;
		line += *p++;
	}
	return line;
}
</t>
<t tx="T1200">@ The test for LOCAL must come before the test for FREE in order to  handle classes where name is both local and free. The local var is  a method and the free var is a free var referenced within a method.
@c

static int
get_ref_type(struct compiling *c, char *name)
{
	char buf[350];
	PyObject *v;

	if (PyDict_GetItemString(c-&gt;c_cellvars, name) != NULL)
		return CELL;
	if (PyDict_GetItemString(c-&gt;c_locals, name) != NULL)
		return LOCAL;
	if (PyDict_GetItemString(c-&gt;c_freevars, name) != NULL)
		return FREE;
	v = PyDict_GetItemString(c-&gt;c_globals, name);
	if (v) {
		if (v == Py_None)
			return GLOBAL_EXPLICIT;
		else {
			return GLOBAL_IMPLICIT;
		}
	}
	PyOS_snprintf(buf, sizeof(buf),
		"unknown scope for %.100s in %.100s(%s) "
		"in %s\nsymbols: %s\nlocals: %s\nglobals: %s\n",
		name, c-&gt;c_name, 
		PyObject_REPR(c-&gt;c_symtable-&gt;st_cur-&gt;ste_id),
		c-&gt;c_filename,
		PyObject_REPR(c-&gt;c_symtable-&gt;st_cur-&gt;ste_symbols),
		PyObject_REPR(c-&gt;c_locals),
		PyObject_REPR(c-&gt;c_globals)
		);

	Py_FatalError(buf);
	return -1;
}
</t>
<t tx="T1201">@ Helper functions to issue warnings
@c

static int
issue_warning(char *msg, char *filename, int lineno)
{
	if (PyErr_WarnExplicit(PyExc_SyntaxWarning, msg, filename,
			       lineno, NULL, NULL) &lt; 0)	{
		if (PyErr_ExceptionMatches(PyExc_SyntaxWarning)) {
			PyErr_SetString(PyExc_SyntaxError, msg);
			PyErr_SyntaxLocation(filename, lineno);
		}
		return -1;
	}
	return 0;
}
</t>
<t tx="T1202"></t>
<t tx="T1203">static int
symtable_warn(struct symtable *st, char *msg)
{
	if (issue_warning(msg, st-&gt;st_filename, st-&gt;st_cur-&gt;ste_lineno) &lt; 0) {
		st-&gt;st_errors++;
		return -1;
	}
	return 0;
}
</t>
<t tx="T1204">@ Helper function for setting lineno and filename
@c

static int
symtable_build(struct compiling *c, node *n)
{
	if ((c-&gt;c_symtable = symtable_init()) == NULL)
		return -1;
	c-&gt;c_symtable-&gt;st_future = c-&gt;c_future;
	c-&gt;c_symtable-&gt;st_filename = c-&gt;c_filename;
	symtable_enter_scope(c-&gt;c_symtable, TOP, TYPE(n), n-&gt;n_lineno);
	if (c-&gt;c_symtable-&gt;st_errors &gt; 0)
		return -1;
	symtable_node(c-&gt;c_symtable, n);
	if (c-&gt;c_symtable-&gt;st_errors &gt; 0)
		return -1;
	/* reset for second pass */
	c-&gt;c_symtable-&gt;st_nscopes = 1;
	c-&gt;c_symtable-&gt;st_pass = 2;
	return 0;
}
</t>
<t tx="T1205">static int
symtable_init_compiling_symbols(struct compiling *c)
{
	PyObject *varnames;

	varnames = c-&gt;c_symtable-&gt;st_cur-&gt;ste_varnames;
	if (varnames == NULL) {
		varnames = PyList_New(0);
		if (varnames == NULL)
			return -1;
		c-&gt;c_symtable-&gt;st_cur-&gt;ste_varnames = varnames;
		Py_INCREF(varnames);
	} else
		Py_INCREF(varnames);
	c-&gt;c_varnames = varnames;

	c-&gt;c_globals = PyDict_New();
	if (c-&gt;c_globals == NULL)
		return -1;
	c-&gt;c_freevars = PyDict_New();
	if (c-&gt;c_freevars == NULL)
		return -1;
	c-&gt;c_cellvars = PyDict_New();
	if (c-&gt;c_cellvars == NULL)
		return -1;
	return 0;
}
</t>
<t tx="T1206">struct symbol_info {
	int si_nlocals;
	int si_ncells;
	int si_nfrees;
	int si_nimplicit;
};

static void
symtable_init_info(struct symbol_info *si)
{
	si-&gt;si_nlocals = 0;
	si-&gt;si_ncells = 0;
	si-&gt;si_nfrees = 0;
	si-&gt;si_nimplicit = 0;
}
</t>
<t tx="T1207">static int
symtable_resolve_free(struct compiling *c, PyObject *name, int flags,
		      struct symbol_info *si)
{
	PyObject *dict, *v;

	/* Seperate logic for DEF_FREE.  If it occurs in a function,
	   it indicates a local that we must allocate storage for (a
	   cell var).  If it occurs in a class, then the class has a
	   method and a free variable with the same name.
	*/
	if (c-&gt;c_symtable-&gt;st_cur-&gt;ste_type == TYPE_FUNCTION) {
		/* If it isn't declared locally, it can't be a cell. */
		if (!(flags &amp; (DEF_LOCAL | DEF_PARAM)))
			return 0;
		v = PyInt_FromLong(si-&gt;si_ncells++);
		dict = c-&gt;c_cellvars;
	} else {
		/* If it is free anyway, then there is no need to do
		   anything here.
		*/
		if (is_free(flags ^ DEF_FREE_CLASS) 
		    || (flags == DEF_FREE_CLASS))
			return 0;
		v = PyInt_FromLong(si-&gt;si_nfrees++);
		dict = c-&gt;c_freevars;
	}
	if (v == NULL)
		return -1;
	if (PyDict_SetItem(dict, name, v) &lt; 0) {
		Py_DECREF(v);
		return -1;
	}
	Py_DECREF(v);
	return 0;
}
</t>
<t tx="T1208">@ If a variable is a cell and an argument, make sure that appears in  co_cellvars before any variable to its right in varnames.
@c

static int
symtable_cellvar_offsets(PyObject **cellvars, int argcount, 
			 PyObject *varnames, int flags) 
{
	PyObject *v, *w, *d, *list = NULL;
	int i, pos;

	if (flags &amp; CO_VARARGS)
		argcount++;
	if (flags &amp; CO_VARKEYWORDS)
		argcount++;
	for (i = argcount; --i &gt;= 0; ) {
		v = PyList_GET_ITEM(varnames, i);
		if (PyDict_GetItem(*cellvars, v)) {
			if (list == NULL) {
				list = PyList_New(1);
				if (list == NULL)
					return -1;
				PyList_SET_ITEM(list, 0, v);
				Py_INCREF(v);
			} else
				PyList_Insert(list, 0, v);
		}
	}
	if (list == NULL || PyList_GET_SIZE(list) == 0)
		return 0;
	/* There are cellvars that are also arguments.  Create a dict
	   to replace cellvars and put the args at the front.
	*/
	d = PyDict_New();
	for (i = PyList_GET_SIZE(list); --i &gt;= 0; ) {
		v = PyInt_FromLong(i);
		if (v == NULL) 
			goto fail;
		if (PyDict_SetItem(d, PyList_GET_ITEM(list, i), v) &lt; 0)
			goto fail;
		if (PyDict_DelItem(*cellvars, PyList_GET_ITEM(list, i)) &lt; 0)
			goto fail;
	}
	pos = 0;
	i = PyList_GET_SIZE(list);
	Py_DECREF(list);
	while (PyDict_Next(*cellvars, &amp;pos, &amp;v, &amp;w)) {
		w = PyInt_FromLong(i++);  /* don't care about the old key */
		if (PyDict_SetItem(d, v, w) &lt; 0) {
			Py_DECREF(w);
			goto fail;
		}
		Py_DECREF(w);
	}
	Py_DECREF(*cellvars);
	*cellvars = d;
	return 1;
 fail:
	Py_DECREF(d);
	return -1;
}
</t>
<t tx="T1209">static int
symtable_freevar_offsets(PyObject *freevars, int offset)
{
	PyObject *name, *v;
	int pos;

	/* The cell vars are the first elements of the closure,
	   followed by the free vars.  Update the offsets in
	   c_freevars to account for number of cellvars. */  
	pos = 0;
	while (PyDict_Next(freevars, &amp;pos, &amp;name, &amp;v)) {
		int i = PyInt_AS_LONG(v) + offset;
		PyObject *o = PyInt_FromLong(i);
		if (o == NULL)
			return -1;
		if (PyDict_SetItem(freevars, name, o) &lt; 0) {
			Py_DECREF(o);
			return -1;
		}
		Py_DECREF(o);
	}
	return 0;
}
</t>
<t tx="T1210">static int
symtable_check_unoptimized(struct compiling *c,
			   PySymtableEntryObject *ste, 
			   struct symbol_info *si)
{
	char buf[300];

	if (!(si-&gt;si_ncells || si-&gt;si_nfrees || ste-&gt;ste_child_free
	      || (ste-&gt;ste_nested &amp;&amp; si-&gt;si_nimplicit)))
		return 0;

#define ILLEGAL_CONTAINS "contains a nested function with free variables"

#define ILLEGAL_IS "is a nested function"

#define ILLEGAL_IMPORT_STAR \
"import * is not allowed in function '%.100s' because it %s"

#define ILLEGAL_BARE_EXEC \
"unqualified exec is not allowed in function '%.100s' it %s"

#define ILLEGAL_EXEC_AND_IMPORT_STAR \
"function '%.100s' uses import * and bare exec, which are illegal " \
"because it %s"

	/* XXX perhaps the linenos for these opt-breaking statements
	   should be stored so the exception can point to them. */

	if (ste-&gt;ste_child_free) {
		if (ste-&gt;ste_optimized == OPT_IMPORT_STAR)
			PyOS_snprintf(buf, sizeof(buf),
				      ILLEGAL_IMPORT_STAR, 
				      PyString_AS_STRING(ste-&gt;ste_name),
				      ILLEGAL_CONTAINS);
		else if (ste-&gt;ste_optimized == (OPT_BARE_EXEC | OPT_EXEC))
			PyOS_snprintf(buf, sizeof(buf),
				      ILLEGAL_BARE_EXEC,
				      PyString_AS_STRING(ste-&gt;ste_name),
				      ILLEGAL_CONTAINS);
		else {
			PyOS_snprintf(buf, sizeof(buf),
				      ILLEGAL_EXEC_AND_IMPORT_STAR,
				      PyString_AS_STRING(ste-&gt;ste_name),
				      ILLEGAL_CONTAINS);
		}
	} else {
		if (ste-&gt;ste_optimized == OPT_IMPORT_STAR)
			PyOS_snprintf(buf, sizeof(buf),
				      ILLEGAL_IMPORT_STAR, 
				      PyString_AS_STRING(ste-&gt;ste_name),
				      ILLEGAL_IS);
		else if (ste-&gt;ste_optimized == (OPT_BARE_EXEC | OPT_EXEC))
			PyOS_snprintf(buf, sizeof(buf),
				      ILLEGAL_BARE_EXEC,
				      PyString_AS_STRING(ste-&gt;ste_name),
				      ILLEGAL_IS);
		else {
			PyOS_snprintf(buf, sizeof(buf),
				      ILLEGAL_EXEC_AND_IMPORT_STAR,
				      PyString_AS_STRING(ste-&gt;ste_name),
				      ILLEGAL_IS);
		}
	}

	PyErr_SetString(PyExc_SyntaxError, buf);
	PyErr_SyntaxLocation(c-&gt;c_symtable-&gt;st_filename,
			     ste-&gt;ste_opt_lineno);
	return -1;
}
</t>
<t tx="T1211">static int
symtable_update_flags(struct compiling *c, PySymtableEntryObject *ste,
		      struct symbol_info *si)
{
	if (c-&gt;c_future)
		c-&gt;c_flags |= c-&gt;c_future-&gt;ff_features;
	if (ste-&gt;ste_generator)
		c-&gt;c_flags |= CO_GENERATOR;
	if (ste-&gt;ste_type != TYPE_MODULE)
		c-&gt;c_flags |= CO_NEWLOCALS;
	if (ste-&gt;ste_type == TYPE_FUNCTION) {
		c-&gt;c_nlocals = si-&gt;si_nlocals;
		if (ste-&gt;ste_optimized == 0)
			c-&gt;c_flags |= CO_OPTIMIZED;
		else if (ste-&gt;ste_optimized != OPT_EXEC) 
			return symtable_check_unoptimized(c, ste, si);
	}
	return 0;
}
</t>
<t tx="T1212">static int
symtable_load_symbols(struct compiling *c)
{
	static PyObject *implicit = NULL;
	struct symtable *st = c-&gt;c_symtable;
	PySymtableEntryObject *ste = st-&gt;st_cur;
	PyObject *name, *varnames, *v;
	int i, flags, pos;
	struct symbol_info si;

	if (implicit == NULL) {
		implicit = PyInt_FromLong(1);
		if (implicit == NULL)
			return -1;
	}
	v = NULL;

	if (symtable_init_compiling_symbols(c) &lt; 0)
		goto fail;
	symtable_init_info(&amp;si);
	varnames = st-&gt;st_cur-&gt;ste_varnames;
	si.si_nlocals = PyList_GET_SIZE(varnames);
	c-&gt;c_argcount = si.si_nlocals;

	for (i = 0; i &lt; si.si_nlocals; ++i) {
		v = PyInt_FromLong(i);
		if (PyDict_SetItem(c-&gt;c_locals, 
				   PyList_GET_ITEM(varnames, i), v) &lt; 0)
			goto fail;
		Py_DECREF(v);
	}

	/* XXX The cases below define the rules for whether a name is
	   local or global.  The logic could probably be clearer. */
	pos = 0;
	while (PyDict_Next(ste-&gt;ste_symbols, &amp;pos, &amp;name, &amp;v)) {
		flags = PyInt_AS_LONG(v);

		if (flags &amp; DEF_FREE_GLOBAL)
			/* undo the original DEF_FREE */
			flags &amp;= ~(DEF_FREE | DEF_FREE_CLASS);

		/* Deal with names that need two actions:
		   1. Cell variables that are also locals.
		   2. Free variables in methods that are also class
		   variables or declared global.
		*/
		if (flags &amp; (DEF_FREE | DEF_FREE_CLASS))
			symtable_resolve_free(c, name, flags, &amp;si);

		if (flags &amp; DEF_STAR) {
			c-&gt;c_argcount--;
			c-&gt;c_flags |= CO_VARARGS;
		} else if (flags &amp; DEF_DOUBLESTAR) {
			c-&gt;c_argcount--;
			c-&gt;c_flags |= CO_VARKEYWORDS;
		} else if (flags &amp; DEF_INTUPLE) 
			c-&gt;c_argcount--;
		else if (flags &amp; DEF_GLOBAL) {
			if (flags &amp; DEF_PARAM) {
				PyErr_Format(PyExc_SyntaxError, LOCAL_GLOBAL,
					     PyString_AS_STRING(name));
				PyErr_SyntaxLocation(st-&gt;st_filename, 
						   ste-&gt;ste_lineno);
				st-&gt;st_errors++;
				goto fail;
			}
			if (PyDict_SetItem(c-&gt;c_globals, name, Py_None) &lt; 0)
				goto fail;
		} else if (flags &amp; DEF_FREE_GLOBAL) {
			si.si_nimplicit++;
			if (PyDict_SetItem(c-&gt;c_globals, name, implicit) &lt; 0)
				goto fail;
		} else if ((flags &amp; DEF_LOCAL) &amp;&amp; !(flags &amp; DEF_PARAM)) {
			v = PyInt_FromLong(si.si_nlocals++);
			if (v == NULL)
				goto fail;
			if (PyDict_SetItem(c-&gt;c_locals, name, v) &lt; 0)
				goto fail;
			Py_DECREF(v);
			if (ste-&gt;ste_type != TYPE_CLASS) 
				if (PyList_Append(c-&gt;c_varnames, name) &lt; 0)
					goto fail;
		} else if (is_free(flags)) {
			if (ste-&gt;ste_nested) {
				v = PyInt_FromLong(si.si_nfrees++);
				if (v == NULL)
					goto fail;
				if (PyDict_SetItem(c-&gt;c_freevars, name, v) &lt; 0)
					goto fail;
				Py_DECREF(v);
			} else {
				si.si_nimplicit++;
 				if (PyDict_SetItem(c-&gt;c_globals, name,
 						   implicit) &lt; 0)
 					goto fail;
 				if (st-&gt;st_nscopes != 1) {
 					v = PyInt_FromLong(flags);
 					if (PyDict_SetItem(st-&gt;st_global, 
 							   name, v)) 
 						goto fail;
 					Py_DECREF(v);
 				}
			}
		}
	}

	assert(PyDict_Size(c-&gt;c_freevars) == si.si_nfrees);

	if (si.si_ncells &gt; 1) { /* one cell is always in order */
		if (symtable_cellvar_offsets(&amp;c-&gt;c_cellvars, c-&gt;c_argcount,
					     c-&gt;c_varnames, c-&gt;c_flags) &lt; 0)
			return -1;
	}
	if (symtable_freevar_offsets(c-&gt;c_freevars, si.si_ncells) &lt; 0)
		return -1;
	return symtable_update_flags(c, ste, &amp;si);
 fail:
	/* is this always the right thing to do? */
	Py_XDECREF(v);
	return -1;
}
</t>
<t tx="T1213">static struct symtable *
symtable_init()
{
	struct symtable *st;

	st = (struct symtable *)PyMem_Malloc(sizeof(struct symtable));
	if (st == NULL)
		return NULL;
	st-&gt;st_pass = 1;

	st-&gt;st_filename = NULL;
	if ((st-&gt;st_stack = PyList_New(0)) == NULL)
		goto fail;
	if ((st-&gt;st_symbols = PyDict_New()) == NULL)
		goto fail; 
	st-&gt;st_cur = NULL;
	st-&gt;st_nscopes = 0;
	st-&gt;st_errors = 0;
	st-&gt;st_tmpname = 0;
	st-&gt;st_private = NULL;
	return st;
 fail:
	PySymtable_Free(st);
	return NULL;
}
</t>
<t tx="T1214">void
PySymtable_Free(struct symtable *st)
{
	Py_XDECREF(st-&gt;st_symbols);
	Py_XDECREF(st-&gt;st_stack);
	Py_XDECREF(st-&gt;st_cur);
	PyMem_Free((void *)st);
}
</t>
<t tx="T1215">@ When the compiler exits a scope, it must should update the scope's  free variable information with the list of free variables in its  children.   Variables that are free in children and defined in the current  scope are cellvars.   If the scope being exited is defined at the top-level (ste_nested is  false), free variables in children that are not defined here are  implicit globals.
@c

static int
symtable_update_free_vars(struct symtable *st)
{
	int i, j, def;
	PyObject *o, *name, *list = NULL;
	PySymtableEntryObject *child, *ste = st-&gt;st_cur;

	if (ste-&gt;ste_type == TYPE_CLASS)
		def = DEF_FREE_CLASS;
	else
		def = DEF_FREE;
	for (i = 0; i &lt; PyList_GET_SIZE(ste-&gt;ste_children); ++i) {
		int pos = 0;

		if (list)
			PyList_SetSlice(list, 0, 
					((PyVarObject*)list)-&gt;ob_size, 0);
		child = (PySymtableEntryObject *)
			PyList_GET_ITEM(ste-&gt;ste_children, i);
		while (PyDict_Next(child-&gt;ste_symbols, &amp;pos, &amp;name, &amp;o)) {
			int flags = PyInt_AS_LONG(o);
			if (!(is_free(flags)))
				continue; /* avoids indentation */
			if (list == NULL) {
				list = PyList_New(0);
				if (list == NULL)
					return -1;
			}
			ste-&gt;ste_child_free = 1;
			if (PyList_Append(list, name) &lt; 0) {
				Py_DECREF(list);
				return -1;
			}
		}
		for (j = 0; list &amp;&amp; j &lt; PyList_GET_SIZE(list); j++) {
			PyObject *v;
			name = PyList_GET_ITEM(list, j);
			v = PyDict_GetItem(ste-&gt;ste_symbols, name);
			/* If a name N is declared global in scope A and
			   referenced in scope B contained (perhaps
			   indirectly) in A and there are no scopes
			   with bindings for N between B and A, then N
			   is global in B.  Unless A is a class scope,
			   because class scopes are not considered for
			   nested scopes.
			*/
			if (v &amp;&amp; (ste-&gt;ste_type != TYPE_CLASS)) {
				int flags = PyInt_AS_LONG(v); 
				if (flags &amp; DEF_GLOBAL) {
					symtable_undo_free(st, child-&gt;ste_id,
							   name);
					continue;
				}
			}
			if (ste-&gt;ste_nested) {
				if (symtable_add_def_o(st, ste-&gt;ste_symbols,
						       name, def) &lt; 0) {
				    Py_DECREF(list);
				    return -1;
				}
			} else {
				if (symtable_check_global(st, child-&gt;ste_id, 
							  name) &lt; 0) {
				    Py_DECREF(list);
				    return -1;
				}
			}
		}
	}

	Py_XDECREF(list);
	return 0;
}
</t>
<t tx="T1216">@ If the current scope is a non-nested class or if name is not  defined in the current, non-nested scope, then it is an implicit  global in all nested scopes.
@c

static int
symtable_check_global(struct symtable *st, PyObject *child, PyObject *name)
{
	PyObject *o;
	int v;
	PySymtableEntryObject *ste = st-&gt;st_cur;
			
	if (ste-&gt;ste_type == TYPE_CLASS)
		return symtable_undo_free(st, child, name);
	o = PyDict_GetItem(ste-&gt;ste_symbols, name);
	if (o == NULL)
		return symtable_undo_free(st, child, name);
	v = PyInt_AS_LONG(o);

	if (is_free(v) || (v &amp; DEF_GLOBAL)) 
		return symtable_undo_free(st, child, name);
	else
		return symtable_add_def_o(st, ste-&gt;ste_symbols,
					  name, DEF_FREE);
}
</t>
<t tx="T1217">static int
symtable_undo_free(struct symtable *st, PyObject *id, 
		      PyObject *name)
{
	int i, v, x;
	PyObject *info;
	PySymtableEntryObject *ste;

	ste = (PySymtableEntryObject *)PyDict_GetItem(st-&gt;st_symbols, id);
	if (ste == NULL)
		return -1;

	info = PyDict_GetItem(ste-&gt;ste_symbols, name);
	if (info == NULL)
		return 0;
	v = PyInt_AS_LONG(info);
	if (is_free(v)) {
		if (symtable_add_def_o(st, ste-&gt;ste_symbols, name,
				       DEF_FREE_GLOBAL) &lt; 0)
			return -1;
	} else
		/* If the name is defined here or declared global,
		   then the recursion stops. */
		return 0;
	
	for (i = 0; i &lt; PyList_GET_SIZE(ste-&gt;ste_children); ++i) {
		PySymtableEntryObject *child;
		child = (PySymtableEntryObject *)
			PyList_GET_ITEM(ste-&gt;ste_children, i);
		x = symtable_undo_free(st, child-&gt;ste_id, name);
		if (x &lt; 0)
			return x;
	}
	return 0;
}
</t>
<t tx="T1218">@ symtable_enter_scope() gets a reference via PySymtableEntry_New().  This reference is released when the scope is exited, via the DECREF  in symtable_exit_scope().
@c

static int
symtable_exit_scope(struct symtable *st)
{
	int end;

	if (st-&gt;st_pass == 1)
		symtable_update_free_vars(st);
	Py_DECREF(st-&gt;st_cur);
	end = PyList_GET_SIZE(st-&gt;st_stack) - 1;
	st-&gt;st_cur = (PySymtableEntryObject *)PyList_GET_ITEM(st-&gt;st_stack, 
							      end);
	if (PySequence_DelItem(st-&gt;st_stack, end) &lt; 0)
		return -1;
	return 0;
}
</t>
<t tx="T1219">static void
symtable_enter_scope(struct symtable *st, char *name, int type,
		     int lineno)
{
	PySymtableEntryObject *prev = NULL;

	if (st-&gt;st_cur) {
		prev = st-&gt;st_cur;
		if (PyList_Append(st-&gt;st_stack, (PyObject *)st-&gt;st_cur) &lt; 0) {
			Py_DECREF(st-&gt;st_cur);
			st-&gt;st_errors++;
			return;
		}
	}
	st-&gt;st_cur = (PySymtableEntryObject *)
		PySymtableEntry_New(st, name, type, lineno);
	if (strcmp(name, TOP) == 0)
		st-&gt;st_global = st-&gt;st_cur-&gt;ste_symbols;
	if (prev &amp;&amp; st-&gt;st_pass == 1) {
		if (PyList_Append(prev-&gt;ste_children, 
				  (PyObject *)st-&gt;st_cur) &lt; 0)
			st-&gt;st_errors++;
	}
}
</t>
<t tx="T1220">static int
symtable_lookup(struct symtable *st, char *name)
{
	char buffer[MANGLE_LEN];
	PyObject *v;
	int flags;

	if (mangle(st-&gt;st_private, name, buffer, sizeof(buffer)))
		name = buffer;
	v = PyDict_GetItemString(st-&gt;st_cur-&gt;ste_symbols, name);
	if (v == NULL) {
		if (PyErr_Occurred())
			return -1;
		else
			return 0;
	}

	flags = PyInt_AS_LONG(v);
	return flags;
}
</t>
<t tx="T1221">static int
symtable_add_def(struct symtable *st, char *name, int flag)
{
	PyObject *s;
	char buffer[MANGLE_LEN];
	int ret;

	if (mangle(st-&gt;st_private, name, buffer, sizeof(buffer)))
		name = buffer;
	if ((s = PyString_InternFromString(name)) == NULL)
		return -1;
	ret = symtable_add_def_o(st, st-&gt;st_cur-&gt;ste_symbols, s, flag);
	Py_DECREF(s);
	return ret;
}
</t>
<t tx="T1222">@ Must only be called with mangled names
@c

static int
symtable_add_def_o(struct symtable *st, PyObject *dict, 
		   PyObject *name, int flag) 
{
	PyObject *o;
	int val;

	if ((o = PyDict_GetItem(dict, name))) {
	    val = PyInt_AS_LONG(o);
	    if ((flag &amp; DEF_PARAM) &amp;&amp; (val &amp; DEF_PARAM)) {
		    PyErr_Format(PyExc_SyntaxError, DUPLICATE_ARGUMENT,
				 PyString_AsString(name));
		    PyErr_SyntaxLocation(st-&gt;st_filename,
				       st-&gt;st_cur-&gt;ste_lineno);
		    return -1;
	    }
	    val |= flag;
	} else
	    val = flag;
	o = PyInt_FromLong(val);
	if (PyDict_SetItem(dict, name, o) &lt; 0) {
		Py_DECREF(o);
		return -1;
	}
	Py_DECREF(o);

	if (flag &amp; DEF_PARAM) {
		if (PyList_Append(st-&gt;st_cur-&gt;ste_varnames, name) &lt; 0) 
			return -1;
	} else	if (flag &amp; DEF_GLOBAL) {
		/* XXX need to update DEF_GLOBAL for other flags too;
		   perhaps only DEF_FREE_GLOBAL */
		if ((o = PyDict_GetItem(st-&gt;st_global, name))) {
			val = PyInt_AS_LONG(o);
			val |= flag;
		} else
			val = flag;
		o = PyInt_FromLong(val);
		if (PyDict_SetItem(st-&gt;st_global, name, o) &lt; 0) {
			Py_DECREF(o);
			return -1;
		}
		Py_DECREF(o);
	}
	return 0;
}
</t>
<t tx="T1223">#define symtable_add_use(ST, NAME) symtable_add_def((ST), (NAME), USE)

/* Look for a yield stmt under n.  Return 1 if found, else 0.
   This hack is used to look inside "if 0:" blocks (which are normally
   ignored) in case those are the only places a yield occurs (so that this
   function is a generator). */
static int
look_for_yield(node *n)
{
	int i;

	for (i = 0; i &lt; NCH(n); ++i) {
		node *kid = CHILD(n, i);

		switch (TYPE(kid)) {

		case classdef:
		case funcdef:
		case lambdef:
			/* Stuff in nested functions and classes can't make
			   the parent a generator. */
			return 0;

		case yield_stmt:
			return 1;

		default:
			if (look_for_yield(kid))
				return 1;
		}
	}
	return 0;
}</t>
<t tx="T1224">static void
symtable_node(struct symtable *st, node *n)
{
	int i;

 loop:
	switch (TYPE(n)) {
	case funcdef: {
		char *func_name = STR(CHILD(n, 1));
		symtable_add_def(st, func_name, DEF_LOCAL);
		symtable_default_args(st, CHILD(n, 2));
		symtable_enter_scope(st, func_name, TYPE(n), n-&gt;n_lineno);
		symtable_funcdef(st, n);
		symtable_exit_scope(st);
		break;
	}
	case lambdef:
		if (NCH(n) == 4)
			symtable_default_args(st, CHILD(n, 1));
		symtable_enter_scope(st, "lambda", TYPE(n), n-&gt;n_lineno);
		symtable_funcdef(st, n);
		symtable_exit_scope(st);
		break;
	case classdef: {
		char *tmp, *class_name = STR(CHILD(n, 1));
		symtable_add_def(st, class_name, DEF_LOCAL);
		if (TYPE(CHILD(n, 2)) == LPAR) {
			node *bases = CHILD(n, 3);
			int i;
			for (i = 0; i &lt; NCH(bases); i += 2) {
				symtable_node(st, CHILD(bases, i));
			}
		}
		symtable_enter_scope(st, class_name, TYPE(n), n-&gt;n_lineno);
		tmp = st-&gt;st_private;
		st-&gt;st_private = class_name;
		symtable_node(st, CHILD(n, NCH(n) - 1));
		st-&gt;st_private = tmp;
		symtable_exit_scope(st);
		break;
	}
	case if_stmt:
		for (i = 0; i + 3 &lt; NCH(n); i += 4) {
			if (is_constant_false(NULL, (CHILD(n, i + 1)))) {
				if (st-&gt;st_cur-&gt;ste_generator == 0)
					st-&gt;st_cur-&gt;ste_generator =
						look_for_yield(CHILD(n, i+3));
				continue;
			}
			symtable_node(st, CHILD(n, i + 1));
			symtable_node(st, CHILD(n, i + 3));
		}
		if (i + 2 &lt; NCH(n))
			symtable_node(st, CHILD(n, i + 2));
		break;
	case global_stmt:
		symtable_global(st, n);
		break;
	case import_stmt:
		symtable_import(st, n);
		break;
	case exec_stmt: {
		st-&gt;st_cur-&gt;ste_optimized |= OPT_EXEC;
		symtable_node(st, CHILD(n, 1));
		if (NCH(n) &gt; 2)
			symtable_node(st, CHILD(n, 3));
		else {
			st-&gt;st_cur-&gt;ste_optimized |= OPT_BARE_EXEC;
			st-&gt;st_cur-&gt;ste_opt_lineno = n-&gt;n_lineno;
		}
		if (NCH(n) &gt; 4)
			symtable_node(st, CHILD(n, 5));
		break;

	}
	case assert_stmt: 
		if (Py_OptimizeFlag)
			return;
		if (NCH(n) == 2) {
			n = CHILD(n, 1);
			goto loop;
		} else {
			symtable_node(st, CHILD(n, 1));
			n = CHILD(n, 3);
			goto loop;
		}
	case except_clause:
		if (NCH(n) == 4)
			symtable_assign(st, CHILD(n, 3), 0);
		if (NCH(n) &gt; 1) {
			n = CHILD(n, 1);
			goto loop;
		}
		break;
	case del_stmt:
		symtable_assign(st, CHILD(n, 1), 0);
		break;
	case yield_stmt:
		st-&gt;st_cur-&gt;ste_generator = 1;
		n = CHILD(n, 1);
		goto loop;
	case expr_stmt:
		if (NCH(n) == 1)
			n = CHILD(n, 0);
		else {
			if (TYPE(CHILD(n, 1)) == augassign) {
				symtable_assign(st, CHILD(n, 0), 0);
				symtable_node(st, CHILD(n, 2));
				break;
			} else {
				int i;
				for (i = 0; i &lt; NCH(n) - 2; i += 2) 
					symtable_assign(st, CHILD(n, i), 0);
				n = CHILD(n, NCH(n) - 1);
			}
		}
		goto loop;
	case list_iter:
		n = CHILD(n, 0);
		if (TYPE(n) == list_for) {
			st-&gt;st_tmpname++;
			symtable_list_comprehension(st, n);
			st-&gt;st_tmpname--;
		} else {
			REQ(n, list_if);
			symtable_node(st, CHILD(n, 1));
			if (NCH(n) == 3) {
				n = CHILD(n, 2); 
				goto loop;
			}
		}
		break;
	case for_stmt:
		symtable_assign(st, CHILD(n, 1), 0);
		for (i = 3; i &lt; NCH(n); ++i)
			if (TYPE(CHILD(n, i)) &gt;= single_input)
				symtable_node(st, CHILD(n, i));
		break;
	/* The remaining cases fall through to default except in
	   special circumstances.  This requires the individual cases
	   to be coded with great care, even though they look like
	   rather innocuous.  Each case must double-check TYPE(n).
	*/
	case argument:
		if (TYPE(n) == argument &amp;&amp; NCH(n) == 3) {
			n = CHILD(n, 2);
			goto loop;
		}
		/* fall through */
	case listmaker:
		if (NCH(n) &gt; 1 &amp;&amp; TYPE(CHILD(n, 1)) == list_for) {
			st-&gt;st_tmpname++;
			symtable_list_comprehension(st, CHILD(n, 1));
			symtable_node(st, CHILD(n, 0));
			st-&gt;st_tmpname--;
			break;
		}
		/* fall through */
	case atom:
		if (TYPE(n) == atom &amp;&amp; TYPE(CHILD(n, 0)) == NAME) {
			symtable_add_use(st, STR(CHILD(n, 0)));
			break;
		}
		/* fall through */
	default:
		/* Walk over every non-token child with a special case
		   for one child.
		*/
		if (NCH(n) == 1) {
			n = CHILD(n, 0);
			goto loop;
		}
		for (i = 0; i &lt; NCH(n); ++i)
			if (TYPE(CHILD(n, i)) &gt;= single_input)
				symtable_node(st, CHILD(n, i));
	}
}
</t>
<t tx="T1225">static void
symtable_funcdef(struct symtable *st, node *n)
{
	node *body;

	if (TYPE(n) == lambdef) {
		if (NCH(n) == 4)
			symtable_params(st, CHILD(n, 1));
	} else
		symtable_params(st, CHILD(n, 2));
	body = CHILD(n, NCH(n) - 1);
	symtable_node(st, body);
}
</t>
<t tx="T1226">@ The next two functions parse the argument tuple.  symtable_default_arg() checks for names in the default arguments,  which are references in the defining scope. symtable_params()  parses the parameter names, which are defined in the function's  body.   varargslist:     (fpdef ['=' test] ',')* ('*' NAME [',' '**' NAME] | '**' NAME)  | fpdef ['=' test] (',' fpdef ['=' test])* [',']
@c

static void
symtable_default_args(struct symtable *st, node *n)
{
	node *c;
	int i;

	if (TYPE(n) == parameters) {
		n = CHILD(n, 1);
		if (TYPE(n) == RPAR)
			return;
	}
	REQ(n, varargslist);
	for (i = 0; i &lt; NCH(n); i += 2) {
		c = CHILD(n, i);
		if (TYPE(c) == STAR || TYPE(c) == DOUBLESTAR) {
			break;
		}
		if (i &gt; 0 &amp;&amp; (TYPE(CHILD(n, i - 1)) == EQUAL))
			symtable_node(st, CHILD(n, i));
	}
}
</t>
<t tx="T1227">static void
symtable_params(struct symtable *st, node *n)
{
	int i, complex = -1, ext = 0;
	node *c = NULL;

	if (TYPE(n) == parameters) {
		n = CHILD(n, 1);
		if (TYPE(n) == RPAR)
			return;
	}
	REQ(n, varargslist);
	for (i = 0; i &lt; NCH(n); i += 2) {
		c = CHILD(n, i);
		if (TYPE(c) == STAR || TYPE(c) == DOUBLESTAR) {
			ext = 1;
			break;
		}
		if (TYPE(c) == test) {
			continue;
		}
		if (TYPE(CHILD(c, 0)) == NAME)
			symtable_add_def(st, STR(CHILD(c, 0)), DEF_PARAM);
		else {
			char nbuf[30];
			PyOS_snprintf(nbuf, sizeof(nbuf), ".%d", i);
			symtable_add_def(st, nbuf, DEF_PARAM);
			complex = i;
		}
	}
	if (ext) {
		c = CHILD(n, i);
		if (TYPE(c) == STAR) {
			i++;
			symtable_add_def(st, STR(CHILD(n, i)), 
					 DEF_PARAM | DEF_STAR);
			i += 2;
			if (i &gt;= NCH(n))
				c = NULL;
			else
				c = CHILD(n, i);
		}
		if (c &amp;&amp; TYPE(c) == DOUBLESTAR) {
			i++;
			symtable_add_def(st, STR(CHILD(n, i)), 
					 DEF_PARAM | DEF_DOUBLESTAR);
		}
	}
	if (complex &gt;= 0) {
		int j;
		for (j = 0; j &lt;= complex; j++) {
			c = CHILD(n, j);
			if (TYPE(c) == COMMA)
				c = CHILD(n, ++j);
			else if (TYPE(c) == EQUAL)
				c = CHILD(n, j += 3);
			if (TYPE(CHILD(c, 0)) == LPAR)
				symtable_params_fplist(st, CHILD(c, 1));
		} 
	}
}
</t>
<t tx="T1228">static void
symtable_params_fplist(struct symtable *st, node *n)
{
	int i;
	node *c;

	REQ(n, fplist);
	for (i = 0; i &lt; NCH(n); i += 2) {
		c = CHILD(n, i);
		REQ(c, fpdef);
		if (NCH(c) == 1)
			symtable_add_def(st, STR(CHILD(c, 0)), 
					 DEF_PARAM | DEF_INTUPLE);
		else
			symtable_params_fplist(st, CHILD(c, 1));
	}
	
}
</t>
<t tx="T1229">static void
symtable_global(struct symtable *st, node *n)
{
	int i;

	/* XXX It might be helpful to warn about module-level global
	   statements, but it's hard to tell the difference between
	   module-level and a string passed to exec.
	*/

	for (i = 1; i &lt; NCH(n); i += 2) {
		char *name = STR(CHILD(n, i));
		int flags;

		flags = symtable_lookup(st, name);
		if (flags &lt; 0)
			continue;
		if (flags &amp;&amp; flags != DEF_GLOBAL) {
			char buf[500];
			if (flags &amp; DEF_PARAM) {
				PyErr_Format(PyExc_SyntaxError,
				     "name '%.400s' is local and global",
					     name);
				PyErr_SyntaxLocation(st-&gt;st_filename,
						   st-&gt;st_cur-&gt;ste_lineno);
				st-&gt;st_errors++;
				return;
			}
			else {
				if (flags &amp; DEF_LOCAL)
					PyOS_snprintf(buf, sizeof(buf),
						      GLOBAL_AFTER_ASSIGN,
						      name);
				else
					PyOS_snprintf(buf, sizeof(buf),
						      GLOBAL_AFTER_USE, name);
				symtable_warn(st, buf);
			}
		}
		symtable_add_def(st, name, DEF_GLOBAL);
	}
}
</t>
<t tx="T1230">static void
symtable_list_comprehension(struct symtable *st, node *n)
{
	char tmpname[30];

	PyOS_snprintf(tmpname, sizeof(tmpname), "_[%d]", st-&gt;st_tmpname);
	symtable_add_def(st, tmpname, DEF_LOCAL);
	symtable_assign(st, CHILD(n, 1), 0);
	symtable_node(st, CHILD(n, 3));
	if (NCH(n) == 5)
		symtable_node(st, CHILD(n, 4));
}
</t>
<t tx="T1231">static void
symtable_import(struct symtable *st, node *n)
{
	int i;
	/* import_stmt: 'import' dotted_as_name (',' dotted_as_name)* 
              | 'from' dotted_name 'import' 
                                ('*' | import_as_name (',' import_as_name)*)
	   import_as_name: NAME [NAME NAME]
	*/
	if (STR(CHILD(n, 0))[0] == 'f') {  /* from */
		node *dotname = CHILD(n, 1);
		if (strcmp(STR(CHILD(dotname, 0)), "__future__") == 0) {
			/* check for bogus imports */
			if (n-&gt;n_lineno &gt;= st-&gt;st_future-&gt;ff_last_lineno) {
				PyErr_SetString(PyExc_SyntaxError,
						LATE_FUTURE);
 				PyErr_SyntaxLocation(st-&gt;st_filename,
						   n-&gt;n_lineno);
				st-&gt;st_errors++;
				return;
			}
		}
		if (TYPE(CHILD(n, 3)) == STAR) {
			if (st-&gt;st_cur-&gt;ste_type != TYPE_MODULE) {
				if (symtable_warn(st,
				  "import * only allowed at module level") &lt; 0)
					return;
			}
			st-&gt;st_cur-&gt;ste_optimized |= OPT_IMPORT_STAR;
			st-&gt;st_cur-&gt;ste_opt_lineno = n-&gt;n_lineno;
		} else {
			for (i = 3; i &lt; NCH(n); i += 2) {
				node *c = CHILD(n, i);
				if (NCH(c) &gt; 1) /* import as */
					symtable_assign(st, CHILD(c, 2),
							DEF_IMPORT);
				else
					symtable_assign(st, CHILD(c, 0),
							DEF_IMPORT);
			}
		}
	} else { 
		for (i = 1; i &lt; NCH(n); i += 2) {
			symtable_assign(st, CHILD(n, i), DEF_IMPORT);
		}
	}
}
</t>
<t tx="T1232">@ The third argument to symatble_assign() is a flag to be passed to  symtable_add_def() if it is eventually called. The flag is useful  to specify the particular type of assignment that should be  recorded, e.g. an assignment caused by import.
@c

static void 
symtable_assign(struct symtable *st, node *n, int def_flag)
{
	node *tmp;
	int i;

 loop:
	switch (TYPE(n)) {
	case lambdef:
		/* invalid assignment, e.g. lambda x:x=2.  The next
		   pass will catch this error. */
		return;
	case power:
		if (NCH(n) &gt; 2) {
			for (i = 2; i &lt; NCH(n); ++i)
				if (TYPE(CHILD(n, i)) != DOUBLESTAR)
					symtable_node(st, CHILD(n, i));
		}
		if (NCH(n) &gt; 1) { 
			symtable_node(st, CHILD(n, 0));
			symtable_node(st, CHILD(n, 1));
		} else {
			n = CHILD(n, 0);
			goto loop;
		}
		return;
	case listmaker:
		if (NCH(n) &gt; 1 &amp;&amp; TYPE(CHILD(n, 1)) == list_for) {
			/* XXX This is an error, but the next pass
			   will catch it. */ 
			return;
		} else {
			for (i = 0; i &lt; NCH(n); i += 2)
				symtable_assign(st, CHILD(n, i), def_flag);
		}
		return;
	case exprlist:
	case testlist:
		if (NCH(n) == 1) {
			n = CHILD(n, 0);
			goto loop;
		}
		else {
			int i;
			for (i = 0; i &lt; NCH(n); i += 2)
				symtable_assign(st, CHILD(n, i), def_flag);
			return;
		}
	case atom:
		tmp = CHILD(n, 0);
		if (TYPE(tmp) == LPAR || TYPE(tmp) == LSQB) {
			n = CHILD(n, 1);
			goto loop;
		} else if (TYPE(tmp) == NAME) {
			if (strcmp(STR(tmp), "__debug__") == 0) {
				PyErr_SetString(PyExc_SyntaxError, 
						ASSIGN_DEBUG);
				PyErr_SyntaxLocation(st-&gt;st_filename,
						     n-&gt;n_lineno);
				st-&gt;st_errors++;
			}
			symtable_add_def(st, STR(tmp), DEF_LOCAL | def_flag);
		}
		return;
	case dotted_as_name:
		if (NCH(n) == 3)
			symtable_add_def(st, STR(CHILD(n, 2)),
					 DEF_LOCAL | def_flag);
		else
			symtable_add_def(st,
					 STR(CHILD(CHILD(n,
							 0), 0)),
					 DEF_LOCAL | def_flag);
		return;
	case dotted_name:
		symtable_add_def(st, STR(CHILD(n, 0)), DEF_LOCAL | def_flag);
		return;
	case NAME:
		symtable_add_def(st, STR(n), DEF_LOCAL | def_flag);
		return;
	default:
		if (NCH(n) == 0)
			return;
		if (NCH(n) == 1) {
			n = CHILD(n, 0);
			goto loop;
		}
		/* Should only occur for errors like x + 1 = 1,
		   which will be caught in the next pass. */
		for (i = 0; i &lt; NCH(n); ++i)
			if (TYPE(CHILD(n, i)) &gt;= single_input)
				symtable_assign(st, CHILD(n, i), def_flag);
	}
}
</t>
<t tx="T1233"></t>
<t tx="T1234">@language python

"""Python abstract syntax node definitions

This file is automatically generated.
"""

from types import TupleType, ListType
from consts import CO_VARARGS, CO_VARKEYWORDS

&lt;&lt; functions &gt;&gt;

@others

klasses = globals()
for k in nodes.keys():
    nodes[k] = klasses[nodes[k]]
</t>
<t tx="T1235"></t>
<t tx="T1236">def flatten(list):
    l = []
    for elt in list:
        t = type(elt)
        if t is TupleType or t is ListType:
            for elt2 in flatten(elt):
                l.append(elt2)
        else:
            l.append(elt)
    return l
</t>
<t tx="T1237">def flatten_nodes(list):
    return [n for n in flatten(list) if isinstance(n, Node)]
</t>
<t tx="T1238">def asList(nodes):
    l = []
    for item in nodes:
        if hasattr(item, "asList"):
            l.append(item.asList())
        else:
            t = type(item)
            if t is TupleType or t is ListType:
                l.append(tuple(asList(item)))
            else:
                l.append(item)
    return l
</t>
<t tx="T1239">nodes = {}

class Node: # an abstract base class

	lineno = None # provide a lineno for nodes that don't have one
	@others</t>
<t tx="T1240">def getType(self):
    pass # implemented by subclass
def getChildren(self):
    pass # implemented by subclasses
def asList(self):
    return tuple(asList(self.getChildren()))
</t>
<t tx="T1241">def getChildNodes(self):
    pass # implemented by subclasses

</t>
<t tx="T1242">class EmptyNode(Node):
	pass
</t>
<t tx="T1243">class Slice(Node):
	nodes["slice"] = "Slice"
	@others

</t>
<t tx="T1244">def __init__(self, expr, flags, lower, upper):
    self.expr = expr
    self.flags = flags
    self.lower = lower
    self.upper = upper
</t>
<t tx="T1245">def getChildren(self):
    children = []
    children.append(self.expr)
    children.append(self.flags)
    children.append(self.lower)
    children.append(self.upper)
    return tuple(children)
</t>
<t tx="T1246">def getChildNodes(self):
    nodes = []
    nodes.append(self.expr)
    if self.lower is not None:            nodes.append(self.lower)
    if self.upper is not None:            nodes.append(self.upper)
    return tuple(nodes)
</t>
<t tx="T1247">def __repr__(self):
    return "Slice(%s, %s, %s, %s)" % (repr(self.expr), repr(self.flags), repr(self.lower), repr(self.upper))
</t>
<t tx="T1248">class Const(Node):
	nodes["const"] = "Const"
	@others

</t>
<t tx="T1249">def __init__(self, value):
    self.value = value
</t>
<t tx="T1250">def getChildren(self):
    return self.value,
</t>
<t tx="T1251">def getChildNodes(self):
    return ()
</t>
<t tx="T1252">def __repr__(self):
    return "Const(%s)" % (repr(self.value),)
</t>
<t tx="T1253">class Raise(Node):
	nodes["raise"] = "Raise"
	@others


</t>
<t tx="T1254">def __init__(self, expr1, expr2, expr3):
    self.expr1 = expr1
    self.expr2 = expr2
    self.expr3 = expr3
</t>
<t tx="T1255">def getChildren(self):
    children = []
    children.append(self.expr1)
    children.append(self.expr2)
    children.append(self.expr3)
    return tuple(children)
</t>
<t tx="T1256">def getChildNodes(self):
    nodes = []
    if self.expr1 is not None:            nodes.append(self.expr1)
    if self.expr2 is not None:            nodes.append(self.expr2)
    if self.expr3 is not None:            nodes.append(self.expr3)
    return tuple(nodes)
</t>
<t tx="T1257">def __repr__(self):
    return "Raise(%s, %s, %s)" % (repr(self.expr1), repr(self.expr2), repr(self.expr3))
</t>
<t tx="T1258">class For(Node):
	nodes["for"] = "For"
	@others

</t>
<t tx="T1259">def __init__(self, assign, list, body, else_):
    self.assign = assign
    self.list = list
    self.body = body
    self.else_ = else_
</t>
<t tx="T1260">def getChildren(self):
    children = []
    children.append(self.assign)
    children.append(self.list)
    children.append(self.body)
    children.append(self.else_)
    return tuple(children)
</t>
<t tx="T1261">def getChildNodes(self):
    nodes = []
    nodes.append(self.assign)
    nodes.append(self.list)
    nodes.append(self.body)
    if self.else_ is not None:            nodes.append(self.else_)
    return tuple(nodes)
</t>
<t tx="T1262">def __repr__(self):
    return "For(%s, %s, %s, %s)" % (repr(self.assign), repr(self.list), repr(self.body), repr(self.else_))
</t>
<t tx="T1263">
class AssTuple(Node):
	&lt;&lt; class AssTuple declarations &gt;&gt;
	&lt;&lt; class AssTuple methods &gt;&gt;

</t>
<t tx="T1264">nodes["asstuple"] = "AssTuple"
</t>
<t tx="T1265">@others</t>
<t tx="T1266">def __init__(self, nodes):
    self.nodes = nodes
</t>
<t tx="T1267">def getChildren(self):
    children = []
    children.extend(flatten(self.nodes))
    return tuple(children)
</t>
<t tx="T1268">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.nodes))
    return tuple(nodes)
</t>
<t tx="T1269">def __repr__(self):
    return "AssTuple(%s)" % (repr(self.nodes),)
</t>
<t tx="T1270">
class Mul(Node):
	&lt;&lt; class Mul declarations &gt;&gt;
	&lt;&lt; class Mul methods &gt;&gt;

</t>
<t tx="T1271">nodes["mul"] = "Mul"
</t>
<t tx="T1272">@others</t>
<t tx="T1273">def __init__(self, (left, right)):
    self.left = left
    self.right = right
</t>
<t tx="T1274">def getChildren(self):
    return self.left, self.right
</t>
<t tx="T1275">def getChildNodes(self):
    return self.left, self.right
</t>
<t tx="T1276">def __repr__(self):
    return "Mul((%s, %s))" % (repr(self.left), repr(self.right))
</t>
<t tx="T1277">
class Invert(Node):
	&lt;&lt; class Invert declarations &gt;&gt;
	&lt;&lt; class Invert methods &gt;&gt;

</t>
<t tx="T1278">nodes["invert"] = "Invert"
</t>
<t tx="T1279">@others</t>
<t tx="T1280">def __init__(self, expr):
    self.expr = expr
</t>
<t tx="T1281">def getChildren(self):
    return self.expr,
</t>
<t tx="T1282">def getChildNodes(self):
    return self.expr,
</t>
<t tx="T1283">def __repr__(self):
    return "Invert(%s)" % (repr(self.expr),)
</t>
<t tx="T1284">
class RightShift(Node):
	&lt;&lt; class RightShift declarations &gt;&gt;
	&lt;&lt; class RightShift methods &gt;&gt;

</t>
<t tx="T1285">nodes["rightshift"] = "RightShift"
</t>
<t tx="T1286">@others</t>
<t tx="T1287">def __init__(self, (left, right)):
    self.left = left
    self.right = right
</t>
<t tx="T1288">def getChildren(self):
    return self.left, self.right
</t>
<t tx="T1289">def getChildNodes(self):
    return self.left, self.right
</t>
<t tx="T1290">def __repr__(self):
    return "RightShift((%s, %s))" % (repr(self.left), repr(self.right))
</t>
<t tx="T1291">
class AssList(Node):
	&lt;&lt; class AssList declarations &gt;&gt;
	&lt;&lt; class AssList methods &gt;&gt;

</t>
<t tx="T1292">nodes["asslist"] = "AssList"
</t>
<t tx="T1293">@others</t>
<t tx="T1294">def __init__(self, nodes):
    self.nodes = nodes
</t>
<t tx="T1295">def getChildren(self):
    children = []
    children.extend(flatten(self.nodes))
    return tuple(children)
</t>
<t tx="T1296">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.nodes))
    return tuple(nodes)
</t>
<t tx="T1297">def __repr__(self):
    return "AssList(%s)" % (repr(self.nodes),)
</t>
<t tx="T1298">
class From(Node):
	&lt;&lt; class From declarations &gt;&gt;
	&lt;&lt; class From methods &gt;&gt;

</t>
<t tx="T1299">nodes["from"] = "From"
</t>
<t tx="T1300">@others</t>
<t tx="T1301">def __init__(self, modname, names):
    self.modname = modname
    self.names = names
</t>
<t tx="T1302">def getChildren(self):
    return self.modname, self.names
</t>
<t tx="T1303">def getChildNodes(self):
    return ()
</t>
<t tx="T1304">def __repr__(self):
    return "From(%s, %s)" % (repr(self.modname), repr(self.names))
</t>
<t tx="T1305">
class Getattr(Node):
	&lt;&lt; class Getattr declarations &gt;&gt;
	&lt;&lt; class Getattr methods &gt;&gt;

</t>
<t tx="T1306">nodes["getattr"] = "Getattr"
</t>
<t tx="T1307">@others</t>
<t tx="T1308">def __init__(self, expr, attrname):
    self.expr = expr
    self.attrname = attrname
</t>
<t tx="T1309">def getChildren(self):
    return self.expr, self.attrname
</t>
<t tx="T1310">def getChildNodes(self):
    return self.expr,
</t>
<t tx="T1311">def __repr__(self):
    return "Getattr(%s, %s)" % (repr(self.expr), repr(self.attrname))
</t>
<t tx="T1312">
class Dict(Node):
	&lt;&lt; class Dict declarations &gt;&gt;
	&lt;&lt; class Dict methods &gt;&gt;

</t>
<t tx="T1313">nodes["dict"] = "Dict"
</t>
<t tx="T1314">@others</t>
<t tx="T1315">def __init__(self, items):
    self.items = items
</t>
<t tx="T1316">def getChildren(self):
    children = []
    children.extend(flatten(self.items))
    return tuple(children)
</t>
<t tx="T1317">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.items))
    return tuple(nodes)
</t>
<t tx="T1318">def __repr__(self):
    return "Dict(%s)" % (repr(self.items),)
</t>
<t tx="T1319">
class Module(Node):
	&lt;&lt; class Module declarations &gt;&gt;
	&lt;&lt; class Module methods &gt;&gt;

</t>
<t tx="T1320">nodes["module"] = "Module"
</t>
<t tx="T1321">@others</t>
<t tx="T1322">def __init__(self, doc, node):
    self.doc = doc
    self.node = node
</t>
<t tx="T1323">def getChildren(self):
    return self.doc, self.node
</t>
<t tx="T1324">def getChildNodes(self):
    return self.node,
</t>
<t tx="T1325">def __repr__(self):
    return "Module(%s, %s)" % (repr(self.doc), repr(self.node))
</t>
<t tx="T1326">
class Expression(Node):
	&lt;&lt; class Expression declarations &gt;&gt;
	&lt;&lt; class Expression methods &gt;&gt;

</t>
<t tx="T1327"># Expression is an artifical node class to support "eval"
nodes["expression"] = "Expression"
</t>
<t tx="T1328">@others</t>
<t tx="T1329">def __init__(self, node):
    self.node = node
</t>
<t tx="T1330">def getChildren(self):
    return self.node,
</t>
<t tx="T1331">def getChildNodes(self):
    return self.node,
</t>
<t tx="T1332">def __repr__(self):
    return "Expression(%s)" % (repr(self.node))
</t>
<t tx="T1333">
class UnaryAdd(Node):
	&lt;&lt; class UnaryAdd declarations &gt;&gt;
	&lt;&lt; class UnaryAdd methods &gt;&gt;

</t>
<t tx="T1334">nodes["unaryadd"] = "UnaryAdd"
</t>
<t tx="T1335">@others</t>
<t tx="T1336">def __init__(self, expr):
    self.expr = expr
</t>
<t tx="T1337">def getChildren(self):
    return self.expr,
</t>
<t tx="T1338">def getChildNodes(self):
    return self.expr,
</t>
<t tx="T1339">def __repr__(self):
    return "UnaryAdd(%s)" % (repr(self.expr),)
</t>
<t tx="T1340">
class Ellipsis(Node):
	&lt;&lt; class Ellipsis declarations &gt;&gt;
	&lt;&lt; class Ellipsis methods &gt;&gt;

</t>
<t tx="T1341">nodes["ellipsis"] = "Ellipsis"
</t>
<t tx="T1342">@others</t>
<t tx="T1343">def __init__(self, ):
    pass
</t>
<t tx="T1344">def getChildren(self):
    return ()
</t>
<t tx="T1345">def getChildNodes(self):
    return ()
</t>
<t tx="T1346">def __repr__(self):
    return "Ellipsis()"
</t>
<t tx="T1347">
class Print(Node):
	&lt;&lt; class Print declarations &gt;&gt;
	&lt;&lt; class Print methods &gt;&gt;

</t>
<t tx="T1348">nodes["print"] = "Print"
</t>
<t tx="T1349">@others</t>
<t tx="T1350">def __init__(self, nodes, dest):
    self.nodes = nodes
    self.dest = dest
</t>
<t tx="T1351">def getChildren(self):
    children = []
    children.extend(flatten(self.nodes))
    children.append(self.dest)
    return tuple(children)
</t>
<t tx="T1352">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.nodes))
    if self.dest is not None:            nodes.append(self.dest)
    return tuple(nodes)
</t>
<t tx="T1353">def __repr__(self):
    return "Print(%s, %s)" % (repr(self.nodes), repr(self.dest))
</t>
<t tx="T1354">
class Import(Node):
	&lt;&lt; class Import declarations &gt;&gt;
	&lt;&lt; class Import methods &gt;&gt;

</t>
<t tx="T1355">nodes["import"] = "Import"
</t>
<t tx="T1356">@others</t>
<t tx="T1357">def __init__(self, names):
    self.names = names
</t>
<t tx="T1358">def getChildren(self):
    return self.names,
</t>
<t tx="T1359">def getChildNodes(self):
    return ()
</t>
<t tx="T1360">def __repr__(self):
    return "Import(%s)" % (repr(self.names),)
</t>
<t tx="T1361">
class Subscript(Node):
	&lt;&lt; class Subscript declarations &gt;&gt;
	&lt;&lt; class Subscript methods &gt;&gt;

</t>
<t tx="T1362">nodes["subscript"] = "Subscript"
</t>
<t tx="T1363">@others</t>
<t tx="T1364">def __init__(self, expr, flags, subs):
    self.expr = expr
    self.flags = flags
    self.subs = subs
</t>
<t tx="T1365">def getChildren(self):
    children = []
    children.append(self.expr)
    children.append(self.flags)
    children.extend(flatten(self.subs))
    return tuple(children)
</t>
<t tx="T1366">def getChildNodes(self):
    nodes = []
    nodes.append(self.expr)
    nodes.extend(flatten_nodes(self.subs))
    return tuple(nodes)
</t>
<t tx="T1367">def __repr__(self):
    return "Subscript(%s, %s, %s)" % (repr(self.expr), repr(self.flags), repr(self.subs))
</t>
<t tx="T1368">
class TryExcept(Node):
	&lt;&lt; class TryExcept declarations &gt;&gt;
	&lt;&lt; class TryExcept methods &gt;&gt;

</t>
<t tx="T1369">nodes["tryexcept"] = "TryExcept"
</t>
<t tx="T1370">@others</t>
<t tx="T1371">def __init__(self, body, handlers, else_):
    self.body = body
    self.handlers = handlers
    self.else_ = else_
</t>
<t tx="T1372">def getChildren(self):
    children = []
    children.append(self.body)
    children.extend(flatten(self.handlers))
    children.append(self.else_)
    return tuple(children)
</t>
<t tx="T1373">def getChildNodes(self):
    nodes = []
    nodes.append(self.body)
    nodes.extend(flatten_nodes(self.handlers))
    if self.else_ is not None:            nodes.append(self.else_)
    return tuple(nodes)
</t>
<t tx="T1374">def __repr__(self):
    return "TryExcept(%s, %s, %s)" % (repr(self.body), repr(self.handlers), repr(self.else_))
</t>
<t tx="T1375">
class Or(Node):
	&lt;&lt; class Or declarations &gt;&gt;
	&lt;&lt; class Or methods &gt;&gt;

</t>
<t tx="T1376">nodes["or"] = "Or"
</t>
<t tx="T1377">@others</t>
<t tx="T1378">def __init__(self, nodes):
    self.nodes = nodes
</t>
<t tx="T1379">def getChildren(self):
    children = []
    children.extend(flatten(self.nodes))
    return tuple(children)
</t>
<t tx="T1380">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.nodes))
    return tuple(nodes)
</t>
<t tx="T1381">def __repr__(self):
    return "Or(%s)" % (repr(self.nodes),)
</t>
<t tx="T1382">
class Name(Node):
	&lt;&lt; class Name declarations &gt;&gt;
	&lt;&lt; class Name methods &gt;&gt;

</t>
<t tx="T1383">nodes["name"] = "Name"
</t>
<t tx="T1384">@others</t>
<t tx="T1385">def __init__(self, name):
    self.name = name
</t>
<t tx="T1386">def getChildren(self):
    return self.name,
</t>
<t tx="T1387">def getChildNodes(self):
    return ()
</t>
<t tx="T1388">def __repr__(self):
    return "Name(%s)" % (repr(self.name),)
</t>
<t tx="T1389">
class Function(Node):
	&lt;&lt; class Function declarations &gt;&gt;
	&lt;&lt; class Function methods &gt;&gt;

</t>
<t tx="T1390">nodes["function"] = "Function"
</t>
<t tx="T1391">@others</t>
<t tx="T1392">def __init__(self, name, argnames, defaults, flags, doc, code):
    self.name = name
    self.argnames = argnames
    self.defaults = defaults
    self.flags = flags
    self.doc = doc
    self.code = code
    self.varargs = self.kwargs = None
    if flags &amp; CO_VARARGS:
        self.varargs = 1
    if flags &amp; CO_VARKEYWORDS:
        self.kwargs = 1
</t>
<t tx="T1393">def getChildren(self):
    children = []
    children.append(self.name)
    children.append(self.argnames)
    children.extend(flatten(self.defaults))
    children.append(self.flags)
    children.append(self.doc)
    children.append(self.code)
    return tuple(children)
</t>
<t tx="T1394">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.defaults))
    nodes.append(self.code)
    return tuple(nodes)
</t>
<t tx="T1395">def __repr__(self):
    return "Function(%s, %s, %s, %s, %s, %s)" % (repr(self.name), repr(self.argnames), repr(self.defaults), repr(self.flags), repr(self.doc), repr(self.code))
</t>
<t tx="T1396">
class Assert(Node):
	&lt;&lt; class Assert declarations &gt;&gt;
	&lt;&lt; class Assert methods &gt;&gt;

</t>
<t tx="T1397">nodes["assert"] = "Assert"
</t>
<t tx="T1398">@others</t>
<t tx="T1399">def __init__(self, test, fail):
    self.test = test
    self.fail = fail
</t>
<t tx="T1400">def getChildren(self):
    children = []
    children.append(self.test)
    children.append(self.fail)
    return tuple(children)
</t>
<t tx="T1401">def getChildNodes(self):
    nodes = []
    nodes.append(self.test)
    if self.fail is not None:            nodes.append(self.fail)
    return tuple(nodes)
</t>
<t tx="T1402">def __repr__(self):
    return "Assert(%s, %s)" % (repr(self.test), repr(self.fail))
</t>
<t tx="T1403">
class Return(Node):
	&lt;&lt; class Return declarations &gt;&gt;
	&lt;&lt; class Return methods &gt;&gt;

</t>
<t tx="T1404">nodes["return"] = "Return"
</t>
<t tx="T1405">@others</t>
<t tx="T1406">def __init__(self, value):
    self.value = value
</t>
<t tx="T1407">def getChildren(self):
    return self.value,
</t>
<t tx="T1408">def getChildNodes(self):
    return self.value,
</t>
<t tx="T1409">def __repr__(self):
    return "Return(%s)" % (repr(self.value),)
</t>
<t tx="T1410">
class Power(Node):
	&lt;&lt; class Power declarations &gt;&gt;
	&lt;&lt; class Power methods &gt;&gt;

</t>
<t tx="T1411">nodes["power"] = "Power"
</t>
<t tx="T1412">@others</t>
<t tx="T1413">def __init__(self, (left, right)):
    self.left = left
    self.right = right
</t>
<t tx="T1414">def getChildren(self):
    return self.left, self.right
</t>
<t tx="T1415">def getChildNodes(self):
    return self.left, self.right
</t>
<t tx="T1416">def __repr__(self):
    return "Power((%s, %s))" % (repr(self.left), repr(self.right))
</t>
<t tx="T1417">
class Exec(Node):
	&lt;&lt; class Exec declarations &gt;&gt;
	&lt;&lt; class Exec methods &gt;&gt;

</t>
<t tx="T1418">nodes["exec"] = "Exec"
</t>
<t tx="T1419">@others</t>
<t tx="T1420">def __init__(self, expr, locals, globals):
    self.expr = expr
    self.locals = locals
    self.globals = globals
</t>
<t tx="T1421">def getChildren(self):
    children = []
    children.append(self.expr)
    children.append(self.locals)
    children.append(self.globals)
    return tuple(children)
</t>
<t tx="T1422">def getChildNodes(self):
    nodes = []
    nodes.append(self.expr)
    if self.locals is not None:            nodes.append(self.locals)
    if self.globals is not None:            nodes.append(self.globals)
    return tuple(nodes)
</t>
<t tx="T1423">def __repr__(self):
    return "Exec(%s, %s, %s)" % (repr(self.expr), repr(self.locals), repr(self.globals))
</t>
<t tx="T1424">
class Stmt(Node):
	&lt;&lt; class Stmt declarations &gt;&gt;
	&lt;&lt; class Stmt methods &gt;&gt;

</t>
<t tx="T1425">nodes["stmt"] = "Stmt"
</t>
<t tx="T1426">@others</t>
<t tx="T1427">def __init__(self, nodes):
    self.nodes = nodes
</t>
<t tx="T1428">def getChildren(self):
    children = []
    children.extend(flatten(self.nodes))
    return tuple(children)
</t>
<t tx="T1429">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.nodes))
    return tuple(nodes)
</t>
<t tx="T1430">def __repr__(self):
    return "Stmt(%s)" % (repr(self.nodes),)
</t>
<t tx="T1431">
class Sliceobj(Node):
	&lt;&lt; class Sliceobj declarations &gt;&gt;
	&lt;&lt; class Sliceobj methods &gt;&gt;

</t>
<t tx="T1432">nodes["sliceobj"] = "Sliceobj"
</t>
<t tx="T1433">@others</t>
<t tx="T1434">def __init__(self, nodes):
    self.nodes = nodes
</t>
<t tx="T1435">def getChildren(self):
    children = []
    children.extend(flatten(self.nodes))
    return tuple(children)
</t>
<t tx="T1436">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.nodes))
    return tuple(nodes)
</t>
<t tx="T1437">def __repr__(self):
    return "Sliceobj(%s)" % (repr(self.nodes),)
</t>
<t tx="T1438">class Break(Node):
	&lt;&lt; class Break declarations &gt;&gt;
	&lt;&lt; class Break methods &gt;&gt;

</t>
<t tx="T1439">nodes["break"] = "Break"
</t>
<t tx="T1440">@others</t>
<t tx="T1441">def __init__(self, ):
    pass
</t>
<t tx="T1442">def getChildren(self):
    return ()
</t>
<t tx="T1443">def getChildNodes(self):
    return ()
</t>
<t tx="T1444">def __repr__(self):
    return "Break()"
</t>
<t tx="T1445">
class Bitand(Node):
	&lt;&lt; class Bitand declarations &gt;&gt;
	&lt;&lt; class Bitand methods &gt;&gt;

</t>
<t tx="T1446">nodes["bitand"] = "Bitand"
</t>
<t tx="T1447">@others</t>
<t tx="T1448">def __init__(self, nodes):
    self.nodes = nodes
</t>
<t tx="T1449">def getChildren(self):
    children = []
    children.extend(flatten(self.nodes))
    return tuple(children)
</t>
<t tx="T1450">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.nodes))
    return tuple(nodes)
</t>
<t tx="T1451">def __repr__(self):
    return "Bitand(%s)" % (repr(self.nodes),)
</t>
<t tx="T1452">
class FloorDiv(Node):
	&lt;&lt; class FloorDiv declarations &gt;&gt;
	&lt;&lt; class FloorDiv methods &gt;&gt;

</t>
<t tx="T1453">nodes["floordiv"] = "FloorDiv"
</t>
<t tx="T1454">@others</t>
<t tx="T1455">def __init__(self, (left, right)):
    self.left = left
    self.right = right
</t>
<t tx="T1456">def getChildren(self):
    return self.left, self.right
</t>
<t tx="T1457">def getChildNodes(self):
    return self.left, self.right
</t>
<t tx="T1458">def __repr__(self):
    return "FloorDiv((%s, %s))" % (repr(self.left), repr(self.right))
</t>
<t tx="T1459">
class TryFinally(Node):
	&lt;&lt; class TryFinally declarations &gt;&gt;
	&lt;&lt; class TryFinally methods &gt;&gt;

</t>
<t tx="T1460">nodes["tryfinally"] = "TryFinally"
</t>
<t tx="T1461">@others</t>
<t tx="T1462">def __init__(self, body, final):
    self.body = body
    self.final = final
</t>
<t tx="T1463">def getChildren(self):
    return self.body, self.final
</t>
<t tx="T1464">def getChildNodes(self):
    return self.body, self.final
</t>
<t tx="T1465">def __repr__(self):
    return "TryFinally(%s, %s)" % (repr(self.body), repr(self.final))
</t>
<t tx="T1466">
class Not(Node):
	&lt;&lt; class Not declarations &gt;&gt;
	&lt;&lt; class Not methods &gt;&gt;

</t>
<t tx="T1467">nodes["not"] = "Not"
</t>
<t tx="T1468">@others</t>
<t tx="T1469">def __init__(self, expr):
    self.expr = expr
</t>
<t tx="T1470">def getChildren(self):
    return self.expr,
</t>
<t tx="T1471">def getChildNodes(self):
    return self.expr,
</t>
<t tx="T1472">def __repr__(self):
    return "Not(%s)" % (repr(self.expr),)
</t>
<t tx="T1473">
class Class(Node):
	&lt;&lt; class Class declarations &gt;&gt;
	&lt;&lt; class Class methods &gt;&gt;

</t>
<t tx="T1474">nodes["class"] = "Class"
</t>
<t tx="T1475">@others</t>
<t tx="T1476">def __init__(self, name, bases, doc, code):
    self.name = name
    self.bases = bases
    self.doc = doc
    self.code = code
</t>
<t tx="T1477">def getChildren(self):
    children = []
    children.append(self.name)
    children.extend(flatten(self.bases))
    children.append(self.doc)
    children.append(self.code)
    return tuple(children)
</t>
<t tx="T1478">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.bases))
    nodes.append(self.code)
    return tuple(nodes)
</t>
<t tx="T1479">def __repr__(self):
    return "Class(%s, %s, %s, %s)" % (repr(self.name), repr(self.bases), repr(self.doc), repr(self.code))
</t>
<t tx="T1480">
class Mod(Node):
	&lt;&lt; class Mod declarations &gt;&gt;
	&lt;&lt; class Mod methods &gt;&gt;

</t>
<t tx="T1481">nodes["mod"] = "Mod"
</t>
<t tx="T1482">@others</t>
<t tx="T1483">def __init__(self, (left, right)):
    self.left = left
    self.right = right
</t>
<t tx="T1484">def getChildren(self):
    return self.left, self.right
</t>
<t tx="T1485">def getChildNodes(self):
    return self.left, self.right
</t>
<t tx="T1486">def __repr__(self):
    return "Mod((%s, %s))" % (repr(self.left), repr(self.right))
</t>
<t tx="T1487">
class Printnl(Node):
	&lt;&lt; class Printnl declarations &gt;&gt;
	&lt;&lt; class Printnl methods &gt;&gt;

</t>
<t tx="T1488">nodes["printnl"] = "Printnl"
</t>
<t tx="T1489">@others</t>
<t tx="T1490">def __init__(self, nodes, dest):
    self.nodes = nodes
    self.dest = dest
</t>
<t tx="T1491">def getChildren(self):
    children = []
    children.extend(flatten(self.nodes))
    children.append(self.dest)
    return tuple(children)
</t>
<t tx="T1492">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.nodes))
    if self.dest is not None:            nodes.append(self.dest)
    return tuple(nodes)
</t>
<t tx="T1493">def __repr__(self):
    return "Printnl(%s, %s)" % (repr(self.nodes), repr(self.dest))
</t>
<t tx="T1494">
class Tuple(Node):
	&lt;&lt; class Tuple declarations &gt;&gt;
	&lt;&lt; class Tuple methods &gt;&gt;

</t>
<t tx="T1495">nodes["tuple"] = "Tuple"
</t>
<t tx="T1496">@others</t>
<t tx="T1497">def __init__(self, nodes):
    self.nodes = nodes
</t>
<t tx="T1498">def getChildren(self):
    children = []
    children.extend(flatten(self.nodes))
    return tuple(children)
</t>
<t tx="T1499">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.nodes))
    return tuple(nodes)
</t>
<t tx="T1500">def __repr__(self):
    return "Tuple(%s)" % (repr(self.nodes),)
</t>
<t tx="T1501">
class AssAttr(Node):
	&lt;&lt; class AssAttr declarations &gt;&gt;
	&lt;&lt; class AssAttr methods &gt;&gt;

</t>
<t tx="T1502">nodes["assattr"] = "AssAttr"
</t>
<t tx="T1503">@others</t>
<t tx="T1504">def __init__(self, expr, attrname, flags):
    self.expr = expr
    self.attrname = attrname
    self.flags = flags
</t>
<t tx="T1505">def getChildren(self):
    return self.expr, self.attrname, self.flags
</t>
<t tx="T1506">def getChildNodes(self):
    return self.expr,
</t>
<t tx="T1507">def __repr__(self):
    return "AssAttr(%s, %s, %s)" % (repr(self.expr), repr(self.attrname), repr(self.flags))
</t>
<t tx="T1508">
class Keyword(Node):
	&lt;&lt; class Keyword declarations &gt;&gt;
	&lt;&lt; class Keyword methods &gt;&gt;

</t>
<t tx="T1509">nodes["keyword"] = "Keyword"
</t>
<t tx="T1510">@others</t>
<t tx="T1511">def __init__(self, name, expr):
    self.name = name
    self.expr = expr
</t>
<t tx="T1512">def getChildren(self):
    return self.name, self.expr
</t>
<t tx="T1513">def getChildNodes(self):
    return self.expr,
</t>
<t tx="T1514">def __repr__(self):
    return "Keyword(%s, %s)" % (repr(self.name), repr(self.expr))
</t>
<t tx="T1515">
class AugAssign(Node):
	&lt;&lt; class AugAssign declarations &gt;&gt;
	&lt;&lt; class AugAssign methods &gt;&gt;

</t>
<t tx="T1516">nodes["augassign"] = "AugAssign"
</t>
<t tx="T1517">@others</t>
<t tx="T1518">def __init__(self, node, op, expr):
    self.node = node
    self.op = op
    self.expr = expr
</t>
<t tx="T1519">def getChildren(self):
    return self.node, self.op, self.expr
</t>
<t tx="T1520">def getChildNodes(self):
    return self.node, self.expr
</t>
<t tx="T1521">def __repr__(self):
    return "AugAssign(%s, %s, %s)" % (repr(self.node), repr(self.op), repr(self.expr))
</t>
<t tx="T1522">
class List(Node):
	&lt;&lt; class List declarations &gt;&gt;
	&lt;&lt; class List methods &gt;&gt;

</t>
<t tx="T1523">nodes["list"] = "List"
</t>
<t tx="T1524">@others</t>
<t tx="T1525">def __init__(self, nodes):
    self.nodes = nodes
</t>
<t tx="T1526">def getChildren(self):
    children = []
    children.extend(flatten(self.nodes))
    return tuple(children)
</t>
<t tx="T1527">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.nodes))
    return tuple(nodes)
</t>
<t tx="T1528">def __repr__(self):
    return "List(%s)" % (repr(self.nodes),)
</t>
<t tx="T1529">
class Yield(Node):
	&lt;&lt; class Yield declarations &gt;&gt;
	&lt;&lt; class Yield methods &gt;&gt;

</t>
<t tx="T1530">nodes["yield"] = "Yield"
</t>
<t tx="T1531">@others</t>
<t tx="T1532">def __init__(self, value):
    self.value = value
</t>
<t tx="T1533">def getChildren(self):
    return self.value,
</t>
<t tx="T1534">def getChildNodes(self):
    return self.value,
</t>
<t tx="T1535">def __repr__(self):
    return "Yield(%s)" % (repr(self.value),)
</t>
<t tx="T1536">
class LeftShift(Node):
	&lt;&lt; class LeftShift declarations &gt;&gt;
	&lt;&lt; class LeftShift methods &gt;&gt;

</t>
<t tx="T1537">nodes["leftshift"] = "LeftShift"
</t>
<t tx="T1538">@others</t>
<t tx="T1539">def __init__(self, (left, right)):
    self.left = left
    self.right = right
</t>
<t tx="T1540">def getChildren(self):
    return self.left, self.right
</t>
<t tx="T1541">def getChildNodes(self):
    return self.left, self.right
</t>
<t tx="T1542">def __repr__(self):
    return "LeftShift((%s, %s))" % (repr(self.left), repr(self.right))
</t>
<t tx="T1543">
class AssName(Node):
	&lt;&lt; class AssName declarations &gt;&gt;
	&lt;&lt; class AssName methods &gt;&gt;

</t>
<t tx="T1544">nodes["assname"] = "AssName"
</t>
<t tx="T1545">@others</t>
<t tx="T1546">def __init__(self, name, flags):
    self.name = name
    self.flags = flags
</t>
<t tx="T1547">def getChildren(self):
    return self.name, self.flags
</t>
<t tx="T1548">def getChildNodes(self):
    return ()
</t>
<t tx="T1549">def __repr__(self):
    return "AssName(%s, %s)" % (repr(self.name), repr(self.flags))
</t>
<t tx="T1550">
class While(Node):
	&lt;&lt; class While declarations &gt;&gt;
	&lt;&lt; class While methods &gt;&gt;

</t>
<t tx="T1551">nodes["while"] = "While"
</t>
<t tx="T1552">@others</t>
<t tx="T1553">def __init__(self, test, body, else_):
    self.test = test
    self.body = body
    self.else_ = else_
</t>
<t tx="T1554">def getChildren(self):
    children = []
    children.append(self.test)
    children.append(self.body)
    children.append(self.else_)
    return tuple(children)
</t>
<t tx="T1555">def getChildNodes(self):
    nodes = []
    nodes.append(self.test)
    nodes.append(self.body)
    if self.else_ is not None:            nodes.append(self.else_)
    return tuple(nodes)
</t>
<t tx="T1556">def __repr__(self):
    return "While(%s, %s, %s)" % (repr(self.test), repr(self.body), repr(self.else_))
</t>
<t tx="T1557">
class Continue(Node):
	&lt;&lt; class Continue declarations &gt;&gt;
	&lt;&lt; class Continue methods &gt;&gt;

</t>
<t tx="T1558">nodes["continue"] = "Continue"
</t>
<t tx="T1559">@others</t>
<t tx="T1560">def __init__(self, ):
    pass
</t>
<t tx="T1561">def getChildren(self):
    return ()
</t>
<t tx="T1562">def getChildNodes(self):
    return ()
</t>
<t tx="T1563">def __repr__(self):
    return "Continue()"
</t>
<t tx="T1564">
class Backquote(Node):
	&lt;&lt; class Backquote declarations &gt;&gt;
	&lt;&lt; class Backquote methods &gt;&gt;

</t>
<t tx="T1565">nodes["backquote"] = "Backquote"
</t>
<t tx="T1566">@others</t>
<t tx="T1567">def __init__(self, expr):
    self.expr = expr
</t>
<t tx="T1568">def getChildren(self):
    return self.expr,
</t>
<t tx="T1569">def getChildNodes(self):
    return self.expr,
</t>
<t tx="T1570">def __repr__(self):
    return "Backquote(%s)" % (repr(self.expr),)
</t>
<t tx="T1571">
class Discard(Node):
	&lt;&lt; class Discard declarations &gt;&gt;
	&lt;&lt; class Discard methods &gt;&gt;

</t>
<t tx="T1572">nodes["discard"] = "Discard"
</t>
<t tx="T1573">@others</t>
<t tx="T1574">def __init__(self, expr):
    self.expr = expr
</t>
<t tx="T1575">def getChildren(self):
    return self.expr,
</t>
<t tx="T1576">def getChildNodes(self):
    return self.expr,
</t>
<t tx="T1577">def __repr__(self):
    return "Discard(%s)" % (repr(self.expr),)
</t>
<t tx="T1578">
class Div(Node):
	&lt;&lt; class Div declarations &gt;&gt;
	&lt;&lt; class Div methods &gt;&gt;

</t>
<t tx="T1579">nodes["div"] = "Div"
</t>
<t tx="T1580">@others</t>
<t tx="T1581">def __init__(self, (left, right)):
    self.left = left
    self.right = right
</t>
<t tx="T1582">def getChildren(self):
    return self.left, self.right
</t>
<t tx="T1583">def getChildNodes(self):
    return self.left, self.right
</t>
<t tx="T1584">def __repr__(self):
    return "Div((%s, %s))" % (repr(self.left), repr(self.right))
</t>
<t tx="T1585">
class Assign(Node):
	&lt;&lt; class Assign declarations &gt;&gt;
	&lt;&lt; class Assign methods &gt;&gt;

</t>
<t tx="T1586">nodes["assign"] = "Assign"
</t>
<t tx="T1587">@others</t>
<t tx="T1588">def __init__(self, nodes, expr):
    self.nodes = nodes
    self.expr = expr
</t>
<t tx="T1589">def getChildren(self):
    children = []
    children.extend(flatten(self.nodes))
    children.append(self.expr)
    return tuple(children)
</t>
<t tx="T1590">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.nodes))
    nodes.append(self.expr)
    return tuple(nodes)
</t>
<t tx="T1591">def __repr__(self):
    return "Assign(%s, %s)" % (repr(self.nodes), repr(self.expr))
</t>
<t tx="T1592">
class Lambda(Node):
	&lt;&lt; class Lambda declarations &gt;&gt;
	&lt;&lt; class Lambda methods &gt;&gt;

</t>
<t tx="T1593">nodes["lambda"] = "Lambda"
</t>
<t tx="T1594">@others</t>
<t tx="T1595">def __init__(self, argnames, defaults, flags, code):
    self.argnames = argnames
    self.defaults = defaults
    self.flags = flags
    self.code = code
    self.varargs = self.kwargs = None
    if flags &amp; CO_VARARGS:
        self.varargs = 1
    if flags &amp; CO_VARKEYWORDS:
        self.kwargs = 1
</t>
<t tx="T1596">def getChildren(self):
    children = []
    children.append(self.argnames)
    children.extend(flatten(self.defaults))
    children.append(self.flags)
    children.append(self.code)
    return tuple(children)
</t>
<t tx="T1597">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.defaults))
    nodes.append(self.code)
    return tuple(nodes)
</t>
<t tx="T1598">def __repr__(self):
    return "Lambda(%s, %s, %s, %s)" % (repr(self.argnames), repr(self.defaults), repr(self.flags), repr(self.code))
</t>
<t tx="T1599">
class And(Node):
	&lt;&lt; class And declarations &gt;&gt;
	&lt;&lt; class And methods &gt;&gt;

</t>
<t tx="T1600">nodes["and"] = "And"
</t>
<t tx="T1601">@others</t>
<t tx="T1602">def __init__(self, nodes):
    self.nodes = nodes
</t>
<t tx="T1603">def getChildren(self):
    children = []
    children.extend(flatten(self.nodes))
    return tuple(children)
</t>
<t tx="T1604">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.nodes))
    return tuple(nodes)
</t>
<t tx="T1605">def __repr__(self):
    return "And(%s)" % (repr(self.nodes),)
</t>
<t tx="T1606">
class Compare(Node):
	&lt;&lt; class Compare declarations &gt;&gt;
	&lt;&lt; class Compare methods &gt;&gt;

</t>
<t tx="T1607">nodes["compare"] = "Compare"
</t>
<t tx="T1608">@others</t>
<t tx="T1609">def __init__(self, expr, ops):
    self.expr = expr
    self.ops = ops
</t>
<t tx="T1610">def getChildren(self):
    children = []
    children.append(self.expr)
    children.extend(flatten(self.ops))
    return tuple(children)
</t>
<t tx="T1611">def getChildNodes(self):
    nodes = []
    nodes.append(self.expr)
    nodes.extend(flatten_nodes(self.ops))
    return tuple(nodes)
</t>
<t tx="T1612">def __repr__(self):
    return "Compare(%s, %s)" % (repr(self.expr), repr(self.ops))
</t>
<t tx="T1613">
class Bitor(Node):
	&lt;&lt; class Bitor declarations &gt;&gt;
	&lt;&lt; class Bitor methods &gt;&gt;

</t>
<t tx="T1614">nodes["bitor"] = "Bitor"
</t>
<t tx="T1615">@others</t>
<t tx="T1616">def __init__(self, nodes):
    self.nodes = nodes
</t>
<t tx="T1617">def getChildren(self):
    children = []
    children.extend(flatten(self.nodes))
    return tuple(children)
</t>
<t tx="T1618">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.nodes))
    return tuple(nodes)
</t>
<t tx="T1619">def __repr__(self):
    return "Bitor(%s)" % (repr(self.nodes),)
</t>
<t tx="T1620">
class Bitxor(Node):
	&lt;&lt; class Bitxor declarations &gt;&gt;
	&lt;&lt; class Bitxor methods &gt;&gt;

</t>
<t tx="T1621">nodes["bitxor"] = "Bitxor"
</t>
<t tx="T1622">@others</t>
<t tx="T1623">def __init__(self, nodes):
    self.nodes = nodes
</t>
<t tx="T1624">def getChildren(self):
    children = []
    children.extend(flatten(self.nodes))
    return tuple(children)
</t>
<t tx="T1625">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.nodes))
    return tuple(nodes)
</t>
<t tx="T1626">def __repr__(self):
    return "Bitxor(%s)" % (repr(self.nodes),)
</t>
<t tx="T1627">
class CallFunc(Node):
	&lt;&lt; class CallFunc declarations &gt;&gt;
	&lt;&lt; class CallFunc methods &gt;&gt;

</t>
<t tx="T1628">nodes["callfunc"] = "CallFunc"
</t>
<t tx="T1629">@others</t>
<t tx="T1630">def __init__(self, node, args, star_args = None, dstar_args = None):
    self.node = node
    self.args = args
    self.star_args = star_args
    self.dstar_args = dstar_args
</t>
<t tx="T1631">def getChildren(self):
    children = []
    children.append(self.node)
    children.extend(flatten(self.args))
    children.append(self.star_args)
    children.append(self.dstar_args)
    return tuple(children)
</t>
<t tx="T1632">def getChildNodes(self):
    nodes = []
    nodes.append(self.node)
    nodes.extend(flatten_nodes(self.args))
    if self.star_args is not None:            nodes.append(self.star_args)
    if self.dstar_args is not None:            nodes.append(self.dstar_args)
    return tuple(nodes)
</t>
<t tx="T1633">def __repr__(self):
    return "CallFunc(%s, %s, %s, %s)" % (repr(self.node), repr(self.args), repr(self.star_args), repr(self.dstar_args))
</t>
<t tx="T1634">
class Global(Node):
	&lt;&lt; class Global declarations &gt;&gt;
	&lt;&lt; class Global methods &gt;&gt;

</t>
<t tx="T1635">nodes["global"] = "Global"
</t>
<t tx="T1636">@others</t>
<t tx="T1637">def __init__(self, names):
    self.names = names
</t>
<t tx="T1638">def getChildren(self):
    return self.names,
</t>
<t tx="T1639">def getChildNodes(self):
    return ()
</t>
<t tx="T1640">def __repr__(self):
    return "Global(%s)" % (repr(self.names),)
</t>
<t tx="T1641">
class Add(Node):
	&lt;&lt; class Add declarations &gt;&gt;
	&lt;&lt; class Add methods &gt;&gt;

</t>
<t tx="T1642">nodes["add"] = "Add"
</t>
<t tx="T1643">@others</t>
<t tx="T1644">def __init__(self, (left, right)):
    self.left = left
    self.right = right
</t>
<t tx="T1645">def getChildren(self):
    return self.left, self.right
</t>
<t tx="T1646">def getChildNodes(self):
    return self.left, self.right
</t>
<t tx="T1647">def __repr__(self):
    return "Add((%s, %s))" % (repr(self.left), repr(self.right))
</t>
<t tx="T1648">
class ListCompIf(Node):
	&lt;&lt; class ListCompIf declarations &gt;&gt;
	&lt;&lt; class ListCompIf methods &gt;&gt;

</t>
<t tx="T1649">nodes["listcompif"] = "ListCompIf"
</t>
<t tx="T1650">@others</t>
<t tx="T1651">def __init__(self, test):
    self.test = test
</t>
<t tx="T1652">def getChildren(self):
    return self.test,
</t>
<t tx="T1653">def getChildNodes(self):
    return self.test,
</t>
<t tx="T1654">def __repr__(self):
    return "ListCompIf(%s)" % (repr(self.test),)
</t>
<t tx="T1655">
class Sub(Node):
	&lt;&lt; class Sub declarations &gt;&gt;
	&lt;&lt; class Sub methods &gt;&gt;

</t>
<t tx="T1656">nodes["sub"] = "Sub"
</t>
<t tx="T1657">@others</t>
<t tx="T1658">def __init__(self, (left, right)):
    self.left = left
    self.right = right
</t>
<t tx="T1659">def getChildren(self):
    return self.left, self.right
</t>
<t tx="T1660">def getChildNodes(self):
    return self.left, self.right
</t>
<t tx="T1661">def __repr__(self):
    return "Sub((%s, %s))" % (repr(self.left), repr(self.right))
</t>
<t tx="T1662">
class Pass(Node):
	&lt;&lt; class Pass declarations &gt;&gt;
	&lt;&lt; class Pass methods &gt;&gt;

</t>
<t tx="T1663">nodes["pass"] = "Pass"
</t>
<t tx="T1664">@others</t>
<t tx="T1665">def __init__(self, ):
    pass
</t>
<t tx="T1666">def getChildren(self):
    return ()
</t>
<t tx="T1667">def getChildNodes(self):
    return ()
</t>
<t tx="T1668">def __repr__(self):
    return "Pass()"
</t>
<t tx="T1669">
class UnarySub(Node):
	&lt;&lt; class UnarySub declarations &gt;&gt;
	&lt;&lt; class UnarySub methods &gt;&gt;

</t>
<t tx="T1670">nodes["unarysub"] = "UnarySub"
</t>
<t tx="T1671">@others</t>
<t tx="T1672">def __init__(self, expr):
    self.expr = expr
</t>
<t tx="T1673">def getChildren(self):
    return self.expr,
</t>
<t tx="T1674">def getChildNodes(self):
    return self.expr,
</t>
<t tx="T1675">def __repr__(self):
    return "UnarySub(%s)" % (repr(self.expr),)
</t>
<t tx="T1676">
class If(Node):
	&lt;&lt; class If declarations &gt;&gt;
	&lt;&lt; class If methods &gt;&gt;

</t>
<t tx="T1677">nodes["if"] = "If"
</t>
<t tx="T1678">@others</t>
<t tx="T1679">def __init__(self, tests, else_):
    self.tests = tests
    self.else_ = else_
</t>
<t tx="T1680">def getChildren(self):
    children = []
    children.extend(flatten(self.tests))
    children.append(self.else_)
    return tuple(children)
</t>
<t tx="T1681">def getChildNodes(self):
    nodes = []
    nodes.extend(flatten_nodes(self.tests))
    if self.else_ is not None:            nodes.append(self.else_)
    return tuple(nodes)
</t>
<t tx="T1682">def __repr__(self):
    return "If(%s, %s)" % (repr(self.tests), repr(self.else_))
</t>
<t tx="T1683">
class ListComp(Node):
	&lt;&lt; class ListComp declarations &gt;&gt;
	&lt;&lt; class ListComp methods &gt;&gt;

</t>
<t tx="T1684">nodes["listcomp"] = "ListComp"
</t>
<t tx="T1685">@others</t>
<t tx="T1686">def __init__(self, expr, quals):
    self.expr = expr
    self.quals = quals
</t>
<t tx="T1687">def getChildren(self):
    children = []
    children.append(self.expr)
    children.extend(flatten(self.quals))
    return tuple(children)
</t>
<t tx="T1688">def getChildNodes(self):
    nodes = []
    nodes.append(self.expr)
    nodes.extend(flatten_nodes(self.quals))
    return tuple(nodes)
</t>
<t tx="T1689">def __repr__(self):
    return "ListComp(%s, %s)" % (repr(self.expr), repr(self.quals))
</t>
<t tx="T1690">
class ListCompFor(Node):
	&lt;&lt; class ListCompFor declarations &gt;&gt;
	&lt;&lt; class ListCompFor methods &gt;&gt;

</t>
<t tx="T1691">nodes["listcompfor"] = "ListCompFor"
</t>
<t tx="T1692">@others</t>
<t tx="T1693">def __init__(self, assign, list, ifs):
    self.assign = assign
    self.list = list
    self.ifs = ifs
</t>
<t tx="T1694">def getChildren(self):
    children = []
    children.append(self.assign)
    children.append(self.list)
    children.extend(flatten(self.ifs))
    return tuple(children)
</t>
<t tx="T1695">def getChildNodes(self):
    nodes = []
    nodes.append(self.assign)
    nodes.append(self.list)
    nodes.extend(flatten_nodes(self.ifs))
    return tuple(nodes)
</t>
<t tx="T1696">def __repr__(self):
    return "ListCompFor(%s, %s, %s)" % (repr(self.assign), repr(self.list), repr(self.ifs))
</t>
<t tx="T1697"># operation flags
OP_ASSIGN = 'OP_ASSIGN'
OP_DELETE = 'OP_DELETE'
OP_APPLY = 'OP_APPLY'

SC_LOCAL = 1
SC_GLOBAL = 2
SC_FREE = 3
SC_CELL = 4
SC_UNKNOWN = 5

CO_OPTIMIZED = 0x0001
CO_NEWLOCALS = 0x0002
CO_VARARGS = 0x0004
CO_VARKEYWORDS = 0x0008
CO_NESTED = 0x0010
CO_GENERATOR = 0x0020
CO_GENERATOR_ALLOWED = 0x1000
CO_FUTURE_DIVISION = 0x2000
</t>
<t tx="T1698">@language python

"""Parser for future statements"""

from compiler import ast, walk

@others

if __name__ == "__main__":
    import sys
    from compiler import parseFile, walk

    for file in sys.argv[1:]:
        print file
        tree = parseFile(file)
        v = FutureParser()
        walk(tree, v)
        print v.found
        print
</t>
<t tx="T1699">def is_future(stmt):
    """Return true if statement is a well-formed future statement"""
    if not isinstance(stmt, ast.From):
        return 0
    if stmt.modname == "__future__":
        return 1
    else:
        return 0
</t>
<t tx="T1700">class FutureParser:
	
	features = ("nested_scopes", "generators", "division")
	
	@others</t>
<t tx="T1701">def __init__(self):
    self.found = {} # set

</t>
<t tx="T1702">def visitModule(self, node):
    stmt = node.node
    for s in stmt.nodes:
        if not self.check_stmt(s):
            break
</t>
<t tx="T1703">def check_stmt(self, stmt):
    if is_future(stmt):
        for name, asname in stmt.names:
            if name in self.features:
                self.found[name] = 1
            else:
                raise SyntaxError, \
                      "future feature %s is not defined" % name
        stmt.valid_future = 1
        return 1
    return 0
</t>
<t tx="T1704">def get_features(self):
    """Return list of features enabled by future statements"""
    return self.found.keys()
</t>
<t tx="T1705">class BadFutureParser:
	"""Check for invalid future statements"""
	@others

</t>
<t tx="T1706">def visitFrom(self, node):
    if hasattr(node, 'valid_future'):
        return
    if node.modname != "__future__":
        return
    raise SyntaxError, "invalid future statement"
</t>
<t tx="T1707">def find_futures(node):
    p1 = FutureParser()
    p2 = BadFutureParser()
    walk(node, p1)
    walk(node, p2)
    return p1.get_features()
</t>
<t tx="T1708">@language python

import types
@others</t>
<t tx="T1709">def flatten(tup):
    elts = []
    for elt in tup:
        if type(elt) == types.TupleType:
            elts = elts + flatten(elt)
        else:
            elts.append(elt)
    return elts
</t>
<t tx="T1710">class Set:
	@others

</t>
<t tx="T1711">def __init__(self):
    self.elts = {}
</t>
<t tx="T1712">def __len__(self):
    return len(self.elts)
</t>
<t tx="T1713">def __contains__(self, elt):
    return self.elts.has_key(elt)
</t>
<t tx="T1714">def add(self, elt):
    self.elts[elt] = elt
</t>
<t tx="T1715">def elements(self):
    return self.elts.keys()
</t>
<t tx="T1716">def has_elt(self, elt):
    return self.elts.has_key(elt)
</t>
<t tx="T1717">def remove(self, elt):
    del self.elts[elt]
</t>
<t tx="T1718">def copy(self):
    c = Set()
    c.elts.update(self.elts)
    return c
</t>
<t tx="T1719">class Stack:
	@others

</t>
<t tx="T1720">def __init__(self):
    self.stack = []
    self.pop = self.stack.pop
</t>
<t tx="T1721">def __len__(self):
    return len(self.stack)
</t>
<t tx="T1722">def push(self, elt):
    self.stack.append(elt)
</t>
<t tx="T1723">def top(self):
    return self.stack[-1]
</t>
<t tx="T1724">def __getitem__(self, index): # needed by visitContinue()
    return self.stack[index]
</t>
<t tx="T1725">MANGLE_LEN = 256 # magic constant from compile.c

def mangle(name, klass):
    if not name.startswith('__'):
        return name
    if len(name) + 2 &gt;= MANGLE_LEN:
        return name
    if name.endswith('__'):
        return name
    try:
        i = 0
        while klass[i] == '_':
            i = i + 1
    except IndexError:
        return name
    klass = klass[i:]

    tlen = len(klass) + len(name)
    if tlen &gt; MANGLE_LEN:
        klass = klass[:MANGLE_LEN-tlen]

    return "_%s%s" % (klass, name)
</t>
<t tx="T1726">def set_filename(filename, tree):
    """Set the filename attribute to filename on every node in tree"""
    worklist = [tree]
    while worklist:
        node = worklist.pop(0)
        node.filename = filename
        worklist.extend(node.getChildNodes())
</t>
<t tx="T1727">@language python

"""A flow graph representation for Python bytecode"""

import dis
import new
import string
import sys
import types

from compiler import misc
from compiler.consts import CO_OPTIMIZED, CO_NEWLOCALS, CO_VARARGS, \
     CO_VARKEYWORDS

@others

findDepth = StackDepthTracker().findDepth
</t>
<t tx="T1728">def xxx_sort(l):
    l = l[:]
    def sorter(a, b):
        return cmp(a.bid, b.bid)
    l.sort(sorter)
    return l
</t>
<t tx="T1729">
class FlowGraph:
	&lt;&lt; class FlowGraph methods &gt;&gt;

</t>
<t tx="T1730">@others</t>
<t tx="T1731">def __init__(self):
    self.current = self.entry = Block()
    self.exit = Block("exit")
    self.blocks = misc.Set()
    self.blocks.add(self.entry)
    self.blocks.add(self.exit)
</t>
<t tx="T1732">def startBlock(self, block):
    if self._debug:
        if self.current:
            print "end", repr(self.current)
            print "    next", self.current.next
            print "   ", self.current.get_children()
        print repr(block)
    self.current = block
</t>
<t tx="T1733">def nextBlock(self, block=None):
    # XXX think we need to specify when there is implicit transfer
    # from one block to the next.  might be better to represent this
    # with explicit JUMP_ABSOLUTE instructions that are optimized
    # out when they are unnecessary.
    #
    # I think this strategy works: each block has a child
    # designated as "next" which is returned as the last of the
    # children.  because the nodes in a graph are emitted in
    # reverse post order, the "next" block will always be emitted
    # immediately after its parent.
    # Worry: maintaining this invariant could be tricky
    if block is None:
        block = self.newBlock()

    # Note: If the current block ends with an unconditional
    # control transfer, then it is incorrect to add an implicit
    # transfer to the block graph.  The current code requires
    # these edges to get the blocks emitted in the right order,
    # however. :-(  If a client needs to remove these edges, call
    # pruneEdges().

    self.current.addNext(block)
    self.startBlock(block)
</t>
<t tx="T1734">def newBlock(self):
    b = Block()
    self.blocks.add(b)
    return b
</t>
<t tx="T1735">def startExitBlock(self):
    self.startBlock(self.exit)
</t>
<t tx="T1736">_debug = 0

def _enable_debug(self):
    self._debug = 1
</t>
<t tx="T1737">def _disable_debug(self):
    self._debug = 0
</t>
<t tx="T1738">def emit(self, *inst):
    if self._debug:
        print "\t", inst
    if inst[0] == 'RETURN_VALUE':
        self.current.addOutEdge(self.exit)
    if len(inst) == 2 and isinstance(inst[1], Block):
        self.current.addOutEdge(inst[1])
    self.current.emit(inst)
</t>
<t tx="T1739">def getBlocksInOrder(self):
    """Return the blocks in reverse postorder

    i.e. each node appears before all of its successors
    """
    # XXX make sure every node that doesn't have an explicit next
    # is set so that next points to exit
    for b in self.blocks.elements():
        if b is self.exit:
            continue
        if not b.next:
            b.addNext(self.exit)
    order = dfs_postorder(self.entry, {})
    order.reverse()
    self.fixupOrder(order, self.exit)
    # hack alert
    if not self.exit in order:
        order.append(self.exit)

    return order
</t>
<t tx="T1740">def fixupOrder(self, blocks, default_next):
    """Fixup bad order introduced by DFS."""

    # XXX This is a total mess.  There must be a better way to get
    # the code blocks in the right order.

    self.fixupOrderHonorNext(blocks, default_next)
    self.fixupOrderForward(blocks, default_next)
</t>
<t tx="T1741">def fixupOrderHonorNext(self, blocks, default_next):
    """Fix one problem with DFS.

    The DFS uses child block, but doesn't know about the special
    "next" block.  As a result, the DFS can order blocks so that a
    block isn't next to the right block for implicit control
    transfers.
    """
    index = {}
    for i in range(len(blocks)):
        index[blocks[i]] = i

    for i in range(0, len(blocks) - 1):
        b = blocks[i]
        n = blocks[i + 1]
        if not b.next or b.next[0] == default_next or b.next[0] == n:
            continue
        # The blocks are in the wrong order.  Find the chain of
        # blocks to insert where they belong.
        cur = b
        chain = []
        elt = cur
        while elt.next and elt.next[0] != default_next:
            chain.append(elt.next[0])
            elt = elt.next[0]
        # Now remove the blocks in the chain from the current
        # block list, so that they can be re-inserted.
        l = []
        for b in chain:
            assert index[b] &gt; i
            l.append((index[b], b))
        l.sort()
        l.reverse()
        for j, b in l:
            del blocks[index[b]]
        # Insert the chain in the proper location
        blocks[i:i + 1] = [cur] + chain
        # Finally, re-compute the block indexes
        for i in range(len(blocks)):
            index[blocks[i]] = i
</t>
<t tx="T1742">def fixupOrderForward(self, blocks, default_next):
    """Make sure all JUMP_FORWARDs jump forward"""
    index = {}
    chains = []
    cur = []
    for b in blocks:
        index[b] = len(chains)
        cur.append(b)
        if b.next and b.next[0] == default_next:
            chains.append(cur)
            cur = []
    chains.append(cur)

    while 1:
        constraints = []

        for i in range(len(chains)):
            l = chains[i]
            for b in l:
                for c in b.get_children():
                    if index[c] &lt; i:
                        forward_p = 0
                        for inst in b.insts:
                            if inst[0] == 'JUMP_FORWARD':
                                if inst[1] == c:
                                    forward_p = 1
                        if not forward_p:
                            continue
                        constraints.append((index[c], i))

        if not constraints:
            break

        # XXX just do one for now
        # do swaps to get things in the right order
        goes_before, a_chain = constraints[0]
        assert a_chain &gt; goes_before
        c = chains[a_chain]
        chains.remove(c)
        chains.insert(goes_before, c)

    del blocks[:]
    for c in chains:
        for b in c:
            blocks.append(b)
</t>
<t tx="T1743">def getBlocks(self):
    return self.blocks.elements()
</t>
<t tx="T1744">def getRoot(self):
    """Return nodes appropriate for use with dominator"""
    return self.entry
</t>
<t tx="T1745">def getContainedGraphs(self):
    l = []
    for b in self.getBlocks():
        l.extend(b.getContainedGraphs())
    return l
</t>
<t tx="T1746">def dfs_postorder(b, seen):
    """Depth-first search of tree rooted at b, return in postorder"""
    order = []
    seen[b] = b
    for c in b.get_children():
        if seen.has_key(c):
            continue
        order = order + dfs_postorder(c, seen)
    order.append(b)
    return order
</t>
<t tx="T1747">
class Block:
	&lt;&lt; class Block declarations &gt;&gt;
	&lt;&lt; class Block methods &gt;&gt;

</t>
<t tx="T1748">_count = 0

</t>
<t tx="T1749">@others</t>
<t tx="T1750">def __init__(self, label=''):
    self.insts = []
    self.inEdges = misc.Set()
    self.outEdges = misc.Set()
    self.label = label
    self.bid = Block._count
    self.next = []
    Block._count = Block._count + 1
</t>
<t tx="T1751">def __repr__(self):
    if self.label:
        return "&lt;block %s id=%d&gt;" % (self.label, self.bid)
    else:
        return "&lt;block id=%d&gt;" % (self.bid)
</t>
<t tx="T1752">def __str__(self):
    insts = map(str, self.insts)
    return "&lt;block %s %d:\n%s&gt;" % (self.label, self.bid,
                                   string.join(insts, '\n'))
</t>
<t tx="T1753">def emit(self, inst):
    op = inst[0]
    if op[:4] == 'JUMP':
        self.outEdges.add(inst[1])
    self.insts.append(inst)
</t>
<t tx="T1754">def getInstructions(self):
    return self.insts
</t>
<t tx="T1755">def addInEdge(self, block):
    self.inEdges.add(block)
</t>
<t tx="T1756">def addOutEdge(self, block):
    self.outEdges.add(block)
</t>
<t tx="T1757">def addNext(self, block):
    self.next.append(block)
    assert len(self.next) == 1, map(str, self.next)
</t>
<t tx="T1758">_uncond_transfer = ('RETURN_VALUE', 'RAISE_VARARGS',
                    'JUMP_ABSOLUTE', 'JUMP_FORWARD', 'CONTINUE_LOOP')

def pruneNext(self):
    """Remove bogus edge for unconditional transfers

    Each block has a next edge that accounts for implicit control
    transfers, e.g. from a JUMP_IF_FALSE to the block that will be
    executed if the test is true.

    These edges must remain for the current assembler code to
    work. If they are removed, the dfs_postorder gets things in
    weird orders.  However, they shouldn't be there for other
    purposes, e.g. conversion to SSA form.  This method will
    remove the next edge when it follows an unconditional control
    transfer.
    """
    try:
        op, arg = self.insts[-1]
    except (IndexError, ValueError):
        return
    if op in self._uncond_transfer:
        self.next = []
</t>
<t tx="T1759">def get_children(self):
    if self.next and self.next[0] in self.outEdges:
        self.outEdges.remove(self.next[0])
    return self.outEdges.elements() + self.next
</t>
<t tx="T1760">def getContainedGraphs(self):
    """Return all graphs contained within this block.

    For example, a MAKE_FUNCTION block will contain a reference to
    the graph for the function body.
    """
    contained = []
    for inst in self.insts:
        if len(inst) == 1:
            continue
        op = inst[1]
        if hasattr(op, 'graph'):
            contained.append(op.graph)
    return contained
</t>
<t tx="T1761">
# flags for code objects

# the FlowGraph is transformed in place; it exists in one of these states
RAW = "RAW"
FLAT = "FLAT"
CONV = "CONV"
DONE = "DONE"

class PyFlowGraph(FlowGraph):
	&lt;&lt; class PyFlowGraph declarations &gt;&gt;
	&lt;&lt; class PyFlowGraph methods &gt;&gt;

</t>
<t tx="T1762">super_init = FlowGraph.__init__

</t>
<t tx="T1763">@others</t>
<t tx="T1764">def __init__(self, name, filename, args=(), optimized=0, klass=None):
    self.super_init()
    self.name = name
    self.filename = filename
    self.docstring = None
    self.args = args # XXX
    self.argcount = getArgCount(args)
    self.klass = klass
    if optimized:
        self.flags = CO_OPTIMIZED | CO_NEWLOCALS
    else:
        self.flags = 0
    self.consts = []
    self.names = []
    # Free variables found by the symbol table scan, including
    # variables used only in nested scopes, are included here.
    self.freevars = []
    self.cellvars = []
    # The closure list is used to track the order of cell
    # variables and free variables in the resulting code object.
    # The offsets used by LOAD_CLOSURE/LOAD_DEREF refer to both
    # kinds of variables.
    self.closure = []
    self.varnames = list(args) or []
    for i in range(len(self.varnames)):
        var = self.varnames[i]
        if isinstance(var, TupleArg):
            self.varnames[i] = var.getName()
    self.stage = RAW
</t>
<t tx="T1765">def setDocstring(self, doc):
    self.docstring = doc
</t>
<t tx="T1766">def setFlag(self, flag):
    self.flags = self.flags | flag
    if flag == CO_VARARGS:
        self.argcount = self.argcount - 1
</t>
<t tx="T1767">def checkFlag(self, flag):
    if self.flags &amp; flag:
        return 1
</t>
<t tx="T1768">def setFreeVars(self, names):
    self.freevars = list(names)
</t>
<t tx="T1769">def setCellVars(self, names):
    self.cellvars = names
</t>
<t tx="T1770">def getCode(self):
    """Get a Python code object"""
    if self.stage == RAW:
        self.computeStackDepth()
        self.flattenGraph()
    if self.stage == FLAT:
        self.convertArgs()
    if self.stage == CONV:
        self.makeByteCode()
    if self.stage == DONE:
        return self.newCodeObject()
    raise RuntimeError, "inconsistent PyFlowGraph state"
</t>
<t tx="T1771">def dump(self, io=None):
    if io:
        save = sys.stdout
        sys.stdout = io
    pc = 0
    for t in self.insts:
        opname = t[0]
        if opname == "SET_LINENO":
            print
        if len(t) == 1:
            print "\t", "%3d" % pc, opname
            pc = pc + 1
        else:
            print "\t", "%3d" % pc, opname, t[1]
            pc = pc + 3
    if io:
        sys.stdout = save
</t>
<t tx="T1772">def computeStackDepth(self):
    """Compute the max stack depth.

    Approach is to compute the stack effect of each basic block.
    Then find the path through the code with the largest total
    effect.
    """
    depth = {}
    exit = None
    for b in self.getBlocks():
        depth[b] = findDepth(b.getInstructions())

    seen = {}

    def max_depth(b, d):
        if seen.has_key(b):
            return d
        seen[b] = 1
        d = d + depth[b]
        children = b.get_children()
        if children:
            return max([max_depth(c, d) for c in children])
        else:
            if not b.label == "exit":
                return max_depth(self.exit, d)
            else:
                return d

    self.stacksize = max_depth(self.entry, 0)
</t>
<t tx="T1773">def flattenGraph(self):
    """Arrange the blocks in order and resolve jumps"""
    assert self.stage == RAW
    self.insts = insts = []
    pc = 0
    begin = {}
    end = {}
    for b in self.getBlocksInOrder():
        begin[b] = pc
        for inst in b.getInstructions():
            insts.append(inst)
            if len(inst) == 1:
                pc = pc + 1
            else:
                # arg takes 2 bytes
                pc = pc + 3
        end[b] = pc
    pc = 0
    for i in range(len(insts)):
        inst = insts[i]
        if len(inst) == 1:
            pc = pc + 1
        else:
            pc = pc + 3
        opname = inst[0]
        if self.hasjrel.has_elt(opname):
            oparg = inst[1]
            offset = begin[oparg] - pc
            insts[i] = opname, offset
        elif self.hasjabs.has_elt(opname):
            insts[i] = opname, begin[inst[1]]
    self.stage = FLAT
</t>
<t tx="T1774">hasjrel = misc.Set()
for i in dis.hasjrel:
    hasjrel.add(dis.opname[i])
hasjabs = misc.Set()
for i in dis.hasjabs:
    hasjabs.add(dis.opname[i])

def convertArgs(self):
    """Convert arguments from symbolic to concrete form"""
    assert self.stage == FLAT
    self.consts.insert(0, self.docstring)
    self.sort_cellvars()
    for i in range(len(self.insts)):
        t = self.insts[i]
        if len(t) == 2:
            opname, oparg = t
            conv = self._converters.get(opname, None)
            if conv:
                self.insts[i] = opname, conv(self, oparg)
    self.stage = CONV
</t>
<t tx="T1775">def sort_cellvars(self):
    """Sort cellvars in the order of varnames and prune from freevars.
    """
    cells = {}
    for name in self.cellvars:
        cells[name] = 1
    self.cellvars = [name for name in self.varnames
                     if cells.has_key(name)]
    for name in self.cellvars:
        del cells[name]
    self.cellvars = self.cellvars + cells.keys()
    self.closure = self.cellvars + self.freevars
</t>
<t tx="T1776">def _lookupName(self, name, list):
    """Return index of name in list, appending if necessary

    This routine uses a list instead of a dictionary, because a
    dictionary can't store two different keys if the keys have the
    same value but different types, e.g. 2 and 2L.  The compiler
    must treat these two separately, so it does an explicit type
    comparison before comparing the values.
    """
    t = type(name)
    for i in range(len(list)):
        if t == type(list[i]) and list[i] == name:
            return i
    end = len(list)
    list.append(name)
    return end
</t>
<t tx="T1777">_converters = {}
def _convert_LOAD_CONST(self, arg):
    if hasattr(arg, 'getCode'):
        arg = arg.getCode()
    return self._lookupName(arg, self.consts)
</t>
<t tx="T1778">def _convert_LOAD_FAST(self, arg):
    self._lookupName(arg, self.names)
    return self._lookupName(arg, self.varnames)
</t>
<t tx="T1779">_convert_STORE_FAST = _convert_LOAD_FAST
_convert_DELETE_FAST = _convert_LOAD_FAST

def _convert_LOAD_NAME(self, arg):
    if self.klass is None:
        self._lookupName(arg, self.varnames)
    return self._lookupName(arg, self.names)
</t>
<t tx="T1780">def _convert_NAME(self, arg):
    if self.klass is None:
        self._lookupName(arg, self.varnames)
    return self._lookupName(arg, self.names)
</t>
<t tx="T1781">_convert_STORE_NAME = _convert_NAME
_convert_DELETE_NAME = _convert_NAME
_convert_IMPORT_NAME = _convert_NAME
_convert_IMPORT_FROM = _convert_NAME
_convert_STORE_ATTR = _convert_NAME
_convert_LOAD_ATTR = _convert_NAME
_convert_DELETE_ATTR = _convert_NAME
_convert_LOAD_GLOBAL = _convert_NAME
_convert_STORE_GLOBAL = _convert_NAME
_convert_DELETE_GLOBAL = _convert_NAME

def _convert_DEREF(self, arg):
    self._lookupName(arg, self.names)
    self._lookupName(arg, self.varnames)
    return self._lookupName(arg, self.closure)
</t>
<t tx="T1782">_convert_LOAD_DEREF = _convert_DEREF
_convert_STORE_DEREF = _convert_DEREF

def _convert_LOAD_CLOSURE(self, arg):
    self._lookupName(arg, self.varnames)
    return self._lookupName(arg, self.closure)
</t>
<t tx="T1783">_cmp = list(dis.cmp_op)
def _convert_COMPARE_OP(self, arg):
    return self._cmp.index(arg)
</t>
<t tx="T1784"># similarly for other opcodes...

for name, obj in locals().items():
    if name[:9] == "_convert_":
        opname = name[9:]
        _converters[opname] = obj
del name, obj, opname

def makeByteCode(self):
    assert self.stage == CONV
    self.lnotab = lnotab = LineAddrTable()
    for t in self.insts:
        opname = t[0]
        if len(t) == 1:
            lnotab.addCode(self.opnum[opname])
        else:
            oparg = t[1]
            if opname == "SET_LINENO":
                lnotab.nextLine(oparg)
            hi, lo = twobyte(oparg)
            try:
                lnotab.addCode(self.opnum[opname], lo, hi)
            except ValueError:
                print opname, oparg
                print self.opnum[opname], lo, hi
                raise
    self.stage = DONE
</t>
<t tx="T1785">opnum = {}
for num in range(len(dis.opname)):
    opnum[dis.opname[num]] = num
del num

def newCodeObject(self):
    assert self.stage == DONE
    if (self.flags &amp; CO_NEWLOCALS) == 0:
        nlocals = 0
    else:
        nlocals = len(self.varnames)
    argcount = self.argcount
    if self.flags &amp; CO_VARKEYWORDS:
        argcount = argcount - 1
    return new.code(argcount, nlocals, self.stacksize, self.flags,
                    self.lnotab.getCode(), self.getConsts(),
                    tuple(self.names), tuple(self.varnames),
                    self.filename, self.name, self.lnotab.firstline,
                    self.lnotab.getTable(), tuple(self.freevars),
                    tuple(self.cellvars))
</t>
<t tx="T1786">def getConsts(self):
    """Return a tuple for the const slot of the code object

    Must convert references to code (MAKE_FUNCTION) to code
    objects recursively.
    """
    l = []
    for elt in self.consts:
        if isinstance(elt, PyFlowGraph):
            elt = elt.getCode()
        l.append(elt)
    return tuple(l)
</t>
<t tx="T1787">def isJump(opname):
    if opname[:4] == 'JUMP':
        return 1
</t>
<t tx="T1788">
class TupleArg:
	&lt;&lt; class TupleArg declarations &gt;&gt;
	&lt;&lt; class TupleArg methods &gt;&gt;

</t>
<t tx="T1789">"""Helper for marking func defs with nested tuples in arglist"""
</t>
<t tx="T1790">@others</t>
<t tx="T1791">def __init__(self, count, names):
    self.count = count
    self.names = names
</t>
<t tx="T1792">def __repr__(self):
    return "TupleArg(%s, %s)" % (self.count, self.names)
</t>
<t tx="T1793">def getName(self):
    return ".%d" % self.count
</t>
<t tx="T1794">def getArgCount(args):
    argcount = len(args)
    if args:
        for arg in args:
            if isinstance(arg, TupleArg):
                numNames = len(misc.flatten(arg.names))
                argcount = argcount - numNames
    return argcount
</t>
<t tx="T1795">def twobyte(val):
    """Convert an int argument into high and low bytes"""
    assert type(val) == types.IntType
    return divmod(val, 256)
</t>
<t tx="T1796">
class LineAddrTable:
	&lt;&lt; class LineAddrTable declarations &gt;&gt;
	&lt;&lt; class LineAddrTable methods &gt;&gt;

</t>
<t tx="T1797">"""lnotab

This class builds the lnotab, which is documented in compile.c.
Here's a brief recap:

For each SET_LINENO instruction after the first one, two bytes are
added to lnotab.  (In some cases, multiple two-byte entries are
added.)  The first byte is the distance in bytes between the
instruction for the last SET_LINENO and the current SET_LINENO.
The second byte is offset in line numbers.  If either offset is
greater than 255, multiple two-byte entries are added -- see
compile.c for the delicate details.
"""

</t>
<t tx="T1798">@others</t>
<t tx="T1799">def __init__(self):
    self.code = []
    self.codeOffset = 0
    self.firstline = 0
    self.lastline = 0
    self.lastoff = 0
    self.lnotab = []
</t>
<t tx="T1800">def addCode(self, *args):
    for arg in args:
        self.code.append(chr(arg))
    self.codeOffset = self.codeOffset + len(args)
</t>
<t tx="T1801">def nextLine(self, lineno):
    if self.firstline == 0:
        self.firstline = lineno
        self.lastline = lineno
    else:
        # compute deltas
        addr = self.codeOffset - self.lastoff
        line = lineno - self.lastline
        # Python assumes that lineno always increases with
        # increasing bytecode address (lnotab is unsigned char).
        # Depending on when SET_LINENO instructions are emitted
        # this is not always true.  Consider the code:
        #     a = (1,
        #          b)
        # In the bytecode stream, the assignment to "a" occurs
        # after the loading of "b".  This works with the C Python
        # compiler because it only generates a SET_LINENO instruction
        # for the assignment.
        if line &gt; 0:
            push = self.lnotab.append
            while addr &gt; 255:
                push(255); push(0)
                addr -= 255
            while line &gt; 255:
                push(addr); push(255)
                line -= 255
                addr = 0
            if addr &gt; 0 or line &gt; 0:
                push(addr); push(line)
            self.lastline = lineno
            self.lastoff = self.codeOffset
</t>
<t tx="T1802">def getCode(self):
    return string.join(self.code, '')
</t>
<t tx="T1803">def getTable(self):
    return string.join(map(chr, self.lnotab), '')
</t>
<t tx="T1804">
class StackDepthTracker:
	&lt;&lt; class StackDepthTracker declarations &gt;&gt;
	&lt;&lt; class StackDepthTracker methods &gt;&gt;

</t>
<t tx="T1805"># XXX 1. need to keep track of stack depth on jumps
# XXX 2. at least partly as a result, this code is broken

</t>
<t tx="T1806">@others</t>
<t tx="T1807">def findDepth(self, insts, debug=0):
    depth = 0
    maxDepth = 0
    for i in insts:
        opname = i[0]
        if debug:
            print i,
        delta = self.effect.get(opname, None)
        if delta is not None:
            depth = depth + delta
        else:
            # now check patterns
            for pat, pat_delta in self.patterns:
                if opname[:len(pat)] == pat:
                    delta = pat_delta
                    depth = depth + delta
                    break
            # if we still haven't found a match
            if delta is None:
                meth = getattr(self, opname, None)
                if meth is not None:
                    depth = depth + meth(i[1])
        if depth &gt; maxDepth:
            maxDepth = depth
        if debug:
            print depth, maxDepth
    return maxDepth
</t>
<t tx="T1808">effect = {
    'POP_TOP': -1,
    'DUP_TOP': 1,
    'SLICE+1': -1,
    'SLICE+2': -1,
    'SLICE+3': -2,
    'STORE_SLICE+0': -1,
    'STORE_SLICE+1': -2,
    'STORE_SLICE+2': -2,
    'STORE_SLICE+3': -3,
    'DELETE_SLICE+0': -1,
    'DELETE_SLICE+1': -2,
    'DELETE_SLICE+2': -2,
    'DELETE_SLICE+3': -3,
    'STORE_SUBSCR': -3,
    'DELETE_SUBSCR': -2,
    # PRINT_EXPR?
    'PRINT_ITEM': -1,
    'RETURN_VALUE': -1,
    'EXEC_STMT': -3,
    'BUILD_CLASS': -2,
    'STORE_NAME': -1,
    'STORE_ATTR': -2,
    'DELETE_ATTR': -1,
    'STORE_GLOBAL': -1,
    'BUILD_MAP': 1,
    'COMPARE_OP': -1,
    'STORE_FAST': -1,
    'IMPORT_STAR': -1,
    'IMPORT_NAME': 0,
    'IMPORT_FROM': 1,
    'LOAD_ATTR': 0, # unlike other loads
    # close enough...
    'SETUP_EXCEPT': 3,
    'SETUP_FINALLY': 3,
    'FOR_ITER': 1,
    }
# use pattern match
patterns = [
    ('BINARY_', -1),
    ('LOAD_', 1),
    ]

def UNPACK_SEQUENCE(self, count):
    return count-1
</t>
<t tx="T1809">def BUILD_TUPLE(self, count):
    return -count+1
</t>
<t tx="T1810">def BUILD_LIST(self, count):
    return -count+1
</t>
<t tx="T1811">def CALL_FUNCTION(self, argc):
    hi, lo = divmod(argc, 256)
    return -(lo + hi * 2)
</t>
<t tx="T1812">def CALL_FUNCTION_VAR(self, argc):
    return self.CALL_FUNCTION(argc)-1
</t>
<t tx="T1813">def CALL_FUNCTION_KW(self, argc):
    return self.CALL_FUNCTION(argc)-1
</t>
<t tx="T1814">def CALL_FUNCTION_VAR_KW(self, argc):
    return self.CALL_FUNCTION(argc)-2
</t>
<t tx="T1815">def MAKE_FUNCTION(self, argc):
    return -argc
</t>
<t tx="T1816">def MAKE_CLOSURE(self, argc):
    # XXX need to account for free variables too!
    return -argc
</t>
<t tx="T1817">def BUILD_SLICE(self, argc):
    if argc == 2:
        return -1
    elif argc == 3:
        return -2
</t>
<t tx="T1818">def DUP_TOPX(self, argc):
    return argc
</t>
<t tx="T1819">@language python
@others
&lt;&lt; pycodegen declarations &gt;&gt;

if __name__ == "__main__":
    import sys

    for file in sys.argv[1:]:
        compileFile(file)
</t>
<t tx="T1820">import imp
import os
import marshal
import stat
import string
import struct
import sys
import types
from cStringIO import StringIO

from compiler import ast, parse, walk, syntax
from compiler import pyassem, misc, future, symbols
from compiler.consts import SC_LOCAL, SC_GLOBAL, SC_FREE, SC_CELL
from compiler.consts import CO_VARARGS, CO_VARKEYWORDS, CO_NEWLOCALS,\
     CO_NESTED, CO_GENERATOR, CO_GENERATOR_ALLOWED, CO_FUTURE_DIVISION
from compiler.pyassem import TupleArg

# Do we have Python 1.x or Python 2.x?
try:
    VERSION = sys.version_info[0]
except AttributeError:
    VERSION = 1

callfunc_opcode_info = {
    # (Have *args, Have **args) : opcode
    (0,0) : "CALL_FUNCTION",
    (1,0) : "CALL_FUNCTION_VAR",
    (0,1) : "CALL_FUNCTION_KW",
    (1,1) : "CALL_FUNCTION_VAR_KW",
}

LOOP = 1
EXCEPT = 2
TRY_FINALLY = 3
END_FINALLY = 4

# XXX this doesn't seem to be used
</t>
<t tx="T1821">class BlockStack(misc.Stack):
	&lt;&lt; class BlockStack declarations &gt;&gt;
	&lt;&lt; class BlockStack methods &gt;&gt;

</t>
<t tx="T1822">__super_init = misc.Stack.__init__

</t>
<t tx="T1823">@others</t>
<t tx="T1824">def __init__(self):
    self.__super_init(self)
    self.loop = None
</t>
<t tx="T1825">def compileFile(filename, display=0):
    f = open(filename)
    buf = f.read()
    f.close()
    mod = Module(buf, filename)
    try:
        mod.compile(display)
    except SyntaxError, err:
        raise
    else:
        f = open(filename + "c", "wb")
        mod.dump(f)
        f.close()
</t>
<t tx="T1826">def compile(source, filename, mode, flags=None, dont_inherit=None):
    """Replacement for builtin compile() function"""
    if flags is not None or dont_inherit is not None:
        raise RuntimeError, "not implemented yet"

    if mode == "single":
        gen = Interactive(source, filename)
    elif mode == "exec":
        gen = Module(source, filename)
    elif mode == "eval":
        gen = Expression(source, filename)
    else:
        raise ValueError("compile() 3rd arg must be 'exec' or "
                         "'eval' or 'single'")
    gen.compile()
    return gen.code
</t>
<t tx="T1827">
class AbstractCompileMode:
	&lt;&lt; class AbstractCompileMode declarations &gt;&gt;
	&lt;&lt; class AbstractCompileMode methods &gt;&gt;

</t>
<t tx="T1828">mode = None # defined by subclass

</t>
<t tx="T1829">@others</t>
<t tx="T1830">def __init__(self, source, filename):
    self.source = source
    self.filename = filename
    self.code = None
</t>
<t tx="T1831">def _get_tree(self):
    tree = parse(self.source, self.mode)
    misc.set_filename(self.filename, tree)
    syntax.check(tree)
    return tree
</t>
<t tx="T1832">def compile(self):
    pass # implemented by subclass

</t>
<t tx="T1833">def getCode(self):
    return self.code
</t>
<t tx="T1834">
class Expression(AbstractCompileMode):
	&lt;&lt; class Expression declarations &gt;&gt;
	&lt;&lt; class Expression methods &gt;&gt;

</t>
<t tx="T1835">mode = "eval"

</t>
<t tx="T1836">@others</t>
<t tx="T1837">def compile(self):
    tree = self._get_tree()
    gen = ExpressionCodeGenerator(tree)
    self.code = gen.getCode()
</t>
<t tx="T1838">
class Interactive(AbstractCompileMode):
	&lt;&lt; class Interactive declarations &gt;&gt;
	&lt;&lt; class Interactive methods &gt;&gt;

</t>
<t tx="T1839">mode = "single"

</t>
<t tx="T1840">@others</t>
<t tx="T1841">def compile(self):
    tree = self._get_tree()
    gen = InteractiveCodeGenerator(tree)
    self.code = gen.getCode()
</t>
<t tx="T1842">
class Module(AbstractCompileMode):
	&lt;&lt; class Module declarations &gt;&gt;
	&lt;&lt; class Module methods &gt;&gt;

</t>
<t tx="T1843">mode = "exec"

</t>
<t tx="T1844">@others</t>
<t tx="T1845">def compile(self, display=0):
    tree = self._get_tree()
    gen = ModuleCodeGenerator(tree)
    if display:
        import pprint
        print pprint.pprint(tree)
    self.code = gen.getCode()
</t>
<t tx="T1846">def dump(self, f):
    f.write(self.getPycHeader())
    marshal.dump(self.code, f)
</t>
<t tx="T1847">MAGIC = imp.get_magic()

def getPycHeader(self):
    # compile.c uses marshal to write a long directly, with
    # calling the interface that would also generate a 1-byte code
    # to indicate the type of the value.  simplest way to get the
    # same effect is to call marshal and then skip the code.
    mtime = os.stat(self.filename)[stat.ST_MTIME]
    mtime = struct.pack('i', mtime)
    return self.MAGIC + mtime
</t>
<t tx="T1848">
class LocalNameFinder:
	&lt;&lt; class LocalNameFinder declarations &gt;&gt;
	&lt;&lt; class LocalNameFinder methods &gt;&gt;

</t>
<t tx="T1849">"""Find local names in scope"""
</t>
<t tx="T1850">@others</t>
<t tx="T1851">def __init__(self, names=()):
    self.names = misc.Set()
    self.globals = misc.Set()
    for name in names:
        self.names.add(name)
</t>
<t tx="T1852"># XXX list comprehensions and for loops

def getLocals(self):
    for elt in self.globals.elements():
        if self.names.has_elt(elt):
            self.names.remove(elt)
    return self.names
</t>
<t tx="T1853">def visitDict(self, node):
    pass
</t>
<t tx="T1854">def visitGlobal(self, node):
    for name in node.names:
        self.globals.add(name)
</t>
<t tx="T1855">def visitFunction(self, node):
    self.names.add(node.name)
</t>
<t tx="T1856">def visitLambda(self, node):
    pass
</t>
<t tx="T1857">def visitImport(self, node):
    for name, alias in node.names:
        self.names.add(alias or name)
</t>
<t tx="T1858">def visitFrom(self, node):
    for name, alias in node.names:
        self.names.add(alias or name)
</t>
<t tx="T1859">def visitClass(self, node):
    self.names.add(node.name)
</t>
<t tx="T1860">def visitAssName(self, node):
    self.names.add(node.name)
</t>
<t tx="T1861">def is_constant_false(node):
    if isinstance(node, ast.Const):
        if not node.value:
            return 1
    return 0
</t>
<t tx="T1862">
class CodeGenerator:
	&lt;&lt; class CodeGenerator declarations &gt;&gt;
	&lt;&lt; class CodeGenerator methods &gt;&gt;

</t>
<t tx="T1863">"""Defines basic code generator for Python bytecode

This class is an abstract base class.  Concrete subclasses must
define an __init__() that defines self.graph and then calls the
__init__() defined in this class.

The concrete class must also define the class attributes
NameFinder, FunctionGen, and ClassGen.  These attributes can be
defined in the initClass() method, which is a hook for
initializing these methods after all the classes have been
defined.
"""

optimized = 0 # is namespace access optimized?
__initialized = None
class_name = None # provide default for instance variable

</t>
<t tx="T1864">@others</t>
<t tx="T1865">def __init__(self):
    if self.__initialized is None:
        self.initClass()
        self.__class__.__initialized = 1
    self.checkClass()
    self.locals = misc.Stack()
    self.setups = misc.Stack()
    self.curStack = 0
    self.maxStack = 0
    self.last_lineno = None
    self._setupGraphDelegation()
    self._div_op = "BINARY_DIVIDE"

    # XXX set flags based on future features
    futures = self.get_module().futures
    for feature in futures:
        if feature == "division":
            self.graph.setFlag(CO_FUTURE_DIVISION)
            self._div_op = "BINARY_TRUE_DIVIDE"
        elif feature == "generators":
            self.graph.setFlag(CO_GENERATOR_ALLOWED)
</t>
<t tx="T1866">def initClass(self):
    """This method is called once for each class"""
</t>
<t tx="T1867">def checkClass(self):
    """Verify that class is constructed correctly"""
    try:
        assert hasattr(self, 'graph')
        assert getattr(self, 'NameFinder')
        assert getattr(self, 'FunctionGen')
        assert getattr(self, 'ClassGen')
    except AssertionError, msg:
        intro = "Bad class construction for %s" % self.__class__.__name__
        raise AssertionError, intro
</t>
<t tx="T1868">def _setupGraphDelegation(self):
    self.emit = self.graph.emit
    self.newBlock = self.graph.newBlock
    self.startBlock = self.graph.startBlock
    self.nextBlock = self.graph.nextBlock
    self.setDocstring = self.graph.setDocstring
</t>
<t tx="T1869">def getCode(self):
    """Return a code object"""
    return self.graph.getCode()
</t>
<t tx="T1870">def mangle(self, name):
    if self.class_name is not None:
        return misc.mangle(name, self.class_name)
    else:
        return name
</t>
<t tx="T1871">def parseSymbols(self, tree):
    s = symbols.SymbolVisitor()
    walk(tree, s)
    return s.scopes
</t>
<t tx="T1872">def get_module(self):
    raise RuntimeError, "should be implemented by subclasses"
</t>
<t tx="T1873"># Next five methods handle name access

def isLocalName(self, name):
    return self.locals.top().has_elt(name)
</t>
<t tx="T1874">def storeName(self, name):
    self._nameOp('STORE', name)
</t>
<t tx="T1875">def loadName(self, name):
    self._nameOp('LOAD', name)
</t>
<t tx="T1876">def delName(self, name):
    self._nameOp('DELETE', name)
</t>
<t tx="T1877">def _nameOp(self, prefix, name):
    name = self.mangle(name)
    scope = self.scope.check_name(name)
    if scope == SC_LOCAL:
        if not self.optimized:
            self.emit(prefix + '_NAME', name)
        else:
            self.emit(prefix + '_FAST', name)
    elif scope == SC_GLOBAL:
        if not self.optimized:
            self.emit(prefix + '_NAME', name)
        else:
            self.emit(prefix + '_GLOBAL', name)
    elif scope == SC_FREE or scope == SC_CELL:
        self.emit(prefix + '_DEREF', name)
    else:
        raise RuntimeError, "unsupported scope for var %s: %d" % \
              (name, scope)
</t>
<t tx="T1878">def _implicitNameOp(self, prefix, name):
    """Emit name ops for names generated implicitly by for loops

    The interpreter generates names that start with a period or
    dollar sign.  The symbol table ignores these names because
    they aren't present in the program text.
    """
    if self.optimized:
        self.emit(prefix + '_FAST', name)
    else:
        self.emit(prefix + '_NAME', name)
</t>
<t tx="T1879">def set_lineno(self, node, force=0):
    """Emit SET_LINENO if node has lineno attribute and it is
    different than the last lineno emitted.

    Returns true if SET_LINENO was emitted.

    There are no rules for when an AST node should have a lineno
    attribute.  The transformer and AST code need to be reviewed
    and a consistent policy implemented and documented.  Until
    then, this method works around missing line numbers.
    """
    lineno = getattr(node, 'lineno', None)
    if lineno is not None and (lineno != self.last_lineno
                               or force):
        self.emit('SET_LINENO', lineno)
        self.last_lineno = lineno
        return 1
    return 0
</t>
<t tx="T1880"># The first few visitor methods handle nodes that generator new
# code objects.  They use class attributes to determine what
# specialized code generators to use.

NameFinder = LocalNameFinder
FunctionGen = None
ClassGen = None

def visitModule(self, node):
    self.scopes = self.parseSymbols(node)
    self.scope = self.scopes[node]
    self.emit('SET_LINENO', 0)
    if node.doc:
        self.emit('LOAD_CONST', node.doc)
        self.storeName('__doc__')
    lnf = walk(node.node, self.NameFinder(), verbose=0)
    self.locals.push(lnf.getLocals())
    self.visit(node.node)
    self.emit('LOAD_CONST', None)
    self.emit('RETURN_VALUE')
</t>
<t tx="T1881">def visitExpression(self, node):
    self.set_lineno(node)
    self.scopes = self.parseSymbols(node)
    self.scope = self.scopes[node]
    self.visit(node.node)
    self.emit('RETURN_VALUE')
</t>
<t tx="T1882">def visitFunction(self, node):
    self._visitFuncOrLambda(node, isLambda=0)
    if node.doc:
        self.setDocstring(node.doc)
    self.storeName(node.name)
</t>
<t tx="T1883">def visitLambda(self, node):
    self._visitFuncOrLambda(node, isLambda=1)
</t>
<t tx="T1884">def _visitFuncOrLambda(self, node, isLambda=0):
    gen = self.FunctionGen(node, self.scopes, isLambda,
                           self.class_name, self.get_module())
    walk(node.code, gen)
    gen.finish()
    self.set_lineno(node)
    for default in node.defaults:
        self.visit(default)
    frees = gen.scope.get_free_vars()
    if frees:
        for name in frees:
            self.emit('LOAD_CLOSURE', name)
        self.emit('LOAD_CONST', gen)
        self.emit('MAKE_CLOSURE', len(node.defaults))
    else:
        self.emit('LOAD_CONST', gen)
        self.emit('MAKE_FUNCTION', len(node.defaults))
</t>
<t tx="T1885">def visitClass(self, node):
    gen = self.ClassGen(node, self.scopes,
                        self.get_module())
    if node.doc:
        self.emit('LOAD_CONST', node.doc)
        self.storeName('__doc__')
    walk(node.code, gen)
    gen.finish()
    self.set_lineno(node)
    self.emit('LOAD_CONST', node.name)
    for base in node.bases:
        self.visit(base)
    self.emit('BUILD_TUPLE', len(node.bases))
    frees = gen.scope.get_free_vars()
    for name in frees:
        self.emit('LOAD_CLOSURE', name)
    self.emit('LOAD_CONST', gen)
    if frees:
        self.emit('MAKE_CLOSURE', 0)
    else:
        self.emit('MAKE_FUNCTION', 0)
    self.emit('CALL_FUNCTION', 0)
    self.emit('BUILD_CLASS')
    self.storeName(node.name)
</t>
<t tx="T1886"># The rest are standard visitor methods

# The next few implement control-flow statements

def visitIf(self, node):
    end = self.newBlock()
    numtests = len(node.tests)
    for i in range(numtests):
        test, suite = node.tests[i]
        if is_constant_false(test):
            # XXX will need to check generator stuff here
            continue
        self.set_lineno(test)
        self.visit(test)
        nextTest = self.newBlock()
        self.emit('JUMP_IF_FALSE', nextTest)
        self.nextBlock()
        self.emit('POP_TOP')
        self.visit(suite)
        self.emit('JUMP_FORWARD', end)
        self.startBlock(nextTest)
        self.emit('POP_TOP')
    if node.else_:
        self.visit(node.else_)
    self.nextBlock(end)
</t>
<t tx="T1887">def visitWhile(self, node):
    self.set_lineno(node)

    loop = self.newBlock()
    else_ = self.newBlock()

    after = self.newBlock()
    self.emit('SETUP_LOOP', after)

    self.nextBlock(loop)
    self.setups.push((LOOP, loop))

    self.set_lineno(node, force=1)
    self.visit(node.test)
    self.emit('JUMP_IF_FALSE', else_ or after)

    self.nextBlock()
    self.emit('POP_TOP')
    self.visit(node.body)
    self.emit('JUMP_ABSOLUTE', loop)

    self.startBlock(else_) # or just the POPs if not else clause
    self.emit('POP_TOP')
    self.emit('POP_BLOCK')
    self.setups.pop()
    if node.else_:
        self.visit(node.else_)
    self.nextBlock(after)
</t>
<t tx="T1888">def visitFor(self, node):
    start = self.newBlock()
    anchor = self.newBlock()
    after = self.newBlock()
    self.setups.push((LOOP, start))

    self.set_lineno(node)
    self.emit('SETUP_LOOP', after)
    self.visit(node.list)
    self.emit('GET_ITER')

    self.nextBlock(start)
    self.set_lineno(node, force=1)
    self.emit('FOR_ITER', anchor)
    self.visit(node.assign)
    self.visit(node.body)
    self.emit('JUMP_ABSOLUTE', start)
    self.nextBlock(anchor)
    self.emit('POP_BLOCK')
    self.setups.pop()
    if node.else_:
        self.visit(node.else_)
    self.nextBlock(after)
</t>
<t tx="T1889">def visitBreak(self, node):
    if not self.setups:
        raise SyntaxError, "'break' outside loop (%s, %d)" % \
              (node.filename, node.lineno)
    self.set_lineno(node)
    self.emit('BREAK_LOOP')
</t>
<t tx="T1890">def visitContinue(self, node):
    if not self.setups:
        raise SyntaxError, "'continue' outside loop (%s, %d)" % \
              (node.filename, node.lineno)
    kind, block = self.setups.top()
    if kind == LOOP:
        self.set_lineno(node)
        self.emit('JUMP_ABSOLUTE', block)
        self.nextBlock()
    elif kind == EXCEPT or kind == TRY_FINALLY:
        self.set_lineno(node)
        # find the block that starts the loop
        top = len(self.setups)
        while top &gt; 0:
            top = top - 1
            kind, loop_block = self.setups[top]
            if kind == LOOP:
                break
        if kind != LOOP:
            raise SyntaxError, "'continue' outside loop (%s, %d)" % \
                  (node.filename, node.lineno)
        self.emit('CONTINUE_LOOP', loop_block)
        self.nextBlock()
    elif kind == END_FINALLY:
        msg = "'continue' not allowed inside 'finally' clause (%s, %d)"
        raise SyntaxError, msg % (node.filename, node.lineno)
</t>
<t tx="T1891">def visitTest(self, node, jump):
    end = self.newBlock()
    for child in node.nodes[:-1]:
        self.visit(child)
        self.emit(jump, end)
        self.nextBlock()
        self.emit('POP_TOP')
    self.visit(node.nodes[-1])
    self.nextBlock(end)
</t>
<t tx="T1892">def visitAnd(self, node):
    self.visitTest(node, 'JUMP_IF_FALSE')
</t>
<t tx="T1893">def visitOr(self, node):
    self.visitTest(node, 'JUMP_IF_TRUE')
</t>
<t tx="T1894">def visitCompare(self, node):
    self.visit(node.expr)
    cleanup = self.newBlock()
    for op, code in node.ops[:-1]:
        self.visit(code)
        self.emit('DUP_TOP')
        self.emit('ROT_THREE')
        self.emit('COMPARE_OP', op)
        self.emit('JUMP_IF_FALSE', cleanup)
        self.nextBlock()
        self.emit('POP_TOP')
    # now do the last comparison
    if node.ops:
        op, code = node.ops[-1]
        self.visit(code)
        self.emit('COMPARE_OP', op)
    if len(node.ops) &gt; 1:
        end = self.newBlock()
        self.emit('JUMP_FORWARD', end)
        self.startBlock(cleanup)
        self.emit('ROT_TWO')
        self.emit('POP_TOP')
        self.nextBlock(end)
</t>
<t tx="T1895"># list comprehensions
__list_count = 0

def visitListComp(self, node):
    self.set_lineno(node)
    # setup list
    append = "$append%d" % self.__list_count
    self.__list_count = self.__list_count + 1
    self.emit('BUILD_LIST', 0)
    self.emit('DUP_TOP')
    self.emit('LOAD_ATTR', 'append')
    self._implicitNameOp('STORE', append)

    stack = []
    for i, for_ in zip(range(len(node.quals)), node.quals):
        start, anchor = self.visit(for_)
        cont = None
        for if_ in for_.ifs:
            if cont is None:
                cont = self.newBlock()
            self.visit(if_, cont)
        stack.insert(0, (start, cont, anchor))

    self._implicitNameOp('LOAD', append)
    self.visit(node.expr)
    self.emit('CALL_FUNCTION', 1)
    self.emit('POP_TOP')

    for start, cont, anchor in stack:
        if cont:
            skip_one = self.newBlock()
            self.emit('JUMP_FORWARD', skip_one)
            self.startBlock(cont)
            self.emit('POP_TOP')
            self.nextBlock(skip_one)
        self.emit('JUMP_ABSOLUTE', start)
        self.startBlock(anchor)
    self._implicitNameOp('DELETE', append)

    self.__list_count = self.__list_count - 1
</t>
<t tx="T1896">def visitListCompFor(self, node):
    start = self.newBlock()
    anchor = self.newBlock()

    self.visit(node.list)
    self.emit('GET_ITER')
    self.nextBlock(start)
    self.emit('SET_LINENO', node.lineno)
    self.emit('FOR_ITER', anchor)
    self.nextBlock()
    self.visit(node.assign)
    return start, anchor
</t>
<t tx="T1897">def visitListCompIf(self, node, branch):
    self.set_lineno(node, force=1)
    self.visit(node.test)
    self.emit('JUMP_IF_FALSE', branch)
    self.newBlock()
    self.emit('POP_TOP')
</t>
<t tx="T1898"># exception related

def visitAssert(self, node):
    # XXX would be interesting to implement this via a
    # transformation of the AST before this stage
    end = self.newBlock()
    self.set_lineno(node)
    # XXX __debug__ and AssertionError appear to be special cases
    # -- they are always loaded as globals even if there are local
    # names.  I guess this is a sort of renaming op.
    self.emit('LOAD_GLOBAL', '__debug__')
    self.emit('JUMP_IF_FALSE', end)
    self.nextBlock()
    self.emit('POP_TOP')
    self.visit(node.test)
    self.emit('JUMP_IF_TRUE', end)
    self.nextBlock()
    self.emit('POP_TOP')
    self.emit('LOAD_GLOBAL', 'AssertionError')
    if node.fail:
        self.visit(node.fail)
        self.emit('RAISE_VARARGS', 2)
    else:
        self.emit('RAISE_VARARGS', 1)
    self.nextBlock(end)
    self.emit('POP_TOP')
</t>
<t tx="T1899">def visitRaise(self, node):
    self.set_lineno(node)
    n = 0
    if node.expr1:
        self.visit(node.expr1)
        n = n + 1
    if node.expr2:
        self.visit(node.expr2)
        n = n + 1
    if node.expr3:
        self.visit(node.expr3)
        n = n + 1
    self.emit('RAISE_VARARGS', n)
</t>
<t tx="T1900">def visitTryExcept(self, node):
    body = self.newBlock()
    handlers = self.newBlock()
    end = self.newBlock()
    if node.else_:
        lElse = self.newBlock()
    else:
        lElse = end
    self.set_lineno(node)
    self.emit('SETUP_EXCEPT', handlers)
    self.nextBlock(body)
    self.setups.push((EXCEPT, body))
    self.visit(node.body)
    self.emit('POP_BLOCK')
    self.setups.pop()
    self.emit('JUMP_FORWARD', lElse)
    self.startBlock(handlers)

    last = len(node.handlers) - 1
    for i in range(len(node.handlers)):
        expr, target, body = node.handlers[i]
        self.set_lineno(expr)
        if expr:
            self.emit('DUP_TOP')
            self.visit(expr)
            self.emit('COMPARE_OP', 'exception match')
            next = self.newBlock()
            self.emit('JUMP_IF_FALSE', next)
            self.nextBlock()
            self.emit('POP_TOP')
        self.emit('POP_TOP')
        if target:
            self.visit(target)
        else:
            self.emit('POP_TOP')
        self.emit('POP_TOP')
        self.visit(body)
        self.emit('JUMP_FORWARD', end)
        if expr:
            self.nextBlock(next)
        else:
            self.nextBlock()
        if expr: # XXX
            self.emit('POP_TOP')
    self.emit('END_FINALLY')
    if node.else_:
        self.nextBlock(lElse)
        self.visit(node.else_)
    self.nextBlock(end)
</t>
<t tx="T1901">def visitTryFinally(self, node):
    body = self.newBlock()
    final = self.newBlock()
    self.set_lineno(node)
    self.emit('SETUP_FINALLY', final)
    self.nextBlock(body)
    self.setups.push((TRY_FINALLY, body))
    self.visit(node.body)
    self.emit('POP_BLOCK')
    self.setups.pop()
    self.emit('LOAD_CONST', None)
    self.nextBlock(final)
    self.setups.push((END_FINALLY, final))
    self.visit(node.final)
    self.emit('END_FINALLY')
    self.setups.pop()
</t>
<t tx="T1902"># misc

def visitDiscard(self, node):
    self.set_lineno(node)
    self.visit(node.expr)
    self.emit('POP_TOP')
</t>
<t tx="T1903">def visitConst(self, node):
    self.emit('LOAD_CONST', node.value)
</t>
<t tx="T1904">def visitKeyword(self, node):
    self.emit('LOAD_CONST', node.name)
    self.visit(node.expr)
</t>
<t tx="T1905">def visitGlobal(self, node):
    # no code to generate
    pass
</t>
<t tx="T1906">def visitName(self, node):
    self.set_lineno(node)
    self.loadName(node.name)
</t>
<t tx="T1907">def visitPass(self, node):
    self.set_lineno(node)
</t>
<t tx="T1908">def visitImport(self, node):
    self.set_lineno(node)
    for name, alias in node.names:
        if VERSION &gt; 1:
            self.emit('LOAD_CONST', None)
        self.emit('IMPORT_NAME', name)
        mod = string.split(name, ".")[0]
        self.storeName(alias or mod)
</t>
<t tx="T1909">def visitFrom(self, node):
    self.set_lineno(node)
    fromlist = map(lambda (name, alias): name, node.names)
    if VERSION &gt; 1:
        self.emit('LOAD_CONST', tuple(fromlist))
    self.emit('IMPORT_NAME', node.modname)
    for name, alias in node.names:
        if VERSION &gt; 1:
            if name == '*':
                self.namespace = 0
                self.emit('IMPORT_STAR')
                # There can only be one name w/ from ... import *
                assert len(node.names) == 1
                return
            else:
                self.emit('IMPORT_FROM', name)
                self._resolveDots(name)
                self.storeName(alias or name)
        else:
            self.emit('IMPORT_FROM', name)
    self.emit('POP_TOP')
</t>
<t tx="T1910">def _resolveDots(self, name):
    elts = string.split(name, ".")
    if len(elts) == 1:
        return
    for elt in elts[1:]:
        self.emit('LOAD_ATTR', elt)
</t>
<t tx="T1911">def visitGetattr(self, node):
    self.visit(node.expr)
    self.emit('LOAD_ATTR', self.mangle(node.attrname))
</t>
<t tx="T1912"># next five implement assignments

def visitAssign(self, node):
    self.set_lineno(node)
    self.visit(node.expr)
    dups = len(node.nodes) - 1
    for i in range(len(node.nodes)):
        elt = node.nodes[i]
        if i &lt; dups:
            self.emit('DUP_TOP')
        if isinstance(elt, ast.Node):
            self.visit(elt)
</t>
<t tx="T1913">def visitAssName(self, node):
    if node.flags == 'OP_ASSIGN':
        self.storeName(node.name)
    elif node.flags == 'OP_DELETE':
        self.set_lineno(node)
        self.delName(node.name)
    else:
        print "oops", node.flags
</t>
<t tx="T1914">def visitAssAttr(self, node):
    self.visit(node.expr)
    if node.flags == 'OP_ASSIGN':
        self.emit('STORE_ATTR', self.mangle(node.attrname))
    elif node.flags == 'OP_DELETE':
        self.emit('DELETE_ATTR', self.mangle(node.attrname))
    else:
        print "warning: unexpected flags:", node.flags
        print node
</t>
<t tx="T1915">def _visitAssSequence(self, node, op='UNPACK_SEQUENCE'):
    if findOp(node) != 'OP_DELETE':
        self.emit(op, len(node.nodes))
    for child in node.nodes:
        self.visit(child)
</t>
<t tx="T1916">if VERSION &gt; 1:
    visitAssTuple = _visitAssSequence
    visitAssList = _visitAssSequence
else:
    def visitAssTuple(self, node):
        self._visitAssSequence(node, 'UNPACK_TUPLE')

    def visitAssList(self, node):
        self._visitAssSequence(node, 'UNPACK_LIST')
</t>
<t tx="T1917"># augmented assignment

def visitAugAssign(self, node):
    self.set_lineno(node)
    aug_node = wrap_aug(node.node)
    self.visit(aug_node, "load")
    self.visit(node.expr)
    self.emit(self._augmented_opcode[node.op])
    self.visit(aug_node, "store")
</t>
<t tx="T1918">_augmented_opcode = {
    '+=' : 'INPLACE_ADD',
    '-=' : 'INPLACE_SUBTRACT',
    '*=' : 'INPLACE_MULTIPLY',
    '/=' : 'INPLACE_DIVIDE',
    '//=': 'INPLACE_FLOOR_DIVIDE',
    '%=' : 'INPLACE_MODULO',
    '**=': 'INPLACE_POWER',
    '&gt;&gt;=': 'INPLACE_RSHIFT',
    '&lt;&lt;=': 'INPLACE_LSHIFT',
    '&amp;=' : 'INPLACE_AND',
    '^=' : 'INPLACE_XOR',
    '|=' : 'INPLACE_OR',
    }

def visitAugName(self, node, mode):
    if mode == "load":
        self.loadName(node.name)
    elif mode == "store":
        self.storeName(node.name)
</t>
<t tx="T1919">def visitAugGetattr(self, node, mode):
    if mode == "load":
        self.visit(node.expr)
        self.emit('DUP_TOP')
        self.emit('LOAD_ATTR', self.mangle(node.attrname))
    elif mode == "store":
        self.emit('ROT_TWO')
        self.emit('STORE_ATTR', self.mangle(node.attrname))
</t>
<t tx="T1920">def visitAugSlice(self, node, mode):
    if mode == "load":
        self.visitSlice(node, 1)
    elif mode == "store":
        slice = 0
        if node.lower:
            slice = slice | 1
        if node.upper:
            slice = slice | 2
        if slice == 0:
            self.emit('ROT_TWO')
        elif slice == 3:
            self.emit('ROT_FOUR')
        else:
            self.emit('ROT_THREE')
        self.emit('STORE_SLICE+%d' % slice)
</t>
<t tx="T1921">def visitAugSubscript(self, node, mode):
    if len(node.subs) &gt; 1:
        raise SyntaxError, "augmented assignment to tuple is not possible"
    if mode == "load":
        self.visitSubscript(node, 1)
    elif mode == "store":
        self.emit('ROT_THREE')
        self.emit('STORE_SUBSCR')
</t>
<t tx="T1922">def visitExec(self, node):
    self.visit(node.expr)
    if node.locals is None:
        self.emit('LOAD_CONST', None)
    else:
        self.visit(node.locals)
    if node.globals is None:
        self.emit('DUP_TOP')
    else:
        self.visit(node.globals)
    self.emit('EXEC_STMT')
</t>
<t tx="T1923">def visitCallFunc(self, node):
    pos = 0
    kw = 0
    self.set_lineno(node)
    self.visit(node.node)
    for arg in node.args:
        self.visit(arg)
        if isinstance(arg, ast.Keyword):
            kw = kw + 1
        else:
            pos = pos + 1
    if node.star_args is not None:
        self.visit(node.star_args)
    if node.dstar_args is not None:
        self.visit(node.dstar_args)
    have_star = node.star_args is not None
    have_dstar = node.dstar_args is not None
    opcode = callfunc_opcode_info[have_star, have_dstar]
    self.emit(opcode, kw &lt;&lt; 8 | pos)
</t>
<t tx="T1924">def visitPrint(self, node, newline=0):
    self.set_lineno(node)
    if node.dest:
        self.visit(node.dest)
    for child in node.nodes:
        if node.dest:
            self.emit('DUP_TOP')
        self.visit(child)
        if node.dest:
            self.emit('ROT_TWO')
            self.emit('PRINT_ITEM_TO')
        else:
            self.emit('PRINT_ITEM')
    if node.dest and not newline:
        self.emit('POP_TOP')
</t>
<t tx="T1925">def visitPrintnl(self, node):
    self.visitPrint(node, newline=1)
    if node.dest:
        self.emit('PRINT_NEWLINE_TO')
    else:
        self.emit('PRINT_NEWLINE')
</t>
<t tx="T1926">def visitReturn(self, node):
    self.set_lineno(node)
    self.visit(node.value)
    self.emit('RETURN_VALUE')
</t>
<t tx="T1927">def visitYield(self, node):
    self.set_lineno(node)
    self.visit(node.value)
    self.emit('YIELD_STMT')
</t>
<t tx="T1928"># slice and subscript stuff

def visitSlice(self, node, aug_flag=None):
    # aug_flag is used by visitAugSlice
    self.visit(node.expr)
    slice = 0
    if node.lower:
        self.visit(node.lower)
        slice = slice | 1
    if node.upper:
        self.visit(node.upper)
        slice = slice | 2
    if aug_flag:
        if slice == 0:
            self.emit('DUP_TOP')
        elif slice == 3:
            self.emit('DUP_TOPX', 3)
        else:
            self.emit('DUP_TOPX', 2)
    if node.flags == 'OP_APPLY':
        self.emit('SLICE+%d' % slice)
    elif node.flags == 'OP_ASSIGN':
        self.emit('STORE_SLICE+%d' % slice)
    elif node.flags == 'OP_DELETE':
        self.emit('DELETE_SLICE+%d' % slice)
    else:
        print "weird slice", node.flags
        raise
</t>
<t tx="T1929">def visitSubscript(self, node, aug_flag=None):
    self.visit(node.expr)
    for sub in node.subs:
        self.visit(sub)
    if aug_flag:
        self.emit('DUP_TOPX', 2)
    if len(node.subs) &gt; 1:
        self.emit('BUILD_TUPLE', len(node.subs))
    if node.flags == 'OP_APPLY':
        self.emit('BINARY_SUBSCR')
    elif node.flags == 'OP_ASSIGN':
        self.emit('STORE_SUBSCR')
    elif node.flags == 'OP_DELETE':
        self.emit('DELETE_SUBSCR')
</t>
<t tx="T1930"># binary ops

def binaryOp(self, node, op):
    self.visit(node.left)
    self.visit(node.right)
    self.emit(op)
</t>
<t tx="T1931">def visitAdd(self, node):
    return self.binaryOp(node, 'BINARY_ADD')
</t>
<t tx="T1932">def visitSub(self, node):
    return self.binaryOp(node, 'BINARY_SUBTRACT')
</t>
<t tx="T1933">def visitMul(self, node):
    return self.binaryOp(node, 'BINARY_MULTIPLY')
</t>
<t tx="T1934">def visitDiv(self, node):
    return self.binaryOp(node, self._div_op)
</t>
<t tx="T1935">def visitFloorDiv(self, node):
    return self.binaryOp(node, 'BINARY_FLOOR_DIVIDE')
</t>
<t tx="T1936">def visitMod(self, node):
    return self.binaryOp(node, 'BINARY_MODULO')
</t>
<t tx="T1937">def visitPower(self, node):
    return self.binaryOp(node, 'BINARY_POWER')
</t>
<t tx="T1938">def visitLeftShift(self, node):
    return self.binaryOp(node, 'BINARY_LSHIFT')
</t>
<t tx="T1939">def visitRightShift(self, node):
    return self.binaryOp(node, 'BINARY_RSHIFT')
</t>
<t tx="T1940"># unary ops

def unaryOp(self, node, op):
    self.visit(node.expr)
    self.emit(op)
</t>
<t tx="T1941">def visitInvert(self, node):
    return self.unaryOp(node, 'UNARY_INVERT')
</t>
<t tx="T1942">def visitUnarySub(self, node):
    return self.unaryOp(node, 'UNARY_NEGATIVE')
</t>
<t tx="T1943">def visitUnaryAdd(self, node):
    return self.unaryOp(node, 'UNARY_POSITIVE')
</t>
<t tx="T1944">def visitUnaryInvert(self, node):
    return self.unaryOp(node, 'UNARY_INVERT')
</t>
<t tx="T1945">def visitNot(self, node):
    return self.unaryOp(node, 'UNARY_NOT')
</t>
<t tx="T1946">def visitBackquote(self, node):
    return self.unaryOp(node, 'UNARY_CONVERT')
</t>
<t tx="T1947"># bit ops

def bitOp(self, nodes, op):
    self.visit(nodes[0])
    for node in nodes[1:]:
        self.visit(node)
        self.emit(op)
</t>
<t tx="T1948">def visitBitand(self, node):
    return self.bitOp(node.nodes, 'BINARY_AND')
</t>
<t tx="T1949">def visitBitor(self, node):
    return self.bitOp(node.nodes, 'BINARY_OR')
</t>
<t tx="T1950">def visitBitxor(self, node):
    return self.bitOp(node.nodes, 'BINARY_XOR')
</t>
<t tx="T1951"># object constructors

def visitEllipsis(self, node):
    self.emit('LOAD_CONST', Ellipsis)
</t>
<t tx="T1952">def visitTuple(self, node):
    self.set_lineno(node)
    for elt in node.nodes:
        self.visit(elt)
    self.emit('BUILD_TUPLE', len(node.nodes))
</t>
<t tx="T1953">def visitList(self, node):
    self.set_lineno(node)
    for elt in node.nodes:
        self.visit(elt)
    self.emit('BUILD_LIST', len(node.nodes))
</t>
<t tx="T1954">def visitSliceobj(self, node):
    for child in node.nodes:
        self.visit(child)
    self.emit('BUILD_SLICE', len(node.nodes))
</t>
<t tx="T1955">def visitDict(self, node):
    lineno = getattr(node, 'lineno', None)
    if lineno:
        self.emit('SET_LINENO', lineno)
    self.emit('BUILD_MAP', 0)
    for k, v in node.items:
        lineno2 = getattr(node, 'lineno', None)
        if lineno2 is not None and lineno != lineno2:
            self.emit('SET_LINENO', lineno2)
            lineno = lineno2
        self.emit('DUP_TOP')
        self.visit(v)
        self.emit('ROT_TWO')
        self.visit(k)
        self.emit('STORE_SUBSCR')
</t>
<t tx="T1956">
class NestedScopeMixin:
	&lt;&lt; class NestedScopeMixin declarations &gt;&gt;
	&lt;&lt; class NestedScopeMixin methods &gt;&gt;

</t>
<t tx="T1957">"""Defines initClass() for nested scoping (Python 2.2-compatible)"""
</t>
<t tx="T1958">@others</t>
<t tx="T1959">def initClass(self):
    self.__class__.NameFinder = LocalNameFinder
    self.__class__.FunctionGen = FunctionCodeGenerator
    self.__class__.ClassGen = ClassCodeGenerator
</t>
<t tx="T1960">
class ModuleCodeGenerator(NestedScopeMixin, CodeGenerator):
	&lt;&lt; class ModuleCodeGenerator declarations &gt;&gt;
	&lt;&lt; class ModuleCodeGenerator methods &gt;&gt;

</t>
<t tx="T1961">__super_init = CodeGenerator.__init__

scopes = None

</t>
<t tx="T1962">@others</t>
<t tx="T1963">def __init__(self, tree):
    self.graph = pyassem.PyFlowGraph("&lt;module&gt;", tree.filename)
    self.futures = future.find_futures(tree)
    self.__super_init()
    walk(tree, self)
</t>
<t tx="T1964">def get_module(self):
    return self
</t>
<t tx="T1965">
class ExpressionCodeGenerator(NestedScopeMixin, CodeGenerator):
	&lt;&lt; class ExpressionCodeGenerator declarations &gt;&gt;
	&lt;&lt; class ExpressionCodeGenerator methods &gt;&gt;

</t>
<t tx="T1966">__super_init = CodeGenerator.__init__

scopes = None
futures = ()

</t>
<t tx="T1967">@others</t>
<t tx="T1968">def __init__(self, tree):
    self.graph = pyassem.PyFlowGraph("&lt;expression&gt;", tree.filename)
    self.__super_init()
    walk(tree, self)
</t>
<t tx="T1969">def get_module(self):
    return self
</t>
<t tx="T1970">
class InteractiveCodeGenerator(NestedScopeMixin, CodeGenerator):
	&lt;&lt; class InteractiveCodeGenerator declarations &gt;&gt;
	&lt;&lt; class InteractiveCodeGenerator methods &gt;&gt;

</t>
<t tx="T1971">__super_init = CodeGenerator.__init__

scopes = None
futures = ()

</t>
<t tx="T1972">@others</t>
<t tx="T1973">def __init__(self, tree):
    self.graph = pyassem.PyFlowGraph("&lt;interactive&gt;", tree.filename)
    self.__super_init()
    self.set_lineno(tree)
    walk(tree, self)
    self.emit('RETURN_VALUE')
</t>
<t tx="T1974">def get_module(self):
    return self
</t>
<t tx="T1975">def visitDiscard(self, node):
    # XXX Discard means it's an expression.  Perhaps this is a bad
    # name.
    self.visit(node.expr)
    self.emit('PRINT_EXPR')
</t>
<t tx="T1976">
class AbstractFunctionCode:
	&lt;&lt; class AbstractFunctionCode declarations &gt;&gt;
	&lt;&lt; class AbstractFunctionCode methods &gt;&gt;

</t>
<t tx="T1977">optimized = 1
lambdaCount = 0

</t>
<t tx="T1978">@others</t>
<t tx="T1979">def __init__(self, func, scopes, isLambda, class_name, mod):
    self.class_name = class_name
    self.module = mod
    if isLambda:
        klass = FunctionCodeGenerator
        name = "&lt;lambda.%d&gt;" % klass.lambdaCount
        klass.lambdaCount = klass.lambdaCount + 1
    else:
        name = func.name
    args, hasTupleArg = generateArgList(func.argnames)
    self.graph = pyassem.PyFlowGraph(name, func.filename, args,
                                     optimized=1)
    self.isLambda = isLambda
    self.super_init()

    if not isLambda and func.doc:
        self.setDocstring(func.doc)

    lnf = walk(func.code, self.NameFinder(args), verbose=0)
    self.locals.push(lnf.getLocals())
    if func.varargs:
        self.graph.setFlag(CO_VARARGS)
    if func.kwargs:
        self.graph.setFlag(CO_VARKEYWORDS)
    self.set_lineno(func)
    if hasTupleArg:
        self.generateArgUnpack(func.argnames)
</t>
<t tx="T1980">def get_module(self):
    return self.module
</t>
<t tx="T1981">def finish(self):
    self.graph.startExitBlock()
    if not self.isLambda:
        self.emit('LOAD_CONST', None)
    self.emit('RETURN_VALUE')
</t>
<t tx="T1982">def generateArgUnpack(self, args):
    for i in range(len(args)):
        arg = args[i]
        if type(arg) == types.TupleType:
            self.emit('LOAD_FAST', '.%d' % (i * 2))
            self.unpackSequence(arg)
</t>
<t tx="T1983">def unpackSequence(self, tup):
    if VERSION &gt; 1:
        self.emit('UNPACK_SEQUENCE', len(tup))
    else:
        self.emit('UNPACK_TUPLE', len(tup))
    for elt in tup:
        if type(elt) == types.TupleType:
            self.unpackSequence(elt)
        else:
            self._nameOp('STORE', elt)
</t>
<t tx="T1984">

class FunctionCodeGenerator(NestedScopeMixin, AbstractFunctionCode,
	&lt;&lt; class FunctionCodeGenerator declarations &gt;&gt;
	&lt;&lt; class FunctionCodeGenerator methods &gt;&gt;

</t>
<t tx="T1985">CodeGenerator):
super_init = CodeGenerator.__init__ # call be other init
scopes = None

__super_init = AbstractFunctionCode.__init__

</t>
<t tx="T1986">@others</t>
<t tx="T1987">def __init__(self, func, scopes, isLambda, class_name, mod):
    self.scopes = scopes
    self.scope = scopes[func]
    self.__super_init(func, scopes, isLambda, class_name, mod)
    self.graph.setFreeVars(self.scope.get_free_vars())
    self.graph.setCellVars(self.scope.get_cell_vars())
    if self.graph.checkFlag(CO_GENERATOR_ALLOWED):
        if self.scope.generator is not None:
            self.graph.setFlag(CO_GENERATOR)
</t>
<t tx="T1988">
class AbstractClassCode:
	&lt;&lt; class AbstractClassCode methods &gt;&gt;

</t>
<t tx="T1989">@others</t>
<t tx="T1990">def __init__(self, klass, scopes, module):
    self.class_name = klass.name
    self.module = module
    self.graph = pyassem.PyFlowGraph(klass.name, klass.filename,
                                       optimized=0, klass=1)
    self.super_init()
    lnf = walk(klass.code, self.NameFinder(), verbose=0)
    self.locals.push(lnf.getLocals())
    self.graph.setFlag(CO_NEWLOCALS)
    if klass.doc:
        self.setDocstring(klass.doc)
</t>
<t tx="T1991">def get_module(self):
    return self.module
</t>
<t tx="T1992">def finish(self):
    self.graph.startExitBlock()
    self.emit('LOAD_LOCALS')
    self.emit('RETURN_VALUE')
</t>
<t tx="T1993">
class ClassCodeGenerator(NestedScopeMixin, AbstractClassCode, CodeGenerator):
	&lt;&lt; class ClassCodeGenerator declarations &gt;&gt;
	&lt;&lt; class ClassCodeGenerator methods &gt;&gt;

</t>
<t tx="T1994">super_init = CodeGenerator.__init__
scopes = None

__super_init = AbstractClassCode.__init__

</t>
<t tx="T1995">@others</t>
<t tx="T1996">def __init__(self, klass, scopes, module):
    self.scopes = scopes
    self.scope = scopes[klass]
    self.__super_init(klass, scopes, module)
    self.graph.setFreeVars(self.scope.get_free_vars())
    self.graph.setCellVars(self.scope.get_cell_vars())
</t>
<t tx="T1997">def generateArgList(arglist):
    """Generate an arg list marking TupleArgs"""
    args = []
    extra = []
    count = 0
    for i in range(len(arglist)):
        elt = arglist[i]
        if type(elt) == types.StringType:
            args.append(elt)
        elif type(elt) == types.TupleType:
            args.append(TupleArg(i * 2, elt))
            extra.extend(misc.flatten(elt))
            count = count + 1
        else:
            raise ValueError, "unexpect argument type:", elt
    return args + extra, count
</t>
<t tx="T1998">def findOp(node):
    """Find the op (DELETE, LOAD, STORE) in an AssTuple tree"""
    v = OpFinder()
    walk(node, v, verbose=0)
    return v.op
</t>
<t tx="T1999">
class OpFinder:
	&lt;&lt; class OpFinder methods &gt;&gt;

</t>
<t tx="T2000">@others</t>
<t tx="T2001">def __init__(self):
    self.op = None
</t>
<t tx="T2002">def visitAssName(self, node):
    if self.op is None:
        self.op = node.flags
    elif self.op != node.flags:
        raise ValueError, "mixed ops in stmt"
</t>
<t tx="T2003">

class Delegator:
	&lt;&lt; class Delegator declarations &gt;&gt;
	&lt;&lt; class Delegator methods &gt;&gt;

</t>
<t tx="T2004">"""Base class to support delegation for augmented assignment nodes

To generator code for augmented assignments, we use the following
wrapper classes.  In visitAugAssign, the left-hand expression node
is visited twice.  The first time the visit uses the normal method
for that node .  The second time the visit uses a different method
that generates the appropriate code to perform the assignment.
These delegator classes wrap the original AST nodes in order to
support the variant visit methods.
"""
</t>
<t tx="T2005">@others</t>
<t tx="T2006">def __init__(self, obj):
    self.obj = obj
</t>
<t tx="T2007">def __getattr__(self, attr):
    return getattr(self.obj, attr)
</t>
<t tx="T2008">
class AugGetattr(Delegator):
	&lt;&lt; class AugGetattr declarations &gt;&gt;
</t>
<t tx="T2009">pass

</t>
<t tx="T2010">class AugName(Delegator):
	&lt;&lt; class AugName declarations &gt;&gt;
</t>
<t tx="T2011">pass

</t>
<t tx="T2012">class AugSlice(Delegator):
	&lt;&lt; class AugSlice declarations &gt;&gt;
</t>
<t tx="T2013">pass

</t>
<t tx="T2014">class AugSubscript(Delegator):
	&lt;&lt; class AugSubscript declarations &gt;&gt;
</t>
<t tx="T2015">pass

wrapper = {
ast.Getattr: AugGetattr,
ast.Name: AugName,
ast.Slice: AugSlice,
ast.Subscript: AugSubscript,
}

</t>
<t tx="T2016">def wrap_aug(node):
    return wrapper[node.__class__](node)
</t>
<t tx="T2017">@language python

&lt;&lt; symbols declarations &gt;&gt;

@others
</t>
<t tx="T2018">"""Module symbol-table generator"""

from compiler import ast
from compiler.consts import SC_LOCAL, SC_GLOBAL, SC_FREE, SC_CELL, SC_UNKNOWN
from compiler.misc import mangle
import types


import sys

MANGLE_LEN = 256

</t>
<t tx="T2019">class Scope:
	&lt;&lt; class Scope declarations &gt;&gt;
	&lt;&lt; class Scope methods &gt;&gt;

</t>
<t tx="T2020"># XXX how much information do I need about each name?
</t>
<t tx="T2021">@others</t>
<t tx="T2022">def __init__(self, name, module, klass=None):
    self.name = name
    self.module = module
    self.defs = {}
    self.uses = {}
    self.globals = {}
    self.params = {}
    self.frees = {}
    self.cells = {}
    self.children = []
    # nested is true if the class could contain free variables,
    # i.e. if it is nested within another function.
    self.nested = None
    self.generator = None
    self.klass = None
    if klass is not None:
        for i in range(len(klass)):
            if klass[i] != '_':
                self.klass = klass[i:]
                break
</t>
<t tx="T2023">def __repr__(self):
    return "&lt;%s: %s&gt;" % (self.__class__.__name__, self.name)
</t>
<t tx="T2024">def mangle(self, name):
    if self.klass is None:
        return name
    return mangle(name, self.klass)
</t>
<t tx="T2025">def add_def(self, name):
    self.defs[self.mangle(name)] = 1
</t>
<t tx="T2026">def add_use(self, name):
    self.uses[self.mangle(name)] = 1
</t>
<t tx="T2027">def add_global(self, name):
    name = self.mangle(name)
    if self.uses.has_key(name) or self.defs.has_key(name):
        pass # XXX warn about global following def/use
    if self.params.has_key(name):
        raise SyntaxError, "%s in %s is global and parameter" % \
              (name, self.name)
    self.globals[name] = 1
    self.module.add_def(name)
</t>
<t tx="T2028">def add_param(self, name):
    name = self.mangle(name)
    self.defs[name] = 1
    self.params[name] = 1
</t>
<t tx="T2029">def get_names(self):
    d = {}
    d.update(self.defs)
    d.update(self.uses)
    d.update(self.globals)
    return d.keys()
</t>
<t tx="T2030">def add_child(self, child):
    self.children.append(child)
</t>
<t tx="T2031">def get_children(self):
    return self.children
</t>
<t tx="T2032">def DEBUG(self):
    print &gt;&gt; sys.stderr, self.name, self.nested and "nested" or ""
    print &gt;&gt; sys.stderr, "\tglobals: ", self.globals
    print &gt;&gt; sys.stderr, "\tcells: ", self.cells
    print &gt;&gt; sys.stderr, "\tdefs: ", self.defs
    print &gt;&gt; sys.stderr, "\tuses: ", self.uses
    print &gt;&gt; sys.stderr, "\tfrees:", self.frees
</t>
<t tx="T2033">def check_name(self, name):
    """Return scope of name.

    The scope of a name could be LOCAL, GLOBAL, FREE, or CELL.
    """
    if self.globals.has_key(name):
        return SC_GLOBAL
    if self.cells.has_key(name):
        return SC_CELL
    if self.defs.has_key(name):
        return SC_LOCAL
    if self.nested and (self.frees.has_key(name) or
                        self.uses.has_key(name)):
        return SC_FREE
    if self.nested:
        return SC_UNKNOWN
    else:
        return SC_GLOBAL
</t>
<t tx="T2034">def get_free_vars(self):
    if not self.nested:
        return ()
    free = {}
    free.update(self.frees)
    for name in self.uses.keys():
        if not (self.defs.has_key(name) or
                self.globals.has_key(name)):
            free[name] = 1
    return free.keys()
</t>
<t tx="T2035">def handle_children(self):
    for child in self.children:
        frees = child.get_free_vars()
        globals = self.add_frees(frees)
        for name in globals:
            child.force_global(name)
</t>
<t tx="T2036">def force_global(self, name):
    """Force name to be global in scope.

    Some child of the current node had a free reference to name.
    When the child was processed, it was labelled a free
    variable.  Now that all its enclosing scope have been
    processed, the name is known to be a global or builtin.  So
    walk back down the child chain and set the name to be global
    rather than free.

    Be careful to stop if a child does not think the name is
    free.
    """
    self.globals[name] = 1
    if self.frees.has_key(name):
        del self.frees[name]
    for child in self.children:
        if child.check_name(name) == SC_FREE:
            child.force_global(name)
</t>
<t tx="T2037">def add_frees(self, names):
    """Process list of free vars from nested scope.

    Returns a list of names that are either 1) declared global in the
    parent or 2) undefined in a top-level parent.  In either case,
    the nested scope should treat them as globals.
    """
    child_globals = []
    for name in names:
        sc = self.check_name(name)
        if self.nested:
            if sc == SC_UNKNOWN or sc == SC_FREE \
               or isinstance(self, ClassScope):
                self.frees[name] = 1
            elif sc == SC_GLOBAL:
                child_globals.append(name)
            elif isinstance(self, FunctionScope) and sc == SC_LOCAL:
                self.cells[name] = 1
            elif sc != SC_CELL:
                child_globals.append(name)
        else:
            if sc == SC_LOCAL:
                self.cells[name] = 1
            elif sc != SC_CELL:
                child_globals.append(name)
    return child_globals
</t>
<t tx="T2038">def get_cell_vars(self):
    return self.cells.keys()
</t>
<t tx="T2039">
class ModuleScope(Scope):
	&lt;&lt; class ModuleScope declarations &gt;&gt;
	&lt;&lt; class ModuleScope methods &gt;&gt;

</t>
<t tx="T2040">__super_init = Scope.__init__

</t>
<t tx="T2041">@others</t>
<t tx="T2042">def __init__(self):
    self.__super_init("global", self)
</t>
<t tx="T2043">
class FunctionScope(Scope):
	&lt;&lt; class FunctionScope declarations &gt;&gt;
</t>
<t tx="T2044">pass

</t>
<t tx="T2045">class LambdaScope(FunctionScope):
	&lt;&lt; class LambdaScope declarations &gt;&gt;
	&lt;&lt; class LambdaScope methods &gt;&gt;

</t>
<t tx="T2046">__super_init = Scope.__init__

__counter = 1

</t>
<t tx="T2047">@others</t>
<t tx="T2048">def __init__(self, module, klass=None):
    i = self.__counter
    self.__counter += 1
    self.__super_init("lambda.%d" % i, module, klass)
</t>
<t tx="T2049">
class ClassScope(Scope):
	&lt;&lt; class ClassScope declarations &gt;&gt;
	&lt;&lt; class ClassScope methods &gt;&gt;

</t>
<t tx="T2050">__super_init = Scope.__init__

</t>
<t tx="T2051">@others</t>
<t tx="T2052">def __init__(self, name, module):
    self.__super_init(name, module, name)
</t>
<t tx="T2053">
class SymbolVisitor:
	&lt;&lt; class SymbolVisitor methods &gt;&gt;

</t>
<t tx="T2054">@others</t>
<t tx="T2055">def __init__(self):
    self.scopes = {}
    self.klass = None
</t>
<t tx="T2056"># node that define new scopes

def visitModule(self, node):
    scope = self.module = self.scopes[node] = ModuleScope()
    self.visit(node.node, scope)
</t>
<t tx="T2057">visitExpression = visitModule

def visitFunction(self, node, parent):
    parent.add_def(node.name)
    for n in node.defaults:
        self.visit(n, parent)
    scope = FunctionScope(node.name, self.module, self.klass)
    if parent.nested or isinstance(parent, FunctionScope):
        scope.nested = 1
    self.scopes[node] = scope
    self._do_args(scope, node.argnames)
    self.visit(node.code, scope)
    self.handle_free_vars(scope, parent)
</t>
<t tx="T2058">def visitLambda(self, node, parent):
    for n in node.defaults:
        self.visit(n, parent)
    scope = LambdaScope(self.module, self.klass)
    if parent.nested or isinstance(parent, FunctionScope):
        scope.nested = 1
    self.scopes[node] = scope
    self._do_args(scope, node.argnames)
    self.visit(node.code, scope)
    self.handle_free_vars(scope, parent)
</t>
<t tx="T2059">def _do_args(self, scope, args):
    for name in args:
        if type(name) == types.TupleType:
            self._do_args(scope, name)
        else:
            scope.add_param(name)
</t>
<t tx="T2060">def handle_free_vars(self, scope, parent):
    parent.add_child(scope)
    scope.handle_children()
</t>
<t tx="T2061">def visitClass(self, node, parent):
    parent.add_def(node.name)
    for n in node.bases:
        self.visit(n, parent)
    scope = ClassScope(node.name, self.module)
    if parent.nested or isinstance(parent, FunctionScope):
        scope.nested = 1
    self.scopes[node] = scope
    prev = self.klass
    self.klass = node.name
    self.visit(node.code, scope)
    self.klass = prev
    self.handle_free_vars(scope, parent)
</t>
<t tx="T2062"># name can be a def or a use

# XXX a few calls and nodes expect a third "assign" arg that is
# true if the name is being used as an assignment.  only
# expressions contained within statements may have the assign arg.

def visitName(self, node, scope, assign=0):
    if assign:
        scope.add_def(node.name)
    else:
        scope.add_use(node.name)
</t>
<t tx="T2063"># operations that bind new names

def visitFor(self, node, scope):
    self.visit(node.assign, scope, 1)
    self.visit(node.list, scope)
    self.visit(node.body, scope)
    if node.else_:
        self.visit(node.else_, scope)
</t>
<t tx="T2064">def visitFrom(self, node, scope):
    for name, asname in node.names:
        if name == "*":
            continue
        scope.add_def(asname or name)
</t>
<t tx="T2065">def visitImport(self, node, scope):
    for name, asname in node.names:
        i = name.find(".")
        if i &gt; -1:
            name = name[:i]
        scope.add_def(asname or name)
</t>
<t tx="T2066">def visitGlobal(self, node, scope):
    for name in node.names:
        scope.add_global(name)
</t>
<t tx="T2067">def visitAssign(self, node, scope):
    """Propagate assignment flag down to child nodes.

    The Assign node doesn't itself contains the variables being
    assigned to.  Instead, the children in node.nodes are visited
    with the assign flag set to true.  When the names occur in
    those nodes, they are marked as defs.

    Some names that occur in an assignment target are not bound by
    the assignment, e.g. a name occurring inside a slice.  The
    visitor handles these nodes specially; they do not propagate
    the assign flag to their children.
    """
    for n in node.nodes:
        self.visit(n, scope, 1)
    self.visit(node.expr, scope)
</t>
<t tx="T2068">def visitAssName(self, node, scope, assign=1):
    scope.add_def(node.name)
</t>
<t tx="T2069">def visitAssAttr(self, node, scope, assign=0):
    self.visit(node.expr, scope, 0)
</t>
<t tx="T2070">def visitSubscript(self, node, scope, assign=0):
    self.visit(node.expr, scope, 0)
    for n in node.subs:
        self.visit(n, scope, 0)
</t>
<t tx="T2071">def visitSlice(self, node, scope, assign=0):
    self.visit(node.expr, scope, 0)
    if node.lower:
        self.visit(node.lower, scope, 0)
    if node.upper:
        self.visit(node.upper, scope, 0)
</t>
<t tx="T2072">def visitAugAssign(self, node, scope):
    # If the LHS is a name, then this counts as assignment.
    # Otherwise, it's just use.
    self.visit(node.node, scope)
    if isinstance(node.node, ast.Name):
        self.visit(node.node, scope, 1) # XXX worry about this
    self.visit(node.expr, scope)
</t>
<t tx="T2073"># prune if statements if tests are false

_const_types = types.StringType, types.IntType, types.FloatType

def visitIf(self, node, scope):
    for test, body in node.tests:
        if isinstance(test, ast.Const):
            if type(test.value) in self._const_types:
                if not test.value:
                    continue
        self.visit(test, scope)
        self.visit(body, scope)
    if node.else_:
        self.visit(node.else_, scope)
</t>
<t tx="T2074"># a yield statement signals a generator

def visitYield(self, node, scope):
    scope.generator = 1
    self.visit(node.value, scope)
</t>
<t tx="T2075">def sort(l):
    l = l[:]
    l.sort()
    return l
</t>
<t tx="T2076">def list_eq(l1, l2):
    return sort(l1) == sort(l2)
</t>
<t tx="T2077">if __name__ == "__main__":
    import sys
    from compiler import parseFile, walk
    import symtable

    def get_names(syms):
        return [s for s in [s.get_name() for s in syms.get_symbols()]
                if not (s.startswith('_[') or s.startswith('.'))]

    for file in sys.argv[1:]:
        print file
        f = open(file)
        buf = f.read()
        f.close()
        syms = symtable.symtable(buf, file, "exec")
        mod_names = get_names(syms)
        tree = parseFile(file)
        s = SymbolVisitor()
        walk(tree, s)

        # compare module-level symbols
        names2 = s.scopes[tree].get_names()

        if not list_eq(mod_names, names2):
            print
            print "oops", file
            print sort(mod_names)
            print sort(names2)
            sys.exit(-1)

        d = {}
        d.update(s.scopes)
        del d[tree]
        scopes = d.values()
        del d

        for s in syms.get_symbols():
            if s.is_namespace():
                l = [sc for sc in scopes
                     if sc.name == s.get_name()]
                if len(l) &gt; 1:
                    print "skipping", s.get_name()
                else:
                    if not list_eq(get_names(s.get_namespace()),
                                   l[0].get_names()):
                        print s.get_name()
                        print sort(get_names(s.get_namespace()))
                        print sort(l[0].get_names())
                        sys.exit(-1)
</t>
<t tx="T2078">@language python

"""Check for errs in the AST.

The Python parser does not catch all syntax errors.  Others, like
assignments with invalid targets, are caught in the code generation
phase.

The compiler package catches some errors in the transformer module.
But it seems clearer to write checkers that use the AST to detect
errors.
"""

from compiler import ast, walk

@others
##            if isinstance(target, ast.AssList):
##                if target.lineno is None:
##                    target.lineno = node.lineno
##                self.error(target, "can't assign to list comprehension")
</t>
<t tx="T2079">def check(tree, multi=None):
    v = SyntaxErrorChecker(multi)
    walk(tree, v)
    return v.errors
</t>
<t tx="T2080">
class SyntaxErrorChecker:
	"""A visitor to find syntax errors in the AST."""
	&lt;&lt; class SyntaxErrorChecker methods &gt;&gt;

</t>
<t tx="T2081">@others</t>
<t tx="T2082">def __init__(self, multi=None):
    """Create new visitor object.

    If optional argument multi is not None, then print messages
    for each error rather than raising a SyntaxError for the
    first.
    """
    self.multi = multi
    self.errors = 0
</t>
<t tx="T2083">def error(self, node, msg):
    self.errors = self.errors + 1
    if self.multi is not None:
        print "%s:%s: %s" % (node.filename, node.lineno, msg)
    else:
        raise SyntaxError, "%s (%s:%s)" % (msg, node.filename, node.lineno)
</t>
<t tx="T2084">def visitAssign(self, node):
    # the transformer module handles many of these
    for target in node.nodes:
        pass
</t>
<t tx="T2085">@language python

"""Parse tree transformation module.

Transforms Python source code into an abstract syntax tree (AST)
defined in the ast module.

The simplest ways to invoke this module are via parse and parseFile.
parse(buf) -&gt; AST
parseFile(path) -&gt; AST
"""

&lt;&lt; transformer declarations &gt;&gt;

@others</t>
<t tx="T2086"># Original version written by Greg Stein (gstein@lyra.org)
#                         and Bill Tutt (rassilon@lima.mudlib.org)
# February 1997.
#
# Modifications and improvements for Python 2.0 by Jeremy Hylton and
# Mark Hammond

# Portions of this file are:
# Copyright (C) 1997-1998 Greg Stein. All Rights Reserved.
#
# This module is provided under a BSD-ish license. See
#   http://www.opensource.org/licenses/bsd-license.html
# and replace OWNER, ORGANIZATION, and YEAR as appropriate.

from ast import *
import parser
# Care must be taken to use only symbols and tokens defined in Python
# 1.5.2 for code branches executed in 1.5.2
import symbol
import token
import string
import sys

error = 'walker.error'

from consts import CO_VARARGS, CO_VARKEYWORDS
from consts import OP_ASSIGN, OP_DELETE, OP_APPLY</t>
<t tx="T2087">def parseFile(path):
    f = open(path)
    src = f.read()
    f.close()
    return parse(src)
</t>
<t tx="T2088">def parse(buf, mode="exec"):
    if mode == "exec" or mode == "single":
        return Transformer().parsesuite(buf)
    elif mode == "eval":
        return Transformer().parseexpr(buf)
    else:
        raise ValueError("compile() arg 3 must be"
                         " 'exec' or 'eval' or 'single'")
</t>
<t tx="T2089">def asList(nodes):
    l = []
    for item in nodes:
        if hasattr(item, "asList"):
            l.append(item.asList())
        else:
            if type(item) is type( (None, None) ):
                l.append(tuple(asList(item)))
            elif type(item) is type( [] ):
                l.append(asList(item))
            else:
                l.append(item)
    return l
</t>
<t tx="T2090">def Node(*args):
    kind = args[0]
    if nodes.has_key(kind):
        try:
            return apply(nodes[kind], args[1:])
        except TypeError:
            print nodes[kind], len(args), args
            raise
    else:
        raise error, "Can't find appropriate Node type: %s" % str(args)
        #return apply(ast.Node, args)

</t>
<t tx="T2091">class Transformer:
	"""Utility object for transforming Python parse trees.

	Exposes the following methods:
		tree = transform(ast_tree)
		tree = parsesuite(text)
		tree = parseexpr(text)
		tree = parsefile(fileob | filename)
	"""

	&lt;&lt; class Transformer methods &gt;&gt;</t>
<t tx="T2092">@others</t>
<t tx="T2093">def __init__(self):
    self._dispatch = {}
    for value, name in symbol.sym_name.items():
        if hasattr(self, name):
            self._dispatch[value] = getattr(self, name)
    self._dispatch[token.NEWLINE] = self.com_NEWLINE
    self._atom_dispatch = {token.LPAR: self.atom_lpar,
                           token.LSQB: self.atom_lsqb,
                           token.LBRACE: self.atom_lbrace,
                           token.BACKQUOTE: self.atom_backquote,
                           token.NUMBER: self.atom_number,
                           token.STRING: self.atom_string,
                           token.NAME: self.atom_name,
                           }
</t>
<t tx="T2094">def transform(self, tree):
    """Transform an AST into a modified parse tree."""
    if type(tree) != type(()) and type(tree) != type([]):
        tree = parser.ast2tuple(tree, line_info=1)
    return self.compile_node(tree)
</t>
<t tx="T2095">def parsesuite(self, text):
    """Return a modified parse tree for the given suite text."""
    # Hack for handling non-native line endings on non-DOS like OSs.
    text = string.replace(text, '\x0d', '')
    return self.transform(parser.suite(text))
</t>
<t tx="T2096">def parseexpr(self, text):
    """Return a modified parse tree for the given expression text."""
    return self.transform(parser.expr(text))
</t>
<t tx="T2097">def parsefile(self, file):
    """Return a modified parse tree for the contents of the given file."""
    if type(file) == type(''):
        file = open(file)
    return self.parsesuite(file.read())
</t>
<t tx="T2098"># --------------------------------------------------------------
#
# PRIVATE METHODS
#

def compile_node(self, node):
    ### emit a line-number node?
    n = node[0]
    if n == symbol.single_input:
        return self.single_input(node[1:])
    if n == symbol.file_input:
        return self.file_input(node[1:])
    if n == symbol.eval_input:
        return self.eval_input(node[1:])
    if n == symbol.lambdef:
        return self.lambdef(node[1:])
    if n == symbol.funcdef:
        return self.funcdef(node[1:])
    if n == symbol.classdef:
        return self.classdef(node[1:])

    raise error, ('unexpected node type', n)
</t>
<t tx="T2099">def single_input(self, node):
    ### do we want to do anything about being "interactive" ?

    # NEWLINE | simple_stmt | compound_stmt NEWLINE
    n = node[0][0]
    if n != token.NEWLINE:
        return self.com_stmt(node[0])

    return Pass()
</t>
<t tx="T2100">def file_input(self, nodelist):
    doc = self.get_docstring(nodelist, symbol.file_input)
    if doc is not None:
        i = 1
    else:
        i = 0
    stmts = []
    for node in nodelist[i:]:
        if node[0] != token.ENDMARKER and node[0] != token.NEWLINE:
            self.com_append_stmt(stmts, node)
    return Module(doc, Stmt(stmts))
</t>
<t tx="T2101">def eval_input(self, nodelist):
    # from the built-in function input()
    ### is this sufficient?
    return Expression(self.com_node(nodelist[0]))
</t>
<t tx="T2102">def funcdef(self, nodelist):
    # funcdef: 'def' NAME parameters ':' suite
    # parameters: '(' [varargslist] ')'

    lineno = nodelist[1][2]
    name = nodelist[1][1]
    args = nodelist[2][2]

    if args[0] == symbol.varargslist:
        names, defaults, flags = self.com_arglist(args[1:])
    else:
        names = defaults = ()
        flags = 0
    doc = self.get_docstring(nodelist[4])

    # code for function
    code = self.com_node(nodelist[4])

    if doc is not None:
        assert isinstance(code, Stmt)
        assert isinstance(code.nodes[0], Discard)
        del code.nodes[0]
    n = Function(name, names, defaults, flags, doc, code)
    n.lineno = lineno
    return n
</t>
<t tx="T2103">def lambdef(self, nodelist):
    # lambdef: 'lambda' [varargslist] ':' test
    if nodelist[2][0] == symbol.varargslist:
        names, defaults, flags = self.com_arglist(nodelist[2][1:])
    else:
        names = defaults = ()
        flags = 0

    # code for lambda
    code = self.com_node(nodelist[-1])

    n = Lambda(names, defaults, flags, code)
    n.lineno = nodelist[1][2]
    return n
</t>
<t tx="T2104">def classdef(self, nodelist):
    # classdef: 'class' NAME ['(' testlist ')'] ':' suite

    name = nodelist[1][1]
    doc = self.get_docstring(nodelist[-1])
    if nodelist[2][0] == token.COLON:
        bases = []
    else:
        bases = self.com_bases(nodelist[3])

    # code for class
    code = self.com_node(nodelist[-1])

    if doc is not None:
        assert isinstance(code, Stmt)
        assert isinstance(code.nodes[0], Discard)
        del code.nodes[0]

    n = Class(name, bases, doc, code)
    n.lineno = nodelist[1][2]
    return n
</t>
<t tx="T2105">def stmt(self, nodelist):
    return self.com_stmt(nodelist[0])
</t>
<t tx="T2106">small_stmt = stmt
flow_stmt = stmt
compound_stmt = stmt

def simple_stmt(self, nodelist):
    # small_stmt (';' small_stmt)* [';'] NEWLINE
    stmts = []
    for i in range(0, len(nodelist), 2):
        self.com_append_stmt(stmts, nodelist[i])
    return Stmt(stmts)
</t>
<t tx="T2107">def parameters(self, nodelist):
    raise error
</t>
<t tx="T2108">def varargslist(self, nodelist):
    raise error
</t>
<t tx="T2109">def fpdef(self, nodelist):
    raise error
</t>
<t tx="T2110">def fplist(self, nodelist):
    raise error
</t>
<t tx="T2111">def dotted_name(self, nodelist):
    raise error
</t>
<t tx="T2112">def comp_op(self, nodelist):
    raise error
</t>
<t tx="T2113">def trailer(self, nodelist):
    raise error
</t>
<t tx="T2114">def sliceop(self, nodelist):
    raise error
</t>
<t tx="T2115">def argument(self, nodelist):
    raise error
</t>
<t tx="T2116"># --------------------------------------------------------------
#
# STATEMENT NODES  (invoked by com_node())
#

def expr_stmt(self, nodelist):
    # augassign testlist | testlist ('=' testlist)*
    en = nodelist[-1]
    exprNode = self.lookup_node(en)(en[1:])
    if len(nodelist) == 1:
        n = Discard(exprNode)
        n.lineno = exprNode.lineno
        return n
    if nodelist[1][0] == token.EQUAL:
        nodes = []
        for i in range(0, len(nodelist) - 2, 2):
            nodes.append(self.com_assign(nodelist[i], OP_ASSIGN))
        n = Assign(nodes, exprNode)
        n.lineno = nodelist[1][2]
    else:
        lval = self.com_augassign(nodelist[0])
        op = self.com_augassign_op(nodelist[1])
        n = AugAssign(lval, op[1], exprNode)
        n.lineno = op[2]
    return n
</t>
<t tx="T2117">def print_stmt(self, nodelist):
    # print ([ test (',' test)* [','] ] | '&gt;&gt;' test [ (',' test)+ [','] ])
    items = []
    if len(nodelist) == 1:
        start = 1
        dest = None
    elif nodelist[1][0] == token.RIGHTSHIFT:
        assert len(nodelist) == 3 \
               or nodelist[3][0] == token.COMMA
        dest = self.com_node(nodelist[2])
        start = 4
    else:
        dest = None
        start = 1
    for i in range(start, len(nodelist), 2):
        items.append(self.com_node(nodelist[i]))
    if nodelist[-1][0] == token.COMMA:
        n = Print(items, dest)
        n.lineno = nodelist[0][2]
        return n
    n = Printnl(items, dest)
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2118">def del_stmt(self, nodelist):
    return self.com_assign(nodelist[1], OP_DELETE)
</t>
<t tx="T2119">def pass_stmt(self, nodelist):
    n = Pass()
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2120">def break_stmt(self, nodelist):
    n = Break()
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2121">def continue_stmt(self, nodelist):
    n = Continue()
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2122">def return_stmt(self, nodelist):
    # return: [testlist]
    if len(nodelist) &lt; 2:
        n = Return(Const(None))
        n.lineno = nodelist[0][2]
        return n
    n = Return(self.com_node(nodelist[1]))
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2123">def yield_stmt(self, nodelist):
    n = Yield(self.com_node(nodelist[1]))
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2124">def raise_stmt(self, nodelist):
    # raise: [test [',' test [',' test]]]
    if len(nodelist) &gt; 5:
        expr3 = self.com_node(nodelist[5])
    else:
        expr3 = None
    if len(nodelist) &gt; 3:
        expr2 = self.com_node(nodelist[3])
    else:
        expr2 = None
    if len(nodelist) &gt; 1:
        expr1 = self.com_node(nodelist[1])
    else:
        expr1 = None
    n = Raise(expr1, expr2, expr3)
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2125">def import_stmt(self, nodelist):
    # import_stmt: 'import' dotted_as_name (',' dotted_as_name)* |
    # from: 'from' dotted_name 'import'
    #                        ('*' | import_as_name (',' import_as_name)*)
    if nodelist[0][1] == 'from':
        names = []
        if nodelist[3][0] == token.NAME:
            for i in range(3, len(nodelist), 2):
                names.append((nodelist[i][1], None))
        else:
            for i in range(3, len(nodelist), 2):
                names.append(self.com_import_as_name(nodelist[i]))
        n = From(self.com_dotted_name(nodelist[1]), names)
        n.lineno = nodelist[0][2]
        return n

    if nodelist[1][0] == symbol.dotted_name:
        names = [(self.com_dotted_name(nodelist[1][1:]), None)]
    else:
        names = []
        for i in range(1, len(nodelist), 2):
            names.append(self.com_dotted_as_name(nodelist[i]))
    n = Import(names)
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2126">def global_stmt(self, nodelist):
    # global: NAME (',' NAME)*
    names = []
    for i in range(1, len(nodelist), 2):
        names.append(nodelist[i][1])
    n = Global(names)
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2127">def exec_stmt(self, nodelist):
    # exec_stmt: 'exec' expr ['in' expr [',' expr]]
    expr1 = self.com_node(nodelist[1])
    if len(nodelist) &gt;= 4:
        expr2 = self.com_node(nodelist[3])
        if len(nodelist) &gt;= 6:
            expr3 = self.com_node(nodelist[5])
        else:
            expr3 = None
    else:
        expr2 = expr3 = None

    n = Exec(expr1, expr2, expr3)
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2128">def assert_stmt(self, nodelist):
    # 'assert': test, [',' test]
    expr1 = self.com_node(nodelist[1])
    if (len(nodelist) == 4):
        expr2 = self.com_node(nodelist[3])
    else:
        expr2 = None
    n = Assert(expr1, expr2)
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2129">def if_stmt(self, nodelist):
    # if: test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
    tests = []
    for i in range(0, len(nodelist) - 3, 4):
        testNode = self.com_node(nodelist[i + 1])
        suiteNode = self.com_node(nodelist[i + 3])
        tests.append((testNode, suiteNode))

    if len(nodelist) % 4 == 3:
        elseNode = self.com_node(nodelist[-1])
##      elseNode.lineno = nodelist[-1][1][2]
    else:
        elseNode = None
    n = If(tests, elseNode)
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2130">def while_stmt(self, nodelist):
    # 'while' test ':' suite ['else' ':' suite]

    testNode = self.com_node(nodelist[1])
    bodyNode = self.com_node(nodelist[3])

    if len(nodelist) &gt; 4:
        elseNode = self.com_node(nodelist[6])
    else:
        elseNode = None

    n = While(testNode, bodyNode, elseNode)
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2131">def for_stmt(self, nodelist):
    # 'for' exprlist 'in' exprlist ':' suite ['else' ':' suite]

    assignNode = self.com_assign(nodelist[1], OP_ASSIGN)
    listNode = self.com_node(nodelist[3])
    bodyNode = self.com_node(nodelist[5])

    if len(nodelist) &gt; 8:
        elseNode = self.com_node(nodelist[8])
    else:
        elseNode = None

    n = For(assignNode, listNode, bodyNode, elseNode)
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2132">def try_stmt(self, nodelist):
    # 'try' ':' suite (except_clause ':' suite)+ ['else' ':' suite]
    # | 'try' ':' suite 'finally' ':' suite
    if nodelist[3][0] != symbol.except_clause:
        return self.com_try_finally(nodelist)

    return self.com_try_except(nodelist)
</t>
<t tx="T2133">def suite(self, nodelist):
    # simple_stmt | NEWLINE INDENT NEWLINE* (stmt NEWLINE*)+ DEDENT
    if len(nodelist) == 1:
        return self.com_stmt(nodelist[0])

    stmts = []
    for node in nodelist:
        if node[0] == symbol.stmt:
            self.com_append_stmt(stmts, node)
    return Stmt(stmts)
</t>
<t tx="T2134"># --------------------------------------------------------------
#
# EXPRESSION NODES  (invoked by com_node())
#

def testlist(self, nodelist):
    # testlist: expr (',' expr)* [',']
    # testlist_safe: test [(',' test)+ [',']]
    # exprlist: expr (',' expr)* [',']
    return self.com_binary(Tuple, nodelist)
</t>
<t tx="T2135">testlist_safe = testlist # XXX
exprlist = testlist

def test(self, nodelist):
    # and_test ('or' and_test)* | lambdef
    if len(nodelist) == 1 and nodelist[0][0] == symbol.lambdef:
        return self.lambdef(nodelist[0])
    return self.com_binary(Or, nodelist)
</t>
<t tx="T2136">def and_test(self, nodelist):
    # not_test ('and' not_test)*
    return self.com_binary(And, nodelist)
</t>
<t tx="T2137">def not_test(self, nodelist):
    # 'not' not_test | comparison
    result = self.com_node(nodelist[-1])
    if len(nodelist) == 2:
        n = Not(result)
        n.lineno = nodelist[0][2]
        return n
    return result
</t>
<t tx="T2138">def comparison(self, nodelist):
    # comparison: expr (comp_op expr)*
    node = self.com_node(nodelist[0])
    if len(nodelist) == 1:
        return node

    results = []
    for i in range(2, len(nodelist), 2):
        nl = nodelist[i-1]

        # comp_op: '&lt;' | '&gt;' | '=' | '&gt;=' | '&lt;=' | '&lt;&gt;' | '!=' | '=='
        #          | 'in' | 'not' 'in' | 'is' | 'is' 'not'
        n = nl[1]
        if n[0] == token.NAME:
            type = n[1]
            if len(nl) == 3:
                if type == 'not':
                    type = 'not in'
                else:
                    type = 'is not'
        else:
            type = _cmp_types[n[0]]

        lineno = nl[1][2]
        results.append((type, self.com_node(nodelist[i])))

    # we need a special "compare" node so that we can distinguish
    #   3 &lt; x &lt; 5   from    (3 &lt; x) &lt; 5
    # the two have very different semantics and results (note that the
    # latter form is always true)

    n = Compare(node, results)
    n.lineno = lineno
    return n
</t>
<t tx="T2139">def expr(self, nodelist):
    # xor_expr ('|' xor_expr)*
    return self.com_binary(Bitor, nodelist)
</t>
<t tx="T2140">def xor_expr(self, nodelist):
    # xor_expr ('^' xor_expr)*
    return self.com_binary(Bitxor, nodelist)
</t>
<t tx="T2141">def and_expr(self, nodelist):
    # xor_expr ('&amp;' xor_expr)*
    return self.com_binary(Bitand, nodelist)
</t>
<t tx="T2142">def shift_expr(self, nodelist):
    # shift_expr ('&lt;&lt;'|'&gt;&gt;' shift_expr)*
    node = self.com_node(nodelist[0])
    for i in range(2, len(nodelist), 2):
        right = self.com_node(nodelist[i])
        if nodelist[i-1][0] == token.LEFTSHIFT:
            node = LeftShift([node, right])
            node.lineno = nodelist[1][2]
        elif nodelist[i-1][0] == token.RIGHTSHIFT:
            node = RightShift([node, right])
            node.lineno = nodelist[1][2]
        else:
            raise ValueError, "unexpected token: %s" % nodelist[i-1][0]
    return node
</t>
<t tx="T2143">def arith_expr(self, nodelist):
    node = self.com_node(nodelist[0])
    for i in range(2, len(nodelist), 2):
        right = self.com_node(nodelist[i])
        if nodelist[i-1][0] == token.PLUS:
            node = Add([node, right])
            node.lineno = nodelist[1][2]
        elif nodelist[i-1][0] == token.MINUS:
            node = Sub([node, right])
            node.lineno = nodelist[1][2]
        else:
            raise ValueError, "unexpected token: %s" % nodelist[i-1][0]
    return node
</t>
<t tx="T2144">def term(self, nodelist):
    node = self.com_node(nodelist[0])
    for i in range(2, len(nodelist), 2):
        right = self.com_node(nodelist[i])
        t = nodelist[i-1][0]
        if t == token.STAR:
            node = Mul([node, right])
        elif t == token.SLASH:
            node = Div([node, right])
        elif t == token.PERCENT:
            node = Mod([node, right])
        elif t == token.DOUBLESLASH:
            node = FloorDiv([node, right])
        else:
            raise ValueError, "unexpected token: %s" % t
        node.lineno = nodelist[1][2]
    return node
</t>
<t tx="T2145">def factor(self, nodelist):
    elt = nodelist[0]
    t = elt[0]
    node = self.com_node(nodelist[-1])
    if t == token.PLUS:
        node = UnaryAdd(node)
        node.lineno = elt[2]
    elif t == token.MINUS:
        node = UnarySub(node)
        node.lineno = elt[2]
    elif t == token.TILDE:
        node = Invert(node)
        node.lineno = elt[2]
    return node
</t>
<t tx="T2146">def power(self, nodelist):
    # power: atom trailer* ('**' factor)*
    node = self.com_node(nodelist[0])
    for i in range(1, len(nodelist)):
        elt = nodelist[i]
        if elt[0] == token.DOUBLESTAR:
            n = Power([node, self.com_node(nodelist[i+1])])
            n.lineno = elt[2]
            return n

        node = self.com_apply_trailer(node, elt)

    return node
</t>
<t tx="T2147">def atom(self, nodelist):
    n = self._atom_dispatch[nodelist[0][0]](nodelist)
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2148">def atom_lpar(self, nodelist):
    if nodelist[1][0] == token.RPAR:
        n = Tuple(())
        n.lineno = nodelist[0][2]
        return n
    return self.com_node(nodelist[1])
</t>
<t tx="T2149">def atom_lsqb(self, nodelist):
    if nodelist[1][0] == token.RSQB:
        n = List(())
        n.lineno = nodelist[0][2]
        return n
    return self.com_list_constructor(nodelist[1])
</t>
<t tx="T2150">def atom_lbrace(self, nodelist):
    if nodelist[1][0] == token.RBRACE:
        return Dict(())
    return self.com_dictmaker(nodelist[1])
</t>
<t tx="T2151">def atom_backquote(self, nodelist):
    n = Backquote(self.com_node(nodelist[1]))
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2152">def atom_number(self, nodelist):
    ### need to verify this matches compile.c
    k = eval(nodelist[0][1])
    n = Const(k)
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2153">def atom_string(self, nodelist):
    ### need to verify this matches compile.c
    k = ''
    for node in nodelist:
        k = k + eval(node[1])
    n = Const(k)
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2154">def atom_name(self, nodelist):
    ### any processing to do?
    n = Name(nodelist[0][1])
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2155"># --------------------------------------------------------------
#
# INTERNAL PARSING UTILITIES
#

# The use of com_node() introduces a lot of extra stack frames,
# enough to cause a stack overflow compiling test.test_parser with
# the standard interpreter recursionlimit.  The com_node() is a
# convenience function that hides the dispatch details, but comes
# at a very high cost.  It is more efficient to dispatch directly
# in the callers.  In these cases, use lookup_node() and call the
# dispatched node directly.

def lookup_node(self, node):
    return self._dispatch[node[0]]
</t>
<t tx="T2156">def com_node(self, node):
    # Note: compile.c has handling in com_node for del_stmt, pass_stmt,
    #       break_stmt, stmt, small_stmt, flow_stmt, simple_stmt,
    #       and compound_stmt.
    #       We'll just dispatch them.
    return self._dispatch[node[0]](node[1:])
</t>
<t tx="T2157">def com_NEWLINE(self, *args):
    # A ';' at the end of a line can make a NEWLINE token appear
    # here, Render it harmless. (genc discards ('discard',
    # ('const', xxxx)) Nodes)
    return Discard(Const(None))
</t>
<t tx="T2158">def com_arglist(self, nodelist):
    # varargslist:
    #   (fpdef ['=' test] ',')* ('*' NAME [',' ('**'|'*' '*') NAME]
    #  | fpdef ['=' test] (',' fpdef ['=' test])* [',']
    #  | ('**'|'*' '*') NAME)
    # fpdef: NAME | '(' fplist ')'
    # fplist: fpdef (',' fpdef)* [',']
    names = []
    defaults = []
    flags = 0

    i = 0
    while i &lt; len(nodelist):
        node = nodelist[i]
        if node[0] == token.STAR or node[0] == token.DOUBLESTAR:
            if node[0] == token.STAR:
                node = nodelist[i+1]
                if node[0] == token.NAME:
                    names.append(node[1])
                    flags = flags | CO_VARARGS
                    i = i + 3

            if i &lt; len(nodelist):
                # should be DOUBLESTAR or STAR STAR
                t = nodelist[i][0]
                if t == token.DOUBLESTAR:
                    node = nodelist[i+1]
                elif t == token.STARSTAR:
                    node = nodelist[i+2]
                else:
                    raise ValueError, "unexpected token: %s" % t
                names.append(node[1])
                flags = flags | CO_VARKEYWORDS

            break

        # fpdef: NAME | '(' fplist ')'
        names.append(self.com_fpdef(node))

        i = i + 1
        if i &gt;= len(nodelist):
            break

        if nodelist[i][0] == token.EQUAL:
            defaults.append(self.com_node(nodelist[i + 1]))
            i = i + 2
        elif len(defaults):
            # Treat "(a=1, b)" as "(a=1, b=None)"
            defaults.append(Const(None))

        i = i + 1

    return names, defaults, flags
</t>
<t tx="T2159">def com_fpdef(self, node):
    # fpdef: NAME | '(' fplist ')'
    if node[1][0] == token.LPAR:
        return self.com_fplist(node[2])
    return node[1][1]
</t>
<t tx="T2160">def com_fplist(self, node):
    # fplist: fpdef (',' fpdef)* [',']
    if len(node) == 2:
        return self.com_fpdef(node[1])
    list = []
    for i in range(1, len(node), 2):
        list.append(self.com_fpdef(node[i]))
    return tuple(list)
</t>
<t tx="T2161">def com_dotted_name(self, node):
    # String together the dotted names and return the string
    name = ""
    for n in node:
        if type(n) == type(()) and n[0] == 1:
            name = name + n[1] + '.'
    return name[:-1]
</t>
<t tx="T2162">def com_dotted_as_name(self, node):
    dot = self.com_dotted_name(node[1])
    if len(node) &lt;= 2:
        return dot, None
    if node[0] == symbol.dotted_name:
        pass
    else:
        assert node[2][1] == 'as'
        assert node[3][0] == token.NAME
        return dot, node[3][1]
</t>
<t tx="T2163">def com_import_as_name(self, node):
    if node[0] == token.STAR:
        return '*', None
    assert node[0] == symbol.import_as_name
    node = node[1:]
    if len(node) == 1:
        assert node[0][0] == token.NAME
        return node[0][1], None

    assert node[1][1] == 'as', node
    assert node[2][0] == token.NAME
    return node[0][1], node[2][1]
</t>
<t tx="T2164">def com_bases(self, node):
    bases = []
    for i in range(1, len(node), 2):
        bases.append(self.com_node(node[i]))
    return bases
</t>
<t tx="T2165">def com_try_finally(self, nodelist):
    # try_fin_stmt: "try" ":" suite "finally" ":" suite
    n = TryFinally(self.com_node(nodelist[2]),
                   self.com_node(nodelist[5]))
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2166">def com_try_except(self, nodelist):
    # try_except: 'try' ':' suite (except_clause ':' suite)* ['else' suite]
    #tryexcept:  [TryNode, [except_clauses], elseNode)]
    stmt = self.com_node(nodelist[2])
    clauses = []
    elseNode = None
    for i in range(3, len(nodelist), 3):
        node = nodelist[i]
        if node[0] == symbol.except_clause:
            # except_clause: 'except' [expr [',' expr]] */
            if len(node) &gt; 2:
                expr1 = self.com_node(node[2])
                if len(node) &gt; 4:
                    expr2 = self.com_assign(node[4], OP_ASSIGN)
                else:
                    expr2 = None
            else:
                expr1 = expr2 = None
            clauses.append((expr1, expr2, self.com_node(nodelist[i+2])))

        if node[0] == token.NAME:
            elseNode = self.com_node(nodelist[i+2])
    n = TryExcept(self.com_node(nodelist[2]), clauses, elseNode)
    n.lineno = nodelist[0][2]
    return n
</t>
<t tx="T2167">def com_augassign_op(self, node):
    assert node[0] == symbol.augassign
    return node[1]
</t>
<t tx="T2168">def com_augassign(self, node):
    """Return node suitable for lvalue of augmented assignment

    Names, slices, and attributes are the only allowable nodes.
    """
    l = self.com_node(node)
    if l.__class__ in (Name, Slice, Subscript, Getattr):
        return l
    raise SyntaxError, "can't assign to %s" % l.__class__.__name__
</t>
<t tx="T2169">def com_assign(self, node, assigning):
    # return a node suitable for use as an "lvalue"
    # loop to avoid trivial recursion
    while 1:
        t = node[0]
        if t == symbol.exprlist or t == symbol.testlist:
            if len(node) &gt; 2:
                return self.com_assign_tuple(node, assigning)
            node = node[1]
        elif t in _assign_types:
            if len(node) &gt; 2:
                raise SyntaxError, "can't assign to operator"
            node = node[1]
        elif t == symbol.power:
            if node[1][0] != symbol.atom:
                raise SyntaxError, "can't assign to operator"
            if len(node) &gt; 2:
                primary = self.com_node(node[1])
                for i in range(2, len(node)-1):
                    ch = node[i]
                    if ch[0] == token.DOUBLESTAR:
                        raise SyntaxError, "can't assign to operator"
                    primary = self.com_apply_trailer(primary, ch)
                return self.com_assign_trailer(primary, node[-1],
                                               assigning)
            node = node[1]
        elif t == symbol.atom:
            t = node[1][0]
            if t == token.LPAR:
                node = node[2]
                if node[0] == token.RPAR:
                    raise SyntaxError, "can't assign to ()"
            elif t == token.LSQB:
                node = node[2]
                if node[0] == token.RSQB:
                    raise SyntaxError, "can't assign to []"
                return self.com_assign_list(node, assigning)
            elif t == token.NAME:
                return self.com_assign_name(node[1], assigning)
            else:
                raise SyntaxError, "can't assign to literal"
        else:
            raise SyntaxError, "bad assignment"
</t>
<t tx="T2170">def com_assign_tuple(self, node, assigning):
    assigns = []
    for i in range(1, len(node), 2):
        assigns.append(self.com_assign(node[i], assigning))
    return AssTuple(assigns)
</t>
<t tx="T2171">def com_assign_list(self, node, assigning):
    assigns = []
    for i in range(1, len(node), 2):
        if i + 1 &lt; len(node):
            if node[i + 1][0] == symbol.list_for:
                raise SyntaxError, "can't assign to list comprehension"
            assert node[i + 1][0] == token.COMMA, node[i + 1]
        assigns.append(self.com_assign(node[i], assigning))
    return AssList(assigns)
</t>
<t tx="T2172">def com_assign_name(self, node, assigning):
    n = AssName(node[1], assigning)
    n.lineno = node[2]
    return n
</t>
<t tx="T2173">def com_assign_trailer(self, primary, node, assigning):
    t = node[1][0]
    if t == token.DOT:
        return self.com_assign_attr(primary, node[2], assigning)
    if t == token.LSQB:
        return self.com_subscriptlist(primary, node[2], assigning)
    if t == token.LPAR:
        raise SyntaxError, "can't assign to function call"
    raise SyntaxError, "unknown trailer type: %s" % t
</t>
<t tx="T2174">def com_assign_attr(self, primary, node, assigning):
    return AssAttr(primary, node[1], assigning)
</t>
<t tx="T2175">def com_binary(self, constructor, nodelist):
    "Compile 'NODE (OP NODE)*' into (type, [ node1, ..., nodeN ])."
    l = len(nodelist)
    if l == 1:
        n = nodelist[0]
        return self.lookup_node(n)(n[1:])
    items = []
    for i in range(0, l, 2):
        n = nodelist[i]
        items.append(self.lookup_node(n)(n[1:]))
    return constructor(items)
</t>
<t tx="T2176">def com_stmt(self, node):
    result = self.lookup_node(node)(node[1:])
    assert result is not None
    if isinstance(result, Stmt):
        return result
    return Stmt([result])
</t>
<t tx="T2177">def com_append_stmt(self, stmts, node):
    result = self.com_node(node)
    assert result is not None
    if isinstance(result, Stmt):
        stmts.extend(result.nodes)
    else:
        stmts.append(result)
</t>
<t tx="T2178">if hasattr(symbol, 'list_for'):
    def com_list_constructor(self, nodelist):
        # listmaker: test ( list_for | (',' test)* [','] )
        values = []
        for i in range(1, len(nodelist)):
            if nodelist[i][0] == symbol.list_for:
                assert len(nodelist[i:]) == 1
                return self.com_list_comprehension(values[0],
                                                   nodelist[i])
            elif nodelist[i][0] == token.COMMA:
                continue
            values.append(self.com_node(nodelist[i]))
        return List(values)

    def com_list_comprehension(self, expr, node):
        # list_iter: list_for | list_if
        # list_for: 'for' exprlist 'in' testlist [list_iter]
        # list_if: 'if' test [list_iter]

        # XXX should raise SyntaxError for assignment

        lineno = node[1][2]
        fors = []
        while node:
            t = node[1][1]
            if t == 'for':
                assignNode = self.com_assign(node[2], OP_ASSIGN)
                listNode = self.com_node(node[4])
                newfor = ListCompFor(assignNode, listNode, [])
                newfor.lineno = node[1][2]
                fors.append(newfor)
                if len(node) == 5:
                    node = None
                else:
                    node = self.com_list_iter(node[5])
            elif t == 'if':
                test = self.com_node(node[2])
                newif = ListCompIf(test)
                newif.lineno = node[1][2]
                newfor.ifs.append(newif)
                if len(node) == 3:
                    node = None
                else:
                    node = self.com_list_iter(node[3])
            else:
                raise SyntaxError, \
                      ("unexpected list comprehension element: %s %d"
                       % (node, lineno))
        n = ListComp(expr, fors)
        n.lineno = lineno
        return n

    def com_list_iter(self, node):
        assert node[0] == symbol.list_iter
        return node[1]
</t>
<t tx="T2179">else:
    def com_list_constructor(self, nodelist):
        values = []
        for i in range(1, len(nodelist), 2):
            values.append(self.com_node(nodelist[i]))
        return List(values)
</t>
<t tx="T2180">def com_dictmaker(self, nodelist):
    # dictmaker: test ':' test (',' test ':' value)* [',']
    items = []
    for i in range(1, len(nodelist), 4):
        items.append((self.com_node(nodelist[i]),
                      self.com_node(nodelist[i+2])))
    return Dict(items)
</t>
<t tx="T2181">def com_apply_trailer(self, primaryNode, nodelist):
    t = nodelist[1][0]
    if t == token.LPAR:
        return self.com_call_function(primaryNode, nodelist[2])
    if t == token.DOT:
        return self.com_select_member(primaryNode, nodelist[2])
    if t == token.LSQB:
        return self.com_subscriptlist(primaryNode, nodelist[2], OP_APPLY)

    raise SyntaxError, 'unknown node type: %s' % t
</t>
<t tx="T2182">def com_select_member(self, primaryNode, nodelist):
    if nodelist[0] != token.NAME:
        raise SyntaxError, "member must be a name"
    n = Getattr(primaryNode, nodelist[1])
    n.lineno = nodelist[2]
    return n
</t>
<t tx="T2183">def com_call_function(self, primaryNode, nodelist):
    if nodelist[0] == token.RPAR:
        return CallFunc(primaryNode, [])
    args = []
    kw = 0
    len_nodelist = len(nodelist)
    for i in range(1, len_nodelist, 2):
        node = nodelist[i]
        if node[0] == token.STAR or node[0] == token.DOUBLESTAR:
            break
        kw, result = self.com_argument(node, kw)
        args.append(result)
    else:
        # No broken by star arg, so skip the last one we processed.
        i = i + 1
    if i &lt; len_nodelist and nodelist[i][0] == token.COMMA:
        # need to accept an application that looks like "f(a, b,)"
        i = i + 1
    star_node = dstar_node = None
    while i &lt; len_nodelist:
        tok = nodelist[i]
        ch = nodelist[i+1]
        i = i + 3
        if tok[0]==token.STAR:
            if star_node is not None:
                raise SyntaxError, 'already have the varargs indentifier'
            star_node = self.com_node(ch)
        elif tok[0]==token.DOUBLESTAR:
            if dstar_node is not None:
                raise SyntaxError, 'already have the kwargs indentifier'
            dstar_node = self.com_node(ch)
        else:
            raise SyntaxError, 'unknown node type: %s' % tok

    return CallFunc(primaryNode, args, star_node, dstar_node)
</t>
<t tx="T2184">def com_argument(self, nodelist, kw):
    if len(nodelist) == 2:
        if kw:
            raise SyntaxError, "non-keyword arg after keyword arg"
        return 0, self.com_node(nodelist[1])
    result = self.com_node(nodelist[3])
    n = nodelist[1]
    while len(n) == 2 and n[0] != token.NAME:
        n = n[1]
    if n[0] != token.NAME:
        raise SyntaxError, "keyword can't be an expression (%s)"%n[0]
    node = Keyword(n[1], result)
    node.lineno = n[2]
    return 1, node
</t>
<t tx="T2185">def com_subscriptlist(self, primary, nodelist, assigning):
    # slicing:      simple_slicing | extended_slicing
    # simple_slicing:   primary "[" short_slice "]"
    # extended_slicing: primary "[" slice_list "]"
    # slice_list:   slice_item ("," slice_item)* [","]

    # backwards compat slice for '[i:j]'
    if len(nodelist) == 2:
        sub = nodelist[1]
        if (sub[1][0] == token.COLON or \
                        (len(sub) &gt; 2 and sub[2][0] == token.COLON)) and \
                        sub[-1][0] != symbol.sliceop:
            return self.com_slice(primary, sub, assigning)

    subscripts = []
    for i in range(1, len(nodelist), 2):
        subscripts.append(self.com_subscript(nodelist[i]))

    return Subscript(primary, assigning, subscripts)
</t>
<t tx="T2186">def com_subscript(self, node):
    # slice_item: expression | proper_slice | ellipsis
    ch = node[1]
    t = ch[0]
    if t == token.DOT and node[2][0] == token.DOT:
        return Ellipsis()
    if t == token.COLON or len(node) &gt; 2:
        return self.com_sliceobj(node)
    return self.com_node(ch)
</t>
<t tx="T2187">def com_sliceobj(self, node):
    # proper_slice: short_slice | long_slice
    # short_slice:  [lower_bound] ":" [upper_bound]
    # long_slice:   short_slice ":" [stride]
    # lower_bound:  expression
    # upper_bound:  expression
    # stride:       expression
    #
    # Note: a stride may be further slicing...

    items = []

    if node[1][0] == token.COLON:
        items.append(Const(None))
        i = 2
    else:
        items.append(self.com_node(node[1]))
        # i == 2 is a COLON
        i = 3

    if i &lt; len(node) and node[i][0] == symbol.test:
        items.append(self.com_node(node[i]))
        i = i + 1
    else:
        items.append(Const(None))

    # a short_slice has been built. look for long_slice now by looking
    # for strides...
    for j in range(i, len(node)):
        ch = node[j]
        if len(ch) == 2:
            items.append(Const(None))
        else:
            items.append(self.com_node(ch[2]))

    return Sliceobj(items)
</t>
<t tx="T2188">def com_slice(self, primary, node, assigning):
    # short_slice:  [lower_bound] ":" [upper_bound]
    lower = upper = None
    if len(node) == 3:
        if node[1][0] == token.COLON:
            upper = self.com_node(node[2])
        else:
            lower = self.com_node(node[1])
    elif len(node) == 4:
        lower = self.com_node(node[1])
        upper = self.com_node(node[3])
    return Slice(primary, assigning, lower, upper)
</t>
<t tx="T2189">def get_docstring(self, node, n=None):
    if n is None:
        n = node[0]
        node = node[1:]
    if n == symbol.suite:
        if len(node) == 1:
            return self.get_docstring(node[0])
        for sub in node:
            if sub[0] == symbol.stmt:
                return self.get_docstring(sub)
        return None
    if n == symbol.file_input:
        for sub in node:
            if sub[0] == symbol.stmt:
                return self.get_docstring(sub)
        return None
    if n == symbol.atom:
        if node[0][0] == token.STRING:
            s = ''
            for t in node:
                s = s + eval(t[1])
            return s
        return None
    if n == symbol.stmt or n == symbol.simple_stmt \
       or n == symbol.small_stmt:
        return self.get_docstring(node[0])
    if n in _doc_nodes and len(node) == 1:
        return self.get_docstring(node[0])
    return None
</t>
<t tx="T2190">,
    symbol.stmt,
    symbol.small_stmt,
    symbol.flow_stmt,
    symbol.simple_stmt,
    symbol.compound_stmt,
    symbol.expr_stmt,
    symbol.print_stmt,
    symbol.del_stmt,
    symbol.pass_stmt,
    symbol.break_stmt,
    symbol.continue_stmt,
    symbol.return_stmt,
    symbol.raise_stmt,
    symbol.import_stmt,
    symbol.global_stmt,
    symbol.exec_stmt,
    symbol.assert_stmt,
    symbol.if_stmt,
    symbol.while_stmt,
    symbol.for_stmt,
    symbol.try_stmt,
    symbol.suite,
    symbol.testlist,
    symbol.testlist_safe,
    symbol.test,
    symbol.and_test,
    symbol.not_test,
    symbol.comparison,
    symbol.exprlist,
    symbol.expr,
    symbol.xor_expr,
    symbol.and_expr,
    symbol.shift_expr,
    symbol.arith_expr,
    symbol.term,
    symbol.factor,
    symbol.power,
    symbol.atom,
    ]

if hasattr(symbol, 'yield_stmt'):
    _legal_node_types.append(symbol.yield_stmt)

_assign_types = [
    symbol.test,
    symbol.and_test,
    symbol.not_test,
    symbol.comparison,
    symbol.expr,
    symbol.xor_expr,
    symbol.and_expr,
    symbol.shift_expr,
    symbol.arith_expr,
    symbol.term,
    symbol.factor,
    ]

import types
_names = {}
for k, v in symbol.sym_name.items():
    _names[k] = v
for k, v in token.tok_name.items():
    _names[k] = v

def debug_tree(tree):
	l = []
    for elt in tree:
        if type(elt) == types.IntType:
            l.append(_names.get(elt, elt))
        elif type(elt) == types.StringType:
            l.append(elt)
        else:
            l.append(debug_tree(elt))
    return l
</t>
<t tx="T2191">@language python

from compiler import ast

# XXX should probably rename ASTVisitor to ASTWalker
# XXX can it be made even more generic?

class ASTVisitor:
	&lt;&lt; about ASTVisitor &gt;&gt;
	VERBOSE = 0
	&lt;&lt; class ASTVisitor methods &gt;&gt;
	
class ExampleASTVisitor(ASTVisitor):
	&lt;&lt; about ExampleASTVisitor &gt;&gt;
	examples = {}
	&lt;&lt; class ExampleASTVisitor methods &gt;&gt;

@others
</t>
<t tx="T2192"></t>
<t tx="T2193">"""Performs a depth-first walk of the AST

The ASTVisitor will walk the AST, performing either a preorder or
postorder traversal depending on which method is called.

methods:
preorder(tree, visitor)
postorder(tree, visitor)
    tree: an instance of ast.Node
    visitor: an instance with visitXXX methods

The ASTVisitor is responsible for walking over the tree in the
correct order.  For each node, it checks the visitor argument for
a method named 'visitNodeType' where NodeType is the name of the
node's class, e.g. Class.  If the method exists, it is called
with the node as its sole argument.

The visitor method for a particular node type can control how
child nodes are visited during a preorder walk.  (It can't control
the order during a postorder walk, because it is called _after_
the walk has occurred.)  The ASTVisitor modifies the visitor
argument by adding a visit method to the visitor; this method can
be used to visit a particular child node.  If the visitor method
returns a true value, the ASTVisitor will not traverse the child
nodes.

XXX The interface for controlling the preorder walk needs to be
re-considered.  The current interface is convenient for visitors
that mostly let the ASTVisitor do everything.  For something like
a code generator, where you want to walk to occur in a specific
order, it's a pain to add "return 1" to the end of each method.
"""

</t>
<t tx="T2194">@others</t>
<t tx="T2195">def __init__(self):
    self.node = None
    self._cache = {}
</t>
<t tx="T2196">def default(self, node, *args):
    for child in node.getChildNodes():
        self.dispatch(child, *args)
</t>
<t tx="T2197">def dispatch(self, node, *args):
    self.node = node
    klass = node.__class__
    meth = self._cache.get(klass, None)
    if meth is None:
        className = klass.__name__
        meth = getattr(self.visitor, 'visit' + className, self.default)
        self._cache[klass] = meth
##        if self.VERBOSE &gt; 0:
##            className = klass.__name__
##            if self.VERBOSE == 1:
##                if meth == 0:
##                    print "dispatch", className
##            else:
##                print "dispatch", className, (meth and meth.__name__ or '')
    return meth(node, *args)
</t>
<t tx="T2198">def preorder(self, tree, visitor, *args):
    """Do preorder walk of tree using visitor"""
    self.visitor = visitor
    visitor.visit = self.dispatch
    self.dispatch(tree, *args) # XXX *args make sense?

</t>
<t tx="T2199"></t>
<t tx="T2200">"""Prints examples of the nodes that aren't visited

This visitor-driver is only useful for development, when it's
helpful to develop a visitor incremently, and get feedback on what
you still have to do.
"""</t>
<t tx="T2201">@others</t>
<t tx="T2202">def dispatch(self, node, *args):
    self.node = node
    meth = self._cache.get(node.__class__, None)
    className = node.__class__.__name__
    if meth is None:
        meth = getattr(self.visitor, 'visit' + className, 0)
        self._cache[node.__class__] = meth
    if self.VERBOSE &gt; 1:
        print "dispatch", className, (meth and meth.__name__ or '')
    if meth:
        meth(node, *args)
    elif self.VERBOSE &gt; 0:
        klass = node.__class__
        if not self.examples.has_key(klass):
            self.examples[klass] = klass
            print
            print self.visitor
            print klass
            for attr in dir(node):
                if attr[0] != '_':
                    print "\t", "%-12.12s" % attr, getattr(node, attr)
            print
        return self.default(node, *args)
</t>
<t tx="T2203"># XXX this is an API change

_walker = ASTVisitor
def walk(tree, visitor, walker=None, verbose=None):
    if walker is None:
        walker = _walker()
    if verbose is not None:
        walker.VERBOSE = verbose
    walker.preorder(tree, visitor)
    return walker.visitor
</t>
<t tx="T2204">def dumpNode(node):
    print node.__class__
    for attr in dir(node):
        if attr[0] != '_':
            print "\t", "%-10.10s" % attr, getattr(node, attr)
</t>
<t tx="T2205">@language python

"""Get useful information from live Python objects.

This module encapsulates the interface provided by the internal special
attributes (func_*, co_*, im_*, tb_*, etc.) in a friendlier fashion.
It also provides some help for examining source code and class layout.

Here are some of the useful functions provided by this module:

    ismodule(), isclass(), ismethod(), isfunction(), istraceback(),
        isframe(), iscode(), isbuiltin(), isroutine() - check object types
    getmembers() - get members of an object that satisfy a given condition

    getfile(), getsourcefile(), getsource() - find an object's source code
    getdoc(), getcomments() - get documentation on an object
    getmodule() - determine the module that an object came from
    getclasstree() - arrange classes so as to represent their hierarchy

    getargspec(), getargvalues() - get info about function arguments
    formatargspec(), formatargvalues() - format an argument spec
    getouterframes(), getinnerframes() - get info about frames
    currentframe() - get the current stack frame
    stack(), trace() - get info about frames on the stack or in a traceback
"""

# This module is in the public domain.  No warranties.

__author__ = 'Ka-Ping Yee &lt;ping@lfw.org&gt;'
__date__ = '1 Jan 2001'

import sys, os, types, string, re, dis, imp, tokenize

@others</t>
<t tx="T2206"></t>
<t tx="T2207">def ismodule(object):
    """Return true if the object is a module.

    Module objects provide these attributes:
        __doc__         documentation string
        __file__        filename (missing for built-in modules)"""
    return isinstance(object, types.ModuleType)
</t>
<t tx="T2208">def isclass(object):
    """Return true if the object is a class.

    Class objects provide these attributes:
        __doc__         documentation string
        __module__      name of module in which this class was defined"""
    return isinstance(object, types.ClassType) or hasattr(object, '__bases__')
</t>
<t tx="T2209">def ismethod(object):
    """Return true if the object is an instance method.

    Instance method objects provide these attributes:
        __doc__         documentation string
        __name__        name with which this method was defined
        im_class        class object in which this method belongs
        im_func         function object containing implementation of method
        im_self         instance to which this method is bound, or None"""
    return isinstance(object, types.MethodType)
</t>
<t tx="T2210">def ismethoddescriptor(object):
    """Return true if the object is a method descriptor.

    But not if ismethod() or isclass() or isfunction() are true.

    This is new in Python 2.2, and, for example, is true of int.__add__.
    An object passing this test has a __get__ attribute but not a __set__
    attribute, but beyond that the set of attributes varies.  __name__ is
    usually sensible, and __doc__ often is.

    Methods implemented via descriptors that also pass one of the other
    tests return false from the ismethoddescriptor() test, simply because
    the other tests promise more -- you can, e.g., count on having the
    im_func attribute (etc) when an object passes ismethod()."""
    return (hasattr(object, "__get__")
            and not hasattr(object, "__set__") # else it's a data descriptor
            and not ismethod(object)           # mutual exclusion
            and not isfunction(object)
            and not isclass(object))
</t>
<t tx="T2211">def isfunction(object):
    """Return true if the object is a user-defined function.

    Function objects provide these attributes:
        __doc__         documentation string
        __name__        name with which this function was defined
        func_code       code object containing compiled function bytecode
        func_defaults   tuple of any default values for arguments
        func_doc        (same as __doc__)
        func_globals    global namespace in which this function was defined
        func_name       (same as __name__)"""
    return isinstance(object, types.FunctionType)
</t>
<t tx="T2212">def istraceback(object):
    """Return true if the object is a traceback.

    Traceback objects provide these attributes:
        tb_frame        frame object at this level
        tb_lasti        index of last attempted instruction in bytecode
        tb_lineno       current line number in Python source code
        tb_next         next inner traceback object (called by this level)"""
    return isinstance(object, types.TracebackType)
</t>
<t tx="T2213">def isframe(object):
    """Return true if the object is a frame object.

    Frame objects provide these attributes:
        f_back          next outer frame object (this frame's caller)
        f_builtins      built-in namespace seen by this frame
        f_code          code object being executed in this frame
        f_exc_traceback traceback if raised in this frame, or None
        f_exc_type      exception type if raised in this frame, or None
        f_exc_value     exception value if raised in this frame, or None
        f_globals       global namespace seen by this frame
        f_lasti         index of last attempted instruction in bytecode
        f_lineno        current line number in Python source code
        f_locals        local namespace seen by this frame
        f_restricted    0 or 1 if frame is in restricted execution mode
        f_trace         tracing function for this frame, or None"""
    return isinstance(object, types.FrameType)
</t>
<t tx="T2214">def iscode(object):
    """Return true if the object is a code object.

    Code objects provide these attributes:
        co_argcount     number of arguments (not including * or ** args)
        co_code         string of raw compiled bytecode
        co_consts       tuple of constants used in the bytecode
        co_filename     name of file in which this code object was created
        co_firstlineno  number of first line in Python source code
        co_flags        bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg
        co_lnotab       encoded mapping of line numbers to bytecode indices
        co_name         name with which this code object was defined
        co_names        tuple of names of local variables
        co_nlocals      number of local variables
        co_stacksize    virtual machine stack space required
        co_varnames     tuple of names of arguments and local variables"""
    return isinstance(object, types.CodeType)
</t>
<t tx="T2215">def isbuiltin(object):
    """Return true if the object is a built-in function or method.

    Built-in functions and methods provide these attributes:
        __doc__         documentation string
        __name__        original name of this function or method
        __self__        instance to which a method is bound, or None"""
    return isinstance(object, types.BuiltinFunctionType)
</t>
<t tx="T2216">def isroutine(object):
    """Return true if the object is any kind of function or method."""
    return (isbuiltin(object)
            or isfunction(object)
            or ismethod(object)
            or ismethoddescriptor(object))
</t>
<t tx="T2217">def getmembers(object, predicate=None):
    """Return all members of an object as (name, value) pairs sorted by name.
    Optionally, only return members that satisfy a given predicate."""
    results = []
    for key in dir(object):
        value = getattr(object, key)
        if not predicate or predicate(value):
            results.append((key, value))
    results.sort()
    return results
</t>
<t tx="T2218">def classify_class_attrs(cls):
    """Return list of attribute-descriptor tuples.

    For each name in dir(cls), the return list contains a 4-tuple
    with these elements:

        0. The name (a string).

        1. The kind of attribute this is, one of these strings:
               'class method'    created via classmethod()
               'static method'   created via staticmethod()
               'property'        created via property()
               'method'          any other flavor of method
               'data'            not a method

        2. The class which defined this attribute (a class).

        3. The object as obtained directly from the defining class's
           __dict__, not via getattr.  This is especially important for
           data attributes:  C.data is just a data object, but
           C.__dict__['data'] may be a data descriptor with additional
           info, like a __doc__ string.
    """

    mro = getmro(cls)
    names = dir(cls)
    result = []
    for name in names:
        # Get the object associated with the name.
        # Getting an obj from the __dict__ sometimes reveals more than
        # using getattr.  Static and class methods are dramatic examples.
        if name in cls.__dict__:
            obj = cls.__dict__[name]
        else:
            obj = getattr(cls, name)

        # Figure out where it was defined.
        homecls = getattr(obj, "__objclass__", None)
        if homecls is None:
            # search the dicts.
            for base in mro:
                if name in base.__dict__:
                    homecls = base
                    break

        # Get the object again, in order to get it from the defining
        # __dict__ instead of via getattr (if possible).
        if homecls is not None and name in homecls.__dict__:
            obj = homecls.__dict__[name]

        # Also get the object via getattr.
        obj_via_getattr = getattr(cls, name)

        # Classify the object.
        if isinstance(obj, staticmethod):
            kind = "static method"
        elif isinstance(obj, classmethod):
            kind = "class method"
        elif isinstance(obj, property):
            kind = "property"
        elif (ismethod(obj_via_getattr) or
              ismethoddescriptor(obj_via_getattr)):
            kind = "method"
        else:
            kind = "data"

        result.append((name, kind, homecls, obj))

    return result
</t>
<t tx="T2219"></t>
<t tx="T2220">def _searchbases(cls, accum):
    # Simulate the "classic class" search order.
    if cls in accum:
        return
    accum.append(cls)
    for base in cls.__bases__:
        _searchbases(base, accum)
</t>
<t tx="T2221">def getmro(cls):
    "Return tuple of base classes (including cls) in method resolution order."
    if hasattr(cls, "__mro__"):
        return cls.__mro__
    else:
        result = []
        _searchbases(cls, result)
        return tuple(result)
</t>
<t tx="T2222"></t>
<t tx="T2223">def indentsize(line):
    """Return the indent size, in spaces, at the start of a line of text."""
    expline = string.expandtabs(line)
    return len(expline) - len(string.lstrip(expline))
</t>
<t tx="T2224">def getdoc(object):
    """Get the documentation string for an object.

    All tabs are expanded to spaces.  To clean up docstrings that are
    indented to line up with blocks of code, any whitespace than can be
    uniformly removed from the second line onwards is removed."""
    try:
        doc = object.__doc__
    except AttributeError:
        return None
    if not isinstance(doc, (str, unicode)):
        return None
    try:
        lines = string.split(string.expandtabs(doc), '\n')
    except UnicodeError:
        return None
    else:
        margin = None
        for line in lines[1:]:
            content = len(string.lstrip(line))
            if not content: continue
            indent = len(line) - content
            if margin is None: margin = indent
            else: margin = min(margin, indent)
        if margin is not None:
            for i in range(1, len(lines)): lines[i] = lines[i][margin:]
        return string.join(lines, '\n')
</t>
<t tx="T2225">def getfile(object):
    """Work out which source or compiled file an object was defined in."""
    if ismodule(object):
        if hasattr(object, '__file__'):
            return object.__file__
        raise TypeError, 'arg is a built-in module'
    if isclass(object):
        object = sys.modules.get(object.__module__)
        if hasattr(object, '__file__'):
            return object.__file__
        raise TypeError, 'arg is a built-in class'
    if ismethod(object):
        object = object.im_func
    if isfunction(object):
        object = object.func_code
    if istraceback(object):
        object = object.tb_frame
    if isframe(object):
        object = object.f_code
    if iscode(object):
        return object.co_filename
    raise TypeError, 'arg is not a module, class, method, ' \
                     'function, traceback, frame, or code object'
</t>
<t tx="T2226">def getmoduleinfo(path):
    """Get the module name, suffix, mode, and module type for a given file."""
    filename = os.path.basename(path)
    suffixes = map(lambda (suffix, mode, mtype):
                   (-len(suffix), suffix, mode, mtype), imp.get_suffixes())
    suffixes.sort() # try longest suffixes first, in case they overlap
    for neglen, suffix, mode, mtype in suffixes:
        if filename[neglen:] == suffix:
            return filename[:neglen], suffix, mode, mtype
</t>
<t tx="T2227">def getmodulename(path):
    """Return the module name for a given file, or None."""
    info = getmoduleinfo(path)
    if info: return info[0]
</t>
<t tx="T2228">def getsourcefile(object):
    """Return the Python source file an object was defined in, if it exists."""
    filename = getfile(object)
    if string.lower(filename[-4:]) in ['.pyc', '.pyo']:
        filename = filename[:-4] + '.py'
    for suffix, mode, kind in imp.get_suffixes():
        if 'b' in mode and string.lower(filename[-len(suffix):]) == suffix:
            # Looks like a binary file.  We want to only return a text file.
            return None
    if os.path.exists(filename):
        return filename
</t>
<t tx="T2229">def getabsfile(object):
    """Return an absolute path to the source or compiled file for an object.

    The idea is for each object to have a unique origin, so this routine
    normalizes the result as much as possible."""
    return os.path.normcase(
        os.path.abspath(getsourcefile(object) or getfile(object)))
</t>
<t tx="T2230">modulesbyfile = {}

def getmodule(object):
    """Return the module an object was defined in, or None if not found."""
    if ismodule(object):
        return object
    if isclass(object):
        return sys.modules.get(object.__module__)
    try:
        file = getabsfile(object)
    except TypeError:
        return None
    if modulesbyfile.has_key(file):
        return sys.modules[modulesbyfile[file]]
    for module in sys.modules.values():
        if hasattr(module, '__file__'):
            modulesbyfile[getabsfile(module)] = module.__name__
    if modulesbyfile.has_key(file):
        return sys.modules[modulesbyfile[file]]
    main = sys.modules['__main__']
    if hasattr(main, object.__name__):
        mainobject = getattr(main, object.__name__)
        if mainobject is object:
            return main
    builtin = sys.modules['__builtin__']
    if hasattr(builtin, object.__name__):
        builtinobject = getattr(builtin, object.__name__)
        if builtinobject is object:
            return builtin
</t>
<t tx="T2231">def findsource(object):
    """Return the entire source file and starting line number for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a list of all the lines
    in the file and the line number indexes a line in that list.  An IOError
    is raised if the source code cannot be retrieved."""
    try:
        file = open(getsourcefile(object))
    except (TypeError, IOError):
        raise IOError, 'could not get source code'
    lines = file.readlines()
    file.close()

    if ismodule(object):
        return lines, 0

    if isclass(object):
        name = object.__name__
        pat = re.compile(r'^\s*class\s*' + name + r'\b')
        for i in range(len(lines)):
            if pat.match(lines[i]): return lines, i
        else: raise IOError, 'could not find class definition'

    if ismethod(object):
        object = object.im_func
    if isfunction(object):
        object = object.func_code
    if istraceback(object):
        object = object.tb_frame
    if isframe(object):
        object = object.f_code
    if iscode(object):
        if not hasattr(object, 'co_firstlineno'):
            raise IOError, 'could not find function definition'
        lnum = object.co_firstlineno - 1
        pat = re.compile(r'^\s*def\s')
        while lnum &gt; 0:
            if pat.match(lines[lnum]): break
            lnum = lnum - 1
        return lines, lnum
    raise IOError, 'could not find code object'
</t>
<t tx="T2232">def getcomments(object):
    """Get lines of comments immediately preceding an object's source code."""
    try: lines, lnum = findsource(object)
    except IOError: return None

    if ismodule(object):
        # Look for a comment block at the top of the file.
        start = 0
        if lines and lines[0][:2] == '#!': start = 1
        while start &lt; len(lines) and string.strip(lines[start]) in ['', '#']:
            start = start + 1
        if start &lt; len(lines) and lines[start][:1] == '#':
            comments = []
            end = start
            while end &lt; len(lines) and lines[end][:1] == '#':
                comments.append(string.expandtabs(lines[end]))
                end = end + 1
            return string.join(comments, '')

    # Look for a preceding block of comments at the same indentation.
    elif lnum &gt; 0:
        indent = indentsize(lines[lnum])
        end = lnum - 1
        if end &gt;= 0 and string.lstrip(lines[end])[:1] == '#' and \
            indentsize(lines[end]) == indent:
            comments = [string.lstrip(string.expandtabs(lines[end]))]
            if end &gt; 0:
                end = end - 1
                comment = string.lstrip(string.expandtabs(lines[end]))
                while comment[:1] == '#' and indentsize(lines[end]) == indent:
                    comments[:0] = [comment]
                    end = end - 1
                    if end &lt; 0: break
                    comment = string.lstrip(string.expandtabs(lines[end]))
            while comments and string.strip(comments[0]) == '#':
                comments[:1] = []
            while comments and string.strip(comments[-1]) == '#':
                comments[-1:] = []
            return string.join(comments, '')
</t>
<t tx="T2233">class ListReader:
	"""Provide a readline() method to return lines from a list of strings."""
	@others

</t>
<t tx="T2234">def __init__(self, lines):
    self.lines = lines
    self.index = 0
</t>
<t tx="T2235">def readline(self):
    i = self.index
    if i &lt; len(self.lines):
        self.index = i + 1
        return self.lines[i]
    else: return ''
</t>
<t tx="T2236">class EndOfBlock(Exception): pass
</t>
<t tx="T2237">class BlockFinder:
	"""Provide a tokeneater() method to detect the end of a code block."""
	@others

</t>
<t tx="T2238">def __init__(self):
    self.indent = 0
    self.started = 0
    self.last = 0
</t>
<t tx="T2239">def tokeneater(self, type, token, (srow, scol), (erow, ecol), line):
    if not self.started:
        if type == tokenize.NAME: self.started = 1
    elif type == tokenize.NEWLINE:
        self.last = srow
    elif type == tokenize.INDENT:
        self.indent = self.indent + 1
    elif type == tokenize.DEDENT:
        self.indent = self.indent - 1
        if self.indent == 0: raise EndOfBlock, self.last
</t>
<t tx="T2240">def getblock(lines):
    """Extract the block of code at the top of the given list of lines."""
    try:
        tokenize.tokenize(ListReader(lines).readline, BlockFinder().tokeneater)
    except EndOfBlock, eob:
        return lines[:eob.args[0]]
</t>
<t tx="T2241">def getsourcelines(object):
    """Return a list of source lines and starting line number for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a list of the lines
    corresponding to the object and the line number indicates where in the
    original source file the first line of code was found.  An IOError is
    raised if the source code cannot be retrieved."""
    lines, lnum = findsource(object)

    if ismodule(object): return lines, 0
    else: return getblock(lines[lnum:]), lnum + 1
</t>
<t tx="T2242">def getsource(object):
    """Return the text of the source code for an object.

    The argument may be a module, class, method, function, traceback, frame,
    or code object.  The source code is returned as a single string.  An
    IOError is raised if the source code cannot be retrieved."""
    lines, lnum = getsourcelines(object)
    return string.join(lines, '')
</t>
<t tx="T2243"></t>
<t tx="T2244">def walktree(classes, children, parent):
    """Recursive helper function for getclasstree()."""
    results = []
    classes.sort(lambda a, b: cmp(a.__name__, b.__name__))
    for c in classes:
        results.append((c, c.__bases__))
        if children.has_key(c):
            results.append(walktree(children[c], children, c))
    return results
</t>
<t tx="T2245">def getclasstree(classes, unique=0):
    """Arrange the given list of classes into a hierarchy of nested lists.

    Where a nested list appears, it contains classes derived from the class
    whose entry immediately precedes the list.  Each entry is a 2-tuple
    containing a class and a tuple of its base classes.  If the 'unique'
    argument is true, exactly one entry appears in the returned structure
    for each class in the given list.  Otherwise, classes using multiple
    inheritance and their descendants will appear multiple times."""
    children = {}
    roots = []
    for c in classes:
        if c.__bases__:
            for parent in c.__bases__:
                if not children.has_key(parent):
                    children[parent] = []
                children[parent].append(c)
                if unique and parent in classes: break
        elif c not in roots:
            roots.append(c)
    for parent in children.keys():
        if parent not in classes:
            roots.append(parent)
    return walktree(roots, children, None)
</t>
<t tx="T2246"># These constants are from Python's compile.h.
CO_OPTIMIZED, CO_NEWLOCALS, CO_VARARGS, CO_VARKEYWORDS = 1, 2, 4, 8

def getargs(co):
    """Get information about the arguments accepted by a code object.

    Three things are returned: (args, varargs, varkw), where 'args' is
    a list of argument names (possibly containing nested lists), and
    'varargs' and 'varkw' are the names of the * and ** arguments or None."""
    if not iscode(co): raise TypeError, 'arg is not a code object'

    code = co.co_code
    nargs = co.co_argcount
    names = co.co_varnames
    args = list(names[:nargs])
    step = 0

    # The following acrobatics are for anonymous (tuple) arguments.
    for i in range(nargs):
        if args[i][:1] in ['', '.']:
            stack, remain, count = [], [], []
            while step &lt; len(code):
                op = ord(code[step])
                step = step + 1
                if op &gt;= dis.HAVE_ARGUMENT:
                    opname = dis.opname[op]
                    value = ord(code[step]) + ord(code[step+1])*256
                    step = step + 2
                    if opname in ['UNPACK_TUPLE', 'UNPACK_SEQUENCE']:
                        remain.append(value)
                        count.append(value)
                    elif opname == 'STORE_FAST':
                        stack.append(names[value])
                        remain[-1] = remain[-1] - 1
                        while remain[-1] == 0:
                            remain.pop()
                            size = count.pop()
                            stack[-size:] = [stack[-size:]]
                            if not remain: break
                            remain[-1] = remain[-1] - 1
                        if not remain: break
            args[i] = stack[0]

    varargs = None
    if co.co_flags &amp; CO_VARARGS:
        varargs = co.co_varnames[nargs]
        nargs = nargs + 1
    varkw = None
    if co.co_flags &amp; CO_VARKEYWORDS:
        varkw = co.co_varnames[nargs]
    return args, varargs, varkw
</t>
<t tx="T2247">def getargspec(func):
    """Get the names and default values of a function's arguments.

    A tuple of four things is returned: (args, varargs, varkw, defaults).
    'args' is a list of the argument names (it may contain nested lists).
    'varargs' and 'varkw' are the names of the * and ** arguments or None.
    'defaults' is an n-tuple of the default values of the last n arguments."""
    if not isfunction(func): raise TypeError, 'arg is not a Python function'
    args, varargs, varkw = getargs(func.func_code)
    return args, varargs, varkw, func.func_defaults
</t>
<t tx="T2248">def getargvalues(frame):
    """Get information about arguments passed into a particular frame.

    A tuple of four things is returned: (args, varargs, varkw, locals).
    'args' is a list of the argument names (it may contain nested lists).
    'varargs' and 'varkw' are the names of the * and ** arguments or None.
    'locals' is the locals dictionary of the given frame."""
    args, varargs, varkw = getargs(frame.f_code)
    return args, varargs, varkw, frame.f_locals
</t>
<t tx="T2249">def joinseq(seq):
    if len(seq) == 1:
        return '(' + seq[0] + ',)'
    else:
        return '(' + string.join(seq, ', ') + ')'
</t>
<t tx="T2250">def strseq(object, convert, join=joinseq):
    """Recursively walk a sequence, stringifying each element."""
    if type(object) in [types.ListType, types.TupleType]:
        return join(map(lambda o, c=convert, j=join: strseq(o, c, j), object))
    else:
        return convert(object)
</t>
<t tx="T2251">def formatargspec(args, varargs=None, varkw=None, defaults=None,
                  formatarg=str,
                  formatvarargs=lambda name: '*' + name,
                  formatvarkw=lambda name: '**' + name,
                  formatvalue=lambda value: '=' + repr(value),
                  join=joinseq):
    """Format an argument spec from the 4 values returned by getargspec.

    The first four arguments are (args, varargs, varkw, defaults).  The
    other four arguments are the corresponding optional formatting functions
    that are called to turn names and values into strings.  The ninth
    argument is an optional function to format the sequence of arguments."""
    specs = []
    if defaults:
        firstdefault = len(args) - len(defaults)
    for i in range(len(args)):
        spec = strseq(args[i], formatarg, join)
        if defaults and i &gt;= firstdefault:
            spec = spec + formatvalue(defaults[i - firstdefault])
        specs.append(spec)
    if varargs:
        specs.append(formatvarargs(varargs))
    if varkw:
        specs.append(formatvarkw(varkw))
    return '(' + string.join(specs, ', ') + ')'
</t>
<t tx="T2252">def formatargvalues(args, varargs, varkw, locals,
                    formatarg=str,
                    formatvarargs=lambda name: '*' + name,
                    formatvarkw=lambda name: '**' + name,
                    formatvalue=lambda value: '=' + repr(value),
                    join=joinseq):
    """Format an argument spec from the 4 values returned by getargvalues.

    The first four arguments are (args, varargs, varkw, locals).  The
    next four arguments are the corresponding optional formatting functions
    that are called to turn names and values into strings.  The ninth
    argument is an optional function to format the sequence of arguments."""
    def convert(name, locals=locals,
                formatarg=formatarg, formatvalue=formatvalue):
        return formatarg(name) + formatvalue(locals[name])
    specs = []
    for i in range(len(args)):
        specs.append(strseq(args[i], convert, join))
    if varargs:
        specs.append(formatvarargs(varargs) + formatvalue(locals[varargs]))
    if varkw:
        specs.append(formatvarkw(varkw) + formatvalue(locals[varkw]))
    return '(' + string.join(specs, ', ') + ')'
</t>
<t tx="T2253"></t>
<t tx="T2254">def getframeinfo(frame, context=1):
    """Get information about a frame or traceback object.

    A tuple of five things is returned: the filename, the line number of
    the current line, the function name, a list of lines of context from
    the source code, and the index of the current line within that list.
    The optional second argument specifies the number of lines of context
    to return, which are centered around the current line."""
    if istraceback(frame):
        frame = frame.tb_frame
    if not isframe(frame):
        raise TypeError, 'arg is not a frame or traceback object'

    filename = getsourcefile(frame)
    lineno = getlineno(frame)
    if context &gt; 0:
        start = lineno - 1 - context//2
        try:
            lines, lnum = findsource(frame)
        except IOError:
            lines = index = None
        else:
            start = max(start, 1)
            start = min(start, len(lines) - context)
            lines = lines[start:start+context]
            index = lineno - 1 - start
    else:
        lines = index = None

    return (filename, lineno, frame.f_code.co_name, lines, index)
</t>
<t tx="T2255">def getlineno(frame):
    """Get the line number from a frame object, allowing for optimization."""
    # Written by Marc-André Lemburg; revised by Jim Hugunin and Fredrik Lundh.
    lineno = frame.f_lineno
    code = frame.f_code
    if hasattr(code, 'co_lnotab'):
        table = code.co_lnotab
        lineno = code.co_firstlineno
        addr = 0
        for i in range(0, len(table), 2):
            addr = addr + ord(table[i])
            if addr &gt; frame.f_lasti: break
            lineno = lineno + ord(table[i+1])
    return lineno</t>
<t tx="T2256">def getouterframes(frame, context=1):
    """Get a list of records for a frame and all higher (calling) frames.

    Each record contains a frame object, filename, line number, function
    name, a list of lines of context, and index within the context."""
    framelist = []
    while frame:
        framelist.append((frame,) + getframeinfo(frame, context))
        frame = frame.f_back
    return framelist
</t>
<t tx="T2257">def getinnerframes(tb, context=1):
    """Get a list of records for a traceback's frame and all lower frames.

    Each record contains a frame object, filename, line number, function
    name, a list of lines of context, and index within the context."""
    framelist = []
    while tb:
        framelist.append((tb.tb_frame,) + getframeinfo(tb, context))
        tb = tb.tb_next
    return framelist
</t>
<t tx="T2258">def currentframe():
    """Return the frame object for the caller's stack frame."""
    try:
        raise 'catch me'
    except:
        return sys.exc_traceback.tb_frame.f_back
</t>
<t tx="T2259">if hasattr(sys, '_getframe'): currentframe = sys._getframe

def stack(context=1):
    """Return a list of records for the stack above the caller's frame."""
    return getouterframes(currentframe().f_back, context)
</t>
<t tx="T2260">def trace(context=1):
    """Return a list of records for the stack below the current exception."""
    return getinnerframes(sys.exc_traceback, context)
</t>
<t tx="T2261">@language python

"""Tokenization help for Python programs.

generate_tokens(readline) is a generator that breaks a stream of
text into Python tokens.  It accepts a readline-like method which is called
repeatedly to get the next line of input (or "" for EOF).  It generates
5-tuples with these members:

    the token type (see token.py)
    the token (a string)
    the starting (row, column) indices of the token (a 2-tuple of ints)
    the ending (row, column) indices of the token (a 2-tuple of ints)
    the original line (string)

It is designed to match the working of the Python tokenizer exactly, except
that it produces COMMENT tokens for comments and gives type OP for all
operators

Older entry points
    tokenize_loop(readline, tokeneater)
    tokenize(readline, tokeneater=printtoken)
are the same, except instead of generating tokens, tokeneater is a callback
function to which the 5 fields described above are passed as 5 arguments,
each time a new token is found."""

&lt;&lt; tokenize declarations &gt;&gt;

@others

if __name__ == '__main__':                     # testing
    import sys
    if len(sys.argv) &gt; 1: tokenize(open(sys.argv[1]).readline)
    else: tokenize(sys.stdin.readline)</t>
<t tx="T2262">from __future__ import generators

__author__ = 'Ka-Ping Yee &lt;ping@lfw.org&gt;'
__credits__ = \
    'GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, Skip Montanaro'

import string, re
from token import *

import token
__all__ = [x for x in dir(token) if x[0] != '_'] + ["COMMENT", "tokenize", "NL"]
del token

COMMENT = N_TOKENS
tok_name[COMMENT] = 'COMMENT'
NL = N_TOKENS + 1
tok_name[NL] = 'NL'
N_TOKENS += 2

</t>
<t tx="T2263">@ group, any and maybe help define the data.</t>
<t tx="T2264">def group(*choices): return '(' + '|'.join(choices) + ')'
</t>
<t tx="T2265">def any(*choices): return apply(group, choices) + '*'
</t>
<t tx="T2266">def maybe(*choices): return apply(group, choices) + '?'
</t>
<t tx="T2267">Whitespace = r'[ \f\t]*'
Comment = r'#[^\r\n]*'
Ignore = Whitespace + any(r'\\\r?\n' + Whitespace) + maybe(Comment)
Name = r'[a-zA-Z_]\w*'

Hexnumber = r'0[xX][\da-fA-F]*[lL]?'
Octnumber = r'0[0-7]*[lL]?'
Decnumber = r'[1-9]\d*[lL]?'
Intnumber = group(Hexnumber, Octnumber, Decnumber)
Exponent = r'[eE][-+]?\d+'
Pointfloat = group(r'\d+\.\d*', r'\.\d+') + maybe(Exponent)
Expfloat = r'\d+' + Exponent
Floatnumber = group(Pointfloat, Expfloat)
Imagnumber = group(r'\d+[jJ]', Floatnumber + r'[jJ]')
Number = group(Imagnumber, Floatnumber, Intnumber)

# Tail end of ' string.
Single = r"[^'\\]*(?:\\.[^'\\]*)*'"
# Tail end of " string.
Double = r'[^"\\]*(?:\\.[^"\\]*)*"'
# Tail end of ''' string.
Single3 = r"[^'\\]*(?:(?:\\.|'(?!''))[^'\\]*)*'''"
# Tail end of """ string.
Double3 = r'[^"\\]*(?:(?:\\.|"(?!""))[^"\\]*)*"""'
Triple = group("[uU]?[rR]?'''", '[uU]?[rR]?"""')
# Single-line ' or " string.
String = group(r"[uU]?[rR]?'[^\n'\\]*(?:\\.[^\n'\\]*)*'",
			   r'[uU]?[rR]?"[^\n"\\]*(?:\\.[^\n"\\]*)*"')

# Because of leftmost-then-longest match semantics, be sure to put the
# longest operators first (e.g., if = came before ==, == would get
# recognized as two instances of =).
Operator = group(r"\*\*=?", r"&gt;&gt;=?", r"&lt;&lt;=?", r"&lt;&gt;", r"!=",
				 r"//=?",
				 r"[+\-*/%&amp;|^=&lt;&gt;]=?",
				 r"~")

Bracket = '[][(){}]'
Special = group(r'\r?\n', r'[:;.,`]')
Funny = group(Operator, Bracket, Special)

PlainToken = group(Number, Funny, String, Name)
Token = Ignore + PlainToken

# First (or only) line of ' or " string.
ContStr = group(r"[uU]?[rR]?'[^\n'\\]*(?:\\.[^\n'\\]*)*" +
				group("'", r'\\\r?\n'),
				r'[uU]?[rR]?"[^\n"\\]*(?:\\.[^\n"\\]*)*' +
				group('"', r'\\\r?\n'))
PseudoExtras = group(r'\\\r?\n', Comment, Triple)
PseudoToken = Whitespace + group(PseudoExtras, Number, Funny, ContStr, Name)

tokenprog, pseudoprog, single3prog, double3prog = map(
	re.compile, (Token, PseudoToken, Single3, Double3))
endprogs = {"'": re.compile(Single), '"': re.compile(Double),
			"'''": single3prog, '"""': double3prog,
			"r'''": single3prog, 'r"""': double3prog,
			"u'''": single3prog, 'u"""': double3prog,
			"ur'''": single3prog, 'ur"""': double3prog,
			"R'''": single3prog, 'R"""': double3prog,
			"U'''": single3prog, 'U"""': double3prog,
			"uR'''": single3prog, 'uR"""': double3prog,
			"Ur'''": single3prog, 'Ur"""': double3prog,
			"UR'''": single3prog, 'UR"""': double3prog,
			'r': None, 'R': None, 'u': None, 'U': None}

tabsize = 8</t>
<t tx="T2268">class TokenError(Exception): pass
</t>
<t tx="T2269">class StopTokenizing(Exception): pass
</t>
<t tx="T2270">def printtoken(type, token, (srow, scol), (erow, ecol), line): # for testing
    print "%d,%d-%d,%d:\t%s\t%s" % \
        (srow, scol, erow, ecol, tok_name[type], repr(token))
</t>
<t tx="T2271">def tokenize(readline, tokeneater=printtoken):
    try:
        tokenize_loop(readline, tokeneater)
    except StopTokenizing:
        pass
</t>
<t tx="T2272"># backwards compatible interface
def tokenize_loop(readline, tokeneater):
    for token_info in generate_tokens(readline):
        apply(tokeneater, token_info)
</t>
<t tx="T2273">def generate_tokens(readline):

	lnum = parenlev = continued = 0
	namechars, numchars = string.ascii_letters + '_', '0123456789'
	contstr, needcont = '', 0
	contline = None
	indents = [0]

	while 1: # loop over lines in stream
		line = readline()
		lnum = lnum + 1
		pos, max = 0, len(line)

		if contstr:
			&lt;&lt; handle continued string &gt;&gt;
		elif parenlev == 0 and not continued: 
			&lt;&lt; handle new statement &gt;&gt;
		else:
			&lt;&lt; handle continued statement &gt;&gt;

		while pos &lt; max:
			pseudomatch = pseudoprog.match(line, pos)
			if pseudomatch:                                # scan for tokens
				&lt;&lt; scan for tokens &gt;&gt;
			else:
				yield (ERRORTOKEN, line[pos],
					(lnum, pos), (lnum, pos+1), line)
				pos = pos + 1

	for indent in indents[1:]:                 # pop remaining indent levels
		yield (DEDENT, '', (lnum, 0), (lnum, 0), '')
	yield (ENDMARKER, '', (lnum, 0), (lnum, 0), '')</t>
<t tx="T2274">if not line:
	raise TokenError, ("EOF in multi-line string", strstart)
endmatch = endprog.match(line)
if endmatch:
	pos = end = endmatch.end(0)
	yield (STRING, contstr + line[:end],
		strstart, (lnum, end), contline + line)
	contstr, needcont = '', 0
	contline = None
elif needcont and line[-2:] != '\\\n' and line[-3:] != '\\\r\n':
	yield (ERRORTOKEN, contstr + line,
		strstart, (lnum, len(line)), contline)
	contstr = ''
	contline = None
	continue
else:
	contstr = contstr + line
	contline = contline + line
	continue</t>
<t tx="T2275">if not line: break
column = 0
while pos &lt; max:                   # measure leading whitespace
	if line[pos] == ' ': column = column + 1
	elif line[pos] == '\t': column = (column/tabsize + 1)*tabsize
	elif line[pos] == '\f': column = 0
	else: break
	pos = pos + 1
if pos == max: break

if line[pos] in '#\r\n':           # skip comments or blank lines
	yield ((NL, COMMENT)[line[pos] == '#'], line[pos:],
		(lnum, pos), (lnum, len(line)), line)
	continue

if column &gt; indents[-1]:           # count indents or dedents
	indents.append(column)
	yield (INDENT, line[:pos], (lnum, 0), (lnum, pos), line)
while column &lt; indents[-1]:
	indents = indents[:-1]
	yield (DEDENT, '', (lnum, pos), (lnum, pos), line)</t>
<t tx="T2276">if not line:
	raise TokenError, ("EOF in multi-line statement", (lnum, 0))
continued = 0</t>
<t tx="T2277">start, end = pseudomatch.span(1)
spos, epos, pos = (lnum, start), (lnum, end), end
token, initial = line[start:end], line[start]

if initial in numchars or \
   (initial == '.' and token != '.'):      # ordinary number
	yield (NUMBER, token, spos, epos, line)
elif initial in '\r\n':
	yield (parenlev &gt; 0 and NL or NEWLINE,
		token, spos, epos, line)
elif initial == '#':
	yield (COMMENT, token, spos, epos, line)
elif token in ("'''", '"""',               # triple-quoted
		"r'''", 'r"""', "R'''", 'R"""',
		"u'''", 'u"""', "U'''", 'U"""',
		"ur'''", 'ur"""', "Ur'''", 'Ur"""',
		"uR'''", 'uR"""', "UR'''", 'UR"""'):
	&lt;&lt; handle triple-quoted string &gt;&gt;
elif initial in ("'", '"') or \
	token[:2] in ("r'", 'r"', "R'", 'R"',
		"u'", 'u"', "U'", 'U"') or \
	token[:3] in ("ur'", 'ur"', "Ur'", 'Ur"',
		"uR'", 'uR"', "UR'", 'UR"' ):
	&lt;&lt; handle continued string &gt;&gt;
elif initial in namechars:                 # ordinary name
	yield (NAME, token, spos, epos, line)
elif initial == '\\':                      # continued stmt
	continued = 1
else:
	if initial in '([{': parenlev = parenlev + 1
	elif initial in ')]}': parenlev = parenlev - 1
	yield (OP, token, spos, epos, line)</t>
<t tx="T2278">endprog = endprogs[token]
endmatch = endprog.match(line, pos)
if endmatch:                           # all on one line
	pos = endmatch.end(0)
	token = line[start:pos]
	yield (STRING, token, spos, (lnum, pos), line)
else:
	strstart = (lnum, start)           # multiple lines
	contstr = line[start:]
	contline = line
	break</t>
<t tx="T2279">if token[-1] == '\n':                  # continued string
	strstart = (lnum, start)
	endprog = (endprogs[initial] or endprogs[token[1]] or
			   endprogs[token[2]])
	contstr, needcont = line[start:], 1
	contline = line
	break
else:                                  # ordinary string
	yield (STRING, token, spos, epos, line)</t>
<t tx="T2280">@language python

"""Routine to "compile" a .py file to a .pyc (or .pyo) file.

This module has intimate knowledge of the format of .pyc files.
"""

import imp

MAGIC = imp.get_magic()

__all__ = ["compile"]


@others</t>
<t tx="T2281">def wr_long(f, x):

    """Internal; write a 32-bit int to a file in little-endian order."""
    f.write(chr( x        &amp; 0xff))
    f.write(chr((x &gt;&gt; 8)  &amp; 0xff))
    f.write(chr((x &gt;&gt; 16) &amp; 0xff))
    f.write(chr((x &gt;&gt; 24) &amp; 0xff))
</t>
<t tx="T2282">def compile(file, cfile=None, dfile=None):
    """Byte-compile one Python source file to Python bytecode.

    Arguments:

    file:  source filename
    cfile: target filename; defaults to source with 'c' or 'o' appended
           ('c' normally, 'o' in optimizing mode, giving .pyc or .pyo)
    dfile: purported filename; defaults to source (this is the filename
           that will show up in error messages)

    Note that it isn't necessary to byte-compile Python modules for
    execution efficiency -- Python itself byte-compiles a module when
    it is loaded, and if it can, writes out the bytecode to the
    corresponding .pyc (or .pyo) file.

    However, if a Python installation is shared between users, it is a
    good idea to byte-compile all modules upon installation, since
    other users may not be able to write in the source directories,
    and thus they won't be able to write the .pyc/.pyo file, and then
    they would be byte-compiling every module each time it is loaded.
    This can slow down program start-up considerably.

    See compileall.py for a script/module that uses this module to
    byte-compile all installed files (or all files in selected
    directories).

    """
    import os, marshal, __builtin__
    f = open(file)
    try:
        timestamp = long(os.fstat(f.fileno())[8])
    except AttributeError:
        timestamp = long(os.stat(file)[8])
    codestring = f.read()
    # If parsing from a string, line breaks are \n (see parsetok.c:tok_nextc)
    # Replace will return original string if pattern is not found, so
    # we don't need to check whether it is found first.
    codestring = codestring.replace("\r\n","\n")
    codestring = codestring.replace("\r","\n")
    f.close()
    if codestring and codestring[-1] != '\n':
        codestring = codestring + '\n'
    try:
        codeobject = __builtin__.compile(codestring, dfile or file, 'exec')
    except SyntaxError, detail:
        import traceback, sys
        lines = traceback.format_exception_only(SyntaxError, detail)
        for line in lines:
            sys.stderr.write(line.replace('File "&lt;string&gt;"',
                                            'File "%s"' % (dfile or file)))
        return
    if not cfile:
        cfile = file + (__debug__ and 'c' or 'o')
    fc = open(cfile, 'wb')
    fc.write('\0\0\0\0')
    wr_long(fc, timestamp)
    marshal.dump(codeobject, fc)
    fc.flush()
    fc.seek(0, 0)
    fc.write(MAGIC)
    fc.close()
    if os.name == 'mac':
        import macfs
        macfs.FSSpec(cfile).SetCreatorType('Pyth', 'PYC ')
</t>
<t tx="T2283">@language python

"""
Import utilities

Exported classes:
    ImportManager   Manage the import process

    Importer        Base class for replacing standard import functions
    BuiltinImporter Emulate the import mechanism for builtin and frozen modules

    DynLoadSuffixImporter
"""

&lt;&lt; to do &gt;&gt;
&lt;&lt; imputil declarations &gt;&gt;

@others
</t>
<t tx="T2284"># TODO
#
# from Finn Bock:
#   type(sys) is not a module in JPython. what to use instead?
#   imp.C_EXTENSION is not in JPython. same for get_suffixes and new_module
#
#   given foo.py of:
#      import sys
#      sys.modules['foo'] = sys
#
#   ---- standard import mechanism
#   &gt;&gt;&gt; import foo
#   &gt;&gt;&gt; foo
#   &lt;module 'sys' (built-in)&gt;
#
#   ---- revamped import mechanism
#   &gt;&gt;&gt; import imputil
#   &gt;&gt;&gt; imputil._test_revamp()
#   &gt;&gt;&gt; import foo
#   &gt;&gt;&gt; foo
#   &lt;module 'foo' from 'foo.py'&gt;
#
#
# from MAL:
#   should BuiltinImporter exist in sys.path or hard-wired in ImportManager?
#   need __path__ processing
#   performance
#   move chaining to a subclass [gjs: it's been nuked]
#   deinstall should be possible
#   query mechanism needed: is a specific Importer installed?
#   py/pyc/pyo piping hooks to filter/process these files
#   wish list:
#     distutils importer hooked to list of standard Internet repositories
#     module-&gt;file location mapper to speed FS-based imports
#     relative imports
#     keep chaining so that it can play nice with other import hooks
#
# from Gordon:
#   push MAL's mapper into sys.path[0] as a cache (hard-coded for apps)
#
# from Guido:
#   need to change sys.* references for rexec environs
#   need hook for MAL's walk-me-up import strategy, or Tim's absolute strategy
#   watch out for sys.modules[...] is None
#   flag to force absolute imports? (speeds _determine_import_context and
#       checking for a relative module)
#   insert names of archives into sys.path  (see quote below)
#   note: reload does NOT blast module dict
#   shift import mechanisms and policies around; provide for hooks, overrides
#       (see quote below)
#   add get_source stuff
#   get_topcode and get_subcode
#   CRLF handling in _compile
#   race condition in _compile
#   refactoring of os.py to deal with _os_bootstrap problem
#   any special handling to do for importing a module with a SyntaxError?
#       (e.g. clean up the traceback)
#   implement "domain" for path-type functionality using pkg namespace
#       (rather than FS-names like __path__)
#   don't use the word "private"... maybe "internal"
#
#
# Guido's comments on sys.path caching:
#
# We could cache this in a dictionary: the ImportManager can have a
# cache dict mapping pathnames to importer objects, and a separate
# method for coming up with an importer given a pathname that's not yet
# in the cache.  The method should do a stat and/or look at the
# extension to decide which importer class to use; you can register new
# importer classes by registering a suffix or a Boolean function, plus a
# class.  If you register a new importer class, the cache is zapped.
# The cache is independent from sys.path (but maintained per
# ImportManager instance) so that rearrangements of sys.path do the
# right thing.  If a path is dropped from sys.path the corresponding
# cache entry is simply no longer used.
#
# My/Guido's comments on factoring ImportManager and Importer:
#
# &gt; However, we still have a tension occurring here:
# &gt;
# &gt; 1) implementing policy in ImportManager assists in single-point policy
# &gt;    changes for app/rexec situations
# &gt; 2) implementing policy in Importer assists in package-private policy
# &gt;    changes for normal, operating conditions
# &gt;
# &gt; I'll see if I can sort out a way to do this. Maybe the Importer class will
# &gt; implement the methods (which can be overridden to change policy) by
# &gt; delegating to ImportManager.
#
# Maybe also think about what kind of policies an Importer would be
# likely to want to change.  I have a feeling that a lot of the code
# there is actually not so much policy but a *necessity* to get things
# working given the calling conventions for the __import__ hook: whether
# to return the head or tail of a dotted name, or when to do the "finish
# fromlist" stuff.
#
</t>
<t tx="T2285"># note: avoid importing non-builtin modules
import imp                      ### not available in JPython?
import sys
import __builtin__

# for the DirectoryImporter
import struct
import marshal

__all__ = ["ImportManager","Importer","BuiltinImporter"]

_StringType = type('')
_ModuleType = type(sys)         ### doesn't work in JPython...

</t>
<t tx="T2286">class ImportManager:
	"Manage the import process."
	@others

</t>
<t tx="T2287">def install(self, namespace=vars(__builtin__)):
    "Install this ImportManager into the specified namespace."

    if isinstance(namespace, _ModuleType):
        namespace = vars(namespace)

    # Note: we have no notion of "chaining"

    # Record the previous import hook, then install our own.
    self.previous_importer = namespace['__import__']
    self.namespace = namespace
    namespace['__import__'] = self._import_hook

    ### fix this
    #namespace['reload'] = self._reload_hook

</t>
<t tx="T2288">def uninstall(self):
    "Restore the previous import mechanism."
    self.namespace['__import__'] = self.previous_importer
</t>
<t tx="T2289">def add_suffix(self, suffix, importFunc):
    assert callable(importFunc)
    self.fs_imp.add_suffix(suffix, importFunc)
</t>
<t tx="T2290">######################################################################
#
# PRIVATE METHODS
#

clsFilesystemImporter = None</t>
<t tx="T2291">def __init__(self, fs_imp=None):
    # we're definitely going to be importing something in the future,
    # so let's just load the OS-related facilities.
    if not _os_stat:
        _os_bootstrap()

    # This is the Importer that we use for grabbing stuff from the
    # filesystem. It defines one more method (import_from_dir) for our use.
    if not fs_imp:
        cls = self.clsFilesystemImporter or _FilesystemImporter
        fs_imp = cls()
    self.fs_imp = fs_imp

    # Initialize the set of suffixes that we recognize and import.
    # The default will import dynamic-load modules first, followed by
    # .py files (or a .py file's cached bytecode)
    for desc in imp.get_suffixes():
        if desc[2] == imp.C_EXTENSION:
            self.add_suffix(desc[0],
                            DynLoadSuffixImporter(desc).import_file)
    self.add_suffix('.py', py_suffix_importer)
</t>
<t tx="T2292">def _import_hook(self, fqname, globals=None, locals=None, fromlist=None):
    """Python calls this hook to locate and import a module."""

    parts = fqname.split('.')

    # determine the context of this import
    parent = self._determine_import_context(globals)

    # if there is a parent, then its importer should manage this import
    if parent:
        module = parent.__importer__._do_import(parent, parts, fromlist)
        if module:
            return module

    # has the top module already been imported?
    try:
        top_module = sys.modules[parts[0]]
    except KeyError:

        # look for the topmost module
        top_module = self._import_top_module(parts[0])
        if not top_module:
            # the topmost module wasn't found at all.
            raise ImportError, 'No module named ' + fqname

    # fast-path simple imports
    if len(parts) == 1:
        if not fromlist:
            return top_module

        if not top_module.__dict__.get('__ispkg__'):
            # __ispkg__ isn't defined (the module was not imported by us),
            # or it is zero.
            #
            # In the former case, there is no way that we could import
            # sub-modules that occur in the fromlist (but we can't raise an
            # error because it may just be names) because we don't know how
            # to deal with packages that were imported by other systems.
            #
            # In the latter case (__ispkg__ == 0), there can't be any sub-
            # modules present, so we can just return.
            #
            # In both cases, since len(parts) == 1, the top_module is also
            # the "bottom" which is the defined return when a fromlist
            # exists.
            return top_module

    importer = top_module.__dict__.get('__importer__')
    if importer:
        return importer._finish_import(top_module, parts[1:], fromlist)

    # Grrr, some people "import os.path"
    if len(parts) == 2 and hasattr(top_module, parts[1]):
        return top_module

    # If the importer does not exist, then we have to bail. A missing
    # importer means that something else imported the module, and we have
    # no knowledge of how to get sub-modules out of the thing.
    raise ImportError, 'No module named ' + fqname
</t>
<t tx="T2293">def _determine_import_context(self, globals):
    """Returns the context in which a module should be imported.

    The context could be a loaded (package) module and the imported module
    will be looked for within that package. The context could also be None,
    meaning there is no context -- the module should be looked for as a
    "top-level" module.
    """

    if not globals or not globals.get('__importer__'):
        # globals does not refer to one of our modules or packages. That
        # implies there is no relative import context (as far as we are
        # concerned), and it should just pick it off the standard path.
        return None

    # The globals refer to a module or package of ours. It will define
    # the context of the new import. Get the module/package fqname.
    parent_fqname = globals['__name__']

    # if a package is performing the import, then return itself (imports
    # refer to pkg contents)
    if globals['__ispkg__']:
        parent = sys.modules[parent_fqname]
        assert globals is parent.__dict__
        return parent

    i = parent_fqname.rfind('.')

    # a module outside of a package has no particular import context
    if i == -1:
        return None

    # if a module in a package is performing the import, then return the
    # package (imports refer to siblings)
    parent_fqname = parent_fqname[:i]
    parent = sys.modules[parent_fqname]
    assert parent.__name__ == parent_fqname
    return parent
</t>
<t tx="T2294">def _import_top_module(self, name):
    # scan sys.path looking for a location in the filesystem that contains
    # the module, or an Importer object that can import the module.
    for item in sys.path:
        if isinstance(item, _StringType):
            module = self.fs_imp.import_from_dir(item, name)
        else:
            module = item.import_top(name)
        if module:
            return module
    return None
</t>
<t tx="T2295">def _reload_hook(self, module):
    "Python calls this hook to reload a module."

    # reloading of a module may or may not be possible (depending on the
    # importer), but at least we can validate that it's ours to reload
    importer = module.__dict__.get('__importer__')
    if not importer:
        ### oops. now what...
        pass

    # okay. it is using the imputil system, and we must delegate it, but
    # we don't know what to do (yet)
    ### we should blast the module dict and do another get_code(). need to
    ### flesh this out and add proper docco...
    raise SystemError, "reload not yet implemented"
</t>
<t tx="T2296">class Importer:
	"Base class for replacing standard import functions."
	@others

</t>
<t tx="T2297">def import_top(self, name):
    "Import a top-level module."
    return self._import_one(None, name, name)
</t>
<t tx="T2298">######################################################################
#
# PRIVATE METHODS
#
def _finish_import(self, top, parts, fromlist):
    # if "a.b.c" was provided, then load the ".b.c" portion down from
    # below the top-level module.
    bottom = self._load_tail(top, parts)

    # if the form is "import a.b.c", then return "a"
    if not fromlist:
        # no fromlist: return the top of the import tree
        return top

    # the top module was imported by self.
    #
    # this means that the bottom module was also imported by self (just
    # now, or in the past and we fetched it from sys.modules).
    #
    # since we imported/handled the bottom module, this means that we can
    # also handle its fromlist (and reliably use __ispkg__).

    # if the bottom node is a package, then (potentially) import some
    # modules.
    #
    # note: if it is not a package, then "fromlist" refers to names in
    #       the bottom module rather than modules.
    # note: for a mix of names and modules in the fromlist, we will
    #       import all modules and insert those into the namespace of
    #       the package module. Python will pick up all fromlist names
    #       from the bottom (package) module; some will be modules that
    #       we imported and stored in the namespace, others are expected
    #       to be present already.
    if bottom.__ispkg__:
        self._import_fromlist(bottom, fromlist)

    # if the form is "from a.b import c, d" then return "b"
    return bottom
</t>
<t tx="T2299">def _import_one(self, parent, modname, fqname):
    "Import a single module."

    # has the module already been imported?
    try:
        return sys.modules[fqname]
    except KeyError:
        pass

    # load the module's code, or fetch the module itself
    result = self.get_code(parent, modname, fqname)
    if result is None:
        return None

    module = self._process_result(result, fqname)

    # insert the module into its parent
    if parent:
        setattr(parent, modname, module)
    return module
</t>
<t tx="T2300">def _process_result(self, (ispkg, code, values), fqname):
    # did get_code() return an actual module? (rather than a code object)
    is_module = isinstance(code, _ModuleType)

    # use the returned module, or create a new one to exec code into
    if is_module:
        module = code
    else:
        module = imp.new_module(fqname)

    ### record packages a bit differently??
    module.__importer__ = self
    module.__ispkg__ = ispkg

    # insert additional values into the module (before executing the code)
    module.__dict__.update(values)

    # the module is almost ready... make it visible
    sys.modules[fqname] = module

    # execute the code within the module's namespace
    if not is_module:
        exec code in module.__dict__

    # fetch from sys.modules instead of returning module directly.
    # also make module's __name__ agree with fqname, in case
    # the "exec code in module.__dict__" played games on us.
    module = sys.modules[fqname]
    module.__name__ = fqname
    return module
</t>
<t tx="T2301">def _load_tail(self, m, parts):
    """Import the rest of the modules, down from the top-level module.

    Returns the last module in the dotted list of modules.
    """
    for part in parts:
        fqname = "%s.%s" % (m.__name__, part)
        m = self._import_one(m, part, fqname)
        if not m:
            raise ImportError, "No module named " + fqname
    return m
</t>
<t tx="T2302">def _import_fromlist(self, package, fromlist):
    'Import any sub-modules in the "from" list.'

    # if '*' is present in the fromlist, then look for the '__all__'
    # variable to find additional items (modules) to import.
    if '*' in fromlist:
        fromlist = list(fromlist) + \
                   list(package.__dict__.get('__all__', []))

    for sub in fromlist:
        # if the name is already present, then don't try to import it (it
        # might not be a module!).
        if sub != '*' and not hasattr(package, sub):
            subname = "%s.%s" % (package.__name__, sub)
            submod = self._import_one(package, sub, subname)
            if not submod:
                raise ImportError, "cannot import name " + subname
</t>
<t tx="T2303">def _do_import(self, parent, parts, fromlist):
    """Attempt to import the module relative to parent.

    This method is used when the import context specifies that &lt;self&gt;
    imported the parent module.
    """
    top_name = parts[0]
    top_fqname = parent.__name__ + '.' + top_name
    top_module = self._import_one(parent, top_name, top_fqname)
    if not top_module:
        # this importer and parent could not find the module (relatively)
        return None

    return self._finish_import(top_module, parts[1:], fromlist)
</t>
<t tx="T2304">######################################################################
#
# METHODS TO OVERRIDE
#
def get_code(self, parent, modname, fqname):
    """Find and retrieve the code for the given module.

    parent specifies a parent module to define a context for importing. It
    may be None, indicating no particular context for the search.

    modname specifies a single module (not dotted) within the parent.

    fqname specifies the fully-qualified module name. This is a
    (potentially) dotted name from the "root" of the module namespace
    down to the modname.
    If there is no parent, then modname==fqname.

    This method should return None, or a 3-tuple.

    * If the module was not found, then None should be returned.

    * The first item of the 2- or 3-tuple should be the integer 0 or 1,
        specifying whether the module that was found is a package or not.

    * The second item is the code object for the module (it will be
        executed within the new module's namespace). This item can also
        be a fully-loaded module object (e.g. loaded from a shared lib).

    * The third item is a dictionary of name/value pairs that will be
        inserted into new module before the code object is executed. This
        is provided in case the module's code expects certain values (such
        as where the module was found). When the second item is a module
        object, then these names/values will be inserted *after* the module
        has been loaded/initialized.
    """
    raise RuntimeError, "get_code not implemented"
</t>
<t tx="T2305">######################################################################
#
# Some handy stuff for the Importers
#

# byte-compiled file suffix character
_suffix_char = __debug__ and 'c' or 'o'

# byte-compiled file suffix
_suffix = '.py' + _suffix_char

def _compile(pathname, timestamp):
    """Compile (and cache) a Python source file.

    The file specified by &lt;pathname&gt; is compiled to a code object and
    returned.

    Presuming the appropriate privileges exist, the bytecodes will be
    saved back to the filesystem for future imports. The source file's
    modification timestamp must be provided as a Long value.
    """
    codestring = open(pathname, 'r').read()
    if codestring and codestring[-1] != '\n':
        codestring = codestring + '\n'
    code = __builtin__.compile(codestring, pathname, 'exec')

    # try to cache the compiled code
    try:
        f = open(pathname + _suffix_char, 'wb')
    except IOError:
        pass
    else:
        f.write('\0\0\0\0')
        f.write(struct.pack('&lt;I', timestamp))
        marshal.dump(code, f)
        f.flush()
        f.seek(0, 0)
        f.write(imp.get_magic())
        f.close()

    return code
</t>
<t tx="T2306">_os_stat = _os_path_join = None

def _os_bootstrap():
    "Set up 'os' module replacement functions for use during import bootstrap."

    names = sys.builtin_module_names

    join = None
    if 'posix' in names:
        sep = '/'
        from posix import stat
    elif 'nt' in names:
        sep = '\\'
        from nt import stat
    elif 'dos' in names:
        sep = '\\'
        from dos import stat
    elif 'os2' in names:
        sep = '\\'
        from os2 import stat
    elif 'mac' in names:
        from mac import stat
        def join(a, b):
            if a == '':
                return b
            path = s
            if ':' not in a:
                a = ':' + a
            if a[-1:] != ':':
                a = a + ':'
            return a + b
    else:
        raise ImportError, 'no os specific module found'

    if join is None:
        def join(a, b, sep=sep):
            if a == '':
                return b
            lastchar = a[-1:]
            if lastchar == '/' or lastchar == sep:
                return a + b
            return a + sep + b

    global _os_stat
    _os_stat = stat

    global _os_path_join
    _os_path_join = join</t>
<t tx="T2307">def _os_path_isdir(pathname):
    "Local replacement for os.path.isdir()."
    try:
        s = _os_stat(pathname)
    except OSError:
        return None
    return (s[0] &amp; 0170000) == 0040000
</t>
<t tx="T2308">def _timestamp(pathname):
    "Return the file modification time as a Long."
    try:
        s = _os_stat(pathname)
    except OSError:
        return None
    return long(s[8])
</t>
<t tx="T2309"># Emulate the import mechanism for builtin and frozen modules

class BuiltinImporter(Importer):
	@others


</t>
<t tx="T2310">def get_code(self, parent, modname, fqname):
    if parent:
        # these modules definitely do not occur within a package context
        return None

    # look for the module
    if imp.is_builtin(modname):
        type = imp.C_BUILTIN
    elif imp.is_frozen(modname):
        type = imp.PY_FROZEN
    else:
        # not found
        return None

    # got it. now load and return it.
    module = imp.load_module(modname, None, modname, ('', '', type))
    return 0, module, { }
</t>
<t tx="T2311"># Internal importer used for importing from the filesystem

class _FilesystemImporter(Importer):
	@others


</t>
<t tx="T2312">def __init__(self):
    self.suffixes = [ ]
</t>
<t tx="T2313">def add_suffix(self, suffix, importFunc):
    assert callable(importFunc)
    self.suffixes.append((suffix, importFunc))
</t>
<t tx="T2314">def import_from_dir(self, dir, fqname):
    result = self._import_pathname(_os_path_join(dir, fqname), fqname)
    if result:
        return self._process_result(result, fqname)
    return None
</t>
<t tx="T2315">def get_code(self, parent, modname, fqname):
    # This importer is never used with an empty parent. Its existence is
    # private to the ImportManager. The ImportManager uses the
    # import_from_dir() method to import top-level modules/packages.
    # This method is only used when we look for a module within a package.
    assert parent

    return self._import_pathname(_os_path_join(parent.__pkgdir__, modname),
                                 fqname)
</t>
<t tx="T2316">def _import_pathname(self, pathname, fqname):
    if _os_path_isdir(pathname):
        result = self._import_pathname(_os_path_join(pathname, '__init__'),
                                       fqname)
        if result:
            values = result[2]
            values['__pkgdir__'] = pathname
            values['__path__'] = [ pathname ]
            return 1, result[1], values
        return None

    for suffix, importFunc in self.suffixes:
        filename = pathname + suffix
        try:
            finfo = _os_stat(filename)
        except OSError:
            pass
        else:
            return importFunc(filename, finfo, fqname)
    return None
</t>
<t tx="T2317"># SUFFIX-BASED IMPORTERS

def py_suffix_importer(filename, finfo, fqname):
    file = filename[:-3] + _suffix
    t_py = long(finfo[8])
    t_pyc = _timestamp(file)

    code = None
    if t_pyc is not None and t_pyc &gt;= t_py:
        f = open(file, 'rb')
        if f.read(4) == imp.get_magic():
            t = struct.unpack('&lt;I', f.read(4))[0]
            if t == t_py:
                code = marshal.load(f)
        f.close()
    if code is None:
        file = filename
        code = _compile(file, t_py)

    return 0, code, { '__file__' : file }
</t>
<t tx="T2318">class DynLoadSuffixImporter:
	@others

</t>
<t tx="T2319">def __init__(self, desc):
    self.desc = desc
</t>
<t tx="T2320">def import_file(self, filename, finfo, fqname):
    fp = open(filename, self.desc[1])
    module = imp.load_module(fqname, fp, filename, self.desc)
    module.__file__ = filename
    return 0, module, { }
</t>
<t tx="T2321">def _print_importers():
    items = sys.modules.items()
    items.sort()
    for name, module in items:
        if module:
            print name, module.__dict__.get('__importer__', '-- no importer')
        else:
            print name, '-- non-existent module'
</t>
<t tx="T2322">def _test_revamp():
    ImportManager().install()
    sys.path.insert(0, BuiltinImporter())
</t>
</tnodes>
</leo_file>
