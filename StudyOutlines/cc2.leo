<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="16" left="110" height="875" width="975"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20080529093004.2" str_leo_pos="1"><vh>@chapters</vh></v>
<v t="ekr.20080529093004.3" a="E"><vh>The Tuple compiler, assembler, linker &amp; loader</vh>
<v t="ekr.20080529093004.4"><vh>Scripts used to create and munge this file</vh>
<v t="ekr.20080529093004.5"><vh>Import all files of a given extension from a directory</vh></v>
<v t="ekr.20080529093004.6"><vh>Remove starting newlines</vh></v>
</v>
<v t="ekr.20080529093004.7"><vh>As</vh>
<v t="ekr.20080529093004.8"><vh>General headers</vh>
<v t="ekr.20080529093004.9"><vh>@@file AS.h</vh></v>
<v t="ekr.20080529093004.10"><vh>@@file AStypes.h</vh></v>
<v t="ekr.20080529093004.11"><vh>@@file AStarget.h</vh></v>
</v>
<v t="ekr.20080529093004.12"><vh>Assembler</vh>
<v t="ekr.20080529093004.13"><vh>headers</vh>
<v t="ekr.20080529093004.14"><vh>@@file ASasm.h</vh></v>
<v t="ekr.20080529093004.15"><vh>@@file ASdisasm.h</vh></v>
<v t="ekr.20080529093004.16"><vh>@@file ASexp.h</vh></v>
<v t="ekr.20080529093004.17"><vh>@@file ASfold.h</vh></v>
<v t="ekr.20080529093004.18"><vh>@@file ASofile.h</vh></v>
<v t="ekr.20080529093004.19"><vh>@@file ASparse.h</vh></v>
<v t="ekr.20080529093004.20"><vh>@@file ASpass12.h</vh></v>
<v t="ekr.20080529093004.21"><vh>@@file ASpseudo.h</vh></v>
<v t="ekr.20080529093004.22"><vh>@@file ASsem.h</vh></v>
</v>
<v t="ekr.20080529093004.23"><vh>code</vh>
<v t="ekr.20080529093004.24"><vh>@@file ASasm.c</vh>
<v t="ekr.20080529093004.25"><vh>&lt;&lt; ASasm #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.26"><vh>&lt;&lt; ASasm declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.27"><vh>assemble</vh></v>
<v t="ekr.20080529093004.28"><vh>asm_bad_bits_error</vh></v>
<v t="ekr.20080529093004.29"><vh>ea_bits</vh></v>
<v t="ekr.20080529093004.30"><vh>ea_val</vh></v>
<v t="ekr.20080529093004.31"><vh>err_match_len</vh></v>
<v t="ekr.20080529093004.32"><vh>match</vh></v>
<v t="ekr.20080529093004.33"><vh>match_len</vh></v>
<v t="ekr.20080529093004.34"><vh>op0af</vh></v>
<v t="ekr.20080529093004.35"><vh>op1af</vh></v>
<v t="ekr.20080529093004.36"><vh>op2af</vh></v>
<v t="ekr.20080529093004.37"><vh>op2afx</vh></v>
<v t="ekr.20080529093004.38"><vh>op3af</vh></v>
<v t="ekr.20080529093004.39"><vh>reg_to_reglist</vh></v>
</v>
<v t="ekr.20080529093004.40"><vh>@@file ASdisasm.c</vh>
<v t="ekr.20080529093004.41"><vh>&lt;&lt; ASdisasm #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.42"><vh>&lt;&lt; ASdisasm declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.43"><vh>disassemble</vh></v>
<v t="ekr.20080529093004.44"><vh>op0df</vh></v>
<v t="ekr.20080529093004.45"><vh>op1df</vh></v>
<v t="ekr.20080529093004.46"><vh>op2df</vh></v>
<v t="ekr.20080529093004.47"><vh>op3df</vh></v>
<v t="ekr.20080529093004.48"><vh>op4df</vh></v>
<v t="ekr.20080529093004.49"><vh>opcc0df</vh></v>
<v t="ekr.20080529093004.50"><vh>opcc1df</vh></v>
<v t="ekr.20080529093004.51"><vh>opcc2df</vh></v>
</v>
<v t="ekr.20080529093004.52"><vh>@@file ASexp.c</vh>
<v t="ekr.20080529093004.53"><vh>&lt;&lt; ASexp #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.54"><vh>&lt;&lt; ASexp declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.55"><vh>eenode</vh></v>
<v t="ekr.20080529093004.56"><vh>eval_string</vh></v>
<v t="ekr.20080529093004.57"><vh>expr_apply</vh></v>
<v t="ekr.20080529093004.58"><vh>expr_check</vh></v>
<v t="ekr.20080529093004.59"><vh>expr_check_subtree</vh></v>
<v t="ekr.20080529093004.60"><vh>expr_dump_op_stack</vh></v>
<v t="ekr.20080529093004.61"><vh>expr_get_val</vh></v>
<v t="ekr.20080529093004.62"><vh>expr_prec</vh></v>
<v t="ekr.20080529093004.63"><vh>expr_prim</vh></v>
<v t="ekr.20080529093004.64"><vh>expr_too_complex</vh></v>
<v t="ekr.20080529093004.65"><vh>expr_value</vh></v>
</v>
<v t="ekr.20080529093004.66"><vh>@@file ASfold.c</vh>
<v t="ekr.20080529093004.67"><vh>&lt;&lt; ASfold #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.68"><vh>fold1</vh></v>
<v t="ekr.20080529093004.69"><vh>fold2</vh></v>
</v>
<v t="ekr.20080529093004.70"><vh>@@file ASofile.c</vh>
<v t="ekr.20080529093004.71"><vh>&lt;&lt; ASofile #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.72"><vh>&lt;&lt; ASofile declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.73"><vh>dump_area</vh></v>
<v t="ekr.20080529093004.74"><vh>dump_comment</vh></v>
<v t="ekr.20080529093004.75"><vh>dump_dict</vh></v>
<v t="ekr.20080529093004.76"><vh>dump_ref</vh></v>
<v t="ekr.20080529093004.77"><vh>dump_unit</vh></v>
<v t="ekr.20080529093004.78"><vh>out_area</vh></v>
<v t="ekr.20080529093004.79"><vh>out_area_size</vh></v>
<v t="ekr.20080529093004.80"><vh>out_area_bytes</vh></v>
<v t="ekr.20080529093004.81"><vh>out_area_bytes_size</vh></v>
<v t="ekr.20080529093004.82"><vh>out_comments</vh></v>
<v t="ekr.20080529093004.83"><vh>out_comments_size</vh></v>
<v t="ekr.20080529093004.84"><vh>out_dict</vh></v>
<v t="ekr.20080529093004.85"><vh>out_dict_size</vh></v>
<v t="ekr.20080529093004.86"><vh>out_header</vh></v>
<v t="ekr.20080529093004.87"><vh>out_ofile</vh></v>
<v t="ekr.20080529093004.88"><vh>out_refs</vh></v>
<v t="ekr.20080529093004.89"><vh>out_ref_size</vh></v>
<v t="ekr.20080529093004.90"><vh>out_trailer</vh></v>
<v t="ekr.20080529093004.91"><vh>out_unit</vh></v>
</v>
<v t="ekr.20080529093004.92"><vh>@@file ASparse.c</vh>
<v t="ekr.20080529093004.93"><vh>&lt;&lt; ASparse #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.94"><vh>&lt;&lt; ASparse declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.95"><vh>par_am</vh></v>
<v t="ekr.20080529093004.96"><vh>prefix_eq</vh></v>
<v t="ekr.20080529093004.97"><vh>par_comment</vh></v>
<v t="ekr.20080529093004.98"><vh>par_next_line</vh></v>
<v t="ekr.20080529093004.99"><vh>par_program</vh></v>
<v t="ekr.20080529093004.100"><vh>par_reglist</vh></v>
<v t="ekr.20080529093004.101"><vh>par_size</vh></v>
<v t="ekr.20080529093004.102"><vh>par_xtok</vh></v>
</v>
<v t="ekr.20080529093004.103"><vh>@@file ASpass12.c</vh>
<v t="ekr.20080529093004.104"><vh>&lt;&lt; ASpass12 #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.105"><vh>check_compress</vh></v>
<v t="ekr.20080529093004.106"><vh>compress</vh></v>
</v>
<v t="ekr.20080529093004.107"><vh>@@file ASpseudo.c</vh>
<v t="ekr.20080529093004.108"><vh>&lt;&lt; ASpseudo #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.109"><vh>&lt;&lt; ASpseudo declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.110"><vh>align</vh></v>
<v t="ekr.20080529093004.111"><vh>pseudo</vh></v>
</v>
<v t="ekr.20080529093004.112"><vh>@@file ASsem.c</vh>
<v t="ekr.20080529093004.113"><vh>&lt;&lt; ASsem #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.114"><vh>&lt;&lt; ASsem declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.115"><vh>sem_begin</vh></v>
<v t="ekr.20080529093004.116"><vh>sem_define_label</vh></v>
<v t="ekr.20080529093004.117"><vh>sem_do_offset</vh></v>
<v t="ekr.20080529093004.118"><vh>sem_end</vh></v>
<v t="ekr.20080529093004.119"><vh>sem_make_cnode_refs</vh></v>
<v t="ekr.20080529093004.120"><vh>sem_make_enode_refs</vh></v>
<v t="ekr.20080529093004.121"><vh>sem_make_ref_node</vh></v>
<v t="ekr.20080529093004.122"><vh>sem_reference_label</vh></v>
<v t="ekr.20080529093004.123"><vh>sem_see_label</vh></v>
<v t="ekr.20080529093004.124"><vh>sem_update_labels</vh></v>
</v>
</v>
</v>
<v t="ekr.20080529093004.125"><vh>Driver</vh>
<v t="ekr.20080529093004.126"><vh>Headers</vh>
<v t="ekr.20080529093004.127"><vh>@@file ASarg.h</vh></v>
<v t="ekr.20080529093004.128"><vh>@@file ASinit.h</vh></v>
<v t="ekr.20080529093004.129"><vh>@@file ASmain.h</vh></v>
</v>
<v t="ekr.20080529093004.130"><vh>Code</vh>
<v t="ekr.20080529093004.131"><vh>@@file ASarg.c</vh>
<v t="ekr.20080529093004.132"><vh>&lt;&lt; ASarg #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.133"><vh>&lt;&lt; ASarg declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.134"><vh>arg_do_argv</vh></v>
<v t="ekr.20080529093004.135"><vh>arg_help</vh></v>
<v t="ekr.20080529093004.136"><vh>arg_prefix</vh></v>
</v>
<v t="ekr.20080529093004.137"><vh>@@file ASinit.c</vh>
<v t="ekr.20080529093004.138"><vh>&lt;&lt; ASinit #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.139"><vh>&lt;&lt; ASinit declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.140"><vh>init_all</vh></v>
<v t="ekr.20080529093004.141"><vh>event_call_back</vh></v>
<v t="ekr.20080529093004.142"><vh>dump1_call_back</vh></v>
<v t="ekr.20080529093004.143"><vh>dump2_call_back</vh></v>
<v t="ekr.20080529093004.144"><vh>dump3_call_back</vh></v>
</v>
<v t="ekr.20080529093004.145"><vh>@@file ASmain.c</vh>
<v t="ekr.20080529093004.146"><vh>&lt;&lt; ASmain #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.147"><vh>&lt;&lt; ASmain declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.148"><vh>main</vh></v>
<v t="ekr.20080529093004.149"><vh>main_asm</vh></v>
<v t="ekr.20080529093004.150"><vh>main_dump_block</vh></v>
<v t="ekr.20080529093004.151"><vh>main_free_all</vh></v>
<v t="ekr.20080529093004.152"><vh>main_listing</vh></v>
<v t="ekr.20080529093004.153"><vh>list_onl</vh></v>
<v t="ekr.20080529093004.154"><vh>main_output</vh></v>
<v t="ekr.20080529093004.155"><vh>main_quit</vh></v>
<v t="ekr.20080529093004.156"><vh>main_report</vh></v>
</v>
</v>
</v>
<v t="ekr.20080529093004.157"><vh>Library &amp; utils</vh>
<v t="ekr.20080529093004.158"><vh>Header</vh>
<v t="ekr.20080529093004.159"><vh>@@file ASend.h</vh></v>
<v t="ekr.20080529093004.160"><vh>@@file ASerr.h</vh></v>
<v t="ekr.20080529093004.161"><vh>@@file ASes.h</vh></v>
<v t="ekr.20080529093004.162"><vh>@@file ASmem.h</vh></v>
</v>
<v t="ekr.20080529093004.163"><vh>Code</vh>
<v t="ekr.20080529093004.164"><vh>@@file ASend.c</vh>
<v t="ekr.20080529093004.165"><vh>&lt;&lt; ASend #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.166"><vh>end_close_all</vh></v>
</v>
<v t="ekr.20080529093004.167"><vh>@@file ASerr.c</vh>
<v t="ekr.20080529093004.168"><vh>&lt;&lt; ASerr #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.169"><vh>&lt;&lt; ASerr declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.170"><vh>err_init_again</vh></v>
<v t="ekr.20080529093004.171"><vh>err_begin_file</vh></v>
<v t="ekr.20080529093004.172"><vh>err_begin_func</vh></v>
<v t="ekr.20080529093004.173"><vh>err_begin_mess</vh></v>
<v t="ekr.20080529093004.174"><vh>err_context</vh></v>
<v t="ekr.20080529093004.175"><vh>err_lines</vh></v>
<v t="ekr.20080529093004.176"><vh>err_file_name</vh></v>
<v t="ekr.20080529093004.177"><vh>err_begin</vh></v>
<v t="ekr.20080529093004.178"><vh>fatal_begin</vh></v>
<v t="ekr.20080529093004.179"><vh>fatal_end</vh></v>
<v t="ekr.20080529093004.180"><vh>help_begin</vh></v>
<v t="ekr.20080529093004.181"><vh>user_fatal_begin</vh></v>
<v t="ekr.20080529093004.182"><vh>user_fatal_end</vh></v>
<v t="ekr.20080529093004.183"><vh>warn_begin</vh></v>
</v>
<v t="ekr.20080529093004.184"><vh>@@file ASes.c</vh>
<v t="ekr.20080529093004.185"><vh>&lt;&lt; ASes #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.186"><vh>&lt;&lt; ASes declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.187"><vh>es</vh></v>
</v>
<v t="ekr.20080529093004.188"><vh>@@file ASlib.c</vh>
<v t="ekr.20080529093004.189"><vh>&lt;&lt; ASlib #includes &gt;&gt;</vh></v>
</v>
<v t="ekr.20080529093004.190"><vh>@@file ASmem.c</vh>
<v t="ekr.20080529093004.191"><vh>&lt;&lt; ASmem #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.192"><vh>&lt;&lt; ASmem declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.193"><vh>mem_str_copy</vh></v>
<v t="ekr.20080529093004.194"><vh>mem_new_tok_block</vh></v>
</v>
</v>
</v>
<v t="ekr.20080529093004.195"><vh>Macros</vh>
<v t="ekr.20080529093004.196"><vh>Headers</vh>
<v t="ekr.20080529093004.197"><vh>@@file AScpp.h</vh></v>
<v t="ekr.20080529093004.198"><vh>@@file ASmacro.h</vh></v>
<v t="ekr.20080529093004.199"><vh>@@file ASmst.h</vh></v>
</v>
<v t="ekr.20080529093004.200"><vh>Code</vh>
<v t="ekr.20080529093004.201"><vh>@@file AScpp.c</vh>
<v t="ekr.20080529093004.202"><vh>&lt;&lt; AScpp #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.203"><vh>&lt;&lt; AScpp declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.204"><vh>char_val</vh></v>
<v t="ekr.20080529093004.205"><vh>cpp</vh></v>
<v t="ekr.20080529093004.206"><vh>cpp_elif</vh></v>
<v t="ekr.20080529093004.207"><vh>cpp_else</vh></v>
<v t="ekr.20080529093004.208"><vh>cpp_endif</vh></v>
<v t="ekr.20080529093004.209"><vh>cpp_error</vh></v>
<v t="ekr.20080529093004.210"><vh>cpp_if</vh></v>
<v t="ekr.20080529093004.211"><vh>cpp_ifdef</vh></v>
<v t="ekr.20080529093004.212"><vh>cpp_include</vh></v>
<v t="ekr.20080529093004.213"><vh>cpp_incl2</vh></v>
<v t="ekr.20080529093004.214"><vh>cpp_inhibit</vh></v>
<v t="ekr.20080529093004.215"><vh>cpp_line</vh></v>
<v t="ekr.20080529093004.216"><vh>cpp_pragma</vh></v>
<v t="ekr.20080529093004.217"><vh>cpp_undef</vh></v>
<v t="ekr.20080529093004.218"><vh>eval</vh></v>
<v t="ekr.20080529093004.219"><vh>gt_prec</vh></v>
<v t="ekr.20080529093004.220"><vh>prec</vh></v>
<v t="ekr.20080529093004.221"><vh>push_op</vh></v>
<v t="ekr.20080529093004.222"><vh>pop_op</vh></v>
<v t="ekr.20080529093004.223"><vh>push_val</vh></v>
<v t="ekr.20080529093004.224"><vh>pop_val</vh></v>
<v t="ekr.20080529093004.225"><vh>skip_lines</vh></v>
<v t="ekr.20080529093004.226"><vh>skip_past</vh></v>
<v t="ekr.20080529093004.227"><vh>skip_pp</vh></v>
</v>
<v t="ekr.20080529093004.228"><vh>@@file ASmacro.c</vh>
<v t="ekr.20080529093004.229"><vh>&lt;&lt; ASmacro #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.230"><vh>&lt;&lt; ASmacro declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.231"><vh>mac_compare_fargs</vh></v>
<v t="ekr.20080529093004.232"><vh>mac_compare_rtexts</vh></v>
<v t="ekr.20080529093004.233"><vh>mac_define</vh></v>
<v t="ekr.20080529093004.234"><vh>mac_define_string</vh></v>
<v t="ekr.20080529093004.235"><vh>mac_expand</vh></v>
<v t="ekr.20080529093004.236"><vh>mac_expand_arg</vh></v>
<v t="ekr.20080529093004.237"><vh>mac_get_actuals</vh></v>
<v t="ekr.20080529093004.238"><vh>mac_get_formals</vh></v>
<v t="ekr.20080529093004.239"><vh>mac_outer_expand</vh></v>
<v t="ekr.20080529093004.240"><vh>mac_parse_actuals</vh></v>
<v t="ekr.20080529093004.241"><vh>mac_parse_formals</vh></v>
<v t="ekr.20080529093004.242"><vh>mac_paste_tokens</vh></v>
<v t="ekr.20080529093004.243"><vh>mac_rescan</vh></v>
<v t="ekr.20080529093004.244"><vh>mac_special</vh></v>
<v t="ekr.20080529093004.245"><vh>mac_stringize</vh></v>
<v t="ekr.20080529093004.246"><vh>mac_substitute</vh></v>
</v>
<v t="ekr.20080529093004.247"><vh>@@file ASmst.c</vh>
<v t="ekr.20080529093004.248"><vh>&lt;&lt; ASmst #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.249"><vh>&lt;&lt; ASmst declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.250"><vh>mst_dump_all</vh></v>
<v t="ekr.20080529093004.251"><vh>mst_dump_mdef</vh></v>
<v t="ekr.20080529093004.252"><vh>mst_init</vh></v>
<v t="ekr.20080529093004.253"><vh>mst_init_again</vh></v>
<v t="ekr.20080529093004.254"><vh>mst_init_define</vh></v>
<v t="ekr.20080529093004.255"><vh>mst_init_undef</vh></v>
<v t="ekr.20080529093004.256"><vh>mst_is_undef</vh></v>
<v t="ekr.20080529093004.257"><vh>mst_pre_define</vh></v>
<v t="ekr.20080529093004.258"><vh>mst_show</vh></v>
</v>
</v>
</v>
<v t="ekr.20080529093004.259"><vh>Tokens, types &amp; nodes</vh>
<v t="ekr.20080529093004.260"><vh>Headers</vh>
<v t="ekr.20080529093004.261"><vh>@@file ASanodes.h</vh></v>
<v t="ekr.20080529093004.262"><vh>@@file AScnodes.h</vh></v>
<v t="ekr.20080529093004.263"><vh>@@file AStokens.h</vh></v>
<v t="ekr.20080529093004.264"><vh>@@file AStokize.h</vh></v>
</v>
<v t="ekr.20080529093004.265"><vh>Code</vh>
<v t="ekr.20080529093004.266"><vh>@@file ASanodes.c</vh>
<v t="ekr.20080529093004.267"><vh>&lt;&lt; ASanodes #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.268"><vh>eanode</vh></v>
<v t="ekr.20080529093004.269"><vh>eanode_bits</vh></v>
<v t="ekr.20080529093004.270"><vh>oanode_bits</vh></v>
</v>
<v t="ekr.20080529093004.271"><vh>@@file AScnodes.c</vh>
<v t="ekr.20080529093004.272"><vh>&lt;&lt; AScnodes #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.273"><vh>&lt;&lt; AScnodes declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.274"><vh>cnode_app_size</vh></v>
<v t="ekr.20080529093004.275"><vh>cnode_strlen</vh></v>
<v t="ekr.20080529093004.276"><vh>ecnode</vh></v>
<v t="ekr.20080529093004.277"><vh>ecnode_bits</vh></v>
<v t="ekr.20080529093004.278"><vh>ecinode</vh></v>
<v t="ekr.20080529093004.279"><vh>ocnode_bits</vh></v>
<v t="ekr.20080529093004.280"><vh>out_cnode</vh></v>
</v>
<v t="ekr.20080529093004.281"><vh>@@file AStokens.c</vh>
<v t="ekr.20080529093004.282"><vh>&lt;&lt; AStokens #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.283"><vh>&lt;&lt; AStokens declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.284"><vh>etok</vh></v>
<v t="ekr.20080529093004.285"><vh>etoknum</vh></v>
<v t="ekr.20080529093004.286"><vh>tok_check</vh></v>
<v t="ekr.20080529093004.287"><vh>tok_dump</vh></v>
<v t="ekr.20080529093004.288"><vh>tok_dump_delim</vh></v>
<v t="ekr.20080529093004.289"><vh>tok_dump_delim2</vh></v>
<v t="ekr.20080529093004.290"><vh>tok_dump_line</vh></v>
<v t="ekr.20080529093004.291"><vh>tok_dump_line2</vh></v>
<v t="ekr.20080529093004.292"><vh>tok_dump_list</vh></v>
<v t="ekr.20080529093004.293"><vh>tok_dump_list2</vh></v>
<v t="ekr.20080529093004.294"><vh>tok_dump1</vh></v>
<v t="ekr.20080529093004.295"><vh>tok_copy</vh></v>
<v t="ekr.20080529093004.296"><vh>tok_copy_list</vh></v>
<v t="ekr.20080529093004.297"><vh>tok_copy2nl</vh></v>
<v t="ekr.20080529093004.298"><vh>tok_ignore</vh></v>
<v t="ekr.20080529093004.299"><vh>tok_next_</vh></v>
<v t="ekr.20080529093004.300"><vh>tok_next_raw</vh></v>
<v t="ekr.20080529093004.301"><vh>tok_out_line</vh></v>
<v t="ekr.20080529093004.302"><vh>tok_out</vh></v>
<v t="ekr.20080529093004.303"><vh>tok_par_next_skip_ws</vh></v>
<v t="ekr.20080529093004.304"><vh>tok_par_next</vh></v>
<v t="ekr.20080529093004.305"><vh>tok_patch</vh></v>
<v t="ekr.20080529093004.306"><vh>tok_scan</vh></v>
<v t="ekr.20080529093004.307"><vh>tok_scan_file</vh></v>
<v t="ekr.20080529093004.308"><vh>tok_scan_line</vh></v>
<v t="ekr.20080529093004.309"><vh>tok_skip_hidden</vh></v>
<v t="ekr.20080529093004.310"><vh>tok_2string</vh></v>
<v t="ekr.20080529093004.311"><vh>tok_skip_ws</vh></v>
</v>
<v t="ekr.20080529093004.312"><vh>@@file AStokize.c</vh>
<v t="ekr.20080529093004.313"><vh>&lt;&lt; AStokize #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.314"><vh>&lt;&lt; AStokize declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.315"><vh>tokize</vh></v>
<v t="ekr.20080529093004.316"><vh>stats1</vh></v>
<v t="ekr.20080529093004.317"><vh>tok_dump_speed</vh></v>
<v t="ekr.20080529093004.318"><vh>tok_dump_stats</vh></v>
<v t="ekr.20080529093004.319"><vh>tok_init_hash_tab</vh></v>
<v t="ekr.20080529093004.320"><vh>tok_enter</vh></v>
<v t="ekr.20080529093004.321"><vh>tok_lookup</vh></v>
<v t="ekr.20080529093004.322"><vh>tok_hash</vh></v>
<v t="ekr.20080529093004.323"><vh>tok_lookup_hash</vh></v>
<v t="ekr.20080529093004.324"><vh>tok_reinit_stats</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20080529093004.325"><vh>CC2</vh>
<v t="ekr.20080529093004.326" a="M"><vh>Documentation</vh>
<v t="ekr.20080529093004.327"><vh>General documentation</vh>
<v t="ekr.20080529093004.328"><vh>About CC2</vh></v>
<v t="ekr.20080529093004.329"><vh>Almost everything I know about optimizing compilers</vh>
<v t="ekr.20080529093004.330"><vh>Memory Management</vh></v>
<v t="ekr.20080529093004.331"><vh>Optimizing is NP hard, and that (sometimes) matters</vh></v>
<v t="ekr.20080529093004.332"><vh>Optimizing is often too _easy_</vh></v>
<v t="ekr.20080529093004.333"><vh>Peephole optimizers can do almost all non-global optimizations</vh></v>
<v t="ekr.20080529093004.334"><vh>Creating complex data structures is "cheap" and pays off</vh></v>
<v t="ekr.20080529093004.335"><vh>Many parts of an optimizing compiler should be target-independent</vh></v>
<v t="ekr.20080529093004.336"><vh>Register allocation should be a separate phase</vh></v>
<v t="ekr.20080529093004.337"><vh>Retargeting is non-trivial</vh></v>
</v>
<v t="ekr.20080529093004.338"><vh>Storage allocation</vh></v>
<v t="ekr.20080529093004.339"><vh>Notes to myself</vh>
<v t="ekr.20080529093004.340"><vh>Breakthrough discovered while programming</vh></v>
<v t="ekr.20080529093004.341"><vh>About descriptive programming</vh></v>
<v t="ekr.20080529093004.342"><vh>Ahas</vh></v>
<v t="ekr.20080529093004.343"><vh>Notes on literate programming (very old)</vh></v>
</v>
</v>
<v t="ekr.20080529093004.344"><vh>The front end</vh>
<v t="ekr.20080529093004.345"><vh>The front end</vh></v>
<v t="ekr.20080529093004.346"><vh>About the front end</vh></v>
<v t="ekr.20080529093004.347"><vh>All about tokens</vh></v>
<v t="ekr.20080529093004.348"><vh>Tokenizing the input file</vh></v>
<v t="ekr.20080529093004.349"><vh>Macro expansion</vh></v>
<v t="ekr.20080529093004.350"><vh>The C preprocessor</vh></v>
<v t="ekr.20080529093004.351"><vh>Error handling and debugging</vh></v>
<v t="ekr.20080529093004.352"><vh>About lists</vh></v>
<v t="ekr.20080529093004.353"><vh>User options</vh></v>
</v>
<v t="ekr.20080529093004.354"><vh>About the parser</vh>
<v t="ekr.20080529093004.355"><vh>Overview of data structures</vh></v>
<v t="ekr.20080529093004.356"><vh>Storage allocation</vh></v>
<v t="ekr.20080529093004.357"><vh>The statement parser</vh></v>
<v t="ekr.20080529093004.358"><vh>The expression parser</vh></v>
<v t="ekr.20080529093004.359"><vh>The declaration parser</vh>
<v t="ekr.20080529093004.360"><vh>Representing types with tnodes</vh></v>
<v t="ekr.20080529093004.361"><vh>Representing objects and user types with snodes</vh></v>
</v>
<v t="ekr.20080529093004.362"><vh>Reporting delayed errors</vh></v>
</v>
<v t="ekr.20080529093004.363"><vh>The back end</vh>
<v t="ekr.20080529093004.364"><vh>The back end</vh></v>
<v t="ekr.20080529093004.365"><vh>Code generators: Theory of operation</vh></v>
<v t="ekr.20080529093004.366"><vh>Design of the code generators</vh></v>
<v t="ekr.20080529093004.367"><vh>How CC2 generates code</vh></v>
</v>
<v t="ekr.20080529093004.368"><vh>About library and utility routines</vh></v>
</v>
<v t="ekr.20080529093004.369"><vh>General headers</vh>
<v t="ekr.20080529093004.370"><vh>@@file CC.h</vh></v>
<v t="ekr.20080529093004.371"><vh>@@file CCnodes.h</vh></v>
<v t="ekr.20080529093004.372"><vh>@@file CCtypes.h</vh></v>
<v t="ekr.20080529093004.373"><vh>@@file CCver.h</vh></v>
</v>
<v t="ekr.20080529093004.374"><vh>Tokens &amp; preprocessor</vh>
<v t="ekr.20080529093004.375"><vh>Documentation</vh>
<v t="ekr.20080529093004.345"><vh>The front end</vh></v>
<v t="ekr.20080529093004.346"><vh>About the front end</vh></v>
<v t="ekr.20080529093004.347"><vh>All about tokens</vh></v>
<v t="ekr.20080529093004.348"><vh>Tokenizing the input file</vh></v>
<v t="ekr.20080529093004.350"><vh>The C preprocessor</vh></v>
<v t="ekr.20080529093004.349"><vh>Macro expansion</vh></v>
<v t="ekr.20080529093004.351"><vh>Error handling and debugging</vh></v>
<v t="ekr.20080529093004.352"><vh>About lists</vh></v>
</v>
<v t="ekr.20080529093004.376"><vh>Headers</vh>
<v t="ekr.20080529093004.377"><vh>@@file CCcpp.h</vh></v>
<v t="ekr.20080529093004.378"><vh>@@file CCmacro.h</vh></v>
<v t="ekr.20080529093004.379"><vh>@@file CCmst.h</vh></v>
<v t="ekr.20080529093004.380"><vh>@@file CCpass12.h</vh></v>
<v t="ekr.20080529093004.381"><vh>@@file CCtarget.h</vh></v>
<v t="ekr.20080529093004.382"><vh>@@file CCtokens.h</vh></v>
<v t="ekr.20080529093004.383"><vh>@@file CCtokize.h</vh></v>
</v>
<v t="ekr.20080529093004.384"><vh>Code</vh>
<v t="ekr.20080529093004.385"><vh>@@file CCcpp.c</vh>
<v t="ekr.20080529093004.386"><vh>&lt;&lt; CCcpp #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.387"><vh>&lt;&lt; CCcpp declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.388"><vh>char_val</vh></v>
<v t="ekr.20080529093004.389"><vh>cpp</vh></v>
<v t="ekr.20080529093004.390"><vh>cpp_elif</vh></v>
<v t="ekr.20080529093004.391"><vh>cpp_else</vh></v>
<v t="ekr.20080529093004.392"><vh>cpp_endif</vh></v>
<v t="ekr.20080529093004.393"><vh>cpp_error</vh></v>
<v t="ekr.20080529093004.394"><vh>cpp_if</vh></v>
<v t="ekr.20080529093004.395"><vh>cpp_ifdef</vh></v>
<v t="ekr.20080529093004.396"><vh>cpp_include</vh></v>
<v t="ekr.20080529093004.397"><vh>cpp_incl2</vh></v>
<v t="ekr.20080529093004.398"><vh>cpp_inhibit</vh></v>
<v t="ekr.20080529093004.399"><vh>cpp_line</vh></v>
<v t="ekr.20080529093004.400"><vh>cpp_pragma</vh></v>
<v t="ekr.20080529093004.401"><vh>cpp_undef</vh></v>
<v t="ekr.20080529093004.402"><vh>eval</vh></v>
<v t="ekr.20080529093004.403"><vh>gt_prec</vh></v>
<v t="ekr.20080529093004.404"><vh>prec</vh></v>
<v t="ekr.20080529093004.405"><vh>push_op</vh></v>
<v t="ekr.20080529093004.406"><vh>pop_op</vh></v>
<v t="ekr.20080529093004.407"><vh>push_val</vh></v>
<v t="ekr.20080529093004.408"><vh>pop_val</vh></v>
<v t="ekr.20080529093004.409"><vh>skip_lines</vh></v>
<v t="ekr.20080529093004.410"><vh>skip_past</vh></v>
<v t="ekr.20080529093004.411"><vh>skip_pp</vh></v>
</v>
<v t="ekr.20080529093004.412"><vh>@@file CCmacro.c</vh>
<v t="ekr.20080529093004.413"><vh>&lt;&lt; CCmacro #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.414"><vh>&lt;&lt; CCmacro declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.415"><vh>mac_compare_fargs</vh></v>
<v t="ekr.20080529093004.416"><vh>mac_compare_rtexts</vh></v>
<v t="ekr.20080529093004.417"><vh>mac_define</vh></v>
<v t="ekr.20080529093004.418"><vh>mac_define_string</vh></v>
<v t="ekr.20080529093004.419"><vh>mac_expand</vh></v>
<v t="ekr.20080529093004.420"><vh>mac_expand_arg</vh></v>
<v t="ekr.20080529093004.421"><vh>mac_get_actuals</vh></v>
<v t="ekr.20080529093004.422"><vh>mac_get_formals</vh></v>
<v t="ekr.20080529093004.423"><vh>mac_outer_expand</vh></v>
<v t="ekr.20080529093004.424"><vh>mac_parse_actuals</vh></v>
<v t="ekr.20080529093004.425"><vh>mac_parse_formals</vh></v>
<v t="ekr.20080529093004.426"><vh>mac_paste_tokens</vh></v>
<v t="ekr.20080529093004.427"><vh>mac_rescan</vh></v>
<v t="ekr.20080529093004.428"><vh>mac_special</vh></v>
<v t="ekr.20080529093004.429"><vh>mac_stringize</vh></v>
<v t="ekr.20080529093004.430"><vh>mac_substitute</vh></v>
</v>
<v t="ekr.20080529093004.431"><vh>@@file CCmst.c</vh>
<v t="ekr.20080529093004.432"><vh>&lt;&lt; CCmst #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.433"><vh>&lt;&lt; CCmst declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.434"><vh>mst_dump_all</vh></v>
<v t="ekr.20080529093004.435"><vh>mst_dump_mdef</vh></v>
<v t="ekr.20080529093004.436"><vh>mst_init</vh></v>
<v t="ekr.20080529093004.437"><vh>mst_init_again</vh></v>
<v t="ekr.20080529093004.438"><vh>mst_init_define</vh></v>
<v t="ekr.20080529093004.439"><vh>mst_init_undef</vh></v>
<v t="ekr.20080529093004.440"><vh>mst_is_undef</vh></v>
<v t="ekr.20080529093004.441"><vh>mst_pre_define</vh></v>
<v t="ekr.20080529093004.442"><vh>mst_show</vh></v>
</v>
<v t="ekr.20080529093004.443"><vh>@@file CCpass12.c</vh>
<v t="ekr.20080529093004.444"><vh>&lt;&lt; CCpass12 #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.445"><vh>&lt;&lt; CCpass12 declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.446"><vh>check_compress1</vh></v>
<v t="ekr.20080529093004.447"><vh>compress</vh></v>
</v>
<v t="ekr.20080529093004.448"><vh>@@file CCtarget.c</vh>
<v t="ekr.20080529093004.449"><vh>&lt;&lt; CCtarget #includes &gt;&gt;</vh></v>
</v>
<v t="ekr.20080529093004.450"><vh>@@file CCtokens.c</vh>
<v t="ekr.20080529093004.451"><vh>&lt;&lt; CCtokens #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.452"><vh>&lt;&lt; CCtokens declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.453"><vh>tok_check</vh></v>
<v t="ekr.20080529093004.454"><vh>tok_dump</vh></v>
<v t="ekr.20080529093004.455"><vh>tok_dump_delim</vh></v>
<v t="ekr.20080529093004.456"><vh>tok_dump_delim2</vh></v>
<v t="ekr.20080529093004.457"><vh>tok_dump_line</vh></v>
<v t="ekr.20080529093004.458"><vh>tok_dump_line2</vh></v>
<v t="ekr.20080529093004.459"><vh>tok_dump_list</vh></v>
<v t="ekr.20080529093004.460"><vh>tok_dump_list2</vh></v>
<v t="ekr.20080529093004.461"><vh>tok_dump1</vh></v>
<v t="ekr.20080529093004.462"><vh>tok_concatenate</vh></v>
<v t="ekr.20080529093004.463"><vh>tok_copy</vh></v>
<v t="ekr.20080529093004.464"><vh>tok_copy_list</vh></v>
<v t="ekr.20080529093004.465"><vh>tok_copy2nl</vh></v>
<v t="ekr.20080529093004.466"><vh>tok_ignore</vh></v>
<v t="ekr.20080529093004.467"><vh>tok_init</vh></v>
<v t="ekr.20080529093004.468"><vh>tok_next_</vh></v>
<v t="ekr.20080529093004.469"><vh>tok_next_raw</vh></v>
<v t="ekr.20080529093004.470"><vh>tok_par_next</vh></v>
<v t="ekr.20080529093004.471"><vh>tok_patch</vh></v>
<v t="ekr.20080529093004.472"><vh>tok_scan</vh></v>
<v t="ekr.20080529093004.473"><vh>tok_scan_file</vh></v>
<v t="ekr.20080529093004.474"><vh>tok_scan_line</vh></v>
<v t="ekr.20080529093004.475"><vh>tok_skip_hidden</vh></v>
<v t="ekr.20080529093004.476"><vh>tok_2string</vh></v>
</v>
<v t="ekr.20080529093004.477"><vh>@@file CCtokize.c</vh>
<v t="ekr.20080529093004.478"><vh>&lt;&lt; CCtokize #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.479"><vh>&lt;&lt; CCtokize declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.480" a="M"><vh>tokize (the main tokenizer routine)</vh>
<v t="ekr.20080529093004.481"><vh>&lt;&lt; declare and initialize local variables &gt;&gt;</vh></v>
<v t="ekr.20080529093004.482"><vh>&lt;&lt; initialize global variables &gt;&gt;</vh></v>
<v t="ekr.20080529093004.483"><vh>&lt;&lt; trace the main loop &gt;&gt;</vh></v>
<v t="ekr.20080529093004.484"><vh>&lt;&lt; cases of the main switch &gt;&gt;</vh>
<v t="ekr.20080529093004.485"><vh>&lt;&lt; letter cases &gt;&gt;</vh></v>
<v t="ekr.20080529093004.486"><vh>&lt;&lt; whitespace cases &gt;&gt;</vh></v>
<v t="ekr.20080529093004.487"><vh>&lt;&lt; slashes or comments cases &gt;&gt;</vh></v>
<v t="ekr.20080529093004.488"><vh>&lt;&lt; strings and characters constants cases &gt;&gt;</vh></v>
<v t="ekr.20080529093004.489"><vh>&lt;&lt; '&lt;' and filenames cases &gt;&gt;</vh></v>
<v t="ekr.20080529093004.490"><vh>&lt;&lt; simple tokens cases &gt;&gt;</vh></v>
<v t="ekr.20080529093004.491"><vh>&lt;&lt; integer or floating constant cases &gt;&gt;</vh></v>
<v t="ekr.20080529093004.492"><vh>&lt;&lt; default case &gt;&gt;</vh></v>
</v>
<v t="ekr.20080529093004.493"><vh>&lt;&lt; handle errors &gt;&gt;</vh></v>
<v t="ekr.20080529093004.494"><vh>&lt;&lt; output final tokens &gt;&gt;</vh></v>
<v t="ekr.20080529093004.495"><vh>&lt;&lt; Save global variables &gt;&gt;</vh></v>
<v t="ekr.20080529093004.496"><vh>&lt;&lt; Output dumps and statistics &gt;&gt;</vh></v>
</v>
<v t="ekr.20080529093004.497"><vh>stats1</vh></v>
<v t="ekr.20080529093004.498"><vh>tok_dump_speed</vh></v>
<v t="ekr.20080529093004.499"><vh>tok_dump_stats</vh></v>
<v t="ekr.20080529093004.500"><vh>tok_init_hash_tab</vh></v>
<v t="ekr.20080529093004.501"><vh>tok_enter (enter)</vh></v>
<v t="ekr.20080529093004.502"><vh>tok_lookup</vh></v>
<v t="ekr.20080529093004.503"><vh>tok_hash</vh></v>
<v t="ekr.20080529093004.504"><vh>tok_lookup_hash</vh></v>
<v t="ekr.20080529093004.505"><vh>tok_reinit_stats</vh></v>
</v>
</v>
</v>
<v t="ekr.20080529093004.506"><vh>Main compiler &amp; parsing</vh>
<v t="ekr.20080529093004.353"><vh>User options</vh></v>
<v t="ekr.20080529093004.354"><vh>About the parser</vh>
<v t="ekr.20080529093004.355"><vh>Overview of data structures</vh></v>
<v t="ekr.20080529093004.356"><vh>Storage allocation</vh></v>
<v t="ekr.20080529093004.357"><vh>The statement parser</vh></v>
<v t="ekr.20080529093004.358"><vh>The expression parser</vh></v>
<v t="ekr.20080529093004.359"><vh>The declaration parser</vh>
<v t="ekr.20080529093004.360"><vh>Representing types with tnodes</vh></v>
<v t="ekr.20080529093004.361"><vh>Representing objects and user types with snodes</vh></v>
</v>
<v t="ekr.20080529093004.362"><vh>Reporting delayed errors</vh></v>
</v>
<v t="ekr.20080529093004.507"><vh>Headers</vh>
<v t="ekr.20080529093004.508"><vh>@@file CCcomp.h</vh></v>
<v t="ekr.20080529093004.509"><vh>@@file CCinit.h</vh></v>
<v t="ekr.20080529093004.510"><vh>@@file CCmain.h</vh></v>
<v t="ekr.20080529093004.511"><vh>@@file CCparser.h</vh></v>
</v>
<v t="ekr.20080529093004.512"><vh>Code</vh>
<v t="ekr.20080529093004.513"><vh>@@file CCcomp.c</vh>
<v t="ekr.20080529093004.514"><vh>&lt;&lt; CCcomp #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.515"><vh>&lt;&lt; CCcomp declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.516"><vh>compile</vh></v>
<v t="ekr.20080529093004.517"><vh>comp_dump_block</vh></v>
<v t="ekr.20080529093004.518"><vh>comp_init</vh></v>
<v t="ekr.20080529093004.519"><vh>comp_perm_init</vh></v>
<v t="ekr.20080529093004.520"><vh>comp_sherlock_adj_stats</vh></v>
<v t="ekr.20080529093004.521"><vh>comp_sherlock_report</vh></v>
<v t="ekr.20080529093004.522"><vh>comp_sherlock_stats</vh></v>
<v t="ekr.20080529093004.523"><vh>count_test</vh></v>
<v t="ekr.20080529093004.524"><vh>comp_timer_test</vh></v>
</v>
<v t="ekr.20080529093004.525"><vh>@@file CCdcl.c</vh>
<v t="ekr.20080529093004.526"><vh>&lt;&lt; CCdcl #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.527"><vh>&lt;&lt; CCdcl declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.528"><vh>dcl</vh></v>
<v t="ekr.20080529093004.529"><vh>dcl_arrays</vh></v>
<v t="ekr.20080529093004.530"><vh>dcl_cast</vh></v>
<v t="ekr.20080529093004.531"><vh>dcl_check_type</vh></v>
<v t="ekr.20080529093004.532"><vh>dcl_enum</vh></v>
<v t="ekr.20080529093004.533"><vh>dcl_fbody</vh></v>
<v t="ekr.20080529093004.534"><vh>dcl_finish</vh></v>
<v t="ekr.20080529093004.535"><vh>dcl_head</vh></v>
<v t="ekr.20080529093004.536"><vh>dcl_head_sclass</vh></v>
<v t="ekr.20080529093004.537"><vh>dcl_head_tmods</vh></v>
<v t="ekr.20080529093004.538"><vh>dcl_head_type</vh></v>
<v t="ekr.20080529093004.539"><vh>dcl_init</vh></v>
<v t="ekr.20080529093004.540"><vh>dcl_init_any_list</vh></v>
<v t="ekr.20080529093004.541"><vh>dcl_init_finish</vh></v>
<v t="ekr.20080529093004.542"><vh>dcl_is_typedef</vh></v>
<v t="ekr.20080529093004.543"><vh>dcl_list</vh></v>
<v t="ekr.20080529093004.544"><vh>dcl_old_formals</vh></v>
<v t="ekr.20080529093004.545"><vh>dcl_proto</vh></v>
<v t="ekr.20080529093004.546"><vh>dcl_size_array</vh></v>
<v t="ekr.20080529093004.547"><vh>dcl_size_struct</vh></v>
<v t="ekr.20080529093004.548"><vh>dcl_size_union</vh></v>
<v t="ekr.20080529093004.549"><vh>dcl_struct_union</vh></v>
<v t="ekr.20080529093004.550"><vh>dcl_tail</vh></v>
</v>
<v t="ekr.20080529093004.551"><vh>@@file CCexp.c</vh>
<v t="ekr.20080529093004.552"><vh>&lt;&lt; CCexp #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.553"><vh>&lt;&lt; CCexp declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.554"><vh>err_too_complex</vh></v>
<v t="ekr.20080529093004.555"><vh>eval_fstring</vh></v>
<v t="ekr.20080529093004.556"><vh>eval_string</vh></v>
<v t="ekr.20080529093004.557"><vh>eval_ustring</vh></v>
<v t="ekr.20080529093004.558"><vh>expr</vh></v>
<v t="ekr.20080529093004.559"><vh>expr1</vh></v>
<v t="ekr.20080529093004.560"><vh>expr_can_reduce</vh></v>
<v t="ekr.20080529093004.561"><vh>expr_cprim</vh></v>
<v t="ekr.20080529093004.562"><vh>expr_const_int</vh></v>
<v t="ekr.20080529093004.563"><vh>expr_is_const</vh></v>
<v t="ekr.20080529093004.564"><vh>expr_is_init_const</vh></v>
<v t="ekr.20080529093004.565"><vh>expr_list1</vh></v>
<v t="ekr.20080529093004.566"><vh>expr_prec</vh></v>
<v t="ekr.20080529093004.567"><vh>expr_prim</vh></v>
<v t="ekr.20080529093004.568"><vh>expr_reduce</vh></v>
<v t="ekr.20080529093004.569"><vh>expr_sizeof</vh></v>
<v t="ekr.20080529093004.570"><vh>expr_tdump</vh></v>
</v>
<v t="ekr.20080529093004.571"><vh>@@file CCinit.c</vh>
<v t="ekr.20080529093004.572"><vh>&lt;&lt; CCinit #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.573"><vh>&lt;&lt; CCinit declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.574"><vh>init_all</vh></v>
<v t="ekr.20080529093004.575"><vh>event_call_back</vh></v>
<v t="ekr.20080529093004.576"><vh>dump1_call_back</vh></v>
<v t="ekr.20080529093004.577"><vh>dump2_call_back</vh></v>
<v t="ekr.20080529093004.578"><vh>dump3_call_back</vh></v>
</v>
<v t="ekr.20080529093004.579"><vh>@@file CCmain.c</vh>
<v t="ekr.20080529093004.580"><vh>&lt;&lt; CCmain #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.581"><vh>&lt;&lt; CCmain declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.582"><vh>main</vh></v>
<v t="ekr.20080529093004.583"><vh>main_free_all</vh></v>
<v t="ekr.20080529093004.584"><vh>main_quit</vh></v>
</v>
<v t="ekr.20080529093004.585"><vh>@@file CCpar.c</vh>
<v t="ekr.20080529093004.586"><vh>&lt;&lt; CCpar #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.587"><vh>&lt;&lt; CCpar declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.588"><vh>ll_check</vh></v>
<v t="ekr.20080529093004.589"><vh>ll_enter</vh></v>
<v t="ekr.20080529093004.590"><vh>ll_init</vh></v>
<v t="ekr.20080529093004.591"><vh>ll_lookup</vh></v>
<v t="ekr.20080529093004.592"><vh>par_block</vh></v>
<v t="ekr.20080529093004.593"><vh>par_break</vh></v>
<v t="ekr.20080529093004.594"><vh>par_case</vh></v>
<v t="ekr.20080529093004.595"><vh>par_continue</vh></v>
<v t="ekr.20080529093004.596"><vh>par_default</vh></v>
<v t="ekr.20080529093004.597"><vh>par_do</vh></v>
<v t="ekr.20080529093004.598"><vh>par_expect</vh></v>
<v t="ekr.20080529093004.599"><vh>par_for</vh></v>
<v t="ekr.20080529093004.600"><vh>par_if</vh></v>
<v t="ekr.20080529093004.601"><vh>par_goto</vh></v>
<v t="ekr.20080529093004.602"><vh>par_invalid</vh></v>
<v t="ekr.20080529093004.603"><vh>par_label</vh></v>
<v t="ekr.20080529093004.604"><vh>par_list</vh></v>
<v t="ekr.20080529093004.605"><vh>par_need</vh></v>
<v t="ekr.20080529093004.606"><vh>par_needend</vh></v>
<v t="ekr.20080529093004.607"><vh>par_needsemi</vh></v>
<v t="ekr.20080529093004.608"><vh>par_outer_dcl</vh></v>
<v t="ekr.20080529093004.609"><vh>par_parenexp</vh></v>
<v t="ekr.20080529093004.610"><vh>par_program</vh></v>
<v t="ekr.20080529093004.611"><vh>par_return</vh></v>
<v t="ekr.20080529093004.612"><vh>par_statement</vh></v>
<v t="ekr.20080529093004.613"><vh>par_switch</vh></v>
<v t="ekr.20080529093004.614"><vh>par_while</vh></v>
</v>
<v t="ekr.20080529093004.615"><vh>@@file CCst.c</vh>
<v t="ekr.20080529093004.616"><vh>&lt;&lt; CCst #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.617"><vh>&lt;&lt; CCst declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.618"><vh>st_begin_block</vh></v>
<v t="ekr.20080529093004.619"><vh>st_detach</vh></v>
<v t="ekr.20080529093004.620"><vh>st_end_block</vh></v>
<v t="ekr.20080529093004.621"><vh>st_enter</vh></v>
<v t="ekr.20080529093004.622"><vh>st_enter_field</vh></v>
<v t="ekr.20080529093004.623"><vh>st_enter_tag</vh></v>
<v t="ekr.20080529093004.624"><vh>st_init</vh></v>
<v t="ekr.20080529093004.625"><vh>st_lookup</vh></v>
<v t="ekr.20080529093004.626"><vh>st_lookup_field</vh></v>
<v t="ekr.20080529093004.627"><vh>st_lookup_tag</vh></v>
<v t="ekr.20080529093004.628"><vh>st_stats</vh></v>
</v>
</v>
</v>
<v t="ekr.20080529093004.629"><vh>Code generation &amp; output</vh>
<v t="ekr.20080529093004.630"><vh>Documentation</vh>
<v t="ekr.20080529093004.364"><vh>The back end</vh></v>
<v t="ekr.20080529093004.365"><vh>Code generators: Theory of operation</vh></v>
<v t="ekr.20080529093004.366"><vh>Design of the code generators</vh></v>
<v t="ekr.20080529093004.367"><vh>How CC2 generates code</vh></v>
</v>
<v t="ekr.20080529093004.631"><vh>Headers</vh>
<v t="ekr.20080529093004.632"><vh>@@file CCdump.h</vh></v>
<v t="ekr.20080529093004.633"><vh>@@file CCgen.h</vh></v>
<v t="ekr.20080529093004.634"><vh>@@file CCregs.h</vh></v>
</v>
<v t="ekr.20080529093004.635"><vh>Code</vh>
<v t="ekr.20080529093004.636"><vh>@@file CCctype.c</vh>
<v t="ekr.20080529093004.637"><vh>&lt;&lt; CCctype #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.638"><vh>&lt;&lt; CCctype declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.639"><vh>ct_cast_arg1</vh></v>
<v t="ekr.20080529093004.640"><vh>ct_cast_arg2</vh></v>
<v t="ekr.20080529093004.641"><vh>ct_check_args</vh></v>
<v t="ekr.20080529093004.642"><vh>ct_convert2</vh></v>
<v t="ekr.20080529093004.643"><vh>ct_convert3</vh></v>
<v t="ekr.20080529093004.644"><vh>ct_copy_expr_tree</vh></v>
<v t="ekr.20080529093004.645"><vh>ct_copy_type_tree</vh></v>
<v t="ekr.20080529093004.646"><vh>ct_cvt_r2l</vh></v>
<v t="ekr.20080529093004.647"><vh>ct_eq</vh></v>
<v t="ekr.20080529093004.648"><vh>ct_eq_proto</vh></v>
<v t="ekr.20080529093004.649"><vh>ct_func_name</vh></v>
<v t="ekr.20080529093004.650"><vh>ct_is_lval</vh></v>
<v t="ekr.20080529093004.651"><vh>ct_is_null</vh></v>
<v t="ekr.20080529093004.652"><vh>ct_promote</vh></v>
<v t="ekr.20080529093004.653"><vh>ct_type1</vh></v>
<v t="ekr.20080529093004.654"><vh>ct_type2</vh></v>
<v t="ekr.20080529093004.655"><vh>ct_type3</vh></v>
</v>
<v t="ekr.20080529093004.656"><vh>@@file CCdump.c</vh>
<v t="ekr.20080529093004.657"><vh>&lt;&lt; CCdump #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.658"><vh>&lt;&lt; CCdump declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.659"><vh>eanode</vh></v>
<v t="ekr.20080529093004.660"><vh>ecnode</vh></v>
<v t="ekr.20080529093004.661"><vh>ecinode</vh></v>
<v t="ekr.20080529093004.662"><vh>ecodelist</vh></v>
<v t="ekr.20080529093004.663"><vh>edcls</vh></v>
<v t="ekr.20080529093004.664"><vh>eenode</vh></v>
<v t="ekr.20080529093004.665"><vh>einode</vh></v>
<v t="ekr.20080529093004.666"><vh>eline</vh></v>
<v t="ekr.20080529093004.667"><vh>eop1node</vh></v>
<v t="ekr.20080529093004.668"><vh>eop2node</vh></v>
<v t="ekr.20080529093004.669"><vh>eop3node</vh></v>
<v t="ekr.20080529093004.670"><vh>epnode</vh></v>
<v t="ekr.20080529093004.671"><vh>estat</vh></v>
<v t="ekr.20080529093004.672"><vh>esmods</vh></v>
<v t="ekr.20080529093004.673"><vh>esnode</vh></v>
<v t="ekr.20080529093004.674"><vh>etdcls</vh></v>
<v t="ekr.20080529093004.675"><vh>etnode</vh></v>
<v t="ekr.20080529093004.676"><vh>etnode_full</vh></v>
<v t="ekr.20080529093004.677"><vh>etok</vh></v>
<v t="ekr.20080529093004.678"><vh>etoknum</vh></v>
<v t="ekr.20080529093004.679"><vh>ettype</vh></v>
</v>
<v t="ekr.20080529093004.680"><vh>@@file CCfold.c</vh>
<v t="ekr.20080529093004.681"><vh>&lt;&lt; CCfold #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.682"><vh>&lt;&lt; CCfold declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.683"><vh>fold</vh></v>
<v t="ekr.20080529093004.684"><vh>fold1</vh></v>
<v t="ekr.20080529093004.685"><vh>fold2</vh></v>
<v t="ekr.20080529093004.686"><vh>fold_float2</vh></v>
<v t="ekr.20080529093004.687"><vh>fold_float_to_int</vh></v>
<v t="ekr.20080529093004.688"><vh>fold_float_to_float</vh></v>
<v t="ekr.20080529093004.689"><vh>fold_int_to_float</vh></v>
<v t="ekr.20080529093004.690"><vh>fold_negate_float</vh></v>
<v t="ekr.20080529093004.691"><vh>fold_new_constant</vh></v>
</v>
<v t="ekr.20080529093004.692"><vh>@@file CCgbody.c</vh>
<v t="ekr.20080529093004.693"><vh>&lt;&lt; CCgbody #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.694"><vh>&lt;&lt; CCgbody declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.695"><vh>gen_alloc_formals</vh></v>
<v t="ekr.20080529093004.696"><vh>gen_alloc_function</vh></v>
<v t="ekr.20080529093004.697"><vh>gen_alloc_locals</vh></v>
<v t="ekr.20080529093004.698"><vh>gen_alloc_outers</vh></v>
<v t="ekr.20080529093004.699"><vh>gen_all_imports</vh></v>
<v t="ekr.20080529093004.700"><vh>gen_auto_inits</vh></v>
<v t="ekr.20080529093004.701"><vh>gen_auto_list</vh></v>
<v t="ekr.20080529093004.702"><vh>gen_fbody</vh></v>
<v t="ekr.20080529093004.703"><vh>gen_import</vh></v>
<v t="ekr.20080529093004.704"><vh>gen_import_name</vh></v>
<v t="ekr.20080529093004.705"><vh>gen_init_data</vh></v>
<v t="ekr.20080529093004.706"><vh>gen_init_float</vh></v>
<v t="ekr.20080529093004.707"><vh>gen_init_pointer</vh></v>
<v t="ekr.20080529093004.708"><vh>gen_init_tree</vh></v>
<v t="ekr.20080529093004.709"><vh>gen_inner_data</vh></v>
</v>
<v t="ekr.20080529093004.710"><vh>@@file CCgbool.c</vh>
<v t="ekr.20080529093004.711"><vh>&lt;&lt; CCgbool #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.712"><vh>&lt;&lt; CCgbool declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.713"><vh>gen_b1</vh></v>
<v t="ekr.20080529093004.714"><vh>gen_bool</vh></v>
<v t="ekr.20080529093004.715"><vh>gen_branch</vh></v>
<v t="ekr.20080529093004.716"><vh>gen_cmp</vh></v>
<v t="ekr.20080529093004.717"><vh>gen_nz</vh></v>
</v>
<v t="ekr.20080529093004.718"><vh>@@file CCgen.c</vh>
<v t="ekr.20080529093004.719"><vh>&lt;&lt; CCgen #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.720"><vh>&lt;&lt; CCgen declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.721"><vh>gen_expr</vh></v>
<v t="ekr.20080529093004.722"><vh>gen_init</vh></v>
<v t="ekr.20080529093004.723"><vh>gen_func_init</vh></v>
<v t="ekr.20080529093004.724"><vh>gen_new_big_anode</vh></v>
<v t="ekr.20080529093004.725"><vh>gen_new_stack_anode</vh></v>
<v t="ekr.20080529093004.726"><vh>gen_outer_expr</vh></v>
<v t="ekr.20080529093004.727"><vh>gen_perm_init</vh></v>
<v t="ekr.20080529093004.728"><vh>gen_pp</vh></v>
</v>
<v t="ekr.20080529093004.729"><vh>@@file CCgfloat.c</vh>
<v t="ekr.20080529093004.730"><vh>&lt;&lt; CCgfloat #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.731"><vh>&lt;&lt; CCgfloat declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.732"><vh>gf_assn2</vh></v>
<v t="ekr.20080529093004.733"><vh>gf_call1</vh></v>
<v t="ekr.20080529093004.734"><vh>gf_call2</vh></v>
<v t="ekr.20080529093004.735"><vh>gf_call_nz</vh></v>
<v t="ekr.20080529093004.736"><vh>gf_cast2f</vh></v>
<v t="ekr.20080529093004.737"><vh>gf_cast2i</vh></v>
<v t="ekr.20080529093004.738"><vh>gf_get_push_ftemp</vh></v>
<v t="ekr.20080529093004.739"><vh>gf_op2</vh></v>
<v t="ekr.20080529093004.740"><vh>gf_pre_post</vh></v>
<v t="ekr.20080529093004.741"><vh>gf_relop</vh></v>
<v t="ekr.20080529093004.742"><vh>gf_uminus</vh></v>
<v t="ekr.20080529093004.743"><vh>lib_name</vh></v>
</v>
<v t="ekr.20080529093004.744"><vh>@@file CCgint.c</vh>
<v t="ekr.20080529093004.745"><vh>&lt;&lt; CCgint #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.746"><vh>&lt;&lt; CCgint declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.747"><vh>gen_e1</vh></v>
<v t="ekr.20080529093004.748"><vh>g_address</vh></v>
<v t="ekr.20080529093004.749"><vh>g_add_dots</vh></v>
<v t="ekr.20080529093004.750"><vh>g_add_offset</vh></v>
<v t="ekr.20080529093004.751"><vh>g_add_sub_any</vh></v>
<v t="ekr.20080529093004.752"><vh>g_add_sub_ii</vh></v>
<v t="ekr.20080529093004.753"><vh>g_add_sub_ip</vh></v>
<v t="ekr.20080529093004.754"><vh>g_and_or</vh></v>
<v t="ekr.20080529093004.755"><vh>g_args</vh></v>
<v t="ekr.20080529093004.756"><vh>g_arg1</vh></v>
<v t="ekr.20080529093004.757"><vh>g_assn</vh></v>
<v t="ekr.20080529093004.758"><vh>g_call</vh></v>
<v t="ekr.20080529093004.759"><vh>g_call_math2</vh></v>
<v t="ekr.20080529093004.760"><vh>g_cast</vh></v>
<v t="ekr.20080529093004.761"><vh>g_cmp</vh></v>
<v t="ekr.20080529093004.762"><vh>g_comma</vh></v>
<v t="ekr.20080529093004.763"><vh>g_cons</vh></v>
<v t="ekr.20080529093004.764"><vh>g_div_mod</vh></v>
<v t="ekr.20080529093004.765"><vh>g_eor</vh></v>
<v t="ekr.20080529093004.766"><vh>g_index</vh></v>
<v t="ekr.20080529093004.767"><vh>g_logical</vh></v>
<v t="ekr.20080529093004.768"><vh>g_mult</vh></v>
<v t="ekr.20080529093004.769"><vh>g_not</vh></v>
<v t="ekr.20080529093004.770"><vh>g_pre_post</vh></v>
<v t="ekr.20080529093004.771"><vh>g_prim</vh></v>
<v t="ekr.20080529093004.772"><vh>g_relop</vh></v>
<v t="ekr.20080529093004.773"><vh>g_scale</vh></v>
<v t="ekr.20080529093004.774"><vh>g_shift</vh></v>
<v t="ekr.20080529093004.775"><vh>g_sub_pp</vh></v>
<v t="ekr.20080529093004.776"><vh>g_ternary</vh></v>
<v t="ekr.20080529093004.777"><vh>g_uand</vh></v>
<v t="ekr.20080529093004.778"><vh>g_uneg</vh></v>
<v t="ekr.20080529093004.779"><vh>g_uplus</vh></v>
<v t="ekr.20080529093004.780"><vh>g_ustar</vh></v>
</v>
<v t="ekr.20080529093004.781"><vh>@@file CCgstat.c</vh>
<v t="ekr.20080529093004.782"><vh>&lt;&lt; CCgstat #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.783"><vh>&lt;&lt; CCgstat declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.784"><vh>gen_block</vh></v>
<v t="ekr.20080529093004.785"><vh>gen_break</vh></v>
<v t="ekr.20080529093004.786"><vh>gen_case</vh></v>
<v t="ekr.20080529093004.787"><vh>gen_continue</vh></v>
<v t="ekr.20080529093004.788"><vh>gen_default</vh></v>
<v t="ekr.20080529093004.789"><vh>gen_do</vh></v>
<v t="ekr.20080529093004.790"><vh>gen_for</vh></v>
<v t="ekr.20080529093004.791"><vh>gen_goto</vh></v>
<v t="ekr.20080529093004.792"><vh>gen_if</vh></v>
<v t="ekr.20080529093004.793"><vh>gen_label</vh></v>
<v t="ekr.20080529093004.794"><vh>gen_list</vh></v>
<v t="ekr.20080529093004.795"><vh>gen_return</vh></v>
<v t="ekr.20080529093004.796"><vh>gen_switch</vh></v>
<v t="ekr.20080529093004.797"><vh>gen_switch_jump</vh></v>
<v t="ekr.20080529093004.798"><vh>gen_switch_size</vh></v>
<v t="ekr.20080529093004.799"><vh>gen_switch_tables</vh></v>
<v t="ekr.20080529093004.800"><vh>gen_switch_table</vh></v>
<v t="ekr.20080529093004.801"><vh>gen_switch_tests</vh></v>
<v t="ekr.20080529093004.802"><vh>gen_while</vh></v>
</v>
<v t="ekr.20080529093004.803"><vh>@@file CCout.c</vh>
<v t="ekr.20080529093004.804"><vh>&lt;&lt; CCout #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.805"><vh>&lt;&lt; CCout declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.806"><vh>out_anode</vh></v>
<v t="ekr.20080529093004.807"><vh>out_anode_tag</vh></v>
<v t="ekr.20080529093004.808"><vh>out_clabel</vh></v>
<v t="ekr.20080529093004.809"><vh>out_begin_file</vh></v>
<v t="ekr.20080529093004.810"><vh>out_cinode</vh></v>
<v t="ekr.20080529093004.811"><vh>out_cnode</vh></v>
<v t="ekr.20080529093004.812"><vh>out_comment_field</vh></v>
<v t="ekr.20080529093004.813"><vh>out_data_address</vh></v>
<v t="ekr.20080529093004.814"><vh>out_data_clabel</vh></v>
<v t="ekr.20080529093004.815"><vh>out_data_clabel_ref</vh></v>
<v t="ekr.20080529093004.816"><vh>out_data_f2i</vh></v>
<v t="ekr.20080529093004.817"><vh>out_data_i2f</vh></v>
<v t="ekr.20080529093004.818"><vh>out_data_float</vh></v>
<v t="ekr.20080529093004.819"><vh>out_data_int</vh></v>
<v t="ekr.20080529093004.820"><vh>out_data_name_offset</vh></v>
<v t="ekr.20080529093004.821"><vh>out_data_offset</vh></v>
<v t="ekr.20080529093004.822"><vh>out_data_string</vh></v>
<v t="ekr.20080529093004.823"><vh>out_data_ulabel</vh></v>
<v t="ekr.20080529093004.824"><vh>out_end_file</vh></v>
<v t="ekr.20080529093004.825"><vh>out_embedded_label</vh></v>
<v t="ekr.20080529093004.826"><vh>out_endr</vh></v>
<v t="ekr.20080529093004.827"><vh>out_entry</vh></v>
<v t="ekr.20080529093004.828"><vh>out_error</vh></v>
<v t="ekr.20080529093004.829"><vh>out_float_dc</vh></v>
<v t="ekr.20080529093004.830"><vh>out_func_head</vh></v>
<v t="ekr.20080529093004.831"><vh>out_function</vh></v>
<v t="ekr.20080529093004.832"><vh>out_import</vh></v>
<v t="ekr.20080529093004.833"><vh>out_list</vh></v>
<v t="ekr.20080529093004.834"><vh>out_raw_clabel</vh></v>
<v t="ekr.20080529093004.835"><vh>out_record</vh></v>
<v t="ekr.20080529093004.836"><vh>out_rlist</vh></v>
<v t="ekr.20080529093004.837"><vh>out_stack_comment</vh></v>
<v t="ekr.20080529093004.838"><vh>out_string_clabel</vh></v>
<v t="ekr.20080529093004.839"><vh>out_switch_offset</vh></v>
<v t="ekr.20080529093004.840"><vh>out_with</vh></v>
<v t="ekr.20080529093004.841"><vh>out_zero</vh></v>
<v t="ekr.20080529093004.842"><vh>set_file_prefix</vh></v>
</v>
<v t="ekr.20080529093004.843"><vh>@@file CCpeep.c</vh>
<v t="ekr.20080529093004.844"><vh>&lt;&lt; CCpeep #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.845"><vh>&lt;&lt; CCpeep declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.846"><vh>c_delete</vh></v>
<v t="ekr.20080529093004.847"><vh>peep_hole</vh></v>
<v t="ekr.20080529093004.848"><vh>ph_dec_ref</vh></v>
<v t="ekr.20080529093004.849"><vh>ph_bxx2bxx</vh></v>
<v t="ekr.20080529093004.850"><vh>ph_bxx2next</vh></v>
<v t="ekr.20080529093004.851"><vh>ph_dead</vh></v>
<v t="ekr.20080529093004.852"><vh>ph_flip_bxx</vh></v>
<v t="ekr.20080529093004.853"><vh>ph_flip_op</vh></v>
<v t="ekr.20080529093004.854"><vh>ph_merge</vh></v>
<v t="ekr.20080529093004.855"><vh>ph_tst</vh></v>
</v>
<v t="ekr.20080529093004.856"><vh>@@file CCput.c</vh>
<v t="ekr.20080529093004.857"><vh>&lt;&lt; CCput #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.858"><vh>&lt;&lt; CCput declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.859"><vh>c_0</vh></v>
<v t="ekr.20080529093004.860"><vh>c_1</vh></v>
<v t="ekr.20080529093004.861"><vh>c_1len</vh></v>
<v t="ekr.20080529093004.862"><vh>c_1len1</vh></v>
<v t="ekr.20080529093004.863"><vh>c_1clab</vh></v>
<v t="ekr.20080529093004.864"><vh>c_1ulab</vh></v>
<v t="ekr.20080529093004.865"><vh>c_2</vh></v>
<v t="ekr.20080529093004.866"><vh>c_2clab</vh></v>
<v t="ekr.20080529093004.867"><vh>c_2len</vh></v>
<v t="ekr.20080529093004.868"><vh>c_2len2</vh></v>
<v t="ekr.20080529093004.869"><vh>c_adj_stack</vh></v>
<v t="ekr.20080529093004.870"><vh>c_ap2address</vh></v>
<v t="ekr.20080529093004.871"><vh>c_chk_ptr</vh></v>
<v t="ekr.20080529093004.872"><vh>c_clabel</vh></v>
<v t="ekr.20080529093004.873"><vh>c_ext</vh></v>
<v t="ekr.20080529093004.874"><vh>c_ext_constant</vh></v>
<v t="ekr.20080529093004.875"><vh>c_lea</vh></v>
<v t="ekr.20080529093004.876"><vh>c_lea_temp</vh></v>
<v t="ekr.20080529093004.877"><vh>c_lea_opt</vh></v>
<v t="ekr.20080529093004.878"><vh>c_line</vh></v>
<v t="ekr.20080529093004.879"><vh>c_line2</vh></v>
<v t="ekr.20080529093004.880"><vh>c_clr</vh></v>
<v t="ekr.20080529093004.881"><vh>c_long2mlen</vh></v>
<v t="ekr.20080529093004.882"><vh>c_ulong2mlen</vh></v>
<v t="ekr.20080529093004.883"><vh>c_copy</vh></v>
<v t="ekr.20080529093004.884"><vh>c_e2mlen</vh></v>
<v t="ekr.20080529093004.885"><vh>c_move</vh></v>
<v t="ekr.20080529093004.886"><vh>c_move_big</vh></v>
<v t="ekr.20080529093004.887"><vh>c_move_len</vh></v>
<v t="ekr.20080529093004.888"><vh>c_move2atreg</vh></v>
<v t="ekr.20080529093004.889"><vh>c_move2dtreg</vh></v>
<v t="ekr.20080529093004.890"><vh>c_push</vh></v>
<v t="ekr.20080529093004.891"><vh>c_push_address</vh></v>
<v t="ekr.20080529093004.892"><vh>c_push_big</vh></v>
<v t="ekr.20080529093004.893"><vh>c_push_float</vh></v>
<v t="ekr.20080529093004.894"><vh>c_put</vh></v>
<v t="ekr.20080529093004.895"><vh>c_s2mlen</vh></v>
<v t="ekr.20080529093004.896"><vh>c_t2mlen</vh></v>
<v t="ekr.20080529093004.897"><vh>c_ulabel</vh></v>
</v>
<v t="ekr.20080529093004.898"><vh>@@file CCregs.c</vh>
<v t="ekr.20080529093004.899"><vh>&lt;&lt; CCregs #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.900"><vh>&lt;&lt; CCregs declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.901"><vh>free_temp</vh></v>
<v t="ekr.20080529093004.902"><vh>free_treg</vh></v>
<v t="ekr.20080529093004.903"><vh>get_a0</vh></v>
<v t="ekr.20080529093004.904"><vh>get_atemp</vh></v>
<v t="ekr.20080529093004.905"><vh>get_d0</vh></v>
<v t="ekr.20080529093004.906"><vh>get_dcl_reg</vh></v>
<v t="ekr.20080529093004.907"><vh>get_dtemp</vh></v>
<v t="ekr.20080529093004.908"><vh>get_reg</vh></v>
<v t="ekr.20080529093004.909"><vh>get_temp</vh></v>
<v t="ekr.20080529093004.910"><vh>is_equiv</vh></v>
<v t="ekr.20080529093004.911"><vh>reg_free_all</vh></v>
<v t="ekr.20080529093004.912"><vh>reg_free_formals</vh></v>
<v t="ekr.20080529093004.913"><vh>reg_free_locals</vh></v>
<v t="ekr.20080529093004.914"><vh>reg_free_user</vh></v>
<v t="ekr.20080529093004.915"><vh>reg_init</vh></v>
<v t="ekr.20080529093004.916"><vh>reg_init_check</vh></v>
<v t="ekr.20080529093004.917"><vh>reg_perm_init</vh></v>
<v t="ekr.20080529093004.918"><vh>reg_spill_all</vh></v>
<v t="ekr.20080529093004.919"><vh>spill_reg</vh></v>
</v>
</v>
</v>
<v t="ekr.20080529093004.920"><vh>Library &amp; Utilities</vh>
<v t="ekr.20080529093004.368"><vh>About library and utility routines</vh></v>
<v t="ekr.20080529093004.921"><vh>Headers</vh>
<v t="ekr.20080529093004.922"><vh>@@file CCarg.h</vh></v>
<v t="ekr.20080529093004.923"><vh>@@file CCend.h</vh></v>
<v t="ekr.20080529093004.924"><vh>@@file CCerr.h</vh></v>
<v t="ekr.20080529093004.925"><vh>@@file CCes.h</vh></v>
<v t="ekr.20080529093004.926"><vh>@@file CCmem.h</vh></v>
</v>
<v t="ekr.20080529093004.927"><vh>Code</vh>
<v t="ekr.20080529093004.928"><vh>@@file CCarg.c</vh>
<v t="ekr.20080529093004.929"><vh>&lt;&lt; CCarg #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.930"><vh>&lt;&lt; CCarg declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.931"><vh>arg_do_argv</vh></v>
<v t="ekr.20080529093004.932"><vh>arg_do_dialog</vh></v>
<v t="ekr.20080529093004.933"><vh>arg_help</vh></v>
<v t="ekr.20080529093004.934"><vh>arg_prefix</vh></v>
</v>
<v t="ekr.20080529093004.935"><vh>@@file CCend.c</vh>
<v t="ekr.20080529093004.936"><vh>&lt;&lt; CCend #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.937"><vh>end_close_all</vh></v>
</v>
<v t="ekr.20080529093004.938"><vh>@@file CCerr.c</vh>
<v t="ekr.20080529093004.939"><vh>&lt;&lt; CCerr #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.940"><vh>&lt;&lt; CCerr declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.941"><vh>err_init</vh></v>
<v t="ekr.20080529093004.942"><vh>err_init_again</vh></v>
<v t="ekr.20080529093004.943"><vh>err_begin_file</vh></v>
<v t="ekr.20080529093004.944"><vh>err_begin_func</vh></v>
<v t="ekr.20080529093004.945"><vh>err_begin_mess</vh></v>
<v t="ekr.20080529093004.946"><vh>err_file_name</vh></v>
<v t="ekr.20080529093004.947"><vh>err_context</vh></v>
<v t="ekr.20080529093004.948"><vh>err_lines</vh></v>
<v t="ekr.20080529093004.949"><vh>err_test</vh></v>
<v t="ekr.20080529093004.950"><vh>err_begin</vh></v>
<v t="ekr.20080529093004.951"><vh>fatal_begin</vh></v>
<v t="ekr.20080529093004.952"><vh>fatal_end</vh></v>
<v t="ekr.20080529093004.953"><vh>help_begin</vh></v>
<v t="ekr.20080529093004.954"><vh>user_fatal_begin</vh></v>
<v t="ekr.20080529093004.955"><vh>user_fatal_end</vh></v>
<v t="ekr.20080529093004.956"><vh>warn_begin</vh></v>
</v>
<v t="ekr.20080529093004.957"><vh>@@file CCes.c</vh>
<v t="ekr.20080529093004.958"><vh>&lt;&lt; CCes #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.959"><vh>es</vh></v>
<v t="ekr.20080529093004.960"><vh>ecblanks</vh></v>
<v t="ekr.20080529093004.961"><vh>ecnl</vh></v>
<v t="ekr.20080529093004.962"><vh>ecnls</vh></v>
<v t="ekr.20080529093004.963"><vh>es_assert_failed</vh></v>
<v t="ekr.20080529093004.964"><vh>es_internal_err</vh></v>
</v>
<v t="ekr.20080529093004.965"><vh>@@file CClib.c</vh>
<v t="ekr.20080529093004.966"><vh>&lt;&lt; CClib #includes &gt;&gt;</vh></v>
</v>
<v t="ekr.20080529093004.967"><vh>@@file CCmem.c</vh>
<v t="ekr.20080529093004.968"><vh>&lt;&lt; CCmem #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.969"><vh>&lt;&lt; CCmem declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.970"><vh>lib_calloc</vh></v>
<v t="ekr.20080529093004.971"><vh>lib_free</vh></v>
<v t="ekr.20080529093004.972"><vh>mem_check</vh></v>
<v t="ekr.20080529093004.973"><vh>mem_new_tok_block</vh></v>
<v t="ekr.20080529093004.974"><vh>mem_str_copy</vh></v>
</v>
<v t="ekr.20080529093004.975"><vh>@@file CCrunlib.c</vh>
<v t="ekr.20080529093004.976"><vh>&lt;&lt; CCrunlib #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.977"><vh>&lt;&lt; CCrunlib declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.978"><vh>_chk_ptr</vh></v>
<v t="ekr.20080529093004.979"><vh>_lib_cvt_double</vh></v>
<v t="ekr.20080529093004.980"><vh>_lib_f_move</vh></v>
<v t="ekr.20080529093004.981"><vh>_lib_d_move</vh></v>
<v t="ekr.20080529093004.982"><vh>_lib_ld_move</vh></v>
<v t="ekr.20080529093004.983"><vh>_lib_d2f</vh></v>
<v t="ekr.20080529093004.984"><vh>_lib_d2l</vh></v>
<v t="ekr.20080529093004.985"><vh>_lib_d2ld</vh></v>
<v t="ekr.20080529093004.986"><vh>_lib_f2d</vh></v>
<v t="ekr.20080529093004.987"><vh>_lib_f2l</vh></v>
<v t="ekr.20080529093004.988"><vh>_lib_f2ld</vh></v>
<v t="ekr.20080529093004.989"><vh>_lib_l2d</vh></v>
<v t="ekr.20080529093004.990"><vh>_lib_l2f</vh></v>
<v t="ekr.20080529093004.991"><vh>_lib_l2ld</vh></v>
<v t="ekr.20080529093004.992"><vh>_lib_ld2d</vh></v>
<v t="ekr.20080529093004.993"><vh>_lib_ld2f</vh></v>
<v t="ekr.20080529093004.994"><vh>_lib_ld2l</vh></v>
<v t="ekr.20080529093004.995"><vh>_lib_ld_add</vh></v>
<v t="ekr.20080529093004.996"><vh>_lib_f_pre_add1</vh></v>
<v t="ekr.20080529093004.997"><vh>_lib_f_post_add1</vh></v>
<v t="ekr.20080529093004.998"><vh>_lib_d_pre_add1</vh></v>
<v t="ekr.20080529093004.999"><vh>_lib_d_post_add1</vh></v>
<v t="ekr.20080529093004.1000"><vh>_lib_ld_pre_add1</vh></v>
<v t="ekr.20080529093004.1001"><vh>_lib_ld_post_add1</vh></v>
<v t="ekr.20080529093004.1002"><vh>_lib_ld_div</vh></v>
<v t="ekr.20080529093004.1003"><vh>_lib_ld_mul</vh></v>
<v t="ekr.20080529093004.1004"><vh>_lib_ld_neg</vh></v>
<v t="ekr.20080529093004.1005"><vh>_lib_ld_sub</vh></v>
<v t="ekr.20080529093004.1006"><vh>_lib_f_pre_sub1</vh></v>
<v t="ekr.20080529093004.1007"><vh>_lib_f_post_sub1</vh></v>
<v t="ekr.20080529093004.1008"><vh>_lib_d_pre_sub1</vh></v>
<v t="ekr.20080529093004.1009"><vh>_lib_d_post_sub1</vh></v>
<v t="ekr.20080529093004.1010"><vh>_lib_ld_pre_sub1</vh></v>
<v t="ekr.20080529093004.1011"><vh>_lib_ld_post_sub1</vh></v>
<v t="ekr.20080529093004.1012"><vh>_lib_d_nz</vh></v>
<v t="ekr.20080529093004.1013"><vh>_lib_ld_eq</vh></v>
<v t="ekr.20080529093004.1014"><vh>_lib_ld_ge</vh></v>
<v t="ekr.20080529093004.1015"><vh>_lib_ld_gt</vh></v>
<v t="ekr.20080529093004.1016"><vh>_lib_ld_le</vh></v>
<v t="ekr.20080529093004.1017"><vh>_lib_ld_lt</vh></v>
<v t="ekr.20080529093004.1018"><vh>_lib_ld_ne</vh></v>
<v t="ekr.20080529093004.1019"><vh>_lib_ld_nz</vh></v>
</v>
</v>
</v>
<v t="ekr.20080529093004.1020"><vh>Testing</vh>
<v t="ekr.20080529093004.1021"><vh>@@file CCfloat_test.c</vh>
<v t="ekr.20080529093004.1022"><vh>&lt;&lt; CCfloat_test #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1023"><vh>&lt;&lt; CCfloat_test declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1024"><vh>tuple_float_test</vh></v>
<v t="ekr.20080529093004.1025"><vh>test</vh></v>
<v t="ekr.20080529093004.1026"><vh>test2</vh></v>
</v>
<v t="ekr.20080529093004.1027"><vh>@@file CCstdclib_test.c</vh>
<v t="ekr.20080529093004.1028"><vh>&lt;&lt; CCstdclib_test #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1029"><vh>&lt;&lt; CCstdclib_test declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1030"><vh>tuple_stdclib_test</vh></v>
<v t="ekr.20080529093004.1031"><vh>print</vh></v>
<v t="ekr.20080529093004.1032"><vh>print_float</vh></v>
<v t="ekr.20080529093004.1033"><vh>print_double</vh></v>
<v t="ekr.20080529093004.1034"><vh>print_long_double</vh></v>
<v t="ekr.20080529093004.1035"><vh>print_short_hex</vh></v>
<v t="ekr.20080529093004.1036"><vh>ekr_test</vh></v>
<v t="ekr.20080529093004.1037"><vh>test_alloc</vh></v>
<v t="ekr.20080529093004.1038"><vh>field_abort</vh></v>
<v t="ekr.20080529093004.1039"><vh>dummy</vh></v>
<v t="ekr.20080529093004.1040"><vh>test_assert</vh></v>
<v t="ekr.20080529093004.1041"><vh>prclass</vh></v>
<v t="ekr.20080529093004.1042"><vh>test_ctype</vh></v>
<v t="ekr.20080529093004.1043"><vh>test_errno</vh></v>
<v t="ekr.20080529093004.1044"><vh>test_float</vh></v>
<v t="ekr.20080529093004.1045"><vh>test_limits</vh></v>
<v t="ekr.20080529093004.1046"><vh>testclocale</vh></v>
<v t="ekr.20080529093004.1047"><vh>test_locale</vh></v>
<v t="ekr.20080529093004.1048"><vh>approx</vh></v>
<v t="ekr.20080529093004.1049"><vh>test_math1</vh></v>
<v t="ekr.20080529093004.1050"><vh>approx2</vh></v>
<v t="ekr.20080529093004.1051"><vh>test_math2</vh></v>
<v t="ekr.20080529093004.1052"><vh>equal</vh></v>
<v t="ekr.20080529093004.1053"><vh>test_math3</vh></v>
<v t="ekr.20080529093004.1054"><vh>jmpto</vh></v>
<v t="ekr.20080529093004.1055"><vh>stackptr</vh></v>
<v t="ekr.20080529093004.1056"><vh>try_jump</vh></v>
<v t="ekr.20080529093004.1057"><vh>test_setjmp</vh></v>
<v t="ekr.20080529093004.1058"><vh>field_fpe</vh></v>
<v t="ekr.20080529093004.1059"><vh>test_signal</vh></v>
<v t="ekr.20080529093004.1060"><vh>tryarg</vh></v>
<v t="ekr.20080529093004.1061"><vh>test_stdarg</vh></v>
<v t="ekr.20080529093004.1062"><vh>test_stddef</vh></v>
<v t="ekr.20080529093004.1063"><vh>vfp</vh></v>
<v t="ekr.20080529093004.1064"><vh>vp</vh></v>
<v t="ekr.20080529093004.1065"><vh>vsp</vh></v>
<v t="ekr.20080529093004.1066"><vh>test_stdio1</vh></v>
<v t="ekr.20080529093004.1067"><vh>test_stdio2</vh></v>
<v t="ekr.20080529093004.1068"><vh>abrt</vh></v>
<v t="ekr.20080529093004.1069"><vh>cmp</vh></v>
<v t="ekr.20080529093004.1070"><vh>done</vh></v>
<v t="ekr.20080529093004.1071"><vh>test_stdlib</vh></v>
<v t="ekr.20080529093004.1072"><vh>test_string</vh></v>
<v t="ekr.20080529093004.1073"><vh>test_time</vh></v>
</v>
</v>
</v>
<v t="ekr.20080529093004.1074"><vh>Link</vh>
<v t="ekr.20080529093004.1075"><vh>General headers</vh>
<v t="ekr.20080529093004.1076"><vh>@@file LK.h</vh></v>
<v t="ekr.20080529093004.1077"><vh>@@file LKtypes.h</vh></v>
</v>
<v t="ekr.20080529093004.1078"><vh>Library &amp; utils</vh>
<v t="ekr.20080529093004.1079"><vh>Headers</vh>
<v t="ekr.20080529093004.1080"><vh>@@file LKend.h</vh></v>
<v t="ekr.20080529093004.1081"><vh>@@file LKerr.h</vh></v>
<v t="ekr.20080529093004.1082"><vh>@@file LKmem.h</vh></v>
</v>
<v t="ekr.20080529093004.1083"><vh>Code</vh>
<v t="ekr.20080529093004.1084"><vh>@@file LKend.c</vh>
<v t="ekr.20080529093004.1085"><vh>&lt;&lt; LKend #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1086"><vh>end_close_all</vh></v>
</v>
<v t="ekr.20080529093004.1087"><vh>@@file LKerr.c</vh>
<v t="ekr.20080529093004.1088"><vh>&lt;&lt; LKerr #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1089"><vh>&lt;&lt; LKerr declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1090"><vh>err_begin_file</vh></v>
<v t="ekr.20080529093004.1091"><vh>err_begin_mess</vh></v>
<v t="ekr.20080529093004.1092"><vh>err_context</vh></v>
<v t="ekr.20080529093004.1093"><vh>err_file_name</vh></v>
<v t="ekr.20080529093004.1094"><vh>err_begin</vh></v>
<v t="ekr.20080529093004.1095"><vh>fatal_begin</vh></v>
<v t="ekr.20080529093004.1096"><vh>fatal_end</vh></v>
</v>
<v t="ekr.20080529093004.1097"><vh>@@file LKes.c</vh>
<v t="ekr.20080529093004.1098"><vh>&lt;&lt; LKes #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1099"><vh>es</vh></v>
</v>
<v t="ekr.20080529093004.1100"><vh>@@file LKlib.c</vh>
<v t="ekr.20080529093004.1101"><vh>&lt;&lt; LKlib #includes &gt;&gt;</vh></v>
</v>
<v t="ekr.20080529093004.1102"><vh>@@file LKmem.c</vh>
<v t="ekr.20080529093004.1103"><vh>&lt;&lt; LKmem #includes &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20080529093004.1104"><vh>Drivers</vh>
<v t="ekr.20080529093004.1105"><vh>Headers</vh>
<v t="ekr.20080529093004.1106"><vh>@@file LKarg.h</vh></v>
<v t="ekr.20080529093004.1107"><vh>@@file LKinit.h</vh></v>
<v t="ekr.20080529093004.1108"><vh>@@file LKmain.h</vh></v>
</v>
<v t="ekr.20080529093004.1109"><vh>Code</vh>
<v t="ekr.20080529093004.1110"><vh>@@file LKarg.c</vh>
<v t="ekr.20080529093004.1111"><vh>&lt;&lt; LKarg #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1112"><vh>&lt;&lt; LKarg declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1113"><vh>arg_do_argv</vh></v>
<v t="ekr.20080529093004.1114"><vh>arg_help</vh></v>
<v t="ekr.20080529093004.1115"><vh>arg_prefix</vh></v>
</v>
<v t="ekr.20080529093004.1116"><vh>@@file LKinit.c</vh>
<v t="ekr.20080529093004.1117"><vh>&lt;&lt; LKinit #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1118"><vh>&lt;&lt; LKinit declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1119"><vh>init_all</vh></v>
<v t="ekr.20080529093004.1120"><vh>event_call_back</vh></v>
<v t="ekr.20080529093004.1121"><vh>dump1_call_back</vh></v>
<v t="ekr.20080529093004.1122"><vh>dump2_call_back</vh></v>
<v t="ekr.20080529093004.1123"><vh>dump3_call_back</vh></v>
</v>
<v t="ekr.20080529093004.1124"><vh>@@file LKmain.c</vh>
<v t="ekr.20080529093004.1125"><vh>&lt;&lt; LKmain #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1126"><vh>&lt;&lt; LKmain declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1127"><vh>main</vh></v>
<v t="ekr.20080529093004.1128"><vh>main_dump</vh></v>
<v t="ekr.20080529093004.1129"><vh>main_quit</vh></v>
<v t="ekr.20080529093004.1130"><vh>main_read</vh></v>
<v t="ekr.20080529093004.1131"><vh>main_TMON_symbols</vh></v>
<v t="ekr.20080529093004.1132"><vh>main_TMON_area</vh></v>
<v t="ekr.20080529093004.1133"><vh>main_unload</vh></v>
</v>
</v>
</v>
<v t="ekr.20080529093004.1134"><vh>Linker</vh>
<v t="ekr.20080529093004.1135"><vh>headers</vh>
<v t="ekr.20080529093004.1136"><vh>@@file LKcheck.h</vh></v>
<v t="ekr.20080529093004.1137"><vh>@@file LKdump.h</vh></v>
<v t="ekr.20080529093004.1138"><vh>@@file LKfscan.h</vh></v>
<v t="ekr.20080529093004.1139"><vh>@@file LKlink.h</vh></v>
<v t="ekr.20080529093004.1140"><vh>@@file LKload.h</vh></v>
<v t="ekr.20080529093004.1141"><vh>@@file LKmap.h</vh></v>
<v t="ekr.20080529093004.1142"><vh>@@file LKmark.h</vh></v>
<v t="ekr.20080529093004.1143"><vh>@@file LKnodes.h</vh></v>
<v t="ekr.20080529093004.1144"><vh>@@file LKout.h</vh></v>
<v t="ekr.20080529093004.1145"><vh>@@file LKst.h</vh></v>
</v>
<v t="ekr.20080529093004.1146"><vh>code</vh>
<v t="ekr.20080529093004.1147"><vh>@@file LKcheck.c</vh>
<v t="ekr.20080529093004.1148"><vh>&lt;&lt; LKcheck #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1149"><vh>&lt;&lt; LKcheck declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1150"><vh>check_area</vh></v>
<v t="ekr.20080529093004.1151"><vh>check_comments</vh></v>
<v t="ekr.20080529093004.1152"><vh>check_dictionary</vh></v>
<v t="ekr.20080529093004.1153"><vh>check_header</vh></v>
<v t="ekr.20080529093004.1154"><vh>check_ofile</vh></v>
<v t="ekr.20080529093004.1155"><vh>check_refs</vh></v>
<v t="ekr.20080529093004.1156"><vh>check_trailer</vh></v>
<v t="ekr.20080529093004.1157"><vh>check_unit</vh></v>
<v t="ekr.20080529093004.1158"><vh>check_units</vh></v>
<v t="ekr.20080529093004.1159"><vh>check_oops</vh></v>
</v>
<v t="ekr.20080529093004.1160"><vh>@@file LKdump.c</vh>
<v t="ekr.20080529093004.1161"><vh>&lt;&lt; LKdump #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1162"><vh>&lt;&lt; LKdump declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1163"><vh>dump_area</vh></v>
<v t="ekr.20080529093004.1164"><vh>dump_dict</vh></v>
<v t="ekr.20080529093004.1165"><vh>dump_f_area</vh></v>
<v t="ekr.20080529093004.1166"><vh>dump_f_header</vh></v>
<v t="ekr.20080529093004.1167"><vh>dump_trailer</vh></v>
<v t="ekr.20080529093004.1168"><vh>dump_f_unit</vh></v>
<v t="ekr.20080529093004.1169"><vh>dump_unit</vh></v>
</v>
<v t="ekr.20080529093004.1170"><vh>@@file LKfscan.c</vh>
<v t="ekr.20080529093004.1171"><vh>&lt;&lt; LKfscan #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1172"><vh>&lt;&lt; LKfscan declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1173"><vh>fscan_make_area</vh></v>
<v t="ekr.20080529093004.1174"><vh>fscan_make_bytes</vh></v>
<v t="ekr.20080529093004.1175"><vh>fscan_make_dicts</vh></v>
<v t="ekr.20080529093004.1176"><vh>fscan_make_refs</vh></v>
<v t="ekr.20080529093004.1177"><vh>fscan_make_units</vh></v>
<v t="ekr.20080529093004.1178"><vh>fscan_preprocess</vh></v>
<v t="ekr.20080529093004.1179"><vh>fscan_rescan</vh></v>
</v>
<v t="ekr.20080529093004.1180"><vh>@@file LKlink.c</vh>
<v t="ekr.20080529093004.1181"><vh>&lt;&lt; LKlink #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1182"><vh>&lt;&lt; LKlink declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1183"><vh>link</vh></v>
<v t="ekr.20080529093004.1184"><vh>link_adjust</vh></v>
<v t="ekr.20080529093004.1185"><vh>link_adjust_area</vh></v>
<v t="ekr.20080529093004.1186"><vh>link_check</vh></v>
<v t="ekr.20080529093004.1187"><vh>link_print_file_name</vh></v>
<v t="ekr.20080529093004.1188"><vh>link_print_flist</vh></v>
<v t="ekr.20080529093004.1189"><vh>link_resolve</vh></v>
</v>
<v t="ekr.20080529093004.1190"><vh>@@file LKload.c</vh>
<v t="ekr.20080529093004.1191"><vh>&lt;&lt; LKload #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1192"><vh>&lt;&lt; LKload declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1193"><vh>load_all_areas</vh></v>
<v t="ekr.20080529093004.1194"><vh>load_one_area</vh></v>
<v t="ekr.20080529093004.1195"><vh>load_create_user_mem</vh></v>
<v t="ekr.20080529093004.1196"><vh>load_user_mem</vh></v>
<v t="ekr.20080529093004.1197"><vh>Called from the loaded program via the jump table</vh>
<v t="ekr.20080529093004.1198"><vh>_user_abort</vh></v>
<v t="ekr.20080529093004.1199"><vh>_user_exit</vh></v>
<v t="ekr.20080529093004.1200"><vh>_user_startup</vh></v>
<v t="ekr.20080529093004.1201"><vh>Library routines</vh>
<v t="ekr.20080529093004.1202"><vh>_chk_ptr</vh></v>
<v t="ekr.20080529093004.1203"><vh>_Close</vh></v>
<v t="ekr.20080529093004.1204"><vh>_Execl</vh></v>
<v t="ekr.20080529093004.1205"><vh>_Exit</vh></v>
<v t="ekr.20080529093004.1206"><vh>_Fork</vh></v>
<v t="ekr.20080529093004.1207"><vh>_Getpid</vh></v>
<v t="ekr.20080529093004.1208"><vh>_Getmem</vh></v>
<v t="ekr.20080529093004.1209"><vh>_Rename</vh></v>
<v t="ekr.20080529093004.1210"><vh>_Lseek</vh></v>
<v t="ekr.20080529093004.1211"><vh>_Open</vh></v>
<v t="ekr.20080529093004.1212"><vh>_Read</vh></v>
<v t="ekr.20080529093004.1213"><vh>_Ticks</vh></v>
<v t="ekr.20080529093004.1214"><vh>_Time</vh></v>
<v t="ekr.20080529093004.1215"><vh>_Remove</vh></v>
<v t="ekr.20080529093004.1216"><vh>_Wait</vh></v>
<v t="ekr.20080529093004.1217"><vh>_Write</vh></v>
<v t="ekr.20080529093004.1218"><vh>_add</vh></v>
<v t="ekr.20080529093004.1219"><vh>_sub</vh></v>
<v t="ekr.20080529093004.1220"><vh>_mul</vh></v>
<v t="ekr.20080529093004.1221"><vh>_div</vh></v>
<v t="ekr.20080529093004.1222"><vh>_eq</vh></v>
<v t="ekr.20080529093004.1223"><vh>_gt</vh></v>
<v t="ekr.20080529093004.1224"><vh>_d2l</vh></v>
<v t="ekr.20080529093004.1225"><vh>_l2d</vh></v>
<v t="ekr.20080529093004.1226"><vh>_d2f</vh></v>
<v t="ekr.20080529093004.1227"><vh>_f2d</vh></v>
<v t="ekr.20080529093004.1228"><vh>_neg</vh></v>
</v>
</v>
</v>
<v t="ekr.20080529093004.1229"><vh>@@file LKmap.c</vh>
<v t="ekr.20080529093004.1230"><vh>&lt;&lt; LKmap #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1231"><vh>&lt;&lt; LKmap declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1232"><vh>map_all_areas</vh></v>
<v t="ekr.20080529093004.1233"><vh>map_all_files</vh></v>
<v t="ekr.20080529093004.1234"><vh>map_area</vh></v>
<v t="ekr.20080529093004.1235"><vh>map_header</vh></v>
<v t="ekr.20080529093004.1236"><vh>map_begin_comment_line</vh></v>
<v t="ekr.20080529093004.1237"><vh>map_grand_totals</vh></v>
<v t="ekr.20080529093004.1238"><vh>map_one_file</vh></v>
<v t="ekr.20080529093004.1239"><vh>map_out_dict</vh></v>
<v t="ekr.20080529093004.1240"><vh>map_subtree</vh></v>
<v t="ekr.20080529093004.1241"><vh>map_tree</vh></v>
</v>
<v t="ekr.20080529093004.1242"><vh>@@file LKmark.c</vh>
<v t="ekr.20080529093004.1243"><vh>&lt;&lt; LKmark #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1244"><vh>&lt;&lt; LKmark declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1245"><vh>mark</vh></v>
<v t="ekr.20080529093004.1246"><vh>mark_reorder</vh></v>
<v t="ekr.20080529093004.1247"><vh>scan_area</vh></v>
<v t="ekr.20080529093004.1248"><vh>scan_unit</vh></v>
</v>
<v t="ekr.20080529093004.1249"><vh>@@file LKout.c</vh>
<v t="ekr.20080529093004.1250"><vh>&lt;&lt; LKout #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1251"><vh>&lt;&lt; LKout declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1252"><vh>out_area</vh></v>
<v t="ekr.20080529093004.1253"><vh>out_file</vh></v>
</v>
<v t="ekr.20080529093004.1254"><vh>@@file LKst.c</vh>
<v t="ekr.20080529093004.1255"><vh>&lt;&lt; LKst #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1256"><vh>&lt;&lt; LKst declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1257"><vh>fst_enter</vh></v>
<v t="ekr.20080529093004.1258"><vh>fst_hash</vh></v>
<v t="ekr.20080529093004.1259"><vh>fst_lookup</vh></v>
<v t="ekr.20080529093004.1260"><vh>st_dump</vh></v>
<v t="ekr.20080529093004.1261"><vh>st_enter</vh></v>
<v t="ekr.20080529093004.1262"><vh>st_hash</vh></v>
<v t="ekr.20080529093004.1263"><vh>st_init</vh></v>
<v t="ekr.20080529093004.1264"><vh>st_lookup</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20080529093004.1265"><vh>Load</vh>
<v t="ekr.20080529093004.1266"><vh>headers</vh>
<v t="ekr.20080529093004.1267"><vh>@@file Debugger.h</vh></v>
<v t="ekr.20080529093004.1268"><vh>@@file LD.h</vh></v>
<v t="ekr.20080529093004.1269"><vh>@@file LDarg.h</vh></v>
<v t="ekr.20080529093004.1270"><vh>@@file LDdisasm.h</vh></v>
<v t="ekr.20080529093004.1271"><vh>@@file LDend.h</vh></v>
<v t="ekr.20080529093004.1272"><vh>@@file LDes.h</vh></v>
<v t="ekr.20080529093004.1273"><vh>@@file LDinit.h</vh></v>
<v t="ekr.20080529093004.1274"><vh>@@file LDload.h</vh></v>
<v t="ekr.20080529093004.1275"><vh>@@file LDmain.h</vh></v>
<v t="ekr.20080529093004.1276"><vh>@@file LDmem.h</vh></v>
<v t="ekr.20080529093004.1277"><vh>@@file LDtypes.h</vh></v>
<v t="ekr.20080529093004.1278"><vh>@@file LDerr.h</vh></v>
</v>
<v t="ekr.20080529093004.1279"><vh>code</vh>
<v t="ekr.20080529093004.1280"><vh>@@file Debugger.c</vh>
<v t="ekr.20080529093004.1281"><vh>&lt;&lt; Debugger #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1282"><vh>&lt;&lt; Debugger declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1283"><vh>trm_asm_g</vh></v>
<v t="ekr.20080529093004.1284"><vh>trm_asm_p</vh></v>
<v t="ekr.20080529093004.1285"><vh>trm_asm_quit</vh></v>
<v t="ekr.20080529093004.1286"><vh>trm_asm_t</vh></v>
<v t="ekr.20080529093004.1287"><vh>eblank</vh></v>
<v t="ekr.20080529093004.1288"><vh>eblanks</vh></v>
<v t="ekr.20080529093004.1289"><vh>echar</vh></v>
<v t="ekr.20080529093004.1290"><vh>ecnl</vh></v>
<v t="ekr.20080529093004.1291"><vh>ecnls</vh></v>
<v t="ekr.20080529093004.1292"><vh>enl</vh></v>
<v t="ekr.20080529093004.1293"><vh>epadhex</vh></v>
<v t="ekr.20080529093004.1294"><vh>es</vh></v>
<v t="ekr.20080529093004.1295"><vh>eulong</vh></v>
<v t="ekr.20080529093004.1296"><vh>get_dec</vh></v>
<v t="ekr.20080529093004.1297"><vh>get_hex</vh></v>
<v t="ekr.20080529093004.1298"><vh>get_radix</vh></v>
<v t="ekr.20080529093004.1299"><vh>trm_command</vh></v>
<v t="ekr.20080529093004.1300"><vh>trm_help</vh></v>
<v t="ekr.20080529093004.1301"><vh>trm_init</vh></v>
<v t="ekr.20080529093004.1302"><vh>trm_main</vh></v>
<v t="ekr.20080529093004.1303"><vh>trm_br</vh></v>
<v t="ekr.20080529093004.1304"><vh>trm_br_display</vh></v>
<v t="ekr.20080529093004.1305"><vh>trm_md</vh></v>
<v t="ekr.20080529093004.1306"><vh>trm_mm</vh></v>
<v t="ekr.20080529093004.1307"><vh>trm_nobr</vh></v>
<v t="ekr.20080529093004.1308"><vh>trm_nobr_all</vh></v>
<v t="ekr.20080529093004.1309"><vh>trm_p</vh></v>
<v t="ekr.20080529093004.1310"><vh>trm_rd</vh></v>
<v t="ekr.20080529093004.1311"><vh>trm_rd_all</vh></v>
<v t="ekr.20080529093004.1312"><vh>trm_rm</vh></v>
</v>
<v t="ekr.20080529093004.1313"><vh>@@file LDarg.c</vh>
<v t="ekr.20080529093004.1314"><vh>&lt;&lt; LDarg #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1315"><vh>&lt;&lt; LDarg declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1316"><vh>arg_do_argv</vh></v>
<v t="ekr.20080529093004.1317"><vh>arg_help</vh></v>
<v t="ekr.20080529093004.1318"><vh>arg_prefix</vh></v>
</v>
<v t="ekr.20080529093004.1319"><vh>@@file LDdisasm.c</vh>
<v t="ekr.20080529093004.1320"><vh>&lt;&lt; LDdisasm #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1321"><vh>&lt;&lt; LDdisasm declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1322"><vh>disassemble</vh></v>
<v t="ekr.20080529093004.1323"><vh>op0df</vh></v>
<v t="ekr.20080529093004.1324"><vh>op1df</vh></v>
<v t="ekr.20080529093004.1325"><vh>op2df</vh></v>
<v t="ekr.20080529093004.1326"><vh>op3df</vh></v>
<v t="ekr.20080529093004.1327"><vh>op4df</vh></v>
<v t="ekr.20080529093004.1328"><vh>opcc0df</vh></v>
<v t="ekr.20080529093004.1329"><vh>opcc1df</vh></v>
<v t="ekr.20080529093004.1330"><vh>opcc2df</vh></v>
</v>
<v t="ekr.20080529093004.1331"><vh>@@file LDend.c</vh>
<v t="ekr.20080529093004.1332"><vh>&lt;&lt; LDend #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1333"><vh>end_close_all</vh></v>
</v>
<v t="ekr.20080529093004.1334"><vh>@@file LDerr.c</vh>
<v t="ekr.20080529093004.1335"><vh>&lt;&lt; LDerr #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1336"><vh>&lt;&lt; LDerr declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1337"><vh>err_context</vh></v>
<v t="ekr.20080529093004.1338"><vh>err_init_again</vh></v>
<v t="ekr.20080529093004.1339"><vh>err_begin_mess</vh></v>
<v t="ekr.20080529093004.1340"><vh>err_begin</vh></v>
<v t="ekr.20080529093004.1341"><vh>fatal_begin</vh></v>
<v t="ekr.20080529093004.1342"><vh>fatal_end</vh></v>
<v t="ekr.20080529093004.1343"><vh>help_begin</vh></v>
<v t="ekr.20080529093004.1344"><vh>user_fatal_begin</vh></v>
<v t="ekr.20080529093004.1345"><vh>user_fatal_end</vh></v>
<v t="ekr.20080529093004.1346"><vh>warn_begin</vh></v>
</v>
<v t="ekr.20080529093004.1347"><vh>@@file LDes.c</vh>
<v t="ekr.20080529093004.1348"><vh>&lt;&lt; LDes #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1349"><vh>es</vh></v>
</v>
<v t="ekr.20080529093004.1350"><vh>@@file LDinit.c</vh>
<v t="ekr.20080529093004.1351"><vh>&lt;&lt; LDinit #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1352"><vh>&lt;&lt; LDinit declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1353"><vh>init_all</vh></v>
<v t="ekr.20080529093004.1354"><vh>event_call_back</vh></v>
<v t="ekr.20080529093004.1355"><vh>dump1_call_back</vh></v>
<v t="ekr.20080529093004.1356"><vh>dump2_call_back</vh></v>
<v t="ekr.20080529093004.1357"><vh>dump3_call_back</vh></v>
</v>
<v t="ekr.20080529093004.1358"><vh>@@file LDlib.c</vh>
<v t="ekr.20080529093004.1359"><vh>&lt;&lt; LDlib #includes &gt;&gt;</vh></v>
</v>
<v t="ekr.20080529093004.1360"><vh>@@file LDload.c</vh>
<v t="ekr.20080529093004.1361"><vh>&lt;&lt; LDload #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1362"><vh>&lt;&lt; LDload declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1363"><vh>load</vh></v>
<v t="ekr.20080529093004.1364"><vh>_user_abort</vh></v>
<v t="ekr.20080529093004.1365"><vh>_user_exit</vh></v>
<v t="ekr.20080529093004.1366"><vh>_user_startup</vh></v>
<v t="ekr.20080529093004.1367"><vh>_chk_ptr</vh></v>
<v t="ekr.20080529093004.1368"><vh>_Close</vh></v>
<v t="ekr.20080529093004.1369"><vh>_Execl</vh></v>
<v t="ekr.20080529093004.1370"><vh>_Exit</vh></v>
<v t="ekr.20080529093004.1371"><vh>_Fork</vh></v>
<v t="ekr.20080529093004.1372"><vh>_Getpid</vh></v>
<v t="ekr.20080529093004.1373"><vh>_Getmem</vh></v>
<v t="ekr.20080529093004.1374"><vh>_Rename</vh></v>
<v t="ekr.20080529093004.1375"><vh>_Lseek</vh></v>
<v t="ekr.20080529093004.1376"><vh>_Open</vh></v>
<v t="ekr.20080529093004.1377"><vh>_Read</vh></v>
<v t="ekr.20080529093004.1378"><vh>_Ticks</vh></v>
<v t="ekr.20080529093004.1379"><vh>_Time</vh></v>
<v t="ekr.20080529093004.1380"><vh>_Remove</vh></v>
<v t="ekr.20080529093004.1381"><vh>_Wait</vh></v>
<v t="ekr.20080529093004.1382"><vh>_Write</vh></v>
</v>
<v t="ekr.20080529093004.1383"><vh>@@file LDmain.c</vh>
<v t="ekr.20080529093004.1384"><vh>&lt;&lt; LDmain #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1385"><vh>&lt;&lt; LDmain declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.1386"><vh>main</vh></v>
<v t="ekr.20080529093004.1387"><vh>main_db</vh></v>
<v t="ekr.20080529093004.1388"><vh>main_free_all</vh></v>
<v t="ekr.20080529093004.1389"><vh>main_quit</vh></v>
<v t="ekr.20080529093004.1390"><vh>main_report</vh></v>
</v>
<v t="ekr.20080529093004.1391"><vh>@@file LDmem.c</vh>
<v t="ekr.20080529093004.1392"><vh>&lt;&lt; LDmem #includes &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20080529093004.1393"><vh>An example of how Leo can clarify code</vh>
<v t="ekr.20080529093004.477"><vh>@@file CCtokize.c</vh>
<v t="ekr.20080529093004.478"><vh>&lt;&lt; CCtokize #includes &gt;&gt;</vh></v>
<v t="ekr.20080529093004.479"><vh>&lt;&lt; CCtokize declarations &gt;&gt;</vh></v>
<v t="ekr.20080529093004.480" a="M"><vh>tokize (the main tokenizer routine)</vh>
<v t="ekr.20080529093004.481"><vh>&lt;&lt; declare and initialize local variables &gt;&gt;</vh></v>
<v t="ekr.20080529093004.482"><vh>&lt;&lt; initialize global variables &gt;&gt;</vh></v>
<v t="ekr.20080529093004.483"><vh>&lt;&lt; trace the main loop &gt;&gt;</vh></v>
<v t="ekr.20080529093004.484"><vh>&lt;&lt; cases of the main switch &gt;&gt;</vh>
<v t="ekr.20080529093004.485"><vh>&lt;&lt; letter cases &gt;&gt;</vh></v>
<v t="ekr.20080529093004.486"><vh>&lt;&lt; whitespace cases &gt;&gt;</vh></v>
<v t="ekr.20080529093004.487"><vh>&lt;&lt; slashes or comments cases &gt;&gt;</vh></v>
<v t="ekr.20080529093004.488"><vh>&lt;&lt; strings and characters constants cases &gt;&gt;</vh></v>
<v t="ekr.20080529093004.489"><vh>&lt;&lt; '&lt;' and filenames cases &gt;&gt;</vh></v>
<v t="ekr.20080529093004.490"><vh>&lt;&lt; simple tokens cases &gt;&gt;</vh></v>
<v t="ekr.20080529093004.491"><vh>&lt;&lt; integer or floating constant cases &gt;&gt;</vh></v>
<v t="ekr.20080529093004.492"><vh>&lt;&lt; default case &gt;&gt;</vh></v>
</v>
<v t="ekr.20080529093004.493"><vh>&lt;&lt; handle errors &gt;&gt;</vh></v>
<v t="ekr.20080529093004.494"><vh>&lt;&lt; output final tokens &gt;&gt;</vh></v>
<v t="ekr.20080529093004.495"><vh>&lt;&lt; Save global variables &gt;&gt;</vh></v>
<v t="ekr.20080529093004.496"><vh>&lt;&lt; Output dumps and statistics &gt;&gt;</vh></v>
</v>
<v t="ekr.20080529093004.497"><vh>stats1</vh></v>
<v t="ekr.20080529093004.498"><vh>tok_dump_speed</vh></v>
<v t="ekr.20080529093004.499"><vh>tok_dump_stats</vh></v>
<v t="ekr.20080529093004.500"><vh>tok_init_hash_tab</vh></v>
<v t="ekr.20080529093004.501"><vh>tok_enter (enter)</vh></v>
<v t="ekr.20080529093004.502"><vh>tok_lookup</vh></v>
<v t="ekr.20080529093004.503"><vh>tok_hash</vh></v>
<v t="ekr.20080529093004.504"><vh>tok_lookup_hash</vh></v>
<v t="ekr.20080529093004.505"><vh>tok_reinit_stats</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20080529093004.2"></t>
<t tx="ekr.20080529093004.3">@ This file contains the bulk of the source code for a C compiler, assember, linker and loader written for Tuple, Inc.  It shows how Leo can organize complex code.</t>
<t tx="ekr.20080529093004.4">@ignore</t>
<t tx="ekr.20080529093004.5">import leoImport
leoImport.importFiles("c:/prog/Tuple/CC2/CC2/CC2Doc", ".txt")</t>
<t tx="ekr.20080529093004.6">from leoGlobals import *
c = top()
v = c.rootVnode()
count = 0
while v:
	s = v.bodyString()
	if len(s) &gt; 0 and s[0] == '\n':
		s = s[1:]
		v.setBodyStringOrPane(s)
		count = count + 1
	v = v.threadNext()
es("%s nodes changed" % (count))</t>
<t tx="ekr.20080529093004.7">@ignore
@language c</t>
<t tx="ekr.20080529093004.8"></t>
<t tx="ekr.20080529093004.9">/*
	AS: Master header file

	source:  AS.h
	started: November 4, 1993.
	version:
		January 17, 1994.
			Added set_bit macro.
*/

#ifndef as_h_
#define as_h_

#pragma once

/*
	Include files that should be included in each file.
	AStypes.h must be included first.
*/

#include &lt;LIBlib.h&gt;		/* Must be first. */
#include "AStypes.h"	/* Must be second. */
#include "ASerr.h"

/*
	Define abbreviations for the assembler.
	Standard abbreviations are defined in &lt;LIBlib.h&gt;
*/

#define bit(field,the_bits)			((field) &amp; (the_bits))
#define clear_bit(field,the_bits)	{(field) &amp;= ~(the_bits);}
#define set_bit(field,the_bits) 	{(field) |= (the_bits);}

#endif /* as_h_ */
</t>
<t tx="ekr.20080529093004.10">/*
	AS: global type definitions and type-related macros.

	source: AStypes.h
	started: December 20, 1993.
	version:
		March 18, 1994.
			Replace item_nodes with dict_nodes.
			Added declaration of area_nodes.
		March 6, 1994.
			Changed n_next to next in all nodes so list macros may be used.
			Eliminated LIST_TYPE and LIST2_TYPE macros.
		February 24, 1994.
			Removed all references to types defined in LIBtypes.h.
			Removed several types that did not need to be defined here.
		January 4,1 1993.
			Removed most anode types.
		December 28, 1993.
			Added support for ASanodes.h, AScnodes.h.
			Removed ASnodes.h.
		December 27, 1993.
			file_info_node's are defined in cpp.h.
		December 23, 1993.
			Eliminated skip_blocks.
			
	This file defines "friend" types, that is,
	types that are refered to in other headers.
	
	Most types need not, and should not be defined here.
	
	Also note that library types are defined in LIBtypes.h, not here.
	  
	Pros:
	? Eliminates the need to #include non-library files from header files.
	? Eliminates problems of circular file dependecies.
	? Reduces the number of files that depend on any header.
	? Header files can be included in any order.
	? Makes explicit the distinction between global and local types.
	  Global types appear here.  Local types should be declared static.

	Cons:
	? Header files are not self contained; they depend on this file.
	  However, the typedefs defined here can be repeated in the other
	  header files if they are protected by #ifndef AS_filename_TYPEDEFS
	? Changing any of these definitions requires recompiling *all* files.
	? Global types are exposed to all files.
*/

#ifndef AStypes_h_
#define AStypes_h_

#pragma once

/*
	Define types unique to the assembler.
*/

	/* General: the following are used in several header files. */

#define COMMON_NODE_HEAD	/* Common part of all nodes. */\
	int	n_type				/* Node type. */

#define LINKED_NODE_HEAD	/* Header for all linked nodes. */\
	COMMON_NODE_HEAD;\
	void *	next

typedef struct linked_struct linked_node;	/* Common part of all linked nodes. */

struct linked_struct {
	LINKED_NODE_HEAD;
};

	/* ASanodes.h */

#define AS_ANODE_TYPEDEFS
	typedef struct anode_struct	anode;

	/* AScnodes.h */

#define AS_CNODE_TYPEDEFS
	typedef struct cnode_struct		cnode;	/* Common part of all cnodes. */
	typedef struct cinode_struct	cinode;	/* Code instruction. */

	/* AScpp.h */

#define AS_CPP_TYPEDEFS
	typedef struct file_info_struct	file_info_node;

	/* ASexp.h */

#define AS_EXP_TYPEDEFS
	typedef struct enode_struct enode;
	typedef struct summary_enode_struct	summary_enode;

	/* ASmacro.h */

#define AS_MACRO_TYPEDEFS
	typedef struct mac_def_node_struct mac_def_node;

	/* ASofile.h */

#define AS_OFILE_TYPEDEFS
	typedef struct area_node_struct		area_node;
	typedef struct comment_node_struct	comment_node;
	typedef struct dict_node_struct		dict_node;
	typedef struct ref_node_struct		ref_node;
	typedef struct unit_node_struct		unit_node;

	/*
		AStokens.h

		A token should be a short, not a char,
		so that all fields of a token will be aligned on an even-byte boundary.
		Using a 1-byte token will work on the 68030,
		but will cause a bus error on the 68000 when the pointer field is accessed.
		
		Spelling nodes are essentially part of tokens,
		and are now defined in AStokens.h.
	*/

#define AS_TOKEN_TYPEDEFS
	typedef ushort token;
	typedef struct spell_node_struct spell_node;

#endif /* AStypes_h_ */
</t>
<t tx="ekr.20080529093004.11">/*
	AS: Header file describing the environment of the target machine.

	Source:  AStarget.h
	Started: July 15, 1994.
	Version: January 24, 1995
	
	Warning: the values in this file should match the values in CCtarget.c.
*/

#ifndef AStarget_h_
#define AStarget_h_

#pragma once

#define FLOAT_SIZE			4
#define DOUBLE_SIZE			8	/* Requires Think C 8-byte double option. */
#define LONG_DOUBLE_SIZE	8	/* Changed 1/24/95 */

#endif /* AStarget_h_ */
</t>
<t tx="ekr.20080529093004.12"></t>
<t tx="ekr.20080529093004.13">		
</t>
<t tx="ekr.20080529093004.14">/*
	AS: Header file for ASasm.c and globals.

	source:  ASasm.h
	started: September 22, 1993.
	version: March 10, 1994.
*/

#ifndef ASasm_h_
#define ASasm_h_

#pragma once

/*
	We define the following silly-looking macro because the PERM_ASSERT_TRACE
	macro is *very* effective in catching bugs in the assembler.
*/
#define set_cbits_macro(cip, bits) \
{\
	PERM_ASSERT_TRACE(((cip -&gt; c_bits) &amp; (bits)) == 0, asm_bad_bits_error(cip, bits));\
	cip -&gt; c_bits |= (bits);\
}

/*
	Function prototypes for the assembler.
*/

cinode *assemble(cinode * cip);
void	asm_bad_bits_error	(cinode * cip, ushort bits);

#endif /* ASasm_h_ */</t>
<t tx="ekr.20080529093004.15">/*
	AS: Header for disassembler.

	source:  ASdisasm.h
	started: November 28, 1993.
	version:
		November 28, 1993.
*/

#ifndef ASdisasm_h_
#define ASdisasm_h_

#pragma once

cnode * disassemble(char * ip);

#endif /* ASdisasm_h_ */</t>
<t tx="ekr.20080529093004.16">/*
	AS: header for ASexp.c.

	source:  ASexp.h
	started: December 28, 1993.
	version:
		July 17, 1994.
			Bug fix: Added sign_kind parameter to expr_get_val.
		May 2, 1994.
			Added delayed_error_line argument to expr_get_val.
		April 4, 1994.
			Added string_enode's.
			Added allow_strings_flag flag to expr_value.
		February 23, 1994.
			Changed var_enodes so they point to m_item_nodes instead of snodes.
		February 11, 1994.
			Added expr_get_val.
		February 10, 1994.
			Added new_summary_enode_macro.
			Bug fix to new_var_enode_macro.
		February 9, 1994.
			Removed op and type fields from enodes.
		December 30, 1993.
			Revised format of enodes.
			Added enode_ptr.
		December 29, 1993.
*/

#ifndef ASexp_h_
#define ASexp_h_

#pragma once

	/* Abbreviations. */

#define enode_ptr(p) 			((enode *) (p))
#define const_enode_ptr(p)		((const_enode *) (p))
#define m_dict_list_enode_ptr(p)((m_dict_list_enode *) (p))
#define float_enode_ptr(p)		((float_enode *) (p))
#define string_enode_ptr(p)		((string_enode *) (p))
#define summary_enode_ptr(p)	((summary_enode *) (p))
#define var_enode_ptr(p)		((var_enode *) (p))

	/* Macros. */

#define new_enode_macro(p,op) \
{\
	new_macro(p, file_life, enode_stats);\
	p -&gt; n_type = op;\
}

	/* Globally visible types. */

#ifndef AS_EXP_TYPEDEFS
	#define AS_EXP_TYPEDEFS
	typedef struct enode_struct 		enode;
	typedef struct summary_enode_struct	summary_enode;
#endif

	/* Types visible only when using this file. */

	typedef struct const_enode_struct		const_enode;
	typedef struct m_dict_list_enode_struct	m_dict_list_enode;
	typedef struct float_enode_struct		float_enode;
	typedef struct string_enode_struct		string_enode;
	typedef struct var_enode_struct			var_enode;

/* n_type = PLUS_TOK, MINUS_TOK, STAR_TOK, DIV_TOK, UPLUS_TOK, UMINUS_TOK */
struct enode_struct {
	COMMON_NODE_HEAD;
	enode * arg1;
	enode * arg2;
};

struct const_enode_struct {
	COMMON_NODE_HEAD;			/* n_type = INT_TOK. */
	long	val;
};

struct m_dict_list_enode_struct {
	COMMON_NODE_HEAD;			/* n_type = O_SLIST. */
	m_dict_list_enode *	next;
	dict_node *		the_m_dict;
};

struct float_enode_struct {
	COMMON_NODE_HEAD;			/* n_type = STRING_TOK. */
	char *	the_float;
	long double float_val;
};

struct string_enode_struct {
	COMMON_NODE_HEAD;			/* n_type = CHAR_TOK. */
	char * the_string;
};

struct summary_enode_struct {
	COMMON_NODE_HEAD;			/* n_type = O_SUMMARY. */
	long				val;	/* This *must* be signed for expr_get_val to work. */
	m_dict_list_enode *	pos_label_list;
	m_dict_list_enode *	neg_label_list;
};

struct var_enode_struct {
	COMMON_NODE_HEAD;			/* n_type = ID_TOK. */
	dict_node * 		var_m_dict;
};

/* The values of the type field. */
enum {E_NO_TYPE = 0, E_ABS_TYPE, E_REL_TYPE};

	/* Prototypes. */

	/* Synonyms for the minus_paren_flag. */
	enum { NOTHING_SEEN_YET = 0, MINUS_PAREN_SEEN, PAREN_SEEN, MINUS_SEEN };
	
	/* Synonyms for allow_strings_flag. */
	enum { ALLOW_STRINGS = TRUE, DONT_ALLOW_STRINGS = FALSE };
	
	/* Synonyms for allow_refs_flag. */
	enum { ALLOW_UNKNOWN_REFS = TRUE, DONT_ALLOW_UNKNOWN_REFS = FALSE };
	
	/* Synonyms for sign_kind. */
	enum { UNSIGNED_FIELD = 1, SIGNED_FIELD = 2, NO_SIGN_FIELD = 3 };

void	eenode		(enode * ep);
long	expr_get_val
	(
		enode * ep, ushort bytes,
		bool * error_flag, bool allow_unknown_refs_flag,
		ulong delayed_error_line,
		short sign_kind
	);
enode * expr_value	(int minus_paren_flag, bool allow_strings_flag);

#endif /* ASexp_h_ */
</t>
<t tx="ekr.20080529093004.17">/*
	AS: header for ASfold.c.
	
	source:  ASfold.h
	started: February 9, 1994.
	version: February 9, 1994.
*/

#ifndef ASfold_h_
#define ASfold_h_

	/* Function prototypes. */

enode * fold1 (enode * ep);
enode * fold2 (enode * ep);

#endif /* ASfold_h_ */</t>
<t tx="ekr.20080529093004.18">/*
	AS: header file describing in-memory classes related to object files.
	
	The following documentation is the most important in all the assembler.

	source:  ASofile.h
	started: December 28, 1993.
	version:
		February 3, 1995.
			Added dump_comment().
			Added comment_nodes.
			Added area_comments field to areas.
		May 19, 1994.
			Added unit_dict.
		May 13, 1994.
			Added area_index field to area nodes.
		May 11, 1994.
			Areas now contain reference lists.
		May 9, 1994.
			This file inherits definitions of flag fields from LIBofile.h.
			Removed m_ prefix from several fields.
		May 3, 1994.
			Added dict_err_line field for error messages.
		March 22, 1994.
			Added prototype of out_ofile.
			Moved all f_xxx_nodes to ASofile.c.
		March 18, 1994.
			A major revision of all classes in this file.
				The file header points to a symbol dictionary.
				Units contain areas.
				Areas contain code lists.
				Labels represent addresses only.
				Indices are assigned to units and labels.
		March 16, 1994.
			Added prototypes for routines in ASofile.c.
		March 8, 1994.
			Defined ref_set_neg and ref_is_neg macros.
			Changed ref_unused to ref_flags.
*/

#ifndef ASofile_h_
#define ASofile_h_

#pragma once

	/* This file inherits definitions of flag fields from LIBofile.h. */
#include &lt;LIBofile.h&gt;

/*
	General remarks and definitions.
	
	This file defines the in-memory classes used to created an object file.
	This file was revised on 3/17/94 to reflect a new understanding
	of how to treat units, areas, labels and references.
	The disk versions of these classes are defined and used only in ASofile.c.
		
	-- MPW mnemonics --
	
	The Tuple assembler uses the same mnemonics for instructions and pseudo
	instructions used by the MPW assembler.
	This saves documentation and simplifies porting from MPW to the Tuple environment.
			
	-- Units --
	
	A unit is the smallest element of an object file that can be included
	in an application by the linker.
	A RECORD unit represents all instructions from a RECORD directive to
	the corresponding ENDR directive.
	Similarly, a PROC unit represents all instructions from a PROC directive
	to the corresponding ENDPROC directive.
	
	An entire RECORD or PROC will be included in an application by the linker
	if any label in the RECORD or PROC is reachable from the main PROC.
	
	The linker is free to allocate units to the application space as it sees fit.
	Thus, *nothing* can be assumed at assembly time about the relationship
	between the addresses of separate units.
		
	-- Areas and code lists --
	
	Each unit consists of a code area and a data area, either of which may be empty.
	Code and data areas exist so that the compiler can intermix data and code.
	RECORD units consist only of a data area, while PROC units may contain either.

	The CODE pseudo operation denotes that instructions are to be placed
	in the code area and the DATA pseudo operation denotes that instruction
	are to be placed in the data area.
	
	The linker allocates code areas separately from data areas,
	regardless of how CODE and DATA directives are actually intermixed in a unit.
	For example, the following two versions of main PROC are completely equivalent:
	
		main 	PROC					main	PROC
		start:	jmp	next						DATA
				DATA							DC.B	'abc'
				DC.B	'abc'					CODE
				CODE					start:	jmp	next
		next:	jmp		end				next:	jmp end	
				DATA					end:	rts
				DC.B	'xyz'					DATA
		end:	rts								DC.B	'xyz'
				ENDPROC							ENDPROC
	
	From this example it will be seen that code and data areas
	must exist even if the processor makes no actual distinction between
	code and data segments.
		
	Units and areas are "thick."  That is, they consist of a *sequence* of bytes.
	These bytes are represented by *byte lists*,
	sequences of byte nodes representing instructions and
	data-generating pseudo operations such as ALIGN, DC and DCB.
	
	The linker must insure that all *hidden relationships* are preserved *within*
	an area, as shown in the example above.
	This can be done by insuring that the order of cnodes within code lists
	corresponds to the order of instructions within the source file.
	
	-- Labels, addresses and references --
	
	A label represents an address or offset within a specified area.
	Unlike an area, a label is "thin".  It represents an address, not bits.
	Picture a label as a mathematical point and an area as a line segment.
	
	As stated earlier, the linker is free to allocate units arbitrarily.
	Because of this, there is no such thing as a "global" location counter.
	Instead, each area of each unit has its own location counter.
	The semantic routines keep track of the "current area" and that area's
	location counter is incremented as required.
	
	Because each area has its own location counter,
	labels can only be specified as an offset *relative to a particular area.*
	Therefore, labels are represented as an area number and an offset within this area.
	Similarly, a reference denotes a label and must also contain both an area
	number and an offset within the area.
	
	The present assembler and linker require that all labels within a file be unique.
	Local labels are supported, however.
	If a label is defined within a file and nowhere delcared to be EXTERN or ENTRY,
	then that label is a local label.
	The linker will only resolve references to a local label from references
	within the file containing the local label.
	Of course, multiple local labels with the same name may exist in a program,
	provided that each local label is defined in a separate file.
	
	-- Indices, offsets and dictionaries --
	
	The biggest problem in converting between in_memory structures and file structures
	is converting between address and offsets.
	Addresses in memory have no meaning in a disk file,
	and addresses are not preserved when a structure is written to a disk file and then
	read back from the file into memory.
	
	In a disk file, an *offset* of a byte is its distance from the start of the file.
	Thus, an offset represents a "file-relative address."
	An *index*, on the other hand, represents not an address but a position in
	some table whose location is usually implicit from context.
	
	When creating the output file the assembler will use indices instead of offsets
	for references to labels and units.
	This simplifies the assembler because these offsets can be written directly
	to disk without an intermediate translation to an offset.

	The assembler assigns a unique index to each label the first time that label is
	encountered either as a definition or a reference.
	Similarly, the assembler assigns a unique index to each unit when
	a PROC or RECORD directive is seen.
	
	Using indices instead of offsets does not complicate the linker.
	Of course, the linker must determine the proper index for each label and unit.
	This is done as follows.
	Labels are represented by entries in the *symbol dictionary*, appearing just
	after the file's header.
	The i'th entry in the dictionary has index i.
	Similarly, units are represented in the object file as a list whose i'th
	member has index i.
	
	The linker creates in-memory addresses for its data structures as follows.
	First, it computes an index for each unit and label.
	The linker creates the in-memory structures corresponding to the
	data structures found in the disk file,
	and using auxiallary tables associates an address with each label and unit.
	A final pass translates from indices to addresses.
	
	-- comment nodes --
	
	These were added 2/3/95.
	They represent line and stack offset comments.
*/

	/*
		Types.
	*/
	
#ifndef AS_OFILE_TYPEDEFS
	#define AS_OFILE_TYPEDEFS
	typedef struct area_node_struct		area_node;
	typedef struct comment_node_struct	comment_node;
	typedef struct dict_node_struct		dict_node;
	typedef struct ref_node_struct		ref_node;
	typedef struct unit_node_struct		unit_node;
#endif

/*
	An area consists of an ordered sequence of bits, specified by a code list.
*/

struct area_node_struct {
	ulong			area_index;			/* Index of this area in the output file. */
	cnode *			area_code_list;		/* List of instructions comprising the area. */
	ulong			area_app_length;	/* Size of the area in the application. */
	ref_node *		area_refs;			/* List of all references in the area. */
	comment_node *	area_comments;		/* List of all comments in the area. */
	dict_node *		area_dict;			/* The first label of the area. */
};

/*
	The comment list contains all line and stack comments for an area.
*/
static struct comment_node_struct {
	comment_node *	comment_next;	/* List of all comment nodes. */
	short			comment_kind;	/* C_xxx_COMMENT: see LIBofile.h. */
	ulong			comment_offset;	/* Stack offset (location counter for line comments) */
	ulong			comment_size;	/* Size of variable (not used for line comments) */
};

/*
	The symbol dictionary contains one entry for each symbol defined or
	referenced in the object file.
*/
struct dict_node_struct {
	dict_node *		next;			/* List of all dict nodes. */
	ulong			dict_index;		/* Future file index of this dict node. */
	spell_node *	dict_spell;		/* The spelling node for this symbol. */
	area_node *		dict_area;		/* The area in which the label is defined, or 0. */
	ulong			dict_offset;	/* Offset of the symbol from the start of the unit. */
	ulong			dict_err_line;	/* Line of first reference for error messages. */
	
		/* Dictionary flags are the same whether on disk or in memory. */

	short	dict_flags;		/* Dictionary flags: see LIBofile.h. */
};

/*
	Each area contains a list of references contained within the area.
	This list is used by the linker in two ways:
	1) To determine what units to link into the application.
	2) To patch fields within included units.

	Reference nodes represent a reference to an atom of the indicated size.
*/

	/* Synonyms for the values of the f_ref_size field. */
	enum { WORD_REF = 2, LONG_REF = 4 };

struct ref_node_struct {

	ref_node *	ref_next;	/* Pointer to next node on the reference list. */
	dict_node *	ref_dict;	/* Pointer to the item being referenced. */
	ulong		ref_offset;	/* Bytes from start of unit of the field to be patched. */
	short		ref_size;	/* The size of the field to be patched, in bytes. */
	
		/* Reference flags are the same whether on disk or in memory. */

	short ref_flags;	/* Reference flags: see LIBofile.h. */
};

/*
	A unit is the smallest element that can be included or excluded from an
	application by the linker.
*/

struct unit_node_struct {
	unit_node *	next;			/* The next unit in the global unit list. */
	ulong		unit_index;		/* Future file index of this unit node. */
	area_node *	unit_code_area;	/* The unit's code area. */
	area_node *	unit_data_area;	/* The unit's code area. */
	dict_node *	unit_dict;		/* The first label of the unit. */
	short		unit_flags;		/* Unit flags: see LIBofile.h. */
};

/*
	Function prototypes for externally visible routines in ASofile.c.
*/

void	dump_area	(area_node * map);
void	dump_comment(f_comment * fcp);
void	dump_dict	(dict_node * mdp);
void	dump_ref	(ref_node  * mrp);
void	dump_unit	(unit_node * mup);
void	out_ofile	(void);

#endif /* ASofile_h_ */
</t>
<t tx="ekr.20080529093004.19">/*
	AS: Header file for parse.c.

	source:  ASparse.h
	started: November 28, 1993.
	version: December 29, 1993.
*/

#ifndef ASparse_h_
#define ASparse_h_

#pragma once

void	par_program (void);
short	par_size	(bool * float_flag);

#endif /* ASparse_h_ */</t>
<t tx="ekr.20080529093004.20">/*
	AS: header file for ASpass12.c.

	source:  ASpass12.h
	started: December 20, 1993.
	version: December 20, 1993.
*/

#ifndef ASpass12_h_
#define ASpass12_h_

#pragma once

void check_compress	(char * s);
void compress		(io_mem_block * input_block);

#endif /* ASpass12_h_ */</t>
<t tx="ekr.20080529093004.21">/*
	AS: Header file for ASpseudo.c

	source:  ASpseudo.h
	started: January 16,1994.
	version: March 15,1994.
*/

#ifndef ASpseudo_h_
#define ASpseudo_h_

#pragma once

cnode * pseudo (ulabel_cnode * the_label);

#endif</t>
<t tx="ekr.20080529093004.22">/*
	AS: header for semantic classes.
	
	source:  ASsem.h
	started: March 2, 1994.
	version:
		May 20, 1994.
			Added sem_update_labels.
		May 13, 1994.
			Added sem_area_number.
		March 24, 1994.
			Added sem_see_label.
		March 15, 1994.
			Added sem_all_items_list and sem_limbo list.
		March 8, 1994.
			Added prototypes for sem_define_label.
*/

#ifndef ASsem_h_
#define ASsem_h_

#pragma once

/*
	Types.
	
	The bxx list consists of labels appearing in bcc, bsr and bra instructions
	whose value is not yet known.
	All such labels must be known by the end of the assembly.
	
	The low 8-bits of the opcode field (bxx_cip -&gt; c_bits) is set for 8-bit offsets.
	Otherwise the operand field (bxx_cip -&gt; c_arg1 -&gt; x_words) is set.
*/

typedef struct bxx_node_struct bxx_node;

struct bxx_node_struct {
	bxx_node *	next;			/* The next node on the bxx_list. */
	ulong		bxx_lc;			/* The location counter at the bxx instruction. */
	unit_node *	bxx_unit;		/* The unit containing the bxx instruction. */
	cinode *	bxx_cip;		/* The bxx instruction itself. */
	anode *		bxx_ap;			/* The label field of the instruction. */
	ulong		bxx_err_line;	/* The line number for delayed errors. */
};

/*
	Function prototypes.
*/

	/*
		Define synonyms for pass_number.

		Pass 1 is the original parsing pass.
		Pass 2 handles all nodes on the bxx list.
		During pass 1 sem_do_offset may optimize bxx instructions if the label is known.
		During pass 2 such an optimization is not possible because a word offset
		must have already been chosen.
	*/
	enum { BXX_PASS1 = 1, BXX_PASS2 = 2 };

void			sem_begin			(void);
ulabel_cnode *	sem_define_label	(spell_node * spell_p);
void 			sem_do_offset		(bxx_node * bxp, short pass_number);
void 			sem_end				(void);
dict_node *		sem_reference_label	(spell_node * spell_p);
dict_node *		sem_see_label		(spell_node * spell_p);
void			sem_update_labels	(dict_node * dp);
/*
	Global semantic variables.
*/

	/*
		The current status of the current unit.
		Only procedure units can change from code to data and back again.
	*/
	enum {SEM_IN_LIMBO_STATUS, SEM_CODE_STATUS, SEM_DATA_STATUS};
	
extern bool sem_unit_status;

	/* Areas. */
	
extern area_node *	sem_current_area;	/* The current area. */
extern ulong 		sem_area_number;	/* The number of area nodes. */

	/* Labels. */
	
extern dict_node *	sem_dict_list;		/* The list of all labels. */
extern ulong 		sem_dict_number;	/* Number of dict nodes. */

	/* Units. */
	
extern unit_node *	sem_current_unit;	/* The current unit. */
extern unit_node *	sem_in_limbo_unit;	/* The dummy unit for out-of-unit items. */
extern unit_node *	sem_unit_list;		/* The list of all non-dummy units. */
extern ulong		sem_unit_number;	/* Number of unit nodes. */


	/* Lists. */
	
extern bxx_node *	sem_bxx_list;	/* The list of bxx nodes. */

#endif /* ASsem_h_ */
</t>
<t tx="ekr.20080529093004.23"></t>
<t tx="ekr.20080529093004.24">/*
	AS: The internal assembler.

	source: ASasm.c
	started: September 28, 1993.
	version:
		February 2, 1995.
			Corrected some comments.
		January 24, 1995.
			Removed useless definitions of bxx_backup and bxx_commit.
		August 29, 1994.
			Use nxdata_size instead of xdata_size for cmpi instruction.
			This allows, for example, CMPI.b #255.
		July 26, 1994.
			Replaced xdata_16 by nxdata_16 in STOP instruction.
		July 17, 1994.
			Set immediate fields only if immediate constant will fit.
			Bug fix: added sign_kind to ea_val.
			Bug fix: created the nxdata_8, nxdata_16 and nxdata_size patterns.
		June 28, 1994.
			Bug fix: .l is the default for MOVEA.
			Bug fix:  added the_cip -&gt; c_new_len logic.
		May 26, 1994.
			Bug fix:  .w not required for DIVS and DIVU.
		April 13, 1994.
			Wrote reg_to_reglist and called it from X_MOVEM case so I could
			eliminate the reglist2, reglist_Xn and reglist2_Xn patterns.
		March 31, 1994.
			Bug fix: clear_abits_macro does not clear REGLIST_EA nodes.
		March 30, 1994.
			Bug fix: Link uses Anreg pattern, not An pattern.
		March 11, 1994.
			"bad" macro now takes a length pattern argument for better error reporting.
		March 3, 1994.
			Bug fix: DBcc instructions used xdata_lab, not xdata_bxx.
		March 2, 1994.
			Completed the xdata_bxx case.
			Made the location counter a global variable.
		February 13, 1994.
			Bug fixes to xdata_size and related cases in match().
		February 10, 1994.
			Completed ea_val.
		February 3, 1994.
			All instructions produce bits.
		February 6, 1994.
			MPW assembler handles full test file.
			Corrected is_control, C_ADDX, C_ANDI.
			Bug fixes to EA2_FIELD and EAREG_FIELD cases of ea_bits.
		February 7, 1994.
			Corrected C_BCHGstatic, C_BSETdynamic, C_BTSTstatic, C_CHK.
			Corrected call to define_shiftop_macro(C_LS,...).
			Corrected C_MOVEfromUSP, C_MOVEtoUSP, C_MOVEAlong, C_MOVEAword.
			Corrected C_ORtoDn, C_ORtoMem, C_SUBXtoMem.
			Bug fix for MOVE: reverse patterns and add data_alt_ea2 pattern.

	This file is an excellent example of the power and simplicity of descriptive programming.
	The routines in this file are the simplest,clearest and fastest possible.
	? Simplest because most of the code describes what is done, not how it is done.
	  Only the abbreviation macros need be changed to change representation.
	? Clearest because patterns follow the notation used in the Motorola 680x0 books.
	? Fastest because nothing can be faster than special-purpose code.
	For instance, this code will be faster than any table-driven method.

	Nothing would be gained by using a "universal assembler" instead of the
	hand-written code in this file since the complexity found here follows
	directly from the complexity of the 68000 series of chips.
*/

#undef USE_68030

&lt;&lt; ASasm #includes &gt;&gt;
&lt;&lt; ASasm declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.25">#include "AS.h"

#include "ASanodes.h"
#include "ASarg.h"
#include "ASasm.h"
#include "AScnodes.h"
#include "ASexp.h"
#include "ASmem.h"
#include "ASofile.h"
#include "ASsem.h"
#include "AStokens.h"
</t>
<t tx="ekr.20080529093004.26">/*
	Define Abbreviations.
*/

	/*
		Abbreviations concerning address modes...

		These abbreviations are taken directly from the Motorola 68030 book
		and the diagrams for individual instructions.

		It would be safer to replace t with (t) throughout these macros,
		though in this file t is always a single identifier.
	*/

#define is_alterable(t) (t &gt; BEGIN_ALT_EA_RANGE &amp;&amp; t &lt; END_ALT_EA_RANGE)

#define is_control(t) \
	(t == INDIRECT_EA || t == DISPLACEMENT_EA || is_mode6(t) || (is_mode7(t) &amp;&amp; !is_mode7_4(t)) )

#define is_control_alterable(t) \
	(t == INDIRECT_EA || t == DISPLACEMENT_EA || is_mode6(t) || is_mode7_01(t) )

#define is_data_mode(t) (is_ea(t) &amp;&amp; t != AREG_EA)

#define is_ea(t) (t &gt; BEGIN_EA_RANGE &amp;&amp; t &lt; END_EA_RANGE)

#define is_memory_alterable(t) \
	(t &gt; BEGIN_MEM_ALT_EA_RANGE &amp;&amp; t &lt; END_ALT_EA_RANGE)

#define is_control_register(r) (r &gt; BEGIN_CONTROL_REG_RANGE &amp;&amp; r &lt; END_CONTROL_REG_RANGE)

#define is_mode6(t)		(t &gt; BEGIN_MODE6_RANGE &amp;&amp; t &lt; END_MODE6_RANGE)
#define is_mode7(t)		(t &gt; BEGIN_MODE7_RANGE &amp;&amp; t &lt; END_MODE7_RANGE)
#define is_mode7_01(t)	(t == ABSOLUTE_EA || t == ABS16_EA || t == ABS32_EA)
#define is_mode7_4(t)	(t &gt; BEGIN_MODE7_4_RANGE &amp;&amp; t &lt; END_MODE7_4_RANGE)

	/*
		Abbreviations concerning backing out of matches...
		As you can see, it is very simple to undo a failed pattern match.
	*/

#define clear_cbits_macro(cip) { cip -&gt; c_bits = 0; }

	/*
		Warning:  don't put this code at the end of match!
		We may have to back out of a match later even if match() succeeds.
	*/
	
#define clear_xwords_macro(ap) {if (ap -&gt; n_type != REGLIST_EA) {ap -&gt; xwords = 0;}}

#ifdef USE_68030
	#define clear_abits_macro(ap) {clear_xwords_macro(ap); ap -&gt; bd = 0; ap -&gt; od = 0;}
#else
	#define clear_abits_macro(ap) {clear_xwords_macro(ap);}
#endif

/*
	the_cip is a hidden parameter to all pattern matching routines.
*/
static cinode * the_cip = NULL;	/* Pointer to the instruction for pattern matching. */

/*
	Function prototypes of routines defined in this file.
*/
	/* Define synonyms for the field_type parameter. */

	enum { NO_FIELD = 0, EA_FIELD, EAREG_FIELD, EA2_FIELD, EA2REG_FIELD };

	/* Define synonyms for report_error_flag. */

	enum { DONT_REPORT_OVERSIZE_CONSTANTS = FALSE, REPORT_OVERSIZE_CONSTANTS = TRUE };

static void	 ea_bits(anode * ap, int field_type);
static ulong ea_val
	(anode * ap, ushort bytes, bool report_error_flag, bool * error_flag, short sign_kind);

static bool match		(anode * arg, int pattern);
static bool	match_len	(ushort clen, int len_pattern);

static bool op0af	(ushort opcode_bits, int len_pat);
static bool op1af	(ushort opcode_bits, int len_pat, int f_pat);
static bool op2af	(ushort opcode_bits, int len_pat, int f1_pat, int f2_pat);
static bool op2afx	(ushort opcode_bits, ushort xbits, int len_pat, int f1_pat, int f2_pat);
static bool op3af	(ushort opcode_bits, int len_pat, int f1_pat, int f2_pat, int f3_pat);

static void	reg_to_reglist	(anode * ap);

/*
	Define descriptive names for bits and fields.
*/
enum {

	bit3	= 0x0008,
	bit5	= 0x0020,
	bit8	= 0x0100,
	bit10	= 0x0400,

	nobit3	= 0,
	nobit5	= 0,
	nobit8	= 0,

	mode000 = 0x0000,	/* Mode in bits 6,7,8. */
	mode001 = 0x0040,
	mode010 = 0x0080,
	mode011 = 0x00c0,
	mode100 = 0x0100,
	mode101 = 0x0140,
	mode110 = 0x0180,
	mode111 = 0x01c0,

	size_bits_b			= 0x0000,	/* Size field in bits 6,7. */
	size_bits_w			= 0x0040,
	size_bits_l			= 0x0080,
	size_bits_special	= 0x00c0,

	size2_bits_b		= 0x0000,	/* Size2 field in bits 9, 10. */
	size2_bits_w		= 0x0200,
	size2_bits_l		= 0x0400,
	size2_bits_special	= 0x0600,

	CCval = 0x0400,	/* Condition codes in bits 8 - 11. */
	CSval = 0x0500,
	EQval = 0x0700,
	Fval  = 0x0100,
	GEval = 0x0c00,
	GTval = 0x0e00,
	HIval = 0x0200,
	LEval = 0x0f00,
	LSval = 0x0300,
	LTval = 0x0d00,
	MIval = 0x0b00,
	NEval = 0x0600,
	PLval = 0x0a00,
	Tval  = 0x0000,
	VCval = 0x0800,
	VSval = 0x0900,

	/* The bits of the extension word as described on page 2-17 of the 68030 book. */

		/* Used in brief format. */

	da_xbits	= 0x8000,
	reg_xbits 	= 0x7000,
	wl_xbits	= 0x0800,
	scale_xbits	= 0x0600,
	bit8_xbits	= 0x0100,	/* 1 indicates full format extension word. */
	disp_xbits	= 0x00ff

		/* Used in full format. */

	#ifdef USE_68030
		,
		bs_xbits		= 0x0080,
		is_xbits		= 0x0040,
		bd_size_xbits	= 0x0030,
		iis_bits		= 0x0007
	#endif

};

/*
	Define bit patterns of all machine instructions.
	Patterns whose names start with CX_ define bits in the extension word.

	The choice of what bits to consider part of the opcode and
	what bits to consider parts of various fields is somewhat arbitrary.
	In general, I have chosen to define non-opcode bit fields when one or more of the
	following criteria are true:
	o the bit field is named in one of the Motorola 680x0 books.
	o using the bit field simplifies pattern matching.
	o using the bit field simplifies the code.

	The define_shiftop_macro is an abbreviation for a commonly occuring set of patterns.
*/
#define define_shiftop_macro(name, regval, memval)\
	\
	name ## Rcount	= (regval | nobit8 | nobit5),\
	name ## Rreg	= (regval | nobit8 | bit5),\
	\
	name ## Lcount	= (regval | bit8 | nobit5),\
	name ## Lreg	= (regval | bit8 | bit5),\
	\
	name ## Rmem	= (memval | nobit8 | size_bits_special),\
	name ## Lmem	= (memval | bit8   | size_bits_special)

enum {

	C_ABCD	= 0xc100,
		C_ABCDtoAnpredec	= (C_ABCD | bit3),
		C_ABCDtoDn			= (C_ABCD | nobit3),

	C_ADD	= 0xd000,
		C_ADDtoDn			= (C_ADD | mode000),	/* modes 0,1,2 */
		C_ADDtoMem			= (C_ADD | mode100),	/* modes 4,5,6 */

	C_ADDA	= 0xd000,
		C_ADDAword			= (C_ADD | mode011),	/* mode 3 */
		C_ADDAlong			= (C_ADD | mode111),	/* mode 7 */

	C_ADDI	= 0x0600,
	C_ADDQ	= 0x5000,

	C_ADDX	= 0xd100,
		C_ADDXtoAnpredec	= (C_ADDX | bit3),
		C_ADDXtoDn			= (C_ADDX | nobit3),

	C_AND	= 0xc000,
		C_ANDtoDn	= (C_AND | mode000),	/* modes 0,1,3 */
		C_ANDtoMem	= (C_AND | mode100),	/* modes 4,5,6 */

	C_ANDI = 0x0200,
		C_ANDItoCR	= 0x023c,
		C_ANDItoSR	= 0x027c,

	define_shiftop_macro(C_AS, 0xe000, 0xe0c0),		/* C_ASL, C_ASR */

	C_Bcc		= 0x6000,
		C_BCC	= (CCval | C_Bcc),
		C_BCS	= (CSval | C_Bcc),
		C_BEQ	= (EQval | C_Bcc),
		C_BGE	= (GEval | C_Bcc),
		C_BGT	= (GTval | C_Bcc),
		C_BHI	= (HIval | C_Bcc),
		C_BLE	= (LEval | C_Bcc),
		C_BLS	= (LSval | C_Bcc),
		C_BLT	= (LTval | C_Bcc),
		C_BMI	= (MIval | C_Bcc),
		C_BNE	= (NEval | C_Bcc),
		C_BPL	= (PLval | C_Bcc),
		C_BVC	= (VCval | C_Bcc),
		C_BVS	= (VSval | C_Bcc),

	C_BCHGdynamic	= 0x0140,
	C_BCHGstatic	= 0x0840,

	C_BCLRdynamic	= 0x0180,
	C_BCLRstatic	= 0x0880,

	C_BFCHG		= 0xeac0,
	C_BFCLR		= 0xecc0,
	C_BFEXTS	= 0xebc0,
	C_BFEXTU	= 0xe9c0,
	C_BFFF0		= 0xedc0,
	C_BFINS		= 0xefc0,
	C_BFSET		= 0xeec0,
	C_BFTST		= 0xe8c0,

	C_BKPT	= 0x4848,

	C_BRA	= 0x6000,

	C_BSETdynamic	= 0x01c0,
	C_BSETstatic	= 0x08c0,

	C_BSR	= 0x6100,

	C_BTSTdynamic	= 0x0100,
	C_BTSTstatic	= 0x0800,

	C_CAS	= 0x08c0,
	C_CAS2	= 0x08fc,

	C_CHK	= 0x4180,
	C_CHK2	= 0x00c0,

	C_CLR	= 0x4200,

	C_CMP	= 0xb000,

	C_CMPAlong	= 0xb1c0,
	C_CMPAword	= 0xb0c0,

	C_CMPI	= 0x0c00,

	C_CMPM	= 0xb108,

	C_CMP2	= 0x00c0,

	C_DBcc	= 0x50c8,
		C_DBCC	= (CCval | C_DBcc),
		C_DBCS	= (CSval | C_DBcc),
		C_DBEQ	= (EQval | C_DBcc),
		C_DBF	= (Fval  | C_DBcc),
		C_DBGE	= (GEval | C_DBcc),
		C_DBGT	= (GTval | C_DBcc),
		C_DBHI	= (HIval | C_DBcc),
		C_DBLE	= (LEval | C_DBcc),
		C_DBLS	= (LSval | C_DBcc),
		C_DBLT	= (LTval | C_DBcc),
		C_DBMI	= (MIval | C_DBcc),
		C_DBNE	= (NEval | C_DBcc),
		C_DBPL	= (PLval | C_DBcc),
		C_DBT	= (Tval  | C_DBcc),
		C_DBVC	= (VCval | C_DBcc),
		C_DBVS	= (VSval | C_DBcc),

	C_DIVSlong		= 0x4c40,
	C_DIVSword		= 0x81c0,
		CX_DIVSlong = 0x0800,
		CX_DIVSL 	= 0x0c00,

	C_DIVUlong		= 0x4c40,
	C_DIVUword		= 0x80c0,
		CX_DIVUlong = 0x0000,
		CX_DIVUL 	= 0x0400,

	C_EOR	= 0xb100,

	C_EORI	= 0x0a00,
		C_EORItoCR	= 0x0a3c,
		C_EORItoSR	= 0x0a7c,

	C_EXGaa	= 0xc148,
	C_EXGda	= 0xc188,
	C_EXGdd	= 0xc140,

	C_EXTbyte	= 0x4880,
	C_EXTword	= 0x48C0,
	C_EXTB		= 0x49C0,

	C_ILLEGAL	= 0x4afc,

	C_JMP	= 0x4ec0,
	C_JSR	= 0x4e80,

	C_LEA	= 0x41c0,
	C_LINK	= 0x4e50,

	C_LINKlong	= 0x4808,
	C_LINKword	= 0x4e50,

	define_shiftop_macro(C_LS, 0xe008, 0xe2c0),		/* C_LSL, C_LSR */

	C_MOVEbyte	= 0x1000,
	C_MOVElong	= 0x2000,
	C_MOVEword	= 0x3000,

	C_MOVEAlong	= 0x2040,
	C_MOVEAword	= 0x3040,

	C_MOVEfromCR	= 0x42c0,
	C_MOVEtoCR		= 0x44c0,

	C_MOVEfromSR	= 0x40c0,
	C_MOVEtoSR		= 0x46c0,

	C_MOVEfromUSP	= 0x4e68,
	C_MOVEtoUSP		= 0x4e60,

	C_MOVECfromCreg	= 0x4e7a,
	C_MOVECtoCreg	= 0x4e7b,

	C_MOVEMlongtomem	= 0x48c0,
	C_MOVEMlongtoregs	= 0x4cc0,
	C_MOVEMwordtomem	= 0x4880,
	C_MOVEMwordtoregs	= 0x4c80,

	C_MOVEPlongtomem	= 0x01c8,
	C_MOVEPlongtoreg	= 0x0148,
	C_MOVEPwordtomem	= 0x0188,
	C_MOVEPwordtoreg	= 0x0108,

	C_MOVEQ	= 0x7000,

	C_MOVES	= 0x0e00,
		CX_MOVESfromGreg	= 0x0800,
		CX_MOVEStoGreg		= 0x0000,

	C_MULSlong	= 0x4c00,
	C_MULSword	= 0xc1c0,
		CX_MULSword	= 0x0800,
		CX_MULSlong	= 0x0c00,

	C_MULUlong	= 0x4c00,
	C_MULUword	= 0xc0c0,
		CX_MULUword	= 0x0000,
		CX_MULUlong	= 0x0400,

	C_NBCD	= 0x4800,

	C_NEG	= 0x4400,
	C_NEGX	= 0x4000,

	C_NOP	= 0x4e71,
	C_NOT	= 0x4600,

	C_ORtoDn	= 0x8000,
	C_ORtoMem	= 0x8100,

	C_ORI	= 0x0000,
		C_ORItoCR	= 0x003c,
		C_ORItoSR	= 0x007c,

	C_PACKtoAnpredec	= 0x8144,
	C_PACKtoDn			= 0x8140,

	C_PEA	= 0x4840,

	C_RESET	= 0x4e70,

	define_shiftop_macro(C_RO,  0xe018, 0xe6c0),	/* C_ROL, C_ROR */

	define_shiftop_macro(C_ROX, 0xe010, 0xe4c0),	/* C_ROXL, C_ROXR */

	C_RTD	= 0x4e74,
	C_RTE	= 0x4e73,
	C_RTR	= 0x4e77,
	C_RTS	= 0x4e75,

	C_SBCDtoDn			= 0x8100,
	C_SBCDtoAnpredec	= 0x8108,

	C_Scc	= 0x50c0,
		C_SCC	= (CCval | C_Scc),
		C_SCS	= (CSval | C_Scc),
		C_SEQ	= (EQval | C_Scc),
		C_SF	= (Fval  | C_Scc),
		C_SGE	= (GEval | C_Scc),
		C_SGT	= (GTval | C_Scc),
		C_SHI	= (HIval | C_Scc),
		C_SLE	= (LEval | C_Scc),
		C_SLS	= (LSval | C_Scc),
		C_SLT	= (LTval | C_Scc),
		C_SMI	= (MIval | C_Scc),
		C_SNE	= (NEval | C_Scc),
		C_SPL	= (PLval | C_Scc),
		C_ST	= (Tval  | C_Scc),
		C_SVC	= (VCval | C_Scc),
		C_SVS	= (VSval | C_Scc),

	C_STOP	= 0x4e72,

	C_SUBtoDn	= 0x9000,
	C_SUBtoMem	= 0x9100,

	C_SUBAlong	= 0x91c0,
	C_SUBAword	= 0x90c0,

	C_SUBI	= 0x0400,
	C_SUBQ	= 0x5100,

	C_SUBXtoDn	= 0x9100,
	C_SUBXtoMem	= 0x9108,

	C_SWAP	= 0x4840,
	C_TAS	= 0x4ac0,

	C_TRAP	= 0x4e40,

	C_TRAPcc	= 0x50f8,
		C_TRAPCC	= (CCval | C_TRAPcc),
		C_TRAPCS	= (CSval | C_TRAPcc),
		C_TRAPEQ	= (EQval | C_TRAPcc),
		C_TRAPF		= (Fval  | C_TRAPcc),
		C_TRAPGE	= (GEval | C_TRAPcc),
		C_TRAPGT	= (GTval | C_TRAPcc),
		C_TRAPHI	= (HIval | C_TRAPcc),
		C_TRAPLE	= (LEval | C_TRAPcc),
		C_TRAPLS	= (LSval | C_TRAPcc),
		C_TRAPLT	= (LTval | C_TRAPcc),
		C_TRAPMI	= (MIval | C_TRAPcc),
		C_TRAPNE	= (NEval | C_TRAPcc),
		C_TRAPPL	= (PLval | C_TRAPcc),
		C_TRAPT		= (Tval  | C_TRAPcc),
		C_TRAPVC	= (VCval | C_TRAPcc),
		C_TRAPVS	= (VSval | C_TRAPcc),

	C_TRAPV	= 0x4e76,
	C_TST	= 0x4a00,
	C_UNLK	= 0x4e58,

	C_UNPACKtoDn	= 0x8180,
	C_UNPACKtoMem	= 0x8188
};

/*
	Define encoding for patterns.
	These encodings are used only by match() and match_len().
*/
enum {
	NO_ARG,			/* Zero should never be a valid pattern. */

		/* Size patterns affecting matching but setting no bits. */

	Bsize_nobits,	/* Byte (B) only. */
	Lsize_nobits,	/* Long (L) only. */
	Wsize_nobits,	/* Word (W) only. */

	defaultBsize_nobits,	/* B or none, none same as B. */
	defaultLsize_nobits,	/* L or none, none same as L. */
	defaultWsize_nobits,	/* W or none, none same as W. */
	
	err_BorLsize_nobits,	/* B or L:  used only in err_match_len. */
	err_LorWsize_nobits,
	
	quick0_data_nobits,		/* immediate zero */

		/* Size patterns that affect bits 6 and 7 in the opcode word. */

	anysize,	/* B, W or L in size field. */
	Bsize,		/* B only in size field. */
	Lsize,		/* L only in size field. */
	no_size,	/* No size should be specified. */
	WorLsize,	/* W or L in size field */
	Wsize,		/* W only in size field. */

		/* Size patterns affecting length bits in extension words... */

	bxx_size_nobits, 	/* B or W or none. */
	dbxx_size_nobits,	/* W or none. */
	
#ifdef USE_68030
	anysize2,		/* Standard encoding of size2 field. */
	DIVS_L_32xsize,	/* L only for DIVS. 32-bit result: xbit 10 = 0. */
	DIVS_L_64xsize,	/* L only for DIVS. 64-bit result: xbit 10 = 1. */
	DIVSL_L_xsize,	/* L only for DIVSL. */
	MULS_L_32xsize,	/* L only for MULS. 32-bit result: xbit 10 = 0. */
	MULS_L_64xsize,	/* L only for MULS. 64-bit result: xbit 10 = 1. */
#endif

	/*
		Operand patterns...

		These patterns encode three items of information,
		1) the syntax giving rise to the address mode,
		2) the bit field in the instruction corresponding to the address mode, and
		3) the encoding of the bit field.
		Items 2 and 3 are merged so the bit field implies the encoding.

		The match function would be simplified by splitting these items into distinct arguments.
		For example, we could split the An2 pattern into two separate patterns, An and ea.
		Alas, that would greatly increase the size of assemble.
	*/

		/* Patterns that only affect matching and set no bits in the instruction. */

	cr_pat,		/* Matches only the condition code register. */
	usp_pat,	/* Matches only the user stack pointer. */
	sr_pat,		/* Matches only the status register. */

		/*
			Patterns that set bits in the ea field (bits 0-5) of the opcode word.
			Bits 0-2 are the register part of the ea field.
		*/

	An,					/* Address register address mode. */
	alt_ea,				/* Alterable address modes. */
	control_ea,			/* Control address modes. */
	control_alt_ea,		/* Control alterable address modes. */
	data_ea,			/* Data	address modes. */
	data_not_imm_ea,	/* All data address modes except immediate mode. */
	data_alt_ea,		/* Data alterable address modes. */
	Dn,					/* Data register address mode. */
	dn_ctl_alt_ea,		/* Dn and control alterable modes. */
	ea,					/* All address modes. */
	imm_ea, 			/* Immediate mode (MOVE only). */
	default_imm_ea,		/* Same as imm_ea, do not complain about oversize constants. */
	mem_alt_ea,			/* Memory alterable address modes. */
	movem_predec,		/* Predecrement mode (reverses bits in register list!) */
	pi_ctr_ea,			/* MOVEM: Postincrement plus control address modes. */

		/*
			Patterns that set only the register bits (bits 0-2) of
			the ea field of the opcode word.
		*/

	Anreg,			/* Address register address mode in ea reg field. */
	Dnreg,			/* Data register 	address mode in ea reg field. */
	Anpostincreg,	/* (An)+            address mode in ea reg field */
	Anpredecreg,	/* -(An) 			address mode in ea reg field. */
	Anreg_disp16,	/* xdisp16(An)      address mode in ea reg field. */

		/*
			Patterns that set bits in the ea2 field (bits 6-11) of the opcode word.
			The *high* bits, bits 9-11, are the register part of the ea2 field.
		*/

	An2,			/* Address register		address mode in ea2 field. */
	Dn2,			/* Data register		address mode in ea2 field. */
	data_alt_ea2,	/* Data alterable		address modes in ea2 field. */
	ea2,			/* All 					address modes in ea2 field. */

		/*
			Patterns that set only the register bits (bits 9-11) of
			the ea2 field of the opcode word.
		*/

	An2reg,			/* Address register	in ea2 reg field. */
	Anpredec2reg,	/* -(An)			in ea2 reg field. */
	Anpostinc2reg,	/* (An)+			in ea2 reg field. */
	Dn2reg,			/* Data register	in ea2 reg field. */

		/* Patterns setting bits in the opword using immediate operands. */

	quick_data,		/* General constant	in bits 0-7  of the opword. */
	quick_data2,	/* General constant	in bits 9-11 of the opword.  8 is represented by 0. */

	trap_num,		/* Trap number		in bits 0-3  of the opword. */
	vector,			/* Vector number	in bits 0-2  of the opword. */

		/*
			Patterns setting bits in extension words.
			Unused bits of extension words must be set to zero.
			
			Arbitrarily signed constants are constants in which the
			interpretation of the sign bit never matters.
			Such constants are used in move instructions and in AND, EOR and OR instructions.
		*/

	nxdata_size, /* Arbitraryily signed constant in one or more extention words depending on size. */
	nxdata_8,	 /* Arbitraryily signed constant in bits  0-7.  */
	nxdata_16,	 /* Arbitraryily signed constant in bits  0-15. */
	
	xbit_num,	/* Bit number mod 32	in bits  0-7. */
	xdata_size,	/* Signed constant		in one or more extention words depending on size. */
	xdata_16,	/* Signed constant		in bits  0-15. */
	xdata_bxx,	/* Signed constant		in bits  0-15 of xword or bits 0-7 of opword. */
	xdata_lab,	/* Label				in bits  0-15. */
	xgreg,		/* General register 	in bits 12-15. */
	xreglist	/* Register list mask	in bits  0-15. */

	#ifdef USE_68030
		,
		x30_creg,		/* MOVEC: Control register in low 12 xbits. */
		xdata_32,		/* Data in two exention words. */
		xDn,			/* Bit operators: Data register in xbits 12-14. */
		xDlow,			/* MULS: Data register in low 3 xbits. */
		xDhighxDlow,	/* MULS: XDhigh:XDlow */
		xDq,			/* DIVS: Data register in xbits 12-14. */
		xDr,			/* DIVS: Data register in low 3 xbits. */
		xDrxDq,			/* DIVS: XDr:XDq */
		xoff_width		/* offset: xbits 6-10, flag: xbit 11, width: xbits 0-4, flag: xbit 5. */
	#endif
};

/*
	Define abbreviations for the control structure of the pattern matching.

	These abbreviations describe _what_ matching to be performed.
	Their expansions determine  _how_ the matching is done.
*/
#define bad(len_pat)	{ err_length_pat = len_pat; goto bad_opcode; }

#define op0(bits) 				if(op0af(bits,no_size)){		goto good;}
#define op1(bits,len,f1)	 	if(op1af(bits,len,f1)){ 		goto good;}
#define op2(bits,len,f1,f2) 	if(op2af(bits,len,f1,f2)){		goto good;}
#define op3(bits,len,f1,f2,f3)	if(op3af(bits,len,f1,f2,f3)){	goto good;}

#define xop2len(bits,xbits,len,f1,f2) \
	if(op2afx(bits,xbits,len,f1,f2)) { goto good;}

/* Different bit patterns are used depending on the kinds of arguments. */

#define bitop(tok)\
	op2(C_ ## tok ## dynamic,defaultLsize_nobits,Dn2reg,data_alt_ea)\
	op2(C_ ## tok ## static,defaultBsize_nobits,xbit_num,data_alt_ea)

#define shiftop(tok)\
	op1(C_ ## tok ## mem,Wsize_nobits,mem_alt_ea)\
	op2(C_ ## tok ## reg,anysize,Dn2reg,Dn)\
	op2(C_ ## tok ## count,anysize,quick_data2,Dn)

/*
	This routine is the heart of the assembler.

	Assemble the single instruction described by tok and cip and
	add the instruction to the global code list.

	Put the specified length of the instruction in cip -&gt; c_length,
	put the logical   length of the instruction in cip -&gt; c_new_len,
	and put all opcode bits in cip -&gt; c_bits.

	As mentioned before,
	the patterns found here correspond directly to patterns found in the 680x0 books.
	Unlike table-driven methods, the patterns here expand directly to code.
*/
static anode * reglist_ap = NULL;
</t>
<t tx="ekr.20080529093004.27">cinode *
assemble(register cinode * cip)
{
	FTAG("assemble");
	int instruction_size = 0;
	int err_length_pat = 0;
	STATB(ftag);
	ASSERT(cip &amp;&amp; is_xtok(cip -&gt; n_type));

	/* Set a global variable for use of all other routines. */
	the_cip = cip;
	
	/* Reset the pointer to the register list. */
	reglist_ap = NULL;

	/*
		Match arguments with patterns based on tok, the instruction mnemonic.
	*/
	switch(cip -&gt; n_type) {

	#ifdef USE_68030
		case X30_BFTST: op2(C_BFTST,no_size,dn_ctl_alt_ea,xoff_width) bad(no_size)
		case X30_BFCHG: op2(C_BFCHG,no_size,dn_ctl_alt_ea,xoff_width) bad(no_size)
		case X30_BFCLR: op2(C_BFCLR,no_size,dn_ctl_alt_ea,xoff_width) bad(no_size)
		case X30_BFSET: op2(C_BFSET,no_size,dn_ctl_alt_ea,xoff_width) bad(no_size)

		case X30_BFEXTU: op3(C_BFEXTU,xDn,no_size,dn_ctl_alt_ea,xoff_width) bad(no_size)
		case X30_BFEXTS: op3(C_BFEXTS,xDn,no_size,dn_ctl_alt_ea,xoff_width) bad(no_size)
		case X30_BFFF0:  op3(C_BFFF0, xDn,no_size,dn_ctl_alt_ea,xoff_width) bad(no_size)
		case X30_BFINS:  op3(C_BFINS, xDn,no_size,dn_ctl_alt_ea,xoff_width) bad(no_size)
		
		#if 0 /* 3 arguments not ready yet. */
			case X30_CAS:  bad(anysize)
			case X30_CAS2: bad(anysize)
		#endif

		case X30_CMP2: op2(C_CMP2,anysize2,control_ea,xgreg) bad(anysize2)
		case X30_CHK2: op2(C_CHK2,anysize2,control_ea,xgreg) bad(anysize2)

		case X30_DIVSL: xop2len(C_DIVSlong,CX_DIVSL,DIVSL_L_xsize,data_ea,xDrxDq) bad(anysize)
		case X30_DIVUL: xop2len(C_DIVUlong,CX_DIVUL,DIVSL_L_xsize,data_ea,xDrxDq) bad(anysize)

		case X30_EXTB: op1(C_EXTB,Lsize,Dn) bad(Lsize);

		case X30_MOVEC:
			op2(C_MOVECfromCreg,no_size,x30_creg,xgreg)
			op2(C_MOVECtoCreg,  no_size,xgreg,x30_creg)
			bad(no_size)

		case X30_PACK:
			op2(C_PACKtoDn,no_size,Dn,Dn2reg)
			op2(C_PACKtoAnpredec,no_size,Anpredecreg,Anpredec2reg)
			bad(no_size)

		case X30_TRAPCC: op2(C_TRAPCC,trap_size,Dn,xdata_16) bad(trap_size)
		case X30_TRAPCS: op2(C_TRAPCS,trap_size,Dn,xdata_16) bad(trap_size)
		case X30_TRAPEQ: op2(C_TRAPEQ,trap_size,Dn,xdata_16) bad(trap_size)
		case X30_TRAPF:  op2(C_TRAPF, trap_size,Dn,xdata_16) bad(trap_size)
		case X30_TRAPGE: op2(C_TRAPGE,trap_size,Dn,xdata_16) bad(trap_size)
		case X30_TRAPGT: op2(C_TRAPGT,trap_size,Dn,xdata_16) bad(trap_size)
		case X30_TRAPHI: op2(C_TRAPHI,trap_size,Dn,xdata_16) bad(trap_size)
		case X30_TRAPLE: op2(C_TRAPLE,trap_size,Dn,xdata_16) bad(trap_size)
		case X30_TRAPLS: op2(C_TRAPLS,trap_size,Dn,xdata_16) bad(trap_size)
		case X30_TRAPLT: op2(C_TRAPLT,trap_size,Dn,xdata_16) bad(trap_size)
		case X30_TRAPMI: op2(C_TRAPMI,trap_size,Dn,xdata_16) bad(trap_size)
		case X30_TRAPNE: op2(C_TRAPNE,trap_size,Dn,xdata_16) bad(trap_size)
		case X30_TRAPPL: op2(C_TRAPPL,trap_size,Dn,xdata_16) bad(trap_size)
		case X30_TRAPT:  op2(C_TRAPT ,trap_size,Dn,xdata_16) bad(trap_size)
		case X30_TRAPVC: op2(C_TRAPVC,trap_size,Dn,xdata_16) bad(trap_size)
		case X30_TRAPVS: op2(C_TRAPVS,trap_size,Dn,xdata_16) bad(trap_size)

		case X30_UNPK:
			op2(C_UNPACKtoDn,no_size,Dn,Dn2reg)
			op2(C_UNPACKtoMem,no_size,Anpredecreg,Anpredec2reg)
			bad(no_size)
	#endif

	case X_ABCD:
		op2(C_ABCDtoDn,defaultBsize_nobits,Dn,Dn2reg)
		op2(C_ABCDtoAnpredec,defaultBsize_nobits,Anpredecreg,Anpredec2reg)
		bad(defaultBsize_nobits)

	case X_ADD:

			/* Try ADDQ. */

		op2(C_ADDQ,WorLsize,quick_data2,An)			/* .B not valid for Aregs. */
		op2(C_ADDQ,anysize,quick_data2,data_alt_ea)

			/* Try ADDI. */

		op2(C_ADDI,anysize,xdata_size,data_alt_ea)

			/* Try ADDA. */

		op2(C_ADDAword,Wsize_nobits,ea,An2reg)
		op2(C_ADDAlong,Lsize_nobits,ea,An2reg)

			/* Default */

		op2(C_ADDtoDn,WorLsize,An,Dn2)				/* .B not valid for Aregs. */
		op2(C_ADDtoDn,anysize,data_ea,Dn2)
		op2(C_ADDtoMem,anysize,Dn2,mem_alt_ea)
		bad(anysize)

	case X_ADDA:
		op2(C_ADDAword,Wsize_nobits,ea,An2reg)
		op2(C_ADDAlong,Lsize_nobits,ea,An2reg)
		bad(err_LorWsize_nobits)

	case X_ADDI: op2(C_ADDI,anysize,xdata_size,data_alt_ea) bad(anysize)

	case X_ADDQ:
		op2(C_ADDQ,WorLsize,quick_data2,An)		/* .B not valid for Aregs. */
		op2(C_ADDQ,anysize,quick_data2,data_alt_ea)
		bad(anysize)

	case X_ADDX:
		op2(C_ADDXtoDn,anysize,Dn,Dn2reg)
		op2(C_ADDXtoAnpredec,anysize,Anpredecreg,Anpredec2reg)
		bad(anysize)

	case X_AND:

			/* Try ADDI. */

		op2(C_ANDItoCR,Bsize_nobits,nxdata_8,cr_pat)
		op2(C_ANDItoSR,Wsize_nobits,nxdata_16,sr_pat)
		op2(C_ANDI,anysize,nxdata_size,data_alt_ea)

			/* Default. */

		op2(C_ANDtoDn,anysize,data_ea,Dn2)
		op2(C_ANDtoMem,anysize,Dn2,mem_alt_ea)
		bad(anysize)

	case X_ANDI:
		op2(C_ANDItoCR,Bsize_nobits,nxdata_8,cr_pat)
		op2(C_ANDItoSR,Wsize_nobits,nxdata_16,sr_pat)
		op2(C_ANDI,anysize,nxdata_size,data_alt_ea)
		bad(anysize)

	case X_ASL: shiftop(ASL) bad(anysize)
	case X_ASR: shiftop(ASR) bad(anysize)

	case X_BCC:	op1(C_BCC,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)
	case X_BCS:	op1(C_BCS,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)
	case X_BEQ:	op1(C_BEQ,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)
	case X_BGE:	op1(C_BGE,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)
	case X_BGT:	op1(C_BGT,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)
	case X_BHI:	op1(C_BHI,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)
	case X_BLE:	op1(C_BLE,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)
	case X_BLS:	op1(C_BLS,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)
	case X_BLT:	op1(C_BLT,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)
	case X_BMI:	op1(C_BMI,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)
	case X_BNE:	op1(C_BNE,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)
	case X_BPL:	op1(C_BPL,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)
	case X_BVC:	op1(C_BVC,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)
	case X_BVS:	op1(C_BVS,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)

	case X_BCHG: bitop(BCHG) bad(err_BorLsize_nobits)
	case X_BCLR: bitop(BCLR) bad(err_BorLsize_nobits)
	case X_BSET: bitop(BSET) bad(err_BorLsize_nobits)
	case X_BTST: bitop(BTST) bad(err_BorLsize_nobits)

	case X_BKPT: op1(C_BKPT,no_size,vector) bad(no_size)

	case X_BRA: op1(C_BRA,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)
	case X_BSR: op1(C_BSR,bxx_size_nobits,xdata_bxx) bad(bxx_size_nobits)

	case X_CHK:

	/* The allowed formats of chk change depending on the machine. */
	#ifdef USE_68030
		op2(C_CHK,WorLsize,data_ea,Dn2reg) bad(WorLsize)
	#else
		op2(C_CHK,defaultWsize_nobits,data_ea,Dn2reg) bad(defaultWsize_nobits)
	#endif

	case X_CLR:  op1(C_CLR,anysize,data_alt_ea) bad(anysize)

	case X_CMP:

			/* Try CMPI. */

		op2(C_CMPI,anysize,xdata_size,data_not_imm_ea)

			/* Try CMPA. */

		op2(C_CMPAword,Wsize_nobits,ea,An2reg)
		op2(C_CMPAlong,Lsize_nobits,ea,An2reg)

			/* Default. */

		op2(C_CMP,WorLsize,An,Dn2)			/* .B not valid for Aregs. */
		op2(C_CMP,anysize,data_ea,Dn2)
		bad(anysize)

	case X_CMPA:
		op2(C_CMPAword,Wsize_nobits,ea,An2reg)
		op2(C_CMPAlong,Lsize_nobits,ea,An2reg)
		bad(err_LorWsize_nobits)

	case X_CMPI: op2(C_CMPI,anysize,nxdata_size,data_not_imm_ea) bad(anysize)

	case X_CMPM: op2(C_CMPM,anysize,Anpostincreg,Anpostinc2reg) bad(anysize)

	case X_DBCC: op2(C_DBCC,dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)
	case X_DBCS: op2(C_DBCS,dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)
	case X_DBEQ: op2(C_DBEQ,dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)
	case X_DBF:  op2(C_DBF, dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)
	case X_DBGE: op2(C_DBGE,dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)
	case X_DBGT: op2(C_DBGT,dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)
	case X_DBHI: op2(C_DBHI,dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)
	case X_DBLE: op2(C_DBLE,dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)
	case X_DBLS: op2(C_DBLS,dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)
	case X_DBLT: op2(C_DBLT,dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)
	case X_DBMI: op2(C_DBMI,dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)
	case X_DBNE: op2(C_DBNE,dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)
	case X_DBPL: op2(C_DBPL,dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)
	case X_DBT:  op2(C_DBT ,dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)
	case X_DBVC: op2(C_DBVC,dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)
	case X_DBVS: op2(C_DBVS,dbxx_size_nobits,Dn,xdata_lab) bad(dbxx_size_nobits)

	case X_DIVS:
		op2(C_DIVSword,defaultWsize_nobits,data_ea,Dn2reg)
		#ifdef USE_68030
			xop2len(C_DIVSlong,CX_DIVSlong,DIVS_L_32xsize,data_ea,xDq)
			xop2len(C_DIVSlong,CX_DIVSlong,DIVS_L_64xsize,data_ea,xDrxDq)
		#endif
		bad(anysize)

	case X_DIVU:
		op2(C_DIVUword,defaultWsize_nobits,data_ea,Dn2reg)
		#ifdef USE_68030
			xop2len(C_DIVUlong,CX_DIVSlong,DIVS_L_32xsize,data_ea,xDq)
			xop2len(C_DIVUlong,CX_DIVSlong,DIVS_L_64xsize,data_ea,xDrxDq)
		#endif
		bad(anysize)

	case X_EOR:

			/* Try EORI. */

		op2(C_EORItoCR,Bsize_nobits,nxdata_8, cr_pat)
		op2(C_EORItoSR,Wsize_nobits,nxdata_16,sr_pat)
		op2(C_EORI,anysize,nxdata_size,data_alt_ea)

			/* Default. */

		op2(C_EOR,anysize,Dn2,data_alt_ea)
		bad(anysize)

	case X_EORI:
		op2(C_EORItoCR,Bsize_nobits,nxdata_8, cr_pat)
		op2(C_EORItoSR,Wsize_nobits,nxdata_16,sr_pat)
		op2(C_EORI,anysize,nxdata_size,data_alt_ea)
		bad(anysize)

	case X_EXG:
		op2(C_EXGdd,defaultLsize_nobits,Dn2reg,Dnreg)
		op2(C_EXGaa,defaultLsize_nobits,An2reg,Anreg)
		op2(C_EXGda,defaultLsize_nobits,Dn2reg,Anreg)	/* The ea field always has the An. */
		op2(C_EXGda,defaultLsize_nobits,Anreg,Dn2reg)
		bad(defaultLsize_nobits)

	case X_EXT:
		op1(C_EXTbyte,Wsize_nobits,Dn)
		op1(C_EXTword,Lsize_nobits,Dn)
		bad(err_LorWsize_nobits)

	case X_ILLEGAL: op0(C_ILLEGAL) bad(no_size)

	case X_JMP:	op1(C_JMP,no_size,control_ea) bad(no_size)
	case X_JSR: op1(C_JSR,no_size,control_ea) bad(no_size)

	case X_LEA:
		op2(C_LEA,defaultWsize_nobits,control_ea,An2reg)
		bad(defaultWsize_nobits)

	case X_LINK:
		op2(C_LINKlong,Lsize_nobits,Anreg,xdata_size)
		op2(C_LINKword,defaultWsize_nobits,Anreg,xdata_size)
		bad(anysize)

	case X_LSL: shiftop(LSL) bad(anysize)
	case X_LSR: shiftop(LSR) bad(anysize)

	case X_MOVE:
	
			/*
				These optimizations work.
				Note that there is *no way* to specify MOVE.x #0,Dn.
				
				If someone *must* have those instructions we
				can always add a command-line option to disable the optimizations.
			*/
	
		op2(C_CLR,Bsize,quick0_data_nobits,Dnreg)
		op2(C_CLR,Wsize,quick0_data_nobits,Dnreg)

			/*
				MOVEQ is equivalent to MOVE.L #0,Dn, not MOVE.B #0,Dn.
				Therefore, use Lsize_nobits, not defaultLsize_nobits.
			*/

		op2(C_MOVEQ,Lsize_nobits,quick_data,Dn2reg)

			/*
				Special case to allow imm_ea pattern.
				These patterns must appear here because
				they are more tolerant of oversized constants.
			*/

		op2(C_MOVEbyte,Bsize_nobits,imm_ea,data_alt_ea2)
		op2(C_MOVEword,Wsize_nobits,imm_ea,data_alt_ea2)
		op2(C_MOVElong,Lsize_nobits,imm_ea,data_alt_ea2)
		
			/*
				default_imm_ea is a kludge to allow default size.
				This code works but I disabled it because it
				seems too dangerous and surprising.

				For example, the MPW assembler generates *word* moves
				when byte moves would suffice.
				
				CC2 always generates explicit lengths, of course.
			*/
					
		#if 0 /* Default move immediates are too dangerous. */
		
			op2(C_MOVEbyte,defaultBsize_nobits,default_imm_ea,data_alt_ea2)
			op2(C_MOVEword,defaultWsize_nobits,default_imm_ea,data_alt_ea2)
			op2(C_MOVElong,defaultLsize_nobits,default_imm_ea,data_alt_ea2)
			
		#endif	
		
			/* Try MOVEA. */

		op2(C_MOVEAword,Wsize_nobits,ea,An2reg)
		op2(C_MOVEAlong,Lsize_nobits,ea,An2reg)
		
			/*
				Match explicit sizes before default sizes so
				we won't generate spurious warnings.
			*/
		
		op2(C_MOVEbyte,Bsize_nobits,ea,data_alt_ea2)
		op2(C_MOVEword,Wsize_nobits,ea,data_alt_ea2)
		op2(C_MOVElong,Lsize_nobits,ea,data_alt_ea2)

			/* Special moves. */

		op2(C_MOVEfromCR,defaultBsize_nobits,cr_pat,data_alt_ea)
		op2(C_MOVEfromSR,defaultWsize_nobits,sr_pat,data_alt_ea)
		op2(C_MOVEfromUSP,defaultLsize_nobits,usp_pat,Anreg)

		op2(C_MOVEtoCR,defaultBsize_nobits,data_ea,cr_pat)
		op2(C_MOVEtoSR,defaultWsize_nobits,data_ea,sr_pat)
		op2(C_MOVEtoUSP,defaultLsize_nobits,Anreg,usp_pat)

		bad(anysize)

	case X_MOVEA:
		op2(C_MOVEAword,Wsize_nobits,ea,An2reg)
		op2(C_MOVEAlong,defaultLsize_nobits,ea,An2reg)
		bad(err_LorWsize_nobits)

	case X_MOVEM:
	
		/*
			Convert a single register to a register list.
			This is possible since registers are not valid in
			control_alterable address modes.
		*/
		{
			anode * ap = NULL;
			ap = the_cip -&gt; c_arg1;
			if (ap &amp;&amp; (ap -&gt; n_type == AREG_EA || ap -&gt; n_type == DREG_EA)) {
				reg_to_reglist(ap);
			}
			ap = the_cip -&gt; c_arg2;
			if (ap &amp;&amp; (ap -&gt; n_type == AREG_EA || ap -&gt; n_type == DREG_EA)) {
				reg_to_reglist(ap);
			}
		}
		
		/*
			Set the reversed flag if the second argument is the register list.
			This makes sure the register list immediately follows the opcode word.
			The c_flags field must not be cleared when backing out of a failed match!
		*/
		{
			anode * ap = the_cip -&gt; c_arg2;
			if (ap &amp;&amp; ap -&gt; n_type == REGLIST_EA) {
				c_set_reversed(the_cip);
			}
		}

		op2(C_MOVEMwordtomem,Wsize_nobits,xreglist,movem_predec)
		op2(C_MOVEMlongtomem,Lsize_nobits,xreglist,movem_predec)

		op2(C_MOVEMwordtoregs,Wsize_nobits,pi_ctr_ea,xreglist)
		op2(C_MOVEMlongtoregs,Lsize_nobits,pi_ctr_ea,xreglist)

		op2(C_MOVEMwordtomem,Wsize_nobits,xreglist,control_alt_ea)
		op2(C_MOVEMlongtomem,Lsize_nobits,xreglist,control_alt_ea)

		bad(err_LorWsize_nobits)

	case X_MOVEP:
		op2(C_MOVEPwordtoreg,Wsize_nobits,Anreg_disp16,Dn2reg)
		op2(C_MOVEPlongtoreg,Lsize_nobits,Anreg_disp16,Dn2reg)
		op2(C_MOVEPwordtomem,Wsize_nobits,Dn2reg,Anreg_disp16)
		op2(C_MOVEPlongtomem,Lsize_nobits,Dn2reg,Anreg_disp16)
		bad(err_LorWsize_nobits)

	case X_MOVEQ:
		op2(C_MOVEQ,defaultLsize_nobits,quick_data,Dn2reg)
		bad(defaultLsize_nobits)

	case X_MOVES:
		xop2len(C_MOVES,CX_MOVESfromGreg,anysize,xgreg,mem_alt_ea)
		xop2len(C_MOVES,CX_MOVEStoGreg,anysize,mem_alt_ea,xgreg)
		error(es("moves not ready yet"));
		bad(anysize)

	case X_MULS:
		op2(C_MULSword,defaultWsize_nobits,data_ea,Dn2reg)
		#ifdef USE_68030
			xop2len(C_MULSlong,CX_MULSlong,MULS_L_32xsize,data_ea,xDlow)
			xop2len(C_MULSlong,CX_MULSword,MULS_L_64xsize,data_ea,xDhighxDlow)
		#endif
		bad(err_LorWsize_nobits)

	case X_MULU:
		op2(C_MULUword,defaultWsize_nobits,data_ea,Dn2reg)
		#ifdef USE_68030
			xop2len(C_MULUlong,CX_MULSlong,MULS_L_32xsize,data_ea,xDlow)
			xop2len(C_MULUlong,CX_MULSword,MULS_L_64xsize,data_ea,xDhighxDlow)
		#endif
		bad(err_LorWsize_nobits)

	case X_NBCD: op1(C_NBCD,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)

	case X_NEG:  op1(C_NEG,anysize,data_alt_ea) bad(anysize)

	case X_NEGX: op1(C_NEGX,anysize,data_alt_ea) bad(anysize)

	case X_NOP:  op0(C_NOP) bad(no_size)

	case X_NOT:  op1(C_NOT,anysize,data_alt_ea) bad(anysize)

	case X_OR:

			/* Try ORI. */

		op2(C_ORItoCR,Bsize_nobits,nxdata_8,cr_pat)
		op2(C_ORItoSR,Wsize_nobits,nxdata_16,sr_pat)
		op2(C_ORI,anysize,nxdata_size,data_alt_ea)

			/* Default. */

		op2(C_ORtoDn,anysize,data_ea,Dn2)
		op2(C_ORtoMem,anysize,Dn2,mem_alt_ea)	/* 0/1 not allowed as dest ea */
		bad(anysize)

	case X_ORI:
		op2(C_ORItoCR,Bsize_nobits,nxdata_8,cr_pat)
		op2(C_ORItoSR,Wsize_nobits,nxdata_16,sr_pat)
		op2(C_ORI,anysize,nxdata_size,data_alt_ea)
		bad(anysize)

	case X_PEA:   op1(C_PEA,defaultLsize_nobits,control_ea) bad(defaultLsize_nobits)
	case X_RESET: op0(C_RESET) bad(no_size)

	case X_ROL:  shiftop(ROL)  bad(anysize)
	case X_ROR:  shiftop(ROR)  bad(anysize)
	case X_ROXL: shiftop(ROXL) bad(anysize)
	case X_ROXR: shiftop(ROXR) bad(anysize)

	case X_RTD: op1(C_RTD,no_size,xdata_16) bad(no_size)
	case X_RTE: op0(C_RTE) bad(no_size)
	case X_RTR: op0(C_RTR) bad(no_size)
	case X_RTS: op0(C_RTS) bad(no_size)

	case X_SBCD:
		op2(C_SBCDtoDn,defaultBsize_nobits,Dn,Dn2reg)
		op2(C_SBCDtoAnpredec,defaultBsize_nobits,Anpredecreg,Anpredec2reg)
		bad(defaultBsize_nobits)

	case X_STOP: op1(C_STOP,no_size,nxdata_16) bad(no_size)

	case X_SCC: op1(C_SCC,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_SCS: op1(C_SCS,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_SEQ: op1(C_SEQ,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_SF:  op1(C_SF, defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_SGE: op1(C_SGE,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_SGT: op1(C_SGT,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_SHI: op1(C_SHI,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_SLE: op1(C_SLE,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_SLS: op1(C_SLS,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_SLT: op1(C_SLT,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_SMI: op1(C_SMI,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_SNE: op1(C_SNE,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_SPL: op1(C_SPL,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_ST:  op1(C_ST ,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_SVC: op1(C_SVC,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_SVS: op1(C_SVS,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)

	case X_SUB:

			/* Try SUBQ. */

		op2(C_SUBQ,WorLsize,quick_data2,An)		/* .B not allowed for Aregs. */
		op2(C_SUBQ,anysize,quick_data2,data_alt_ea)

			/* Try SUBA. */

		op2(C_SUBAword,Wsize_nobits,ea,An2reg)
		op2(C_SUBAlong,Lsize_nobits,ea,An2reg)

			/* Try SUBI. */

		op2(C_SUBI,anysize,xdata_size,data_alt_ea)

			/* Default. */

		op2(C_SUBtoDn,WorLsize,An,Dn2)		/* .B not allowed for Aregs. */
		op2(C_SUBtoDn,anysize,data_ea,Dn2)
		op2(C_SUBtoMem,anysize,Dn2,mem_alt_ea)
		bad(anysize)

	case X_SUBA:
		op2(C_SUBAword,Wsize_nobits,ea,An2reg)
		op2(C_SUBAlong,Lsize_nobits,ea,An2reg)
		bad(err_LorWsize_nobits)

	case X_SUBI: op2(C_SUBI,anysize,xdata_size,data_alt_ea) bad(anysize)

	case X_SUBQ:
		op2(C_SUBQ,WorLsize,quick_data2,An)		/* .B not allowed for Aregs. */
		op2(C_SUBQ,anysize,quick_data2,data_alt_ea)
		bad(anysize)

	case X_SUBX:
		op2(C_SUBXtoDn,anysize,Dn,Dn2reg)
		op2(C_SUBXtoMem,anysize,Anpredecreg,Anpredec2reg)
		bad(anysize)

	case X_SWAP: op1(C_SWAP,defaultWsize_nobits,Dn)			bad(defaultWsize_nobits)
	case X_TAS:  op1(C_TAS,defaultBsize_nobits,data_alt_ea) bad(defaultBsize_nobits)
	case X_TRAP: op1(C_TRAP,no_size,vector)					bad(no_size)

	case X_TRAPV: op0(C_TRAPV)					bad(no_size)
	case X_TST:   op1(C_TST,anysize,data_ea)	bad(anysize)
	case X_UNLK:  op1(C_UNLK,no_size,Anreg)		bad(no_size)

	default:
		if (is_x30tok(cip -&gt; n_type)) {
			error(es("68030 instructions not supported yet"));
		}
		else {
			fatal(es("bad op code"));
		}
	}

	/*
		All patterns fail for the given mnemonic and arguments.
	*/
bad_opcode:

	/* Issue an error message and mark the cinode as in error. */
	error(es("valid arguments do not match any machine pattern"));
	c_set_error(cip);
	
	/* Add the instruction to the start of the code list for the current area. */
	ASSERT(sem_current_area);
	cip -&gt; next = sem_current_area -&gt; area_code_list;
	sem_current_area -&gt; area_code_list = cnode_ptr(cip);

	STATX(ftag);
	return cip;
	
	/*
		A valid instruction has been found.
	*/
good:
	
	/* Add the instruction at the start of the global code list. */
	ASSERT(sem_current_area);
	cip -&gt; next = sem_current_area -&gt; area_code_list;
	sem_current_area -&gt; area_code_list = cnode_ptr(cip);
	
	STATX(ftag);
	return cip;
}
</t>
<t tx="ekr.20080529093004.28">@ Report an internal compiler error arising from the attempt to set one or more bits twice. This check is *very* effective in finding assembler bugs.
@c

void
asm_bad_bits_error(cinode * cip, ushort bits)
{
	SL_DISABLE();
	es(" bits set more than once: ");
	es(" previous bits: ");	epadhex(cip -&gt; c_bits, 4);
	es(", new bits: ");		epadhex(bits,4);
	es(", conflict: ");		epadhex((cip -&gt; c_bits) &amp; (bits), 4);
}
</t>
<t tx="ekr.20080529093004.29">@ The opcode bits of an instruction are set by the match routine. All other bits of a machine instruction are set here.  Using the address mode in ap -&gt; n_type, set the ea or ea2 bits of the_cip -&gt; c_bits. If extension words are implied by the address mode,  set ap -&gt; xsize to the number of extension words for this operand.  set ap -&gt; xwords, ap -&gt; bd and ap -&gt; od as needed.  The field_type parameter tells which bits of the_cip -&gt; c_bits to set:  NO_FIELD: set no bits.  EA_FIELD: set the ea field.  EA2_FIELD: set the ea2 field.  EAREG_FIELD: set only the register bits of the ea field.  EA2REG_FIELD: set only the register bits of the ea2 field.
@c

static void
ea_bits(anode * ap, int field_type)
{
	FTAG("ea_bits");
	ushort ea = 0;
	ushort ea_size = 0;	/* Number of extension words.  Assume no extension words. */
	ushort temp = 0;
	STATB(ftag);
	ASSERT(ap);

	switch(ap -&gt; n_type) {

	/* modes 7:0 short address. */
	case ABS16_EA:
	{
		bool error_flag = FALSE;
		ulong uval = ea_val(ap, 2, REPORT_OVERSIZE_CONSTANTS, &amp;error_flag, UNSIGNED_FIELD);

		ASSERT(0x38 == (0x07 &lt;&lt; 3));
		ea = 0x38;
		ea_size = 1;
		if (!error_flag) {
			ap -&gt; xwords = uval;
			(ap -&gt; xwords) &amp;= 0xffff;
		}
		goto done;
	}

	/* mode 7:1: Long address. */
	case ABSOLUTE_EA:
	case ABS32_EA:
	{
		bool error_flag = FALSE;
		ulong uval = ea_val(ap, 4, REPORT_OVERSIZE_CONSTANTS, &amp;error_flag, UNSIGNED_FIELD);

		ASSERT(0x39 == ((0x07 &lt;&lt; 3) | 1));
		ea = 0x39;
		ea_size = 2;
		if (!error_flag) {
			ap -&gt; xwords = uval;
		}
		goto done;
	}

	/* mode 1: An */
	case AREG_EA:
		ASSERT(0x08 == (0x01 &lt;&lt; 3));
		ASSERT(is_areg(ap -&gt; a_reg));
		ea = (0x08 | areg_num(ap -&gt; a_reg));
		goto done;

	/*
		mode 5: #word(a6)
		This requires one word on extension, holding the displacement.
	*/
	case DISPLACEMENT_EA:
	{
		bool error_flag = FALSE;
		ulong uval = ea_val(ap, 2, REPORT_OVERSIZE_CONSTANTS, &amp;error_flag, SIGNED_FIELD);

		ASSERT(0x28 == (0x05 &lt;&lt; 3));
		ASSERT(is_areg(ap -&gt; a_reg));
		ea = (0x28 | areg_num(ap -&gt; a_reg));
		ea_size = 1;
		if (!error_flag) {
			ap -&gt; xwords = uval;
			(ap -&gt; xwords) &amp;= 0xffff;
		}
		goto done;
	}

	/* mode 0: Dn */
	case DREG_EA:
		ASSERT(is_dreg(ap -&gt; a_reg));
		ea = (0x00 | dreg_num(ap -&gt; a_reg));
		goto done;

	/*
		mode 7:4: Immediate data:

		M68000 book, page 3-10:
		The *instruction* length determines the format of the extension:
			Byte: data in low byte of first extension word.
			Word: data in all of first extension word.
			Long: data in both extension words.
	*/
	case IMMEDIATE_EA:
	case IMM8_EA:
	case IMM16_EA:
	case IMM32_EA:
	{
		bool error_flag = FALSE;
		ulong uval = ea_val(ap, the_cip -&gt; c_new_len,
						REPORT_OVERSIZE_CONSTANTS, &amp;error_flag, SIGNED_FIELD);

		ASSERT(0x3c == ((0x07 &lt;&lt; 3) | 4));
		ea = 0x3c;
		ea_size = (the_cip -&gt; c_new_len &lt; 4) ? 1 : 2;
		if (!error_flag) {
			ap -&gt; xwords = uval;
			if (ea_size == 1) {
				(ap -&gt; xwords) &amp;= 0xffff;
			}
		}
		goto done;
	}

	/*
		mode 6: #byte(a4,d4)

		M68000 book, page 3-8:
		This mode requires one extension word, formatted as follows:
		da_xbits:	0/1: Index reg is a data/address register.
		reg_xbits:	the data or address register.
		wl_xbits:	0/1: Index register is word/long.
		disp_xbits:	8-bit displacement.

		In the 68000 bits 8,9,10 must be zero.
	*/
	case INDEX_EA:			/* #byte(a4,d4) */
	case INDEX16_EA:		/* #byte(an,xn.w) */
	case INDEX32_EA:		/* #byte(an,xn.l) */
	{
		bool error_flag = FALSE;
		ulong uval = ea_val(ap, 1, REPORT_OVERSIZE_CONSTANTS, &amp;error_flag, SIGNED_FIELD);

		ASSERT(0x30 == (0x06 &lt;&lt; 3));
		ASSERT(is_areg(ap -&gt; a_reg));
		ea = (0x30 | areg_num(ap -&gt; a_reg));
		ea_size = 1;
		
		if (!error_flag) {
			ap -&gt; xwords = uval;
			if (is_areg(ap -&gt; a_xreg)) {
				ap -&gt; xwords |= (areg_num(ap -&gt; a_xreg) &lt;&lt; 12);
				ASSERT( (ap -&gt; xwords &amp; da_xbits) == 0);
				ap -&gt; xwords |= da_xbits;
			}
			else {
				ASSERT(is_dreg(ap -&gt; a_xreg));
				ap -&gt; xwords |= (dreg_num(ap -&gt; a_xreg) &lt;&lt; 12);
			}
			
			if (ap -&gt; n_type == INDEX32_EA) {
				/* We go along with MPW: the default is .w, not .l. */
				ap -&gt; xwords |= wl_xbits;
			}
			(ap -&gt; xwords) &amp;= 0xffff;
		}
		goto done;
	}

	/* mode 2: (a0) */
	case INDIRECT_EA:
		ASSERT(0x10 == (0x02 &lt;&lt; 3));
		ASSERT(is_areg(ap -&gt; a_reg));
		ea = (0x10 | areg_num(ap -&gt; a_reg));
		goto done;

	/* mode 3: (a0)+ */
	case POST_INC_EA:
		ASSERT(0x18 == (0x03 &lt;&lt; 3));
		ASSERT(is_areg(ap -&gt; a_reg));
		ea = (0x18 | areg_num(ap -&gt; a_reg));
		goto done;

	/* mode 4: -(a0) */
	case PRE_DEC_EA:
		ASSERT(0x20 == (0x04 &lt;&lt; 3));
		ASSERT(is_areg(ap -&gt; a_reg));
		ea = (0x20 | areg_num(ap -&gt; a_reg));
		goto done;

	/* mode 7:2: #word(pc) */
	case PC_DISP_EA:
	{
		bool error_flag = FALSE;
		ulong uval = ea_val(ap, 2, REPORT_OVERSIZE_CONSTANTS, &amp;error_flag, SIGNED_FIELD);

		ASSERT(0x3a == ((0x07 &lt;&lt; 3) | 2));
		ea = 0x3a;
		ea_size = 1;
		if (!error_flag) {
			ap -&gt; xwords = 
			(ap -&gt; xwords) &amp;= 0xffff;
		}
		goto done;
	}

	/*
		mode 7:3: #byte(pc,xn)

		M68000 book, page 3-10:
		This mode requires one extension word, formatted as follows:
		da_xbits:	0/1: Index reg is a data/address register.
		reg_xbits:	the data or address register.
		wl_xbits:	0/1: Index register is word/long.
		disp_xbits:	8-bit displacement.

		In the 68000 bits 8,9,10 must be zero.
	*/
	case PC_INDEX_EA:
	case PC_INDEX16_EA:		/* #byte(pc,xn.w) */
	case PC_INDEX32_EA:		/* #byte(pc,xn.l) */
	{
		bool error_flag = FALSE;
		ulong uval = ea_val(ap, 1, REPORT_OVERSIZE_CONSTANTS, &amp;error_flag, SIGNED_FIELD);

		ASSERT(0x3b == ((0x07 &lt;&lt; 3) | 3));
		ea = 0x3b;
		ea_size = 1;
		if (!error_flag) {
			ap -&gt; xwords = uval;
			if (is_areg(ap -&gt; a_xreg)) {
				ap -&gt; xwords |= da_xbits;
				ap -&gt; xwords |= (areg_num(ap -&gt; a_xreg) &lt;&lt; 12);
			}
			else {
				ASSERT(is_dreg(ap -&gt; a_xreg));
				ap -&gt; xwords |= (dreg_num(ap -&gt; a_xreg) &lt;&lt; 12);
			}
	
			if (ap -&gt; n_type == PC_INDEX32_EA) {
				/* We go along with MPW: the default is .w, not .l. */
				ap -&gt; xwords |= wl_xbits;
			}
			(ap -&gt; xwords) &amp;= 0xffff;
		}
		goto done;
	}

	/*
		Register lists are implied by the opcode,
		so only the extension word is affected.
	*/
	case REGLIST_EA:
		ea_size = 1;
		goto done;

	/*
		Special registers are used for pattern matching only.
		The actual bits are implied by the op codes so
		nothing further need be done here.
	*/
	case SPECIAL_EA:
		goto done;

	#ifdef USE_68030

		/* Dr:Dq or Dhigh:Dlow. */
		case DREG_DREG_EA:
			goto done;

		/* #word(a0) */
		case IND16_EA20:
			goto done;

		/* #long(an,xn.w*scale) */
		case INDEX16_EA20:
			goto done;

		/* #long(an,xn.l*scale) */
		case INDEX32_EA20:
			goto done;

		/* offset:width. */
		case OFFSET_WIDTH_EA:
			goto done;

		/* #byte(pc,xn.w*scale) */
		case PC_INDEX16_EA20:
			goto done;

		/* #byte(pc,xn.l*scale) */
		case PC_INDEX32_EA20:
			goto done;

		/* ([bd,an],xn*scale,od) */
		case POST_INDEX_EA20:
			goto done;

		/* ([bd,an],xn.w*scale,od) */
		case POST_INDEX16_EA20:
			goto done;

		/* ([bd,an],xn.l*scale,od) */
		case POST_INDEX32_EA20:
			goto done;

		/* ([bd,an],xn*scale,od) */
		case PRE_INDEX_EA20:
			goto done;

		/* ([bd,an,xn.w*scale],od) */
		case PRE_INDEX16_EA20:
			goto done;

		/* ([bd,an,xn.l*scale],od) */
		case PRE_INDEX32_EA20:
			goto done;

		/* ([bd,pc],xn*scale,od) */
		case PC_POST_INDEX_EA20:
			goto done;

		/* ([bd,pc],xn.w*scale,od) */
		case PC_POST_INDEX16_EA20:
			goto done;

		/* ([bd,pc],xn.l*scale,od) */
		case PC_POST_INDEX32_EA20:
			goto done;

		/* ([bd,pc],xn*scale,od) */
		case PC_PRE_INDEX_EA20:
			goto done;

		/* ([bd,pc,xn.w*scale],od) */
		case PC_PRE_INDEX16_EA20:
			goto done;

		/* ([bd,pc,xn.l*scale],od) */
		case PC_PRE_INDEX32_EA20:
			goto done;

	#endif

	default:
		fatal(es("unknown address mode"));
	}

done:
	ap -&gt; xsize = ea_size;
	switch(field_type) {

	case EA_FIELD:
		set_cbits_macro(the_cip, ea)
		TRACEPN(ftag, es("ea     bits: "); epadhex(ea, 4); enl());
		break;

	case EA2_FIELD:
		/*
			Switch the mode and register bits.
			Think C compiler bug: don't merge the following two instructions!
		*/
		temp = ((ea &amp; 0x07) &lt;&lt; 3) | ((ea &amp; 0x38) &gt;&gt; 3);
		temp = (temp &lt;&lt; 6);
		set_cbits_macro(the_cip, temp)
		TRACEPN(ftag, es("ea2    bits: "); epadhex(temp, 4); enl());
		break;

	case EAREG_FIELD:
		temp = (ea &amp; 0x07);
		set_cbits_macro(the_cip, temp)
		TRACEPN(ftag, es("eareg bits:  "); epadhex(temp, 4); enl());
		break;

	case EA2REG_FIELD:
		temp = ((ea &amp; 0x07) &lt;&lt; 9);
		set_cbits_macro(the_cip, temp)
		TRACEPN(ftag, es("ea2reg bits: "); epadhex(temp, 4); enl());
		break;

	case NO_FIELD:
		break;

	default:
		fatal(es("unknown field type"));
		break;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.30">@ Return the unsigned value of a constant described by ap -&gt; a_enode. Set error_flag in the caller if the constant will not fit  in the indicated number of bytes.  This routine *must* return an unsigned value, even when the bits are interpreted as a signed value by the 68000.  Don't report the error if report_error_flag is FALSE. This allows the pattern matcher to try instructions such as ADDQ without generating error messages.
@c

static ulong
ea_val (anode * ap, ushort bytes, bool report_error_flag, bool * error_flag, short sign_kind)
{
	FTAG("ea_val");
	long val = 0;
	STATB(ftag);
	
	/* User errors can cause this. */
	if (ap == NULL || ap -&gt; a_enode == NULL) {
		*error_flag = TRUE;
		goto done;
	}
	else {
		val = expr_get_val(
			ap -&gt; a_enode, bytes, error_flag, ALLOW_UNKNOWN_REFS, err_line, sign_kind);
	}

	if (report_error_flag &amp;&amp; *error_flag) {
		error(elong(val); es(" does not fit in ");
		eint(bytes); es((bytes == 1) ? " byte" : " bytes"));
	}

done:
	STATX(ftag);
	return (ulong) val;
}
</t>
<t tx="ekr.20080529093004.31">@ Given an error and return TRUE if the indicated length does not match the given pattern.  This routine is used to give a more specific error message when no pattern matches fully.
@c

#define err_length_macro(condition) error_flag = !(condition); break

static bool
err_match_len(cinode * cip, int pattern)
{
	FTAG("err_match");
	bool error_flag = FALSE;
	ushort clen = 0;
	STATB(ftag);
	ASSERT(cip);
	
	clen = cip -&gt; c_new_len;
	
	switch(pattern) {

	case anysize:
	case bxx_size_nobits:		err_length_macro(clen == 0 || clen == 1 || clen == 2);

	case Bsize:
	case Bsize_nobits:			err_length_macro(clen == 1);
	
	case defaultBsize_nobits:	err_length_macro(clen == 0 || clen == 1);

	case defaultLsize_nobits:	err_length_macro(clen == 0 || clen == 4);
	
	case dbxx_size_nobits:
	case defaultWsize_nobits:	err_length_macro(clen == 0 || clen == 2);
	
	/* Used only for error matching... */
	case err_BorLsize_nobits:	err_length_macro(clen == 1 || clen == 2);
	case err_LorWsize_nobits:	err_length_macro(clen == 2 || clen == 4);
	
	case Lsize:					
	case Lsize_nobits:			err_length_macro(clen == 4);

	case no_size:				err_length_macro(clen == 0);

	case WorLsize:				err_length_macro(clen == 2 || clen == 4);

	case Wsize:					
	case Wsize_nobits:			err_length_macro(clen == 2);

	default:
		fatal(es("unknown size pattern"));
	}
	
	if (error_flag) {
		error(es("improper instruction length"));
	}
		
	STATX(ftag);
	return error_flag;
}
</t>
<t tx="ekr.20080529093004.32">@ This routine matches the ap's address mode against a pattern. Return TRUE is a match is found, otherwise return FALSE. Set the ap -&gt; xsize, ap -&gt; xwords, ap -&gt; bd and ap -&gt; bd fields only if a match is not found.  The caller is responsible for backing out of failed matches.  This routine defines the semantics of all patterns except length patterns.
@c

#define match_ea_bits(condition)  		result = (condition); goto set_ea
#define match_eareg_bits(condition)  	result = (condition); goto set_eareg
#define match_ea2_bits(condition) 		result = (condition); goto set_ea2
#define match_ea2reg_bits(condition)	result = (condition); goto set_ea2reg
#define match_no_bits(condition)  		result = (condition); goto done
#define match_xbits(condition)    		result = (condition); goto set_xbits

static bool
match(anode * ap, int pattern)
{
	FTAG("match");
	register bool result = FALSE;
	register int type = 0;
	bool junk;
	STATB(ftag);

	if (ap == NULL) {
		goto done;
	}
	type = ap -&gt; n_type;

	switch(pattern) {

	/* Alterable modes in ea field. */
	case alt_ea:
		match_ea_bits(is_alterable(type));

	/* An in ea field. */
	case An:
		match_ea_bits(type == AREG_EA);

	/* An in reg part of ea field. */
	case Anreg:
		match_eareg_bits(type == AREG_EA);

	/* An in ea2 field. */
	case An2:
		match_ea2_bits(type == AREG_EA);

	/* An in reg part of ea2 field. */
	case An2reg:
		match_ea2reg_bits(type == AREG_EA);

	/* -(An) in ea field. */
	case Anpredecreg:
		match_eareg_bits(type == PRE_DEC_EA);

	/* -(An) in ea2 field. */
	case Anpredec2reg:
		match_ea2reg_bits(type == PRE_DEC_EA);

	/* (An)+ in ea field. */
	case Anpostincreg:
		match_eareg_bits(type == POST_INC_EA);

	/* (An)+ in ea2 reg field. */
	case Anpostinc2reg:
		match_ea2reg_bits(type == POST_INC_EA);

	/* #word(An) in ea field. */
	case Anreg_disp16:
		match_eareg_bits(type == DISPLACEMENT_EA);

	/* Control modes in ea field. */
	case control_ea:
		match_ea_bits(is_control(type));
		
	/* Control alterable in ea field. */
	case control_alt_ea:
		match_ea_bits(is_control_alterable(type));

	/* condition code register. */
	case cr_pat:
		match_no_bits(type == SPECIAL_EA &amp;&amp; ap -&gt; a_reg == R_CCR);

	/* Data modes in ea. */
	case data_ea:
		match_ea_bits(is_data_mode(type));

	/* Data modes except immediate: not modes 1, 7:4 */
	case data_not_imm_ea:
		match_ea_bits(is_data_mode(type) &amp;&amp; !is_mode7_4(type));
		break;

	/* Data alterable: not modes 1, 7, (modes 7:0, 7:1 are valid) */
	case data_alt_ea:
		match_ea_bits(type != AREG_EA &amp;&amp; is_alterable(type));
		
	/* Data alterable in ea2 field. */
	case data_alt_ea2:
		match_ea2_bits(type != AREG_EA &amp;&amp; is_alterable(type));

	/* Data register in ea. */
	case Dn:
		match_ea_bits(type == DREG_EA);

	/* Data register in register part of ea. */
	case Dnreg:
		match_eareg_bits(type == DREG_EA);

	/* Data register in ea2. */
	case Dn2:
		match_ea2_bits(type == DREG_EA);

	/* Data register in register field (only) ofea2. */
	case Dn2reg:
		match_ea2reg_bits(type == DREG_EA);

	/* Data register and control in ea. */
	case dn_ctl_alt_ea:
		match_ea_bits(type == DREG_EA || is_control(type));

	/* All modes in ea. */
	case ea:
		match_ea_bits(is_ea(type));

	/* All modes in ea2. */
	case ea2:
		match_ea2_bits(is_ea(type));

	/* Memory alterable modes in ea. */
	case mem_alt_ea:
		match_ea_bits(is_memory_alterable(type));

	/* MOVEM memory to register: postincrement or control. */
	case pi_ctr_ea:
		match_ea_bits(type == POST_INC_EA || is_control(type));

	/*
		*signed* data in low 8 bits of opword.
		We must be very careful not to turn a negative value into a positive value here.
		The interpretation of the sign *does* matter in the MOVEQ instruction!
	 */
	case quick_data:
		result = (type == IMMEDIATE_EA);
		if (result) {
			bool error_flag = FALSE;
			ulong uval = ea_val(ap, 1,
				DONT_REPORT_OVERSIZE_CONSTANTS, &amp;error_flag, SIGNED_FIELD);

			if (error_flag) {
				result = FALSE;
			}
			else {
				set_cbits_macro(the_cip, uval); 
			}
		}
		goto done;
		
	case quick0_data_nobits:
		result = (type == IMMEDIATE_EA);
		if (result) {
			bool error_flag = FALSE;
			ulong uval = ea_val(ap, 1, DONT_REPORT_OVERSIZE_CONSTANTS,
							&amp;error_flag, NO_SIGN_FIELD);
			result = (!error_flag &amp;&amp; uval == 0);
		}
		goto done;

	/* *unsigned* data in bits 9-11 of opword.  8 is represented by 0. */
	case quick_data2:
		result = (type == IMMEDIATE_EA);
		if (result) {
			bool error_flag = FALSE;
			long val = ea_val(ap, 2, DONT_REPORT_OVERSIZE_CONSTANTS,
							&amp;error_flag, UNSIGNED_FIELD);

			if (error_flag == FALSE &amp;&amp; val == 8) {
				/* Set no bits. */
				;
			}
			else if (error_flag == FALSE &amp;&amp; val &lt; 8 &amp;&amp; val &gt; 0) {
				ushort temp = (val &lt;&lt; 9);
				set_cbits_macro(the_cip, temp); 
			}
			else {
				result = FALSE;
			}
		}
		goto done;

	/* Status register. */
	case sr_pat:
		match_no_bits(type == SPECIAL_EA &amp;&amp; ap -&gt; a_reg == R_SR);

	/* Bits 0-3 */
	case trap_num:
	case vector:
		result = (type == IMMEDIATE_EA);
		if (result) {
			bool error_flag = FALSE;
			ulong uval = ea_val(ap, 1, DONT_REPORT_OVERSIZE_CONSTANTS,
									&amp;error_flag, UNSIGNED_FIELD);

			if (error_flag == FALSE &amp;&amp; uval &lt; 16) {
				set_cbits_macro(the_cip, uval); 
			}
			else {
				/* No match after all. */
				result = FALSE;
			}
		}
		goto done;

	/* User stack pointer. */
	case usp_pat:
		match_no_bits(type == SPECIAL_EA &amp;&amp; ap -&gt; a_reg == R_USP);

	/* Bit number (0 - 31 mod 32) in low 8 bits of extension word (high bits are 0) */
	case xbit_num:
		result = (type == IMMEDIATE_EA);
		if (result) {
			bool error_flag = FALSE;
			ulong uval = ea_val(ap, 1, REPORT_OVERSIZE_CONSTANTS,
							&amp;error_flag, NO_SIGN_FIELD);

			ap -&gt; xsize = 1;
			if (!error_flag) {
				ap -&gt; xwords = uval;
				(ap -&gt; xwords) &amp;= 0xffff;
			}
		}
		goto done;

	case default_imm_ea:
		result = (type == IMMEDIATE_EA);
		if (result) {
			bool error_flag = FALSE;
			ulong uval = ea_val(ap, the_cip -&gt; c_new_len,
							DONT_REPORT_OVERSIZE_CONSTANTS,
							&amp;error_flag, NO_SIGN_FIELD);

			if (error_flag) {
				result = FALSE;
			}
			else {
				ap -&gt; xsize = (the_cip -&gt; c_new_len &lt; 4) ? 1 : 2;
				ap -&gt; xwords = uval;
				if (ap -&gt; xsize == 1) {
					(ap -&gt; xwords) &amp;= 0xffff;
				}
			
				/* Set the ea field. */
				ASSERT(0x3c == ((0x07 &lt;&lt; 3) | 4));
				set_cbits_macro(the_cip, 0x3c);
			}
		}
		goto done;

	case imm_ea:
	{
		bool error_flag = FALSE;
		result = (type == IMMEDIATE_EA);
		if (result) {
			bool error_flag = FALSE;
			ulong uval = ea_val(ap, the_cip -&gt; c_new_len,
				REPORT_OVERSIZE_CONSTANTS, &amp;error_flag, NO_SIGN_FIELD);

			ASSERT(0x3c == ((0x07 &lt;&lt; 3) | 4));
			set_cbits_macro(the_cip, 0x3c)
			ap -&gt; xsize = (the_cip -&gt; c_new_len &lt; 4) ? 1 : 2;
			if (!error_flag) {
				ap -&gt; xwords = uval;
				if (ap -&gt; xsize == 1) {
					(ap -&gt; xwords) &amp;= 0xffff;
				}
			}
		}
		goto done;
	}
		
	/*
		Data in extention word(s) whose size depends on size field.
		The nxdata_size pattern is used for AND, OR, EOR instructions,
		so we can use the more relaxed NO_SIGN_FIELD specification.
		In other words, we don't care about the interpretation of the sign bit.
	*/

	case nxdata_size:
	case xdata_size:
	{
		bool error_flag = FALSE;
		result = (type == IMMEDIATE_EA);
		if (result) {
			bool error_flag = FALSE;
			ulong uval = ea_val(ap, the_cip -&gt; c_new_len,
				REPORT_OVERSIZE_CONSTANTS, &amp;error_flag,
				((pattern == xdata_size) ? SIGNED_FIELD : NO_SIGN_FIELD));
	
			ap -&gt; xsize = (the_cip -&gt; c_new_len &lt; 4) ? 1 : 2;
			if (!error_flag) {
				ap -&gt; xwords = uval;
				if (ap -&gt; xsize == 1) {
					(ap -&gt; xwords) &amp;= 0xffff;
				}
			}
		}
		goto done;
	}

	case nxdata_8:
		result = (type == IMMEDIATE_EA);
		if (result) {
			bool error_flag = FALSE;
			ulong uval = ea_val(ap, 1, REPORT_OVERSIZE_CONSTANTS,
							&amp;error_flag, NO_SIGN_FIELD);
	
			ap -&gt; xsize = 1;
			if (!error_flag) {
				ap -&gt; xwords = uval;
				(ap -&gt; xwords) &amp;= 0xffff;
			}
		}
		goto done;
		
	case nxdata_16:
	case xdata_16:

		result = (type == IMMEDIATE_EA);
		if (result) {
			bool error_flag = FALSE;
			ulong uval = ea_val(ap, 2, REPORT_OVERSIZE_CONSTANTS, &amp;error_flag,
								((pattern == xdata_size) ? SIGNED_FIELD : NO_SIGN_FIELD));
			
			ap -&gt; xsize = 1;
			if (!error_flag) {
				ap -&gt; xwords = uval;
				(ap -&gt; xwords) &amp;= 0xffff;
			}
		}
		goto done;

	/*
		Handle the offset field of bxx instructions, i.e., bcc, bra and bsr instructions.
		The operand to a bxx instruction must be a single label.
		This is a stricter requirement than simply requing ABSOLUTE_EA mode.
		
		There is an interesting conundrum involved here.
		We have to know the sizes of bxx instruction to get the value of labels
		and we have to know the value of labels to calculate the sizes of bxx instructions!
		
		There are several ways to break this circular dependency.
		We could, for example, calculate the minimum and maximum values of all labels,
		using the minimum and maximum sizes of bxx instructions.
		In this way, we could calculate the minimum safe size of bxx instructions.
	 
		While such a scheme would work, the following code uses the following method:

		1) [The label field has been defined.]
		   Use the explicitly given size if one has been given.
		   Othewise, use the appropriate offset size based on the known offset.
		2) [The label field has not been defined yet.]
		   The offset field will be the explicitly stated size, or 16 bits if no size is given.
		   Create a bxx node describing the offset field that will be filled in later.
		   An error will be given later if byte size is specifed and the offset is later
		   found to require 16 bits.
		   An optional warning will be given later if word size is specifed and the
		   offset is found later to require only 8 bits.
		   
		This method is simple and honors explicit size designations.
		   
		IMPORTANT WARNING:
		The present code assumes that the *entire* instruction succeeds if
		the xdata_bxx pattern succeeds.
		This assumption is valid at present because the xdata_bxx pattern is
		matched last in the op1af and op2af routines.
		
		An alternate scheme that does not impose this global requirement on the matching
		routines would be to place bxx_nodes initially on a temp_bxx_list and
		"commit" to these nodes by placing them on the global sem_bxx_list only when
		the entire pattern matches.

		By the way, this is the only pattern whose size depends on the value of labels.
		Therefore, this is the only pattern that must handle these gruesome details.
		
		The xdata_lab case is very similar except that *only* an 16-bit
		extension word is used, never an 8-bit extenstion.
	*/
	case xdata_bxx:
	case xdata_lab:
	
		/* Set result is true if the argument field is a single label. */
		result = (
			type == ABSOLUTE_EA &amp;&amp;
			ap &amp;&amp; ap -&gt; a_enode &amp;&amp; ap -&gt; a_enode -&gt; n_type == O_SUMMARY &amp;&amp;
			summary_enode_ptr(ap -&gt; a_enode) -&gt; val == 0 &amp;&amp;
			summary_enode_ptr(ap -&gt; a_enode) -&gt; neg_label_list == NULL &amp;&amp;
			summary_enode_ptr(ap -&gt; a_enode) -&gt; pos_label_list &amp;&amp;
			summary_enode_ptr(ap -&gt; a_enode) -&gt; pos_label_list -&gt; next == NULL
		);
		if (result) {

			summary_enode * sep = summary_enode_ptr(ap -&gt; a_enode);
			dict_node * mdp = sep -&gt; pos_label_list -&gt; the_m_dict;
			ASSERT(ap == the_cip -&gt; c_arg1 || ap == the_cip -&gt; c_arg2);
			
			if (pattern == xdata_lab) {

				/*
					Force an extension word by setting the length to a flag value.
					The sem_do_offset routine will set the length to 0 for printing.
				*/
				the_cip -&gt; c_new_len = 100;
			}
		
			if (dict_is_defined(mdp)) {
			
				/* Use a temporary bxx node to describe the field. */
				bxx_node bxx;
				
				bxx . next = NULL;
				bxx . bxx_lc = sem_current_area -&gt; area_app_length;
				bxx . bxx_unit = sem_current_unit;
				bxx . bxx_cip = the_cip;
				bxx . bxx_ap = ap;
				bxx . bxx_err_line = err_line;
				
				sem_do_offset(&amp;bxx, BXX_PASS1);
			}
			else {
			
				/* Create a bxx_node describing the field to be filled in. */
				bxx_node * bxp = NULL;
				new_file_macro(bxp, bxx_stats);
				bxp -&gt; bxx_lc = sem_current_area -&gt; area_app_length;
				bxp -&gt; bxx_cip = the_cip;
				bxp -&gt; bxx_ap = ap;
				bxp -&gt; bxx_err_line = err_line;
				
				/*
					Set the xsize field *now* so that cnode_app_size will work properly.
					We don't need to know the final offset to do this.
				*/
				if (the_cip -&gt; c_new_len == 0 || the_cip -&gt; c_new_len == 2 ||
					the_cip -&gt; c_new_len == 100
				) {
					ap -&gt; xsize = 1;
				}

				/* Attach the node to the global bxx list. */
				bxp -&gt; next = sem_bxx_list;
				sem_bxx_list = bxp;
			}
		}
		goto done;

	/* General register in high 4 bits of extension word. */
	case xgreg:
		result = (type == AREG_EA || type == DREG_EA);
		if (result) {
			ap -&gt; xsize = 1;
			ap -&gt; xwords = ((type == AREG_EA) ?
				areg_num(ap -&gt; a_reg) : (da_xbits | dreg_num(ap -&gt; a_reg)));
			(ap -&gt; xwords) &amp;= 0xffff;
		}
		goto done;

	/*
		Register list mask in extension word.
		Kludge: set the global reglist_ap for possible use by the movem_predec case.
	*/
	case xreglist:
		result = (type == REGLIST_EA);
		if (result) {
			reglist_ap = ap;
		}
		goto done;
		
	/*
		This pattern appears *only* in the destination field,
		so if it matches the entire instruction matches.
		
		If this pattern matches, and *only* if this pattern matches,
		the bits in the register list must be reversed!
	*/
	case movem_predec:
		result = (type == PRE_DEC_EA);		
		/* Reverse the bits of the register list. */
		if (result) {
			register ulong temp = 0;
			register int i = 0;
			register ulong old_reg_list = 0;
			register ulong new_reg_list = 0;
			ASSERT(reglist_ap);

			old_reg_list = reglist_ap -&gt; xwords;
			old_reg_list &amp;= 0xffff;
			for (i = 0; i &lt; 16; i++) {
				temp = (1 &lt;&lt; i);
				temp &amp;= 0xffff;
				if (old_reg_list &amp; temp) {
					temp = (1 &lt;&lt; (15-i));
					temp &amp;= 0xffff;
					new_reg_list |= temp;
				}
			}
			reglist_ap -&gt; xwords = new_reg_list;
			(reglist_ap -&gt; xwords) &amp;= (0xffff);
		}
		goto set_ea;

	#ifdef USE_68030

		/* MOVEC: Control register in low 12 bits of extension word. */
		case x30_creg:
			result = (type == SPECIAL_EA &amp;&amp; is_control_register(ap -&gt; a_reg));
			if (result) {
				;
			}
			goto done;

		/* Data in two exention words. */
		case xdata_32:
			goto done;

		/* Bit operators: Data register in bits 12-14 of extension word. */
		case xDn:
			result = (type == DREG_EA);
			if (result) {
				;
			}
			goto done;

		/* MULS: Data register in low 3 bits of extension word. */
		case xDlow:
			result = (type == DREG_EA);
			if (result) {
				;
			}
			goto done;

		/* MULS: XDhigh:XDlow */
		case xDhighxDlow:
			result = (type == DREG_DREG_EA);
			if (result) {
				;
			}
			goto done;

		/* DIVS: XDr:XDq */
		case xDrxDq:
			result = (type == DREG_DREG_EA);
			if (result) {
				;
			}
			goto done;

		/* DIVS: Data register in bits 12-14 of extension word. */
		case xDq:
			result = (type == DREG_EA);
			if (result) {
				;
			}
			goto done;

		/* DIVS: Data register in low 3 bits of extension word. */
		case xDr:
			result = (type == DREG_EA);
			if (result) {
				;
			}
			goto done;

		/*
			Extended bit instructions.
			Offset in bits 6-10 of extension word, flag in bit 11 of extension.
			Width  in bits 0-4  of extension word, flag in bit  5 of extension.
		*/
		case xoff_width:
			match_xbits(type == OFFSET_WIDTH_EA);

	#endif

	default:
		fatal(es("unknown address mode pattern: "); eint(pattern); ecnl());
	}

set_ea:
	if (result) {
		ea_bits(ap, EA_FIELD);
	}
	goto done;

set_eareg:
	if (result) {
		ea_bits(ap, EAREG_FIELD);
	}
	goto done;

set_ea2:
	if (result) {
		ea_bits(ap, EA2_FIELD);
	}
	goto done;

set_ea2reg:
	if (result) {
		ea_bits(ap, EA2REG_FIELD);
	}
	goto done;

set_xbits:
	if (result) {
		ea_bits(ap, NO_FIELD);
	}
	goto done;

done:
	STATX(ftag);
	return result;
}
</t>
<t tx="ekr.20080529093004.33">@ Return TRUE if the machine length, clen, matches the length pattern. If a match is found, set length bits in the_cip -&gt; c_bits.  The caller is responsible for backing out of failed matches.  This routine defines the semantics of all length patterns.
@c

#define return_result_macro(condition) \
{ result = (condition); goto return_result; }

#define return_size_bits_macro(the_bits) \
{ bits = (the_bits); goto set_length_bits; }

static bool
match_len(ushort clen, int len_pat)
{
FTAG("match_len");
register ushort bits = 0;
register bool result = FALSE;
STATB(ftag);
ASSERT(the_cip);

/*
	A kludge: set the global the_cip -&gt; c_new_len to clen.
	Later in this routine, defaults can also set clen.
	
	Setting the c_new_len allows routines in match to
	determine the "logical" instruction length,
	independent of the specified instruction length.

	We can't set cip -&gt; c_length because that would
	prevent backups.
*/
the_cip -&gt; c_new_len = clen;

switch(len_pat) {

/* Standard encoding of size field. */
case anysize:
	if (clen == 1) {
		return_size_bits_macro (size_bits_b);
	}
	else if (clen == 2) {
		return_size_bits_macro (size_bits_w);
	}
	else if (clen == 4) {
		return_size_bits_macro (size_bits_l);
	}
	else {
		goto false_ret;
	}

case Bsize:
	if (clen == 1) {
		return_size_bits_macro (size_bits_b);
	}
	else {
		goto false_ret;
	}

case Bsize_nobits:
	return_result_macro (clen == 1);

case bxx_size_nobits:
	the_cip -&gt; c_new_len = (clen == 1) ? 1 : 2;
	return_result_macro (clen == 0 || clen == 1 || clen == 2);

case dbxx_size_nobits:
	the_cip -&gt; c_new_len = (clen == 1) ? 1 : 2;
	return_result_macro (clen == 0 || clen == 2);

case defaultBsize_nobits:
	the_cip -&gt; c_new_len = 1;
	return_result_macro (clen == 0 || clen == 1);

case defaultLsize_nobits:
	the_cip -&gt; c_new_len = 4;
	return_result_macro (clen == 0 || clen == 4);

case defaultWsize_nobits:
	the_cip -&gt; c_new_len = 2;
	return_result_macro (clen == 0 || clen == 2);

case Lsize:
	if (clen == 4) {
		return_size_bits_macro (size_bits_l);
	}
	else {
		goto false_ret;
	}

case Lsize_nobits:
	return_result_macro (clen == 4);

case no_size:
	return_result_macro (clen == 0);

/* W or L but not B in size field */
case WorLsize:
	if (clen == 2) {
		return_size_bits_macro (size_bits_w);
	}
	else if (clen == 4) {
		return_size_bits_macro (size_bits_l);
	}
	else {
		goto false_ret;
	}

case Wsize:
	if (clen == 2) {
		return_size_bits_macro (size_bits_w);
	}
	else {
		goto false_ret;
	}

case Wsize_nobits:
	return_result_macro (clen == 2);

#ifdef USE_68030

	/* Standard encoding of size2 field in bits 9, 10 */
	case anysize2:
		if (clen == 1) {
			return_size_bits_macro (size2_bits_b);
		}
		else if (clen == 2) {
			return_size_bits_macro (size2_bits_w);
		}
		else if (clen == 4) {
			return_size_bits_macro (size2_bits_l);
		}
		else {
			goto false_ret;
		}

	/* L only for DIVS. 32-bit result: xbit 10 = 0. */
	case DIVS_L_32xsize:
		return_result_macro (clen == 4);

	/* L only for DIVS. 64-bit result: xbit 10 = 1. */
	case DIVS_L_64xsize:
		if (clen == 4) {
			set_bit(temp_xbits, bit10);
			goto true_ret;
		}
		else {
			goto false_ret;
		}

	/* L only for DIVSL. */
	case DIVSL_L_xsize:
		return_result_macro (clen == 4);

	/* L only for MULS. 32-bit result: xbit 10 = 0. */
	case MULS_L_32xsize:
		return_result_macro (clen == 4);

	/* L only for MULS. 64-bit result: xbit 10 = 1. */
	case MULS_L_64xsize:
		return_result_macro (clen == 4);

#endif

default:
	fatal(es("unknown size pattern"));
	break;
}

false_ret:
result = FALSE;
goto return_result;

set_length_bits:
set_cbits_macro(the_cip, bits);
result = TRUE;
goto return_result;

true_ret:
result = TRUE;
goto return_result;

return_result:
STATX(ftag);
return result;
}
</t>
<t tx="ekr.20080529093004.34">@ Outer-level pattern matching routines.  The following routines call match to match an argument against an argument pattern and call match_len to match the_cip -&gt; c_new_len against a length pattern.  If a match is found, these routines set opcode bits in the_cip -&gt; c_bits. Otherwise, these routines "back out" of the match by clearing the opcode bits. Setting or clearing the_cip -&gt; c_bits is handled by set_cbits_macro.  if the match succeeds, match sets the xwords, od and bd fields in the argument. However, a match may fail after a previous call to match succeeds. Thus, *all* previous matches must be undone when a match fails. This is done by the clear_abits_macro.
Return TRUE and set various bits if the pattern len_pat matches the instruction. Otherwise return FALSE and clear all bit fields.
@c

static bool
op0af (ushort opcode_bits, int len_pat)
{
	FTAG("op0af");
	bool result = 0;
	STATB(ftag);

	result =
		the_cip -&gt; c_arg1 == NULL &amp;&amp;
		the_cip -&gt; c_arg2 == NULL &amp;&amp;
		the_cip -&gt; c_arg3 == NULL &amp;&amp;
		match_len(the_cip -&gt; c_length, len_pat);

	if (result) {
		set_cbits_macro(the_cip, opcode_bits);
	}
	else {
		clear_cbits_macro(the_cip);
	}

	TRACEPX(ftag,
		eret(); ebool(result);
		if (result) {
			es(", opcode bits: ");	epadhex(opcode_bits, 4);
			es(", all bits: ");		epadhex(the_cip -&gt; c_bits, 4); ecnl();
		}
	);
	return result;
}
</t>
<t tx="ekr.20080529093004.35">@ Return TRUE and set various bits if the pattern (len_pat,f_pat) matches the instruction. Otherwise return FALSE and clear all bit fields.
@c

static bool
op1af (ushort opcode_bits, int len_pat, int f_pat)
{
	FTAG("op1af");
	bool result = 0;
	STATB(ftag);
	
	/*
		IMPORTANT WARNING:
		The present code assumes that the *entire* instruction succeeds if
		the xdata_bxx pattern succeeds.
		That is, no provision exists for removing a bxx_node if a partial match fails.
		
		This assumption is valid at present because the xdata_bxx pattern
		is always matched last in the op1af and op2af routines.
		In other words, the order of operands to the &amp;&amp; operators below is significant.
	*/

	result =
		the_cip -&gt; c_arg2 == NULL &amp;&amp;
		the_cip -&gt; c_arg3 == NULL &amp;&amp;
		match_len(the_cip -&gt; c_length, len_pat) &amp;&amp;
		match(the_cip -&gt; c_arg1, f_pat);

	if (result) {
		set_cbits_macro(the_cip, opcode_bits);
	}
	else {
		clear_cbits_macro(the_cip);
		clear_abits_macro(the_cip -&gt; c_arg1);
	}

	TRACEPX(ftag,
		eret(); ebool(result);
		if (result) {
			es(", opcode bits: ");	epadhex(opcode_bits, 4);
			es(", all bits: ");		epadhex(the_cip -&gt; c_bits, 4); ecnl();
		}
	);
	return result;
}
</t>
<t tx="ekr.20080529093004.36">@ Return TRUE and set various bits if a the pattern (len_pat,f1_pat,f2_pat) matches the instruction. Otherwise return FALSE and clear all bit fields.
@c

static bool
op2af (ushort opcode_bits, int len_pat, int f1_pat, int f2_pat)
{
	FTAG("op2af");
	bool result = FALSE;
	STATB(ftag);
	
	/*
		IMPORTANT WARNING:
		The present code assumes that the *entire* instruction succeeds if
		the xdata_bxx pattern succeeds.
		That is, no provision exists for removing a bxx_node if a partial match fails.
		
		This assumption is valid at present because the xdata_bxx pattern
		is always matched last in the op1af and op2af routines,
		In other words, the order of operands to the &amp;&amp; operators below is significant.
	*/

	result =
		the_cip -&gt; c_arg3 == NULL &amp;&amp;
		match_len(the_cip -&gt; c_length, len_pat) &amp;&amp;
		match(the_cip -&gt; c_arg1, f1_pat) &amp;&amp;
		match(the_cip -&gt; c_arg2, f2_pat);

	if (result) {
		set_cbits_macro(the_cip, opcode_bits);
	}
	else {
		clear_cbits_macro(the_cip);
		clear_abits_macro(the_cip -&gt; c_arg1);
		clear_abits_macro(the_cip -&gt; c_arg2);
	}

	TRACEPX(ftag,
		eret(); ebool(result);
		if (result) {
			es(", opcode bits: ");	epadhex(opcode_bits, 4);
			es(", all bits: ");		epadhex(the_cip -&gt; c_bits, 4); ecnl();
		}
	);
	return result;
}
</t>
<t tx="ekr.20080529093004.37">@ Return TRUE and set various bits if the pattern (len_pat, f1_pat, f2_pat) matches the instruction. Otherwise return FALSE and clear all bit fields.
@c

static bool
op2afx (ushort opcode_bits, ushort xbits, int len_pat, int f1_pat, int f2_pat)
{
	FTAG("op2afx");
	bool result = FALSE;
	STATB(ftag);

	result =
		the_cip -&gt; c_arg3 == NULL &amp;&amp;
		match_len(the_cip -&gt; c_length, len_pat) &amp;&amp;
		match(the_cip -&gt; c_arg1, f1_pat) &amp;&amp;
		match(the_cip -&gt; c_arg2, f2_pat);

	if (result) {
		set_cbits_macro(the_cip, opcode_bits);
	}
	else {
		clear_cbits_macro(the_cip);
		clear_abits_macro(the_cip -&gt; c_arg1);
		clear_abits_macro(the_cip -&gt; c_arg2);
	}

	TRACEPX(ftag,
		eret(); ebool(result);
		if (result) {
			es(", opcode bits: ");	epadhex(opcode_bits, 4);
			es(", all bits: ");		epadhex(the_cip -&gt; c_bits, 4); ecnl();
		}
	);
	return result;
}
</t>
<t tx="ekr.20080529093004.38">@ Return TRUE and set various bits if a the pattern (len_pat,f1_pat,f2_pat,f3) matches the instruction. Otherwise return FALSE and clear all bit fields.
@c

static bool
op3af (ushort opcode_bits, int len_pat, int f1_pat, int f2_pat, int f3)
{
	FTAG("op3af");
	bool result = FALSE;
	STATB(ftag);

	result =
		match_len(the_cip -&gt; c_length, len_pat) &amp;&amp;
		match(the_cip -&gt; c_arg1, f1_pat) &amp;&amp;
		match(the_cip -&gt; c_arg2, f2_pat) &amp;&amp;
		match(the_cip -&gt; c_arg3, f3);

	if (result) {
		set_cbits_macro(the_cip, opcode_bits);
	}
	else {
		clear_cbits_macro(the_cip);
		clear_abits_macro(the_cip -&gt; c_arg1);
		clear_abits_macro(the_cip -&gt; c_arg2);
		clear_abits_macro(the_cip -&gt; c_arg3);
	}

	TRACEPX(ftag,
		eret(); ebool(result);
		if (result) {
			es(", opcode bits: ");	epadhex(opcode_bits, 4);
			es(", all bits: ");		epadhex(the_cip -&gt; c_bits, 4); ecnl();
		}
	);
	return result;
}
</t>
<t tx="ekr.20080529093004.39">@ Convert the register mode to the normal, i.e., unreversed, REGLIST address mode.
@c

static void
reg_to_reglist(anode * ap)
{
	FTAG("reg_to_reglist");
	int regnum = 0;
	STATB(ftag);
	ASSERT(ap);

	regnum = ((ap -&gt; n_type == AREG_EA) ?
		(8 + areg_num(ap -&gt; a_reg)) : dreg_num(ap -&gt; a_reg));
	ap -&gt; n_type = REGLIST_EA;
	ap -&gt; a_reg = 0;
	ap -&gt; xsize = 1;
	ap -&gt; xwords |= (1 &lt;&lt; regnum);
	(ap -&gt; xwords) &amp;= 0xffff;
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.40">/*
	AS: internal disassembler.

	This is useful as a check on the assembler bit patterns.

	source: ASdisasm.c
	started: September 28, 1993.
	version:
		November 28, 1993.
			Include ASdisasm.h instead of ASasm.h.
*/

&lt;&lt; ASdisasm #includes &gt;&gt;
&lt;&lt; ASdisasm declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.41">#include "AS.h"

#include "ASdisasm.h"
#include "AStokens.h"
</t>
<t tx="ekr.20080529093004.42">/*
	Define various fields of an instruction word.
*/

	/* These fields have "official" names. */

#define cc			((opword &amp; 0x0f00) &gt;&gt;  8)	/* Bits  8 - 11 */
#define eamode		((opword &amp; 0x0034) &gt;&gt;  3)   /* Bits  3 -  5 */
#define eafield		 (opword &amp; 0x007f)			/* Bits  0 -  7 */
#define eareg		 (opword &amp; 0x0007)			/* Bits  0 -  3 */
#define op			((opword &amp; 0xf000) &gt;&gt; 12)	/* Bits 12 - 15 */
#define opmode		((opword &amp; 0x01c0) &gt;&gt;  6)	/* Bits  6 -  8 */

	/* These fields have no "official" names. */

#define bit3		((opword &amp; 0x0008) &gt;&gt;  3)	/* Bit   3		*/
#define bits34		((opword &amp; 0x0018) &gt;&gt;  3)	/* Bits  3 -  4	*/
#define bits345		((opword &amp; 0x0038) &gt;&gt;  3)	/* Bits  3 -  5 */
#define bit5		((opword &amp; 0x0020) &gt;&gt;  5)	/* Bit   5		*/
#define bits67		((opword &amp; 0x00c0) &gt;&gt;  6)	/* Bits  6 -  7 */
#define bit8		((opword &amp; 0x0010) &gt;&gt;  8)	/* Bit   8		*/
#define bits8910	((opword &amp; 0x0700) &gt;&gt;  8)	/* Bits  8 - 10 */
#define bits891011	((opword &amp; 0x0f00) &gt;&gt;  8)	/* Bits  8 - 11 */
#define bits910		((opword &amp; 0x0600) &gt;&gt;  9)	/* Bits  9 - 10 */
#define bits91011	((opword &amp; 0x0e00) &gt;&gt;  9)	/* Bits  9 - 11 */
#define bit11		((opword &amp; 0x0800) &gt;&gt; 11)	/* Bit  11		*/

#define xopword (*((short *)(ip+1)))

#define xbit11		((xopword &amp; 0x0800) &gt;&gt; 11)	/* Bit 11 of extension word */

/*
	Define alternates for case that indicate context
*/
#define main_case case
#define size_case case

/*
	Define sizes: these values must correspond to the default size encoding.
*/
#define B 0
#define W 1
#define L 2
#define NO_LEN 3

/*
	Define encoding for fields
*/
enum {
	NO_ARG,
	/*
		disp: bits 0-8 of the opword:

		0x00: 16 bit displacement in extension word
		0xff: 32 bit displacement in extension word
		else:  8 bit displacement
	*/
	disp,		/* 8,16, or 32-bit displacement depending on bits 0-8 of opword */
	data,		/* Data in low 8 bits of opword */
	data2,		/* Data field in bits 9-11 of opword. */
	size2,		/* Size in bits 9 and 10 (instead of bits 6 and 7) */
	vector,		/* Vector number in low 3 bits of opword. */

	/*
		Effective address in bits 0-5 of opword.
		This has several variants, depending on which modes are valid.
		The code must arrange matters so that all invalid modes
		that are used in special-case opcodes are handled *before* the xxx_ea modes.
	*/
	ea,				/* General effective address.  All modes valid. */
	alt_ea,			/* Alterable:		  not mode 7      (modes 7:0, 7:1 are valid) */
	control_ea,		/* Control:			  not 0,1,3,4 or 7:4 */
	control_alt_ea,	/* Control alterable: not 0,1,3,4,7   (modes 7:0, 7:1 are valid) */
	dn_ctl_alt_ea,	/* Dn and control alterable */
	pd_ctl_alt_ea,	/* Predecrement  plus control alterable. */
	pi_ctl_alt_ea,	/* Postincrement plus control alterable. */
	data_ea,		/* Data				  not mode 1 */
	data_ximm_ea,	/* Data except immediate: not modes 1, 7:4 */
	data_alt_ea,	/* Data alterable:    not modes 1, 7, (modes 7:0, 7:1 are valid) */
	mem_alt_ea,		/* Memory alterable:  not modes 0,1,7 (modes 7:0, 7:1 are valid) */


	ea2,		/* Effective address in bits 6-11 of opword (reg and mode reversed!) */

	An,			/* Address register in bits 0-3 */
	An2,		/* Address register in bits 9-11 (reg field of ea2) */

	Anpredec,	/* Address register (implied predecrement mode) in bits 0-3 */
	Anpredec2,	/* Address register (implied predecrement mode) in data2 field. */
	Anpostinc,	/* Address register (implied postincrement mode) in bits 0-3 */
	Anpostinc2,	/* Address register (implied postincrement mode) in data2 field. */
	An_xdisp16,	/* Address register (implied (xdisp16,An) mode) in bits 0-3 */

	Dn,			/* Data register in bits 0-3 */
	Dn2,		/* Data register in bits 9-11 (reg field of ea2) */

	xdata_size,	/* Data in extention word(s) whose size depends on size field */
	xdata_8,	/* Data in low  8 bits of extension word (high bits are 0) */
	xdata_16,	/* Data in all 16 bits of extension word */
	xdata_32,	/* Data in two exention words. */

	xbit,		/* Dit number in low 8 bits of extension word (high bits are 0) */
	xsize,		/* Bit 10 of extension word. */
	xtype,		/* Bit 11 of extension word. */

	xoffset,	/* Offset in bits 6-10 of extension word, flag in bit 11 of extension */
	xwidth,		/* Width  in bits 0-4  of extension word, flag in bit  5 of extension */

	xDhigh,		/* Data register in bits 12-14 of extension word. */
	xDlow,		/* Data register in low 3 bits of extension word. */
	xDn,		/* Data register in bits 12-14 of extension word. */

	xDq,		/* Data register in bits 12-14 of extension word. */
	xDr,		/* Data register in low 3 bits of extension word. */

	xcreg,		/* Control register in low 12 bits of extension word. */
	xgreg,		/* General register in high 4 bits of extension word. */
	xreglist,	/* Register list mask in extension word. */

	cr_implied,		/* Condition code register implicit in opcode */
	sr_implied,		/* Status register implied by opcode */
	usp_implied		/* User stack pointer implied by opcode */
};

/*
	Define abbreviations for control structure.
*/
#define bad_switch(tag) fatal(es(ftag); es("Bad switch: "); es(tag));
#define bad goto bad_opcode

#define op0(op) 			 	{result=op0df(ip,op,NO_LEN);			goto done;}
#define op1(op,f1)			 	{result=op1df(ip,op,NO_LEN,f1); 		goto done;}
#define op2(op,f1,f2)		 	{result=op2df(ip,op,NO_LEN,f1,f2);		goto done;}
#define op3(op,f1,f2,f3)		{result=op3df(ip,op,NO_LEN,f1,f2,f3);	goto done;}
#define op4(op,f1,f2,f3,f4)		{result=op4df(ip,op,NO_LEN,f1,f2,f3,f4);goto done;}
#define op0len(op,len)		 	{result=op0df(ip,op,len); 				goto done;}
#define op1len(op,len,f1)	 	{result=op1df(ip,op,len,f1); 			goto done;}
#define op2len(op,len,f1,f2) 	{result=op2df(ip,op,len,f1,f2); 		goto done;}
#define op3len(op,len,f1,f2,f3)	{result=op3df(ip,op,len,f1,f2,f3);		goto done;}
#define opcc0(op,cc)			{result=opcc0df(ip,op,cc,NO_LEN);		goto done;}
#define opcc1(op,cc,f1)	 		{result=opcc1df(ip,op,cc,NO_LEN,f1);	goto done;}
#define opcc2(op,cc,f1,f2) 		{result=opcc2df(ip,op,cc,NO_LEN,f2,f2);	goto done;}
#define opcc1len(op,cc,len,f1)	{result=opcc1df(ip,op,cc,len,f1); 		goto done;}

/* 	Temporaries. */
#define cas2(length)	{goto done;}
#define cas 			{goto done;}

/* Prototypes on internal routines. */

static void * op0df		(char *ip, int the_op, int len);
static void * op1df		(char *ip, int the_op, int len, int f);
static void * op2df		(char *ip, int the_op, int len, int f1, int f2);
static void * op3df		(char *ip, int the_op, int len, int f1, int f2, int f3);
static void * op4df		(char *ip, int the_op, int len, int f1, int f2, int f3, int f4);
static void * opcc0df	(char *ip, int the_op, int the_cc, int len);
static void * opcc1df	(char *ip, int the_op, int the_cc, int len, int f1);
static void * opcc2df	(char *ip, int the_op, int the_cc, int len, int f1, int f2);
</t>
<t tx="ekr.20080529093004.43">@ Disassemble a single instruction located at ip.  Return a code node corresponding to the instruction.
@c

cnode *
disassemble(char * ip)
{
	FTAG("disassemble");
	register word opword = *((short *)ip);
	register int size = bits67;
	register void * result;
	STATB(ftag);
	ASSERT(ip);

	/*
		Select the category of instruction based on the high four bits.
		See page 3-201 of the Motorola 68030 manual.
	*/
	switch(op) {

	main_case 0:	/* Bit manipulation, MOVEP/ Immediate */

		/* 0x3c (mode 7, register 4) is not usually a valid effective address. */
		if (eafield == 0x3c) {
			switch (opword) {
			case 0x003c: op2(X_ORI, xdata_8, cr_implied)
			case 0x007c: op2(X_ORI, xdata_16,sr_implied)
			case 0x023c: op2(X_ANDI,xdata_8, cr_implied)
			case 0x027c: op2(X_ANDI,xdata_16,sr_implied)
			case 0x063c: op2(X_EORI,xdata_8, cr_implied)
			case 0x067c: op2(X_EORI,xdata_16,sr_implied)
			case 0x0cfc: cas2(W)
			case 0x0dfc: cas2(L)
			default:	 bad;
			}
		}

		if (eamode == 1) {
			/*
				Mode 1 is usually invalid for type 0 instructions
				since these instructions use D-regs, not A-regs.
			*/
			switch(opmode) {
			case 4:	op2len(X_MOVEP,W,An_xdisp16,Dn2)
			case 5:	op2len(X_MOVEP,L,An_xdisp16,Dn2)
			case 6:	op2len(X_MOVEP,W,Dn2,An_xdisp16)
			case 7:	op2len(X_MOVEP,L,Dn2,An_xdisp16)
			default: bad;
			}
		}

		if (bit8) {
			/*
				Bit 8 is 0 for all instructions with op == 1 except for
				MOVEP (tested above) and dynamic bit instructions.
				Cases 0-3 are impossible since bit 8 is the high bit of the opmode field.
			*/
			switch (opmode) {
			case 4:	op2(X_BTST,Dn2,data_alt_ea)	/* Dynamic...*/
			case 5: op2(X_BCHG,Dn2,data_alt_ea)
			case 6:	op2(X_BCLR,Dn2,data_alt_ea)
			case 7:	op2(X_BSET,Dn2,data_alt_ea)
			}
		}

		/*
			At this point bits 9, 10 and 11 mostly determine the operation.
			However, Bits 6 and 7 are used as flags in various circumstances.
		*/
		if (bits67 == 3) {

			if (bit11 == 1 &amp;&amp; bits910 != 0) cas
			else if (bit11 == 0) {
				if (xbit11) op2len(X30_CHK2,size2,control_ea,xgreg)
				else 		op2len(X30_CMP2,size2,control_ea,xgreg)
			}
			else {
				/* This is a static bit operation handled below. */
			}
		}

		if (size == 3 &amp;&amp; bits91011 != 4) bad;

		switch(bits91011) {
		case 0:	op2len(X_ORI, size,xdata_size,data_alt_ea)
		case 1: op2len(X_ANDI,size,xdata_size,data_alt_ea)
		case 2:	op2len(X_SUBI,size,xdata_size,data_alt_ea)
		case 3: op2len(X_ADDI,size,xdata_size,data_alt_ea)
		case 5: op2len(X_EORI,size,xdata_size,data_alt_ea)
		case 6: op2len(X_CMPI,size,xdata_size,data_ximm_ea)
		case 7:	if (xbit11) op2len(X_MOVES,size,xgreg,mem_alt_ea)
				else		op2len(X_MOVES,size,mem_alt_ea,xgreg)
		case 4:	/* Bit static */
			switch(size) {
			case 0:	op2(X_BTST,xbit,data_alt_ea)
			case 1:	op2(X_BCHG,xbit,data_alt_ea)
			case 2:	op2(X_BCLR,xbit,data_alt_ea)
			case 3:	op2(X_BSET,xbit,data_alt_ea)
			}
		}
		bad_switch("main 0");

	main_case 1:	/* Move byte */

		op2len(X_MOVE,B,ea2,data_alt_ea)

	main_case 2:	/* Move long */

		if (opmode == 1)	op2len(X_MOVEA,L,ea,An2)
		else				op2len(X_MOVE,L,ea2,data_alt_ea)

	main_case 3:	/* Move word */

		if (opmode == 1)	op2len(X_MOVEA,W,ea,An2)
		else				op2len(X_MOVE,W,ea2,data_alt_ea)

	main_case 4:	/* Miscellaneous */

		if (bit8) {
			switch (size) {
			case 0:	op2len(X_CHK,L,data_ea,Dn2)
			case 1: bad;
			case 2: op2len(X_CHK,W,data_ea,Dn2)
			case 3: if (eamode == 0) op1len(X30_EXTB,L,Dn)
					else op2(X_LEA,control_ea,An2)
			}
		}

		/* Bit 8 is zero from here on. */
		switch (bits91011) {
		case 0: if (size == 3) op2(X_MOVE,sr_implied,data_alt_ea)
				else op1len(X_NEGX,size,data_alt_ea)
		case 1: if (size == 3) op2(X_MOVE,cr_implied,data_alt_ea)
				else op1len(X_CLR,size,data_alt_ea)
		case 2: if (size == 3) op2(X_MOVE,data_ea,cr_implied)
				else op1len(X_NEG,size,data_alt_ea)
		case 3: if (size == 3) op2(X_MOVE,data_ea,sr_implied)
				else op1len(X_NOT,size,data_alt_ea)
		case 4:
			switch(size) {
			case 0: if (eamode == 0) op2len(X_LINK,L,An,xdata_size)
					else op1(X_NBCD,data_alt_ea)
			case 1:	if (eamode == 0) op1(X_SWAP,Dn)
					else if (eamode == 1) op1(X_BKPT,vector)
					else op1(X_PEA,control_ea)
			case 2: if (eamode == 0) op1len(X_EXT,W,Dn)
					else op2len(X_MOVEM,W,xreglist,pd_ctl_alt_ea)
			case 3: if (eamode == 0) op1len(X_EXT,L,Dn)
					else op2len(X_MOVEM,L,xreglist,pd_ctl_alt_ea)
			}
		case 5:
			switch(size) {
			case 0: case1: case 2: op1len(X_TST,size,data_ea)
			case 3: if (eafield == 0x3c) op0(X_ILLEGAL) else op1(X_TAS,data_alt_ea)
			}
		case 6:
			switch (size) {
			case 0: /* xDq may *not* be the same register as xDr */
				if (xsize)	op3len(xtype ? X30_MULSL : X30_MULUL, L, ea, xDhigh, xDlow)
				else		op2len(xtype ? X30_MULSL : X30_MULUL, L, ea, xDlow)
			case 1: /* xDq *may* be the same register as xDr */
				if (xsize)	op3len(xtype ? X30_DIVSL : X30_DIVUL, L, data_ea, xDq, xDr)
				else		op3len(xtype ? X30_DIVSL : X30_DIVUL, L, data_ea, xDq, xDr)
			case 2:	op2len(X_MOVEM,W,pi_ctl_alt_ea,xreglist)
			case 3: op2len(X_MOVEM,L,pi_ctl_alt_ea,xreglist)
			}
		case 7:
			switch (size) {
			size_case 0: bad;
			size_case 1:
				switch (eamode) {
				case 0:	op1(X_TRAP,vector)	/* vector field is low bit of eamode field */
				case 1:	op1(X_TRAP,vector)
				case 2: op2len(X_LINK,W,An,xdata_size)
				case 3:	op1(X_UNLK,An)
				case 4: op2(X_MOVE,An,usp_implied)
				case 5: op2(X_MOVE,usp_implied,An)
				case 6: 
					switch (eareg) {
					case 0:	op0(X_RESET)
					case 1: op0(X_NOP)
					case 2: op1(X_STOP,xdata_16)
					case 3: op0(X_RTE)
					case 4: op1(X_RTD,xdata_16)
					case 5: op0(X_RTS)
					case 6: op0(X_TRAPV)
					case 7:	op0(X_RTR)
					}
				case 7:
					switch (eareg) {
					case 2:	op2(X30_MOVEC,xcreg,xgreg)
					case 3:	op2(X30_MOVEC,xgreg,xcreg)
					default: bad;
					}
				}
			size_case 2: op1(X_JSR,control_ea)
			size_case 3: op1(X_JMP,control_ea)
			}
		}
		bad_switch("Main 4");

	main_case 5:	/* ADDQ, SUBQ, Scc, DBcc, TRAPcc */

		if (size == 3) {
			switch(eamode) {
			case 1: opcc2(X_DBcc,cc,Rn,xdata_16)	/* Label */
			case 7:
				switch(eareg) {
					case 0: opcc1(X_Scc,cc,data_alt_ea)
					case 1: opcc1(X_Scc,cc,data_alt_ea)
					case 2: opcc1len(X30_TRAPcc,cc,W,xdata_16)
					case 3: opcc1len(X30_TRAPcc,cc,L,xdata_32)
					case 4: opcc0(X30_TRAPcc,cc)
					default: bad;
				}
			default: opcc1(X_Scc,cc,data_alt_ea)
			}
		}
		else if (bit8)	op2len(X_SUBQ,size,data2,alt_ea)
		else			op2len(X_ADDQ,size,data2,alt_ea)

	main_case 6:	/* Bcc, BSR, BRA */

		switch(cc) {
		case 0:  op1(X_BRA,disp)	/* Label */
		case 1:  op1(X_BSR,disp)	/* Label */
		default: opcc1(X_BCC,cc,disp)
		}

	main_case 7:	/* MOVEQ */

		if (bit8) bad; else op2(X_MOVEQ,data,Dn2)

	main_case 8:	/* OR, DIV, SBCD, PACK, UNPK */

		/* One *really must* consider opmode before eamode. */
		switch(opmode) {
		case 0: case 1: case 2: op2len(X_OR,size,data_ea,Dn2)
		case 3: op2(X_DIVU,data_ea,Dn2)
		case 4:
			switch(eamode) {
			case 0:  op2(X_SBCD,Dn,Dn2)
			case 1:  op2(X_SBCD,Anpredec,Anpredec2)
			default: op2len(X_OR,B,Dn2,mem_alt_ea)	/* 0/1 not allowed as dest ea */
			}
		case 5:
			switch(eamode) {
			case 0:  op2(X30_PACK,Dn,Dn2)
			case 1:  op2(X30_PACK,Anpredec,Anpredec2)
			default: op2len(X_OR,W,Dn2,mem_alt_ea)	/* 0/1 not allowed as dest ea */
			}
		case 6:
			switch(eamode) {
			case 0:  op3(X30_UNPK,Dn,Dn2,xdata_16)
			case 1:  op3(X30_UNPK,Anpredec,Anpredec2,xdata_16)
			default: op2len(X_OR,W,Dn2,mem_alt_ea)	/* 0/1 not allowed as dest ea */
			}
		case 7: op2(X_DIVS,data_ea,Dn2)
		}

	main_case  9:	/* SUB, SUBA, SUBX */

		switch(opmode) {
		case 0: case 1: case 2:	op2len(X_SUB,size,ea,Dn2)
		case 4: case 5: case 6:
			switch(eamode) {
			case 0:  op2len(X_SUBX,size,Dn,Dn2)
			case 1:  op2len(X_SUBX,size,Anpredec,Anpredec2)
			default: op2len(X_SUB, size,Dn2,mem_alt_ea)	/* 0/1 not allowed as dest ea */
			}
		case 3:	op2len(X_SUBA,W,ea,An2)
		case 7:	op2len(X_SUBA,L,ea,An2)
		}

	main_case 10:	/* A-trap (reserved) */

		bad;

	main_case 11:	/* CMP, CMPA, EOR */

		switch(opmode) {
		case 0: case 1: case 2: op2len(X_CMP,size,ea,Dn2)
		case 4: case 5: case 6:
			if (eamode == 1)	op2len(X_CMPM,size,Anpostinc,Anpostinc2)
			else				op2len(X_EOR,size,Dn2,data_alt_ea)
		case 3:	op2len(X_CMPA,W,ea,An2)
		case 7:	op2len(X_CMPA,L,ea,An2)
		}

	main_case 12:	/* AND, MUL, ABCD, EXG */

		switch(opmode) {
		case 0: case 1: case 2: op2len(X_AND,size,data_ea,Dn2)
		case 4:
			switch(eamode) {
			case 0:  op2(X_ABCD,Dn,Dn2)
			case 1:  op2(X_ABCD,Anpredec,Anpredec2)
			default: op2len(X_AND,B,Dn2,mem_alt_ea)	/* 0/1 not allowed as dest ea */
			}
		case 5:
			switch(eamode) {
			case 0:  op2(X_EXG,Dn2,Dn)
			case 1:  op2(X_EXG,An2,An)
			default: op2len(X_AND,W,Dn2,mem_alt_ea)	/* 0/1 not allowed as dest ea */
			}
		case 6:
			switch(eamode) {
			case 0:  bad;
			case 1:  op2(X_EXG,Dn2,An)
			default: op2len(X_AND,L,Dn2,mem_alt_ea)	/* 0/1 not allowed as dest ea */
			}
		case 3: op2(X_MULU,data_ea,Dn2)
		case 7: op2(X_MULS,data_ea,Dn2)
		}

	main_case 13:	/* ADD, ADDA, ADDX */

		switch(opmode) {
		case 0: case 1: case 2: op2len(X_ADD,size,ea,Dn)
		case 4: case 5: case 6:
			switch(eamode) {
			case 0:  op2len(X_ADDX,size,Dn,Dn2)
			case 1:  op2len(X_ADDX,size,Anpredec,Anpredec2)
			default: op2len(X_ADD,size,Dn2,mem_alt_ea)	/* 0/1 not allowed as dest ea */
			}
		case 3: op2len(X_ADDA,W,ea,An2)
		case 7: op2len(X_ADDA,L,ea,An2)
		}

	main_case 14:	/* Shift, Rotate, Bit Field */

		if (size == 3) {
			switch(bits891011) {
			case  0: op1(X_ASR, mem_alt_ea)			/* Shift/Rotate Memory */
			case  1: op1(X_ASL, mem_alt_ea)
			case  2: op1(X_LSR, mem_alt_ea)
			case  3: op1(X_LSL, mem_alt_ea)
			case  4: op1(X_ROXR,mem_alt_ea)
			case  5: op1(X_ROXL,mem_alt_ea)
			case  6: op1(X_ROR, mem_alt_ea)
			case  7: op1(X_ROL, mem_alt_ea)
			case  8: op3(X30_BFTST, dn_ctl_alt_ea,xoffset,xwidth)		/* Bit field */
			case  9: op4(X30_BFEXTU,dn_ctl_alt_ea,xoffset,xwidth,xDn)
			case 10: op3(X30_BFCHG, dn_ctl_alt_ea,xoffset,xwidth)
			case 11: op4(X30_BFEXTS,dn_ctl_alt_ea,xoffset,xwidth,xDn)
			case 12: op3(X30_BFCLR, dn_ctl_alt_ea,xoffset,xwidth)
			case 13: op4(X30_BFFF0, dn_ctl_alt_ea,xoffset,xwidth,xDn)
			case 14: op3(X30_BFSET, dn_ctl_alt_ea,xoffset,xwidth)
			case 15: op4(X30_BFINS, dn_ctl_alt_ea,xoffset,xwidth,xDn)
			}
		}
		else {	/* Shift/Rotate Register */
			switch(bits345) { 
			case 0: op2len(bit8 ? X_ASL  : X_ASR,  size, data2, eareg)
			case 1: op2len(bit8 ? X_LSL  : X_LSR,  size, data2, eareg)
			case 2: op2len(bit8 ? X_ROXL : X_ROXR, size, data2, eareg)
			case 3: op2len(bit8 ? X_ROL  : X_ROR,  size, data2, eareg)
			case 4: op2len(bit8 ? X_ASL  : X_ASR,  size, Dn2, eareg)
			case 5: op2len(bit8 ? X_LSL  : X_LSR,  size, Dn2, eareg)
			case 6: op2len(bit8 ? X_ROXL : X_ROXR, size, Dn2, eareg)
			case 7: op2len(bit8 ? X_ROL  : X_ROR,  size, Dn2, eareg)
			}
		}

	main_case 15:	/* Coprocessor Interface */

		// not ready yet

	default: break;

	}
	fatal(es(ftag); es("Bad outer switch.  case: "); eint(op));

bad_opcode:
	error(es("Bad opcode"));

done:
	STATX(ftag);
	return NULL;
}
</t>
<t tx="ekr.20080529093004.44">static void *
op0df (char *ip, int the_op, int len)
{}
</t>
<t tx="ekr.20080529093004.45">static void *
op1df (char *ip, int the_op, int len, int f)
{}
</t>
<t tx="ekr.20080529093004.46">static void *
op2df (char *ip, int the_op, int len, int f1, int f2)
{}
</t>
<t tx="ekr.20080529093004.47">static void *
op3df (char *ip, int the_op, int len, int f1, int f2, int f3)
{}
</t>
<t tx="ekr.20080529093004.48">static void * op4df (char *ip, int the_op, int len, int f1, int f2, int f3, int f4)
{}
</t>
<t tx="ekr.20080529093004.49">static void * opcc0df (char *ip, int the_op, int the_cc, int len)
{}
</t>
<t tx="ekr.20080529093004.50">static void * opcc1df (char *ip, int the_op, int the_cc, int len, int f1)
{}
</t>
<t tx="ekr.20080529093004.51">static void * opcc2df (char *ip, int the_op, int the_cc, int len, int f1, int f2)
{}
</t>
<t tx="ekr.20080529093004.52">/*
	AS: Expression parsing and printing routines.

	source:  ASexp.c
	started: December 28, 1993
	version:
		January 24, 1995.
			Removed the _user_lib_cvt_double hack from expr_prim.
			(As far as I know, this hack was never actually used.)
		January 20, 1995.
			Bug fix to eval_string to handle 0x80000000 properly.
		July 18, 1994.
			Bug fix: Rewrote expr_get_val using sign_kind argument.
		July 13, 1994.
			Bug fix: added field_mask to expr_get_val.
		May 26, 1994.
			Changed par_next followed by tok_skip_ws to tok_par_next_skip_ws.
		May 3, 1994.
			Bug fix to expr_prim: return NULL if a bad floating constant is seen.
		April 22, 1994.
			Bug fix to ea_val.  Use a default of 4 when bytes == 0.
		April 10, 1994.
			Added support for float constants and expressions.
		April 4, 1994.
			Changed expr_apply so it checks the operand stack.
		March 31, 1994.
			Bug fix: initialize ex_count and op_count.
			Bug fix: Make sure ex_count is large enough before calling expr_apply.
		March 4, 1994.
			Bug fix: rewrote expr_get_val.
		February 12, 1994.
			Handle missing expressions correctly in s_end.
		February 10, 1994.
			Added support for summary_enode's to eenode.
			Wrote expr_check.
		February 9, 1994.
			Bug fix to op_push_macro and op_pop_macro.
			Installed constant folding logic in expr_apply.
			Added support for ~ operator in s_unop.
			Add support for $ constants to eval_string.
		January 25, 1994.
			Allow '(' to end an expression following an operator.
		January 17, 1994.
			Rewrote all routines.
*/
&lt;&lt; ASexp #includes &gt;&gt;
&lt;&lt; ASexp declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.53">#include "AS.h"

#include "ASanodes.h"
#include "AScnodes.h"
#include "AScpp.h"		/* for char_val. */
#include "ASexp.h"
#include "ASfold.h"
#include "ASmem.h"
#include "ASofile.h"
#include "ASsem.h"
#include "AStokens.h"

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.54">/*
	Inline functions.
*/
#define ex_pop_macro(ep) \
	ASSERT(ex_count &gt; 0);\
	ep = ex_stack[--ex_count];

#define ex_push_macro(ep) \
	if (ex_count &gt;= MAX_EX_STACK) {\
		expr_too_complex();\
	}\
	else {\
		ex_stack[ex_count++] = ep;\
	}

#define op_pop_macro(op) \
	ASSERT(op_count &gt; 0);\
	op = op_stack[--op_count];\
	op_top = ((op_count &gt;= 0) ? op_stack[op_count] : BAD_TOK);

#define op_push_macro(op) \
	if (op_count &gt;= MAX_OP_STACK) {\
		expr_too_complex();\
	}\
	else {\
		op_stack[op_count++] = op_top = op;\
	}

/*
	Local variables.
*/
#define MAX_OP_STACK 200
#define MAX_EX_STACK 400

static int		op_stack [MAX_OP_STACK];	/* The operator stack. */
static enode *	ex_stack [MAX_EX_STACK];	/* The expression (operand) stack. */

static int ex_count = 0;		/* The ex stack counter. */
static int op_count = 0;		/* The op stack counter. */
static token op_top = BAD_TOK;	/* The current top of the operator stack. */

/*
	Function prototypes of internal routines.
*/
	/* Synonyms for label_type argument. */
	enum { NO_LABEL, POS_LABEL, NEG_LABEL };

static long		eval_string		(char * s);

static bool		expr_apply	(void);
static enode *	expr_check	(enode * ep);
static bool		expr_check_subtree
	(
		summary_enode *sep, enode *ep, int label_type,
		int * p_num, int * n_num, bool * has_val, ulong * val
	);
static void		expr_dump_op_stack	(void);
static int		expr_prec			(token op);
static enode *	expr_prim			(void);
static void		expr_too_complex	(void);
</t>
<t tx="ekr.20080529093004.55">@ Dump an enode.
@c

void
eenode(enode * ep)
{
	FTAG("eenode");
	STATB(ftag);
	
	if (ep == NULL) {
		es("&lt;NULL enode&gt;");
	}
	else if (is_binop(ep -&gt; n_type)) {
		etoknum(ep -&gt; n_type);
		es("[");
		eenode(ep -&gt; arg1);
		es(",");
		eenode(ep -&gt; arg2);
		es("]");
	}
	else if (is_unop(ep -&gt; n_type)) {
		etoknum(ep -&gt; n_type);
		es("[");
		eenode(ep -&gt; arg1);
		es("]");
	}
	else if (ep -&gt; n_type == INT_TOK) {
		elong(const_enode_ptr(ep) -&gt; val);
	}
	else if (ep -&gt; n_type == CHAR_TOK) {
		es("\'"); es(string_enode_ptr(ep) -&gt; the_string); es("\'");
	}
	else if (ep -&gt; n_type == ID_TOK) {
		ASSERT(var_enode_ptr(ep) -&gt; var_m_dict);
		if (var_enode_ptr(ep) -&gt; var_m_dict -&gt; dict_spell) {
			es(var_enode_ptr(ep) -&gt; var_m_dict -&gt; dict_spell -&gt; spell_name);
		}
		else {
			es("&lt;NULL id name&gt;");
		}
	}
	else if (ep -&gt; n_type == STRING_TOK) {
		if (float_enode_ptr(ep) -&gt; the_float) {
			es("\""); es(float_enode_ptr(ep) -&gt; the_float); es("\"");
		}
		else {
			es("\""); edouble(float_enode_ptr(ep) -&gt; float_val); es("\"");
		}
	}
	else if (ep -&gt; n_type == O_SUMMARY) {

		summary_enode * sep = summary_enode_ptr(ep);
		m_dict_list_enode * mdl_p = NULL;
		bool print_plus_flag = FALSE;
		
		/* Don't print 0 unless that's all there is. */
		if (
			sep -&gt; val ||
			(sep -&gt; pos_label_list == NULL &amp;&amp; sep -&gt; neg_label_list == NULL)
		) {
			elong(sep -&gt; val);
			print_plus_flag = TRUE;
		}
		for (mdl_p = sep -&gt; pos_label_list; mdl_p; mdl_p = mdl_p -&gt; next) {
			ASSERT(mdl_p -&gt; the_m_dict &amp;&amp; mdl_p -&gt; the_m_dict -&gt; dict_spell);
			if (print_plus_flag) {
				es("+");
			}
			print_plus_flag = TRUE;
			es(mdl_p -&gt; the_m_dict -&gt; dict_spell -&gt; spell_name);
		}
		for (mdl_p = sep -&gt; neg_label_list; mdl_p; mdl_p = mdl_p -&gt; next) {
			ASSERT(mdl_p -&gt; the_m_dict &amp;&amp; mdl_p -&gt; the_m_dict -&gt; dict_spell);
			es("-"); es(mdl_p -&gt; the_m_dict -&gt; dict_spell -&gt; spell_name);
		}
	}
	else {
		es("unknown type: "); etoknum(ep -&gt; n_type);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.56">@ Return the value of a string representing a signed int or signed long
@c

static long
eval_string (char * s)
{
	FTAG("eval_string");
	char * end = NULL;
	long val = 0L;
	STATB(ftag);
	ASSERT(s);
	
	if (*s == '$') {
		/*
			It must be a hex constant.
			Bug fix: 7/18/94 parse an *unsigned* constant to retain all bits.
		*/
		val = (long) strtoul(s+1, &amp;end, 16);
	}
	else {
		/*
			Determine the base from the form of the constant.
			Bug fix: 1/20/95 parse an *unsigned* constant to retain all bits.
		*/
		val = (long) strtoul(s, &amp;end, 0);
	}

	/* Allow constants of the form xxxL, xxxU, xxxUL, xxxLU */
	if (*end != '\0' &amp;&amp; *end != 'u' &amp;&amp; *end != 'U' &amp;&amp; *end != 'l' &amp;&amp; *end != 'L') {

		error(es("bad signed constant: "); es(s); es(", 0 assumed"));
		val = 0;
	}

	TRACEPX(ftag, epads(s,5); eblank(); eret(); elong(val); enl());
	return val;
}
</t>
<t tx="ekr.20080529093004.57">@ Apply the operator on the top of the operator stack to one or two operands on the top of the expression stack. Push the result back on the expression stack.  Return TRUE if there are not enough operands on the operand stack to perform the operation.
@c

static bool
expr_apply(void)
{
	FTAG("expr_apply");
	TRACEPB(ftag, etoknum(op_top); enl());

	if (is_binop(op_top)) {
		enode * ep = NULL;
		token op = 0;
		if (ex_count &lt; 2) {
			goto bad_apply;
		}
		op_pop_macro(op);
		new_enode_macro(ep, op);
		ex_pop_macro(ep -&gt; arg2);
		ex_pop_macro(ep -&gt; arg1);
		ep = fold2(ep);
		ex_push_macro(ep);
	}
	else if (is_unop(op_top)) {
		enode * ep = NULL;
		token op = 0;
		if (ex_count &lt; 1) {
			goto bad_apply;
		}
		op_pop_macro(op);
		new_enode_macro(ep, op);
		ex_pop_macro(ep -&gt; arg1);
		ep = fold1(ep);
		ex_push_macro(ep);
	}
	else {
		/* A bad operator should never be pushed in the first place! */
		fatal(es("bad operator"));
	}

	STATX(ftag);
	return FALSE;
	
bad_apply:
	STATX(ftag);
	return TRUE;
}
</t>
<t tx="ekr.20080529093004.58">@ Check an expression tree and return a summary enode summarizing the expression.  An expression is valid if  1) No multiplicative operator (* or /) is applied to an expression containing   a label. 2) p(E) - n(E) is either 0 or 1, where p(E) is the number of positive labels   and n(E) is the number of negative labels in expression E.    A negative label is a label either the operand of the unary '-' operator or the second operand of the binary '-' operator. All other labels are positive labels.
@c

static enode *
expr_check(enode * ep)
{
	FTAG("expr_check");
	summary_enode * result = NULL;
	int p_num = 0;
	int n_num = 0;
	bool has_val = FALSE;
	ulong val = 0;
	bool error_flag = FALSE;
	STATB(ftag);
	ASSERT(ep);
	
	if (ep -&gt; n_type == CHAR_TOK) {
		/* The expression consists of a single *string*. */
		result = summary_enode_ptr(ep);
	}
	else if (ep -&gt; n_type == STRING_TOK) {
		/* The expression consists of a single *floating* number. */
		result = summary_enode_ptr(ep);
	}
	else {
	
		new_enode_macro(result, O_SUMMARY);
		error_flag = expr_check_subtree(result, ep, POS_LABEL,
			&amp;p_num, &amp;n_num, &amp;has_val, &amp;val);
		
		if (error_flag == FALSE &amp;&amp; n_num - p_num &gt; 1) {
			error(es("too many negative labels"));
			error_flag = TRUE;
		}
			
		if (error_flag == FALSE &amp;&amp; has_val) {
			result -&gt; val = val;
		}
	}

	TRACEPX(ftag, eret(); eenode(enode_ptr(result)); ecnl());
	return enode_ptr(result);
}
</t>
<t tx="ekr.20080529093004.59">@ Add the totals for the subtree ep to the summary enode sep. The label_type argument determines whether a label is positive or negative. Return TRUE if an error was found.  Return *in the caller* the following values:  p_num The number of positive labels in the subtree. n_num The number of negative labels in the subtree. has_val TRUE: the subtree contains a constant. val  The evaluated value of all constants in the subtree.
@c

static bool
expr_check_subtree(summary_enode *sep, enode *ep, int label_type,
	int * p_num, int * n_num, bool * has_val, ulong * val)
{
	FTAG("expr_check_subtree");
	ulong result = 0;
	int inner_label_type1 = NO_LABEL;
	int inner_label_type2 = NO_LABEL;
	bool error_flag = FALSE;
	register token op = 0;
	STATB(ftag);
	ASSERT(ep &amp;&amp; sep &amp;&amp; sep -&gt; n_type == O_SUMMARY);
	op = ep -&gt; n_type;
	
	/* Set the defaults return values in the caller. */
	*p_num = 0;
	*n_num = 0;
	*has_val = FALSE;
	*val = 0;
	
	if (op == INT_TOK) {
		*has_val = TRUE;
		*val = const_enode_ptr(ep) -&gt; val;
	}
	else if (op == CHAR_TOK) {
		error(es("can not apply operators to strings"));
		error_flag = TRUE;
	}
	else if (op == STRING_TOK) {
		error(es("can not apply operator floats here"));
		error_flag = TRUE;
	}
	else if (op == ID_TOK) {
	
		/* Create a new m_dict_list_enode node. */
		m_dict_list_enode * mdl_p = NULL;
		new_enode_macro(mdl_p, O_SLIST);
		mdl_p -&gt; the_m_dict = var_enode_ptr(ep) -&gt; var_m_dict;
		ASSERT(mdl_p -&gt; the_m_dict);
		
		/* Add the node to the positive or negative list in the summary node. */
		if (label_type == POS_LABEL) {
			mdl_p -&gt; next = sep -&gt; pos_label_list;
			sep -&gt; pos_label_list = mdl_p;
			(*p_num)++;
		}
		else if (label_type == NEG_LABEL) {
			mdl_p -&gt; next = sep -&gt; neg_label_list;
			sep -&gt; neg_label_list = mdl_p; /* Bug fix: 4/24/94. */
			(*n_num)++;
		}
		else {
			ASSERT(label_type == NO_LABEL);
			ASSERT(is_unop(op) || is_binop(op));
			error(es("can not apply "); etoknum(op); es(" to a label"));
			error_flag = TRUE;
		}
	}
	else if (is_unop(op)) {

		ulong inner_val = 0;
		bool has_inner_val = FALSE;
		int inner_label_type = ((op == UPLUS_TOK) ? POS_LABEL : NO_LABEL);
	
		error_flag = expr_check_subtree(sep, ep -&gt; arg1, inner_label_type,
										p_num, n_num, &amp;has_inner_val, &amp;inner_val);

		if (!error_flag &amp;&amp; has_inner_val) {
			switch(op) {
			case UPLUS_TOK:		*val = +inner_val; break;
			case NOT_TOK:		*val = !inner_val; break;
			case TILDE_TOK:		*val = ~inner_val; break;
			case UMINUS_TOK:	*val = -inner_val; break;
			default: fatal(es("unknown unop"));
			}
			*has_val = TRUE;
		}
	}
	else if (is_binop(op)) {
		
		int		inner_label_type1, inner_label_type2;
		ulong	inner_val1, inner_val2;
		bool	has_inner_val1, has_inner_val2;
		
		ASSERT(is_binop(op) &amp;&amp; ep -&gt; arg1 &amp;&amp; ep -&gt; arg2);
		
		/* Only '+' and '-' may have labels for operands. */
		if (op == MINUS_TOK) {
			inner_label_type1 = POS_LABEL;
			inner_label_type2 = NEG_LABEL;
		}
		else if (op == PLUS_TOK) {
			inner_label_type1 = POS_LABEL;
			inner_label_type2 = POS_LABEL;
		}
		else {
			inner_label_type1 = NO_LABEL;
			inner_label_type2 = NO_LABEL;
		}
		
		/* Recursively evaluate the first subtree. */
		error_flag = expr_check_subtree(sep, ep -&gt; arg1, inner_label_type1,
										p_num, n_num, &amp;has_inner_val1, &amp;inner_val1);				
		if (error_flag) {
			goto done;
		}

		/* Recursively evaluate the second subtree. */
		error_flag = expr_check_subtree(sep, ep -&gt; arg2, inner_label_type2,
										p_num, n_num, &amp;has_inner_val2, &amp;inner_val2);
		if (error_flag) {
			goto done;
		}
		
		if (has_inner_val1 &amp;&amp; has_inner_val2) {
			switch(op) {
				case AND_TOK:	*val = (inner_val1 &amp; inner_val2); break;
				case DIV_TOK:	*val = (inner_val1 / inner_val2); break;
				case MOD_TOK:	*val = (inner_val1 % inner_val2); break;
				case OR_TOK:	*val = (inner_val1 | inner_val2); break;
				case MINUS_TOK:	*val = (inner_val1 - inner_val2); break;
				case PLUS_TOK:	*val = (inner_val1 + inner_val2); break;
				case STAR_TOK:	*val = (inner_val1 * inner_val2); break;
				case XOR_TOK:	*val = (inner_val1 ^ inner_val2); break;
				default: fatal(es("unknown unop"));
			}
		}
		else if (has_inner_val1) {
			/*
				The second subtree must a label and the operator must
				allow labels, i.e., it must be + or -.
				Either + or - will return the value of the first subtree.
			*/
			ASSERT(op == PLUS_TOK || op == MINUS_TOK);
			ASSERT(inner_label_type2 != NO_LABEL);
			*val = inner_val1;
			*has_val = TRUE;
		}
		else if (has_inner_val2) {
			/*
				The first subtree must a label and the operator must
				allow labels, i.e., it must be + or -.
			*/
			if (op == PLUS_TOK) {
				*val = inner_val2;
			}
			else {
				ASSERT(op == MINUS_TOK);
				*val = -inner_val2;
			}
			*has_val = TRUE;
		}
		else {
			/* Both subtrees evaluate only to valid labels. */
			ASSERT(op == PLUS_TOK || op == MINUS_TOK);
		}
	}
	else {
		fatal(es("unknown enode type"));
	}

done:
	STATX(ftag);
	return error_flag;
}
</t>
<t tx="ekr.20080529093004.60">@ Dump the token stack.
@c

static void
expr_dump_op_stack(void)
{
	register int i = 0;

	for (i = op_count-1; i &gt;= 0; i--) {
		eblank(); etoknum(op_stack[i]);
	}
	ecnl();
}
</t>
<t tx="ekr.20080529093004.61">@ Return the value of a summary enode. Return error_flag set in the caller if the value will not fit in the indicated number of bytes.  This code was *very* difficult to get right. In particular, note the role of NO_SIGN_FIELD.
@c

long
expr_get_val
(
	enode * ep,						/* The enode containing the value. */
	ushort bytes,					/* The size of the field containing the value. */
	bool * error_flag,				/* The error flag in the *caller*. */
	bool allow_unknown_refs_flag,	/* TRUE: don't give errors. */
	ulong delayed_error_line,		/* The line containing the error. */
	short sign_kind					/* TRUE: the field represents an unsigned number. */
)
{
	FTAG("expr_get_val");
	long field_mask = 0;	/* These bits indicate the field to be returned. */
	long sign_mask = 0;		/* These bits must all be 1 in negative numbers. */
	long val = 0;
	long result = 0;
	STATB(ftag);
	
	if (ep == NULL) {
		*error_flag = TRUE;
		goto done;
	}

	/* Summary nodes have already been generated by now. */
	ASSERT(ep -&gt; n_type == O_SUMMARY);
	
	/* Make sure everything is known that must be known. */
	if (allow_unknown_refs_flag == DONT_ALLOW_UNKNOWN_REFS) {
	
		m_dict_list_enode * mdp = NULL;
		for (mdp = summary_enode_ptr(ep) -&gt; pos_label_list; mdp; mdp = mdp -&gt; next) {
			ASSERT(mdp -&gt; the_m_dict);
			if (!dict_is_defined(mdp -&gt; the_m_dict)) {
				delayed_error(delayed_error_line, es("invalid undefined reference"));
				*error_flag = TRUE;
				goto done;
			}
		}
		
		for (mdp = summary_enode_ptr(ep) -&gt; neg_label_list; mdp; mdp = mdp -&gt; next) {
			ASSERT(mdp -&gt; the_m_dict);
			if (!dict_is_defined(mdp -&gt; the_m_dict)) {
				delayed_error(delayed_error_line, es("invalid undefined reference"));
				*error_flag = TRUE;
				goto done;
			}
		}
	}
		
	val = summary_enode_ptr(ep) -&gt; val;
	
	if (val &gt;= 0) {
	
		if (sign_kind == SIGNED_FIELD) {
		
			switch(bytes) {
			case 1:
				field_mask = 0x000000ff;
				sign_mask  = 0xffffff80;
				break;
			case 2:
				field_mask = 0x0000ffff;
				sign_mask  = 0xffff8000;
				break;
			case 0: case 4:
				field_mask = 0xffffffff;
				sign_mask  = 0x80000000;
				break;
			default: fatal(es("can't happen"));
			}
		
			*error_flag = ((val &amp; sign_mask) != 0);

			/* Use the original result if there is an error so errors print properly. */
			result = ((*error_flag) ? val : (val &amp; field_mask));
		}
		else {
		
			/* Arbitrary sign or unsigned. */
		
			switch(bytes) {
			case 1:	field_mask = 0x000000ff; break;
			case 2: field_mask = 0x0000ffff; break;
			case 0: case 4: field_mask = 0xffffffff; break;
			default: field_mask = 0;
			}

			/* Use the original result if there is an error so errors print properly. */
			*error_flag = ((val &amp; field_mask) != val);
			result = ((*error_flag) ? val : (val &amp; field_mask));
		}
	}
	else {
	
		if (sign_kind == SIGNED_FIELD || sign_kind == NO_SIGN_FIELD) {
		
			/* Make sure all sign bits are preserved. */
			switch(bytes) {
			case 1:
				field_mask = 0x000000ff;
				sign_mask  = 0xffffff80;
				break;
			case 2:
				field_mask = 0x0000ffff;
				sign_mask  = 0xffff8000;
				break;
			case 0: case 4:
				field_mask = 0xffffffff;
				sign_mask  = 0x80000000;
				break;
			default: fatal(es("can't happen"));
			}
		
			*error_flag = ((val &amp; sign_mask) != sign_mask);

			/* Use the original result if there is an error so errors print properly. */
			result = ((*error_flag) ? val : (val &amp; field_mask));
		}
		else {
		
			/* Negative values should not exist in unsigned fields. */
			*error_flag = TRUE;
			result = val;
		}
	}

done:
	STATX(ftag);
	return result;
}
</t>
<t tx="ekr.20080529093004.62">@ Return the precedence of a binary operator.
@c

static int
expr_prec(token op)
{
	FTAG("expr_prec");
	register int result = 0;
	STATB(ftag);
	ASSERT(is_binop(op));

	if (op == PLUS_TOK || op == MINUS_TOK) {
		result = 1;
	}
	else if (op == DIV_TOK || op == STAR_TOK) {
		result = 2;
	}
	else {
		result = 3;
	}

	STATX(ftag);
	return result;
}
</t>
<t tx="ekr.20080529093004.63">@ Parse a primitive (a constant or a label). Return a pointer to a suitable enode.  WARNING: the syntax for C and assembly language is different.  In C  '123' is a multibyte integer constant. In assembler, '123' is a string.  In C  "0.153" is a string. In assembler, "0.153" is a floating point constant.
@c

static enode *
expr_prim(void)
{
	FTAG("expr_prim");
	enode * result = NULL;
	TRACEPB(ftag,
		es("at "); etok(tok_token_ptr); enl());

	switch (t_type) {

	case CHAR_TOK:
	{
		/* WARNING: this represents an *string* constant. */
		string_enode * str_p = NULL;
		new_enode_macro(str_p, CHAR_TOK);
		str_p -&gt; the_string = t_ptr;
		tok_par_next_skip_ws();
		result = enode_ptr(str_p);
		break;
	}

	case INT_TOK:
	{
		const_enode * cep = NULL;
		new_enode_macro(cep, INT_TOK);
		cep -&gt; val = eval_string(t_ptr);
		tok_par_next_skip_ws();
		result = enode_ptr(cep);
		break;
	}

	case ID_TOK:
	{
		var_enode * vep = NULL;
		spell_node * spell_p = t_spell;
		dict_node * mdp = NULL;
		ASSERT(spell_p);

		/* Create a new dict_node and link it to the spelling node. */
		mdp = sem_reference_label(spell_p);
		
		/* The result is a new var enode pointing to the item for the spelling. */
		new_enode_macro(vep, ID_TOK);
		vep -&gt; var_m_dict = mdp;
		result = enode_ptr(vep);

		/* Skip past the id. */
		tok_par_next_skip_ws();
		break;
	}
	
	case STRING_TOK:
	{
		/* WARNING: this represents a *float* constant. */
		float_enode * float_p = NULL;
		char * s = t_ptr;
		long double ldval = 0.0;
		
		/* This is the only call to sscanf anywhere in CC2, AS or Link. */
		if (strlen(s) &gt; 0 &amp;&amp; sscanf(s, "%Le", &amp;ldval) == 1) {
			new_enode_macro(float_p, STRING_TOK);
			float_p -&gt; the_float = s;
			float_p -&gt; float_val = ldval;
			
			TRACEP("expr_prim_sscanf",
				es("sscanf("); es(s); es(") returns: "); edouble(ldval); enl());
		}
		else {
			error(es("bad floating constant: "); es(s));
		}
		tok_par_next_skip_ws();
		result = enode_ptr(float_p);
		break;
	}

	default:
		error(es("primitive expected at "); etok(tok_token_ptr));
		tok_par_next_skip_ws();
	}

	TRACEPX(ftag, eret(); eenode(result); ecnl());
	return result;
}
</t>
<t tx="ekr.20080529093004.64">@ Abort if any stack limit is exceeded.
@c

static void
expr_too_complex(void)
{
	user_fatal(es("expression too complex"));
}
</t>
<t tx="ekr.20080529093004.65">@ Create a summary enode representing a value expression.  Value expressions represent signed 8, 16 or 32-bit constants, combined with a lists of positive and negative labels.  Value expressions consist of the following: Operands: integer constants and labels. Operators: unaary + and - and binary + and - and * and /.  The minus_paren_flag indicates whether the parser has already seen the '-' and '(' tokens. Possible values for minus_paren_flag are NOTHING_SEEN_YET, PAREN_SEEN, MINUS_SEEN and MINUS_PAREN_SEEN.  The only time strings or floats are allowed is when handling DB pseudo op.
@c

enode *
expr_value(int minus_paren_flag, bool allow_strings_flag)
{
	FTAG("expr_value");
	register enode * result = NULL;
	STATB(ftag);
	
	/* Initialize. */
	ex_count = 0;
	op_count = 0;

	/* Push previous tokens on the stack. */
	if (minus_paren_flag == MINUS_PAREN_SEEN || minus_paren_flag == MINUS_SEEN) {
		op_push_macro(UMINUS_TOK);
	}

	if (minus_paren_flag == MINUS_PAREN_SEEN || minus_paren_flag == PAREN_SEEN) {
		op_push_macro(LPAREN_TOK);
	}

	/* Start of expression: push unary ops. */
	tok_skip_ws();
s_unop:
	TRACEP("s_unop", etok(tok_token_ptr); ecnl());

	while (is(PLUS_TOK) || is(MINUS_TOK) || is(TILDE_TOK)) {

		/* Push the unary operator and move past it. */
		if (is(PLUS_TOK)) {
			op_push_macro(UPLUS_TOK);
		}
		else if (is(MINUS_TOK)) {
			op_push_macro(UMINUS_TOK);
		}
		else {
			op_push_macro(TILDE_TOK);
		}
		tok_par_next_skip_ws();
	}

	/* Get an operand or including a recursely evaluated parenthesized expression. */
s_operand:
	TRACEP("s_operand", etok(tok_token_ptr); ecnl());

	if (is(LPAREN_TOK)) {

		/* Push the open parenthesis. */
		op_push_macro(t_type);
		tok_par_next_skip_ws();
		goto s_unop;
	}
	else if (is(ID_TOK) || is(CHAR_TOK) || is(INT_TOK) || is(STRING_TOK)) {

		/* Create an enode representing the primitive. */
		enode * ep = NULL;
		if (
			(is(CHAR_TOK) || is(STRING_TOK)) &amp;&amp;
			allow_strings_flag == DONT_ALLOW_STRINGS
		) {
			goto bad_expr;
		}
		ep = expr_prim();
		if (ep) {
			ex_push_macro(ep);
		}
		else {
			goto bad_expr;
		}
	}
	else {
		/* We expect the end of expression. */
		goto s_end;
	}

	/* Apply all previous unary operators. */
	while (op_count &amp;&amp; is_unop(op_top)) {
		if (expr_apply()) {
			goto bad_expr;
		}
	}
	
	if (is(RPAREN_TOK)) {

		/* Skip the closing parenthesis. */
		tok_par_next_skip_ws();

		/* Evaluate all operators in the subexpression. */
		while (op_count &amp;&amp; is_binop(op_top)) {
			if (expr_apply()) {
				goto bad_expr;
			}
		}

		/* Discard the matching left parenthesis. */
		if (op_count) {
			token junk;
			ASSERT(op_top == LPAREN_TOK);
			op_pop_macro(junk);
			goto s_binop;
		}
		else {
			goto bad_expr;
		}
	}
	
	/*
		An open parenthesis here ends the expression.
		Consider, for example, #5(a5)
	*/
	if (is(LPAREN_TOK)) {
		goto s_end;
	}

	/* Get a binary operator or end-of-expression. */
s_binop:
	TRACEP("s_binop", etok(tok_token_ptr); ecnl());

	if (!is_binop(t_type)) {
		goto s_end;
	}

	/*
		All binary operators associate left-to-right.
		Apply operators until the precedence of the current operator is
		less than or equal to the precedence of the operator on the top of the stack.
	*/

	while(op_count &amp;&amp; is_binop(op_top) &amp;&amp; expr_prec(op_top) &lt; expr_prec(t_type)) {
		if (expr_apply()) {
			goto bad_expr;
		}
	}
	op_push_macro(t_type);
	tok_par_next_skip_ws();
	goto s_unop;

	/*
		Handle the end of the expression.  Apply all remaining operators.
		By the way, an open parenthesis may end the expression.
	*/
s_end:
	TRACEP("s_end", etok(tok_token_ptr); ecnl());

	if (
		is(COMMA_TOK) || is(COMMENT_TOK) || is(LPAREN_TOK) ||
		is(WS_NL_TOK) || is(END_PROG_TOK)
	) {

		while (op_count) {
			if (is_binop(op_top) || is_unop(op_top)) {
				if (expr_apply()) {
					goto bad_expr;
				}
			}
			else if (op_top == LPAREN_TOK) {
				token junk;
				op_pop_macro(junk);
			}
			else {
				goto bad_expr;
			}
		}
		
		/* Pop the result, if it exists. */
		if (ex_count &gt; 0) {
			ex_pop_macro(result);
			goto done;
		}
		else {
			goto bad_expr;
		}
	}
	else {
		goto bad_expr;
	}
	
	fatal(es("fall through"));

bad_expr:
	error(es("invalid operand"));
	result = NULL;

done:
	if (result) {
		result = expr_check(result);
	}
	TRACEPX(ftag, eret(); eenode(result); ecnl());
	return result;
}
</t>
<t tx="ekr.20080529093004.66">/*
	AS: Constant folding routines.
	
	source:  ASfold.c
	started: February 9, 1994.
	version:
		April 10, 1994.
			Added code to handle floats.
		February 9, 1994.
*/

&lt;&lt; ASfold #includes &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.67">#include "AS.h"

#include "AScnodes.h"
#include "ASexp.h"
#include "Asfold.h"
#include "AStokens.h"
</t>
<t tx="ekr.20080529093004.68">@ Fold integer expressions involving a unary operator. Return the resulting expression.
@c

enode *
fold1(register enode * ep)
{
	FTAG("fold1");
	register enode *result = NULL;
	STATB(ftag);
	ASSERT(ep &amp;&amp; is_unop(ep -&gt; n_type));
	
	if (ep &amp;&amp; ep -&gt; arg1 &amp;&amp; ep -&gt; arg1 -&gt; n_type == INT_TOK) {
	
		/* An integer constant. */
		register long val = const_enode_ptr(ep -&gt; arg1) -&gt; val;
	
		switch(ep -&gt; n_type) {
		case NOT_TOK:		val = !val; break;
		case TILDE_TOK:		val = ~val; break;
		case UMINUS_TOK:	val = -val; break;
		case UPLUS_TOK:		break;
		default:			fatal(es("unknown unary operator"));
		}
		
		/* Put the result in arg1. */
		const_enode_ptr(ep -&gt; arg1) -&gt; val = val;
		result = ep -&gt; arg1;
	}
	else if (ep &amp;&amp; ep -&gt; arg1 &amp;&amp; ep -&gt; arg1 -&gt; n_type == STRING_TOK) {
	
		/* A *floating* constant. */
		register double val = float_enode_ptr(ep -&gt; arg1) -&gt; float_val;
	
		switch(ep -&gt; n_type) {
		case NOT_TOK:		val = !val; break;
		case UMINUS_TOK:	val = -val; break;
		case UPLUS_TOK:		break;
		case TILDE_TOK:		error(es("~ can not be applied to a float")); break;

		default:			fatal(es("unknown unary operator"));
		}
		
		/* Put the result in arg1. */
		float_enode_ptr(ep -&gt; arg1) -&gt; float_val = val;
		result = ep -&gt; arg1;
	}
	else {
	
		/* No folding is possible. */
		result = ep;
	}
	
	ASSERT(result);
	TRACEPX(ftag, eret(); eenode(result); ecnl());
	return result;
}
</t>
<t tx="ekr.20080529093004.69">@ Fold an integer expression involving a binary operator.
@c

enode *
fold2(enode * ep)
{
	FTAG("fold2");
	register enode * result = NULL;
	STATB(ftag);
	ASSERT(ep &amp;&amp; is_binop(ep -&gt; n_type));
	
	if (
		ep -&gt; arg1 &amp;&amp; ep -&gt; arg1 -&gt; n_type == INT_TOK &amp;&amp;
		ep -&gt; arg2 &amp;&amp; ep -&gt; arg2 -&gt; n_type == INT_TOK
	) {
		
		/* We have two constant integer arguments.  Do the folding. */
		long val = 0;
		long val1 = const_enode_ptr(ep -&gt; arg1) -&gt; val;
		long val2 = const_enode_ptr(ep -&gt; arg2) -&gt; val;
	
		switch (ep -&gt; n_type) {
				
		case AND_TOK:	 val = (val1 &amp; val2); break;
		case DIV_TOK:
			if (val2 == 0) {
				warning(eint(val1); es(" / 0 = 0"));
				val = 0;
			}
			else {
				val = (val1 / val2);
			}
			break;
		case MINUS_TOK:	 val = (val1 - val2); break;
		case MOD_TOK:
			if (val2 == 0) {
				warning(eint(val1); es(" % 0 = 0"));
				val = 0;
			}
			else {
				val = (val1 % val2);
			}
			break;
		case OR_TOK:	 val = (val1 | val2); break;
		case PLUS_TOK:	 val = (val1 + val2); break;
		case STAR_TOK:	 val = (val1 * val2); break;
		case XOR_TOK:	 val = (val1 ^ val2); break;
		default:		 fatal(es("unknown binary operator"));
		}
		
		/* Put the result in arg1. */
		const_enode_ptr(ep -&gt; arg1) -&gt; val = val;
		result = ep -&gt; arg1;
	}
	else if (
		ep -&gt; arg1 &amp;&amp; ep -&gt; arg1 -&gt; n_type == STRING_TOK &amp;&amp;
		ep -&gt; arg2 &amp;&amp; ep -&gt; arg2 -&gt; n_type == STRING_TOK
	) {
		
		/* We have two constant float arguments.  Do the folding. */
		double val = 0;
		double val1 = float_enode_ptr(ep -&gt; arg1) -&gt; float_val;
		double val2 = float_enode_ptr(ep -&gt; arg2) -&gt; float_val;
		char * op_string = NULL;

		switch (ep -&gt; n_type) {		
		
		case DIV_TOK:
			if (val2 == 0.0) {
				warning(edouble(val1); es(" / 0.0 = 0.0"));
				val = 0;
			}
			else {
				val = (val1 / val2);
			}
			break;

		case MINUS_TOK:	 val = (val1 - val2); break;
		case PLUS_TOK:	 val = (val1 + val2); break;
		case STAR_TOK:	 val = (val1 * val2); break;
		
		case AND_TOK:	op_string = "&amp;"; goto op_err;
		case MOD_TOK:	op_string = "%"; goto op_err;
		case OR_TOK:	op_string = "|"; goto op_err;
		case XOR_TOK:	op_string = "&amp;"; goto op_err;

		op_err:
			ASSERT(op_string);
			error(es("can not apply "); es(op_string); es(" to floating constant"));
			
		default:		 fatal(es("unknown binary operator"));
		}
		
		/* Put the result in arg1. */
		float_enode_ptr(ep -&gt; arg1) -&gt; float_val = val;
		result = ep -&gt; arg1;
	}
	else {
		/* No folding is possible. */
		result = ep;
	}

	ASSERT(result);
	TRACEPX(ftag, eret(); eenode(result); ecnl()); 
	return result;
}
</t>
<t tx="ekr.20080529093004.70">/*
	AS: the object file class.

	source: ASofile.c
	started: November 21, 1993.
	version:
		February 6, 1995.
			Retain f_ref_next field:  it saves lots of main memory in the linker.
		February 3, 1995.
			Added out_comments and out_comments_size.
		January 24, 1995.
			Changed several warning("...") to warning(es("...")).
			Changed register name_size to register int name_size.
		August 25, 1994.
			Check for non-NULL, zero-length sizes.  These are probably compiler errors.
		July 7, 1994.
			Bug fix: declare count to be ulong in out_area.
			Added several PERM_ASSERT_TRACE's.
		May 23, 1994.
			Bug fix: out_count must be declared ulong in out_ofile.
		May 20, 1994.
			Added arg_full_label_flag logic.
		May 19, 1994.
			Added f_unit_name.
		May 16, 1994.
			Wrote f_area_index and f_area_name fields.
			Bug fix in out_area_size: area size now includes size of its ref list.
			Bug fix in out_dict:  symbol length must be 0 for local symbols.
			Bug fix: 0 is not a valid dict number.
		May 13, 1994.
			Wrote fh_areas field.
		May 9, 1994.
			Include LIBofile.h rather than defining the object file here.
		May 6, 1994.
			The symbol dictionary does not contain the spelling of local symbols.
		May 4, 1994.
			Added symbolic tracing of flags.
			Fixed unit count field in header.
			Set out_bytes_offset to zero for each file.
		May 3, 1994.
			Set reserved fields to 0 in out_ofile.
		April 23, 1994.
			Removed buggy state machines from out_area_bytes and out_area_bytes_size.
		March 25, 1994.
			Added byte_node logic.
		March 22, 1994.
			Merged ASout.c into ASofile.c.
*/

&lt;&lt; ASofile #includes &gt;&gt;
&lt;&lt; ASofile declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.71">#include "AS.h"

#include "ASanodes.h"
#include "ASarg.h"
#include "AScnodes.h"
#include "ASmain.h"
#include "ASmem.h"
#include "ASofile.h"
#include "ASsem.h"
#include "AStokens.h"

#include &lt;LIBlist.h&gt;
#include &lt;LIBofile.h&gt;
#include &lt;LIBos.h&gt;

#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.72">/*
	Define abbreviations.
	
	The ASSERT_PADDED macro is used to check that the file has
	been properly padded so that all structs occur on an even byte boundary.
	
	The is_byte_cnode macro returns TRUE if the cnode will be put in a byte_node.
	O_ULABEL is included so it doesn't break up the list of bytes.
	
	DCB instructions small than SMALL_DCB_SIZE bytes are put into a byte node.
	Larger DCB instructions create fill nodes.
	
	trace_out_bytes_macro executes the compact code if PRODUCTION is #defined or
	if tracing for v_out is not defined. Otherwise, the expanded code is executed.
*/
#define ASSERT_PADDED(n) ASSERT(((n) &amp; 1) == 0)

#define SMALL_DCB_SIZE 20

#define is_byte_cnode(cp) \
	(\
		cp -&gt; n_type == O_ULABEL ||\
		cp -&gt; n_type == Z_DC || cp -&gt; n_type == Z_OPWORD || is_xtok(cp -&gt; n_type) ||\
		(cp -&gt; n_type == Z_DCB &amp;&amp; dcb_cnode_ptr(cp) -&gt; dcb_size &lt;= SMALL_DCB_SIZE)\
	)
	
#ifdef PRODUCTION
	#define trace_out_bytes_macro(compact, expanded) {compact;}
#else
	#define trace_out_bytes_macro(compact, expanded) \
		{ TRACEN("v_out", expanded); SL_NOT("v_out", compact);}
#endif

/*
	Define prototypes of local routines.
*/
static ulong out_area 			(area_node * map, ulong offset);
static ulong out_area_size		(area_node * map);
static ulong out_area_bytes		(area_node * map, ulong offset);
static ulong out_area_bytes_size(area_node * map);
static ulong out_comments		(area_node * map, ulong offset);
static ulong out_comments_size	(area_node * map);
static ulong out_dict	 		(ulong offset);
static ulong out_dict_size 		(void);
static ulong out_header			(ulong dict_size);
static ulong out_refs			(area_node * mup, ulong offset);
static ulong out_ref_size		(area_node * map);
static ulong out_trailer		(ulong offset);
static ulong out_unit 			(unit_node * mup, ulong offset);

/*
	Local variables.
	
	ofile_pad_bytes contains zero bytes for end-of-string, padding and alignment.
*/
static char ofile_pad_bytes [10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
</t>
<t tx="ekr.20080529093004.73">@ Dump an area node.
@c

void
dump_area (area_node * map)
{
	FTAG("dump_area");
	dict_node * mdp = NULL;
	ref_node * mrp = NULL;
	STATB(ftag);
	
	if (map == NULL) {
		es("&lt;NULL area&gt;");
	}
	else {
	
		es("reference list...");
		if (mrp = map -&gt; area_refs) {
			es("Reference list...");
			for (mrp = map -&gt; area_refs; mrp; mrp = mrp -&gt; ref_next) {
				dump_ref(mrp);
			}
		}
		else {
			es("NULL reference list.");
		}
	}

	STATB(ftag);
}
</t>
<t tx="ekr.20080529093004.74">@ Dump a comment node.
@c

void
dump_comment(f_comment * fcp)
{
	FTAG("dump_comment");
	STATB(ftag);

	switch(fcp -&gt; f_comment_kind) {
	
	case C_AUTO_COMMENT:		es("auto");			break;
	case C_BIG_TEMP_COMMENT:	es("big temp");		break;
	case C_FORMAL_COMMENT:		es("formal");		break;
	case C_FTEMP_COMMENT:		es("ftemp");		break;
	case C_HIDDEN_PTR_COMMENT:	es("hidden ptr");	break;
	case C_LINE_COMMENT: 		es("line");			break;
	default:					es(" ??? ");		break;
	}
	
	eblank();
	
	if (fcp -&gt; f_comment_kind == C_LINE_COMMENT) {
		eint(fcp -&gt; f_comment_offset);
		es(":&gt;");
	}
	else {
		es("size=");
		epadint(fcp -&gt; f_comment_size, 4);
		epadint(fcp -&gt; f_comment_offset, 4);
		es("[`");
		epadhex(fcp -&gt; f_comment_offset, 4);
		es("](a6)&gt;");
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.75">@ Dump a dict node.
@c

void
dump_dict(dict_node *mdp)
{
	FTAG("dump_dict");
	STATB(ftag);

	if (mdp == NULL) {
		ecnl(); es("&lt;NULL dictionary label&gt;\n");
	}
	else {
		
		ecnl(); es("Dump of dictionary label ");
		if (mdp -&gt; dict_spell &amp;&amp; mdp -&gt; dict_spell -&gt; spell_name) {
			es(mdp -&gt; dict_spell -&gt; spell_name);
		}
		else {
			es("&lt;NULL item name&gt;");
		}
		es(".  flags: ");
		es(dict_is_defined(mdp)		? ", defined"	 : "");
		es(dict_is_global(mdp)		? ", global"	 : "");
		es(dict_is_imported(mdp)	? ", import"	 : "");
		es(dict_is_referenced(mdp)	? ", referenced" : "");
		enl();
		es("offset: ");	epaduint(mdp -&gt; dict_offset, 4);
		es(" area: ");	eptr(mdp -&gt; dict_area);
		enl();
		ecnl();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.76">@ Dump an m_ref node.
@c

void
dump_ref(ref_node * mrp)
{
	FTAG("dump_ref");
	STATB(ftag);

	if (mrp == NULL) {
		ecnl(); es("&lt;NULL ref&gt;\n");
	}
	else {
	
		ASSERT(
			mrp -&gt; ref_dict &amp;&amp;
			mrp -&gt; ref_dict -&gt; dict_spell &amp;&amp;
			mrp -&gt; ref_dict -&gt; dict_spell -&gt; spell_name);
	
		es("Reference to: ");
		if (ref_is_neg(mrp)) {
			es("-");
		}
		es(mrp -&gt; ref_dict -&gt; dict_spell -&gt; spell_name);
		es(", size: "); eint(mrp -&gt; ref_size);
		es(", area offset: "); eulong(mrp -&gt; ref_offset);
		enl();
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.77">@ Dump a unit node.
@c

void
dump_unit(unit_node * mup)
{
	FTAG("dump_unit");
	STATB(ftag);
	
	if (mup == NULL) {
		ecnl(); es("&lt;NULL m_unit&gt;\n");
	}
	else {	
		if (unit_is_proc(mup)) {
			es("PROC");
		}
		else if (unit_is_record(mup)) {
			es("RECORD");
		}
		else {
			es("&lt;LIMBO&gt;");
		}
		es(" unit at "); eptr(mup); enl();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.78">@ Output a possibly NULL area to the file. Return the number of bytes written.
@c

static ulong
out_area (area_node * map, ulong offset)
{
	FTAG("out_area");
	register ulong count = 0;
	f_area_node a;
	ulong ref_size  = out_ref_size(map);
	ulong byte_size = out_area_bytes_size(map);
	ulong comments_size = out_comments_size(map);
	ulong area_size = sizeof(f_unit_node) + byte_size + ref_size + comments_size;
	TRACEPB(ftag,
		es("offset: "); epadhex(offset,4); enl());
	
	if (map == NULL) {
		goto done;
	}
	
	/* Create the area node. */
	
	a . f_area_index = map -&gt; area_index;
	a . f_area_app_length = map -&gt; area_app_length;
	a . f_area_file_length = area_size;
	
	a . f_area_refs = (map -&gt; area_refs) ?  (offset + sizeof(f_area_node)) : 0;

	#ifdef USE_BYTE_LIST
		a . f_area_bytes =
			(map -&gt; area_code_list) ? (offset + sizeof(f_area_node) + ref_size) : 0;
	#else
		a . f_area_bytes = 0;
	#endif
	
	a . f_area_comments =
			(map -&gt; area_comments) ?
				(offset + sizeof(f_area_node) + ref_size + byte_size) : 0;
	
	a . f_area_name = (map -&gt; area_dict) ? (map -&gt; area_dict -&gt; dict_index) : 0;
	
	/* Write the area node. */
	trace_out_bytes_macro(
		out_bytes((char *) &amp;a, sizeof(f_area_node), "f_area_node");
			, /* Start of expanded code. */
		
		out_bytes(
			(char *) 	&amp;(a . f_area_index),
			sizeof		 (a . f_area_index),
			"area ----- index");
		out_bytes(
			(char *) 	&amp;(a . f_area_app_length),
			sizeof		 (a . f_area_app_length),
			"app_length");
		out_bytes(
			(char *)	&amp;(a . f_area_file_length),
			sizeof		 (a . f_area_file_length),
			"area size");
		out_bytes(
			(char *)	&amp;(a . f_area_refs),
			sizeof		 (a . f_area_refs),
			"reference list");
		out_bytes(
			(char *)	&amp;(a . f_area_bytes),
			sizeof		 (a . f_area_bytes),
			"byte list");
		out_bytes(
			(char *)	&amp;(a . f_area_comments),
			sizeof		 (a . f_area_comments),
			"comments list");	
		out_bytes(
			(char *)	&amp;(a . f_area_name),
			sizeof		 (a . f_area_name),
			"area name");
	);

	count += sizeof(f_area_node);
	offset += sizeof(f_area_node);
	
	/* Output the reference list. */
	{
		ulong ref_count = out_refs(map, offset);
		PERM_ASSERT_TRACE(ref_size == ref_count,
			es("ref count: ");  eulong(ref_count);
			es(", ref size: "); eulong(ref_size));

		offset += ref_count;
		count  += ref_count;
	}
	
	/* Output the byte list. */
	{
		ulong byte_count = out_area_bytes(map, offset);
		PERM_ASSERT_TRACE(byte_count == byte_size,
			es("byte count: ");  eulong(byte_count);
			es(", byte size: "); eulong(byte_size));

		offset += byte_count;
		count  += byte_count;
	}
	
	/* Output the comments list. */
	{
		ulong comments_count = out_comments(map, offset);
		PERM_ASSERT_TRACE(comments_count == comments_size,
			es("comments count: ");  eulong(comments_count);
			es(", comments size: "); eulong(comments_size));
			
		count += comments_count;
	}

done:	
	STATX(ftag);
	return count;
}
</t>
<t tx="ekr.20080529093004.79">@ Compute the size of one area on disk, including all code nodes attached to it. Return 0 if map is NULL.
@c

static ulong
out_area_size(area_node * map)
{
	FTAG("out_area_size");
	ulong size = 0;
	register cnode * cp = NULL;
	STATB(ftag);
	
	/* Add the file size of all cnodes. */
	if (map) {
		size += sizeof(f_area_node);
		size += out_ref_size(map);
		size += out_area_bytes_size(map);
		size += out_comments_size(map);
		ASSERT_PADDED(size);
	
	
		/* Zero-length, non-NULL sizes are almost always compiler errors. */
		if (size == 0) {
			warning(es("zero length area: probably a compiler error"));
		}
	}

	STATX(ftag);
	return size;
}
</t>
<t tx="ekr.20080529093004.80">@ Output the bytes or the byte_list of an area. Return the number of bytes written.  WARNING: This routine must be kept "in synch" with out_area_byte_size;
@c

static ulong
out_area_bytes (area_node * map, ulong offset)
{
	FTAG("out_area_bytes");
	register cnode * cp = NULL;
	register ulong count = 0;
	TRACEPB(ftag,
		es("offset: "); epadhex(offset,4); enl());

	ASSERT(map);

#ifdef USE_BYTE_LIST
	cp = map -&gt; area_code_list;
	while (cp) {
		switch(cp -&gt; n_type) {
		
		case O_ULABEL:
			cp = cp -&gt; next;
			break;

		case Z_ALIGN:
		{
			/* Create the align node. */
			f_align_node a;
			a . f_byte_type = F_ALIGN_TYPE;
			a . f_byte_next = ((cp -&gt; next) ? offset + sizeof(f_align_node) : 0);
			a . f_align_pad = align_cnode_ptr(cp) -&gt; align_pad;
			
			/* Write the align node. */
			trace_out_bytes_macro(
				out_bytes((char *) &amp;a, sizeof(a), "align node");
					, /* Start of expanded code. */
				out_bytes(
					(char *)	&amp;(a . f_byte_type),
					sizeof		 (a . f_byte_type),
					"align ----- F_ALIGN_TYPE");
				out_bytes(
					(char *)	&amp;(a . f_byte_next),
					sizeof		 (a . f_byte_next),
					"next");
				out_bytes(
					(char *)	&amp;(a . f_align_pad),
					sizeof		 (a . f_align_pad),
					"pad");
			);
					
			count  += sizeof(f_align_node);
			offset += sizeof(f_align_node);
			cp = cp -&gt; next;
			break;
		}

		case Z_DCB:
		
		if (dcb_cnode_ptr(cp) -&gt; dcb_size &gt; SMALL_DCB_SIZE) {
			f_fill_node f;
		
			/* Create the fill node. */
			f . f_byte_type = F_FILL_TYPE;
			f . f_byte_next = ((cp -&gt; next) ? offset + sizeof(f_fill_node) : 0);
			f . f_fill_count = dcb_cnode_ptr(cp) -&gt; dcb_size;
			f . f_fill_val   = dcb_cnode_ptr(cp) -&gt; dcb_val;
			
			/* Write the fill node. */
			trace_out_bytes_macro(
				out_bytes((char *) &amp;f, sizeof(f_fill_node), "fill node");
					, /* Start of expanded code. */
				out_bytes(
					(char *)	&amp;(f . f_byte_type),
					sizeof		 (f . f_byte_type),
					"fill ----- F_FILL_TYPE");
				out_bytes(
					(char *)	&amp;(f . f_byte_next),
					sizeof		 (f . f_byte_next),
					"next");
				out_bytes(
					(char *)	&amp;(f . f_fill_count),
					sizeof		 (f . f_fill_count),
					"fill count");
				out_bytes(
					(char *)	&amp;(f . f_fill_val),
					sizeof		 (f . f_fill_val),
					"fill val");
			);

			count  += sizeof(f_fill_node);
			offset += sizeof(f_fill_node);
			cp = cp -&gt; next;
			break;
		}
		
		/* else fall through. */

		default:
		{
			register ulong byte_count1 = 0;
			register ulong byte_count2 = 0;
			cnode * save_cp = cp;
			f_byte_node b;

			ASSERT(cp &amp;&amp; is_byte_cnode(cp));
			
			/*
				Calculate the size of the bytes following the byte node itself.

				WARNING: we can't use the area size here because the area
				may contain more than one byte node.
			*/
			while (cp &amp;&amp; is_byte_cnode(cp)) {
				byte_count1 += cnode_app_size(cp);
				cp = cp -&gt; next;
			}
			
			/* Create the byte node. */
			b . f_byte_type = F_BYTE_TYPE;
			b . f_byte_next = (cp ? offset+sizeof(f_byte_node)+byte_count1 : 0);
			b . f_byte_size = byte_count1;
			
			/* Write the byte node itself. */
			trace_out_bytes_macro(
				out_bytes((char *) &amp;b, sizeof(f_byte_node), "byte node");
					, /* Start of expanded code. */
				out_bytes(
					(char *)	&amp;(b . f_byte_type),
					sizeof		 (b . f_byte_type),
					"byte ----- F_BYTE_TYPE");
				out_bytes(
					(char *)	&amp;(b . f_byte_next),
					sizeof		 (b . f_byte_next),
					" next");
				out_bytes(
					(char *)	&amp;(b . f_byte_size),
					sizeof		 (b . f_byte_size),
					"byte node size");
			);

			count  += sizeof(f_byte_node);
			offset += sizeof(f_byte_node);
		
			/* Write the bytes following the byte node. */
			cp = save_cp;
			while(cp &amp;&amp; is_byte_cnode(cp)) {
				byte_count2 += out_cnode(cp);
				cp = cp -&gt; next;
			}
			ASSERT(byte_count1 == byte_count2);
			count  += byte_count1;
			offset += byte_count1;
			break;

		} /* End default case. */
		} /* End switch. */
	}
#else
	for (cp = map -&gt; area_code_list; cp; cp = cp -&gt; next) {
		count += out_cnode(cp);
	}
#endif

	/* Output a pad byte if needed. */
	if (count &amp; 1) {
		out_bytes((char *) &amp;ofile_pad_bytes, 1, "pad byte");
		count++;
	}

	STATX(ftag);
	return count;
}
</t>
<t tx="ekr.20080529093004.81">@ Return the number of bytes to be written in the byte_list of an area.
@c

static ulong
out_area_bytes_size (area_node * map)
{
	FTAG("out_area_bytes_size");
	register cnode * cp = NULL;
	register ulong size = 0;
	STATB(ftag);
	
	if (map == NULL) {
		goto done;
	}

#ifdef USE_BYTE_LIST
	cp = map -&gt; area_code_list;
	while (cp) {
		switch(cp -&gt; n_type) {
		
		case O_ULABEL:
			cp = cp -&gt; next;
			break;
		case Z_ALIGN:
			size += sizeof(f_align_node);
			cp = cp -&gt; next;
			break;
		case Z_DCB:
			if (dcb_cnode_ptr(cp) -&gt; dcb_size &gt; SMALL_DCB_SIZE) {
				size += sizeof(f_fill_node);
				cp = cp -&gt; next;
				break;
			}
			/* else fall through */

		default:
			ASSERT(cp &amp;&amp; is_byte_cnode(cp));

			/* Start a new byte node. */
			size += sizeof(f_byte_node);

			/* Scan forward until the end of the byte nodes. */
			while(cp &amp;&amp; is_byte_cnode(cp)) {
				size += cnode_app_size(cp);
				cp = cp -&gt; next;
			}
			break;
		}
	}
#else
	for (cp = map -&gt; area_code_list; cp; cp = cp -&gt; next) {
		size += cnode_app_size(cp);
	}
#endif

	/* Account for a pad byte. */
	if (size &amp; 1) {
		size++;
	}

	/* 8/25/95: zero-length, non-NULL sizes are almost always compiler errors. */
	if (size == 0) {
		warning(es("zero length byte list: probably a compiler error"));
	}
	
done:
	STATX(ftag);
	return size;
}
</t>
<t tx="ekr.20080529093004.82">@ Output the comments list of an area.
@c

static ulong
out_comments (area_node * map, ulong offset)
{
	FTAG("out_comments");
	
		register comment_node * mcp = NULL;
		register ulong comment_size = 0;
		register ulong f_comment_size = sizeof(f_comment);
		
	TRACEPB(ftag, es("offset: "); epadhex(offset,4); enl());
	ASSERT(map);
	
	if (map == NULL || map -&gt; area_comments == NULL) {
		goto done;
	}
	
	/* Reverse the comment list. */
	lst_general_reverse_macro(map -&gt; area_comments, comment_next, comment_node);
	
	for (mcp = map -&gt; area_comments; mcp; mcp = mcp -&gt; comment_next) {
	
		/* Create the reference node. */
		f_comment fc;
		char * comment_tag = NULL;

		fc . f_comment_kind		= mcp -&gt; comment_kind;
		fc . f_comment_offset	= mcp -&gt; comment_offset;
		fc . f_comment_size		= mcp -&gt; comment_size;
		
		switch(mcp -&gt; comment_kind) {
		
		case C_AUTO_COMMENT:		comment_tag = "auto comment";		break;
		case C_BIG_TEMP_COMMENT:	comment_tag = "big temp comment";	break;
		case C_FORMAL_COMMENT:		comment_tag = "formal comment";		break;
		case C_FTEMP_COMMENT:		comment_tag = "ftemp comment";		break;
		case C_HIDDEN_PTR_COMMENT:	comment_tag = "hidden ptr comment";	break;
		case C_LINE_COMMENT:		comment_tag = "line comment";		break;
		default:					fatal(es("bad comment"));
		}
		
		/* Output the comment node. */
		trace_out_bytes_macro(
			out_bytes((char *) &amp;fc, f_comment_size, "comment node");
				, /* Start of expanded code. */
			out_bytes(
				(char *)	&amp;(fc . f_comment_kind),
				sizeof		 (fc . f_comment_kind),
				comment_tag);
			out_bytes(
				(char *)	&amp;(fc . f_comment_offset),
				sizeof		 (fc . f_comment_offset),
				"offset");
			out_bytes(
				(char *)	&amp;(fc . f_comment_size),
				sizeof		 (fc . f_comment_size),
				"size");
		);
		
		comment_size += f_comment_size;
		offset       += f_comment_size;
	}
	
	/* Create an empty node to end the list. */
	{
		f_comment fc = {0, 0, 0};
	
		/* Output the reference node. */
		trace_out_bytes_macro(
			out_bytes((char *) &amp;fc, f_comment_size, "end comment node");
				, /* Start of expanded code. */
			out_bytes((char *) &amp;fc, f_comment_size, "end comment node");
		);
		
		comment_size += f_comment_size;
	}

done:
	TRACEPX(ftag, eret(); eulong(comment_size); enl());
	return comment_size;
}
</t>
<t tx="ekr.20080529093004.83">static ulong
out_comments_size (area_node * map)
{
	FTAG("out_comments_size");
	
	register comment_node * mcp = NULL;
	register ulong comment_size = 0;

	STATB(ftag);
	
	/* Add the sizes of all comment nodes for the area. */
	if (map  &amp;&amp; map -&gt; area_comments) {
		for (mcp = map -&gt; area_comments; mcp; mcp = mcp -&gt; comment_next) {
			comment_size += sizeof(f_comment);
			ASSERT_PADDED(comment_size);
		}

		/* Add the size of the null comment node that ends the list. */
		comment_size += sizeof(f_comment);
	}

	STATX(ftag);
	return comment_size;
}
</t>
<t tx="ekr.20080529093004.84">@ Output the dictionary at the indicated offset. Return the number of bytes written.
@c

static ulong
out_dict (ulong offset)
{
	FTAG("out_dict");
	char flags [200];
	dict_node * mdp = NULL;
	ulong dict_count = 0;
	ulong index = 1;
	f_dict_node	d;
	TRACEPB(ftag, es("offset: "); epadhex(offset,4); enl());

	/* Output every dict node. */
	for (mdp = sem_dict_list; mdp; mdp = mdp -&gt; next) {
	
		ASSERT(mdp -&gt; dict_spell &amp;&amp; mdp -&gt; dict_spell -&gt; spell_name);
		ASSERT(index == mdp -&gt; dict_index);
		index++;

		/*
			Create the f_dict node.
			
			An index of 0 represents no area.
			Only non-local symbols have a spelling.
		*/
		d . f_dict_area =
			((mdp -&gt; dict_area) ? mdp -&gt; dict_area -&gt; area_index : 0);
		d . f_dict_offset = mdp -&gt; dict_offset;
		d . f_dict_length =
			(arg_full_label_flag || dict_is_global(mdp) || dict_is_imported(mdp)) ?
				mdp -&gt; dict_spell -&gt; spell_length : 0;
		d . dict_flags = mdp -&gt; dict_flags;

		/* Output the f_dict node. */
		trace_out_bytes_macro(
			out_bytes((char *) &amp;d, sizeof(f_dict_node), "f_dict_node");
			
				, /* Start of expanded code. */
				
			/* Create a flags tag. */
			char flags [100];
			strcpy(flags, "flags:");
			if (dict_is_defined(mdp)) 		strcat(flags, " def");
			if (dict_is_referenced(mdp))	strcat(flags, " ref");
			if (dict_is_global(mdp))		strcat(flags, " glb");
			if (dict_is_imported(mdp))		strcat(flags, " imp");
	
			out_bytes(
				(char *)	&amp;(d . f_dict_area),
				sizeof		 (d . f_dict_area),
				"dict ----- area (0 = none)");
			out_bytes(
				(char *)	&amp;(d . f_dict_offset),
				sizeof		 (d . f_dict_offset),
				"offset");
			out_bytes(
				(char *)	&amp;(d . f_dict_length),
				sizeof		 (d . f_dict_length),
				"length");
			out_bytes(
				(char *)	&amp;(d . dict_flags),
				sizeof		 (d . dict_flags),
				flags);
		);

		dict_count += sizeof(f_dict_node);

		/*
			Output the spelling of the symbol.
			Local symbols have null names unless the full label flag is on.
		*/
		if (arg_full_label_flag || dict_is_global(mdp) || dict_is_imported(mdp)) {
		
			ASSERT(
				strlen(mdp -&gt; dict_spell -&gt; spell_name) ==
				mdp -&gt; dict_spell -&gt; spell_length
			);
			
			/* The tag is the symbol name itself. */
			out_bytes(
				mdp -&gt; dict_spell -&gt; spell_name,
				mdp -&gt; dict_spell -&gt; spell_length,
				mdp -&gt; dict_spell -&gt; spell_name);
			dict_count += mdp -&gt; dict_spell -&gt; spell_length;
	
			if ((mdp -&gt; dict_spell -&gt; spell_length &amp; 1) == 0) {
			
				/* Output the trailing 0 byte and  padding byte. */
				out_bytes((char *) &amp;ofile_pad_bytes, 2, "zero, pad byte");
				dict_count += 2;
			}
			else {
			
				/* Output just the trailing 0 byte. */
				out_bytes((char *) &amp;ofile_pad_bytes, 1, "zero byte");
				dict_count++;
			}
		}
	
		ASSERT_PADDED(dict_count);
	}
	
	STATX(ftag);
	return dict_count;
}
</t>
<t tx="ekr.20080529093004.85">@ Compute the file size of the dictionary. Only imported or global symbols will be placed in the dictionary.
@c

static ulong 
out_dict_size (void)
{
	FTAG("out_dict_size");
	register dict_node * mdp = NULL;
	register ulong size = 0;
	register int name_size = 0;
	STATB(ftag);
	
	for (mdp = sem_dict_list; mdp; mdp = mdp -&gt; next) {
	
		size += sizeof(f_dict_node);
		
		/* Local symbols have null names. */
		if (arg_full_label_flag || dict_is_global(mdp) || dict_is_imported(mdp)) {
		
			ASSERT(mdp -&gt; dict_spell &amp;&amp; mdp -&gt; dict_spell -&gt; spell_name);
			name_size = mdp -&gt; dict_spell -&gt; spell_length;
			size += name_size;
			if ((name_size &amp; 1) == 0) {
				size+=2;	/* Add the zero byte and a pad byte. */
			}
			else {
				size++;		/* Just add the zero byte. */
			}
		}
	}
	
	/* Zero-length, non-NULL sizes are almost always compiler errors. */
	if (sem_dict_list &amp;&amp; size == 0) {
		warning(es("zero length dictionary: probably a compiler error"));
	}
	
	STATX(ftag);
	return size;
}
</t>
<t tx="ekr.20080529093004.86">@ Output the header. Return the number of bytes written.
@c

static ulong
out_header (ulong dict_size)
{
	FTAG("out_header");
	f_header fh;		/* h conflicts with a variable in Macheaders. */
	STATB(ftag);

	fh . fh_version =	LINK_VERSION;
	fh . fh_revision =	LINK_REVISION;
	fh . fh_magic =		LINK_MAGIC;
	fh . fh_reserved1 =	0;
	fh . fh_reserved2 =	0;
	fh . fh_units =		sem_unit_number - 1;
	fh . fh_areas =		sem_area_number - 1;
	fh . fh_symbols =	sem_dict_number - 1;
	
	/* The symbol dictionary immediately follows the header. */
	if (sem_dict_list) {
		ASSERT(sem_dict_number);
		fh . fh_dictionary = sizeof(f_header);
	}
	else {
		ASSERT(sem_dict_number == 1);
		fh . fh_dictionary = 0;
	}
	ASSERT_PADDED(fh . fh_dictionary);
	
	/* The first unit occurs immediately after the dictionary. */
	if (sem_unit_list) {
		ASSERT(sem_unit_number);
		fh . fh_unit = sizeof(f_header) + dict_size;
	}
	else {
		ASSERT(sem_unit_number == 1);
		fh . fh_unit = 0;
	}
	ASSERT_PADDED(fh . fh_unit);
	
	/* Output the header. */
	trace_out_bytes_macro(
		out_bytes((char *) &amp;fh, sizeof(f_header), "f_header");
			, /* Start of expanded code. */
		out_bytes(
			(char *)	&amp;(fh . fh_version),
			sizeof		 (fh . fh_version),
			"header ----- version");
		out_bytes(
			(char *)	&amp;(fh . fh_revision),
			sizeof		 (fh . fh_revision),
			"revision");
		out_bytes(
			(char *)	&amp;(fh . fh_magic),
			sizeof		 (fh . fh_magic),
			"magic");
		out_bytes(
			(char *)	&amp;(fh . fh_reserved1),
			sizeof		 (fh . fh_reserved1),
			"reserved 1");
		out_bytes(
			(char *)	&amp;(fh . fh_reserved2),
			sizeof		 (fh . fh_reserved2),
			"reserved 2");
		out_bytes(
			(char *)	&amp;(fh . fh_symbols),
			sizeof		 (fh . fh_symbols),
			"symbols");
		out_bytes(
			(char *)	&amp;(fh . fh_units),
			sizeof		 (fh . fh_units),
			"units");
		out_bytes(
			(char *)	&amp;(fh . fh_areas),
			sizeof		 (fh . fh_areas),
			"areas");
		out_bytes(
			(char *)	&amp;(fh . fh_dictionary),
			sizeof		 (fh . fh_dictionary),
			"dict offset");
		out_bytes(
			(char *)	&amp;(fh . fh_unit),
			sizeof		 (fh . fh_unit),
			"unit offset");
	);

	STATX(ftag);
	return sizeof(f_header);
}
</t>
<t tx="ekr.20080529093004.87">@ Output the application file by scanning the global code list.  This routine translates between pointers and indices or offsets.
@c

void
out_ofile (void)
{
	FTAG("out_ofile");
	register ulong out_count = 0;
	ulong dict_size = 0;	/* The file size of the symbol dictionary. */
	STATB(ftag);

	/* Compute various sizes and make sure they are properly padded. */
	ASSERT_PADDED(sizeof(f_header));
	ASSERT_PADDED(sizeof(f_trailer));
	ASSERT_PADDED(sizeof(f_area_node));
	ASSERT_PADDED(sizeof(f_dict_node));
	ASSERT_PADDED(sizeof(f_ref_node));
	ASSERT_PADDED(sizeof(f_unit_node));
	
	/* Set the file offset in out_bytes for dumps. */
	out_bytes_offset = 0;

	dict_size = out_dict_size();
	ASSERT_PADDED(dict_size);
	
	/* Output the header. */
	out_count += out_header(dict_size);

	/* Output the dictionary. */
	{
		ulong dict_out_count = out_dict(out_count);
		ASSERT(dict_size == dict_out_count);
		out_count += dict_out_count;
		ASSERT_PADDED(out_count);
	}
	
	/* Output each unit. */
	{
		unit_node * mup = NULL;
		ulong unit_size = 0;
		ulong unit_index = 1;

		for (mup = sem_unit_list; mup; mup = mup -&gt; next) {
			ASSERT(unit_index == mup -&gt; unit_index);
			unit_index++;
			unit_size = out_unit(mup, out_count);
			out_count += unit_size;
			ASSERT_PADDED(out_count);
		}
	}
	
	/* Output the trailer. */
	out_count += out_trailer(out_count);
	ASSERT_PADDED(out_count);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.88">@ Output all reference nodes of an area to the file. Return the number of bytes written.
@c

static ulong
out_refs (area_node * map, ulong offset)
{
	FTAG("out_refs");
	register ref_node * mrp = NULL;
	register ulong ref_size = 0;
	register ulong f_ref_node_size = sizeof(f_ref_node);
	TRACEPB(ftag,
		es("offset: "); epadhex(offset,4); enl());

	ASSERT(map);
	
	for (mrp = map -&gt; area_refs; mrp; mrp = mrp -&gt; ref_next) {
	
		/* Create the reference node. */
		f_ref_node r;
		
		ASSERT(mrp -&gt; ref_dict);
		r . f_ref_dict		= mrp -&gt; ref_dict -&gt; dict_index;
		r . f_ref_offset	= mrp -&gt; ref_offset;
		r . f_ref_size		= mrp -&gt; ref_size;
		r . ref_flags		= mrp -&gt; ref_flags;
		
		#if 1 /* The f_ref_next field saves a _lot_ of space in the linker! */
			r . f_ref_next = ((mrp -&gt; ref_next) ? offset + f_ref_node_size : 0);
		#else
			if (mrp -&gt; ref_next == NULL) {
				ref_set_last(&amp;r);
			}
		#endif
		
		/* Output the reference node. */
		trace_out_bytes_macro(
			out_bytes((char *) &amp;r, f_ref_node_size, "ref node");
				, /* Start of expanded code. */
			out_bytes(
				(char *)	&amp;(r . f_ref_next),
				sizeof		 (r . f_ref_next),
				"ref ----- next");
			out_bytes(
				(char *)	&amp;(r . f_ref_dict),
				sizeof		 (r . f_ref_dict),
				"dict");
			out_bytes(
				(char *)	&amp;(r . f_ref_offset),
				sizeof		 (r . f_ref_offset),
				"offset");
			out_bytes(
				(char *)	&amp;(r . f_ref_size),
				sizeof		 (r . f_ref_size),
				"size");
			out_bytes(
				(char *)	&amp;(r . ref_flags),
				sizeof		 (r . ref_flags),
				"flags");
		);

		ref_size += f_ref_node_size;
		offset   += f_ref_node_size;
	}

	TRACEPX(ftag, eret(); eulong(ref_size); enl());
	return ref_size;
}
</t>
<t tx="ekr.20080529093004.89">@ Compute the size of all the reference nodes attached to unit mup.
@c

static ulong
out_ref_size(area_node * map)
{
	FTAG("out_ref_size");
	register ref_node * mrp = NULL;
	register ulong ref_size = 0;
	STATB(ftag);
	
	/* Add the sizes of all reference nodes for the area. */
	if (map) {
		for (mrp = map -&gt; area_refs; mrp; mrp = mrp -&gt; ref_next) {
			ref_size += sizeof(f_ref_node);
			ASSERT_PADDED(ref_size);
		}
	
		/* Zero-length, non-NULL sizes are almost always compiler errors. */
		if (map -&gt; area_refs &amp;&amp; ref_size == 0) {
			warning(es("zero length ref list: probably a compiler error"));
		}
	}

	STATX(ftag);
	return ref_size;
}
</t>
<t tx="ekr.20080529093004.90">@ Output the trailer at the indicated offset.
@c

static ulong
out_trailer(ulong offset)
{
	FTAG("out_trailer");
	f_trailer t;
	TRACEPB(ftag, es("offset: "); epadhex(offset,4); enl());

	/* Create the trailer. */
	ASSERT_PADDED(offset + sizeof(f_trailer));
	t . t_file_size = offset + sizeof(f_trailer);
	t . t_end = LINK_MAGIC;
	
	/* Output the trailer. */
	trace_out_bytes_macro(
		out_bytes((char *) &amp;t, sizeof(f_trailer), "f_trailer");
			, /* Start of expanded code. */
		out_bytes(
			(char *)	&amp;(t . t_file_size),
			sizeof		 (t . t_file_size),
			"trailer ----- file size");
		out_bytes(
			(char *)	&amp;(t . t_end),
			sizeof		 (t . t_end),
			"magic");
	);
	
	STATX(ftag);
	return sizeof(f_trailer);
}
</t>
<t tx="ekr.20080529093004.91">@ Output a unit at the indicated offset of the file. Return the number of bytes written.
@c

static ulong
out_unit (unit_node * mup, ulong offset)
{
	FTAG("out_unit");
	ulong beginning_offset = offset;
	ulong code_size = out_area_size(mup -&gt; unit_code_area);
	ulong data_size = out_area_size(mup -&gt; unit_data_area);
	ulong unit_size = sizeof(f_unit_node) + code_size + data_size;
	f_unit_node u;
	TRACEPB(ftag,
		es("offset: "); epadhex(offset,4); enl());

	ASSERT(mup);

	/* Create the unit node. */
	u . f_unit_next =
		((mup -&gt; next) ? offset + unit_size : 0);
	u . f_unit_code_area =
		((mup -&gt; unit_code_area) ? offset + sizeof(f_unit_node) : 0);
	u . f_unit_data_area =
		((mup -&gt; unit_data_area) ? offset + sizeof(f_unit_node) + code_size : 0);
	u . f_unit_name = (mup -&gt; unit_dict) ? (mup -&gt; unit_dict -&gt; dict_index) : 0;

	u . unit_flags = mup -&gt; unit_flags;

	ASSERT_PADDED(u . f_unit_next);
	ASSERT_PADDED(u . f_unit_code_area);
	ASSERT_PADDED(u . f_unit_data_area);
	
	/* Output the f_unit node. */
	trace_out_bytes_macro(
		out_bytes((char *) &amp;u, sizeof(f_unit_node), "unit node");
			, /* Start of expanded code. */
			
		/* Create a flags tag. */
		char flags [100];
		strcpy(flags, "unit flags:");
		if		(unit_is_proc(mup))		strcat(flags, " proc");
		else if (unit_is_record(mup)) 	strcat(flags, " record");
		else							strcat(flags, " limbo");
		
		out_bytes(
			(char *)	&amp;(u . f_unit_next),
			sizeof		 (u . f_unit_next),
			"unit ----- next");
		out_bytes(
			(char *)	&amp;(u . f_unit_code_area),
			sizeof		 (u . f_unit_code_area),
			"unit code area");
		out_bytes(
			(char *)	&amp;(u . f_unit_data_area),
			sizeof		 (u . f_unit_data_area),
			"unit data area");
		out_bytes(
			(char *)	&amp;(u . f_unit_name),
			sizeof		 (u . f_unit_name),
			"unit name");
		out_bytes(
			(char *)	&amp;(u . unit_flags),
			sizeof		 (u . unit_flags),
			"unit flags");
	);

	offset += sizeof(f_unit_node);
	ASSERT_PADDED(offset);

	/* Output the code area. */
	{
		ulong code_count = out_area(mup -&gt; unit_code_area, offset);
		PERM_ASSERT_TRACE(code_count == code_size,
			es("code count: ");  eulong(code_count);
			es(", code size: "); eulong(code_size));
			
		offset += code_count;
		ASSERT_PADDED(offset);
	}

	/* Output the data area. */
	{
		ulong data_count = out_area(mup -&gt; unit_data_area, offset);
		PERM_ASSERT_TRACE(data_count == data_size,
			es("data count: ");  eulong(data_count);
			es(", data size: "); eulong(data_size));

		offset += data_count;
		ASSERT_PADDED(offset);
	}
	
	PERM_ASSERT_TRACE(unit_size == (offset - beginning_offset),
		es("unit size: ");  eulong(unit_size);
		es(", offset-beginning_offset: "); eulong(offset - beginning_offset));

	STATX(ftag);
	return unit_size;
}
</t>
<t tx="ekr.20080529093004.92">/*
	AS: Statement and expression parsers.

	source: ASparse.c
	started: November 4, 1993.
	version:
		February 3, 1995.
			Added par_comment(), including support for arg_no_debug_flag.
		May 26, 1994.
			Changed par_next followed by tok_skip_ws to tok_par_next_skip_ws.
		April 24, 1994.
			Changed Q length specifier to D.
		April 23, 1994.
			Removed logic to handle '*' at start of a line.
			This must be handled by tokize.
		March 8, 1994.
			Call sem_define_label from par_program.
		March 2, 1994.
			Made the location counter global.
		February 13, 1994.
			Created ulabel_cnodes for lone labels.
		February 6, 1994.
			Added end_expression processing to par_am.
		January 12, 1994.
			Completed first draft of the parsers.
*/
&lt;&lt; ASparse #includes &gt;&gt;
&lt;&lt; ASparse declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.93">#include "AS.h"

#include "ASanodes.h"
#include "ASarg.h"
#include "ASasm.h"
#include "AScnodes.h"
#include "ASexp.h"
#include "ASmem.h"
#include "ASofile.h"
#include "ASparse.h"
#include "ASpseudo.h"
#include "ASsem.h"
#include "AStarget.h"
#include "AStokens.h"
#include "AStokize.h"

#include "LIBlist.h"
</t>
<t tx="ekr.20080529093004.94">/*
	Prototypes of local routines defined in this file.
*/
static anode *	par_am			(void);
static cnode *	par_comment		(char * comment);
static void		par_next_line	(cnode * cp);
static anode *	par_reglist		(token prev_reg, anode * ap);
static cnode *	par_xtok		(void);
</t>
<t tx="ekr.20080529093004.95">@ Parse a single address mode expression. When done, the current token will be either comma, newline or end-of-program.  An *address mode expression* represents a 680x0 address mode. The following is a list of the 68000 address modes:  mode syntax 0 Dn 1 An 2 (An) 3 (An)+ 4 -(An) 5 expr16(An) 6 expr8(An,Xn) 7:0 expression . W 7:1 expression . L (default if no .W or .L is given.) 7:4 #immediate 7:2 expr16(pc) 7:3 expr8(pc,xn)  Other address modes are specific to the 68020.
@c

static anode *
par_am(void)
{
	FTAG("par_am");
	anode * result = NULL;
	enode * e1 = NULL;
	STATB(ftag);

	/* Allocate the result. */
	new_anode_macro(result, BAD_TOK);

	if (is(WS_NL_TOK) || is(COMMA_TOK) || is(COMMENT_TOK) || is(END_PROG_TOK)) {
		error(es("missing operand field"));
		goto bad_am;
	}
	else if (is(POUND_TOK)) {
	
		/* #immediate */

		/* Skip the '#' */
		tok_par_next_skip_ws();

		/* Parse the expression. */
		e1 = expr_value(NOTHING_SEEN_YET, DONT_ALLOW_STRINGS);
		if (e1) {
			result -&gt; n_type = IMMEDIATE_EA;
			result -&gt; a_enode = e1;
			goto done;
		}
		else {
			goto bad_am;
		}
	}
	else if (is_reg(t_type)) {
	
		/*
			WARNING:
			register lists consisting of a single register must be
			handled separately in the assembler.
		*/
		if (is_areg(t_type) || is_dreg(t_type)) {
			/* Look ahead. */
			token tok = t_type;
			tok_par_next_skip_ws();
			if (is(MINUS_TOK) || is(DIV_TOK)) {
				result = par_reglist(tok, result);
			}
			else {
				result -&gt; n_type = (is_areg(tok) ? AREG_EA : DREG_EA);
				result -&gt; a_reg = tok;
			}
		}
		else {
			result -&gt; n_type = SPECIAL_EA;
			result -&gt; a_reg = t_type;
			tok_par_next_skip_ws();
		}
	
		goto done;
	}
	else if (is(MINUS_TOK)) {

		/* -(An) or -(expr). */
		
		/* Skip the minus sign. */
		tok_par_next_skip_ws();

		if (is(LPAREN_TOK)) {

			/* Skip the open parentheses. */
			tok_par_next_skip_ws();

			if (is_reg(t_type)) {

				/* -(An) */
				if (is_areg(t_type)) {
				
					result -&gt; n_type = PRE_DEC_EA;
					result -&gt; a_reg = t_type;
				
					/* Skip the address register. */
					tok_par_next_skip_ws();
					
					if (is(RPAREN_TOK)) {
					
						/* Skip the closing parenthesis. */
						tok_par_next_skip_ws();
						goto done;
					}
					else {
						error(es("')' expected"));
						goto bad_am;
					}
				}
				else {
					error(es("autodecrement mode can only be applied to A-regs"));
					goto bad_am;
				}
			}
			else {
				/* -(expr) */
				e1 = expr_value(MINUS_PAREN_SEEN, DONT_ALLOW_STRINGS);
				if (e1) {
					result -&gt; n_type = ABSOLUTE_EA;
					result -&gt; a_enode = e1;
					goto end_expression;
				}
				else {
					goto bad_am;
				}
			}
		}
		else {

			/* We expect -expr. */
			e1 = expr_value(MINUS_SEEN, DONT_ALLOW_STRINGS);
			if (e1) {
				result -&gt; n_type = ABSOLUTE_EA;
				result -&gt; a_enode = e1;
				goto end_expression;
			}
			else {
				goto bad_am;
			}
		}
	}
	else if (is(LPAREN_TOK)) {
	
		/* (An) or (An)+ or (expr) */

		/* Skip the open parentheses. */
		tok_par_next_skip_ws();

		if (is_reg(t_type)) {

			/* We expect (An) or (An)+ or ([...]) */
			if (is_areg(t_type)) {

				/* Assume we will get (An). */
				result -&gt; n_type = INDIRECT_EA;
				result -&gt; a_enode = e1;
				result -&gt; a_reg = t_type;
				
				/* Skip the register. */
				tok_par_next_skip_ws();

				/* Get the closing parenthesis. */
				if (is(RPAREN_TOK)) {
					tok_par_next_skip_ws();
				}
				else {
					error(es("')' expected"));
					goto bad_am;
				}

				if (is(PLUS_TOK)) {
					result -&gt; n_type = POST_INC_EA;
					tok_par_next_skip_ws();
				}
				goto done;
			}
			else {
				error(es("Address register expected"));
				goto bad_am;
			}
		}
		else {

			/* (expr) */
			e1 = expr_value(PAREN_SEEN, DONT_ALLOW_STRINGS);
			if (e1) {
				result -&gt; n_type = ABSOLUTE_EA;
				result -&gt; a_enode = e1;
				goto end_expression;
			}
			else {
				goto bad_am;
			}
		}
	}
	else {
	
		/* expr, expr(An), expr(An,Xn). */
		e1 = expr_value(NOTHING_SEEN_YET, DONT_ALLOW_STRINGS);
		if (e1) {
			result -&gt; n_type = ABSOLUTE_EA;
			result -&gt; a_enode = e1;
			goto end_expression;
		}
		else {
			goto bad_am;
		}
	}
	
	fatal(es("missing goto done"));

	/*
		An expression not preceded by a '#' has been found.
		Handle displacement and index modes and their pc-relative counterparts.
	*/
end_expression:

	if (is(LPAREN_TOK)) {
	
		/* expr(An), expr(An,Xn), expr(pc) or expr(pc,Xn). */

		/* Skip the '('. */
		tok_par_next_skip_ws();
	
		/* Finish parsing expr(An), expr(An,Xn), expr(pc) or expr(pc,Xn). */
		if (is_areg(t_type) || is(R_PC)) {
	
			bool pc_flag = is(R_PC);
	
			/* Change the address mode. */
			result -&gt; n_type = (pc_flag ? PC_DISP_EA : DISPLACEMENT_EA);
			result -&gt; a_reg = t_type;
			result -&gt; a_enode = e1;
	
			/* Skip the A-reg. */
			tok_par_next_skip_ws();
	
			/* Get an optional index register. */
			if (is(COMMA_TOK)) {
				result -&gt; n_type = pc_flag ? PC_INDEX_EA : INDEX_EA;
				tok_par_next_skip_ws();
				
				if (is_reg(t_type)) {
					result -&gt; a_xreg = t_type;
					tok_par_next_skip_ws();
				}
				
				/* Handle an optional .W or .L applied to the index register. */
				{
					bool float_flag = FALSE;
					short size = par_size(&amp;float_flag);
					if (float_flag || size == 1) {
						error(es("only .W or .L may be applied to index registers"));
						goto bad_am;
					}
					else if (size == 2) {
						if (result -&gt; n_type == INDEX_EA) {
							result -&gt; n_type = INDEX16_EA;
						}
						else {
							ASSERT(result -&gt; n_type == PC_INDEX_EA);
							result -&gt; n_type = PC_INDEX16_EA;
						}
					}
					else if (size == 4) {
						if (result -&gt; n_type == INDEX_EA) {
							result -&gt; n_type = INDEX32_EA;
						}
						else {
							ASSERT(result -&gt; n_type == PC_INDEX_EA);
							result -&gt; n_type = PC_INDEX32_EA;
						}
					}
					else {
						ASSERT(size == 0);
					}
				}
			}
	
			/* Get the closing parenthesis. */
			if (is(RPAREN_TOK)) {
				tok_par_next_skip_ws();
			}
			else {
				error(es("')' expected"));
				goto bad_am;
			}
		}
	}
	else {

		/* expr */
		if (e1) {
			result -&gt; n_type = ABSOLUTE_EA;
			result -&gt; a_enode = e1;
			
			/* Handle an optional .W or .L applied to a label. */
			{
				bool float_flag = FALSE;
				short size = par_size(&amp;float_flag);
				if (float_flag || size == 1) {
					error(es("only .W or .L may be applied to labels"));
					goto bad_am;
				}
				else if (size == 2) {
					result -&gt; n_type = ABS16_EA;
				}
				else {
					ASSERT(size == 4 || size == 0);
				}
			}
		}
		else {
			goto bad_am;
		}
	}

	/*
		No error has been found so far.
		Discard the result if the argument field does not end well.
	*/
done:

	if (
		!is_ws(t_type) &amp;&amp;
		!is(COMMA_TOK) &amp;&amp; !is(COMMENT_TOK) &amp;&amp;
		!is(WS_NL_TOK) &amp;&amp; !is(END_PROG_TOK)
	) {
		error(es("bad operand at "); etok(tok_token_ptr));
		goto bad_am;
	}

	STATX(ftag);
	return result;
	
	/*
		An error has been found.
		Scan forward to a comma, comment or newline.
	*/
bad_am:

	/* Skip to the end of the argument field. */
	while (
		!is(COMMA_TOK) &amp;&amp; !is(COMMENT_TOK) &amp;&amp;
		!is(WS_NL_TOK) &amp;&amp; !is(END_PROG_TOK)
	) {
		tok_par_next_skip_ws();
	}

	/* Skip to end of line unless we are at a comma token. */
	if (!is(COMMA_TOK)) {
		while (!is(WS_NL_TOK) &amp;&amp; !is(END_PROG_TOK)) {
			tok_par_next_skip_ws();
		}
	}

	STATX(ftag);
	return NULL;
}
</t>
<t tx="ekr.20080529093004.96">@ Create a comment cnode for a compiler comment. Return a pointer to the cnode or NULL if the comment was not a compiler comment.
@c

static bool
prefix_eq(char * s1, char * s2)
{
	while(*s2) {
		if (*s1++ != *s2++) {
			return FALSE;
		}
	}
	return *s1 == ' ';
}
</t>
<t tx="ekr.20080529093004.97">static cnode *
par_comment (char * comment)
{
	FTAG("par_comment");
	
		cnode * cp = NULL;
		comment_node * cnp = NULL;
		token kind = 0;
		
		int size = 0;
		int offset = 0;
	
	STATB(ftag);
	
	if (
		arg_no_debug_flag ||
		comment[0] != '*' &amp;&amp; comment[1] != ' ' ||
		comment[2] != '@' || comment[3] != ' '
	) {
		goto done;
	}
	
	/* Skip the '* @ ' characters. */
	comment += 4;
		
	/* Set the comment kind. */
	     if (prefix_eq(comment, "line"))		{ kind = C_LINE_COMMENT;		}
	else if (prefix_eq(comment, "auto"		))	{ kind = C_AUTO_COMMENT;		}
	else if (prefix_eq(comment, "big temp"	))	{ kind = C_BIG_TEMP_COMMENT;	}
	else if (prefix_eq(comment, "formal"	))	{ kind = C_FORMAL_COMMENT;		}
	else if (prefix_eq(comment, "ftemp"		))	{ kind = C_FTEMP_COMMENT;		}
	else if (prefix_eq(comment, "hidden ptr"))	{ kind = C_HIDDEN_PTR_COMMENT;	}
	else {
		goto done;
	}

	/*
		Set the offset and size fields.
		The true size field for line nodes will be filled in later.
	*/
	if (kind == C_LINE_COMMENT) {
		
		if (sscanf(comment, "line %4d:", &amp;size) != 1) {
			goto done;
		}
		offset = sem_current_area -&gt; area_app_length;
	}
	else {
	
		int junk = 0;

		/* Skip over the tag field. */
		comment += 11;
		
		/* Convert the strings to integers. */
		if (sscanf(comment, "size=%3d,%4d[`%4p](a%d)", &amp;size, &amp;offset, &amp;junk, &amp;junk) != 4) {
			goto done;
		}
	}
	
	/* Create a comment cnode. */
	new_file_macro(cnp, comment_stats);
	cnp -&gt; comment_kind = kind;
	cnp -&gt; comment_offset = offset;
	cnp -&gt; comment_size = size;
	
	/* Attach this to the current area's comment list. */
	ASSERT(sem_current_area);
	cnp -&gt; comment_next = sem_current_area -&gt; area_comments;
	sem_current_area -&gt; area_comments = cnp;
	
	#if 0
		/* Create a line_cnode for line comments. */
		if (kind == C_LINE_COMMENT) {
		
			new_file_macro(cp, cnode_stats);
			line_cnode_ptr(cp) -&gt; n_type = O_LINE;
			line_cnode_ptr(cp) -&gt; c_lc = 0;
			line_cnode_ptr(cp) -&gt; the_comment = cnp;
		}
	#endif

done:
	STATX(ftag);
	return cp;
}
</t>
<t tx="ekr.20080529093004.98">@ Skip to the start of the next line. Attach cp to the newline ending the current line.
@c

static void
par_next_line(cnode * cp)
{
	FTAG("par_next_line");
	STATB(ftag);

	/* Skip to the end of the current line. */
	while (!is(WS_NL_TOK) &amp;&amp; !is(END_PROG_TOK)) {
		tok_par_next_skip_ws();
	}

	/* Put cp into the newline, then skip the newline. */
	if (is(WS_NL_TOK)) {
		ASSERT(ptr_tok_ptr(tok_token_ptr) == NULL);
		patch_ptr_tok(tok_token_ptr, cp);
		err_line++;
		/* Skip *only* the newline: white space is important. */
		tok_par_next();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.99">@ Parse each line of an assembly language program.
@c

void
par_program (void)
{
	FTAG("par_program");
	register cnode * cp = NULL;
	register token * start_line = NULL;
	ulabel_cnode * the_label = NULL;
	long cp_size;
	STATB(ftag);

	/*
		Get the first token of the program.

		We can assert that the first non-hidden token is a newline
		because tokenize puts a newline at the start of the token
		list.  (This makes the first real line be line number 1).

		We skip to that newline so that tok_par_next_skip_ws
		can assert !is_hidden(par_token_ptr) on its initial entry.
		Clearly tok_par_next_skip_ws never needs to check for hidden tokens on entry
		because tok_par_next_skip_ws only returns visible tokens, 

		All this makes tok_par_next_skip_ws a bit faster, which is important.
		Notice: tok_par_next_skip_ws will skip the WS_NL_TOK
		*without* bumping err_line, so we must do it here.
	*/
	{
		tok_token_ptr = tok_skip_hidden(tok_first_token);
		ASSERT(is(WS_NL_TOK));
		err_line++;
		
		/* Skip *only* the newline: white space is important. */
		tok_par_next();
		start_line = tok_token_ptr;
	}

	while (!is(END_PROG_TOK)) {
	
		TRACEPN(ftag,
			tok_dump_line2(tok_token_ptr,
				DONT_PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_NON_USER_TOKENS);
			ecnl());
			
		/*
			We have just seen a newline.
			That is, we are at the start of a line.
			Indicate that no code node has been seen yet.
		*/
		cp = NULL;
		cp_size = 0;
		
		/*
			Bug fix:  7/14/94.
			Remember the label until it no longer represents the current location.
			Otherwise, the alignment operator for constructions such as
				label:
					dc.w 2
			would not see the label and could not adjust it.
		*/
		#if 0 /* Invalidate the label below. */
			the_label = NULL;
		#endif
		
		/*
			2/2/95:
			The start of a line can only be a label, white space or a comment.
			Anything else is an error.
		*/
		if (is(COMMENT_TOK)) {
		
			/*
				2/2/95:
				The comment could be a special compiler comment.
				Such comments can only happen here: the compiler never
				generates compiler comments following a label or white space.
			*/
			par_comment(ptr_tok_ptr(tok_token_ptr));
			
			#if 0 /* There is no lable, so this code is not needed. */
				if (cp == NULL) {
					cp = cnode_ptr(the_label);
				}
			#endif
			
			/* A comment continues to the end of the line. */
			goto end_line;
		}
		else if (is(ID_TOK)) {
			
			/*
				Handle an optional label field, followed by an optional colon.
				Remember the label for use by pseudo().
				Bug fix: 7/25/95.  Create a *list* of labels for align in ASpseudo.c.
			*/
			ulabel_cnode * new_label = sem_define_label(t_spell);
			new_label -&gt; clab_prev = the_label;
			the_label = new_label;

			/* Move past the label. */
			tok_par_next_skip_ws();
			
			/* Skip the optional colon. */
			if (is(COLON_TOK)) {
				tok_par_next_skip_ws();
			}
			
			/* Skip to the start of the op code field. */
			tok_skip_ws();
		}
		else if(is_ws(t_type)) {
		
			/* Skip to the start of the op code field. */
			tok_skip_ws();
		}
		else {
			error(es("bad label field"));
			par_next_line(NULL);
			continue;
		}

		/* Handle the op code and operand fields. */
		if (is(WS_NL_TOK) || is(END_PROG_TOK) || is(COMMENT_TOK)) {
					
			/* Put the label field in the newline token so it will be printed. */
			cp = cnode_ptr(the_label);
		}
		else if (is(END_PROG_TOK)) {
			break;
		}
		else if (is_pseudo(t_type)) {
			cp = pseudo(the_label);
			if (cp) {
				cp_size = cnode_app_size(cp);
				(sem_current_area -&gt; area_app_length) += cp_size;
			}
		}
		else if (is_xtok(t_type)) {
			cp = par_xtok();
			if (cp) {
				cp_size = cnode_app_size(cp);
				(sem_current_area -&gt; area_app_length) += cp_size;
			}
		}
		else {
			error(es("invalid op code"));
		}
		
		/*
			Remember the first label of any unit or area.
			This must be done *after* any PROC, RECORD, DATA or CODE directive.
		*/
		if (the_label) {
			sem_update_labels(the_label -&gt; clab_dict);
		}
		
		/* Only now do we invalidate the label. */
		if (cp_size) {
			the_label = NULL;
		}

		/*
			Attach cp to the newline ending the current line,
			then move to the next line.
		*/
end_line:
		par_next_line(cp);
		start_line = tok_token_ptr;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.100">@ Returns a pointer to a reglist_anode representing a register list. prev_reg contains the register that has been skipped over to get - or /.
@c

static char * reg_mess = "register appears twice in register list: ";

#define set_reg_bits_macro(tok, ap) \
{\
	ASSERT(is_xreg(tok));\
	regnum = (is_areg(tok) ? (8 + areg_num(tok)) : dreg_num(tok));\
	bits = (1 &lt;&lt; regnum);\
	if (bits &amp; ap -&gt; xwords) {\
		warning(es(reg_mess); es(tok_name(tok)));\
	}\
	ap -&gt; n_type = REGLIST_EA;\
	ap -&gt; xsize = 1;\
	ap -&gt; xwords |= bits;\
	(ap -&gt; xwords) &amp;= 0xffff;\
}

static anode *
par_reglist(token prev_reg, anode * ap)
{
	FTAG("par_reglist");
	token prev_op = 0;
	short regnum = 0;
	short bits = 0;
	STATB(ftag);
	ASSERT(ap);
	ASSERT(is(DIV_TOK) || is(MINUS_TOK));

	goto s_operator;
	
	/* We must have an operand. */
	
s_operand:

	if (!is_xreg(t_type)) {
		goto bad_reg_list;
	}
	
	/*
		"push" the operand: the stack hold only one element.
		Do nothing until the next operator is seen.
	*/
	if (prev_op == 0 || prev_op == DIV_TOK) {
		if (prev_reg == 0) {
			prev_reg = t_type;
			
			/* Scan past the operand. */
			tok_par_next_skip_ws();
			goto s_operator;
		}
		else {
			goto bad_reg_list;
		}
	}
	else if (prev_op == MINUS_TOK) {
	
		if (prev_reg == 0) {
			goto bad_reg_list;
		}
	
		/* 
			The input looks like prev_reg - t_type,
			Set a range of bits and set prev_op = 0.
		*/
		ASSERT(is_xreg(prev_reg));
		
		/* Set all the registers between prev_reg and tok bits. */
		{
			token the_tok = 0;
			
			/* Make sure the range is entirely within one kind of register. */
			if (
				(is_areg(prev_reg) &amp;&amp; !is_areg(t_type)) ||
				(is_dreg(prev_reg) &amp;&amp; !is_dreg(t_type))
			) {
				goto bad_reg_list;
			}
			
			if (prev_reg &lt; t_type) {
				for (the_tok = prev_reg; the_tok &lt;= t_type; the_tok++) {
					set_reg_bits_macro(the_tok, ap);
				}
			}
			else {
				for (the_tok = t_type; the_tok &lt;= prev_reg; the_tok++) {
					set_reg_bits_macro(the_tok, ap);
				}
			}
		}
		
		/* Nothing remains on either stack. */
		prev_op = prev_reg = 0;
		
		/* Scan past the register. */
		tok_par_next_skip_ws();
		goto s_operator;
	}
	else {
		goto bad_reg_list;
	}

s_operator:

	if (is(DIV_TOK)) {
		if (prev_reg) {
			set_reg_bits_macro(prev_reg, ap);
		}
		prev_reg = prev_op = 0;

		/* Scan past the operator. */
		tok_par_next_skip_ws();
		goto s_operand;
	}
	else if (is(MINUS_TOK)) {
		if (prev_reg &amp;&amp; prev_op == 0) {
			prev_op = t_type;
			
			/* Scan past the operator. */
			tok_par_next_skip_ws();
			goto s_operand;
		}
		else {
			goto bad_reg_list;
		}
	}
	else {
		goto s_end;
	}
	
s_end:

	if (prev_op == DIV_TOK || prev_op == 0) {
		if (prev_reg) {
			set_reg_bits_macro(prev_reg, ap);
		}
	}
	else if (prev_op == MINUS_TOK) {
		goto bad_reg_list;
	}
	
	/* Make sure the field ends properly. */
	if (!is(COMMA_TOK) &amp;&amp; !is(WS_NL_TOK) &amp;&amp; !is(END_PROG_TOK) &amp;&amp; !is(COMMENT_TOK)) {
		goto bad_reg_list;
	}
	goto done;

bad_reg_list:
	error(es("improper register list"));
	ap = NULL;
	goto done;
		
done:
	STATX(ftag);
	return ap;
}
</t>
<t tx="ekr.20080529093004.101">@ Parse an optional size specifier, consisting of a period and one of the letters b,w,l,s,x,q. Return the length implied by the field and set float_flag for the s,x or q. Return 0 if no size field was specified. Return -1 on an error.
@c

short
par_size(bool * float_flag)
{
	FTAG("par_size");
	register short size = 0;	/* Default: no size specified. */
	STATB(ftag);
	ASSERT(float_flag);
	*float_flag = FALSE;
	
	if (is(DOT_TOK)) {

		/* Skip the dot. */
		tok_par_next_skip_ws();
		
		if (is(ID_TOK) &amp;&amp; t_spell_name[1] == '\0') {
		
			switch(t_spell_name[0]) {
			
			case 'b': case 'B':	size = 1;  *float_flag = FALSE;  break;
			case 'l': case 'L': size = 4;  *float_flag = FALSE;  break;
			case 'w': case 'W': size = 2;  *float_flag = FALSE;  break;

			case 'd': case 'D': size = DOUBLE_SIZE;      *float_flag = TRUE; break;
			case 's': case 'S': size = FLOAT_SIZE;       *float_flag = TRUE; break;
			case 'x': case 'X': size = LONG_DOUBLE_SIZE; *float_flag = TRUE; break;
			
			default:
				error(es("improper length specifier: "); es(t_spell_name));
				size = -1;
			}

			/* Skip the length specifier. */
			tok_par_next_skip_ws();
		}
		else {
			error(es("improper length specifier"); es(t_spell_name));
			size = -1;
		}
	}
	
	STATX(ftag);
	return size;
}
</t>
<t tx="ekr.20080529093004.102">@ The current token is an assembly-language opcode. Parse the opcode and 0-3 arguments, then call assemble to create the corresponding cinode.
@c

static cnode *
par_xtok(void)
{
	FTAG("par_xtok");
	register cinode * cip = NULL;
	register bool error_flag = FALSE;
	int instruction_size = 0;
	STATB(ftag);	
	
	/* Create a cinode. */
	new_cnode_macro(cip, t_type, sem_current_area -&gt; area_app_length);
	
	/* Skip the op code. */
	tok_par_next_skip_ws();
	
	/* Handle the size specifier. */
	{
		bool junk;
		short size = par_size(&amp;junk);
		error_flag = (size == -1);
		if (size &gt; 0) {
			cip -&gt; c_length = size;
		}
	}
	
	/* See if there is any argument. */
	if (!error_flag &amp;&amp; !is(WS_NL_TOK) &amp;&amp; !is(END_PROG_TOK) &amp;&amp; !is(COMMENT_TOK)) {

		/* Parse the first argument. */
		cip -&gt; c_arg1 = par_am();
		
		if (cip -&gt; c_arg1 &amp;&amp; is(COMMA_TOK)) {
		
			/* Skip the comma. */
			tok_par_next_skip_ws();
			
			/* Parse the second argument. */
			cip -&gt; c_arg2 = par_am();

			if (cip -&gt; c_arg2 &amp;&amp; is(COMMA_TOK)) {
			
				/* Skip the comma. */
				tok_par_next_skip_ws();

				/* Parse the third argument. */
				cip -&gt; c_arg3 = par_am();
			}
		}
	}

	if (error_flag) {
		cip = NULL;
	}
	else {
		cip = assemble(cip);
	}
	
	STATX(ftag);
	return cnode_ptr(cip);
}
</t>
<t tx="ekr.20080529093004.103">/*	AS: First character compression pass.

	? Replace end-of-line characters by new-line characters.
	? Eliminate backslash newline combinations.
	? Make sure a non-empty file ends in a (real) newline and IO_EOF_CHAR.

	The compress function does both phases in a single pass.

	source:  ASpass12.c
	started: September 21, 1991
	version:
		March 25, 1994.
			Removed trigraph logic.
		December 27, 1993.
*/

&lt;&lt; ASpass12 #includes &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.104">#include "AS.h"

#include "ASarg.h"
#include "ASpass12.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBio.h&gt;
</t>
<t tx="ekr.20080529093004.105">@ Check the result of compress. Abort if there is a problem.
@c

void
check_compress(char * p)
{
	FTAG("check_compress");
	long count = 0;
	long newlines = 0;
	STATB(ftag);

	while (*p != IO_EOF_CHAR) {
		count++;
		if (*p == '\n') {
			count = 0;
			newlines++;
		}
		else if (*p == '\r') {
			fatal(
				es(ftag);
				es(": \\r seen: line: "); elong(newlines);
				es(" position: "); elong(count); enl();
			);
		}
		p++;
	}
	if (*(p-1) != '\n') {
		fatal(
			es(ftag);
			es(": unexpected IO_EOF_CHAR: line: "); elong(newlines);
			es(" position: "); elong(count); enl();
		);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.106">@ Define macros used in compress.  These macros form the heart of the alterations done on the input file.
@c

#define get(c)\
COMPRESS_STATS(icount++;) c = *ibuf++

#define put(c, stat)\
COMPRESS_STATS(ocount++; stat++;) *obuf++ = c

#define ignore_backslash_newline()\
{\
held_newlines++; obuf--; input_block -&gt; mem_length -= 2;\
COMPRESS_STATS(ocount--; backslash_newlines++;)\
}

/*
Eliminate trigraphs and backslash-newlines from the input block.
The input buffer must already end with PHYS_NL followed by IO_EOF_CHAR.

On exit:
o Guarantee a newline followed by a IO_EOF_CHAR at the end of the output buffer.
o Set input_block -&gt; mem_length to length of output buffer.

The main loop should be as fast as possible.

The same buffer is used for both input and output.  This works because
the output buffer pointer is always strictly behind the input buffer pointer.
*/

#if 1
#define COMPRESS_STATS(s)
#else
#define COMPRESS_STATS(s) s
#endif

void
compress (io_mem_block * input_block)
{
FTAG("compress");
register char * ibuf = NULL;
register char * obuf = NULL;
register char c = '\0';
int	held_newlines = 0;

COMPRESS_STATS(
	long junk = 0;
	long backslash_newlines = 0;
	long carriage_returns = 0;
	long eofs = 0;
	long icount = 0;
	long input_length = input_block -&gt; mem_length;
	long ocount = 0;
	long regular_chars = 0;
	long trigraphs = 0;
);

STATB(ftag);

ibuf = obuf = input_block -&gt; mem_start;

loop:
get(c);

#if defined(THINK_C) || defined(applec)
if (c == '\n' || c == '\r') {
	/* Treat *either* as a newline. */
	goto do_nl;
}
else {
	put(c, regular_chars);
	goto loop;
}
#else
if (c == '\n') {
	goto do_nl;
}
else if (c == '\r') {
	/* Ignore the '\r' */
	goto loop;
}
else {
	put(c, regular_chars);
	goto loop;
}
#endif

do_nl:
if (*(ibuf - 2) == '\\') {
	ignore_backslash_newline();
	if (*ibuf == IO_EOF_CHAR) goto done; else goto loop;
}

/*
	Output held-over newlines from backslash-newlines.
	This keeps physical and logical newlines in synch.
*/
while(held_newlines &gt; 0) {
	put('\n', junk);
	held_newlines--;
}

if (*ibuf != IO_EOF_CHAR) {
	put('\n', carriage_returns);
	goto loop;
}

done:
put('\n', carriage_returns);
put(IO_EOF_CHAR, eofs);

TICKX(ftag);

COMPRESS_STATS(TRACEP("-compress_stats",
	ecnl();
	es("input length:          "); elong(input_length); enl();
	es("output count:          "); elong(ocount); enl();
	es("correct output length: ");
	elong(input_length - (2 * trigraphs) - (2 * backslash_newlines) + eofs); enl();

	enl();
	es("regular chars:      "); elong(regular_chars); enl();
	es("trigraphs:          "); elong(trigraphs); enl();
	es("backslash-newlines: "); elong(backslash_newlines); enl();
	es("carriage_returns:   "); elong(carriage_returns); enl();
	enl();
));

TRACEP("-compress_check", check_compress(input_block -&gt; mem_start));

TRACEP("-compress_dump",
	char * p = &amp;(input_block -&gt; mem_start [0]);

	enl(); es("Output is...\n");
	while (*p != IO_EOF_CHAR) {
		echar(*p);
		p++;
	}
);
}
</t>
<t tx="ekr.20080529093004.107">/*
	AS: pseudo operations.

	source:  ASpseudo.c
	started: January 16, 1994.
	version:
		August 25, 1994.
			Use NO_SIGN_FIELD for DC constants.
		July 25, 1994.
			Bug fix to align: adjust all labels in the label list.
		July 14, 1994.
			Bug fix: supply a missing ENDPROC or ENDR.
			This compensates for a compiler bug!
		May 26, 1994.
			Changed par_next followed by tok_skip_ws to tok_par_next_skip_ws.
		May 3, 1994.
			Set import flag in IMPORT directive.
		April 22, 1994.
			Added support for multi-byte character constants.
			ALIGN directives are now valid in CODE areas.
		April 4, 1994.
			Bug fix: do not add padding bytes if the field is already aligned.
		March 25, 1994.
*/

&lt;&lt; ASpseudo #includes &gt;&gt;
&lt;&lt; ASpseudo declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.108">#include "AS.h"

#include "ASasm.h"
#include "AScnodes.h"
#include "ASexp.h"
#include "ASmem.h"
#include "ASofile.h"
#include "ASparse.h"
#include "ASpseudo.h"
#include "ASsem.h"
#include "AStarget.h"
#include "AStokens.h"

#include &lt;LIBlist.h&gt;
</t>
<t tx="ekr.20080529093004.109">/*
	Prototypes of local routines.
*/

static cnode * align (short val, ulabel_cnode * the_label);
</t>
<t tx="ekr.20080529093004.110">@ Create an alignment node if necessary and return a pointer to it.  val:  the necessary alignment. the_label: a possibly NULL label whose value must be adjusted.
@c

static cnode *
align (short val, ulabel_cnode * the_label)
{
	FTAG("align");
	short pad = 0;
	align_cnode * align_p = NULL;
	STATB(ftag);
	
	if ((sem_current_area -&gt; area_app_length) % val) {
	
		/* Compute the padding factor. */
		pad = (val - ((sem_current_area -&gt; area_app_length) % val));
		(sem_current_area -&gt; area_app_length) += pad;

		ASSERT(((sem_current_area -&gt; area_app_length) % val) == 0);
		
		/* Bug fix: 7/25/94: adjust all labels in the label list. */
		{
			ulabel_cnode * lab = the_label;
			while (lab) {
			
				/* Change the value of the label. */
				ASSERT(the_label -&gt; clab_dict);
				(the_label -&gt; clab_dict -&gt; dict_offset) += pad;

				lab = lab -&gt; clab_prev;
			}
		}

		/* Create an align cnode.  Save the *old* value of the location counter. */
		new_cnode_macro(align_p, Z_ALIGN, sem_current_area -&gt; area_app_length - pad);
		align_p -&gt; align_pad = pad;
	}
	
	STATX(ftag);
	return cnode_ptr(align_p);
}
</t>
<t tx="ekr.20080529093004.111">@ Parse a pseudo instruction. However, the caller will skip up to and past the newline ending the instruction,  Semantics for pseudo instructions are also handled here. If a cnode is created, enter it at the *start* the global code list. Set the new value of the current location counter, sem_current_area -&gt; area_app_length.
@c

#define pseudo_error(message) { error_message = message; goto give_pseudo_error; }

cnode *
pseudo (ulabel_cnode * the_label)
{
	FTAG("pseudo");
	token tok = t_type;
	cnode * pseudo_p = NULL;
	char * error_message = NULL;
	STATB(ftag);
	ASSERT(sem_current_unit &amp;&amp; sem_current_area);
	
	/* Skip the op code. */
	tok_par_next_skip_ws();
	
	switch(tok) {
	
	/*
		This version of ALIGN is a subset of the MPW align instruction.
		In particular, the ALIGN 0 and ALIGN 1 instructions are do nothing.
		At present, CC2 only generates ALIGN instructions with no arguments.
	*/
	case Z_ALIGN:	/* Align. */
	{
		long val = 0;
		
		/* Assume an alignment value of 2 if none is given. */
		if (is(WS_NL_TOK) || is(END_PROG_TOK) || is(COMMENT_TOK)) {
			val = 2;
		}
		else {
			bool error_flag = FALSE;
			enode * e1 = expr_value(NOTHING_SEEN_YET, DONT_ALLOW_STRINGS);
			if (e1) {
				val = expr_get_val(e1,4,&amp;error_flag, DONT_ALLOW_UNKNOWN_REFS,
						err_line, UNSIGNED_FIELD);
				if (error_flag || val &lt; 2) {
					val = 2;
				}
			}
			else {
				val = 2;
			}
		}
		
		pseudo_p = align(val, the_label);
		goto done;
	}

	case Z_CASE:	/* Ignored: specify how to handle cases of identifiers. */
		goto done;

	case Z_CODE:	/* Start of code area of a PROC unit. */
	
		if (unit_is_proc(sem_current_unit)) {
			sem_unit_status = SEM_CODE_STATUS;
			if (sem_current_unit -&gt; unit_code_area == NULL) {
			
				/* Create an area node and make it the unit's code area. */
				new_file_macro(sem_current_unit -&gt; unit_code_area, area_stats);
				sem_current_unit -&gt; unit_code_area -&gt; area_index = sem_area_number++;
			}
			sem_current_area = sem_current_unit -&gt; unit_code_area;
		}
		else {
			pseudo_error("CODE directive must appear in the range of a PROC directive");
		}
		goto done;

	case Z_DATA:	/* Start data are of a PROC unit. */

		if (unit_is_proc(sem_current_unit) || unit_is_record(sem_current_unit)) {
			sem_unit_status = SEM_DATA_STATUS;
			if (sem_current_unit -&gt; unit_data_area == NULL) {
			
				/* Create an area node and make it the unit's data area. */
				new_file_macro(sem_current_unit -&gt; unit_data_area, area_stats);
				sem_current_unit -&gt; unit_data_area -&gt; area_index = sem_area_number++;
			}
			sem_current_area = sem_current_unit -&gt; unit_data_area;
		}
		else {
			pseudo_error("DATA outside the range of a PROC or RECORD directive");
		}
		goto done;

	case Z_DCB:		/* Data block. */
	{
		bool error_flag = FALSE;
		enode * e1 = NULL, * e2 = NULL;
		char char_val = 0;
		ulong count = 1;

		/* Parse char_value and repeat count. */
		e1 = expr_value(NOTHING_SEEN_YET, DONT_ALLOW_STRINGS);
		if (e1 == NULL) {
			goto done;
		}

		count = expr_get_val(e1,2,&amp;error_flag, DONT_ALLOW_UNKNOWN_REFS, err_line, UNSIGNED_FIELD);
		if (error_flag) {
			error(es("bad DCB count"));
			goto done;
		}
		
		if (is(COMMA_TOK)) {
			/* Skip the comma. */
			tok_par_next_skip_ws();
			e2 = expr_value(NOTHING_SEEN_YET, DONT_ALLOW_STRINGS);
			if (e2 == NULL) {
				goto done;
			}
			char_val = expr_get_val(e2,1,&amp;error_flag, DONT_ALLOW_UNKNOWN_REFS, err_line, SIGNED_FIELD);
			if (error_flag) {
				error(es("bad DCB character value"));
				goto done;
			}
		}
		
		/* Make sure the DCB instruction is even aligned. */
		{
			cnode * cp = align(2, the_label);
			if (cp) {

				/* Add the instruction at the start of the global code list. */
				ASSERT(sem_current_area);
				cp -&gt; next = sem_current_area -&gt; area_code_list;
				sem_current_area -&gt; area_code_list = cp;
			}
		}
		
		/* Create a dcb node representing the DCB instruction. */
		{
			dcb_cnode * dcb_p = NULL;
			new_cnode_macro(dcb_p, Z_DCB, sem_current_area -&gt; area_app_length);
			dcb_p -&gt; dcb_size = count;
			dcb_p -&gt; dcb_val = char_val;
			pseudo_p = cnode_ptr(dcb_p);
		}
		
		if (sem_unit_status == SEM_IN_LIMBO_STATUS) {
			pseudo_error("DCB must appear in the range of a RECORD or PROC directive");
		}
		goto done;
	}
	
	case Z_DC:		/* DC instructions. */
	{
		short size = 0;
		dc_cnode * dc_p = NULL;
		bool float_flag = FALSE;

		/* Handle the required size field. */
		size = par_size(&amp;float_flag);
		if (size == -1) {
			goto done;
		}
		else if (size == 0) {
			pseudo_error("dc requires size specifier");
		}
		else if (
			size != 1 &amp;&amp; size != 2 &amp;&amp; size != 4 &amp;&amp;
			size != FLOAT_SIZE &amp;&amp;
			size != DOUBLE_SIZE &amp;&amp;
			size != LONG_DOUBLE_SIZE
		) {
			pseudo_error("improper instruction size");
		}
		
		/*
			Make sure the DC instruction is even aligned.
			An exception: DC.B instructions are not aligned.
		*/
		if (size &gt; 1) {
			cnode * cp = align(2, the_label);
			if (cp) {

				/* Add the instruction at the start of the global code list. */
				ASSERT(sem_current_area);
				cp -&gt; next = sem_current_area -&gt; area_code_list;
				sem_current_area -&gt; area_code_list = cp;
			}
		}
				
		/* Create the dc cnode. */
		new_cnode_macro(dc_p, Z_DC, sem_current_area -&gt; area_app_length);
		dc_p -&gt; dc_size = size;
		dc_p -&gt; dc_float_flag = float_flag;
		
		if (sem_unit_status == SEM_IN_LIMBO_STATUS) {
			pseudo_error("DC must appear in the range of a RECORD or PROC directive");
		}
		
		/*
			Be careful:
				DC.B xxx is a string.
				DC.L xxxx is a multi-byte character constant.
		*/
		for (;;) {
		
			dc_list_node * dc_list_p = NULL;
			ulong val = 0;			
			enode * e1 = NULL;
			bool error_flag;
	
			/*
				Allow strings only for the .B and .L specifications.
				DC.L will be converted to a multi-byte character constant next.
			*/
			e1 = expr_value(NOTHING_SEEN_YET, ALLOW_STRINGS);
			if (e1 == NULL) {
				pseudo_error("bad constant or string");
				goto done;
			}
			
			if (size == 4 &amp;&amp; !float_flag &amp;&amp; e1 -&gt; n_type == CHAR_TOK) {
			
				/*
					Convert the string to a multi-byte char constant.
					Such constants must consist of exactly 4 characters,
					though strlen(the_string) may be larger because of escape characters.
					
					By the way, MPW appears to allow longer multi-byte characters.
					This may be a bug in the MPW assmebler.
				*/
				char * s = string_enode_ptr(e1) -&gt; the_string;
				size_t i = strlen(s);
				int n = 0; /* The number of significant characters in the constant. */

				val = 0;
				while (*s) {
					if (*s == '\\') {
						s++; i--;
						if (i == 0) {
							/* Force an error message. */
							n = 0;
							break;
						}
					}
					val = (val &lt;&lt; 8);
					val += *s;
					s++; i--;
					n++;
				}
				if (n != 4) {
					error(
						es("Improper multi-byte character constant: ");
						es(string_enode_ptr(e1) -&gt; the_string));
					goto done;
				}
			}
			else if (e1 -&gt; n_type != CHAR_TOK &amp;&amp; e1 -&gt; n_type != STRING_TOK) {
			
				/*
					Bug fix: 5/2/94.
					We must allow unknown references here to later labels.
					For example:
								DC.L	lab
						lab:	DC.B	'a string',0
				*/
				val = expr_get_val(e1,size,&amp;error_flag, ALLOW_UNKNOWN_REFS, err_line, NO_SIGN_FIELD);
				if (error_flag) {
					pseudo_error("constant too large");
					goto done;
				}
			}
				
			/* Create a new list node representing the value. */
			new_file_macro(dc_list_p, dc_val_stats);
			dc_list_p -&gt; dc_enode = e1;
			dc_list_p -&gt; dc_val = val;
			
			/* Add the node to the dc_node's dc_val_list. */
			dc_list_p -&gt; next = dc_p -&gt; dc_val_list;
			dc_p -&gt; dc_val_list = dc_list_p;
			
			/* See if more constants remain. */
			if (is(COMMA_TOK)) {
			
				/* Skip the comma. */
				tok_par_next_skip_ws();
			}
			else if (is(WS_NL_TOK) || is(END_PROG_TOK) || is(COMMENT_TOK)) {
			
				/* A valid end to the list of expressions. */
				break;
			}
			else {
				pseudo_error("improper end of DC expression");
			}
		}
		
		/* Reverse the list of value nodes attached to the dc node. */
		lst_reverse_macro(dc_p -&gt; dc_val_list, dc_list_node);
		
		/* Set pseudo_p only after it is known that there is no error. */
		pseudo_p = cnode_ptr(dc_p);
		goto done;
	}
	
	case Z_END:		/* End assembly file. */
	{
		bool over_run_flag = FALSE;

		/* Warn if anything important follows. */
		tok_skip_ws();
		while (!is(END_PROG_TOK)) {
			if (is(WS_NL_TOK)) {
				err_line++;
			}
			else if (!is(COMMENT_TOK)) {
				if (!over_run_flag) {
					error(es("something follows END"));
				}
				over_run_flag = TRUE;
			}
			tok_par_next_skip_ws();
		}
		
		/* Warn about missing directives. */
		if (unit_is_proc(sem_current_unit)) {
			warning(es("missing ENDPROC directive"));
			goto endproc;
		}
		else if (unit_is_record(sem_current_unit)) {
			warning(es("missing ENDR directive"));
			goto endr;
		}
		else {
		
			/* End the current unit. */
			sem_unit_status = SEM_IN_LIMBO_STATUS;
			sem_current_unit = sem_in_limbo_unit;
			goto done;
		}
	}

	case Z_ENDPROC:	/* End procedure. */
endproc:
	
		if (unit_is_proc(sem_current_unit)) {
		
			/*
				Reverse the order of the unit's code list to
				preserve hidden relationships between cnodes.
			*/
			area_node * map = NULL;
			
			/* Reverse the code list for the code area. */
			map = sem_current_unit -&gt; unit_code_area;			
			if (map) {
				lst_reverse_macro(map -&gt; area_code_list, cnode);
			}
			
			/* Reverse the code list for the data area. */
			map = sem_current_unit -&gt; unit_data_area;			
			if (map) {
				lst_reverse_macro(map -&gt; area_code_list, cnode);
			}

			sem_unit_status = SEM_IN_LIMBO_STATUS;
			sem_current_unit = sem_in_limbo_unit;
		}
		else {
			pseudo_error("Ignoring an ENDPROC directive");
		}
		goto done;

	case Z_ENDR:	/* Ignored: end record specification. */
endr:

		if (unit_is_record(sem_current_unit)) {
		
			/*
				Reverse the order of the unit's code list to
				preserve hidden relationships between cnodes.
			*/
			area_node * map = sem_current_unit -&gt; unit_data_area;			
			if (map) {
				lst_reverse_macro(map -&gt; area_code_list, cnode);
			}

			sem_unit_status = SEM_IN_LIMBO_STATUS;
			sem_current_unit = sem_in_limbo_unit;
		}
		else {
			pseudo_error("Ignoring an ENDR directive");
		}
		goto done;

	case Z_ENTRY:	/* Define entry point. */
	case Z_EXPORT:	/* Make a symbol globally visible. */
	case Z_IMPORT:	/* Import a global symbol. */
		
		for (;;) {
		
			if (is(ID_TOK)) {
		
				/* Get the dict node and handle the semantics. */
				dict_node * mdp = sem_see_label(t_spell);
				if (tok == Z_ENTRY || tok == Z_EXPORT) {
					dict_set_global(mdp);
				}
				else if (tok == Z_IMPORT) {
					dict_set_import(mdp);
				}

				/* Move past the label. */
				tok_par_next_skip_ws();
				
				/* Skip a :CODE or :DATA. */
				if (is(COLON_TOK)) {
					tok_par_next_skip_ws();
					
					if (is(Z_CODE) || is(Z_DATA)) {
						tok_par_next_skip_ws();
					}
					else {
						pseudo_error("CODE or DATA expected");
					}
				}
				
				/* Skip the optional comma. */
				if (is(COMMA_TOK)) {
					tok_par_next_skip_ws();
				}
			}
			else if (is(WS_NL_TOK) || is(END_PROG_TOK) || is(COMMENT_TOK)) {
			
				/* A valid end to the list of expressions. */
				break;
			}
			else {
				pseudo_error("improper end of label list");
			}
		}
		goto done;

	case Z_OPT:		/* Ignored: specify optimizations. */
		goto done;

	case Z_OPWORD:	/* Specify a 2-byte operation code. */
	{
		ulong val = 0;
		
		/* Get the next expression. */
		{
			enode * e1 = NULL;
			bool error_flag;
			e1 = expr_value(NOTHING_SEEN_YET, DONT_ALLOW_STRINGS);
			if (e1 == NULL) {
				goto done;
			}
			val = expr_get_val(e1,2,&amp;error_flag, DONT_ALLOW_UNKNOWN_REFS, err_line, UNSIGNED_FIELD);
			if (error_flag) {
				goto done;
			}
		}
		
		/* Create an opword node. */
		{
			opword_cnode * opword_p = NULL;
			new_cnode_macro(opword_p, Z_OPWORD, sem_current_area -&gt; area_app_length);
			opword_p -&gt; opword = val;
			pseudo_p = cnode_ptr(opword_p);
		}
		goto done;
	}
		
	case Z_PROC:	/* Start a PROC unit. */
	case Z_RECORD:	/* Start a RECORD unit. */

		/* Warn about missing directives, but enter the appropriate unit! */
		if (unit_is_proc(sem_current_unit)) {
			error(es("missing ENDPROC directive"));
		}
		else if (unit_is_record(sem_current_unit)) {
			error(es("missing ENDR directive"));
		}
		
		/* Create a new area. */
		new_file_macro(sem_current_area, area_stats);
		sem_current_area -&gt; area_index = sem_area_number++;

		/*
			Create a new unit with the appropriate default status.
			Attach the new area to the appropriate part of the unit.
		*/
		new_file_macro(sem_current_unit, unit_stats);
		sem_current_unit -&gt; unit_index = sem_unit_number++;
		if (tok == Z_PROC) {
			unit_set_proc(sem_current_unit);
			sem_unit_status = SEM_CODE_STATUS;
			sem_current_unit -&gt; unit_code_area = sem_current_area;
		}
		else {
			unit_set_record(sem_current_unit);
			sem_unit_status = SEM_DATA_STATUS;
			sem_current_unit -&gt; unit_data_area = sem_current_area;
		}

		/* Add the unit to the global unit list. */
		sem_current_unit -&gt; next = sem_unit_list;
		sem_unit_list = sem_current_unit;
		goto done;

	case Z_SEG:		/* Ignored: specify segment. */
		goto done;

	case Z_STRING:	/* Ignored: specify how strings are to be handled. */
		goto done;

	case Z_WITH:	/* Ignored: specify a record. */
		goto done;

	default:
		fatal(es("unknown pseuodo operator"));
	}
	
	fatal(es("pseudo: fall through case"));
	
	/*
		Give an error message an exit *without* adding anything to the code list.
	*/
give_pseudo_error:

	ASSERT(error_message);
	error(es(error_message));
	pseudo_p = NULL;

	/*
		Add any generated cnode to the start of the global code list.
	*/
done:
	if (pseudo_p) {

		/* Add the instruction at the start of the global code list. */
		ASSERT(sem_current_area);
		pseudo_p -&gt; next = sem_current_area -&gt; area_code_list;
		sem_current_area -&gt; area_code_list = cnode_ptr(pseudo_p);
	}

	STATX(ftag);
	return pseudo_p;
}
</t>
<t tx="ekr.20080529093004.112">/*
	AS: Semantic classes.
	
	source:  ASsem.c
	started: March 2, 1994.
	version:
		January 24, 1995.
			Removed extern from declaration of sem_area_number.
		May 27, 1994.
			Change sem_update_labels so global labels over-ride local labels.
		May 20, 1994.
			Added sem_update_labels.
		May 16, 1994.
			Bug fix: unit numbers are never zero.
			Bug fix: dict numbers are never zero.
		May 13, 1994.
			Added sem_area_number.
		May 11, 1994.
			Revised so that areas contain reference lists instead of units.
		May 3, 1994.
			Bug fix to sem_begin: set sem_dict_number to 0.
		May 2, 1994.
			Computed size and offsets before calling sem_make_enode_refs.
			Added size and offset fields to sem_make_enode_refs.
		March 20, 1994.
*/

&lt;&lt; ASsem #includes &gt;&gt;
&lt;&lt; ASsem declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.113">#include "AS.h"

#include "ASanodes.h"
#include "ASarg.h"
#include "ASasm.h"
#include "AScnodes.h"
#include "ASexp.h"
#include "ASmem.h"
#include "ASofile.h"
#include "ASsem.h"
#include "AStokens.h"

#include &lt;LIBlist.h&gt;
</t>
<t tx="ekr.20080529093004.114">/*
	Global semantic variables.
*/

	/*
		The location counter is a global variable so it doesn't have
		to be passed to all the pattern matching routines.
	*/

bool sem_unit_status = SEM_IN_LIMBO_STATUS;

	/* Areas. */
	
area_node *	sem_current_area = NULL;	/* The current area. */
ulong 		sem_area_number = 1;		/* The number of area nodes. */


	/* Labels. */
	
dict_node *	sem_dict_list = NULL;	/* The list of all dict nodes. */
ulong		sem_dict_number = 1;	/* Number of dict nodes. */
				
	/* Units. */
	
unit_node *	sem_current_unit = NULL;	/* The current unit. */
unit_node *	sem_in_limbo_unit = NULL;	/* The dummy unit for out-of-unit items. */
unit_node *	sem_unit_list = NULL;		/* The list of all non-dummy units. */
ulong		sem_unit_number = 1;		/* Number of unit nodes. */


	/* Lists. */
	
bxx_node *	sem_bxx_list = NULL;		/* The list of bxx nodes. */

/*
	Semantic variables local to this file.
*/
static ulong sem_next_dict_index = 1;	/* Index of next dict node to be created. */

/*
	Prototypes of local routines.
*/

	/* Defined synonyms for pos_label_kind. */
	enum {POS_LABEL_FLAG = 1, NEG_LABEL_FLAG = 2 };
	
static void sem_make_cnode_refs	(area_node * map);
static void	sem_make_enode_refs
	(area_node * map, cnode * cp, enode * ep, short size, ulong offset);
static void sem_make_ref_node
	(area_node * map, dict_node * mdp, short size, ulong offset, bool pos_label_kind);
</t>
<t tx="ekr.20080529093004.115">@ Start semantic processing for one file.  We start by creating a unit "in limbo," i.e., a unit that is neither a code nor a data unit.  Items that are seen before any CODE, DATA, RECORD or PROC directive are invalid and will belong to this dummy unit.
@c

void
sem_begin (void)
{
	FTAG("sem_begin");
	STATB(ftag);
	
	/* Initialize all local semantic variables. */
	
	sem_next_dict_index = 1;
	
	/* Initialize all global semantic variables. */
	
	sem_unit_status = SEM_IN_LIMBO_STATUS;
	
		/* Areas. */
		
	sem_current_area = NULL;
	sem_area_number = 1;
	
		/* Labels. */
	
	sem_dict_list = NULL;
	sem_dict_number = 1;

		/* Units. */
	
	sem_in_limbo_unit = NULL;	/* A dummy unit for items outside any unit. */
	sem_unit_list = NULL;		/* The list of units. */
	sem_current_unit = NULL;	/* The current unit. */
	sem_unit_number = 1;

		/* Lists. */
	
	sem_bxx_list = NULL;		/* The list of bxx nodes. */

	/* Create the dummy unit but do *not* add it to the global unit list. */
	new_file_macro(sem_in_limbo_unit, unit_stats);
	sem_current_unit = sem_in_limbo_unit;
	
	/* Attach a dummy area to the dummy unit. */
	new_file_macro(sem_current_area, area_stats);
	sem_in_limbo_unit -&gt; unit_code_area = sem_current_area;
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.116">@ Return a pointer to the m_item node of the newly defined label, creating the node if it did not previously exist.
@c

ulabel_cnode *
sem_define_label (spell_node * spell_p)
{
	FTAG("sem_define_label");
	dict_node * mdp = NULL;
	ulabel_cnode * cup = NULL;
	STATB(ftag);
	ASSERT(spell_p &amp;&amp; sem_current_unit &amp;&amp; sem_current_area);

	mdp = sem_see_label(spell_p);
	
	/* Define the label or give an error for duplicate definitions. */
	if (dict_is_defined(mdp)) {
		error(es("duplicate definition of "); es(spell_p -&gt; spell_name));
	}
	else {
		/* Define the label's offset within its defining area. */
		dict_set_defined(mdp);
		mdp -&gt; dict_area = sem_current_area;
		mdp -&gt; dict_offset = sem_current_area -&gt; area_app_length;
	}
	
	/* Create a user label cnode. */
	new_cnode_macro(cup, O_ULABEL, sem_current_area -&gt; area_app_length);
	cup -&gt; clab_dict = mdp;
	
	/* Attach the label cnode to the code list. */
	cup -&gt; next = sem_current_area -&gt; area_code_list;
	sem_current_area -&gt; area_code_list = cnode_ptr(cup);
	
	STATX(ftag);
	return cup;
}
</t>
<t tx="ekr.20080529093004.117">@ Convert a field to an offset as indicated by the bxx node.  bxp -&gt; bxx_unit and bxp -&gt; bxx_lc describe the location of the patched offset. bxp -&gt; bxx_ap is a summary enode that should contain a single positive label. Compute the offset between the bxp -&gt; bxx_lc and the value of the label and convert the summary enode to reflect the offset.
@c

void
sem_do_offset (bxx_node * bxp, short pass_number)
{
	FTAG("sem_do_offset");
	cinode * cip = NULL;			/* The cnode containing the bxx instruction. */
	anode * ap = NULL;				/* The field of cip containing the offset. */
	summary_enode * sep = NULL;		/* ap -&gt; a_enode, a summary enode. */
	dict_node * mdp = NULL;		/* The (positive) label hung off sep. */
	short clen = 0;					/* cip -&gt; c_new_len. */
	ulong uval = 0;
	long offset = 0;
	bool error_flag = FALSE;
	ulong bxx_line = 0;
	STATB(ftag);
	
	ASSERT(bxp);
	cip = bxp -&gt; bxx_cip;
	bxx_line = bxp -&gt; bxx_err_line;
	ASSERT(cip);
	clen = cip -&gt; c_new_len;
	
	ap = bxp -&gt; bxx_ap;
	ASSERT(ap &amp;&amp; (ap == cip -&gt; c_arg1 || ap == cip -&gt; c_arg2));
	
	sep = summary_enode_ptr(ap -&gt; a_enode);
	ASSERT(sep &amp;&amp; sep -&gt; n_type == O_SUMMARY);
	
	mdp = sep -&gt; pos_label_list -&gt; the_m_dict;
	ASSERT(mdp &amp;&amp; mdp -&gt; dict_spell &amp;&amp; mdp -&gt; dict_spell -&gt; spell_name);
	
	/*
		Calculate the pattern to go into the bit fields.
		The offset is always relative to the word *after* the opcode word.
	*/
	offset = mdp -&gt; dict_offset - (bxp -&gt; bxx_lc) - 2;

	/* Set the val field in the summary enode to the actual offset. */
	sep -&gt; val = offset;
	sep -&gt; pos_label_list = NULL;
	
	if (pass_number == BXX_PASS2) {
		/* Pass 1 must have chosen an offset size without knowing the actual offset. */
		switch(clen) {
		case 1:
			ASSERT(ap -&gt; xsize == 0);
			goto byte_offset;
		case 0:
		case 2:
		case 100:
			ASSERT_TRACE(ap -&gt; xsize == 1, es("xsize: "); eint(ap -&gt; xsize));
			goto force_word_offset;
		default:
			goto invalid_size;
		}
	}
	else {
		/* More latitude is possible if offsets are known in pass 1. */
		ASSERT(pass_number == BXX_PASS1);
		switch(clen) {
		case 0:		goto no_offset;
		case 1:		goto byte_offset;
		case 2:		goto word_offset;
		case 100:	goto force_word_offset;
		default:	goto invalid_size;
		}
	}
	
	/* These cases use expr_get_val to handle tricky masking of sign bits. */
	
		/* An offset small enough to fit in a byte is required. */

byte_offset:

	uval = expr_get_val(enode_ptr(sep), 1,
		&amp;error_flag, DONT_ALLOW_UNKNOWN_REFS, bxx_line, SIGNED_FIELD);
	goto set_byte_offset;

		/* Use a word size and give no warnings. */

force_word_offset:

	uval = expr_get_val(enode_ptr(sep), 2,
		&amp;error_flag, DONT_ALLOW_UNKNOWN_REFS, bxx_line, SIGNED_FIELD);
	goto set_word_offset;

		/*
			Word offset has been specified.
			Give an optional warning if a smaller offset could have been used.
		*/

word_offset:

	if (arg_no_opt_flag) {
		uval = expr_get_val(enode_ptr(sep), 2,
			&amp;error_flag, DONT_ALLOW_UNKNOWN_REFS, bxx_line, SIGNED_FIELD);
		goto set_word_offset;
	}
	else {
		uval = expr_get_val(enode_ptr(sep), 1,
			&amp;error_flag, DONT_ALLOW_UNKNOWN_REFS, bxx_line, SIGNED_FIELD);
		if (error_flag) {
			uval = expr_get_val(enode_ptr(sep), 2,
				&amp;error_flag, DONT_ALLOW_UNKNOWN_REFS, bxx_line, SIGNED_FIELD);
			goto set_word_offset;
		}
		else {
			if (arg_warn_bxx_flag) {
				warning(es("byte offset is big enough for bcc, bra or bsr instruction"));
			}
			goto set_byte_offset;
		}
	}

		/* No offset is specified and either byte or word may be used. */

no_offset:

	/* Calculate the size of the offset using the value of the offset. */
	uval = expr_get_val(enode_ptr(sep), 1,
		&amp;error_flag, DONT_ALLOW_UNKNOWN_REFS, bxx_line, SIGNED_FIELD);
	if (error_flag) {
		uval = expr_get_val(enode_ptr(sep), 2,
			&amp;error_flag, DONT_ALLOW_UNKNOWN_REFS, bxx_line, SIGNED_FIELD);
		goto set_word_offset;
	}
	else {
		goto set_byte_offset;
	}
	
		/* uval represents an offset to be put in the opcode word. */

set_byte_offset:
	if (error_flag) {
		goto too_small;
	}
	set_cbits_macro(cip, uval);
	goto done;
	
		/* uval represents an offset to be put in a 16-bit extension word. */

set_word_offset:
	if (error_flag) {
		goto too_small;
	}
	ap -&gt; xsize = 1;
	ap -&gt; xwords = uval;
	(ap -&gt; xwords) &amp;= 0xffff;
	goto done;

too_small:
	delayed_error(bxp -&gt; bxx_err_line,
		es("size of bcc, bra or bsr instruction is too small"));
	goto done;

invalid_size:
	delayed_error(bxp -&gt; bxx_err_line, es("invalid size"));
	goto done;

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.118">@ Do all semantic processing required at the end of the parsing pass.
@c

void
sem_end(void)
{
	FTAG("sem_end");
	register bxx_node * bxp = NULL;
	register cnode * cp = NULL;
	unit_node * mup = NULL;
	STATB(ftag);
	
	/* Reverse the bxx list so error messages will appear in the correct order. */
	lst_reverse_macro(sem_bxx_list, bxx_node);
	
	/*
		Complete the processing for all nodes on the bxx list *before*
		creating label references so that bxx labels will not generate references.
		This is similar to the processing done in the xdata_bxx case in match().
	*/
	for (bxp = sem_bxx_list; bxp; bxp = bxp -&gt; next) {

		/* Set some abbreviations. */
		anode * ap = NULL;
		cinode * cip = NULL;
		summary_enode * sep = NULL;
		dict_node * mdp = NULL;

		cip = bxp -&gt; bxx_cip;
		ASSERT(cip);

		ap = bxp -&gt; bxx_ap;
		ASSERT(ap &amp;&amp; (ap == cip -&gt; c_arg1 || ap == cip -&gt; c_arg2));

		sep = summary_enode_ptr(ap -&gt; a_enode);
		ASSERT(sep &amp;&amp; sep -&gt; n_type == O_SUMMARY);

		mdp = sep -&gt; pos_label_list -&gt; the_m_dict;
		ASSERT(mdp &amp;&amp; mdp -&gt; dict_spell &amp;&amp; mdp -&gt; dict_spell -&gt; spell_name);
		
		/* Fill in the label field using the offset. */
		if (!dict_is_defined(mdp)) {
			delayed_error(bxp -&gt; bxx_err_line,
				es("undefined label: "); es(mdp -&gt; dict_spell -&gt; spell_name));
		}
		else {
			sem_do_offset(bxp, BXX_PASS2);
		}
	}
	
	/* Create references for all labels in the code list. */
	for (mup = sem_unit_list; mup; mup = mup -&gt; next) {
	
		/* Make all references in the unit's code area. */
		if (mup -&gt; unit_code_area &amp;&amp; mup -&gt; unit_code_area -&gt; area_code_list) {
			sem_make_cnode_refs(mup -&gt; unit_code_area);
		}
		
		/* Make all references in the unit's data area. */
		if (mup -&gt; unit_data_area &amp;&amp; mup -&gt; unit_data_area -&gt; area_code_list) {
			sem_make_cnode_refs(mup -&gt; unit_data_area);
		}
	}
	
	/* Reverse all units before printing or outputting them. */
	lst_reverse_macro(sem_unit_list, unit_node);
	
	/* Reverse sem_dict_list before outputting the dictionary. */
	lst_reverse_macro(sem_dict_list, dict_node);
	
	/* Check all dictionary nodes for undefined and non-imported symbols. */
	{
		register dict_node * mdp = NULL;
		for (mdp = sem_dict_list; mdp; mdp = mdp -&gt; next) {
			if (!dict_is_defined(mdp) &amp;&amp; !dict_is_imported(mdp)) {
				ASSERT(mdp -&gt; dict_spell &amp;&amp; mdp -&gt; dict_spell -&gt; spell_name);
				delayed_error(
					mdp -&gt; dict_err_line,
					es("undefined symbol: "); es(mdp -&gt; dict_spell -&gt; spell_name));
			}
		}
	}
			
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.119">@ Create all reference nodes arising from the code_list of the given area.
@c

static void
sem_make_cnode_refs(register area_node * map)
{
	FTAG("sem_make_cnode_refs");
	register cnode * cp = NULL;
	register ulong offset = 0;
	register short size = 0;
	STATB(ftag);
	ASSERT(map);

	cp = map -&gt; area_code_list;
	
	/* Handle all nodes on the code list. */
	for ( ;cp; cp = cp -&gt; next) {
	
		offset = cp -&gt; c_lc;
		
		if (cp -&gt; n_type == Z_DC) {
		
			dc_cnode * dc_p = dc_cnode_ptr(cp);
			dc_list_node *dcl_p = NULL;
			
			size = dc_p -&gt; dc_size;
			for (dcl_p = dc_p -&gt; dc_val_list; dcl_p; dcl_p = dcl_p -&gt; next) {
			
				if (dcl_p -&gt; dc_enode &amp;&amp; dcl_p -&gt; dc_enode -&gt; n_type == O_SUMMARY) {
					sem_make_enode_refs(map, cp, dcl_p -&gt; dc_enode, size, offset);
					offset += size;
				}
			}
		}
		else if (is_xtok(cp -&gt; n_type)) {
		
			cinode * cip = cinode_ptr(cp);
			
			/* Allow for size of opcode. */
			offset += 2;
			
			if (
				cip -&gt; c_arg1 &amp;&amp;
				cip -&gt; c_arg1 -&gt; a_enode &amp;&amp;
				cip -&gt; c_arg1 -&gt; a_enode -&gt; n_type == O_SUMMARY
			) {
				size = 2 * cip -&gt; c_arg1 -&gt; xsize;
				sem_make_enode_refs(map, cp, cip -&gt; c_arg1 -&gt; a_enode, size, offset);
				offset += size;
			}
			
			if (
				cip -&gt; c_arg2 &amp;&amp;
				cip -&gt; c_arg2 -&gt; a_enode &amp;&amp;
				cip -&gt; c_arg2 -&gt; a_enode -&gt; n_type == O_SUMMARY
			) {
				size = 2 * cip -&gt; c_arg2 -&gt; xsize;
				sem_make_enode_refs(map, cp, cip -&gt; c_arg2 -&gt; a_enode, size, offset);
				offset += size;
			}
			if (
				cip -&gt; c_arg3 &amp;&amp;
				cip -&gt; c_arg3 -&gt; a_enode &amp;&amp;
				cip -&gt; c_arg3 -&gt; a_enode -&gt; n_type == O_SUMMARY
			) {
				size = 2 * cip -&gt; c_arg3 -&gt; xsize;
				sem_make_enode_refs(map, cp, cip -&gt; c_arg3 -&gt; a_enode, size, offset);
				offset += size;
			}
		}
		else {
			/* Do nothing: No other pseudo operation allows references. */
		}
	}
		
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.120">@ Create all references in a summary enode.
@c

static void
sem_make_enode_refs
(
	area_node * map,	/* The area containing the cnode. */
	cnode * cp,			/* The cnode containing the reference. */
	enode * ep,			/* The summary enode containing the reference. */
	short size,			/* The size of the reference field, in bytes.  Must be 2 or 4. */
	ulong offset		/* The offset of the field from the start of the area. */
)
{
	FTAG("sem_make_enode_refs");
	m_dict_list_enode * mdl_p = NULL;
	summary_enode * sep = summary_enode_ptr(ep);
	STATB(ftag);
	ASSERT(sem_current_unit &amp;&amp; map &amp;&amp; cp &amp;&amp; ep &amp;&amp; ep -&gt; n_type == O_SUMMARY);

	/* Generate references for all positive labels. */
	for (mdl_p = sep -&gt; pos_label_list; mdl_p; mdl_p = mdl_p -&gt; next) {
	
		ASSERT_TRACE(size == 2 || size == 4, es("pos label size: "); eint(size));
		sem_make_ref_node(map, mdl_p -&gt; the_m_dict, size, offset, POS_LABEL_FLAG);
	}
	
	/* Generate references for all negative labels. */
	for (mdl_p = sep -&gt; neg_label_list; mdl_p; mdl_p = mdl_p -&gt; next) {
	
		ASSERT_TRACE(size == 2 || size == 4, es("neg label size: "); eint(size));
		sem_make_ref_node(map, mdl_p -&gt; the_m_dict, size, offset, NEG_LABEL_FLAG);
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.121">@ Create a single reference node to the dict anode and link it to the reference list of the unit.  Remember, all references are relative to the unit. There is no such thing as an "absolute reference."
@c

static void
sem_make_ref_node
(
	area_node * map,	/* The area containing the reference. */
	dict_node * mdp,	/* The dictionary node for the reference. */
	short size, 		/* The size in bytes of the field: must be 2 or 4. */
	ulong offset,		/* The offset of the reference from the start of the area. */
	bool pos_label_kind	/* TRUE: a positive reference. */
)
{
	FTAG("sem_make_ref_node");
	ref_node * mrp = NULL;
	STATB(ftag);
	ASSERT(map &amp;&amp; mdp);
	
	/* Create a new m_ref node. */
	new_file_macro(mrp, ref_stats)
	mrp -&gt; ref_dict = mdp;
	mrp -&gt; ref_offset = offset;
	mrp -&gt; ref_size = size;
	if (pos_label_kind == NEG_LABEL_FLAG) {
		ref_set_neg(mrp);
	}

	/* Link the node on the list of references of the indicated area. */
	mrp -&gt; ref_next = map -&gt; area_refs;
	map -&gt; area_refs = mrp;
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.122">@ Handle the initial semantic processing when a reference to a label is seen. That is, return a pointer to the dict_node attached to the spell node, creating one if necessary. This routine does *not* create m_ref nodes; that is done by sem_make_ref_node.
@c

dict_node *
sem_reference_label(spell_node * spell_p)
{
	FTAG("sem_reference_label");
	dict_node * mdp = NULL;
	STATB(ftag);
	ASSERT(spell_p);
	
	mdp = sem_see_label(spell_p);
	dict_set_referenced(mdp);

	STATX(ftag);
	return mdp;
}
</t>
<t tx="ekr.20080529093004.123">@ Handle the initial semantic processing when a label is seen in an EXTERN or ENTRY or IMPORT directive. That is, return a pointer to the dict_node attached to the spell node, creating one if necessary.
@c

dict_node *
sem_see_label(spell_node * spell_p)
{
	FTAG("sem_see_label");
	dict_node * mdp = NULL;
	STATB(ftag);
	ASSERT(spell_p);
	
	mdp = spell_p -&gt; spell_dict;
	if (mdp == NULL) {
	
		STAT("sem_see_label_create");

		new_file_macro(mdp, dict_stats);
		sem_dict_number++;
		mdp -&gt; dict_index = sem_next_dict_index++;
		mdp -&gt; dict_spell = spell_p;
		spell_p -&gt; spell_dict = mdp;
		mdp -&gt; dict_err_line = err_line;
		
		/* Add it to the list of all dict nodes. */
		mdp -&gt; next = sem_dict_list;
		sem_dict_list = mdp;
	}
	
	STATX(ftag);
	return mdp;
}
</t>
<t tx="ekr.20080529093004.124">@ Update the unit and area label. We want to associate global labels with units and areas if possible, but we will settle for a local label if no globals exist.
@c

void
sem_update_labels(dict_node * dp)
{
	FTAG("sem_update_labels");
	STATB(ftag);
	
	dp -&gt; dict_area = sem_current_area;
	
	/* The first global label over-rides any local label. */
	if (
		sem_current_unit -&gt; unit_dict == NULL ||
		(dict_is_global(dp) &amp;&amp; !dict_is_global(sem_current_unit -&gt; unit_dict))
	) {
		sem_current_unit -&gt; unit_dict = dp;
	}
	
	if (
		sem_current_area -&gt; area_dict == NULL ||
		(dict_is_global(dp) &amp;&amp; !dict_is_global(sem_current_area -&gt; area_dict))
	) {
		sem_current_area -&gt; area_dict = dp;
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.125"></t>
<t tx="ekr.20080529093004.126"></t>
<t tx="ekr.20080529093004.127">/*
	AS: header file for user arguments.

	source:  ASarg.h
	started: November 8, 1993.
	version:
		February 3, 1995.
			Added arg_no_debug_flag.
		January 5, 1995.
			Added arg_no_cpp_flag.
		March 25, 1994.
*/

#ifndef ASarg_h_
#define Asarg_h_

#pragma once

/*
	User Flags.
*/

extern bool arg_list_flag;	 /* +-list enable listing file. */

	/* Preprocessor flags. */

extern bool	arg_cpp_flag;			/* TRUE: output cpp results to output file. */
extern bool	arg_cpp_only_flag;		/* TRUE: exit after cpp finishes. */
extern bool arg_line_flag;			/* TRUE: #line directive in cpp output. */
extern bool arg_no_cpp_flag;		/* TRUE: suppress cpp. */
extern bool arg_once_flag;			/* TRUE: include all files only once. */
extern bool arg_v_full_include_flag; /* TRUE: use full file names in include messages. */
extern bool arg_v_func_flag;		/* +-v_function verbose messages about functions. */
extern bool arg_v_include_flag; 	/* TRUE: verbose messages about include files. */

	/* Code generation flags. */
	
extern bool arg_no_opt_flag;	/* TRUE: suppress optimization of bxx instructions. */
extern bool arg_warn_bxx_flag;	/* TRUE: warn if byte offset could be used. */

	/* Output and debugging flags. */

extern bool	arg_full_label_flag;	/* +-full_labels	Include local labels in object file. */
extern bool arg_no_debug_flag;		/* TRUE: don't create comment_cnodes. */  
extern bool arg_no_out_flag;		/* TRUE: suppress output, not code generation. */
extern short arg_page_length;		/* +-page xx Size of each listing page. 0 means no page breaks. */

/*
	Declare variables describing the input and output file paths.
	These are used to open files and to search for include paths.
*/
extern char * arg_segment;

extern char * arg_in_path;
extern char * arg_list_path;
extern char * arg_out_path;

extern io_path_list * arg_search_paths;

/*
	Function prototypes.
*/

	/* Synonyms for the return values from arg_do_argv. */
	enum { MORE_FILES_REMAIN = TRUE, NO_MORE_FILES_REMAIN = FALSE };

bool		arg_do_argv 		(int argc, char **argv, char * on_str, char * off_str);
void		arg_massage_string	(char * s);
int			arg_string2argv		(char *** argvp, char * buf);

#endif /* ASarg_h_ */</t>
<t tx="ekr.20080529093004.128">/*
	AS: header file for initialization module.

	source:  ASinit.h
	started: November 8, 1993.
	version: December 27, 1993.
*/

#ifndef init_h_
#define init_h_

#pragma once

/*
	Include headers for all modules that must be initialized.
*/

void	init_all	(int argc, char ** argv);
void	init_again	(void);

#endif /* init_h_ */
</t>
<t tx="ekr.20080529093004.129">/*
	AS: Header for main.c.

	source:  ASmain.c
	started: November 28, 1993.
	version: December 27, 1993.
*/

#ifndef ASmain_h_
#define ASmain_h_

#pragma once

void main_quit	(void);

#endif /* ASmain_h_ */</t>
<t tx="ekr.20080529093004.130"></t>
<t tx="ekr.20080529093004.131">/*	AS: Argument processing module
	Not all the routines in this module are used in
	all programming environments.

	source:  ASarg.c
	started: November 30, 1990
	version:
		February 3, 1995.
			Added arg_no_debug_flag.
		January 5, 1995.
			Added arg_no_cpp_flag.
		August 29, 1994.
			Added -bell option and -quit as a synonym for -exit.
		May 20, 1994.
			Added arg_full_label_flag.
		April 6, 1994.
			Issue better "missing -of" warning. It may be due to a bad comment.
		March 25, 1994.
			Removed arg_trigraph_flag.
		March 1, 1994.
			Added warn_bxx logic.
		January 26, 1994.
			Added arg_list_path logic.
		December 27, 1993.
			Added code to ignore Sherlock arguments in PRODUCTION mode.
		December 21, 1993.
			Converted str_alloc_macro logic to use mem_perm_string_macro logic.
		November 3, 1993.
			Added @ logic.
*/

/* Includes. */

&lt;&lt; ASarg #includes &gt;&gt;
&lt;&lt; ASarg declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.132">#include "AS.h"

#include "ASarg.h"
#include "ASmem.h"
#include "ASmst.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBenv.h&gt;
#include &lt;LIBio.h&gt;
#include &lt;LIBlist.h&gt;
#include &lt;LIBlog.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.133">/* Global vars... */

	/* Global user flags. */

bool arg_list_flag = TRUE;	 /* +-list enable listing file. */

	/* Preprocessor flags. */

bool arg_cpp_flag = FALSE; 				/* +-cpp 			 output cpp results to file. */
bool arg_cpp_only_flag = FALSE; 		/* +-cpp_only		 exit after cpp finishes. */
bool arg_line_flag = TRUE;	 			/* +-line			 #line directive in cpp output. */
bool arg_no_cpp_flag = FALSE;			/* +-no_cpp			 suppress cpp. */
bool arg_once_flag = FALSE; 			/* +-once			 include all files only once. */
bool arg_v_include_flag = FALSE; 		/* +-v_include		 verbose messages about include files. */
bool arg_v_full_include_flag = FALSE; 	/* +-v_full_include  full names of include files. */
bool arg_v_func_flag = FALSE; 			/* +-v_function		verbose messages about functions. */

	/* Code generation flags. */
	
bool arg_no_opt_flag = FALSE;	/* +-no_optimize suppress optimization of bxx instructions. */
bool arg_warn_bxx_flag = FALSE;	/* +-warn_bxx	 warn if byte offset could be used. */

	/* Output and debugging flags. */

bool	arg_full_label_flag = TRUE;	/* +-full_labels	Include local labels in object file. */
bool 	arg_no_debug_flag = FALSE;	/* +-no_debug	Don't create comment_cnodes. */  
bool 	arg_no_out_flag = FALSE;	/* +-no_output	Suppress output, not code generation. */
short	arg_page_length = 66;		/* +-page xx	Size of each listing page. 0 means no page breaks. */

	/* Error reporting options. */

								/* +-error		Enable error messages. */
								/* +-note		Enable notes. */
								/* +-warning	Enable warning messages. */
/*
	Define the global file paths and files.
*/
char * arg_segment = "MAIN";	/* Do not re-initialize. */
char * arg_in_path = NULL;
char * arg_out_path = NULL;
char * arg_list_path = NULL;

io_path_list * arg_search_paths = NULL;	/* Do not re-initialize. */

static int		arg_save_argc = 0;	/* Saved argc. */
static char **	arg_save_argv = NULL;	/* Saved argp. */

/* Prototypes of routines local to this class. */

static void	arg_help	(void);
static bool arg_prefix	(char *p, char *s);
</t>
<t tx="ekr.20080529093004.134">@ arg_do_argv: Process the arguments found in an argv vector. This routine may be re-entered. Return TRUE if any more arguments remain.
@c

#define debug_arg_do_argv(a)

bool
arg_do_argv(int argc, char ** argv, char * on_str, char * off_str)
{
	FTAG("arg_do_argv");
	register char * arg = NULL;
	char * in = NULL;
	char * out = NULL;
	char * listing = NULL;
	static char * path_tag = "path name";
	static char * default_opath = NULL;

	/*
		Do not put Sherlock macros here: Sherlock has not been initialized!
	*/
	SL_DISABLE();

	debug_arg_do_argv(TRACEP(ftag, elp(); eint(argc); ecs(); eptr(argv); erpnl()));

	if (argv == NULL) {
		argc = arg_save_argc;
		argv = arg_save_argv;
	}

	/* Indicate that no file arguments have been seen yet. */
	in  = NULL;
	out = NULL;
	listing = NULL;

	/* Process all the arguments on the command line. */
	ASSERT(argv);
	argc--;
	argv++;
	while (argc-- &gt; 0) {

		ASSERT(*argv);
		arg = *argv++;
		debug_arg_do_argv(TRACEPN(ftag, es("arg: "); es(arg); enl() ));

		if (arg[0] == '@') {
			/* Handle labels starting with @. */
			if (str_eq(arg+1, "goto")) {
				if (argc--) {

					/* Scan forward for the label. */
					char * label = *argv++;
					ecnl(); es("@goto "); es(label); enl();
					while(argc--) {
						arg = *argv++;
						if (str_eq(label, arg)) {
							break;
						}
					}
				}
				else {
					es("Trailing @goto\n");
					end_usage();
				}
			}
			else {
				/* Ignore the label. */
				;
			}
		}
		else if (arg[0] == '+' || arg[0] == '-') {
			bool arg_bool = (arg[0] == '+');
			arg++;
			switch(arg[0]) {
				/* option character cases... */
			case 'a': goto unknown_option;
			
			case 'b':
			
				if (str_eq(arg, "bell")) {
					#ifdef THINK_C
						SysBeep(20);
					#endif
				}
				else {
					goto unknown_option;
				}
				break;

			case 'c':
				if (str_eq(arg, "cpp")) {
					arg_cpp_flag = arg_bool;
				}
				else if (str_eq(arg, "cpp_only")) {
					arg_cpp_only_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;
			case 'd':
				if (str_eq(arg, "d")) {
					/* Define a variable. */
					if (argc--) {
						char * def = NULL;
						arg = *argv++;
						/* Scan for an optional equal sign. */
						for (def = arg;	*def; def++) {
							if (*def == '=') {
								*def = '\0';
								def++;
								break;
							}
						}
						mst_init_define(arg, def, TRUE);
					}
					else {
						es("Trailing +-d\n");
						end_usage();
					}
				}
				else {
					goto unknown_option;
				}
				break;
			case 'e':
				if (str_eq(arg, "error")) {
					err_err_flag = arg_bool;
				}
				else if (str_eq(arg, "exit")) {
					return NO_MORE_FILES_REMAIN;
				}
				else {
					goto unknown_option;
				}
				break;
			case 'f':
				if (str_eq(arg, "full_labels")) {
					arg_full_label_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
				goto unknown_option;
			case 'l':
				if (str_eq(arg, "line")) {
					arg_line_flag = arg_bool;
				}
				else if (str_eq(arg, "list")) {
					arg_list_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;
			case 'm': goto unknown_option;
			case 'n':
				if (str_eq(arg, "note")) {
					err_help_flag = arg_bool;
				}
				else if (str_eq(arg, "no_cpp")) {
					arg_no_cpp_flag = arg_bool;
				}
				else if (str_eq(arg, "no_debug")) {
					arg_no_debug_flag = arg_bool;
				}
				else if (str_eq(arg, "no_optimize")) {
					arg_no_opt_flag = arg_bool;
				}
				else if (str_eq(arg, "no_output")) {
					arg_no_out_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;
			case 'o':
				if (str_eq(arg, "of")) {
					if (argc--) {
						out = arg = *argv++;
					}
					else {
						es("Trailing +-of\n");
						end_usage();
					}
				}
				else if (str_eq(arg, "ol")) {
					if (argc--) {
						listing = arg = *argv++;
					}
					else {
						es("Trailing +-ol\n");
						end_usage();
					}
				}
				else if (str_eq(arg, "once")) {
					arg_once_flag = arg_bool;
				}
				else if (str_eq(arg, "out_path")) {

					/* Define the default output path. */
					if (argc--) {
						arg = *argv++;
						if(arg[strlen(arg)-1] == ENV_PATH_SEPARATOR_CHAR) {
							new_perm_string_macro(default_opath, arg);
						}
						else {
							new_perm_cat2_macro(default_opath, arg, ENV_PATH_SEPARATOR_STRING);
						}
					}
					else {
						es("Trailing +-out_path.\n");
						end_usage();
					}
				}
				else {
					goto unknown_option;
				}
				break;
			case 'p':
				if (str_eq(arg, "page")) {
					if (argc--) {
						arg = *argv++;
						arg_page_length = atoi(arg);
					}
					else {
						es("Trailing +-page.\n");
						end_usage();
					}
				}
				else {
					goto unknown_option;
				}
				break;

			case 'q':
			
				if (str_eq(arg, "quit")) {
					return NO_MORE_FILES_REMAIN;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'r': goto unknown_option;
			case 's':
				if (str_eq(arg, "s")) {

					/* Define a path. */
					if (argc--) {

						char * name = NULL;
						io_path_list * path_p = NULL;

						arg = *argv++;
						if(arg[strlen(arg)-1] == ENV_PATH_SEPARATOR_CHAR) {
							new_perm_string_macro(name, arg);
						}
						else {
							new_perm_cat2_macro(name, arg, ENV_PATH_SEPARATOR_STRING);
						}

						new_perm_macro(path_p, perm_arg_stats);
						path_p -&gt; io_path_name = name;
						lst_append_macro(path_p, arg_search_paths, io_path_list);
					}
					else {
						es("Trailing +-s.\n");
						end_usage();
					}
				}
				else if (str_eq(arg, "segment")) {
					char * arg1 = NULL;
					if (argc--) {
						arg1 = *argv++;
						new_perm_string_macro(arg_segment, arg1);
					}
					else {
						es("Trailing +-segment.\n");
						end_usage();
					}
				}
				else {
					goto unknown_option;
				}
				break;
			case 't': goto unknown_option;
			case 'u':
				if(str_eq(arg, "u")) {
					/* Suppress the initial definition of a variable. */
					if (argc--) {
						arg = *argv++;
						/* Put new u_node on global list. */
						mst_init_undef(arg);
					}
					else {
						es("Trailing +-u.\n");
						end_usage();
					}
				}
				else {
					goto unknown_option;
				}
				break;
			case 'v':
				if (str_eq(arg, "v")) {
					err_verbose = arg_bool;
				}
				else if (str_eq(arg, "v_full_include")) {
					arg_v_full_include_flag = arg_bool;
				}
				else if (str_eq(arg, "v_function")) {
					arg_v_func_flag = arg_bool;
				}
				else if (str_eq(arg, "v_include")) {
					arg_v_include_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;
			case 'w':
				if (str_eq(arg, "warning")) {
					err_warn_flag = arg_bool;
				}
				else if (str_eq(arg, "warn_bxx")) {
					arg_warn_bxx_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;
			default:
				if (str_eq(arg, "?")) {
					/* Tell the version number and go on. */
					enl(); es(lib_version); enl();
					arg_help();
					break;
				}
				/* Fall through to unknown option. */
			unknown_option:
				#ifdef PRODUCTION
					if (on_str &amp;&amp; arg_prefix(on_str+1, arg)) {

						/* Ignore a Sherlock argument. */
						char * s = arg + strlen(on_str) - 1;
						if (*s == '&gt;' &amp;&amp; *(s+1) == '&gt;') {
							log_open(0, s+2);
						}
					}
					else if (off_str &amp;&amp; arg_prefix(off_str+1, arg)) {
						/* Ignore a Sherlock argument. */
						;
					}
					else {
						es("ignoring unknown command-line option: ");
						es(arg_bool ? "+" : "-"); es(arg); enl();
					}
				#else
					es("ignoring unknown command-line option: ");
					es(arg_bool ? "+" : "-"); es(arg); enl();
				#endif
			} /* end +- option switch */
		}
		else if (in == NULL) {
			in = arg;
			break;
		}
	}

	/* Make sure that the input file name was provided. */
	if (in == NULL) {
		es("Missing input file argument.\n");
		end_usage();
	}

	/* Remember the input and output paths. */
	arg_in_path = in;

	if (out == NULL) {
		/* Create an output file name from the input file name. */
		size_t ilen = strlen(in);
		if (ilen &gt; 2 &amp;&amp; in[ilen-2] == '.' &amp;&amp; (in[ilen-1] == 'a' || in[ilen-1] == 'A')) {

			/* Prepend the default output path if it exists. */
			if (default_opath) {

				/*
					Scan backwards from end of input file name,
					looking for ENV_PATH_SEPARATOR_CHAR.
				*/
				size_t back_count = ilen - 1;
				char * back = in + ilen - 1;
				while(*back != ENV_PATH_SEPARATOR_CHAR &amp;&amp; back_count) {
					back--;
					back_count--;
				}
				if (*back == ENV_PATH_SEPARATOR_CHAR) {
					back++;
				}

				if (default_opath[strlen(default_opath)-1] == ENV_PATH_SEPARATOR_CHAR) {
					new_perm_cat2_macro(out, default_opath, back);
				}
				else {
					new_perm_cat3_macro(out, default_opath, back, ENV_PATH_SEPARATOR_STRING);
				}
			}
			else {
				new_perm_string_macro(out, arg);
			}
			out[strlen(out)-1] = 'o';
			arg_out_path = out;
		}
		else {
			es("Missing -of.  Input file: "); es(arg_in_path); enl();
			end_usage();
		}
	}
	else {
		arg_out_path = out;
	}
	
	if (arg_list_flag &amp;&amp; listing == NULL) {
		/* Create a listing file name from the input file name. */
		size_t ilen = strlen(in);
		if (ilen &gt; 2 &amp;&amp; in[ilen-2] == '.' &amp;&amp; (in[ilen-1] == 'a' || in[ilen-1] == 'A')) {

			/* Prepend the default output path if it exists. */
			if (default_opath) {

				/*
					Scan backwards from end of input file name,
					looking for ENV_PATH_SEPARATOR_CHAR.
				*/
				size_t back_count = ilen - 1;
				char * back = in + ilen - 1;
				while(*back != ENV_PATH_SEPARATOR_CHAR &amp;&amp; back_count) {
					back--;
					back_count--;
				}
				if (*back == ENV_PATH_SEPARATOR_CHAR) {
					back++;
				}

				if (default_opath[strlen(default_opath)-1] == ENV_PATH_SEPARATOR_CHAR) {
					new_perm_cat2_macro(listing, default_opath, back);
				}
				else {
					new_perm_cat3_macro(listing, default_opath, back, ENV_PATH_SEPARATOR_STRING);
				}
			}
			else {
				new_perm_string_macro(listing, arg);
			}
			listing[strlen(listing)-1] = 'l';
			arg_list_path = listing;
		}
		else {
			es("Missing -ol\n");
			end_usage();
		}
	}
	
	if (arg_list_flag &amp;&amp; listing) {
		arg_list_path = listing;
	}

	if (argc &gt; 0) {
		arg_save_argv = argv - 1;
		arg_save_argc = argc + 1;
	}
	else {
		arg_save_argv = NULL;
	}
	return MORE_FILES_REMAIN;

}</t>
<t tx="ekr.20080529093004.135">@ End arg_do_arg
@c

#undef debug_arg_do_argv

/* arg_help: Output a usage message. */

static void
arg_help(void)
{

#ifdef PRODUCTION
	es("\nusage: AS [options] in out\n");
#else
	es("\nusage: ASdb [++--routine] [options] input_file\n");
#endif

	es("\noptions...\n");
	es("+-bell            Make a bell sound\n");
	es("+-cpp             Output results of cpp\n");
	es("+-cpp_only        Exit after cpp is done\n");
	es("-d id=value       Define a preprocessor constant\n");
	es("+-error           Enable error messages\n");
	es("-exit             Terminate option list\n");
	es("+-full_labels     Include local labels in object file\n");
	es("+-line            #line numbers in cpp output\n");
	es("+-list            Create listing file\n");
	es("+-note            Enable notes\n");
	es("+-no_debug        Don't write debugging information\n");
	es("+-no_optimize     Disable optimization of bxx instructions\n");
	es("+-no_output       Disable all output\n");
	es("-of               Specify output file\n");
	es("-ol               Specify name of listing file\n");
	es("-out_path         Specify default path name for output and listing files\n");
	es("-page &lt;n&gt;         Set page length or zero for no paging\n");
	es("+-once            Include header files only once\n");
	es("-s &lt;path&gt;         Look for include files in path\n");
	es("-segment &lt;name&gt;   Set the name of the segment\n");
	es("-u id             Undefine a preprocessor constant\n");
	es("+-v               Verbose output\n");
	es("+-v_include       Verbose include messages\n");
	es("+-v_function      Verbose function messages\n");
	es("+-warning         Enable warning messages\n");
	es("+-warn_bxx        Print a warning for offset that could be made smaller\n");
	es("-?                Print the version number and exit\n");
}
</t>
<t tx="ekr.20080529093004.136">@ arg_prefix: Return TRUE if string p is a prefix of string s.
@c

static bool
arg_prefix(char *p, char *s)
{
	while (*p) {
		if (*p++ != *s++) {
			return FALSE;
		}
	}
	return TRUE;
}
</t>
<t tx="ekr.20080529093004.137">/*
	AS: initialization code.

	source:  ASinit.c
	started: November 4, 1993.
	version: December 18, 1993.
*/

/* Always allow Sherlock macros, especially SL_PARSE. */
#undef NO_SHERLOCK

/* include these *before* Sherlock is included. */

#ifdef applec
	#ifndef __size_t__	/* This is used in the MPW headers. */
  	#define __size_t__
		typedef unsigned long size_t;
	#endif

&lt;&lt; ASinit #includes &gt;&gt;
&lt;&lt; ASinit declarations &gt;&gt;
@others

#endif /* THINK_C */
</t>
<t tx="ekr.20080529093004.138">#include &lt;Memory.h&gt;	/* For MaxApplZone. */
</t>
<t tx="ekr.20080529093004.139">#endif

#ifdef THINK_C

#include &lt;LoMem.h&gt;

#include &lt;Dialogs.h&gt;
#include &lt;Fonts.h&gt;
#include &lt;Menus.h&gt;
#include &lt;Quickdraw.h&gt;
#include &lt;OSEvents.h&gt;
#include &lt;Windows.h&gt;
#endif

#include "AS.h"

#include "ASarg.h"
#include "ASinit.h"
#include "ASmain.h"
#include "ASmem.h"
#include "ASmst.h"
#include "AStokens.h"
#include "AStokize.h"

#include &lt;LIBcmnd.h&gt;
#include &lt;LIBend.h&gt;
#include &lt;LIBenv.h&gt;
#include &lt;LIBlog.h&gt;
#include &lt;LIBobj.h&gt;

#ifdef THINK_C
#include &lt;mac_about_dialog.h&gt;
#include &lt;mac_gui.h&gt;
#endif

/*
Function prototypes for internal routines.
The call-back routines are only needed when windows are used.
*/
#ifdef THINK_C
static void dump1_call_back	(void);
static void dump2_call_back	(void);
static void dump3_call_back	(void);
static void	event_call_back	(void);
</t>
<t tx="ekr.20080529093004.140">#endif

/*
	Initialize the environment, Sherlock and all modules.

	The argv vector is not used in some environments, so it is possible
	that a compiler could generate a warning to that effect,
	but trying to eliminate that warning would not be wise:
	we definitely want all initialization done by a single routine.
*/
void
init_all(int argc, char ** argv)
{
	FTAG("init_all");

/*
	When using Think C, we must completely initialize the Mac Toolbox,
	since we are building a stand-along application.

	When using MPW, we must *not* initialize the Toolbox, nor call MaxApplZone.
	Also, we do *not* call InitGraf, since Sherlock uses standard io under MPW.
*/

#ifdef THINK_C

	void * ApplLimit1;		/* Original values before heap and stack are changed. */
	void * CurStackBase1;
	void * HeapEnd1;
	void * ApplZone1;

	/*
		Initialize the ToolBox routines.

		Warning:

		*never* put anything before the follwing instructions.
		Even an inocuous-looking routine like tok_init will crash MaxApplZone().
	*/
	InitGraf( (Ptr) &amp;(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent,0);
	InitWindows();
	InitMenus();
	TEInit();
	InitDialogs(0L);
	InitCursor();

	/* These are defined in LoMem.h, which only exists for Think C. */
	ApplLimit1 = ApplLimit;
	CurStackBase1 = CurStackBase;
	HeapEnd1 = HeapEnd;
	ApplZone1 = ApplZone;

	SetApplLimit( (Ptr)(CurStackBase - 9000));
	MaxApplZone();
	
#endif

	/*
		Initialize the memory manager.
		This can and should be done before all other initializations.
	*/
	perm_life	= mem_init_life("perm lifetime");
	file_life	= mem_init_life("file lifetime");
	expand_life	= mem_init_life("macro expansion lifetime");
	token_life	= mem_init_life("token lifetime");
	
		/* Statistics for file lifetime. */

	anode_stats =			mem_init_stats (file_life, "anodes");
	cnode_stats =			mem_init_stats (file_life, "cnodes");
	enode_stats =			mem_init_stats (file_life, "enodes");
	keyword_spell_stats =	mem_init_stats (file_life, "keyword nodes");	
	spell_stats =			mem_init_stats (file_life, "spell nodes");	
	string_stats =			mem_init_stats (file_life, "strings");
	other_file_stats =		mem_init_stats (file_life, "all other");
	
	bxx_stats =		mem_init_stats (file_life, "bxx nodes");
	cpp_stats =		mem_init_stats (file_life, "cpp nodes");
	err_stats =		mem_init_stats (file_life, "err nodes");
	macro_stats =	mem_init_stats (file_life, "macro nodes");
	
	area_stats =	mem_init_stats (file_life, "area nodes");
	comment_stats =	mem_init_stats (file_life, "comment nodes");
	dc_val_stats =	mem_init_stats (file_life, "dc val nodes");
	dict_stats =	mem_init_stats (file_life, "dict nodes");
	ref_stats =		mem_init_stats (file_life, "ref nodes");
	unit_stats =	mem_init_stats (file_life, "unit nodes");
		
		/* Statistics for permanent lifetime. */

	perm_arg_stats =	mem_init_stats (perm_life, "args areas");
	perm_macro_stats =	mem_init_stats (perm_life, "macro nodes");
	perm_string_stats =	mem_init_stats (perm_life, "strings");
	other_perm_stats =	mem_init_stats (perm_life, "all other");
		
		/* Statistics for macro expansion lifetime. */
		
	other_expand_stats =mem_init_stats (expand_life, "all other");
	
		/* Statistics for token lifetime. */
	
	id_token_stats =	mem_init_stats (token_life, "id tokens");
	ptr_token_stats =	mem_init_stats (token_life, "ptr tokens");
	small_token_stats =	mem_init_stats (token_life, "small tokens");
	val_token_stats =	mem_init_stats (token_life, "val tokens");
	
#ifdef THINK_C

	/*
		Notice that the Sherlock menu is used only if Sherlock is defined.
	*/
	w_mac_init(
		SL_VERSION_NAME,			/* version name from sl.h. */
		FALSE,						/* Initialize the Macintosh ToolBox. */
		TRUE,						/* TRUE: output to log window. */
		lib_log_window_name,		/* Name of log window. */
		TRUE,						/* TRUE: open Sherlock window. */
		TRUE,						/* TRUE: Insert standard menus.	 */
		SHERLOCK_DEFINED,			/* TRUE: Insert Sherlock menu. */
		TRUE,						/* TRUE: Insert first item in apple menu. */
		lib_about_title,			/* Title of first item in apple menu. */
		&amp;about_dialog,				/* CallBack routine for first apple item. */
		TRUE,						/* TRUE: Insert menus immediately. */
		&amp;event_call_back,			/* Event callback routine. */
		&amp;dump1_call_back,			/* First user callback routine. */
		(pstring) "\pObjects",		/* Name of first user menu item. */
		&amp;dump2_call_back,			/* Second user callback routine. */
		(pstring) "\pObject Stats",	/* Name of second user menu item. */
		&amp;dump3_call_back,			/* Third user callback routine. */
		(pstring) "\pHeap Stats"	/* Name of third user menu item. */
	);

#endif

	/* Sherlock must be initialized now. */
	SL_INIT();

	/*
		Check and initialize the token and opcode description arrays.
		Do this *before* any tokens are used!
	*/
	tok_check();

	/*
		Initialize the macro symbol table before processing user arguments, so
		that constants can be #define'd or #undef'd from the command line.

		Sherlock traces are disabled since Sherlock arguments have not been handled.
	*/
	tok_init_hash_tab();
	mst_init();

	/*
		Process user arguments, including Sherlock arguments.
		No Sherlock traces will be in effect before this point.
	*/
	init_args(&amp;argc, &amp;argv, lib_arg_file_name, "++", "--");

	SL_PARSE(argc, argv, "++", "--");

	STATB(ftag);

	/* Watch location 0.  This test catches *p = x where p is NULL. */
	SL_WATCH(0, 4, "loc 0");

	/* Parse the program arguments. */
	arg_do_argv(argc, argv, "++", "--");

	/* Sign on *after* opening the log file. */
	ecnl(); es(lib_version); ecnl();

	TRACEPN("-show_args",

		int i = 0;
		ecnl();
		while (argv[i]) {
			es("argv["); eint(i); es("]: "); es(argv[i]); enl();
			i++;
		}
	);

#define line(a) epads(#a,14); epadptr(a ## 1, 10); epadptr(a, 10); enl();

	#ifdef THINK_C
		TRACEN("-zone",
			void * Sp = env_stackPtr();
			ecnl();
			epads(" ", 14); epads("Before", 10); epads("After", 10); enl();
			line(CurStackBase);
			line(ApplLimit);
			line(HeapEnd);
			line(ApplZone);
			enl();
		);
	#endif

#undef line

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.141">@ The call-back routines are only needed when windows are used.
@c

#ifdef THINK_C

/*
	"Call-back" routines for event processing when Sherlock outputs a line.
*/
static void
event_call_back(void)
{
	SL_DISABLE();

	#ifdef THINK_C
		if (w_applEvent(0) == FALSE) {
			end_quit();
		}
	#endif
}
</t>
<t tx="ekr.20080529093004.142">static void
dump1_call_back(void)
{
	SL_DISABLE();

	#ifndef PRODUCTION
		ecnls(2);
		obj_dump_objects("Sherlock User Report");
	#endif

	ecnl();
}
</t>
<t tx="ekr.20080529093004.143">static void
dump2_call_back(void)
{
	SL_DISABLE();

	#ifndef PRODUCTION
		ecnls(2);
		obj_dump_stats("Sherlock User Report: ");
		ecnl();
	#endif

	ecnl();
}
</t>
<t tx="ekr.20080529093004.144">static void
dump3_call_back(void)
{
	SL_DISABLE();

	#ifndef PRODUCTION
		ecnls(2); es("Sherlock User Report: ");
		env_dump_stats();
		ecnl();
	#endif
}
</t>
<t tx="ekr.20080529093004.145">/*
	AS: Main routines and globals.

	source:  ASmain.c
	started: September 22, 1993.
	Version:
		January 25, 1995.
			Allow sizeof(long double) != LONG_DOUBLE_SIZE if LONG_DOUBLE_SIZE == DOUBLE_SIZE.
		November 4, 1994.
			Move tests to Tuple Test Bed.
		March 21, 1994.
			Added better statistics to main_asm.
				Output stats now include time to open and close file.
			Added verbose messages for listing and object output phases.
		March 7, 1994.
			Added support for error nodes in file listings.
		February 24, 1994.
			Removed calls to st_init and st_dump.
		February 13, 1994.
			Added main_listing.
		January 26, 1994.
			Add call to st_init.
		December 23, 1993.
			Eliminate skip_block_list.
		November 27, 1993.
			Added ++dummy_out logic.
		November 8, 1993.
			All driver routines merged into this file.
*/

/* Always allow Sherlock macros in this file. */
#undef NO_SHERLOCK

&lt;&lt; ASmain #includes &gt;&gt;
&lt;&lt; ASmain declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.146">#include "AS.h"

#include "ASarg.h"
#include "ASasm.h"
#include "AScnodes.h"
#include "AScpp.h"
#include "ASinit.h"
#include "ASmacro.h"
#include "ASmain.h"
#include "ASmem.h"
#include "ASmst.h"
#include "ASpass12.h"
#include "ASofile.h"
#include "ASparse.h"
#include "ASsem.h"
#include "AStarget.h"
#include "AStokens.h"
#include "AStokize.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBenv.h&gt;
#include &lt;LIBio.h&gt;
#include &lt;LIBlist.h&gt;
#include &lt;LIBmath.h&gt;
#include &lt;LIBobj.h&gt;
#include &lt;LIBos.h&gt;

#include &lt;time.h&gt;
</t>
<t tx="ekr.20080529093004.147">/*
	Prototypes of internal routines.
*/
static void list_onl		(short *page_line, short *page_number);
static void main_asm		(void);
static void main_dump_block	(io_mem_block *block);
static void	main_free_all	(void);
static void	main_listing	(void);
static void	main_output		(void);
static void	main_report		(void);

/*
	Local variables of this module.
*/
static char *	asm_file_name = NULL;	/* Name of current file. */
static long		asm_files = 0;	</t>
<t tx="ekr.20080529093004.148">@ Number of files assembled.
The main line of the program...
@c

void
main(int argc, char **argv)
{
	/* Calls to Sherlock from this routine just distort statistics. */
	SL_DISABLE();

	#if 0 /* Remember: this will not work if the Think C debugger is on. */
		DebugStr("\pmain");
	#endif

	/* Absolutely *no* calls to Sherlock before init_all is called! */
	init_all(argc, argv);
	
	/*
		Make sure we have compiled the file with the correct settings.
		1/24/95:
			Allow sizeof(long double) != LONG_DOUBLE_SIZE if LONG_DOUBLE_SIZE == DOUBLE_SIZE.
			This is required to work around inflexibilities of Think C's settings.
			The idea is that the code will never generate long double constants in this case.
	*/
	if (
		sizeof(float) != FLOAT_SIZE ||
		sizeof(short double) != DOUBLE_SIZE ||
		(sizeof(long double) != LONG_DOUBLE_SIZE &amp;&amp; LONG_DOUBLE_SIZE != DOUBLE_SIZE)
	) {
		fatal(es("wrong floating sizes"));
	}

	/* Assemble each file in turn. */
	while (arg_in_path) {
		main_asm();
		main_report();
		if (arg_do_argv(0, NULL, NULL, NULL) != MORE_FILES_REMAIN) {
			break;
		}
	}

	/* Report statistics and exit. */
	main_quit();
	end_done();
}
</t>
<t tx="ekr.20080529093004.149">@ Completely assemble one source file and create the output file.
@c

void
main_asm(void)
{
	FTAG("main_asm");
	io_mem_block * input_block = NULL;
	long token_length = 0L;
	char * p = NULL;

	/* Disable context messages until the preprocessor is finished. */
	err_context_flag = FALSE;

	/*
		We can't call asm_free_all here because the macro table
		has already been initialized.
	*/

	/* Update the global description variables. */
	asm_files++;
	err_init_again();	/* Bug fix: 4/23/94. */
	err_begin_file(arg_in_path);
	asm_file_name = err_file_name();

	/* Assembler main line. */

	/*
		Open the input file.
		In the call to io_read_pad_all, lead_char (' ') can be anything except backslash.
	*/
	input_block = io_read_pad_all(arg_in_path, 1, ' ', 3 , IO_EOF_CHAR,
		NO_CANT_MESSAGE, IO_TEXT_FILE);

	if (input_block == NULL) {
		/* Always report this error. */
		force_error(es("Can not open "); es(arg_in_path));
		return;
	}

	if (err_verbose) {
		ecnl();
		if (arg_no_cpp_flag) {
			es("Tokenizing    ");
		}
		else {
			es("Preprocessing ");
		}
		es(asm_file_name); es("...\n");
	}

	/* Make sure the file ends in a physical newline. */
	p = input_block -&gt; mem_start;

	/* Allow either '\n' or '\r'. */
	if (
		p [input_block -&gt; mem_length -1] != '\n' &amp;&amp;
		p [input_block -&gt; mem_length -1] != '\r'
	) {
		p [input_block -&gt; mem_length] =  '\n';
		input_block -&gt; mem_length++;
		TRACEP(ftag, es("trailing newline added\n"));
	}

	/*
		Pass 1: Eliminate trigraphs and backslash newlines.
	*/
	compress(input_block);
	TRACE("-main_block_dump", main_dump_block(input_block));

	/*
		Pass 2: Create token blocks and the spelling table.
	*/

	tok_first_token = tokize(input_block, NULL, err_fname, END_WITH_EOF_TOK, NULL);

	/* The input block can be freed directly after tokize is finished. */
	obj_free_macro(input_block -&gt; mem_freep);
	obj_free_macro(input_block);

	TRACE("-asm_tdump1",	tok_dump(tok_first_token, DONT_PRINT_HIDDEN_TOKS));
	TRACE("-asm_tdump_all1",tok_dump(tok_first_token, PRINT_HIDDEN_TOKS));

	/* Preprocess the token block. */
	if (!arg_no_cpp_flag) {
		tok_first_token = cpp(tok_first_token);
	

		/* Handle +cpp option command-line option. */
		if (arg_cpp_flag) {
			tok_dump(tok_first_token, DONT_PRINT_HIDDEN_TOKS);
		}
	}

	/* Enable context messages now that the preprocessor is finished. */
	err_context_flag = TRUE;

	/* CPP dumps. */
	TRACE("-main_tok_dump",	tok_dump(tok_first_token, PRINT_HIDDEN_TOKS));

	/* Handle +cpp_only command-line option. */
	if (arg_cpp_only_flag) {
		goto done;
	}

	/* Assemble the program! */
	if (err_verbose) {
		ecnl(); es("Assembling    "); es(err_file_name()); es("...\n");
	}
	sem_begin();
	par_program();
	sem_end();
	
	/* Output the object file. */
	if (arg_out_path &amp;&amp; !arg_no_out_flag) {
		if (err_count == 0) {
			main_output();
		}
		else {
			TRACEPN("force_output", main_output());
		}
	}
	
	if (arg_list_flag &amp;&amp; arg_list_path &amp;&amp; !arg_no_out_flag) {
		if (err_verbose) {
			ecnl(); es("Writing       "); es(arg_list_path); es("...\n");
		}
		main_listing();
	}

	/* Free all data structures with file lifetime. */
done:
	main_free_all();

	/* Print statistics. */
	TRACE("-asm_io_stats",
		ecnls(2); es("io_read_chars: ");
		elong(io_read_chars); es(" total characters\n"));
	TRACE("-asm_sl_dump",		SL_DUMP());
	TRACE("-asm_object_stats",	obj_dump_stats(ftag));
}
</t>
<t tx="ekr.20080529093004.150">@ Print a memory block.
@c

static void
main_dump_block (io_mem_block * block)
{
	register int i;
	register char * p = block -&gt; mem_start;

	for (i = 0; i &lt; block -&gt; mem_length; i++) {
		echar(*p++);
	}
}
</t>
<t tx="ekr.20080529093004.151">@ Free all assembler data structures that can be freed after one source file has been completely assembled.  Data with permanent lifetime must *not* be freed here!  This routine can only work properly if *all* aspects of memory allocation are correct. The acid test is whether AS can assemble 2 files without crashing.  WARNING: Add *nothing* to this routine without making sure that AS can assemble 2 files.
@c

static void
main_free_all(void)
{
	FTAG("main_free_all");
	STATB(ftag);

	/* Free all all blocks with file and token lifetimes. */
	mem_free_life(file_life);
	mem_free_life(token_life);

	/* Re-initialize all global lists. */
	mac_mdef_list = NULL;
	tok_first_token = NULL;

	/*
		Reinitialize the hash table.
		This must be done here, *before* processing additional command-line args.
	*/
	tok_init_hash_tab();

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.152">@ Output the map file, if requested.  A hack simplifies this code: each newline token points to the cnode created from the line. Thus, both the source line and generated code can easily be printed. The par_program function attaches the cnode to the newline token.
@c

static void
main_listing(void)
{
	FTAG("main_listing");
	register token * tp = tok_first_token;
	register token * end_p = NULL;
	register cnode * cp = NULL;
	register err_node * err_p = NULL;
	ulong prev_lc = 0;
	ulong the_line = 0;
	short page_line = 0;
	short page_number = 1;
	STATB(ftag);
	
	/* Open the listing file. */
	ASSERT(os_text_file == NULL);
	os_text_file = io_create(arg_list_path, FALSE, IO_TEXT_FILE);
	if (os_text_file == NULL) {
		force_error(es("Can not create "); es(arg_list_path));
		goto done;
	}
	
	/*
		Reverse the global list of error nodes so they will appear in
		order of ascending line numbers.
	*/
	lst_reverse_macro(err_node_list, err_node);
	err_p = err_node_list;

	/* Point tp at the first line. */
	tp = tok_skip_hidden(tok_first_token);
	
	/* Print the initial header. */
	if (arg_page_length &gt; 0) {
		list_onl(&amp;page_line, &amp;page_number);
	}
	
	/* Print every line of the file. */
	while (tp &amp;&amp; *tp != END_PROG_TOK) {
	
		/*
			Scan to the newline ending the current line.
			Print any node attached to the newline.
		*/
		ASSERT(*tp == WS_NL_TOK || *tp == HIDDEN_NL_IN_COMMENT_TOK);
		end_p = tp;
		next_raw_tok(end_p);
		next_raw_tok(tp);
		the_line++;

		while(
			end_p &amp;&amp;
			*end_p != WS_NL_TOK &amp;&amp; *end_p != HIDDEN_NL_IN_COMMENT_TOK &amp;&amp;
			*end_p != END_PROG_TOK &amp;&amp; *end_p != HIDDEN_END_FILE_TOK
		) {
			next_raw_tok(end_p);
		}

		/*
			Print the error message and go on to the next error node.
			More than one error can be associated with the line because
			errors arise during several passes.
		*/
		while (err_p &amp;&amp; err_p -&gt; err_line == the_line) {
			os(err_p -&gt; err_message); list_onl(&amp;page_line, &amp;page_number);
			err_p = err_p -&gt; next;
		}
		
		/* Point cp at the node describing the instruction or pseuod op. */
		cp = ( (*end_p == WS_NL_TOK) ? cnode_ptr(ptr_tok_ptr(end_p)) : NULL);

		if (cp) {
		
			/* Print the bit field. */
			opadhex(cp -&gt; c_lc,5); oblank();
			ocnode_bits(cp, cp -&gt; c_lc);
			prev_lc = cp -&gt; c_lc;
		}
		else {
		
			/* Print blanks as placeholders for the bit field. */
			oblanks(6);
			ocnode_bits(NULL, prev_lc);
		}

		/*
			Print the source line.
			This code is a modified form of tok_dump_line2.
		*/
		tp = tok_out_line(tp);
		list_onl(&amp;page_line, &amp;page_number);
	}
	
	/* No more error messages should remain. */
	ASSERT(err_p == NULL);
	
	/* Close the listing file. */
	io_close(os_text_file);
	os_text_file = NULL;

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.153">@ Print the header on the start of each page.
@c

static char *monthname[] = {
	"January", "February", "March", "April", "May", "June",
	"July", "August", "September", "October", "November", "December"
};

static char *dayname[] = {	/* Days since Sunday */
	"Sunday", "Monday", "Tuesday", "Wednesday",
	"Thursday", "Friday", "Saturday"
};

static void
list_onl(short *page_line, short *page_number)
{
	FTAG("list_onl");
	STATB(ftag);
	
	/* Write the header at the start of each page. */
	if (arg_page_length &gt; 10 &amp;&amp; ((*page_line) % arg_page_length) == 0) {
			
		if (*page_number &gt; 1) {
			onl(); onl();

		}
		os("Tuple Assembler: ");
		
		/* Print the date and time. */
		{
			time_t	ltime;
			struct tm * t = NULL;
			
			/* Put the "broken down" time into t. */
			time(&amp;ltime);
			t = localtime(&amp;ltime);
			
			/* Print the day of the week and the month */
			os(dayname[t -&gt; tm_wday]); os(", ");
			os(monthname[t -&gt; tm_mon]); oblank();
			
			/* Print the day of the month and the year. */
			oulong(t -&gt; tm_mday); os(", ");
			oulong(1900 + t -&gt; tm_year);
			
			/* Print the hour and minute. */
			os(", at ");
			oulong( (t -&gt; tm_hour) % 12);
			os(":"); 
			if (t -&gt; tm_min &lt; 10) {
				os("0");
			}
			oulong(t -&gt; tm_min);
			os( (t -&gt; tm_hour &lt; 12) ? " a.m." : " p.m.");
			onl();
		}	
		
		os("Page: "); oulong(*page_number); onl();
		onl();
		(*page_line) += 3;
		(*page_number)++;
		/* Allow space for a blank line at the end of the page. */
		*(page_line) += 2;
	}
	else {
		onl();
		(*page_line)++;
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.154">@ Output the object file.
@c

static void
main_output(void)
{
	FTAG("main_output");
	STATB(ftag);
	
	if (err_verbose) {
		ecnl(); es("Writing       "); es(arg_out_path); es("...\n");
	}

	/* Open the object file. */
	ASSERT(os_bytes_file == NULL);
	os_bytes_file = io_create(arg_out_path, FALSE, IO_BINARY_FILE);
	
	if (os_bytes_file == NULL) {
		force_error(es("Can not create "); es(arg_out_path));
	}
	else {

		/* Write the file and close it. */
		out_ofile();
		io_close(os_bytes_file);
		os_bytes_file = NULL;
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.155">@ Free all dynamic structures and do end-of-program reporting.  This routine is called on normal termination and also by lib_quit when the user interrupts the assembly.
@c

void
main_quit(void)
{
	/* Free all paths, path names and argument strings. */
	mem_free_life(file_life);
	mem_free_life(perm_life);

	/* Give various reports. */
	TRACE("-quit_mem_stats",
		mem_life * mlp = NULL;
		for (mlp = mem_life_list; mlp; mlp = mlp -&gt; mem_life_list) {
			mem_dump_stats(mlp, DONT_DUMP_CURRENT_STATS);
		}
	);

	TRACEP("-quit_env_stats",	env_dump_stats());
	TRACEP("-quit_sl_dump", sl_dump());

	TRACEP("-quit_obj_stats",	obj_dump_stats("main_dumps"));
	TRACEP("-quit_obj_objects",	obj_dump_objects("main_dumps"));

	TRACEP("-quit_report",

		sl_dump_start();
		sl_dump_header(TRUE);

		/* Initialization. */
		sl_dump_subtotal_start();
			sl_dump_name("main_init");
			sl_dump_name("init_all");
		sl_dump_subtotals();

		/* I/O. */
		sl_dump_subtotal_start();
			sl_dump_name("io_close");
		    sl_dump_name("io_close_all");
			sl_dump_name("io_close_stream");
			sl_dump_name("io_open");
			sl_dump_name("io_read");
			sl_dump_name("io_read_all");
			sl_dump_name("io_write");
		sl_dump_subtotals();

		/* Preprocessing. */
		sl_dump_subtotal_start();
			sl_dump_name("compress");
			sl_dump_name("tokize");
			sl_dump_name("cpp");
			sl_dump_name("inner_cpp");
			sl_dump_name("skip_lines");
			sl_dump_name("skip_past");
			sl_dump_name("mac_define");
			sl_dump_name("mac_define_string");
		sl_dump_subtotals();

		/* Expressions. */
		sl_dump_subtotal_start();
			sl_dump_name("expr_cprim");
			sl_dump_name("expr_prim");
			sl_dump_name("expr_value");
		sl_dump_subtotals();

		/* The main assembly loop. */
		sl_dump_subtotal_start();
			sl_dump_name("par_am");
			sl_dump_name("par_next_line");
			sl_dump_name("par_program");
			sl_dump_name("par_size");
			sl_dump_name("par_xtok");
			sl_dump_name("peudo");
			sl_dump_name("sem_end");
		sl_dump_subtotals();

		/* Storage allocation. */
		sl_dump_subtotal_start();
			sl_dump_name("obj_new");
			sl_dump_name("obj_new_db");
			sl_dump_name("obj_free_db");
		    sl_dump_name("obj_free_check");
			sl_dump_name("asm_free_all");
		sl_dump_subtotals();

		sl_dump_totals();
	);
}
</t>
<t tx="ekr.20080529093004.156">@ Report any hidden errors, but only in vervose mode.
@c

static void
main_report(void)
{
	FTAG("main_report");
	STATB(ftag);

	if (err_verbose) {

		if (!err_err_flag &amp;&amp; err_count) {
			ecnl(); elong (err_count);
			es(" error"); es( (err_count == 1) ? " was" : "s were");
			es(" detected but not reported.\n");
		}

		if (!err_warn_flag &amp;&amp; err_warning) {
			ecnl(); elong (err_warning);
			es(" warning");es( (err_warning == 1) ? " was" : "s were");
			es(" detected but not reported.\n");
		}

		if (!err_help_flag &amp;&amp; err_help) {
			ecnl(); elong (err_help);
			es(" note"); es( (err_help == 1) ? " was" : "s were");
			es(" detected but not reported.\n");
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.157"></t>
<t tx="ekr.20080529093004.158"></t>
<t tx="ekr.20080529093004.159">/*
	AS: header file for ASend.c.

	source:  ASend.h
	started: December 13, 1993.
	version: January 7, 1994.
*/

#ifndef ASend_h_
#define ASend_h_

#pragma once

void end_close_all	(void);

#endif /* ASend_h_ */</t>
<t tx="ekr.20080529093004.160">/*
	AS: Header file for ASerr.c.

	source:  ASerr.h
	started: January 7, 1994.
	version:
		March 7, 1994.
			Added support for buffering error messages.
			Defined err_nodes.
*/

#ifndef ASerr_h_
#define ASerr_h_

#pragma once

	/* Types. */
	
typedef struct err_node_struct err_node;

struct err_node_struct {

	err_node *	next;			/* The next item in the list of err nodes. */
	char *		err_message;	/* The error message. */
	ulong		err_line;		/* The line containing the error message. */
};

	/* 
		Application-specific error reporting macros.
		error and fatal are defined in LIBdebug.h
	*/

#define help(stat)		if(help_begin()) { stat; err_context(); }
#define user_fatal(stat){user_fatal_begin(); stat; user_fatal_end();}
#define warning(stat)	if(warn_begin()) { stat; err_context(); }

	/* Use line instead of err_line. */

#define delayed_error(line, stat)\
	{long save=err_line; err_line=line; error(stat); err_line = save;}
#define delayed_help(line, stat)\
	{long save=err_line; err_line=line; help(stat); err_line = save;}
#define delayed_warning(line, stat)\
	{long save=err_line; err_line=line; warning(stat); err_line = save;}

	/* Give error regardless of err_err_flag. */

#define force_error(stat)\
	{bool save=err_err_flag; err_err_flag=TRUE; error(stat); err_err_flag = save;}

#ifdef PRODUCTION
	#define DEBUG(a)
#else
	#define DEBUG(a) a
#endif

/*
	Function prototypes.
	Some of these are also defined in LIBdebug.h
*/

	/* Routines called by macros in this file. */

bool	err_begin			(void);
void	fatal_begin			(void);
void	fatal_end			(void);
bool	help_begin			(void);
void	user_fatal_begin	(void);
void	user_fatal_end		(void);
bool	warn_begin			(void);

void	es_assert_failed	(char * condition, int line, char * file);
void	err_context			(void);
void	es_internal_err		(char * condition, int line, char * file);
void	err_lines			(long the_line, int lead_context, int trail_context);

	/* Other routines in ASerr.c */

void	err_begin_file	(char * file_name);
void	err_begin_func	(char * func_name);
char *	err_file_name	(void);
void	err_init		(void);
void	err_init_again	(void);
/*
	Global variables defined in ASerr.c.
*/

extern long		err_count;			/* Error counts... */
extern long		err_help;
extern long		err_warning;
extern bool		err_err_flag;		/* Enable message flags... */
extern bool		err_fatal_flag;
extern bool		err_help_flag;
extern bool		err_warn_flag;
extern long		err_line;			/* Current line number. */
extern long		err_line_offset;	/* Current line offset. */
extern int		err_pass;			/* Current pass number. */
extern bool		err_verbose;		/* Verbose flag. */
extern char *	err_fname ;			/* Current file name. */
extern char *	err_func_name;		/* Current function name. */
extern bool		err_context_flag;	/* TRUE: print context of errors. */

extern err_node * err_node_list;	/* List of error nodes. */

#endif /* ASerr_h_ */
</t>
<t tx="ekr.20080529093004.161">/*
	AS: header file for application-specific routines.
	
	source:  ASes.h.
	started: March 7, 1994.
	version: March 7, 1994.
*/

#ifndef ASes_h_
#define ASes_h_

#pragma once

/*
	Define the buffer used capture error messages for use in the listing file.
	
	A fixed-sized buffer is used since we can't predict the size of an error message.
*/

#define ES_ERR_BUFFER_SIZE 120

extern bool		es_err_buffer_flag;	/* TRUE: buffer characters into err_buffer. */
extern char *	es_err_buffer;		/* Fixed-sized buffer for error messages. */
extern short	es_err_buf_count;	/* Number of characters in es_err_buffer. */

/*
	The function prototype for es also appears in LIBes.h.
*/

void es (char * s);

#endif /* ASes_h_ */</t>
<t tx="ekr.20080529093004.162">/*
	AS: Application-specific memory allocation macros and routines.
		See LIBmem.h for general memory allocation macros and routines.
		
		ASmem.h and LIBmem.h own the suffixes _life and _stat and
		the prefixes mem_ and new_.

	source:  ASmem.h
	started: September 22, 1993.
	version:
		February 3, 1995.
			Added comment_stats.
		April 5, 1994.
			All macros revised to used the sizeof(*var) technique.
			Abbreviation macros added.
*/

#ifndef ASmem_h_
#define ASmem_h_

#pragma once

#include &lt;LIBmem.h&gt;

#include &lt;string.h&gt; 

/*
	Abbreviations.
*/

#define new_file_macro(p, stats)	new_macro(p,file_life,stats)
#define new_perm_macro(p, stats)	new_macro(p,perm_life,stats)
#define new_expand_macro(p, stats)	new_macro(p,expand_life,stats)

#define new_file_cat2_macro(p,s1,s2)	new_cat2_macro(p,s1,s2,file_life,string_stats)
#define new_perm_cat2_macro(p,s1,s2)	new_cat2_macro(p,s1,s2,perm_life,perm_string_stats)

#define new_perm_cat3_macro(p,s1,s2,s3)	   new_cat3_macro(p,s1,s2,s3,perm_life,perm_string_stats)
#define new_perm_cat4_macro(p,s1,s2,s3,s4) new_cat4_macro(p,s1,s2,s3,s4,perm_life,perm_string_stats)
	
#define new_file_string_macro(p,s1)	new_string_macro(p,s1,file_life,string_stats)
#define new_perm_string_macro(p,s1) new_string_macro(p,s1,perm_life,perm_string_stats)

/*
	General allocation macros.

	These macros are the fundamental lifetime-based storage allocation macro.

	This macro is used by the tokenizer, and must be as fast as possible.
	In particular, the MEM_STATS and MEM_UPDATE_STATS macro must expand to null code
	in the production version; otherwise the performace of the assembler would suffer.
	
	What makes all the new macros simpler *and* safer is the definition of new_macro.
	In particular, using sizeof(*p) istead of the older sizeof(type_name_param)
	*guarantees* that p must be a pointer.
	It also eliminates the possibility of having a macro expand to sizeof(sizeof(x)).
*/

#define new_macro(p, life, stat) \
{\
	ASSERT(sizeof(*p) &gt; 4);\
	new_size_macro(p, sizeof(*p), life, stat);\
}

#define new_size_macro(p, the_size, life, stat) \
{\
	size_t size = the_size;\
	ASSERT(life);\
	MEM_UPDATE_STATS(stat, size);\
	MEM_STATS(life -&gt; mem_cur_nodes ++; life -&gt; mem_cur_bytes += (size));\
	if (size &gt; life -&gt; mem_avail) {\
		p = mem_new_block(size, life);\
	}\
	else {\
		p = life -&gt; mem_ptr;\
		life -&gt; mem_ptr    = (((char *) (life -&gt; mem_ptr)) + size);\
		life -&gt; mem_avail -= size;\
	}\
	/* TRACEP("new", es(life -&gt; name); eptr(p); enl()); */\
}

	/* strings. */

#define new_string_macro(p,s1,the_life,the_stat)\
{\
	ASSERT(s1);\
	new_size_macro(p, strlen(s1)+1, the_life, the_stat);\
	strcpy(p, s1);\
}

#define new_cat2_macro(p,s1,s2,the_life,the_stat)\
{\
	ASSERT(s1 &amp;&amp; s2);\
	new_size_macro(p, strlen(s1)+strlen(s2)+1,the_life,the_stat);\
	strcpy(p, s1);\
	strcat(p, s2);\
}

#define new_cat3_macro(p,s1,s2,s3,the_life,the_stat)\
{\
	ASSERT(s1 &amp;&amp; s2 &amp;&amp; s3);\
	new_size_macro(p, strlen(s1)+strlen(s2)+strlen(s3)+1,the_life, the_stat);\
	strcpy(p, s1);\
	strcat(p, s2);\
	strcat(p, s3);\
}

#define new_cat4_macro(p,s1,s2,s3,s4,the_life,the_stat)\
{\
	ASSERT(s1 &amp;&amp; s2 &amp;&amp; s3 &amp;&amp; s4);\
	new_size_macro(p,strlen(s1)+strlen(s2)+strlen(s3)+strlen(s4)+1,the_life, the_stat);\
	strcpy(p, s1);\
	strcat(p, s2);\
	strcat(p, s3);\
	strcat(p, s4);\
}

/*
	Function prototypes for application-specific routines.
*/
token * mem_new_tok_block	(token * tp, long tavail);

/*
	Define global variables.

	The actual lifetimes used in the program.
	Tokens must have a separate lifetime so token blocks
	will contain only tokens.
*/
extern mem_life * expand_life;	/* Description of macro expansion lifetime. */
extern mem_life * file_life;	/* Description of file lifetime. */
extern mem_life * perm_life;	/* Description of permanent lifetime. */
extern mem_life * token_life;	/* Description of token lifetime. */

extern mem_stat * anode_stats;		/* Statistics nodes... */
extern mem_stat * cnode_stats;
extern mem_stat * enode_stats;
extern mem_stat * keyword_spell_stats;
extern mem_stat * spell_stats;
extern mem_stat * string_stats;

extern mem_stat * bxx_stats;
extern mem_stat * cpp_stats;
extern mem_stat * err_stats;
extern mem_stat * macro_stats;

extern mem_stat * area_stats;
extern mem_stat * comment_stats;
extern mem_stat * dc_val_stats;
extern mem_stat * dict_stats;
extern mem_stat * ref_stats;
extern mem_stat * unit_stats;

extern mem_stat * perm_arg_stats;
extern mem_stat * perm_macro_stats;
extern mem_stat * perm_string_stats;

extern mem_stat * id_token_stats;
extern mem_stat * ptr_token_stats;
extern mem_stat * small_token_stats;
extern mem_stat * val_token_stats;

extern mem_stat * other_expand_stats;
extern mem_stat * other_file_stats;
extern mem_stat * other_perm_stats;

#endif /* ASmem_h_ */
</t>
<t tx="ekr.20080529093004.163"></t>
<t tx="ekr.20080529093004.164">/*
	AS: application-specific program termination module.

	source:  ASend.c
	started: January 7, 1994.
	version: January 7, 1994.
*/

&lt;&lt; ASend #includes &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.165">#include "AS.h"
#include "ASend.h"
#include &lt;LIBos.h&gt;
</t>
<t tx="ekr.20080529093004.166">@ Close all application files. Do not close the log file.
@c

void
end_close_all(void)
{
	FTAG("end_close_all");
	STATB(ftag);

	io_close(os_bytes_file);
	io_close(os_text_file);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.167">/*
	AS: General error handling.

	Source:  ASerr.c
	Started: November 8, 1993.
	Version:
		April 7, 1994.
			All error nodes now have file lifetime.
		March 7, 1994.
			Added support for buffering error messages.
		December 21, 1993.
			Replaced str_alloc_macro logic with new_xxx_string_macro logic.
*/

&lt;&lt; ASerr #includes &gt;&gt;
&lt;&lt; ASerr declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.168">#include "AS.h"

#include "ASarg.h"
#include "ASes.h"
#include "ASmem.h"
#include "AStokens.h"
#include "AStokize.h"

#include &lt;LIBend.h&gt;

#include &lt;stdlib.h&gt;	/* For abort. */
#include &lt;string.h&gt; /* For strlen. */
</t>
<t tx="ekr.20080529093004.169">/*
	Define global status variables.
*/
long	err_count = 0;				/* Error counts... */
long	err_help = 0;
long	err_fatal = 0;
long	err_warning = 0;
bool	err_err_flag = TRUE;		/* Enable message flags... */
bool	err_fatal_flag = TRUE;
bool	err_help_flag = TRUE;
bool	err_warn_flag = TRUE;
long	err_last_line = -1;			/* Line number of last error. */
long	err_line = 0;				/* Current line number. */
long	err_line_offset = 0;		/* Current line offset. (set by #line) */
int		err_pass = 0;				/* Current pass number. */
bool	err_verbose = FALSE;		/* Verbose flag. */
char *	err_fname = NULL;			/* Current file name. */
char *	err_func_name = NULL;		/* Current function name. */
bool	err_context_flag = FALSE;	/* TRUE: print context of errors. */

err_node * err_node_list = NULL;	/* List of error nodes. */

/*
	Function prototypes internal routines.
*/
static void	err_begin_mess	(char * message);

/*
	Define internal variables.
*/
static bool err_abort_flag = FALSE;
</t>
<t tx="ekr.20080529093004.170">@ Initialize all the internal variables declared above.
@c

void
err_init_again(void)
{
	FTAG("err_init_again");
	STATB(ftag);

	err_func_name = NULL;

	err_line = 0;
	err_line_offset = 0;
	err_pass = 0;

	err_count = 0;
	err_help = 0;
	err_warning = 0;
	
	es_err_buffer_flag = FALSE;
	err_node_list = NULL;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.171">@ Set the file name used in error message. The file name will exist until the end of compile.
@c

void
err_begin_file (char * file_name)
{
	FTAG("err_begin_file");
	STATB(ftag);

	new_file_string_macro(err_fname, file_name);
	err_func_name = NULL;
	err_last_line = -1;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.172">@ Set the file name for the duration of the file lifetime.
@c

void
err_begin_func (char * func_name)
{
	FTAG("err_begin_func");
	STATB(ftag);

	new_file_string_macro(err_func_name, func_name);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.173">@ Output the common start of an error message.
@c

#define F_WIDTH 10

static void
err_begin_mess(char * message)
{
	register char * name = (err_func_name == NULL) ? "no function" : err_func_name;

	ecnls(2);
	epads(message, 8);
	es(" line: "); epadlong(err_line+err_line_offset, 4); es(" ");
	epads(err_file_name(), 10);
	es(" ("); etrunc(name, F_WIDTH); es(") ");
	epadlen(strlen(name), F_WIDTH);

	/* Put error message on new line. */
	ecnl();
	
	/*
		Begin buffering the error message if a listing will be made.
		Careful: there may be no tokens yet.
	*/
	if (
		err_context_flag &amp;&amp; tok_first_token &amp;&amp;
		arg_list_flag &amp;&amp; arg_list_path &amp;&amp; !arg_no_out_flag
	) {
		es_err_buffer_flag = TRUE;
		if (es_err_buffer == NULL) {
			/*
				Bug fix: 4/25/94:
				Either use perm life or set es_err_buffer to NULL when
				the current' file's lifetime is finished.
								
				Failure to do either caused a nasty pointer bug:
				es_err_buffer pointed into the allocation area for file lifetime.
				An error message set the "error buffer" which clobbered
				some innocent node with file lifetime.

				This bug was an example of a dangling *explict* pointer.
				Explicit pointers have to be set to NULL by hand when
				their lifetime is over.
				Implicit pointers (nameless pointers) automatically
				become inaccessible when their lifetime is over.
				
			*/
			new_size_macro(es_err_buffer, ES_ERR_BUFFER_SIZE, perm_life, err_stats);
		}
		es_err_buf_count = 0;
		
		/* Copy the header message (error, warning, etc.) into the buffer. */
		ASSERT(strlen(message) &lt; ES_ERR_BUFFER_SIZE-10);
		strcpy(es_err_buffer, "**** ");
		strcat(es_err_buffer, message);
		es_err_buf_count = strlen(es_err_buffer);
		es_err_buffer[es_err_buf_count++] = ' ';
		es_err_buffer[es_err_buf_count] = '\0';
	}
}
</t>
<t tx="ekr.20080529093004.174">@ Print the context of an error, using err_line and err_file_name.
@c

#define CONTEXT_WIDTH 4	/* Width of the line number field. */

void
err_context(void)
{
	SL_DISABLE();
	
	err_lines(err_line, 2, 2);
}
</t>
<t tx="ekr.20080529093004.175">void
err_lines(long the_line, int lead_context, int trail_context)
{
	FTAG("-err_context");
	register token *tp = NULL;
	register int lead_lines = 0;
	register int trail_lines = 0;
	register int i = 0;
	long actual_line = 0;
	bool update_save = tok_update_flag;
	STATB(ftag);

	/*
		End the error message with a period and a newline.
		Doing this here makes the error macros shorter.
		
		Halt the buffering of the error message just after the period.
		es_err_buffer_flag will be TRUE here only if a listing will be made.
	*/
	es(".");
	if (es_err_buffer_flag) {
		err_node * ep = NULL;
		char * message = NULL;
		es_err_buffer_flag = FALSE;
		
		/* Copy the error buffer into a node with file lifetime. */
		new_file_string_macro(message, es_err_buffer);

		/* Create an error node describing the error. */
		new_file_macro(ep, err_stats);
		ep -&gt; err_message = message;
		ep -&gt; err_line = err_line;
		
		/*
			Insert the error node into the global error list,
			so that nodes are sorted by line number with
			the highest line numbers at the head of the list.
			
			This sorting is necessary because errors can arise during
			parsing and during later semantic passes.
		*/
		if (err_node_list == NULL || err_node_list -&gt; err_line &lt;= err_line) {
		
			/* Put the new node at the head of the list. */
			ep -&gt; next = err_node_list;
			err_node_list = ep;
		}
		else {
		
			/* Set ep_prev to the node that will preceed ep in the list. */
			err_node * ep_prev = err_node_list;
			ASSERT(ep_prev);
			while (ep_prev -&gt; next &amp;&amp; ep_prev -&gt; next -&gt; err_line &gt; err_line) {
				ep_prev = ep_prev -&gt; next;
			}
			
			/* Insert ep before ep_prev. */
			ep -&gt; next = ep_prev -&gt; next;
			ep_prev -&gt; next = ep;
			
			ASSERT(
				ep_prev -&gt; err_line &gt;= ep -&gt; err_line &amp;&amp;
				(
					ep_prev -&gt; next == NULL ||
					ep -&gt; err_line &gt;= ep_prev -&gt; next -&gt; err_line
				));
		}
	}
	enl();

	/* Careful: there may be no tokens yet. */
	if (!err_context_flag || tok_first_token == NULL) {
		STATX(ftag);
		return;
	}

	/* Disable the updating of line numbers. */
	tok_update_flag = FALSE;

	if (the_line &lt;= 1 || lead_context &lt; 0) {
		lead_lines = 0;
	}
	else if (the_line &lt;= lead_context) {
		lead_lines = the_line - 1;
	}
	else {
		lead_lines = lead_context;
	}
	trail_lines = trail_context;

	/*
		The scanning of the output happens after the function has been scanned,
		so err_fname is unreliable.
	*/
	tp = tok_scan_file(err_fname, tok_first_token);
	ASSERT(tp);
	tp = tok_scan_line(tp, the_line - lead_lines, err_fname, &amp;actual_line);

	ASSERT(tok_update_flag == FALSE);

	/* Skip over the newline to which tp points. */
	if (*tp == WS_NL_TOK || *tp == HIDDEN_NL_IN_COMMENT_TOK) {
		next_raw_tok(tp);
	}

	/*
		Before the days of err_line_offset, the actual leading line
		returned by tok_scan_line could be different from the_line - lead_lines.

		Not any more, but leave the code this way to be defensive.
	*/
	lead_lines = the_line - actual_line;

	/* Visually separate the leading lines for error messages. */
	ecnl(); enl();

	/* Print the leading lines. */
	if (lead_lines &gt; 0) {
		for (i = 0; i &lt; lead_lines &amp;&amp; *tp != HIDDEN_END_FILE_TOK; i++) {
			epadlong(the_line + err_line_offset - lead_lines + i, CONTEXT_WIDTH); es(": ");
			tp = tok_dump_line2(tp,
				DONT_PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_USER_TOKENS);
			ecnl();
			next_raw_tok(tp);
		}
	}

	/* Print the "middle" line. */
	epadlong(the_line + err_line_offset, CONTEXT_WIDTH);
	es((lead_context || trail_context) ? "* " : ": ");
	tp = tok_dump_line2(tp,
		DONT_PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_USER_TOKENS);
	enl();
	next_raw_tok(tp);

	/* Print the trailing lines. */
	if (trail_lines &gt; 0) {
		for (i = 0; i &lt; trail_lines &amp;&amp; *tp != HIDDEN_END_FILE_TOK; i++) {
			epadlong(the_line + err_line_offset + 1 + i, CONTEXT_WIDTH); es(": ");
			tp = tok_dump_line2(tp,
				DONT_PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_USER_TOKENS);
			ecnl();
			next_raw_tok(tp);
		}
	}

	/* Visually separate the trailing lines for error messages. */
	ecnl(); enl();

	/* Restore the previous settings. */
	ASSERT(tok_update_flag == FALSE);
	tok_update_flag = update_save;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.176">@ Return the name of the current file or "(no file)".
@c

char *
err_file_name(void)
{
	if (err_fname == NULL) {
		return "(no file)";
	}
	else {
		return cvt_short_fn(err_fname);
	}
}
</t>
<t tx="ekr.20080529093004.177">@ Start an error message.
@c

bool
err_begin(void)
{
	bool result = err_err_flag &amp;&amp; err_last_line != err_line;
	err_count++;
	if (result) {
		err_begin_mess("error:");
	}
	err_last_line = err_line;
	return result;
}
</t>
<t tx="ekr.20080529093004.178">@ Start a fatal error message. User errors should never result in a call to fatal.
@c

void
fatal_begin(void)
{
	/*7/19/93: Abort if we take a fatal error while processing a fatal error. */
	static bool in_fatal = FALSE;

	err_fatal++;
	ecnl(); enl();
	es("Oh Dear...There is something wrong me\n");
	es("in: "); es(current_ftag);
	es(" called from "); es(caller_ftag);
	es(" called from "); es(caller2_ftag);
	enl();

	if (in_fatal) {
		es("Encountered a second fatal error...aborting now!\n");
		end_abort();
		abort();
	}
	in_fatal = TRUE;
	err_begin_mess("oops:"); enl();
}
</t>
<t tx="ekr.20080529093004.179">@ Terminate a fatal error message that was begun with fatal_start.
@c

void
fatal_end(void)
{
	err_context();
	ecnl();
	if (err_fatal_flag) {
		end_abort();
		abort();
	}
}
</t>
<t tx="ekr.20080529093004.180">@ Start a help message.
@c

bool
help_begin(void)
{
	bool result = err_help_flag &amp;&amp; err_last_line != err_line;
	err_help++;
	if (result) {
		err_begin_mess("note:");
	}
	err_last_line = err_line;
	return result;
}
</t>
<t tx="ekr.20080529093004.181">@ Start and end an unrecoverable user error.
@c

void
user_fatal_begin(void)
{
	err_fatal++;
	ecnl();
	err_begin_mess("oops:"); enl();
}
</t>
<t tx="ekr.20080529093004.182">void
user_fatal_end(void)
{
	TRACE("fatal", err_context());
	ecnl();
	if (err_fatal_flag) {
		end_abort();
		abort();
	}
}
</t>
<t tx="ekr.20080529093004.183">@ Formatted warning routines.
@c

bool
warn_begin(void)
{
	bool result = err_warn_flag &amp;&amp; err_last_line != err_line;
	err_warning++;
	if (result) {
		err_begin_mess("warning:");
	}
	err_last_line = err_line;
	return result;
}
</t>
<t tx="ekr.20080529093004.184">/*
	AS: Application-specific error-stream routines.
	
	source:  ASes.c
	started: March 7, 1994.
	version:
		March 7, 1994.
			es moved here from LIBes.c.
		
		Prototypes for all routines in this file are found in LIBes.h.
*/

&lt;&lt; ASes #includes &gt;&gt;
&lt;&lt; ASes declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.185">#include "AS.h"
#include "ASes.h"

#include &lt;LIBes.h&gt;
#include &lt;LIBlog.h&gt;
</t>
<t tx="ekr.20080529093004.186">/*
	The error buffer allows error messages to be captured
	for later inclusion into the listing file.
*/

bool	es_err_buffer_flag = FALSE;	/* TRUE: buffer characters into es_err_buffer. */
char *	es_err_buffer = NULL;		/* Fixed-sized buffer for error messages. */
short	es_err_buf_count = 0;	</t>
<t tx="ekr.20080529093004.187">@ Number of characters in es_err_buffer.
All error output eventually comes here. Defining es here allows each application to define es as it sees fit.
@c

void
es(char * s)
{
	if (s) {
		log_sout(s);
		
		/* Buffer error messages. */
		if (es_err_buffer_flag) {
			ASSERT(es_err_buffer);
			while (*s &amp;&amp; es_err_buf_count &lt; ES_ERR_BUFFER_SIZE-2) {
				es_err_buffer [es_err_buf_count++] = *s++;
			}
			es_err_buffer [es_err_buf_count] = '\0';
		}	
	}
}
</t>
<t tx="ekr.20080529093004.188">/*
	AS: interface to devlib.

	source:  ASlib.c
	started: January 7, 1994.
	version: January 7, 1994.
*/

&lt;&lt; ASlib #includes &gt;&gt;

	/* Define variables used by devlib. */

pstring	lib_about_title = "\pAbout AS";			/* Must be a pascal string. */
char *	lib_arg_file_prompt = "AS log file...";	/* Prompt for file name. */

char *	lib_dialog_version = "AS version 1.0:\r\rCopyright ? 1994 by Tuple, Inc.";

char *	lib_log_window_name = "AS log";	/* The name of log window. */
bool	lib_modem_flag = TRUE;			/* 0/1 send output to modem/printer port. */

char *	lib_program_name = "AS";	/* The name of the program. */
bool	lib_serial_flag = FALSE; 	/* TRUE: S-record output goes to serial port. */
bool	lib_stderr_flag = FALSE;	/* TRUE: send log output to stderr on the Mac. */

#if defined(THINK_C)
	char *	lib_arg_file_name = "ASargs";	/* The name of the argument file. */
#elif defined(applec)
	char *	lib_arg_file_name = "AS MPW args";
#else
	char *	lib_arg_file_name = "ASargs.txt";
#endif

char *	lib_version = "AS version 1.0";
</t>
<t tx="ekr.20080529093004.189">#include &lt;LIBlib.h&gt;
</t>
<t tx="ekr.20080529093004.190">/*
	AS: Application-specific memory management routines

	source:  ASmem.c
	started: September 20, 1985
	version: April 5, 1994.
*/

&lt;&lt; ASmem #includes &gt;&gt;
&lt;&lt; ASmem declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.191">#include "AS.h"
#include "ASmem.h"
#include "AStokens.h"
#include "AStokize.h"

#include &lt;LIBlib.h&gt;
#include &lt;LIBlist.h&gt;
#include &lt;LIBmem.h&gt;
#include &lt;LIBobj.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.192">/*
	Define the actual lifetimes used in the program.
	Tokens must have a separate lifetime so that only tokens will appear in token blocks.
*/
mem_life * expand_life = NULL;	/* Description of macro expansion lifetime. */
mem_life * file_life = NULL;	/* Description of file lifetime. */
mem_life * perm_life = NULL;	/* Description of permanent lifetime. */
mem_life * token_life = NULL;	/* Description of token lifetime. */

mem_stat * anode_stats = NULL;
mem_stat * cnode_stats = NULL;
mem_stat * enode_stats = NULL;
mem_stat * keyword_spell_stats = NULL;
mem_stat * spell_stats = NULL;
mem_stat * string_stats = NULL;

mem_stat * perm_arg_stats = NULL;
mem_stat * perm_macro_stats = NULL;
mem_stat * perm_string_stats = NULL;

mem_stat * bxx_stats = NULL;
mem_stat * cpp_stats = NULL;
mem_stat * err_stats = NULL;
mem_stat * macro_stats = NULL;

mem_stat * area_stats = NULL;
mem_stat * comment_stats = NULL;
mem_stat * dc_val_stats = NULL;
mem_stat * dict_stats = NULL;
mem_stat * ref_stats = NULL;
mem_stat * unit_stats = NULL;

mem_stat * other_expand_stats = NULL;
mem_stat * other_file_stats = NULL;
mem_stat * other_perm_stats = NULL;

mem_stat * id_token_stats = NULL;
mem_stat * ptr_token_stats = NULL;
mem_stat * small_token_stats = NULL;
mem_stat * val_token_stats = NULL;

static long mem_max_node_tag = 12;	</t>
<t tx="ekr.20080529093004.193">@ strlen("big blocks:")+1
Copy a string of the indicated length into a block with file lifetime. Do not assume the string ends with a zero byte.
@c

char *
mem_str_copy(char * start, size_t length)
{
	FTAG("mem_str_copy");
	char * result = NULL;
	STATB(ftag);
	ASSERT(file_life);

	new_size_macro(result, length+1, file_life, string_stats);
	/* Warning: do not use strncpy here; the string may not be zero terminated! */
	memcpy(result, start, length);
	result[length]='\0';
	ASSERT(strlen(result) == length &amp;&amp; file_life -&gt; mem_ptr == result + length + 1);
	STATX(ftag);
	return result;
}
</t>
<t tx="ekr.20080529093004.194">@ Allocate a new token block and put an end-block token in the old block.
@c

token *
mem_new_tok_block(token * tp, long tavail)
{
	FTAG("mem_new_tok_block");
	void * new_tp = NULL;
	STATB(ftag);

	ASSERT_TRACE(
		(tavail &gt;= BIG_TOKEN_SIZE &amp;&amp; tavail &lt; MAX_TOKEN_SIZE) ||
		token_life -&gt; mem_ptr == NULL,
		es("tavail: "); elong(tavail);
	);

	TOKIZE_STATS(
		tok_blocks++;
		tok_waste += (tavail - BIG_TOKEN_SIZE);
		tok_number++;
		tok_bigs++;
		tok_end_blocks++;
	);
	
	/* 
		Set the globals for mem_new_block.
		This affects the statistics only.
	*/
	token_life -&gt; mem_ptr = tp;
	token_life -&gt; mem_avail = tavail;

	/*
		Put the end-block token in the old block.
		We can't use put_ptr_tok because it calls this routine!
	*/
	new_tp = mem_new_block(0, token_life);
	*tp++ = HIDDEN_END_BLOCK_TOK;
	* ((char **) tp) = new_tp;

	STATX(ftag);
	return new_tp;
}
</t>
<t tx="ekr.20080529093004.195"></t>
<t tx="ekr.20080529093004.196"></t>
<t tx="ekr.20080529093004.197">/*
	AS: Header for AScpp.c.

	Source:  AScpp.h
	Started: September 22, 1993.
	Version:
		December 27, 1993.
			Define file_info_nodes and skip_nodes here instead of tokens.h.
*/

#ifndef AScpp_h_
#define AScpp_h_

#pragma once

/* File info nodes describe include files. */

#ifndef AS_CPP_TYPEDEFS
	#define AS_CPP_TYPEDEFS
	typedef struct file_info_struct	file_info_node;
#endif

struct file_info_struct {
	char *	finfo_fname;		/* Saved file name. */
	long	finfo_line;			/* Saved line number. */
	long	finfo_line_offset;	/* Saved line offset. */
	token *	finfo_tp;			/* "Return address" for include file. */
};

typedef struct skip_struct skip_node;

struct skip_struct {
	token *		skip_tp;		/* Skip pointer. */
	long		skip_lines;		/* Number of skipped lines. */
};

token * cpp			(token * tp);
long	char_val	(register char *s);
token *	skip_pp		(token * tp);

#endif /* AScpp_h_ */
</t>
<t tx="ekr.20080529093004.198">/*
	AS: header file for ASmacro.c.

	source: ASmacro.h
	started: December 20, 1993.
	version:
		December 27, 1993.
			Added typedefs that are defined in AStypes.h.
*/

#ifndef ASmacro_h_
#define ASmacro_h_

	/* Typedefs and structures. */

#ifndef AS_MACRO_TYPEDEFS
	#define AS_MACRO_TYPEDEFS
	typedef struct mac_def_node_struct mac_def_node;
#endif

struct mac_def_node_struct {
	mac_def_node *	next;			/* List of macro definitions. */
	token *			mac_rtokens;	/* The tokenized replacement text. */
	int				mac_nargs;		/* The number of formal arguments. */
	char **			mac_names;		/* Pointer to block of names of macro args. */
	spell_node *	mac_spell;		/* Pointer to owner of this definition. */
};

	/* Function prototypes. */

token * mac_define			(token * tp, bool special_flag);
void	mac_define_string	(char * name, char * rtext, bool special_flag);
token *	mac_outer_expand	(token * tp);

	/* Globals. */

extern mac_def_node * mac_mdef_list;	/* List of macro defs. */

#endif /* ASmacro_h_ */</t>
<t tx="ekr.20080529093004.199">/*
	AS: header file for ASmst.c.

	source:  ASmst.h
	source:  December 20, 1993.
	version: December 20, 1993.
*/

#ifndef ASmst_h_
#define ASmst_h_

#pragma once

void	mst_dump_all		(void);
void	mst_dump_mdef		(mac_def_node * mp);
void	mst_init			(void);
void	mst_init_again		(void);
void	mst_init_define		(char * arg, char * def, bool user_flag);
void	mst_init_undef		(char * arg);
bool	mst_is_undef		(char * name);
void	mst_show			(void);
void	mst_special			(spell_node * spell_p);

#endif /* ASmst_h_ */</t>
<t tx="ekr.20080529093004.200"></t>
<t tx="ekr.20080529093004.201">/*
	AS: The main line of the C preprocessor and non-macro directives.

	source:  AScpp.c
	started: February 6, 1992
	version:
		August 29, 1994.
			Bug fix: call strtoul to retain all bits when evaluating a constant string.
			Added type information to push_val and pop_val.
			This information is used to properly evaluate operators.
			Added type stack to handle this new information.
		June 12, 1994.
			Added support for ternary operator in preprocessor.
		December 27, 1993.
			Installed new_cat2_macro logic and eliminated CPP_MAX_FILE_NAME.
		December 24, 1993.
			Replaced most calls to obj_free by calls to new_macro and its relatives.
		December 22, 1993.
			Reinstalled path logic.
*/

&lt;&lt; AScpp #includes &gt;&gt;
&lt;&lt; AScpp declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.202">#include "AS.h"

#include "ASarg.h"
#include "AScpp.h"
#include "ASmacro.h"
#include "ASmem.h"
#include "ASmst.h"
#include "ASpass12.h"
#include "AStokens.h"
#include "AStokize.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBio.h&gt;
#include &lt;LIBlist.h&gt;
#include &lt;LIBobj.h&gt;

#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.203">/*
	Define the maximum depth of nesting of #if's.
	The ANSI Standard requires at least 8 levels (See page14)
*/
#define CPP_MAX_IF	100

/*
	Define the maximum depth of compile time expressions.
	The ANSI Standard requires at least 32 levels.
*/
#define MAX_EVAL_VAL 100
#define MAX_EVAL_OP 50

/*
	Define the inhibit include list.
	This is created by #prama once.
*/
typedef struct file_inhibit_node_struct file_inhibit_node;

static struct file_inhibit_node_struct {
	TYPE_LIST(file_inhibit_node);
	char *	inhibit_fname;
};

/*
	Define the local variables of this module.
*/
static file_inhibit_node * cpp_inhibit_list = NULL;

static short int * if_stack = NULL;
static int if_level = 0;

static long	* val_stack = NULL;	 /* Operand stack. */
static token * op_stack = NULL;	 /* Operator stack. */
static bool	* type_stack = NULL; /* Type stack. */

static int val_ptr = 0;	/* Operand stack pointer. */
static int op_ptr = 0;	/* Operator stack pointer. */

static bool error_seen = FALSE;		/* TRUE: error in eval seen. */
static bool	cpp_init_flag = FALSE;	/* TRUE: cpp has been initialized. */

/*
	Declare internal routines.
*/

	/* Synonyms for unsigned_flag. */
	enum { UNSIGNED_VAL = TRUE, SIGNED_VAL = FALSE };

static token *	cpp_elif	(token * tp);
static token *	cpp_else	(token * tp);
static token *	cpp_endif	(token * tp);
static void		cpp_error	(token * tp);
static token *	cpp_if		(token * tp);
static token *	cpp_ifdef	(token * tp, bool flag);
static token *	cpp_include	(token * tp);
static token *	cpp_incl2	(token * tp, io_mem_block * input_block,
							char * fname, char * path, bool std_lib_flag);
static void		cpp_inhibit	(char * file_name);
static token *	cpp_line	(token * tp);
static token *	cpp_pragma	(token * tp);
static token *	cpp_undef	(token * tp);

static token *	eval		(token * tp, long * val_p);
static bool		gt_prec		(token op1, token op2);
static void		push_op		(token);
static token	pop_op		(void);
static void		push_val	(long, bool unsigned_flag);
static long		pop_val		(bool * unsigned_flag);
static int		prec		(int);

	/* Define synonyms for skip_all_flag */

	#define SKIP_UNTIL_ENDIF			TRUE
	#define SKIP_UNTIL_ELSE_OR_ENDIF	FALSE

static token *	skip_lines	(token * tp, char * directive_name, bool skip_all_flag);
static token *	skip_past	(token * tp);
</t>
<t tx="ekr.20080529093004.204">@ What about form feed '\f' and vertical tab '\v' in preprocessor directives?  See Standard: page 6, page 87 and Rationale, page 62.  p87 says only blank and tab are allowed, but that may just mean '\n' is not allowed (except in comments).  p 62 says newlines in comments are allowed in a preprocessor directive.  p 6: Whether each nonempty sequence of white-space characters other than newline is retained or replaced by one blank character is implementation defined.  Tokenize replaces '\f' and '\v' by WS_TOK, so these are replaced by a blank character.  What all this means is that skip_hws_tok just tests for is_ws except WS_NL_TOK.
Return the value of a character constant.
@c

long
char_val(register char *s)
{
	SL_DISABLE();

	if (*s != '\\') {
		return (long) *s;
	}

	/* Handle escape sequences. */

	s++;
	switch (*s) {
	case 'b':	return '\b';
	case 'f':	return '\f';
	case 'n':	return '\n';
	case 'r':	return '\r';
	case 't':	return '\t';
	case 'v':	return '\v';
	case '\'':	return '\'';
	case '\\':	return '\\';

	default:
		{
			register long val = 0;
	
			if (*s &lt; '0' || *s &gt; '7') {
				return (long)*s;
			}
			while (*s &gt;= '0' &amp;&amp; *s &lt;= '7') {
				val = val * 8 + (int)*s - '0';
				s++;
			}
			return val;
		}
	}
}
</t>
<t tx="ekr.20080529093004.205">@ The main C preprocessor.  This converts a token list created by tokize into a fully preprocessed token list:  o All preprocessor directives are processed and bypassed by HIDDEN_SKIP_TOK's. o All nested #incude files are handled recursively. o All macro substitution is performed. o All string concatenation is performed.  Tokenize adds a "dummy newline" to the beginning of the block so we can recognize directives at the start of a file without problems.
@c

token *
cpp(register token * tp)
{
	FTAG("cpp");
	FTAGV("-cpp_v");
	register token c = 0;
	long skipped_lines = 0;
	token * first_tp = tp;
	token * skip_tp = NULL;
	long start_line = 0;
	TRACEPB(ftag,
		es(err_fname); enl());

	if (!cpp_init_flag) {

		cpp_init_flag = TRUE;

		/* Allocate the stacks */
		obj_new_macro(if_stack,   CPP_MAX_IF   * sizeof(int),   "cpp if stack");
		obj_new_macro(val_stack,  MAX_EVAL_VAL * sizeof(long),  "cpp value stack");
		obj_new_macro(type_stack, MAX_EVAL_VAL * sizeof(bool),  "cpp type stack");
		obj_new_macro(op_stack,   MAX_EVAL_OP  * sizeof(token), "cpp op stack");
	}

	while ( (c = *tp) != END_PROG_TOK) {

		#if 0 /* Expensive. */
			TRACE("obj_v", obj_checkMem());
		#endif

		ASSERT_TRACE(c &gt; 0 &amp;&amp; c &lt; BAD_LAST_TOK,
			es("tp = "); eptr(tp); enl();
			tok_dump(first_tp, PRINT_HIDDEN_TOKS);
		);

		#if 0 /* Very expensive. */
			#ifdef THINK_C
				if (w_applEvent(0) == FALSE) {
					end_quit();
				}
			#endif
		#endif

		/* Look for preprocessor directives. */
		if (c == WS_NL_TOK) {

			/* Skip the newline and leading white space. */
			err_line++;
			next_tok(tp);
			skip_hws_tok(tp);

			if (*tp != POUND_TOK) {
				/* We have to scan the line to look for macros. */
				continue;
			}

			TRACEPN(ftagv, tok_dump_line(tp));

			/* Remember where to put the HIDDEN_SKIP_TOK. */
			skip_tp = tp;

			/* Skip the '#' and trailing white space. */
			next_tok(tp);
			skip_hws_tok(tp);

			c = *tp;

			/*
				Remember the line at the beginning of the directive.
				This will be used to choose between HIDDEN_SKIP_TOK and
				HIDDEN_BIG_SKIP_TOK.

				We will set start_line to -1 for #include and #line since
				the HIDDEN_BEGIN_FILE_TOK and HIDDEN_FILE_INFO_TOK tokens set
				the line number directly.
			*/
			start_line = err_line;

			/* No lines have been skipped in this directive yet. */
			skipped_lines = 0;

			if (c == WS_NL_TOK) {

				/* A bare '#' */
				err_line++;
				next_tok(tp);
			}
			else if (is_ppkey(c)) {

				switch(c) {

				case K_DEFINE:	tp = mac_define(tp, FALSE);	break;
				case K_ELIF:	tp = cpp_elif(tp);			break;
				case K_ELSE:	tp = cpp_else(tp);			break;
				case K_ENDIF:	tp = cpp_endif(tp);			break;
				case K_ERROR:	cpp_error(tp);				break;
				case K_IF:		tp = cpp_if(tp);			break;
				case K_IFDEF:	tp = cpp_ifdef(tp, TRUE);	break;
				case K_IFNDEF:	tp = cpp_ifdef(tp, FALSE);	break;
				case K_INCLUDE:	start_line = -1;
								tp = cpp_include(tp);		break;
				case K_LINE:	start_line = -1;
								tp = cpp_line(tp);			break;
				case K_PRAGMA:	tp = cpp_pragma(tp);		break;
				case K_UNDEF:	tp = cpp_undef(tp);			break;

				default:
					fatal(
						es("Unrecognized token in preprocessor directive: ");
						tok_dump1(tp, PRINT_HIDDEN_TOKS);
					);
				}
			}
			else if (c == ID_TOK) {

				/*
					Do *not* look for macros here:

					The ANSI C Standard p 92:
					"The resulting completely macro-replaced preprocessing
					token sequence is not processed as a preprocessing
					directive even if it resembles one."
				*/

				spell_node * spell_p = id_tok_ptr(tp);

				error(
					es("Unrecognized preprocessor directive: ");
					es(spell_p -&gt; spell_name);
				);
				tp = skip_pp(tp);
			}
			else {
				error(
					es("Unrecognized token in preprocessor directive: ");
					tok_dump1(tp, PRINT_HIDDEN_TOKS);
				);
			}

			/*
				Replace the POUND_TOK at skip_tp by skip directive tok or
				a big skip tok.

				cpp_incl2 uses this code to stitch in the included file.
				This is the *only* place patching is done!
			*/

			ASSERT(*skip_tp == POUND_TOK);

			if (start_line == -1) {
				skipped_lines = 0;
			}
			else {
				skipped_lines = err_line - start_line;
			}
			ASSERT(skipped_lines &gt;= 0);

			if (skipped_lines == 0) {
				tok_patch(skip_tp, HIDDEN_SKIP_DIRECTIVE_TOK,
					tp, "skip directive");
			}
			else {

				/* 12/23/93: Allocate skip blocks from the file lifetime. */
				skip_node *	skip_p = NULL;
				new_file_macro(skip_p, cpp_stats);
				skip_p -&gt; skip_lines = skipped_lines;
				skip_p -&gt; skip_tp = tp;

				/* Change the # to a big skip */
				tok_patch(skip_tp, HIDDEN_BIG_SKIP_TOK, skip_p, "skip multiple lines");
			}

		} /* End c == NL */

		else if (is_id(*tp) &amp;&amp; (id_tok_ptr(tp)) -&gt; spell_macro != NULL) {

			tp = mac_outer_expand(tp);
		}
		else if (*tp == ERROR_MESSAGE_TOK) {

			char * message = (char *) ptr_tok_ptr(tp);

			/* Do not print the error token.. */
			tok_ignore(tp);

			/* Print an error message generated in tokize. */
			error(es(message));
		}
		else {
			next_tok(tp);
		}

	}

	/*
		End of cpp main loop.
	*/
	TRACE("-cpp_mst_dump",	mst_dump_all());

	{
		mac_def_node * md_p = NULL;

		/* Free all pointers to formal arguments. */
		lst_every_macro(md_p, mac_mdef_list) {

			ASSERT_TRACE(md_p -&gt; mac_spell -&gt; spell_macro == md_p,
				es("md_p -&gt; mac_spell -&gt; spell_macro: ");
				eptr(md_p -&gt; mac_spell -&gt; spell_macro);
				enl();
				es("md_p: "); eptr(md_p); enl();
			);

			md_p -&gt; mac_spell -&gt; spell_macro = NULL;
		}
		/*
			Make sure we do not execute the above code twice.
			mac_def_list is a "constituent list" of mac_def_block_list.
			mac_def_list freed implicitly when mac_def_block_list is freed.
		*/
		mac_mdef_list = NULL;
	}

	/* The actual nodes have file lifetime and will be freed later. */
	cpp_inhibit_list = NULL;

	TRACEPX(ftag, es(err_file_name()));
	return first_tp;
}</t>
<t tx="ekr.20080529093004.206">@ Handle the #elif directive when lines are NOT being skipped. The skip_lines() routines handles #elif when lines ARE being skipped.
@c

static token *
cpp_elif (token * tp)
{
	FTAG("cpp_elif");
	TRACEPB(ftag, tok_dump_line(tp));

	/* Skip the "elif" */
	next_tok(tp);
	skip_hws_tok(tp);

	if (if_level == 0) {
		error(es("#elif ignored--no matching #if"));
		tp = skip_pp(tp);
	}
	else {
		/*
			Something has already evaluated to TRUE.
			Skip all the rest of the directive.
		*/
		tp = skip_lines(tp, "elif", SKIP_UNTIL_ENDIF);
	}
	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.207">@ Handle the #else directive when lines are NOT being skipped. The skip_lines() routine handles #else when lines ARE being skipped.
@c

static token *
cpp_else (token * tp)
{
	FTAG("cpp_else");
	TICKB(ftag);

	if (if_level == 0) {
		error(es("#else ignored--no matching #if"));
		tp = skip_pp(tp);
	}
	else if (if_stack [if_level - 1] == TRUE) {
		error(es("Duplicate #else ignored"));
		tp = skip_pp(tp);
	}
	else {
		if_stack [if_level - 1] = TRUE;

		/*
			Something has already evaluated to TRUE.
			Skip everything else.
		*/
		tp = skip_lines(tp, "else", SKIP_UNTIL_ENDIF);
	}

	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.208">@ Handle the #endif directive when lines are NOT being skipped. The skip_lines() routine handles #endif when lines ARE being skipped.
@c

static token *
cpp_endif (token * tp)
{
	FTAG("cpp_endif");
	TICKB(ftag);

	if (if_level == 0) {
		error(es("#endif ignored--no matching #if"));
	}
	else {
		if_level--;
	}

	tp = skip_pp(tp);
	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.209">@ Print an error message and abort.
@c

static void
cpp_error (token * tp)
{
	SL_DISABLE();

	error(tok_dump_line2(tp,
		DONT_PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_USER_TOKENS));
	end_abort();
}
</t>
<t tx="ekr.20080529093004.210">@ Handle the #if directive when lines are NOT being skipped. The skip_lines() routine handles #if when lines ARE being skipped.
@c

static token *
cpp_if (token * tp)
{
	FTAG("cpp_if");
	long result = 0;
	TRACEPB(ftag, tok_dump_line(tp));

	/* Skip the "if" */
	next_tok(tp);

	/* Indicate that no #else has been seen. */
	if (if_level &gt;= CPP_MAX_IF) {
		error(es("#if ignored--nested too deeply"));
		return skip_pp(tp);
	}
	if_stack [if_level++] = FALSE;

	error_seen = FALSE;
	tp = eval(tp, &amp;result);
	if (result == 0L) {
		/*
			Nothing has evaluated to TRUE so far.
			Skip only to #elif or #else.
		*/
		tp = skip_lines(tp, "if", SKIP_UNTIL_ELSE_OR_ENDIF);
	}

	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.211">@ Handle the #ifdef and #ifndef directives when lines are NOT being skipped. The skip_lines() routine handles #if when lines ARE being skipped.  flag is TRUE for #ifdef and FALSE for #ifndef.
@c

static token *
cpp_ifdef (token * tp, bool flag)
{
	FTAG("cpp_ifdef");
	TRACEPB(ftag, tok_dump_line(tp));

	if(if_level &gt; CPP_MAX_IF) {
		error(es("#ifdef or #ifndef ignored--nested too deeply"));
		tp = skip_pp(tp);
		goto done;
	}

	/* Skip the "ifdef" or "ifndef" */
	next_tok(tp);

	skip_hws_tok(tp);

	if (!is_id(*tp)) {
		error(es("#ifdef or #ifndef ignored--identifier expected"));
		tp = skip_pp(tp);
		goto done;
	}

	/* Indicate that no #else has been seen. */
	if_stack [if_level++] = FALSE;

	/* Skip lines if required. */
	{

		spell_node * spell_p = id_tok_ptr(tp);
		bool found = (spell_p -&gt; spell_macro != NULL);

		if (flag == found) {
			tp = skip_pp(tp);
		}
		else {
			/*
				Nothing has evaluated to TRUE so far.
				Skip only to #elif or #else.
			*/
			tp = skip_lines(tp, flag ? "ifdef" : "ifndef", SKIP_UNTIL_ELSE_OR_ENDIF);
		}
	}

done:
	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.212">@ Handle the #include directive.
@c

static token *
cpp_include (register token * tp)
{
	FTAG("cpp_include");
	FTAGV("-cpp_include_v");
	char *	ftagvv = "cpp_include_vv";
	bool	std_lib_flag = FALSE;
	char *	f_name = NULL;
	token * patch_tp = tp;

	TRACE("-no_include", return skip_pp(tp));

	TRACEP(ftag, tok_dump_line(tp));

	/* Skip the include. */
	next_tok(tp);

	skip_hws_tok(tp);

	/* Allow macro expansion. */
	tp = mac_outer_expand(tp);

	/* Tokenize generates deferred error messages for some bad file names. */
	if (*tp == ERROR_MESSAGE_TOK) {

		char * message = (char *) ptr_tok_ptr(tp);

		tok_ignore(tp);
		error(es(message));
		return skip_pp(tp);
	}

	if (*tp != STRING_TOK &amp;&amp; *tp != FILE_NAME_TOK) {
		error(
			es("File name expected after #include, ");
			tok_dump1(tp, DONT_PRINT_HIDDEN_TOKS);
			es(" found instead");
		);
		return skip_pp(tp);
	}

	std_lib_flag = (*tp == FILE_NAME_TOK);
	if (*tp == STRING_TOK || *tp == FILE_NAME_TOK) {
		f_name = ptr_tok_ptr(tp);
	}

	/* Do nothing if the file name is on the file inhibit list. */
	{
		file_inhibit_node * fxp;

		lst_every_macro(fxp, cpp_inhibit_list) {
			if (str_eq(f_name, fxp -&gt; inhibit_fname)) {

				TRACEP("cpp_inhibit",
					es(f_name);
					es(" on inhibit list.  Ignoring: #include ");
					es(std_lib_flag ? "&lt;" : "\"");
					es(f_name);
					es(std_lib_flag ? "&gt;" : "\""); enl());

				return skip_pp(tp);
			}
		}
	}

	/*
		Add the file to the inhibit list if -once option is enabled.
	*/
	if (arg_once_flag) {
		cpp_inhibit(f_name);
	}

	/*
		Do not include filename.h if _H_filename is defined.
	*/

#ifdef THINK_C

	{
		spell_node * spell_p = NULL;
		size_t	i = strlen(f_name);

		if (i &gt; 3 &amp;&amp; f_name[i-2] == '.' &amp;&amp; f_name[i-1] == 'h') {

			char * f2_name = NULL;
			char *	rtextp;
			int		nargs;

			new_file_cat2_macro(f2_name, "_H_", f_name);
			spell_p = tok_lookup_hash(f2_name);
			if (spell_p != NULL &amp;&amp; spell_p -&gt; spell_macro != NULL) {

				TRACEP(ftagv,
					es(f2_name); es(" defined.  Ignoring: #include ");
					es(std_lib_flag ? "&lt;" : "\"");
					es(f_name);
					es(std_lib_flag ? "&gt;" : "\""); enl());

				return skip_pp(tp);
			}
		}
	}

#endif

	/* Skip the line before recursing. */
	tp = skip_pp(tp);

	/* Open the new file file. */

	/* Allow the user to specify a full path name. */
	{
		io_mem_block * input_block =
			io_read_pad_all(f_name, 1, ' ', 3 , IO_EOF_CHAR,
				NO_CANT_MESSAGE, IO_TEXT_FILE);

		if (input_block != NULL) {
			TRACEP(ftagvv, es("successful open: "); es(f_name));
			return cpp_incl2(tp, input_block, f_name, f_name, std_lib_flag);
		}
	}

	/* Search the list of search paths. */
	{
		io_path_list *	search_p = NULL;
		io_mem_block *	input_block = NULL;

		lst_every_macro(search_p, arg_search_paths) {

			char * path_name = NULL;
			new_file_cat2_macro(path_name, search_p -&gt; io_path_name, f_name);
			input_block = io_read_pad_all(path_name, 1, ' ', 3 , IO_EOF_CHAR,
				NO_CANT_MESSAGE, IO_TEXT_FILE);
			if (input_block != NULL) {
				TRACEP(ftagvv, es("successful open: "); es(path_name));
				return cpp_incl2(tp, input_block, f_name, path_name, std_lib_flag);
			}
		}
	}

	/* Always report this error. */
	force_error(
		es("#include ");
		es(std_lib_flag ? "&lt;" : "\"");
		es(f_name);
		es(std_lib_flag ? "&gt;" : "\"");
		es(" ignored--file not found");
	);

	return tp;
}
</t>
<t tx="ekr.20080529093004.213">@ Preprocess the input block by tokenizing it and adding it to the current token list.
@c

static token *
cpp_incl2(
	token * tp,
	io_mem_block * input_block,
	char * f_name,
	char * full_path_name,
	bool std_lib_flag)
{
	FTAG("cpp_incl2");
	file_info_node * fip = NULL;
	token * first_token = NULL;

	if (arg_v_include_flag || arg_v_full_include_flag) {

		ecnl();
		es("#include ");
		es(std_lib_flag ? "&lt;" : "\"");
		es(arg_v_full_include_flag ? full_path_name : f_name);
		es(std_lib_flag ? "&gt;" : "\"");
		enl();
	}

	/* Save global settings. */
	new_file_macro(fip, cpp_stats);
	fip -&gt; finfo_fname		= err_fname;
	fip -&gt; finfo_line		= err_line;
	fip -&gt; finfo_line_offset = err_line_offset;
	fip -&gt; finfo_tp			= tp;			/* "return address" for tokize. */

	/* Set the new settings for cpp. */
	err_fname = f_name;
	err_line = 0;
	err_line_offset = 0;

	/* Make sure the file ends in a physical newline. */
	{
		char * p = input_block -&gt; mem_start;

		if (p [input_block -&gt; mem_length -1] != '\n') {
			p [input_block -&gt; mem_length] =  '\n';
			TRACEP("cpp_incl2", es("trailing newline added\n"));
		}
	}

	/*
		Tokenize the file.
	*/

	/* Do not include time in tokize or compress in stats for cpp. */
	STATX("cpp");

	STATB("inner_cpp");
	compress(input_block);
	first_token = tokize(input_block, fip, f_name, END_WITH_EOF_TOK, NULL);
	STATX("inner_cpp");

	STATB("cpp");

	/* The input block can be freed directly after tokize is finished. */
	obj_free_macro(input_block -&gt; mem_freep);
	obj_free_macro(input_block);

	/*
		Just return the first token of the new file.
		The "patch code" in cpp will stitch the new file in place.
	*/
	return first_token;
}
</t>
<t tx="ekr.20080529093004.214">@ Inhibit any further #include processing for the indicated file.
@c

static void
cpp_inhibit(char * file_name)
{
	FTAG("cpp_inhibit");
	file_inhibit_node *	fxp = NULL;

	/* Don't add a name to the list twice. */
	lst_every_macro(fxp, cpp_inhibit_list) {
		if (str_eq(file_name, fxp -&gt; inhibit_fname)) {
			return;
		}
	}

	new_file_macro(fxp, cpp_stats);
	new_file_string_macro(fxp -&gt; inhibit_fname, file_name);

	TRACEP(ftag, es(file_name); es(" added to file inhibit list\n"));
}
</t>
<t tx="ekr.20080529093004.215">@ Set the line number and file name.
@c

#define BUF_MAX 1000 /* Size of the file name buffer. */

static token *
cpp_line  (token * tp)
{
	FTAG("cpp_line");
	TRACEP(ftag, tok_dump_line(tp));

	/* Skip over the "line" */
	next_tok(tp);
	skip_hws_tok(tp);

	/* Allow macro expansion. */
	tp = mac_outer_expand(tp);

	if (*tp != INT_TOK) {
		error(es("line number expected after #line"));
		return skip_pp(tp);
	}

	/* Set err_line by converting the string. */
	{
		char * start = (char *) val_tok_val(tp);
		char c = start[strlen(start)];
		char * end = NULL;
		long val = 0;

		if (c == 'u' || c == 'U') {
			val = (long) strtoul(start, &amp;end, 0);
		}
		else {
			val = strtol(start, &amp;end, 0);
		}
		if (*end != '\0') {
			error(es("ignoring bad #line number"));
			return skip_pp(tp);
		}
		else {
			/* The line number remains the same.  Only the offset changes. */
			err_line_offset = val - err_line;
		}
	}

	next_tok(tp);
	skip_hws_tok(tp);

	/* See if an optional file name is present. */

	if (!is_id(*tp)) {
		tp = skip_pp(tp);
		goto done;
	}

	/* Allow a macro id here. */
	tp = mac_outer_expand(tp);

	/*
		Assume the rest of the line is a file name.
		Copy it to buffer[].
	*/
	{
		register char *	s;
		register int	buf_index = 0;

		char buffer[BUF_MAX];
		int  length = 0;

		while (*tp != WS_NL_TOK) {
			s = tok_2string(tp, &amp;length, FALSE);
			if (length + buf_index &lt; BUF_MAX) {
				strcpy(buffer + buf_index, s);
				buf_index += length;
			}
			else {
				tp = skip_pp(tp);
				break;
			}
			next_tok(tp);
		}

		/* Set the file name but not the line number. */
		{
			long save_line = err_line;
			err_begin_file(buffer);
			err_line = save_line;
		}
	}

	/*
		Create a HIDDEN_FILE_INFO_TOK in the current token space.
		The HIDDEN_FILE_INFO_TOK points at a file_info_node which in turn
		points to the next token.
	*/

done:

	/* Save the new settings. */
	{
		file_info_node * fip = NULL;
		new_file_macro(fip, cpp_stats);
		fip -&gt; finfo_fname		= err_fname;
		fip -&gt; finfo_line		= err_line;
		fip -&gt; finfo_line_offset = err_line_offset;
		fip -&gt; finfo_tp			= tp;

		tp = tok_copy(HIDDEN_FILE_INFO_TOK, fip);
	}
	return tp;
}
</t>
<t tx="ekr.20080529093004.216">@ Handle all pragmas.
@c

static token *
cpp_pragma (token * tp)
{
	FTAG("cpp_pragma");
	TRACEPB(ftag, tok_dump_line(tp));

	/* Skip the pragma. */
	next_tok(tp);
	skip_hws_tok(tp);

	if (*tp == ID_TOK) {
		spell_node * spell_p = id_tok_ptr(tp);

		if (str_eq(spell_p -&gt; spell_name, "once") &amp;&amp; err_fname != NULL) {
			cpp_inhibit(err_fname);
		}
	}

	tp = skip_pp(tp);
	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.217">@ #undef a macro name. Give no warning if the name has not been defined.
@c

static token *
cpp_undef (token * tp)
{
	FTAG("cpp_undef");
	TRACEPB(ftag, tok_dump_line(tp));

	/* Skip the undef. */
	next_tok(tp);
	skip_hws_tok(tp);

	/* Get the identifier. */
	if (!is_id(*tp)) {
		error(es("#undef ignored--identifier expected"));
	}
	else if ((id_tok_ptr(tp)) -&gt; spell_macro != NULL) {

		spell_node * 	sp = (spell_node *) id_tok_ptr(tp);
		mac_def_node *	md_p = sp -&gt; spell_macro;

		TRACEPN(ftag,
			ecnl(); es("undefining ");
			es((id_tok_ptr(tp)) -&gt; spell_name); enl());

		md_p -&gt; mac_spell -&gt; spell_macro = NULL;

		/* Remove the item from the list. */
		lst_remove_macro(md_p, mac_mdef_list, mac_def_node);
	}

	tp = skip_pp(tp);
	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.218">@ Evaluate a constant expression to either true or false. A constant expression consists of:  1. integer constants or character constants 2. the unary - + and ~ operators 3. the binary + - * / &amp; | ^ &lt;&lt; &gt;&gt; == != &lt; &gt; &lt;= &gt;= oprators 4. the ternary ? : operator 5. the ( and ) groupers.  Identifiers are expanded if they are defined, otherwise they are taken to have a value of zero. All arithmetic is integer and ints are expanded to long.
@c

static token *
eval(register token * tp, long * val_p)
{
	FTAG("eval");
	FTAGV("-eval_v");
	int	op_1ptr = op_ptr;
	TRACEPB(ftag, tok_dump_line(tp));

	/* State S1: unary +, unary -, !, ~, constant or id is expected here. */

s1:
	skip_hws_tok(tp);

	TRACEPN(ftagv, es("state 1: "); es(tok_name(*tp)); enl());

	switch(*tp) {

	case PLUS_TOK:	push_op(UPLUS_TOK);		next_tok(tp); goto s1;
	case MINUS_TOK:	push_op(UMINUS_TOK);	next_tok(tp); goto s1;
	case NOT_TOK:	push_op(NOT_TOK);		next_tok(tp); goto s1;
	case TILDE_TOK:	push_op(TILDE_TOK);		next_tok(tp); goto s1;

	case CHAR_TOK:

		push_val(char_val(ptr_tok_ptr(tp)), SIGNED_VAL);
		next_tok(tp);
		break;

	case INT_TOK:
	{
		char * start = ptr_tok_ptr(tp); /* 7/16/92 */
		size_t len = strlen(start);
		char c1 = (len &gt; 0) ? tolower(start[len-1]) : ' ';
		char c2 = (len &gt; 1) ? tolower(start[len-2]) : ' ';
		bool unsigned_flag = c1 == 'u' || c2 == 'u';
		char * end = NULL;
		ulong uval = 0;

		/* Bug fix 8/29/94: parse an *unsigned* constant to retain all bits. */
		uval = strtoul(start, &amp;end, 0);

		if (*end != '\0') {
			error(
				es("bad constant value: "); es(start); es(". 0 assumed");
			);
			push_val(0L, SIGNED_VAL);
		}
		else {
			push_val(uval, unsigned_flag);
		}
		next_tok(tp);
		break;
	}

	case KM_DEFINED:
	{
		bool paren_seen = FALSE;

		next_tok(tp);
		skip_hws_tok(tp);

		if (*tp != ID_TOK &amp;&amp; *tp != LPAREN_TOK) {
			error(
				es("Id or '(' expected after 'defined', ");
				es(tok_name(*tp)); es(" found");
			);
			goto bad_expr2;
		}
		paren_seen = (*tp == LPAREN_TOK);
		if (paren_seen) {
			next_tok(tp);
			skip_hws_tok(tp);
			if (*tp != ID_TOK) {
				error(
					es("Id expected after '(', ");
					es(tok_name(*tp)); es(" found");
				);
				goto bad_expr2;
			}
		}

		if (is_id(*tp) &amp;&amp; (id_tok_ptr(tp)) -&gt; spell_macro != NULL) {
			push_val(1L, SIGNED_VAL);
		}
		else {
			push_val(0L, SIGNED_VAL);
		}
		next_tok(tp);
		if (paren_seen) {
			if (*tp == RPAREN_TOK) {
				next_tok(tp);
			}
			else {
				error(
					es("')' expected, ");
					es(tok_name(*tp)); es(" found\n");
				);
				goto bad_expr2;
			}
		}
		break;
	}

	case LPAREN_TOK:
	{
		long result = 0;

		/* Evaluate the expression recursively. */
		next_tok(tp);
		tp = eval(tp, &amp;result);
		if (*tp = RPAREN_TOK) {
			next_tok(tp);
			push_val(result, SIGNED_VAL);
		}
		else {
			error(
				es("')' expected, ");
				es(tok_name(*tp)); es(" found\n");
			);
			goto bad_expr2;
		}
		break;
	}

	default:
		if (is_id(*tp)) {
			if ((id_tok_ptr(tp)) -&gt; spell_macro != NULL) {

				tp = mac_outer_expand(tp);

				/* Still expecting an identifier. */
				goto s1;
			}
			else {
				push_val(0L, SIGNED_VAL);
				next_tok(tp);
				break;
			}
		}
		else if (*tp == IDX_TOK) {
			push_val(0L, SIGNED_VAL);
			next_tok(tp);
			break;
		}
		else {
			error(
				es("Constant or '(' expected, ");
				es(tok_name(*tp)); es(" found\n");
			);
			goto bad_expr2;
		}
	}

	/* Perform all unary ops and enter state S2. */

	TRACEPN(ftagv, es("at state 1A\n"));

	while (op_ptr &gt; op_1ptr) {

		token op = 0;

		switch (op = pop_op()) {

		case UPLUS_TOK:
			break;
			
		case UMINUS_TOK:
		{
			bool unsigned_flag;
			unsigned long uval = pop_val(&amp;unsigned_flag);
			
			if (unsigned_flag) {
				uval = - uval;
				push_val(uval, UNSIGNED_VAL);
			}
			else {
				long val = uval;
				val = - val;
				push_val(val, SIGNED_VAL);
			}
			break;
		}
			
		case NOT_TOK:
		{
			bool unsigned_flag;
			unsigned long uval = pop_val(&amp;unsigned_flag);
			push_val(!uval, unsigned_flag);
			break;
		}

		case TILDE_TOK:
		{
			bool unsigned_flag;
			unsigned long uval = pop_val(&amp;unsigned_flag);
			push_val(~uval, unsigned_flag);
			break;
		}
		
		default: push_op(op); goto s2;
		}
	}

	/* State S2: binary op or end_of_expression expected here. */

s2:
	skip_hws_tok(tp);

	TRACEPN(ftagv, es("state 2: "); es(tok_name(*tp)); enl());

		/*
		Perform binary operators until the operator stack is
		empty or until token operator has a higher precedence
		than the operator on the top of the operator stack.
	*/

	if (op_ptr &gt; op_1ptr &amp;&amp; gt_prec(op_stack[op_ptr - 1], *tp)) {
	
		bool unsigned_flag1 = 0;
		bool unsigned_flag2 = 0;
		
		/* The result is unsigned if either operand is unsigned. */
		ulong uval2 = pop_val(&amp;unsigned_flag1);
		ulong uval1 = pop_val(&amp;unsigned_flag2);
		
		bool unsigned_flag = unsigned_flag1 || unsigned_flag2;

		token op = pop_op();
		
		/*
			Bug fix: 8/29/94:
			The bit pattern we get will depend on whether val1 and val2
			are considered to be signed or unsigned numbers.
			
			Example:  val1 = 0xffffffff; val2 = 2;
			
			unsigned: val1/val1 = 0x7fffffff;
			signed:   val1/val2 = (-1)/2 = 0;
		*/
		
		if (unsigned_flag) {

			switch (op) {
			case PLUS_TOK:		push_val(uval1 +  uval2, unsigned_flag);	goto s2;
			case MINUS_TOK:		push_val(uval1 -  uval2, unsigned_flag);	goto s2;
			case STAR_TOK:		push_val(uval1 *  uval2, unsigned_flag);	goto s2;
			case DIV_TOK: push_val((uval2?(uval1/uval2):0), unsigned_flag);	goto s2;
			case MOD_TOK:		push_val(uval1 %  uval2, unsigned_flag);	goto s2;
			case AND_TOK:		push_val(uval1 &amp;  uval2, unsigned_flag);	goto s2;
			case OR_TOK:		push_val(uval1 |  uval2, unsigned_flag);	goto s2;
			case XOR_TOK:		push_val(uval1 ^  uval2, unsigned_flag);	goto s2;
			case LSHIFT_TOK:	push_val(uval1 &lt;&lt; uval2, unsigned_flag);	goto s2;
			case RSHIFT_TOK:	push_val(uval1 &gt;&gt; uval2, unsigned_flag);	goto s2;
			case EQUAL_TOK:		push_val(uval1 == uval2, unsigned_flag);	goto s2;
			case NE_TOK:		push_val(uval1 != uval2, unsigned_flag);	goto s2;
			case LT_TOK:		push_val(uval1 &lt;  uval2, unsigned_flag);	goto s2;
			case GT_TOK:		push_val(uval1 &gt;  uval2, unsigned_flag);	goto s2;
			case LE_TOK:		push_val(uval1 &lt;= uval2, unsigned_flag);	goto s2;
			case GE_TOK:		push_val(uval1 &gt;= uval2, unsigned_flag);	goto s2;
			case LAND_TOK:		push_val(uval1 &amp;&amp; uval2, unsigned_flag);	goto s2;
			case LOR_TOK:		push_val(uval1 || uval2, unsigned_flag);	goto s2;
	
			case COLON_TOK:
	
				if (pop_op() != QUESTION_TOK) {
					error(
						es("question mark expected, ");
						es(tok_name(*tp)); es(" found\n");
					);
					goto bad_expr2;
				}
				{
					bool junk;
					push_val(pop_val(&amp;junk) ? uval1 : uval2, unsigned_flag);
				}
				goto s2;
	
			default:
				goto bad_expr;
			}
		}
		else {
		
			long val1 = uval1;
			long val2 = uval2;
		
				switch (op) {
			case PLUS_TOK:		push_val(val1 +  val2, unsigned_flag);	goto s2;
			case MINUS_TOK:		push_val(val1 -  val2, unsigned_flag);	goto s2;
			case STAR_TOK:		push_val(val1 *  val2, unsigned_flag);	goto s2;
			case DIV_TOK: push_val((val2?(val1/val2):0), unsigned_flag); goto s2;
			case MOD_TOK:		push_val(val1 %  val2, unsigned_flag);	goto s2;
			case AND_TOK:		push_val(val1 &amp;  val2, unsigned_flag);	goto s2;
			case OR_TOK:		push_val(val1 |  val2, unsigned_flag);	goto s2;
			case XOR_TOK:		push_val(val1 ^  val2, unsigned_flag);	goto s2;
			case LSHIFT_TOK:	push_val(val1 &lt;&lt; val2, unsigned_flag);	goto s2;
			case RSHIFT_TOK:	push_val(val1 &gt;&gt; val2, unsigned_flag);	goto s2;
			case EQUAL_TOK:		push_val(val1 == val2, unsigned_flag);	goto s2;
			case NE_TOK:		push_val(val1 != val2, unsigned_flag);	goto s2;
			case LT_TOK:		push_val(val1 &lt;  val2, unsigned_flag);	goto s2;
			case GT_TOK:		push_val(val1 &gt;  val2, unsigned_flag);	goto s2;
			case LE_TOK:		push_val(val1 &lt;= val2, unsigned_flag);	goto s2;
			case GE_TOK:		push_val(val1 &gt;= val2, unsigned_flag);	goto s2;
			case LAND_TOK:		push_val(val1 &amp;&amp; val2, unsigned_flag);	goto s2;
			case LOR_TOK:		push_val(val1 || val2, unsigned_flag);	goto s2;
	
			case COLON_TOK:
	
				if (pop_op() != QUESTION_TOK) {
					error(
						es("question mark expected, ");
						es(tok_name(*tp)); es(" found\n");
					);
					goto bad_expr2;
				}
				{
					bool junk;
					push_val(pop_val(&amp;junk) ? val1 : val2, unsigned_flag);
				}
				goto s2;
	
			default:
				goto bad_expr;
			}
		}
	}

	/* Enter state S1 or return on end-of-expression. */

	skip_hws_tok(tp);

	if (*tp == END_PROG_TOK || *tp == HIDDEN_END_FILE_TOK ||
		*tp == WS_NL_TOK || *tp == RPAREN_TOK ||
		*tp == COMMENT_TOK
	) {
		bool junk;
		*val_p = pop_val(&amp;junk);
		goto done;
	}
	else {
		push_op(*tp);
		next_tok(tp);
		goto s1;
	}

bad_expr:
	if (!error_seen) {
		error(es("Bad constant expression--zero assumed\n"));
	}

bad_expr2:
	error_seen = TRUE;
	* val_p = 0L;
	TRACEPX(ftag,
		es("error: result=0L; remain: ");
		tok_dump_line(tp));
	return tp;

done:
	TRACEPX(ftag, es("*val_p: "); elong(*val_p); enl());
	return tp;
}
</t>
<t tx="ekr.20080529093004.219">@ Return TRUE if a reduction is possible with op1 on the operator stack  and op2 as the new operator.   Always return TRUE if op2 delimits the expression, otherwise return TRUE if op1 has higher precedence than op2, otherwise return TRUE if they associate left to right.  This code reflects the table on page 49 of K &amp; R.
@c

static bool
gt_prec(register token op1, register token op2)
{
	TRACEP("gt_prec", es(tok_name(op1)); ecs(); es(tok_name(op2)); enl());

	if (op2 == RPAREN_TOK || op2 == NULL_TOK ||
		op2 == WS_NL_TOK ||
		op2 == END_PROG_TOK || op2 == HIDDEN_END_FILE_TOK) {
		return TRUE;
	}

	{
		register int prec1 = prec((int)op1);
		register int prec2 = prec((int)op2);
	
		if (prec1 != prec2) {
			/* Associativity doesn't matter. */
			return prec1 &gt; prec2;
		}
		else if (prec1 == 14 || prec1 == 3 || prec1 == 2) {
			/* Associate right to left. */
			return FALSE;
		}
		else {
			/* Associate left to right. */
			return TRUE;
		}
	}
}
</t>
<t tx="ekr.20080529093004.220">@ Return the precedence of an operator.  This code reflects the table on page 49 of K &amp; R.
@c

static int
prec(int operator)
{
	TRACEP("prec", elp(); es(tok_name(operator)); erpnl());

	switch (operator) {
	case TILDE_TOK:		return 14;
	case STAR_TOK:
	case DIV_TOK:
	case MOD_TOK:		return 13;
	case PLUS_TOK:
	case MINUS_TOK:		return 12;
	case LSHIFT_TOK:
	case RSHIFT_TOK:	return 11;
	case LT_TOK:
	case LE_TOK:
	case GT_TOK:
	case GE_TOK:		return 10;
	case EQUAL_TOK:
	case NE_TOK:		return 9;
	case XOR_TOK:		return 7;
	case OR_TOK:		return 6;

	default:			return -1;
	}
}
</t>
<t tx="ekr.20080529093004.221">@ Routines to push and pop the operator and operand stacks.
@c

static void
push_op(token op)
{
	FTAG("push_op");
	TRACEP(ftag, elp(); es(tok_name(op)); erpnl());

	if (op_ptr &lt; MAX_EVAL_OP) {
		op_stack[op_ptr++] = op;
	}
	else {
		fatal(es("Operator stack overflow"));
	}
}
</t>
<t tx="ekr.20080529093004.222">static token
pop_op(void)
{
	FTAG("pop_op");
	SL_DISABLE();

	if (op_ptr &gt; 0) {
		TRACEP(ftag, eret(); es(tok_name(op_stack[op_ptr - 1])); enl());
		return op_stack [--op_ptr];
	}
	else {
		fatal(es("Operator stack underflow"));
		return NULL_TOK;
	}
}
</t>
<t tx="ekr.20080529093004.223">static void
push_val(long val, bool unsigned_flag)
{
	FTAG("push_val");
	TRACEPB(ftag, elong(val); ecs(); ebool(unsigned_flag));

	if (val_ptr &lt; MAX_EVAL_VAL) {
		val_stack  [val_ptr] = val;
		type_stack [val_ptr++] = unsigned_flag;
	}
	else {
		fatal(es("Value stack overflow"));
	}
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.224">static long
pop_val(bool * unsigned_flag)
{
	FTAG("pop_val");
	STATB(ftag);

	if (val_ptr &gt; 0) {
		*unsigned_flag = type_stack[val_ptr-1];
		
		TRACEPX(ftag, eret(); elong(val_stack [val_ptr - 1]); enl());
		return val_stack [--val_ptr];
	}
	else {
		fatal(es("Value stack underflow"));
	}
}
</t>
<t tx="ekr.20080529093004.225">@ Skip lines for #if, #ifdef, #ifndef, #elif or #else directives.  If skip_all_flag, skip until an #endif at the current level is found. If skip_all_flag is FALSE, skip until #else, #elif or #endif.  Interior #if, #ifdef, #ifndef, #elif, #else and #endif directives must be recognized and dealt with.
@c

static token *
skip_lines(register token * tp, char * directive_name, bool skip_all_flag)
{
	FTAG("skip_lines");
	register int level = 0;			/* Inner nesting level */
	long first_line = err_line;
	STATB(ftag);

	/* Just in case. */
	if (if_level &lt;= 0) {
		fatal(es("skip_lines: Can't happen"));
	}

	/*
		One line is scanned each time through this while loop.
	*/
	while(*tp != HIDDEN_END_FILE_TOK &amp;&amp; *tp != END_PROG_TOK) {

		token * first = tp;

		/* Skip the line if it doesn't start with '#'. */
		skip_hws_tok(tp);
		if (*tp != POUND_TOK) {

			TRACEPN(ftag, tok_dump_line(first));
			tp = skip_past(tp);
			continue;
		}

		/* Skip the '#'. */
		next_tok(tp);
		skip_hws_tok(tp);

		switch(*tp) {

		case K_IFDEF:
		case K_IFNDEF:
		case K_IF:

			level++;
			TRACEPN(ftag, tok_dump_line(first));
			tp = skip_past(tp);
			break;

		case K_ELIF:

			if (level == 0 &amp;&amp; !skip_all_flag) {

				long result;

				/* Skip the elif */
				next_tok(tp);

				error_seen = FALSE;
				tp = eval(tp, &amp;result);
				if (result != 0L) {
					TRACEPN(ftag, es("stopped by #elif\n"));
					goto done;
				}
			}

			TRACEPN(ftag, tok_dump_line(first));
			tp = skip_past(tp);
			break;

		case K_ELSE:

			if (level == 0 &amp;&amp; !skip_all_flag) {
				if (if_stack [if_level - 1] == FALSE) {
					if_stack [if_level - 1] = TRUE;
					TRACEPN(ftag, es("stopped by #else\n"));
					goto done;
				}
				else {
					error(es("Extra #else ignored"));
					break;
				}
			}

			TRACEPN(ftag, tok_dump_line(first));
			tp = skip_past(tp);
			break;

		case K_ENDIF:

			if (level &gt; 0) {
				level--;
			}
			else {
				if_level--;
				TRACEPN(ftag, es("stopped by #endif\n"));
				goto done;
			}

			TRACEPN(ftag, tok_dump_line(first));
			tp = skip_past(tp);
			break;

		default:

			TRACEPN(ftag, tok_dump_line(first));
			tp = skip_past(tp);
		}
	}

	error(
		es("File ends in ");
		es(directive_name); es(" at line ");
		elong(first_line);
	);

	TRACEPX(ftag, eptr(tp); ecnl());
	return tp;

done:
	tp = skip_pp(tp);
	STATX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.226">@ Skip over one line, including the trailing newline. This should be called only by skip_lines(). (If called elsewhere cpp() will not see the newline.)
@c

static token *
skip_past(register token * tp)
{
	FTAG("skip_past");
	TRACEPB(ftag, tok_dump_line(tp));

	while (	*tp != WS_NL_TOK &amp;&amp;
			*tp != HIDDEN_END_FILE_TOK &amp;&amp;
			*tp != END_PROG_TOK) {
		next_tok(tp);
	}
	if (*tp == WS_NL_TOK) {
		err_line++;
		next_tok(tp);
	}

	TRACEX(ftag, enl());
	return tp;
}
</t>
<t tx="ekr.20080529093004.227">@ Skip over a preprocessor directive. Stop at a newline so it will be seen in the main cpp loop.
@c

token *
skip_pp(register token * tp)
{
	FTAG("skip_pp");
	TRACEPB(ftag, tok_dump_line(tp));

	while (	*tp != WS_NL_TOK &amp;&amp;
			*tp != HIDDEN_END_FILE_TOK &amp;&amp;
			*tp != END_PROG_TOK) {
		next_tok(tp);
	}

	TRACEX(ftag, enl());
	return tp;
}
</t>
<t tx="ekr.20080529093004.228">/*
	AS: macro definition and processing routines.
	  
	source:  ASmacro.c
	started: February 25, 1992
	version:
		June 12, 1994.
			obj_new_macro must be used to allocate actual nargs arrays because
				a token life would not handle recursion properly.
		December 22, 1993.
			Initialized all local variables to NULL or 0.
*/

&lt;&lt; ASmacro #includes &gt;&gt;
&lt;&lt; ASmacro declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.229">#include "AS.h"

#include "AScpp.h"
#include "ASmacro.h"
#include "ASmem.h"
#include "ASmst.h"
#include "AStokens.h"
#include "AStokize.h"

#include &lt;LIBio.h&gt;
#include &lt;LIBlist.h&gt;
#include &lt;LIBobj.h&gt;

#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.230">/*
	Define global variables owned by this file.
*/
mac_def_node *	mac_mdef_list = NULL;	/* List of macro definitions. */

/*
	Variables and structures local to this file.
*/
static long mac_hidden_nl = 0;	/* Hidden newlines seen in mac_parse_actuals. */

typedef struct mac_disable_struct mac_disable_node;

/* The list of disabled macro names. */
static struct mac_disable_struct {
	mac_disable_node *	dis_next;
	spell_node *		dis_spell;
};

static mac_disable_node * mac_disable_list = NULL;

/*
	Refuse to expand the macro if current recursion depth exceeds the
	maximum recursion depth.  This protects the assembler's stack.
*/

#define MAX_EXPAND_DEPTH 50

static int mac_expand_depth = 0;

/*
	Function prototypes of internal routines.
*/
static bool		mac_compare_fargs	(int nargs, char ** fp, mac_def_node *mdef_p);
static bool		mac_compare_rtexts	(token * tp1, token * tp2);
static token *	mac_expand
	(token * tp, token * bound_tp, token ** res_last);
static void		mac_expand_arg		(token ** ap_first, token ** ap_last);
static token *	mac_get_actuals
	(token * tp, token *** ap_first, token *** ap_last,
	token *** exp_first, token *** exp_last, int * nargs, token * bound_tp);
static token *	mac_get_formals		(token * tp, char  *** fp, int * nargs);
static token *	mac_parse_actuals
	(token * tp, token ** ap_first, token ** ap_last, int * nargs, token * bound_tp);
static token *	mac_parse_formals	(token * tp, char ** fp, int * nargs);
static token *	mac_paste_tokens
	(token * tp1, token * bound_tp, token ** ap_first, token ** ap_last);
static token * mac_rescan
	(token * res_first, token * res_bound, token * res_last, spell_node * spell_p);
static void		mac_special		(token * tp, spell_node * spell_p);
static char *	mac_stringize	(token * tp_first, token * tp_last);
static token *	mac_substitute
	(spell_node * spell_p, token * rtokens,
	token ** ap_first, token ** ap_last, token ** exp_first, token ** exp_last,
	token ** res_first, token ** res_bound, token ** res_last,
	int nargs, token * tp_follow, long hidden_nl);
</t>
<t tx="ekr.20080529093004.231">@ Return TRUE if the spelling of all formal arguments are identical.
@c

static bool
mac_compare_fargs(int nargs, char ** names1, mac_def_node *mdef_p)
{
	FTAG("mac_compare_fargs");
	register int i = 0;
	register char ** names2 = mdef_p -&gt; mac_names;
	STATB(ftag);

	if (nargs != mdef_p -&gt; mac_nargs) {
		TRACEPX(ftag, eret(); es("FALSE (nargs)"));
		return FALSE;
	}

	for (i = 0; i &lt; nargs; i++) {
		if (!str_eq(names1[i], names2[i])) {
			TRACEPX(ftag, eret(); ebool(FALSE));
			return FALSE;
		}
	}

	TRACEPX(ftag, eret(); ebool(TRUE));
	return TRUE;
}
</t>
<t tx="ekr.20080529093004.232">@ Return TRUE if two macro replacement texts are identical.
@c

static bool
mac_compare_rtexts(register token * tp1, register token * tp2)
{
	FTAG("mac_compare_rtexts");
	TRACEPB(ftag,
		enl();
		tok_dump_line2(tp1,
			PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_NON_USER_TOKENS);
		ecnl();
		tok_dump_line2(tp2,
			PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_NON_USER_TOKENS);
		ecnl();
	);

	while (*tp1 != WS_NL_TOK) {

		switch(*tp1) {

		case MACRO_ARG_TOK:

			/* Make sure the argument numbers are the same. */
			if (*tp2 != MACRO_ARG_TOK ||
				val_tok_val(tp1) != val_tok_val(tp2)) {
				goto false_return;
			}
			break;

		case CHAR_TOK:
		case FILE_NAME_TOK:
		case FLOAT_TOK:
		case ID_TOK:		/* suppresses switch. */
		case IDX_TOK:
		case INT_TOK:
		case STRING_TOK:

			/* Make sure the spellings are the same. */
			if (*tp1 != *tp2 ||
				!str_eq(ptr_tok_ptr(tp1), ptr_tok_ptr(tp2))) {
				goto false_return;
			}
			break;

		case WS_TOK:		/* suppresses switch. */
		case WS_NL_TOK:		/* suppresses switch. */

			/* The 2 kinds of blanks compare equal. */
			if (*tp2 != WS_TOK &amp;&amp; *tp2 != WS_BLANKS_TOK) {
				goto false_return;
			}
			break;

		default:
			if (*tp1 != *tp2) {
				goto false_return;
			}
		}

		/* Equal so far. Go on. */
		next_tok(tp1);
		next_tok(tp2);
	}

	TRACEPX(ftag, eret(); ebool(*tp2 == WS_NL_TOK));
	return *tp2 == WS_NL_TOK;

false_return:
	TRACEPX(ftag, eret(); ebool(FALSE));
	return FALSE;
}
</t>
<t tx="ekr.20080529093004.233">@ Handle the #define directive. If special_flag is true, we define a special macro such as __line__.  The replacement text is massaged in place because it will never need to be printed. The replacement text is guaranteed to end in a newline.
@c

token *
mac_define (register token * tp, bool special_flag)
{
	FTAG("mac_define");
	FTAGV("-mac_define_v");
	register spell_node * spell_p = NULL;		/* The spelling of the macro. */
	register mac_def_node *	prev_mdef_p = NULL;	/* Previous macro def. */

	char **	fp = NULL;		/* Formal parameter descriptor. */
	int nargs = 0;			/* Number of formal arguments. */
	char * name = NULL;		/* macro name. */
	token *	rtext = NULL;	/* First token of new replacement text. */
	token * old_tp = NULL;	/* Saved ptr at original rtext. */
	TRACEPB(ftag, tok_dump_line(tp));

	/* Skip the define. */
	next_tok(tp);
	skip_hws_tok(tp);

	/* Make sure the name is present. */
	if (!is_id(*tp)) {
		error(es("#define ignored--no symbol name given"));
		tp = skip_pp(tp);
		goto done;
	}

	/* 
		Reject any user attempt to redefine "defined", __time__, etc.
	*/
	if (!special_flag &amp;&amp; is_nodef(*tp)) {
		error(es("can not redefine "); es(tok_name(*tp)));
		tp = skip_pp(tp);
		goto done;
	}

	/* Remember the macro name. */
	spell_p = id_tok_ptr(tp);
	name = spell_p -&gt; spell_name;
	prev_mdef_p = spell_p -&gt; spell_macro;

	ASSERT(spell_p);
	TRACEPN(ftag, es("name: "); es(name));

	/* Move past the macro name. */
	next_tok(tp);

	/*
		Do nothing if the name has been #undef'd on the command line.
		(The call to mst_is_undef will disable the #undef.)
	*/
	if (mst_is_undef(name)) {
		TRACEPN(ftag, es("#define "); es(name); es("cancelled by #undef\n"));
		tp = skip_pp(tp);
		goto done;
	}

	/* Put the formal arguments into a block that fp points to. */

	{
		token * old_tp = tp;

		tp = mac_get_formals(tp, &amp;fp, &amp;nargs);
		TRACEN(ftag, es(", nargs = "); eint(nargs); enl());

		if (nargs == -2) {
			/* An error was found.  Create no macro_def node. */
			tp = skip_pp(old_tp);
			goto done;
		}
	}

	/*
		At this point, nargs contains the number of formal arguments,
		or -1 if no argument list was given.
		0 is allowed and means that the argument list was ().

		fp[] contains pointers to the formal identifiers.
		fp[*nargs] == NULL;
		tp points past the formals.
	*/

	TRACEN(ftag,
		int i = 0;
		ecnl();
		for (i = 0; nargs &gt; 0 &amp;&amp; i &lt;= nargs; i++) {
			es("fp["); eint(i); es("] = ");
			es( (fp[i] == NULL) ? "NULL" : fp[i] ); enl();
		}
	);

	ASSERT(nargs &lt;= 0 || fp[nargs] == NULL);

	/*
		Scan the replacement text:

		Delete white space around # and ## and before newlines.
		Replace sequences of white space by a single blank.
		Replace formal argument n by MACRO_ARG_TOK(n).

		The file is guaranteed to end in a newline,
		so we need not test for HIDDEN_END_FILE_TOK.
	*/

	/* Point rtext at the first non-white space token of the replacement text. */
	skip_hws_tok(tp);
	if (*tp == POUND_POUND_TOK) {
		error(es("## not valid at the start of a macro replacement text"));
		tok_ignore(tp);
		next_tok(tp);
	}
	rtext = tp;

	/*
		Make a copy of the replacement text so error messages contain
		the original spellings of macro arguments.

		Save the pointer to the original rtext for skip_pp().
	*/
	{
		token * junk = NULL;
		old_tp = tp;
		tp = tok_copy2nl(rtext, &amp;junk, "rtext");
		rtext = tp;
		tok_copy(WS_NL_TOK, NULL);
	}

	while (*tp != WS_NL_TOK) {

		/* Replace sequences of white space by a single blank. */
		if (is_ws(*tp)) {

			token * start_ws = tp;

			/* Convert the first white space token to a single blank. */
			if (tok_size(*tp) == SMALL_TOKEN_SIZE) {
				*tp = WS_TOK;
			}
			else {
				*tp = WS_BLANKS_TOK;
				patch_val_tok(tp,1);
			}

			/* Ignore all following white space tokens. */
			next_tok(tp);
			while(is_ws(*tp) &amp;&amp; *tp != WS_NL_TOK) {
				tok_ignore(tp);
				next_tok(tp);
			}

			/* Ignore white space before newlines, # and ## operators. */
			if (*tp == WS_NL_TOK || *tp == POUND_TOK || *tp == POUND_POUND_TOK) {
				tok_ignore(start_ws);
			}
		}

		/* Delete white space after # and ## operators. */
		if (*tp == POUND_TOK || *tp == POUND_POUND_TOK) {
			next_tok(tp);
			while(is_ws(*tp) &amp;&amp; *tp != WS_NL_TOK) {
				tok_ignore(tp);
				next_tok(tp);
			}
		}

		/* Replace a formal parameter by MACRO_ARG_TOK(i). */
		if (is_id(*tp)) {

			register int i = 0;
			spell_node * arg_spell_p = id_tok_ptr(tp);
			register char * name = arg_spell_p -&gt; spell_name;

			/* See if it is a formal argument. */
			for (i = 0; i &lt; nargs; i++) {
				if (str_eq(name, fp[i])) {
					break;
				}
			}
			if (i != nargs &amp;&amp; nargs &gt; 0) {
				*tp = MACRO_ARG_TOK;
				patch_val_tok(tp, i);
			}
		}
		if (*tp != WS_NL_TOK) {
			next_tok(tp);
		}
	}

	/* Allocate a new node if the symbol has not been defined. */
	if (prev_mdef_p == NULL) {

		mac_def_node * 	mdef_p = NULL;
		new_file_macro(mdef_p, macro_stats);
		mdef_p -&gt; mac_rtokens	= rtext;
		mdef_p -&gt; mac_nargs		= nargs;
		mdef_p -&gt; mac_names		= fp;
		mdef_p -&gt; mac_spell		= spell_p;
		spell_p -&gt; spell_macro	= mdef_p;

		lst_add_macro(mdef_p, mac_mdef_list);
	}
	else if (special_flag) {
		/* Redefine __line__, etc. */
		spell_p -&gt; spell_macro -&gt; mac_rtokens = rtext;
	}
	else {
		/* Make sure the two definitions are identical. */

		if (!mac_compare_rtexts(rtext, prev_mdef_p -&gt; mac_rtokens) ||
			!mac_compare_fargs(nargs, fp, prev_mdef_p)) {

			error(
				es("invalid non-identical redefinition of "); es(name);
				es(" ignored");

				TRACEPN(ftag, 
					es("old: "); tok_dump_line(prev_mdef_p -&gt; mac_rtokens); ecnl();
					es("new: "); tok_dump_line(rtext); ecnl();
				);
			);
		}
		else {
			TRACEPN(ftag, es("duplicate #define "); es(name); ecnl());
		}
	}

	/* Skip past the original rtext, not the copy. */
	tp = skip_pp(old_tp);

done:
	TRACEPX(ftag, mst_dump_mdef(spell_p -&gt; spell_macro));
	return tp;
}
</t>
<t tx="ekr.20080529093004.234">@ Enter a command-line macro definition. If special_flag is true, we define a special macro such as __line__.
@c

void
mac_define_string(char * name, char * def, bool special_flag)
{
	FTAG("mac_define_string");
	io_mem_block block;
	char * p = NULL;
	token * tp = NULL;
	size_t length = 0;
	STATB(ftag);

	/* Create a memory block with a simulated #define. */
	ASSERT(name);

	if (def == NULL) {
		/* Do not pass a NULL string to new_perm_cat4_macro! */
		new_perm_cat4_macro(p, name, " ", " ", "\n   ");
	}
	else {
		new_perm_cat4_macro(p, name, " ", def, "\n   ");
	}

	length = strlen(p)-1;
	p [length] = IO_EOF_CHAR;
	block . mem_start = p;
	block . mem_length = length;
	block . mem_freep = NULL;

	/* Tokenize the block and use mac_define to do the work. */
	tp = tokize(&amp;block, NULL, name, END_WITH_EOF_TOK, NULL);

	/*
		The first token is HIDDEN_BEGIN_FILE_TOK.
		The next is WS_NL_TOK, which mac_define will skip.
	*/
	next_tok(tp);
	(void) mac_define(tp, special_flag);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.235">@ Inner macro expansion.  bound_tp points to the bounding token, or NULL for an unbounded scan.  Return a pointer to the first token of the expansion or NULL if the expansion was aborted because of a bound.  Point *res_last_param to the last token of the expansion. (res_last_param is used in traces in mac_outer_expand.)  Refuse to expand the macro if current recursion depth exceeds the maximum recursion depth. This protects the assembler's stack.
@c

token *
mac_expand(register token * tp, token * bound_tp, token ** res_last_param)
{
	FTAG("mac_expand");

	spell_node *	spell_p;	/* Ptr to macro's spelling node. */
	mac_def_node *	mdef_p;		/* Ptr to macro's replacement text. */
	token *			id_tp;		/* Ptr to macro's id token. */
	token **		ap_first;	/* Ptr to block of token pointers. */
	token **		ap_last;	/* Ptr to block of token pointers. */
	token **		exp_first;	/* Ptr to block of token pointers. */
	token **		exp_last;	/* Ptr to block of token pointers. */
	token *			res_first;	/* Ptr to first substituted token. */
	token *			res_bound;	/* Ptr to trailing BOUND_TOK token. */
	token *			res_last;	/* Ptr to last HIDDEN_SKIP_TOK. */
	int				nargs;		/* Number of actual arguments. */
	char *			name;		/* Namber of the macro. */
	int		expected_nargs;		/* Number of formal arguments. */
	long			hidden_nl;	/* Saved hidden newlines. */

	ASSERT(is_id(*tp) &amp;&amp; (id_tok_ptr(tp)) -&gt; spell_macro);
	ASSERT(res_last_param);
	ASSERT(bound_tp == NULL || *bound_tp == BOUND_TOK);

	if (++mac_expand_depth &gt; MAX_EXPAND_DEPTH) {

		error(es("expansion thwarted by recursion bound\n"));
		return NULL;
	}

	/* Set various quantities. */
	spell_p			= id_tok_ptr(tp);
	mdef_p			= spell_p -&gt; spell_macro;
	name			= spell_p -&gt; spell_name;
	expected_nargs	= mdef_p -&gt; mac_nargs;
	id_tp 			= tp;
	*res_last_param = NULL;
	hidden_nl = 0;

	TRACEPB(ftag,
		es("name: "); es(spell_p -&gt; spell_name);
		es(" bound: "); eptr(bound_tp); enl());

	if (is_nodef(*tp)) {

		/* Patch the special identifier into the token list. */
		mac_special(tp, spell_p);
		*res_last_param = tp;

		STATX(ftag);
		return tp;
	}

	/* Skip the identifier. */
	next_tok(tp);

	if (tp == bound_tp &amp;&amp; expected_nargs &gt;= 0) {

		TRACEPN(ftag, es("expansion thwarted by bound\n"));
		goto null_expand;
	}

	/* Parse the actual args and point ap at a block of pointers to the actuals. */
	if (expected_nargs &gt;= 0) {

		tp = mac_get_actuals(tp,
			&amp;ap_first, &amp;ap_last,
			&amp;exp_first, &amp;exp_last, &amp;nargs, bound_tp);

		/*
			Make sure the number of arguments match.
			Give no warning on bounded scan.

			If symbol s is a macro with expected_nargs &gt; -1, it is *not*
			an error to see just plain s.  For example: goto s;
		*/
		if (nargs != expected_nargs &amp;&amp; bound_tp == NULL &amp;&amp;
			expected_nargs &gt; -1 &amp;&amp; nargs &gt; -1 &amp;&amp;
			!(expected_nargs == 0 &amp;&amp; nargs == 1)
		) {
			error(
				es("macro "); es(name);
				es(" expects "); eint(expected_nargs);
				es(" argument"); es( (expected_nargs == 1) ? "" : "s");
			);
			goto null_expand;
		}
		else if (nargs != expected_nargs) {

			TRACEPN(ftag, es((bound_tp == NULL) ?
				"expansion thwarted by missing arguments\n" :
				"expansion and get_args thwarted by bound\n"));

			goto null_expand;
		}

		hidden_nl = mac_hidden_nl;
	}
	else {
		ap_first = ap_last = NULL;
		nargs = -1;
		TRACEPN(ftag, es("nargs: -1\n"));
	}

	if (nargs &gt; 0) {

		register int i = 0;

		TRACEPN(ftag,
			es("actual args: \n\n");
			for (i = 0; i &lt; nargs; i++) {
				es("actual "); eint(i); es(": ");
				tok_dump_list(ap_first[i], ap_last[i]);
				ecnl();
				es("=\n");
				es("actual "); eint(i); es(": ");
				tok_dump_list2(ap_first[i], ap_last[i], DONT_PRINT_HIDDEN_TOKS);
				ecnl();
			}
			enl();
		);

		/* Fully expand each actual arg with bounded rescan. */
		for(i = 0; i &lt; nargs; i++) {
			mac_expand_arg(&amp;exp_first[i], &amp;exp_last[i]);
		}

		TRACEPN(ftag,
			es("expanded args: \n\n");
			for (i = 0; i &lt; nargs; i++) {
				es("expanded "); eint(i); es(": ");
				tok_dump_list(exp_first[i], exp_last[i]);
				ecnl();
				es("=\n");
				es("expanded "); eint(i); es(": ");
				tok_dump_list2(exp_first[i], exp_last[i], DONT_PRINT_HIDDEN_TOKS);
				ecnl();
			}
			enl();
		);
	}

	/*
		Create the final replacement text.
		Replace the macro id with a jump to the replacement text.
	*/
	{
		token * new_rtext = mac_substitute(
			spell_p,
			mdef_p -&gt; mac_rtokens,
			ap_first, ap_last,
			exp_first, exp_last,
			&amp;res_first,
			&amp;res_bound,
			&amp;res_last,
			nargs,
			tp,
			hidden_nl);

		tok_patch(id_tp, HIDDEN_SKIP_TO_MACRO_TOK,
			new_rtext, "skip to final rtext");
	}

	/* Rescan the text, looking for identifiers to disable. */
	{
		token * dump_last = NULL;

		dump_last = mac_rescan(res_first, res_bound, res_last, spell_p);
		*res_last_param = dump_last;

		TRACEPN(ftag, eret(); enl(); enl();
			tok_dump_list(id_tp, dump_last);
			ecnl();
			es("="); enl();
			tok_dump_list2(id_tp, dump_last, DONT_PRINT_HIDDEN_TOKS);
			ecnls(2));
	}

	/* Free all the storage allocated in mac_get_actuals. */
	if (nargs &gt; 0) {
		ASSERT(ap_first &amp;&amp; ap_last &amp;&amp; exp_first &amp;&amp; exp_last);
		obj_free_macro(ap_first);
		obj_free_macro(ap_last);
		obj_free_macro(exp_first);
		obj_free_macro(exp_last);
	}

	ASSERT(*id_tp == HIDDEN_SKIP_TO_MACRO_TOK);

	mac_expand_depth--;

	STATX(ftag);
	return id_tp;

null_expand:
	mac_expand_depth--;
	*res_last_param = NULL;

	STATX(ftag);
	return NULL;
}
</t>
<t tx="ekr.20080529093004.236">@ Completely expand one actual macro argument (with bounded rescan.) Change *ap_first and *ap_last to point at the expanded argument.
@c

static void
mac_expand_arg(token ** exp_first, token ** exp_last)
{
	FTAG("mac_expand_arg");
	register token * tp = NULL;
	register token * bound_tp = NULL;
	TRACEPB(ftag,
		tok_dump_list(*exp_first, *exp_last));

	/*
		Make a copy of the actual arguments.
		Point *exp_first and *exp_last at the start and end of the new list.
		Point bound_tp at the trailing bound tok.

		This is the *only* place where bound_tp is ever set, so
		we can assert bound_tp == BOUND_TOK everywhere.
	*/
	{
		token * junk = NULL;

		*exp_first = tp = tok_copy_list(*exp_first, *exp_last, &amp;junk, "actual arg");
		*exp_last = bound_tp = tok_copy(BOUND_TOK, NULL);

		TRACEPN(ftag, tok_dump_list(*exp_first, *exp_last));
	}

	while (tp != bound_tp) {

		if (is_id(*tp)) {

			spell_node * spell_p = (spell_node *) id_tok_ptr(tp);

			if (spell_p -&gt; spell_macro != NULL) {

				token * res_last = NULL;
				token * tp_new = NULL;

				/*
					Expand the macro, and ignore res_last.
					Leave mac_disable_list unchanged: a macro name
					*may* be expanded in its own argument list!
				*/

				TRACEPN(ftag, es("recursive bounded call to mac_expand\n"));
				tp_new = mac_expand(tp, bound_tp, &amp;res_last);

				/* Check for an aborted macro call. */
				if (tp_new != NULL) {

					/*
						The macro was expanded.
						We can ignore res_last.
						Rescan the macro.
					*/

					ASSERT(tp_new == tp);
					continue;
				}
			}
		}
		next_tok(tp);
	}

	TRACEPX(ftag, eret(); tok_dump_list(*exp_first, *exp_last); ecnl());
}
</t>
<t tx="ekr.20080529093004.237">@ Put pointers to actual args into actuals.  Set *nargs to the number of formals. 0 means () was seen. -1 means no ( was seen. -2 means some syntax error was encountered.
@c

static token *
mac_get_actuals(
	register token * tp,
	token *** ap_first,		/* Ptr to a block of ptrs to the arg's start. */
	token *** ap_last,		/* Ptr to a block of ptrs to the arg's end. */
	token *** exp_first,	/* Ptr to a block of ptrs to expanded arg's start. */
	token *** exp_last,		/* Ptr to a block of ptrs to expanded arg's end. */
	int * nargs,			/* Number of arguments found. */
	token * bound_tp		/* Ptr to boundary token, or NULL. */
	)
{
	FTAG("mac_get_actuals");
	token * old_tp = tp;
	ulong array_size = 0;
	STATB(ftag);

	ASSERT(bound_tp == NULL || *bound_tp == BOUND_TOK);

	/* Scan the parameter list and set nargs. */
	tp = mac_parse_actuals(tp, NULL, NULL, nargs, bound_tp);

	if (*nargs &lt;= 0) {
		*ap_first = NULL;
		*ap_last = NULL;
		goto done;
	}
	tp = old_tp;

	/*
		Allocate space for nargs pointers and one NULL pointer at the end.
		These pointer blocks are freed at the end of mac_expand.
		
		Warning: do *not* try to use an "expansion" lifetime here!!
		This code is recursive: trying to free the expansion lifetime will not work.
	*/
	array_size = (((*nargs)+1) * sizeof(token **));

	obj_new_macro(*ap_first, array_size, "mac ap_first");
 	obj_new_macro(*ap_last, array_size, "mac ap_last");
 	obj_new_macro(*exp_first, array_size, "mac exp_first");
 	obj_new_macro(*exp_last, array_size, "mac exp_last");

	/* Rescan the parameter list, setting actuals this time. */
	{
		bool save_update = tok_update_flag;
		tok_update_flag = FALSE;
		tp = mac_parse_actuals(tp, *ap_first, *ap_last, nargs, bound_tp);
		tok_update_flag = save_update;
	}

	if (*nargs &lt;= 0) {
		fatal(es("nargs mismatch"));
	}
	else {
		memcpy(*exp_first, *ap_first, array_size);
		memcpy(*exp_last,  *ap_last,  array_size);
	}

done:
	STATX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.238">@ Put pointers to the names of the formal parameters into formals.  Set *nargs to the number of formals. 0 means () was seen. -1 means no ( was seen. -2 means some syntax error was encountered.
@c

token *
mac_get_formals(register token * tp, char *** fp, int * nargs)
{
	FTAG("mac_get_formals");
	token * old_tp = tp;
	STATB(ftag);

	/* Scan the parameter list and set nargs. */
	tp = mac_parse_formals(tp, NULL, nargs);

	if (*nargs &lt;= 0) {
		*fp = NULL;
		STATX(ftag);
		return tp;
	}
	tp = old_tp;

	/* Allocate space for nargs pointers and one NULL pointer at the end. */
	new_size_macro(*fp, ((*nargs)+1 * sizeof(char **)), file_life, other_file_stats);

	/* Rescan the parameter list, setting formals this time. */
	tp = mac_parse_formals(tp, *fp, nargs);
	if (*nargs &lt;= 0) {
		fatal(es("nargs mismatch"));
	}

	STATX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.239">@ Call mac_expand from the outer level.
@c

token *
mac_outer_expand(token * tp)
{
	FTAG("mac_outer_expand");

	TRACE("-no_outer_expand",
		if (is_id(*tp)) {
			ASSERT(tok_size(*tp) == BIG_TOKEN_SIZE);
			*tp = IDX_TOK;
			return tp;
		}
	);

	STATB(ftag);

	if (is_id(*tp)) {

		token * res_last = NULL;
		token * new_p = NULL;
		mac_disable_node the_disable_node;
		spell_node * spell_p = id_tok_ptr(tp);

		if (spell_p -&gt; spell_macro == NULL) {
			*tp = IDX_TOK;
			STATX(ftag);
			return tp;
		}

		/* The list initially contains only the one node. */
		the_disable_node . dis_spell = spell_p;
		the_disable_node . dis_next = NULL;
		mac_disable_list = &amp;the_disable_node;

		/* We are at the outer level. */
		mac_expand_depth = 0;

		new_p = mac_expand(tp, NULL, &amp;res_last);
		if (new_p == NULL) {
			/* Make sure we don't call mac_outer_expand again. */
			ASSERT(is_id(*tp));
			*tp = IDX_TOK;
		}
		else {
			tp = new_p;

			/*
				Put the trace *before* the call to tok_skip_hidden so
				we don't move past res_last!
			*/
			TRACEPN(ftag,
				es(spell_p -&gt; spell_name); eblank(); eret(); enl();
				tok_dump_list(new_p, res_last); ecnl());
		}
		ASSERT_TRACE(
			is_id(*tp) || *tp == IDX_TOK ||
			*tp == HIDDEN_SKIP_TO_MACRO_TOK ||
			*tp == INT_TOK || *tp == STRING_TOK,
			es("is: "); es(tok_name(*tp)); es(" at: "); eptr(tp); enl());

		tp = tok_skip_hidden(tp);
	}

	STATX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.240">@ Scan over list of actual parameters and check for a missing ')'.  Set the element of ap[] to point to first token of the actual arg. Set *nargs to the number of actual args. A NULL ap is valid and means that only *nargs is set. bound_tp is NULL for an unbounded scan.  8/21/92: set the global mac_hidden_nl.
@c

#define update_err_line_macro()\
if (*tp == WS_NL_TOK &amp;&amp; tok_update_flag) { err_line++; }

static token *
mac_parse_actuals(
register token * tp,
register token ** ap_first,
register token ** ap_last,
int * nargs,
token * bound_tp)
{
FTAG("mac_parse_actuals");
token * old_tp = tp;
long save_err_line = 0;
char * save_err_fname = NULL;
static token dummy_ws [2];		/* A made-up token for null arguments. */
TRACEPB(ftag,
	es("tok_update_flag: "); ebool(tok_update_flag); enl());

ASSERT(bound_tp == NULL || *bound_tp == BOUND_TOK);

/* A kludge: save the line number and file in case of error. */
save_err_line = err_line;
save_err_fname = err_fname;

/* The default is no parameters. */
if (ap_first != NULL) {
	ap_first[0] = NULL;
	ap_last[0] = NULL;
}

/* See if the next token is a '('  */
while(tp != bound_tp &amp;&amp; is_ws(*tp)) {
	update_err_line_macro();
	next_tok(tp);
}

if (*tp != LPAREN_TOK) {
	*nargs = -1;
	mac_hidden_nl = 0;
	TICKX(ftag);
	return tp;
}

/* Skip over the '(' */
next_tok(tp);

/* Test for () separately. */
while(tp != bound_tp &amp;&amp; is_ws(*tp)) {
	update_err_line_macro();
	next_tok(tp);
}

if (*tp == RPAREN_TOK) {

	/* Skip over the ')' */
	next_tok(tp);

	STATX(ftag);
	mac_hidden_nl = 0;
	*nargs = 0;
	return tp;
}

/*
	Step through the actual argument list,
	setting nargs and ap_first[] and ap_last[] if ap_first != NULL.
*/
{
	register int n = 0;
	register int paren_level = 0;
	register token * start_p = tp;
	register token * last_p = tp;
	register bool continue_flag = FALSE;

	do {

		continue_flag = (tp != bound_tp);

		switch (*tp) {

		case HIDDEN_END_FILE_TOK:
		case END_PROG_TOK:

			error(es("End-of-file in macro argument"));
			goto bad_list;

		case POUND_TOK:
			error(es("# seen in macro argument"));
			goto bad_list;

		case RPAREN_TOK:

			if (paren_level == 0) {
				if (ap_first != NULL) {
					/* 9/16/92: check for null argument. */
					if (start_p == last_p &amp;&amp; *start_p == RPAREN_TOK) {

						/* Create a dummy white space argument. */
						dummy_ws[0] = WS_TOK;
						ap_first[n] = &amp;dummy_ws[0];
						ap_last [n] = &amp;dummy_ws[0];
					}
					else {
						ap_first[n] = start_p;
						ap_last [n] = last_p;
					}
					ap_first[n+1] = NULL;
					ap_last [n+1] = NULL;
				}
				*nargs = n+1;

				/* Skip over the ')' */
				next_tok(tp);

				/* Set the number of hidden newlines. */
				if (tok_update_flag) {
					mac_hidden_nl = err_line - save_err_line;
				}
				TRACEPX(ftag,
					es("mac_hidden_nl: ");
					elong(mac_hidden_nl); enl());

				return tp;
			}
			/* Skip over the ')' */
			last_p = tp;
			next_tok(tp);
			paren_level--;
			break;

		case LPAREN_TOK:

			last_p = tp;
			next_tok(tp);
			paren_level++;
			break;

		case COMMA_TOK:

			if (paren_level == 0) {
				if (ap_first != NULL) {

					/* 9/16/92: check for null argument. */
					if (start_p == last_p &amp;&amp; *start_p == COMMA_TOK) {

						/* Create a dummy white space argument. */
						dummy_ws[0] = WS_TOK;
						ap_first[n] = &amp;dummy_ws[0];
						ap_last [n] = &amp;dummy_ws[0];
					}
					else {
						ap_first[n] = start_p;
						ap_last [n] = last_p;
					}
				}
				n++;

				/* Skip the comma. */
				next_tok(tp);

				/*
					It is not clear from the ANSI standard whether
					leading white space is part of actual args.
					(A *very* fine point.)
				*/
				while(tp != bound_tp &amp;&amp; is_ws(*tp)) {
					update_err_line_macro();
					next_tok(tp);
				}
				start_p = last_p = tp;
			}
			else {
				last_p = tp;
				next_tok(tp);
			}
			break;

		case WS_NL_TOK:
			update_err_line_macro();

			/* Fall through */

		default:
			last_p = tp;
			next_tok(tp);
		}
	} while (continue_flag);
}

/* The bound has been seen. */

TRACEPX(ftag, es("aborted by bounds\n"));
*nargs = -1;
err_line = save_err_line;
err_fname = save_err_fname;
mac_hidden_nl = 0;
return old_tp;

bad_list:
*nargs = -2;
err_line = save_err_line;
err_fname = save_err_fname;
mac_hidden_nl = 0;
TICKX(ftag);
return old_tp;
}
</t>
<t tx="ekr.20080529093004.241">@ Scan over a list of formal parameters. Set the element of fp[] to point to id's spelling. Set *nargs to the number of actual args. A NULL formals is valid and means that only *nargs is set.
@c

static token *
mac_parse_formals(register token * tp, char ** fp, int * nargs)
{
	FTAG("mac_parse_formals");
	token * old_tp = tp;
	TICKB(ftag);

	/* The default is no parameters. */
	if (fp != NULL) {
		fp[0] = NULL;
	}

	/* See if the next token, with no intervening white space, is a '('  */
	if (*tp != LPAREN_TOK) {
		*nargs = -1;
		TICKX(ftag);
		return tp;
	}

	/* Skip over the '(' */
	next_tok(tp);
	skip_hws_tok(tp);

	if (*tp == RPAREN_TOK) {

		/* Skip over the ')' */
		next_tok(tp);
		*nargs = 0;
		TICKX(ftag);
		return tp;
	}

	/*
		Step through the argument list, setting nargs and fp[].
	*/
	{
		int n = 0;
		spell_node * spell_p = NULL;

		for(;;) {

			skip_hws_tok(tp);

			if (*tp == HIDDEN_END_FILE_TOK || *tp == END_PROG_TOK) {
				error(es("End-of-file in formal argument list"));
				goto bad_list;
			}

			/* RPAREN_TOK is not valid here. */

			if (!is_id(*tp)) {
				error(
					es("formal macro argument expected, ");
					es(tok_name(*tp)); es(" found");
				);
				goto bad_list;
			}

			if (fp != NULL) {
				spell_p = id_tok_ptr(tp);
				fp[n] = spell_p -&gt; spell_name;
			}
			n++;

			/* Skip the formal. */
			next_tok(tp);
			skip_hws_tok(tp);

			if (*tp == RPAREN_TOK) {

				/* Success */

				/* Skip over the ')' */
				next_tok(tp);
				*nargs = n;
				if (fp != NULL) {
					fp[n] = NULL;
				}
				TICKX(ftag);
				return tp;
			}
			else if (*tp == COMMA_TOK) {
				next_tok(tp);
			}
			else {
				error(es("comma or ')' expected in formal argument list"));
				goto bad_list;
			}
		}
	}

bad_list:
	*nargs = -2;
	TICKX(ftag);
	return old_tp;
}
</t>
<t tx="ekr.20080529093004.242">@ Paste tokens together and return a pointer to the first pasted token.  first_tp points at a the token *before* the initial ##. The new tokens end with a jump beyond the pasted tokens.  Stop at bound_tp.  Note: The ## operator can only occur in the replacement list of a macro.  In particular, ## can not occur in an actual argument of a macro.
@c

#define MAX_PASTE_SIZE 2000

token *
mac_paste_tokens(token * first_tp, token * bound_tp, token ** ap_first, token ** ap_last)
{
	FTAG("mac_paste_tokens");
	register token * tp = NULL;
	register char * buf_p = NULL;
	register int string_length = 0;
	token * result = NULL;
	static char * buffer = NULL;
	STATB(ftag);

	ASSERT(*bound_tp == BOUND_TOK);

	/*
		Allocate the pasting buffer the first time.
		This buffer is never deallocated.
	*/
	if (buffer == NULL) {
		obj_new_macro(buffer, MAX_PASTE_SIZE, "mac token paste buf");
	}

	buffer[0] = ' ';
	buf_p = buffer+1;
	string_length = 1;

	ASSERT(first_tp &amp;&amp; *first_tp != POUND_POUND_TOK);
	tp = first_tp;

	/*
		Convert each token to a string and append it to the buffer.
		Convert unexpanded actual arguments, not expanded actual arguments.
	*/
	while(*tp != HIDDEN_END_FILE_TOK &amp;&amp; *tp != END_PROG_TOK) {

		int length = 0;

		if (*tp == MACRO_ARG_TOK) {

			long	arg = val_tok_val(tp);
			token *	arg_tp = ap_first[arg];

			for(;;) {
				char * s = tok_2string(arg_tp, &amp;length, FALSE);
				if (string_length + length + 5 &gt;= MAX_PASTE_SIZE) {
					goto too_big;
				}
				if (length &gt; 0) {
					strcpy(buf_p, s);
					buf_p += length;
					string_length += length;
				}
				if (arg_tp == ap_last[arg]) {
					next_tok(tp);
					break;
				}
				else {
					next_tok(arg_tp);
				}
			}
		}
		else if (*tp == POUND_TOK) {

			token * patch_tp = NULL;

			/* mac_define has deleted any whitespace after the #. */
			patch_tp = tp;
			next_tok(tp);

			if (*tp == MACRO_ARG_TOK) {
				long	arg = val_tok_val(tp);
				char *	s;

				/* Use the *unexpanded* actual argument for stringizing. */
				s = mac_stringize(ap_first[arg], ap_last[arg]);

				/* Replace the # with a STRING_TOK. */
				tok_patch(patch_tp, STRING_TOK, s, "patch in # string");

				/* Ignore the MACRO_ARG_TOK. */
				*tp = HIDDEN_BIG_IGNORE_TOK;

				/* Continue with the string tok so #a ## is handled properly. */
				tp = patch_tp;
				continue;
			}
			else {
				error(es("Formal parameter expected after #"));
				next_tok(tp);
			}
		}
		else {
			char * s = tok_2string(tp, &amp;length, FALSE);
			if (string_length + length + 5 &gt;= MAX_PASTE_SIZE) {
				goto too_big;
			}
			else if (length &gt; 0) {
				strcpy(buf_p, s);
				buf_p += length;
				string_length += length;
			}
			next_tok(tp);
		}

		/* Keep going while more ## operators exist. */
		if (*tp == POUND_POUND_TOK) {
			next_tok(tp);
		}
		else {
			break;
		}
	}

	/* Convert buffer to tokens. */
	{
		io_mem_block block;
		size_t length = strlen(buffer);

		ASSERT(length &gt; 0);

		block . mem_start = buffer+1;	/* Point past the leading blank. */
		block . mem_length = length-1;
		block . mem_freep = NULL;

		/* End the buffer with IO_EOF_CHAR. */
		buffer [length] = IO_EOF_CHAR;
		buffer [length+1] = '\0';
		block . mem_length++;

		result = tokize(&amp;block, NULL, "pasted tokens", END_WITH_SKIP_TOK, tp);
	}

	TRACEPX(ftag, eret(); tok_dump_delim(result, HIDDEN_SKIP_TOK));
	return result;

too_big:
	error( es("pasted token is too big"));
	STATX(ftag);
	return NULL;
}
</t>
<t tx="ekr.20080529093004.243">@ Rescan replacement text looking for identifiers to disable. When an identifier is found that should be disabled, convert it to an IDX_TOK.  This code has caused me a good deal of pain. Although it appears simple now, there are some very tricky points lurking here.  The ANSI Standard specifies the rescanning process precisely, if implicitly. Rescanning the replacement text properly requires that, most, but not all inner macro calls must be expanded. The details are complicated. (See the long comment below.)  Return a pointer to the last token to appear in dumps. This prevents debugging code dumping to the end of the token list when the res_bound is bypassed as the result of macro expansion.
@c

static token *
mac_rescan(
	token * res_first,
	token * res_bound,
	token * res_last,
	spell_node * spell_p)
{
	FTAG("mac_rescan");
	register token * tp = res_first;
	spell_node * spell_p2 = NULL;
	token * inner_p = NULL;
	token * inner_end_p = NULL;
	token * dump_last = res_last;
	mac_disable_node the_disable_node;
	mac_disable_node * dis_p = mac_disable_list;
	STATB(ftag);

	ASSERT(*res_first == IDX_TOK);
	ASSERT(*res_bound == BOUND_TOK);

	TRACEPN(ftag, es("before final rescan: "); 
		tok_dump_list2(res_first, res_last, PRINT_HIDDEN_TOKS);
		ecnl());

	/*
		This label simplifies the loop because
		the C language lacks a multi-level continue.
	*/
rescan_loop:

	if (tp == res_bound) {
		ASSERT(*res_bound == BOUND_TOK);
		tok_ignore(res_bound);

		STATX(ftag);
		return dump_last;
	}

	if (!is_id(*tp)) {
		next_tok(tp);
		goto rescan_loop;
	}

	spell_p2 = id_tok_ptr(tp);

	if (spell_p2 -&gt; spell_macro == NULL) {
		next_tok(tp);
		goto rescan_loop;
	}

	ASSERT(spell_p2 -&gt; spell_token == *tp);

	/* Disable the id if it is the current macro id. */
	if (spell_p2 == spell_p) {
		TRACEPN(ftag, es("disabling current: "); es(spell_p -&gt; spell_name));
		*tp = IDX_TOK;
		goto rescan_loop;
	}

	/* Disable the id if it is on the disable list. */
	while(dis_p != NULL) {
		if (dis_p -&gt; dis_spell == spell_p2) {
			*tp = IDX_TOK;
			TRACEPN(ftag,
				es("disabling: ");
				es(dis_p -&gt; dis_spell -&gt; spell_name); enl());

			/* This is a "multi-level continue". */
			goto rescan_loop;
		}
		else {
			dis_p = dis_p -&gt; dis_next;
		}
	}

	/*
		Here it is: the guts of macro expansion!

		Make a recursive call to mac_expand so we can disable
		the appropriate identifiers in the inner replacement text.
		However, don't go past the *more* *restrictive* res_bound.

		We are primarily looking for id's to disable: these tokens will be
		rescanned later in an unbounded context so that macros that
		over-run the bound eventually get expanded.

		We are justified in stopping at this inner bound!
		To quote from the Rationale of the ANSI C Standard, page 67:

		"The rescanning rules incorporate an ambiguity.  Given the definitions:

			#define f(a) a*g
			#define g f

		it is clear (or at least unambiguous) that the expansion of
		f(2)(9) is 2*f(9).  The f in the result clearly was introduced
		during the expansion of the original f, so is not further expanded.

		However, given the definitions:

			#define f(a) a*g
			#define g(a) f(a)

		the expansion rules allow the result to be either 2*f(9) or 2*9*g.
		It is unclear whether the f(9) token string (resulting from the initial
		expansion of f and the examination of the rest of the source file)
		should be considered as nested within the expansion of f or not.
		The Committee intentionally left this behavior ambiguous; it saw no
		useful purposein specifying all the quirks of preprocessing for such
		questionably useful constructs."

		(End of quote.)

		This quote is one indication (among many) that The Committee really
		knew what it was doing.  Using the inner bound here allows us
		to eliminate some really nasty code that tried to figure out where
		mac_rescan should stop rescanning.

		In fact, the preprocessor ultimately produces 2*9*g.

		Indeed, mac_rescan does *not* consider f(9) to be part of the expansion,
		and so it is *not* converted to an IDX_TOK.  Later, cpp considers f(9)
		to be a valid macro call and mac_outer_expand expands it to 9*g.
	*/

	/* Add the new identifier to the disable list */
	the_disable_node . dis_spell = spell_p2;
	the_disable_node . dis_next = mac_disable_list;
	mac_disable_list = &amp;the_disable_node;

	/* Recursively call mac_expand. It may fail. */
	TRACEPN(ftag, es("recursive unbounded call to mac_expand\n"));
	inner_p = mac_expand(tp, res_bound, &amp;inner_end_p);

	/* Remove the new identifier from the disable list. */
	ASSERT(mac_disable_list);
	mac_disable_list = mac_disable_list -&gt; dis_next;

	/* Check for an aborted inner expand. */
	if (inner_end_p == NULL) {
		TRACEPN(ftag, es("inner call failed.\n"));
		ASSERT(is_id(*tp));
		next_tok(tp);

		/* Give the tracing routines a break! */
		dump_last = tp;
		goto rescan_loop;
	}
	else {
		tp = inner_p;
		next_tok(tp)
		goto rescan_loop;
	}
}
</t>
<t tx="ekr.20080529093004.244">@ Patch the value of a special macro into the token list.
@c

#define BUF_SIZE 100

static void
mac_special(token * tp, spell_node * spell_p)
{
	FTAG("mac_special");
	register char * name = spell_p -&gt; spell_name;
	char * p = NULL;
	char buf[BUF_SIZE];
	STATB(ftag);

	if (str_eq(name, "__LINE__")) {
		cvt_long(buf, BUF_SIZE, err_line+err_line_offset);
		new_file_string_macro(p, buf);
		tok_patch(tp, INT_TOK, p, "__LINE__");
	}
	else if (str_eq(name, "__FILE__")) {
		char * s = err_file_name();
		new_file_string_macro(p, s);
		tok_patch(tp, STRING_TOK, p, "__FILE__");
	}
	else if (str_eq(name, "__TIME__")) {
		cvt_time(buf, BUF_SIZE, FALSE);
		new_file_string_macro(p, buf);
		tok_patch(tp, STRING_TOK, p, "__TIME__");
	}
	else if (str_eq(name, "__DATE__")) {
		cvt_date(buf, BUF_SIZE, FALSE);
		new_file_string_macro(p, buf);
		tok_patch(tp, STRING_TOK, p, "__DATE__");
	}
	else if (str_eq(name, "defined")) {
		/* This should never happen. */
		*tp = IDX_TOK;
	}
	else {
		fatal(es("unknown reserved macro"));
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.245">@ Stringize the tokens from tp_first to tp_last.  A new string is created in the string space, so that the caller need not worry about allocating storage.
@c

#define MAX_STRINIZE_SIZE 2000

char *
mac_stringize(token * tp_first, token * tp_last)
{
	FTAG("mac_stringize");
	register char * buf_p = NULL;
	register token * tp = NULL;
	register char * s = NULL;
	register int string_length = 0;
	char * result = NULL;
	static char * buffer = NULL;
	STATB(ftag);

	/*
		Allocate the stringize buffer the first time.
		This buffer is never deallocated.
	*/
	if (buffer == NULL) {
		obj_new_macro(buffer, MAX_STRINIZE_SIZE, "mac stringize buf");
	}

	/*
		Convert each token to a string and
		append the string to the buffer.
	*/
	buf_p = buffer;
	string_length = 0;
	tp = tp_first;
	for(;;) {

		int length = 0;

		/*
			Convert the token to a string and stringize
			strings and character constants.
		*/
		s = tok_2string(tp, &amp;length, TRUE);

		if (string_length + length &gt;= MAX_STRINIZE_SIZE) {
			error(
				es("stringized actual argument too big: ");
				tok_dump_list(tp_first, tp_last);
			);
			result = NULL;
			goto done;
		}
		else if (length &gt; 0) {
			strcpy(buf_p, s);
			buf_p += length;
			string_length += length;
		}

		if (tp == tp_last) {
			break;
		}
		else {
			next_tok(tp);
		}
	}
	if (string_length == 0) {
		result = NULL;
		goto done;
	}

	/* Allocate space in the string space. */
	result = mem_str_copy(buffer, string_length);

done:
	STATX(ftag);
	return result;
}
</t>
<t tx="ekr.20080529093004.246">@ Convert an intial replacement text and a list of expanded and unexpanded actual arguments to a final token list. Handle # and ## arguments.  This is really part of mac_expand, which is why there are so many args.  o The expanded and unexpanded arguments are described by blocks of pointers  the start and end of each argument: exp_first, exp_last, ap_first, ap_last.  o The initial replacement text ends with WS_NL_TOK, which is *not*  included in the final token list. This preserves line numbering.  o End the final token list with a skip to tp_follow, which must point to a  valid, though possibly hidden, token.  o Replace HIDDEN_MACRO_ARG_TOK's by correct *expanded* arg. Terminate each  expanded arg by a skip to the token following the original HIDDEN_MACRO_ARG_TOK.   o Replace # HIDDEN_MACRO_ARG_TOK by a STRING_TOK formed by strinizing the  *unexpanded* macro argument.   o Replace t1 ## t2 by the token list formed by concatenating the tokens  t1 and t2. Either t1 or t2 may be HIDDEN_MACRO_ARG_TOK or # t3.   o Replace each instance if an id (either ID_TOK or reserved word tok)  by IDX_TOK to disable further macro expansion.
@c

static token *
mac_substitute(
	spell_node * spell_p,	/* Ptr to macro's spelling node. */
	token *		rtokens,	/* Ptr to macro's initial replacement text. */
	token **	ap_first,	/* Ptr to block of ptrs to start of actual args. */
	token **	ap_last,	/* Ptr to block of ptrs to end of actual args. */
	token **	exp_first,	/* Ptr to block of ptrs to start of expanded args. */
	token **	exp_last,	/* Ptr to block of ptrs to end of expanded args. */
	token **	res_first,	/* Ptr to first token of result. */
	token **	res_bound,	/* ptr to trailing BOUND_TOK of result. */
	token **	res_last,	/* Ptr to last HIDDEN_SKIP_TOK of result. */
	int			nargs,		/* Number of actual arguments. */
	token *		tp_follow,	/* Ptr to token to follow replacement text or NULL. */
	long		hidden_nl)	/* Hidden newlines in actual args. */
{
	FTAG("mac_substitute");
	token * first_p = NULL;	/* Ptr to copy of replacement text. */
	token * bound_p = NULL;	/* Ptr to bound just before the end. */
	token * end_p = NULL;	/* Ptr to end of copy. */
	bool save_update = tok_update_flag;
	TRACEPB(ftag,
		es("macro: "); es(spell_p -&gt; spell_name);
		es(" rtext:\n"); tok_dump_line(rtokens));

	ASSERT(tp_follow);

	/* Disable the updating of line numbers. */
	tok_update_flag = FALSE;

	/*
		Make a copy of the replacement list terminated by
		a skip to tp_follow.

		The leading IDX_TOK is a continuation of the HIDDEN_SKIP_TO_MACRO_TOK
		which replaces the identifier token that started the macro.
	*/
	ASSERT(is_id(spell_p -&gt; spell_token));

	first_p =	tok_copy(IDX_TOK, spell_p);
				tok_copy2nl(rtokens, &amp;end_p, "final rtext");
	bound_p =	tok_copy(BOUND_TOK, NULL);

	/* Insert line adjust *after* bound_p so it will not be skipped. */
	ASSERT(hidden_nl &gt;= 0 &amp;&amp; hidden_nl &lt; 100);
	while (hidden_nl-- &gt; 0) {
		tok_copy(HIDDEN_NL_IN_MACRO_TOK, NULL);
	}
	end_p = 	tok_copy(HIDDEN_SKIP_TOK, tp_follow);

	*res_first	= first_p;
	*res_bound	= bound_p;
	*res_last	= end_p;

	/*
		Make the indivudual substitutions in the copy of the replacement text.
		Actual arguments may appear more than once so make copies of each.
	*/
	{
		register token * tp = first_p;
		register token * last_tp = NULL;
		register bool continue_flag = FALSE;

		/* Skip past the copy of the macro call. */
		next_tok(tp);

		/* The copy of the replacement text does *not* have a newline. */
		do {

			continue_flag = (tp != bound_p);

			switch(*tp) {

			case HIDDEN_END_FILE_TOK:	fatal(es("end file"));
			case END_PROG_TOK:			fatal(es("end prog"));
			case BAD_TOK:				fatal(es("bad token"));

			case POUND_TOK:

			/* Stringize the following argument. */
			{
				token * patch_tp = NULL;

				/* mac_define has deleted any whitespace after the #. */
				patch_tp = tp;
				next_tok(tp);

				if (*tp == MACRO_ARG_TOK) {
					long	arg = val_tok_val(tp);
					char *	s;

					/* Use the *unexpanded* actual argument for stringizing. */
					s = mac_stringize(ap_first[arg], ap_last[arg]);

					/* Replace the # with a STRING_TOK. */
					tok_patch(patch_tp, STRING_TOK, s, "patch in # string");

					/* Ignore the MACRO_ARG_TOK. */
					*tp = HIDDEN_BIG_IGNORE_TOK;

					/* Continue with the string tok so #a ## is handled properly. */
					last_tp = NULL;
					tp = patch_tp;
				}
				else {
					error(es("Formal parameter expected after #"));
					last_tp = tp;
					next_tok(tp);
				}
				break;
			}

			case POUND_POUND_TOK:

			/* Token pasting operator. */
			{
				token * patch_tp = tp;
				token * result_tp;

				/*
					Concatenate a list of *unexpanded* tokens.
					The list starts with last_tp.
				*/
				ASSERT(last_tp);
				result_tp = mac_paste_tokens(last_tp, bound_p, ap_first, ap_last);

				/* Ignore the token preceding the ##. */
				ASSERT(last_tp);
				tok_ignore(last_tp);

				/* Replace the ## with a skip to the new tokens. */
				ASSERT(*patch_tp == POUND_POUND_TOK);
				tok_patch(patch_tp, HIDDEN_SKIP_TOK, result_tp, "patch in ## tokens");

				/* Continue with the new tokens so new # operators are recognized. */
				last_tp = NULL;
				tp = result_tp;
				break;
			}

			case MACRO_ARG_TOK:

				/*
					Replace MACRO_ARG_TOK(i) by HIDDEN_SKIP_TOK1.

					Copy

						exp_first[i], ... exp_last[i],
						HIDDEN_SKIP_TOK2

					 into the token space and point HIDDEN_SKIP_TOK2
					 to the token following HIDDEN_SKIP_TOK1.
				*/
			{

				long arg = val_tok_val(tp);
				token * patch_tp = tp;
				token * arg_p = NULL;
				token * junk = NULL;

				ASSERT(arg &gt;= 0 &amp;&amp; arg &lt; nargs);

				arg_p = tok_copy_list(exp_first[arg], exp_last[arg], &amp;junk, "arg");

				/* 7/5/93: Make this code independent of sizeof(token). */
				{
					token * temp_tp = patch_tp;
					bump_tp_macro(temp_tp, BIG_TOKEN_SIZE);
					tok_copy(HIDDEN_SKIP_TOK, temp_tp);
				}

				/* Continue at the newly created tokens. */
				last_tp = NULL;
				tp = arg_p;
				tok_patch(patch_tp, HIDDEN_SKIP_TOK, arg_p, "patch in macro arg");
				break;
			}

			default:
				last_tp = tp;
				next_tok(tp);
			}
		} while (continue_flag);
	}

	/* Restore the previous setting. */
	tok_update_flag = save_update;

	TRACEPX(ftag, eret(); enl(); enl();
		tok_dump_list(first_p, end_p); ecnl();
		es("=\n");
		tok_dump_list2(first_p, end_p, DONT_PRINT_HIDDEN_TOKS);
		ecnls(2));

	return first_p;
}
</t>
<t tx="ekr.20080529093004.247">/*
	AS: command-line #define and #undef routines.

	These routines manage lists of symbols defined or undefed on the
	command line.  They need not be fast, and they sure aren't pretty.

	Warning: Be wary of putting Sherlock macros in this file:
			 Many of the routines are called before Sherlock is initialized.

	source:  ASmst.c
	started: September 22, 1985
	version: December 20, 1993.
*/

&lt;&lt; ASmst #includes &gt;&gt;
&lt;&lt; ASmst declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.248">#include "AS.h"

#include "ASmacro.h"
#include "ASmem.h"
#include "ASmst.h"
#include "AStokens.h"

#include &lt;LIBlist.h&gt;

#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.249">/*
	Define command-line #define and #undef nodes.
*/
typedef struct d_struct d_node;
typedef struct u_struct u_node;

static struct d_struct {
	TYPE_LIST(d_node);
	char *	d_name;	/* Pointer to name. */
	char *	d_text;	/* Pointer to replacement text. */
	bool 	d_flag; /* TRUE: user-defined. */
};

static struct u_struct {
	TYPE_LIST(u_node);
	char *	u_name;	/* Name of undef. */
	bool	u_flag;	/* TRUE: undef still active. */
};

static d_node * def_list = NULL;	/* List of command-line #define's. */
static u_node * undef_list = NULL;	/* List of command-line #undef's. */

/*
	Function prototypes of local routines.
*/
static void mst_pre_define	(void);
</t>
<t tx="ekr.20080529093004.250">@ Show all macro definitions.
@c

void
mst_dump_all(void)
{
	FTAG("mst_dump_all");
	register mac_def_node * mp = NULL;
	STATB(ftag);

	es("List of all macro definitions:\n");
	lst_every_macro(mp, mac_mdef_list) {
		mst_dump_mdef(mp);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.251">void
mst_dump_mdef(mac_def_node * mp)
{
	FTAG("mst_dump_mdef");
	STATB(ftag);

	es(mp -&gt; mac_spell -&gt; spell_name);
	es("("); eint(mp -&gt; mac_nargs); es(")");
	tok_dump_line2(mp -&gt; mac_rtokens,
		PRINT_HIDDEN_TOKS, SPLIT_LONG_LINES, PRINT_NON_USER_TOKENS);
	ecnl();

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.252">@ Initialize the macro module. This must be done *before* command-line arguments are processed.
@c

void
mst_init(void)
{
	FTAG("mst_init");
	STATB(ftag);

	/* Clear the command-line lists." */
	def_list = NULL;
	undef_list = NULL;

	/* Enter the pre-defined macros. */
	mst_pre_define();

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.253">@ Enter all previous command-line #defines and #undefs into the table.
@c

void
mst_init_again(void)
{
	FTAG("mst_init_again");
	u_node * up = NULL;
	d_node * dp = NULL;
	STATB(ftag);

	lst_every_macro(dp, def_list) {
		mac_define_string(dp -&gt; d_name, dp -&gt; d_text, TRUE);
	}

	/* Make all #undef's active. */
	lst_every_macro(up, undef_list) {
		up -&gt; u_flag = TRUE;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.254">@ Add an argument to the define list. Cancel any previous defines or undefs. user_flag is TRUE if the define comes from the command line.
@c

void
mst_init_define(char * arg, char * def, bool user_flag)
{
	FTAG("mst_init_define");
	d_node * dp = NULL;
	u_node * up = NULL;
	STATB(ftag);

	if (str_eq(arg, "defined")) {
		warning(es("Can not re-define "); es(arg));
		return;
	}

	/* Remove any previous #undef. */
	lst_every_macro(up, undef_list) {
		if (str_eq(arg, up -&gt; u_name)) {
			warning(es("Cancelling previous #undef "); es(arg));
			lst_remove_macro(up, undef_list, u_node);
			return;
		}
	}

	/* Remove any previous #define. */
	lst_every_macro(dp, def_list) {
		if (str_eq(arg, dp -&gt; d_name)) {
			if (user_flag &amp;&amp; dp -&gt; d_flag) {
				warning(es("Cancelling previous #define "); es(arg));
			}
			dp -&gt; d_text = def;
			dp -&gt; d_flag = user_flag;
			return;
		}
	}

	/*
		Add the definition to the define list.
		These definitions have permanent lifetimes,
		though they may be removed from the def_list.
	*/
	new_perm_macro(dp, perm_macro_stats);
	lst_add_macro(dp, def_list);
	dp -&gt; d_name  = arg;
	dp -&gt; d_text  = def;
	dp -&gt; d_flag  = user_flag;

	mac_define_string(arg, def, TRUE);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.255">@ Add an argument to the undef list.
@c

void
mst_init_undef(char * arg)
{
	FTAG("mst_init_undef");
	d_node * dp = NULL;
	u_node * up = NULL;
	TRACEPB(ftag,
		elp(); es(arg); erpnl());

	ASSERT(arg);

	if (str_eq(arg, "defined")) {
		warning(es("Can not undefine "); es(arg));
	}

	/* Disable any previous command-line definition. */
	lst_every_macro(dp, def_list) {
		if (str_eq(arg, dp -&gt; d_name)) {
			lst_remove_macro(dp, def_list, d_node);
		}
	}

	/* Warn if an undef is already in effect. */
	lst_every_macro(up, undef_list) {
		if (str_eq(arg, up -&gt; u_name)) {
			up -&gt; u_flag = TRUE;
			return;
		}
	}

	/*
		These items are never deallocated,
		though they may be removed from lists.
	*/
	new_perm_macro(up, perm_macro_stats);
	lst_add_macro(up, undef_list);
	up -&gt; u_name = arg;
	up -&gt; u_flag = TRUE;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.256">@ Return TRUE if the name is on the initial undef list. Also mark the #undef as having been seen.
@c

bool
mst_is_undef(char * name)
{
	FTAG("mst_is_undef");
	u_node * up = NULL;
	STATB(ftag);

	lst_every_macro(up, undef_list) {
		if (up -&gt; u_flag == TRUE &amp;&amp; str_eq(name, up -&gt; u_name)) {
			up -&gt; u_flag = FALSE;
			return TRUE;
		}
	}

	STATX(ftag);
	return FALSE;
}
</t>
<t tx="ekr.20080529093004.257">@ Enter the predefined macros into the table. According to the ANSI Standard, these may not be re-#define'd or #undef'd.  Note: only the upper case spellings are special. __date__ is a plain id.
@c

static void
mst_pre_define(void)
{
	FTAG("mst_pre_define");
	STATB(ftag);

	/* mst_special() will update these as required. */
	mst_init_define("__DATE__", "__DATE__", FALSE);
	mst_init_define("__FILE__", "__FILE__", FALSE);
	mst_init_define("__LINE__", "__LINE__", FALSE);
	mst_init_define("__STDC__", "1", FALSE);
	mst_init_define("__TIME__", "__TIME__", FALSE);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.258">@ Dump the defined and undef lists.
@c

void
mst_show(void)
{
	FTAG("mst_show");
	d_node * dp = NULL;
	u_node * up = NULL;
	STATB(ftag);

	es("defined list:\n");
	lst_every_macro(dp, def_list) {
		es("name: "); es(dp -&gt; d_name);
		es(" rtext: "); es(dp -&gt; d_text);
		es(" user: "); ebool(dp -&gt; d_flag);
		enl();
	}

	es("undef list:\n");
	lst_every_macro(up, undef_list) {
		es("name: "); es(up -&gt; u_name);
		es(" flag: "); ebool(up -&gt; u_flag);
		enl();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.259"></t>
<t tx="ekr.20080529093004.260"></t>
<t tx="ekr.20080529093004.261">/*
	AS: definitions of anodes.

	anodes define machine language arguments.

	source:  anodes.h
	started: December 20, 1993.
	version:
		January 23, 1994.
			Added xword1, bd and od fields to anodes.
		January 4, 	1994.
			Greatly simplified anodes.
			Anodes now use the enode tree to indicate differences in operands.
*/

#ifndef ASanodes_h_
#define ASanodes_h_

#pragma once

	/* Abbreviations. */

#define anode_ptr(p)	((anode *) (p))

	/* Macros. */

#define new_anode_macro(p, mode)\
{\
	new_macro(p, file_life, anode_stats);\
	p -&gt; n_type = mode;\
}

	/* Types globally visible. */

#ifndef AS_ANODE_TYPEDEFS
	#define AS_ANODE_TYPEDEFS
	typedef struct anode_struct	anode;
#endif

	/* Types only accessible when including this file. */
	
	typedef struct reglist_anode_struct reglist_anode;

/*
	The following address modes (and others) are defined in AStokens.h.
	These form the n_type field of anodes.

	ABSOLUTE_EA,			adr
	AREG_EA,				a4
	DISPLACEMENT_EA,		#word(a6)
	DREG_EA,				d5
	IMMEDIATE_EA,			#nn or #adr
	INDIRECT_EA,			(a0)
	INDEX_EA,				#byte(a4,d4)
	PC_DISP_EA,				#word(pc)
	PC_INDEX_EA,			#byte(pc,xn)
	PRE_DEC_EA,				-(a0)
	POST_INC_EA,			(a0)+
	
	REGLIST_EA,				register list

	68020 and 68030 address modes...

	PC_POST_INDEX_EA20,		([bd,pc],xn.w*scale,od)
	PC_PRE_INDEX_EA20,		([bd,pc],xn*scale,od)
	POST_INDEX_EA20,		([bd,an],xn*scale,od)
	PRE_INDEX_EA20,			([bd,an],xn*scale,od)

	Unlike the compiler, the assembler represents all anodes by a single anode_struct.
	Another kind of anode will be used for 68020 and 68030 instructions.
*/
struct anode_struct {

	COMMON_NODE_HEAD;	/* n_type indicates address mode.  See above. */
	
		/* Set by parser. */

	ushort	a_reg;		/* A-reg or D-register. */
	ushort	a_xreg;		/* Index register. */
	enode *	a_enode;	/* Enode tree representing the operand. */
	
		/* Set by pattern matching routines. */

	ushort	xsize;	/* Number of extension *words*: 0 - 5. */
	ulong	xwords;	/* one or two 16-bit extension words. */
	
	#ifdef USE_68030
		ulong	bd;		/* Base displacement:  0, 1 or 2 words. */
		ulong	od;		/* Outer displacement: 0, 1 or 2 words. */
	#endif
};

	/* Function prototypes. */

void eanode			(anode * ap);
int eanode_bits	(anode * ap);
int oanode_bits	(anode * ap);

#endif /* ASanodes_h_ */
</t>
<t tx="ekr.20080529093004.262">/*
	AS: definitions of cnodes.

	cnodes represent code, i.e, individual machine instructions or pseudo ops.

	source:  cnode.h
	started: December 28, 1993.
	version:
		July 26, 1994.
			Bug fix: Added clab_prev field to ulabel_cnode's.
		April 21, 1993.
			Added dc_float_flag.
		April 10, 1994.
			Replaced c_error field by c_flags field.
		April 9, 1994.
			Made c_lc common to all cnodes.
		March 28, 1994.
			Moved cnode_app_size here where it belongs.
		March 24, 1994.
			Added out_cnode.
		March 20, 1994.
			Added align_cnode's, db_cnode's, dcb_cnode's and dc_list_node's.
		March 10, 1994.
			Added c_lc debugging field.
		February 23, 1994.
			Changed ulabel_cnodes so it points to an dict_node, not an snode.
		February 13, 1994.
			Added ecinode_bits.
		January 26, 1994.
			Removed back link from cnodes.
		January 18, 1994.
			Added c_arg3, c_length and c_xbits fields to cinodes.
		January 4, 1993.
			Added c_bits field to cinodes.
		December 28, 1993.
			Removed compiler label nodes and table pointer nodes.
*/

#ifndef AScnodes_h_
#define AScnodes_h_

#pragma once

	/* Abbreviation macros. */

#define align_cnode_ptr(p)	((align_cnode *) (p))
#define cinode_ptr(p)		((cinode *) (p))
#define cnode_ptr(p)		((cnode *) (p))
#define dc_cnode_ptr(p)		((dc_cnode *) (p))
#define dcb_cnode_ptr(p)	((dcb_cnode *) (p))
#define opword_cnode_ptr(p)	((opword_cnode *) (p))
#define ulabel_cnode_ptr(p)	((ulabel_cnode *) (p))

	/* Macros. */

#define new_cnode_macro(p, the_type, the_lc)\
{\
	new_macro(p, file_life, cnode_stats);\
	cnode_ptr(p) -&gt; n_type = the_type;\
	cnode_ptr(p) -&gt; c_lc = the_lc;\
}

	/* Types. */
	
		/* Types refered to in other headers and actually defined in AStypes.h. */

#ifndef AS_CNODE_TYPEDEFS
#define AS_CNODE_TYPEDEFS
	typedef struct cnode_struct		cnode;	/* Common part of all cnodes. */
	typedef struct cinode_struct	cinode;	/* Code instruction. */
#endif

		/* Types used only by routines that include AScnodes.h */

typedef struct align_cnode_struct	align_cnode;	/* ALIGN	pseudo operation. */
typedef struct dc_cnode_struct		dc_cnode;		/* DC.size	pseudo operation. */
typedef struct dc_list_node_struct	dc_list_node;	/* Values in DC value list. */
typedef struct dcb_cnode_struct		dcb_cnode;		/* DCB		pseudo operation. */
typedef struct opword_cnode_struct	opword_cnode;	/* OPWORD	pseudo operation. */
typedef struct ulabel_cnode_struct	ulabel_cnode;	/* User label node. */

/*
	The n_type field for cinodes contains instruction types (X_xxx).
	The n_type field for other cnodes contains output codes (O_xxx).
	All these codes are defined in AStokens.h.
*/
#define CODE_HEAD			/* Header for code nodes. */\
	LINKED_NODE_HEAD;\
	ulong c_lc				/* The location counter: offset relative to unit. */

/*
	Generic code node.
	The location counter field makes producing listings easier,
	because otherwise main_listing would have to keep track of
	PROC, RECORD, DATA and CODE instructions.
*/
struct cnode_struct {
	CODE_HEAD;		/* n_type indicates subclass type. */
};

/*
	ALIGN pseudo operations.
*/
struct align_cnode_struct {
	CODE_HEAD;				/* n_type = Z_ALIGN. */
	short	align_pad;		/* Size of the adjustment: 1 - 4 */
};

/*
	Code node for machine instructions.
*/
struct cinode_struct {
	CODE_HEAD;			/* ASSERT(is_xtok(n_type)) */
	anode *	c_arg1;		/* Operand bits for arg 1. */
	anode *	c_arg2;		/* Operand bits for arg 2. */
	anode * c_arg3;		/* Operand bits for arg 3 (used in some bit instructions) */
	ushort	c_bits;		/* Opcode bits. */
	ushort	c_length;	/* Instruction length, i.e. .B, .W, .L or none. */
	ushort	c_new_len;	/* The logical instruction length implied by defaults. */
	sbool	c_flags;	/* Various flag bits (see below). */
};

/*
	Define the bits of the c_flags field.
	
	C_ERROR_FLAG:		set if there is an error in parsing the instruction.
	C_REVERSED_FLAG:	set if the bits of c_arg1 come *after* the bits of c_arg2 field.
						This only occurs in some forms of the movem instruction.
*/
enum { C_ERROR_FLAG = 0x01, C_REVERSED_FLAG = 0x02};

#define c_is_error(cp)		((((cp) -&gt; c_flags) &amp; C_ERROR_FLAG) != 0)
#define c_is_reversed(cp)	((((cp) -&gt; c_flags) &amp; C_REVERSED_FLAG) != 0)

#define c_set_error(cp)		{ (cp) -&gt; c_flags |= C_ERROR_FLAG; }
#define c_set_reversed(cp)	{ (cp) -&gt; c_flags |= C_REVERSED_FLAG; }

/*
	DCB pseudo operation.
*/
struct dcb_cnode_struct {
	CODE_HEAD;				/* n_type = Z_DCB. */
	ulong		dcb_size;	/* Size of the constant block. */
	long		dcb_val;	/* Fill value of the block. */
};

/*
	DC.B, DC.W and DC.L pseudo operations.
*/
struct dc_cnode_struct {
	CODE_HEAD;						/* n_type = Z_DC. */
	dc_list_node *	dc_val_list;	/* List of constants. */
	short			dc_size;		/* Size of each constant: 1, 2, 4 */
	short			dc_float_flag;	/* TRUE: all constants are float constants. */
};

struct dc_list_node_struct {
	dc_list_node *	next;		/* Next constant in the constant list. */
	long			dc_val;		/* The actual integer constant */
	enode *			dc_enode;	/* The expression giving rise to the constant. */
};

/*
	OPWORD pseudo instruction.
*/
struct opword_cnode_struct {
	CODE_HEAD;					/* n_type = Z_OPWORD. */
	short		opword;
};

/*
	User labels.
*/
static struct ulabel_cnode_struct {
	CODE_HEAD;					/* n_type = O_ULABEL. */
	dict_node * 	clab_dict;
	ulabel_cnode *	clab_prev;	/* previous label with the *same* location counter. */
};

	/* Function prototypes. */

short	cnode_app_size	(cnode * cp);
void	ecinode			(cinode * cip);
void	ecnode			(cnode * cp);
void	ecnode_bits		(cnode * cp);
void	ocnode_bits		(cnode * cp, ulong lc);
ulong	out_cnode		(cnode * cp);

#endif /* AScnodes_h_ */

</t>
<t tx="ekr.20080529093004.263">/*
	AS: Definitions of nodes and values of tokens.

	source:  AStokens.h
	started: September 22, 1993.
	version:
		June 12, 1994.
			Added QUESTION_TOK for the preprocessor.
		May 26, 1994.
			Removed par_next macro.
		April 22, 1994.
			Added ASSN_TOK so that '=' in full-line comments are handled without
			generating an error.
		April 1, 1994.
			Added statistics for spell nodes.
		February 24, 1994.
			Moved definition of spell_nodes into this file.
			This makes sense since they are refered to only by tokens.
		February 13, 1994.
			Added tok_out_line.
			Removed O_LINE_NUMBER.
		February 10, 1994.
			Added O_SLIST.
		February 9, 1994.
			Removed LONG_TOK (replaced throughout by INT_TOK).
			Removed UAND_TOK.
		February 6, 1994.
			Added BEGIN_ALT_EA_RANGE.
		January 19, 1994.
			Added DREG_DREG_EA, OFFSET_WIDTH_EA, REGLIST_EA and SPECIAL_EA.
			Added definitions of control registers.
		January 18, 1994.
			Reorganized address modes into ranges.
		January 16, 1994.
			Added pseudo instructions.
			Added is_pseudo macro.
			Added tok_skip_ws.
		December 29, 1993.
			Added is_reg, is_areg, is_dreg and is_xreg macros.
		December 23, 1993.
			Eliminated skip blocks.  Skip nodes are allocated from the file lifetime.
			Rewrote tok_protect_macro.
		December 21, 1993.
			Removed statistic argument from put_xxx_tok macros.
			Replaced global statistic logic with TOKIZE_STATS logic.
		December 20, 1993.
			Added prototypes for all routines in tokens.c.
		November 28, 1993.
			Abbreviation macros and function prototypes moved here from ASasm.h.
		October 27, 1993.
			Removed all compiler-only tokens:
				all assignment tokens,
				ARRAY_TOK, ARROW_TOK, CAST_TOK, CALL_TOK,
				PRE_INC_TOK, POST_INC_TOK, POST_INC_TOK, POST_INC_TOK,
				WIDE_STRING_TOK, WIDE_CHAR_TOK.
			Changed bracket tokens (),[],{} to small_tok's.
			Moved X_tokens to this file from ops.h.
*/

#ifndef AStokens_h_
#define AStokens_h_

#pragma once

/*
	Abbreviation macros.
*/
#define t_type	 	(*tok_token_ptr)
#define t_ptr	 	(ptr_tok_ptr(tok_token_ptr))

#define t_spell  	(id_tok_ptr(tok_token_ptr))
#define t_spell_name (t_spell -&gt; spell_name)

#define is(a) 		(t_type == (a))

#ifndef AS_TOKEN_TYPEDEFS
	#define AS_TOKEN_TYPEDEFS
	typedef ushort token;
	typedef struct spell_node_struct spell_node;

#endif

/*
	Spell Nodes.

	All ID_TOK's, IDX_TOK's and all reserved-word tokens point to a
	unique spelling table entry.  Two identifier tokens have the same
	spelling if and only if their spelling table pointers are equal.

	These entries are created only in tokize.
*/

struct spell_node_struct {
	spell_node *	spell_next;		/* Pointer to next bucket. */
	int				spell_length;	/* Length of name. */
	token			spell_token;	/* Presumed token. */
	char *			spell_name;		/* The name of the var. */
	mac_def_node *	spell_macro;	/* Pointer to macro node. */
	dict_node *		spell_dict;		/* Pointer to semantic information. */
};

/*
	The tok_info table describes all the tokens used in AS.
	It is the most important data base in the assembler.

	It's length is 8 bytes, which speeds up array access.
	(Multiplying by 8 is can be done with 3 adds instead of a multiply.)
*/

typedef struct tok_info_struct tok_info_type;

struct tok_info_struct {

	ushort	tok_value_;	/* size of tokens, opcode for aops. */
	char *	tok_name_;	/* The print name of the token. */
	token	tok_tok_;	/* tok_tok(n) == n for all n. */
};

#define tok_size(n)		(tok_info[n].tok_value_)
#define tok_opcode(n)	(tok_info[n].tok_value_)
#define tok_value(n)	(tok_info[n].tok_value_)

#define tok_name(n)		(tok_info[n].tok_name_)
#define tok_tok(n)		(tok_info[n].tok_tok_)

/*
	The following enum defines the codes for most quantities in the assembler.

	Unlike the current version of CC2, a single enumeration is used
	so that all codes are unique.
*/
enum {

	/* Zero is never a valid type code. */

	NULL_TOK = 0, BAD_TOK = 0,

	/* ----- Non tokens ----- */

	BEGIN_REG_RANGE,

		R_A0,	/* Address registers. */
		R_A1,
		R_A2,
		R_A3,
		R_A4,
		R_A5,
		R_A6,
		R_A7,
		
		R_SP,		/* A synonym for a7. */

		R_D0,	/* Data registers. */
		R_D1,
		R_D2,
		R_D3,
		R_D4,
		R_D5,
		R_D6,
		R_D7,

				/* General registers... */

		R_CCR,	/* Condition code register. */
		R_PC,	/* Program counter. */
		R_SR,	/* Status register. */

				/* Control registers.  See MOVEC for a list of codes. */

	BEGIN_CONTROL_REG_RANGE,

		R_SFC,	/* Source Function Code (SFC) register. */
		R_DFC,	/* Destination Function Code (DFC) register. */
		R_CACR,	/* Cache Control Register (CACR). */
		R_USP,	/* User Stack Pointer (USP). */
		R_VBR,	/* Vector Base Register (VBR). */
		R_CAAR,	/* Cache Address Register (CAAR). */
		R_MSP,	/* Master Stack Pointer (MSP). */
		R_ISP,	/* Interrupt Stack Pointer (ISP). */

	END_CONTROL_REG_RANGE,

				/* Floating registers. */

	END_REG_RANGE,

	BEGIN_O_RANGE,		/* Semantic nodes... */

		O_SLIST,		/* snode_list node. */
		O_SUMMARY,		/* Summary of expression. */
		O_ULABEL,		/* User label. */

	END_O_RANGE,

	/*
		The IMMEDIATE_EA, DIRECT_EA and PC_INDEX_EA modes have 2 or
		more variations, depending on the length of a constant.
		The opcodes with explicit length information are never generated
		by the code generators, and are used only by the internal assembler.

		Besides indicating address modes, the address modes form the valid
		values of the n_type field of anodes.
		The indented address modes are invalid in the n_type field.

		Note the distinction between these address modes and the
		*patterns* of address modes used in the existence tables.

		Modes ending in EA20 are for the 68020 and above.
		Modes ending in EA30 are for the 68030 and above.

		The address modes are grouped for easy classification.
	*/

	BEGIN_DUMMY_EA_RANGE,	/* Not real address modes. */

		DREG_DREG_EA,		/* Dr:Dq or Dhigh:Dlow. */
		OFFSET_WIDTH_EA,	/* offset:width. */
		REGLIST_EA,			/* register list. */
		SPECIAL_EA,			/* Special registers. */

	END_DUMMY_EA_RANGE,

	BEGIN_EA_RANGE,

	BEGIN_ALT_EA_RANGE,		/* Begin alterable modes... */

		DREG_EA,					/* mode 0: Dn */
		AREG_EA,					/* mode 1: An */
		
	BEGIN_MEM_ALT_EA_RANGE,	/* Begin memory alterable modes... */

		INDIRECT_EA,				/* mode 2: (a0) */
		POST_INC_EA,				/* mode 3: (a0)+ */
		PRE_DEC_EA,					/* mode 4: -(a0) */
		DISPLACEMENT_EA,			/* mode 5: #word(a6) */

	BEGIN_MODE6_RANGE,	/* Begin mode 6... */

		INDEX_EA,					/* mode 6: #byte(a4,d4) */

			INDEX16_EA,					/* #byte(an,xn.w) */
			INDEX32_EA,					/* #byte(an,xn.l) */

			INDEX16_EA20,				/* #long(an,xn.w*scale) */
			INDEX32_EA20,				/* #long(an,xn.l*scale) */

			POST_INDEX_EA20,			/* ([bd,an],xn*scale,od) */
			POST_INDEX16_EA20,			/* ([bd,an],xn.w*scale,od) */
			POST_INDEX32_EA20,			/* ([bd,an],xn.l*scale,od) */

			PRE_INDEX_EA20,				/* ([bd,an],xn*scale,od) */
			PRE_INDEX16_EA20,			/* ([bd,an,xn.w*scale],od) */
			PRE_INDEX32_EA20,			/* ([bd,an,xn.l*scale],od) */

	END_MODE6_RANGE,	/* End mode 6. */

	BEGIN_MODE7_RANGE,	/* Begin mode 7... */

		ABSOLUTE_EA,				/* modes 7:0 and 7:1: address (value of object) */

			ABS16_EA,					/* mode 7:0: Word address */
			ABS32_EA,					/* mode 7:1: Long address */

	END_ALT_EA_RANGE,	/* End memory alterable and alterable modes. */

		PC_DISP_EA,					/* mode 7:2: #word(pc) */

		PC_INDEX_EA,				/* mode 7:3: #byte(pc,xn) */

			PC_INDEX16_EA,				/* #byte(pc,xn.w) */
			PC_INDEX32_EA,				/* #byte(pc,xn.l) */
			PC_INDEX16_EA20,			/* #byte(pc,xn.w*scale) */
			PC_INDEX32_EA20,			/* #byte(pc,xn.l*scale) */

			PC_POST_INDEX_EA20,			/* ([bd,pc],xn*scale,od) */
				PC_POST_INDEX16_EA20,		/* ([bd,pc],xn.w*scale,od) */
				PC_POST_INDEX32_EA20,		/* ([bd,pc],xn.l*scale,od) */

			PC_PRE_INDEX_EA20,			/* ([bd,pc],xn*scale,od) */
				PC_PRE_INDEX16_EA20,		/* ([bd,pc,xn.w*scale],od) */
				PC_PRE_INDEX32_EA20,		/* ([bd,pc,xn.l*scale],od) */

	BEGIN_MODE7_4_RANGE,	/* Begin mode 7:4... */

		IMMEDIATE_EA,				/* mode 7:4: #immediate */

			IMM8_EA,					/* Byte data */
			IMM16_EA,					/* Word data */
			IMM32_EA,					/* Long data */
			IND16_EA20,					/* #word(a0) */

	END_MODE7_4_RANGE,	/* End mode 7:4... */

	END_MODE7_RANGE,	/* End mode 7. */

	END_EA_RANGE,		/* End of address modes. */

		/* Start of compiler tokens (continues to end) */

	BEGIN_TOKEN_RANGE,		/* Tokens begin here and continue to the end... */

	BOUND_TOK,			/* Visible macro boundary. Created in macro.c */
	COLON_TOK,			/* A colon. */
	COMMA_TOK,			/* A comma. */
	COMMENT_TOK,		/* Comment. */
	CONS_TOK,			/* Parser token: cons node. */
	DOT_TOK,			/* .   */
	DOTS3_TOK,			/* ... */
	END_PROG_TOK,		/* Visible end-of-program. */
	ERROR_CHAR_TOK,		/* Possible partial token for pasting. */
	ERROR_MESSAGE_TOK,	/* Delayed error message. */
	EXPRESSION_TOK,		/* Created by parser. */
	FILE_NAME_TOK,		/* &lt; any sequence not containing '&lt;' &gt; */

	BEGIN_KEY_RANGE,		/* Start of all keywords... */

		BEGIN_X_RANGE,	/* Assembler mnemonics for executable operations. */

		/* Classes of opcodes. */

		X_DBcc,
		X_Scc,
		X30_TRAPcc,
		
		BEGIN_X30_RANGE,	/* Instructions unique to the 68030. */

			X30_BFCHG,
			X30_BFCLR,
			X30_BFEXTS,
			X30_BFEXTU,
			X30_BFFF0,
			X30_BFINS,
			X30_BFSET,
			X30_BFTST,
	
			X30_CAS,
			X30_CAS2,
			X30_CHK2,
			X30_CMP2,
	
			X30_DIVSL,
			X30_DIVUL,
	
			X30_EXTB,
	
			X30_MOVEC,
			X30_MULSL,
			X30_MULUL,
	
			X30_PACK,
	
			X30_TRAPCC,
			X30_TRAPCS,
			X30_TRAPEQ,
			X30_TRAPF,
			X30_TRAPGE,
			X30_TRAPGT,
			X30_TRAPHI,
			X30_TRAPLE,
			X30_TRAPLS,
			X30_TRAPLT,
			X30_TRAPMI,
			X30_TRAPNE,
			X30_TRAPPL,
			X30_TRAPT,
			X30_TRAPVC,
			X30_TRAPVS,
	
			X30_UNPK,
			
		END_X30_RANGE,

		/* Instructions found in the 68000. */

		X_ABCD,
		X_ADD,
		X_ADDA,
		X_ADDI,
		X_ADDQ,
		X_ADDX,
		X_AND,
		X_ANDI,
		X_ASL,
		X_ASR,

		X_BCHG,
		X_BCLR,
		X_BKPT,
		X_BRA,
		X_BSET,
		X_BSR,
		X_BTST,

		X_BCC,
		X_BCS,
		X_BEQ,
		X_BGE,
		X_BGT,
		X_BHI,
		X_BLE,
		X_BLS,
		X_BLT,
		X_BMI,
		X_BNE,
		X_BPL,
		X_BVC,
		X_BVS,

		X_CHK,
		X_CLR,
		X_CMP,
		X_CMPA,
		X_CMPI,
		X_CMPM,

		X_DBCC,
		X_DBCS,
		X_DBEQ,
		X_DBF,
		X_DBGE,
		X_DBGT,
		X_DBHI,
		X_DBLE,
		X_DBLS,
		X_DBLT,
		X_DBMI,
		X_DBNE,
		X_DBPL,
		X_DBT,
		X_DBVC,
		X_DBVS,

		X_DIVS,
		X_DIVU,

		X_EOR,
		X_EORI,
		X_EXG,
		X_EXT,
		
		X_ILLEGAL,

		X_JMP,
		X_JSR,

		X_LEA,
		X_LINK,
		X_LSL,
		X_LSR,

		X_MOVE,
		X_MOVEA,
		X_MOVEM,
		X_MOVEP,
		X_MOVEQ,
		X_MOVES,
		X_MULS,
		X_MULU,

		X_NBCD,
		X_NEG,
		X_NEGX,
		X_NOP,
		X_NOT,

		X_OR,
		X_ORI,

		X_PEA,

		X_RESET,
		X_ROL,
		X_ROR,
		X_ROXL,
		X_ROXR,
		
		X_RTD,
		X_RTE,
		X_RTR,
		X_RTS,

		X_SBCD,
		X_SCC,
		X_SCS,
		X_SEQ,
		X_SF,
		X_SGE,
		X_SGT,
		X_SHI,
		X_SLE,
		X_SLS,
		X_SLT,
		X_SMI,
		X_SNE,
		X_SPL,
		X_ST,
		X_SVC,
		X_SVS,

		X_STOP,
		X_SUB,
		X_SUBA,
		X_SUBI,
		X_SUBQ,
		X_SUBX,
		X_SWAP,

		X_TAS,
		X_TRAP,
		X_TRAPV,
		X_TST,

		X_UNLK,

	END_X_RANGE,

	BEGIN_PSEUDO_RANGE,			/* Start of all keywords for pseudo operators. */

		Z_ALIGN,	/* Align. */
		Z_CASE,		/* Ignored: specify how to handle cases of identifiers. */
		Z_CODE,		/* Start of code segment. */
		Z_DATA,		/* Start data segment. */
		Z_DCB,		/* Data block. */
		Z_DC,		/* DC pseudo instruction. */
		Z_END,		/* End assembly file. */
		Z_ENDPROC,	/* End procedure. */
		Z_ENDR,		/* Ignored: end record specification. */
		Z_ENTRY,	/* Define entry point. */
		Z_EXPORT,	/* Make a symbol globally visible. */
		Z_IMPORT,	/* Refer to a globally visible symbol. */
		Z_OPT,		/* Ignored: specify optimizations. */
		Z_OPWORD,	/* Specify a 2-byte operation code. */
		Z_PROC,		/* Start of procedure. */
		Z_RECORD,	/* Ignored: start record specification. */
		Z_SEG,		/* Ignored: specify segment. */
		Z_STRING,	/* Ignored: specify how strings are to be handled. */
		Z_WITH,		/* Ignored: specify a record. */

	END_PSEUDO_RANGE,

	BEGIN_PP_KEY_RANGE,		/* Start of all PP keywords... */

		BEGIN_PP_KEY_ONLY_RANGE,	/* Start of keywords used only by the PP... */

		K_DEFINE,
		K_ELIF,
		K_ENDIF,
		K_ERROR,
		K_IFDEF,
		K_IFNDEF,
		K_INCLUDE,
		K_LINE,
		K_PRAGMA,
		K_UNDEF,

			BEGIN_NO_DEF_RANGE,	/* Start of reserved PP macro keywords... */

			KM_DATE,
			KM_DEFINED,
			KM_FILE,
			KM_LINE,
			KM_STDC,
			KM_TIME,

			END_NO_DEF_RANGE,	/* End of reserved PP macro keywords. */

		END_PP_KEY_ONLY_RANGE,	/* End of keywords used only by the PP. */

		K_ELSE,			/* Keywords which are both PP and parser keywords. */
		K_IF,

	END_PP_KEY_RANGE,	/* End of all PP keywords. */

	END_KEY_RANGE,		/* End of *all* keywords. */

	LCURLY_TOK,			/* { */

	MACRO_ARG_TOK,		/* macro argument. created by mac_define. */

/*
	Operands are grouped to make switches faster.
	Operands should be defined adjacent to operators.
*/
	CHAR_TOK,		/* Character constant. */
	FLOAT_TOK,		/* floating constant. */
	ID_TOK,			/* An id that is not a reserved word. */
	IDX_TOK,		/* Disabled macro id. */
	INT_TOK,		/* An integer constant. */
	STRING_TOK,		/* string constant. */

/*
	Operators are grouped so that their precedence can be found from a table.

	Warning: change expr_prec if this subrange changes.
*/

	BEGIN_UNOP_RANGE,	/* Start of unary operators... */

		NOT_TOK,	/* ! */
		TILDE_TOK,	/* ~ */
		UMINUS_TOK,	/* unary - created by parser. */
		UPLUS_TOK,	/* unary + created by parser. */

	END_UNOP_RANGE,		/* End of unary operators. */

	BEGIN_BINOP_RANGE,	/* Start of binary operators... */

		AND_TOK,	/* &amp; */
		DIV_TOK,	/* / */
		MINUS_TOK,	/* - */
		MOD_TOK,	/* % */
		OR_TOK,		/* | */
		PLUS_TOK,	/* + */
		STAR_TOK,	/* * */
		XOR_TOK,	/* ^ */

	END_BINOP_RANGE,	/* End of binary operators. */

	ASSN_TOK,	/* =  */	/* Preprocessor only operators... */
	EQUAL_TOK,	/* == */
	GE_TOK,		/* &gt;= */
	GT_TOK,		/* &gt;  */
	LAND_TOK,	/* &amp;&amp; */
	LE_TOK,		/* &lt;= */
	LOR_TOK,	/* || */
	LSHIFT_TOK,	/* &lt;&lt; */
	LT_TOK,		/* &lt;  */
	NE_TOK,		/* != */
	RSHIFT_TOK,	/* &gt;&gt; */

	LBRACK_TOK,		/* [ */
	LPAREN_TOK,		/* ( */

	PARTIAL_CHAR_TOK,		/* char constant without trailing ' */
	PARTIAL_FILE_NAME_TOK,	/* file name with trailing &gt; */
	PARTIAL_STRING_TOK,		/* string without trailing " */

	POUND_TOK,			/* #  */
	POUND_POUND_TOK,	/* ## */
	
	QUESTION_TOK,	/* ? */

	RBRACK_TOK,		/* ] */
	RCURLY_TOK,		/* } */
	RPAREN_TOK,		/* ) */

	ULABEL_TOK,		/* user label */

	/*
		White space tokens are grouped for easy recognition.
	*/
	BEGIN_WS_RANGE,

		WS_FF_TOK,		/* form feed. */
		WS_NL_TOK,		/* newline. */
		WS_VTAB_TOK,	/* vertical tab. */
		WS_TOK,			/* one blank. */
		WS_BLANKS_TOK,	/* 1 or more blanks. */

	END_WS_RANGE,

	/*
		Hidden tokens are grouped so they can be recognized quickly.
		This makes the next_tok macro much faster.
	*/
	BEGIN_HIDDEN_RANGE,

		HIDDEN_BEGIN_FILE_TOK,		/* Start of a file. */
		HIDDEN_BIG_IGNORE_TOK,		/* Ignored big token. */
		HIDDEN_BIG_SKIP_TOK,		/* Skip multiple lines. */
		HIDDEN_END_BLOCK_TOK,		/* End token block token. */
		HIDDEN_END_FILE_TOK,		/* End file. */
		HIDDEN_FILE_INFO_TOK,		/* Created by cpp_line. */
		HIDDEN_LINE_ADJUST_TOK,		/* Adjust after comment. */
		HIDDEN_NL_IN_COMMENT_TOK,	/* Newline in comment. */
		HIDDEN_NL_IN_MACRO_TOK,		/* Newline in macro call. */
		HIDDEN_SMALL_IGNORE_TOK,	/* Ignored small token. */
		HIDDEN_SKIP_TOK,			/* Skip to next token. */
		HIDDEN_SKIP_DIRECTIVE_TOK,	/* Skip one directive line. */
		HIDDEN_SKIP_TO_MACRO_TOK,	/* Start of macro. */

	END_HIDDEN_RANGE,

	/*
		WARNING: The is_hidden macro assumes that there are no
				 legal tokens beyond the hidden tokens!
	*/

	BAD_LAST_TOK

};

/*
	The following is_xxx macros take the place of type code.
*/
#define is_token(n)		(n &gt; BEGIN_TOKEN_RANGE)

#define is_areg(n)		(n &gt;= R_A0 &amp;&amp; n &lt;= R_SP)
#define is_binop(n)		(n &gt; BEGIN_BINOP_RANGE		&amp;&amp; n &lt; END_BINOP_RANGE)
#define is_dreg(n)		(n &gt;= R_D0 &amp;&amp; n &lt;= R_D7)
#define is_eatok(n)		(n &gt; BEGIN_EA_RANGE			&amp;&amp; n &gt; END_EA_RANGE)
#define is_hidden(n)	(n &gt; BEGIN_HIDDEN_RANGE)
#define is_id(n)		(is_key(n) || n == ID_TOK)
#define is_kdecl(n)		(n &gt; BEGIN_KDECL_RANGE		&amp;&amp; n &lt; END_KDECL_RANGE)
#define is_key(n)		(n &gt; BEGIN_KEY_RANGE		&amp;&amp; n &lt; END_KEY_RANGE)
#define is_mnemonic(n)	(n &gt; BEGIN_ASMOP_RANGE  	&amp;&amp; n &lt; END_ASMOP_RANGE)
#define is_nodef(n)		(n &gt; BEGIN_NO_DEF_RANGE 	&amp;&amp; n &lt; END_NO_DEF_RANGE)
#define is_otok(n)		(n &gt; BEGIN_O_RANGE			&amp;&amp; n &lt; END_O_RANGE)
#define is_ppkey(n)		(n &gt; BEGIN_PP_KEY_RANGE 	&amp;&amp; n &lt; END_PP_KEY_RANGE)
#define is_ppkey_only(n)(n &gt; BEGIN_PP_KEY_ONLY_RANGE &amp;&amp; n &lt; END_PP_KEY_ONLY_RANGE)
#define is_pseudo(n)	(n &gt; BEGIN_PSEUDO_RANGE		&amp;&amp; n &lt; END_PSEUDO_RANGE)
#define is_reg(n)		(n &gt; BEGIN_REG_RANGE		&amp;&amp; n &lt; END_REG_RANGE)
#define is_unop(n)		(n &gt; BEGIN_UNOP_RANGE		&amp;&amp; n &lt; END_UNOP_RANGE)
#define is_ws(n)		(n &gt; BEGIN_WS_RANGE			&amp;&amp; n &lt; END_WS_RANGE)
#define is_xreg(n)		(is_areg(n) || is_dreg(n))
#define is_xtok(n)		(n &gt; BEGIN_X_RANGE			&amp;&amp; n &lt; END_X_RANGE)
#define is_x30tok(n)	(n &gt; BEGIN_X30_RANGE		&amp;&amp; n &lt; END_X30_RANGE)

#define is_bxx(n)  (n &gt;= X_BCC	 &amp;&amp; n &lt;= X_BVS)
#define is_dbxx(n) (n &gt;= X_DBCC	 &amp;&amp; n &lt;= X_DBVS)

	/* Define macros that convert a register token to a register token. */
	
#define areg_num(tok) (((tok) == R_SP) ? 7 : ((tok) - R_A0))
#define dreg_num(tok) ((tok) - R_D0)

/* ----- Token macros ----- */

/*
	Define token sizes.

	MAX_TOKEN_SIZE is space that must be left free in a token block
	so that there is room for one more token *and* a HIDDEN_END_BLOCK_TOK.
*/
#define SMALL_TOKEN_SIZE sizeof(token)
#define BIG_TOKEN_SIZE (sizeof(token) + sizeof(char *))
#define MAX_TOKEN_SIZE (BIG_TOKEN_SIZE+BIG_TOKEN_SIZE)

/*
	Make sure enough space remains for the next token and
	allocate another token block if required.
*/
#define tok_protect_macro(tp, tavail) \
{\
	if (MAX_TOKEN_SIZE &gt; tavail) {\
		tp = mem_new_tok_block(tp, tavail);\
		tavail = token_life -&gt; mem_avail;\
	}\
}

/*
	Increment token pointer tp by n.

	This is trickier than it looks,
	because this macro must work regardless of the value of sizeof(*tp).
	For example, we can't say tp += n because sizeof(tp) may not be 1.
*/
#define bump_tp_macro(tp, n) { tp = (token *) (((char *) tp) + n); }

/*
	put_small_tok, put_id_tok, put_ptr_tok, put_val_tok.

	I experimented with writing parts of these macros
	in assembly language, but no speed was gained.

	At present, these macros are used only in tokize.c.
	However, they should be defined here since
	several other macros in this file must change 
	if the format of tokens defined by the put_xxx_tok macros change.

	7/3/93:
		These macros were revised to make them independent of
		the values of sizeof(tp), that is sizeof(token).
*/

/*
	Place a new small token in the token list.
*/
#define put_small_tok(tp, tavail, tok)\
{\
	tok_protect_macro(tp, tavail);\
	*tp++ = tok;\
	tavail -= SMALL_TOKEN_SIZE;\
}

/*
	Place a new (big) id token in the token list.
*/
#define put_id_tok(tp, tavail, tok, ptr)\
{\
	tok_protect_macro(tp, tavail);\
	*tp++ = tok;\
	* ((char **) tp) = (char *) ptr;\
	bump_tp_macro(tp, sizeof(char *));\
	tavail -= BIG_TOKEN_SIZE;\
}

/*
	Place a new (big) pointer token in the token list.
*/
#define put_ptr_tok(tp, tavail, tok, ptr)\
{\
	tok_protect_macro(tp, tavail);\
	*tp++ = tok;\
	* ((char **) tp) = (char *) ptr;\
	bump_tp_macro(tp, sizeof(char *));\
	tavail -= BIG_TOKEN_SIZE;\
}

/*
	Place a new (big) value token in the token list.
*/
#define put_val_tok(tp, tavail, tok, val)\
{\
	tok_protect_macro(tp, tavail);\
	*tp++ = tok;\
	* ((long *) tp) = val;\
	bump_tp_macro(tp, sizeof(char *));\
	tavail -= BIG_TOKEN_SIZE;\
}

/*
	Return the next *visible* preprocessor token.
	This macro will never return a token whose name starts with HIDDEN_.

	This macro absolutely must be as fast as possible.
	Using a function call here significantly degrades performance.
*/
#define next_tok(tp)\
{\
	if (!is_hidden(*tp)) bump_tp_macro(tp, tok_size(*tp));\
	if (is_hidden(*tp)) tp = tok_skip_hidden(tp);\
}

/*
	Return the next preprocessor token, whether visible or invisible.

	The speed of this macro is not very important since it is rarely used
	and used only in non-critical locations.
*/
#define next_raw_tok(tp) tp = tok_next_raw(tp)

/*
	Convert a large token into another large token.

	Warning: an ASSERT would be useful here.

	1 is *not* a magic constant.  Use 1, not SMALL_TOKEN_SIZE.
	Since tp is a pointer, the 1 will be properly scaled by sizeof(token).
	The old code only works if sizeof(token) == 1!
*/

#define patch_ptr_tok(tp, ptr) { *((char **) (tp+1)) = (char *) ptr; }
#define patch_val_tok(tp, val) { *((long *) (tp+1)) = val; }

/*
	Return the last 4 bytes of a big token.

	The various forms of this macro eliminate the need for most casts.

	1 is *not* a magic constant.  Use 1, not SMALL_TOKEN_SIZE.
	Since tp is a pointer, the 1 will be properly scaled by sizeof(token).
	The old code only works if sizeof(token) == 1!
*/
#define id_tok_ptr(tp)  ((spell_node *) *((char **) (tp+1)))
#define ptr_tok_ptr(tp) *((char **) (tp+1))
#define val_tok_val(tp) *((long *) (tp+1))

/*
	Skip white space preprocessor tokens.
*/
#define skip_ws_tok(tp)\
{\
	if (is_hidden(*tp)) tp = tok_skip_hidden(tp);\
	while(is_ws(*tp) {\
		next_tok(tp);\
	}\
}

/*
	Skip "horizontal" white space preprocessor tokens: blank, tab, comments.
*/
#define skip_hws_tok(tp)\
{\
	if (is_hidden(*tp)) tp = tok_skip_hidden(tp);\
	while(is_ws(*tp) &amp;&amp; *tp != WS_NL_TOK) {\
		next_tok(tp);\
	}\
}

/*
	Function prototypes.
*/
void	etok	(token * p);
void	etoknum	(token tok);

	/* Synonyms for flags. */

		/* print_hidden_flag */
		enum { PRINT_HIDDEN_TOKS = TRUE, DONT_PRINT_HIDDEN_TOKS = FALSE };

		/* split_flag */
		enum { SPLIT_LONG_LINES = TRUE, DONT_SPLIT_LONG_LINES = FALSE };

		/* user_flag */
		enum {PRINT_USER_TOKENS = TRUE, PRINT_NON_USER_TOKENS = FALSE };

void	tok_check		(void);
token *	tok_dump		(token * tp, bool print_hidden_flag);
token *	tok_dump_delim	(token * tp, token delim);
token *	tok_dump_delim2
	(token * tp, token delim, bool print_hidden_flag);
token *	tok_dump_line	(token * tp);
token *	tok_dump_line2
	(token * tp, bool print_hidden_flag, bool split_flag, bool user_flag);
token *	tok_dump_list	(token * start_p, token * end_p);
token *	tok_dump_list2	(token * start_p, token * end_p, bool print_hidden_flag);
void	tok_dump1	(token * tp, bool print_hidden_flag);
token *	tok_copy	(token the_token, void * the_ptr);
token *	tok_copy_list
	(token * start_p, token * end_p, token ** last_copy, char * tag);
token *		tok_copy2nl		(token * start_p, token ** last_copy, char * tag);
spell_node *tok_enter		(char * string_start, int string_length, long hash);
void		tok_ignore		(token * tp);
long		tok_hash		(char * s);
void		tok_init		(void);
spell_node *tok_lookup_hash	(char *s);
spell_node *tok_lookup		(char * string_start, long string_length, long hash);
token *		tok_next_		(token * tp);
token *		tok_next_raw	(token * tp);
token *		tok_out_line	(token * tp);
void 		tok_par_next	(void);
void tok_par_next_skip_ws	(void);
void		tok_out			(token * tp);
void		tok_patch
	(token * patch_tp, token the_token, void * the_ptr, char * tag);
token *	tok_scan		(register token * tp);
token *	tok_scan_file	(char * file_name, token * first_tok);
token *	tok_scan_line
	(token * first_tok, long target_line, char * target_file_name, long * returned_line);
token *	tok_skip_hidden	(token * tp);
char *	tok_2string		(token * tp, int * length, bool stringize_flag);
void	tok_skip_ws		(void);

/*
	Declare global variables owned by tokens.c.
*/
extern int tok_update_flag;	/* TRUE: update line numbers in next_tok, etc. */

extern char	tok_size_array [BAD_LAST_TOK + 1];	/* Makes tok_size macro faster. */
extern tok_info_type tok_info [];				/* The token info array. */

extern long		tok_cur_lab;	/* The current label index. */
extern token *	tok_token_ptr;	/* Ptr to the current token. */
extern token *	tok_line_ptr;	/* Ptr to the newline before the current line. */

#endif /* AStokens_h_ */</t>
<t tx="ekr.20080529093004.264">/*
	AS: header file for AStokize.c.

	source:  AStokize.h
	started: December 20, 1993.
	version:
		December 27, 1993.
			Removed sym_hash_tab.  It is now local to AStokize.c.
		December 23, 1993.
			New memory management installed.
*/

#ifndef AStokize_h_
#define AStokize_h_

#pragma once

/*
	Enable or disable token statistics.
*/
#undef  DO_TOKIZE_STATS
#define DO_TOKIZE_STATS

#ifdef DO_TOKIZE_STATS
	#define TOKIZE_STATS(s) s
#else
	#define TOKIZE_STATS(s)
#endif

	/* Global token statistics. */

extern long	tok_bigs;		/* Number of big tokens. */
extern long	tok_blocks;		/* Number of token blocks. */
extern long	tok_bytes;		/* Total allocated bytes. */
extern long	tok_end_blocks;	/* Number of end block tokens. */
extern long	tok_number;		/* Total number of tokens. */
extern long	tok_smalls; 	/* Number of small tokens. */
extern long	tok_waste;		/* Number of wasted bytes. */

	/* Define the first token block. */

extern token * tok_first_token;/* First token of the outer file. */

	/* Function prototypes */

		/* Synonyms for skip_flag. */
		enum { END_WITH_SKIP_TOK = TRUE, END_WITH_EOF_TOK = FALSE };
		
token *	tokize
	(
		io_mem_block * input_block, 
		file_info_node * return_fip,
		char * file_name,
		bool skip_flag,
		token * skip_tp
	);

void	tok_dump_stats		(void);
void	tok_init_hash_tab	(void);
void	tok_reinit_stats	(void);

#endif /* AStokize_h_ */</t>
<t tx="ekr.20080529093004.265"></t>
<t tx="ekr.20080529093004.266">/*
	AS: Routines dealing with anodes.

	source:  ASanodes.c
	started: December 31, 1993.
	version:
		February 13, 1994.
			Added oanode_bits.
		February 6, 1994.
			Added support for SPECIAL_EA.
			Added dummy code for REGLIST_EA.
*/

&lt;&lt; ASanodes #includes &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.267">#include "AS.h"

#include "ASanodes.h"
#include "AScnodes.h"
#include "ASexp.h"
#include "AStokens.h"
#include &lt;LIBos.h&gt;
</t>
<t tx="ekr.20080529093004.268">@ Dump an anode or a label.
@c

void
eanode(anode * ap)
{
	FTAG("eanode");
	STATB(ftag);

	if (ap == NULL) {
		es("&lt;NULL anode&gt;");
		goto done;
	}

	switch(ap -&gt; n_type) {

	case ABSOLUTE_EA:	/* address */

		eenode(ap -&gt; a_enode);
		break;

	case AREG_EA:		/* a4 */
	case DREG_EA:		/* d5 */

		es(tok_name(ap -&gt; a_reg));
		break;

	case DISPLACEMENT_EA:	/* word(a6) */

		eenode(ap -&gt; a_enode);
		es("("); es(tok_name(ap -&gt; a_reg)); es(")");
		break;

	case IMMEDIATE_EA:	/* #data */

		es("#"); eenode(ap -&gt; a_enode);
		break;

	case INDIRECT_EA:	/* (a0) */

		es("("); es(tok_name(ap -&gt; a_reg)); es(")");
		break;

	case INDEX_EA:		/* byte(a4,d4) */

		eenode(ap -&gt; a_enode); es("(");
		es(tok_name(ap -&gt; a_reg)); es(",");
		es(tok_name(ap -&gt; a_xreg)); es(")");
		break;

	case PC_DISP_EA:	/* word(pc) */

		eenode(ap -&gt; a_enode);
		es("(pc)");
		break;

	case PC_INDEX_EA:	/* byte(pc,xn) */

		eenode(ap -&gt; a_enode);
		es("(pc,"); es(tok_name(ap -&gt; a_xreg)); es(")");
		break;

	case POST_INC_EA:	/* (a0)+ */

		es("("); es(tok_name(ap -&gt; a_reg)); es(")+");
		break;

	case PRE_DEC_EA:	/* -(a0) */

		es("-("); es(tok_name(ap -&gt; a_reg)); es(")");
		break;
		
	case REGLIST_EA:

		es("&lt;register list: "); epadhex(ap -&gt; xwords, 4); es("&gt;");
		break;

	case SPECIAL_EA:	/* Special purpose register. */
	
		es(tok_name(ap -&gt; a_reg));
		break;
			
	default:
		es("&lt;unknown address mode:"); eint(ap -&gt; n_type); es("&gt;");
	}

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.269">@ Dump the bits of an anode and return the number of charactrs printed. Print a trailing blank only if something else is, in fact, printed.
@c

int
eanode_bits(anode * ap)
{
	FTAG("eanode_bits");
	int length = 0;
	STATB(ftag);
	
	/* Print blanks for a NULL argument. */
	if (ap) {

		switch(ap -&gt; xsize) {
	
		case 0:
			break;
	
		case 1:
			/* The top half of the longword should be empty except for the sign bit. */
			if ((ap -&gt; xwords) &amp; (0xffff0000)) {
				es(" ??"); epadhex(ap -&gt; xwords, 8);
				length += 11;
			}
			else {
				eblank(); epadhex(ap -&gt; xwords, 4);
				length += 5;
			}
			break;
			
		case 2:
		{
			ulong top = ((ap -&gt; xwords) &gt;&gt; 16);
			top &amp;= 0xffff;
			eblank(); epadhex(top, 4); eblank();
			eblank(); epadhex((ap -&gt; xwords) &amp; (0xffff), 4);
			length += 10;
			break;
		}
	
		default:
			es(" ???? ????");
			length += 10;
			break;
		}
	}
	
	STATX(ftag);
	return length;
}
</t>
<t tx="ekr.20080529093004.270">@ Dump the bits of an anode. Print a trailing blank only if something else is, in fact, printed.
@c

int
oanode_bits(anode * ap)
{
	FTAG("eanode_bits");
	int length = 0;
	STATB(ftag);
	
	if (ap) {

		switch(ap -&gt; xsize) {
	
		case 0:
			break;
	
		case 1:
			/* The top half of the longword should be empty. */
			if ((ap -&gt; xwords) &amp; (0xffff0000)) {
				os(" ??"); opadhex(ap -&gt; xwords, 8);
				length += 11;
			}
			else {
				oblank(); opadhex(ap -&gt; xwords, 4);
				length += 5;
			}
			break;
			
		case 2:
		{
			ulong top = ((ap -&gt; xwords) &gt;&gt; 16);
			top &amp;= 0xffff;
			oblank(); opadhex(top, 4);
			oblank(); opadhex((ap -&gt; xwords) &amp; (0xffff), 4);
			length += 10;
			break;
		}
	
		default:
			os(" ???? ????");
			length += 10;
			break;
		}
	}
	
	STATX(ftag);
	return length;
}
</t>
<t tx="ekr.20080529093004.271">/*
	AS: Routines dealing with cnodes.

	source:  AScnodes.c
	started: December 31, 1993.
	version:
		February 6, 1995.
			Added support for line_cnodes.
		January 24, 1995.
			Bug fix to ecnode: changed a switch to an if statement so it
			can handle the situation where DOUBLE_SIZE == LONG_DOUBLE_SIZE.
			Changed some hard constants to FLOAT_SIZE, DOUBLE_SIZE or LONG_DOUBLE_SIZE.
		April 26, 1994.
			Added cnode_strlen to handle repeated single quotes in assembler strings.
		April 22, 1994.
			Added support for multi-byte character constants.
		April 21, 1994.
			Added code to properly print floats, doubles and long doubles.
		March 24, 1994.
			Added out_cnode.
		February 13, 1994.
			Added ocnode_bits.
			Revised ecnode_bits.
*/

&lt;&lt; AScnodes #includes &gt;&gt;
&lt;&lt; AScnodes declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.272">#include "AS.h"

#include "ASanodes.h"
#include "AScnodes.h"
#include "ASexp.h"
#include "ASofile.h"
#include "ASsem.h"
#include "AStarget.h"
#include "AStokens.h"

#include &lt;LIBos.h&gt;
#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.273">/*
	Prototypes of internal routines.
*/
static size_t cnode_strlen (register char * s);
</t>
<t tx="ekr.20080529093004.274">@ Return the number of application bytes used in an instruction.
@c

short
cnode_app_size(cnode * cp)
{
	FTAG("cnode_app_size");
	short size = 0;
	cinode * cip = cinode_ptr(cp);
	STATB(ftag);
	ASSERT(cp);
	
	/* Calculate the size of the instruction in words. */
	switch(cp -&gt; n_type) {
	
	case O_ULABEL:
		break;
	
	case Z_ALIGN:
		size += align_cnode_ptr(cp) -&gt; align_pad;
		break;

	case Z_DC:
	{
		/* Count the number of constants. */
		dc_cnode * dc_p = dc_cnode_ptr(cp);
		short dc_size = dc_p -&gt; dc_size;
		dc_list_node * dc_list_p = dc_p -&gt; dc_val_list;
		while(dc_list_p) {
			ASSERT(dc_list_p -&gt; dc_enode);
			if (dc_list_p -&gt; dc_enode -&gt; n_type == CHAR_TOK) {
				if (dc_size == 4 &amp;&amp; dc_p -&gt; dc_float_flag == FALSE) {
					size += 4;
				}
				else {
					size += cnode_strlen(
						string_enode_ptr(dc_list_p -&gt; dc_enode) -&gt; the_string);
				}
			}
			else {
				size += dc_size;
			}
			dc_list_p = dc_list_p -&gt; next;
		}
		break;
	}

	case Z_DCB:
		size += dcb_cnode_ptr(cp) -&gt; dcb_size;
		break;

	case Z_OPWORD:
		size += 2;
		break;
	
	default:
		PERM_ASSERT_TRACE(is_xtok(cp -&gt; n_type),
			es("unknown n_type"); es(tok_name(cp -&gt; n_type)));
		if (cip &amp;&amp; !c_is_error(cip)) {
			size = 1;
			if (cip -&gt; c_arg1) {
				size +=  cip -&gt; c_arg1 -&gt; xsize;
			}
			if (cip -&gt; c_arg2) {
				size +=  cip -&gt; c_arg2 -&gt; xsize;
			}
			if (cip -&gt; c_arg3) {
				size +=  cip -&gt; c_arg3 -&gt; xsize;
			}
			
			/* Convert word size to byte size. */
			size = size * 2;
		}
	}

	STATX(ftag);
	return size;
}
</t>
<t tx="ekr.20080529093004.275">@ Return the "effective string length of an assembler string. Repeated single quotes count as one single quote.
@c

static size_t
cnode_strlen(register char * s)
{
	FTAG("cnode_strlen");
	register size_t length = 0;
	STATB(ftag);
	
	while(*s) {
		if (*s == '\'' &amp;&amp; *(s+1) == '\'') {
			s++;
		}
		s++;
		length++;
	}

	STATX(ftag);
	return length;
}
</t>
<t tx="ekr.20080529093004.276">@ Output a code node.
@c

void
ecnode(cnode * p)
{
	FTAG("ecnode");

	if (p == NULL) {
		es("&lt;NULL cnode&gt;");
		return;
	}

	STATB(ftag);

	switch(p -&gt; n_type) {
	
	case O_ULABEL:			/* User label. */
		ASSERT(ulabel_cnode_ptr(p) -&gt; clab_dict -&gt; dict_spell);
		es(ulabel_cnode_ptr(p) -&gt; clab_dict -&gt; dict_spell -&gt; spell_name);
		break;

	case Z_ALIGN:
		es("&lt;ALIGN "); eint(align_cnode_ptr(p) -&gt; align_pad); es("&gt;");
		break;

	case Z_DC:
	{
		dc_cnode * dc_p = dc_cnode_ptr(p);
		short dc_size = dc_p -&gt; dc_size;
		dc_list_node * dc_list_p = dc_p -&gt; dc_val_list;

		es("&lt;DC.");
		if (dc_cnode_ptr(p) -&gt; dc_float_flag) {
		
			/* 1/24/95: Don't use a case: the sizes may be the same. */
			if (dc_size == FLOAT_SIZE) {
				es("S");
			}
			else if (dc_size == DOUBLE_SIZE) {
				es("Q");
			}
			else if (dc_size == LONG_DOUBLE_SIZE) {
				es("X");
			}
			else {
				es("??");
			}
		}
		else {
			switch(dc_size) {
			case 1:  es("B");	break;
			case 2:	 es("W");	break;
			case 4:	 es("L");	break;
			default: es("??");	break;
			}
		}
		eblank();
		
		while(dc_list_p) {
			ASSERT(dc_list_p -&gt; dc_enode);
			if (dc_list_p -&gt; dc_enode -&gt; n_type == CHAR_TOK) {
				if (dc_size == 4 &amp;&amp; dc_p -&gt; dc_float_flag == FALSE) {
					/* A multi-byte character constant. */
					eulong(dc_list_p -&gt; dc_val);
				}
				else {
					/* Don't worry about repeated single quotes in the dump. */
					es(string_enode_ptr(dc_list_p -&gt; dc_enode) -&gt; the_string);
				}
			}
			else {
				elong(dc_list_p -&gt; dc_val);
			}
			dc_list_p = dc_list_p -&gt; next;
			if (dc_list_p) {
				es(",");
			}
		}
		es("&gt;");
		break;
	}

	case Z_DCB:
		es("&lt;DCB size: "); eulong(dcb_cnode_ptr(p) -&gt; dcb_size);
		es(", val: "); elong(dcb_cnode_ptr(p) -&gt; dcb_val);
		es("&gt;");
		break;

	case Z_OPWORD:
		es("&lt;OPWORD: "); epadhex(opword_cnode_ptr(p) -&gt; opword, 4); es("&gt;");
		break;

	default:
		ASSERT(is_xtok(p -&gt; n_type));
		ecinode(cinode_ptr(p));
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.277">@ Print the opcode bits of a cnode to the log file. Print filler if cip is NULL or if the cnode is not a cinode. Return the number of columns printed.
@c

void
ecnode_bits(cnode * cp)
{
	FTAG("ecnode_bits");
	cinode * cip = cinode_ptr(cp);
	int length = 0;
	STATB(ftag);
	
	if (cip &amp;&amp; is_xtok(cip -&gt; n_type) &amp;&amp; !c_is_error(cip)) {

		/* Print the bits. */
		eblank(); epadhex(cip -&gt; c_bits, 4);
		length += 5;
		
		if (c_is_reversed(cip)) {
			/* Reverse the fields! */
			length += eanode_bits(cip -&gt; c_arg2);
			length += eanode_bits(cip -&gt; c_arg1);
		}
		else {
			length += eanode_bits(cip -&gt; c_arg1);
			length += eanode_bits(cip -&gt; c_arg2);
			#if 0 /*  not ready yet. */
				length += eanode_bits(cip -&gt; c_arg3);
			#endif
		}
	}
	
	/*
		Fill out the rest of the field.
		The start of the opcode field should be a multiple of 4 to have tabs print properly.
		6 is the length of the address field.
	*/
	eblanks (32-length-6);
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.278">@ Output a code instruction node. This is used to print the source code: don't honor c_is_reversed.
@c

void
ecinode(cinode * cip)
{
	FTAG("-ecinode");
	STATB(ftag);
	ASSERT(cip);
	
	/* Print the bits. */
	ecnode_bits(cnode_ptr(cip));
	
	/* Print the mnemonic. */
	es(tok_name(cip -&gt; n_type));

	/* Output the instruction length. */
	if (cinode_ptr(cip) -&gt; c_length != cinode_ptr(cip) -&gt; c_new_len) {
		switch(cinode_ptr(cip) -&gt; c_length) {
		case 0:
			es("[0]");	break;
		case 1:
			es("[.b]");	break;
		case 100:	/* A flag value meaning "force to word length" */
		case 2:
			es("[.w]");	break;
		case 4:	es("[.l]");	break;
		default:
			es("&lt;bad new opcode length:");
			eint(cinode_ptr(cip) -&gt; c_length); es("&gt;");
		}
	}
	
	switch(cinode_ptr(cip) -&gt; c_length) {
	case 0:
		es("    ");	break;
	case 1:
		es(".b  ");	break;
	case 100:	/* A flag value meaning "force to word length" */
	case 2:
		es(".w  ");	break;
	case 4:	es(".l  ");	break;
	default:
		es("&lt;bad opcode length:");
		eint(cinode_ptr(cip) -&gt; c_length); es("&gt;");
	}
	etab();

	/* Output the arguments. */
	if (cip -&gt; c_arg1) {
		eanode (cip -&gt; c_arg1);
	}
	if (cip -&gt; c_arg2) {
		es(",");
		eanode (cip -&gt; c_arg2);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.279">@ Output the opcode bits of a cnode to the listing file. Output filler if cp is NULL or generates no bytes.  The location counter, lc, is used to print multiple lines.
@c

void
ocnode_bits(cnode * cp, ulong lc)
{
	FTAG("ocnode_bits");
	int length = 0;
	STATB(ftag);
	
	oblank();
	length++;
	if (cp &amp;&amp; is_xtok(cp -&gt; n_type)) {
	
		cinode * cip = cinode_ptr(cp);

		if (c_is_error(cip)) {
			os(" ****");
			length += 4;
		}
		else {
	
			/* Print the bits. */
			opadhex(cip -&gt; c_bits, 4);
			length += 4;
			
			if (c_is_reversed(cip)) {
				length += oanode_bits(cip -&gt; c_arg2);
				length += oanode_bits(cip -&gt; c_arg1);
			}
			else {
				length += oanode_bits(cip -&gt; c_arg1);
				length += oanode_bits(cip -&gt; c_arg2);
				#if 0 /* arg3 field not used at present. */
					length += oanode_bits(cip -&gt; c_arg3);
				#endif
			}
		}
	}
	else if (cp &amp;&amp; cp -&gt; n_type == Z_DC) {
	
		dc_cnode * dc_p = dc_cnode_ptr(cp);
		dc_list_node * dcl_p = NULL;
		short size = dc_p -&gt; dc_size;
		long columns = length;

		for (dcl_p = dc_p -&gt; dc_val_list; dcl_p; dcl_p = dcl_p -&gt; next) {
			ASSERT(dcl_p -&gt; dc_enode);
			if (dcl_p -&gt; dc_enode -&gt; n_type == CHAR_TOK) {
			
				if (size == 4 &amp;&amp; dc_p -&gt; dc_float_flag == FALSE) {
				
					/* A multi-byte string constant. */
					if (columns + (2*size) &gt;= 22) {
						/* Start another listing line. */
						onl(); opadhex(lc,5); oblank();
						columns = 6;
					}
					opadhex(dcl_p -&gt; dc_val, 2*size);
					columns += (2*size);
					lc += size;
				}
				else {
					char * s = string_enode_ptr(dcl_p -&gt; dc_enode) -&gt; the_string;
					while (*s) {
						if (columns + 2 &gt;= 28) {
							/* Start another listing line. */
							onl(); opadhex(lc,5); oblank();
							columns = 6;
						}
						opadhex(*s,2);
						/* Repeated single quotes print as one character. */
						if (*s == '\'' &amp;&amp; *(s+1) == '\'') {
							s++;
						}
						s++; columns += 2; lc++;
					}
				}
			}
			else if (dcl_p -&gt; dc_enode -&gt; n_type == STRING_TOK) {
			
				if (columns + 2 &gt;= 28) {
					/* Start another listing line. */
					onl(); opadhex(lc,5); oblank();
					columns = 6;
				}
		
				if (size == FLOAT_SIZE) {
					float d = float_enode_ptr(dcl_p -&gt; dc_enode) -&gt; float_val;
					ASSERT(sizeof(float) == FLOAT_SIZE);
					ofloat((char *) &amp;d, FLOAT_SIZE);
					columns += 2 * FLOAT_SIZE;
				}
				else if (size == DOUBLE_SIZE) {
					short double d = float_enode_ptr(dcl_p -&gt; dc_enode) -&gt; float_val;
					ASSERT(sizeof(short double) == DOUBLE_SIZE);
					ofloat((char *) &amp;d, DOUBLE_SIZE);
					columns += 2 * DOUBLE_SIZE;
				}
				else {
					long double d = float_enode_ptr(dcl_p -&gt; dc_enode) -&gt; float_val;
					ASSERT(
						size == LONG_DOUBLE_SIZE &amp;&amp;
						sizeof(long double) == LONG_DOUBLE_SIZE);
					ofloat((char *) &amp;d, LONG_DOUBLE_SIZE);
					columns += 2 * LONG_DOUBLE_SIZE;
				}
			}
			else {
				ASSERT(dcl_p -&gt; dc_enode -&gt; n_type == O_SUMMARY);
				if (columns + (2*size) &gt;= 22) {
					/* Start another listing line. */
					onl(); opadhex(lc,5); oblank();
					columns = 6;
				}
				opadhex(dcl_p -&gt; dc_val, 2*size);
				columns += (2*size);
				lc += size;
			}
			length = columns;
		}
	}
	
	/*
		Fill out the rest of the field.
		The bit field length should be a multiple of 4 to have tabs print properly.
		6 is the length of the address field.
	*/
	oblanks(32-length-6);
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.280">@ The out_anode_macro is defined here for speed, though of course it logically belongs in ASanodes.c.
@c

#define out_anode_macro(size, ap) \
{\
	if (ap -&gt; xsize == 1) {\
		ushort xwords = ap -&gt; xwords;\
		ASSERT_TRACE(xwords == ap -&gt; xwords,\
			es("xwords: "); epadhex(xwords,4);\
			es(", ap -&gt; xwords: "); epadhex(ap -&gt; xwords,8));\
		out_bytes((char *) &amp;xwords, 2, "xword");\
		size += 2;\
	}\
	else {\
		ASSERT(ap -&gt; xsize == 2);\
		out_bytes((char *) &amp;(ap -&gt; xwords), 4, "xword");\
		size += 4;\
	}\
}

/*
	Output the bytes of a cnode to the object file.
	Return the number of bytes written.
*/
ulong
out_cnode (cnode * cp)
{
	FTAG("out_cnode");
	ulong size = 0;
	cinode * cip = cinode_ptr(cp);
	STATB(ftag);
	ASSERT(cp);
	
	switch(cp -&gt; n_type) {
	
	case O_ULABEL:
		break;
	
	case Z_ALIGN:
	{
		ulong pad = align_cnode_ptr(cp) -&gt; align_pad;
		char pad_bytes [10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
		if (pad &gt; 0) {
			out_bytes((char *) &amp;pad_bytes, pad, "align bytes");
			size += pad;
		}
		break;
	}

	case Z_DC:
	{
		dc_cnode * dc_p = dc_cnode_ptr(cp);
		short dc_size = dc_p -&gt; dc_size;
		dc_list_node * dc_list_p = dc_p -&gt; dc_val_list;
		while(dc_list_p) {
		
			ASSERT(dc_list_p -&gt; dc_enode);
			if (dc_list_p -&gt; dc_enode -&gt; n_type == CHAR_TOK) {
			
				if (dc_size == 4 &amp;&amp; dc_p -&gt; dc_float_flag == FALSE) {
					/* Multi-byte character constant. */
					out_bytes((char *) &amp;(dc_list_p -&gt; dc_val), 4, "dc.l val");
					size += 4;
				}
				else {
					/* A string. */
					char * s = string_enode_ptr(dc_list_p -&gt; dc_enode) -&gt; the_string;
					size_t n = cnode_strlen(s);
					size += n;
					if (n == strlen(s)) {
						/*
							The string does not contain single quotes.
							Bug fix 8/28/94: rewrote the code to avoid strncat.
						*/
						char tag_name[42];
						char * tag_prefix = "dc.b string: ";
						size_t prefix_len = strlen(tag_prefix);
						
						/* Create a readable tag name. */
						strcpy(tag_name, tag_prefix);
						strncpy(tag_name + prefix_len, s, 40-strlen(tag_prefix));
						tag_name[min(40,n)] = '\0';
						
						/* Output *all* the bytes with a possibly truncated tag name. */
						out_bytes(s, n, tag_name);
					}
					else {
						/*
							The string contains repeated single quotes.
							Replace repeated single quotes with one single quote.
						*/
						char c[2];
						c[1] = '\0';
						while (*s) {
							c[0] = *s;
							out_bytes(&amp;c[0], 1, "dc.b string char");
							if (*s == '\'' &amp;&amp; *(s+1) == '\'') {
								s++;
							}
							s++;
						}
					}
				}
			}
			else if (dc_p -&gt; dc_float_flag) {
				/* Output float constants. */
				ASSERT(dc_list_p -&gt; dc_enode -&gt; n_type == STRING_TOK);
				if (dc_size == FLOAT_SIZE) {
					float d = float_enode_ptr(dc_list_p -&gt; dc_enode) -&gt; float_val;
					ASSERT(sizeof(float) == FLOAT_SIZE);
					out_bytes((char *) &amp;d, FLOAT_SIZE, "dc.s val");
				}
				else if (dc_size == DOUBLE_SIZE) {
					short double d = float_enode_ptr(dc_list_p -&gt; dc_enode) -&gt; float_val;
					ASSERT(sizeof(short double) == DOUBLE_SIZE);
					out_bytes((char *) &amp;d, DOUBLE_SIZE, "dc.q val");
				}
				else {
					long double d = float_enode_ptr(dc_list_p -&gt; dc_enode) -&gt; float_val;
					ASSERT(
						dc_size == LONG_DOUBLE_SIZE &amp;&amp;
						sizeof(long double) == LONG_DOUBLE_SIZE);
					out_bytes((char *) &amp;d, LONG_DOUBLE_SIZE, "dc.x val");
				}
				size += dc_size;
			}
			else {
				/* Output integer constants. */
				if (dc_size == 1) {
					char val1 = dc_list_p -&gt; dc_val;
					out_bytes((char *) &amp;val1, 1, "dc.b val");
				}
				else if (dc_size == 2) {
					short val2 = dc_list_p -&gt; dc_val;
					ASSERT(sizeof(short) == 2);
					out_bytes((char *) &amp;val2, 2, "dc.w val");
				}
				else {
					ASSERT(dc_size == 4 &amp;&amp; sizeof(long) == 4);
					out_bytes((char *) &amp;(dc_list_p -&gt; dc_val), 4, "dc.l val");
				}
				size += dc_size;
			}
			dc_list_p = dc_list_p -&gt; next;
		}
		break;
	}

	case Z_DCB:
	{
		register char * p = NULL;
		register int i = 0;

		dcb_cnode * dcb_p = dcb_cnode_ptr(cp);
		ulong count = dcb_p -&gt; dcb_size;
		char val1 = dcb_p -&gt; dcb_val;
		char buffer[100];

		/*
			The count will be 20 or less if USE_BYTE_LIST
			is #defined in ASofile.c.
		*/
		if (count &gt;= 100) {
			
			/* Fill the buffer with the value. */
			p = &amp;buffer[0];
			for (i = 0; i &lt; 100; i++) {
				*p++ = dcb_p -&gt; dcb_val;
			}
				
			/* Write 100 bytes. */
			while(count &gt;= 100) {
				out_bytes((char *) buffer, 100, "dcb val");
				count -= 100;
			}
			
			/* Finish the write. */
			if (count) {
				out_bytes((char *) buffer, count, "dcb val");
			}
		}
		else  {
		
			/* Fill the buffer with the value. */
			p = &amp;buffer[0];
			for (i = 0; i &lt; count; i++) {
				*p++ = dcb_p -&gt; dcb_val;
			}
			if (count) {
				out_bytes((char *) buffer, count, "dcb val");
			}
		}
		
		size += dcb_p -&gt; dcb_size;
		break;
	}

	case Z_OPWORD:
		
		out_bytes((char *) &amp;(opword_cnode_ptr(cp) -&gt; opword), 2, "opword");
		size += 2;
		break;
	
	default:

		PERM_ASSERT_TRACE(is_xtok(cp -&gt; n_type),
			es("unknown n_type"); es(tok_name(cp -&gt; n_type)));
		
		if (cip &amp;&amp; !c_is_error(cip)) {
		
			/* Make sure we are writing the correct part of the word. */
			ASSERT(sizeof(short)==2);

			/* Supplement the out_bytes trace with a symbolic trace. */
			TRACEPN(ftag, ecnl(); ecinode(cip); ecnl());
	
			out_bytes((char *) &amp;(cip -&gt; c_bits), 2, "opcode");
			size += 2;
			
			if (c_is_reversed(cip)) {
			
				ASSERT(cip -&gt; c_arg1 &amp;&amp; cip -&gt; c_arg2 &amp;&amp; cip -&gt; c_arg3 == NULL);
				
				if (cip -&gt; c_arg2 &amp;&amp; cip -&gt; c_arg2 -&gt; xsize &gt; 0) {
					out_anode_macro(size, cip -&gt; c_arg2);
				}
				if (cip -&gt; c_arg1 &amp;&amp; cip -&gt; c_arg1 -&gt; xsize &gt; 0) {
					out_anode_macro(size, cip -&gt; c_arg1);
				}
			}
			else {
			
				if (cip -&gt; c_arg1 &amp;&amp; cip -&gt; c_arg1 -&gt; xsize &gt; 0) {
					out_anode_macro(size, cip -&gt; c_arg1);
				}
				if (cip -&gt; c_arg2 &amp;&amp; cip -&gt; c_arg2 -&gt; xsize &gt; 0) {
					out_anode_macro(size, cip -&gt; c_arg2);
				}
				if (cip -&gt; c_arg3 &amp;&amp; cip -&gt; c_arg3 -&gt; xsize &gt; 0) {
					out_anode_macro(size, cip -&gt; c_arg3);
				}
			}
		}
	}

	STATX(ftag);
	ASSERT_TRACE(size == cnode_app_size(cp),
		es("size: "); eint(size);
		es(", cnode_app_size: "); eint(cnode_app_size(cp));
		es(", cnode: "); ecnode(cp); ecnl());
	return size;
}
</t>
<t tx="ekr.20080529093004.281">/*
	AS: Token space routines.

	source: AStokens.c
	started: September 25, 1991
	version:
		June 12, 1994.
			Bug fix to tok_2string.  ERROR_CHAR_TOK should return buffer, not ptr.
			Added QUESTION_TOK for the preprocessor.
		May 26, 1994.
			Added tok_par_next_skip_ws for greater speed.
			Changed tok_copy2nl so it stops on COMMENT_TOK's.
			This makes sense in assembly language, but *not* in C!
		April 22, 1994.
			Added ASSN_TOK so that '=' in full-line comments are handled without
			generating an error.
		April 7, 1994.
			Bug fix to default case of tok_dump1.
		March 30, 1994.
			The names of all pseudo operators changed to lower case because
			tok_init_hash_tab now enters them all in both upper and lower case.
		February 11, 1994.
			Made WS_NL_TOK a large token so it can point to cnodes.
		February 10, 1994.
			Added O_SLIST.
		February 9, 1994.
			Removed LONG_TOK (replaced throughout by INT_TOK).
			Removed UAND_TOK.
		January 26, 1994.
			Added COLON_TOK for optional colons after labels.
		January 25, 1994.
			Registers are now proper tokens.
		January 19, 1994.
			Added DREG_DREG_EA, OFFSET_WIDTH_EA, REGLIST_EA and SPECIAL_EA.
			Added definitions of control registers.
		January 18, 1994.
			Reorganized address modes into ranges.
		January 16, 1994.
			Added pseudo instructions.
			Added tok_skip_ws.
		January 14, 1994.
			Added R_PC.
		December 21, 1993.
			Replaced global statistic logic with TOKIZE_STATS logic.
		October 28, 1993
			Removed all compiler-only tokens:
				all assignment tokens,
				ARRAY_TOK, ARROW_TOK, CAST_TOK, CALL_TOK,
				PRE_INC_TOK, POST_INC_TOK, POST_INC_TOK, POST_INC_TOK,
				WIDE_STRING_TOK, WIDE_CHAR_TOK.
*/

&lt;&lt; AStokens #includes &gt;&gt;
&lt;&lt; AStokens declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.282">#include "AS.h"

#include "ASarg.h"
#include "ASasm.h"
#include "AScpp.h"
#include "ASmem.h"
#include "AStokens.h"
#include "AStokize.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBlist.h&gt;
#include &lt;LIBobj.h&gt;
#include &lt;LIBos.h&gt;

#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.283">/*
	Globals owned by tokens.c.
*/
bool	tok_update_flag = TRUE;	/* TRUE: update line numbers in next_tok, etc. */
long	tok_cur_lab = 0;		/* The current label index. */
token *	tok_token_ptr = NULL;	/* Ptr to the current token. */
token *	tok_line_ptr = NULL;	/* Ptr to the newline before the current line. */

/*
	The following macros are used to define entries in tok_info[].

	In the present version many of these macros are redundant
	and this redundancy is descriptive and useful.
*/

	/* Non tokens: info not used. */

#define ea(a,b)		{0,b,a}		/* Address modes. */
#define o(a,b)		{0,b,a}		/* Output node types operatations. */
#define parser(a,b)	{0,a,b}		/* Parser token. */
#define range(a,b)	{0,a,b}		/* Marker for a range of tokens. */

	/* Big tokens. */

#define big_tok(a,b)		{BIG_TOKEN_SIZE, a, b}		/* General */
#define big_ws(a,b)			{BIG_TOKEN_SIZE, a, b}		/* White space. */
#define big_hidden_ws(a,b)	{BIG_TOKEN_SIZE, a, b}

#define hidden(a,b)			{BIG_TOKEN_SIZE, a, b}

#define kdecl(a,b)			{BIG_TOKEN_SIZE, a, b}		/* Keywords. */
#define kcontrol(a,b)		{BIG_TOKEN_SIZE, a, b}
#define key(a,b)			{BIG_TOKEN_SIZE, a, b}
#define madeup_key(a,b)		{BIG_TOKEN_SIZE, a, b}
#define ppkcontrol(a,b)		{BIG_TOKEN_SIZE, a, b}
#define pp_key(a,b)			{BIG_TOKEN_SIZE, a, b}
#define pp_keymac(a,b)		{BIG_TOKEN_SIZE, a, b}
#define reg(a,b)			{BIG_TOKEN_SIZE, b, a}		/* Registers. */
#define x(a,b)				{BIG_TOKEN_SIZE, b, a}		/* Machine instructions. */
#define z(a,b)				{BIG_TOKEN_SIZE, b, a}		/* Pseudo operations. */

	/* Small tokens. */

#define bad_tok(a,b)		{SMALL_TOKEN_SIZE, a, b}	/* A bad token. */
#define small_tok(a,b)		{SMALL_TOKEN_SIZE, a, b}	/* General */

#define small_ws(a,b)		{SMALL_TOKEN_SIZE, a, b}	/* White space. */
#define small_hidden_ws(a,b){SMALL_TOKEN_SIZE, a, b}

#define abelian(a,b)		{SMALL_TOKEN_SIZE, a, b}	/* Operators... */
#define assnop(a,b)			{SMALL_TOKEN_SIZE, a, b}
#define binop(a,b)			{SMALL_TOKEN_SIZE, a, b}
#define relop(a,b)			{SMALL_TOKEN_SIZE, a, b}
#define ternop(a,b)			{SMALL_TOKEN_SIZE, a, b}
#define unop(a,b)			{SMALL_TOKEN_SIZE, a, b}

/* Describe the attributes of each token. */

struct tok_info_struct tok_info [] = {

		/* Zero is never a valid type code. */

	bad_tok		(		"&lt;bad token&gt;",			BAD_TOK),

	/* ----- Non tokens ----- */

	range ("&lt;begin reg range&gt;", BEGIN_REG_RANGE),

	reg	(R_A0,	"a0"),	/* Address registers. */
	reg	(R_A1,	"a1"),
	reg	(R_A2,	"a2"),
	reg	(R_A3,	"a3"),
	reg	(R_A4,	"a4"),
	reg	(R_A5,	"a5"),
	reg	(R_A6,	"a6"),
	reg	(R_A7,	"a7"),

	reg (R_SP,	"sp"),	/* A synonym for a7. */

	reg	(R_D0,	"d0"),	/* Data registers. */
	reg	(R_D1,	"d1"),
	reg	(R_D2,	"d2"),
	reg	(R_D3,	"d3"),
	reg	(R_D4,	"d4"),
	reg	(R_D5,	"d5"),
	reg	(R_D6,	"d6"),
	reg	(R_D7,	"d7"),

	reg	(R_CCR,	"ccr"),	/*	General registers */
	reg	(R_PC,	"pc"),
	reg	(R_SR,	"sr"),

	range ("&lt;begin control reg range&gt;", BEGIN_CONTROL_REG_RANGE),

	reg (R_SFC,		"sfc"	),	/* Control registers: see MOVEC instruction. */
	reg (R_DFC,		"dfc"	),
	reg (R_CACR,	"cacr"	),
	reg (R_USP,		"usp"	),
	reg (R_VBR,		"vbr"	),
	reg (R_CAAR,	"caar"	),
	reg (R_MSP,		"msp"	),
	reg (R_ISP,		"isp"	),

	range ("&lt;end control reg range&gt;", END_CONTROL_REG_RANGE),

		/* Floating registers. */

	range ("&lt;end reg range&gt;", END_REG_RANGE),

	range ("&lt;begin o range&gt;", BEGIN_O_RANGE),

	o (O_SLIST,			"&lt;o_slist&gt;"			),
	o (O_SUMMARY,		"&lt;o_summary&gt;"		),
	o (O_ULABEL,		"&lt;o_ulabel&gt;"		),

	range ("&lt;end o range&gt;", END_O_RANGE),

	/*
		The IMMEDIATE_EA, DIRECT_EA and PC_INDEX_EA modes have 2 or
		more variations, depending on the length of a constant.
		The opcodes with explicit length information are never generated
		by the code generators, and are used only by the internal assembler.

		Besides indicating address modes, the address modes form the valid
		values of the n_type field of anodes.
		The indented address modes are invalid in the n_type field.

		Note the distinction between these address modes and the
		*patterns* of address modes used in the existence tables.

		Modes ending in EA20 are for the 68020 and above.
		Modes ending in EA30 are for the 68030 and above.
	*/

	range ("&lt;begin dummy ea range&gt;", BEGIN_DUMMY_EA_RANGE),

		ea (DREG_DREG_EA,		"&lt;Dn:Dn ea&gt;"		),
		ea (OFFSET_WIDTH_EA,	"&lt;offset:width ea&gt;"	),
		ea (REGLIST_EA,			"&lt;reg list ea&gt;"		),
		ea (SPECIAL_EA,			"&lt;special ea&gt;"		),

	range ("&lt;end dummy ea range&gt;", END_DUMMY_EA_RANGE),

	range ("&lt;begin ea range&gt;", BEGIN_EA_RANGE),

	range ("&lt;begin alt ea range&gt;", BEGIN_ALT_EA_RANGE),

		ea (DREG_EA,			"&lt;dreg ea&gt;"			),
		ea (AREG_EA,			"&lt;areg ea&gt;"			),
		
	range ("&lt;begin mem alt ea range&gt;", BEGIN_MEM_ALT_EA_RANGE),

		ea (INDIRECT_EA,		"&lt;indirect ea&gt;"		),
		ea (POST_INC_EA,		"&lt;post ea&gt;"			),
		ea (PRE_DEC_EA,			"&lt;pre ea&gt;"			),
		ea (DISPLACEMENT_EA,	"&lt;disp ea&gt;"			),

	range ("&lt;begin mode6 range&gt;", BEGIN_MODE6_RANGE),

	ea (INDEX_EA,				"&lt;index ea&gt;"		),

		ea (INDEX16_EA,			"&lt;index16 ea&gt;"		),
		ea (INDEX32_EA,			"&lt;index32 ea&gt;"		),

		ea (INDEX16_EA20,		"&lt;index16 ea20&gt;"	),
		ea (INDEX32_EA20,		"&lt;index32 ea20&gt;"	),

		ea (POST_INDEX_EA20,	"&lt;post ea20&gt;"		),
		ea (POST_INDEX16_EA20,	"&lt;post16 ea20&gt;"		),
		ea (POST_INDEX32_EA20,	"&lt;post32 ea20&gt;"		),

		ea (PRE_INDEX_EA20,		"&lt;pre ea20&gt;"		),
		ea (PRE_INDEX16_EA20,	"&lt;pre16 ea20&gt;"		),
		ea (PRE_INDEX32_EA20,	"&lt;pre32 ea20&gt;"		),

	range ("&lt;end mode6 range&gt;", END_MODE6_RANGE),

	range ("&lt;begin mode7 range&gt;", BEGIN_MODE7_RANGE),

	ea (ABSOLUTE_EA,			"&lt;abs ea&gt;"			),

		ea (ABS16_EA,			"&lt;abs16 ea&gt;"		),
		ea (ABS32_EA,			"&lt;abs32 ea&gt;"		),

	range ("&lt;end alt range&gt;", END_ALT_EA_RANGE),

	ea (PC_DISP_EA,				"&lt;pc disp ea&gt;"		),

	ea (PC_INDEX_EA,			"&lt;pc index ea&gt;"		),

	ea (PC_INDEX16_EA,			"&lt;pc index16 ea&gt;"	),
	ea (PC_INDEX32_EA,			"&lt;pc index32 ea&gt;"	),
	ea (PC_INDEX16_EA20,		"&lt;pc index16 ea20&gt;"	),
	ea (PC_INDEX32_EA20,		"&lt;pc index32 ea20&gt;"	),

	ea (PC_POST_INDEX_EA20,		"&lt;pc post ea20&gt;"	),
	ea (PC_POST_INDEX16_EA20,	"&lt;pc post16 ea20&gt;"	),
	ea (PC_POST_INDEX32_EA20,	"&lt;pc post32 ea20&gt;"	),

	ea (PC_PRE_INDEX_EA20,		"&lt;pc pre ea20&gt;"		),
	ea (PC_PRE_INDEX16_EA20,	"&lt;pc pre16 ea20&gt;"	),
	ea (PC_PRE_INDEX32_EA20,	"&lt;pc pre32 ea20&gt;"	),

	range ("&lt;begin mode7 range&gt;", BEGIN_MODE7_4_RANGE),

	ea (IMMEDIATE_EA,			"&lt;imm ea&gt;"			),

		ea (IMM8_EA,			"&lt;imm8 ea&gt;"			),
		ea (IMM16_EA,			"&lt;imm16 ea&gt;"		),
		ea (IMM32_EA,			"&lt;imm32 ea&gt;"		),
		ea (IND16_EA20,			"&lt;ind16 ea20&gt;"		),

	range ("&lt;end mode7:4 range&gt;", END_MODE7_4_RANGE),

	range ("&lt;end mode7 range&gt;", END_MODE7_RANGE),

	range ("&lt;end ea range&gt;", END_EA_RANGE),

	/* ------ Start of compiler tokens (continues to end) -----  */

	range ("&lt;begin token range&gt;", BEGIN_TOKEN_RANGE),

	small_tok	("&lt;bound tok&gt;",			BOUND_TOK),
	small_tok	(":",					COLON_TOK),
	small_tok	(",",					COMMA_TOK),
	big_tok		("&lt;comment tok&gt;",		COMMENT_TOK),
	small_tok	("&lt;cons&gt;",				CONS_TOK),
	small_tok	(".",					DOT_TOK),
	small_tok	("...",					DOTS3_TOK),
	small_tok	("&lt;end program tok&gt;",	END_PROG_TOK),
	big_tok		("&lt;error tok&gt;",			ERROR_CHAR_TOK),
	big_tok		("&lt;error message tok&gt;",	ERROR_MESSAGE_TOK),
	small_tok	("&lt;expression tok&gt;",	EXPRESSION_TOK),
	big_tok		("&lt;file name tok&gt;",		FILE_NAME_TOK),

	range ("&lt;begin key range&gt;", BEGIN_KEY_RANGE),

	range ("&lt;begin x range&gt;", BEGIN_X_RANGE),

	/* Classes of opcodes. */

	x (X_DBcc,		"&lt;X_DBcc&gt;"		),
	x (X_Scc,		"&lt;X_Scc&gt;"		),
	x (X30_TRAPcc,	"&lt;X30_TRAPcc&gt;"	),
	
	range ("&lt;begin x30 range&gt;", BEGIN_X30_RANGE), 	/* 68030 instructions. */

		x (X30_BFCHG,	"bfchg"	),
		x (X30_BFCLR,	"bfclr"	),
		x (X30_BFEXTS,	"bfexts"),
		x (X30_BFEXTU,	"bfextu"),
		x (X30_BFFF0,	"bfffo"	),
		x (X30_BFINS,	"bfins"	),
		x (X30_BFSET,	"bfset"	),
		x (X30_BFTST,	"bftst"	),
	
		x (X30_CAS,		"cas"	),
		x (X30_CAS2,	"cas2"	),
		x (X30_CHK2,	"chk2"	),
		x (X30_CMP2,	"cmp2"	),
	
		x (X30_DIVSL,	"divsl"	),
		x (X30_DIVUL,	"divul"	),
	
		x (X30_EXTB,	"extb"	),
	
		x (X30_MOVEC,	"movec"	),
		x (X30_MULSL,	"mulsl"	),
		x (X30_MULUL,	"mulul"	),
	
		x (X30_PACK,	"pack"	),
	
		x (X30_TRAPCC,	"trapcc"	),
		x (X30_TRAPCS,	"trapcs"	),
		x (X30_TRAPEQ,	"trapeq"	),
		x (X30_TRAPF,	"trapf"		),
		x (X30_TRAPGE,	"trapge"	),
		x (X30_TRAPGT,	"trapgt"	),
		x (X30_TRAPHI,	"traphi"	),
		x (X30_TRAPLE,	"traple"	),
		x (X30_TRAPLS,	"trapls"	),
		x (X30_TRAPLT,	"traplt"	),
		x (X30_TRAPMI,	"trapmi"	),
		x (X30_TRAPNE,	"trapne"	),
		x (X30_TRAPPL,	"trappl"	),
		x (X30_TRAPT,	"trapt"		),
		x (X30_TRAPVC,	"trapvc"	),
		x (X30_TRAPVS,	"trapvs"	),
	
		x (X30_UNPK,	"unpk"	),
	
	range ("&lt;end x30 range&gt;", END_X30_RANGE),

	/* Instructions found in the 68000. */

	x (X_ABCD,	"abcd"	),
	x (X_ADD,	"add"	),
	x (X_ADDA,	"adda"	),
	x (X_ADDI,	"addi"	),
	x (X_ADDQ,	"addq"	),
	x (X_ADDX,	"addx"	),
	x (X_AND,	"and"	),
	x (X_ANDI,	"andi"	),
	x (X_ASL,	"asl"	),
	x (X_ASR,	"asr"	),

	x (X_BCHG,	"bchg"	),
	x (X_BCLR,	"bclr"	),
	x (X_BKPT,	"bkpt"	),
	x (X_BRA,	"bra"	),
	x (X_BSET,	"bset"	),
	x (X_BSR,	"bsr"	),
	x (X_BTST,	"btst"	),

	x (X_BCC,	"bcc"	),
	x (X_BCS,	"bcs"	),
	x (X_BEQ,	"beq"	),
	x (X_BGE,	"bge"	),
	x (X_BGT,	"bgt"	),
	x (X_BHI,	"bhi"	),
	x (X_BLE,	"ble"	),
	x (X_BLS,	"bls"	),
	x (X_BLT,	"blt"	),
	x (X_BMI,	"bmi"	),
	x (X_BNE,	"bne"	),
	x (X_BPL,	"bpl"	),
	x (X_BVC,	"bvc"	),
	x (X_BVS,	"bvs"	),

	x (X_CHK,	"chk"	),
	x (X_CLR,	"clr"	),
	x (X_CMP,	"cmp"	),
	x (X_CMPA,	"cmpa"	),
	x (X_CMPI,	"cmpi"	),
	x (X_CMPM,	"cmpm"	),

	x (X_DBCC,	"dbcc"	),
	x (X_DBCS,	"dbcs"	),
	x (X_DBEQ,	"dbeq"	),
	x (X_DBF,	"dbf"	),
	x (X_DBGE,	"dbge"	),
	x (X_DBGT,	"dbgt"	),
	x (X_DBHI,	"dbhi"	),
	x (X_DBLE,	"dble"	),
	x (X_DBLS,	"dbls"	),
	x (X_DBLT,	"dblt"	),
	x (X_DBMI,	"dbmi"	),
	x (X_DBNE,	"dbne"	),
	x (X_DBPL,	"dbpl"	),
	x (X_DBT,	"dbt"	),
	x (X_DBVC,	"dbvc"	),
	x (X_DBVS,	"dbvs"	),

	x (X_DIVS,	"divs"	),
	x (X_DIVU,	"divu"	),

	x (X_EOR,	"eor"	),
	x (X_EORI,	"eori"	),
	x (X_EXG,	"exg"	),
	x (X_EXT,	"ext"	),
	
	x (X_ILLEGAL,	"illegal"	),

	x (X_JMP,	"jmp"	),
	x (X_JSR,	"jsr"	),

	x (X_LEA,	"lea"	),
	x (X_LINK,	"link"	),
	x (X_LSL,	"lsl"	),
	x (X_LSR,	"lsr"	),

	x (X_MOVE,	"move"	),
	x (X_MOVEA,	"movea"	),
	x (X_MOVEM,	"movem"	),
	x (X_MOVEP,	"movep"	),
	x (X_MOVEQ,	"moveq"	),
	x (X_MOVES,	"moves"	),
	x (X_MULS,	"muls"	),
	x (X_MULU,	"mulu"	),

	x (X_NBCD,	"nbcd"	),
	x (X_NEG,	"neg"	),
	x (X_NEGX,	"negx"	),
	x (X_NOP,	"nop"	),
	x (X_NOT,	"not"	),

	x (X_OR,	"or"	),
	x (X_ORI,	"ori"	),

	x (X_PEA,	"pea"	),

	x (X_RESET,	"reset"	),
	x (X_ROL,	"rol"	),
	x (X_ROR,	"ror"	),
	x (X_ROXL,	"roxl"	),
	x (X_ROXR,	"roxr"	),
	
	x (X_RTD,	"rtd"	),
	x (X_RTE,	"rte"	),
	x (X_RTR,	"rtr"	),
	x (X_RTS,	"rts"	),

	x (X_SBCD,	"sbcd"	),
	x (X_SCC,	"scc"	),
	x (X_SCS,	"scs"	),
	x (X_SEQ,	"seq"	),
	x (X_SF,	"sf"	),
	x (X_SGE,	"sge"	),
	x (X_SGT,	"sgt"	),
	x (X_SHI,	"shi"	),
	x (X_SLE,	"sle"	),
	x (X_SLS,	"sls"	),
	x (X_SLT,	"slt"	),
	x (X_SMI,	"smi"	),
	x (X_SNE,	"sne"	),
	x (X_SPL,	"spl"	),
	x (X_ST,	"st"	),
	x (X_SVC,	"svc"	),
	x (X_SVS,	"svs"	),

	x (X_STOP,	"stop"	),
	x (X_SUB,	"sub"	),
	x (X_SUBA,	"suba"	),
	x (X_SUBI,	"subi"	),
	x (X_SUBQ,	"subq"	),
	x (X_SUBX,	"subx"	),
	x (X_SWAP,	"swap"	),

	x (X_TAS,	"tas"	),
	x (X_TRAP,	"trap"	),
	x (X_TRAPV,	"trapv"	),
	x (X_TST,	"tst"	),

	x (X_UNLK,	"unlk"	),

	range ("&lt;end x range&gt;", END_X_RANGE),

	range ("&lt;begin z range&gt;", BEGIN_PSEUDO_RANGE),

	z (Z_ALIGN,		"align"	),	/* Align. */
	z (Z_CASE,		"case"	),	/* Ignored: specify case sensitivity. */
	z (Z_CODE,		"code"	),	/* Start of code segment. */
	z (Z_DATA,		"data"	),	/* Start data segment. */
	z (Z_DCB,		"dcb"	),	/* Data block. */
	z (Z_DC,		"dc"	),	/* DC pseudo instruction. */
	z (Z_END,		"end"	),	/* End assembly file. */
	z (Z_ENDPROC,	"endproc"),	/* End procedure. */
	z (Z_ENDR,		"endr"	),	/* Ignored: end record specification. */
	z (Z_ENTRY,		"entry"	),	/* Define entry point. */
	z (Z_EXPORT,	"export"),	/* Make a symbol globally visible. */
	z (Z_IMPORT,	"import"),	/* Refer to a globally visible symbol. */
	z (Z_OPT,		"opt"	),	/* Ignored: specify optimizations. */
	z (Z_OPWORD,	"opword"),	/* Specify a 2-byte operation code. */
	z (Z_PROC,		"proc"	),	/* Start of procedure. */
	z (Z_RECORD,	"record"),	/* Ignored: start record specification. */
	z (Z_SEG,		"seg"	),	/* Ignored: set segment. */
	z (Z_STRING,	"string"),	/* Ignored: specify how strings are to be handled. */
	z (Z_WITH,		"with"	),	/* Ignored: specify a record. */

	range ("&lt;end z range&gt;", END_PSEUDO_RANGE),

	range ("&lt;begin pp key range&gt;", BEGIN_PP_KEY_RANGE),

	range ("&lt;begin pp_only range&gt;", BEGIN_PP_KEY_ONLY_RANGE),

	pp_key	("define",	K_DEFINE),		/* Warning: tokize uses  */
	pp_key	("elif",	K_ELIF),		/* Spelling of keywords. */
	pp_key	("endif",	K_ENDIF),
	pp_key	("error",	K_ERROR),
	pp_key	("ifdef",	K_IFDEF),
	pp_key	("ifndef",	K_IFNDEF),
	pp_key	("include",	K_INCLUDE),
	pp_key	("line",	K_LINE),
	pp_key	("pragma",	K_PRAGMA),
	pp_key	("undef",	K_UNDEF),

	range ("&lt;begin no def range&gt;", BEGIN_NO_DEF_RANGE),

	pp_keymac	("__DATE__",	KM_DATE),	/* Preprocessor protected macros. */
	pp_keymac	("defined",		KM_DEFINED),
	pp_keymac	("__FILE__",	KM_FILE),
	pp_keymac	("__LINE__",	KM_LINE),
	pp_keymac	("__STDC__",	KM_STDC),
	pp_keymac	("__TIME__",	KM_TIME),

	range ("&lt;end no def range&gt;", END_NO_DEF_RANGE),

	range ("&lt;end pp key only range&gt;", END_PP_KEY_ONLY_RANGE),

	ppkcontrol	("else",	K_ELSE),
	ppkcontrol	("if",		K_IF),

	range ("&lt;end pp key range&gt;", END_PP_KEY_RANGE),

	range ("&lt;end key range&gt;", END_KEY_RANGE),

	small_tok	("{",	LCURLY_TOK),

	big_tok	("arg",		MACRO_ARG_TOK),

/*
	Operands are grouped to make switches faster.
	Operands should be defined adjacent to operators.
*/
	big_tok	("&lt;char tok&gt;",			CHAR_TOK),
	big_tok	("&lt;float tok&gt;",			FLOAT_TOK),
	big_tok	("&lt;id tok&gt;",			ID_TOK),
	big_tok	("&lt;disabled id tok&gt;", 	IDX_TOK),
	big_tok	("&lt;int tok&gt;",			INT_TOK),
	big_tok	("&lt;string tok&gt;",		STRING_TOK),

/*
	Operators are grouped so that their precedence can be found from a table.

	Warning: change expr_prec if this subrange changes.
*/

	range ("&lt;begin unop range&gt;", BEGIN_UNOP_RANGE),

		unop	("!",	NOT_TOK),
		unop	("~",	TILDE_TOK),
		unop	("-",	UMINUS_TOK),
		unop	("+",	UPLUS_TOK),

	range ("&lt;end unop range&gt;", END_UNOP_RANGE),

	range ("&lt;begin binop range&gt;", BEGIN_BINOP_RANGE),

		abelian		("&amp;",	AND_TOK),
		binop		("/",	DIV_TOK),
		binop		("-",	MINUS_TOK),
		binop		("%",	MOD_TOK),
		abelian		("|",	OR_TOK),
		abelian		("+",	PLUS_TOK),
		abelian		("*",	STAR_TOK),
		abelian		("^",	XOR_TOK),

	range ("&lt;end binop range&gt;",	END_BINOP_RANGE),

	small_tok	("=",	ASSN_TOK),		/* Preprocessor only operators... */
	small_tok	("==",	EQUAL_TOK),
	small_tok	("&gt;=",	GE_TOK),
	small_tok	("&gt;",	GT_TOK),
	small_tok	("&amp;&amp;",	LAND_TOK),
	small_tok	("&lt;=",	LE_TOK),
	small_tok	("||",	LOR_TOK),
	small_tok	("&lt;&lt;",	LSHIFT_TOK),
	small_tok	("&lt;",	LT_TOK),
	small_tok	("!=",	NE_TOK),
	small_tok	("&gt;&gt;",	RSHIFT_TOK),

	small_tok	("[",	LBRACK_TOK),
	small_tok	("(",	LPAREN_TOK),

	big_tok	("&lt;partial char tok&gt;",		PARTIAL_CHAR_TOK),
	big_tok	("&lt;partial fname tok&gt;",		PARTIAL_FILE_NAME_TOK),
	big_tok	("&lt;partial string tok&gt;",	PARTIAL_STRING_TOK),

	big_tok	("#",	POUND_TOK),
	big_tok	("##",	POUND_POUND_TOK),
	
	small_tok	("?",	QUESTION_TOK),

	small_tok	("]",	RBRACK_TOK),
	small_tok	("}",	RCURLY_TOK),
	small_tok	(")",	RPAREN_TOK),

	small_tok	("&lt;user label&gt;",	ULABEL_TOK),

	/*
		White space tokens are grouped for easy recognition.
	*/
	range ("&lt;begin ws range&gt;", BEGIN_WS_RANGE),

	small_ws	("&lt;form feed tok&gt;",		WS_FF_TOK),
	big_ws		("\n",					WS_NL_TOK),
	small_ws	("&lt;vertical tab tok&gt;",	WS_VTAB_TOK),
	small_ws	(" ",					WS_TOK),
	big_ws		("&lt;blanks tok&gt;",		WS_BLANKS_TOK),

	range ("&lt;end ws range&gt;", END_WS_RANGE),

	/*
		Hidden tokens are grouped so they can be recognized quickly.
		This makes the next_tok macro much faster.
	*/
	range ("&lt;begin hidden range&gt;", BEGIN_HIDDEN_RANGE),

	hidden			("&lt;begin file tok&gt;",		HIDDEN_BEGIN_FILE_TOK),
	big_hidden_ws	("&lt;big ignore tok&gt;",		HIDDEN_BIG_IGNORE_TOK),
	hidden			("&lt;big skip tok&gt;",			HIDDEN_BIG_SKIP_TOK),
	hidden			("&lt;end block tok&gt;",			HIDDEN_END_BLOCK_TOK),
	hidden			("&lt;end file tok&gt;",			HIDDEN_END_FILE_TOK),
	hidden			("&lt;file info tok&gt;",			HIDDEN_FILE_INFO_TOK),
	hidden			("&lt;line adjust tok&gt;",		HIDDEN_LINE_ADJUST_TOK),
	small_hidden_ws	("\n",						HIDDEN_NL_IN_COMMENT_TOK),
	small_hidden_ws	("\n",						HIDDEN_NL_IN_MACRO_TOK),
	small_hidden_ws	("&lt;small ignore tok&gt;",		HIDDEN_SMALL_IGNORE_TOK),
	hidden			("&lt;skip tok&gt;",				HIDDEN_SKIP_TOK),
	hidden			("&lt;skip directive tok&gt;",	HIDDEN_SKIP_DIRECTIVE_TOK),
	hidden			("&lt;skip to macro tok&gt;",		HIDDEN_SKIP_TO_MACRO_TOK),

	range ("&lt;end hidden range&gt;", END_HIDDEN_RANGE),

	/*
		WARNING: The is_hidden macro assumes that no tokens
				 tokens lie beyond the hidden tokens!
	*/

	bad_tok		("&lt;bad last tok&gt;", BAD_LAST_TOK)

};	</t>
<t tx="ekr.20080529093004.284">@ en_tokens
Print a token, given a *pointer* to it.
@c

void
etok(token * tp)
{
	tok_dump1(tp, DONT_PRINT_HIDDEN_TOKS);
}
</t>
<t tx="ekr.20080529093004.285">@ Print a token, given a token number.
@c

void
etoknum(token tok)
{
	if (tok &lt; 0 || tok &gt; BAD_LAST_TOK) {
		es("&lt;out of range: "); eint(tok); es("&gt;");
	}
	else {
		es(tok_name(tok));
	}
}
</t>
<t tx="ekr.20080529093004.286">@ Check the consistency of tok_info [].  This routine makes adding items to tok_info foolproof *provided* it is called before any tokens are needed!  It should be called as soon as possible in init_all.
@c

void
tok_check(void)
{
	FTAG("tok_check");
	int i = 0;
	STATB(ftag);

	for (i = 0; i &lt; BAD_LAST_TOK; i++) {

		ASSERT_TRACE(i == tok_tok(i),
			es("tok_check: value mismatch.  i: "); eint(i);
			es(" name: "); es(tok_name(i)));
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.287">@ Print the entire token list.
@c

token *
tok_dump(register token * tp, bool print_hidden_flag)
{
	bool save_update = tok_update_flag;
	tok_update_flag = FALSE;

	ecnl();
	while (tp != NULL) {
		tok_dump1(tp, print_hidden_flag);
		tp = tok_next_raw(tp);
		if (*tp == END_PROG_TOK) {
			break;
		}
	}
	if (print_hidden_flag) {
		ecnl();
	}

	tok_update_flag = save_update;
	return tp;
}
</t>
<t tx="ekr.20080529093004.288">@ Print tokens up to and including an delimiter token.
@c

token *
tok_dump_delim(token * tp, token delim)
{
	bool save_update = tok_update_flag;
	tok_update_flag = FALSE;

	tp = tok_dump_delim2(tp, delim, PRINT_HIDDEN_TOKS);

	tok_update_flag = save_update;
	return tp;
}
</t>
<t tx="ekr.20080529093004.289">token *
tok_dump_delim2(token * tp, token delim, bool print_hidden_flag)
{
	bool save_update = tok_update_flag;
	tok_update_flag = FALSE;

	while(tp != NULL) {
		tok_dump1(tp, PRINT_HIDDEN_TOKS);
		if (*tp == delim) {
			break;
		}
		next_raw_tok(tp);
		if (*tp == END_PROG_TOK) {
			break;
		}
	}
	if (print_hidden_flag) {
		ecnl();
	}

	tok_update_flag = save_update;
	return tp;
}
</t>
<t tx="ekr.20080529093004.290">@ Print one line of the token list. Return a pointer to the start of the next line.
@c

token *
tok_dump_line(token * tp)
{
	bool save_update = tok_update_flag;
	tok_update_flag = FALSE;

	tp = tok_dump_line2(tp,
		PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_NON_USER_TOKENS);

	tok_update_flag = save_update;
	return tp;
}
</t>
<t tx="ekr.20080529093004.291">token *
tok_dump_line2(
	register token * tp,
	bool print_hidden_flag,
	bool split_flag,
	bool user_flag)
{
	register int count = 0;
	bool save_update = tok_update_flag;

	tok_update_flag = FALSE;

	while (	tp != NULL &amp;&amp;
			*tp != WS_NL_TOK &amp;&amp;
			*tp != HIDDEN_NL_IN_COMMENT_TOK) {
		count++;
		if (split_flag &amp;&amp; count == 15) {
			count = 0;
			enl(); es("...");
		}
		tok_dump1(tp, print_hidden_flag);
		if (user_flag &amp;&amp; *tp == HIDDEN_SKIP_TO_MACRO_TOK) {

			/* Print name of the the unexpanded macro. */
			token * name_tp = (token *) ptr_tok_ptr(tp);
			spell_node * spell_p = (spell_node *) ptr_tok_ptr(name_tp);

			es(spell_p -&gt; spell_name);

			/* Move on to the unexpanded replacement text. */
			bump_tp_macro(tp, tok_size(*tp));
		}
		else if (
			user_flag &amp;&amp;
				/* 12/28/92 added HIDDEN_BIG_SKIP_TOK case */
				(*tp == HIDDEN_SKIP_DIRECTIVE_TOK || *tp == HIDDEN_BIG_SKIP_TOK)
		) {

			/* Print the patched '#' and go on. */
			es("#");
			bump_tp_macro(tp, tok_size(*tp));
		}
		else {
			tp = tok_next_raw(tp);
		}
		if (*tp == HIDDEN_END_FILE_TOK || *tp == END_PROG_TOK) {
			break;
		}
	}
	if (print_hidden_flag) {
		ecnl();
	}

	tok_update_flag = save_update;
	return tp;
}
</t>
<t tx="ekr.20080529093004.292">@ Dump a list of tokens.
@c

token *
tok_dump_list(token * first_p, token * end_p)
{
	token * tp;
	bool save_update = tok_update_flag;
	tok_update_flag = FALSE;

	tp = tok_dump_list2(first_p, end_p, PRINT_HIDDEN_TOKS);

	tok_update_flag = save_update;
	return tp;
}
</t>
<t tx="ekr.20080529093004.293">static token * last_tp;

token *
tok_dump_list2(token * first_p, token * end_p, bool print_hidden_flag)
{
	register token * tp = first_p;
	bool save_update = tok_update_flag;

	tok_update_flag = FALSE;
	while (tp != NULL) {
		tok_dump1(tp, print_hidden_flag);
		if (tp == end_p) {
			break;
		}
		else {
			tp = tok_next_raw(tp);
		}
		if (*tp == END_PROG_TOK) {
			break;
		}
	}
	if (print_hidden_flag) {
		ecnl();
	}

	tok_update_flag = save_update;
	return tp;
}
</t>
<t tx="ekr.20080529093004.294">@ Print one token.
@c

void
tok_dump1(register token * tp, bool print_hidden_flag)
{
	FTAG("tok_dump1");
	register char * ptr = NULL;
	register token kind = 0;

	ASSERT_TRACE(*tp &lt; BAD_LAST_TOK &amp;&amp; *tp &gt; 0, es("tp: "); eptr(tp));

	ptr = ptr_tok_ptr(tp);
	kind = *tp;

	switch(kind) {

	case BOUND_TOK:
		if (print_hidden_flag) {
			/* An honorary hidden token. */
			es("&lt;bound&gt;");
		}
		break;

	case CHAR_TOK:
		echar('\''); es(ptr); echar('\'');
		break;

	case COMMENT_TOK:
		es(ptr);
		break;

	case DOTS3_TOK:
		es( print_hidden_flag ? "&lt;...&gt;" : "...");
		break;

	case END_PROG_TOK:
		if (print_hidden_flag) {
			es("&lt;end program&gt;\n");
		}
		break;

	case ERROR_CHAR_TOK:
		echar((long) ptr);
		break;

	case ERROR_MESSAGE_TOK:
		if (print_hidden_flag) {
			char * message = ptr_tok_ptr(tp);
			es("&lt;error message: "); es(message); es("&gt;");
		}
		break;

	case FILE_NAME_TOK:
		echar('&lt;'); es(ptr); echar('&gt;');
		break;

	case FLOAT_TOK:
		es(ptr);
		break;

	case HIDDEN_BEGIN_FILE_TOK:
		if (print_hidden_flag) {
			es("&lt;begin file tok: "); es(ptr); es("&gt;");
			/* The file starts with a dummy newline, so don't add one here. */
		}
		break;

	case HIDDEN_BIG_IGNORE_TOK:
		if (print_hidden_flag) {
			es("&lt;ignore5&gt;");
		}
		break;

	case HIDDEN_BIG_SKIP_TOK:
		if (print_hidden_flag) {
			es("&lt;big skip: ");
			elong(((skip_node *) ptr) -&gt; skip_lines);
			es(" lines&gt;");
		}
		break;

	case HIDDEN_END_BLOCK_TOK:
		if (print_hidden_flag) {
			es(tok_name(*tp));
		}
		break;

	case HIDDEN_END_FILE_TOK:
		{
			file_info_node *fip = (file_info_node *) ptr;

			if (print_hidden_flag) {
				es("&lt;end file tok: resuming: "); es(fip -&gt; finfo_fname);
				es(" line: "); elong(fip -&gt; finfo_line); es("&gt;");
			}
			break;
		}

	case HIDDEN_FILE_INFO_TOK:
		{
			file_info_node * fip = (file_info_node *) ptr;

			if(arg_line_flag) {
				ecnl(); es("#line "); elong(fip -&gt; finfo_line);
				eblank(); es(fip -&gt; finfo_fname); enl();
			}
			else if (print_hidden_flag) {
				ecnl();
				es("&lt;file info tok: line: "); elong(fip -&gt; finfo_line);
				eblank(); es(fip -&gt; finfo_fname); enl();
			}
			break;
		}

	case HIDDEN_LINE_ADJUST_TOK:
		/* A #line directive is never appropriate here. */
		if(print_hidden_flag) {
			es("&lt;line adjust: "); elong((long) ptr); es("&gt;");
		}
		break;

	case HIDDEN_NL_IN_COMMENT_TOK:
		if (print_hidden_flag) {
			es("&lt;hidden nl in comment&gt;\n");
		}
		else {
			enl();
		}
		break;

	case HIDDEN_NL_IN_MACRO_TOK:
		if (print_hidden_flag) {
			es("&lt;hidden nl in macro&gt;\n");
		}
		else {
			enl();
		}
		break;

	case HIDDEN_SKIP_TOK:
		if (print_hidden_flag) {
			es("&lt;skip&gt;");
		}
		break;

	case HIDDEN_SKIP_DIRECTIVE_TOK:
		if (print_hidden_flag) {
			es("&lt;skip directive&gt;");
		}
		break;

	case HIDDEN_SKIP_TO_MACRO_TOK:
		if (print_hidden_flag) {

			token * name_tp = (token *) ptr_tok_ptr(tp);
			spell_node * spell_p = (spell_node *) ptr_tok_ptr(name_tp);

			es("&lt;skip to macro ");
			es(spell_p -&gt; spell_name);
			es("&gt;");
		}
		break;

	case HIDDEN_SMALL_IGNORE_TOK:
		if (print_hidden_flag) {
			es("&lt;ignore1&gt;");
		}
		break;

	case ID_TOK:
		es( ((spell_node *) ptr) -&gt; spell_name);
		break;

	case IDX_TOK:
		if (print_hidden_flag) {
			es("&lt;idx:");
			es( ((spell_node *) ptr) -&gt; spell_name);
			es("&gt;");
		}
		else {
			es( ((spell_node *) ptr) -&gt; spell_name);
		}
		break;

	case INT_TOK:
		es(ptr);
		break;

	case MACRO_ARG_TOK:
		es("&lt;macro arg "); elong((long) ptr); es("&gt;");
		break;

	case PARTIAL_CHAR_TOK:
		es("'");
		es(ptr);
		break;

	case PARTIAL_FILE_NAME_TOK:
		es("&lt;");
		es(ptr);
		break;

	case PARTIAL_STRING_TOK:
		echar('"');
		es(ptr);
		break;

	case STRING_TOK:

		echar('"');
		/* Split long lines so Sherlock doesn't truncate them. */
		{
			int count = 0;
			while(*ptr) {
				if(count++ == 80) {
					es("&lt;added nl&gt;\n");
					count = 0;
				}
				echar(*ptr);
				ptr++;
			}
		}
		echar('"');
		break;

	case WS_BLANKS_TOK:
		eblanks((long) ptr);
		break;

	default:
		if (is_id(*tp)) {
			es( ((spell_node *) ptr) -&gt; spell_name);
		}
		else {
			es(tok_name(kind));
		}
		break;
	}
}
</t>
<t tx="ekr.20080529093004.295">@ Copy a single token to the current token buffer.  the_tok is used only if the_token is a big token.
@c

token *
tok_copy(token the_token, void * the_ptr)
{
	FTAG("tok_copy");
	register token * dp = NULL;	/* Destination ptr. */
	register long davail = 0;	/* Destination avail. */
	token * first_dp = NULL;
	STATB(ftag);

	/* Restore the token paremeters saved by tokize(). */
	davail = token_life -&gt; mem_avail;
	dp = token_life -&gt; mem_ptr;

	/* Careful: we must call tok_protect_macro before setting first_dp. */
	tok_protect_macro(dp, davail);
	first_dp = dp;

	/* Copy the token. */
	if (tok_size(the_token) == BIG_TOKEN_SIZE) {
		*dp = the_token;
		patch_ptr_tok(dp, the_ptr);
		bump_tp_macro(dp, BIG_TOKEN_SIZE);
		davail -= BIG_TOKEN_SIZE;
	}
	else {
		ASSERT(the_ptr == NULL);
		*dp = the_token;
		dp++;
		davail -= SMALL_TOKEN_SIZE;
	}

	/* Save the token paremeters for tokize(). */
	token_life -&gt; mem_avail = davail;
	token_life -&gt; mem_ptr = dp;

	TRACEPX(ftag,
		tok_dump1(first_dp, PRINT_HIDDEN_TOKS);
		ecnl());

	return first_dp;
}
</t>
<t tx="ekr.20080529093004.296">@ Copy a token list (from start_p to end_p) to the current token buffer. Do not copy invisible tokens or BOUND_TOK. Change newline tokens to a single blank.  Set last_p in the caller to the first and last *visible* token copied.  It may be that nothing is copied. In that case, return a pointer to where the next token will be copied.
@c

token *
tok_copy_list(token * start_p, token * end_p, token ** last_copy, char * tag)
{
	FTAG("tok_copy_list");
	FTAGV("-tok_copy_list_v");
	register token * sp = start_p;		/* Source pointer. */
	register token * dp = NULL;			/* Destination pointer. */
	register token * last_dp = NULL;	/* Ptr to last copied token. */
	register long davail = 0;			/* Destination avail ptr. */
	register bool continue_flag = 0;
	token *	first_dp = NULL;
	bool save_update = tok_update_flag;
	STATB(ftag);
	ASSERT(start_p);
	
	/* Do not update line numbers, etc. while scanning. */
	tok_update_flag = FALSE;

	/* Restore the token paremeters saved by tokize(). */
	davail = token_life -&gt; mem_avail;
	dp = token_life -&gt; mem_ptr;

	/* Careful: we must call tok_protect_macro before setting first_dp. */
	tok_protect_macro(dp, davail);
	last_dp = dp;
	first_dp = dp;

	/*
		Copy the token list, but not hidden tokens and not bound toks.
		Be careful: it is valid for a hidden token to end the list.
	*/
	ASSERT(sp);
	do {

		continue_flag = (sp != end_p);

		ASSERT(*sp != HIDDEN_END_FILE_TOK &amp;&amp; *sp != END_PROG_TOK);

		/* Careful: we must call tok_protect_macro before setting last_dp. */
		tok_protect_macro(dp, davail);

		/* 7/5/93: Make code independent of sizeof(token). */
		if (*sp == WS_NL_TOK) {
		
			#if 0 /* 2/11/94: old code for small newline tokens. */
				ASSERT(tok_size(WS_NL_TOK) == SMALL_TOKEN_SIZE);
				*dp++ = WS_TOK;
				davail -= SMALL_TOKEN_SIZE;
			#endif
			
			ASSERT(tok_size(WS_NL_TOK) == BIG_TOKEN_SIZE);
			last_dp = dp;
			*dp = WS_TOK;
			bump_tp_macro(dp, BIG_TOKEN_SIZE);
			davail -= SMALL_TOKEN_SIZE;
		}
		else if (is_hidden(*sp)) {

			/* 9/16/92: do not call tok_next_raw if we are at the end. */
			if (sp == end_p) {
				break;
			}
		}
		else if (*sp != BOUND_TOK) {
			last_dp = dp;
			*dp = *sp;
			if (tok_size(*sp) == BIG_TOKEN_SIZE) {
				patch_ptr_tok(dp, (ptr_tok_ptr(sp)));
				bump_tp_macro(dp, BIG_TOKEN_SIZE);
				davail -= BIG_TOKEN_SIZE;
			}
			else {
				dp++;
				davail -= SMALL_TOKEN_SIZE;
			}
		}
		sp = tok_next_raw(sp);
	}
	while (continue_flag);

	/* Save the token paremeters for tokize(). */
	token_life -&gt; mem_avail = davail;
	token_life -&gt; mem_ptr = dp;

	TRACEPX(ftag, es(tag); eblank();
		if (first_dp != last_dp) {
			tok_dump_list(first_dp, last_dp);
		}
		ecnl();
	);
	
	tok_update_flag = save_update;
	*last_copy = last_tp;
	return first_dp;
}
</t>
<t tx="ekr.20080529093004.297">@ Copy a token up to but not including a newline to the current token buffer.  It may be that nothing is copied. In that case, return a pointer to where the next token will be copied.  Do not copy invisible tokens, BOUND_TOK.  Bug fix: 5/26/94. Comment tokens (representing ';' or '*') also stop the scan. This allows comments to appear in #define directives without being included in the replacement text.
@c

token *
tok_copy2nl(token * start_p, token ** last_copy, char * tag)
{
	FTAG("tok_copy2nl");
	register token * sp = start_p;		/* Source pointer. */
	register token * dp = NULL;			/* Destination pointer. */
	register token * last_dp = NULL;	/* Ptr to last copied token. */
	register long davail = 0;			/* Destination avail ptr.	*/
	token *	first_dp = NULL;
	bool save_update = tok_update_flag;
	STATB(ftag);
	ASSERT(token_life);

	/* Do not update line numbers, etc. while scanning. */
	tok_update_flag = FALSE;

	/* Restore the token paremeters saved by tokize(). */
	davail = token_life -&gt; mem_avail;
	dp = token_life -&gt; mem_ptr;

	/* Careful: we must call tok_protect_macro before setting first_dp. */
	tok_protect_macro(dp, davail);
	first_dp = dp;
	last_dp = dp;

	/* WARNING: This test is *different* from the test in the compiler! */
	while (*sp != WS_NL_TOK &amp;&amp; *sp != COMMENT_TOK) {

		ASSERT(*sp != HIDDEN_END_FILE_TOK &amp;&amp; *sp != END_PROG_TOK);

		/* Careful: we must call tok_protect_macro before setting last_tp. */
		tok_protect_macro(dp, davail);
		last_dp = dp;

		/* Copy the token. */
		if (!is_hidden(*sp) &amp;&amp; *sp != BOUND_TOK) {
			*dp = *sp;
			if (tok_size(*sp) == BIG_TOKEN_SIZE) {
				patch_ptr_tok(dp, (ptr_tok_ptr(sp)));
				bump_tp_macro(dp, BIG_TOKEN_SIZE);
				davail -= BIG_TOKEN_SIZE;
			}
			else {
				dp++;
				davail -= SMALL_TOKEN_SIZE;
			}
		}
		next_tok(sp);
	}

	/* Save the token paremeters for tokize(). */
	token_life -&gt; mem_avail = davail;
	token_life -&gt; mem_ptr = dp;
	
	ASSERT(first_dp &amp;&amp; last_dp &amp;&amp; !is_hidden(*first_dp) &amp;&amp; !is_hidden(*last_dp));

	TRACEPX(ftag, es(tag); eblank();
		if (first_dp != last_dp) {
			tok_dump_list(first_dp, last_dp);
		}
		ecnl();
	);

	tok_update_flag = save_update;
	*last_copy = last_tp;
	return first_dp;
}
</t>
<t tx="ekr.20080529093004.298">@ Replace the token at tp with a hidden ignore token.
@c

void
tok_ignore(token * tp)
{
	FTAG("tok_ignore");
	STATB(ftag);

	if (tok_size(*tp) == SMALL_TOKEN_SIZE) {
		*tp = HIDDEN_SMALL_IGNORE_TOK;
	}
	else {
		*tp = HIDDEN_BIG_IGNORE_TOK;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.299">@ Return a pointer to the next visible token.  It turns out that the speed of the next_tok macro is important. Substituting this routine for the next_tok macro (defined in AStokens.h) significantly degrades the speed of the assembler.
@c

#if 0 /* Old, slow and unused. */
token *
tok_next_(register token * tp)
{
	register token tok = *tp;

	SL_DISABLE();

	if (!is_hidden(tok)) {
		bump_tp_macro(tp, tok_size(tok));
	}
	return tok_skip_hidden(tp);
}
</t>
<t tx="ekr.20080529093004.300">#endif

/*
	Return a pointer to the next token, whatever the kind.

	Warning: You can *never* predict what the next raw token is going to be
			 because of the possibility of intervening HIDDEN_END_BLOCK_TOK's.
*/
token *
tok_next_raw(register token * tp)
{
	FTAG("tok_next_raw");

	#if 0 /* This slows down the code too much. */
		STATB(ftag);
	#endif

	ASSERT_TRACE(tp &amp;&amp; *tp &lt; BAD_LAST_TOK &amp;&amp; *tp &gt; 0,
		es(ftag); es(": ");
		es("tp: "); eptr(tp);
		es(", *tp: "); eulong(*tp);
	);

	switch(*tp) {

	case END_PROG_TOK:
		goto return_tp;

	/*
		These are placed here so we can assert !is_hidden(*tp) in the default.
	*/
	case HIDDEN_BIG_IGNORE_TOK:
	case HIDDEN_SMALL_IGNORE_TOK:
		goto return_next_tp;

	case HIDDEN_BEGIN_FILE_TOK:
	{
		char * name = (char *) ptr_tok_ptr(tp);

		if (tok_update_flag) {
			err_fname = name;
			err_line = 0;
			err_line_offset = 0;
		}
		goto return_next_tp;
	}

	case HIDDEN_BIG_SKIP_TOK:
		{
			skip_node * skip_p = (skip_node *) ptr_tok_ptr(tp);

			if (tok_update_flag) {
				err_line += skip_p -&gt; skip_lines;
			}
			tp = skip_p -&gt; skip_tp;
			goto return_tp;
		}

	case HIDDEN_END_BLOCK_TOK:
		tp = (token *) ptr_tok_ptr(tp);
		goto return_tp;

	case HIDDEN_END_FILE_TOK:
		{
			file_info_node * fip = (file_info_node *) ptr_tok_ptr(tp);

			if (tok_update_flag) {
				if (fip -&gt; finfo_fname != NULL) {
					err_fname = fip -&gt; finfo_fname;
				}
				err_line  		= fip -&gt; finfo_line;
				err_line_offset = fip -&gt; finfo_line_offset;
			}
			tp = fip -&gt; finfo_tp;
			goto return_tp;
		}

	case HIDDEN_FILE_INFO_TOK:
		{
			file_info_node * fip = (file_info_node *) ptr_tok_ptr(tp);

			if (tok_update_flag) {
				if (fip -&gt; finfo_fname != NULL) {
					err_fname = fip -&gt; finfo_fname;
				}
				err_line_offset  = fip -&gt; finfo_line_offset;
			}
			tp = fip -&gt; finfo_tp;
			goto return_tp;
		}

	case HIDDEN_LINE_ADJUST_TOK:
		if (tok_update_flag) {
			err_line += val_tok_val(tp);
		}
		goto return_next_tp;

	case HIDDEN_NL_IN_COMMENT_TOK:
	case HIDDEN_NL_IN_MACRO_TOK:
		if (tok_update_flag) {
			err_line++;
		}
		goto return_next_tp;

	case HIDDEN_SKIP_TOK:
	case HIDDEN_SKIP_DIRECTIVE_TOK:

		tp = (token *) ptr_tok_ptr(tp);
		goto return_tp;

	case HIDDEN_SKIP_TO_MACRO_TOK:
	{
		token * name_tp = (token *) ptr_tok_ptr(tp);

		ASSERT(*name_tp == ID_TOK || *name_tp == IDX_TOK);
		tp = name_tp;
		bump_tp_macro(tp, BIG_TOKEN_SIZE);
		goto return_tp;
	}

	default:

		ASSERT_TRACE(!is_hidden(*tp),
			es(ftag); es(": &lt;"); es(tok_name(*tp));
			es("&gt; = "); eint(*tp); es(" is hidden");
		);
		goto return_next_tp;
	}

return_next_tp:
	bump_tp_macro(tp, tok_size(*tp));

	/* Fall through. */

return_tp:

	#if 0 /* This slows down the code too much. */
		STATX(ftag);
	#endif

	return tp;
}
</t>
<t tx="ekr.20080529093004.301">@ Output the next line to the output file.
@c

token *
tok_out_line(register token * tp)
{
	FTAG("tok_out_line");
	register int count = 0;
	STATB(ftag);
	
	while (
		tp &amp;&amp;
		*tp != WS_NL_TOK &amp;&amp; *tp != HIDDEN_NL_IN_COMMENT_TOK &amp;&amp;
		*tp != HIDDEN_END_FILE_TOK &amp;&amp; *tp != END_PROG_TOK
	) {
		
		if (*tp == HIDDEN_SKIP_TO_MACRO_TOK) {

			/* Print name of the the unexpanded macro. */
			token * name_tp = (token *) ptr_tok_ptr(tp);
			spell_node * spell_p = (spell_node *) ptr_tok_ptr(name_tp);
			os(spell_p -&gt; spell_name);

			/* Move on to the unexpanded replacement text. */
			bump_tp_macro(tp, tok_size(*tp));
		}
		else if (*tp == HIDDEN_SKIP_DIRECTIVE_TOK || *tp == HIDDEN_BIG_SKIP_TOK) {

			/* Print the patched '#' and go on. */
			os("#");
			bump_tp_macro(tp, tok_size(*tp));
		}
		else {
			tok_out(tp);
			tp = tok_next_raw(tp);
		}
	}

	STATX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.302">@ Output one token to the output file.
@c

void
tok_out(register token * tp)
{
	FTAG("tok_out");
	register char * ptr = ptr_tok_ptr(tp);
	register token kind = *tp;
	STATB(ftag);

	ASSERT_TRACE(tp &amp;&amp; *tp &lt; BAD_LAST_TOK &amp;&amp; *tp &gt; 0, es("tp: "); eptr(tp));

	switch(kind) {

	case BOUND_TOK:
		break;

	case CHAR_TOK:
		ochar('\''); os(ptr); ochar('\'');
		break;

	case COMMENT_TOK:
		os(ptr);
		break;

	case DOTS3_TOK:
		os("...");
		break;

	case END_PROG_TOK:
		break;

	case ERROR_CHAR_TOK:
		ochar((long) ptr);
		break;

	case ERROR_MESSAGE_TOK:
		break;

	case FILE_NAME_TOK:
		ochar('&lt;'); os(ptr); ochar('&gt;');
		break;

	case FLOAT_TOK:
		os(ptr);
		break;

	case ID_TOK:
		os( ((spell_node *) ptr) -&gt; spell_name);
		break;

	case IDX_TOK:
		os( ((spell_node *) ptr) -&gt; spell_name);
		break;

	case INT_TOK:
		os(ptr);
		break;

	case MACRO_ARG_TOK:
		os("&lt;macro arg "); oulong((ulong) ptr); os("&gt;");
		break;

	case PARTIAL_CHAR_TOK:
		os("'");
		os(ptr);
		break;

	case PARTIAL_FILE_NAME_TOK:
		os("&lt;");
		os(ptr);
		break;

	case PARTIAL_STRING_TOK:
		ochar('"');
		os(ptr);
		break;

	case STRING_TOK:
		ochar('"'); os(ptr); ochar('"');
		break;

	case WS_BLANKS_TOK:
		oblanks((long) ptr);
		break;

	default:
		if (!is_hidden(kind)) {
			if (is_id(kind)) {
				os( ((spell_node *) ptr) -&gt; spell_name);
			}
			else {
				os(tok_name(kind));
			}
		}
		break;
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.303">@ Point tok_token_ptr at the next parser token. This routine skips all white space tokens except WS_NL_TOK.  This routine should be as fast as possible because it is called very often.
@c

void
tok_par_next_skip_ws(void)
{
	FTAG("-tok_par_next_skip_ws");
	FTAGV("-tok_par_next_skip_ws_v");

	register token * tp = tok_token_ptr;

	/*
		This assertion is initially made true by par_program and
		clearly remains true on exit from this routine.
	*/

	STATB(ftag);
	ASSERT_TRACE(!is_hidden(*tp), es("token: "); eint(*tp); ecs(); es(tok_name(*tp)));

	/* Skip the current token. */

	#if 1 /* We know *tp is not hidden. */
		bump_tp_macro(tp, tok_size(*tp));
	#else
		if (!is_hidden(*tp)) {
			bump_tp_macro(tp, tok_size(*tp));
		}
	#endif

	/* Repeating this test allows the while test to be done at the end of the loop. */
	if (is_hidden(*tp)) {
		tp = tok_skip_hidden(tp);
	}

	/* Skip all white space except newlines */
	while(*tp != WS_NL_TOK &amp;&amp; is_ws(*tp)) {
	
		/* This is the same as the tok_skip_ws routine. */
		bump_tp_macro(tp, tok_size(*tp));
		if (is_hidden(*tp)) {
			tp = tok_skip_hidden(tp);
		}
	}

	/*
		Restore the meaning of disabled macros.
		The call to the new is_ppkey_only(*tp) macro
		is another crucial optimization.
	*/
	if (*tp == IDX_TOK) {
		*tp = id_tok_ptr(tp) -&gt; spell_token;
	}

	/*
		Translate reserved words after restoring the meaning of disabled macros.
		E.g., defining error as a macro requires these two translations.
	*/
	if (is_ppkey_only(*tp)) {

		#if 0 /* This is too slow to leave in. */
			TRACEPN(ftag, es("converting pp reserved word ");
			es(id_tok_ptr(tp) -&gt; spell_name); es(" to a plain id.\n"));
		#endif
		*tp = ID_TOK;
	}

done:
	tok_token_ptr = tp;
	TRACEPN(ftagv, es("line: "); epadlong(err_line, 3); es(", token: "); etok(tp); enl());
	STATX(ftag);

}
</t>
<t tx="ekr.20080529093004.304">@ Point tok_token_ptr at the next parser token. Unlike tok_par_next_skip_ws, this routine *will* return any white space character.  This routine should be as fast as possible because it is called very often.
@c

void
tok_par_next(void)
{
	FTAG("-tok_par_next");
	FTAGV("-tok_par_next_v");

	register token * tp = tok_token_ptr;

	/*
		This assertion is initially made true by par_program and
		clearly remains true on exit from this routine.
	*/

	STATB(ftag);
	ASSERT_TRACE(!is_hidden(*tp), es("token: "); eint(*tp); ecs(); es(tok_name(*tp)));

	/* Skip the current token. */

	#if 1 /* We know *tp is not hidden. */
		bump_tp_macro(tp, tok_size(*tp));
	#else
		if (!is_hidden(*tp)) {
			bump_tp_macro(tp, tok_size(*tp));
		}
	#endif

	/* Repeating this test allows the while test to be done at the end of the loop. */
	if (is_hidden(*tp)) {
		tp = tok_skip_hidden(tp);
	}

	/*
		Restore the meaning of disabled macros.
		The call to the new is_ppkey_only(*tp) macro
		is another crucial optimization.
	*/
	if (*tp == IDX_TOK) {
		*tp = id_tok_ptr(tp) -&gt; spell_token;
	}

	/*
		Translate reserved words after restoring the meaning of disabled macros.
		E.g., defining error as a macro requires these two translations.
	*/
	if (is_ppkey_only(*tp)) {

		#if 0 /* This is too slow to leave in. */
			TRACEPN(ftag, es("converting pp reserved word ");
			es(id_tok_ptr(tp) -&gt; spell_name); es(" to a plain id.\n"));
		#endif
		*tp = ID_TOK;
	}

done:
	tok_token_ptr = tp;
	TRACEPN(ftagv, es("line: "); epadlong(err_line, 3); es(", token: "); etok(tp); enl());
	STATX(ftag);

}
</t>
<t tx="ekr.20080529093004.305">@ Patch a large token.
@c

void
tok_patch(token * patch_tp, token the_token, void * the_ptr, char * tag)
{
	FTAG("tok_patch");
	STATB(ftag);

	ASSERT(tok_size(*patch_tp) == BIG_TOKEN_SIZE);

	*patch_tp = the_token;
	patch_ptr_tok(patch_tp, the_ptr);

	TRACEPX(ftag,
		es("@: "); eptr(patch_tp); eblank();
		tok_dump1(patch_tp, PRINT_HIDDEN_TOKS);
		eblank(); eptr(the_ptr); eblank(); es(tag); enl());
}
</t>
<t tx="ekr.20080529093004.306">@ Scan the token list.
@c

token *
tok_scan(register token * tp)
{
	FTAG("tok_scan");
	STATB(ftag);

	while (*tp != END_PROG_TOK) {

		ASSERT(*tp != BAD_TOK);

		next_tok(tp);
	}

	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.307">@ Scan a token list, looking for the first token of the indicated file.
@c

token *
tok_scan_file (char * file_name, token * first_tok)
{
	FTAG("tok_scan_file");
	register token * tp = first_tok;
	register char * ptr = NULL;
	bool save_update = tok_update_flag;
	token * result = 0;
	TRACEPB(ftag, es(file_name); enl());

	tok_update_flag = FALSE;

	TRACEPN(ftag, es("*****scanning for start of: "); es(file_name); enl());

	for(;;) {

		/* ASSERT will not work since tok_scan_line is called by ASSERT! */
		if (*tp == END_PROG_TOK) {
			ecnl(); es(ftag); es(": end-file over-run\n");
			end_abort();
		}

		if (*tp == HIDDEN_BEGIN_FILE_TOK) {
			ptr = (char *) ptr_tok_ptr(tp);
			if (str_eq(file_name, ptr)) {
				result = tp;
				goto done;

			}
			else if (ptr == NULL) {
				result = NULL;
				goto done;
			}
		}
		else if (*tp == HIDDEN_FILE_INFO_TOK) {
			file_info_node * fip = (file_info_node *) ptr_tok_ptr(tp);
			if(	fip -&gt; finfo_fname != NULL &amp;&amp;
				str_eq(file_name, fip -&gt; finfo_fname)) {
				result = tp;
				goto done;
			}
		}
		next_raw_tok(tp);
	}

done:
	tok_update_flag = save_update;
	STATX(ftag);
	return result;
}
</t>
<t tx="ekr.20080529093004.308">@ Scan a token list, looking for the first token of the indicated line. Assume first_tok points at the first token of the correct file.  The err_line_offset variable was added so this routine will work correctly even if we have #line directives that specify a previous line.
@c

token *
tok_scan_line (
	token *			first_tok,
	register long	target_line,
	char *			target_file_name,
	long *			returned_line)
{
	FTAG("-tok_scan_line");

	register token * tp = NULL;
	register long current_line = 0;
	bool save_update = tok_update_flag;

	static long	 tok_prev_line = 0;
	static char * tok_prev_line_file = NULL;
	static token * tok_prev_line_tp = NULL;

#ifndef PRODUCTION
	long start_line = err_line;
	char *	start_file = err_fname;
	token last_tok = 0;
#endif

	TRACEPB(ftag, elong(target_line); ecs(); es(target_file_name); enl());

	tok_update_flag = FALSE;

	/* The target_line can be negative because of leading context. */
	if (target_line &lt; 1) {
		target_line = 1;
	}

	if (tok_prev_line_file != NULL &amp;&amp;
		str_eq(target_file_name, tok_prev_line_file)) {

		if (tok_prev_line == target_line) {
			STATX(ftag);
			*returned_line = target_line;
			return tok_prev_line_tp;
		}
		else if (tok_prev_line &lt; target_line &amp;&amp; tok_prev_line &gt; 0) {
			tp = tok_prev_line_tp;
			current_line = tok_prev_line-1;
			TRACEPN(ftag,
				es("starting at line: "); elong(current_line); enl());
		}
		else {
			tp = first_tok;
			current_line = 0;
			TRACEPN(ftag,
				es("starting at line: "); elong(current_line); enl());
		}
	}
	else {
		tp = first_tok;
		current_line = 0;
	}

	for(;;) {

		if (*tp == END_PROG_TOK || *tp == HIDDEN_END_FILE_TOK) {

			/* ASSERT will not work: tok_scan_line is called by ASSERT! */
			ecnl(); es(ftag); es(": END_FILE seen:");
			es(" current line: "); elong(current_line);
			es(" target line: "); elong(target_line);
			end_abort();
		}
		else if (*tp == WS_NL_TOK || *tp == HIDDEN_NL_IN_COMMENT_TOK) {
			if (++current_line &gt;= target_line) {
				goto done;
			}
		}
		else if (*tp == HIDDEN_LINE_ADJUST_TOK) {
			current_line += val_tok_val(tp);
		}
		else if (*tp == HIDDEN_BEGIN_FILE_TOK) {

			register char * file_name = (char *) ptr_tok_ptr(tp);
			register file_info_node * fip;

			/* Skip the entire inner file. */
			if (!str_eq(file_name, target_file_name)) {
				for(;;) {
					if (*tp == HIDDEN_END_FILE_TOK) {
						fip = (file_info_node *) ptr_tok_ptr(tp);
						if (str_eq(target_file_name, fip -&gt; finfo_fname)) {
							break;
						}
					}
					else if (*tp == HIDDEN_FILE_INFO_TOK) {
						file_info_node * fip = (file_info_node *) ptr_tok_ptr(tp);
						if(fip -&gt; finfo_fname != NULL &amp;&amp;
							str_eq(target_file_name, fip -&gt; finfo_fname)) {
							break;
						}
					}
					next_raw_tok(tp);
				}
			}
		}
		DEBUG(last_tok = *tp);

		/*
			Scan the original macro text, not the substituted text.
			Similarly, scan original preprocessor directives.
		*/
		if (*tp == HIDDEN_SKIP_TO_MACRO_TOK ||
			*tp == HIDDEN_SKIP_DIRECTIVE_TOK ||
			*tp == HIDDEN_BIG_SKIP_TOK
		) {
			bump_tp_macro(tp, tok_size(*tp));
		}
		else {
			next_raw_tok(tp);
		}

		DEBUG(TRACEN(ftag,
			if (last_tok == WS_NL_TOK || last_tok == HIDDEN_NL_IN_COMMENT_TOK) {
				ecnl(); epadlong(current_line,4); es("::");
			}
			tok_dump1(tp, PRINT_HIDDEN_TOKS);
		));

	}

done:
	tok_update_flag = save_update;

	/* Save the settings for the next invocation of this routine. */
	tok_prev_line_file = target_file_name;
	tok_prev_line = current_line;
	tok_prev_line_tp = tp;

	ASSERT(err_line == start_line &amp;&amp; str_eq(err_fname, start_file));

	*returned_line = current_line;
	TRACEPX(ftag, eret(); es(" *returned_line "); elong(*returned_line); enl());

	ASSERT(*tp == WS_NL_TOK || *tp == HIDDEN_NL_IN_COMMENT_TOK || current_line == -1);
	return tp;
}
</t>
<t tx="ekr.20080529093004.309">@ Skip over and process any hidden tokens. Return NULL on end program.
@c

token *
tok_skip_hidden(token * tp)
{
	FTAG("tok_skip_hidden");
	FTAGV("-tok_skip_hidden_v");

	#if 0 /* This distorts the statistics too much. */
		STATB(ftag);
	#endif

	for(;;) {

		ASSERT_TRACE(*tp &lt; BAD_LAST_TOK &amp;&amp; *tp &gt; 0,
			es("*tp: "); eint(*tp);
			es(" tok_name: "); es(tok_name(*tp));
		);

		switch(*tp) {

		case END_PROG_TOK:
			TRACEPN(ftag, es("end file\n"));

			/* Do not change tp. */
			goto done;

		case HIDDEN_BEGIN_FILE_TOK:
		{
			char * name = (char *) ptr_tok_ptr(tp);

			if (tok_update_flag) {
				err_fname = name;
				err_line = 0;
				err_line_offset = 0;
			}
			bump_tp_macro(tp, tok_size(*tp));
			break;
		}

		case HIDDEN_BIG_IGNORE_TOK:
			bump_tp_macro(tp, BIG_TOKEN_SIZE);
			break;

		case HIDDEN_BIG_SKIP_TOK:
		{
			skip_node * sip = (skip_node *) ptr_tok_ptr(tp);

			if (tok_update_flag) {
				err_line += sip -&gt; skip_lines;
			}
			tp = sip -&gt; skip_tp;
			break;
		}

		case HIDDEN_END_BLOCK_TOK:
			tp = (token *) ptr_tok_ptr(tp);
			break;

		case HIDDEN_END_FILE_TOK:
		{
			file_info_node * fip = (file_info_node *) ptr_tok_ptr(tp);

			if (tok_update_flag) {
				if (fip -&gt; finfo_fname != NULL) {
					err_fname = fip -&gt; finfo_fname;
				}
				err_line 		= fip -&gt; finfo_line;
				err_line_offset = fip -&gt; finfo_line_offset;
			}

			tp = fip -&gt; finfo_tp;
			break;
		}

		case HIDDEN_FILE_INFO_TOK:
		{
			file_info_node * fip = (file_info_node *) ptr_tok_ptr(tp);

			if (tok_update_flag) {
				if (fip -&gt; finfo_fname != NULL) {
					err_fname = fip -&gt; finfo_fname;
				}
				err_line_offset = fip -&gt; finfo_line_offset;
			}

			tp = fip -&gt; finfo_tp;
			break;
		}

		case HIDDEN_LINE_ADJUST_TOK:
			if (tok_update_flag) {
				err_line += val_tok_val(tp);
			}
			bump_tp_macro(tp, tok_size(*tp));
			break;

		case HIDDEN_NL_IN_COMMENT_TOK:
		case HIDDEN_NL_IN_MACRO_TOK:

			if (tok_update_flag) {
				err_line++;
			}
			bump_tp_macro(tp, tok_size(*tp));
			break;

		case HIDDEN_SMALL_IGNORE_TOK:
			bump_tp_macro(tp, SMALL_TOKEN_SIZE);
			break;

		case HIDDEN_SKIP_TOK:
		case HIDDEN_SKIP_DIRECTIVE_TOK:
			tp = (token *)  ptr_tok_ptr(tp);
			break;

		case HIDDEN_SKIP_TO_MACRO_TOK:
		{
			token * name_tp = (token *) ptr_tok_ptr(tp);

			ASSERT_TRACE(*name_tp == ID_TOK || *name_tp == IDX_TOK,
				es("*tp: "); es(tok_name(*tp)));

			tp = name_tp;
			bump_tp_macro(tp, BIG_TOKEN_SIZE);
			break;
		}

		default:

			ASSERT_TRACE(!is_hidden(*tp),
				es(ftag); es(": "); es(tok_name(*tp)); es(" is hidden");
			);

			goto done;
		}
	}

done:
	ASSERT(*tp &lt; BAD_LAST_TOK &amp;&amp; *tp &gt; 0);

	#if 0 /* This distorts the statistics too much. */
		STATX(ftag);
	#endif

	return tp;

}</t>
<t tx="ekr.20080529093004.310">@ end tok_skip_hidden
Convert a visible token back to a string.  Created strings reside in tok_buffer[], which will be reused on the next call to tok_2string, so the caller is responsible for copying the strings returned by tok_2string to a permanent location.  If the stringize flag is TRUE, strings and character constants are "stringized" by preceding backslashes and " (including the opening and closing " of a string) by a backslash.  If the stringize flag is FALSE, strings and character constants are converted to their "print format" by surrounding them by " or '.
@c

#define MAX_BUF 1000
static char buffer [MAX_BUF+1];

char *
tok_2string(register token * tp, int * length_p, bool stringize_flag)
{
	FTAG("tok_2string");
	register char * ptr = ptr_tok_ptr(tp);
	register int buf_p = 0;
	register token kind = *tp;
	register int length = 0;
	register char delim = '\0';

	SL_DISABLE();

	switch(kind) {

	case CHAR_TOK:

char_tok:
		delim = '\'';
		goto char_or_string;

	case ERROR_CHAR_TOK:
	{
		char c = (long) ptr;
		buffer[0] = c;
		buffer[1] = '\0';
		*length_p = 1;
		return buffer;
	}

	case FLOAT_TOK:
	case INT_TOK:
		*length_p = strlen(ptr);
		return ptr;

	case HIDDEN_LINE_ADJUST_TOK:
	case HIDDEN_NL_IN_COMMENT_TOK:

		/* These are not even white space! */
		*length_p = 0;
		return "";

		/* Preprocessor special macros. */

	case KM_DATE:
		cvt_date(buffer, MAX_BUF, TRUE);
		*length_p = strlen(buffer);
		return buffer;

	case KM_FILE:
		*length_p = strlen(err_file_name());
		return err_file_name();

	case KM_LINE:
		cvt_long(buffer, MAX_BUF, err_line+err_line_offset);
		*length_p = strlen(buffer);
		return buffer;

	case KM_TIME:
		cvt_time(buffer, MAX_BUF, TRUE);
		*length_p = strlen(buffer);
		return buffer;

	case STRING_TOK:

		delim = '"';

char_or_string:
		length = strlen(ptr);
		if (length + buf_p &gt;= MAX_BUF) {
			error(es("stringized token is too large"));
			*length_p = 0;
			return "";
		}
		else if (!stringize_flag) {
			/* Surround with delim's. */
			buffer[buf_p++] = delim;
			strcpy(buffer + buf_p, ptr);
			buf_p += length;
			buffer[buf_p++] = delim;
			buffer[buf_p++] = '\0';
			*length_p = buf_p;
			return buffer;
		}
		else {
			/* Strinize but do not surround with delims. */
			if (delim == '"') {
				buffer[buf_p++] = '\\';
				buffer[buf_p++] = '"';
			}
			else {
				buffer[buf_p++] = '\'';
			}
			while (*ptr) {
				if (length + buf_p + 4 &gt;= MAX_BUF) {
					error(es("stringized token is too large"));
					*length_p = 0;
					return "";
				}
				else if (*ptr == '"' || *ptr == '\\') {
					buffer[buf_p++] = '\\';
					buffer[buf_p++] = *ptr++;
				}
				else {
					buffer[buf_p++] = *ptr++;
				}
			}
			if (delim == '"') {
				buffer[buf_p++] = '\\';
				buffer[buf_p++] = '"';
			}
			else {
				buffer[buf_p++] = '\'';
			}
			*length_p = buf_p;
			return buffer;
		}

	case COMMENT_TOK:
	case WS_NL_TOK:
	case WS_BLANKS_TOK:
		*length_p = 1; /* White space converts to a blank. */
		return " ";

	default:
		if (is_id(kind) || kind == IDX_TOK) {
			*length_p = strlen(((spell_node *) ptr) -&gt; spell_name);
			return ((spell_node *) ptr) -&gt; spell_name;
		}
		else if (is_hidden(kind)) {
			*length_p = 0;
			return "";
		}
		else {
			*length_p = strlen(tok_name(kind));
			return tok_name(kind);
		}
	}

}</t>
<t tx="ekr.20080529093004.311">@ end tok_2string
Skip all white space except newlines.
@c

void
tok_skip_ws(void)
{
	FTAG("-tok_skip_ws");
	register token * tp = tok_token_ptr;
	STATB(ftag);

	while(*tp != WS_NL_TOK &amp;&amp; is_ws(*tp)) {
		bump_tp_macro(tp, tok_size(*tp));
		if (is_hidden(*tp)) {
			tp = tok_skip_hidden(tp);
		}
	}

	tok_token_ptr = tp;
	TRACEPX(ftag, es("line: "); epadlong(err_line, 3); es(", token: "); etok(tp); enl());
}</t>
<t tx="ekr.20080529093004.312">/*
	AS: tokenizing pass.

	Scan the input buffer, adding to the token list, the spelling table and
	string space blocks.  This routine is called in a variety of contexts.

	The input block must end with a IO_EOF_CHAR character.

	source:  AStokize.c
	started: September 25, 1991.
	version:
		June 12, 1994.
			Added QUESTION_TOK for the preprocessor.
		April 26, 1994.
			Removed "partial whitespace" logic because full whitespace
			is required in order to produce proper listings.
		April 23, 1994.
			Added support for doubled single-quote convention.
			This convention is used by the MPW assembler.
			Recognized asterisk at the start of a line as a single-line comment.
		March 30, 1994.
			tok_init_hash_tab now enters both the lower and upper case version
			of all register names, pseudo mnemonics and opcodes.
		February 20, 1994.
			Removed spell_symbol field from spell nodes.
		February 13, 1994.
			Bug fix to ';' case.  Don't include newline in COMMENT_TOK.
		February 11, 1994.
			Allow @ anywhere within identifiers.
			Converted WS_NL_TOK to a big token so it can point to cnodes.
		February 9, 1994.
			Dollar sign indicate hex constants.
		January 26, 1994.
			Added COLON_TOK.
		January 17, 1994.
			Removed C-style comment logic.
			Added ; comment logic.
			Removed ++ and -- logic.
		December 27, 1993.
			Made sym_hash_tab local to this file.
		December 21, 1993.
			Replaced global statistics logic with local TOKIZE_STATS logic.
			Updated statistics in the macros defined in this file, not AStokens.h.
*/

&lt;&lt; AStokize #includes &gt;&gt;
&lt;&lt; AStokize declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.313">#include "AS.h"

#include "ASarg.h"
#include "ASmem.h"
#include "AStokens.h"
#include "AStokize.h"

#include &lt;LIBio.h&gt;
#include &lt;LIBlist.h&gt;
#include &lt;LIBobj.h&gt;

#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.314">/*
	Define globals owned by this file.
*/
token *			tok_first_token = NULL;	/* First token of the outer file. */

	/* Global token statistics. */

long tok_bigs = 0;			/* Number of big tokens. */
long tok_blocks = 0;		/* Number of token blocks. */
long tok_bytes = 0;			/* Total allocated bytes. */
long tok_end_blocks = 0;	/* Number of end block tokens. */
long tok_number = 0;		/* Total number of tokens. */
long tok_smalls = 0; 		/* Number of small tokens. */
long tok_waste = 0;			/* Number of wasted bytes. */

/* 
	Define abbreviation macros.  These simplify the appearance of the
	source code and indicate relationships between groups of statements.

	o The 'put_small', 'put_ptr', 'put_id' and 'put_val' macros are 
	local versions of put_xxx_tok macros defined in AS2tok.h.
	These allow the tp and tavail parameters to be fully bound in
	the put_xxx_macros without cluttering up the code in this file.

	o The 'next' macro gets a character and updates ws_count.
	 This must be done on *every* character so tabs are handled proplerly.

	o The 'next_number' macro gets the next character of a number.

	o The 'next_string' macro gets the next string character and
	updates the proper statistic depending on string_delim.
*/
#define put_small(a,statistic) \
{\
	TOKIZE_STATS(tok_number++; tok_smalls++; statistic++);\
	MEM_UPDATE_STATS(small_token_stats, SMALL_TOKEN_SIZE);\
	MEM_STATS(\
		token_life -&gt; mem_cur_nodes ++;\
		token_life -&gt; mem_cur_bytes += (SMALL_TOKEN_SIZE));\
	put_small_tok(tp, tavail, a);\
}

#define put_ptr(a,b,statistic) \
{\
	TOKIZE_STATS(tok_number++; tok_bigs++; statistic++);\
	MEM_UPDATE_STATS(ptr_token_stats, BIG_TOKEN_SIZE);\
	MEM_STATS(\
		token_life -&gt; mem_cur_nodes ++;\
		token_life -&gt; mem_cur_bytes += (BIG_TOKEN_SIZE));\
	put_ptr_tok(tp, tavail, a, b);\
}

#define put_id(a,b,statistic) \
{\
	TOKIZE_STATS(tok_number++; tok_bigs++; statistic++);\
	MEM_UPDATE_STATS(id_token_stats, BIG_TOKEN_SIZE);\
	MEM_STATS(\
		token_life -&gt; mem_cur_nodes ++;\
		token_life -&gt; mem_cur_bytes += (BIG_TOKEN_SIZE));\
	put_id_tok(tp, tavail, a, b);\
}

#define put_val(a,b,statistic) \
{\
	TOKIZE_STATS(tok_number++; tok_bigs++; statistic++);\
	MEM_UPDATE_STATS(val_token_stats, BIG_TOKEN_SIZE);\
	MEM_STATS(\
		token_life -&gt; mem_cur_nodes ++;\
		token_life -&gt; mem_cur_bytes += (BIG_TOKEN_SIZE));\
	put_val_tok(tp, tavail, a, b);\
}

#define next(statistic) { c = *ip++; ws_count++; TOKIZE_STATS(statistic++;) }

#define next_number() { next(number_chars); string_length++;}

#define next_string()\
	if (string_delim == '"') { next(string_chars); }\
	else { next(char_constant_chars); }

/*
	Define slightly quicker versions of &lt;ctype.h&gt; macros.
*/
#undef isalpha
#undef isspace
#undef isdigit
#undef isxdigit

#define isalpha(c) (((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z') || ((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'Z'))
#define isspace(c) ((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) == '\f' || (c) == '\v' )
#define isdigit(c) ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9')
#define isxdigit(c) (isdigit(c) || ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'f') || ((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'F'))

/*
	Function prototypes of internal routines.
*/
static void	stats1			(char * title, long tokens, long chars);
static void	tok_dump_speed	(long ticks, long start_newlines);

/*
	Variables local to this file.
*/
#define SPELL_PRIME 1009	/* The size of the spelling hash table. (It should be prime) */

static bool			init_flag = FALSE;		/* TRUE: tokize has been initialized. */
static spell_node **sym_hash_tab = NULL;	/* Global spelling hash table. */

/*
	The following statistics are always kept in case Sherlock is enabled.
*/
static long	input_chars = 0;	/* Number of input characters. */
static long	newlines = 0;		/* Number of newlines. */

#ifdef DO_TOKIZE_STATS

static long	junk = 0;			/* Ignored statistic. */
static long	found_ids = 0;		/* Id's found in searches. */
static long	bad_chars = 0;
static long	begin_prog_tokens = 0;
static long	char_constants = 0;
static long	char_constant_chars = 0;
static long	comments = 0;
static long	comment_chars = 0;
static long	end_prog_tokens = 0;
static long	error_tokens = 0;
static long	ids = 0;
static long	id_chars = 0;
static long	id_found_chars = 0;
static long	ints = 0;
static long	file_names = 0;
static long	file_name_chars = 0;
static long	floats = 0;
static long	long_ints = 0;
static long	newline_toks = 0;
static long	number_chars = 0;		/* Includes ints, floats and long ints. */
static long	regulars = 0;
static long	regular_chars = 0;
static long	strings = 0;
static long	string_chars = 0;
static long	tokens = 0;
static long	total_chars = 0;
static long	tot_strings = 0;
static long	tot_string_chars = 0;
static long	wide_chars = 0;
static long	wide_strings = 0;
static long	ws = 0;
static long	ws_chars = 0;
</t>
<t tx="ekr.20080529093004.315">#endif /* DO_TOKIZE_STATS */

/*
	Create a token block from the input block.
	Return a pointer to the first token of the first token block.

	The last token created depends on skip_flag:

		TRUE:	the last token is HIDDEN_SKIP_TOK(skip_tp);
		FALSE:	the last token is HIDDEN_END_FILE_TOK(return_fip);

	This code also creates string blocks and symbol table blocks.

	This code is long and complex, and it has the following
	simple conceptual structure:

		token *
		tokize(params)
		{
			declare and initialize local variables;	(Part 1)
			initialize global variables;			(Part 2)

		loop:										(Part 3)
			switch(c) {
			cases in the main loop:
				parse a token;
				goto loop;
			}
		done:
			output the last tokens;					(Part 4)
			save global variables.					(Part 5)
			print statistics;						(Part 6)
			return a pointer to the first token;
		}
*/

token *
tokize(
	io_mem_block * input_block,		/* Descriptor for input block. */
	file_info_node * return_fip,	/* For HIDDEN_END_FILE_TOK. */
	char * file_name,				/* For HIDDEN_BEGIN_FILE_TOK. */
	bool skip_flag,					/* TRUE: output HIDDEN_SKIP_TOK. */
	token * skip_tp)				/* For HIDDEN_SKIP_TOK. */
{

	/* PART 1: declare and initialize local variables */

	FTAG("tokize");
	FTAGV("-tokize_v");

	/*
		Warning: Registers are only assigned as indicated if the Think C
		'automatic register assignment' setting is OFF.
	*/

	/* The 3 most important A registers. */

	register char * ip;				/* Input pointer. */
	register token * tp;			/* Token pointer. */
	register char * string_start;	/* Start of string. */

	/* The 5 most important D registers. */

	register char c;			/* The current character. */
	register long tavail = 0;	/* Available token chars. */
	register int hash;			/* Hash code for id. */
	register int string_length;	/* Length of string. */

	/* Spelling nodes. */

	spell_node * hp;	/* Spell node pointer. */
	spell_node * hp2;	/* Temp spell node pointer. */

	/* Token blocks and string blocks. */

	token *	first_token;	/* Start of first token. */

	/* Processing of file name tokens. */

	token * old_tp;		/* Start of possible file name. */
	long old_tavail;	/* Saved tavail for restart. */

	/* White space. */

	long nl_in_ws = 0;		/* Accumulated newlines in white space. */
	token * nl_mark = NULL;	/* Marker to previous newline. */
	long ws_count = 0;		/* Count of characters in the current line. */
	long start_ws_count;	/* Starting line count. */
	int tab_size = 4;		/* Size of a tab. */

	/* Errors in tokize. */

	char * error_ptr = NULL;	/* defered error message. */
	bool error_flag = FALSE;	/* TRUE: an error was seen. */

	/* Strings. */

	bool wide_flag;		/* TRUE: wide char or string. */
	token final_token;	/* token to output (changed by error code. */
	char string_delim;	/* " for strings, ' for char constants. */

	/* Local statistics. */

	long ticks = 0;					/* Ticks spent in tokize. */
	long start_newlines = newlines;	/* Starting newline in the current file. */

	/* PART 2: initialize global variables. */
	STATB(ftag);
	ASSERT(sym_hash_tab);

	TOKIZE_STATS(tok_reinit_stats());

	/* Point at the start of the input block. */
	input_chars = input_block -&gt; mem_length;
	ip = input_block -&gt; mem_start;

	/*
		Restore local variables from globals.
		Allocate a new token block if none has been allocated.
	*/
	if (token_life -&gt; mem_ptr == NULL) {
		mem_new_block(0, token_life);
	}
	ASSERT(token_life -&gt; mem_ptr);
	tavail = token_life -&gt; mem_avail;
	first_token = tp = token_life -&gt; mem_ptr;

	TRACEP(ftagv, es(file_name); enl());

	if (!skip_flag) {
		char * p;

		/* Put in a HIDDEN_BEGIN_FILE_TOK. */
		new_file_string_macro(p, file_name);
		put_ptr(HIDDEN_BEGIN_FILE_TOK, p, begin_prog_tokens);

		/* Put in a dummy newline token. */

		/* Careful: make the mark *after* calling tok_protect_macro. */
		tok_protect_macro(tp, tavail);
		nl_mark = tp;
		put_ptr(WS_NL_TOK, NULL, begin_prog_tokens);
	}

	/* Initialize c. */
	next(bad_chars);

	nl_in_ws = 0;
	
	/* Handle an asterisk at the very start of a file. */
	if (c == '*') {
	
		TOKIZE_STATS(comments++; regular_chars--; comment_chars++);
	
		/* Scan to the end of the line. */
		string_start = ip - 1;
		string_length = 0;
		while (c != '\n') {
			string_length++;
			next(comment_chars);
		}
	
		/* Create a COMMENT_TOK so comments will print properly in error messages. */
		put_ptr(COMMENT_TOK, mem_str_copy(string_start, string_length), comments);
		goto loop;
	}

	/*
		PART 3: The main loop, which must be as fast as possible!
	*/
loop:

	#if 0 /* Too Expensive */
		TRACE("tokize_obj_v", obj_checkMem());
	#endif

	#if 0 /* Much too expensive. */
		#ifdef THINK_C
			if (w_applEvent(0) == FALSE) {
				end_quit();
			}
		#endif
	#endif

switch(c) {

case '@':
case '_':
case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':
case 'h': case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':
case 'o': case 'p': case 'q': case 'r': case 's': case 't': case 'u':
case 'v': case 'w': case 'x': case 'y': case 'z':
case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':
case 'H': case 'I': case 'J': case 'K': case 'L': case 'M': case 'N':
case 'O': case 'P': case 'Q': case 'R': case 'S': case 'T': case 'U':
case 'V': case 'W': case 'X': case 'Y': case 'Z':

	/* Compute the hash code of the identifier. */
	hash = 0;
	string_start = ip - 1;
	string_length = 0;
	while (
		isalpha(c) || isdigit(c) || c == '_' || c == '@') {
		hash *= 3; hash += c; hash %= SPELL_PRIME;
		next(id_chars); string_length++;
	}

	/* See if the id is already in the spelling table. */

#if 1 /* Faster in-line version. */

	for (hp2 = sym_hash_tab[hash]; hp2 != NULL; hp2 = hp2 -&gt; spell_next) {
		if (string_length == hp2 -&gt; spell_length) {
			int i;
			for (i = 0; i &lt; string_length; i++) {
				if (string_start[i] != hp2 -&gt; spell_name[i]) {
					break;
				}
			}

			if (i == string_length) {
				TOKIZE_STATS(found_ids++; id_found_chars += string_length);
				put_id(hp2 -&gt; spell_token, hp2, ids);
				goto loop;
			}
		}
	}

#else /* Significantly slower version using tok_lookup. */

	hp2 = tok_lookup(string_start, string_length, hash);
	if (hp2 != NULL) {
		TOKIZE_STATS(found_ids++; id_found_chars += string_length);
		put_id(hp2 -&gt; spell_token, hp2, ids);
		goto loop;
	}

#endif

	/*
		Symbol not found. (It can not be a keyword.)

		Enter the string into the spelling table.
	*/	
	new_file_macro(hp, spell_stats)
	hp -&gt; spell_next = sym_hash_tab[hash]; sym_hash_tab[hash] = hp;
	hp -&gt; spell_length = string_length;
	hp -&gt; spell_name = mem_str_copy(string_start, string_length);
	hp -&gt; spell_token = ID_TOK;
	hp -&gt; spell_macro = NULL;

	put_id(ID_TOK, hp, ids);
	goto loop;

	/*
		Handle white space, which may continue into comments.

		If the full_ws command line option is on, return one or more of:

			WS_VTAB_TOK		'\v'
			WS_FF_TOK		'\f'
			WS_NL_TOK		'\n'
			WS_COMMENT_TOK	comments
			WS_BLANKS_TOK	white space with space count.
			WS_TOK			white space

		Otherwise, return one or more of:

			WS_NL_TOK		'\n'
			WS_TOK			white space
	*/

	case '\r':

		fatal(es("unexpected \\r in tokize"));

	case ' ': case '\f': case '\t': case '\n': case '\v':
	{
		bool newline_seen = FALSE;
		start_ws_count = ws_count;
		for(;;) {

			switch(c) {

			case '\v':
				next(ws_chars);
				start_ws_count = ws_count = 0;
				put_small(WS_VTAB_TOK, ws);
				break;

			case '\f':
				next(ws_chars);
				start_ws_count = ws_count = 0;
				put_small(WS_FF_TOK, ws);
				break;

			case ' ':
				next(ws_chars);
				break;

			case '\t':
				next(ws_chars);
				ws_count--;
				ws_count += (tab_size - (ws_count % tab_size));
				break;

			case '\n':
				newline_seen = TRUE;
				next(junk); newlines++;
				start_ws_count = ws_count = 0;

				/* Careful: make the mark *after* calling tok_protect_macro. */
				tok_protect_macro(tp, tavail);
				nl_mark = tp;
				put_ptr(WS_NL_TOK, NULL, newline_toks);
				break;
				
			case '*':
			
				/*
					4/23/94: An asterisk at the *beginning* of a line is a comment.
					We *must* recognize the comment here to allow anything
					to appear in the comment, such as, for example, single quotes.
				*/
				if (newline_seen) {
				
					TOKIZE_STATS(comments++; regular_chars--; comment_chars++);

					/* Scan to the end of the line. */
					string_start = ip - 1;
					string_length = 0;
					while (c != '\n') {
						string_length++;
						next(comment_chars);
					}
				
					/* Create a COMMENT_TOK so comments will print properly in error messages. */
					put_ptr(COMMENT_TOK, mem_str_copy(string_start, string_length), comments);
					break;
				}
				
				/* else fall through. */

			default:
				/* A non white-space character. */
				if (ws_count - start_ws_count &gt; 0) {
					ws_count -= start_ws_count;
					put_val(WS_BLANKS_TOK, ws_count, ws);
					ws_count += start_ws_count;
				}
				goto loop;
			}
		}
	}
	
	fatal(es("fall through ws case"));

	/* Semicolon starts a comment that continues to the end of the line. */

case ';':

	TOKIZE_STATS(comments++; regular_chars--; comment_chars++);

	/* Scan to the end of the line. */
	string_start = ip - 1;
	string_length = 0;
	while (c != '\n') {
		string_length++;
		next(comment_chars);
	}

	/* Create a COMMENT_TOK so comments will print properly in error messages. */
	put_ptr(COMMENT_TOK, mem_str_copy(string_start, string_length), comments);
	goto loop;

	/*
		Handle both strings and character constants and their wide variants.

		Create an ERROR_MESSAGE_TOK followed by the appropriate variety of
		PARTIAL_STRING_TOK if a newline is seen before the end of the string.

		Recall that compress has already deleted all backslash newlines.
	*/

case '\'':

	wide_flag = FALSE;
	final_token = CHAR_TOK;
	string_delim = '\'';
	TOKIZE_STATS(char_constants++);
	goto start_string;

case '"':

	wide_flag = FALSE;
	final_token = STRING_TOK;
	string_delim = '"';
	TOKIZE_STATS(strings++);
	goto start_string;

start_string:

	string_start = ip;
	string_length = 0;

	/* Skip the opening delim. */
	next_string();

	for(;;) {

		if (c == string_delim) {
			next_string();
			if (string_delim == '\'' &amp;&amp; c == string_delim) {
				/* two consecutive single-quote characters are a single quote. */
				next_string();
				string_length += 2;
			}
			else {
				put_ptr(final_token, mem_str_copy(string_start, string_length), junk);
				goto loop;
			}
		}
		else if (c == '\\') {

			/* Skip the back slash. */
			next_string();
			string_length++;

			/* Skip the next character. */
			ASSERT(c != '\n' &amp;&amp; c != IO_EOF_CHAR);
			next_string();
			string_length++;
		}
		else if (c == '\n') {
			goto error_in_string_constant;
		}
		else {
			next_string();
			string_length++;
		}

	} /* end string for loop */

	/*
		Create an error token followed by an error message token.
	*/

error_in_string_constant:

	/* Do not make the newline part of the string. */
	if (*ip == IO_EOF_CHAR) {
		if (string_delim == '"') {
			error_ptr = "File ends in a string";
		}
		else {
			error_ptr = "File ends in a character constant";
		}
	}
	else {
		if (string_delim == '"') {
			error_ptr = "String crosses a line";
		}
		else {
			error_ptr = "Character constant crosses a line";
		}
	}

	switch(final_token) {
	case STRING_TOK:	final_token = PARTIAL_STRING_TOK;	break;
	case CHAR_TOK:		final_token = PARTIAL_CHAR_TOK;		break;
	default:			fatal(es("bad final token"));

	}

	put_ptr(final_token, mem_str_copy(string_start, string_length), junk);
	goto error;

	/*
		The following is a major kludge to handle file names that
		are delimited by &lt; and &gt;.  In effect, these file names
		are strings, but strings which only exist in a very limited
		context.

		If a '&lt;' is seen, we look *backward* in the token file,
		starting with NL_MARK, looking for #define &lt;whitespace&gt;

		If we find that, followed by the current character, we
		create a FILE_NAME_TOK.

		Otherwise, we back up, using old_tp and old_tavail, and
		process a regular '&lt;' token.

		By the way, once we start looking for a FILE_NAME_TOK, a newline
		before the ending '&gt;' is an error which we signal by creating
		a ERROR_MESSAGE_TOK followed by a PARTIAL_FILE_NAME_TOK.

		The alternative to this kludge, namely to have cpp paste
		together a file name from an *arbitrary* sequence of tokens,
		would be an even worse kludge.
	*/

case '&lt;':	/* #define&lt;file name&gt; or &lt; or or &lt;= or &lt;&lt; or &lt;&lt;= */

	old_tp = tp;
	old_tavail = tavail;

	/*
		nl_mark points at the previous WS_NL_TOK in the token space.
		Look for POUND_TOK WS_TOK(opt) K_DEFINE WS_TOK(opt) in
		the token space, followed by the current position in the token
		space.  If found, treat the '&lt;' as the start of a file name.
	*/

	if (nl_mark == NULL) goto do_less_than;
	tp = nl_mark;
	next_tok(tp);
	if (is_ws(*tp)) next_tok(tp);
	if (*tp != POUND_TOK) goto do_less_than;
	next_tok(tp);
	if (is_ws(*tp)) next_tok(tp);
	if (*tp != K_INCLUDE) goto do_less_than;

	/*
		We have to be *very* careful here.
		old_tp may be BAD_TOK.
	*/
	tp = next_raw_tok(tp);
	while(tp != old_tp &amp;&amp; (is_hidden(*tp) || is_ws(*tp))) {
		tp = tok_next_raw(tp);
	}
	if (tp != old_tp) goto do_less_than;

	/*
		We have found #define &lt;
		Create a FILE_NAME_TOK.
	*/

	/* The string starts after the &lt; */
	string_start = ip;
	string_length = 0;

	/* Don't put &lt; in the string space */
	next(regular_chars);

	for(;;) {

		if (c == '&gt;') {
			next(regular_chars);
			if (string_length == 0) {
				put_ptr(ERROR_MESSAGE_TOK, "Missing file name", error_tokens);
			}
			put_ptr(FILE_NAME_TOK,
				mem_str_copy(string_start, string_length), file_names);
			goto loop;
		}
		else if (c == '\n') {
			put_ptr(ERROR_MESSAGE_TOK, "&gt; expected", error_tokens);
			put_ptr(PARTIAL_FILE_NAME_TOK,
				mem_str_copy(string_start, string_length), file_names);
			goto loop;
		}
		else {
			next(file_name_chars);
			string_length++;
		}

	} /* End file name for loop */

	/*
		We have seen a '&lt;' that is not part of #define &lt;
		Valid tokens are '&lt;', '&lt;&lt;', '&lt;=' or '&lt;&lt;='.
	*/

do_less_than:

	tavail = old_tavail;
	tp = old_tp;
	nl_mark = NULL;

	/* Eat the *first* '&lt;'. */
	next(regular_chars);
	if (c == '&lt;') {
		next(regular_chars);
		put_small(LSHIFT_TOK, regulars);
	}
	else if (c == '=') {
		next(regular_chars);
		put_small(LE_TOK, regulars);
	}
	else {
		put_small(LT_TOK, regulars);
	}
	goto loop;

	/*
		The start of simple tokens.
	*/

case '/':

	next(regular_chars);
	put_small(DIV_TOK, regulars);
	goto loop;

case '&gt;':	/* &gt; or &gt;= or &gt;&gt;  */

	next(regular_chars);
	if (c == '&gt;') {
		next(regular_chars);
		put_small(RSHIFT_TOK, regulars);
	}
	else if (c == '=') {
		next(regular_chars);
		put_small(GE_TOK, regulars);
	}
	else {
		put_small(GT_TOK, regulars);
	}
	goto loop;

case '%':

	next(regular_chars);
	put_small(MOD_TOK, regulars);
	goto loop;

case '=':
		next(regular_chars);
		if (c == '=') {
			next(regular_chars);
			put_small(EQUAL_TOK, regulars);
		}
		else {
			put_small(ASSN_TOK, regulars);
		}
		goto loop;

case '+':	/* + */

	next(regular_chars);
	put_small(PLUS_TOK, regulars);
	goto loop;

case '-':	/* - */

	next(regular_chars);
	put_small(MINUS_TOK, regulars);
	goto loop;

case '*':

	next(regular_chars);
	put_small(STAR_TOK, regulars);
	goto loop;


case '!':	/* ! or != */

	next(regular_chars);
	if (c == '=') {
		next(regular_chars);
		put_small(NE_TOK, regulars);
	}
	else {
		put_small(NOT_TOK, regulars);
	}
	goto loop;

case '|':	/* | or || */

	next(regular_chars);
	if (c == '|') {
		next(regular_chars);
		put_small(LOR_TOK, regulars);
	}
	else {
		put_small(OR_TOK, regulars);
	}
	goto loop;

case '&amp;':	/* &amp; or &amp;&amp; */

	next(regular_chars);
	if (c == '&amp;') {
		next(regular_chars);
		put_small(LAND_TOK, regulars);
	}
	else {
		put_small(AND_TOK, regulars);
	}
	goto loop;

case '^':

	next(regular_chars);
	put_small(XOR_TOK, regulars);
	goto loop;

case '#':

	next(regular_chars);
	if(c == '#') {
		next(regular_chars);
		put_ptr(POUND_POUND_TOK, NULL, regulars);
	}
	else {
		put_ptr(POUND_TOK, NULL, regulars);
	}
	goto loop;

case '~':

	next(regular_chars);
	put_small(TILDE_TOK, regulars);
	goto loop;
	
case ':':

	next(regular_chars);
	put_small(COLON_TOK, regulars);
	goto loop;
	
case '?':

	next(regular_chars);
	put_small(QUESTION_TOK, regulars);
	goto loop;

case ',':

	next(regular_chars);
	put_small(COMMA_TOK, regulars);
	goto loop;

case '(':

	next(regular_chars);
	put_small(LPAREN_TOK, regulars);
	goto loop;

case ')':

	next(regular_chars);
	put_small(RPAREN_TOK, regulars);
	goto loop;

case '[':

	next(regular_chars);
	put_small(LBRACK_TOK, regulars);
	goto loop;

case ']':

	next(regular_chars);
	put_small(RBRACK_TOK, regulars);
	goto loop;

case '{':

	next(regular_chars);
	put_small(LCURLY_TOK, regulars);
	goto loop;

case '}':

	next(regular_chars);
	put_small(RCURLY_TOK, regulars);
	goto loop;

	/*
		Parse an integer or floating constant.

		Because of token pasting requirements, the created tokens
		contain pointers to the *spelling* of these constants,
		not their value.

		Legal integer forms:	ddd,	0ddd,	0xddd
		Legal float forms:	xxx.yyyE+-zzz

		+-zzz is optional
		one of xxx and yyy may be omitted
		one of . and E+-zzz may be omitted

		Recall that according to the ANSI Standard each token must
		contain the longest possible valid sequence of characters.

		However, at this point there is no such thing as a missing
		character in a numeric token. Consider a macro such as:

			#define ten_to_the_x(x) 10.0E##x

		The token 10.0E would be erroneous by itself, but it is made valid
		by the token pasting.  So just accumulate what we can and hope for the
		best later on.
	*/

case '.':

	if (!isdigit(*ip)) {
		if (*ip == '.' &amp;&amp; *(ip+1) == '.') {
			next(regular_chars);
			next(regular_chars);
			next(regular_chars);
			put_small(DOTS3_TOK, regulars);
		}
		else {
			put_small(DOT_TOK, regulars);
			next(regular_chars);
		}
		goto loop;
	}

	string_start = ip-1;
	string_length = 0;
	goto begin_float;

case '0':

	string_start = ip-1;
	string_length = 0;

	/* Leading 0 or 0x changes base. */
	next_number();

	if (c == 'x' || c == 'X') {
		next_number();
		while (isxdigit(c)) {
			next_number();
		}
	}
	else {
		while (isxdigit(c)) {
			if (c &lt; '0' || c &gt; '7') {
				error_ptr = "Non octal digit in octal constant";
				error_flag = TRUE;
				goto put_int;
			}
			next_number();
		}
	}
	goto end_int_part;
	
case '$':

	string_start = ip-1;
	string_length = 0;

	/* Leading $ changes base to hex. */
	next_number();
	
	while (isxdigit(c)) {
		next_number();
	}
	goto end_int_part;

case '1': case '2': case '3': case '4':
case '5': case '6': case '7': case '8': case '9':

	string_start = ip-1;
	string_length = 0;

	while (isxdigit(c)) {

		/* Assume the e starts a floating constant. */
		if (c == 'e' || c == 'E') {
			goto begin_float;
		}

		if (!isdigit(c)) {
			error_ptr = "Hex digit in decimal constant";
			error_flag = TRUE;
			goto put_int;
		}
		next_number();
	}

end_int_part:

	/* Trailing u, l, ul, or lu terminate the int or long constant. */

	if (c == 'l' || c == 'L') {
		next_number();
		if(c == 'u' || c == 'U') {
			next_number();
		}
		goto put_long_int;
	}

	if (c == 'u' || c == 'U') {
		next_number();
		if (c == 'l' || c == 'L') {
			next_number();
			goto put_long_int;
		}
		else {
			goto put_int;
		}
	}

	/* Only . or e will continue the constant. */

	if (c != '.' &amp;&amp; c != 'e' &amp;&amp; c != 'E') {
		goto put_int;
	}

	/* c is either '.' or 'e' or 'E' here. */

begin_float:

	/* All tokens after here are floats. */

	if (c == '.') {
		next_number();
		while (isdigit(c)) {
			next_number();
		}
	}

	/* Trailing l or f terminate the floating constant. */

	if (c == 'l' || c == 'L' || c == 'f' || c == 'F') {
		next_number();
		goto put_float;
	}

	/* Only E, +, -, E+ or E- will continue the floating constant. */

	if (c != 'e' &amp;&amp; c != 'E' &amp;&amp; c != '+' &amp;&amp; c != '-') goto put_float;

	if (c == 'e' || c == 'E') {
		next_number();
	}

	if (c == '+' || c == '-') {
		next_number();
	}

	if (!isdigit(c)) {

		/*
			99.999% of the time this really will be an error, but do not
			complain now because of the possibility of token pasting.
		*/
		#if 0
			error_ptr = "Missing exponent in floating constant";
			error_flag = TRUE;
		#endif

		goto put_float;
	}

	/* Scan the exponent. */
	while (isdigit(c)) {
		next_number();
	}

	/* Trailing l or f are possible. */
	if (c == 'l' || c == 'L' || c == 'f' || c == 'F') {
		next_number();
		goto put_float;
	}
	goto put_float;

	/* 2/9/94: INT's and LONG's are equivalent. */

put_int:
put_long_int:

	put_ptr(INT_TOK, mem_str_copy(string_start, string_length), ints);
	goto end_number;

put_float:

	put_ptr(FLOAT_TOK, mem_str_copy(string_start, string_length), floats);
	goto end_number;

end_number:

	if (error_flag) {
		goto error;
	}
	else {
		goto loop;
	}

case IO_EOF_CHAR:

	goto done;


	/*
		Because of stringizing and other weirdnesses,
		there is no such thing here as a "bad input character."

		Convert all other characters to a (big) ERROR_CHAR_TOK.
	*/

default:

		put_val(ERROR_CHAR_TOK, (long) c, junk);
		next(bad_chars);
		goto loop;

	} /* End main switch */

	/*
		An error has been seen and error_ptr points to an error message.

		Create an ERROR_MESSAGE_TOK so cpp can print the message in
		context when the token list is complete.
	*/

error:

	ASSERT(error_ptr);
	put_ptr(ERROR_MESSAGE_TOK, error_ptr, error_tokens);
	error_ptr = NULL;
	error_flag = FALSE;
	goto loop;

	/*
		PART 4: output the final tokens.
	*/

done:

	/* Output any remaining newlines. */
	{
		int i;
		for (i = 0; i &lt; nl_in_ws; i++) {
			put_ptr(WS_NL_TOK, NULL, newline_toks);
		}
	}

	/* Output the last token. */
	if (skip_flag) {
		put_ptr(HIDDEN_SKIP_TOK, skip_tp, end_prog_tokens);
	}
	else if (return_fip == NULL) {
		put_small(END_PROG_TOK, end_prog_tokens);
	}
	else {
		put_ptr(HIDDEN_END_FILE_TOK, return_fip, end_prog_tokens);
	}

	/*
		Part 5: Save global variables.

		Save the global avail pointers in the current blocks.
		These will be restored when tokize is re-entered.
	*/
	token_life -&gt; mem_avail = tavail;
	token_life -&gt; mem_ptr = tp;

	TRACEPX(ftag, es(file_name); es(": chars: "); elong(input_chars); enl());

	/*
		PART 6: output dumps and statistics.
	*/
	#ifdef SHERLOCK
		ticks = sl_theTicks;
	#endif

	TRACE("-tokize_dump",tok_dump(tok_first_token, PRINT_HIDDEN_TOKS));

	TOKIZE_STATS(TRACE("-tokize_stats",
		/* Ignore include files and command-line arguments. */
		if (!skip_flag &amp;&amp; return_fip == NULL &amp;&amp; input_chars &gt; 100) {
			tok_dump_stats();
		}
	));

	TRACE("-tokize_speed", 
		/* Ignore include files and command-line arguments. */
		if (!skip_flag &amp;&amp; return_fip == NULL &amp;&amp; input_chars &gt; 100) {
			tok_dump_speed(ticks, start_newlines);
		}
	);

	/* Return a pointer to the first token created by this call. */
	return first_token;
}
</t>
<t tx="ekr.20080529093004.316">@ Print one line of statistics.
@c

static void
stats1(char * title, long tokens, long chars)
{
	bool not_token_flag = (title [0] == '(');
	bool not_char_flag =  (title [1] == '(');

	SL_DISABLE();

	if (not_token_flag) title++;
	if (not_char_flag) title++;

	ecnl();
	epads(title, 25);

	if (not_token_flag) {
		epadparenlong(tokens, 9);
	}
	else if (tokens &gt;= 0) {
		epadlong(tokens, 9);
	}
	else {
		eblanks(9);
	}

	if (not_char_flag) {
		epadparenlong(chars, 9);
	}
	else if (chars &gt;= 0) {
		epadlong(chars, 9);
	}

	if (tokens &gt; 0 &amp;&amp; chars &gt;= 0) {
		epadfrac(chars, tokens, 12);
	}
	enl();
}
</t>
<t tx="ekr.20080529093004.317">@ Output the speed of tokize.
@c

static void
tok_dump_speed(long ticks, long start_newlines)
{
	long nl = newlines - start_newlines;
	long double d6 = ((double) 60) * 1000;
	long double chars_per_min = d6 * (input_chars / (double) ticks2msec(ticks));
	long double lines_per_min = d6 * (nl / (double) ticks2msec(ticks));

	ecnl();
	es("chars/min: "); elong((long) chars_per_min);
	es(" lines/min: "); elong((long) lines_per_min);
	enl(); enl();
}
</t>
<t tx="ekr.20080529093004.318">@ Output the tokize statistics.
@c

#ifdef DO_TOKIZE_STATS

void
tok_dump_stats(void)
{
	tokens =

	tok_end_blocks +
	begin_prog_tokens + end_prog_tokens +
	wide_chars + wide_strings +
	regulars + ws + newline_toks + file_names +
	ids + strings + char_constants + ints + long_ints + floats;

	total_chars =

	regular_chars + ws_chars + comment_chars + newlines + file_name_chars +
	id_chars + string_chars + char_constant_chars + number_chars;

	tot_strings =

	 (ids - found_ids) + ints + long_ints + floats +
	 strings + char_constants + wide_chars + wide_strings + file_names;
	 
	tot_string_chars =

	 (id_chars - id_found_chars) + number_chars +
	 string_chars + char_constant_chars + file_name_chars +
	 
	 /* Add for each token: one for the trailing '\0' */

	+ (ids - found_ids) + ints + long_ints + floats +
	strings + char_constants + wide_chars + wide_strings + file_names
	 
	 /*
 		Subtract two for strings and char_constants.
 		(the " or '  or &lt; &gt; are not stored.)
 		Subtract 4 for comments.
	 */

	 - 2*(strings + char_constants + wide_chars + wide_strings + file_names);
	 
	tokens += comments;
	tot_strings += comments;
	tot_string_chars += (comment_chars - 4 * comments);

	ecnls(2);
	epads("token type",25);
	epads("tokens", 9);
	epads("chars", 9);
	eblanks(5);
	es("chars/token");
	enl();

	stats1("newlines", newline_toks, newlines);
	stats1("ints", ints, -1);
	stats1("longs", long_ints, -1);
	stats1("floats", floats,  -1);
	stats1("(int + long + float chars",ints+long_ints+floats, number_chars);
	stats1("regular tokens", regulars, regular_chars);
	stats1("ws and not comments", ws, ws_chars);
	stats1("comments", comments, comment_chars);
	stats1("ids", ids, id_chars);
	stats1("((ids found", found_ids, id_found_chars);
	stats1("((ids not found", ids - found_ids, id_chars - id_found_chars);
	stats1("strings", strings, string_chars);
	stats1("wide strings", wide_strings, -1);
	stats1("char constants", char_constants, char_constant_chars);
	stats1("wide char constants", wide_chars, -1);
	stats1("&lt;file names&gt;", file_names, file_name_chars);
	stats1("end block tokens", tok_end_blocks, -1);
	stats1("begin prog tokens", begin_prog_tokens, -1);
	stats1("end prog tokens", end_prog_tokens, -1);
	stats1("((string table", tot_strings, tot_string_chars);
	stats1("TOTALS", tokens, total_chars);
	stats1("input chars", -1, input_chars);
	enl();
}
</t>
<t tx="ekr.20080529093004.319">#endif /* DO_TOKIZE_STATS */

/*
	Initialize global variables and the hash table.
*/
#define create_spell_node_macro(hp, name, length, index, hash) \
{\
	new_file_macro(hp, keyword_spell_stats);\
	hp -&gt; spell_length = length;\
	hp -&gt; spell_name = name;\
	hp -&gt; spell_token = index;\
	\
	/* Hang the node off the hash table. */\
	hp -&gt; spell_next = sym_hash_tab[hash];\
	sym_hash_tab[hash] = hp;\
}

#define compute_hash_macro(hash, name) \
{\
	register char * p = name;\
	hash = 0;\
	while (*p) {\
		hash *= 3; hash += *p; hash %= SPELL_PRIME;\
		p++;\
	}\
}

#define compute_hash_and_length_macro(hash, name, length) \
{\
	register char * p = name;\
	hash = 0;\
	length = 0;\
	while (*p) {\
		hash *= 3; hash += *p; hash %= SPELL_PRIME;\
		p++;\
		length++;\
	}\
}

void
tok_init_hash_tab(void)
{
	FTAG("tok_init_hash_tab");
	register spell_node * hp = NULL;
	register char * string_start = NULL;
	register long hash = 0;
	register long string_length = 0;
	register int tok_index = 0;
	register int i = 0;
	STATB(ftag);

	/* Allocate the symbol table.  It is never deallocated. */
	if (sym_hash_tab == NULL) {
		obj_new_macro(sym_hash_tab, SPELL_PRIME * sizeof(spell_node *), "symbol table");
	}

	/* Initialize the table. */
	for (tok_index = 0; tok_index &lt; SPELL_PRIME; tok_index++) {
		sym_hash_tab[tok_index] = 0;
	}

	/* Enter keywords into the hash table. */
	for (tok_index = 0; tok_index &lt; BAD_LAST_TOK; tok_index++) {

		/* Only enter keywords and register names. */
		if (!is_key(tok_index) &amp;&amp; !is_ppkey(tok_index) &amp;&amp; !is_reg(tok_index)) {
			continue;
		}
		
		/* Enter the keyword as is. */
		string_start = tok_name(tok_index);
		compute_hash_and_length_macro(hash, string_start, string_length);
		{
			char * name = mem_str_copy(string_start, string_length);
			create_spell_node_macro(hp, name, string_length, tok_index, hash);
		}
		
		/*
			Part 2: enter assembler mnemonics in upper case as well.
			Don't bother to translate internal tokens starting with '&lt;'.
		*/
		if (!is_ppkey(tok_index) &amp;&amp; *string_start != '&lt;') {
			
			/* Create the upper-case version of the mnemonic. */
			char * upper_case_name = mem_str_copy(string_start, string_length);
			register char * p = upper_case_name;
			for (i = 0; i &lt; string_length; i++) {
				*p = toupper(*p);
				p++;
			}
			
			/* Enter the upper case mnemonic into the symbol table. */
			compute_hash_macro(hash, upper_case_name);
			create_spell_node_macro(hp, upper_case_name, string_length, tok_index, hash);
		}
	}

	TICKX(ftag);
}
</t>
<t tx="ekr.20080529093004.320">@ Enter a symbol whose hash is given into the symbol table.  The *caller* is responsible to see that the symbol does not already exist.
@c

#if 0 /* Not used in the assembler. */
spell_node *
tok_enter(char * string_start, int string_length, long hash)
{
	spell_node * hp = NULL;		/* Spell node pointer. */

	/*
		Enter the string into the spelling table.
	*/
	new_file_macro(hp, spell_stats);
	hp -&gt; spell_next = sym_hash_tab[hash]; sym_hash_tab[hash] = hp;
	hp -&gt; spell_length = string_length;
	hp -&gt; spell_name = mem_str_copy(string_start, string_length);
	hp -&gt; spell_token = ID_TOK;
	hp -&gt; spell_macro = NULL;

	return hp;
}
</t>
<t tx="ekr.20080529093004.321">#endif

/*
	Look up the string in the hash table.
*/
spell_node *
tok_lookup(
	register char * string_start,
	register long string_length,
	register long hash)
{
	register spell_node * hp2 = NULL;

	ASSERT(sym_hash_tab);

	for (hp2 = sym_hash_tab[hash]; hp2 != NULL; hp2 = hp2 -&gt; spell_next) {
		if (string_length == hp2 -&gt; spell_length) {
			int i;
			for (i = 0; i &lt; string_length; i++) {
				if (string_start[i] != hp2 -&gt; spell_name[i]) {
					break;
				}
			}

			if (i == string_length) {
				return hp2;
			}
		}
	}
	return NULL;
}
</t>
<t tx="ekr.20080529093004.322">@ Return the hash code for a symbol.
@c

long
tok_hash(char * s)
{
	register long hash = 0;

	SL_DISABLE();

	while (isalpha(*s) || isdigit(*s) || *s == '_') {
		hash *= 3; hash += *s; hash %= SPELL_PRIME;
		s++;
	}

	return hash;
}
</t>
<t tx="ekr.20080529093004.323">@ Look up the symbol Return a pointer to the spelling node if found. Return NULL if not found.
@c

spell_node *
tok_lookup_hash(char * s)
{
	return tok_lookup(s, strlen(s), tok_hash(s));
}
</t>
<t tx="ekr.20080529093004.324">@ Initialize all the tokize statistics.
@c

void
tok_reinit_stats(void)
{
	input_chars = 0;
	newlines = 0;

#ifdef DO_TOKIZE_STATS
	junk = 0;
	bad_chars = 0;
	begin_prog_tokens = 0;
	char_constants = 0;
	char_constant_chars = 0;
	comments = 0;
	comment_chars = 0;
	end_prog_tokens = 0;
	error_tokens = 0;
	file_names = 0;
	file_name_chars = 0;
	floats = 0;
	found_ids = 0;
	ids = 0;
	id_chars = 0;
	id_found_chars = 0;
	ints = 0;
	long_ints = 0;
	newline_toks = 0;
	number_chars = 0;
	regulars = 0;
	regular_chars = 0;
	strings = 0;
	string_chars = 0;
	tokens = 0;
	total_chars = 0;
	tot_strings = 0;
	tot_string_chars = 0;
	wide_chars = 0;
	wide_strings = 0;
	ws = 0;
	ws_chars = 0;

#endif /* DO_TOKIZE_STATS */

}
</t>
<t tx="ekr.20080529093004.325">@ignore
@language c</t>
<t tx="ekr.20080529093004.326">@nocolor

This section contains all the documention for CC2.  This documentation was written at various times for different purposes.  No attempt has been made to merge redundant documentation.

Clones of this documentation are found where they apply.
</t>
<t tx="ekr.20080529093004.327"></t>
<t tx="ekr.20080529093004.328">&gt; How was it organized? What did you use for intermediate representations? 

CC2 uses a memory management scheme based on "lifetimes", very similar to the "arena" scheme used by Hanson and Fraser.  CC2 has an integrated preprocessor that produces tokens.  No hashing is ever needed after tokenizing.  The preprocessor alters the token list, creating and deleting tokens as it scans.  A recursive descent parser creates a fairly standard parse tree containing nodes of various types describing statements, initializers, and types.  No DAG's are ever used, so no common subexpressons are found.  CC2 does no global optimization.  CC2 allocates registers to local register variables during parsing.  CC2 generates code and allocates temporary registers in a single pass over the parse tree.  The output of this pass is a doubly-linked code list, to which peephole optimizations are applied.  A final pass over the code list outputs assembly language. 

&gt; What sort of optimizations did it perform?
&gt; What technique did you use for register allocation?

The parser folds constants.  Boolean expressions are short circuited in a way that allows the peephole to generate perfect code.  The code generators were hand written; there is lots of machine-dependent hacking.  Register allocation for temporaries is intertwined with code selection.  I used greedy register allocation: moving temporary operands into registers whenever necessary or desirable, always assuming registers would be available.  The "get_a_register" routines spill a register when necessary.  In practice, spills almost never do happen.

&gt; What sort of code-quality results did you get vs THINK C 5.0 or MPW C?

Good to excellent, though not quite as good as Think C.  I often compared my code to Think C 6.0.  When CC2 compiles itself, it runs maybe 10% slower than when compiled with Think C. The following is an excerpt from a letter to Tuple dated 08/02/93:

"Since I talked with you last Thursday I have created a production version of CC2_tool, called CC2fast_tool.  This production program includes no Sherlock code because it writes to stderrr instead of using the Sherlock window.  The size of CC2fast_tool is 210K.

The following statistics were taken by measuring long runs of CC2fast_tool with a watch.  CC2 is currently about 75% slower than the Think C compiler.  This figure should not be cause for any alarm.  The code generated by CC2 is about 27% slower than that produced by Think C and installing an arithmetic peephole pass would make CC2's code competitive with the code produced by Think C.  More importantly, CC2fast_tool spends fully 39% of its time merely writing its output to the output file.  With the +no_output option enabled in CC2, Think C is 42% slower than CC2!  Thus, simply writing the output file dominates all other processing, including opening and closing files, reading all input, preprocessing, parsing and code generation. Installing an integrated assembler will cut output time substantially since .o output is much more compact than .a output.  Also, it may be possible to find way to speed up the copying of characters by, say, 20%.  Finally, note that even without any further improvements, the CC2 is already substantially faster than the MPW C compiler, the GNU C compiler and other similar compilers."

If my memory is correct, the 27% figure quoted above was derived simply by using a stopwatch on two different versions of CC2 as it executed: one version compiled by Think C and the other compiled by CC2 itself.  As such, the figure is pretty meaningless because it may very well be measuring differences in some critical sections of code.  In other words, there is no particular reason to think that CC2 is a good benchmark of its own generated code.

As I reread this, I'm still amazed that writing an output file can be so slow.  And I'm not sure why I thought I could only do 20% better--there may well be ways of doing much better than that.

a)  The generated code to handle conditionals is optimal after the peephole pass.  "if" "while" "for" and "do" instructions generate optimal code.
b)  Switch statements generate either a table jump, jocating registers only to local register variables.  CC2 was coded to make this optimal: in other words, we assume that the Think C "Honor Register First" preference will give the best performance.
d) Local code generation is good, not great.  Most, but not all address modes can be generated.  That is, the code generators find many ways to use address modes to avoid extra instructions.
e)  I considered adding an "arithmetic peephole" to find patterns involving operands spanning several instructions.
f)  Code to do floating point operations is crude.  It simply calls library routines.

Some parts of CC2 are a bit crude, but it met its design goals: it worked reliably and it had excellent compilation speed.  In particular, I wanted to get CC2 running quickly: there were many other tasks to do besides just the compiler.

If I were redesigning CC2, I would make the following changes:

a) I would make the parse tree smarter, by specifying operations in more detail.  In particular, the code generators would be simplified by making dereferencing operators explicit.
b) I would linearize the parse tree into an intermediate "abstract code list," as is done in both GCC and LCC. This would make more of code generation machine independent.
c) I would detect common subexpressions using the value-hashing scheme described in Hanson and Frasier.
d) I would use some kind of pattern-based code generator.  Hanson and Frasier describe a dynamic programming scheme that looks cool.  BDS C used a macro-based pattern matcher.  Still, peepholes are very easy to understand and to debug: I'd want to use peepholes whenever possible.</t>
<t tx="ekr.20080529093004.329">The following is an architect-level view of what I've learned about compilers:</t>
<t tx="ekr.20080529093004.330">This is an important topic because a compiler creates so many small objects.  Lifetime-oriented  (Arena-oriented) memory management is by far the best way to manage memory in a compiler.  This technique is used in LCC.  I independently discovered this technique and used it in the Tuple compiler.

The key idea is that all data with the same lifetime should be allocated in the same list of blocks (Arena).  The lifetime of a datum is the place (in time or, equivalently, in code) at which it is deallocated.  All data with the same lifetime (in the same Arena) are deallocated en masse. For instance, LCC and CC2 use 3 lifetimes:  permanent, file and function.

Using lifetimes, creating even millions of small data structures can be done quickly.  Lifetimes  _eliminate_  freeing of individual data structures, a major time saving and a major factor in eliminating memory management bugs.

Ironically, preflighting Mac toolbox calls would be needed even with garbage collection (as in Java) because Mac Toolbox calls can't grow stack space.  However, class libraries could hide details of preflighting.
</t>
<t tx="ekr.20080529093004.331">Optimizing is NP-hard, and it is usually possible to generate excellent code in a reasonable amount of time.  Optimal register allocation is known to be an NP-hard problem, so optimal code generation is also NP-hard.

Less theoretically, the problems of code generation can be explained as follows:
1. To allocate registers optimally, you must have already selected instructions.
2. To select instructions optimally, you must have already selected registers.
3. An optimal assignment of registers and instructions in a lower part of the parse tree may cause inefficiencies in the upper part of the parse tree.
4. The parse tree in question may be the parse tree (or forest) for the entire function being compiled, or even the tree for entire program.
5. What's optimal for one set of run-time data may not be optimal for another set.  There have been projects that generate code based on run-time statistics, though these are not common, perhaps for obvious reasons.

Dynamic programming, as practiced in LCC, is an effective and relatively efficient way of generating near-optimal code.  Dynamic programming creates a tree of possible code such that _every_ different alternative is considered until it is clear that the alternative can not be part of an optimal solution.

Another approach is to use naive code generation and then use extensive peephole optimizers.  This is what GCC does.

Regardless of what schemes are used, it is clear that because code generation is NP-hard that there will always be essentially kludgy interactions between, for instance, code generation and register allocation.  (If this were not true, we would have simplified NP-hard problems, and this is not likely to happen!)

In any event, the term optimization is a misnomer.  There is no such thing either in theory (optimization may depend on run-time data, for instance) or in practice (it would be too time consuming to solve an NP-hard problem).  Actually, optimization is pragmatic: what will produce generated code better than the competition?
</t>
<t tx="ekr.20080529093004.332">In practice, it is often easy for _any_ compiler to generate locally optimal code.  For instance, the Tuple compiler produced excellent local code using no global optimization and a greedy register allocator.   This isn't good news; differentiating a compiler from its competition isn't going to be easy.

Most expressions are very simple.  Knuth published statistical studies of programs about 20 years ago showing that most expressions in typical programs contain only 1 or 2 operators.  Therefore, registers seldom spill in practice.

Differences between optimizing compilers will be found in the areas of 1) global optimizations and 2) global register allocation and 3) sophisticated code generation for complex patterns of instructions and address modes.  None of these areas is trivial; however, the GCC and LCC compilers show how these problems can be solved, effectively if not easily.
</t>
<t tx="ekr.20080529093004.333">Peephole optimizers and similar hacks can improve code significantly.  Peepholes are sometimes machine dependent, so there is some reluctance to use them, even though they work well.

Machine _independent_ code generators can sometimes be modified to make peepholes see more patterns.  Such coordination is part of the art of optimization, and can not easily be systematized.

Machine-dependent peepholes can be applied to arithmetic expressions (to consolidate instructions using complex address modes, for instance, or to eliminate redundant or unnecessary instructions).  However, one prefers to do as much as possible on machine-independent representations.

In particular, some kinds of RISC instruction scheduling are problems ideally suited to a peephole approach.  The reason is simple:  scheduling exists at a different level of abstraction from the parse tree or code list.  Scheduling issues become apparent only _after_ code is generated.  If scheduling is really difficult, one would create "scheduling data structures" that describe the problem at the highest possible level of abstraction.  Such data structures could only be created after preliminary code has been generated.  Maybe such an approach wouldn't really be called a peephole approach because it uses global data, but this is just a matter of terminology.
</t>
<t tx="ekr.20080529093004.334">The "Watergate test" (what does a compiler know and when does it know it?) ultimately determines what optimizations the compiler can and can not create.

As mentioned earlier, creating many small data structures can be done quickly using arenas.  Having the needed data is the key in reducing code complexity and in discovering patterns quickly.  Although only general statements can be made on this topic, the design of data structures is what is really important in a compiler, especially an optimizer.

</t>
<t tx="ekr.20080529093004.335">Parse trees and dags can be fully (or almost fully) target-independent.  A target-independent code list can be produced by traversing the parse tree.  This kind of code list is used in both LCC and GCC.   Using such a code list substantially simplifies early code generation.

Essentially all global optimizers can be expressed in machine-independent terms.  For instance, GCC performs global optimizations on the machine-independent RTL form of the program, which is essentially a linearization of the machine-independent parse tree.  Global optimizers need not interact with the rest of the program.  Their only effect is to modify the parse tree or code list.
</t>
<t tx="ekr.20080529093004.336">Register allocation should be separate from other parts of code generation.  As mentioned earlier, register allocation and code generation are related, but it is impractical to consider both simultaneously.  Even in a relatively simple compiler, intermixing register allocation throughout code generation was a mistake.  GCC uses a "graph coloring" algorithm to determine how to have a single register can share several temporaries.

Separating register allocation into a separate pass creates difficulties that must be handled by hacks like peepholes.  However, any alternatives to such a separation of concerns will be worse.  Theory is valuable here:  the general problem _is_ hard and no amount of cleverness is going to completely avoid special kludges.
</t>
<t tx="ekr.20080529093004.337">GCC uses macros to specify target machines, but this approach is dubious.  The problem is that a macro is essentially a piece of source code taken out of context.  Specifying what the macro does, including all interactions with all other macros, is difficult.  It might even be easier simply to rewrite one or more files than to figure out what complex and not-necessarily-well-documented macros really do.

LCC uses a machine-description language to generate pattern matching code automatically.  This approach may be more viable, yet it is not perfect either.  Like the code produced by YACC, the code or tables produced may be impossible to understand or to improve.

Retargeting a compiler exposes subtle assumptions present in the design of the parse tree or code list.  Changing the design of either the parse tree or code list will require changes throughout the compiler.
</t>
<t tx="ekr.20080529093004.338">Overview

Storage allocation is crucial to any compiler because of the number, size and complexity of data which must be allocated.  You would not be far off to say that a compiler consists of storage allocation and everything else.  Indeed, the design of CC2 was driven by the goal of creating the token list quickly, and that goal has far-reaching implications for how memory is allocated.

CC2 uses several forms of storage allocation, all based on objects.  Objects are created by m_new, defined in obj.c.  However, m_new should never be called directly--always create objects using the object macros defined in ekrlib.h.

CC2 allocates objects one-at-a-time (simple allocation), in blocks of fixed-sized objects (block allocation) or in blocks of variable-sized objects (stream allocation).  Simple allocation requires just a single macro call, but results in a call to calloc for each object allocated.  It is appropriate only for infrequently allocated data structures.  Block allocation and stream allocation are optimizations which reduce calls to calloc by more than an order of magnitude.

Recent Breakthroughs

I have recently made some discoveries concerning storage allocation and register allocation that promise to significantly improve CC2.  These discoveries were surprising because they seemed to contradict either common sense or conclusions based on performance measurements.

As an illustration of the effects of these discoveries, I have included a revised copy of tokenize.c.  As you will see, the new version of tokenize is much simpler conceptually than it's predecessor.  What is amazing to me is that the new code is significantly smaller and measurably faster than the old code!  These discoveries can be summarized as follows:

o The stream reservation macros, discussed at length in the documentation on storage allocation, can be made part of the stream put macros.  This eliminates the odious global constraints between the stream reservation and stream put macros.

o There is no speed penalty for having the stream reservation macros use a subroutine to allocate a new stream block.  This came as a shock, though the reason is clear in retrospect.

o Using global variables greatly simplifies how streams are defined.

o Streams are polymorphic: they may contain items of varying types.

o Streams are defined primarily by their lifetime and only secondarily by their type.

o Lists are special-purpose streams.

o Abbreviation macros highlight relationships among source text, while removing
the actual source text from view.
Block Allocation

Block allocation is done by allocating an item block, containing an avail count, a used count and an array of items.  Items are not objects!  Indeed, block allocation was invented so we don't have to call calloc for every item.  Currently, block allocation techniques are used to allocate hash table nodes in tokenize and to allocate HIDDEN_BIG_SKIP_TOK's in cpp.c.  Block allocation will be used extensively in the parser and code generator to allocate nodes for parsing, semantic analysis and code generation. 

At present, the code to allocate the next item from an item block is hand coded.  The hreserve_macro used in tokenize is a special-purpose block allocation macro.  A general-purpose macro or some other mechanism will be added in the future to make block allocation easier and less error-prone.

Stream Allocation

Stream allocation is done only in tokenize, though it may be used to generate code nodes later.  Steam allocation is crucial to making tokenize fast, but using stream allocation exacts a price in increased code complexity.  tokenize is like an Indy racer--both fast and finicky.

Stream allocation allocates a stream block, then adds variable-sized items to the block until the stream block is nearly full, at which time another stream block is allocated.  Steam blocks contain a stream avail count to keep track of what is in the stream.  The first unused portion of the stream block is calculated from the stream avail count.  The definition of nearly full depends on the individual stream.
Because stream allocation is tricky, the details are hidden by two sets of macros.  Stream reservation macros allocate another stream block when the current block is nearly full.  Stream put macros add an element to the stream without checking to see if the stream block is big enough to hold it.  I shall speak of stream put macros being protected by stream reservation macros.  Because of differences between streams, there are separate reservation and put macros for each distinct stream.

Every stream put macro must be protected.  That is, a stream reservation macro must be called before every call to any stream put macro.  Failure to do so will, under impossible-to-predict circumstances, over-write the stream block.  When using the debugging version of the compiler this error can be detected in two ways.  All stream reservation macros contain several ASSERT statements that will fail if a stream put macro over-writes the stream block.  Also, the object routines will detect the over-run buffer if tracing for the Sherlock obj_v tracepoint is enabled.  By the way, obj_v should be enabled whenever there is even a suspicion that some kind of pointer bug or other memory allocation error is present.

Alas, failure to protect a put macro will cause the production version of CC2 to crash--all ASSERT's and object checking are disabled in the production version of CC2.  The compiler will crash because over-running a block allocated by calloc will almost certainly cause either calloc or free to crash or loop.

While tokenize uses stream allocation for both tokens and streams, the details of stream allocation for tokens and streams differ substantially.
treserve_macro is the stream reservation macro for tokens.  put_id_tok, put_ptr_tok, put_val_tok and put_small_tok are the stream put macros for tokens.  Protect these put macros!  These macros are defined in tokens.h.

Tokens form a packed list--tokens usually follow one right after another.  Packing the list eliminates the need for a next token pointer and saves a lot of space.  At the end of a token block a HIDDEN_END_BLOCK_TOK is inserted so that the next token in the token list can be found.  Therefore, a token block is "almost full" when there is no longer room for an arbitrary token and a HIDDEN_END_BLOCK_TOK.

Tokens have a maximum size, BIG_TOKEN_SIZE.  Since HIDDEN_END_BLOCK_TOK is a big token, a token block is "almost full" when less than  2 * BIG_TOKEN_SIZE bytes remain.

It would be safer to put a call to treserve_macro inside the token put macros.  However, this would make tokenize much bigger.  Also, there are cases where the value of the token pointer returned by treserve_macro must be saved before the token put macro is called and this would be clumsy to do if treserve_macro were a part of the token put macros.

There is a call to treserve_macro at the start of the main loop in tokenize, just before the main switch.  The first put token macro to be executed in any case of the main switch need not be protected by a treserve_macro, since it is protected by the treserve_macro at the start of the loop. All other macro must be protected by treserve_macro!  All token put macros inside a loop inside an individual case must also be protected.

By the way, put macros must be protected even between calls to tokenize.  The token block may be almost full on entry to tokenize!  

Strings are handled very differently from tokens because strings may be arbitrarily large but are not part of a list.  sreserve_macro is the stream reservation macro for the string stream.  scopy_macro and big_scopy_macro are the put macros for the string stream.

Huge strings are strings larger than the size of the string space in a string block.  big_scopy_macro allocates string space for huge tokens, creating a block just big enough to hold the huge string.  Such a block does not contain  avail or used counts.  big_scopy_macro need not be protected since it always creates its own string block.  By the way, huge strings are seldom allocated now that multi-line comments are split into one COMMENT_TOK per line.

Normal strings, i.e., strings smaller than the size of a stream block, are allocated by the scopy_macro.  Each call to scopy_macro must be protected by sreserve_macro.  A string block is "almost full" when the next string to be allocated will not fit in the current block.  This wastes some space if the string to be allocated is large and the current block is almost empty but not empty enough.  Fortunately, large strings are rare so I have ignored this waste.

In short, everything will go well if you protect all stream put macros.  Everything will eventually fail (but maybe much later) if you don't.

The extra work involved in using stream reserve and put macros produces a spectacular increase in speed of tokenize.  Among the benefits:

o Crucial pointers may be allocated in registers throughout the lifetime of tokenize.  These registers are never unloaded because there are no function calls inside tokenize!

o The compiler is able to generate perfect code without doing any global optimization.  Local code optimization is sufficient to produce code as good as would be produced by an excellent assembly language coder.

o There are no get-next-character or put_next_token routines.  Earlier versions of tokenize, using such routines, ran more than 5 times slower than the present version.

o Storage is allocated in uniformly sized blocks, not in small pieces.  This keeps calloc happy.
By the way, I may make the size of all stream blocks 1024 bytes.  This should improve the performance of calloc still further.  However, such a change is a bit tricky:  Given the structure:

	struct foo {
		header fields;
		char space [STREAM_SPACE_SIZE]
	}

one has to compute STREAM_SPACE_SIZE without using sizeof(foo) !  This certainly can be done, but the solutions may make the code more brittle, and I am unwilling to do that.  Perhaps the best way is simply to compute STREAM_SPACE_SIZE by hand, then assert  sizeof(foo) == 1024 somewhere in the initialization code.

Saving and Restoring the Variables used by Tokenize

tokenize is called in a variety of contexts: to tokenize the main file, header files, pasted strings, and command-line #define's and #undef's.  Many calls to tokenize create short token lists so it would be very wasteful for tokenize to create new token and string blocks each time it was called.  Also, the hash table must be retained between calls so that all variables with the same spelling have the same pointer to the spelling table.  The global variables  tok_block_list, str_block_list and sym_hash_list are used to keep track of the current token, string and hash blocks, respectively.

The tok_copy, tok_copy_list and tok_copy2nl use the tok_block_list variable to access the current token block.  The token put macros in these routines must also be protected by treserve_macro!

The str_alloc_macro Macro

The compiler allocates strings for several purposes outside of tokenize.  Such strings could often be allocated in a string block, but that would be clumsy--the str_block_list global would have to be saved and restored and both the sreserve_macro and scopy_macro macros used.  All that to allocate a string?

The previous version of the object routines used the str_alloc family of subroutines.  The drawback to using these routines was that it was impossible to correctly specify the object tag because that tag had to be specified in the str_alloc subroutine itself.

It finally dawned on me that making str_alloc a macro would solve this problem.   The new str_alloc macros are defined in ekrlib.h.  These macros allocate a list object big enough to hold the list pointer and the actual string.  Nifty.

Why put strings on a list?  So they can be deallocated eventually.  This brings me to...

Deallocating Objects

The proper time to specify when an object will be deallocated is when the object if created!  Discovering this simple rule was a conceptual breakthrough and is directly responsible for the clean state of objects at the end of the compiler.

All object macros take a parameter specifying a deallocation list.  If the parameter is non-NULL, the allocation macro places the newly created object on the list.  Objects on deallocation lists are freed in the following places:

o  At the end of cpp.  All preprocessing objects not part of the token list are freed here.

o In comp_free_all.   Objects which are logically part of the token list may only be freed when the entire source file has been compiled.  comp_free_all is called at the start of compile in the production version of the compiler, and it is called at the end of compile in the debugging version.  In the debugging version we want to make sure that all objects are eventually freed.  In the pro-duction version, the objects used by the last compiled file need never be freed, a small time gain.

Objects are placed on no deallocation list in the following instances:
		
o Object are deallocated in the routine in which they are allocated.  This is seldom used, since most such objects can be allocated on the stack.  Variable-length objects could be freed in this way.
		
o The ap_first and ap_last arrays are allocated in mac_get_actuals but freed in mac_expand.

Debugging and Production Objects

Debugging objects and production objects are allocated, used and freed in exactly the same way.  However, debugging objects provide increased statistics and error-checking capabilities. Debugging objects are created by the object macros when the OBJ_DEBUG compile-time constant is defined.  Otherwise, production objects are created.

Debugging objects contain several fields not found in production objects:

o Lists fields:  All debugging objects are placed on lists.  These lists ensure that obj_free frees only objects.  These lists are also used to check the integrity of all objects.

o Statistics fields.

o Header and trailer protection fields.  These fields are filled with a fixed bit pattern when the object is allocated.  The fields are checked on request, and certainly when the object is freed.  This provides an excellent, though not foolproof, test for over-writing a buffer allocated by calloc.  Using these protection fields has found some bugs that otherwise would have been really tough to find.

Code Improvements

The latest version of the object routines protects all objects--the M_PROT bit is obsolete.  This greatly increases the protection offered by the object routines at a small extra cost.  Protecting all objects is only possible because so many items are block allocated or stream allocated.

The new object code allocates an object if the requested size is greater than zero.  Otherwise a type is created.  This convention greatly simplified the object macros in ekrlib.h.

A major conceptual advance in my understanding of objects was the invention of raw lists, i.e., lists of items not composed of objects.  Now lists can be created without making each node an object.  See the List Chapter for more details.
Improved Streams

The following sections described the new and improved streams.

Eliminating treserve_macro

Let's start with the infamous treserve_macro.  It was defined in tokens.h as follows:

/*
	Make sure enough space remains for the next token and
	allocate another token block if required.
			 
	Warning: a call to treserve_macro must be executed between any two
	calls to put_id_tok, put_val_tok, put_ptr_tok or put_small_tok
	(including calls between one invocation of tokenize to another).

	Failure to protect these macros with treserve_macro is a bug:
	ASSERT(tavail &gt;= BIG_TOKEN_SIZE) will fail, but rarely.
*/
#define treserve_macro(tp,tavail,twaste,tblocks,tentries,end_blocks)\
{\
	ASSERT(tavail &gt;= BIG_TOKEN_SIZE);\
	ASSERT(tok_block_list != NULL);\
	ASSERT(tp - (&amp;tok_block_list -&gt; token_space[0]) + tavail == TOKEN_BLOCK_SIZE);\
	if (tavail &lt; MAX_TOKEN_SIZE) {\
		token_block * new_block;\
		STATS(tblocks++; twaste += (tavail - BIG_TOKEN_SIZE));\
		tok_block_list -&gt; token_avail = tavail;\
		new_block = obj_new(&amp;token_t, sizeof(token_block), NULL, NULL, M_NULL);\
		lst_add(new_block, &amp;tok_block_list);\
		put_ptr_tok(tp,HIDDEN_END_BLOCK_TOK,\
			new_block -&gt; token_space,tavail,tentries,end_blocks);\
		tp = new_block -&gt; token_space; /* Only now can we change tp! */\
		tavail = TOKEN_BLOCK_SIZE;\
		tok_block_list -&gt; token_avail = TOKEN_BLOCK_SIZE;\
	}\
}

This macro is too large to include in each call to put_id_tok, put_small_tok, etc.  The reason the macro is so large is that I wanted to avoid a function call here. Similar kinds of function calls had grossly slowed down previous versions of tokenize.  However, I was surprised when measurements showed that a function call here does not matter at all!   So the new version of treserve_macro, called tok_protect_macro, is:

	#define tok_protect_macro(tp, tavail)\
	if (tavail &lt; MAX_TOKEN_SIZE) {\
		tp = tok_new_block(tp, tavail);\
		tavail = tok_avail;\
	}

The tok_new_block allocates a new token block, sets two global variables, tok_ptr and tok_avail and returns tok_ptr.

In retrospect, it is clear why a function call is acceptable here.  tok_new_block is called when a new block of tokens is required. An average token comprises almost exactly 4 characters and there are about 200 tokens per block so tok_new_block is called only about once every 800 input characters.  The function that had previously slowed down tokenize so much was called once every input character.  Clearly, the overhead of calling tok_new_block is 3 orders of magnitude smaller.

Because tok_protect_macro is so much smaller than treserve_macro, tok_protect_macro can be made part of the various stream put macros, such as put_small_tok:

#define put_small_tok(tp, tavail, tok, statistic)\
{\
	STATS(tok_number++; tok_smalls++; statistic++);\
	tok_protect_macro(tp, tavail);\
	*tp++ = tok; tavail--;\
}

Since tok_protect_macro is part of put_small_tok and all the other put_xxx_tok macros, it is clear that tok_protect_macro is called between every to calls to the put_xx_tok macros.  The global relationship between calls to treserve_macro and the put_xxx has been guaranteed.

This simplification would not be very significant if it only affected tokenize.  However, it created ripple effects...

Eliminating String Macros

Once I allowed myself to consider the possibility of using function calls when allocating objects, I turned my attention to sreserve_macro, sbig_copy_macro and scopy_macro.  The old version of tokenize had code to test whether a string was larger than could fit into a normal sized string space block.  For instance:

#define put_comment_string_macro()\
if (string_length &gt; MAX_STRING_SIZE) {\
	char * new_string;\
	\
	big_scopy_macro(new_string,string_start,string_length,sbigbufs);\
	treserve_macro(tp,tavail,twaste,tblocks,tentries,end_blocks);\
	put_ptr_tok(tp, WS_COMMENT_TOK, new_string, tavail,\
		tentries, comments);\
}\
else {\
	sreserve_macro(string_length,strp,savail,swaste,sblocks);\
	scopy_macro(string_start,string_length,strp,savail,sentries);\
	treserve_macro(tp, tavail, twaste, tblocks, tentries, end_blocks);\
	put_ptr_tok(tp, WS_COMMENT_TOK, string_start, tavail,\
			tentries, comments);\
}

In the new version of tokenize the put_comment_string_macro no longer exists--tokenize simply calls str_copy2block, which handles all the details:

	/* Output a comment string token */
	put_ptr(WS_COMMENT_TOK,
	str_copy2block(string_start, string_length), comments);

It was surprisingly difficult to see this optimization because the old sreserve_macro and scopy_macros allowed tokenize to keep in registers the current string space pointer and the current string space avail count.  I thought keeping those variables in registers was important.  I was wrong--it turns out that the string_start and string_length variables in tokenize are more important.

The new str_copy2block routine uses the str_ptr and str_avail globals to keep track of the string space with no ill effect.  More precisely, the slowdown of using str_ptr and str_avail rather than register variables was more than offset by freeing up a register in which to hold the string_start and string_length variables.
The definition of str_copy2block follows the old definition of sreserve_macro, but since it is not placed inline it can be more relaxed, i.e., space considerations are not important.

/*
	Copy a string into the string space after
	allocating the next string block if required.
*/
char *
str_copy2block(char * start, size_t length)
{
	FTAG("str_copy2block");
	register string_block * new_block;
	char * result;
	STATB(ftag);
	
	if (length &gt;= MAX_STRING_SIZE) {
		/* Allocate the new block at the *end* of the list. */
		obj_new_macro(new_block,
			sizeof(string_block) - STRING_BLOCK_SIZE + length + 1,
			"str big block", list_type, M_NULL, NULL);

		lst_append(new_block, &amp;str_block_list);
		
		/* Update the block parameters. */
		new_block -&gt; string_avail = 0;
		new_block -&gt; string_size = length+1;
		
		/* Copy the string to the string block. */
		result = &amp;(new_block -&gt; string_space [0]);
		memcpy(result, start, length);
		*(result + length) = '\0';
		
		/* Update the global block statistics. */
		STATS(str_blocks++; str_number++; str_bytes += (length+1));
	
		STATX(ftag);
		return result;
	}
	
		/* Make sure there is enough room in the string block. */
	if (str_avail &lt; length + 1) {

		/* Allocate a new block. */
		obj_new_macro(new_block, sizeof(string_block),
			"str block", list_type, M_NULL, &amp;str_block_list);
			
		new_block -&gt; string_avail = STRING_BLOCK_SIZE;
		new_block -&gt; string_size = STRING_BLOCK_SIZE;
		
		/* Update the statistics before str_avail changes. */
		STATS(str_blocks++; str_waste += str_avail);
		
		/* Set the global variables. */
		str_ptr = &amp;new_block -&gt; string_space [0];
		str_avail = STRING_BLOCK_SIZE;
	}
	
	/* Copy the string to the current block. */
	result = str_ptr;
	memcpy(str_ptr, start, length);
	*(result + length) = '\0';
	
	/* Update the global variables. */
	str_ptr   += (length + 1);
	str_avail -= (length + 1);
	
	/* Update the block count. */
	str_block_list -&gt; string_avail = str_avail;
	
	/* Update the global statistics. */
	STATS(str_number++; str_bytes += length+1);
	STATX(ftag);
	return result;
}
Creating str_copy2block had even more beneficial effects outside tokenize.  For instance, the old code in mac_stringize was:

	/*
		Allocate space in the string space.
		Be careful:  string_length could be huge.
	*/
	if (string_length &gt; MAX_STRING_SIZE) {
		long junk;
		/* Allocate an entirely new string block. */
		big_scopy_macro(result,buffer,string_length,junk);
	}
	else {
		char * strp;
		long savail;
		long junk;
		
		/* Restore the global string parameters. */
		savail = str_block_list -&gt; string_avail;
		strp = &amp;(str_block_list -&gt; string_space[STRING_BLOCK_SIZE-savail]);

		/* Create the string in a possibly new string block. */		
		sreserve_macro(string_length,strp,savail,junk,junk);
		result = buffer;
		scopy_macro(result,string_length,strp,savail,junk);
		
		/* Re-save the global string parameters. */
		str_block_list -&gt; string_avail = savail;
	}

The new code is:

	/* Allocate space in the string space. */
	result = str_copy2block(buffer, string_length);

Notice how the old code had to save and restore global variables.  The new code does not because those globals are managed by str_copy2block.

Simplifying the code to allocate strings was gratifying, but it would not be of great significance if it did not have further ripple effects...

Defining Streams

I began to see that global variables drastically simplify defining a stream.  Especially in the back end, streams are used across numerous functions so there is no possibility of keeping important stream variables in registers anyway.  This was an Aha--defining a stream involves defining a complex of global variables. 

For instance, the globals needed to define the string stream are:

	/* Globals describing the current string block. */

	string_block * str_block_list = NULL; /* List of string blocks. */
	long	 str_avail = 0;	/* Available bytes in current block. */
	char * str_ptr = NULL;	/* Pointer to first free byte. */

These variables are all controlled by str_copy2block, so they are benign.  In addition to these essential stream variables, it is useful to define global stream statistics:

	long	str_blocks;		/* Total allocated string blocks. */
	long	str_bytes;		/* Total bytes in strings. */
	long	str_number;		/* Number of strings. */
	long	str_waste;		/* Total wasted bytes. */

Since the string statistics are global they can be printed at any time.  In addition, they can accumulate since they need not be initialized at any particular place.

Global variables, if used in stylized ways, can simplify a program!  Once again, this Aha had an important ripple effect...

Streams Are Polymorphic

Once defining a stream became so easy I started to reconsider how streams are used and what they mean.  The old way of allocating items from blocks relied on having a special block for every kind of item.  For example a separate "skip block" exists to allocate skip nodes:

/* ----- Skipped Lines Info ----- */

struct skip_struct {
	token * skip_tp;    /* Skip pointer. */
	long    skip_lines; /* Number of skipped lines. */
};

#define SKIP_PER_BLOCK 20 /* Number of skip_node's per block. */

struct skip_block_struct {
	LIST;		/* Pointer to next block. */
	long		skip_avail;
	long		skip_used;
	skip_node	skip_items [SKIP_PER_BLOCK];
};
Actually allocating an item from such a block was clumsy.  This example is taken from code in cpp.c that still exists:

{			
	skip_node *		skip_p;
	skip_block *	block_p = skip_block_list;
				
	/* Block allocate a big skip node. */				
	if (block_p == NULL || block_p -&gt; skip_avail == 0) {
		obj_new_macro(block_p, sizeof(skip_block),
			"skip block", list_type, M_NULL, &amp;skip_block_list);
		block_p -&gt; skip_avail = SKIP_PER_BLOCK;
		block_p -&gt; skip_used  = 0;
	}
	skip_p = &amp;(block_p -&gt; skip_items[block_p -&gt; skip_used]);
	block_p -&gt; skip_avail--;
	block_p -&gt; skip_used++;
					
	skip_p -&gt; skip_lines = skipped_lines;
	skip_p -&gt; skip_tp = tp;
				
	/* Change the # to a big skip */
	tok_patch(skip_tp, HIDDEN_BIG_SKIP_TOK,
		skip_p, "skip multiple lines");
}	

This is a lot of work just to allocate another skip node!  There is a much better way.  If global variables are used to keep track of streams, it became clear that streams themselves have a global nature.  In addition, both the token stream and the string stream deals with variable size items, so it dawned on me that streams may be composed of a variety of different items.

This kind of rumination led to the following Aha--streams may contain different types of items!  What, then, determines which items go in which stream, if not the type of item that the stream contains? A stream is defined by its lifetime, i.e., when the whole stream is deallocated.

Looking back at the documentation on storage allocation, I am struck by the section called Deallocating Objects.  My subconscious was apparently telling me that when objects were deallocated was more important than I consciously realized at the time.  This section is not just describing how to free objects--it tells us how to define streams!

After all this, we are left with the following rule of thumb:

Streams may contain items of varying sizes and types as long as all items of a stream may be deallocated at the same time.

If we define the lifetime of an item as the point at which it is destroyed, the rule of thumb becomes:

Streams may contain items of varying sizes and types as long as all items of a stream have the same lifetime.

It is necessary, but not sufficient, that all the items of a stream have the same lifetime.  For instance, tokenize uses 3 streams, the string stream, the token stream and the hash node stream, even though all streams are deallocated at the same time.  Indeed the string stream and token stream are special purpose streams.  The string stream is treated specially because it can contain strings larger than the size of a normal stream block.  The token stream is treated specially because a HIDDEN_END_BLOCK_TOK must be added to the end of a block when the block becomes "nearly full."

Using Streams

Let us now simplify the code above that allocates the next item from a skip_block.  Since all items on skip_dealloc_list are freed in comp_free_all at the end of compile, these items can be allocated from a common stream that is freed at that time.  Call that stream the cs_ stream, the compile stream.  Create the following macros:

#define cs_protect(size) if (size &gt; cs_avail) { cs_new_block(); }

#define cs_put(p, size)\
	cs_protect(size);\
	p = cs_ptr;\
	cs_ptr += size;\
	cs_avail -= size;

Create the cs_ptr and cs_avail global variables just like the str_ptr and str_avail variables.  Also create statistics variables for the cs_ stream.

Finally, replace:
				
	{
		skip_node *		skip_p;
		skip_block *	block_p = skip_block_list;
				
		/* Block allocate a big skip node. */				
		if (block_p == NULL || block_p -&gt; skip_avail == 0) {
			obj_new_macro(block_p, sizeof(skip_block),
				"skip block", list_type, M_NULL, &amp;skip_block_list);
			block_p -&gt; skip_avail = SKIP_PER_BLOCK;
			block_p -&gt; skip_used  = 0;
		}
		skip_p = &amp;(block_p -&gt; skip_items[block_p -&gt; skip_used]);
		...
	}
	
by:

	{
		skip_node * skip_p;

		cs_put(skip_p, sizeof(skip_node));
		...
	}

Notice: cs_put, cs_protect and cs_new_block need only be written once, regardless of how many types of items the cs_ stream contains.  There is no need for different kinds of blocks and different code to support them!

Let's look ahead to the parser and code generator.  There will be a parser stream that contains all parse nodes and other nodes that will be freed at the same time as the parse tree.  The code stream will contain all code nodes.  Defining and using these streams will be trivial and will comprise essentially all the storage allocation for the back end!

The new storage allocation scheme also guarantees absolute highest storage allocation speed!  Indeed, allocating a new parse or code node will require only one function call per about 200 nodes, so the call-return overhead in calling cs_new_block can be ignored.  It is also clear that the other processing done by the cs_put macro can not be reduced further, even if written in assembly language.

I am thrilled by these discoveries.  They drastically reduce the design, coding and testing required to allocated and free objects.  And there is one more ripple effect...

Lists Are Streams

The front end of the compiler uses the LIST macro to define the "next" field in nodes.  This method is optimal for nodes that will be on exactly one list at a time.  Indeed, objects in the front end are on only one list, their deallocation list.  Sometimes the deallocation list does double duty, but the fact remains that each object appears on only one list.

Objects in the back end, however, may be on several lists simultaneously.  For instance, nodes in a parse tree may be threaded.  Many overlapping lists of symbols may need to be maintained.  To maintain these lists separate list nodes will be required.  These will be called cons nodes after LISP terminology.  The definition of a cons node will be something like:

	typedef struct cons_struct cons_node;

	struct const_struct {
		void * cons_next;
		void * cons_item;
	}
	
Thousands of such nodes will be needed throughout the back end.  Clearly, cons nodes should be allocated in list blocks to speed the storage allocation process.  The question is, when should list blocks be deallocated?  The surprising answer is: usually never.  In other words, cons nodes have permanent lifetime. Cons nodes will be allocated in a special purpose stream, the cons stream. The new_cons_node macro will be defined as follows:

	/* Point a at a new cons node. */
	#define new_cons_node(a)\
	{\
		if (cons_avail_list == NULL) {\
			cons_new_block();\
		}\
		a = cons_avail_list;\
		cons_avail_list = cons_avail_list -&gt; cons_next;\
	}

cons_new_block allocates a new block of cons_nodes and puts them on the avail list.   When an individual cons node is freed, it is simply added to a list of free cons nodes. Thus, in general list blocks will contain both free and used cons nodes.   cons_new_block is called only when no free cons nodes exist.  List blocks need never be deallocated because free cons nodes will eventually be reused--unless the number of cons nodes grows truly enormous, there should never be a need for garbage collection.

I said "usually never" above because there may be some instances when it is advantageous to deallocate all the cons nodes of a specialized stream at once to save time.  In that case, the cons nodes would be allocated using a specialized version of new_cons_node.
Are Objects Necessary?

Instead of allocating any object, we could simply allocate another item from an appropriate stream.  However, eliminating all objects in this way would be going to far.  The object routines provide detailed statistics about objects which are lost when items are allocated from blocks.  Also, the object routines provide important error checking for the stream blocks themselves.  Finally, it would be silly to have to allocate an entire stream when allocating an object once or twice is all that is needed.

Having said that, it seems to me that streams are a more fundamental implementation concept than objects.  All the fancy code in obj2.c seems to be overshadowed by the elegantly simple stream put macros.

Whatever the theoretical relationship between objects and streams, this storage allocation scheme seems perfect--items may be allocated simply and flexibly with minimal time or space overhead.  Streams can be created easily for special purposes.  Blocks can be of uniform size so that minimal stress is put on calloc.  Objects can be used instead of stream items during development for greater error detection and greater resolution of statistics.

Abbreviation Macros

One final Aha simplifies the appearance of tokenize.  Abbreviation macros formalize a relationship between source text that could not be efficiently expressed as a function call.  For instance, consider the macro:

	#define put_small(a,b) put_small_tok(tp, tavail, a, b)

The put_small macro shows clearly that all calls to put_small_tok in tokenize will have tp and tavail as parameters.  This relationship could be expressed as a function call, but not efficiently.

It would also be possible to simplify the appearance of tokenize simply by omitting the tp and tavail parameters from put_small_tok, but that would be a very bad idea.  In general, macros should be fully bound, i.e., all local variables used by these macros appear as binding arguments.  There is a subtle point here--the concept of abbreviation was difficult to discover precisely because I wanted all macros to be fully bound.  But abbreviation macros show the existence of binding parameters without using them.

Once I discovered how to use put_small to hide the constant details of the calls to put_small_tok, I was able to generalize the concept of abbreviation macros.  For instance, consider the next_number macro:

	#define next_number() { next(number_chars); string_length++;}

This abbreviation macro expresses the relationship between calls to next and string_length when scanning numbers.  Again, this relationship could be expressed as a function call, but not efficiently.
</t>
<t tx="ekr.20080529093004.339"></t>
<t tx="ekr.20080529093004.340">Add watch list to Sherlock

SL_WATCH(start, length) reports when the indicated memory block has changed.
The code to do this is very simple!

9/20/92 WEB replaces the preprocessor

To implement Donald Knuth's WEB documentation system, one would simply replace the Standard C preprocessor with a WEB preprocessor.  The tokenizer and parser would remain the same!

9/15/92 CC2 can generate functionalized operator code

o CC2 can generate code to simulate smart pointers in C++.
o CC2 can generate run-time checks.
o CC2 can generate the same kind of checks that can be done by defining operator functions in C++.
o CC2 can simulate the functionalizing style of programming.  Instead of defining:
		
	#ifdef PRODUCTION
		#define setp(a,b) (a) = (b)
	#else
		{check_ptr(#a,b); (a) = (b);}
	#endif
	
the compiler can do the pointer checking when it generates code!  This kind of trick can be extended to other situations and should make the generated code *much* safer.

11/14/92 Unions make copying nodes trivial

The advantage of using a union is most apparent when all fields of a union are about the same size so that little or no storage is wasted when copying the entire union.

2/9/92 bit fields should be abstracted

It is truly amazing how important this is: the source code is *much* cleaner and bits can be shifted from field to field without changing the source.
	
In particular, some fields turn out to be much more efficiently represented as a mutually-exclusive list of items rather than a bit field.  This makes the code *much* more compact.  This organization is used in tnodes and it is an important optimization.

12/28/92 List macros can be made type safe

This can be done by eliminating casts in the macros.  The key element in doing this was to define the TYPE_LIST and TYPE_LIST2 macros, which eliminate the void * in the old LIST and LIST2 macros.
	
The old macros joined and confused the notions of object and list.  They are, or should be, two separate entities.  The new macros eliminate the need for the lst_every family of macros.

01/28/93 Type expressions before folding them

This greatly simplifies the folding logic, since the proper type is now attached to all constants and no retyping needs to be done.</t>
<t tx="ekr.20080529093004.341">From a letter to Tuple dated 5/10/93

Another successful coding technique is descriptive programming, that is, the separation of what the code does from how it does iptive programming are the macros in nodes.h of the form x_is_y, x_set_y and x_clear_y.  Exit.  In CC2, the main agent of descriptive programming are the macros in nodes.h of the form x_is_y, x_set_y and x_clear_y.  Examples are a_is_temp, c_is_perm_label and s_clear_auto.  These macros implement virtual bits, as I described last year.  Other descriptive macros appear scattered throughout the code.

Virtual bits and descriptive programming are successful for at least seven reasons.  First, virtual bits can be assigned to different fields within a struct simply by changing the definitions of the macros that express the virtual bits.  No other source code needs to change.  This is a huge advantage--using virtual bits is much more flexible than using physical bits.  Second, virtual bits and related descriptive macros impose no unavoidable speed penalty.  Testing several physical bits at once can be done more quickly than testing two or more virtual bits, but this doesn't happen often, and when it does, a virtual bit field can be defined.  Third, using virtual bits and other descriptive macros makes the code less cluttered--virtual bits eliminate many -&gt; and . operators and essentially all &amp;, | and ~ operators.  Fourth, using virtual bits and other descriptive macros greatly decreases the possibility of making coding errors. It's much easier to get s_clear_extern(s_p) correct than to get

	(s_p -&gt; smods) | ~EXTERN_SMODS

correct.  Fifth, using virtual bits allows the code to express ideas in the problem domain directly.  This is very apparent in the files ct.c and ct_type2.  (Besides the macros defined in nodes.h, the ct_type2 routine makes heavy use of similar descriptive macros defined at the start of ct.c.)  Sixth, when using virtual bits and other descriptive macros, it is at all times obvious that the code is, in fact, actually expressing ideas related to the problem to be solved, rather than expressing housekeeping details.  This is an important psychological advantage in a large project.  Virtual bits helped keep my energy level high--I knew I was making real progress.  Seventh, descriptive programming is reassuring.  I know that regardless of what kinds of implementation strategies I use the calls to descriptive macros themselves will not need to change.  For someone as obsessive about implementation details and code speed as I am, this is a huge advantage.  I can concentrate on the higher-level tasks to be done, secure in the knowledge that I can change implementation details without modifying the calls to the descriptive macros themselves.

Actually, one could regard the entire organization of the file nodes.h as an embodiment of descriptive programming.  Each pnode represents or describes a distinct type of C-language statement.  Each snode describes a declaration and the corresponding identifier.  Each cnode describes a assembly language statement and each anode describes an address mode.  One could also regard nodes.h as defining classes in the C++ sense.  While these classes are not as robust in implementation as C++ classes, they serve much the same design function.
</t>
<t tx="ekr.20080529093004.342">This file records some insights gained while working on the parser.  These do not really belong in parser.doc because of their general nature.

Don't use unions to represent classes

There is no need to use unions to represent C++ classes!  Instead of using a union, represent a class by a struct containing only the common part of each subclass.  Without the dummy union, there are no dot operators and no need for macros to hide the casts and dot operators.  Notice how much cleaner nodes.h is now.

Multiple inheritance is easily represented by this scheme!    The only detail: if parents p1 and p2 share fields, then those fields must appear in a struct representing the common fields of p1 and p2.  There is no need for pointers to the parents of a class, even if there are more than one.

The project DB represents the outermost level of the symbol table

Creating the DB means writing the permanent part of symbol table to a disk file.  That's all!  The symbol table pulls in all parser nodes, spelling nodes and most strings in the string space.

CC2 can check itself
	
The code generators can be written to generate debugging code.  The code generators for operators can also generate code to library functions.  These library functions can simulate C++ style operators.  For instance, suppose in C++ that operator Op1 expands into a call to a function f1. To simulate this, modify the code generator in CC2 for Op1 to call a library function f2, and make f2 equivalent to f1.

This trick can simulate smart pointers, bounds checking and almost any other kind of run-time check!  For instance, pointer checking is done by having the code generators for the assignment operators call a library function which does the actual checking.

This can save a huge amount of hand coding.  For instance, the functionalizing style of programming would define and use the following macros
		
	#ifdef PRODUCTION
		#define setp(a,b) (a) = (b)
	#else
		#define setp(a,b) check_and_set_ptr(&amp;a, b)
	#endif

Rather than using these macros, the compiler's code generators can generate this code directly.

Initialize all pointers to NULL

As a matter of style, it is best to initialize all pointer variables to NULL even if the variable will be initialized in the code to a different value.  This practice allows a simple test for NULL to catch all uninitialized pointer errors.  Without such a redundant initialization to NULL, uninitialized pointers would almost never be NULL.
</t>
<t tx="ekr.20080529093004.343">Notes on Literate Programming

This document describes my experiments with literate programming, a programming method developed by Donald Knuth and described in the book by the same name.  This document assumes that you are familiar with the TEX typesetting system, the book, Literate programming, and the WEB system of structured documentation described in that book.

I was astounded by Knuth's productivity.  He claims to have designed the TEX typesetting program in a week and written the program in 45 days.  The program consists of about 550 typeset pages!  After leaving the program on the shelf for about 6 months, he debugged TEX in 18 days!

After getting over my initial feelings of shock and disbelief, I compiled the following list of the practices that Knuth used in developing TEX.

o He wrote the entire TEX program before testing any of it.  No stubs or temporary code were used because none were ever needed.
o He used the WEB system of structured documentation.  He says that programming in WEB gave him extreme confidence in his program before he tested or debugged it.
o He used desk check-out and informal proofs of correctness before debugging.
o He stepped through a program statement by statement using a debugger.  Once a section of code has been checked in this way, he skipped over it using breakpoints.
o He develops torture tests whose purpose was to show that the program did contain bugs.
o He logged and categorized each error.
o He spent about 6-8 hours each day debugging.
o He inserted code to verifying that data structures are consistent.

I spent several days designing and writing a simple, machine-independent variant of WEB called SWEB. The file sweb.w discusses SWEB.  The files sweave.w and stangle.w contain the SWeave and STangle programs, written in SWEB.  The file stangle.c is a hand translation of sweave.w into C.  Notice how quickly these programs were written.

The next two sections of this document discuss the pros and cons of using WEB.  The third section offers my conclusions regarding WEB.  To summarize that section: I do not believe using WEB would be a good idea in this project.  However, my experiences with WEB have improved my programming practice, perhaps greatly.  In addition, these experiences suggest that a simple tool to reformat C comments might be surprisingly useful.  The final section of this document examines Knuth's debugging and testing techniques.  It appears that these techniques will be of great value to this project.

The benefits of using WEB

When using SWEB I separated the process of writing comments from the task of formatting them.  I put each phrase or clause on a separate line and I ignored how the comment looked, assuming that the SWeave program would format the comment.

This was a surprisingly significant change--my writing and thinking flowed much more fluidly.
Apparently, even the small amount of attention involved in formatting comments distracted me significantly.  I wrote much faster once my attention was focused exclusively on writing, not formatting.  To a lesser extent, putting each separate part of a sentence on a separate line even speeded the process of revising individual sentences.

Knuth uses a style of comments that worked very well for me.  Knuth suggests using imperative sentences--what I call "cookbook style" for the names of SWEB modules.   For example, Print the first 100 primes.  This is the style of comments that I have used almost exclusively.  However, when writing documentation for a module, Knuth suggests using declarative sentences. For example, This program prints the first 100 primes using a method first suggested by Alfred E. Newman.

Using declarative sentences for the major comments encouraged a more relaxed, even breezy style.  This relaxation lead me to discuss issues at greater length and to consider more design issues.  Since I spent more time thinking about design issues, coding was easier and I suffered fewer false starts.  The SWEB style of comments encourages full and complete comments when new variables, data structures or algorithms are first introduced.

When I adapted this style to stangle.c I found that the first comments in a section, i.e., those comments corresponding to an SWEB module, would be written without indentation.  All other comments in a section would be indented to show their subordinate relationship to the main comment.  This indentation also is an improvement.

I believe that following Knuth's style of documentation will produce important improvements to my programming practice--the more I document the less confused I become.  I plan to follow a WEB-like method when writing design specifications, and perhaps when writing the first draft of a major new part of CC2.

The drawbacks of using WEB

At first I was enthusiastic about WEB (and SWEB).  I wrote,

WEB makes programming easier for several reasons, none of which really depend on the visual quality of the woven output.  First, WEB decouples the actual writing from the order that must later be imposed (by Tangle) on the source code. Second, pieces of code can be referred to by name without creating real functions. These pieces share any local variable of the calling environment so there is a bit of danger present. However, this danger is outweighed by the greater opportunity for abstraction in the source code.  Third, one can indicate the abstraction directly as one is writing.  Fourth, WEB contains build-in cross referencing facilities.

After writing the SWeave and STangle programs in SWEB some of my opinions about SWEB have changed.  Let's look at these four supposed advantages of WEB.

WEB allows code to be written in what Knuth calls "psychological order", rather than in a top-down or bottom up order.  However, I found this to more confusing than helpful. The notion that somehow a program is clearer if it is presented in some optimal order is dubious.  What really seems important is understanding the relationships between modules (i.e., .c files) and the constraints that must hold between functions.  Trying to create code in the right order is even more distracting than trying to format comments.  I prefer the order that I have always used: header files first, then data structures, then prototypes, then functions in alphabetical order.  Indeed this order makes modifying a file as painless as possible.

Second, WEB allows pieces of code to be referenced by name without creating real functions.  These code modules are really a more elegant way to create macros with no arguments.  There is value in creating such light weight abstractions when designing a program.  Alas, I found that creating modules could often be confusing and dangerous.  Using modules rather than functions is confusing because it is not clear from context how much space is taken up by a module.  If a long module is used in more than one place, much space is wasted.  This can be circumvented by defining the module to be a function call, but then nothing but extra complexity has been gained.
WEB modules are dangerous! All global variables in a module are unbound, that is, their meaning (binding) depends on context.  This is unacceptable. When calling a module one must always be aware that one is actually doing a macro substitution.  Again, this extra awareness was distracting and in some cases very confusing.  And using macros with unbound variables is bad style.

Perhaps Knuth has some mental discipline that allows him to create these modules without confusion.  I have studied several of his programs and have carefully read his discussions of literate programming looking for some clarifying principles.  I have not found them.

Clearly, WEB modules can be simulated in C using function calls or macros.  Using parameters to functions and macros to bind all variables is a plus, not a minus.

The third point is similar to the second: WEB allows one to indicate abstractions in a kind of stream-of-consciousness way.  This is an important plus, but it's real value is in suggesting abstractions in the first place.  Once clarifying abstractions have been recognized, they can be simulated easily using C language functions or macros.  WEB has more value in the design and prototyping phases than in the final coding phase.

Fourth, WEB contains build-in cross referencing facilities.  This is a nice feature, but it is by no means crucial.  Indeed, my style of naming functions and variables largely makes them self-indexing.  For instance, it is obvious that the variable err_line is defined in err.c.

There are other drawbacks to using WEB.  The development tools for the C language do not support WEB directly.  Any change to the original WEB program requires that the Tangle program be run first to convert the web to a tangled C program.  This adds an extra step to the edit-compile-test cycle.  Also, the output of Tangle is far less readable than a typical C program.  Symbolic debuggers will show the tangled C program, not the original web.

Still other drawbacks to using WEB are unique to the CC2 project.  Since CC2 is a compiler, writing any part of CC2 in WEB would require extra steps in the bootstrapping process needed to port CC2 to the target machine.  This bootstrapping process will be complex enough.  The last thing we need is to make it even more complex.  This drawback alone is probably sufficient to eliminate WEB as a candidate for use in CC2.

Conclusions about WEB

I have known of and been intrigued by WEB for about 5 years.  I am glad that I finally gave it a  substantial test.  One must use WEB to understand its benefits--reading about it is almost useless.

As I was writing this paper I finally got, I think, what Knuth is saying.  The real contribution made by the notion of literate programming is not in WEB's tools but in the notion of programming as a literary activity.  Of course!  Why didn't I see that before?  The Weave, Tangle and TEX tools are simply means to an end.  I focused so much attention on Knuth's tools that I lost track of the process those tools were meant to support.

Now for the promised conclusions.  First, it is clear that neither WEB nor SWEB is suitable for this project, for the reasons stated above.  However, using a more literary style of programming will have important benefits and I plan to examine adapt such a style immediately.  In thinking how my programming might have been different had I used a more literate style of programming, I am struck by how much work I have done writing separate documentation.  Had I incorporated that documentation into the code in the design and early coding phases I might have speeded up the coding and eliminated much of the later work on separate documentation.
In an earlier section of this paper I mentioned that writing comments went more smoothly and quickly when I wrote them without bothering with how they looked.  I was able to ignore the appearance of the comments because I assumed that another program would reformat them.  This suggests that a very simple utility program that would format long C comments might be of surprising benefit to C programmers.

Let's call this program CCF, for C Comment Formatter.  CCF would translate a C source file into an output file identical to the input file except for the appearance of comments.  The following options, all on by default, would control how CCF formats comments:

	+-multi-line	format only multi-line comments.
	+-@		      format only comments that start with /*@.
	+-table		do not reformat table lines concerning internal tabs.
	+-filter		change /*@ to /* after reformatting.

By default, only multi-line comments that start with /*@ would be reformatted.  Thus, CCF could be run several times over a source file and only the specially marked comments would be changed.  This convention also means that comments that have been hand formatted could be protected from reformatting.

The code for CCF would be similar to the code for SWeave.  However, CCF translates from C source to C source, while SWeave translates from WEB source to TEX source.  This is a crucial difference, because it means that 1) using CCF is always optional and 2) using CCF does not require using a foreign language such as WEB.

Finally, note that CCF need not actually exist to be useful!  Comments can be written in a more relaxed, literary style in the expectation that CCF will someday be written.  In the mean time,  important design work can continue, freed from the somewhat compulsive attention to the appearance of comments.  In this sense, CCF becomes a mental tool.

New testing and debugging strategies

While CC2 now parses all files of CC2 correctly, I still need to verify that all sections of the code have been executed by my test programs.  I can do this by setting a breakpoint on every instruction to be tested, then single stepping through the program, clearing breakpoints as I go along.  My debugger can remember breakpoints from run to run, so the instructions that still contain breakpoints have never been executed in any test program.

I would never have considered such a brute-force approach had it not worked so spectacularly well for Knuth.  This technique was virtually Knuth's only debugging method.  And I have a big advantage over Knuth--Sherlock makes it very easy to find the cause of a bug once the bug has been uncovered.  This testing plan is admirably suited to testing a compiler.  Indeed, the big challenge with testing a compiler is simply remembering or recording what has and has not been implemented and tested.

Knuth suggests using a Trap file, i.e., a file designed to show that the program under test does contain bugs.  He spent about 5 days developing a Trap file for the TEX system.  This file serves several purposes: 1) it uncovers bugs that might otherwise lie dormant for years, 2) it ensures that all statements of the program under test have been covered, 3) it forms a checklist ensuring that all features of the program have been tested and 4) it forms the smallest possible file usable for regression testing.  I plan to complete such a file in the next week.

These techniques should help produce a higher quality product more quickly.</t>
<t tx="ekr.20080529093004.344"></t>
<t tx="ekr.20080529093004.345">--- History and Design Goals

CC2 has a long history.  It d life almost 10 years ago as a "Little Implementation Lastarted life almost 10 years ago as a "Little Implementation Language" called C*.  I wrote an article about C* in Dr. Dobb's Journal.  Like P.J. Plauger, I eventually decided that there was no need for a more machine-oriented version of C, so I turned my attention to making C* a full C compiler.  In one of life's amazing coincidences, David Smead of Tuple contacted me about doing the very project I was already doing!

Why was I working on yet another C compiler, especially after a disastrous experience with Sherlock?  The reason is that all my programming life I've been interested in programming tools, and a compiler is really the ultimate tool.  Sherlock, RED (my first text , RED (my first text editor) and Sherlock can be seen as the disparate parts of an IDE.  In particular, I had thoughts of integrating Sherlock into the compiler.  Later, I toyed with the idea of replacing the preprocessor with Knuth's Tangle program (part of the literate programming system).  (You will find notes of this in one of the discovery sections.)  OWL is also part of this interest.

For reasons that I don't quite understand myself, I have always been fascinated with what makes programs run really fast.  Maybe it's just the challenge of it.  One of my first programs was a rewrite of a screen driver for a video board attached to a MITS 8080 computer.  The video board had hardware scroll registers--by disassembling and rewriting the inner loop of the scrolli of the scrolling registers I was able to more than double the rate of scrolling: it changed how one used the screen.

Later, I talked Leor Zolman into letting me see the 8080 source code of his BDS C compiler.  It was great:  he tokenized the source code _in place_ in RAM, an amazingly effective hack.  Most tokens were smaller than the source text they replaced, so that was no problem, but tokens for small identifiers were _longer_ than the source code they replaced, so the tokens "jiggled" in memory.   Leor told me he debugged and tuned the code by watching the front panel LED's!

Leor's code wasn't organized like in any compiler book you ever saw.  To this day, I think BDS C holds the world's speed record for C compilers, when normalized for processor speed.

When I moved to the Mac in 1986, I was very impressed with Think C, and wanted to see whether I could do better, so my original design goals were as follows:

1.  To produce a fairly simple C compiler as a test-bed for programming techniques.
2.  To produce a compiler at least as fast as Think C, and maybe faster in compilation speed.
3.  Since I was going to eventually compile CC2 using CC2 itself, to produce code good enough so that the running speed of CC2 would not suffer when compiled with itself.  Floating point had to be present, but it's speed would not affect the outcome.

These goals remained unchanged when I started to work for Tuple.  The closeness of my original project and Tuple's project was eerie.  In particular, there wasn't a lot of interest in doing any fancy optimization:  time to market was paramount.

Looking back, I made several mistakes in the organization of CC2, all with the same root cause: a overzealous concern with compilation speed.  As someone has said, "premature optimization is the root of all evil."  It certainly was with CC2.  What the statistics eventually taught me, of course only _after_ CC2 was producing code, was how fast creating and traversing in-memory data structures really is.  Had I understood this in my gut, the design of CC2 would have been different.

--- Overviiew of the front end

CC2 contains an integrated preprocessor, and I believe this is essential for any fast compiler.  The reason is that simply stepping across the characters of the source files turns out to be very time consuming.  Foy time consuming.  For sure you don't want to do it twice: once in the preprocessor and once in the compiler.  Also, file io is extremely expensive, so you don't want to create intermediate files.

--- Reading Input Files.

The compiler main line is the compile() function in the file CCcomp.c.  The heart of tokize is a large switch statement, with a case for every character that can start a token.  Again, stepping through the input buffer is very fast.

Tokens come in 2 sizes: 2-byte tokens for tokens such as '+' and 6-byte tokens for tokens containing pointers.  Because of token pasting and other weirdnesses, the spelling of _all_ 6-byte tokens must be retained.

Identifiers are hashed only once, in tokize(), and are never hashed again.  Identifiers tokens contain pointers to entries in a hashed spelling table.  Keywords are recognized during the second pass and converted to distinct tokeeeical and physical line numbers in synch.)

The first pass is handled in the function called compress() in file CCpass12.c.  This pass is handled in the function called compress().  Compress() is very fast because it steps through a _single_ buffer using two register pointers.  The buffer only shrinks, so the pointers never can trade places.

For the same reason, you want to tokenize the source code ASAP, so you only deal with tokens, not the characters that make up the tokens.  This is especially ng the directive (by inserting a HIDDEN_SKIP token) and creating entries in the macro symbol table.

b) Handling an #include directive involves deleting tokens comprising the directive, calling the read and tokenizing routines to create the tokens of the included file, and finally linking in the "included" tokens with HIDDEN_BEGIN_FILE and HIDDEN_END_FILE tokens.

c) Handling #if directives involves deleting the tokens of the directive, possibly evaluating a preprocessor expression, scanning over a range of tokens to be skipped, skipping the tokens by inserting a HIDDEN_SKIP token, and possibly updating a stack structure describing the skipping state of the preprocessor.

d) Handling a macro call involves scanning, parsing and skipping the tokens making up  re held in token blocks of a standard size.  If the next token would be too big to fit in the current token block, a HIDDEN_END_BLOCK token is inserted at the end of the block which points at a newly allocated block.

Most strings are held in standararndarthe macro call, expanding the call by creating a list of tokens, using the macro symbol table and the arguments, and linking in the expanded tokens at the place of the call using a HIDDEN_SKIP_TO_MACRO token.  The end of the macro expansion contains a HIDD so that the _original_ tokens can be scanned when reporting errors.  That's why, for instance, we have HIDDEN_SKIP_TO_MACRO tokens:  the error reporting routines print the macro _call_, not the macro expansion.  (The error reporting routines are far frooons.  This complicates the preprocessor because keywords must be treated like any other identifier token during preprocessor, for example, during macro expansion and token pasting.  However, the extra complication is hidden by a macro and the advantage o oom simple.)  BTW, errors are reported in context, with the two preceding and following lines also shown.

Anyway, the idea of cpp is simple:  we just stitch tokens in and out of the token list.  I consider that CC2 up to this pnt is essentially perfect.  I wouldn't change anything major here.  It's not possible to do this job faster than CC2 does, and here the speed is useful and has no harmful side effects.

There is one faintly humorous exception to this perfection:  keeping track of line numbers.  Newlines arise all over the place in various contexts.  

--- Tokenizing passes and token blocks.

CC2 tokenizes the source code in two passes.  The first pass uses Leor's trick of processing a buffer in place: it translates trigraph sequences and eliminates backslash-newlines.  (Actually, it removes the backslash part of a backslash-newline and moves the newline part to the following "plain" newline.

There are _lots_ of complications involving tokens, but they are hidden by macros.  See the files CCtokens.c and CCtokens.h, two of the most important files of the front end.

Errors can not be reported during tokenizing because there is not enough context to do so.  When an error is detected, an ERROR token is created.  The preprocessor issues an error message when it sees an ERROR token.

--- Preprocessing

After tokenizing the input buffer, compile() calls the preprocessor, cpp().  cpp() steps through token list, looking for something to do.  All preprocessing involves inserting, deleting, replacing or linking tokens:

a) Handling a #define directive involves deleting the tokens comprisirective involves deleting the tokens comprisiEN_SKIP token.  The details of ANSI macro expansion are horrendous, and they _are_ handled correctly. See the lengthy comments in file macro.c.  Literate programming would really have helped here.

b) We handle token pasting by brute force:  convert tokens back to strings, concatenate the strings, retokenize the string and link the new tokens back to their proper place.  Crude, but effective.

--- Parsing and the next_tok macro

compile() now calls the top level routine of a recursive-descent parser.  The output of the parser is a fairly typical parse tree, which I shall discuss in more detail in the next section.

The files CCdcl.c, CCpar.c, CCctype.c, CCexp.c, CCfold.c and CCst.c make up the parser.  par.ccs executable statement h parses executable statements. CCdcl.c parses declarations and calls the symbol table routines in CCst.c. CCexp.c parses expressions, CCctype.c attaches the correct type to an expression and CCfold.c folds constants.   There d.c folds constants.

--- The parse tree and other nodes

The heart of the expression routines is expr1() in CCexp.c, a supremely ugly state machine implementing operator precedence, whose only virtue is that there is no recursion, so it's not possible to crash the stack. However, that's a pretty feeble excuse for the code that's there... If I were to redo the parser, I would use some of Hanson's and Fraser's tricks, if only to make the code prettier.

The parse tree is made up of linked nodes, all defined in the file nodes.h.

CCnodes.h is the heart of CC2: if you understand this file you understand much of the compiler.  That being so, I will walk you through this file.  It would be best to be looking at the code while you read the descriptions.

The file starts by defining many "abbreviation macros."

The rest of the file is organized alphabetically by the name of the nodes being defined.

Anodes

The parser doesn't produce anodes, they insulate the rest of the code from details of representation.

reg_list_nodes nodes represent lists of spill_anodes to be saved and restored in functions.

The definition of anodes shows a technique used throughout nodes.h: virtual bits.  Rather than access bits directly, almost all bit fields are accessed via macros.  This has two benefits: it allows for reorganization without changing code outside nodes.h, and it allowed me to avoid bit fields: always a plus when bootstrapping a compiler.

There are several flavors of anode: the "base type" anode, const_anode, spill_anode and var_anode.  Stack variables and all temporaries anodes define the operand fields of instructions, that is, actual 68000 address modes.  The parser doesn't produce anodes, except those attached to snodes, all other anodes are represented by spill nodes. This makes it possible to change representations without creating new nodes when registers are spilled.

While we are discussing anodes, I'll discuss a technique that simplified the code generators: the notion of "freezing" sses of nodes. In effect, these define base classes from which subclasses can be derived.

Alas, this trick may be a bit too clever: it appears to violate Section 3.3 of the Standard, so maybe this file should be recast in terms of unions instead of relateAn anode representing a temporary is frozen, i.e., copied, at the time the instruction containing the anode is added to the code list.  This allows later spills to alter an existing anode with impunity.y.ter spills to alter an existing anode with impunity.ething like this is required because of the possibility of elided braces.  However, there are bugs in this area which I never got around to fixing:  Rather than having the rest of the compiler worry about elided braces, the parser should fully parenthesise

The code list consists entirely of cnodes.  cnodes represent code, i.e, individual machine instructions, pseudo ops or labels.  cinodes represent executable machine instructions, label_cnodes represent compiler-generated labels and ulabel_cnodes represent labels appearing in the source code (user labels).  Finally, line_cnodes represent assembly-language comments specifying line numbers and related C source (represented by a pointer into the token list).  Mark bits are used by the peephole.

enodes represent the operators and operands of expressions.  A cons_enode represents a comma operator.  It is used for its precedence.  const_enodes represent various kinds of constants, with their various representations.  op1_enode's, op2_enodes and op3_enodes represent unary, binary and ternary operators.  The code assumes in various places that these three operator nodes are prefixes of each other.  Finally, var_enodes represent variable names.

inodes represent initializers, and capture the actual braces used.  Somparenthesize the initializer.  I don't remember all the details.  I have notes somewhere about what needs to be done: all I remember is that the fix is uuuuuugly.

pnodes represent statements.   the code list.  s and p_line_count was an over_oppp_opover_opThe various flavors of pnodes should be self-explanatory, with perhaps the exception of block_nodes.  The block_regs and block_alloc fields are filled in by the register allocator, allowing local variables and temps to use the same register ato be shared aresent both symbols and the declarations which create them.  snodes also contain fields used only by the symbol table routines; as such, they do double duty as the buckets of the symbol table.

Everything known about a symbol ends up in an snode;  they are the heart of the parser.  Symbol nodes are created from declarations by dcl() and related routines. They are linked to spelling nodes by symbol table routine routines.  The "semantic fields" of an snode are used by the code generators.  See the c the ce comments in nodes.h for full details.

types are represented by trees of tnodes.  Each node represents either a primitive type or an aggregate type.  For example, the type: "array of pointers to ints" would be represent by three tnodes: one for the "array  of", one for the "pointer to" and one for the "int."  See the comments in nodes.h for more details.  The code that handles types traverses these type trees to determine type compatibility and to do type conversions.

In a more clever compiler the parse trree would have no machine-dependent information: that information would be added by the code generators in later passes.  As I mentioned previously, another important change I would make to the parse tree would be to make the dereferencing operator explicit: that would clarify what the code generators should do, thereby simplifying them.

--- Memory allocation and libraries

LIBmem.c implements the basics of lifetime allocation, but the actual lifetimes and atistics are defined in the application-specific fissociated statistics are defined in the application-specific files called CCmem.c and CCmem.h.
</t>
<t tx="ekr.20080529093004.346">Introduction

This documentation deals with the major parts of CPP, the C preprocessor.

1. User Options	              Command line arguments and #pragmas.
2. Tokenizing the Input File	  How compress1.c and tokenize.c create a token list.
3. CPP	                    How cpp.c processes preprocessor directives.
4. Macro Expansion	        How macro.c replaces macro calls by their replacement texts.
5. All about Tokens	        How token tables are defined and what tokens mean.
6. Storage Allocation	        How CC2 allocates and frees storage.
7. Error Handling and Debugging Improvements made to error and debugging code.
8. List Processing	        Improvements made to list processing utilities and macros.

I suggest reading the documentation in the order above.  Each chapter makes references to others and attempts to be as self-contained as possible.  Except for Chapter 1, each chapter discusses both design and implementation, with emphasis on details that will be important to a maintenance programmer.

Chapter 1 is the user manual for CPP.  Chapters 2, 3 and 4 discuss the various phases of the preprocessor.  Chapters 5 and 6 are the heart of the technical documentation.  Chapter 5 discusses at length the crucial token definition table, as well as details of what tokens actually mean and why they were designed the way they were.  Chapter 6 discusses the storage allocation strategies used to maximize the speed of tokenize.  Chapters 7 and 8 discuss improvements that greatly simplified and clarified the code.
</t>
<t tx="ekr.20080529093004.347">All About Tokens

Overview

Tokens are representations of syntactic entities: identifiers, comments, various kinds of strings and numeric constants, and other 'units' of the C language such as : , , -&gt;, &amp;&amp; etc. There are two kinds of tokens.  Small tokens consist only of a one-byte code (the token index).  These are used for simple tokens without additional structure.  Large tokens consist of a token index followed by a 4-byte pointer to other information.  For most large tokens, this other information is a pointer to the spelling of the token, i.e., a pointer to the characters that make up the token.  The ANSI Standard requires that this spelling be retained until very late in the pre-processing phase so that tokens may be pasted.  Error reporting also uses the spelling of tokens.

Tokens are the key to the speed of the Preprocessor--they allow a token to be skipped rapidly without examining the spelling of the token at all.  Since an average token represents about 10 characters of input, this results in at least an order of magnitude improvement over scanning letters.  In fact, much effort has gone into to making token scanning as fast as possible.  For more details, see the section below called Improving next_tok.

Tokens simplify preprocessing as well as making it faster.  In SPP's preprocessor, the input characters had to be reparsed in several contexts.  In CC2, this work is done only in tokenize.

Tokens are the backbone of the Preprocessor.  tokenize creates tokens, cpp patches the token lists for included files into the token list for the main program, cpp inserts tokens to skip preprocessor directives and conditionally excluded lines, and macro processing replaces the tokens comprising macro calls by the tokens for the macro expanded text.  Both cpp.c and macro.c insert hidden tokens into the token list.  Hidden tokens allow additional information to be added to the token list.  Other hidden tokens act like goto's, so that the next logical token need not be the next physical token.

Finally, the parser scans the tokens list to generate the parse tree.  The parser calls the next_parse_tok routine to return the next parse token.  next_parse_tok skips white space and hidden tokens and also performs string concatenation.  The parser converts numeric tokens to numbers using their spelling, as does eval, the preprocessing expression evaluator.  The token list is freed after the parse tree is generated and all errors reported.

The Token Information Table

If tokens are the backbone of the Preprocessor, the token information table, tok_info[],  is its heart.  This table is defined in tokens.c using the tok_info_struct structure and the en_tokens enumeration, both defined in tokens.h.  Please refer to the listings of both tokens.c and tokens.h while reading this documentation.  The fields of tok_info_struct are almost always referenced indirectly through various macros so I won't even mention what they are.
A token is simply a number, the token index, used to access a member of tok_info[].  The token index is defined by the en_token enumeration in tokens.h.  The position of each token in tok_info[] in tokens.c must match the position of the token in the en_tokens.  As described below, there is redundant information in tok_info[] so the tok_check routine (called during initialization) can detect if this requirement has been violated.

For each token, tok_info[] contains the token print name (used by tok_dump1 and the tok_name macro), the token size (used by tok_init to initialize tok_size_array, which in turn is used by the tok_size macro), the token attributes (used by various is_xxx macros like is_id), and the token index, the position of the token in tok_info[].  Obviously, the token index of tok_info[i] should be i, and this is the redundant condition the tok_check routine checks.

Every item in the token information table is crucial.  Not even token print names can be changed because they are used by tok_dump to produce the output requested by the +cpp option.   In particular, print names of tokens that start with KM_ (the preprocessor reserved words) must be exactly as given or the code that macro expands keywords such as __LINE__ will fail.  However, print names for hidden tokens (see below) are used only by the tok_name macro and could be any string.

Token attributes are single bits, with the exception of the token size attribute which is currently a field 4 bits wide.  The token attribute bits are defined in tokens.h in code following a comment which reads: Define the bits of t_attrib.  (t_attrib is one of the fields of tok_info_struct.)  Again, these bits are always referenced indirectly through macros defined in both tokens.h and tokens.c.

The tok_info array is defined using macros.  Here is a section of the definition of tok_info[] taken from tokens.c.

	other		(big,	"&lt;long tok&gt;",	LONG_TOK),
	binop		(	"||",			LOR_TOK),
	other		(big,	"(",			LPAREN_TOK),
	assnop	(	"&lt;&lt;=",		LSHIFT_ASSN_TOK),
	binop		(	"&lt;&lt;",			LSHIFT_TOK),

The first column (containing in this example 'other', 'binop' or 'assnop') is  the name of an token definition macro.  These macros are defined just before the start of the definition tok_info[].  The optional second column specifies token attributes.  Macros such as 'assnop' completely describe the token attributes, including token size, of a token.  For example, the assnop macro specifies various attributes and a token size of 1.  Other token definition macros need an additional argument to specify additional attributes.  In this example, the 'other' macro requires the 'big' argument (also a macro, of course) to specify the token's size.  The next column of macro arguments specifies the token print name and the last column specifies the (redundant) token index.  Besides being used by tok_check, the token index makes good documentation.

I am explaining this table in such great detail because every bit matters: any error in this table will cause a bug.  Make no changes in this table, or in the token definition macros or in the macros used by the token definition macros without careful thought.

The current definition of tok_info in tokens.c is much simpler than previous versions, due to improvements in the token definition macros.  This was made possible in part by eliminating several unneeded and confusing token attributes.

This simplification has created a conceptual Aha!  I see clearly now that the tok_info table is an excellent model for representing other kinds of information such as instruction formats.  Indeed, a p-code interpreter based on the model of tokens.h, tokens.c and the next_tok macro would take just hours to write.


Hidden and Visible Tokens

Understanding why tokens are visible or invisible is crucial to understanding the Preprocessor.  As I look back on my notes, I am amazed to see that I had no notion at first that hidden tokens would be useful, or so complicated.

o Some hidden tokens contain information the compiler uses to keep the line number and file number correct.  Examples:  HIDDEN_BEGIN_FILE_TOK, HIDDEN_END_FILE_TOK, HIDDEN_FILE_INFO_TOK, HIDDEN_LINE_ADJUST_TOK, HIDDEN_NL_IN_WS_TOK

o Other hidden tokens are used to alter the sequence of tokens.  Examples:  HIDDEN_END_BLOCK_TOK, HIDDEN_SKIP_TOK, HIDDEN_SKIP_DIRECTIVE_TOK, HIDDEN_SKIP_TO_MACRO_TOK.

o The HIDDEN_BIG_IGNORE_TOK and HIDDEN_SMALL_IGNORE_TOK are used to disable tokens (usually hidden tokens) when their purpose has been served.

I'll discuss these tokens in more detail later.

By definition, the next_tok macro returns the next visible token.  A hidden token is a token that is never returned from next_tok.  These definitions say nothing about the purpose of a hidden token.  This mismatch between how hidden tokens are used and how they are defined must always be kept firmly in mind.  While reading the code, remember:

o The next_tok macro returns the next visible token.
o The tok_next_raw function returns the next token, whether visible or hidden.
o The tok_skip_hidden function returns the current token if it visible, or the next visible token if the current function is hidden.

Consequently, if a token is hidden, tok_skip_hidden will handle it automatically whenever tok_next is called.  Therefore, it is advantageous to have as many tokens as possible be hidden so that the processing of these tokens can be handled in one place, namely in tok_skip_hidden.

By the way, the tok_copy_list and tok_copy2nl routines do not copy hidden tokens.  This is just one more battle in the eternal struggle to keep line numbers accurate.
Alas, not all tokens can be hidden!  The Preprocessor needs to see most tokens in order to recognize preprocessor directives, macros, etc.  A general rule of thumb: tokens that affect the parsing of preprocessor constructs in cpp.c and macro.c must be visible.  All other tokens must be hidden so as not to interfere with that parsing.  There are some exceptions to this rule of thumb, and they have caused problems.

The above rule of thumb explains why the tok_skip_hidden function does not update line numbers automatically--the WS_NL_TOK which represents newlines must be visible because cpp.c must see newlines in order to know where preprocessing directives end.  Since WS_NL_TOK is visible, it can not be handled in tok_skip_hidden.  Hence, cpp.c is sprinkled with err_line++ statements.

There is an additional complication.  Hidden tokens are often scanned by tok_skip_hidden in contexts in which it is inappropriate to process the additional data contained in the hidden tokens:

o When tokens are being dumped by the debugging routines.
o When tokens are rescanned, either during the parsing of macro calls or during macro expansion.

To handle this situations, tok_skip_hidden processes the information associated with hidden tokens only when the global tok_update_flag is TRUE.  The tok_update_flag is one of those Boolean variables I would like to do without.  Alas, it is a reflection of unavoidably messy details.  The tok_update_flag is set FALSE temporarily in several places in macro.c while source text is being rescanned.  It is saved, set to FALSE, then restored by the tok_dump family of routines.

One more crucial detail.  The BOUND_TOK is visible and it will be returned by next_tok.  However, BOUND_TOK exists only during macro expansion--it will never be seen outside the routines called by mac_outer_expand.  You could say that BOUND_TOK is visible but limited.

BOUND_TOK is conceptually the most important and most complicated token in the Preprocessor.  It represents a boundary beyond which macro expansion will be aborted.  (Bounded macro expansions are an explicit part of the ANSI C Standard.  Most macros are expanded in unbounded context, i.e., all tokens in the current source file are available during macro rescanning.  However, macro calls which are themselves part of the actual parameters of an outer macro call are bounded: only the text of the actual parameter is available during the rescanning process.)

Since BOUND_TOK is visible, the routines in macro.c can use the next_tok macro rather than the far more cumbersome tok_next_raw routine.  (You can never predict what the next raw token will be--it could always be a HIDDEN_END_BLOCK_TOK or other surprise.)  Realizing that BOUND_TOK could be visible because it could be eliminated before being passed outside mac_outer_expand was an important breakthrough.

As you have no doubt noticed, hidden macros all have names that start with HIDDEN_.  This has turned out to be a real benefit, because it means that loops like the following are obviously erroneous:

	while (*tp != HIDDEN_SKIP_TOK) {
		next_tok(tp);
	}
What Tokens Mean and How They are Used

The en_tokens enumeration in tokens.h contains a short description of every token. What follows is a longer description of the most interesting tokens.

	BOUND_TOK

This is the certainly the most important token in the Preprocessor, and the only visible token created outside of tokenize.  See the extensive discussion of BOUND_TOK above.

	END_PROG_TOK

This token is visible, unlike HIDDEN_END_FILE_TOK.  Making END_PROG_TOK was another Aha.  Actually, a strong case can be made that HIDDEN_END_FILE_TOK should be visible.  Indeed, preprocessor constructs should not be allowed to cross file boundaries.  The current code usually enforces this requirement by special checks.  There may be bugs here that no one will ever complain of.

	HIDDEN_BEGIN_RANGE

As the name indicates, this is not a real token.  It marks the beginning of the range of hidden tokens and its value is used by the very-important is_hidden macro.

	HIDDEN_BEGIN_FILE_TOK

This token is used to set the current file name (returned by err_fname) and to reset the current line number (in err_line) to zero.  It is created in tokenize using the fip parameter.  It is a big token whose pointer points to the new file name.

	HIDDEN_BIG_IGNORE_TOK

This token is used to zap big tokens.

	HIDDEN_BIG_SKIP_TOK

This token is generated by cpp.c when a range of lines is to be skipped as the result of an #if, #ifdef, #ifndef, #elif or #else directive.  It is cleverly generated in the main cpp loop.

	HIDDEN_END_BLOCK_TOK

This is a vital token, with important implications for memory management.  It is created by  treserve_macro whenever the current token block no longer contains room for a big macro and a HIDDEN_END_BLOCK_TOK.  Obviously, there must always be room for the HIDDEN_END_BLOCK_TOK itself, so if a call to treserve_macro does not separate calls to the macros that put tokens into token blocks a very hard-to-find bug will result.	HIDDEN_END_FILE_TOK

This is an unusual big token.  Unlike other big tokens, this token points to not to a string but to a file_info_node, defined in tokens.h.  This token allows both the file name and line number to be restored from one hidden token.  It is handled in lib_err_context and, of course, in skip_hidden.

In retrospect, the HIDDEN_END_FILE_TOK is a fairly dumb idea--there is no real need for the file_info_node.  All we need is two new tokens, say HIDDEN_END_FILE_NAME_TOK and HIDDEN_END_FILE_LINE_TOK, which would be used to restore the file name and line respectively.  That way the restored information would be held in the token space rather than in separate little file_info_nodes.  Memory management would be improved slightly and the code simplified.  However, the present code works and there is no needed to change it.  Warning: file_info_node's are logical part of the token list and must not be freed until all tokens are freed.

	HIDDEN_FILE_INFO_TOK

This token is generated as the result of the #line directive.  It too uses a file_info_node.  It too could be split into two tokens, thereby eliminating the need for the file_info_node.  It is handled in lib_err_context and tok_scan_file as well as in skip_hidden.

	HIDDEN_LINE_ADJUST_TOK

This is a vestigial token, not used in the current preprocessor.  However, cases to handle this token are still retained in tok_skip_hidden and tok_dump1.  It's purpose was to adjust line numbers after multi-line tokens.  It has been made moot by HIDDEN_NL_IN_COMMENT_TOK

	HIDDEN_NL_IN_COMMENT_TOK

This token represents a newline inside a comment.  It must not be visible!  Indeed, if it were visible weird but valid preprocessor directives such as

	#if 	/* comment
		*/ a == b

would not be handled properly.  (The newline in the comment must not end the directive.) This token is only generated if the full_ws command-line option is on.  It is used by lib_err_context and the related tok_scan_file and tok_scan_line routines.

	HIDDEN_SMALL_IGNORE_TOK

This token nullifies the effect of a small token.

	HIDDEN_SKIP_TOK

This token is used to stitch various lists of tokens together, especially during macro expansion.  Its pointer field points to the next logical token.	HIDDEN_SKIP_DIRECTIVE_TOK

The HIDDEN_SKIP_DIRECTIVE_TOK replaces the POUND_TOK that starts a preprocessor directive.  It points to the newline that ends the directive. lib_err_context knows that the tokens physically following this token form a preprocessor directive.  For example, the visible tokens created by tokenize for:

		#define a 125

would be the following:

		POUND_TOK(0)
		ID_TOK("define")
		WS_TOK
		ID_TOK("a")
		WS_TOK
		NT_TOK(125)
		WS_NL_TOK

 (values in parentheses represent pointer fields of big tokens.)

The cpp_define routine coverts this to:

		HIDDEN_SKIP_DIRECTIVE_TOK(target)
		ID_TOK("define")
		WS_TOK
		ID_TOK("a")
		WS_TOK
		INT_TOK(125)
target:	WS_NL_TOK

where target is the address of the WS_NL_TOK

This example shows that next_tok macro will skip from the HIDDEN_SKIP_DIRECTIVE_TOK directly to the WS_NL_TOK.  However, the original tokens still remain for lib_err_context, marked by the HIDDEN_SKIP_DIRECTIVE_TOK.  Note: lib_err_context prints the HIDDEN_SKIP_DIRECTIVE_TOK as a '#'!

Clearly, POUND_TOK must be a big token because the HIDDEN_SKIP_DIRECTIVE_TOK which replaces it is big. 	HIDDEN_SKIP_TO_MACRO_TOK

This is another special purpose skip token.  cpp replaces macro identifiers with this token.  The token after this will be a IDX_TOK whose pointer field is the same as the pointer field replaced by the  HIDDEN_SKIP_TO_MACRO_TOK.  So given the following macro definition and call

	#define a 25
	a b

tokenize will create:

		POUND_TOK(0)
		ID_TOK("define")
		WS_TOK
		ID_TOK("a")
		WS_TOK
		INT_TOK(25)
		WS_NL_TOK
		ID_TOK("a")
		WS_TOK
		ID_TOK("b")
		WS_NL_TOK

and the macro expansion logic in macro.c will create:

		HIDDEN_SKIP_DIRECTIVE_TOK(target1)
		ID_TOK("define")
		WS_TOK
		ID_TOK("a")
		WS_TOK
		INT_TOK(25)
target1:	WS_NL_TOK
		HIDDEN_SKIP_TO_MACRO_TOK(target3)
		WS_TOK
		ID_TOK("b")
		WS_NL_TOK
target2:	...rest of token list

target3:	IDX_TOK("a")
		INT_TOK(25)
		HIDDEN_SKIP_TOK(target2)

Notice the hack:  in effect, the IDX_TOK("a") becomes an extension of the HIDDEN_SKIP_TO_MACRO_TOK.  tok_skip_hidden, tok_next_raw, lib_err_context and tok_dump_line2 must be aware of the meaning of the IDX_TOK which is essentially hidden.  (I should have used a hidden token rather than an IDX_TOK, but it doesn't really matter--the IDX_TOK is never seen where it would matter.)  Why all this fuss?  So lib_err_context can print the original macro call rather than the expanded text.

The tokens following target3 are allocated at the end of the current token block (by tok_copy and tok_copy_list) and stitched into the main token list as shown.  The details of how the replacement tokens are created do not concern us here, but one thing is certain, they are not just copied from the preceding #define statement!

	HIDDEN_END_RANGE

Just like HIDDEN_BEGIN_RANGE, this is not a token.  It marks the end of the range of hidden tokens.  It's probably not used at all, although it might appear in some ASSERT or other.

	POUND_TOK

cpp convert POUND_TOK into HIDDEN_BIG_SKIP_TOK, which is the reason it must be a big token even though its pointer is never used.

	
Improving next_tok

The next_tok macro is defined as follows:

	#define next_tok(tp)\
	{\
		if (!is_hidden(*tp)) tp += tok_size(*tp);\
		if (is_hidden(*tp)) tp = tok_skip_hidden(tp);\
	}

It is vital that this macro be both as fast as possible and as compact as possible.  For that reason, the hidden tokens are all defined at the end of tok_info.  This allows the is_hidden macro to be defined as 

	#define is_hidden(n)	(n &gt; HIDDEN_BEGIN_RANGE)

rather than 

	#define is_hidden(n)	(tok_attr(n) &amp; hidden_bits)

as it used to be.  I was amazed to see how much code the second form takes: it's more than twice as big and twice as slow as the first.

As mentioned in the overview section, the tok_size macro has also been made substantially faster.  Rather than have tok_size delve into the tok_info array, the tok_size macro accesses tok_size_array.  This eliminates masking, shifting and multiplication.

In general, accessing attribute bits is very slow and should be reserved for infrequently used operations.
</t>
<t tx="ekr.20080529093004.348">Tokenizing the Input File

Overview

Input files are tokenized in two passes. First, compress1 deletes trigraphs and backslash newline combinations.  (See the discussion of trigraphs in the Chapter called User Options.) Second tokenize converts this compressed input buffer into a list of tokens.  Tokens reside in the token space, composed of token blocks.  Tokens contain pointers to strings residing in the string space, composed of string blocks.  Identifiers are hashed and entered into the spelling table.  This is the only hashing done in the whole compiler.

Tokenize is called by compile, cpp_incl2 and mac_define-string to tokenize outer-level files, included files and command-line #define statements respectively.  compress1 need not be called when tokenize is called from mac_define_string.


Compressing the Input File

Several coding details significantly speed up compress1.  As a result, compress1 takes less than 5% of the execution time of CC2.
		
o compress1 uses a single continuous buffer for both input and output.  Since the buffer is continuous, two register pointers are all that are needed to keep step through the buffers.  There is no need for very expensive get_next_character and put_next_character subroutines.  compress1 never lengthens the input buffer so it can create the output buffer in place by overwriting the input buffer.  This is also a very significant optimization.
		
o compress1 checks for end-of-file only after a newline character because the caller of compress1 is required to end the input buffer with a newline.  This trick saves about 25% of the tests that have to be made in compress1.

Tokenize is Fast

Tokenize really does need to be as fast as possible: it accounts for about 20% of the execution time of the front end of the compiler.  I used several tricks to speed up tokenize and their cumulative effect is remarkable--the current version of tokenize is more then 5 times faster than earlier versions.
		
o Most importantly, tokenize uses the same continuous input buffer created by compress1.  Tokenize can step through this buffer without checking for end-of-block after each character.  This saves a huge amount of time.

o Tokenize is written in "assembly language style."  Pointer arithmetic is used instead of array subscripting.  Explicit cases are used for identifiers and numbers instead of  isalnum or isnum macros.  All important pointers are in registers.  No registers need to saved and restored across function calls because there are no function calls in the main tokenize loop.  The result of this style is that the code generated by the Think C compiler for tokenize is identical to what a good assembly language programmer would create.
		
o Tokenize allocates the token space and strings space in blocks.  Token blocks hold about 200 tokens and string blocks hold about 30 strings, so the cost of allocating storage is sharply reduced.

The chapter called Storage Allocation discusses token and string blocks in great detail. A great deal of effort was required so that tokenize can allocate space for tokens and strings quickly.

The String Space

The string space contains the spellings of all identifiers, strings, character constants and numbers (and comments if the full_ws command-line option is in effect).  Spellings of numbers and character constants must be retained due to rules of macro expansion.
		
The format of the string space is defined by the scopy_macro and big_scopy_macro macros defined in tokens.h.  At present the string space consists only of strings, terminated as usual with a null character.  At one time strings were preceded by a length byte, so that given a pointer p to a string s in the string space, the length of s was *(p-1).

The Spelling Table

The spelling table makes CC2 very fast.  Two identifiers have the same spelling if and only if they have the same spelling table pointer.  This fact eliminates the need for any calls to strcmp in the entire back end of the compiler!  Only the spelling table is needed for macro processing.
		
It's best to have tokenize create the spelling table.  Indeed, tokenize has to scan identifiers anyway, so creating the spelling table at the same time saves a surprising amount of time.  Also, identifier tokens contain pointers into the spelling table, so conceptually the spelling table is part of the token list.
		
The spelling table is not the symbol table needed by the parser and code generators: there may be several symbols with the same spelling, either in different files, different functions or even in different name spaces within the same block.  For instance, it is possible to have a label, a variable, a field in a struct or union all with the same spelling.  Thus, for any particular spelling, there may be a list of symbols and associated C language objects hung off the spelling table entry.

The spelling table is initialized with all reserved words needed by the compiler. The spell_token field of the spelling node contains the token that will be returned by the parse_next routine when and if the token survives macro expansion.  Recall that macro definitions such as:

	#define char a

are perfectly legal.Initializing the hash table with reserved words is an outstanding optimization.  Why?  Because there is no need to recognize reserved words!  The parse_next routine will simply do:

	if (is_id(*tp)) {
		token = (id_tok_ptr(tp)) -&gt; spell_token;
	}

That's all.  No need for any lookup at all.  Goodbye minimal perfect hash functions!
		
Code Changes

Many changes were made so that tokenize can be called in various contexts.  New global variables and save and restore macros make communication with other routines possible.  These macros and global variables are defined in tokens.h and tokens.c. The tok_copy, tok_copy_list and tok_copy2nl routines use these save and restore macros to create new tokens in the current token space.  In effect, tok_copy, tok_copy_list and tok_copy2nl are extensions of tokenize.

The tok_lookup and tok_lookup_hash routines are new.  They are slower than inline code, so are not used in the main loop of tokenize.  tok_lookup_hash is called by cpp to look up file names during #include processing.
		
The parsing of comments and white space was greatly simplified.  Multi-line comments are split into COMMENT_TOK's separated by HIDDEN_NL_IN_COMMENT_TOK's.  This makes error reporting much simpler since lib_err_context does not have to unpack multi-line comments.  Slightly more string space is required, but not enough to make a difference.
		
The full_ws command-line option now controls whether full white space is retained. Retaining white space makes error messages more understandable but requires more storage for the string space.  The old CC2_FULL_WS compile-time constant has been eliminated along with all the conditionally compiled code depending on it.

Tokenize no longer reports errors directly.  Instead, tokenize encodes error messages in ERROR_MESSAGE_TOK's for later printing by cpp.  That way, the error logic in lib_err_context has the full tokenized input available.  tokenize creates other tokens to hold erroneous strings which are printed in their original, erroneous, form by lib_err_context.  See the chapter on Error Processing and Debugging for more details.
</t>
<t tx="ekr.20080529093004.349">Macro Expansion

The code in macro.c looks deceptively simple.  In fact,  it is complicated because of the quirky nature of macro expansion mandated by the ANSI C Standard.  The Standard is far more clear, precise and well-thought-out than K&amp;R, but that same precision and detail makes implementing macro expansion challenging.  In particular, consider the following sections.

Section 3.8.3.4 Rescanning and Further Replacement

"After all parameters in the replacement list have been substituted, the resulting preprocessing token sequence is rescanned with all subsequent tokens of the source file for more macro names to replace.

If the name of the macro being replaced is found during this scan of the replacement list (not including the rest of the source file's preprocessing tokens), it is not replaced.  Further, if any nested replacements encounter the name of the macro being replaced, it is not replaced.  These nonreplaced macro name preprocessing tokens are no longer available for further replacement even if they are later (re)examined in contexts in which that macro name preprocessing token would otherwise have been replaced."  (End of Section 3.8.3.4)

Section 3.8.3.1 Argument Substitution

"After arguments for the invocation of a function-like macro have been identified, argument substitution takes place...Before being substituted, each argument's preprocessing tokens are completely replaced as if they formed the rest of the translation unit; no other preprocessing tokens are available."  (End of Section 3.8.3.1)

By the way, a function-like macro is simply a macro with arguments.

Let's look at some of the subtleties arising from these and other sections.

1.  Argument substitution takes place before rescanning, so both f's are expanded in a call such as

	#define f(a) start a finish
	f(f(2))

The result would be

	start start 2 finish finish

2.  Macro substitution for macro arguments is bounded, while rescanning of macros is unbounded, i.e., all tokens in the source file following the macro are available.  For instance:

	#define a  b (
	#define b(c) c + 2
	a this is a test of boundedness )
	

The macro a is expanded to

	b (

and the rescanning of b includes the rest of the source file, so the call to b is:

	b ( this is a test of boundedness )

and the final result is:

	this is a test of boundedness + 2

3.  It is not an error for a macro bound to thwart the expansion of a macro.  For example, the following is a valid macro call:

	#define f(a) 2+a
	f(f)(a)

and the result is:

	2+f(a)

The expansion of the inner f is thwarted by the bound.  Once the argument is completely macro replaced (yielding 2+f), the f will never be macro expanded again, even if the (a) is seen during the rescanning phase.

Most of the examples in macro_test.c were token from pages 92 and 93 of The Standard.  These examples illustrate the full complexity of macro expansion.
Code Notes

Making macro expansion boundaries explicit and visible was a breakthrough.  This took several forms:

o Explicit bound parameters to mac_rescan and mac_substitute.
o The ap_last parameters to mac_get_actuals, mac_parse_actuals, mac_paste_tokens, mac_stringize and mac_substitute.
o Making the BOUND_TOK visible with a lifetime restricted to the life of mac_outer_expand.  See the discussion of BOUND_TOK in the chapter called All About Tokens.

By far the most difficult part of macro expansion is finding out which macros must be disabled.  This involves figuring out when to stop rescanning the replacement text. The second breakthrough was rescanning in a single place, mac_rescan.  While this is a brute-force approach, it allows me to clarify the context of various recursive operations.

The key to understanding macro expansion is to understand macro expansion boundaries.  These comments give some hints.  The extensive comments in macro.c may provide more hints.  Only immersion in C Standard and the code itself will provide real understanding.

Defining Macros from the Command Line

Macros can be defined using the -d command-line option and undefined using the -u command-line option.  The mst3.c module handles these operations. It is a new and happy invention.

The key hack is that mac_define_string creates a dummy input file, then calls tokenize to create tokens, then calls cpp_define to define the the macro from those tokens.  While this is a bit slow, it keeps the main line of cpp very fast.  mst3.c does not have to worry about speed, since only a few command-line arguments are created in any program.

Most of mst3.c is mundane.  It keeps track of the command-line options from one file to the next.  Some, but not all options are retained from file to file.
</t>
<t tx="ekr.20080529093004.350">The C Preprocessor

Overview

The file cpp.c contains the main line of the C preprocessor.  The main function of cpp.c is also called cpp.  In this chapter, cpp will refer to the code in cpp.c, either the cpp function itself or the code called by cpp.

cpp creates a token list with the following properties:
		
o Line numbers can be recreated.
o Both the original source text and the macro expanded text may be recovered at will.
o Preprocessor directives are replaced by a HIDDEN_SKIP_TOK the following newline.
o Lines conditionally skipped as the result of #if's #ifdef's, #ifndefs, #else's and #elif's are replaced by a HIDDEN_BIG_SKIP_TOK to the newline following the range of lines.
				
The most clever code in cpp is the code that rearranges the token list to handle skipped lines, skipped directives and lists of tokens created from included files and macro expansion.  See the Chapter called All About Tokens for full details.
		
Much of the code is similar to the corresponding code in SPP.  However, this version is much faster than the old code since cpp deals with tokens instead of individual characters.  In particular, skip_lines is very fast, as it should be.

cpp fixes a bug that existed (and still exists) in SPP.  SPP allows more than one #elif section can be included in the range of any particular #if, #ifdef or #ifndef!  If an #elif has already been included, the value of the expression in the #elif should be ignored--we should simply skip to the proper #endif.  The fix involved adding the skip_all_flag to skip_lines.

The #include logic is extensive and allows one to simulate the performance of a compiler in an integrated environment.  The -s2 command-line option tells cpp in which directory to look for a file.  This saves a lot of time.
	Code Details

Tokenize has already implicitly recognized the preprocessor directives, so cpp only needs to switch to the proper directive.  Clearly, this is the fastest method possible.  Indeed, the essential part of cpp is the following code:

	else if (is_ppkey(c)) {

		switch(c) {
		case K_DEFINE:	tp = mac_define(tp, FALSE);	break;
		case K_ELIF:	tp = cpp_elif(tp);		break;
		case K_ELSE:	tp = cpp_else(tp);		break;
		case K_ENDIF:	tp = cpp_endif(tp);		break;
		case K_ERROR:	cpp_error(tp);			break;
		case K_IF:		tp = cpp_if(tp);			break;	
		case K_IFDEF:	tp = cpp_ifdef(tp, TRUE);	break;
		case K_IFNDEF:	tp = cpp_ifdef(tp, FALSE);	break;	
		case K_INCLUDE:	start_line = -1;
					tp = cpp_include(tp);		break;	
		case K_LINE:	start_line = -1;
					tp = cpp_line(tp);		break;		
		case K_PRAGMA:	tp = cpp_pragma(tp);		break;
		case K_UNDEF:	tp = cpp_undef(tp);		break;					default:
			fatal(
				es("Unrecognized token in preprocessor directive: ");
				tok_dump1(tp, TRUE, FALSE); enl();
			);
		}
	}
				
cpp encourages the compiler to generate a table jump for this switch statement by defining the values of the K_ constants to be in an unbroken range.  Indeed, the Think C compiler does so.

Stitching include files and ignoring already-processed preprocessor directives is handled by the patch code soon after the above code:
		
	if (skipped_lines == 0) {
		*skip_tp = SKIP_TOK;
		patch_ptr_tok(skip_tp, tp);
	}
	else {
					
		*skip_tp = BIG_SKIP_TOK;
						
		/* Block allocate the next skip node. */		
		....code omitted...
		
		patch_ptr_tok(skip_tp, skip_p);
	}
</t>
<t tx="ekr.20080529093004.351">Error Handling and Debugging

Reporting the Context of Errors

Error reporting is tricky.  When an error is found two lines of error message are printed and then the error context, 2 lines preceding the erroneous line, the erroneous line itself marked by an asterisk, and 2 more lines.  An example of an error message is:

	  error: line:  144     mst3.c ()           
	macro warning expects 1 argument.

	 142: 
	 143:     if (str_eq(arg, "defined")) {
	 144*         warning(); es("Can not re-define "); es(arg); enl();
	 145:         return;
	 146:     }

The err_line_offset variable keeps track of the difference between the line number as seen by tok_scan_line and the line number that is set by the #line directive.  lib_err_context adjusts the display as required by err_line_offset.  The err_line_offset variable makes it possible to make tok_scan_line very simple.

New Error Reporting Macros

The error message above was produced by an error macro like this:

	error(
		es("macro "); es(macro_name);
		es("expects "); es(expected_nargs);
		es(" argument"); es(expected_nargs ? "s" : "");
	);

The definitions of the fatal, warning, error and help macros have been changed and are much more flexible than before.  They are defined as follows:

	#define error(stat)	{error_begin(); stat; lib_err_context(); }
	#define fatal(stat)	{fatal_begin(); stat; fatal_end(); }
	#define help(stat)	{help_begin(); stat; lib_err_context(); }
	#define warning(stat)	{warn_begin(); stat; lib_err_context(); }

error_begin prints the first two lines.  lib_err_context prints the closing period and newline and then prints the 5 lines of context.  The number of lines is a variable, although at present there is no way for the user to set it. 
lib_err_context calls tok_scan_file and tok_scan_line to scan through the token list to find the right line of the right file.  Getting these routines working required some changes to the token list.  In particular, the HIDDEN_SKIP_DIRECTIVE_TOK and HIDDEN_SKIP_TO_MACRO_TOK tokens allow the tok_scan routines to distinguish what lies "behind" a skip.  The error reporting routines do not follow these skip tokens, they bypass them.  This allows the error reporting code to print directives and the original (not expanded) calls to macros.

Deferred Error Reporting

tokenize can not report errors using the error macro because lib_err_context needs a complete list of tokens!  Instead tokenize creates error tokens representing an error message to be printed later.  The ERROR_MESSAGE_TOK points to the text of error message.  Other tokens, whose names start with PARTIAL_, contain pointers to the text of partial tokens resulting from various kinds of run-on strings, i.e., strings that are missing their final delimiter.  These tokens allow lib_err_context to print the original, erroneous, form of the tokens.   cpp actually prints the error message using a simple call to the error macro.  It's a nice clean hack.

Improvements to Sherlock

The sl_callname() routine supplies the name of  function 0 levels back.  Inventing this routine was a major breakthrough: now fatal error messages automatically supply the calling context of the bomb.

Tracepoint names may now start with -.  Such tracepoints are enabled only if explicitly mentioned: They are not enabled by ++* or other wildcards.

debug.h

The ASSERT_TRACE macro is new.  The fatal macro is called if the assertion is FALSE.  A typical call would be:

	ASSERT_TRACE(id_tok_ptr(tp) -&gt; spell_token == *tp,
		es("tp: "); eptr(tp);
		es(" = "); es(tok_name(*tp)));

The ASSERT_TRACE macro prints the text of the assertion that failed, so there is no need to repeat that.

The current_ftag, caller_ftag and caller2_ftag macros, defined in debug.c, provide mnemonics for various calls to sl_callname.  These macros are used in error_begin.

The check_ptr macros are obsolete now that the fatal and ASSERT_TRACE macros are so flexible.  They will be replaced by ASSERT macros in the near future.
</t>
<t tx="ekr.20080529093004.352">List Processing

Raw Lists

I realized that not all lists involve objects allocated by obj.c.  A raw list is a list whose members are not objects.  When items are block allocated, i.e., allocated en masse in an enclosing block, only the block containing the individual items is an object.  The individual items in the block are not objects, so raw lists must be used to link such items together.

Most routines in lst.c now contain a flag indicating whether a check for a valid object should be made. ekrlib.h now contains set of lst_raw_ macros that handle raw lists.

All List Macros Use &amp;list

The lst_every family of macros was changed so they require a pointer to a list.  This makes their calling sequence just like all the other list macros.  It has the added benefit that we can  ASSERT(list!=NULL) in each macro.

Be Careful with lst_every Macros

In general, macros that expand into more than one statement should be enclosed in curly brackets.  Alas, there are several macros in ekrlib.h that can not be so bracketed:
		
o LIST and LIST2 can not be enclosed in curly brackets because they appear in declarations.  This should create no problems.
		
o The list_every macros can not be enclosed in curly brackets because they form the beginning of a statement.  This definitely does have the potential for trouble.  For example, the following will not work!
		
	if (...) lst_every {...}
		
Do this instead:
		
	if (...) {lst_every {...}}</t>
<t tx="ekr.20080529093004.353">User Options

CC2 reads command-line options from an argument file whose name currently is hard coded in CC2init.c.  Comments may be inserted in the argument file: everything from ! to the next newline is ignored.

Command-line options start with + or -, except input file names.   Boolean options may be preceded by either + or -.  A leading + enables the option and a leading - disables it.  Other options should be preceded only by -.

Multiple input files may be specified.  The options that apply to an input file must precede the name of the input file.  For example:

	-of output1 input1.c -of output2 input2.c -of output3 input3.c

Options remain in effect until explicitly over-ridden.  For example, the +once option below applies to both file1.c and file2.c.

	+once  file1.c file2.c

Pragmas are implementation-defined extensions to the C preprocessor.  Only one pragma exists in the current compiler: #pragma once.

The following options are available. Optional items are enclosed in &lt;angle brackets&gt;.

+-cpp	        Output preprocessed file and exit.
-d id&lt;=value&gt; Define a preprocessor constant.
-exit	        Terminate option list.
+-full_ws	  Retain full white space for error messages.
+-line	  #line numbers in cpp output.
-of file	  Specify output file.
+-once	  Include header files only once.
-s path	  Look for include files at path.
-s2 path	  Specify a path to a single file.
+-trigraph	  Translate trigraph sequences.
-u id	        Undefine a preprocessor constant.
+-v	        Verbose output.
-?	        Print the version number and exit.

In the descriptions below, the default setting of an option, if any, is indicated in parentheses following the name of the option.+-cpp (-cpp)

If this option is on (+cpp) the preprocessed input file is written to the output file and the input file is not processed further.

-d id&lt;=value&gt;

This option defines a preprocessor symbol.  For example, the options:

	-d DEBUG -d DEBUG_LEVEL=2

have the same effect as if

	#define DEBUG
	#define DEBUG_LEVEL 2

appeared at the start of the input file.  There must be space between the -d and the symbol being defined, while there must be no space around the equal sign.

-exit

This option halts the processing command line options.  No further options in the command line (or the command line file) are recognized.

+-full_ws (+full_ws)

If this option is on (+full_ws) white space (blanks, tabs and comments) is retained for use in error messages.  Turning this option off saves compiler memory but makes error messages more terse.

+-line (-line)

This option has effect only if +cpp option is in effect.  If +line is specified, #line directives are copied to the preprocessed output.  Otherwise, #line directives are replaced by a blank line.

-of file

This option specifies the name of the output file. (At present, all output is written to the Sherlock tracing file so this option has no effect.)  This option, and all other options, must precede the name of the input file.
+-once (-once)
#pragma once

If this option is on (+once) no #include file is included more than once.  #pragma once inhibits any further includes of the file containing the #pragma once.

-s path

This option adds a directory path to the list of standard places to be searched when looking for a file.  By the way, cpp treats the following identically:

	#include "header.h"
	#include &lt;header.h&gt;

This will be changed in the future.

-s2 path

This option tells CC2 where to look for a single file.  The effect of this is large even on machines with fast disks:  the time taken to locate and load an include file using the -s2 option is only 25% of the time used when using the -s option alone.

The -s2 command-line option allows CC2 to simulate the performance of a project-oriented compiler.  Compilers such as Think C or Turbo C never need to search for files since they know where all files of a project live.

Instead of using the -s option to specify directories, as in:
		
	-s library		!directory for library files
	-s userlib		!directory for user library files
	-s sherlock		!directory for Sherlock files
		
to simulate a project environment one uses the -s2 option to specify files, as in:
		
	-s2 library:stdio.h	!library files
	-s2 library:stdlib.h
	...
	-s2 sources:mst3.h	!header files
	-s2 sources:tokens.h
	...
	-s2 sherlock:sl.h		!Sherlock header files
	-s2 sherlock:sl2.h
	
(Aside.) Tokenizing include files also takes a lot of time.  If a project saved the tokenized forms of include files, it might be able to eliminate from 50% up to 90% of the time spent in the front end.  Clearly, this should be seriously considered.  On the minus side of the ledger, retaining token buffers takes a lot of memory.
+-trigraph (-trigraph)

Trigraphs are an invention of the the ANSI C Standards committee.  They allow people with old keyboards to enter all the characters required by C.   Trigraphs are three-character sequences starting with ?? which are converted to single characters as follows:

	Trigraph	Result
	??=		#
	??(		[
	??)		]
	??'		^
	??&lt;		{
	??&gt;		}
	??!		|
	??-		~

Most user's  don't need and don't want trigraphs.  Worse, trigraphs are dangerous: they are translated everywhere, even in strings, character constants and and comments. (The Standard requires them to be translated in the first phase of processing,  before strings and comments are recognized.)

For example, one of my files contains '????', a multi-character character constant.  If trigraphs are recognized, this gets translated to '??^   which becomes an unterminated character constant!  Clearly, trigraphs should be disabled by default.

-u name

This option cancels the first #define name seen in the input file.

+-v (-v)

If this option is on (+v) CC2 prints the name of the input file before compiling it.

-?

This option causes CC2 to print its version and then exit.
</t>
<t tx="ekr.20080529093004.354">The Parser

This document describes the parser for CC2.  The parser consists of three parts--a statement parser in par2.c, a declaration parser in dcl2.c and an expression parser in expr2.c.  The statement and declaration parsers operate by recursive descent while the expression parser is a state machine implementing a modified operator precedence scheme.

This document is organized into the following sections:
			
- Overview of Data Structures.
- Storage Allocation.
- The Statement Parser: How statements are parsed into statement lists.
- The Expression Parser: How expressions are parsed into expression trees.
- The Declaration Parser	How declarations are parsed into tnodes and snodes.
- How delayed errors are reported.





</t>
<t tx="ekr.20080529093004.355">The parser creates several kinds of data structures collectively called parser nodes.  snodes represent symbols and related items such as declaration statements, pnodes represent executable statements, tnodes represent types, enodes represent expressions and inodes represent initializers.  The simplest way to describe the parser is as follows:

The parser creates snodes, pnodes, tnodes, enodes and inodes that represent the program being parsed.  

The complexity of the C language is mirrored in the parser's data structures.  Indeed, declarations may contain other declarations and initializers; statements may contain other statements, initializers and expressions, as well as casts containing declarations and types;  initializers contain one or more expressions; types may refer to declarations via struct/union/enum tags or casts; expressions may contain other expressions and casts. 

Similarly, snodes point to other snodes, tnodes and inodes; pnodes point to other pnodes, tnodes, inodes and enodes; inodes point to enodes; tnodes point to snodes and other tnodes; enodes point to other enodes and tnodes.

All aspects of the data structures used by the parser are defined in nodes.h.

The type of snodes, tnodes, enodes and inodes is indicated by n_type, a field common to all such nodes.  The n_type field contains tokens, as created by tokenize and defined by tokens.h and tokens.c. The type of a tnode is contained in its tprim field.  The valid values of the tprim field of a tnode are defined by enum tprim.  Attribute fields in snodes and tnodes form subtypes of the type classes created by the n_type and tprim fields.  Attributes will be discussed in great detail later.

The n_next field in snodes and pnodes is used to link the snode to at most one  list.  The head or root of such a list is never another n_next field.  Lists of fields (of structs or unions) and lists of parameters of functions are rooted in the dcls field of an snode.  Lists of declarations and statements are rooted in named variables.  In short, the n_next field contains the links of a list, never the root of the list.
</t>
<t tx="ekr.20080529093004.356">All parser nodes are allocated using parser allocation macros defined in mem2.h.  These macros allocate nodes to streams, as discussed earlier in the chapter now called stream.doc.  The file mem2.c contains the global stream variables required to manage the streams.  Routines and macros outside mem2.c and mem2.h should leave these variables alone!  Using streams insures that nodes are allocated as fast as possible.

There are three streams to which parser nodes are allocated.  The permanent stream holds information that exists beyond the lifetime of a single file.  The permanent stream corresponds to identifiers declared outside of any function, including function definitions themselves.
Since declarations are permanent, declarations in one file can be checked to make sure they are compatible with declarations in other files.

The file stream holds information whose lifetime is the same as the static variables of a file.  This stream is deallocated and reinitialized after a file has been compiled.

The function stream holds information local to the lifetime of a single function.  This stream is deallocated and reinitialized after the code for a function has been generated.

The present code allocates more nodes to the permanent stream than is necessary.  This can not cause any errors, but does waste considerable storage.  In the future the parser will predict the lifetime of objects and types introduced by declarations--the permanent stream will be used if the extern keyword is present, the file stream will be used if the static keyword is present and the function stream will be used otherwise.  Of course, this prediction can only be made for declarations at the outer level.  The function stream would be used for all other declarations.

The permanent stream provides the basis for implementing projects--all and only those declarations allocated to the permanent stream need to be saved in the project data base file.  The unload routine will write all snodes, tnodes, pnodes, enodes and inodes to an external project file.  The load routine will do the reverse, recreating the internal data structures from an internal files.

The load and unload routines are non-trivial because pointers can not be unloaded as they are.  The unload routine will translate pointers to position-independent references, i.e.,  indices into some table which will itself be part of the project data base file.  The load routine will first allocate space for the parse nodes, creating a translation table as it does so.  The load routine will then translate position-independent references back to pointers.

The most bug-prone part of the load and unload routines is making sure that each parser node is unloaded and loaded once and only once.  To ensure this constraint a load bit will be added to each parser node.  This bit will be set by the unload routine as nodes are written to the project data file.  It will be cleared by the load routine when all position independent references are translated back to valid pointers.

The load bit will be part of the attribute fields of snodes and tnodes.  For enodes, the load bit will be contained in the n_opt_flags field, part of OP_NODE_HEAD.  There is no readily available field in pnodes.  It appears that a new field will need to be created in STATEMENT_HEAD.  The itype field of inodes contains plenty of extra space for a load bit.

</t>
<t tx="ekr.20080529093004.357">The statement parser is the simplest part of the parser.  A separate statement parsing routine, par_do, par_if, etc. exists for each executable C language statement.  Each statement parsing routine creates a corresponding pnode--do_node, if_node, etc.--that represents the statement.

Two fields of the pnode are filled in by new_pnode_macro, the macro that allocates pnodes. The n_type field indicates the type of statement and the n_line field indicates the line number at which the statement starts.  The n_type and n_line fields are common to all pnodes and are defined by the STATEMENT_HEAD macro in nodes.h.

Other fields of the node are filled in by calling other statement parsing routines recursively.  For example, the if_node is defined as follows:

	struct if_node_struct {
		STATEMENT_HEAD;	/* n_type is K_IF. */
		enode * if_bool;
		pnode * if_then_body;
		pnode * if_else_body;
	};

The par_if routine calls par_parenexp to get a parenthesized expression and sets if_bool to the result.  Similarly, par_if calls par_statement to get a statement and sets if_then_body to the result.  Finally, if an else clause exists, par_if calls par_statement again and sets if_else_body to the result.

The result of the statement parser is a list of pnodes.  This list is rooted in the global variable par_body_node . parse and the links of this list are found in the n_next field of each pnode.  Statement lists are created by the par_list routine.

Statements consisting of an expressions at the outer level are represented by expr_nodes, another kind of pnode.  This allows a line number to be associated with an outer expression without having to put a line number in every enode.
</t>
<t tx="ekr.20080529093004.358">The expression parser produces an expression tree representing the operands and operators of the expression.  The expression tree consists mostly of enodes, though other kinds of nodes are used to represent cast operators.  Enodes representing constants and variables are collectively called operand nodes.  Expression trees are rooted in pnodes, inodes and tnodes.

In the old C* compiler, all operand nodes were represented by loc_nodes.  In effect, loc_nodes were unions.  This was a mistake.  With the addition of float, double and long double operands, using loc_nodes would have wasted far too much space.  Also, the only way to know what kind of operand was represented by a loc_node was to look at all of its fields.  This complicated and slowed the code.

In the new CC2 compiler, operand nodes are represented by several different kinds of enodes.  Besides enodes representing constants, variables and expressions, another kind of enode represents combinations, sequences of C-language operations that can be represented by a single 68000 machine language instruction.  Recognizing combinations is an important part of code generation and optimization.

The only drawback to using distinct enodes rather than a single kind of loc_node is that new combination nodes must be created when creating combinations from individual operand nodes.  This complicates the code a bit.  However, the storage saved by having appropriately-sized operand nodes is just too great to ignore.

Primitives consist of constants, variables or primitive expressions involving the dot and arrow operators.  Primitive expressions must be handled differently from other expressions because the name space of objects is distinct from the name space of fields of structs or union.  Consider, for example, the primitive expression  a -&gt; b.  The parser must look up b in the name space of fields of the structure or union to which a points, not in the name space of general objects.  Because of this constraint, the expression a -&gt; b must be treated like a primitive, not like a compound expression.  Constants are parsed by expr_cprim.  All other primitives, including primitive expressions, are parsed by expr_prim.

The top level of the expression parser is found in expr1.  expr1 is a state machine implementing a modified operator precedence scheme.  When a primitive operand is seen, expr_cprim or expr_prim is called to create an operand node representing the operand and the operand node is pushed on the operand stack.  When a new operator is seen, it is either reduced or pushed on the operator stack, depending on whether the new operator has higher or lower precedence than the operator on the top of the operator stack.  Reducing an operator means creating an operand node describing the application of that operator to its operands.  The new operand node is then pushed on the operand stack.

Reducing operators is done by expr_reduce.  Before an operator is reduced, either expr_fold1 or expr_fold2 is called to fold its operands if possible.  Folding converts an operator applied to one or more constant operands to a constant compile-time value.  If folding is possible, the type of the resulting operand is determined by expr_fold1 or expr_fold2.  Otherwise, one of the routines ct1, ct2 or ct3 is called to set the type of the result, depending on how many arguments the operator takes.

The ct1, ct2 and ct3 routines create cast nodes as necessary to perform the integral promotions, the usual arithmetic conversions and other type conversions required by the ANSI C Standard.  These routines also perform type checking, often by calling the routine ct_eq.  All routines having names starting with "ct" are found in the file ct.c. Most of the changes made to the expression parser involved ct1, ct2, ct3, ct_eq, expr_cprim and expr_prim.

</t>
<t tx="ekr.20080529093004.359">The declaration parser is the most complex part of the parser; its complexity mirrors the inherent complexity of C declarations. Declarations may contain other declarations. For example:

	int * (*f) (void (*g)(int a, int (*h)(double i)));

This statement declares f to be a pointer to a function returning a pointer to int.  f takes one argument, g, a pointer to a void function of a two arguments, a and h.  a is an int, while h is a pointer to a function returning int which takes a single argument i of type double.

At the outer level, multiple declarations may share a common type head, as in,

	int a, b;

The type head is int and there are two type tails, namely a and b.  In function prototypes, however, commas separate complete declarations and type tails never share a common type head.  For example, the following function prototype is invalid,

	int f(int a, b);

The storage class keywords such as extern and typedef are likewise valid in most contexts but not in function prototypes.

The declaration parser creates lists and trees of snodes and tnodes.  The global structure par_body_node contains the roots of two lists, a list of snodes representing formal parameters and a list of snodes representing the outermost local variables of a function.  Similarly, a local variable in par_outer_dcl contains the root of the list of all snodes created by an outer declaration statement.</t>
<t tx="ekr.20080529093004.360">Types are represented by lists of tnodes having the following fields:

	enum tprim	tprim;	/* Type code */
	enum tmods	tmods;	/* Modifier bits. */
	tnode *		ttype;	/* Next type node. */
	snode *		tdcls;	/* Parent of fields, parameter of function. */
	ulong			tdim;	/* Dimension/internal offsets. */	
	ulong			tsize;	/* What sizeof(this type) returns. */

The tprim field tells what type the tnode represents.  INT_TYPE means char, short, int or long, depending on bits in the tmods field.  FLOAT_TYPE means float, double or long double, depending on bits in the tmods field.  DOTS3_TYPE and VOID_TYPE represent ... and void in function prototypes.

The ttype field points to the next tnode in the type chain.  It is NULL for base types, i.e., NULL_TYPE, DOTS3_TYPE, INT_TYPE, FLOAT_TYPE, LABEL_TYPE and VOID_TYPE.
If tprim is CAST_TYPE, the ttype field points to the type of the cast.
If tprim is FUNCTION_TYPE, the ttype field points to the type of object returned by the function.
If tprim is POINTER_TYPE, the ttype field points to the type of the object to which the pointer points.

For example, the type "pointer to pointer to function returning int" would be represented as:

	t1: tprim: POINTER_TYPE,  ttype: t2.
	t2: tprim: POINTER_TYPE,  ttype: t3.
	t3: tprim: FUNCTION_TYPE, ttype: t4.
	t4: tprim: INT_TYPE,      ttype: NULL.

Some fields have been omitted for clarity.  For example, as will be seen in a later section, tnode t3 also contains a pointer to an snode that describes the number and type of the function's arguments.

If tprim is STRUCT_TYPE or UNION_TYPE the ttype field does not point to a tnode.  Instead the ttype field points to an snode  describing the fields of the struct or union.  Such an snode is called a tag snode.  I'll discuss tag snodes in detail later.  This overloading of the ttype field is a kludge, but without it another field would have to be added to all tnodes.  Indeed, structs and unions are essentially user-defined base types and a link to the definition of these base types must exist in the tnode.  The ttype field is really a union since the ttype field contains pointer either to a tnode or to an snode.  However, instead of creating an explicit union, I simply use casts where needed.

The tmods field contains type attribute bits.  In effect, attributes create subtypes.  tnodes with  INT_TYPE in their tprim field represent char, short, int or long, depending on the tmods field.  Similarly, FLOAT_TYPE represents float, double or long double depending on tmods bits.  Other modifier bits indicate whether an object is an array type, an enum type, or signed or unsigned, or const or volatile.  By the way, snodes must not have ENUM_TYPE because enums are first-class ints.

Using attributes helps reduce the combinatorial explosion of cases of types that have to be considered in the parser.  In many cases the distinctions represented by attributes can be ignored, thereby reducing the number of cases that have to be written.   Be aware that attribute bits were not created haphazardly and be warned that changing attribute bits to types would have far-reaching and undesirable consequences.

The tdcls field is another multi-purpose field.  If the tnode describes a field of a struct or union, the tdcls field points to the tag snode describing the type of the enclosing struct or union.  If tprim is FUNCTION_TYPE, tdcls points to the list of snodes describing the function parameters.  Since functions are not valid members of structs or unions, no conflict is possible between these two usages of the tnode field.

At first I thought that the tdcls field could point to the type of a structure, but this created a hard-to-find bug.  The problem was that structures can contain other structures, which meant that the tdcls field was being asked to hold two different values at the same time.  Thus the ttype kludge was born.

The tdim field holds the dimension of arrays, while the tsize field holds the size of the type, i.e., what sizeof will return.

All the fields of tnodes are needed in one context or another to compare types.  For instance, the dimension of an array is an essential element of a type: an array of 5 integers has a different type than an array of 10 integers.  Similarly, a function returning int with no arguments has a different type than a function returning int that takes one argument.  Finally, the tdcls field is an essential part of the definition of a field of a struct or union.  The symbol table routines require a pointer to the parent struct or union in order to associate field names with their parent.  In short, C requires that complete descriptions of types exist independent of any object which may have that type.</t>
<t tx="ekr.20080529093004.361">Snodes represent both objects and the user-defined types defined by structs and unions.  Snodes have the following fields:		

		/* Parser fields. */
		
	STATEMENT_HEAD;	/* n_type: indicates name space. */
						/* n_next: the next outer declaration. */
						/* n_line: line number of start of declaration. */

	snode *	dcls;	/* list struct/union elements. */
						/* formals of function. */
	
		/* Symbol table fields. */

	snode *		next;	/* Next symbol with the same spelling. */
	snode *		back;	/* Previous symbol with same spelling. */
	snode * 		life;	/* Next symbol with the same lifetime. */
	spell_node *spell;	/* Spelling node for this symbol. */
	long			block;	/* Block number of defining block. */
	enum nspace	nspace;	/* Name space. */

		/* Semantic fields. */
	
	inode *		vlist;	/* List of initializers. */
	long			offset;	/* Offset for struct/union elements. */
	tnode *		ctype;	/* C-language type. */
	enum smods	smods;	/* Other object attributes. */
	int			sreg;	/* Register number. */
	char *		alias;	/* Unique assembly name for the symbol. */

The n_type field tells what kind of object or type the snode represents, as shown in the following table:

	n_type	meaning

	KP_ENUM_ELEM	a constant defined by an enum statement.
	KP_ENUM_TAG	      an snode describing the type of an enum statement.
	KP_STRUCT_TAG	an snode describing the type of a structure.
	KP_UNION_TAG	an snode describing the type of a union.
	KP_VAR	      a normal object.
	KP_VOID_VAR	     (void) in a function prototype.

The following paragraphs describe the meaning of these types of snodes in detail.  This is dense reading and it forms the core of the declaration parser.

If n_type is KP_ENUM_ELEM the snode represents an enum constant.  The ctype field points to a tnode describing an integer (enum constants are always ints) and ctype -&gt; tdcls points to an snode whose n_type is KP_ENUM_TAG.  The n_next field points to the next constant in the list of enum constants headed by ctype -&gt; tdcls -&gt; dcls.

If n_type is KP_ENUM_TAG the snode is an enum tag snode.  An enum tag snode represents a base type of an enumeration.  It is an snode so it may entered into the symbol table, but no object is ever created with an enum tag snode.  An enum tag snode also provides a target for the tdcls field of enum element snodes.  The ctype field is NULL.  The dcls field points to a list of snodes whose n_type is KP_ENUM_ELEM.
If n_type is KP_STRUCT_TAG or KP_UNION_TAG the snode is a struct or union tag snode.  These snodes represent a base type of an structure or union.  They are snodes so they may entered into the symbol table, but no object is ever created with a struct or union tag snode.  A struct or union tag snode also provides a target for the tdcls field of snodes representing the fields of a struct or union.  The ctype field is NULL.  The dcls field is the head of a list of snodes representing the fields of the struct or union.  This list is continued in the n_next field of the snodes, not the dcls field.

Tag snodes are created whether or not a struct or union type actually contains a tag.  This is an important trick that greatly simplifies the code.  Because tag snodes are created for every struct or union, they are used to represent the user type of a struct or union.  Tag snodes for structs or unions that do not contain an actual tag have a NULL spell field and are called nameless tag nodes.  

Snodes representing objects or fields of structs or unions have an n_type field whose value is KP_VAR.  The ctype field points, as usual, to a list of tnodes describing the type of the field.
For objects, the value of ctype -&gt; tdcls is NULL while for fields of structs or unions ctype -&gt; tdcls points back to the struct or union tag snode.  The n_next field is used to link snodes to various lists.  For objects, these are lists of outer declarations, formal parameters, etc.  For fields, the n_next field forms the links in the list of fields whose root is ctype -&gt; tdcls -&gt; dcls.

Object snodes and field snodes have the same n_type because fields of structs or unions must be treated just like other objects.  It is easy to distinguish between field names and other objects--field names have a non-NULL ctype -&gt; tdcls field.

If n_type is KP_VOID_VAR, the snode represents a null snode.  Null snodes represent (void) in lists of formal parameters in function prototypes.  For example,

	int f(void);	

Null snodes also represent the "missing" variable in some struct or union declarations.  For example,

	struct tag { int a; } /* no variable is defined here */ ;

The following paragraphs discuss the other fields of snodes.
  	
The spell field points to a spell_node that gives the name of the symbol, or NULL for nameless tag snodes.

The next, back, life, block and nspace fields should be used only by the symbol table routines.  They are not touched by the parser.  These fields greatly speed the symbol table routines.  In effect, snodes do double duty as symbol table nodes.

The vlist field points to the list of initializers for an object.

The offset field contains the offset from the start of a struct.  For formal parameter objects, it represents the offset from the stack frame.

The sreg field contains the register to which an object has been assigned, or zero.  Other fields will be added to snodes for the use of the project-oriented linker.

The alias field points to an alternate symbolic name for an object.  Alias are needed to insure that the names of static variables are unique.  This field will be eliminated when the project-oriented linker is installed.

The smods field provides additional attributes for snodes.  Like the tmods field, the smods field contains information secondary to the the main type of the snode.  The same warnings about attributes apply here: these attributes were not created haphazardly.

Several sets of macros, defined in nodes.h,  hide the representation of the smods field from the rest of the program.  The first set of macros, is_auto, is_reg, is_static and is_typedef, record the presence or absence of modifier keywords.  These macros are used by the code generators.

The second set of macros record the context in which a symbol was defined.

The is_code macro is TRUE if the snode represents a function or function prototype.  This macro is used by the symbol table routines to tell if a previous definition is a harmless redundant prototype or an erroneous duplicate definition.

The is_explicit macro is TRUE if the snode was created as the result of an actual user symbol.  This tells the output routines how to create an assembler symbol for the snode.  This macro may be eliminated when the project-oriented linker is installed.

The is_formal macro is TRUE if the snode represents a formal parameter.  This macro is used by the code generators.

The is_global macro is TRUE if the snode was defined in the outer context.

The is_su_elem macro is TRUE if the snode is a field of a struct or union.  This information can not be included in the tnode for the snode, because the tnode is already being used to indicate the object's type.  This shows that the smods field can not be incorporated into a tnode field.

The third set of macros are abbreviations.  

The is_rstack macro is TRUE if the snode should be allocated on the runtime stack.  It is TRUE if either is_auto or is_formal is TRUE.

The has_offset macro is TRUE if the snode can be expressed as an offset from some base pointer.  It is TRUE if either is_rstack or is_su_elem is TRUE.

The is_formal_reg macro is TRUE if the snode describes a formal parameter which has been declared to be a register variable.

The is_static_code, is_static_global and is_static_local macros are true if the snode was defined in the indicated context.
Examples

The following examples illustrate how declarations give rise to snodes and tnodes.  

The declaration,

	struct s1 {int a; int b} sv;

creates the following snodes and tnodes:

	snodes:
	s1: spell: s1, n_type: KP_STRUCT_TAG, ctype: NULL, dcls: s2.
	s2: spell: a,  n_type: KP_VAR,        ctype: t1,   n_next: s3.
	s3: spell: b,  n_type: KP_VAR,        ctype: t2,   n_next: NULL.
	s4: spell: sv, n_type: KP_VAR,        ctype: t3.

	tnodes:
	t1: tprim: INT_TYPE,    ttype: NULL, tdcls: s1.
	t2: tprim: INT_TYPE,    ttype: NULL, tdcls: s1.
	t3: tprim: STRUCT_TYPE, ttype: (tnode *) s1.

If the tag s1 was not present in the example above, the only difference would be that the node s1 would have a NULL spell field.  Of course the spell field actually points to a spelling node--the actual spelling would be spell_p -&gt; spell_name.  Note the cast needed to convert s1 to the proper type for the ttype field.  Observe that the list rooted by the dcls field in s1 is continued in the n_next fields of s2 and s3.

A similar arrangement is used to describe the parameters of a function.  The declaration,

	long * f(int a, char /* no name */ );

creates the following structures,
	
	snodes:
	s1: spell: f,    n_type: KP_VAR, ctype: t1, dcls: s2.
	s2: spell: a,    n_type: KP_VAR, ctype: t4, n_next: s4.
	s3: spell: NULL, n_type: KP_VAR, ctype: t5, n_next: NULL.

	tnodes:
	t1: tprim: FUNCTION_TYPE, ttype: t2, tdcls: s1.
	t2: tprim: POINTER_TYPE,  ttype: t3.
	t3: tprim: INT_TYPE,      ttype: NULL, tmods: LONG_TMOD.
	t4: tprim: INT_TYPE,      ttype: NULL.
	t5: tprim: INT_TYPE,      ttype: NULL, tmods: CHAR_TMOD.
Calling Diagrams

The following calling diagrams illustrate the workings of the declaration parser.

	par_outer_dcl
		dcl
			dcl_head
			dcl_tail (0 or more)

par_outer_dcl calls dcl to parse a single declaration, which may define 0, 1 or more objects.  If no objects are defined, then we expect that at least one tag is defined and dcl returns a null snode.

	dcl_head
		dcl_head_sclass
		dcl_head_tmods
		dcl_head_type
			dcl_enum
			dcl_struct_union

dcl_head parses a type head, consisting of at most one storage class identifier (auto, extern, static, register, typedef), zero or more type modifiers (char, const, long, short, signed, unsigned, volatile) and at most one base type (int, long, double, float, enum, struct, union).

	dcl_tail
		dcl_tail1
		dcl_post
			dcl_post_struct_union
	
The dcl_tail routine insures that dcl_post is called after every outer call to  dcl_tail1.  The dcl_post routine massages the declarations produced by dcl_tail1.

	dcl_tail1 (with recursive_flag == FALSE)
		dcl_tail1 (with recursive_flag == TRUE)
		dcl_finish
			dcl_arrays
			dcl_proto
				dcl_list (to parse new function scope)
					dcl
				dcl_old_formals;
				dcl_list (to parse old formal def scope)
					dcl
			dcl_init
				dcl_init_blist
					dcl_init_list
						dcl_init1
				dcl_init_expr
		dcl_fbody
			dcl_list (to parse formals)
			par_list

dcl_tail1 handles the parsing of a type tail, i.e., all the declaration following the type head. The first part of dcl_tail1 counts asterisks.  The second part of dcl_tail1 calls itself recursively to parse the underlined part of a declaration such as

	int ** (*fp) (void);

After the part containing the identifier has been parsed (or the part that would contain the identifier in the case of casts and new function prototypes), dcl_finish is called to handle argument lists, arrays dimensions and initializers.  dcl_finish is really part of dcl_tail1, but has been made a separate function to make the size of dcl_tail1 more manageable.  If dcl_finish detects that a function body exists, it sets the dcl_body_flag variable which causes dcl_tail1 to call dcl_fbody.

	expr1
		dcl_cast
			dcl_head
			dcl_tail

dcl_cast is called from the expression parsing routines in expr.c.  

Many declaration parsing routines contain a scope parameter which indicates the kind of declaration being parsed.  These scope parameters essentially form a stack of context.  This generality is essential because declarations may contain other declarations. 
</t>
<t tx="ekr.20080529093004.362">The n_line field of snodes and pnodes contains the line on which the statement starts.  Recall that outer expressions are rooted in a pnode so that the line on which an outer expression starts can be determined from the n_line field of that pnode.

For the most part the parser does not need to use the n_line field.  The parser can simply use the error macro to report errors because calling the next_tok macro automatically updates the global err_line variable used by the error macro.  All that must be done is to make sure that err_line is initialized, and this is done by calling err_begin_file in compile just before calling par_program.

In several points in the parser, however, an error must be reported that pertains to a line other than the line to which err_line currently points.  Such errors arise, for example, when checking the formal parameters in a function prototype.  At the time the check is made the parameters have long since been scanned and the err_line variable points at the start of the function body rather than the start of the function prototype.

The delayed_error macro handles such error messages.  It takes two parameters.  The first is the number of the erroneous line.  The delayed_error macro temporarily sets err_line to the the value of the first argument so that the error reporting logic will work correctly.  The old value of err_line is then restored.

The code generators could use the delayed_error macro to report errors.  However, they could also use the error macro as long as the code that traverses the parse trees properly updates the err_line variable.</t>
<t tx="ekr.20080529093004.363"></t>
<t tx="ekr.20080529093004.364">The code generators are found in  CCgbody.c, CCgbool.c, CCgen.c and CCgstat.c.  Register allocation is handled in CCreg.c and the peephole is in CCpeep.c.

The peephole is straightforward and I'll say no more about it.  The code should be self-explanatory.

-- The code generators 

CCgen.c contains utility routines of various kinds, public global variables used to communi are called within the declaration routines: CC2 is essentially a one-pass compiler.

CCbody.c contains 3 functions, gen_alloc_locals, gen_alloc_formals and gen_alloc_outers that allocate space for C identifiers either statically or on the stack.  Once allocated, an identifier's location never changes: only temporary registers are ever spilled.  CCbody.c also contains gen_fbody(), which generates code for a single function.  The parse tree for the entire function, including all snodes, exists when gen_fbodyion.  gen_fbody() then calls the peephole optimizer, and finally calls out_function() to output the function entry code, the code list and the function exit code.

This might be a good time to mention the "call 1 arg optimization."  The following comment appears in CCgen.c:

[Quote]
gen_call_1arg is the number of calls to functions g1, g2...gn with one argument
IN THE CURRENT FUNCTION, say CCgen.c:

gen_call_1arg is the number of calls to functions g1, g2...gn with one argument
IN THE CURRENT FUNCTION, say f.  If gen_call_1arg &gt;= 1, _f_ will pre-reserve space for the single argument as follows:

f:
	...entry code...
	subq.l #4,7	;allocate pre-reserve space for the first argument

The g_args() routine can then generate:

	move	arg,a7
	jsr gi

arg,a7
	jsr		gi

instead of:

	move	arg,-a7
	jsr gi
	addq.l #4,a7

The exit code at the end of f will look like:

	addq.l #4,7	;free the pre-reserved space
	...exit code...
	rts

Only when gen_call_1arg &gt; 1 is a real savings is made, since when gen_call_1arg &lt; 2 the cosssplus the definitions of public global variables used to communicate between the declaration routines and the code generators.  Such globals are needed because the code generators of a functionsn_alloc_formals and gen_alloc_outers that allocate space for C  is called.  gen_fbody() is the main line of code generation: it calls gen_alloc_formals() to allocate stack space for the formals and calls gen_list() to generate most of the executable code for the funct generate most of the executable code for the functt of allocating and freeing the pre-reserved space offsets the savings made in speeding up the lone function call.
[End Quote]

The other fn CCbody.c contains the messy code to allocate initializers.

CCgstat.c contains the code generators for executable sunctions in CCbody.c contains the messy code to allocate initializers.

CCgstat.c contains the code generators for executable statements.  This code is routine.  The code for switch statements is fairly simple.

CCgbool.c generates code for expressions used in conditional contexts.  This code takes pains to arrange things so that the peephole will always yield optimal code.  The gen_bso that the peephole will always yield optimal code.  The gen_be peephole will always yield optimal code.  The gen_bThe gen_b1() function handles short-circuiting of Boolean expressions using the true/false branch method taught in all the books.  The most interesting part of the gen_bool() function are the two assertions in the GEN_ASSERT_TRACE macros.  It turns out that the register allocation scheme is a bit fragile, and these two assertions caught a lot of mistakes.

The heart of the code generators is CCgint.c.  The top-level function is gen_e1(), which generates code to evaluate an expression and leave the result in the location represented by the returned anode.

In concept, the code generators are straightforward, akin to recursive-descent parsing.  They traverse the tree from top down, calling sub-generators to handle code for each branch of an operator.  In practice, however, they are complex, because they have to handle all the complexity of the 68000 instruction set, and they have to handle the special-cases that arise depending on which instructions are in registers.  That is, the code generators _simultaneously_ keep track of allocating and deallocating register temps.  The plus side is that the code generators know where their operands are; the minus side is that freeing register temps is tricky at best.

A good example of the tricks that can be played is the g_add_sub_ip() function, which adds or subtracts a constant from a pointer.  There are lots of special cases to consider, as you will see when you look at the code.

There are several abbreviation macros defined in CCgint.c that are used throughout the code generators.  These simplify the _appearance_ of the code, but in reality they only highlight how tricky it was to get the code generators correct.

Another thing  to notice about the code generators is that they have only local information to work with, so they sometimes have to guess whether it is worthwhile to move an operand into a register.  Not surprisingly, the code generators do so only when forced, or when there is a clear local payoff.

g_prim() and g_address() generate the "leaf" operands used by the other code generators.  g_prim() need not create anodes in most cases because they have already been created by the parser.

These routin work, and produce decent code, but I am dissatisfied with them for several reasons:
o Almost all the code would have to brewritten for a new machine.
o They are inflexible: there's no way to make them more clever without scrapping them.
o There is no way for them to make global judgments.
o They show the wrong "attitude" towards a complex problem: we want to use computer timor D or don't care) from the register allocation routines in CCreg.c.  These allocate a temporary register, spilling a previously allocated temporary if all temporaries have already been allocated.  The register at the back of the list of allocated temporaries is spilled when needed: this is a crude approximation to the register that will be needed the least.  Spilling replaces the anode representing the temporary register with an anode representing a stack location, so when the anode is examined again it will be seen to be a stack-temp and handled appropriately.

The code generators implicitly keep track of which registers have been a allocated to temporaries by handling the housekeeping of freeing the registers when they are no longer used.  That is, thehe code generators must free a temporary (by calling free_temp) when, and _only_ when the temp will no longer be used.  This is error prone.  The permanent assertion in free_temp will fail if a temp is freed twice.  Several assertions in the code will fail if a temp is never freed.  These assertions are too important ever to be removed from the code because the wrong code would surely be generated when they fail.

-- Outputting code

The routines in CCput.c create ual code nodes.  These are mostly utility rouactual code nodes.  These are mostly utility routines and complication in these routines indicates a conceptual problem.  In particular, c_ap2address() is a mess.  c_lea() isn't great either.  The comments in() isn't great either.  The lengthy comments in  these routines indicate conceptual problems in the code generators.  I think the cure would have been to represent dereferencing explicitly in the parse tree.

The code in CCout.c generates assembly code.  Most is straightforward, but there is an amazing stupidity in the MPW assembler that had to be circumvented with compiler hacks.  If I remember correctly, the MPW assembler apparently would not accept an INTRY for the same symbol, complaining of a redefinition.
The following comment appears in CCdcl.c

[MPORT and ENTRY for the same symbol, complaining of a redefinition.  The following comment appears in CCdcl.c (!)

[Quote]
A horrible kludge to satisfy the MPW assembler...We establish the bogus convention that a prototype in the main file (tok_file_level==1) that is neither *explicitly* extern nor static indicates that the function mentioned in the prototype will be *defined* later in the file.  All prototypes in the main file suppress IMPORT directives. Non-external prototypes create ENTRY directives.
[End Quote]

I did use a different approach in the assembler, using a pattern-matching scheme to parse assembly language instructions.

CCgfloat.c contains the code to generate code for expressions containg floating point operands.  There is little to say about them: they simply generate calls to library routines.  No optimization or cleverness of any kind is attempted.

-- Register allocation

The code generators demand a register of a particular type (A machine patterns, though it actually consists of macros that generate very fast code.  See the attached file, ASasm.c.  Of course, you might prefer an assembler-generator...

CCgfloat.c contains the code to generate code for expressions containing floats.
</t>
<t tx="ekr.20080529093004.365">The CC2 Code Generators: Theory of Operation

This document describes how CC2 produces code from a parse tree.  A glossary of standard terms appears at the back of this documentation.  Terms defined in the text or in the glossary are underlined the first time they are mentioned.  Appendix A describes those few features of the 68000 instruction set that directly affect the code generators.

Parse Trees and Type Trees

For each function, the parser generates a parse tree consisting of parse nodes representing arithmetic expressions and flow of control constructs such as if statements, for statements, etc.  Parse nodes for flow of control constructs contain pointers to subtrees representing conditional expressions and the bodies of the constructs.  For example, an if_node, the parse node for an if statement, contains two bodies--one for the then clause and one for the else clause.

Arithmetic expressions are represented in the parse tree by an expr_node that contains the line number of the start of the expression and a pointer to an expression tree representing the expression itself.  Leaf nodes of expression trees represent user variables and non-leaf nodes represent operators.  Constituents of expression trees are collectively referred to as expression nodes, or enodes for short.

The parser generates a type tree from each declaration.  Each type node (or tnode) in a type tree represents either a base type, such as int, float, long double, etc., or a composite type, such as pointer to, array of, function returning.  For example, a type tree for

	int * a [25];

would consist of a tnode representing the composite type "array of" pointing to a tnode representing the composite type "pointer to" pointing to a tnode representing the base type int. This type tree is attached to the symbol table entry for the variable a.

Temporary variables do not appear explicitly in expression trees.  Rather, their presence is implied--each operator node creates an intermediate result corresponding to a temporary variable.

Type conversion operators also do not appear explicitly in expression trees.  Instead, all nodes of an expression tree contain a pointer to a type tree representing the C language type of the subexpression.  Type conversion code is generated as needed based on those types.Code Nodes

The code generators produce a doubly-linked set of code nodes (cnodes) called the Global Code List, or GCL.  Each code node represents either a machine instruction, a label or a line number.  After the Global Code List is created by the code generators, the peephole optimizer, located in ph.c, scans the GCL looking for further local optimizations.  Routines in out2.c produce the final output from the GCL.

Loc Nodes

Loc nodes describe where an operand is physically located.  The parser creates a loc node for each user variable; the code generators create loc nodes for all temporaries.  The loc nodes created by the parser initially describe the location of the user variable.  The loc nodes created by the code generators initially refer to a register that initially contains the temporary.

Loc nodes are enodes, which makes sense because they form the leaves of expression trees.  However, loc nodes are also used in code nodes to describe actual machine language operands.

The code generators manipulate loc nodes, not the variables or register to which they refer.  This allows the code generators to change loc nodes to reflect the current location of an operand.  The location described by a loc node may change during code generation.  Loc nodes change when a user variable gets assigned to a specific hardware register or when a register must be pushed on the runtime stack (the R stack).

A loc node must not change further once it becomes part of a machine instruction!  To inhibit further changes to the loc nodes of a code nodes, copies are made of all the loc nodes to be attached to a code node when the code node is generated.  At present, these copy operations, done via calls to locn_dupl or locn_xdupl, are scattered throughout the code, but it would be more logical to make these calls in g_put, the routine that attaches the code node to the Global Code List.

Loc nodes describe the location of temporary variables so a separate loc node must be created for each temporary.  Although this is a simple principle, in practice it can cause problems since temporaries are not explicitly represented in the parse tree.  The rule of thumb is: create separate loc nodes for temporaries that can coexist at the same time.

Overview of the Code Generators

Generating code for flow-of-control constructs is straightforward.  Only jumps and labels are generated directly evaluating expressions and bodies is handled elsewhere.  Flow-of-control code is generated in g1.c and the algorithms are machine independent.  The real work in a code generator is generating good code for arithmetic expressions.

The code generators are found in the files g1.c, g2.c, g3.c, reg.c and x2.c.  The file g1.c contains machine-independent code generators.  The file g2.c contains the bulk of the machine-dependent code generators for arithmetic expressions.  The file g3.c contains utility routines to create code nodes and attach them to the GCL.  The files reg.c and x2.c contain utility routines.The code generators create the Global Code List in a single walk through the parse tree.  No intermediate code such as tuples or quadruples is generated.  This strategy is unusual and has both advantages and disadvantages.  On the plus side, code generation is very fast.  On the other hand, code generation is limited to what can be discovered from a plain parse tree.  In particular, it is not possible to recognize or exploit common subexpressions (CSE's).

Even though CC2 does not recognize CSE's the programmer can compute CSE's explicitly and put them in register variables.  I did this in tokize.c and as a result the Think C compiler generates essentially perfect code for the tokenize routine even with all global optimizations disabled.

The code generators of C* and CC2 actually represent the final phase of an optimizing compiler such as the GNU C compiler. If one were extend CC2 one would have to add phases before the actual tree walk that generates code.

The gen_e1 routine, found in g2.c, controls the traversal of an entire expression tree, or subtree thereof.  Code generators for individual operators have names starting with sop_ (for Stack Operator) and are also located in g2.c.  Examples are sop_add, sop_dbinop, etc.  Each sop routine calls gen_e1 recursively to generate code to evaluate each argument before generating code for the operator.  The order in which the parse tree is traversed, as determined mostly in gen_e1 and gen_b1, determines the order in which the sop_ routines will be called.

The individual sop_ routines do not, should not, and can not know anything about how the parse tree is traversed.  As far as the sop_ routines are concerned, code generation is a local process.
The sop_ code generators know only where their arguments will be at run time, i.e., at the time the code which is about to be generated is executed.  This information is passed to the code generators by a data structure called the simulation stack (or S stack).  The items on the S stack are pointers to loc nodes, of course.  Do not confuse the S stack and the R stack!  The code generators use the S stack; the generated code uses the R stack.

In summary, a typical code generator calls gen_e1 to generate code to evaluate its arguments, pops the S stack to get the current location of its arguments, generates appropriate code to perform its operation on these operators, and pushes a loc node describing its result back on the S stack.  This kind of stack-based code generation is very similar to code generation in a p-code compiler.

Spilling Registers

The S stack not only is the mechanism by which the code generators know where their arguments will be run time, it is also the mechanism by which registers are allocated to temporary variables.  Temporaries are always allocated to registers when first created.  Since there are a limited number of registers some way must be found to spill a register, i.e., to transfer a temporary from a register to the R stack.

The S stack makes spilling registers easy and efficient.  When a register must be freed, the S stack is scanned, starting from the bottom, until a loc node describing a register is found.  Code is generated to push the register on the R stack and the loc node at that location in the S stack is changed to a pop loc, i.e, a loc _node describing the address mode -(A7).For example, if the loc node found on the S stack represents D0, the get_temp routine will generate

	move.l d0,(A7)+

This is faster and more compact than using:

	move.l	d0,offset(A6)

where offset is a fixed offset from the function's stack frame.  

When the pop loc describing the spilled value becomes the top of the S stack, the pushed value will be on the top of the R stack.  This follows because registers are spilled starting from the bottom of the S stack and because of the following invariant property of code generators:

When generating code for an instruction at point A, the S stack must describe the state of the R stack when execution reaches point A.

All code generators and utilities must preserve this invariant!

To complete this example, if another code generator needed the spilled value in a D register, it would use code such as the following:

	loc1 = ss_pop();			/* Get an operand. */
	if (!is_dreg(loc1)) {		/* Is it a D register? */
		loc2 = get_dtemp();	/* Get a new temp, say D1. */
		g_2(X_MOVE, loc1, loc2);/* Move the value into D1. */
	}

And the generated code would be, assuming get_dtemp () returns D1,

	move.l	-(A7),D1

The -(A7) argument comes from the pop_loc returned by ss_pop().  The code above doesn't know anything about the history of loc1 or that loc1 has been spilled.  It knows only that loc1 describes the top of the R stack.

Any register on the S stack may be spilled whenever get_temp or get_atemp or get_dtemp is called.  The code generators must make no assumptions about the location of any temporary after any of these routines are called.  Conversely, the code generators will often push a loc node on the S stack so as to make it available for spilling.
Hidden Assumptions and Simplifications

The CC2 code generators do no flow analysis such as computing basic blocks and computing which variables are live, dead, used, etc.  (See the Glossary for the definitions of these terms.)  This analysis can be avoided because 1) temporaries are used only once and are dead after that one use, 2) temporaries do not span basic blocks and are dead after each basic block, and 3) with the exception of the ternary operator, all code generated for an expression lies in a single basic block.

No "long lasting" pointers to loc nodes exist because loc nodes are accessed by popping the S stack into a temporary pointer, making some changes to them, and then pushing them back on the S stack.  Eliminating global pointers to arguments greatly simplifies the spilling of registers since it means that there are no global assumptions about what a particular loc node describes.

Just about any call to another code generator may cause a loc node on the S stack to spill.  The code generators must be careful not to assume that temporaries are in the same place after a call that they were before the call, unless the loc node has been popped from the S stack.

Optimizations and Complications

Premature optimizations may be the root of all evil, but significant optimizations are necessary to produce decent code.  This section discusses these optimizations and some important details about code generation that have been ignored so far.

There is a strong connection between the format of loc nodes and the types of addressing modes available on the 68000.  Indeed, loc nodes are essentially a hidden union of all the kinds of addressing modes possible on the 68000.

The fields of loc nodes are used to merge several add operations into one effective machine address.  Consequently, the x_addpsi routine avoids generating actual code it it can avoid it in favor of adding extra arguments to a loc node.  When an operand's value is required, the x_resolve routine generates the most complex address mode possible.  In this way, one or more add operations my be combined in a single address mode.

I have doubts about whether these optimizations are best done as they are--complicating the format and purpose of loc nodes adds to the already large number of special cases that must be handled by the code generators.  It may have been better to have kept loc nodes simple and to do these optimizations in the peephole phase.  I'll discuss this in a bit more detail below.

The eamode field of loc nodes indicates whether the temporary represented by the loc node has an address.  This is an optimization--user variables are loaded into a register only when actually required by an operator.  Depending on the particular operator, a user variable may be accessed directly.  The code for this is a bit tricky and is located, in the case of binary operators,  in sop_dbinop in g2.c.

As another optimization, the code that handles the unary * operator (the dereference operator) and the &amp; operator can sometimes avoid generating actual code by modifying the eamode field.
The Terrible Ternary Operator

Without doubt the operator that causes the most problems is the ternary operator.  For example, consider the assignment:

	a = expr1 + (b ? expr2 : expr3);

Suppose that all three expressions are complex and cause registers to be spilled while being evaluated.  The problem is that expr2 and expr3 may spill differing numbers of registers from expr1.  The code that evaluates the subexpression (b ? expr2 : expr3) must make sure the R stack is in a known state after either branch is executed.  Equivalently, the S stack must somehow be forced to be in the same state after gen_e1 is called for each branch.

The C* code to balance the stack is a kludge involving global data structure, the forks stack.  The forks stack is set by sop_ternop to indicate the present position of each branch of the ternary expression.  The forks stack tracks which registers are available for spilling.  See get_bot in reg.c.  The code that updates forks stack is fairly horrendous.  More importantly, I believe the C* generators can run out of temporary registers on perfectly correct C code.

In any event, it is not clear from reading the code exactly what is going on.  I may well rip out this code and replace it with the brute force approach of spilling all register temporaries before generating a ternary expression.  For instance, in the example above, all temporary registers would be spilled after generating code for expr1.  This leaves the R stack in a known state and ensures that all temporaries will be available when evaluating expr2 and expr3.  It also ensures that a common temporary will be available in which to hold the results of both branches.

All register temporaries of expr1 must be spilled so ternary operators can never run out of temporaries no matter how deeply nested.  However, in this example, at most one register will be spilled from expr1, the register that contains the final value of expr1.  More than one register will be spilled before generating the ternary expression only in those rare cases where a ternary expression is nested inside a complicated ternary expression.

Often expr1 is empty and the brute force is equivalent to the code generated by C*.  When expr1 is non-empty, the brute force approach will generate one extra spill.

A similar problem occurs when generating code to push arguments to function calls.  For example, consider the expression

	a = expr1 + f(expr2 , expr3);

Assume expr1 is evaluated first, then expr2, then expr3.  We can not allow register spills out of expr1 when evaluating either expr3 because that would push another value on the R stack!  It appears that the C* code, in gen_args in g2.c, does not handle this kind of expression correctly.

Again, a simple and correct approach is to spill all registers used in expr1 before generating code to evaluate expr2 and expr3.
The Context of an Expression

The context of an expression determines the set of temporary variables in use as code for an expression is being generated.  Clearly, the S stack keeps track of the current context.

A simple picture has helped me understand context. Shaded triangles represent subtrees of an expression and junctions in the tree represent operators.  Assuming that expressions are generated in preorder, subtree 1 will be generated first, then subtree 2, then subtree 3, then op2 and finally op1.

The context of expression 3 is the circled subtrees.  In general, the context of a subexpression are the subtrees above it and to its left.  Obviously, the  code generators must produce code that works in the current context.  As we have seen with the ternary operator, this is not always simple.

Reordering Parse Trees

The C* compiler never reorders the branches of the parse tree and indeed never massages the parse tree in any way except in gen_pp, which converts a [b] into *(a + b).  The discussion of the ternary operator shows one example where reordering the parse tree can save a register spill.  For example, from the discussion above it should be clear that the expression

	a = expr1 + f(expr2 : expr3);

will require one more register spill than the expression

	a =f(expr2 : expr3) + expr1;

assuming that expr1 does not contain a function call.

I believe that C* avoided rearranging the parse tree on principle, the idea being that one should be able to specify exactly what one means without having the C* compiler change one's stated intention.

However, rearranging the parse tree can often save register loads and spills.  There is a well-known algorithm for minimizing the number of registers needed in an expression.  The idea is that given an abelian binary operator with two subtrees, one should evaluate the most complex subtree of the operator first because putting the result of that calculation in a register will not cause any problems in evaluating the least complex expression.  This is a recursive calculation with the complexity of subexpression calculated from the bottom up.  In theory this algorithm is straightforward.  In practice, it depends on knowing the details of all binary machine instructions.  This is not a high priority operation because in practice most expressions are so simple that they require no spilling anyway.

Other Possible Improvements and Changes

Loc nodes logically should be a union.  At present, the is_xxx routines in reg.c return the type of this implicit union by examining the various fields of the loc_node.  This is much slower than simply looking at a type field.  Also, most loc nodes contain many unused fields, a significant waste of space.

Alas, making loc nodes into an explicit union would be a major change.  Indeed, changing a field of a loc node would essentially change the loc node from one type to another.  Some of the time and space gains of using an union would be lost by having to create copies of loc nodes of the new type.  I will make this change only if statistics indicate it would save a lot of time and space.

Another possible change would be to delay the optimization of effective addresses and let a separate peephole pass do the work.  This effective address peephole pass would substantially simplify loc nodes, reduce the number of times loc nodes are converted from one implicit type to another and would thereby eliminate many special cases in the code generators.  However, this new peephole pass would be more complicated than the other peephole routines because it would have to keep track of both the lifetimes and contents of registers.  I have not yet completed the paper design of this pass and do not know yet whether it is really feasible.
Appendix A: The 68000 Instruction Set

This appendix discusses only those few features of the 68000 that directly affect the code generators.  I assume you are familiar with The Motorola 68000 manual.

As far as code generation is concerned, we can consider the 68000 to have 8 address registers (A regs) and 8 data registers, (D regs).  Other registers, such as the condition code register and status register, can be ignored for the time being as they do not affect code generation very much. 

Many instructions operate on two operands, a source and a destination, abbreviated src and dst.  The effect of a typical operator, say op, is dst &lt;= dst op src.  In other words:

o the result op the operation ends up in the destination register
o for non-abelian operations such as division, the destination operand is the first operand.

Some examples:

	DIVS	D0,D1		;D1 &lt;= D1 / D0
	SUB	D0,D1		;D1 &lt;= D1 - D0

Non-abelian operators do not complicate the code generators--the only effect of non-abelian operators is to force certain subtrees of expression trees to be evaluated before others.  These constraints are enforced in gen_e1 do not complicate the code in any way.

The 68000 instruction set has a variety of different address modes.  Most instructions limit the address modes that can be used.  The ADD instructions is typical.  The allowed forms for this instructions are:

	ADD	&lt;ea&gt;,Dn
	ADD	Dn,&lt;ea&gt;

In other words, one operand may be any kind of operand as long as the operand is a D register.  Because not all address modes are allowed for all arguments,  the code generators must be able to ensure that arguments are located in a particular kind of hardware register.
Glossary

A basic block is a list of instructions such that all instructions are executed if any is.  Therefore, a basic block begins at the beginning of a function, a label or a conditional jump and ends at the next label, jump or return instruction.

A path is an sequence of instructions.  Paths may span basic blocks.  A point on a path is another name for a machine instruction.

A variable V is defined by a point A if the value of V is changed by the instruction at A.

A variable V is defined at a point A if the following three conditions are met:

o there exists a point B such that V is defined by  B
o there exists a path P from B to A 
o V is not defined by any point on path P except point B.

A variable V is defined at point A if it is defined by point A.  The property of being defined at a point depends, in general, on a flow analysis of the entire program.

A temporary variable (temporary for short) is a variable holding exactly one intermediate result.  By definition, a temporary is defined by exactly one point.  Temporaries are generated by the compiler and are anonymous: there is no way for the programmer to refer to either the value or the address of a temporary.

A variable V is used at a point A if it is the argument to a machine instruction at A.

A variable V is live at a point A if 1) there exists another point B such that V is used by B, 2) there is a path P from A to B and 3) V is not defined by any point of path P.  The property of being live depends, in general, on a flow analysis of the program.  A variable may be defined at a point A while not being live at A.

The lifetime of a temporary variable V is the set S of instructions I at which V is both defined and live at I.  Remember, a temporary variable is defined by exactly one point.  The lifetime of a user variable V need not concern us since the CC2 code generators assume that all user variables are live everywhere.
</t>
<t tx="ekr.20080529093004.366">Design of the Code Generators

This file documents the problems and possible strategies involved in generating code.  This is a design document, not a code document.

What are my goals for the code generators?  I would like the simplest,  fastest and most flexible approach yielding the best possible code.  Since these are conflicting goals, some choices must be made.  I am willing to forgo recognizing common subexpressions (CSE's) and many other optimizations at present, but I would rather not make them impossible.  The present (C*) generators are too inflexible.  They are also difficult to get right and are bug-prone: global theorums have to be proved in order to get them right.  I am willing to make more than one pass over an expression tree in the interests of simplicity and optimization.  One of my major goals right now is simply to get something that works:  optimizations and fancy tricks are for the (possibly distant) future. 

The problems are to be solved:

o Variables must be allocated and linked.

There are several kinds of variables:

Anonymous variables. These variables are accessed by address, using casts.  For example,

	* ((long *) 0x100) = 25;

Such variables are never referred to by name, and at the machine level are referenced as follows:

	movea	#100h, a1
	move #25, (a1)

No name is ever needed.  Indeed, no symbol table entry is ever needed!  No entries for these variables are made in the project data base.

Variables with static storage duration internal linkage.  No entry is made for these in the project data base.  If an assembler is used, a unique name must be given to these variables.  This name must be unique across all modules.  A name such as _Sxxx will not do, since that would not be unique across all files.  However, a name of the form _S_xxx_yyy would work, where yyy is some string unique to the file and xxx is some string unique within the file.  In that case, xxx could be a string corresponding to the integer and the variable's alias coud be represented as an int.  Even a short int could be used, since no file will ever have more than 16,000 named variables.

In C*, alias were numeric strings, for example _S_001, _S002, etc.  However, as long as the assembler supports long variable names, symbolic aliases can be used.  For example _S_par_switch_ref would represent static variable named switch_ref within the file par.c.  Because both variable names and module names may contain the underscore character, there is an ambiguity:  _S_par_switch_ref is also the alias for the variable ref in the module named par_switch.c.  We could either ignore the ambiguity, or delimit the alias by a character (say @) which is valid in assembler identifiers but invalid in C identifiers.  The resulting alias would be _S_par@switch_ref.

By the way, the Macintosh MPW allows identifiers to have up to 64 unique characters (and allows @ in identifiers), so that this scheme will work well while using MPW to test CC2.  The Tuple Assembler (TASM) will allow identifiers of arbitrary length, just as CC2 does, so again, this scheme will work.

Variables with static storage duration and external linkage.  The project data base will contain entries for all such variables.  The names of such variables can be used as is in an assember, provided that they are not of the form _S_xxx_yyy described above.  Since names starting with underscore are reserved for the implementation, this should not create any problems.  In short, no aliases are needed for variables with static storage duration and external linkage.

Variables with automatic storage duration.  This category includes register variables that are not, in fact, allocated to a register.  The project data base will contain no entries for these variables.  In assembly, these variables will be represented as offsets either from a stack pointer or a frame pointer.  There are some options about how big a stack frame can be:  1) Require that all stack frames be smaller than 16K.  This will work for CC2, but is not correct in general.  2) Allow stack frames of arbitrary size.  This is not possible.  For example, suppose the stack contains 3 arrays of size 16K-1 bytes each.  3)  Represent all arrays of size greater than some limit, perhaps 4 or 8 bytes, by pointers to the start of the array.  Accessing the array would involve an extra pointer access in those cases.  4) Use the array descriptor technique only if the stack frame otherwise exceed 16K bytes.  This last option is the most general and most efficient, though the most complex for a compiler to implement.

Temporary variables.  These have automatic storage duration and (essentially) no linkage.  No entries will be made for these variables in the project data base.  In assembly, these variables will be represented as registers or locations on the run-time stack, or both.
A common strategy employed in many compilers is to make the following assumptions: 1) All temporaries are equivalent to registers for the purposes of determining whether an instruction is valid.  That is, at the time that a temporary is actually used by an operator, the temporary will actually be assigned a register.  2) The code generators will assume that an unlimited number of temporaries are available.  If more are needed than are actually available, a register will be freed by spilling its contents to a location on the stack.

The code thus must keep track of the actual location of a temporary.  The symbol table for a temporary will contain the register number and the stack offset.  Both these fields could be held in a common field, provided a bit exists somewhere to distinguish between their uses.

There are many ways to allocate space for temporaries. The following discussion assumes the following:  1) no conmmon subexpressions are recognized by the compiler.  That is, code for each expression will be generated independently from all other expressions.  This is the simplest method.  It assumes that the programmer will keep common subexpressions in variables (possibly register variables).  2) Registers will be allocated to named variables only as the result of the register keyword.  This allows the user maximal control.  3) The same registers are used as scratch registers as are used in the Think C compiler.  This means that registers a0, a1, d0, d1, d2 and d3 are scratch registers, and registers a2, a3, a4, d3, d4, d5, d6 and d7 (the user registers) are available to be assigned to user variables.  User registers can also be used as scratch registers if they have not been allocated to a user's automatic variable.  (Note that whether a user register is used as a scratch register can change from block to block.) Register a5 points to the start of the global variables, register a6 points to the current stack frame and register a7 is used (as is required) points to the top of the run time stack.

In the interests of simplicity and comprehensibility, I am going to reject the C* approach.  Temporary variables will be represented as offsets from a6, the frame pointer.  While this requires the use of a6 in all but the very simplest functions (i.e., those without any auto or temporary variables), using a6 has several advantages:  1) debugging becomes slightly easier since a6 always points to the current stack frame, 2) the offsets used to access temporaries do not change when the a7 changes.

Allocating space for temporaries need only be done when the temporary is spilled.  Each expression will keep track of the number of spilled variables is requires.  When a spill occurs, the temporary is allocated to offset i on the stack.  The starting offset i is -x, where x is the size of the first temporary.  The offsets decrease as new temporaries are spilled.  At the end of an expression, i is set to 0 again so that the space on the stack is reused.  The maximum value of | i | is used to allocate space on the stack for temporaries.  This maximum value is remembered in the global fbody_gnode.

Simplifying the Code Generators

The C* code generators seem more complicated than they need to be.  The culprits:  1) indexing temporaries off the stack pointer rather than the frame pointer,  2) modifying entries in the S-stack, 3) trying to make all optimizations in a single pass, 4) using very complex loc nodes, 5) generating code at sequence points on the fly, 6) having resolve try to do too much.  Let's see what we can do to make the code more straightforward.

Simplifying loc nodes

In the new simpler scheme, loc nodes still must represent the following: constants, variables, temporaries (both registers and spilled registers), and at least some of the address modes.

	constants:		#xx
	variables:		yy or yy(a6) or yy(a5)
	temporaries:	ax or dx
	spilled temps:	yy(a6)
	
There is a question about what to do about floats.  In particular, doubles need more than 4 bytes.  It would be possible to allocate two registers to them.  Alternatively, floats could always be stored on the stack.

A new philosophy of code generation

After much reflection, I have chosen to change the philosophy underlying the code generators.  The new code generators will differ in several important ways from the C* code generators.  First, and most importantly, the S-stack will be eliminated.  Second, no optimizations involving the 68000's address modes will be performed in the code generators themselves.  Such optimizations will be done in a new peephole phase.  Third, the code generators will pay less attention to the distinction between the address of an object and its value.  It turns out that playing dumb in this way will produce much simpler and clearer code generators.  Fourth, the register allocation routines will be completely rewritten.  These routines will now follow the Think C scheme more closely.  These routines could not be rewritten while the S-stack was in place.

The code generators need not be nearly so complex as were the C* code generators.  All the changes mentioned above should simplify the code.  The addition of a final arithmetic peephole pass should result in the same excellent generated code.

The old C* code generators are very hard to understand.  I would have left them intact if I could have, but since they have to be substantially changed anyway, I have decided that little would be lost by changing them more radically.

Eliminating the S Stack

Using the S stack was a good idea but very bad engineering.  While the C* code generators worked, they depended on complex global theorems whose proof involved examining just about every part of the code generators.  Even worse, perhaps, using the S stack locked the code into rigid patterns.  Finally, the code to allocate a temporary variable become almost impossibly complicated.

The new code will allocate non-register temporaries in the function's stack frame, (with a fixed offset from the a6) register) rather than on the top of the stack (with an offset of 0 from a7).  This simplifies several aspects of code generation.  First, the code generators don't have to be fanatically careful about changing the stack, because items can be pushed or popped without changing the address of spilled temporaries. 

Second, spilling a register becomes trivial because any register (except the register used for the source register of a binary machine operator) may be used.  In the old C* compiler, only the register at the bottom of the S stack could be spilled, because only that register would be at the top of the R stack when the spilled register was finally accessed. By the way, I keep forgetting the details of this process, and what I have just said may not be completely correct.  I've never been able to keep all the details of the old register spilling process clearly in my mind, which is one of the main reasons why I have decided to abandon the algorithm.

 allocating and spilling registers is simple.  

The *, &amp; and sizeof operators

In the C* code generators a distinction was made between the value of a variable and the address of a variable.  As I recall, this was motivated by the desire to do perform an optimization during the actual code generation.  For instance, the expression *&amp;a is equivalent to a, so if the code generator for &amp; records the fact that &amp;a stands  for the a's address (instead of actually generating code), the code generator for * can generate the best code.

In the C* code the resolve routine was called to ensure that an operand was actually loaded with a value, not its address.  

The place for the distinction between a value and an address is in the parser.  The ANSI Standard specifies exactly what is an lvalue and what is not.  This distinction invalidates constructions such as 25 = *a;  The parser catches, (or will when it is complete), so that for the most part the code generators can assume that the parse tree is correct.
With the new CC2 code generators, the distinction between a primitive and its address will be ignored.

The code generator for &amp; loads the address of its operand into an a register.  The operand to the &amp; operator must be either  1) a variable, e.g., &amp;a, 2) a primitive, e.g., &amp;a-&gt;b 3) a function designator, e.g., &amp;f, or 4) an expression that is an lvalue, &amp;a[i].  In case 4, the expression must have an address, i.e., it must be an lvalue.  The code generator for &amp; must only deal with those operators that do produce an lvalue, namely +, -, * and &amp;, ., [] and -&gt;.

Let us postulate the existence of a routine called gen_address that returns the address of an expression instead of its value.  gen_address(t) will report an error unless the expression t is an lvalue.  Clearly, it must be possible to write gen_address().  The expression tree t must have one of the forms mentioned above.  

ampersand, the code generator for &amp;, just calls gen_address with the appropriate argument.  star_value, the code generator for value of * is simple--it loads its argument into a areg, then does an indirection on the areg.  star_address, the code generator for the address of * simply returns its argument.

The resolve routine becomes unnecessary because operands in the CC2 code generators are always resolved.

The code generators never see the sizeof operator, because the parser translates the sizeof operator into an integer constant.

Satisfying the constraints of machine operators

Perhaps no other area of the compiler has created so much confusion and complication.  I am inclined to believe that most of this confusion and complication is unnecesary. Consider the ADD operator, applied to integers (byte, int or long).  The allowed forms are:

	ADD	&lt;ea1&gt;,dn
	ADD	dn,&lt;ea2&gt;

If the result of this operation is wanted, then only the first form is valid, unless ea2 specifies a temporary.  Actually, lots of different sequences might be optimal, depending on context.

	a += 1;	ADDQ #1,a
	a = a + 1;	MOVE a,dn; ADDQ #1,dn; MOVE dn,a // peephole sequence

If using a d-reg causes a spill later on, it might be best to use a stack temp, but in general the greedy algorithm should work well enough (always leave the result in a dreg).  Besides being simple, the greedy algorithm may help the peephole.

The operator assignment operators are clearly different from the simple assignment operator: the LHS of the assignment must be evaluated only once.  If the LHS is a variable or a primitive, do the following

	a op= b;	move a,dn; op b,dn; move dn,a;

The += and -= operators are special cases since the ADDQ and SUBQ instructions exists.

This code is handled in sop_assnop.  The various cases here should probably be factored out so as to make the code more simple.

New facts about instruction choice

1.  In most cases there is no choice about the ADD instruction, the ADD &lt;ea&gt;,dn form must be used be cause the destination must be a temporary (hence a register).  At the outer level the ADD dn,&lt;ea&gt; form can be used.  Actually, the ADD dn,offset(a6) form could also be used if the temporary were held in the stack frame instead of a register (I suppose that might be preferable if it saved a register spill.

2.  The register-minimization algorithm assumes a symmetric instruction set.  The 68000 has an asymmetric set, so some modifications must be made.  If the most complicated branch is evaluated first, and is evaluated into a register, then there is not problem.  Use the ADD &lt;ea&gt;,dn form, where dn holds the most complicated branch and &lt;ea&gt; holds the least complicated branch.

3.  At the outer level, the ADD dn,&lt;ea&gt; is generally preferable, assuming that dn is really needed.load routine.   
</t>
<t tx="ekr.20080529093004.367">How CC2 Generates Code

This file discusses how CC2 generates code.  A lot has changed since July 15, 1992 when the original gen.c was written.  This file is organized as follows:  The first section highlights the differences between the C* and CC2 code generators.  The next five sections discuss how nodes and fields are represented.  Surprisingly,  these representational issues are the most important part of CC2's code generators.  The final sections discuss individual code generation routines and techniques.

Overview: C* versus CC2

The CC2 code generators are completely different from the C* code generators, both in strategy and in detail.  The C* approach was excessively complicated and was difficult, if not impossible, to fully understand.  The CC2 code generators use a traditional approach and are straightforward.

Two design decisions made the C* code generators complicated.  First, the S and R stacks were used to spill temporary registers to stack locations expressed as offsets from A7, the stack pointer.  Second, loc nodes represented arguments that were not necessarily represented as a single 68000 address mode.  Both of these decisions were meant as optimizations and both turned out to be ill advised.

The CC2 code generators spill temporary registers to stack locations expressed as offsets from A6, the frame pointer.  Because the value of A6 does not change during the execution of a function, the offset of a spilled temporary variable never changes.  In C* by contrast, changing the stack pointer  implicitly affected the address of all spilled temporaries.  Global theorems were needed to insure that spilled temporaries were properly addressed.  In addition, C* could run out of temporaries in some situations: a completely unacceptable state of affairs.  Finally, it was never clear to me whether the C* method of allocating temporaries could be adapted to work with nested blocks, as is required in ANSI C.

The CC2 code generators represent machine arguments by anodes, which correspond to 68000 address modes.  As it turns out, this simplifies the code generators enormously.  The old C* loc nodes were invented in order to delay the generation of code as long as possible in order to be able to recognize certain optimizations on the fly.

The CC2 code generators generate fairly simple-minded code.  This is not a problem because a separate arithmetic peephole pass will discover the kind optimizations that were made possible by C*'s loc nodes.  This peephole pass should be straightforward and fast.  The result is that CC2's code generators are much, much simpler than the C* code generators.

loc nodes, anodes and cnodes

CC2 represents nodes and fields in a more descriptive manner than did C*.  The present scheme looks natural and obvious, but is the result of a lot of experimentation and revision.  Indeed, several Aha's were necessary to create the present simplicity.

First, I had to separate nodes into proper classes.  In C* there was only one node class.  Earlier versions of CC2 used pnodes, enodes, inodes, tnodes and cnodes.  arg_cnodes were a subclass of cnodes.  It finally dawned on me that arg_cnodes should be completely distinct from cnodes and arg_cnodes were renamed anodes. This allowed anodes and cnodes to have different formats.  More importantly, anodes are conceptually distinct from cnodes, and making that distinction explicit greatly clarified the code.

Looking back, it seems obvious that loc nodes are precursors to anodes.  However, this realization came only after I had created anodes.  Sigh.  Both loc nodes and anodes represent arguments to machine instructions.  However, loc nodes represented "virtual" arguments, while anodes represent actual address modes.  In C*, the x_resolve routine had to be called to guarantee that a loc node actually represented an valid machine argument.  This greatly complicated the C* code generators because one could never just use a loc node: one had to test it first.  Loc nodes had other serious drawbacks.  In effect, they were implicit unions.  In order to tell what a loc node really was, one had to test all of its many fields.  The result was a mess.
Operands are anodes, anodes are operands

Anodes represents both machine operands and valid address modes.  In other words, machine operands are represented by an address mode.  This identification of operand with address mode (a kind of pun) simplifies the code generators enormously.  The code generators can often use anodes as operands without even looking at the n_type field that indicates the address mode because they know beforehand that an anode always represents an argument which is representable by a valid address mode.

The C* code generators distinguished between loc nodes representing an operand and loc nodes representing the address of an operand.  (It did this to allow the possibility of more optimization.)  The CC2 code generators do not need this "address-of" bit.  The differences between an operand and its address are handled by changing address modes, possibly as the result of generating code.

This is actually a fairly subtle point.  The code in CC2 that handles the &amp; (address of) and * (dereference) operators create anodes representing their results by, in some cases, changing the address modes of their operand.  In other cases, the &amp; and * operators must actually generate code.  In all cases, though, the anode representing the result contains enough information to use the result without worrying about where the result came from.  This is a direct result of identifying operands with address modes.

As yet another example of how anodes simplify code generation, notice that the const_anode for a double constant represents a label, i.e., an address, not a value.  This makes no difference since the code generators for floating operands know that the representation of a floating constant is a label.  The assembler doesn't care either.

In short, in almost all cases the code generators can be written in the most straightforward manner without worrying about what their arguments mean.  CC2's code generators are almost as simple as typical p-code generators because they can ignore many representation details.  Indeed, I estimate it would only take a day or so to replace the current code generators with p-code generators.  While I doubt that we will ever want to do so, it is a possibility to keep in mind.

Unions are back

C* represented classes by using unions.  As mentioned in previous documentation, this is not a good idea and I eliminated such unions from CC2.  However, there is another use for unions which is valid, namely to hold alternate representations of operands.

For example, unions are used in const_anodes, a subclass of anode representing a constant.  There are many ways in assembly language to represent a constant.  Integers can be represented directly, as in

	move	#25,...

Double constants, though, can not be represented directly, and must be represented by the label of the memory location holding the double constant, as in

	pea	internal_label
	...
internal_label	dc.d	"3.14159"	;MPW assembler syntax

It would be clumsy and misleading to represent the various kinds of constants as subclasses of const_anode.  Instead, a union represents the situation accurately.

There is a slight storage penalty involved in using unions for this purpose because space for the largest member of the union must be allocated.  However, this penalty is small because the largest representation takes only 4 bytes.  Also, using a union means that a copy of the const_anode can be made without checking the type of the union.  It turns out that this is important, as will be explained in the section called freezing anodes.
The kind fields

Most anodes and some enodes now contain unions.  Various fields, whose names end in kind, indicate what the the corresponding union actually contains.  The kind fields are accessed only by the code that creates the anode and by the code that prints it.  The code generators ignore the kind field!  If the n_type field also indicated the kind of the union, all the code generators would be greatly complicated.

One can view the kind field as indicating a lightweight class. The class should be lightweight because we don't want purely representational issues infecting the code.  This is, perhaps, a subtle point, but it turns out to be important.

Hiding bit fields

Recently I discovered the coding principle that the representation of all quantities that are, or could be, represented by a bit field should be hidden.  This is one of the simplest and happiest discoveries about programming that I have ever made.  Let's refer to a quantity that could be represented as a bit, but may or may not actually be represented that way, as a logical bit.

The C* code referred to actual bits throughout the code, especially the tmods and smods bits.  I initially revised the code to use macros to access the bits, but the fact that quantities were represented as bits remained explicit.  I finally realized that instead of using macros to reference bits, I should use macros to reference the quantities represented as bits.  See the snode and tnode sections of nodes.h for the actual definitions of these macros.

Using these new macros creates wonderful benefits.  First, the actual appearance of the source code becomes simpler and less cluttered; the descriptive power of these macros is much greater than before.  Second, it becomes possible to reassign bits to different fields of a struct without changing any of the code that uses it.  This flexibility is often needed when trying to find space for "one more bit." Finally, there are some cases when a mutually exclusive set of values can be used instead of using individual bits.  For example, the LONG_LTMOD, CHAR_LTMOD and INT_LTMOD fields are mutually exclusive.  Hiding the representation of these logical bits allowed me to represent these quantities in the new tlength field.  Surprisingly, using the tlength field decreases the size of gfloat.c and gint.c by about 40%  The code to test a bit in a bit field is much larger than the code to test a char field for a particular value.

After adding this new macros, it became easy to find space for the save/restore bits which will be needed when reading and writing the project data base.  Note that other logical bits can share the field used by the save/restore bits without being represented as actual bits.  The reason is that the save/restore bits will always be cleared while CC2 is running so that their existence is effectively hidden.

This concludes the discussion of representation of nodes and fields.  The remaining sections discuss more procedural topics.

The main line of code generation

In your last letter you said, its at the conception stage where programs are made or broken.  As I have attempted to show above, anodes are the fundamental concept of the code generators.  Even so, it is still surprising to me that the heart of the code generators is the part that deals with variables and constants.

Dealing with all the many operators becomes simple if anodes are created properly, but creating anodes in the first place is messy.  Creating anodes is messy because the size, type, storage class and storage duration of a constant or variable must all be taken into account.  Indeed, without the ability to create new fields in the unions of the various kinds of anodes, generating anodes would have been even more laborious than it was.

The main line of the code generators is difficult to see because it is spread out over several files and because it deals with differing concepts.  Most anodes are created in gen_alloc_outers, gen_alloc_locals and gen_alloc_formals, all in the file gbody.c.  These routines associate the newly created anode with the snode representing the C language primitive.  This association is made by setting the sarg field of the snode.

The sarg field is another happy Aha.  Once this field is set, the code generator (either gi_prim or gf_prim)  which is to load a constant a variable needs only return the sarg field of the corresponding snode.

The last part of the main line is out_decl, which actually outputs the definitions of variables and constants.  Not all variables and constants need to be explicitly defined.  Stack variables and most constants are defined implicitly.

In short, the main line of code generation consists of expr_prim, expr_cprim, gen_alloc_outers, gen_alloc_locals, gen_alloc_formals,  gi_prim, gf_prim and out_decl.  It would not be much of an exaggeration to say that if you understand these routines you understand the code generators.  See the code generated from the file hello_code.c for examples of the different kinds of actions that have to be taken by the routines of the main line.

Freezing anodes

The C* code generators copied loc nodes in a variety of situations in order to prevent unintended side effects.  For example, a loc node might be attached to a code node but it might still refer to a location.  Changing the loc node would change the already-generated instruction unless a copy of the loc node were made.

The CC2 code generators handle this problem more smoothly.  Whenever a cnode is added to the global code list by the c_put routine, a copy of the anodes attached to the cnode is made.  This process is called freezing the anodes.  The code generators depend on this freezing to eliminate unwanted side effects when anodes are modified later.  Actually, the only anodes that can ever be changed after they are generated are spill_anodes, so only those nodes are frozen.

The arithmetic peephole optimizer

The code generators are greatly simplified by delaying optimizations until a later peephole pass.  However, the code generators should still provide the best code that they can in the local context.  The arithmetic peephole should be used only for those optimizations that can not be recognized locally. 

The arithmetic peephole will run after the regular peephole so that the flow of control is as simple as possible.  This will minimize the number of basic blocks and will make more arithmetic optimizations possible.

In order to make sure only valid optimizations are performed, each anode contains an a_length field, indicating the machine length of the operand, i.e, either byte, word, long or none.  The a_length field is partially redundant because cnodes also contain a length field.  However, the a_length field simplifies various function calls and also serves as a consistency check.

While I have not designed the arithmetic peephole in detail, it will certainly depend on a table of aliases.  When a register is loaded from a variable, the register becomes an alias for that variable.  This table can be used to eliminate redundant loads and stores.

Other patterns can be recognized.  For example,

	move.b (an),y
	...any code not using or setting an...
	addq #1,an

can be replaced by

	move (an)+,y

One can spend huge amounts of (human) time finding and optimizing such patterns.  I plan to optimize only the patterns that yield a significant payoff.  Actually, the real payoff in having the arithmetic peephole available is that the code generators are simplified.  

Debugging options

Two new command-line arguments allow Sherlock-style tracing and statistics in the production version of CC2.  The gen_trace argument prints code nodes as they are added to the global code list by c_put.  The no_output argument disables only the routines in cout.c while leaving code generation enabled.  This provides a simple way of measuring the time spent in code generation while ignoring the time spent actually sending the output to the screen or to a file.

Allocating variables declared in inner blocks

At first I thought I woould have to create a tree structure reflecting the nesting of blocks in order to be able to allocate auto variables declared in nested blocks.  However, I realized that all I needed to do was to keep track of two quantities, gen_current_alloc and gen_max_alloc.  The gen_alloc_locals routine allocates the next stack variable at gen_current_alloc.  When a block is exited, the value of gen_current_alloc is restored to the value it had when the block was entered.  This allows stack variables (both user and temporary) in non-nested blocks to share stack space.  The gen_max_alloc variable is used to allocate space for all stack variables at the start of the function using the LINK machine language instruction.

Static variables declared in blocks present more problems because they must be allocated in static memory (as opposed to stack memory) and must therefore have unique names.  It appears that a separate pass will have to be written to properly allocate unique names for these variables.  This pass will be called from gen_function just before calling gen_list().</t>
<t tx="ekr.20080529093004.368">The attached file contains the log of compiling all files of CC2 with CC2 itself on a Quadra 800.  This log contains a dump of all Sherlock statistics and the statistics generated by the lifetime allocation routines.  CC2 can generate other stacs,compiler and loader.  Some routines are missing from these files: they are to be "over-ridden" by application-specific routines.

For example, all "error stream" output goes through the es() function, and es() is defined not in LIBes.c but in CCes.c, ASess.c, etc.  This allows per-application control of all output.  Funneling all output through es() is handy while bootstrapping.

I prefer to use the routines in LIBes.c rather than fprintf, and d iler to catch all type problems during printing.

There are the routines in LIBcvt rather than sprintf.  This allows the compiler to catch all type problems during printing and scanning.

There are only a very few calls to sprintf in the tools, and they are found in LIBcvt.c, LIBos.c, LIBtime.c, and possibly LIBes. interfaces with the file system.  The current version of LIBio.c just calls ANSI io routines, but calls to a native OS can be made easily here:  LIBio.c should making porting CC2 easy.

The os() function in LIBos.c buffers characters by handtion itself is before writing a block at a time.  The os() function itself is fast, but closing the file used by os() is the most time-consuming part of CC2, at least on the Mac.  Apparently the Mac OS writes most of a file whenon.  When debugging is on these routines aocate sentinel bytes before and after all allocated blocks.  These bytes are checked when the block is deallocated, and the ++obj_v Sherlock trace checks all bytes whenever any memory is allocated or freed.  This catches corrupted memory quickly.  It is also possible to use the Sherlock watch mechanism to watch individual blocks.

LIBmem.c contains the lifetime-oriented memory routines.  Application-specific routines tailor these routines as needed.  For example, see CCmem.c and CCmem.h.

LIBcmnd.c contains routines to parse the simulated command line used by Sherlock and the tools themselves.  Routines in this file never need to be over-ridden.

Each tool contains definitions of several variables used by the library.  These "variables" are really constants, and making them variables allows the linker access to them.  The file LIBlib.c contains a template file: each tool contains a corresponding file (essentially over-riding the template file.)  For example, see CClib.c.

The development library is flexible

The rest of this letter contains some notes about the "development library" in DevLibSrc.   These routines are shared by the tools, that is, the assembler, linker, LibSrc.   These routines are shared by the tools, that is, the assembler, linker, linker, c depending on the  compile-time constant, LIB_USE_CVT.  This was a help when compiler errors broke sprintf.

LIBio.c and LIBos.c contain thee was being debugged.

LIBio.c and LIBos.c contain the sprintf was being debugged.

LIBio.c and LIBos.c contain thenough to be used by a variety of tools with somewhat different needs.  When I find something that can't be handled in a general manner I take the routine in question out of the DevLibSrc source file and require that all tools create their own version of the function.  This happens rarely enough so that DevLibSrc is more than just a collection of templates.
</t>
<t tx="ekr.20080529093004.369">@ The file CCnodes.h is perhaps the most important header file in CC2.  If I were going to revise CC2 using Leo I would certainly split this header into sections.

Another very important file is CCtokens.h.  See the Tokens &amp; preprocessor section.</t>
<t tx="ekr.20080529093004.370">/*
	CC2: Master header file

	Include this file in all .c files.

	Source:  CC.h
	Started: September 14, 1991
	Version:
		June 1, 1994.
			Rewritten for devlib.
*/

#ifndef cc2_h_
#define cc2_h_

#pragma once

/*
	Include files that should be included in each file.
	CCtypes.h must be included first.
*/

#include &lt;LIBlib.h&gt;		/* Must be first. */
#include "CCtypes.h"	/* Must be second. */
#include "CCerr.h"

#define elist(statements) { elp(); statements; erpnl(); }
#define elistx(statements) { elp(); statements; es(") "); }

#ifdef PRODUCTION
	#define STATS(s)
#else
	#define STATS(s) s
#endif

#define bit(field,the_bits)			((field) &amp; (the_bits))
#define clear_bit(field,the_bits)	(field) &amp;= ~(the_bits)
#define set_bit(field,the_bits) 	{(field) |= (the_bits);}

#endif /* cc2_h_ */
</t>
<t tx="ekr.20080529093004.371">/*
	CC2: header parser and code generation nodes.

	Source: nodes.h
	Started: May 22, 1992.
	Version:
		December 21, 1994.
			Added t_is_big_type.
		August 26, 1994.
			Defined e_is_folded and e_set_folded macros so that constructs such as
			x += 0; (which folds just to x) will not create a warning about a
			"possibly useless expression"
		June 10, 1994.
			Moved enums into tok_info [].
		November 1993.
			Reorganized how float constants are represented to support
			initializers containing operations on floating constants.
				Added e_long_double field.
				Added econst_xxx macros.
		July 29, 1993.
			Made a_debug and a_sname permanent rather than debug-only.
		July27, 1993.
			Bug fix: changed all boolean macros involving bit.
		July 22, 1993.
			Added STRING_REF_CKIND.
		June 30, 1993.
			Changed a_will_freeze to c_arg_will_freeze.
		June 15, 1993.
			*** A Major Revision of tnodes ***
			1) Eliminated the tlength field.
			2) All flags now contained in the tflags field.
			3) Eliminated type-distinguishing flags.
			4) Eliminated macros that depend on type-distinguishing flag
			   (The code now tests tsize directly.)
		June 10, 1993.
			Changed p_set_line_count_macro so it evaluates its argument only once.
		June 5, 1993.
			Bug fixes to t_is_volatile and t_set_volatile.
		May 25, 1993.
			Removed unused bc_parent field from bc_nodes.
		May 23, 1993.
			Added p_line2_ptr and p_line2_count fields to do nodes.
			Added p_set_line_count2_macro.
		May 6, 1993.
			Printed copy sent to Tuple.
		May 4, 1993.
			Added s_clear_proto.
		April 30, 1993.
			Added c_set_perm_label, c_is_perm_label so case labels will never be removed.
			Added a_is_stackop.  (Not used now, and maybe will never be used.)
		April 27, 1993.
			Created ulabel_cnode for user labels.
		April 26, 1993.
			Added s_is_defined, s_set_defined macros.
				The s_is_defined hack works around a problem with the MPW assembler,
				namely that IMPORT and EXPORT directives can not coexist (boo hiss).
				s_is_defined set TRUE when a prototype or function definition is seen
				in the main file (not in a header file).
				Thus, simply add a function prototype to disable an unwanted IMPORT.
		April 22, 1993.
			Added switch_next, switch_jtab and switch_default_label fields to switch_nodes.
			Added s_is_import, s_set_import, s_clear_import.
		April 13, 1993.
			Replaced p_unused by p_line_count in pnodes.
			Added c_line_count field to line_cnodes.
			Added p_set_line_count_macro.
		April 8, 1993.
			Added a_is_indirect.
		April 5, 1993.
			Redefined t_is_short and t_set_short.
		April 2, 1993.
			Added BLOCK_CKIND.
			Changed format of AUTO inodes.
		March 26, 1993.
			Merged flaot_enodes into const_enodes and removed float enodes.
		March 25, 1993.
			Added AUTO_ITYPE and related fields.
			Made e_defstr a permanent part of float_enodes.
		March 24, 1993.
			Added s_set_proto and s_is_proto.
		March 14, 1993.
			Changed e_debug to e_defstr, which is now always defined.
			(e_defstr is needed to generate code for initializers.)
		March 8, 1993.
			Added c_line_ptr field to line cnodes.
			Added p_line_ptr field to pnodes.
		March 3, 1993.
			Added s_clear_typedef.
		February 12, 1993.
			Added block_alloc field to block_nodes.
		February 11, 1993.
			Added reg_list_nodes.
			Added block_regs field to block nodes.
		February 10, 1993.
			Removed xxx_CLEN constants.
			New table_cnodes.
			Added a_voffset and a_vprefix fields to var_anodes.
			Merged a_vxname and a_vlibname into a_vname field.
		February 7, 1993.
			Removed the union containing the e_float and e_long_double fields.
			Bug fix: some of the smods bits overlapped!
		January 30, 1993.
			Removed comment about unused s_set_su_elem.
			Bug fix to a_has_areg macro.
			Improved t_set_xxx macros by also setting tsize field.
		January 26, 1993.
			Removed several obsolete inode items.
			Added xxx_debug fields to various nodes.
		January 22, 1993.
			Added ADDRESS_EA.
		January 21, 1993.
			Added a_has_areg macro.
		January 18, 1993.
			Removed various unused fields and macros.
		January 12, 1993.
			Added s_is_array and s_set_array macros.
		December 31, 1992.
			Added a_sname field for debugging to spill_anode_struct.
		December 26, 1992.
			Added a_is_quick8 and a_is_quick255.
		December 2, 1992.
			Added is_xloc macros.
			Removed link fields from anodes. (anodes are no longer cnodes.)
		November 18, 1992.
			Revised const_enodes.
			New float_enodes.
			Removed other enodes representing constants.
		November 14, 1992.
			Added BRACE_ITYPE.
		November 7, 1992.
			Added new items to anode class.
			Use enum in opcodes.h to define n_type field for anodes.
			Eliminate loc_nodes!
		November 6, 1992.
			Changed loc_nodes to enodes and manodes.
			Changed asm_cnodes to mnodes.
			Added various enodes to represent constants, strings and variables.
			Changed format of cnodes.
			Removed literal cnodes.
		September 28, 1992.
			Replaced all unions defining "classes" by structs
				representing the common fields of all subclasses.
			Replaced ENUM_TYPE by INT_TYPE with ENUM_TMOD.
		September 11, 1992.
			Added BIT_FIELD_SMOD.
			Added ARRAY_SMOD.
			Added ARRAY_TMOD.
		August 12, 1992
			New formats for symbol nodes and type nodes.
		August 6, 1992.
			Converted dcl_nodes to st_nodes.
			Eliminated DELEMENT_TYPE from type nodes.
		July 29, 1992
			Added ENUM_TYPE.
		July 27, 1992
			Added block nodes and dcl_nodes.
		July 16, 1992
			Removed old spellings of structs.
			Eliminated goto_cnodes.
			Added defintions of spell nodes and macro nodes.
		July 4, 1992
			Removed c_format field from code nodes.
		June 30, 1992
			Removed old definitions of fields.
		June 12, 1992
			Added n_optype to all enodes.
		June 9, 1992
			Created en_ntype enumeration.
			Merged gen.h with this file.
		June 5, 1992
			Abbreviate field names for st_nodes, loc_nodes, type_nodes.
			Add ctype field to loc nodes.
		June 4, 1992.
			C* fields merged into this file.
		May 22, 1992.
*/

/*
	Make sure this file is inluded only once.
*/
#ifndef nodes_h_
#define nodes_h_

/* ----- Abbreviation macros ----- */

/*
	Define abbreviation macros for converting pointers.

	This machinery would be unnecessary if we could define
	a hierarchy of types as in C++.
*/

	/* general */

#define snode_ptr(p)	((snode *) p)
#define tnode_ptr(p)	((tnode *) p)

	/* anodes */

#define anode_ptr(p)		((anode *) p)
#define const_anode_ptr(p)	((const_anode *) p)
#define m20_anode_ptr(p)	((m20_anode *) p)
#define spill_anode_ptr(p)	((spill_anode *) p)
#define var_anode_ptr(p)	((var_anode *) p)

	/* cnodes */

#define cnode_ptr(p)		((cnode *) p)
#define cinode_ptr(p)		((cinode *) p)
#define label_ptr(p)		((label_cnode *) p)
#define line_ptr(p)			((line_cnode *) p)
#define table_ptr(p)		((table_cnode *) p)
#define ulabel_cnode_ptr(p)	((ulabel_cnode *) p)

	/* enodes */

#define enode_ptr(p)			((enode *) p)
#define const_enode_ptr(p)		((const_enode *) p)
#define cons_ptr(p)				((cons_enode *) p)
#define op1_ptr(p)				((op1_enode *) p)
#define op2_ptr(p)				((op2_enode *) p)
#define op3_ptr(p)				((op3_enode *) p)
#define var_enode_ptr(p)		((var_enode *) p)

	/* pnodes */

#define pnode_ptr(p)	((pnode *) p)
#define break_ptr(p)	((bc_node *) p)
#define block_ptr(p)	((block_node *) p)
#define case_ptr(p)		((case_node *) p)
#define continue_ptr(p)	((bc_node *) p)
#define do_ptr(p)		((do_node *) p)
#define expr_ptr(p)		((expr_node *) p)
#define for_ptr(p)		((for_node *) p)
#define goto_ptr(p)		((goto_node *) p)
#define if_ptr(p)		((if_node *) p)
#define return_ptr(p)	((return_node *) p)
#define switch_ptr(p)	((switch_node *) p)
#define ulabel_ptr(p)	((ulabel_node *) p)
#define while_ptr(p)	((while_node *) p)

/* 4/13/93: careful: p_line_count is a char-length field. */
#define p_set_line_count_macro(p, count) \
{\
	long temp_ = count;\
	p -&gt; p_line_count = max(0,min(255, temp_));\
}
#define p_set_line2_count_macro(p, count) \
{\
	long temp_ = count;\
	p -&gt; p_line2_count = max(0,min(255, temp_));\
}

/*
	Node heads:
	These macros define the fields common to various classes of nodes.
	In effect, these define the fields of a base class from which
	subclasses can be derived.
*/

#if 0 /* now defined in CCtypes.h. */
	#define COMMON_NODE_HEAD	/* Common part of all nodes. */\
		token	n_type			/* Node type. */

	#define LINKED_NODE_HEAD	/* Header for all linked nodes. */\
		COMMON_NODE_HEAD;\
		void *	n_next

	struct linked_struct {
		COMMON_NODE_HEAD;
		void *	n_next;
	};
#endif

/*
	----- anodes -----
	anodes define machine language arguments refered to by cnodes.
*/

/*
	The following address modes (as well as some others) are defined in opcodes.h.
	These form the n_type field of anodes.
	The address modes ending in _EA20 are not available on the 68000 and are
	not currently generated by the code generators.

	LIB_ABSOLUTE_EA, LIB_IMMEDIATE_EA and IMMEDIATE_SYMBOL_EA denote alternate
	represent of ABSOLUTE_EA or IMMEDIATE_EA modes.  These *pseudo address modes*
	allow the code generators to represent operands efficiently.

	ABSOLUTE_EA,			adr
	ADDRESS_EA,				#adr
	AREG_EA,				a4
	DISPLACEMENT_EA,		#word(a6)
	DREG_EA,				d5
	IMMEDIATE_EA,			#nn
	INDIRECT_EA,			(a0)
	INDEX_EA,				#byte(a4,d4)
	LIB_ABSOLUTE_EA,		name of compiler library function
	PC_DISP_EA,				#word(pc)
	PC_INDEX_EA,			#byte(pc,xn)
	PC_POST_INDEX_EA20,		([bd,pc],xn.w*scale,od)
	PC_PRE_INDEX_EA20,		([bd,pc],xn*scale,od)
	POST_INC_EA,			(a0)+
	POST_INDEX_EA20,		([bd,an],xn*scale,od)
	PRE_DEC_EA,				-(a0)
	PRE_INDEX_EA20,			([bd,an],xn*scale,od)
*/

/*
	a_length is the machine length of an operand,
	which is no greater than 8 because arrays and
	structs are represented as pointers or addresses.
*/
#define ANODE_HEAD			/* Header for argument code nodes. */\
	COMMON_NODE_HEAD;		/* n_type indicates ea mode. */\
	char	a_length;		/* Length of the argument. */\
	char	a_flags			/* Various bits. */

	/* Define the values of the a_flags field. */

enum {
	NO_AFLAG = 0,
	TEMP_AFLAG,			/* TRUE: a temporary register or spill node. */
	SAVED_AFLAG			/* TRUE: already written to disk. */
};

	/* Define macros that hide the representation of the a_flags field. */

#define a_is_temp(ap)		(ap -&gt; a_flags == TEMP_AFLAG)
#define a_set_temp(ap)		(ap -&gt; a_flags =  TEMP_AFLAG)
#define a_clear_temp(ap)	(ap -&gt; a_flags =  NO_AFLAG)

/*
	Generic anode.
*/
struct anode_struct {
	ANODE_HEAD;			/* n_type indicates the address mode. */
};

/*
	Integer constants and float constants fit into a long word,
	but string, double and long double constants do not;
	Such *big constants* are represented by their address of
	a statically allocated object containing the actual constant.

	Nothing would be gained by representing big constants by
	their actual values using other fields of the a_cunion;
	real objects must be allocated for big constants,
	and the time to do this is at the time the const_anode is created.

	1/16/92: floats are big constants too.
	This makes the code generators more general, but less efficient.
*/
struct const_anode_struct {
	ANODE_HEAD;			/* n_type:IMMEDIATE_EA. */
	token	a_ckind;	/* Representation of a_cunion...xxx_CKIND: see CCtokens.h. */
	char *	a_debug;	/* The "print name" of the constant. */
	union {
		long			a_long_;
		label_cnode *	a_label_;	/* Label of string, float, double or long double. */
	} a_cunion;
};

#define a_long		a_cunion . a_long_
#define a_label		a_cunion . a_label_

/*
	The following defines the format of address modes unique to the 68020 and above.
	This structure is not used in the present code because CC2 generates
	no 68020 or 68030 instructions.
*/
#if 0 /* CC2 currently generates no 68020 or 68030 instructions. */
struct m20_anode_struct {
	ANODE_HEAD;				/* n_type: all xxx_EA20 modes. */
	int		a_m30_areg;
	int		a_m30_xreg;
	int		a_m30_scale;	/* Scale factor. */
	long	a_m30_bd;		/* Base displacement. */
	long	a_m30_od;		/* Outer displacement. */
};
#endif

/*
	Stack variables and all temporaries are represented by spill nodes.
	This makes it possible to change representations without creating new nodes.
	In this sense, spill_nodes are similar to the loc_nodes used in C*.

	All of the following address modes are represented by spill_nodes:
	AREG_EA, DISPLACEMENT_EA, DREG_EA, INDIRECT_EA, POST_INC_EA, PRE_DEC_EA,
	INDEX_EA, PC_INDEX_EA.
*/
struct spill_anode_struct {
	ANODE_HEAD;			/* n_type: see above. */
	int		a_sreg;		/* A-reg or D-reg, depending on mode. */
	int		a_sxreg;	/* Index register. */
	long	a_slong;	/* Offset: byte, word or long, depending on mode. */
	char *	a_sname;	/* Name of stack vars. */
};

/*
	Objects and functions may be represented in several ways.
	In most cases, the code generators ignore these different representation,
	so using a separate a_vkind field substantially simplifies the code.

	Using c_vunion makes copying a var_anode very easy.

	The a_voffset field is an important optimization,
	allowing addition as part of the address mode for non-stack variables.

	The a_vprefix field disambiguates static variables with the same name
	in the same file.
*/
struct var_anode_struct {
	ANODE_HEAD;			/* n_type: ABSOLUTE_EA or ADDRESS_EA */
	token	a_vkind;	/* Representation of c_vunion...xxx_VKIND */
	int		a_voffset;	/* nn, as in symbol + nn. */
	int		a_vprefix;	/* mm, as in file@name@mm. */
	union  {
		char *			a_vname_;
		long			a_vaddress_;
	} a_vunion;
};

#define a_vname		a_vunion . a_vname_
#define a_vaddress	a_vunion . a_vaddress_

/*
	Define macros that test the status of anodes.

	a_has_areg:		TRUE if a contains an A-reg: An, (An), -(An), (An)+, xx(An).
					Warning: this does not cover index modes.
	a_is_areg:		TRUE if a is an A-reg.
	a_is_atreg:		TRUE if a is a temp A-reg.
	a_is_constant:	TRUE if a is a constant.
	a_is_dreg:		TRUE if a is a D-reg.
	a_is_dtreg:		TRUE if a is a temp D-reg.
	a_is_quick8:	TRUE if a is a constant c with 0 &lt;= c &lt;= 8.
	a_is_stackop:	TRUE if a is (A7), -(A7) or (A7)+
	a_is_zero:		TRUE if a is an integer zero constant.
*/
#define a_has_areg(a)\
	(a -&gt; n_type == DISPLACEMENT_EA || a -&gt; n_type == INDEX_EA ||\
	 a -&gt; n_type == AREG_EA         || a -&gt; n_type == INDIRECT_EA ||\
	 a -&gt; n_type == POST_INC_EA     || a -&gt; n_type == PRE_DEC_EA)

#define a_is_areg(a)		(a -&gt; n_type == AREG_EA)
#define a_is_atreg(a)		(a_is_areg(a) &amp;&amp; a_is_temp(a))
#define a_is_constant(a)\
	(a -&gt; n_type == IMMEDIATE_EA &amp;&amp; const_anode_ptr(a) -&gt; a_ckind == LONG_CKIND)
#define a_is_dreg(a)		(a -&gt; n_type == DREG_EA)
#define a_is_dtreg(a)		(a_is_dreg(a) &amp;&amp; a_is_temp(a))
#define a_is_indirect(a)	(a -&gt; n_type == INDIRECT_EA)
#define a_is_quick8(a)		(a_is_constant(a) &amp;&amp; \
	const_anode_ptr(a) -&gt; a_long &gt;= 0 &amp;&amp; const_anode_ptr(a) -&gt; a_long &lt;= 8)
#define a_is_quick255(a)		(a_is_constant(a) &amp;&amp; \
	const_anode_ptr(a) -&gt; a_long &gt;= 0 &amp;&amp; const_anode_ptr(a) -&gt; a_long &lt;= 255)
/* a_is_stackop is not used in the current code. */
#define a_is_stackop(a)	 \
	((a -&gt; n_type == INDIRECT_EA || a -&gt; n_type == POST_INC_EA ||\
	  a -&gt; n_type == PRE_DEC_EA) &amp;&amp; spill_anode_ptr(a) -&gt; a_sreg == R_A7)
#define a_is_zero(a)\
	(a_is_constant(a) &amp;&amp;\
	const_anode_ptr(a) -&gt; a_ckind == LONG_CKIND &amp;&amp;\
	const_anode_ptr(a) -&gt; a_long == 0)

/*
	Return true if the c_arg1 or c_arg2 field is
	1. really an anode (it could be O_CLABEL or O_ULABEL instead)
	2. is a temporary.
*/
#define c_arg_will_freeze(ap) \
	(ap -&gt; n_type != O_CLABEL &amp;&amp; ap -&gt; n_type != O_ULABEL &amp;&amp; a_is_temp(ap))

/*
	----- cnodes -----
	cnodes represent code, i.e, individual machine instructions or pseudo ops.
*/

/*
	The n_type field for cinodes contains instruction types (X_xxx).
	The n_type field for other cnodes contains output codes (O_xxx).
	All these codes are defined in opcodes.h.
*/
#define CODE_HEAD			/* Header for code nodes. */\
	LINKED_NODE_HEAD;\
	cnode * c_back;			/* Back pointer. */\
	char	c_flags;		/* Various bits. */\
	char	c_length		/* Machine length. */

/* Define the values of the a_flags field. */
enum {
	NO_CFLAG = 0,
	PERM_LABEL_CFLAG,	/* TRUE: never remove this label. */
	MARK_CFLAG,			/* TRUE: label marked. */
	SAVED_CFLAG			/* TRUE: already written to disk. */
};

	/* Define macros that hide the representation of the c_flags field. */

#define c_clear_mark(cp)		{cp -&gt; c_flags &amp;= ~MARK_CFLAG;}

#define c_is_marked(cp)			(bit(cp -&gt; c_flags, MARK_CFLAG)			!= 0)
#define c_is_perm_label(cp)		(bit(cp -&gt; c_flags, PERM_LABEL_CFLAG)	!= 0)

#define c_set_mark(cp)			{cp -&gt; c_flags |= MARK_CFLAG;}
#define c_set_perm_label(cp)	{cp -&gt; c_flags |= PERM_LABEL_CFLAG;}

/*
	Generic code node.
*/
struct cnode_struct {
	CODE_HEAD;
};

/*
	Code node for machine instructions.
*/
struct cinode_struct {
	CODE_HEAD;			/* ASSERT(is_xtok(n_type)) */
	anode *	c_arg1;		/* argument node for arg 1 */
	anode *	c_arg2;		/* argument node for arg 2 */
};

/*
	Compiler labels are represented by longs.
	User labels are represented by strings.

	4/27/93:
	user labels require both a symbol label (for the label table) and
	a compiler label to handle multiple labels with the same name.
*/
#define LABEL_CODE_HEAD		/* Header for label code nodes. */\
	CODE_HEAD;\
	int		c_refcount;		/* Reference count. */\
	long	c_labnum		/* number for internal label. */

static struct label_cnode_struct {
	LABEL_CODE_HEAD;
};

static struct ulabel_cnode_struct {
	LABEL_CODE_HEAD;
	char * c_labsym;
};

/*
	Line numbers in the code list.
*/
struct line_cnode_struct {
	CODE_HEAD;				/* n_type is O_LINE_NUMBER. */
	long	c_line;
	token * c_line_ptr;		/* Ptr to the newline *before* the first token of the line. */
	int		c_line_count;	/* Number of lines to print. */
};

/*
	----- enodes ------
	enodes represent the operators and operands of expressions.
*/

#define ENODE_HEAD		/* Header for all enodes. */\
	LINKED_NODE_HEAD;\
	tnode * e_ctype;	/* Type of the expression. */\
	char	e_flags;	/* Various bits. */\
	char	e_nargs		/* Number of operands. */

/* Define the values of the a_flags field. */

enum {
	NO_EFLAG = 0,
	FOLDED_EFLAG, 	/* TRUE: The result (an id or constant) of a folded expression. */
	SAVED_EFLAG		/* TRUE: already written to disk. */
};

/*
	We use the folded_assop bit to flag situations such as
	
		a += 0;
		
	These usually happen when 0 comes from a macro expansion.
	It is senseless to warn about a possibly usesless expression in this case.
*/

#define e_is_folded(ep)		(bit((ep) -&gt; e_flags, FOLDED_EFLAG) != 0)

#define e_set_folded(ep)	{ (ep) -&gt; e_flags |= FOLDED_EFLAG; }

/*
	Define the parse node produced by C language operators.
*/
struct enode_struct {
	ENODE_HEAD;
};

/*
	Define "cons nodes" used to create expression lists.
	They take their name from "cons cells" in the LISP language.
*/
struct cons_enode_struct {
	ENODE_HEAD;				/* n_type is CONS_TOK (COMMA_TOK or SEMICOLON_TOK) */
	enode * cons_car;		/* Pointer to second subtree */
};

/*
	const_enode's represent all kinds constants.

	The n_type field is INT_TOK, FLOAT_TOK or STRING_TOK.
	The e_ctype -&gt; tmods field distingues amoung various possibilities.

	11/3/93: The e_defstr field is used whenever possible to ensure the maximum
	correspondence between what appears in the program and the actual value
	generated by the assembler for the constant.
	However, the e_defstr field is set to NULL when a constant is computed
	at compile time.

	11/3/93: To ensure maximum accuracy, all computations on floats are done
	using long doubles.

	11/3/93: All access to the fields of this struct is now via the econst_xxx macros.
*/
struct const_enode_struct {
	ENODE_HEAD;				/* n_type is INT_TOK, FLOAT_TOK or STRING_TOK */
	char *		e_defstr_;	/* The actual string: required for initializers. */
	anode *		e_anode_;	/* The anode representing the label for big constants. */
	union {
		long	e_long_;			/* n_type: INT_TOK. */
		ulong	e_ulong_;			/* n_type: INT_TOK. UNSIGNED_TMOD. */
		long double e_long_double_;	/* n_type: FLOAT_TOK, NULL e_defstr. */
	} e_cunion_;
};

#define econst_defstr(ep)		(const_enode_ptr(ep) -&gt; e_defstr_)
#define econst_anode(ep)		(const_enode_ptr(ep) -&gt; e_anode_)

#define econst_long(ep)			(const_enode_ptr(ep) -&gt; e_cunion_ . e_long_)
#define econst_ulong(ep)		(const_enode_ptr(ep) -&gt; e_cunion_ . e_ulong_)
#define econst_long_double(ep)	(const_enode_ptr(ep) -&gt; e_cunion_ . e_long_double_)

/*
	The code assumes in various places that these three operator nodes
	are prefixes of each other.
*/
struct op1_enode_struct {	/* Unary operator. */
	ENODE_HEAD;				/* ASSERT(is_unop(n_type)). */
	enode * arg1;
};

struct op2_enode_struct {	/* Binary operator. */
	ENODE_HEAD;				/* ASSERT(is_binop(n_type)). */
	enode * arg1;
	enode *	arg2;
};

struct op3_enode_struct {	/* Ternary operator. */
	ENODE_HEAD;				/* ASSERT(n_type == QUESTION_TOK). */
	enode * arg1;
	enode *	arg2;
	enode *	arg3;
};

struct var_enode_struct {
	ENODE_HEAD;				/* n_type is ID_TOK. */
	snode *	e_var;
};

/*
	inodes represent initializers.
*/
struct inode_struct {
	token	itype;		/* xxx_ITYPE.  see CCtokens.h. */
	short	iflags;		/* Various flags. */
	inode *	inext;		/* The next item in the initializer list. */
	ulong	icount;		/* BRACE_ITYPE: Number of expressions in brace-enclosed list. */
						/* AUTO_ITYPE:  Size of the initial data area. */
	union ival_union {
		inode *	i_brace_;	/* A brace-enclosed list. */
		enode *	i_expr_;	/* An expression. */
		anode *	i_auto_;	/* A local label for big auto initializers. */
	} i_union;
};

#define i_brace	i_union . i_brace_
#define i_expr	i_union . i_expr_
#define i_auto	i_union . i_auto_

	/* Define the values of the iflags field. */

enum {
	NO_IFLAG = 0,
	SAVE_IFLAG		/* TRUE: saved to disk. */
};

/*
	----- pnodes-----
	pnodes represent parser statments.
*/

#define PNODE_HEAD		/* Header for statement nodes. */\
	LINKED_NODE_HEAD;\
	long	p_line;			/* Line number of start of statement. */\
	token *	p_line_ptr;		/* Pointer to the start of the line. */\
	char	p_flags;		/* Various bits. */\
	char	p_line_count	/* Number of lines spanned by the statement. */

	/* Define the values of pflags. */

enum {
	NO_FLAG = 0,
	SAVED_PFLAG		/* TRUE: saved to disk. */
};

/*
	Define a generic statement node.
	This is used to access fields common to all statement nodes.
*/
struct pnode_struct {
	PNODE_HEAD;
};

/*
	Define the parse node produced by a 'break' or 'continue' statement.
*/
struct bc_node_struct {
	PNODE_HEAD;					/* n_type is K_BREAK or K_CONTINUE. */
};

/*
	Define the parse node for a block.
*/
struct block_node_struct {
	PNODE_HEAD;					/* n_type is KP_BLOCK. */
	snode *		block_dcls;		/* The declarations of the block. */
	pnode *		block_body;		/* The statements of the block. */
	reg_node *	block_regs;		/* List of user regs of this block. */
	ulong		block_alloc;	/* gen_current_alloc on entry to the block. */
};

/*
	Define the parse node produced by a 'case' or 'default' statement.
*/
struct case_node_struct {
	PNODE_HEAD;						/* n_type is K_CASE, K_DEFAULT. */
	long			case_constant;	/* case constant.	  */
	label_cnode *	case_label;		/* ptr to label pnode. */
	case_node *		case_list;		/* list of cases.	  */
};

/*
	Define the parse node for 'do' statements.
*/
struct do_node_struct {
	PNODE_HEAD;				/* n_type is K_DO. */
	pnode * do_body;
	enode * do_bool;
	long	p_line2;		/* Line number of the expression. */
	token *	p_line2_ptr;	/* Pointer to the start of the expression. */
	char	p_line2_count;	/* Number of lines spanned by the expression. */
};

/*
	Define the parse node for an expression statement.
*/
struct expr_node_struct {
	PNODE_HEAD;				/* n_type is EXPRESSION_TOK. */
	enode * expr;
};

/*
	Define the parse node for 'for' statements.
*/
struct for_node_struct {
	PNODE_HEAD;				/* n_type is K_FOR. */
	enode * for_list1;
	enode * for_bool;
	enode * for_list2;
	pnode * for_body;
};

/*
	Define the parse node for 'if' statements.
*/
struct if_node_struct {
	PNODE_HEAD;				/* n_type is K_IF. */
	enode * if_bool;
	pnode * if_then_body;
	pnode * if_else_body;
};

/*
	Define the parse node for 'goto' statements.
*/
struct goto_node_struct {
	PNODE_HEAD;					/* n_type is K_GOTO. */
	ulabel_cnode * goto_label;
};

/*
	Define the parse node for user labels.

	Parser label nodes are very different from code label nodes!
*/
struct label_node_struct {
	PNODE_HEAD;					/* n_type is ULABEL_TOK. */
	ulabel_cnode * ulab_label;
};

/*
	Define the parse node for 'return' statements.
*/
struct return_node_struct {
	PNODE_HEAD;					/* n_type is K_RETURN. */
	enode * return_val;
};

/*
	Define the parse node for 'switch' statements.
*/
struct switch_node_struct {
	PNODE_HEAD;					/* n_type is K_SWITCH. */
	enode *			switch_val;
	pnode *			switch_body;
	case_node * 	switch_list;	/* List of cases in the switch. */
	case_node *		switch_default;	/* "Case" for the default actions. */
	switch_node *	switch_next;	/* List of switches in the function. */
	label_cnode *	switch_jtab;			/* Label of jump table. */
	label_cnode *	switch_default_label;	/* Label for missing jump table entries. */
};

/*
	Define the parse node for 'while' statements.
*/
struct while_node_struct {
	PNODE_HEAD;					/* n_type is K_WHILE. */
	pnode * while_body;
	enode * while_bool;
};

/*
	reg_list_nodes nodes represent lists of spill_anodes.
	The nodes are doubly-linked in order to be able to find the tail quickly.
*/
struct reg_list_struct {
	TYPE_LIST2(reg_node);
	anode *	the_anode;
};

/*
	----- snodes -----
	snodes represent both symbols and the declarations which create them.
	snodes also contain fields used only by the symbol table routines.
*/

/*
	Define the smods field of symbol nodes.
*/
enum {

	NULL_SMOD		= 0x0000,

		/* Modifiers arising from modifier keywords. */

	AUTO_SMOD		= 0x0001,	/* Auto modifier. */
	EXTERN_SMOD		= 0x0002,	/* Extern modifier. */
	REGISTER_SMOD	= 0x0004,	/* Register modifier. */
	STATIC_SMOD		= 0x0008,	/* Static modifier. */
	TYPEDEF_SMOD	= 0x0010,	/* Typedef modifier. */

		/* Modifiers used in code generation. */

	IMPORT_SMOD		= 0x0020,	/* On the global import list. */
	DEFINED_SMOD	= 0x0040,	/* Do not generate an MPW assembler IMPORT pseudo-op. */

		/* Modifiers arising from the defining context. */

	ARRAY_SMOD		= 0x0100,	/* An array identifier. */
	BIT_FIELD_SMOD	= 0x0200,	/* A bit field. */
	CODE_SMOD		= 0x0400,	/* A function or prototype. */
	PROTO_SMOD		= 0x0800,	/* A function prototype, not a function definition. */

	FORMAL_SMOD		= 0x1000,	/* A formal parameter. */
	GLOBAL_SMOD		= 0x2000,	/* A symbol with "file scope." */
	SU_ELEM_SMOD	= 0x4000	/* A struct/union element. */
};

#define s_clear_auto(s)		{s -&gt; smods &amp;= ~AUTO_SMOD;}
#define s_clear_import(s)	{s -&gt; smods &amp;= ~IMPORT_SMOD;}
#define s_clear_proto(s)	{s -&gt; smods &amp;= ~PROTO_SMOD;}
#define s_clear_typedef(s)	{s -&gt; smods &amp;= ~TYPEDEF_SMOD;}

#define s_is_array(s)		(bit(s -&gt; smods, ARRAY_SMOD)	!= 0)
#define s_is_auto(s)		(bit(s -&gt; smods, AUTO_SMOD)		!= 0)
#define s_is_bit_field(s)	(bit(s -&gt; smods, BIT_FIELD_SMOD)!= 0)
#define s_is_code(s)		(bit(s -&gt; smods, CODE_SMOD)		!= 0)
#define s_is_defined(s)		(bit(s -&gt; smods, DEFINED_SMOD)	!= 0)
#define s_is_extern(s)		(bit(s -&gt; smods, EXTERN_SMOD)	!= 0)
#define s_is_formal(s)		(bit(s -&gt; smods, FORMAL_SMOD)	!= 0)
#define s_is_global(s)		(bit(s -&gt; smods, GLOBAL_SMOD)	!= 0)
#define s_is_import(s)		(bit(s -&gt; smods, IMPORT_SMOD)	!= 0)
#define s_is_proto(s)		(bit(s -&gt; smods, PROTO_SMOD)	!= 0)
#define s_is_register(s)	(bit(s -&gt; smods, REGISTER_SMOD)	!= 0)
#define s_is_static(s)		(bit(s -&gt; smods, STATIC_SMOD)	!= 0)
#define s_is_su_elem(s)		(bit(s -&gt; smods, SU_ELEM_SMOD)	!= 0)
#define s_is_typedef(s)		(bit(s -&gt; smods, TYPEDEF_SMOD)	!= 0)

#define s_set_array(s)		{s -&gt; smods |= ARRAY_SMOD;}
#define s_set_auto(s)		{s -&gt; smods |= AUTO_SMOD;}
#define s_set_bit_field(s)	{s -&gt; smods |= BIT_FIELD_SMOD;}
#define s_set_code(s)		{s -&gt; smods |= CODE_SMOD;}
#define s_set_defined(s)	{s -&gt; smods |= DEFINED_SMOD;}
#define s_set_extern(s)		{s -&gt; smods |= EXTERN_SMOD;}
#define s_set_formal(s)		{s -&gt; smods |= FORMAL_SMOD;}
#define s_set_import(s)		{s -&gt; smods |= IMPORT_SMOD;}
#define s_set_global(s)		{s -&gt; smods |= GLOBAL_SMOD;}
#define s_set_proto(s)		{s -&gt; smods |= PROTO_SMOD;}
#define s_set_register(s)	{s -&gt; smods |= REGISTER_SMOD;}
#define s_set_static(s)		{s -&gt; smods |= STATIC_SMOD;}
#define s_set_su_elem(s)	{s -&gt; smods |= SU_ELEM_SMOD;}
#define s_set_typedef(s)	{s -&gt; smods |= TYPEDEF_SMOD;}

/*
	Define symbol (table) nodes.  These nodes are the heart of the parser.

	Symbol nodes are created from declarations by dcl and related routines.
	They are linked to spelling nodes by symbol table routine routines.

	The dcls field is multi-purpose:

	? For functions: 			a list of formal paramenters.
	? For structs and unions:	a list of elements.

	Warning: the dcls field is *not* the same as the tdcls field of type nodes!

	The life list is used to unlink symbol nodes from spelling nodes when a
	function, block or file ends.  When a symbol node is unlinked, it is placed
	on a global free list--nodes are *never* actually deallocated.

	All nodes with the same spelling are kept on a doubly-linked "bucket list"
	consisting of the next and back links.

	Spelling nodes are not symbol nodes, so the next field is NULL for
	the first item on the bucket list is NULL.
	The spell field is used instead of the back field when back is NULL.

	n_type indicates the exact type of object.

	nspace indicates the name space: objects, tags or fields.

	The alias field is required because most assemblers have only one or
	two name spaces while in C arbitrarily many name spaces may exist--
	spell -&gt; spell_name can *not* be used instead.
*/

struct snode_struct {

		/* Parser fields. */

	PNODE_HEAD;		/* n_type: indicates name space. */
					/* n_next: the next outer declaration. */
					/* p_line: line number of start of declaration. */
					/* p_line_ptr: pointer to start of line. */

	snode *	dcls;	/* list struct/union elements. */
					/* formals of function. */

		/* Symbol table fields. */

	token		nspace;	/* Name space: see CCtokens.h. */
	snode *		next;	/* Next symbol with the same spelling. */
	snode *		back;	/* Previous symbol with same spelling. */
	snode * 	life;	/* Next symbol with the same lifetime. */
	spell_node *spell;	/* Spelling node for this symbol. */
	long		block;	/* Block number of defining block. */

		/* Semantic fields. */

	inode *		vlist;	/* List of initializers. */
	long		offset;	/* Offset for struct/union elements. */
	tnode *		ctype;	/* C-language type. */
	int			smods;	/* Other object attributes. */
	anode *		sarg;	/* anode denoting location of the object. */
};

/*
	Define type nodes.

	Type nodes are produced when declarations are parsed and
	are attached to symbol table nodes.

	tprim:	the kind of the type node (See the enum above).

	ttype:  WARNING!!! the ttype field is a union...

	? Usually, ttype points to the next type node, a ***tnode***

	? For structs, unions and enums, the ttype field points at the
	***snode*** describing the struct, union or enum.

	tdcls...

	? For struct/union variables or fields, tdcls points to the symbol node
	  for the "parent."  The parent is a struct/union tag if the tag exists.
	  Otherwise, the parent is the symbol node for the struct/union variable itself.

	? For functions, tdcls points to the declarations of the formals.

	tmods:  Type modifiers (see above).

	tdim:	The dimension of arrays, or 1 for other base types.

	tsize:	The size of one object in bytes, i.e., what sizeof returns.
			tsize of an array of 200 longs will be 800.
			tsize of a struct may be surprising because of padding.
			tsize is 0 for struct/union elements.

	Reorganized 6/15/93:

	Only the actual machine size of an int or float,
	*not* the declared type of an int or float,
	is used to determine whether two ints or two floats are the same.
	This eliminates the old tmod2 field and results in fewer unneeded casts.

	More importantly, the code now works correctly in all cases
	*regardless* of the actual sizes of short vs. int. vs. long and
	float vs. double vs. long double.

	Of course, the signed/unsigned bits are absolutely essential because
	whether an int is signed or not affects the "usual arithmetic conversions".
	In the unlikely event that distinct float types have the same size
	a similar distinguishing bit would have to be added to the tflags field.

*/
struct tnode_struct {
	token		tprim;		/* Type code: see CCtokens.h. */
	tnode *		ttype;		/* Next type node. */
	snode *		tdcls;		/* Parent for struct/union, dcls for function. */
	ulong		tdim;		/* Dimension/internal offsets. */
	ulong		tsize;		/* What sizeof() returns. */
	short		tflags;		/* Flag bits. */
};

	/*
		Define the tflags field.

		Warning: the LONG_DCL_TFLAG bit should be used *only* to remember
		whether a long was seen previously in the current declaration.
		Use the tsize field to distinguish between integer or floating types!
	*/

enum {
	NO_TFLAGS = 0,
	ARRAY_TFLAGS	= 0x01, /* TRUE: explicit array type. */
	CONST_TFLAGS	= 0x02,	/* TRUE: const keyword seen. */
	ENUM_TFLAGS		= 0x04,	/* TRUE: enum keyword seen. */
	LONG_DCL_TFLAGS	= 0x08,	/* TRUE: long seen earlier in a declaration. */
	SIGNED_TFLAGS	= 0x10,	/* TRUE: explicitly signed   char, int or long. */
	UNSIGNED_TFLAGS	= 0x20,	/* TRUE: explicitly unsigned char, int or long. */
	VOLATILE_TFLAGS	= 0x40, /* TRUE: volitile keyword seen. */
	SAVE_TFLAGS		= 0x80	/* TRUE: saved to disk. (not used yet). */
};

#define t_is_array(t)		(bit(t -&gt; tflags, ARRAY_TFLAGS)		!= 0)
#define t_is_const(t)		(bit(t -&gt; tflags, CONST_TFLAGS)		!= 0)
#define t_is_enum(t)		(bit(t -&gt; tflags, ENUM_TFLAGS)		!= 0)
#define t_is_long_dcl(t)	(bit(t -&gt; tflags, LONG_DCL_TFLAGS)	!= 0)
#define t_is_signed(t)		(bit(t -&gt; tflags, SIGNED_TFLAGS)	!= 0)
#define t_is_unsigned(t)	(bit(t -&gt; tflags, UNSIGNED_TFLAGS)	!= 0)
#define t_is_volatile(t)	(bit(t -&gt; tflags, VOLATILE_TFLAGS)	!= 0)

#define t_set_array(t)		{t -&gt; tflags |= ARRAY_TFLAGS;}
#define t_set_const(t)		{t -&gt; tflags |= CONST_TFLAGS;}
#define t_set_enum(t)		{t -&gt; tflags |= ENUM_TFLAGS;}
#define t_set_long_dcl(t)	{t -&gt; tflags |= LONG_DCL_TFLAGS;}
#define t_set_signed(t)		{t -&gt; tflags |= SIGNED_TFLAGS;}
#define t_set_unsigned(t)	{t -&gt; tflags |= UNSIGNED_TFLAGS;}
#define t_set_volatile(t)	{t -&gt; tflags |= VOLATILE_TFLAGS;}

#define t_set_char(t)		{t -&gt; tprim = INT_TYPE; t -&gt; tsize = CHAR_SIZE;}
#define t_set_int(t)		{t -&gt; tprim = INT_TYPE; t -&gt; tsize = INT_SIZE;}
#define t_set_long(t)		{t -&gt; tprim = INT_TYPE; t -&gt; tsize = LONG_SIZE;}
#define t_set_short(t)		{t -&gt; tprim = INT_TYPE; t -&gt; tsize = SHORT_SIZE;}

#define t_set_double(t) 	{t -&gt; tprim = FLOAT_TYPE; t -&gt; tsize = DOUBLE_SIZE;}
#define t_set_float(t)		{t -&gt; tprim = FLOAT_TYPE; t -&gt; tsize = FLOAT_SIZE;}
#define t_set_long_double(t){t -&gt; tprim = FLOAT_TYPE; t -&gt; tsize = LONG_DOUBLE_SIZE;}

/*
	Bug fix 1/1/94:
		Macros are now independent of the order in which they are tested.
		At most one of these macros can ever be true.
*/
#define t_is_double(t)\
	(t -&gt; tprim == FLOAT_TYPE &amp;&amp; t -&gt; tsize == DOUBLE_SIZE)
#define t_is_float(t)\
	(t -&gt; tprim == FLOAT_TYPE &amp;&amp; t -&gt; tsize == FLOAT_SIZE &amp;&amp; t -&gt; tsize != DOUBLE_SIZE)
#define t_is_long_double(t)\
	(t -&gt; tprim == FLOAT_TYPE &amp;&amp; t -&gt; tsize == LONG_DOUBLE_SIZE &amp;&amp; t -&gt; tsize != DOUBLE_SIZE)

#define t_is_big_type(t) \
	(t &amp;&amp; t -&gt; tsize &gt; REGISTER_SIZE &amp;&amp; t -&gt; tprim != ARRAY_TYPE)


#endif /* nodes_h_ */
</t>
<t tx="ekr.20080529093004.372">/*
	CC: type definitions.

	source: CCtypes.h.
	started: June 1, 1994.
	version: June 1, 1994.
*/

#ifndef CCtypes_h_
#define CCtypes_h_

#pragma once

/*
	Define types unique to the compiler.
*/

	/*
		tokens

		A token should be a short, not a char,
		so that all fields of a token will be aligned on an even-byte boundary.
		Using a 1-byte token will work on the 68030,
		but will cause a bus error on the 68000 when the pointer field is accessed.

		Spelling nodes are essentially part of tokens,
		and are now defined in CCtokens.h.
	*/

#define CC_TOKEN_TYPEDEFS
	typedef ushort token;
	typedef struct spell_node_struct spell_node;

	/* General: the following are used in several header files. */

#define COMMON_NODE_HEAD	/* Common part of all nodes. */\
	token n_type			/* Node type. */

#define LINKED_NODE_HEAD	/* Header for all linked nodes. */\
	COMMON_NODE_HEAD;\
	void * n_next

typedef struct linked_struct linked_node;	/* Common part of all linked nodes. */

struct linked_struct {
	LINKED_NODE_HEAD;
};

	/* anodes */

#define CC_ANODE_TYPEDEFS
	typedef struct anode_struct			anode;			/* Common part of all anodes. */
	typedef struct const_anode_struct	const_anode;	/* Constant anode. */
	typedef struct m20_anode_struct		m20_anode;		/* 68020 operand. */
	typedef struct spill_anode_struct	spill_anode;	/* Register anode. */
	typedef struct var_anode_struct		var_anode;		/* Variable (symbol) anode. */

	/* cnodes */

#define CC_CNODE_TYPEDEFS
	typedef struct cnode_struct			cnode;			/* Common part of all cnodes. */
	typedef struct cinode_struct		cinode;			/* Code instruction. */
	typedef struct label_cnode_struct	label_cnode;	/* Internal label node. */
	typedef struct line_cnode_struct	line_cnode;		/* Line number. */
	typedef struct table_cnode_struct	table_cnode;	/* Entry in a jump table. */
	typedef struct ulabel_cnode_struct	ulabel_cnode;	/* User label node. */

	/* cpp nodes */

#define CC_CPP_TYPEDEFS
	typedef struct file_info_struct	file_info_node;
	typedef struct skip_struct		skip_node;

	/* enodes */

#define CC_EXP_TYPEDEFS
	typedef struct enode_struct			enode;			/* Common part of all enodes. */
	typedef struct cons_enode_struct	cons_enode;		/* Lisp-like cons cell. */
	typedef struct const_enode_struct	const_enode;	/* Non-float constant. */
	typedef struct op1_enode_struct		op1_enode;		/* Unary operator. */
	typedef struct op2_enode_struct		op2_enode;		/* Binary operator. */
	typedef struct op3_enode_struct		op3_enode;		/* Ternary operator. */
	typedef struct var_enode_struct		var_enode;		/* Variable name. */

	/* general nodes */

#define CC_NODES_TYPEDEFS
	typedef struct inode_struct			inode;			/* Initializer info. */
	typedef struct scope_node_struct 	scope_node;		/* Scope info. */
	typedef struct snode_struct			snode;			/* Symbol node. */
	typedef struct tnode_struct 		tnode;			/* Type node. */

	/* macro nodes */

#define CC_MACRO_TYPEDEFS
	typedef struct mac_def_struct			mac_def_node;

	/* pnodes */

#define CC_PNODE_TYPEDEFS
	typedef struct pnode_struct			pnode;			/* Common part of all pnodes. */
	typedef struct bc_node_struct		bc_node;		/* 'break' and 'continue' statements. */
	typedef struct block_node_struct	block_node;		/* A block statement. */
	typedef struct case_node_struct		case_node;		/* 'case' and 'default' statements. */
	typedef struct do_node_struct		do_node;		/* 'do' statement. */
	typedef struct expr_node_struct		expr_node;		/* an expression statement. */
	typedef struct for_node_struct		for_node;		/* 'for' statement. */
	typedef struct goto_node_struct		goto_node;		/* 'goto' statement. */
	typedef struct if_node_struct		if_node;		/* 'if' statement. */
	typedef struct label_node_struct	ulabel_node;	/* User Label. */
	typedef struct return_node_struct	return_node;	/* 'return' statement. */
	typedef struct switch_node_struct	switch_node;	/* 'switch' statement. */
	typedef struct while_node_struct	while_node;		/* 'while' statement. */

	/* reg nodes */

#define CC_REGS_TYPEDEFS
	typedef struct reg_list_struct reg_node;

#endif /* CCtypes_h_ */
</t>
<t tx="ekr.20080529093004.373">/*
	CC2 -- version number header.

	source:  CCver.h
	started: December 10, 1990.
	version: See below.
*/

/*
	Make sure this file is included only once.
*/
#ifndef ver_h_
#define ver_h_

#define VER_VERSION			"CC version 1.0: September 1, 1994"
#define VER_COPYRIGHT		"Copyright 1994 by Tuple, Inc."
#define VER_DIALOG_VERSION 	"CC2 version 1.0:  September 1, 1994"

#endif /* ver_h_ */
</t>
<t tx="ekr.20080529093004.374"></t>
<t tx="ekr.20080529093004.375">@nocolor</t>
<t tx="ekr.20080529093004.376"></t>
<t tx="ekr.20080529093004.377">/*
	CC2: Header for functions and globals of the Preprocessor

	Source: CCcpp.h
	Started: May 31, 1992
	Version: June 2, 1994.
*/

#ifndef cpp_h_
#define cpp_h_

#pragma once

#ifndef CC_CPP_TYPEDEFS
	#define CC_CPP_TYPEDEFS
	typedef struct file_info_struct	file_info_node;
	typedef struct skip_struct		skip_node;
#endif

	/* File Info Nodes. */

struct file_info_struct {
	TYPE_LIST(file_info_node);	/* Allocated on a list, not in a block. */
	char *	finfo_fname;		/* Saved file name. */
	long	finfo_line;			/* Saved line number. */
	long	finfo_line_offset;	/* Saved line offset. */
	token *	finfo_tp;			/* "Return address" for #include file. */
};

	/* Skipped Lines Info. */

struct skip_struct {
	token *	skip_tp;	/* Skip pointer. */
	long	skip_lines;	/* Number of skipped lines. */
};

	/* Function prototypes. */

token * cpp			(token * tp);
long	char_val	(register char *s);
token *	skip_pp		(token * tp);

#endif /* cpp_h_ */</t>
<t tx="ekr.20080529093004.378">/*
	CC2: header for CCmacro.c.
	Started: June 1, 1994.
	Version: June 2, 1994.
*/

#ifndef CCcpp_h_
#define CCcpp_h_

#pragma once

/*
	Types.
*/
#ifndef CC_MACRO_TYPEDEFS
	#define CC_MACRO_TYPEDEFS
	typedef struct mac_def_struct mac_def_node;
#endif

struct mac_def_struct {
	TYPE_LIST(mac_def_node);	/* List of macro definitions. */
	token *		mac_rtokens;	/* The tokenized replacement text. */
	int			mac_nargs;		/* The number of formal arguments. */
	char **		mac_names;		/* Pointer to block of names of macro args. */
	spell_node *mac_spell;		/* Pointer to owner of this definition. */
};

/*
	Globals owned by this module.
*/
extern mac_def_node * mac_mdef_list;		/* List of macro defs. */

/*
	Function prototypes.
*/
token * mac_define			(token * tp, bool special_flag);
void	mac_define_string	(char * name, char * rtext, bool special_flag);
token *	mac_outer_expand	(token * tp);

#endif /* CCcpp_h_ */
</t>
<t tx="ekr.20080529093004.379">/*
	CC2: header for CCmst.c.
	Started: June 1, 1994.
	Version: June 2, 1994.
*/

#ifndef CCmst_h_
#define CCmst_h_

#pragma once

void	mst_dump_all		(void);
void	mst_dump_mdef		(mac_def_node * mp);
void	mst_init			(void);
void	mst_init_again		(void);
void	mst_init_define		(char * arg, char * def, bool user_flag);
void	mst_init_undef		(char * arg);
bool	mst_is_undef		(char * name);
void	mst_show			(void);
void	mst_special			(spell_node * spell_p);

#endif /* CCmst_h_ */

</t>
<t tx="ekr.20080529093004.380">/*
	CC2: header for CCpass12.c.
	Started: June 1, 1994.
	Version: June 1, 1994.
*/

#ifndef CCpass12_h_
#define CCpass12_h_

#pragma once

void	compress (io_mem_block * input_block);

#endif /* CCpass12_h_ */

</t>
<t tx="ekr.20080529093004.381">/*
	CC2: Header file describing the environment of the target machine.

	Source:  CCtarget.h
	Started: June 5, 1992
	Version: January 1, 1995.
*/

#ifndef CCtarget_h_
#define CCtarget_h_
#pragma once

extern short CHAR_SIZE;
extern short REGISTER_SIZE;
extern short POINTER_SIZE;

/*
	RELOP_SIZE is the apparent size of the "boolean" value resulting from
	a relational operator.

	Using a size of 1 increases the number of casts in the parse tree,
	and eliminates extra casts in cases such as:

		char c;
		c = v1 &lt; v2;
*/
extern short RELOP_SIZE;

/*
	Section 3.2.1.1

	"A char, a short int, or an int bit-field, or their signed or unsigned varieties,
	or an enumeration type, may be used in an expression wherever an int or unsigned int
	may be used.
	If an int can represent all values of the original type, the value is converted
	to an int; otherwise, it is converted to unsigned int.
	These are the integral promotions."

	"Apparently, both chars and shorts must be promoted to int,
	even though short would suffice."

	EKR: According to the "as if" rule, it may be possible to avoid extra promotions.
	The following constant determines whether a shortcut is possible.

	There is a very long discussion of promotion in the Rationale, section 3.2.1.1.
*/
extern short PROMOTE_SIZE;	/* The size of a promoted char or short. */

/*
	Define the sizes of primitive types, as defined by the target compiler.

	These *must* match the sizes used in the target for the code to make sense.
*/
extern short SHORT_SIZE;
extern short INT_SIZE;
extern short LONG_SIZE;

extern short FLOAT_SIZE;
extern short DOUBLE_SIZE;
extern short LONG_DOUBLE_SIZE;

/*
	Maximum values of ints and unsigned ints.
*/
extern ulong INT_MAX;
extern ulong UINT_MAX;

/*
	Define the extended keywords recognized by the compiler.
*/
#define TARGET_PASCAL_KEYWORD

#endif /* CCtarget_h_ */
</t>
<t tx="ekr.20080529093004.382">/*
	CC2: Definitions of nodes and values of tokens.

	source:  CC2tok.h
	started: February 6, 1991.
	version:
		June 10, 1994.
			Added type codes that used to be in CCnodes.h.
		June 8, 1994.
			Removed all attribute bits and associated code.
			Added all informatin from CCops.h.
		June 1, 1994.
			A major revision to handle devlib.
			Added spell_nodes.
			Changed put_small_tok, put_id_tok, put_ptr_tok, put_val_tok so
				that statistics are now kept in CCtokize.c.
*/

#ifndef tokens_h_
#define tokens_h_

#pragma once

#include "CCtarget.h"

	/* Temporary redefinitions. */

#define BAD_LAST_REG (R_D7 + 1)

/*
	Bug fix 7/4/93:
		a token should be a short, not a char, so that all fields of a token
		will be aligned on an even-byte boundary.
		Using a 1-byte token will work on the 68030,
		but will cause a bus error on the 68000 when the pointer field is accessed.
*/

#ifndef CC_TOKEN_TYPEDEFS
	#define CC_TOKEN_TYPEDEFS
	typedef ushort token;
	typedef struct spell_node_struct spell_node;
#endif

/*
	----- Spelling Nodes -----

	All ID_TOK's, IDX_TOK's and all reserved-word tokens point to a
	unique spelling table entry.  Two identifier tokens have the same
	spelling if and only if their spelling table pointers are equal.

	These entries are created only in tokize.
*/

struct spell_node_struct {
	spell_node *	spell_next;		/* Pointer to next bucket. */
	int				spell_length;	/* Length of name. */
	token			spell_token;	/* Presumed token. */
	char *			spell_name;		/* The name of the var. */
	mac_def_node *	spell_macro;	/* Pointer to macro node. */
	snode *			spell_symbol;	/* List of symbol nodes having this spelling. */
};

/* ----- Tokens and the Token Space ----- */


/* The "attribute bits of a token. */

struct tok_info_struct {
	short	tok_info_size;	/* Size of all tokens of this type. */
	char *	tok_info_name;	/* Print name of token. */
	token	tok_info_val;	/* Token value */
};

extern struct tok_info_struct tok_info [];

/*
	Tokens are not described by structs because
	the token type is only one byte long.
*/

/* ----- Enumerations ----- */

/*
	All information about tokens resides in tok_info [].
*/
#define tok_size(n)		tok_size_array [n]
#define tok_name(n)		(tok_info[n] . tok_info_name)

/*
	This enumeration defines the basic types used in the compiler.

	Unless otherwise noted, all tokens are created by tokize.
*/

typedef enum {

	NULL_TOK = 0, BAD_TOK = 0,

		/* ----- Non Tokens (zero size) ----- */

	/* WARNING: the code assumes that R_FIRST_REG is one! */

		/* Address regs. */

	R_FIRST_REG,
	R_A0 = R_FIRST_REG,
	R_A1,
	R_A2,
	R_A3,
	R_A4,
	R_A5,
	R_A6,
	R_A7,

		/* Data regs. */

	R_D0,
	R_D1,
	R_D2,
	R_D3,
	R_D4,
	R_D5,
	R_D6,
	R_D7,
	R_LAST_REG = R_D7,

	/* General regs. */

	R_CCR,
	R_SR,
	R_USP,

	/* ----- Node types and other type fields. ----- */

		/*
			Kinds of constant anodes.

			ADDRESS_CKIND is not used when assembly output is generated.
			LABEL_CKIND is not used when the project-oriented linker is used.
		*/

	NO_CKIND,
	BLOCK_CKIND,		/* A label of an initializer block. */
	DOUBLE_CKIND,		/* A double constant. */
	FLOAT_CKIND,		/* A float constant. */
	LONG_CKIND,			/* An int, long or char constant. */
	LONG_DOUBLE_CKIND,	/* A long double constant. */
	STRING_CKIND,		/* A string constant. */
	STRING_REF_CKIND,	/* A reference to a string constant used by initializers. */

		/*
			Kinds of var anodes.

			Only ADDRESS_VKIND will be used in the project-oriented version.
			When assembly output is created, ADDRESS_VKIND is used only as the result of
			address-specific constructions such as...

				typedef void (*ptr2voidfunc) (void);
				((ptr2voidfunc) 0x100) ();		(Call a function whose address 0x100.)
					or
				* ((char *) 0x100) = 5;			(Set byte at 0x100 to 5.)

			LIBNAME_VKIND is distinct from NAME_VKIND so that the output routines
			can add an implementation-defined prefex to the names of compiler functions.
		*/

	ADDRESS_VKIND,	/* A constant address of a function or object. */
	LIBNAME_VKIND,	/* The name of a compiler library function. */
	NAME_VKIND,		/* The name of statically allocated object. */
	XNAME_VKIND,	/* The name of externally visible statically allocated object. */

		/* Kinds of inodes. */

	AUTO_ITYPE,		/* A label of the initial data area for big auto initializers. */
	BRACE_ITYPE,	/* A list of inodes, enclosed in braces. */
	EXPR_ITYPE,		/* An expression. */

		/* Kinds of tnodes. */

	NULL_TYPE,		/* No type. */
	ARRAY_TYPE,		/* Array of... */
	CAST_TYPE,		/* "in cast" flag. */
	DOTS3_TYPE,		/* Represents ... in function prototypes. */
	INT_TYPE,		/* char, short, int, or long. */
	FLOAT_TYPE,		/* float, double, or long double. */
	FUNCTION_TYPE,	/* Function returning... */
	LABEL_TYPE,		/* An internal label. */
	POINTER_TYPE,	/* Pointer to... */
	STRUCT_TYPE,	/* A structure object. */
	UNION_TYPE,		/* A union object. */
	VOID_TYPE,		/* Represents (void) in function prototypes. */
	BAD_LAST_TYPE,	/* Not a valid type. */

		/* Scopes. */

	NULL_SCOPE,
	BLOCK_SCOPE,
	CAST_SCOPE,
	FILE_SCOPE,
	FUNCTION_SCOPE,
	NEW_FORMAL_SCOPE,
	OLD_FORMAL_SCOPE,		/* Old-style definitions, part 1. */
	OLD_FORMAL_DEF_SCOPE,	/* Old-style definitions, part 2, */
	STRUCT_SCOPE,
	UNION_SCOPE,
	BAD_LAST_SCOPE,

		/* Name spaces in the symbol table. */

	FIELD_NSPACE,	/* Struct/union/enum fields. */
	OBJECT_NSPACE,	/* Variables, functions, typedefs. */
	TAG_NSPACE,		/* Struct/union/enum tags. */

	/*
		The IMMEDIATE_EA, DIRECT_EA and PC_INDEX_EA modes have 2 or
		more variations, depending on the length of a constant.
		The opcodes with explicit length information are never generated
		by the code generators, and are used only by the internal assembler.

		Besides indicating address modes, the address modes form the valid
		values of the n_type field of anodes.
		The indented address modes are invalid in the n_type field.

		Note the distinction between these address modes and the
		*patterns* of address modes used in the existence tables.

		Modes ending in EA20 are for the 68020 and above.
		Modes ending in EA30 are for the 68030 and above.
	*/
	EA_RANGE_BEGIN,			/* Start of address modes. */

		ABSOLUTE_EA,			/* address (value of object) */
			ABS16_EA,				/* Word address */
			ABS32_EA,				/* Long address */
		ADDRESS_EA,				/* #address */
		AREG_EA,				/* An */
		DISPLACEMENT_EA,		/* #word(An) */
		DREG_EA,				/* Dn */
		IMMEDIATE_EA,			/* #data */
			IMM8_EA,				/* Byte data */
			IMM16_EA,				/* Word data */
			IMM32_EA,				/* Long data  */
		INDIRECT_EA,			/* (An)	 */
			IND16_EA20,				/* #word(An) */
		INDEX_EA,				/* #byte(a4,d4), */
			INDEX16_EA,				/* #byte(An,Xn.w) */
			INDEX32_EA,				/* #byte(An,Xn.l) */
			INDEX16_EA20,			/* #long(An,Xn.w*scale) */
			INDEX32_EA20,			/* #long(An,Xn.l*scale) */
		PC_DISP_EA,				/* #word(pc) */
		PC_INDEX_EA,			/* #byte(pc,Xn) */
			PC_INDEX16_EA,			/* #byte(pc,Xn.w) */
			PC_INDEX32_EA,			/* #byte(pc,Xn.l) */
			PC_INDEX16_EA20,		/* #byte(pc,Xn.w*scale) */
			PC_INDEX32_EA20,		/* #byte(pc,Xn.l*scale) */
		PC_POST_INDEX_EA20,		/* ([bd,pc],Xn.w*scale,od) */
			PC_POST_INDEX16_EA20,	/* ([bd,pc],Xn.w*scale,od) */
			PC_POST_INDEX32_EA20,	/* ([bd,pc],Xn.l*scale,od) */
		PC_PRE_INDEX_EA20,		/* ([bd,pc],Xn*scale,od) */
			PC_PRE_INDEX16_EA20,	/* ([bd,pc,Xn.w*scale],od) */
			PC_PRE_INDEX32_EA20,	/* ([bd,pc,Xn.l*scale],od) */
		POST_INC_EA,			/* (An)+ */
		POST_INDEX_EA20,		/* ([bd,An],Xn*scale,od) */
			POST_INDEX16_EA20,		/* ([bd,An],Xn.w*scale,od) */
			POST_INDEX32_EA20,		/* ([bd,An],Xn.l*scale,od) */
		PRE_DEC_EA,				/* -(An) */
		PRE_INDEX_EA20,			/* ([bd,An],Xn*scale,od) */
			PRE_INDEX16_EA20,		/* ([bd,An,Xn.w*scale],od) */
			PRE_INDEX32_EA20,		/* ([bd,An,Xn.l*scale],od) */

	EA_RANGE_END, /* End of address modes. */

		/* Machine instructions. */

	XTOK_RANGE_BEGIN,

		X_DUMMY,		/* Do-nothing node at start of code list. */

		X_ABCD,
		X_ADD,
		X_ADDA,
		X_ADDI,
		X_ADDQ,
		X_ADDX,
		X_AND,
		X_ANDI,
		X_ASL,
		X_ASR,

		X_BCHG,
		X_BCLR,
		X_BRA,
		X_BSET,
		X_BSR,
		X_BTST,

		BCC_RANGE_BEGIN,		/* Bcc instructions... */
			X_BCC,
			X_BCS,
			X_BEQ,
			X_BGE,
			X_BGT,
			X_BHI,
			X_BLE,
			X_BLS,
			X_BLT,
			X_BMI,
			X_BNE,
			X_BPL,
			X_BVC,
			X_BVS,
		BCC_RANGE_END,

		X_CHK,
		X_CLR,
		X_CMP,
		X_CMPA,
		X_CMPI,
		X_CMPM,

		X_DBCC,	/* DBxx instructions. */
		X_DBCS,
		X_DBEQ,
		X_DBF,
		X_DBGE,
		X_DBGT,
		X_DBHI,
		X_DBLE,
		X_DBLS,
		X_DBLT,
		X_DBMI,
		X_DBNE,
		X_DBPL,
		X_DBT,
		X_DBVC,
		X_DBVS,

		X_DIVS,
		X_DIVU,

		X_EOR,
		X_EORI,
		X_EXG,
		X_EXT,

		X_JMP,
		X_JSR,

		X_LEA,
		X_LINK,
		X_LSL,
		X_LSR,

		X_MOVE,
		X_MOVEA,
		X_MOVEM,
		X_MOVEP,
		X_MOVEQ,
		X_MULS,
		X_MULU,

		X_NBCD,
		X_NEG,
		X_NEGX,
		X_NOP,
		X_NOT,

		X_OR,
		X_ORI,

		X_PEA,

		X_RESET,
		X_ROL,
		X_ROR,
		X_ROXL,
		X_ROXR,
		X_RTE,
		X_RTR,
		X_RTS,

		X_SBCD,
				/* sxx instructions. */
		X_SCC,
		X_SCS,
		X_SEQ,
		X_SF,
		X_SGE,
		X_SGT,
		X_SHI,
		X_SLE,
		X_SLS,
		X_SLT,
		X_SMI,
		X_SNE,
		X_SPL,
		X_ST,
		X_SVC,
		X_SVS,

		X_STOP,
		X_SUB,
		X_SUBA,
		X_SUBI,
		X_SUBQ,
		X_SUBX,
		X_SWAP,

		X_TAS,
		X_TRAP,
		X_TRAPV,
		X_TST,

		X_UNLK,

	XTOK_RANGE_END,

	O_CLABEL,		/* Compiler generated label. */
	O_ULABEL,		/* User label. */
	O_LINE_NUMBER,	/* Line number. */
	Q_BRN,			/* Branch not (reversed from usual sense) */

	/* ----- Tokens with non-zero size ----- */

	BOUND_TOK,	/* Visible macro boundary. Created in macro.c */

	CONS_TOK,	/* Parser token: cons node. */

	DOTS3_TOK,	/* ... */

	END_PROG_TOK,		/* Visible end-of-program. */
	ERROR_CHAR_TOK,		/* Possible partial token for pasting. */
	ERROR_MESSAGE_TOK,	/* Delayed error message. */
	EXPRESSION_TOK,		/* Created by parser. */

	FILE_NAME_TOK,			/* &lt; any sequence not containing '&lt;' &gt; */

	KEY_RANGE_BEGIN, /* Start of all keywords... */

	PP_KEY_RANGE_BEGIN, /* Start of all PP keywords... */

		PP_KEY_ONLY_RANGE_BEGIN, /* Start of keywords used only by the PP... */
		K_DEFINE,
		K_ELIF,
		K_ENDIF,
		K_ERROR,
		K_IFDEF,
		K_IFNDEF,
		K_INCLUDE,
		K_LINE,
		K_PRAGMA,
		K_UNDEF,
			NO_DEF_RANGE_BEGIN,		/* Start of reserved PP macro keywords... */
			KM_DATE,
			KM_DEFINED,
			KM_FILE,
			KM_LINE,
			KM_STDC,
			KM_TIME,
			NO_DEF_RANGE_END,		/* End of reserved PP macro keywords. */
		PP_KEY_ONLY_RANGE_END,		/* End of keywords used only by the PP. */

		K_ELSE,						/* Keywords which are both PP and parser keywords. */
		K_IF,

	PP_KEY_RANGE_END, /* End of all PP keywords. */

	KDECL_RANGE_BEGIN, /* Start of keywords that can begin a declaration... */

		#ifdef TARGET_PASCAL_KEYWORD
			K_PASCAL,
		#endif
		K_AUTO,
		K_CHAR,
		K_CONST,
		K_DOUBLE,
		K_ENUM,
		K_EXTERN,
		K_FLOAT,
		K_INT,
		K_LONG,
		K_NOALIAS,
		K_REGISTER,
		K_SHORT,
		K_SIGNED,
		K_STATIC,
		K_STRUCT,
		K_TYPEDEF,
		K_UNION,
		K_UNSIGNED,
		K_VOID,
		K_VOLATILE,

	KDECL_RANGE_END, /* End of keywords that may start a declaration. */

	K_BREAK,
	K_CASE,
	K_CONTINUE,
	K_DEFAULT,
	K_DO,
	K_ENTRY,
	K_FOR,
	K_GOTO,
	K_LONG_DOUBLE,
	K_RETURN,
	K_SIZEOF,
	K_SWITCH,
	K_UNSIGNED_LONG,
	K_WHILE,

	KEY_RANGE_END, /* End of all keywords. */

		/* Parser tokens. */

	KP_BLOCK,		/* block statement. */
	KP_DOTS3,		/* ... (as an argument) */
	KP_ENUM_ELEM,	/* enum constant. */
	KP_ENUM_TAG,	/* enum tag. */
	KP_NULL_VAR,	/* null, i.e, missing variable. */
	KP_STRUCT_TAG,	/* structure tag. */
	KP_UNION_TAG,	/* union tag. */
	KP_VAR,			/* variable */
	KP_VOID_VAR,	/* void var, e.g (void) */

	LCURLY_TOK,		/* { */

	MACRO_ARG_TOK,	/* macro argument. created by mac_define. */

/*
	Operands are grouped to make switches faster.
	Operands should be defined adjacent to operators.
*/
	CHAR_TOK,			/* Character constant. */
	FLOAT_TOK,			/* floating constant. */
	ID_TOK,				/* An id that is not a reserved word. */
	IDX_TOK,			/* Disabled macro id. */
	INT_TOK,			/* An integer constant. */
	LONG_TOK,			/* long constant. */
	STRING_TOK,			/* string constant. */
	WIDE_CHAR_TOK,		/* wide character constant. */
	WIDE_STRING_TOK,	/* wide string constant. */

/*
	Operators are grouped so that their precedence can be found from a table.

	Warning: change expr_prec if this subrange changes.
*/
	OP_RANGE_BEGIN,		/* Start of all operators... */

	UNOP_RANGE_BEGIN,	/* Start of unary operators... */

		CAST_TOK,		/* Parser token: cast operator. */
		DEC_TOK,		/* -- */
		INC_TOK,		/* ++ */
		POST_DEC_TOK,	/* -- created by parser. */
		POST_INC_TOK,	/* ++ created by parser. */
		PRE_DEC_TOK,	/* -- created by parser. */
		PRE_INC_TOK,	/* ++ created by parser. */
		NOT_TOK,		/* ! */
		TILDE_TOK,		/* ~ */
		UAND_TOK,		/* unary &amp; created by parser. */
		UMINUS_TOK,		/* unary - created by parser. */
		UPLUS_TOK,		/* unary + created by parser. */
		USTAR_TOK,		/* unary * created by parser. */

	UNOP_RANGE_END, 	/* End of unary operators. */

	BINOP_RANGE_BEGIN,	/* Start of binary operators... */

		AND_TOK,			/* &amp;	*/
		AND_ASSN_TOK,		/* +=	*/
		ARRAY_TOK,			/* []	*/
		ARROW_TOK,			/* -&gt;	*/
		ASSN_TOK,			/* =	*/
		CALL_TOK,			/* Parser token: function call operator. */
		COMMA_TOK,			/* ,	*/
		DIV_TOK,			/* /	*/
		DIV_ASSN_TOK,		/* /=	*/
		DOT_TOK,			/* .	*/
		EQUAL_TOK,			/* ==	*/
		GE_TOK,				/* &gt;=	*/
		GT_TOK,				/* &gt;	*/
		LAND_TOK,			/* &amp;&amp;	*/
		LE_TOK,				/* &lt;=	*/
		LOR_TOK,			/* ||	*/
		LSHIFT_TOK,			/* &lt;&lt;	*/
		LSHIFT_ASSN_TOK,	/* &lt;&lt;=	*/
		LT_TOK,				/* &lt;	*/
		MINUS_TOK,			/* -	*/
		MINUS_ASSN_TOK,		/* -=	*/
		MOD_TOK,			/* %	*/
		MOD_ASSN_TOK,		/* %=	*/
		NE_TOK,				/* !=	*/
		OR_TOK,				/* |	*/
		OR_ASSN_TOK,		/* |=	*/
		PLUS_TOK,			/* +	*/
		PLUS_ASSN_TOK,		/* +=	*/
		RSHIFT_TOK,			/* &gt;&gt;	*/
		RSHIFT_ASSN_TOK,	/* &gt;&gt;=	*/
		STAR_TOK,			/* *	*/
		STAR_ASSN_TOK,		/* *=	*/
		XOR_TOK,			/* ^	*/
		XOR_ASSN_TOK,		/* ^=	*/

	BINOP_RANGE_END,		/* End of binary operators. */

	COLON_TOK,				/* : */
	QUESTION_TOK,			/* ? */

	LBRACK_TOK,				/* [  Has precedence, but is not treated as a binary operator! */
	LPAREN_TOK,				/* (  Has precedence, but is not treated as a binary operator! */

	OP_RANGE_END,		/* End of operator range. */

	PARTIAL_CHAR_TOK,			/* char constant without trailing ' */
	PARTIAL_FILE_NAME_TOK,		/* file name with trailing &gt; */
	PARTIAL_STRING_TOK,			/* string without trailing " */
	PARTIAL_WIDE_CHAR_TOK,		/* wide char constant without trailing ' */
	PARTIAL_WIDE_STRING_TOK,	/* string without trailing " */

	POUND_TOK,			/* #  */
	POUND_POUND_TOK,	/* ## */

	RBRACK_TOK,			/* ] */
	RCURLY_TOK,			/* } */
	RPAREN_TOK,			/* ) */

	SEMICOLON_TOK,		/* ; */

	ULABEL_TOK,			/* user label */

	/*
		White space tokens are grouped for easy recognition.
	*/
	WS_RANGE_BEGIN,
		WS_COMMENT_TOK,	/* O or 1 comment lines. */
		WS_FF_TOK,		/* form feed. */
		WS_NL_TOK,		/* newline. */
		WS_VTAB_TOK,	/* vertical tab. */
		WS_TOK,			/* one blank. */
		WS_BLANKS_TOK,	/* 1 or more blanks. */
	WS_END_RANGE,

	/*
		Hidden tokens are grouped so they can be recognized quickly.
		This makes the next_tok macro much faster.
	*/
	HIDDEN_RANGE_BEGIN,
		HIDDEN_BEGIN_FILE_TOK,		/* Start of a file. */
		HIDDEN_BIG_IGNORE_TOK,		/* Ignored big token. */
		HIDDEN_BIG_SKIP_TOK,		/* Skip multiple lines. */
		HIDDEN_END_BLOCK_TOK,		/* End token block token. */
		HIDDEN_END_FILE_TOK,		/* End file. */
		HIDDEN_FILE_INFO_TOK,		/* Created by cpp_line. */
		HIDDEN_LINE_ADJUST_TOK,		/* Adjust after comment. */
		HIDDEN_NL_IN_COMMENT_TOK,	/* Newline in comment. */
		HIDDEN_NL_IN_MACRO_TOK,		/* Newline in macro call. */
		HIDDEN_SMALL_IGNORE_TOK,	/* Ignored small token. */
		HIDDEN_SKIP_TOK,			/* Skip to next token. */
		HIDDEN_SKIP_DIRECTIVE_TOK,	/* Skip one directive line. */
		HIDDEN_SKIP_TO_MACRO_TOK,	/* Start of macro. */
	HIDDEN_RANGE_END,

	/*
		WARNING: The is_hidden macro assumes that no
				 legal tokens beyond the hidden tokens!
	*/

	BAD_LAST_TOK
};

/*
	Define some common synonyms.
*/
#define X_BLO  X_BCS	/* Branch *until* carry set. */
#define X_BHS  X_BCC
#define X_DBRA X_DBF	/* Branch always. */
#define X_DBRN X_DBT
#define X_DBLO X_DBCS
#define X_DBHS X_DBCC
#define X_SLO  X_SCS
#define X_SHS  X_SCC

/*
	Define an array that makes the next_tok macro faster.
*/
extern char tok_size_array [BAD_LAST_TOK + 1];

/*
	Define abbreviations for range tests.
*/
#define is_areg(n)  	(n &gt;= R_A0						&amp;&amp; n &lt;= R_A7)
#define is_binop(n)		(n &gt;  BINOP_RANGE_BEGIN			&amp;&amp; n &lt;  BINOP_RANGE_END)
#define is_bxx(n)  		(n &gt;  BCC_RANGE_BEGIN			&amp;&amp; n &lt;  BCC_RANGE_END)
#define is_dreg(n)  	(n &gt;= R_D0						&amp;&amp; n &lt;= R_D7)
#define is_eatok(n)		(n &gt;  EA_RANGE_BEGIN			&amp;&amp; n &gt;  EA_RANGE_END)
#define is_hidden(n)	(n &gt;  HIDDEN_RANGE_BEGIN)
#define is_id(n)		(is_key(n) || n == ID_TOK)
#define is_kdecl(n)		(n &gt;  KDECL_RANGE_BEGIN			&amp;&amp; n &lt;  KDECL_RANGE_END)
#define is_key(n)		(n &gt;  KEY_RANGE_BEGIN			&amp;&amp; n &lt;  KEY_RANGE_END)
#define is_nodef(n)		(n &gt;  NO_DEF_RANGE_BEGIN		&amp;&amp; n &lt;  NO_DEF_RANGE_END)
#define is_ppkey(n)		(n &gt;  PP_KEY_RANGE_BEGIN		&amp;&amp; n &lt;  PP_KEY_RANGE_END)
#define is_ppkey_only(n)(n &gt;  PP_KEY_ONLY_RANGE_BEGIN	&amp;&amp; n &lt;  PP_KEY_ONLY_RANGE_END)
#define is_unop(n)		(n &gt;  UNOP_RANGE_BEGIN			&amp;&amp; n &lt;  UNOP_RANGE_END)
#define is_ws(n)		(n &gt;  WS_RANGE_BEGIN			&amp;&amp; n &lt;  WS_END_RANGE)
#define is_xreg(n)  	(n &gt;= R_A0						&amp;&amp; n &lt;= R_D7)
#define is_xtok(n) 		(n &gt;  XTOK_RANGE_BEGIN			&amp;&amp; n &lt;  XTOK_RANGE_END)

/* ----- Inline token functions (implemented as macros) ----- */

/*
	Define token sizes.

	MAX_TOKEN_SIZE is space that must be left free in a token block
	so that there is room for one more token *and* a HIDDEN_END_BLOCK_TOK.
*/
#define SMALL_TOKEN_SIZE sizeof(token)
#define BIG_TOKEN_SIZE (sizeof(token) + sizeof(char *))
#define MAX_TOKEN_SIZE (BIG_TOKEN_SIZE+BIG_TOKEN_SIZE)

/*
	Make sure enough space remains for the next token and
	allocate another token block if required.
*/
#define tok_protect_macro(tp, tavail) \
{\
	if (MAX_TOKEN_SIZE &gt; tavail) {\
		tp = mem_new_tok_block(tp, tavail);\
		tavail = token_life -&gt; mem_avail;\
	}\
}

/*
	Increment token pointer tp by n.

	This is trickier than it looks,
	because this macro must work regardless of the value of sizeof(*tp).
	For example, we can't say tp += n because sizeof(tp) may not be 1.
*/
#define bump_tp_macro(tp, n) { tp = (token *) (((char *) tp) + n); }

/*
	put_small_tok, put_id_tok, put_ptr_tok, put_val_tok.

	I experimented with writing parts of these macros
	in assembly language, but no speed was gained.

	At present, these macros are used only in tokize.c.
	However, they should be defined here since
	several other macros in this file must change
	if the format of tokens defined by the put_xxx_tok macros change.

	7/3/93:
		These macros were revised to make them independent of
		the values of sizeof(tp), that is sizeof(token).
*/

/*
	Place a new small token in the token list.
*/
#define put_small_tok(tp, tavail, tok)\
{\
	tok_protect_macro(tp, tavail);\
	*tp++ = tok;\
	tavail -= SMALL_TOKEN_SIZE;\
}

/*
	Place a new (big) id token in the token list.
*/
#define put_id_tok(tp, tavail, tok, ptr)\
{\
	tok_protect_macro(tp, tavail);\
	*tp++ = tok;\
	* ((char **) tp) = (char *) ptr;\
	bump_tp_macro(tp, sizeof(char *));\
	tavail -= BIG_TOKEN_SIZE;\
}

/*
	Place a new (big) pointer token in the token list.
*/
#define put_ptr_tok(tp, tavail, tok, ptr)\
{\
	tok_protect_macro(tp, tavail);\
	*tp++ = tok;\
	* ((char **) tp) = (char *) ptr;\
	bump_tp_macro(tp, sizeof(char *));\
	tavail -= BIG_TOKEN_SIZE;\
}

/*
	Place a new (big) value token in the token list.
*/
#define put_val_tok(tp, tavail, tok, val)\
{\
	tok_protect_macro(tp, tavail);\
	*tp++ = tok;\
	* ((long *) tp) = val;\
	bump_tp_macro(tp, sizeof(char *));\
	tavail -= BIG_TOKEN_SIZE;\
}

/*
	Return the next *visible* preprocessor token.
	This macro will never return a token whose name starts with HIDDEN_.

	This macro absolutely must be as fast as possible.
	Using a function call here significantly degrades performance.
*/
#define next_tok(tp)\
{\
	if (!is_hidden(*tp)) bump_tp_macro(tp, tok_size(*tp));\
	if (is_hidden(*tp)) tp = tok_skip_hidden(tp);\
}

/*
	Return the next preprocessor token, whether visible or invisible.

	The speed of this macro is not very important since it is rarely used
	and used only in non-critical locations.
*/
#define next_raw_tok(tp) tp = tok_next_raw(tp)

/*
	Convert a large token into another large token.

	Warning: an ASSERT would be useful here.

	Bug fix: 7/4/93:
		1 is *not* a magic constant.  Use 1, not SMALL_TOKEN_SIZE.
		Since tp is a pointer, the 1 will be properly scaled by sizeof(token).
		The old code only works only if sizeof(token) == 1!
*/
#define patch_ptr_tok(tp, ptr) { *((char **) (tp+1)) = (char *) ptr; }
#define patch_val_tok(tp, val) { *((long *) (tp+1)) = val; }

/*
	Return the last 4 bytes of a big token.

	The various forms of this macro eliminate the need for most casts.

	Bug fix: 7/4/93:
		1 is *not* a magic constant.  Use 1, not SMALL_TOKEN_SIZE.
		Since tp is a pointer, the 1 will be properly scaled by sizeof(token).
		The old code only works if sizeof(token) == 1!
*/
#define id_tok_ptr(tp)  ((spell_node *) *((char **) (tp+1)))
#define ptr_tok_ptr(tp) *((char **) (tp+1))
#define val_tok_val(tp) *((long *) (tp+1))

/*
	Skip white space preprocessor tokens.
*/
#define skip_ws_tok(tp)\
{\
	if (is_hidden(*tp)) tp = tok_skip_hidden(tp);\
	while(is_ws(*tp) {\
		next_tok(tp);\
	}\
}

/*
	Skip "horizontal" white space preprocessor tokens: blank, tab, comments.
*/
#define skip_hws_tok(tp)\
{\
	if (is_hidden(*tp)) tp = tok_skip_hidden(tp);\
	while(is_ws(*tp) &amp;&amp; *tp != WS_NL_TOK) {\
		next_tok(tp);\
	}\
}

/*
	Function prototypes.
*/

		/* Define synonyms for flags. */

		#define PRINT_HIDDEN_TOKS		TRUE	/* print_hidden_flag */
		#define DONT_PRINT_HIDDEN_TOKS	FALSE

		#define SPLIT_LONG_LINES		TRUE	/* split_flag */
		#define DONT_SPLIT_LONG_LINES	FALSE

		#define PRINT_USER_TOKENS		TRUE	/* user_flag */
		#define PRINT_NON_USER_TOKENS	FALSE

void	tok_check		(void);
token *	tok_dump		(token * tp, bool print_hidden_flag);
token *	tok_dump_delim	(token * tp, token delim);
token *	tok_dump_delim2	(token * tp, token delim, bool print_hidden_flag);
token *	tok_dump_line	(token * tp);
token *	tok_dump_line2
	(token * tp, bool print_hidden_flag, bool split_flag, bool user_flag);
token *	tok_dump_list	(token * start_p, token * end_p);
token *	tok_dump_list2	(token * start_p, token * end_p, bool print_hidden_flag);
void	tok_dump1		(token * tp, bool print_hidden_flag);
token *	tok_concatenate (token * tp);
token *	tok_copy		(token the_token, void * the_ptr);
token *	tok_copy_list
	(token * start_p, token * end_p, token ** last_copy, char * tag);
token *		tok_copy2nl		(token * start_p, token ** last_copy, char * tag);
spell_node *tok_enter		(char * string_start, int string_length, long hash);
void		tok_ignore		(token * tp);
long		tok_hash		(char * s);
void		tok_init		(void);
spell_node *tok_lookup_hash	(char *s);
spell_node *tok_lookup		(char * string_start, long string_length, long hash);
token * 	tok_new_block	(token * tp, long tavail);
token *		tok_next_		(token * tp);
token *		tok_next_raw	(token * tp);
token *		tok_parse_next	(token * tp);
void		tok_patch
	(token * patch_tp, token the_token, void * the_ptr, char * tag);
token *	tok_scan		(token * tp);
token *	tok_scan_file	(char * file_name, token * first_tok);
token *	tok_scan_line
	(token * first_tok, long target_line, char * target_file_name, long * returned_line);
token *	tok_skip_hidden	(token * tp);
char *	tok_2string		(token * tp, int * length, bool stringize_flag);

/*
	Declare variables owned by tokens.c.
*/
extern int tok_update_flag;	/* TRUE: update line numbers in next_tok, etc. */
extern int tok_file_level;	/* 1: main file, &gt;1 header file. */

extern token * tok_first_token;/* First token of the outer file. */

extern char	tok_size_array [BAD_LAST_TOK + 1];	/* Makes tok_size macro faster. */
extern struct tok_info_struct tok_info [];		/* The token info array. */

extern long tok_cur_lab;		/* The current label index. */
extern token * tok_token_ptr;	/* Ptr to the current token. */
extern token * tok_line_ptr;	/* Ptr to the newline before the current line. */

#endif /* tokens_h_ */</t>
<t tx="ekr.20080529093004.383">/*
	CC2: header for CCtokize.c.
	Started: June 1, 1994.
	Version: June 1, 1994.
*/

#ifndef CCtokize_h_
#define CCtokize_h_

#pragma once

/*
	Enable or disable token statistics.
*/
#ifdef PRODUCTION
	#define TOKIZE_STATS(s)
#else
	#define TOKIZE_STATS(s) s
#endif

/* Globals. */

extern spell_node **sym_hash_tab;	/* Global spelling hash table. */

extern long	tok_bigs;		/* Number of big tokens. */
extern long	tok_blocks;		/* Number of token blocks. */
extern long	tok_bytes;		/* Total allocated bytes. */
extern long	tok_end_blocks;	/* Number of end block tokens. */
extern long	tok_number;		/* Total number of tokens. */
extern long	tok_smalls; 	/* Number of small tokens. */
extern long	tok_waste;		/* Number of wasted bytes. */

/*
	Function prototypes.
*/
	/* Synonyms for skip_flag of tokize(). */
	enum { END_WITH_SKIP_TOK = TRUE, END_WITH_EOF_TOK = FALSE };

token *	tokize
	(io_mem_block * input_block, file_info_node * return_fip,
	char * file_name, bool skip_flag, token * skip_tp);

void	tok_dump_stats		(void);
void	tok_init_hash_tab	(void);
void	tok_reinit_stats	(void);

#endif /* CCpass12_h_ */

</t>
<t tx="ekr.20080529093004.384"></t>
<t tx="ekr.20080529093004.385">/*
	CC2: The main line of the C preprocessor and non-macro directives.

	Use 4-space tabs for best appearance.

	source:  CCcpp.c
	started: February 6, 1992
	version:
		August 29, 1994.
			Bug fix: call strtoul to retain all bits when evaluating a constant string.
			Added type information to push_val and pop_val.
			This information is used to properly evaluate operators.
			Added type stack to handle this new information.
		August 27, 1994.
			Bug fix: allow U and L suffices for constants in eval.
		August 2, 1993.
			Added synonyms for skip_flag.
		May 14, 1993.
			Added path argument to cpp_incl2.
		May 10, 1993.
			Removed patch_tp arg from cpp_incl2.  (Patching is done elsewhere.)
		April 26, 1993.
			Removed unused result variable from cpp_elif.
		March 8, 1993.
			Verbose include messages controled by arg_v_include_flag, not err_verbose.
		December 9, 1992.
			Added better warning on erroneous -s2 path name.
			Added std_lib_flag to cpp_incl2.
		September 29, 1992.
			Added '\v' case to char_val.
		September 19, 1992.
			Always print error if #include file is not found.
		August 19, 1992.
			Added #include trace if -v option on.
		August 16, 1992.
			Made char_val global.
		July 16, 1992
			Use ptr_tok_ptr instead of val_tok_val in eval.
		June 4, 1992
			Eliminated spell_union.
		May 19, 1992
			Added support for err_line_offset.
		May 12, 1992
			Made sure statements were inside error and warning macros.
		May 7, 1992
			Enable macros in main line of cpp.
		May 6, 1992
			Print error messages if ERROR_MESSAGE_TOKEN seen.
		May 1, 1992
			Bug fix to #undef code.
		April 16, 1992
			Removed WS_NEWLINES_TOK.
		April 11, 1992
			Created cpp_inhibit.
		April 7, 1992
			Change pp_m_v tracepoint to pp_obj_v.
		April 1, 1992
			Installed ASSERT_TRACE macros.
			Removed redundant patch code from cpp_incl2.
		March 31, 1992
			skip_all_flag added to skip_lines.
			(A *major* bug fix which bites SPP too.)
		March 29, 1992
			Made POUND_TOK big so can replace it with HIDDEN_SKIP_TOK.
		March 17, 1992
			Added FTAG logic.
		March 6, 1992
			Installed obj_new_macro.
		February 26
			WS_TOK's replace all # at the start of lines.
			HIDDEN_SKIP_TOK's replace all directives.
		February 25, 1992
*/

&lt;&lt; CCcpp #includes &gt;&gt;
&lt;&lt; CCcpp declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.386">#include "CC.h"

#include "CCarg.h"
#include "CCcpp.h"
#include "CCmacro.h"
#include "CCmem.h"
#include "CCmst.h"
#include "CCpass12.h"
#include "CCtokens.h"
#include "CCtokize.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBio.h&gt;
#include &lt;LIBlist.h&gt;
#include &lt;LIBobj.h&gt;

#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.387">/*
	Define the maximum depth of nesting of #if's.
	The ANSI Standard requires at least 8 levels (See page14)
*/
#define CPP_MAX_IF	100

/*
	Define the maximum depth of compile time expressions.
	The ANSI Standard requires at least 32 levels.
*/
#define MAX_EVAL_VAL 100
#define MAX_EVAL_OP 50

/*
	Define the inhibit include list.
	This is created by #prama once.
*/
typedef struct file_inhibit_node_struct file_inhibit_node;

static struct file_inhibit_node_struct {
	TYPE_LIST(file_inhibit_node);
	char *	inhibit_fname;
};

static file_inhibit_node * cpp_inhibit_list = NULL;

/*
	Define global variables of the preprocessor.
*/
mac_def_node * mac_mdef_list = NULL;	/* List of macro definitions. */

/*
	Declare local variables.
*/

static short int * if_stack = NULL;
static int if_level = 0;

static long	* val_stack = NULL;	/* Operand stack. */
static token * op_stack = NULL;	/* Operator stack. */
static bool	* type_stack  = NULL; /* Type stack. */

static int val_ptr = 0;	/* Operand stack pointer. */
static int op_ptr = 0;	/* Operator stack pointer. */

static bool error_seen = FALSE;		/* TRUE: error in eval seen. */
static bool	cpp_init_flag = FALSE;	/* TRUE: cpp has been initialized. */

/*
	Declare internal routines.
*/

	/* Synonyms for unsigned_flag. */
	enum { UNSIGNED_VAL = TRUE, SIGNED_VAL = FALSE };

static token *	cpp_elif	(token * tp);
static token *	cpp_else	(token * tp);
static token *	cpp_endif	(token * tp);
static void		cpp_error	(token * tp);
static token *	cpp_if		(token * tp);
static token *	cpp_ifdef	(token * tp, bool flag);
static token *	cpp_include	(token * tp);
static token *	cpp_incl2	(token * tp, io_mem_block * input_block,
							char * fname, char * path, bool std_lib_flag);
static void		cpp_inhibit	(char * file_name);
static token *	cpp_line	(token * tp);
static token *	cpp_pragma	(token * tp);
static token *	cpp_undef	(token * tp);

static token *	eval		(token * tp, long * val_p);
static bool		gt_prec		(token op1, token op2);
static void		push_op		(token);
static token	pop_op		(void);
static void		push_val	(long, bool unsigned_flag);
static long		pop_val		(bool * unsigned_flag);
static int		prec		(int);

	/* Define synonyms for skip_all_flag */

	#define SKIP_UNTIL_ENDIF			TRUE
	#define SKIP_UNTIL_ELSE_OR_ENDIF	FALSE

static token *	skip_lines	(token * tp, char * directive_name, bool skip_all_flag);
static token *	skip_past	(token * tp);
</t>
<t tx="ekr.20080529093004.388">@ What about form feed '\f' and vertical tab '\v' in preprocessor directives?  See Standard: page 6, page 87 and Rationale, page 62.  p87 says only blank and tab are allowed, but that may just mean '\n' is not allowed (except in comments).  p 62 says newlines in comments are allowed in a preprocessor directive.  p 6: Whether each nonempty sequence of white-space characters other than newline is retained or replaced by one blank character is implementation defined.  Tokenize replaces '\f' and '\v' by WS_TOK, so these are replaced by a blank character.  What all this means is that skip_hws_tok just tests for is_ws except WS_NL_TOK.
Return the value of a character constant.
@c

long
char_val(register char *s)
{
	register long val;

	SL_DISABLE();

	if (*s != '\\') {
		return (long) *s;
	}

	/* Handle escape sequences. */

	s++;
	switch (*s) {
	case 'b':	return '\b';
	case 'f':	return '\f';
	case 'n':	return '\n';
	case 'r':	return '\r';
	case 't':	return '\t';
	case 'v':	return '\v';
	case '\'':	return '\'';
	case '\\':	return '\\';

	default:
		if (*s &lt; '0' || *s &gt; '7') {
			return (long)*s;
		}
		val = 0;
		while (*s &gt;= '0' &amp;&amp; *s &lt;= '7') {
			val = val * 8 + (int)*s - '0';
			s++;
		}
		return val;
	}
}
</t>
<t tx="ekr.20080529093004.389">@ The main C preprocessor.  This converts a token list created by tokize into a fully preprocessed token list:  o All preprocessor directives are processed and bypassed by HIDDEN_SKIP_TOK's. o All nested #incude files are handled recursively. o All macro substitution is performed. o All string concatenation is performed.  Tokenize adds a "dummy newline" to the beginning of the block so we can recognize directives at the start of a file without problems.
@c

token *
cpp(register token * tp)
{
	FTAG("cpp");
	FTAGV("-cpp_v");
	register token 	c = 0;
	long skipped_lines = 0;
	token * first_tp = tp;
	token * skip_tp = NULL;
	long start_line = 0;
	TRACEPB(ftag, es(err_fname); enl());

	if (!cpp_init_flag) {

		cpp_init_flag = TRUE;

		/* Allocate the stacks */
		obj_new_macro(if_stack,   CPP_MAX_IF   * sizeof(int),   "cpp if stack");
		obj_new_macro(val_stack,  MAX_EVAL_VAL * sizeof(long),  "cpp value stack");
		obj_new_macro(type_stack, MAX_EVAL_VAL * sizeof(bool),  "cpp type stack");
		obj_new_macro(op_stack,   MAX_EVAL_OP  * sizeof(token), "cpp op stack");
	}

	while ( (c = *tp) != END_PROG_TOK) {

		#if 0 /* Expensive. */
			TRACE("obj_v", obj_checkMem());
		#endif

		ASSERT_TRACE(c &gt; 0 &amp;&amp; c &lt; BAD_LAST_TOK,
			es("tp = "); eptr(tp); enl();
			tok_dump(first_tp, PRINT_HIDDEN_TOKS);
		);

		#if 0 /* Very expensive. */
			#ifdef THINK_C
				if (w_applEvent(0) == FALSE) {
					end_quit();
				}
			#endif
		#endif

		/* Look for preprocessor directives. */
		if (c == WS_NL_TOK) {

			/* Skip the newline and leading white space. */
			err_line++;
			next_tok(tp);
			skip_hws_tok(tp);

			if (*tp != POUND_TOK) {
				/* We have to scan the line to look for macros. */
				continue;
			}

			TRACEPN(ftagv, tok_dump_line(tp));

			/* Remember where to put the HIDDEN_SKIP_TOK. */
			skip_tp = tp;

			/* Skip the '#' and trailing white space. */
			next_tok(tp);
			skip_hws_tok(tp);

			c = *tp;

			/*
				Remember the line at the beginning of the directive.
				This will be used to choose between HIDDEN_SKIP_TOK and
				HIDDEN_BIG_SKIP_TOK.

				We will set start_line to -1 for #include and #line since
				the HIDDEN_BEGIN_FILE_TOK and HIDDEN_FILE_INFO_TOK tokens set
				the line number directly.
			*/
			start_line = err_line;

			/* No lines have been skipped in this directive yet. */
			skipped_lines = 0;

			if (c == WS_NL_TOK) {

				/* A bare '#' */
				err_line++;
				next_tok(tp);
			}
			else if (is_ppkey(c)) {

				switch(c) {

				case K_DEFINE:	tp = mac_define(tp, FALSE);	break;
				case K_ELIF:	tp = cpp_elif(tp);			break;
				case K_ELSE:	tp = cpp_else(tp);			break;
				case K_ENDIF:	tp = cpp_endif(tp);			break;
				case K_ERROR:	cpp_error(tp);				break;
				case K_IF:		tp = cpp_if(tp);			break;
				case K_IFDEF:	tp = cpp_ifdef(tp, TRUE);	break;
				case K_IFNDEF:	tp = cpp_ifdef(tp, FALSE);	break;
				case K_INCLUDE:	start_line = -1;
								tp = cpp_include(tp);		break;
				case K_LINE:	start_line = -1;
								tp = cpp_line(tp);			break;
				case K_PRAGMA:	tp = cpp_pragma(tp);		break;
				case K_UNDEF:	tp = cpp_undef(tp);			break;

				default:
					fatal(
						es("Unrecognized token in preprocessor directive: ");
						tok_dump1(tp, PRINT_HIDDEN_TOKS);
					);
				}
			}
			else if (c == ID_TOK) {

				/*
					Do *not* look for macros here:

					The ANSI C Standard p 92:
					"The resulting completely macro-replaced preprocessing
					token sequence is not processed as a preprocessing
					directive even if it resembles one."
				*/

				spell_node * spell_p = id_tok_ptr(tp);

				error(
					es("Unrecognized preprocessor directive: ");
					es(spell_p -&gt; spell_name);
				);
				tp = skip_pp(tp);
			}
			else {
				error(
					es("Unrecognized token in preprocessor directive: ");
					tok_dump1(tp, PRINT_HIDDEN_TOKS);
				);
			}

			/*
				Replace the POUND_TOK at skip_tp by skip directive tok or
				a big skip tok.

				cpp_incl2 uses this code to stitch in the included file.
				This is the *only* place patching is done!
			*/

			ASSERT(*skip_tp == POUND_TOK);

			if (start_line == -1) {
				skipped_lines = 0;
			}
			else {
				skipped_lines = err_line - start_line;
			}
			ASSERT(skipped_lines &gt;= 0);

			if (skipped_lines == 0) {
				tok_patch(skip_tp, HIDDEN_SKIP_DIRECTIVE_TOK,
					tp, "skip directive");
			}
			else {
				skip_node * skip_p = NULL;
				new_file_macro(skip_p, skip_stats);
				skip_p -&gt; skip_lines = skipped_lines;
				skip_p -&gt; skip_tp = tp;

				/* Change the # to a big skip */
				tok_patch(skip_tp, HIDDEN_BIG_SKIP_TOK, skip_p, "skip multiple lines");
			}

		} /* End c == NL */


		else if (is_id(*tp) &amp;&amp; (id_tok_ptr(tp)) -&gt; spell_macro != NULL) {

			tp = mac_outer_expand(tp);
		}

		else if (*tp == ERROR_MESSAGE_TOK) {

			char * message = (char *) ptr_tok_ptr(tp);

			/* Do not print the error token.. */
			tok_ignore(tp);

			/* Print an error message generated in tokize. */
			error(es(message));
		}
		else {
			next_tok(tp);
		}

	} /* end while */

	/*
		End of cpp main loop.
	*/
	TRACE("-cpp_mst_dump",	mst_dump_all());

	{
		mac_def_node * md_p;

		/* Free all pointers to formal arguments. */
		lst_every_macro(md_p, mac_mdef_list) {

			ASSERT_TRACE(md_p -&gt; mac_spell -&gt; spell_macro == md_p,
				es("md_p -&gt; mac_spell -&gt; spell_macro: ");
				eptr(md_p -&gt; mac_spell -&gt; spell_macro);
				enl();
				es("md_p: "); eptr(md_p); enl();
			);

			md_p -&gt; mac_spell -&gt; spell_macro = NULL;
		}
		/*
			Make sure we do not execute the above code twice.
			mac_def_list is a "constituent list" of mac_def_block_list.
			mac_def_list freed implicitly when mac_def_block_list is freed.
		*/
		mac_mdef_list = NULL;
	}

	/* The actual nodes have file lifetime and will be freed later. */
	cpp_inhibit_list = NULL;

	TRACEPX(ftag, es(err_file_name()));
	return first_tp;
}
</t>
<t tx="ekr.20080529093004.390">@ Handle the #elif directive when lines are NOT being skipped. The skip_lines() routines handles #elif when lines ARE being skipped.
@c

static token *
cpp_elif (token * tp)
{
	FTAG("cpp_elif");
	TRACEPB(ftag, tok_dump_line(tp));

	/* Skip the "elif" */
	next_tok(tp);
	skip_hws_tok(tp);

	if (if_level == 0) {
		error(es("#elif ignored--no matching #if"));
		tp = skip_pp(tp);
	}
	else {
		/*
			Something has already evaluated to TRUE.
			Skip all the rest of the directive.
		*/
		tp = skip_lines(tp, "elif", SKIP_UNTIL_ENDIF);
	}
	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.391">@ Handle the #else directive when lines are NOT being skipped. The skip_lines() routine handles #else when lines ARE being skipped.
@c

static token *
cpp_else (token * tp)
{
	FTAG("cpp_else");
	TICKB(ftag);

	if (if_level == 0) {
		error(es("#else ignored--no matching #if"));
		tp = skip_pp(tp);
	}
	else if (if_stack [if_level - 1] == TRUE) {
		error(es("Duplicate #else ignored"));
		tp = skip_pp(tp);
	}
	else {
		if_stack [if_level - 1] = TRUE;

		/*
			Something has already evaluated to TRUE.
			Skip everything else.
		*/
		tp = skip_lines(tp, "else", SKIP_UNTIL_ENDIF);
	}

	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.392">@ Handle the #endif directive when lines are NOT being skipped. The skip_lines() routine handles #endif when lines ARE being skipped.
@c

static token *
cpp_endif (token * tp)
{
	FTAG("cpp_endif");
	TICKB(ftag);

	if (if_level == 0) {
		error(es("#endif ignored--no matching #if"));
	}
	else {
		if_level--;
	}

	tp = skip_pp(tp);
	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.393">@ Print an error message and abort.
@c

static void
cpp_error (token * tp)
{
	SL_DISABLE();

	error(tok_dump_line2(tp,
		DONT_PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_USER_TOKENS));
	end_abort();
}
</t>
<t tx="ekr.20080529093004.394">@ Handle the #if directive when lines are NOT being skipped. The skip_lines() routine handles #if when lines ARE being skipped.
@c

static token *
cpp_if (token * tp)
{
	FTAG("cpp_if");
	long result = 0;
	TRACEPB(ftag, tok_dump_line(tp));

	/* Skip the "if" */
	next_tok(tp);

	/* Indicate that no #else has been seen. */
	if (if_level &gt;= CPP_MAX_IF) {
		error(es("#if ignored--nested too deeply"));
		return skip_pp(tp);
	}
	if_stack [if_level++] = FALSE;

	error_seen = FALSE;
	tp = eval(tp, &amp;result);
	if (result == 0L) {
		/*
			Nothing has evaluated to TRUE so far.
			Skip only to #elif or #else.
		*/
		tp = skip_lines(tp, "if", SKIP_UNTIL_ELSE_OR_ENDIF);
	}

	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.395">@ Handle the #ifdef and #ifndef directives when lines are NOT being skipped. The skip_lines() routine handles #if when lines ARE being skipped.  flag is TRUE for #ifdef and FALSE for #ifndef.
@c

static token *
cpp_ifdef (token * tp, bool flag)
{
	FTAG("cpp_ifdef");
	TRACEPB(ftag, tok_dump_line(tp));

	if(if_level &gt; CPP_MAX_IF) {
		error(es("#ifdef or #ifndef ignored--nested too deeply"));
		tp = skip_pp(tp);
		goto done;
	}

	/* Skip the "ifdef" or "ifndef" */
	next_tok(tp);

	skip_hws_tok(tp);

	if (!is_id(*tp)) {
		error(es("#ifdef or #ifndef ignored--identifier expected"));
		tp = skip_pp(tp);
		goto done;
	}

	/* Indicate that no #else has been seen. */
	if_stack [if_level++] = FALSE;

	/* Skip lines if required. */
	{

		spell_node * spell_p = id_tok_ptr(tp);
		bool	found = (spell_p -&gt; spell_macro != NULL);

		if (flag == found) {
			tp = skip_pp(tp);
		}
		else {
			/*
				Nothing has evaluated to TRUE so far.
				Skip only to #elif or #else.
			*/
			tp = skip_lines(tp, flag ? "ifdef" : "ifndef", SKIP_UNTIL_ELSE_OR_ENDIF);
		}
	}

done:
	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.396">@ Handle the #include directive.
@c

static token *
cpp_include (register token * tp)
{
	FTAG("cpp_include");
	FTAGV("-cpp_include_v");
	char * ftagvv = "cpp_include_vv";
	bool std_lib_flag = FALSE;
	char * f_name = NULL;
	token * patch_tp = tp;

	TRACE("-no_include", return skip_pp(tp));

	TRACEP(ftag, tok_dump_line(tp));

	/* Skip the include. */
	next_tok(tp);

	skip_hws_tok(tp);

	/* Allow macro expansion. */
	tp = mac_outer_expand(tp);

	/* Tokenize generates deferred error messages for some bad file names. */
	if (*tp == ERROR_MESSAGE_TOK) {

		char * message = (char *) ptr_tok_ptr(tp);

		tok_ignore(tp);
		error(es(message));
		return skip_pp(tp);
	}

	if (*tp != WIDE_STRING_TOK &amp;&amp; *tp != STRING_TOK &amp;&amp;
		*tp != FILE_NAME_TOK) {

		error(
			es("File name expected after #include, ");
			tok_dump1(tp, DONT_PRINT_HIDDEN_TOKS);
			es(" found instead");
		);
		return skip_pp(tp);
	}

	std_lib_flag = (*tp == FILE_NAME_TOK);
	if (*tp == WIDE_STRING_TOK || *tp == STRING_TOK ||
		*tp == FILE_NAME_TOK) {
		f_name = ptr_tok_ptr(tp);
	}

	/* Do nothing if the file name is on the file inhibit list. */
	{
		file_inhibit_node * fxp;

		lst_every_macro(fxp, cpp_inhibit_list) {
			if (str_eq(f_name, fxp -&gt; inhibit_fname)) {

				TRACEP("cpp_inhibit",
					es(f_name);
					es(" on inhibit list.  Ignoring: #include ");
					es(std_lib_flag ? "&lt;" : "\"");
					es(f_name);
					es(std_lib_flag ? "&gt;" : "\""); enl());

				return skip_pp(tp);
			}
		}
	}

	/*
		Add the file to the inhibit list if -once option is enabled.
	*/
	if (arg_once_flag) {
		cpp_inhibit(f_name);
	}

	/*
		Do not include filename.h if _H_filename is defined.
	*/

#ifdef THINK_C

	{
		spell_node * spell_p = NULL;
		size_t	i = strlen(f_name);

		if (i &gt; 3 &amp;&amp; f_name[i-2] == '.' &amp;&amp; f_name[i-1] == 'h') {

			char * f2_name = NULL;
			char * rtextp = NULL;
			int nargs = 0;

			new_file_cat2_macro(f2_name, "_H_", f_name);
			spell_p = tok_lookup_hash(f2_name);
			if (spell_p != NULL &amp;&amp; spell_p -&gt; spell_macro != NULL) {

				TRACEP(ftagv,
					es(f2_name); es(" defined.  Ignoring: #include ");
					es(std_lib_flag ? "&lt;" : "\"");
					es(f_name);
					es(std_lib_flag ? "&gt;" : "\""); enl());

				return skip_pp(tp);
			}
		}
	}

#endif

	/* Skip the line before recursing. */
	tp = skip_pp(tp);

	/* Open the new file file. */

	/* Allow the user to specify a full path name. */
	{
		io_mem_block * input_block =
			io_read_pad_all(f_name, 1, ' ', 3 , IO_EOF_CHAR,
				NO_CANT_MESSAGE, IO_TEXT_FILE);

		if (input_block != NULL) {
			TRACEP(ftagvv, es("successful open: "); es(f_name));
			return cpp_incl2(tp, input_block, f_name, f_name, std_lib_flag);
		}
	}

	/* Search the list of search paths. */
	{
		io_path_list * search_p = NULL;
		io_mem_block * input_block = NULL;

		lst_every_macro(search_p, arg_search_paths) {

			char * path_name = NULL;
			new_file_cat2_macro(path_name, search_p -&gt; io_path_name, f_name);
			input_block = io_read_pad_all(path_name, 1, ' ', 3 , IO_EOF_CHAR,
				NO_CANT_MESSAGE, IO_TEXT_FILE);
			if (input_block != NULL) {
				TRACEP(ftagvv, es("successful open: "); es(path_name));
				return cpp_incl2(tp, input_block, f_name, path_name, std_lib_flag);
			}
		}
	}

	/* Always report this error. */
	force_error(
		es("#include ");
		es(std_lib_flag ? "&lt;" : "\"");
		es(f_name);
		es(std_lib_flag ? "&gt;" : "\"");
		es(" ignored--file not found");
	);

	return tp;
}
</t>
<t tx="ekr.20080529093004.397">@ Preprocess the input block by tokenizing it and adding it to the current token list.
@c

static token *
cpp_incl2(
	token * tp,
	io_mem_block * input_block,
	char * f_name,
	char * full_path_name,
	bool std_lib_flag)
{
	FTAG("cpp_incl2");
	file_info_node * fip = NULL;
	token * first_token = NULL;

	if (arg_v_include_flag || arg_v_full_include_flag) {

		ecnl();
		es("#include ");
		es(std_lib_flag ? "&lt;" : "\"");
		es(arg_v_full_include_flag ? full_path_name : f_name);
		es(std_lib_flag ? "&gt;" : "\"");
		enl();
	}

	new_file_macro(fip, cpp_stats);
	fip -&gt; finfo_fname		= err_fname;
	fip -&gt; finfo_line		= err_line;
	fip -&gt; finfo_line_offset = err_line_offset;
	fip -&gt; finfo_tp			= tp;			/* "return address" for tokize. */

	/* Set the new settings for cpp. */
	err_fname = f_name;
	err_line = 0;
	err_line_offset = 0;

	/* Make sure the file ends in a physical newline. */
	{
		char * p = input_block -&gt; mem_start;

		if (p [input_block -&gt; mem_length -1] != '\n') {
			p [input_block -&gt; mem_length] =  '\n';
			TRACEP("cpp_incl2", es("trailing newline added\n"));
		}
	}

	/*
		Tokenize the file.
	*/

	/* Do not include time in tokize or compress in stats for cpp. */
	STATX("cpp");

	STATB("inner_cpp");
	compress(input_block);
	first_token = tokize(input_block, fip, f_name, END_WITH_EOF_TOK, NULL);
	STATX("inner_cpp");

	STATB("cpp");

	/* The input block can be freed directly after tokize is finished. */
	obj_free_macro(input_block -&gt; mem_freep);
	obj_free_macro(input_block);

	/*
		Just return the first token of the new file.
		The "patch code" in cpp will stitch the new file in place.
	*/
	return first_token;
}
</t>
<t tx="ekr.20080529093004.398">@ Inhibit any further #include processing for the indicated file.
@c

static void
cpp_inhibit(char * file_name)
{
	FTAG("cpp_inhibit");
	file_inhibit_node * fxp = NULL;

	/* Don't add a name to the list twice. */
	lst_every_macro(fxp, cpp_inhibit_list) {
		if (str_eq(file_name, fxp -&gt; inhibit_fname)) {
			return;
		}
	}

	new_file_macro(fxp, inhibit_stats);
	new_file_string_macro(fxp -&gt; inhibit_fname, file_name);

	TRACEP(ftag, es(file_name); es(" added to file inhibit list\n"));
}
</t>
<t tx="ekr.20080529093004.399">@ Set the line number and file name.
@c

#define BUF_MAX 1000 /* Size of the file name buffer. */

static token *
cpp_line  (token * tp)
{
	FTAG("cpp_line");
	TRACEP(ftag, tok_dump_line(tp));

	/* Skip over the "line" */
	next_tok(tp);
	skip_hws_tok(tp);

	/* Allow macro expansion. */
	tp = mac_outer_expand(tp);

	if (*tp != INT_TOK &amp;&amp; *tp != LONG_TOK) {
		error(es("line number expected after #line"));
		return skip_pp(tp);
	}

	/* Set err_line by converting the string. */
	{
		char * start = (char *) val_tok_val(tp);
		char c = start[strlen(start)];
		char * end = NULL;
		long val = (long) strtoul(start, &amp;end, 0);
		
		if (*end != '\0') {
			error(es("ignoring bad #line number"));
			return skip_pp(tp);
		}
		else {
			/* The line number remains the same.  Only the offset changes. */
			err_line_offset = val - err_line;
		}
	}

	next_tok(tp);
	skip_hws_tok(tp);

	/* See if an optional file name is present. */

	if (!is_id(*tp)) {
		tp = skip_pp(tp);
		goto done;
	}

	/* Allow a macro id here. */
	tp = mac_outer_expand(tp);

	/*
		Assume the rest of the line is a file name.
		Copy it to buffer[].
	*/
	{
		register char * s = NULL;
		register int buf_index = 0;

		char buffer[BUF_MAX];
		int  length = 0;

		while (*tp != WS_NL_TOK) {
			s = tok_2string(tp, &amp;length, FALSE);
			if (length + buf_index &lt; BUF_MAX) {
				strcpy(buffer + buf_index, s);
				buf_index += length;
			}
			else {
				tp = skip_pp(tp);
				break;
			}
			next_tok(tp);
		}

		/* Set the file name but not the line number. */
		{
			long	save_line = err_line;
			err_begin_file(buffer);
			err_line = save_line;
		}
	}

	/*
		Create a HIDDEN_FILE_INFO_TOK in the current token space.
		The HIDDEN_FILE_INFO_TOK points at a file_info_node which in turn
		points to the next token.
	*/

done:

	{
		file_info_node * fip = NULL;
		new_file_macro(fip, cpp_stats);

		/* Save the new settings. */
		fip -&gt; finfo_fname		= err_fname;
		fip -&gt; finfo_line		= err_line;
		fip -&gt; finfo_line_offset = err_line_offset;
		fip -&gt; finfo_tp			= tp;

		tp = tok_copy(HIDDEN_FILE_INFO_TOK, fip);
	}
	return tp;
}
</t>
<t tx="ekr.20080529093004.400">@ Handle all pragmas.
@c

static token *
cpp_pragma (token * tp)
{
	FTAG("cpp_pragma");
	TRACEPB(ftag, tok_dump_line(tp));

	/* Skip the pragma. */
	next_tok(tp);
	skip_hws_tok(tp);

	if (*tp == ID_TOK) {
		spell_node * spell_p = id_tok_ptr(tp);

		if (str_eq(spell_p -&gt; spell_name, "once") &amp;&amp; err_fname != NULL) {
			cpp_inhibit(err_fname);
		}
	}

	tp = skip_pp(tp);
	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.401">@ #undef a macro name. Give no warning if the name has not been defined.
@c

static token *
cpp_undef (token * tp)
{
	FTAG("cpp_undef");
	TRACEPB(ftag, tok_dump_line(tp));

	/* Skip the undef. */
	next_tok(tp);
	skip_hws_tok(tp);

	/* Get the identifier. */
	if (!is_id(*tp)) {
		error(es("#undef ignored--identifier expected"));
	}
	else if ((id_tok_ptr(tp)) -&gt; spell_macro != NULL) {

		spell_node * sp = (spell_node *) id_tok_ptr(tp);
		mac_def_node * md_p = sp -&gt; spell_macro;

		TRACEPN(ftag,
			ecnl(); es("undefining ");
			es((id_tok_ptr(tp)) -&gt; spell_name); enl());

		md_p -&gt; mac_spell -&gt; spell_macro = NULL;

		/* Remove the item from the list. */
		lst_remove_macro(md_p, mac_mdef_list, mac_def_node);
	}

	tp = skip_pp(tp);
	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.402">@ Evaluate a constant expression to either true or false. A constant expression consists of:  1. integer constants or character constants 2. the unary - + and ~ operators 3. the binary + - * / &amp; | ^ &lt;&lt; &gt;&gt; == != &lt; &gt; &lt;= &gt;= oprators 4. the ternary ? : operator 5. the ( and ) groupers.  Identifiers are expanded if they are defined, otherwise they are taken to have a value of zero. All arithmetic is integer and ints are expanded to long.
@c

static token *
eval(register token * tp, long * val_p)
{
	FTAG("eval");
	FTAGV("-eval_v");
	int op_1ptr = op_ptr;
	TRACEPB(ftag, tok_dump_line(tp));

	/* State S1: unary +, unary -, !, ~, constant or id is expected here. */

s1:
	skip_hws_tok(tp);

	TRACEPN(ftagv, es("state 1: "); es(tok_name(*tp)); enl());

	switch(*tp) {

	case PLUS_TOK:	push_op(UPLUS_TOK);		next_tok(tp); goto s1;
	case MINUS_TOK:	push_op(UMINUS_TOK);	next_tok(tp); goto s1;
	case NOT_TOK:	push_op(NOT_TOK);		next_tok(tp); goto s1;
	case TILDE_TOK:	push_op(TILDE_TOK);		next_tok(tp); goto s1;

	case CHAR_TOK:

		push_val(char_val(ptr_tok_ptr(tp)), SIGNED_VAL);
		next_tok(tp);
		break;

	case INT_TOK:
	case LONG_TOK:
		{
			char * start = ptr_tok_ptr(tp); /* 7/16/92 */
			size_t len = strlen(start);
			char c1 = (len &gt; 0) ? tolower(start[len-1]) : ' ';
			char c2 = (len &gt; 1) ? tolower(start[len-2]) : ' ';
			bool unsigned_flag = c1 == 'u' || c2 == 'u';
			char * end = NULL;
			ulong uval = 0;
			
			/* Bug fix 8/29/94: parse an *unsigned* constant to retain all bits. */
			uval = strtoul(start, &amp;end, 0);

			if (*end != '\0' &amp;&amp; tolower(*end) != 'l' &amp;&amp; tolower(*end) != 'u') {
				error(es("bad constant value: "); es(start); es(". 0 assumed"));
				push_val(0L, SIGNED_VAL);
			}
			else {
				push_val(uval, unsigned_flag);
			}
			next_tok(tp);
		}
		break;

	case KM_DEFINED:

		{
			bool paren_seen = FALSE;

			next_tok(tp);
			skip_hws_tok(tp);

			if (*tp != ID_TOK &amp;&amp; *tp != LPAREN_TOK) {
				error(
					es("Id or '(' expected after 'defined', ");
					es(tok_name(*tp)); es(" found");
				);
				goto bad_expr2;
			}
			paren_seen = (*tp == LPAREN_TOK);
			if (paren_seen) {
				next_tok(tp);
				skip_hws_tok(tp);
				if (*tp != ID_TOK) {
					error(
						es("Id expected after '(', ");
						es(tok_name(*tp)); es(" found");
					);
					goto bad_expr2;
				}
			}

			if (is_id(*tp) &amp;&amp; (id_tok_ptr(tp)) -&gt; spell_macro != NULL) {
				push_val(1L, SIGNED_VAL);
			}
			else {
				push_val(0L, SIGNED_VAL);
			}
			next_tok(tp);
			if (paren_seen) {
				if (*tp == RPAREN_TOK) {
					next_tok(tp);
				}
				else {
					error(
						es("')' expected, ");
						es(tok_name(*tp)); es(" found\n");
					);
					goto bad_expr2;
				}
			}
		}
		break;

	case LPAREN_TOK:

		{
			long result;

			/* Evaluate the expression recursively. */
			next_tok(tp);
			tp = eval(tp, &amp;result);
			if (*tp = RPAREN_TOK) {
				next_tok(tp);
				push_val(result, SIGNED_VAL);
			}
			else {
				error(
					es("')' expected, ");
					es(tok_name(*tp)); es(" found\n");
				);
				goto bad_expr2;
			}
		}
		break;

	default:

		if (is_id(*tp)) {
			if ((id_tok_ptr(tp)) -&gt; spell_macro != NULL) {

				tp = mac_outer_expand(tp);

				/* Still expecting an identifier. */
				goto s1;
			}
			else {
				push_val(0L, SIGNED_VAL);
				next_tok(tp);
				break;
			}
		}
		else if (*tp == IDX_TOK) {
			push_val(0L, SIGNED_VAL);
			next_tok(tp);
			break;
		}
		else {
			error(
				es("Constant or '(' expected, ");
				es(tok_name(*tp)); es(" found\n");
			);
			goto bad_expr2;
		}
	}

	/* Perform all unary ops and enter state S2. */

	TRACEPN(ftagv, es("at state 1A\n"));

	while (op_ptr &gt; op_1ptr) {

		token op;

		switch (op = pop_op()) {

		case UPLUS_TOK:
			break;
			
		case UMINUS_TOK:
		{
			bool unsigned_flag;
			unsigned long uval = pop_val(&amp;unsigned_flag);
			
			if (unsigned_flag) {
				uval = - uval;
				push_val(uval, UNSIGNED_VAL);
			}
			else {
				long val = uval;
				val = - val;
				push_val(val, SIGNED_VAL);
			}
			break;
		}
			
		case NOT_TOK:
		{
			bool unsigned_flag;
			unsigned long uval = pop_val(&amp;unsigned_flag);
			push_val(!uval, unsigned_flag);
			break;
		}

		case TILDE_TOK:
		{
			bool unsigned_flag;
			unsigned long uval = pop_val(&amp;unsigned_flag);
			push_val(~uval, unsigned_flag);
			break;
		}
		
		default: push_op(op); goto s2;
		}
	}

	/* State S2: binary op or end_of_expression expected here. */

s2:
	skip_hws_tok(tp);

	TRACEPN(ftagv, es("state 2: "); es(tok_name(*tp)); enl());

	/*
		Perform binary operators until the operator stack is
		empty or until token operator has a higher precedence
		than the operator on the top of the operator stack.
	*/

	if (op_ptr &gt; op_1ptr &amp;&amp; gt_prec(op_stack[op_ptr - 1], *tp)) {
	
		bool unsigned_flag1 = 0;
		bool unsigned_flag2 = 0;
		
		/* The result is unsigned if either operand is unsigned. */
		ulong uval2 = pop_val(&amp;unsigned_flag1);
		ulong uval1 = pop_val(&amp;unsigned_flag2);
		
		bool unsigned_flag = unsigned_flag1 || unsigned_flag2;

		token op = pop_op();
		
		/*
			Bug fix: 8/29/94:
			The bit pattern we get will depend on whether val1 and val2
			are considered to be signed or unsigned numbers.
			
			Example:  val1 = 0xffffffff; val2 = 2;
			
			unsigned: val1/val1 = 0x7fffffff;
			signed:   val1/val2 = (-1)/2 = 0;
		*/
		
		if (unsigned_flag) {

			switch (op) {
			case PLUS_TOK:		push_val(uval1 +  uval2, unsigned_flag);	goto s2;
			case MINUS_TOK:		push_val(uval1 -  uval2, unsigned_flag);	goto s2;
			case STAR_TOK:		push_val(uval1 *  uval2, unsigned_flag);	goto s2;
			case DIV_TOK: push_val((uval2?(uval1/uval2):0), unsigned_flag);	goto s2;
			case MOD_TOK:		push_val(uval1 %  uval2, unsigned_flag);	goto s2;
			case AND_TOK:		push_val(uval1 &amp;  uval2, unsigned_flag);	goto s2;
			case OR_TOK:		push_val(uval1 |  uval2, unsigned_flag);	goto s2;
			case XOR_TOK:		push_val(uval1 ^  uval2, unsigned_flag);	goto s2;
			case LSHIFT_TOK:	push_val(uval1 &lt;&lt; uval2, unsigned_flag);	goto s2;
			case RSHIFT_TOK:	push_val(uval1 &gt;&gt; uval2, unsigned_flag);	goto s2;
			case EQUAL_TOK:		push_val(uval1 == uval2, unsigned_flag);	goto s2;
			case NE_TOK:		push_val(uval1 != uval2, unsigned_flag);	goto s2;
			case LT_TOK:		push_val(uval1 &lt;  uval2, unsigned_flag);	goto s2;
			case GT_TOK:		push_val(uval1 &gt;  uval2, unsigned_flag);	goto s2;
			case LE_TOK:		push_val(uval1 &lt;= uval2, unsigned_flag);	goto s2;
			case GE_TOK:		push_val(uval1 &gt;= uval2, unsigned_flag);	goto s2;
			case LAND_TOK:		push_val(uval1 &amp;&amp; uval2, unsigned_flag);	goto s2;
			case LOR_TOK:		push_val(uval1 || uval2, unsigned_flag);	goto s2;
	
			case COLON_TOK:
	
				if (pop_op() != QUESTION_TOK) {
					error(
						es("question mark expected, ");
						es(tok_name(*tp)); es(" found\n");
					);
					goto bad_expr2;
				}
				{
					bool junk;
					push_val(pop_val(&amp;junk) ? uval1 : uval2, unsigned_flag);
				}
				goto s2;
	
			default:
				goto bad_expr;
			}
		}
		else {
		
			long val1 = uval1;
			long val2 = uval2;
		
				switch (op) {
			case PLUS_TOK:		push_val(val1 +  val2, unsigned_flag);	goto s2;
			case MINUS_TOK:		push_val(val1 -  val2, unsigned_flag);	goto s2;
			case STAR_TOK:		push_val(val1 *  val2, unsigned_flag);	goto s2;
			case DIV_TOK: push_val((val2?(val1/val2):0), unsigned_flag); goto s2;
			case MOD_TOK:		push_val(val1 %  val2, unsigned_flag);	goto s2;
			case AND_TOK:		push_val(val1 &amp;  val2, unsigned_flag);	goto s2;
			case OR_TOK:		push_val(val1 |  val2, unsigned_flag);	goto s2;
			case XOR_TOK:		push_val(val1 ^  val2, unsigned_flag);	goto s2;
			case LSHIFT_TOK:	push_val(val1 &lt;&lt; val2, unsigned_flag);	goto s2;
			case RSHIFT_TOK:	push_val(val1 &gt;&gt; val2, unsigned_flag);	goto s2;
			case EQUAL_TOK:		push_val(val1 == val2, unsigned_flag);	goto s2;
			case NE_TOK:		push_val(val1 != val2, unsigned_flag);	goto s2;
			case LT_TOK:		push_val(val1 &lt;  val2, unsigned_flag);	goto s2;
			case GT_TOK:		push_val(val1 &gt;  val2, unsigned_flag);	goto s2;
			case LE_TOK:		push_val(val1 &lt;= val2, unsigned_flag);	goto s2;
			case GE_TOK:		push_val(val1 &gt;= val2, unsigned_flag);	goto s2;
			case LAND_TOK:		push_val(val1 &amp;&amp; val2, unsigned_flag);	goto s2;
			case LOR_TOK:		push_val(val1 || val2, unsigned_flag);	goto s2;
	
			case COLON_TOK:
	
				if (pop_op() != QUESTION_TOK) {
					error(
						es("question mark expected, ");
						es(tok_name(*tp)); es(" found\n");
					);
					goto bad_expr2;
				}
				{
					bool junk;
					push_val(pop_val(&amp;junk) ? val1 : val2, unsigned_flag);
				}
				goto s2;
	
			default:
				goto bad_expr;
			}
		}
	}

	/* Enter state S1 or return on end-of-expression. */

	skip_hws_tok(tp);

	if (
		*tp == END_PROG_TOK || *tp == HIDDEN_END_FILE_TOK ||
		*tp == WS_NL_TOK || *tp == RPAREN_TOK
	) {
		bool junk;
		*val_p = pop_val(&amp;junk);
		goto done;
	}
	else {
		push_op(*tp);
		next_tok(tp);
		goto s1;
	}

bad_expr:
	if (!error_seen) {
		error(es("Bad constant expression--zero assumed\n"));
	}

bad_expr2:
	error_seen = TRUE;
	* val_p = 0L;
	TRACEPX(ftag,
		es("error: result=0L; remain: ");
		tok_dump_line(tp));
	return tp;

done:
	TRACEPX(ftag, es("*val_p: "); elong(*val_p); enl());
	return tp;
}
</t>
<t tx="ekr.20080529093004.403">@ Return TRUE if a reduction is possible with op1 on the operator stack and op2 as the new operator.  Always return TRUE if op2 delimits the expression, otherwise return TRUE if op1 has higher precedence than op2, otherwise return TRUE if they associate left to right.  This code reflects the table on page 49 of K &amp; R.
@c

static bool
gt_prec(register token op1, register token op2)
{
	register int prec1, prec2;

	TRACEP("gt_prec", es(tok_name(op1)); ecs(); es(tok_name(op2)); enl());

	if (op2 == RPAREN_TOK || op2 == NULL_TOK ||
		op2 == WS_NL_TOK ||
		op2 == END_PROG_TOK || op2 == HIDDEN_END_FILE_TOK) {
		return TRUE;
	}

	prec1 = prec((int)op1);
	prec2 = prec((int)op2);

	if (prec1 != prec2) {
		/* Associativity doesn't matter. */
		return prec1 &gt; prec2;
	}
	else if (prec1 == 14 || prec1 == 3 || prec1 == 2) {
		/* Associate right to left. */
		return FALSE;
	}
	else {
		/* Associate left to right. */
		return TRUE;
	}
}
</t>
<t tx="ekr.20080529093004.404">@ Return the precedence of an operator.  This code reflects the table on page 49 of K &amp; R.
@c

static int
prec(int operator)
{
	TRACEP("prec", elp(); es(tok_name(operator)); erpnl());

	switch (operator) {
	case TILDE_TOK:		return 14;
	case STAR_TOK:
	case DIV_TOK:
	case MOD_TOK:		return 13;
	case PLUS_TOK:
	case MINUS_TOK:		return 12;
	case LSHIFT_TOK:
	case RSHIFT_TOK:	return 11;
	case LT_TOK:
	case LE_TOK:
	case GT_TOK:
	case GE_TOK:		return 10;
	case EQUAL_TOK:
	case NE_TOK:		return 9;
	case XOR_TOK:		return 7;
	case OR_TOK:		return 6;
	case COLON_TOK:
	case QUESTION_TOK:	return 3;
	default:			return -1;
	}
}
</t>
<t tx="ekr.20080529093004.405">@ Routines to push and pop the operator and operand stacks.
@c

static void
push_op(token op)
{
	FTAG("push_op");
	TRACEP(ftag, elp(); es(tok_name(op)); erpnl());

	if (op_ptr &lt; MAX_EVAL_OP) {
		op_stack[op_ptr++] = op;
	}
	else {
		fatal(es("Operator stack overflow"));
	}
}
</t>
<t tx="ekr.20080529093004.406">static token
pop_op(void)
{
	FTAG("pop_op");
	SL_DISABLE();

	if (op_ptr &gt; 0) {
		TRACEP(ftag, eret(); es(tok_name(op_stack[op_ptr - 1])); enl());
		return op_stack [--op_ptr];
	}
	else {
		fatal(es("Operator stack underflow"));
		return NULL_TOK;
	}
}
</t>
<t tx="ekr.20080529093004.407">static void
push_val(long val, bool unsigned_flag)
{
	FTAG("push_val");
	TRACEPB(ftag, elong(val); ecs(); ebool(unsigned_flag));

	if (val_ptr &lt; MAX_EVAL_VAL) {
		val_stack  [val_ptr] = val;
		type_stack [val_ptr++] = unsigned_flag;
	}
	else {
		fatal(es("Value stack overflow"));
	}
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.408">static long
pop_val(bool * unsigned_flag)
{
	FTAG("pop_val");
	STATB(ftag);

	if (val_ptr &gt; 0) {
		*unsigned_flag = type_stack[val_ptr-1];
		
		TRACEPX(ftag, eret(); elong(val_stack [val_ptr - 1]); enl());
		return val_stack [--val_ptr];
	}
	else {
		fatal(es("Value stack underflow"));
	}
}
</t>
<t tx="ekr.20080529093004.409">@ Skip lines for #if, #ifdef, #ifndef, #elif or #else directives.  If skip_all_flag, skip until an #endif at the current level is found. If skip_all_flag is FALSE, skip until #else, #elif or #endif.  Interior #if, #ifdef, #ifndef, #elif, #else and #endif directives must be recognized and dealt with.
@c

static token *
skip_lines(register token * tp, char * directive_name, bool skip_all_flag)
{
	FTAG("skip_lines");
	register int level = 0;			/* Inner nesting level */
	long first_line = err_line;
	STATB(ftag);

	/* Just in case. */
	if (if_level &lt;= 0) {
		fatal(es("skip_lines: Can't happen"));
	}

	/*
		One line is scanned each time through this while loop.
	*/
	while(*tp != HIDDEN_END_FILE_TOK &amp;&amp; *tp != END_PROG_TOK) {

		token * first = tp;

		/* Skip the line if it doesn't start with '#'. */
		skip_hws_tok(tp);
		if (*tp != POUND_TOK) {

			TRACEPN(ftag, tok_dump_line(first));
			tp = skip_past(tp);
			continue;
		}

		/* Skip the '#'. */
		next_tok(tp);
		skip_hws_tok(tp);

		switch(*tp) {

		case K_IFDEF:
		case K_IFNDEF:
		case K_IF:

			level++;
			TRACEPN(ftag, tok_dump_line(first));
			tp = skip_past(tp);
			break;

		case K_ELIF:

			if (level == 0 &amp;&amp; !skip_all_flag) {

				long result;

				/* Skip the elif */
				next_tok(tp);

				error_seen = FALSE;
				tp = eval(tp, &amp;result);
				if (result != 0L) {
					TRACEPN(ftag, es("stopped by #elif\n"));
					goto done;
				}
			}

			TRACEPN(ftag, tok_dump_line(first));
			tp = skip_past(tp);
			break;

		case K_ELSE:

			if (level == 0 &amp;&amp; !skip_all_flag) {
				if (if_stack [if_level - 1] == FALSE) {
					if_stack [if_level - 1] = TRUE;
					TRACEPN(ftag, es("stopped by #else\n"));
					goto done;
				}
				else {
					error(es("Extra #else ignored"));
					break;
				}
			}

			TRACEPN(ftag, tok_dump_line(first));
			tp = skip_past(tp);
			break;

		case K_ENDIF:

			if (level &gt; 0) {
				level--;
			}
			else {
				if_level--;
				TRACEPN(ftag, es("stopped by #endif\n"));
				goto done;
			}

			TRACEPN(ftag, tok_dump_line(first));
			tp = skip_past(tp);
			break;

		default:

			TRACEPN(ftag, tok_dump_line(first));
			tp = skip_past(tp);
		}

	} /* End while */

	error(
		es("File ends in ");
		es(directive_name); es(" at line ");
		elong(first_line);
	);

	TRACEPX(ftag, eptr(tp); ecnl());
	return tp;

done:
	tp = skip_pp(tp);
	STATX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.410">@ Skip over one line, including the trailing newline. This should be called only by skip_lines(). (If called elsewhere cpp() will not see the newline.)
@c

static token *
skip_past(register token * tp)
{
	FTAG("skip_past");
	TRACEPB(ftag, tok_dump_line(tp));

	while (	*tp != WS_NL_TOK &amp;&amp;
			*tp != HIDDEN_END_FILE_TOK &amp;&amp;
			*tp != END_PROG_TOK) {
		next_tok(tp);
	}
	if (*tp == WS_NL_TOK) {
		err_line++;
		next_tok(tp);
	}

	TRACEX(ftag, enl());
	return tp;
}
</t>
<t tx="ekr.20080529093004.411">@ Skip over a preprocessor directive. Stop at a newline so it will be seen in the main cpp loop.
@c

token *
skip_pp(register token * tp)
{
	FTAG("skip_pp");
	TRACEPB(ftag, tok_dump_line(tp));

	while (	*tp != WS_NL_TOK &amp;&amp;
			*tp != HIDDEN_END_FILE_TOK &amp;&amp;
			*tp != END_PROG_TOK) {
		next_tok(tp);
	}

	TRACEX(ftag, enl());
	return tp;
}
</t>
<t tx="ekr.20080529093004.412">/*
	CC2: macro definition and processing routines.

	Use 4-space tabs for best appearance.

	source:  CCmacro.c
	started: February 25, 1992
	version:
		July 5, 1993.
			Bug fix to mac_substitute: make the code independent of sizeof(token).
		October 15, 1992.
			Give no warning if macro_name() is expected and macro_name is seen
			without parens.
		September 16, 1992.
			Allow null (or whitespace only) macro actual arguments.
		July 3, 1992
			Fixed bug in trace of mac_define.
		June 4, 1992
			Eliminated spell_union.
		May 19, 1992
			Added support for err_line_offset.
		May 18, 1992
			Initialized def_list to NULL in mac_define_string.
		May 12, 1992
			Made rescan logic into separate routine.
		May 9, 1992
			Defined mac_disable_node and mac_disable list.
			Added rescan code to mac_expand.
		May 5, 1992
			Allow "bare" macro symbol.
		April 16, 1992
			Removed WS_NEWLINES_TOK.
		April 1, 1992
			Installed ASSERT_TRACE macros.
		March 27, 1992
			Debugged parsing of actual arguments.
		March 17, 1992
			Added FTAG logic.
		March 8, 1992
			Added *formals to cpp_formals_list.
		March 6, 1992
			Installed obj_new_macro.
		March 4, 1992
			Installed new object routines.
		February 25, 1992
			Based on SPP def.c: March 22, 1991
*/

&lt;&lt; CCmacro #includes &gt;&gt;
&lt;&lt; CCmacro declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.413">#include "CC.h"

#include "CCcpp.h"
#include "CCdump.h"
#include "CCmacro.h"
#include "CCmem.h"
#include "CCmst.h"
#include "CCtokize.h"

#include &lt;LIBio.h&gt;
#include &lt;LIBlist.h&gt;
#include &lt;LIBobj.h&gt;

#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.414">/*
	Variables and structures local to this file.
*/
static long mac_hidden_nl;	/* Hidden newlines seen in mac_parse_actuals. */

typedef struct mac_disable_struct mac_disable_node;

/* The list of disabled macro names. */
static struct mac_disable_struct {
	mac_disable_node *	dis_next;
	spell_node *		dis_spell;
};

static mac_disable_node * mac_disable_list;

/*
	Refuse to expand the macro if current recursion depth exceeds the
	maximum recursion depth.  This protects the compiler's stack.
*/

#define MAX_EXPAND_DEPTH 50

static int mac_expand_depth = 0;

/*
	Function prototypes of internal routines.
*/
static bool		mac_compare_fargs	(int nargs, char ** fp, mac_def_node *mdef_p);
static bool		mac_compare_rtexts	(token * tp1, token * tp2);
static token *	mac_expand
	(token * tp, token * bound_tp, token ** res_last);
static void		mac_expand_arg		(token ** ap_first, token ** ap_last);
static token *	mac_get_actuals
	(token * tp,
	token *** ap_first, token *** ap_last, token *** exp_first, token *** exp_last,
	int * nargs, token * bound_tp);
static token *	mac_get_formals		(token * tp, char  *** fp, int * nargs);
static token *	mac_parse_actuals
	(token * tp, token ** ap_first, token ** ap_last, int * nargs, token * bound_tp);
static token *	mac_parse_formals	(token * tp, char ** fp, int * nargs);
static token *	mac_paste_tokens
	(token * tp1, token * bound_tp, token ** ap_first, token ** ap_last);
static token * mac_rescan
	(token * res_first, token * res_bound, token * res_last, spell_node * spell_p);
static void		mac_special		(token * tp, spell_node * spell_p);
static char *	mac_stringize	(token * tp_first, token * tp_last);
static token *	mac_substitute
	(spell_node * spell_p, token * rtokens,
	token ** ap_first, token ** ap_last, token ** exp_first, token ** exp_last,
	token ** res_first, token ** res_bound, token ** res_last,
	int nargs, token * tp_follow, long hidden_nl);
</t>
<t tx="ekr.20080529093004.415">@ Return TRUE if the spelling of all formal arguments are identical.
@c

static bool
mac_compare_fargs(int nargs, char ** names1, mac_def_node *mdef_p)
{
	FTAG("mac_compare_fargs");
	register int i = 0;
	register char ** names2 = mdef_p -&gt; mac_names;
	STATB(ftag);

	if (nargs != mdef_p -&gt; mac_nargs) {
		TRACEPX(ftag, eret(); es("FALSE (nargs)"));
		return FALSE;
	}

	for (i = 0; i &lt; nargs; i++) {
		if (!str_eq(names1[i], names2[i])) {
			TRACEPX(ftag, eret(); ebool(FALSE));
			return FALSE;
		}
	}

	TRACEPX(ftag, eret(); ebool(TRUE));
	return TRUE;
}
</t>
<t tx="ekr.20080529093004.416">@ Return TRUE if two macro replacement texts are identical.
@c

static bool
mac_compare_rtexts(register token * tp1, register token * tp2)
{
	FTAG("mac_compare_rtexts");
	TRACEPB(ftag,
		enl();
		tok_dump_line2(tp1,
			PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_NON_USER_TOKENS);
		ecnl();
		tok_dump_line2(tp2,
			PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_NON_USER_TOKENS);
		ecnl();
	);

	while (*tp1 != WS_NL_TOK) {

		switch(*tp1) {

		case MACRO_ARG_TOK:

			/* Make sure the argument numbers are the same. */
			if (*tp2 != MACRO_ARG_TOK ||
				val_tok_val(tp1) != val_tok_val(tp2)) {
				goto false_return;
			}
			break;

		case CHAR_TOK:
		case FILE_NAME_TOK:
		case FLOAT_TOK:
		case ID_TOK:		/* suppresses switch. */
		case IDX_TOK:
		case LONG_TOK:
		case STRING_TOK:
		case WIDE_CHAR_TOK:
		case WIDE_STRING_TOK:

			/* Make sure the spellings are the same. */
			if (*tp1 != *tp2 ||
				!str_eq(ptr_tok_ptr(tp1), ptr_tok_ptr(tp2))) {
				goto false_return;
			}
			break;

		case WS_TOK:		/* suppresses switch. */
		case WS_NL_TOK:		/* suppresses switch. */

			/* The 2 kinds of blanks compare equal. */
			if (*tp2 != WS_TOK &amp;&amp; *tp2 != WS_BLANKS_TOK) {
				goto false_return;
			}
			break;

		default:
			if (*tp1 != *tp2) {
				goto false_return;
			}
		}

		/* Equal so far. Go on. */
		next_tok(tp1);
		next_tok(tp2);
	}

	TRACEPX(ftag, eret(); ebool(*tp2 == WS_NL_TOK));
	return *tp2 == WS_NL_TOK;

false_return:
	TRACEPX(ftag, eret(); ebool(FALSE));
	return FALSE;
}
</t>
<t tx="ekr.20080529093004.417">@ Handle the #define directive. If special_flag is true, we define a special macro such as __line__.  The replacement text is massaged in place because it will never need to be printed. The replacement text is guaranteed to end in a newline.
@c

token *
mac_define (register token * tp, bool special_flag)
{
	FTAG("mac_define");
	FTAGV("-mac_define_v");
	register spell_node * spell_p = NULL;		/* The spelling of the macro. */
	register mac_def_node * prev_mdef_p = NULL;	/* Previous macro def. */
	char ** fp = NULL;		/* Formal parameter descriptor. */
	int nargs = 0;			/* Number of formal arguments. */
	char * name = NULL;		/* macro name. */
	token * rtext = NULL;	/* First token of new rtext. */
	token * old_tp = NULL;	/* Saved ptr at original rtext. */
	TRACEPB(ftag,
		tok_dump_line(tp));

	/* Skip the define. */
	next_tok(tp);
	skip_hws_tok(tp);

	/* Make sure the name is present. */
	if (!is_id(*tp)) {
		error(es("#define ignored--no symbol name given"));
		tp = skip_pp(tp);
		goto done;
	}

	/*
		Reject any user attempt to redefine "defined", __time__, etc.
	*/
	if (!special_flag &amp;&amp; is_nodef(*tp)) {
		error(es("can not redefine "); es(tok_name(*tp)));
		tp = skip_pp(tp);
		goto done;
	}

	/* Remember the macro name. */
	spell_p = id_tok_ptr(tp);
	name = spell_p -&gt; spell_name;
	prev_mdef_p = spell_p -&gt; spell_macro;

	ASSERT(spell_p);
	TRACEPN(ftag, es("name: "); es(name));

	/* Move past the macro name. */
	next_tok(tp);

	/*
		Do nothing if the name has been #undef'd on the command line.
		(The call to mst_is_undef will disable the #undef.)
	*/
	if (mst_is_undef(name)) {
		TRACEPN(ftag, es("#define "); es(name); es("cancelled by #undef\n"));
		tp = skip_pp(tp);
		goto done;
	}

	/* Put the formal arguments into a block that fp points to. */

	{
		token * old_tp = tp;

		tp = mac_get_formals(tp, &amp;fp, &amp;nargs);
		TRACEN(ftag, es(", nargs = "); eint(nargs); enl());

		if (nargs == -2) {
			/* An error was found.  Create no macro_def node. */
			tp = skip_pp(old_tp);
			goto done;
		}
	}

	/*
		At this point, nargs contains the number of formal arguments,
		or -1 if no argument list was given.
		0 is allowed and means that the argument list was ().

		fp[] contains pointers to the formal identifiers.
		fp[*nargs] == NULL;
		tp points past the formals.
	*/

	TRACEN(ftag,
		int i=0;
		ecnl();
		for (i = 0; nargs &gt; 0 &amp;&amp; i &lt;= nargs; i++) {
			es("fp["); eint(i); es("] = ");
			es( (fp[i] == NULL) ? "NULL" : fp[i] ); enl();
		}
	);

	ASSERT(nargs &lt;= 0 || fp[nargs] == NULL);

	/*
		Scan the replacement text:

		Delete white space around # and ## and before newlines.
		Replace sequences of white space by a single blank.
		Replace formal argument n by MACRO_ARG_TOK(n).

		The file is guaranteed to end in a newline,
		so we need not test for HIDDEN_END_FILE_TOK.
	*/

	/* Point rtext at the first non-white space token of the replacement text. */
	skip_hws_tok(tp);
	if (*tp == POUND_POUND_TOK) {
		error(es("## not valid at the start of a macro replacement text"));
		tok_ignore(tp);
		next_tok(tp);
	}
	rtext = tp;

	/*
		Make a copy of the replacement text so error messages contain
		the original spellings of macro arguments.

		Save the pointer to the original rtext for skip_pp().
	*/
	{
		token * junk = NULL;

		old_tp = tp;
		tp = tok_copy2nl(rtext, &amp;junk, "rtext");
		rtext = tp;
		tok_copy(WS_NL_TOK, NULL);
	}

	while (*tp != WS_NL_TOK) {

		/* Replace sequences of white space by a single blank. */
		if (is_ws(*tp)) {

			token * start_ws = tp;

			/* Convert the first white space token to a single blank. */
			if (tok_size(*tp) == SMALL_TOKEN_SIZE) {
				*tp = WS_TOK;
			}
			else {
				*tp = WS_BLANKS_TOK;
				patch_val_tok(tp,1);
			}

			/* Ignore all following white space tokens. */
			next_tok(tp);
			while(is_ws(*tp) &amp;&amp; *tp != WS_NL_TOK) {
				tok_ignore(tp);
				next_tok(tp);
			}

			/* Ignore white space before newlines, # and ## operators. */
			if (*tp == WS_NL_TOK || *tp == POUND_TOK || *tp == POUND_POUND_TOK) {
				tok_ignore(start_ws);
			}
		}

		/* Delete white space after # and ## operators. */
		if (*tp == POUND_TOK || *tp == POUND_POUND_TOK) {
			next_tok(tp);
			while(is_ws(*tp) &amp;&amp; *tp != WS_NL_TOK) {
				tok_ignore(tp);
				next_tok(tp);
			}
		}

		/* Replace a formal parameter by MACRO_ARG_TOK(i). */
		if (is_id(*tp)) {

			register int 	i;
			spell_node * arg_spell_p = id_tok_ptr(tp);
			register char * name = arg_spell_p -&gt; spell_name;

			/* See if it is a formal argument. */
			for (i = 0; i &lt; nargs; i++) {
				if (str_eq(name, fp[i])) {
					break;
				}
			}
			if (i != nargs &amp;&amp; nargs &gt; 0) {
				*tp = MACRO_ARG_TOK;
				patch_val_tok(tp, i);
			}
		}
		if (*tp != WS_NL_TOK) {
			next_tok(tp);
		}
	}

	/* Allocate a new node if the symbol has not been defined. */
	if (prev_mdef_p == NULL) {

		mac_def_node * 	mdef_p = NULL;
		new_file_macro(mdef_p, macro_stats);
		mdef_p -&gt; mac_rtokens	= rtext;
		mdef_p -&gt; mac_nargs		= nargs;
		mdef_p -&gt; mac_names		= fp;
		mdef_p -&gt; mac_spell		= spell_p;
		spell_p -&gt; spell_macro = mdef_p;

		lst_add_macro(mdef_p, mac_mdef_list);
	}
	else if (special_flag) {
		/* Redefine __line__, etc. */
		spell_p -&gt; spell_macro -&gt; mac_rtokens = rtext;
	}
	else {
		/* Make sure the two definitions are identical. */

		if (!mac_compare_rtexts(rtext, prev_mdef_p -&gt; mac_rtokens) ||
			!mac_compare_fargs(nargs, fp, prev_mdef_p)) {

			error(
				es("invalid non-identical redefinition of "); es(name);
				es(" ignored");

				TRACEPN(ftag,
					es("old: "); tok_dump_line(prev_mdef_p -&gt; mac_rtokens); ecnl();
					es("new: "); tok_dump_line(rtext); ecnl();
				);
			);
		}
		else {
			TRACEPN(ftag, es("duplicate #define "); es(name); ecnl());
		}
	}

	/* Skip past the original rtext, not the copy. */
	tp = skip_pp(old_tp);

done:
	TRACEPX(ftag, mst_dump_mdef(spell_p -&gt; spell_macro));
	return tp;
}
</t>
<t tx="ekr.20080529093004.418">@ Enter a command-line macro definition. If special_flag is true, we define a special macro such as __line__.
@c

void
mac_define_string(char * name, char * def, bool special_flag)
{
	FTAG("mac_define_string");
	char * p = NULL;
	io_mem_block block;
	token * tp = NULL;
	size_t length = 0;
	STATB(ftag);

	/* Create a memory block with a simulated #define. */
	ASSERT(name);

	if (def == NULL) {
		/* Do not pass a NULL string to new_perm_cat4_macro! */
		new_perm_cat4_macro(p, name, " ", " ", "\n   ");
	}
	else {
		new_perm_cat4_macro(p, name, " ", def, "\n   ");
	}

	length = strlen(p)-1;
	p [length] = IO_EOF_CHAR;
	block . mem_start = p;
	block . mem_length = length;
	block . mem_freep = NULL;

	/* Tokenize the block and use mac_define to do the work. */
	tp = tokize(&amp;block, NULL, name, END_WITH_EOF_TOK, NULL);

	/*
		The first token is HIDDEN_BEGIN_FILE_TOK.
		The next is WS_NL_TOK, which mac_define will skip.
	*/
	next_tok(tp);
	(void) mac_define(tp, special_flag);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.419">@ Inner macro expansion.  bound_tp points to the bounding token, or NULL for an unbounded scan.  Return a pointer to the first token of the expansion or NULL if the expansion was aborted because of a bound.  Point *res_last_param to the last token of the expansion. (res_last_param is used in traces in mac_outer_expand.)  Refuse to expand the macro if current recursion depth exceeds the maximum recursion depth. This protects the compiler's stack.
@c

token *
mac_expand(register token * tp, token * bound_tp, token ** res_last_param)
{
	FTAG("mac_expand");
	spell_node *	spell_p;	/* Ptr to macro's spelling node. */
	mac_def_node *	mdef_p;		/* Ptr to macro's replacement text. */
	token *			id_tp;		/* Ptr to macro's id token. */
	token **		ap_first;	/* Ptr to block of token pointers. */
	token **		ap_last;	/* Ptr to block of token pointers. */
	token **		exp_first;	/* Ptr to block of token pointers. */
	token **		exp_last;	/* Ptr to block of token pointers. */
	token *			res_first;	/* Ptr to first substituted token. */
	token *			res_bound;	/* Ptr to trailing BOUND_TOK token. */
	token *			res_last;	/* Ptr to last HIDDEN_SKIP_TOK. */
	int				nargs;		/* Number of actual arguments. */
	char *			name;		/* Namber of the macro. */
	int		expected_nargs;		/* Number of formal arguments. */
	long			hidden_nl;	/* Saved hidden newlines. */

	ASSERT(is_id(*tp) &amp;&amp; (id_tok_ptr(tp)) -&gt; spell_macro != NULL);
	ASSERT(res_last_param);
	ASSERT(bound_tp == NULL || *bound_tp == BOUND_TOK);

	if (++mac_expand_depth &gt; MAX_EXPAND_DEPTH) {

		error(es("expansion thwarted by recursion bound\n"));
		return NULL;
	}

	/* Set various quantities. */
	spell_p			= id_tok_ptr(tp);
	mdef_p			= spell_p -&gt; spell_macro;
	name			= spell_p -&gt; spell_name;
	expected_nargs	= mdef_p -&gt; mac_nargs;
	id_tp 			= tp;
	*res_last_param = NULL;
	hidden_nl = 0;

	TRACEPB(ftag,
		es("name: "); es(spell_p -&gt; spell_name);
		es(" bound: "); eptr(bound_tp); enl());

	if (is_nodef(*tp)) {

		/* Patch the special identifier into the token list. */
		mac_special(tp, spell_p);
		*res_last_param = tp;

		STATX(ftag);
		return tp;
	}

	/* Skip the identifier. */
	next_tok(tp);

	if (tp == bound_tp &amp;&amp; expected_nargs &gt;= 0) {

		TRACEPN(ftag, es("expansion thwarted by bound\n"));
		goto null_expand;
	}

	/* Parse the actual args and point ap at a block of pointers to the actuals. */
	if (expected_nargs &gt;= 0) {

		tp = mac_get_actuals(tp,
			&amp;ap_first, &amp;ap_last,
			&amp;exp_first, &amp;exp_last, &amp;nargs, bound_tp);

		/*
			Make sure the number of arguments match.
			Give no warning on bounded scan.

			If symbol s is a macro with expected_nargs &gt; -1, it is *not*
			an error to see just plain s.  For example: goto s;
		*/
		if (nargs != expected_nargs &amp;&amp; bound_tp == NULL &amp;&amp;
			expected_nargs &gt; -1 &amp;&amp; nargs &gt; -1 &amp;&amp;
			!(expected_nargs == 0 &amp;&amp; nargs == 1) /* Bug fix: 10/15/92 */
		) {
			error(
				es("macro "); es(name);
				es(" expects "); eint(expected_nargs);
				es(" argument"); es( (expected_nargs == 1) ? "" : "s");
			);
			goto null_expand;
		}
		else if (nargs != expected_nargs) {

			TRACEPN(ftag, es((bound_tp == NULL) ?
				"expansion thwarted by missing arguments\n" :
				"expansion and get_args thwarted by bound\n"));

			goto null_expand;
		}

		hidden_nl = mac_hidden_nl;
	}
	else {
		ap_first = ap_last = NULL;
		nargs = -1;
		TRACEPN(ftag, es("nargs: -1\n"));
	}

	ASSERT(nargs &lt;= 0 || (exp_first &amp;&amp; exp_last));

	if (nargs &gt; 0) {

		register int i;

		TRACEPN(ftag,
			es("actual args: \n\n");
			for (i = 0; i &lt; nargs; i++) {
				es("actual "); eint(i); es(": ");
				tok_dump_list(ap_first[i], ap_last[i]);
				ecnl();
				es("=\n");
				es("actual "); eint(i); es(": ");
				tok_dump_list2(ap_first[i], ap_last[i], DONT_PRINT_HIDDEN_TOKS);
				ecnl();
			}
			enl();
		);

		/* Fully expand each actual arg with bounded rescan. */
		for(i = 0; i &lt; nargs; i++) {
			mac_expand_arg(&amp;exp_first[i], &amp;exp_last[i]);
		}

		TRACEPN(ftag,
			es("expanded args: \n\n");
			for (i = 0; i &lt; nargs; i++) {
				es("expanded "); eint(i); es(": ");
				tok_dump_list(exp_first[i], exp_last[i]);
				ecnl();
				es("=\n");
				es("expanded "); eint(i); es(": ");
				tok_dump_list2(exp_first[i], exp_last[i], DONT_PRINT_HIDDEN_TOKS);
				ecnl();
			}
			enl();
		);
	}

	/*
		Create the final replacement text.
		Replace the macro id with a jump to the replacement text.
	*/
	{
		token * new_rtext = mac_substitute(
			spell_p,
			mdef_p -&gt; mac_rtokens,
			ap_first, ap_last,
			exp_first, exp_last,
			&amp;res_first,
			&amp;res_bound,
			&amp;res_last,
			nargs,
			tp,
			hidden_nl);

		tok_patch(id_tp, HIDDEN_SKIP_TO_MACRO_TOK,
			new_rtext, "skip to final rtext");
	}

	/* Rescan the text, looking for identifiers to disable. */
	{
		token * dump_last = NULL;

		dump_last = mac_rescan(res_first, res_bound, res_last, spell_p);
		*res_last_param = dump_last;

		TRACEPN(ftag, eret(); enl(); enl();
			tok_dump_list(id_tp, dump_last);
			ecnl();
			es("="); enl();
			tok_dump_list2(id_tp, dump_last, DONT_PRINT_HIDDEN_TOKS);
			ecnls(2));
	}

	/* Free all the storage allocated in mac_get_actuals. */
	if (nargs &gt; 0) {
		ASSERT(ap_first &amp;&amp; ap_last &amp;&amp; exp_first &amp;&amp; exp_last);
		obj_free_macro(ap_first);
		obj_free_macro(ap_last);
		obj_free_macro(exp_first);
		obj_free_macro(exp_last);
	}

	ASSERT(*id_tp == HIDDEN_SKIP_TO_MACRO_TOK);

	mac_expand_depth--;

	STATX(ftag);
	return id_tp;

null_expand:
	mac_expand_depth--;
	*res_last_param = NULL;

	STATX(ftag);
	return NULL;
}
</t>
<t tx="ekr.20080529093004.420">@ Completely expand one actual macro argument (with bounded rescan.) Change *ap_first and *ap_last to point at the expanded argument.
@c

static void
mac_expand_arg(token ** exp_first, token ** exp_last)
{
	FTAG("mac_expand_arg");
	register token * tp = NULL;
	register token * bound_tp = NULL;
	TRACEPB(ftag,
		tok_dump_list(*exp_first, *exp_last));
	ASSERT(exp_first &amp;&amp; exp_last);

	/*
		Make a copy of the actual arguments.
		Point *exp_first and *exp_last at the start and end of the new list.
		Point bound_tp at the trailing bound tok.

		This is the *only* place where bound_tp is ever set, so
		we can assert bound_tp == BOUND_TOK everywhere.
	*/
	{
		token * junk = NULL;
		*exp_first = tp = tok_copy_list(*exp_first, *exp_last, &amp;junk, "actual arg");
		*exp_last = bound_tp = tok_copy(BOUND_TOK, NULL);

		TRACEPN(ftag, tok_dump_list(*exp_first, *exp_last));
	}

	while (tp != bound_tp) {

		if (is_id(*tp)) {

			spell_node * spell_p = (spell_node *) id_tok_ptr(tp);

			if (spell_p -&gt; spell_macro != NULL) {

				token * res_last;
				token * tp_new;

				/*
					Expand the macro, and ignore res_last.
					Leave mac_disable_list unchanged: a macro name
					*may* be expanded in its own argument list!
				*/

				TRACEPN(ftag, es("recursive bounded call to mac_expand\n"));
				tp_new = mac_expand(tp, bound_tp, &amp;res_last);

				/* Check for an aborted macro call. */
				if (tp_new != NULL) {

					/*
						The macro was expanded.
						We can ignore res_last.
						Rescan the macro.
					*/

					ASSERT(tp_new == tp);
					continue;
				}
			}
		}
		next_tok(tp);
	}

	ASSERT(*exp_first &amp;&amp; *exp_last);
	TRACEPX(ftag, eret(); tok_dump_list(*exp_first, *exp_last); ecnl());
}
</t>
<t tx="ekr.20080529093004.421">@ Put pointers to actual args into actuals.  Set *nargs to the number of formals. 0 means () was seen. -1 means no ( was seen. -2 means some syntax error was encountered.
@c

static token *
mac_get_actuals(
	register token * tp,
	token *** ap_first,		/* Ptr to a block of ptrs to the arg's start. */
	token *** ap_last,		/* Ptr to a block of ptrs to the arg's end. */
	token *** exp_first,	/* Ptr to a block of ptrs to expanded arg's start. */
	token *** exp_last,		/* Ptr to a block of ptrs to expanded arg's end. */
	int * nargs,			/* Number of arguments found. */
	token * bound_tp		/* Ptr to boundary token, or NULL. */
	)
{
	FTAG("mac_get_actuals");
	token * old_tp = tp;
	ulong array_size = 0;	/* Size of arrays of pointers. */
	STATB(ftag);
	ASSERT(bound_tp == NULL || *bound_tp == BOUND_TOK);

	/* Scan the parameter list and set nargs. */
	tp = mac_parse_actuals(tp, NULL, NULL, nargs, bound_tp);

	if (*nargs &lt;= 0) {
		*ap_first = NULL;
		*ap_last = NULL;
		goto done;
	}
	tp = old_tp;

	array_size = (((*nargs)+1) * sizeof(token **));

	/*
		Allocate space for nargs pointers and one NULL pointer at the end.
		These pointer blocks are freed at the end of mac_expand.

		Warning:  do *not* try to use an "expansion" lifetime here!!
		This code is recursive: trying to free the expansion lifetime
		will not work.
	*/
	obj_new_macro(*ap_first,  array_size, "mac ap_first");
	obj_new_macro(*ap_last,   array_size, "mac ap_last");
	obj_new_macro(*exp_first, array_size, "mac exp_first");
	obj_new_macro(*exp_last,  array_size, "mac exp_last");

	ASSERT(*ap_first &amp;&amp; *ap_last &amp;&amp; *exp_first &amp;&amp; *exp_last);

	/* Rescan the parameter list, setting actuals this time. */
	{
		bool save_update = tok_update_flag;
		tok_update_flag = FALSE;
		tp = mac_parse_actuals(tp, *ap_first, *ap_last, nargs, bound_tp);
		tok_update_flag = save_update;
	}

	if (*nargs &lt;= 0) {
		fatal(es("nargs mismatch"));
	}
	else {
		memcpy(*exp_first, *ap_first, array_size);
		memcpy(*exp_last,  *ap_last,  array_size);
	}

done:
	STATX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.422">@ Put pointers to the names of the formal parameters into formals.  Set *nargs to the number of formals. 0 means () was seen. -1 means no ( was seen. -2 means some syntax error was encountered.
@c

token *
mac_get_formals(register token * tp, char *** fp, int * nargs)
{
	FTAG("mac_get_formals");
	token * old_tp = tp;
	STATB(ftag);

	/* Scan the parameter list and set nargs. */
	tp = mac_parse_formals(tp, NULL, nargs);

	if (*nargs &lt;= 0) {
		*fp = NULL;
		STATX(ftag);
		return tp;
	}
	tp = old_tp;

	/* allocate space for nargs pointers and one NULL pointer at the end. */
	new_size_macro(*fp, (((*nargs)+1) * sizeof(char **)), file_life, narg_block_stats);

	/* Rescan the parameter list, setting formals this time. */
	tp = mac_parse_formals(tp, *fp, nargs);
	if (*nargs &lt;= 0) {
		fatal(es("nargs mismatch"));
	}

	STATX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.423">@ Call mac_expand from the outer level.
@c

token *
mac_outer_expand(token * tp)
{
	FTAG("mac_outer_expand");

	TRACE("-no_outer_expand",
		if (is_id(*tp)) {
			ASSERT(tok_size(*tp) == BIG_TOKEN_SIZE);
			*tp = IDX_TOK;
			return tp;
		}
	);

	STATB(ftag);

	if (is_id(*tp)) {

		token * res_last;
		token * new_p;
		mac_disable_node the_disable_node;
		spell_node * spell_p = id_tok_ptr(tp);

		if (spell_p -&gt; spell_macro == NULL) {
			*tp = IDX_TOK;
			STATX(ftag);
			return tp;
		}

		/* The list initially contains only the one node. */
		the_disable_node . dis_spell = spell_p;
		the_disable_node . dis_next = NULL;
		mac_disable_list = &amp;the_disable_node;

		/* We are at the outer level. */
		mac_expand_depth = 0;

		new_p = mac_expand(tp, NULL, &amp;res_last);
		if (new_p == NULL) {
			/* Make sure we don't call mac_outer_expand again. */
			ASSERT(is_id(*tp));
			*tp = IDX_TOK;
		}
		else {
			tp = new_p;

			/*
				Put the trace *before* the call to tok_skip_hidden so
				we don't move past res_last!
			*/
			TRACEPN(ftag,
				es(spell_p -&gt; spell_name); eblank(); eret(); enl();
				tok_dump_list(new_p, res_last); ecnl());
		}
		ASSERT_TRACE(
			is_id(*tp) || *tp == IDX_TOK ||
			*tp == HIDDEN_SKIP_TO_MACRO_TOK ||
			*tp == LONG_TOK || *tp == STRING_TOK,
			es("is: "); es(tok_name(*tp)); es(" at: "); eptr(tp); enl());

		tp = tok_skip_hidden(tp);
	}

	STATX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.424">@ Scan over list of actual parameters and check for a missing ')'.  Set the element of ap[] to point to first token of the actual arg. Set *nargs to the number of actual args.  NULL ap_first and ap_last are valid and means that only *nargs is set. bound_tp is NULL for an unbounded scan.  8/21/92: set the global mac_hidden_nl.
@c

#define update_err_line_macro()\
if (*tp == WS_NL_TOK &amp;&amp; tok_update_flag) { err_line++; }

static token *
mac_parse_actuals(
register token * tp,
register token ** ap_first,
register token ** ap_last,
int * nargs,
token * bound_tp)
{
FTAG("mac_parse_actuals");
token * old_tp = tp;
long save_err_line = 0;
char * save_err_fname = NULL;
static token dummy_ws [2];		/* A made-up token for null arguments. */
TRACEPB(ftag,
	es("tok_update_flag: "); ebool(tok_update_flag); enl());
ASSERT(bound_tp == NULL || *bound_tp == BOUND_TOK);

/* A kludge: save the line number and file in case of error. */
save_err_line = err_line;
save_err_fname = err_fname;

/* The default is no parameters. */
if (ap_first != NULL) {
	ap_first[0] = NULL;
	ap_last[0] = NULL;
}

/* See if the next token is a '('  */
while(tp != bound_tp &amp;&amp; is_ws(*tp)) {
	update_err_line_macro();
	next_tok(tp);
}

if (*tp != LPAREN_TOK) {
	*nargs = -1;
	mac_hidden_nl = 0;
	TICKX(ftag);
	return tp;
}

/* Skip over the '(' */
next_tok(tp);

/* Test for () separately. */
while(tp != bound_tp &amp;&amp; is_ws(*tp)) {
	update_err_line_macro();
	next_tok(tp);
}

if (*tp == RPAREN_TOK) {

	/* Skip over the ')' */
	next_tok(tp);

	STATX(ftag);
	mac_hidden_nl = 0;
	*nargs = 0;
	return tp;
}

/*
	Step through the actual argument list,
	setting nargs and ap_first[] and ap_last[] if ap_first != NULL.
*/
{
	register int n = 0;
	register int paren_level = 0;
	register token * start_p = tp;
	register token * last_p = tp;
	register bool continue_flag;

	do {

		continue_flag = (tp != bound_tp);

		switch (*tp) {

		case HIDDEN_END_FILE_TOK:
		case END_PROG_TOK:

			error(es("End-of-file in macro argument"));
			goto bad_list;

		case POUND_TOK:
			error(es("# seen in macro argument"));
			goto bad_list;

		case RPAREN_TOK:

			if (paren_level == 0) {
				if (ap_first != NULL) {
					/* 9/16/92: check for null argument. */
					if (start_p == last_p &amp;&amp; *start_p == RPAREN_TOK) {

						/* Create a dummy white space argument. */
						dummy_ws[0] = WS_TOK;
						ap_first[n] = &amp;dummy_ws[0];
						ap_last [n] = &amp;dummy_ws[0];
					}
					else {
						ap_first[n] = start_p;
						ap_last [n] = last_p;
					}
					ap_first[n+1] = NULL;
					ap_last [n+1] = NULL;
				}
				*nargs = n+1;

				/* Skip over the ')' */
				next_tok(tp);

				/* Set the number of hidden newlines. */
				if (tok_update_flag) {
					mac_hidden_nl = err_line - save_err_line;
				}
				TRACEPX(ftag,
					es("mac_hidden_nl: ");
					elong(mac_hidden_nl); enl());

				return tp;
			}
			/* Skip over the ')' */
			last_p = tp;
			next_tok(tp);
			paren_level--;
			break;

		case LPAREN_TOK:

			last_p = tp;
			next_tok(tp);
			paren_level++;
			break;

		case COMMA_TOK:

			if (paren_level == 0) {
				if (ap_first != NULL) {

					/* 9/16/92: check for null argument. */
					if (start_p == last_p &amp;&amp; *start_p == COMMA_TOK) {

						/* Create a dummy white space argument. */
						dummy_ws[0] = WS_TOK;
						ap_first[n] = &amp;dummy_ws[0];
						ap_last [n] = &amp;dummy_ws[0];
					}
					else {
						ap_first[n] = start_p;
						ap_last [n] = last_p;
					}
				}
				n++;

				/* Skip the comma. */
				next_tok(tp);

				/*
					It is not clear from the ANSI standard whether
					leading white space is part of actual args.
					(A *very* fine point.)
				*/
				while(tp != bound_tp &amp;&amp; is_ws(*tp)) {
					update_err_line_macro();
					next_tok(tp);
				}
				start_p = last_p = tp;
			}
			else {
				last_p = tp;
				next_tok(tp);
			}
			break;

		case WS_NL_TOK:
			update_err_line_macro();

			/* Fall through */

		default:
			last_p = tp;
			next_tok(tp);
		}
	} while (continue_flag);
}

/* The bound has been seen. */

TRACEPX(ftag, es("aborted by bounds\n"));
*nargs = -1;
err_line = save_err_line;
err_fname = save_err_fname;
mac_hidden_nl = 0;
return old_tp;

bad_list:
*nargs = -2;
err_line = save_err_line;
err_fname = save_err_fname;
mac_hidden_nl = 0;
TICKX(ftag);
return old_tp;
}
</t>
<t tx="ekr.20080529093004.425">@ Scan over a list of formal parameters. Set the element of fp[] to point to id's spelling. Set *nargs to the number of actual args. A NULL formals is valid and means that only *nargs is set.
@c

static token *
mac_parse_formals(register token * tp, char ** fp, int * nargs)
{
	FTAG("mac_parse_formals");
	token * old_tp = tp;
	TICKB(ftag);

	/* The default is no parameters. */
	if (fp != NULL) {
		fp[0] = NULL;
	}

	/* See if the next token, with no intervening white space, is a '('  */
	if (*tp != LPAREN_TOK) {
		*nargs = -1;
		TICKX(ftag);
		return tp;
	}

	/* Skip over the '(' */
	next_tok(tp);
	skip_hws_tok(tp);

	if (*tp == RPAREN_TOK) {

		/* Skip over the ')' */
		next_tok(tp);
		*nargs = 0;
		TICKX(ftag);
		return tp;
	}

	/*
		Step through the argument list, setting nargs and fp[].
	*/
	{
		int n = 0;
		spell_node * spell_p = NULL;

		for(;;) {

			skip_hws_tok(tp);

			if (*tp == HIDDEN_END_FILE_TOK || *tp == END_PROG_TOK) {
				error(es("End-of-file in formal argument list"));
				goto bad_list;
			}

			/* RPAREN_TOK is not valid here. */

			if (!is_id(*tp)) {
				error(
					es("formal macro argument expected, ");
					es(tok_name(*tp)); es(" found");
				);
				goto bad_list;
			}

			if (fp != NULL) {
				spell_p = id_tok_ptr(tp);
				fp[n] = spell_p -&gt; spell_name;
			}
			n++;

			/* Skip the formal. */
			next_tok(tp);
			skip_hws_tok(tp);

			if (*tp == RPAREN_TOK) {

				/* Success */

				/* Skip over the ')' */
				next_tok(tp);
				*nargs = n;
				if (fp != NULL) {
					fp[n] = NULL;
				}
				TICKX(ftag);
				return tp;
			}
			else if (*tp == COMMA_TOK) {
				next_tok(tp);
			}
			else {
				error(es("comma or ')' expected in formal argument list"));
				goto bad_list;
			}
		}
	}

bad_list:
	*nargs = -2;
	TICKX(ftag);
	return old_tp;
}
</t>
<t tx="ekr.20080529093004.426">@ Paste tokens together and return a pointer to the first pasted token.  first_tp points at a the token *before* the initial ##. The new tokens end with a jump beyond the pasted tokens.  Stop at bound_tp.  Note: The ## operator can only occur in the replacement list of a macro.  In particular, ## can not occur in an actual argument of a macro.
@c

#define MAX_PASTE_SIZE 2000

token *
mac_paste_tokens(token * first_tp, token * bound_tp, token ** ap_first, token ** ap_last)
{
	FTAG("mac_paste_tokens");
	register token * tp = NULL;
	register char * buf_p = NULL;
	register int string_length = 0;
	token * result = NULL;
	static char * buffer = NULL;
	STATB(ftag);
	ASSERT(*bound_tp == BOUND_TOK);

	/*
		Allocate the pasting buffer the first time.
		This buffer is never deallocated.
	*/
	if (buffer == NULL) {
		obj_new_macro(buffer, MAX_PASTE_SIZE, "mac token paste buf");
	}

	buffer[0] = ' ';
	buf_p = buffer+1;
	string_length = 1;

	ASSERT(first_tp);
	ASSERT(*first_tp != POUND_POUND_TOK);
	tp = first_tp;

	/*
		Convert each token to a string and append it to the buffer.
		Convert unexpanded actual arguments, not expanded actual arguments.
	*/
	while(*tp != HIDDEN_END_FILE_TOK &amp;&amp; *tp != END_PROG_TOK) {

		int length = 0;

		if (*tp == MACRO_ARG_TOK) {

			long	arg = val_tok_val(tp);
			token * arg_tp = ap_first[arg];

			for(;;) {
				char * s  = tok_2string(arg_tp, &amp;length, FALSE);
				if (string_length + length + 5 &gt;= MAX_PASTE_SIZE) {
					goto too_big;
				}
				if (length &gt; 0) {
					strcpy(buf_p, s);
					buf_p += length;
					string_length += length;
				}
				if (arg_tp == ap_last[arg]) {
					next_tok(tp);
					break;
				}
				else {
					next_tok(arg_tp);
				}
			}
		}
		else if (*tp == POUND_TOK) {

			token * patch_tp = NULL;

			/* mac_define has deleted any whitespace after the #. */
			patch_tp = tp;
			next_tok(tp);

			if (*tp == MACRO_ARG_TOK) {
				long arg = val_tok_val(tp);
				char * s = NULL;

				/* Use the *unexpanded* actual argument for stringizing. */
				s = mac_stringize(ap_first[arg], ap_last[arg]);

				/* Replace the # with a STRING_TOK. */
				tok_patch(patch_tp, STRING_TOK, s, "patch in # string");

				/* Ignore the MACRO_ARG_TOK. */
				*tp = HIDDEN_BIG_IGNORE_TOK;

				/* Continue with the string tok so #a ## is handled properly. */
				tp = patch_tp;
				continue;
			}
			else {
				error(es("Formal parameter expected after #"));
				next_tok(tp);
			}
		}
		else {
			char * s = tok_2string(tp, &amp;length, FALSE);
			if (string_length + length + 5 &gt;= MAX_PASTE_SIZE) {
				goto too_big;
			}
			else if (length &gt; 0) {
				strcpy(buf_p, s);
				buf_p += length;
				string_length += length;
			}
			next_tok(tp);
		}

		/* Keep going while more ## operators exist. */
		if (*tp == POUND_POUND_TOK) {
			next_tok(tp);
		}
		else {
			break;
		}
	}

	/* Convert buffer to tokens. */
	{
		io_mem_block block;
		size_t length = strlen(buffer);

		ASSERT(length &gt; 0);

		block . mem_start = buffer+1;	/* Point past the leading blank. */
		block . mem_length = length-1;
		block . mem_freep = NULL;

		/* End the buffer with IO_EOF_CHAR. */
		buffer [length] = IO_EOF_CHAR;
		buffer [length+1] = '\0';
		block . mem_length++;

		result = tokize(&amp;block, NULL, "pasted tokens", END_WITH_SKIP_TOK, tp);
	}

	TRACEPX(ftag, eret(); tok_dump_delim(result, HIDDEN_SKIP_TOK));
	return result;

too_big:
	error( es("pasted token is too big"));
	STATX(ftag);
	return NULL;
}
</t>
<t tx="ekr.20080529093004.427">@ Rescan replacement text looking for identifiers to disable. When an identifier is found that should be disabled, convert it to an IDX_TOK.  This code has caused me a good deal of pain. Although it appears simple now, there are some very tricky points lurking here.  The ANSI Standard specifies the rescanning process precisely, if implicitly. Rescanning the replacement text properly requires that, most, but not all inner macro calls must be expanded. The details are complicated. (See the long comment below.)  Return a pointer to the last token to appear in dumps. This prevents debugging code dumping to the end of the token list when the res_bound is bypassed as the result of macro expansion.
@c

static token *
mac_rescan(
	token * res_first,
	token * res_bound,
	token * res_last,
	spell_node * spell_p)
{
	FTAG("mac_rescan");
	register token * tp = res_first;
	spell_node * spell_p2 = NULL;
	token * inner_p = NULL;
	token * inner_end_p = NULL;
	token * dump_last = res_last;
	mac_disable_node the_disable_node;
	mac_disable_node * dis_p = mac_disable_list;
	STATB(ftag);

	ASSERT(*res_first == IDX_TOK);
	ASSERT(*res_bound == BOUND_TOK);

	TRACEPN(ftag, es("before final rescan: ");
		tok_dump_list2(res_first, res_last, PRINT_HIDDEN_TOKS);
		ecnl());

	/*
		This label simplifies the loop because
		the C language lacks a multi-level continue.
	*/
rescan_loop:

	if (tp == res_bound) {
		ASSERT(*res_bound == BOUND_TOK);
		tok_ignore(res_bound);

		STATX(ftag);
		return dump_last;
	}

	if (!is_id(*tp)) {
		next_tok(tp);
		goto rescan_loop;
	}

	spell_p2 = id_tok_ptr(tp);

	if (spell_p2 -&gt; spell_macro == NULL) {
		next_tok(tp);
		goto rescan_loop;
	}

	ASSERT(spell_p2 -&gt; spell_token == *tp);

	/* Disable the id if it is the current macro id. */
	if (spell_p2 == spell_p) {
		TRACEPN(ftag, es("disabling current: "); es(spell_p -&gt; spell_name));
		*tp = IDX_TOK;
		goto rescan_loop;
	}

	/* Disable the id if it is on the disable list. */
	while(dis_p != NULL) {
		if (dis_p -&gt; dis_spell == spell_p2) {
			*tp = IDX_TOK;
			TRACEPN(ftag,
				es("disabling: ");
				es(dis_p -&gt; dis_spell -&gt; spell_name); enl());

			/* This is a "multi-level continue". */
			goto rescan_loop;
		}
		else {
			dis_p = dis_p -&gt; dis_next;
		}
	}

	/*
		Here it is: the guts of macro expansion!

		Make a recursive call to mac_expand so we can disable
		the appropriate identifiers in the inner replacement text.
		However, don't go past the *more* *restrictive* res_bound.

		We are primarily looking for id's to disable: these tokens will be
		rescanned later in an unbounded context so that macros that
		over-run the bound eventually get expanded.

		We are justified in stopping at this inner bound!
		To quote from the Rationale of the ANSI C Standard, page 67:

		"The rescanning rules incorporate an ambiguity.  Given the definitions:

			#define f(a) a*g
			#define g f

		it is clear (or at least unambiguous) that the expansion of
		f(2)(9) is 2*f(9).  The f in the result clearly was introduced
		during the expansion of the original f, so is not further expanded.

		However, given the definitions:

			#define f(a) a*g
			#define g(a) f(a)

		the expansion rules allow the result to be either 2*f(9) or 2*9*g.
		It is unclear whether the f(9) token string (resulting from the initial
		expansion of f and the examination of the rest of the source file)
		should be considered as nested within the expansion of f or not.
		The Committee intentionally left this behavior ambiguous; it saw no
		useful purposein specifying all the quirks of preprocessing for such
		questionably useful constructs."

		(End of quote.)

		This quote is one indication (among many) that The Committee really
		knew what it was doing.  Using the inner bound here allows us
		to eliminate some really nasty code that tried to figure out where
		mac_rescan should stop rescanning.

		In fact, the preprocessor ultimately produces 2*9*g.

		Indeed, mac_rescan does *not* consider f(9) to be part of the expansion,
		and so it is *not* converted to an IDX_TOK.  Later, cpp considers f(9)
		to be a valid macro call and mac_outer_expand expands it to 9*g.
	*/

	/* Add the new identifier to the disable list */
	the_disable_node . dis_spell = spell_p2;
	the_disable_node . dis_next = mac_disable_list;
	mac_disable_list = &amp;the_disable_node;

	/* Recursively call mac_expand. It may fail. */
	TRACEPN(ftag, es("recursive unbounded call to mac_expand\n"));
	inner_p = mac_expand(tp, res_bound, &amp;inner_end_p);

	/* Remove the new identifier from the disable list. */
	ASSERT(mac_disable_list);
	mac_disable_list = mac_disable_list -&gt; dis_next;

	/* Check for an aborted inner expand. */
	if (inner_end_p == NULL) {
		TRACEPN(ftag, es("inner call failed.\n"));
		ASSERT(is_id(*tp));
		next_tok(tp);

		/* Give the tracing routines a break! */
		dump_last = tp;
		goto rescan_loop;
	}
	else {
		tp = inner_p;
		next_tok(tp)
		goto rescan_loop;
	}
}
</t>
<t tx="ekr.20080529093004.428">@ Patch the value of a special macro into the token list.
@c

#define BUF_SIZE 100

static void
mac_special(token * tp, spell_node * spell_p)
{
	FTAG("mac_special");
	register char * name = spell_p -&gt; spell_name;
	char * p = NULL;
	char buf[BUF_SIZE];
	STATB(ftag);

	if (str_eq(name, "__LINE__")) {
		cvt_long(buf, BUF_SIZE, err_line+err_line_offset);
		new_file_string_macro(p, buf);
		tok_patch(tp, INT_TOK, p, "__LINE__");
	}
	else if (str_eq(name, "__FILE__")) {
		char * s =  err_file_name();
		new_file_string_macro(p, s);
		tok_patch(tp, STRING_TOK, p, "__FILE__");
	}
	else if (str_eq(name, "__TIME__")) {
		cvt_time(buf, BUF_SIZE, FALSE);
		new_file_string_macro(p, buf);
		tok_patch(tp, STRING_TOK, p, "__TIME__");
	}
	else if (str_eq(name, "__DATE__")) {
		cvt_date(buf, BUF_SIZE, FALSE);
		new_file_string_macro(p, buf);
		tok_patch(tp, STRING_TOK, p, "__DATE__");
	}
	else if (str_eq(name, "defined")) {
		/* This should never happen. */
		*tp = IDX_TOK;
	}
	else {
		fatal(es("unknown reserved macro"));
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.429">@ Stringize the tokens from tp_first to tp_last.  A new string is created in the string space, so that the caller need not worry about allocating storage.
@c

#define MAX_STRINIZE_SIZE 2000

char *
mac_stringize(token * tp_first, token * tp_last)
{
	FTAG("mac_stringize");
	register char * buf_p = NULL;
	register token * tp = NULL;
	register char * s = NULL;
	register int string_length = 0;
	char * result = NULL;
	static char * buffer = NULL;
	STATB(ftag);

	/*
		Allocate the stringize buffer the first time.
		This buffer is never deallocated.
	*/
	if (buffer == NULL) {
		obj_new_macro(buffer, MAX_STRINIZE_SIZE, "mac stringize buf");
	}

	/*
		Convert each token to a string and
		append the string to the buffer.
	*/
	buffer[0] = '\0';
	buf_p = buffer;
	string_length = 0;
	tp = tp_first;
	for(;;) {

		int length = 0;

		/*
			Convert the token to a string and stringize
			strings and character constants.
		*/
		s = tok_2string(tp, &amp;length, TRUE);

		if (string_length + length &gt;= MAX_STRINIZE_SIZE) {
			error(
				es("stringized actual argument too big: ");
				tok_dump_list(tp_first, tp_last);
			);
			result = NULL;
			goto done;
		}
		else if (length &gt; 0) {
			strcpy(buf_p, s);
			buf_p += length;
			string_length += length;
		}

		if (tp == tp_last) {
			break;
		}
		else {
			next_tok(tp);
		}
	}
	if (string_length == 0) {
		result = NULL;
		goto done;
	}

	/* Allocate space in the string space. */
	result = mem_str_copy(buffer, string_length);

done:
	STATX(ftag);
	return result;
}
</t>
<t tx="ekr.20080529093004.430">@ Convert an intial replacement text and a list of expanded and unexpanded actual arguments to a final token list. Handle # and ## arguments.  This is really part of mac_expand, which is why there are so many args.  o The expanded and unexpanded arguments are described by blocks of pointers  the start and end of each argument: exp_first, exp_last, ap_first, ap_last.  o The initial replacement text ends with WS_NL_TOK, which is *not*  included in the final token list. This preserves line numbering.  o End the final token list with a skip to tp_follow, which must point to a  valid, though possibly hidden, token.  o Replace HIDDEN_MACRO_ARG_TOK's by correct *expanded* arg. Terminate each  expanded arg by a skip to the token following the original HIDDEN_MACRO_ARG_TOK.  o Replace # HIDDEN_MACRO_ARG_TOK by a STRING_TOK formed by strinizing the  *unexpanded* macro argument.  o Replace t1 ## t2 by the token list formed by concatenating the tokens  t1 and t2. Either t1 or t2 may be HIDDEN_MACRO_ARG_TOK or # t3.  o Replace each instance if an id (either ID_TOK or reserved word tok)  by IDX_TOK to disable further macro expansion.
@c

static token *
mac_substitute(
	spell_node * spell_p,	/* Ptr to macro's spelling node. */
	token *		rtokens,	/* Ptr to macro's initial replacement text. */
	token **	ap_first,	/* Ptr to block of ptrs to start of actual args. */
	token **	ap_last,	/* Ptr to block of ptrs to end of actual args. */
	token **	exp_first,	/* Ptr to block of ptrs to start of expanded args. */
	token **	exp_last,	/* Ptr to block of ptrs to end of expanded args. */
	token **	res_first,	/* Ptr to first token of result. */
	token **	res_bound,	/* ptr to trailing BOUND_TOK of result. */
	token **	res_last,	/* Ptr to last HIDDEN_SKIP_TOK of result. */
	int			nargs,		/* Number of actual arguments. */
	token *		tp_follow,	/* Ptr to token to follow replacement text or NULL. */
	long		hidden_nl)	/* Hidden newlines in actual args. */
{
	FTAG("mac_substitute");
	token * first_p = NULL;	/* Ptr to copy of replacement text. */
	token * bound_p = NULL;	/* Ptr to bound just before the end. */
	token * end_p = NULL;	/* Ptr to end of copy. */
	bool save_update = tok_update_flag;
	TRACEPB(ftag,
		int i;
		es("macro: "); es(spell_p -&gt; spell_name);
		es(" rtext:\n"); tok_dump_line(rtokens);
		ecnl();
		es("expanded args: \n\n");
		for (i = 0; i &lt; nargs; i++) {
			es("expanded "); eint(i); es(": ");
			ASSERT(exp_first[i] &amp;&amp; exp_last[i]);
			tok_dump_list2(exp_first[i], exp_last[i], DONT_PRINT_HIDDEN_TOKS);
			ecnl();
		}
		enl();
	);

	ASSERT(tp_follow);

	/* Disable the updating of line numbers. */
	tok_update_flag = FALSE;

	/*
		Make a copy of the replacement list terminated by a skip to tp_follow.

		The leading IDX_TOK is a continuation of the HIDDEN_SKIP_TO_MACRO_TOK
		which replaces the identifier token that started the macro.
	*/
	ASSERT(is_id(spell_p -&gt; spell_token));

	first_p =	tok_copy(IDX_TOK, spell_p);
				tok_copy2nl(rtokens, &amp;end_p, "final rtext");
	bound_p =	tok_copy(BOUND_TOK, NULL);

	/* Insert line adjust *after* bound_p so it will not be skipped. */
	ASSERT(hidden_nl &gt;= 0 &amp;&amp; hidden_nl &lt; 100);
	while (hidden_nl-- &gt; 0) {
		tok_copy(HIDDEN_NL_IN_MACRO_TOK, NULL);
	}
	end_p = 	tok_copy(HIDDEN_SKIP_TOK, tp_follow);

	*res_first	= first_p;
	*res_bound	= bound_p;
	*res_last	= end_p;

	/*
		Make the individual substitutions in the copy of the replacement text.
		Actual arguments may appear more than once so make copies of each.
	*/
	{
		register token * tp = first_p;
		register token * last_tp = NULL;
		register bool continue_flag = FALSE;

		/* Skip past the copy of the macro call. */
		next_tok(tp);

		/* The copy of the replacement text does *not* have a newline. */
		do {

			continue_flag = (tp != bound_p);

			switch(*tp) {

			case HIDDEN_END_FILE_TOK:	fatal(es("end file"));
			case END_PROG_TOK:			fatal(es("end prog"));
			case BAD_TOK:				fatal(es("bad token"));

			case POUND_TOK:

			/* Stringize the following argument. */
			{
				token * patch_tp;

				/* mac_define has deleted any whitespace after the #. */
				patch_tp = tp;
				next_tok(tp);

				if (*tp == MACRO_ARG_TOK) {
					long arg = val_tok_val(tp);
					char * s = NULL;

					/* Use the *unexpanded* actual argument for stringizing. */
					s = mac_stringize(ap_first[arg], ap_last[arg]);

					/* Replace the # with a STRING_TOK. */
					tok_patch(patch_tp, STRING_TOK, s, "patch in # string");

					/* Ignore the MACRO_ARG_TOK. */
					*tp = HIDDEN_BIG_IGNORE_TOK;

					/* Continue with the string tok so #a ## is handled properly. */
					last_tp = NULL;
					tp = patch_tp;
				}
				else {
					error(es("Formal parameter expected after #"));
					last_tp = tp;
					next_tok(tp);
				}
				break;
			}

			case POUND_POUND_TOK:

			/* Token pasting operator. */
			{
				token * patch_tp = tp;
				token * result_tp;

				/*
					Concatenate a list of *unexpanded* tokens.
					The list starts with last_tp.
				*/
				ASSERT(last_tp);
				result_tp = mac_paste_tokens(last_tp, bound_p, ap_first, ap_last);

				/* Ignore the token preceding the ##. */
				ASSERT(last_tp);
				tok_ignore(last_tp);

				/* Replace the ## with a skip to the new tokens. */
				ASSERT(*patch_tp == POUND_POUND_TOK);
				tok_patch(patch_tp, HIDDEN_SKIP_TOK, result_tp, "patch in ## tokens");

				/* Continue with the new tokens so new # operators are recognized. */
				last_tp = NULL;
				tp = result_tp;
				break;
			}

			case MACRO_ARG_TOK:

				/*
					Replace MACRO_ARG_TOK(i) by HIDDEN_SKIP_TOK1.

					Copy

						exp_first[i], ... exp_last[i],
						HIDDEN_SKIP_TOK2

					 into the token space and point HIDDEN_SKIP_TOK2
					 to the token following HIDDEN_SKIP_TOK1.
				*/
			{

				long arg = val_tok_val(tp);
				token * patch_tp = tp;
				token * arg_p = NULL;
				token * junk = NULL;

				ASSERT(arg &gt;= 0 &amp;&amp; arg &lt; nargs);
				arg_p = tok_copy_list(exp_first[arg], exp_last[arg], &amp;junk, "arg");

				/* 7/5/93: Make this code independent of sizeof(token). */
				{
					token * temp_tp = patch_tp;
					bump_tp_macro(temp_tp, BIG_TOKEN_SIZE);
					tok_copy(HIDDEN_SKIP_TOK, temp_tp);
				}

				/* Continue at the newly created tokens. */
				last_tp = NULL;
				tp = arg_p;
				tok_patch(patch_tp, HIDDEN_SKIP_TOK, arg_p, "patch in macro arg");
				break;
			}

			default:
				last_tp = tp;
				next_tok(tp);
			}
		} while (continue_flag);
	}

	/* Restore the previous setting. */
	tok_update_flag = save_update;

	TRACEPX(ftag, eret(); enl(); enl();
		tok_dump_list(first_p, end_p); ecnl();
		es("=\n");
		tok_dump_list2(first_p, end_p, DONT_PRINT_HIDDEN_TOKS);
		ecnls(2));

	return first_p;
}
</t>
<t tx="ekr.20080529093004.431">/*
	CC2: command-line #define and #undef routines.

	Use 4-space tabs for best appearance.

	These routines manage lists of symbols defined or undefed on the
	command line.  They need not be fast, and they sure aren't pretty.

	Warning: Be wary of putting Sherlock macros in this file:
			 Many of the routines are called before Sherlock is initialized.

	source:  CCmst.c
	started: September 22, 1985
	version:
		June 2, 1994.
			Installed new memory allocation macros.
		May 27, 1992
			Replaced check_ptr1 with ASSERT.
		May 17, 1992
			Removed newlines from end of warning messages.
		May 12, 1992
			Made sure statements are inside warning macro.
		April 1, 1992
			Installed ASSERT_TRACE macros.
		March 19, 1992
			Added mst_dump_all and mst_dump_mdef.
		March 17, 1992
			Removed character oriented routines.
		March 6, 1992
			Installed obj_new_macro.
		March 4, 1992
			Installed new object routines.
		September 29, 1991;
		January 17, 1992;
*/

&lt;&lt; CCmst #includes &gt;&gt;
&lt;&lt; CCmst declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.432">#include "CC.h"

#include "CCmacro.h"
#include "CCmem.h"
#include "CCmst.h"
#include "CCtokens.h"

#include &lt;LIBlist.h&gt;
#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.433">/*
	Define command-line #define and #undef nodes.
*/
typedef struct d_struct d_node;
typedef struct u_struct u_node;

static struct d_struct {
	TYPE_LIST(d_node);
	char *	d_name;	/* Pointer to name. */
	char *	d_text;	/* Pointer to replacement text. */
	bool 	d_flag; /* TRUE: user-defined. */
};

static struct u_struct {
	TYPE_LIST(u_node);
	char *	u_name;	/* Name of undef. */
	bool	u_flag;	/* TRUE: undef still active. */
};

static d_node * def_list = NULL;	/* List of command-line #define's. */
static u_node * undef_list = NULL;	/* List of command-line #undef's. */

/*
	Function prototypes of local routines.
*/
static void mst_pre_define	(void);
</t>
<t tx="ekr.20080529093004.434">@ Show all macro definitions.
@c

void
mst_dump_all(void)
{
	register mac_def_node * mp;

	es("List of all macro definitions:\n");
	lst_every_macro(mp, mac_mdef_list) {
		mst_dump_mdef(mp);
	}
}
</t>
<t tx="ekr.20080529093004.435">void
mst_dump_mdef(mac_def_node * mp)
{
	es(mp -&gt; mac_spell -&gt; spell_name);
	es("("); eint(mp -&gt; mac_nargs); es(")");
	tok_dump_line2(mp -&gt; mac_rtokens,
		PRINT_HIDDEN_TOKS, SPLIT_LONG_LINES, PRINT_NON_USER_TOKENS);
	ecnl();
}
</t>
<t tx="ekr.20080529093004.436">@ Initialize the macro module. This must be done *before* command-line arguments are processed.
@c

void
mst_init(void)
{
	FTAG("mst_init");
	SL_DISABLE();

	/* Clear the command-line lists." */
	def_list = NULL;
	undef_list = NULL;

	/* Enter the pre-defined macros. */
	mst_pre_define();
}
</t>
<t tx="ekr.20080529093004.437">@ Enter all previous command-line #defines and #undefs into the table.
@c

void
mst_init_again(void)
{
	FTAG("mst_init_again");
	u_node * up = NULL;
	d_node * dp = NULL;
	STATB(ftag);

	lst_every_macro(dp, def_list) {
		mac_define_string(dp -&gt; d_name, dp -&gt; d_text, TRUE);
	}

	/* Make all #undef's active. */
	lst_every_macro(up, undef_list) {
		up -&gt; u_flag = TRUE;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.438">@ Add an argument to the define list. Cancel any previous defines or undefs. user_flag is TRUE if the define comes from the command line.
@c

void
mst_init_define(char * arg, char * def, bool user_flag)
{
	FTAG("mst_init_define");
	d_node * dp;
	u_node * up;
	SL_DISABLE();

	if (str_eq(arg, "defined")) {
		warning(es("Can not re-define "); es(arg));
		return;
	}

	/* Remove any previous #undef. */
	lst_every_macro(up, undef_list) {
		if (str_eq(arg, up -&gt; u_name)) {
			warning(es("Cancelling previous #undef "); es(arg));
			lst_remove_macro(up, undef_list, u_node);
			return;
		}
	}

	/* Remove any previous #define. */
	lst_every_macro(dp, def_list) {
		if (str_eq(arg, dp -&gt; d_name)) {
			if (user_flag &amp;&amp; dp -&gt; d_flag) {
				warning(es("Cancelling previous #define "); es(arg));
			}
			dp -&gt; d_text = def;
			dp -&gt; d_flag = user_flag;
			return;
		}
	}

	/* Add the definition to the define list. */
	new_perm_macro(dp, perm_macro_stats);
	lst_add_macro(dp, def_list);
	dp -&gt; d_name  = arg;
	dp -&gt; d_text  = def;
	dp -&gt; d_flag  = user_flag;

	mac_define_string(arg, def, TRUE);
}
</t>
<t tx="ekr.20080529093004.439">@ Add an argument to the undef list.
@c

void
mst_init_undef(char * arg)
{
	FTAG("mst_init_undef");
	d_node * dp = NULL;
	u_node * up = NULL;

	ASSERT(arg != NULL);
	TRACEP(ftag, elp(); es(arg); erpnl());

	if (str_eq(arg, "defined")) {
		warning(es("Can not undefine "); es(arg));
	}

	/* Disable any previous command-line definition. */
	lst_every_macro(dp, def_list) {
		if (str_eq(arg, dp -&gt; d_name)) {
			#if 0
				warning(es("#undef of previous #define "); es(arg));
			#endif
			lst_remove_macro(dp, def_list, d_node);
		}
	}

	/* Warn if an undef is already in effect. */
	lst_every_macro(up, undef_list) {
		if (str_eq(arg, up -&gt; u_name)) {
			if (up -&gt; u_flag == TRUE) {
				#if 0
				warning(
						enl();
						es("previous #undef "); es(arg);
						es(" still in effect");
					);
				#endif
			}
			else {
				up -&gt; u_flag = TRUE;
			}
			return;
		}
	}

	new_perm_macro(up, perm_macro_stats);
	lst_add_macro(up, undef_list);
	up -&gt; u_name = arg;
	up -&gt; u_flag = TRUE;
}
</t>
<t tx="ekr.20080529093004.440">@ Return TRUE if the name is on the initial undef list. Also mark the #undef as having been seen.
@c

bool
mst_is_undef(char * name)
{
	FTAG("mst_is_undef");
	u_node * up = NULL;

	lst_every_macro(up, undef_list) {
		if (up -&gt; u_flag == TRUE &amp;&amp; str_eq(name, up -&gt; u_name)) {
			up -&gt; u_flag = FALSE;
			return TRUE;
		}
	}
	return FALSE;
}
</t>
<t tx="ekr.20080529093004.441">@ Enter the predefined macros into the table. According to the ANSI Standard, these may not be re-#define'd or #undef'd.  Note: only the upper case spellings are special. __date__ is a plain id.
@c

static void
mst_pre_define(void)
{
	SL_DISABLE();

	/* mst_special() will update these as required. */
	mst_init_define("__DATE__", "__DATE__", FALSE);
	mst_init_define("__FILE__", "__FILE__", FALSE);
	mst_init_define("__LINE__", "__LINE__", FALSE);
	mst_init_define("__STDC__", "1", FALSE);
	mst_init_define("__TIME__", "__TIME__", FALSE);
}
</t>
<t tx="ekr.20080529093004.442">@ Dump the defined and undef lists.
@c

void
mst_show(void)
{
	d_node * dp;
	u_node * up;

	SL_DISABLE();

	es("defined list:\n");
	lst_every_macro(dp, def_list) {
		es("name: "); es(dp -&gt; d_name);
		es(" rtext: "); es(dp -&gt; d_text);
		es(" user: "); ebool(dp -&gt; d_flag);
		enl();
	}

	es("undef list:\n");
	lst_every_macro(up, undef_list) {
		es("name: "); es(up -&gt; u_name);
		es(" flag: "); ebool(up -&gt; u_flag);
		enl();
	}
}
</t>
<t tx="ekr.20080529093004.443">/*	CC2: First character compression pass.

	Handles the first two translations phases of the ANSI standard:

	ANSI Translation Phase 1:
	? Replace end-of-line characters by new-line characters.
	? Replace trigraph sequences by internal characters.

	ANSI Translation Phase 2:
	? Eliminate backslash newline combinations.
	? Make sure a non-empty file ends in a (real) newline and IO_EOF_CHAR.

	The compress function does both phases in a single pass.
	Some care is needed since the ??/ trigraph produces a back slash.

	Warning: ??' is a trigraph, so '????' is not a character constant!

	source:  CCpass12.c
	started: September 21, 1991
	version:
		July 28, 1993.
			Remove the dependency on the value of ENV_PHYS_NL.
			That is, allow either '\n' or '\r' to delimit lines on the Mac.
		May 23, 1993.
			Replace backslash-newlines by newlines at the *next* real newline.
		May 6, 1992
			Recognize trigraphs only if arg_trigraph_flag is TRUE.
		March 17, 1992
			Added FTAG logic.
		October 31, 1991

	Compress1 processes arg.c (about 18,000 characters) as follows:

	Statistics:

	IIci:  35/27 msec. (with/without statistics)
	SE/30:

	Rewriting the C code in "assembly style," as the code is now,
	decreased the time significantly
*/

#undef NO_DEBUG		/* #defined: suppress debugging code. */
#undef NO_STATS		/* #defined: Compile in statistics. */

&lt;&lt; CCpass12 #includes &gt;&gt;
&lt;&lt; CCpass12 declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.444">#include "CC.h"

#include "CCarg.h"
#include "CCpass12.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBio.h&gt;
</t>
<t tx="ekr.20080529093004.445">/*
	Function prototypes.
*/
static bool check_compress1 (char * p);
</t>
<t tx="ekr.20080529093004.446">@ Define macros used in compress.  These macros form the heart of the alterations done on the input file.
@c

#define get(c)\
STATS(icount++;) c = *ibuf++

#define put(c, stat)\
STATS(ocount++; stat++;) *obuf++ = c

#define put_trigraph(c)\
STATS(ocount++; trigraphs++;) *obuf++ = c; input_block -&gt; mem_length -= 2

#define ignore_trigraph()\
STATS(trigraphs++; backslash_newlines++;) input_block -&gt; mem_length -= 4

#define ignore_backslash_newline()\
{\
held_newlines++; obuf--; input_block -&gt; mem_length -= 2;\
STATS(ocount--; backslash_newlines++;)\
}

/*
Check the result of compress().
*/
static bool
check_compress1(char * p)
{
FTAG("check_compress1");
long count = 0;
long newlines = 0;

SL_DISABLE();

while (*p != IO_EOF_CHAR) {
	count++;
	if (*p == '\n') {
		count = 0;
		newlines++;
	}
	else if (*p == '\r') {
		fatal(
			ecnl(); es(ftag); es(": ");
			es("\\r seen: line: "); elong(newlines);
			es(" position: "); elong(count); enl();
		);
		return FALSE;
	}
	p++;
}
if (*(p-1) != '\n') {
	fatal(
		ecnl(); es(ftag); es(": ");
		es("unexpected IO_EOF_CHAR: line: "); elong(newlines);
		es(" position: "); elong(count); enl();
	);
	return FALSE;
}
return TRUE;
}
</t>
<t tx="ekr.20080529093004.447">@ Eliminate trigraphs and backslash-newlines from the input block. The input buffer must already end with PHYS_NL followed by IO_EOF_CHAR.  On exit: o Guarantee a newline followed by a IO_EOF_CHAR at the end of the output buffer. o Set input_block -&gt; mem_length to length of output buffer.  The main loop should be as fast as possible.  The same buffer is used for both input and output. This works because the output buffer pointer is always strictly behind the input buffer pointer.
@c

void
compress (io_mem_block * input_block)
{
	FTAG("compress");
	register char * ibuf = NULL;
	register char * obuf = NULL;
	register char c = ' ';
	int held_newlines = 0;

#ifndef PRODUCTION
	long junk = 0;
	long backslash_newlines = 0;
	long carriage_returns = 0;
	long eofs = 0;
	long icount = 0;
	long input_length = input_block -&gt; mem_length;
	long ocount = 0;
	long regular_chars = 0;
	long trigraphs = 0;
#endif

	STATB(ftag);

	ibuf = obuf = input_block -&gt; mem_start;

loop:
	get(c);
	#if defined(THINK_C) || defined(applec)
		if (c == '\n' || c == '\r') {
			/* Treat *either* as a newline. */
			goto do_nl;
		}
	#else
		if (c == '\n') {
			goto do_nl;
		}
		else if (c == '\r') {
			/* Ignore the '\r' */
			goto loop;
		}
	#endif
	else if (c == '?' &amp;&amp; arg_trigraph_flag) {
		goto try_trigraphs;
	}
	else {
		put(c, regular_chars);
		goto loop;
	}

do_nl:
	if (*(ibuf - 2) == '\\') {
		ignore_backslash_newline();
		if (*ibuf == IO_EOF_CHAR) goto done; else goto loop;
	}

	/*
		5/23/93: Output held-over newlines from backslash-newlines.
		This keeps physical and logical newlines in synch.
	*/
	while(held_newlines &gt; 0) {
		put('\n', junk);
		held_newlines--;
	}

	if (*ibuf == IO_EOF_CHAR) {
		goto done;
	}
	else {
		put('\n', carriage_returns);
		goto loop;
	}

try_trigraphs:
	if (*ibuf != '?') {
		put('?', regular_chars);
		goto loop;
	}

	if (*(ibuf+1) == IO_EOF_CHAR) {
		ecnl(); es("File ends in start of trigraph!"); enl();
		end_done();
	}

	get(c); get(c); /* Skip both question marks. */

	switch(c) {

	case '=':  put_trigraph('#'); goto loop;
	case '(':  put_trigraph('['); goto loop;
	case ')':  put_trigraph(']'); goto loop;
	case '\'': put_trigraph('^'); goto loop;
	case '&lt;':  put_trigraph('{'); goto loop;
	case '!':  put_trigraph('|'); goto loop;
	case '&gt;':  put_trigraph('}'); goto loop;
	case '-':  put_trigraph('~'); goto loop;

	case '/':

		if (c == '\n' || c == '\r') {
			get(c); ignore_trigraph();
		}
		else {
			put_trigraph('\\');
		}
		goto loop;

	default:
		/* Not a trigraph sequence.  Back up. */
		put('?', regular_chars);
		ibuf -= 2;
		goto loop;
	}

done:
	put('\n', carriage_returns);
	put(IO_EOF_CHAR, eofs);

	TICKX(ftag);

	STATS(TRACEP("-compress1_stats",
		ecnl();
		es("input length:          "); elong(input_length); enl();
		es("output count:          "); elong(ocount); enl();
		es("correct output length: ");
		elong(input_length - (2 * trigraphs) - (2 * backslash_newlines) + eofs); enl();

		enl();
		es("regular chars:      "); elong(regular_chars); enl();
		es("trigraphs:          "); elong(trigraphs); enl();
		es("backslash-newlines: "); elong(backslash_newlines); enl();
		es("carriage_returns:   "); elong(carriage_returns); enl();
		enl()));

	TRACEP("-compress1_check", check_compress1(input_block -&gt; mem_start));

	TRACEP("-compress1_dump",
		{
			char * p = &amp;(input_block -&gt; mem_start [0]);

			enl(); es("Output is...\n");
			while (*p != IO_EOF_CHAR) {
				echar(*p);
				p++;
			}
		}
	);
}
</t>
<t tx="ekr.20080529093004.448">/*
	CC2: Definitions of constants describing the environment of the target machine.

	Source:  CCtarget.c
	Started: November 13, 1994.
	Version: January 2, 1995.
*/

&lt;&lt; CCtarget #includes &gt;&gt;

/*
	The following should never change.
*/
short CHAR_SIZE		= 1;
short REGISTER_SIZE	= 4;	/* The size of a "complete" register. */
short POINTER_SIZE	= 4;

/*
	relop_size is the apparent size of the "boolean" value resulting from
	a relational operator.
	
	The ASSERT in c_push may fail if RELOP_SIZE is 1.
	However, that ASSERT could be eliminated if we really want RELOP_SIZE == 1
	In general, we want booleans to be 2 bytes so they can be pushed naturally.

	Using a size of 1 increases the number of casts in the parse tree,
	and eliminates extra casts in cases such as:

		char c;
		c = v1 &lt; v2;
*/
short RELOP_SIZE = 2;	/* The minimum size of a relational operator. */

/*
	Section 3.2.1.1

	"A char, a short int, or an int bit-field, or their signed or unsigned varieties,
	or an enumeration type, may be used in an expression wherever an int or unsigned int
	may be used.
	If an int can represent all values of the original type, the value is converted
	to an int; otherwise, it is converted to unsigned int.
	These are the integral promotions."

	"Apparently, both chars and shorts must be promoted to int,
	even though short would suffice."

	EKR: According to the "as if" rule, it may be possible to avoid extra promotions.
	The following constant determines whether a shortcut is possible.

	There is a very long discussion of promotion in the Rationale, section 3.2.1.1.
*/
short PROMOTE_SIZE	= 4;	/* The size of a promoted char or short. */

/*
	Define the sizes of primitive types, as defined by the target compiler.

	These *must* match the sizes used in the target for the code to make sense.
*/
short SHORT_SIZE	= 2;
short INT_SIZE		= 4;
short LONG_SIZE		= 4;

short FLOAT_SIZE		=  4;
short DOUBLE_SIZE		=  8;
short LONG_DOUBLE_SIZE	=  8;	/* 12 Requires MPW Asm -mc68881 option to be effect. */

/*
	Maximum values of ints and unsigned ints.
*/
ulong INT_MAX	= 32767;
ulong UINT_MAX	= 65535;
</t>
<t tx="ekr.20080529093004.449">#include "CC.h"
#include "CCtarget.h"
</t>
<t tx="ekr.20080529093004.450">/*
	CC2: Token space routines.

	source: CCtokens.c
	started: September 25, 1991
	version:
		December 28, 1994
			Bug fix to tok_copy_list: check for end of list before calling tok_raw_next.
		August 25, 1994.
			Bug fix to tok_concatenate: use new_size_macro to allocate string space. 
		June 11, 1994.
			Removed paren_flag from all tok_dump routines.
			Made () [] and {} small tokens.
		June 10, 1994.
			Bug fix to the ERROR_CHAR_TOK case of tok_2string.
		June 8, 1994.
			Removed all attribute bits and associated code.
			Added all information from CCops.h.
		June 6, 1994.
			Bug fix to tok_scan_line.
			Make a *copy* of the previous file name.
		November 2, 1993.
			Added tok_concatenate.
		July16, 1993.
			Replaced STATX(ftag) by goto done in tok_skip_hidden.
		July 4, 1993.
			Replaced tp += n by bump_tp_macro(tp,n);
		May 1, 1993.
			Bug fix to tok_2string: WS_NL_TOK converted to blank.
			(This can only show up when stringizing an argument, e.g., in ASSERT.
		April 16, 1993.
			Added tok_file_level.
		March 8, 1993.
			Set par_line_ptr in tok_par_next.
		February 25, 1993.
			Bug fix to tok_par_next.
		February 22, 1993.
			Added several new ranges.
			Changed expr_prec to reflect the new order of operators.
		February 16, 1993.
			Added pp_only range.  This greatly speeds tok_par_next.
		November 5, 1992.
			Put all operand tokens in a range.  This makes switches faster.
		September 19, 1992.
			Fixed bug in tok_par_next.
		September 16, 1992.
			Made tok_copy_list more robust.
		August 30, 1992.
			Added tok_par_next.
		August 21, 1992.
			Added HIDDEN_NL_IN_MACRO_TOK.
		August 17, 1992.
			Added KP_TAG, deleted KP_xxx_TAG.
		August 14, 1992.
			Added KP_BLOCK.
		August 11, 1992
			Added KP_ENUM_ELEM, KP_ENUM_TAG.
			Added KP_STRUCT_TAG, KP_UNION_TAG.
		August 3, 1992
			Added optional 'pascal' keyword.
		July 27, 1992
			Added parser token definition macro.
		July 5, 1992
			Added EXPRESSION_TOK to denote expression parse nodes.
		July 3, 1992
			Fixed bug in tracing for tok_copy2nl.
		June 24, 1992
			Added CONS_TOK.
			Changed LABEL_TOK to ULABEL_TOK.
			Made -- and ++ unary ops.
			Made ARRAY_TOK an abelian operator.
		June 3, 1992
			Added str_copy2perm routine.
		May 29, 1992
			Most global variables now defined in cpp.c.
			However, tok_update flag is still owned by tokens.c.
		May 28, 1992
			Removed string_t.
			Removed sreserve_macro, scopy_macro and sbig_copy_macro.
			Added str_copy routine.
			Added global string and token varibles.
			Added global statistics.
		May 27, 1992
			Changed tok_scan_line so it scans HIDDEN_BIG_SKIP_TOK properly.
		May 26, 1992
			K_BOOL removed.
		May 19, 1992
			Added checks for NULL file name in HIDDEN_FILE_INFO_TOK.
			Added support for err_line_offset.
		May 12, 1992
			Add support for preprocessor reserved macros to tok_2string.
		May 6, 1992
			Added ERROR_MESSAGE_TOK.
			Added PARTIAL_ tokens for error messages.
		May 4, 1992
			Made bound tok visible.
			tok_copy_list and tok_copy2nl do not copy bound toks.
		May 3, 1992
			Added HIDDEN_SKIP_TO_MACRO_TOK.
			Added HIDDEN_SKIP_DIRECTIVE_TOK.
			Added END_PROG_TOK.
			Removed HIDDEN_BEGIN_MACRO_TOK.
			Removed HIDDEN_END_MACRO_TOK.
		April 28, 1992
			Added tok_ignore routine.
		April 24, 1992
			Added HIDDEN_BIG_IGNORE_TOK and HIDDEN_SMALL_IGNORE_TOK.
		April 22, 1992
			Created token ranges for whitespace and hidden tokens.
		April 18, 1992
			Added HIDDEN_NL_IN_COMMENT_TOK.
		April 16, 1992
			Replaced WS_NEWLINES_TOK with HIDDEN_LINE_ADJUST_TOK.
			Replaced is_jump by is_hidden.
			Replaced jump_bits by hidden_bits.
		April 12, 1992
			Added HIDDEN_FILE_INFO_TOK to handle the #line directive.
		April 8, 1992
			Added inner file scan to tok_scan_line.
			tok_dump_line and tok_dump_line2 now print a trailing newline.
		April 7, 1992
			Added tok_first_token.
			Added tok_scan_file and tok_scan_line routines.
			All token dumping and scanning routines now
				return a pointer to the next token.
		April 2, 1992
			Added HIDDEN_BIG_SKIP_TOK.
		April 1, 1992
			Installed ASSERT_TRACE macros.
		March 30, 1992
			Changed skip_invisibles and tok_next_raw so that
			HIDDEN_BEGIN_MACRO_TOK takes a pointer to a spelling node.
			Simplified token attribute macros.
		March 29, 1992
			Bug fix to tok_dump_list2.
			Added POUND_POUND_TOK.
		March 19, 1992
			Changed tok_dump_line.  Added tok_dump_line2.
		March 17, 1992
			Added FTAG logic.
		February 26, 1992
			Support for HIDDEN_SKIP_TOK added.
		February 19, 1992
			Support for HIDDEN_END_FILE_TOK and HIDDEN_END_MACRO_TOK added.
		February 15, 1992
			sym_init_flag eliminated. (tokize.c initializes)
		February 9, 1992
			Global string space and symbol table variables defined here.
		January 29, 1992
			added tp argument to next_tok().
			( ) { } [ ] tokens made big_ops.
			added code to tok_dump1 to print the new ( ) { } [ ] tokens.
		January 28, 1992
			added pp reserved words:
			if, else
			define, elif, endif, error, ifdef, ifndef, include, line, pragma, undef
		October 31, 1991
*/

&lt;&lt; CCtokens #includes &gt;&gt;
&lt;&lt; CCtokens declarations &gt;&gt;
@others
 /* end tok_2string */
</t>
<t tx="ekr.20080529093004.451">#include "CC.h"
#include "CCarg.h"
#include "CCtokens.h"

#include "CCcpp.h"
#include "CCdump.h"
#include "CCmem.h"
#include "CCparser.h"

#include &lt;LIBend.h&gt;

#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.452">/*
	Globals owned by tokens.c.
*/
bool tok_update_flag = TRUE;	/* TRUE: update line numbers in next_tok, etc. */
int  tok_file_level = 0;	/* 1: main file, &gt;1 header file. */

/*
	Token Definition Macros.

	Define types of quantities used in tok_info array.
*/
#define big		BIG_TOKEN_SIZE
#define small	SMALL_TOKEN_SIZE

		/* Non tokens: info not used. */

#define ea(a,b)		{ 0, b, a }	/* Address modes. */
#define parser(a,b)	{ 0, a, b }	/* Parser token. */
#define range(a,b)	{ 0, a, b }	/* Start or end of a token range. */
#define reg(a,b)	{ 0, a, b }	/* Register. */
#define x(a,b)		{ 0, b, a }	/* Machine instructions. */
#define o(a,b)		{ 0, b, a }	/* Pseudo instructions. */
#define t(a,b)		{ 0, a, b } /* Type codes for nodes defined in CCnodes.h. */

		/* Implicit size. */

#define bad(a,b)		{ small, a, b }
#define hidden(a,b)		{ big, a, b }
#define id(a,b)			{ big, a, b }

#define kdecl(a,b)		{ big, a, b }
#define kcontrol(a,b)	{ big, a, b }
#define key(a,b)		{ big, a, b }
#define madeup_key(a,b)	{ big, a, b }

#define ppkcontrol(a,b)	{ big, a, b }
#define pp_key(a,b)		{ big, a, b }
#define pp_keymac(a,b)	{ big, a, b }

#define op(a,b)			{ small, a, b }
#define ternop(a,b)		{ small, a, b }
#define binop(a,b)		{ small, a, b }
#define assnop(a,b)		{ small, a, b }
#define abelian(a,b)	{ small, a, b }
#define relop(a,b)		{ small, a, b }
#define unop(a,b)		{ small, a, b }

	/* The following must have an explicit size. */

#define hidden_ws(s,a,b)	{ s, a, b }
#define other(s,a,b)		{ s, a, b }
#define ws(s,a,b)			{ s, a, b }

	/*
		The size and hidden attributes of each token.

		These array are filled in during initialization
		so that the next_token macro doesn't have to do
		masking and shifting.
	*/

char tok_size_array   [BAD_LAST_TOK + 1];

	/* Describe the attributes of each token. */

struct tok_info_struct tok_info [] = {

	bad ( "&lt;bad token&gt;", BAD_TOK),

		/* ----- Non Tokens (zero size) ----- */

	/* WARNING: the code assumes that R_FIRST_REG is one! */

		/* Address regs. */

		/* R_FIRST_REG must be R_A0 */
	reg ("a0", R_A0),
	reg ("a1", R_A1),
	reg ("a2", R_A2),
	reg ("a3", R_A3),
	reg ("a4", R_A4),
	reg ("a5", R_A5),
	reg ("a6", R_A6),
	reg ("a7", R_A7),

		/* Data regs. */

	reg ("d0", R_D0),
	reg ("d1", R_D1),
	reg ("d2", R_D2),
	reg ("d3", R_D3),
	reg ("d4", R_D4),
	reg ("d5", R_D5),
	reg ("d6", R_D6),
	reg ("d7", R_D7),
		/* R_LAST_REG must be R_D7 */

		/* General regs. */

	reg ("ccr", R_CCR),
	reg ("sr",  R_SR),
	reg ("usr", R_USP),

	/* ----- Node types and other type fields. ----- */

		/*
			Kinds of constant anodes.

			ADDRESS_CKIND is not used when assembly output is generated.
			LABEL_CKIND is not used when the project-oriented linker is used.
		*/

	t ( "&lt;no ckind&gt;",			NO_CKIND),
	t ( "&lt;block ckind&gt;",		BLOCK_CKIND),		/* A label of an initializer block. */
	t ( "&lt;double ckind&gt;",		DOUBLE_CKIND),		/* A double constant. */
	t ( "&lt;float ckind&gt;",		FLOAT_CKIND),		/* A float constant. */
	t ( "&lt;long ckind&gt;",			LONG_CKIND),		/* An int, long or char constant. */
	t ( "&lt;long double ckind&gt;",	LONG_DOUBLE_CKIND),	/* A long double constant. */
	t ( "&lt;string ckind&gt;",		STRING_CKIND),		/* A string constant. */
	t ( "&lt;stringref ckind&gt;",	STRING_REF_CKIND),	/* A reference to a string constant used by initializers. */

		/*
			Kinds of var anodes.

			Only ADDRESS_VKIND will be used in the project-oriented version.
			When assembly output is created, ADDRESS_VKIND is used only as the result of
			address-specific constructions such as...

				typedef void (*ptr2voidfunc) (void);
				((ptr2voidfunc) 0x100) ();		(Call a function whose address 0x100.)
					or
				* ((char *) 0x100) = 5;			(Set byte at 0x100 to 5.)

			LIBNAME_VKIND is distinct from NAME_VKIND so that the output routines
			can add an implementation-defined prefex to the names of compiler functions.
		*/

	t ( "&lt;address vkind&gt;",	ADDRESS_VKIND),	/* A constant address of a function or object. */
	t ( "&lt;lib name vkind&gt;",	LIBNAME_VKIND),	/* The name of a compiler library function. */
	t ( "&lt;name vkind&gt;",		NAME_VKIND),	/* The name of statically allocated object. */
	t ( "&lt;xname vkind&gt;",	XNAME_VKIND),	/* The name of externally visible statically allocated object. */

		/* Kinds of inodes. */

	t ( "&lt;auto itype&gt;",		AUTO_ITYPE),	/* A label of the initial data area for big auto initializers. */
	t ( "&lt;brace itype&gt;",	BRACE_ITYPE),	/* A list of inodes, enclosed in braces. */
	t ( "&lt;expr itype&gt;",		EXPR_ITYPE),	/* An expression. */

		/* Kinds of tnodes. */

	t ( "&lt;no type&gt;",		NULL_TYPE),		/* No type. */
	t ( "&lt;array type&gt;",		ARRAY_TYPE),	/* Array of... */
	t ( "&lt;cast type&gt;",		CAST_TYPE),		/* "in cast" flag. */
	t ( "&lt;dots3 type&gt;",		DOTS3_TYPE),	/* Represents ... in function prototypes. */
	t ( "&lt;int type&gt;",		INT_TYPE),		/* char, short, int, or long. */
	t ( "&lt;float type&gt;",		FLOAT_TYPE),	/* float, double, or long double. */
	t ( "&lt;function type&gt;",	FUNCTION_TYPE),	/* Function returning... */
	t ( "&lt;label type&gt;",		LABEL_TYPE),	/* An internal label. */
	t ( "&lt;pointer type&gt;",	POINTER_TYPE),	/* Pointer to... */
	t ( "&lt;struct type&gt;",	STRUCT_TYPE),	/* A structure object. */
	t ( "&lt;union type&gt;",		UNION_TYPE),	/* A union object. */
	t ( "&lt;void type&gt;",		VOID_TYPE),		/* Represents (void) in function prototypes. */
	t ( "&lt;bad last type&gt;",	BAD_LAST_TYPE),	/* Not a valid type. */

		/* Scopes. */

	t ( "&lt;null scope&gt;",				NULL_SCOPE),
	t ( "&lt;block scope&gt;",			BLOCK_SCOPE),
	t ( "&lt;cast scope&gt;",				CAST_SCOPE),
	t ( "&lt;file scope&gt;",				FILE_SCOPE),
	t ( "&lt;function scope&gt;",			FUNCTION_SCOPE),
	t ( "&lt;new formal scope&gt;",		NEW_FORMAL_SCOPE),
	t ( "&lt;old formal scope&gt;",		OLD_FORMAL_SCOPE),		/* Old-style definitions, part 1. */
	t ( "&lt;old formal def scope&gt;",	OLD_FORMAL_DEF_SCOPE),	/* Old-style definitions, part 2, */
	t ( "&lt;struct scope&gt;",			STRUCT_SCOPE),
	t ( "&lt;union scope&gt;",			UNION_SCOPE),
	t ( "&lt;bad last scope&gt;",			BAD_LAST_SCOPE),

		/* Name spaces in the symbol table. */

	t ( "&lt;field name space&gt;",	FIELD_NSPACE),	/* Struct/union/enum fields. */
	t ( "&lt;object name space&gt;",	OBJECT_NSPACE),	/* Variables, functions, typedefs. */
	t ( "&lt;tag name space&gt;",		TAG_NSPACE),	/* Struct/union/enum tags. */

	/*
		The IMMEDIATE_EA, DIRECT_EA and PC_INDEX_EA modes have 2 or
		more variations, depending on the length of a constant.
		The opcodes with explicit length information are never generated
		by the code generators, and are used only by the internal assembler.

		Besides indicating address modes, the address modes form the valid
		values of the n_type field of anodes.
		The indented address modes are invalid in the n_type field.

		Note the distinction between these address modes and the
		*patterns* of address modes used in the existence tables.

		Modes ending in EA20 are for the 68020 and above.
		Modes ending in EA30 are for the 68030 and above.
	*/
	range("&lt;begin ea range&gt;", EA_RANGE_BEGIN),

		ea(	ABSOLUTE_EA,				"&lt;absolute&gt;"			),
		ea(		ABS16_EA,				"&lt;abs16&gt;"				),
		ea(		ABS32_EA,				"&lt;abs32&gt;"				),
		ea(  ADDRESS_EA,				"&lt;absolute address&gt;"	),
		ea(	AREG_EA,					"&lt;areg&gt;"				),
		ea(	DISPLACEMENT_EA,			"&lt;displacement&gt;"		),
		ea(	DREG_EA,					"&lt;dreg&gt;"				),
		ea(	IMMEDIATE_EA,				"&lt;immediate&gt;"			),
		ea(		IMM8_EA,				"&lt;imm8&gt;"				),
		ea(		IMM16_EA,				"&lt;imm16&gt;"				),
		ea(		IMM32_EA,				"&lt;imm32&gt;"				),
		ea(	INDIRECT_EA,				"&lt;indirect&gt;"			),
		ea(		IND16_EA20,				"&lt;ind16_20&gt;"			),
		ea(	INDEX_EA,					"&lt;index&gt;"				),
		ea(		INDEX16_EA,				"&lt;index16&gt;"				),
		ea(		INDEX32_EA,				"&lt;index32&gt;"				),
		ea(		INDEX16_EA20,			"&lt;index16_20&gt;"			),
		ea(		INDEX32_EA20,			"&lt;index32_20&gt;"			),
		ea(	PC_DISP_EA,					"&lt;pc_disp&gt;"				),
		ea(	PC_INDEX_EA,				"&lt;pc_index&gt;"			),
		ea(		PC_INDEX16_EA,			"&lt;pc_index16&gt;"			),
		ea(		PC_INDEX32_EA,			"&lt;pc_index32&gt;"			),
		ea(		PC_INDEX16_EA20,		"&lt;pc_index16_20&gt;"		),
		ea(		PC_INDEX32_EA20,		"&lt;pc_index32_20&gt;"		),
		ea(	PC_POST_INDEX_EA20,			"&lt;pc_post_index_20&gt;"	),
		ea(		PC_POST_INDEX16_EA20,	"&lt;pc_post_index16_20&gt;"	),
		ea(		PC_POST_INDEX32_EA20,	"&lt;pc_post_index32_20&gt;"	),
		ea(	PC_PRE_INDEX_EA20,			"&lt;pc_pre_index_20&gt;"		),
		ea(		PC_PRE_INDEX16_EA20,	"&lt;pc_pre_index16_20&gt;"	),
		ea(		PC_PRE_INDEX32_EA20,	"&lt;pc_pre_index32_20&gt;"	),
		ea(	POST_INC_EA,				"&lt;post_inc&gt;"			),
		ea(	POST_INDEX_EA20,			"&lt;post_index_20&gt;"		),
		ea(		POST_INDEX16_EA20,		"&lt;post_index16_20&gt;"		),
		ea(		POST_INDEX32_EA20,		"&lt;post_index32_20&gt;"		),
		ea(	PRE_DEC_EA,					"&lt;pre_dec&gt;"				),
		ea(	PRE_INDEX_EA20,				"&lt;pre_index_20&gt;"		),
		ea(		PRE_INDEX16_EA20,		"&lt;pre_index16_20&gt;"		),
		ea(		PRE_INDEX32_EA20,		"&lt;pre_index32_20&gt;"		),

	range ( "&lt;end ea range&gt;", EA_RANGE_END),

		/* Machine instructions. */

	range ( "&lt;begin xtok range&gt;", XTOK_RANGE_BEGIN),

		x( X_DUMMY,"&lt;X_DUMMY&gt;" ),	/* Do-nothing node at start of code list. */

		x( X_ABCD,	"abcd"	),
		x( X_ADD,	"add"	),
		x( X_ADDA,	"adda"	),
		x( X_ADDI,	"addi"	),
		x( X_ADDQ,	"addq"	),
		x( X_ADDX,	"addx"	),
		x( X_AND,	"and"	),
		x( X_ANDI,	"andi"	),
		x( X_ASL,	"asl"	),
		x( X_ASR,	"asr"	),

		x( X_BCHG,	"bchg"	),
		x( X_BCLR,	"bclr"	),
		x( X_BRA,	"bra"	),
		x( X_BSET,	"bset"	),
		x( X_BSR,	"bsr"	),
		x( X_BTST,	"btst"	),

		range("&lt;begin Bcc range&gt;", BCC_RANGE_BEGIN),
			x( X_BCC,	"bcc"	),
			x( X_BCS,	"bcs"	),
			x( X_BEQ,	"beq"	),
			x( X_BGE,	"bge"	),
			x( X_BGT,	"bgt"	),
			x( X_BHI,	"bhi"	),
			x( X_BLE,	"ble"	),
			x( X_BLS,	"bls"	),
			x( X_BLT,	"blt"	),
			x( X_BMI,	"bmi"	),
			x( X_BNE,	"bne"	),
			x( X_BPL,	"bpl"	),
			x( X_BVC,	"bvc"	),
			x( X_BVS,	"bvs"	),
		range("&lt;end Bcc range&gt;", BCC_RANGE_END),

		x( X_CHK,	"chk"	),
		x( X_CLR,	"clr"	),
		x( X_CMP,	"cmp"	),
		x( X_CMPA,	"cmpa"	),
		x( X_CMPI,	"cmpi"	),
		x( X_CMPM,	"cmpm"	),

		x( X_DBCC,	"dbcc"	),
		x( X_DBCS,	"dbcs"	),
		x( X_DBEQ,	"dbeq"	),
		x( X_DBF,	"dbf"	),
		x( X_DBGE,	"dbge"	),
		x( X_DBGT,	"dbgt"	),
		x( X_DBHI,	"dbhi"	),
		x( X_DBLE,	"dble"	),
		x( X_DBLS,	"dbls"	),
		x( X_DBLT,	"dblt"	),
		x( X_DBMI,	"dbmi"	),
		x( X_DBNE,	"dbne"	),
		x( X_DBPL,	"dbpl"	),
		x( X_DBT,	"dbt"	),
		x( X_DBVC,	"dbvc"	),
		x( X_DBVS,	"dbvs"	),

		x( X_DIVS,	"divs"	),
		x( X_DIVU,	"divu"	),

		x( X_EOR,	"eor"	),
		x( X_EORI,	"eori"	),
		x( X_EXG,	"exg"	),
		x( X_EXT,	"ext"	),

		x( X_JMP,	"jmp"	),
		x( X_JSR,	"jsr"	),

		x( X_LEA,	"lea"	),
		x( X_LINK,	"link"	),
		x( X_LSL,	"lsl"	),
		x( X_LSR,	"lsr"	),

		x( X_MOVE,	"move"	),
		x( X_MOVEA,"movea"	),
		x( X_MOVEM,"movem"	),
		x( X_MOVEP,"movep"	),
		x( X_MOVEQ,"moveq"	),
		x( X_MULS,	"muls"	),
		x( X_MULU,	"mulu"	),

		x( X_NBCD,	"nbcd"	),
		x( X_NEG,	"neg"	),
		x( X_NEGX,	"negx"	),
		x( X_NOP,	"nop"	),
		x( X_NOT,	"not"	),

		x( X_OR,	"or"	),
		x( X_ORI,	"ori"	),

		x( X_PEA,	"pea"	),

		x( X_RESET,	"reset"	),
		x( X_ROL,	"rol"	),
		x( X_ROR,	"ror"	),
		x( X_ROXL,	"roxl"	),
		x( X_ROXR,	"roxr"	),
		x( X_RTE,	"rte"	),
		x( X_RTR,	"rtr"	),
		x( X_RTS,	"rts"	),

		x( X_SBCD,	"sbcd"	),

		x( X_SCC,	"scc"	),
		x( X_SCS,	"scs"	),
		x( X_SEQ,	"seq"	),
		x( X_SF,	"sf"	),
		x( X_SGE,	"sge"	),
		x( X_SGT,	"sgt"	),
		x( X_SHI,	"shi"	),
		x( X_SLE,	"sle"	),
		x( X_SLS,	"sls"	),
		x( X_SLT,	"slt"	),
		x( X_SMI,	"smi"	),
		x( X_SNE,	"sne"	),
		x( X_SPL,	"spl"	),
		x( X_ST,	"st"	),
		x( X_SVC,	"svc"	),
		x( X_SVS,	"svs"	),

		x( X_STOP,	"stop"	),
		x( X_SUB,	"sub"	),
		x( X_SUBA,	"suba"	),
		x( X_SUBI,	"subi"	),
		x( X_SUBQ,	"subq"	),
		x( X_SUBX,	"subx"	),
		x( X_SWAP,	"swap"	),

		x( X_TAS,	"tas"	),
		x( X_TRAP,	"trap"	),
		x( X_TRAPV,"trapv"	),
		x( X_TST,	"tst"	),

		x( X_UNLK,	"unlk"	),

	range("&lt;end xtok range&gt;", XTOK_RANGE_END),

	o( O_CLABEL,		"&lt;CLABEL&gt;" ),
	o( O_ULABEL,		"&lt;ULABEL&gt;" ),
	o( O_LINE_NUMBER,	"&lt;O_LINE&gt;" ),
	o( Q_BRN,			"&lt;Q_BRN&gt;"  ),

	/* ----- Tokens with non-zero size ----- */

	other		(small,	"&lt;bound tok&gt;", BOUND_TOK),

	other		(small,	"&lt;cons&gt;", CONS_TOK),

	op			(		"...", DOTS3_TOK),

	other		(small, "&lt;end program tok&gt;",	END_PROG_TOK),
	other		(big,	"&lt;error char tok&gt;",		ERROR_CHAR_TOK),
	other		(big,	"&lt;error message tok&gt;",	ERROR_MESSAGE_TOK),
	other		(small,	"&lt;expression tok&gt;",		EXPRESSION_TOK),

	other		(big,	"&lt;file name tok&gt;",		FILE_NAME_TOK),

	range ( "&lt;begin key range&gt;", KEY_RANGE_BEGIN),

	range ( "&lt;begin pp key range&gt;", PP_KEY_RANGE_BEGIN),

		range ( "&lt;begin pp_only range&gt;", PP_KEY_ONLY_RANGE_BEGIN),
		pp_key ( "define",	K_DEFINE),	/* Warning: tokize uses  */
		pp_key ( "elif",	K_ELIF),	/* Spelling of keywords. */
		pp_key ( "endif",	K_ENDIF),
		pp_key ( "error",	K_ERROR),
		pp_key ( "ifdef",	K_IFDEF),
		pp_key ( "ifndef",	K_IFNDEF),
		pp_key ( "include",	K_INCLUDE),
		pp_key ( "line",	K_LINE),
		pp_key ( "pragma",	K_PRAGMA),
		pp_key ( "undef",	K_UNDEF),
			range (	"&lt;begin no def range&gt;",	NO_DEF_RANGE_BEGIN),
			pp_keymac ( "__DATE__",	KM_DATE),	/* Preprocessor protected macros. */
			pp_keymac ( "defined",	KM_DEFINED),
			pp_keymac ( "__FILE__",	KM_FILE),
			pp_keymac ( "__LINE__",	KM_LINE),
			pp_keymac ( "__STDC__",	KM_STDC),
			pp_keymac ( "__TIME__",	KM_TIME),
			range (	"&lt;end no def range&gt;", NO_DEF_RANGE_END),
		range ( "&lt;end pp key only range&gt;", PP_KEY_ONLY_RANGE_END),

		ppkcontrol ( "else",	K_ELSE),
		ppkcontrol ( "if",		K_IF),

	range ( "&lt;end pp key range&gt;",	PP_KEY_RANGE_END),

	range ( "&lt;begin kdecl range&gt;",	KDECL_RANGE_BEGIN),

	#ifdef TARGET_PASCAL_KEYWORD								/* Optional keywords. */
		kdecl (		"pascal",				K_PASCAL),
	#endif
	kdecl ( "auto",		K_AUTO),
	kdecl ( "char",		K_CHAR),
	kdecl ( "const",	K_CONST),
	kdecl ( "double",	K_DOUBLE),
	kdecl ( "enum",		K_ENUM),
	kdecl ( "extern",	K_EXTERN),
	kdecl ( "float",	K_FLOAT),
	kdecl ( "int",		K_INT),
	kdecl ( "long",		K_LONG),
	kdecl ( "noalias",	K_NOALIAS),
	kdecl ( "register",	K_REGISTER),
	kdecl ( "short",	K_SHORT),
	kdecl ( "signed",	K_SIGNED),
	kdecl ( "static",	K_STATIC),
	kdecl ( "struct",	K_STRUCT),
	kdecl ( "typedef",	K_TYPEDEF),
	kdecl ( "union",	K_UNION),
	kdecl ( "unsigned",	K_UNSIGNED),
	kdecl ( "void",		K_VOID),
	kdecl ( "volatile",	K_VOLATILE),

	range		(	"&lt;end kdecl range&gt;",	KDECL_RANGE_END),

	kcontrol	( "break",			K_BREAK),
	kcontrol	( "case",			K_CASE),
	kcontrol	( "continue",		K_CONTINUE),
	kcontrol	( "default",		K_DEFAULT),
	kcontrol	( "do",				K_DO),
	key			( "entry",			K_ENTRY),
	kcontrol	( "for",			K_FOR),
	kcontrol	( "goto",			K_GOTO),
	madeup_key	( "long double",	K_LONG_DOUBLE),
	kcontrol	( "return",			K_RETURN),
	key			( "sizeof",			K_SIZEOF),
	kcontrol	( "switch",			K_SWITCH),
	madeup_key	( "unsigned long",	K_UNSIGNED_LONG),
	kcontrol	( "while",			K_WHILE),

	range	(	"&lt;end key range&gt;",	KEY_RANGE_END),

		/* Parser tokens. */

	parser ( "&lt;block&gt;",			KP_BLOCK),
	parser ( "&lt;...&gt;",			KP_DOTS3),
	parser ( "&lt;enum constant&gt;",	KP_ENUM_ELEM),
	parser ( "&lt;enum tag&gt;",		KP_ENUM_TAG),
	parser ( "&lt;null var&gt;",		KP_NULL_VAR),
	parser ( "&lt;struct tag&gt;",	KP_STRUCT_TAG),
	parser ( "&lt;union tag&gt;",		KP_UNION_TAG),
	parser ( "&lt;var&gt;",			KP_VAR),
	parser ( "&lt;void var&gt;",		KP_VOID_VAR),

	other (small,	"{", LCURLY_TOK),

	other (big,	"arg", MACRO_ARG_TOK),

/*
	Operands are grouped to make switches faster.
	Operands should be defined adjacent to operators.
*/
	other (big,	"&lt;char tok&gt;",			CHAR_TOK),
	other (big,	"&lt;float tok&gt;",			FLOAT_TOK),
	id	  (	    "&lt;id tok&gt;",				ID_TOK),
	other (big,	"&lt;disabled id tok&gt;",	IDX_TOK),
	other (big,	"&lt;int tok&gt;",			INT_TOK),
	other (big,	"&lt;long tok&gt;",			LONG_TOK),
	other (big,	"&lt;string tok&gt;",			STRING_TOK),
	other (big,	"&lt;wide char tok&gt;",		WIDE_CHAR_TOK),
	other (big,	"&lt;wide string tok&gt;",	WIDE_STRING_TOK),

/*
	Operators are grouped so that their precedence can be found from a table.

	Warning: change expr_prec if this subrange changes.
*/
	range (	"&lt;begin op range&gt;", OP_RANGE_BEGIN),

	range (	"&lt;begin unop range&gt;", UNOP_RANGE_BEGIN),

		unop ( "&lt;cast&gt;",	CAST_TOK),
		unop ( "--",		DEC_TOK),
		unop ( "++",		INC_TOK),
		unop ( "--",		POST_DEC_TOK),
		unop ( "++",		POST_INC_TOK),
		unop ( "--",		PRE_DEC_TOK),
		unop ( "++",		PRE_INC_TOK),
		unop ( "!",			NOT_TOK),
		unop ( "~",			TILDE_TOK),
		unop ( "&amp;",			UAND_TOK),
		unop ( "-",			UMINUS_TOK),
		unop ( "+",			UPLUS_TOK),
		unop ( "*",			USTAR_TOK),

	range (	"&lt;end unop range&gt;", UNOP_RANGE_END),

	range (	"&lt;begin binop range&gt;", BINOP_RANGE_BEGIN),

		abelian	( "&amp;",			AND_TOK),
		assnop	( "&amp;=",			AND_ASSN_TOK),
		abelian	( "&lt;array&gt;",	ARRAY_TOK),
		binop	( "-&gt;",			ARROW_TOK),
		assnop	( "=",			ASSN_TOK),
		binop	( "&lt;call&gt;",		CALL_TOK),
		binop	( ",",			COMMA_TOK),
		binop	( "/",			DIV_TOK),
		assnop	( "/=",			DIV_ASSN_TOK),
		binop	( ".",			DOT_TOK),
		relop	( "==",			EQUAL_TOK),
		relop	( "&gt;=",			GE_TOK),
		relop	( "&gt;",			GT_TOK),
		binop	( "&amp;&amp;",			LAND_TOK),
		relop	( "&lt;=",			LE_TOK),
		binop	( "||",			LOR_TOK),
		binop	( "&lt;&lt;",			LSHIFT_TOK),
		assnop	( "&lt;&lt;=",		LSHIFT_ASSN_TOK),
		relop	( "&lt;",			LT_TOK),
		binop	( "-",			MINUS_TOK),
		assnop	( "-=",			MINUS_ASSN_TOK),
		binop	( "%",			MOD_TOK),
		assnop	( "%=",			MOD_ASSN_TOK),
		relop	( "!=",			NE_TOK),
		abelian ( "|",			OR_TOK),
		assnop	( "|=",			OR_ASSN_TOK),
		abelian ( "+",			PLUS_TOK),
		assnop	( "+=",			PLUS_ASSN_TOK),
		binop	( "&gt;&gt;",			RSHIFT_TOK),
		assnop	( "&gt;&gt;=",		RSHIFT_ASSN_TOK),
		abelian ( "*",			STAR_TOK),
		assnop	( "*=",			STAR_ASSN_TOK),
		abelian ( "^",			XOR_TOK),
		assnop	( "^=",			XOR_ASSN_TOK),

	range ( "&lt;end binop range&gt;", BINOP_RANGE_END),

	ternop ( ":", COLON_TOK),
	ternop ( "?", QUESTION_TOK),

	other (small,	"[", LBRACK_TOK),	/* has a precedence. */
	other (small,	"(", LPAREN_TOK),	/* has a precedence. */

	range ( "&lt;end op range&gt;", OP_RANGE_END),

	other (big,	"&lt;partial char tok&gt;",	PARTIAL_CHAR_TOK),
	other (big,	"&lt;partial fname tok&gt;",	PARTIAL_FILE_NAME_TOK),
	other (big,	"&lt;partial string tok&gt;",	PARTIAL_STRING_TOK),
	other (big,	"&lt;partial W char tok&gt;",	PARTIAL_WIDE_CHAR_TOK),
	other (big,	"&lt;partial W str tok&gt;",	PARTIAL_WIDE_STRING_TOK),

	other (big,	"#",  POUND_TOK),
	other (big,	"##", POUND_POUND_TOK),

	other (small,	"]", RBRACK_TOK),
	other (small,	"}", RCURLY_TOK),
	other (small,	")", RPAREN_TOK),

	op ( ";", SEMICOLON_TOK),

	other (small, "&lt;user label&gt;", ULABEL_TOK),

	/*
		White space tokens are grouped for easy recognition.
	*/
	range ( "&lt;begin ws range&gt;", WS_RANGE_BEGIN),
		ws (big,	"&lt;comment tok&gt;",		WS_COMMENT_TOK),
		ws (small,	"&lt;form feed tok&gt;",		WS_FF_TOK),
		ws (small,	"\n",					WS_NL_TOK),
		ws (small,	"&lt;vertical tab tok&gt;",	WS_VTAB_TOK),
		ws (small,	" ",					WS_TOK),
		ws (big,	"&lt;blanks tok&gt;",			WS_BLANKS_TOK),
	range ( "&lt;end ws range&gt;", WS_END_RANGE),

	/*
		Hidden tokens are grouped so they can be recognized quickly.
		This makes the next_tok macro much faster.
	*/
	range ( "&lt;begin hidden range&gt;",	HIDDEN_RANGE_BEGIN),
		hidden		(		"&lt;begin file tok&gt;",		HIDDEN_BEGIN_FILE_TOK),
		hidden_ws	(big,	"&lt;big ignore tok&gt;",		HIDDEN_BIG_IGNORE_TOK),
		hidden		(		"&lt;big skip tok&gt;",		HIDDEN_BIG_SKIP_TOK),
		hidden		(		"&lt;end block tok&gt;",		HIDDEN_END_BLOCK_TOK),
		hidden		(		"&lt;end file tok&gt;",		HIDDEN_END_FILE_TOK),
		hidden		(		"&lt;file info tok&gt;",		HIDDEN_FILE_INFO_TOK),
		hidden		(		"&lt;line adjust tok&gt;",	HIDDEN_LINE_ADJUST_TOK),
		hidden_ws	(small, "\n",					HIDDEN_NL_IN_COMMENT_TOK),
		hidden_ws	(small,	"\n",					HIDDEN_NL_IN_MACRO_TOK),
		hidden_ws	(small,	"&lt;small ignore tok&gt;",	HIDDEN_SMALL_IGNORE_TOK),
		hidden		(		"&lt;skip tok&gt;",			HIDDEN_SKIP_TOK),
		hidden		(		"&lt;skip directive tok&gt;",	HIDDEN_SKIP_DIRECTIVE_TOK),
		hidden		(		"&lt;skip to macro tok&gt;",	HIDDEN_SKIP_TO_MACRO_TOK),
	range ( "&lt;end hidden range&gt;", HIDDEN_RANGE_END),

	/*
		WARNING: The is_hidden macro assumes that no tokens
				 tokens lie beyond the hidden tokens!
	*/

	bad ( "&lt;bad last tok&gt;", BAD_LAST_TOK)
};
</t>
<t tx="ekr.20080529093004.453">@ ----- Token Routines -----
Check the consistency of tok_info [].  This routine makes adding items to tok_info foolproof *provided* it is called before any tokens are needed!  It should be called as soon as possible in init_all.
@c

void
tok_check(void)
{
	FTAG("tok_check");
	int i = 0;
	TRACEPB(ftag, eint(BAD_LAST_TOK); enl());

	for (i = 0; i &lt; BAD_LAST_TOK; i++) {

		ASSERT_TRACE(i == tok_info [i] . tok_info_val,
			es("tok_check: value mismatch.  i: "); eint(i);
			es(" name: "); es(tok_name(i));
		);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.454">@ Print the entire token list.
@c

token *
tok_dump(register token * tp, bool print_hidden_flag)
{
	bool save_update = tok_update_flag;
	tok_update_flag = FALSE;

	ecnl();
	while (tp != NULL) {
		tok_dump1(tp, print_hidden_flag);
		tp = tok_next_raw(tp);
		if (*tp == END_PROG_TOK) {
			break;
		}
	}
	if (print_hidden_flag) {
		ecnl();
	}

	tok_update_flag = save_update;
	return tp;
}
</t>
<t tx="ekr.20080529093004.455">@ Print tokens up to and including an delimiter token.
@c

token *
tok_dump_delim(token * tp, token delim)
{
	bool save_update = tok_update_flag;
	tok_update_flag = FALSE;

	tp = tok_dump_delim2(tp, delim, PRINT_HIDDEN_TOKS);

	tok_update_flag = save_update;
	return tp;
}
</t>
<t tx="ekr.20080529093004.456">token *
tok_dump_delim2(token * tp, token delim, bool print_hidden_flag)
{
	bool save_update = tok_update_flag;
	tok_update_flag = FALSE;

	while(tp != NULL) {
		tok_dump1(tp, PRINT_HIDDEN_TOKS);
		if (*tp == delim) {
			break;
		}
		next_raw_tok(tp);
		if (*tp == END_PROG_TOK) {
			break;
		}
	}
	if (print_hidden_flag) {
		ecnl();
	}

	tok_update_flag = save_update;
	return tp;
}
</t>
<t tx="ekr.20080529093004.457">@ Print one line of the token list. Return a pointer to the start of the next line.
@c

token *
tok_dump_line(token * tp)
{
	bool save_update = tok_update_flag;
	tok_update_flag = FALSE;

	tp = tok_dump_line2(tp, PRINT_HIDDEN_TOKS,
	DONT_SPLIT_LONG_LINES, PRINT_NON_USER_TOKENS);

	tok_update_flag = save_update;
	return tp;
}
</t>
<t tx="ekr.20080529093004.458">token *
tok_dump_line2(
	register token * tp,
	bool print_hidden_flag,
	bool split_flag,
	bool user_flag)
{
	register int count = 0;
	bool save_update = tok_update_flag;

	tok_update_flag = FALSE;

	while (	tp != NULL &amp;&amp;
			*tp != WS_NL_TOK &amp;&amp;
			*tp != HIDDEN_NL_IN_COMMENT_TOK) {
		count++;
		if (split_flag &amp;&amp; count == 15) {
			count = 0;
			enl(); es("...");
		}
		tok_dump1(tp, print_hidden_flag);
		if (user_flag &amp;&amp; *tp == HIDDEN_SKIP_TO_MACRO_TOK) {

			/* Print name of the the unexpanded macro. */
			token * name_tp = (token *) ptr_tok_ptr(tp);
			spell_node * spell_p = (spell_node *) ptr_tok_ptr(name_tp);

			es(spell_p -&gt; spell_name);

			/* Move on to the unexpanded replacement text. */
			bump_tp_macro(tp, tok_size(*tp));
		}
		else if (
			user_flag &amp;&amp;
				/* 12/28/92 added HIDDEN_BIG_SKIP_TOK case */
				(*tp == HIDDEN_SKIP_DIRECTIVE_TOK || *tp == HIDDEN_BIG_SKIP_TOK)
		) {

			/* Print the patched '#' and go on. */
			es("#");
			bump_tp_macro(tp, tok_size(*tp));
		}
		else {
			tp = tok_next_raw(tp);
		}
		if (*tp == HIDDEN_END_FILE_TOK || *tp == END_PROG_TOK) {
			break;
		}
	}
	if (print_hidden_flag) {
		ecnl();
	}

	tok_update_flag = save_update;
	return tp;
}
</t>
<t tx="ekr.20080529093004.459">@ Dump a list of tokens.
@c

token *
tok_dump_list(token * first_p, token * end_p)
{
	token * tp;
	bool save_update = tok_update_flag;
	tok_update_flag = FALSE;

	tp = tok_dump_list2(first_p, end_p, PRINT_HIDDEN_TOKS);

	tok_update_flag = save_update;
	return tp;
}
</t>
<t tx="ekr.20080529093004.460">token *
tok_dump_list2(token * first_p, token * end_p, bool print_hidden_flag)
{
	register token * tp = first_p;
	bool save_update = tok_update_flag;

	tok_update_flag = FALSE;
	while (tp != NULL) {
		tok_dump1(tp, print_hidden_flag);
		if (tp == end_p) {
			break;
		}
		else {
			tp = tok_next_raw(tp);
		}
		if (*tp == END_PROG_TOK) {
			break;
		}
	}
	if (print_hidden_flag) {
		ecnl();
	}

	tok_update_flag = save_update;
	return tp;
}
</t>
<t tx="ekr.20080529093004.461">@ Print one token.
@c

void
tok_dump1(register token * tp, bool print_hidden_flag)
{
	FTAG("tok_dump1");

	register char * ptr;
	register token kind;

	ASSERT_TRACE(*tp &lt; BAD_LAST_TOK &amp;&amp; *tp &gt; 0,
		es("tok_dump1: tp: "); eptr(tp));

	ptr = ptr_tok_ptr(tp);
	kind = *tp;

	switch(kind) {

	case BOUND_TOK:
		if (print_hidden_flag) {
			/* An honorary hidden token. */
			es("&lt;bound&gt;");
		}
		break;

	case CHAR_TOK:
		echar('\''); es(ptr); echar('\'');
		break;

	case DOTS3_TOK:
		es( print_hidden_flag ? "&lt;...&gt;" : "...");
		break;

	case END_PROG_TOK:
		if (print_hidden_flag) {
			es("&lt;end program&gt;\n");
		}
		break;

	case ERROR_CHAR_TOK:
		echar((long) ptr);
		break;

	case ERROR_MESSAGE_TOK:
		if (print_hidden_flag) {
			char * message = ptr_tok_ptr(tp);
			es("&lt;error message: "); es(message); es("&gt;");
		}
		break;

	case FILE_NAME_TOK:
		echar('&lt;'); es(ptr); echar('&gt;');
		break;

	case FLOAT_TOK:
		es(ptr);
		break;

	case HIDDEN_BEGIN_FILE_TOK:
		if (print_hidden_flag) {
			es("&lt;begin file tok: "); es(ptr); es("&gt;");
			/* The file starts with a dummy newline, so don't add one here. */
		}
		break;

	case HIDDEN_BIG_IGNORE_TOK:
		if (print_hidden_flag) {
			es("&lt;ignore5&gt;");
		}
		break;

	case HIDDEN_BIG_SKIP_TOK:
		if (print_hidden_flag) {
			es("&lt;big skip: ");
			elong(((skip_node *) ptr) -&gt; skip_lines);
			es(" lines&gt;");
		}
		break;

	case HIDDEN_END_BLOCK_TOK:
		if (print_hidden_flag) {
			es(tok_name(*tp));
		}
		break;

	case HIDDEN_END_FILE_TOK:
		{
			file_info_node *fip = (file_info_node *) ptr;

			if (print_hidden_flag) {
				es("&lt;end file tok: resuming: "); es(fip -&gt; finfo_fname);
				es(" line: "); elong(fip -&gt; finfo_line); es("&gt;");
			}
			break;
		}

	case HIDDEN_FILE_INFO_TOK:
		{
			file_info_node * fip = (file_info_node *) ptr;

			if(arg_line_flag) {
				ecnl(); es("#line "); elong(fip -&gt; finfo_line);
				eblank(); es(fip -&gt; finfo_fname); enl();
			}
			else if (print_hidden_flag) {
				ecnl();
				es("&lt;file info tok: line: "); elong(fip -&gt; finfo_line);
				eblank(); es(fip -&gt; finfo_fname); enl();
			}
			break;
		}

	case HIDDEN_LINE_ADJUST_TOK:
		/* A #line directive is never appropriate here. */
		if(print_hidden_flag) {
			es("&lt;line adjust: "); elong((long) ptr); es("&gt;");
		}
		break;

	case HIDDEN_NL_IN_COMMENT_TOK:
		if (print_hidden_flag) {
			es("&lt;hidden nl in comment&gt;\n");
		}
		else {
			enl();
		}
		break;

	case HIDDEN_NL_IN_MACRO_TOK:
		if (print_hidden_flag) {
			es("&lt;hidden nl in macro&gt;\n");
		}
		else {
			enl();
		}
		break;

	case HIDDEN_SKIP_TOK:
		if (print_hidden_flag) {
			es("&lt;skip&gt;");
		}
		break;

	case HIDDEN_SKIP_DIRECTIVE_TOK:
		if (print_hidden_flag) {
			es("&lt;skip directive&gt;");
		}
		break;

	case HIDDEN_SKIP_TO_MACRO_TOK:
		if (print_hidden_flag) {

			token * name_tp = (token *) ptr_tok_ptr(tp);
			spell_node * spell_p = (spell_node *) ptr_tok_ptr(name_tp);

			es("&lt;skip to macro ");
			es(spell_p -&gt; spell_name);
			es("&gt;\n");
		}
		break;

	case HIDDEN_SMALL_IGNORE_TOK:
		if (print_hidden_flag) {
			es("&lt;ignore1&gt;");
		}
		break;

	case ID_TOK:
		es( ((spell_node *) ptr) -&gt; spell_name);
		break;

	case IDX_TOK:
		if (print_hidden_flag) {
			es("&lt;idx:");
			es( ((spell_node *) ptr) -&gt; spell_name);
			es("&gt;");
		}
		else {
			es( ((spell_node *) ptr) -&gt; spell_name);
		}
		break;

	case INT_TOK:
		es(ptr);
		break;

	case LBRACK_TOK:
	case LCURLY_TOK:
	case LPAREN_TOK:
		es(tok_name(kind));
		break;

	case LONG_TOK:
		es(ptr);
		break;

	case MACRO_ARG_TOK:
		es("&lt;macro arg "); elong((long) ptr); es("&gt;");
		break;

	case PARTIAL_CHAR_TOK:
		es("'");
		es(ptr);
		break;

	case PARTIAL_FILE_NAME_TOK:
		es("&lt;");
		es(ptr);
		break;

	case PARTIAL_STRING_TOK:
		echar('"');
		es(ptr);
		break;

	case PARTIAL_WIDE_CHAR_TOK:
		es("W'");
		es(ptr);
		break;

	case PARTIAL_WIDE_STRING_TOK:
		es("W\"");
		es(ptr);
		break;

	case RBRACK_TOK:
	case RCURLY_TOK:
	case RPAREN_TOK:
		es(tok_name(kind));
		break;

	case STRING_TOK:

string_tok:
		echar('"');
		/* Split long lines so Sherlock doesn't truncate them. */
		{
			int count = 0;
			while(*ptr) {
				if(count++ == 80) {
					es("&lt;added nl&gt;\n");
					count = 0;
				}
				echar(*ptr);
				ptr++;
			}
		}
		echar('"');
		break;

	case WIDE_CHAR_TOK:
		es("L'"); es(ptr); echar('\'');
		break;

	case WIDE_STRING_TOK:
		es("L");
		goto string_tok;

	case WS_BLANKS_TOK:
		eblanks((long) ptr);
		break;

	case WS_COMMENT_TOK:
		#if 0 /* For multi-line comments */

			es("/*"); es(ptr); es("*/");

		#else /* For single-line comments */

			es(ptr);

		#endif
		break;

	default:
		if (is_id(*tp) &amp;&amp; print_hidden_flag) {
			es("&lt;");
			es( ((spell_node *) ptr) -&gt; spell_name);
			es("&gt;");
		}
		else {
			es(tok_name(kind));
		}
		break;
	}
}
</t>
<t tx="ekr.20080529093004.462">@ On entry, tp points to a STRING_TOK. Return a pointer to a token representing the concatenation of tp and any following strings.  If there are no following strings strings to be concatenated, simply return the value of tp on entry.  Otherwise, create a new STRING_TOK at the *end* of the token list, followed by a HIDDEN_SKIP_TOK pointing to the token following the last concatenated string.  Creating a these new tokens at the end of the token list keeps the original token list unchanged so that it will be correctly printed if there is an error.  To do: handle wide strings as well.
@c

token *
tok_concatenate (token * tp)
{
	FTAG("tok_concatenate");
	token * old_tp = tp;
	STATB(ftag);
	ASSERT(*tp == STRING_TOK);

	/* Skip past the STRING_TOK. */
	bump_tp_macro(tp, tok_size(*tp));

	for (;;) {

		/* Skip over all white space. */
		if (is_hidden(*tp)) {
			tp = tok_skip_hidden(tp);
		}

		while(is_ws(*tp)) {
			if (*tp == WS_NL_TOK) {
				err_line++;

				/* Record the start of the line for line number nodes. */
				par_line_ptr = tp;
			}
			bump_tp_macro(tp, tok_size(*tp));
			if (is_hidden(*tp)) {
				tp = tok_skip_hidden(tp);
			}
		}

		/* Look for another string to concatenate. */
		if (*tp == STRING_TOK) {

			/*
				Create a new STRING_TOK representing the concatenation
				of the string at the_string and tp.
				Point the_string to the newly created token.
			*/
			char * cat_string = NULL;

			char * old_string = ptr_tok_ptr(old_tp);
			char * new_string = ptr_tok_ptr(tp);

			size_t old_length = strlen(old_string);
			size_t new_length = strlen(new_string);
			
			ASSERT(*old_tp == STRING_TOK);

			/* Allocate string space for the new string. */			
			new_size_macro(cat_string, old_length + new_length + 1, file_life, string_stats);

			/* Copy the strings to the newly allocated space. */
			memcpy(cat_string, old_string, old_length);
			memcpy(cat_string + old_length, new_string, new_length);
			*(cat_string + old_length + new_length) = '\0';

			/* Create the string token and remember where it is. */
			old_tp = tok_copy(STRING_TOK, cat_string);

			/* Skip past the STRING_TOK. */
			bump_tp_macro(tp, tok_size(*tp));

			/* Create a HIDDEN_SKIP_TOK pointing to the token following the_string. */
			tok_copy(HIDDEN_SKIP_TOK, tp);
		}
		else {
			tp = old_tp;
			break;
		}
	}

	TRACEPX(ftag, tok_dump1(tp, PRINT_HIDDEN_TOKS); ecnl());
	return tp;
}
</t>
<t tx="ekr.20080529093004.463">@ Copy a single token to the current token buffer.  the_tok is used only if the_token is a big token.
@c

token *
tok_copy(token the_token, void * the_ptr)
{
	FTAG("tok_copy");
	register token *  dp = NULL;	/* Destination ptr. */
	register long davail = 0;		/* Destination avail. */
	token * the_dp;
	STATB(ftag);

	/* Restore the token paremeters saved by tokize(). */
	davail = token_life -&gt; mem_avail;
	dp = token_life -&gt; mem_ptr;

	/* Careful: we must call tok_protect_macro before setting the_dp. */
	tok_protect_macro(dp, davail);
	the_dp = dp;

	/* Copy the token. */
	if (tok_size(the_token) == BIG_TOKEN_SIZE) {
		*dp = the_token;
		patch_ptr_tok(dp, the_ptr);
		bump_tp_macro(dp, BIG_TOKEN_SIZE);
		davail -= BIG_TOKEN_SIZE;
	}
	else {
		ASSERT(the_ptr == NULL);
		*dp = the_token;
		dp++;
		davail -= SMALL_TOKEN_SIZE;
	}

	/* Save the token paremeters for tokize(). */
	token_life -&gt; mem_avail = davail;
	token_life -&gt; mem_ptr = dp;

	TRACEPX(ftag,
		tok_dump1(the_dp, PRINT_HIDDEN_TOKS);
		ecnl());

	return the_dp;
}
</t>
<t tx="ekr.20080529093004.464">@ Copy a token list (from start_p to end_p) to the current token buffer. Do not copy invisible tokens or BOUND_TOK. Change newline tokens to a single blank.  Set last_p in the caller to the first and last *visible* token copied.  It may be that nothing is copied. In that case, return a pointer to where the next token will be copied.
@c

token *
tok_copy_list(token * start_p, token * end_p, token ** last_copy, char * tag)
{
	FTAG("tok_copy_list");
	FTAGV("-tok_copy_list_v");

		register token * sp = start_p;		/* Source pointer. */
		register token * dp = NULL;			/* Destination pointer. */
		register token * last_dp = NULL;	/* Ptr to last copied token. */
		register long davail = 0;			/* Destination avail ptr. */
		token * first_dp = NULL;
		bool save_update = tok_update_flag;

	STATB(ftag);
	ASSERT(start_p);
	TRACEPN(ftagv, es(tag); eblank(); tok_dump_list(start_p, end_p); ecnl());

	/* Do not update line numbers, etc. while scanning. */
	tok_update_flag = FALSE;

	/* Restore the token paremeters saved by tokize(). */
	davail = token_life -&gt; mem_avail;
	dp = token_life -&gt; mem_ptr;

	/* Careful: we must call tok_protect_macro before setting first_dp. */
	tok_protect_macro(dp, davail);
	last_dp = dp;
	first_dp = dp;

	/*
		Copy the token list, but do not copy hidden tokens or bound toks.
		Be careful: it is valid for a hidden token to end the list.
	*/
	ASSERT(sp);
	
	for (;;) {

		ASSERT_TRACE(*sp != HIDDEN_END_FILE_TOK &amp;&amp; *sp != END_PROG_TOK,
			es("token: "); tok_dump1(sp, PRINT_HIDDEN_TOKS);
			es(", ptr: "); eptr(sp); enl());

		/* Careful: we must call tok_protect_macro before setting last_dp. */
		tok_protect_macro(dp, davail);

		/* 7/5/93: Make code independent of sizeof(token). */
		if (*sp == WS_NL_TOK) {

			ASSERT(tok_size(WS_TOK) == SMALL_TOKEN_SIZE);
			last_dp = dp;
			*dp++ = WS_TOK;
			davail -= SMALL_TOKEN_SIZE;

			#if 0 /* AS code uses big newlines */
				ASSERT(tok_size(WS_TOK) == BIG_TOKEN_SIZE);
				*dp = WS_TOK;
				bump_tp_macro(dp, BIG_TOKEN_SIZE);
				davail -= SMALL_TOKEN_SIZE;
			#endif
		}
		else if (is_hidden(*sp)) {
			;
		}
		else if (*sp != BOUND_TOK) {
			last_dp = dp;
			*dp = *sp;
			if (tok_size(*sp) == BIG_TOKEN_SIZE) {
				patch_ptr_tok(dp, (ptr_tok_ptr(sp)));
				bump_tp_macro(dp, BIG_TOKEN_SIZE);
				davail -= BIG_TOKEN_SIZE;
			}
			else {
				dp++;
				davail -= SMALL_TOKEN_SIZE;
			}
		}
		if (sp == end_p) {
			break;
		}
		sp = tok_next_raw(sp);
	}

	/* Save the token paremeters for tokize(). */
	token_life -&gt; mem_avail = davail;
	token_life -&gt; mem_ptr = dp;

	TRACEPX(ftag, es(tag); eblank(); tok_dump_list(first_dp, last_dp); ecnl());

	tok_update_flag = save_update;
	*last_copy = last_dp;
	return first_dp;
}
</t>
<t tx="ekr.20080529093004.465">@ Copy a token up to but not including a newline to the current token buffer.  It may be that nothing is copied. In that case, return a pointer to where the next token will be copied.  Do not copy invisible tokens, BOUND_TOK.
@c

token *
tok_copy2nl(token * start_p, token ** last_copy, char * tag)
{
	FTAG("tok_copy2nl");

		register token * sp = start_p;		/* Source pointer. */
		register token * dp = NULL;			/* Destination pointer. */
		register token * last_dp = NULL;	/* Ptr to last copied token. */
		register long davail = 0;			/* Destination avail ptr. */
		token *	first_dp = NULL;
		bool save_update = tok_update_flag;
	
	STATB(ftag);
	ASSERT(start_p);

	/* Do not update line numbers, etc. while scanning. */
	tok_update_flag = FALSE;

	/* Restore the token paremeters saved by tokize(). */
	davail = token_life -&gt; mem_avail;
	dp = token_life -&gt; mem_ptr;

	/* Careful: we must call tok_protect_macro before setting first_dp. */
	tok_protect_macro(dp, davail);
	first_dp = dp;
	last_dp = dp;

	while (*sp != WS_NL_TOK) {

		ASSERT_TRACE(*sp != HIDDEN_END_FILE_TOK &amp;&amp; *sp != END_PROG_TOK,
			es("token: "); tok_dump1(sp, PRINT_HIDDEN_TOKS);
			es(", ptr: "); eptr(sp); enl());

		/* Careful: we must call tok_protect_macro before setting last_dp. */
		tok_protect_macro(dp, davail);
		last_dp = dp;

		/* Copy the token. */
		if (!is_hidden(*sp) &amp;&amp; *sp != BOUND_TOK) {
			*dp = *sp;
			if (tok_size(*sp) == BIG_TOKEN_SIZE) {
				patch_ptr_tok(dp, (ptr_tok_ptr(sp)));
				bump_tp_macro(dp, BIG_TOKEN_SIZE);
				davail -= BIG_TOKEN_SIZE;
			}
			else {
				dp++;
				davail -= SMALL_TOKEN_SIZE;
			}
		}
		next_tok(sp);
	}

	/* Save the token paremeters for tokize(). */
	token_life -&gt; mem_avail = davail;
	token_life -&gt; mem_ptr = dp;

	ASSERT(first_dp &amp;&amp; last_dp &amp;&amp; !is_hidden(*first_dp) &amp;&amp; !is_hidden(*last_dp));

	TRACEPX(ftag, es(tag); eblank();
		if (first_dp != last_dp) {
			tok_dump_list(first_dp, last_dp);
		}
		ecnl();
	);

	tok_update_flag = save_update;
	*last_copy = last_dp;
	return first_dp;
}
</t>
<t tx="ekr.20080529093004.466">@ Replace the token at tp with a hidden ignore token.
@c

void
tok_ignore(token * tp)
{
	FTAG("tok_ignore");
	STATB(ftag);

	if (tok_size(*tp) == SMALL_TOKEN_SIZE) {
		*tp = HIDDEN_SMALL_IGNORE_TOK;
	}
	else {
		*tp = HIDDEN_BIG_IGNORE_TOK;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.467">@ This routine should contain no Sherlock macros or output statments. It is called before all other initilization routines.
@c

void
tok_init(void)
{
	register int i;
	register char * p = &amp;tok_size_array[0];

	for (i = 0; i &lt; BAD_LAST_TOK; i++) {
		*p++ = tok_info[i].tok_info_size;
	}
}
</t>
<t tx="ekr.20080529093004.468">@ Return a pointer to the next visible token.  It turns out that the speed of the next_tok macro is important. Substituting this routine for the next_tok macro (defined in CC2tok.h) significantly degrades the speed of the compiler.
@c

#if 0 /* Old, slow and unused. */
token *
tok_next_(register token * tp)
{
	register token tok = *tp;

	SL_DISABLE();

	if (!is_hidden(tok)) {
		bump_tp_macro(tp, tok_size(tok));
	}
	return tok_skip_hidden(tp);
}
</t>
<t tx="ekr.20080529093004.469">#endif

/*
	Return a pointer to the next token, whatever the kind.

	Warning: You can *never* predict what the next raw token is going to be
			 because of the possibility of intervening HIDDEN_END_BLOCK_TOK's.
*/
token *
tok_next_raw(register token * tp)
{
	FTAG("tok_next_raw");

	#if 0 /* This slows down the code too much. */
		STATB(ftag);
	#endif

	/* Part of this assertion is that all tokens are even aligned. */
	ASSERT_TRACE(tp &amp;&amp; (((ulong)tp &amp; 1) == 0) &amp;&amp; *tp &lt; BAD_LAST_TOK &amp;&amp; *tp &gt; 0,
		es(ftag); es(": ");
		es("tp: "); eptr(tp);
		es(", *tp: "); eulong(*tp);
	);

	switch(*tp) {

	case END_PROG_TOK:
		goto return_tp;

	/*
		These are placed here so we can assert !is_hidden(*tp) in the default.
	*/
	case HIDDEN_BIG_IGNORE_TOK:
	case HIDDEN_SMALL_IGNORE_TOK:
		goto return_next_tp;

	case HIDDEN_BEGIN_FILE_TOK:
	{
		char * name = (char *) ptr_tok_ptr(tp);

		if (tok_update_flag) {
			err_fname = name;
			err_line = 0;
			err_line_offset = 0;
			tok_file_level++;
		}
		goto return_next_tp;
	}

	case HIDDEN_BIG_SKIP_TOK:
		{
			skip_node * skip_p = (skip_node *) ptr_tok_ptr(tp);

			if (tok_update_flag) {
				err_line += skip_p -&gt; skip_lines;
			}
			tp = skip_p -&gt; skip_tp;
			goto return_tp;
		}

	case HIDDEN_END_BLOCK_TOK:
		tp = (token *) ptr_tok_ptr(tp);
		goto return_tp;

	case HIDDEN_END_FILE_TOK:
		{
			file_info_node * fip = (file_info_node *) ptr_tok_ptr(tp);

			if (tok_update_flag) {
				if (fip -&gt; finfo_fname != NULL) {
					err_fname = fip -&gt; finfo_fname;
				}
				err_line  		= fip -&gt; finfo_line;
				err_line_offset = fip -&gt; finfo_line_offset;
				tok_file_level--;
			}
			tp = fip -&gt; finfo_tp;
			goto return_tp;
		}

	case HIDDEN_FILE_INFO_TOK:
		{
			file_info_node * fip = (file_info_node *) ptr_tok_ptr(tp);

			if (tok_update_flag) {
				if (fip -&gt; finfo_fname != NULL) {
					err_fname = fip -&gt; finfo_fname;
				}
				err_line_offset  = fip -&gt; finfo_line_offset;
			}
			tp = fip -&gt; finfo_tp;
			goto return_tp;
		}

	case HIDDEN_LINE_ADJUST_TOK:
		if (tok_update_flag) {
			err_line += val_tok_val(tp);
		}
		goto return_next_tp;

	case HIDDEN_NL_IN_COMMENT_TOK:
	case HIDDEN_NL_IN_MACRO_TOK:
		if (tok_update_flag) {
			err_line++;
		}
		goto return_next_tp;

	case HIDDEN_SKIP_TOK:
	case HIDDEN_SKIP_DIRECTIVE_TOK:

		tp = (token *) ptr_tok_ptr(tp);
		goto return_tp;

	case HIDDEN_SKIP_TO_MACRO_TOK:
	{
		token * name_tp = (token *) ptr_tok_ptr(tp);

		ASSERT(*name_tp == ID_TOK || *name_tp == IDX_TOK);
		tp = name_tp;
		bump_tp_macro(tp, BIG_TOKEN_SIZE);
		goto return_tp;
	}

	default:

		ASSERT_TRACE(!is_hidden(*tp),
			es(ftag); es(": &lt;"); es(tok_name(*tp));
			es("&gt; = "); eint(*tp); es(" is hidden");
		);
		goto return_next_tp;
	}

return_next_tp:
	bump_tp_macro(tp, tok_size(*tp));

	/* Fall through. */

return_tp:

	#if 0 /* This slows down the code too much. */
		STATX(ftag);
	#endif

	return tp;
}
</t>
<t tx="ekr.20080529093004.470">@ Point par_token_ptr at the next parser token.  This routine should be as fast as possible because it is called very often.
@c

void
tok_par_next(void)
{
	FTAG("-tok_par_next");
	FTAGV("-tok_par_next_v");

	register token * tp = par_token_ptr;

	/*
		This assertion is initially made true by par_program and
		clearly remains true on exit from this routine.
	*/
	ASSERT(!is_hidden(*tp));

	STATB(ftag);

	/* Skip the current token. */

	#if 1 /* We know *tp is not hidden. */
		bump_tp_macro(tp, tok_size(*tp));
	#else
		if (!is_hidden(*tp)) {
			bump_tp_macro(tp, tok_size(*tp));
		}
	#endif

	/*
		2/16/92: The compact code is now much better than the old
		compact code because the is_hidden, is_ws and is_ppkey_only macros
		are now range tests rather than bit tests.
		Also, tok_skip_hidden is called only if is_hidden is true.
	*/

	/* Repeating this test allows the while test to be done at the end of the loop. */
	if (is_hidden(*tp)) {
		tp = tok_skip_hidden(tp);
	}

	/* Skip all white space. */
	while(is_ws(*tp)) {
		if (*tp == WS_NL_TOK) {
			err_line++;

			/* 3/8/93: Record the start of the line for line number nodes. */
			par_line_ptr = tp;
		}
		bump_tp_macro(tp, tok_size(*tp));
		if (is_hidden(*tp)) {
			tp = tok_skip_hidden(tp);
		}
	}

	ASSERT(*tp != BOUND_TOK);

	/*
		Restore the meaning of disabled macros.
		The call to the new is_ppkey_only(*tp) macro
		is another crucial optimization.
	*/
	if (*tp == IDX_TOK) {
		*tp = id_tok_ptr(tp) -&gt; spell_token;
	}

	/*
		Bug fixes: 9/19/92 and (sigh) 2/25/93.
		Translate reserved words after restoring the meaning of disabled macros.

		E.g., defining error as a macro requires these two translations.
	*/
	if (is_ppkey_only(*tp)) {

		#if 0 /* This is too slow to leave in. */
			TRACEPN(ftag, es("converting pp reserved word ");
			es(id_tok_ptr(tp) -&gt; spell_name); es(" to a plain id.\n"));
		#endif
		*tp = ID_TOK;
	}

	/* Bug fix: 11/1/93: Concatenate strings here. */

	if (*tp == STRING_TOK) {
		tp = tok_concatenate(tp);
	}

done:
	par_token_ptr = tp;
	TRACEPN(ftagv, es("line: "); epadlong(err_line, 3); es(", token: "); etok(tp); enl());
	STATX(ftag);

}
</t>
<t tx="ekr.20080529093004.471">@ Patch a large token.
@c

void
tok_patch(token * patch_tp, token the_token, void * the_ptr, char * tag)
{
	FTAG("tok_patch");
	STATB(ftag);

	ASSERT(tok_size(*patch_tp) == BIG_TOKEN_SIZE);

	*patch_tp = the_token;
	patch_ptr_tok(patch_tp, the_ptr);

	TRACEPX(ftag,
		es("@: "); eptr(patch_tp); eblank();
		tok_dump1(patch_tp, PRINT_HIDDEN_TOKS);
		eblank(); eptr(the_ptr); eblank(); es(tag); enl());
}
</t>
<t tx="ekr.20080529093004.472">@ Scan the token list. (Used to gather statistics.)  Statistics for CopyOfArg.c:  IIci: 16/18 msec. (no ws/ full ws) SE/30: 28 msec (full ws)
@c

token *
tok_scan(register token * tp)
{
	FTAG("tok_scan");
	STATB(ftag);

	while (*tp != END_PROG_TOK) {

		ASSERT(*tp != BAD_TOK);

		next_tok(tp);
	}

	TICKX(ftag);
	return tp;
}
</t>
<t tx="ekr.20080529093004.473">@ Scan a token list, looking for the first token of the indicated file.
@c

token *
tok_scan_file (char * file_name, token * first_tok)
{
	FTAG("tok_scan_file");
	register token * tp = first_tok;
	register char * ptr = NULL;
	bool save_update = tok_update_flag;
	token * result = NULL;
	TRACEPB(ftag,
		es(file_name); enl());

	/*
		Bug fix: 7/30/93.

		This "restart" logic is faulty because file_name is simply err_fname,
		so the test below will *always* succeed.
		An improper value returned from this routine can cause lib_err_context
		to fail.

		This could be considered a memory-allocation bug because
		what tok_prev_file points to changes underneath it.

		Fortunately, the speed of this routine is no longer important
		because line nodes now contain pointers to the start of their lines.
		Thus, this routine is not called when outputing line cnodes and
		this routine is called only when giving error messages.

		In short, we don't need the restart logic here at all.
	*/
	tok_update_flag = FALSE;

	TRACEPN(ftag, es("*****scanning for start of: "); es(file_name); enl());

	for(;;) {

		/* ASSERT will not work since tok_scan_line is called by ASSERT! */
		if (*tp == END_PROG_TOK) {
			ecnl(); es(ftag); es(": end-file over-run\n");
			end_abort();
		}

		if (*tp == HIDDEN_BEGIN_FILE_TOK) {
			ptr = (char *) ptr_tok_ptr(tp);
			if (str_eq(file_name, ptr)) {
				result = tp;
				goto done;

			}
			else if (ptr == NULL) {
				result = NULL;
				goto done;
			}
		}
		else if (*tp == HIDDEN_FILE_INFO_TOK) {
			file_info_node * fip = (file_info_node *) ptr_tok_ptr(tp);
			if(	fip -&gt; finfo_fname != NULL &amp;&amp;
				str_eq(file_name, fip -&gt; finfo_fname)) {
				result = tp;
				goto done;
			}
		}
		next_raw_tok(tp);
	}

done:
	tok_update_flag = save_update;
	STATX(ftag);
	return result;
}
</t>
<t tx="ekr.20080529093004.474">@ Scan a token list, looking for the first token of the indicated line. Assume first_tok points at the first token of the correct file.  The err_line_offset variable was added so this routine will work correctly even if we have #line directives that specify a previous line.
@c

token *
tok_scan_line (
	token * first_tok, register long target_line, char * target_file_name,
	long * returned_line)
{
	FTAG("-tok_scan_line");
	register token * tp;
	register long current_line;
	bool save_update = tok_update_flag;
	static long	 tok_prev_line = 0;
	static char * tok_prev_line_file = NULL;
	static token * tok_prev_line_tp = NULL;

#ifndef PRODUCTION
	long   start_line = err_line;
	char * start_file = err_fname;
	token  last_tok = 0;
#endif

	TRACEPB(ftag, elong(target_line); ecs(); es(target_file_name); enl());

	tok_update_flag = FALSE;

	/* The target_line can be negative because of leading context. */
	if (target_line &lt; 1) {
		target_line = 1;
	}

	if (tok_prev_line_file != NULL &amp;&amp;
		str_eq(target_file_name, tok_prev_line_file)) {

		if (tok_prev_line == target_line) {
			STATX(ftag);
			*returned_line = target_line;
			return tok_prev_line_tp;
		}
		else if (tok_prev_line &lt; target_line &amp;&amp; tok_prev_line &gt; 0) {
			tp = tok_prev_line_tp;
			current_line = tok_prev_line-1;
			TRACEPN(ftag,
				es("starting at line: "); elong(current_line); enl());
		}
		else {
			tp = first_tok;
			current_line = 0;
			TRACEPN(ftag,
				es("starting at line: "); elong(current_line); enl());
		}
	}
	else {
		tp = first_tok;
		current_line = 0;
	}

	for(;;) {

		if (*tp == END_PROG_TOK || *tp == HIDDEN_END_FILE_TOK) {

			/* ASSERT will not work: tok_scan_line is called by ASSERT! */
			ecnl(); es(ftag); es(": END_FILE seen:");
			es(" current line: "); elong(current_line);
			es(" target line: "); elong(target_line);
			end_abort();
		}
		else if (*tp == WS_NL_TOK || *tp == HIDDEN_NL_IN_COMMENT_TOK) {
			if (++current_line &gt;= target_line) {
				goto done;
			}
		}
		else if (*tp == HIDDEN_LINE_ADJUST_TOK) {
			current_line += val_tok_val(tp);
		}
		else if (*tp == HIDDEN_BEGIN_FILE_TOK) {

			register char * file_name = (char *) ptr_tok_ptr(tp);
			register file_info_node * fip;

			/* Skip the entire inner file. */
			if (!str_eq(file_name, target_file_name)) {
				for(;;) {
					if (*tp == HIDDEN_END_FILE_TOK) {
						fip = (file_info_node *) ptr_tok_ptr(tp);
						if (str_eq(target_file_name, fip -&gt; finfo_fname)) {
							break;
						}
					}
					else if (*tp == HIDDEN_FILE_INFO_TOK) {
						file_info_node * fip = (file_info_node *) ptr_tok_ptr(tp);
						if(fip -&gt; finfo_fname != NULL &amp;&amp;
							str_eq(target_file_name, fip -&gt; finfo_fname)) {
							break;
						}
					}
					next_raw_tok(tp);
				}
			}
		}
		DEBUG(last_tok = *tp);

		/*
			Scan the original macro text, not the substituted text.
			Similarly, scan original preprocessor directives.
		*/
		if (*tp == HIDDEN_SKIP_TO_MACRO_TOK ||
			*tp == HIDDEN_SKIP_DIRECTIVE_TOK ||
			*tp == HIDDEN_BIG_SKIP_TOK
		) {
			bump_tp_macro(tp, tok_size(*tp));
		}
		else {
			next_raw_tok(tp);
		}

		DEBUG(TRACEN(ftag,
			if (last_tok == WS_NL_TOK || last_tok == HIDDEN_NL_IN_COMMENT_TOK) {
				ecnl(); epadlong(current_line,4); es("::");
			}
			tok_dump1(tp, PRINT_HIDDEN_TOKS);
		));

	}

done:
	tok_update_flag = save_update;

	/*
		Save the settings for the next invocation of this routine.
		Bug fix: 6/6/94: we must save a copy of the string,
		not a pointer to the string because the pointer will change!
	*/
	new_perm_string_macro(tok_prev_line_file, target_file_name);

	tok_prev_line = current_line;
	tok_prev_line_tp = tp;

	ASSERT(err_line == start_line &amp;&amp; str_eq(err_fname, start_file));

	*returned_line = current_line;
	TRACEPX(ftag, eret(); es(" *returned_line "); elong(*returned_line); enl());

	ASSERT(*tp == WS_NL_TOK || *tp == HIDDEN_NL_IN_COMMENT_TOK || current_line == -1);
	return tp;
}
</t>
<t tx="ekr.20080529093004.475">@ Skip over and process any hidden tokens. Return NULL on end program.
@c

token *
tok_skip_hidden(token * tp)
{
	FTAG("tok_skip_hidden");
	FTAGV("-tok_skip_hidden_v");

	#if 0 /* This distorts the statistics too much. */
		STATB(ftag);
	#endif

	for(;;) {

		ASSERT_TRACE(*tp &lt; BAD_LAST_TOK &amp;&amp; *tp &gt; 0,
			es("*tp: "); eint(*tp);
			es(" tok_name: "); es(tok_name(*tp));
		);

		switch(*tp) {

		case END_PROG_TOK:
			TRACEPN(ftag, es("end file\n"));

			/* Do not change tp. */
			goto done;

		case HIDDEN_BEGIN_FILE_TOK:
		{
			char * name = (char *) ptr_tok_ptr(tp);

			if (tok_update_flag) {
				err_fname = name;
				err_line = 0;
				err_line_offset = 0;
				tok_file_level++;
			}
			bump_tp_macro(tp, tok_size(*tp));
			break;
		}

		case HIDDEN_BIG_IGNORE_TOK:
			bump_tp_macro(tp, BIG_TOKEN_SIZE);
			break;

		case HIDDEN_BIG_SKIP_TOK:
		{
			skip_node * sip = (skip_node *) ptr_tok_ptr(tp);

			if (tok_update_flag) {
				err_line += sip -&gt; skip_lines;
			}
			tp = sip -&gt; skip_tp;
			break;
		}

		case HIDDEN_END_BLOCK_TOK:
			tp = (token *) ptr_tok_ptr(tp);
			break;

		case HIDDEN_END_FILE_TOK:
		{
			file_info_node * fip = (file_info_node *) ptr_tok_ptr(tp);

			if (tok_update_flag) {
				if (fip -&gt; finfo_fname != NULL) {
					err_fname = fip -&gt; finfo_fname;
				}
				err_line 		= fip -&gt; finfo_line;
				err_line_offset = fip -&gt; finfo_line_offset;
				tok_file_level--;
			}

			tp = fip -&gt; finfo_tp;
			break;
		}

		case HIDDEN_FILE_INFO_TOK:
		{
			file_info_node * fip = (file_info_node *) ptr_tok_ptr(tp);

			if (tok_update_flag) {
				if (fip -&gt; finfo_fname != NULL) {
					err_fname = fip -&gt; finfo_fname;
				}
				err_line_offset = fip -&gt; finfo_line_offset;
			}

			tp = fip -&gt; finfo_tp;
			break;
		}

		case HIDDEN_LINE_ADJUST_TOK:
			if (tok_update_flag) {
				err_line += val_tok_val(tp);
			}
			bump_tp_macro(tp, tok_size(*tp));
			break;

		case HIDDEN_NL_IN_COMMENT_TOK:
		case HIDDEN_NL_IN_MACRO_TOK:

			if (tok_update_flag) {
				err_line++;
			}
			bump_tp_macro(tp, tok_size(*tp));
			break;

		case HIDDEN_SMALL_IGNORE_TOK:
			bump_tp_macro(tp, SMALL_TOKEN_SIZE);
			break;

		case HIDDEN_SKIP_TOK:
		case HIDDEN_SKIP_DIRECTIVE_TOK:
			tp = (token *)  ptr_tok_ptr(tp);
			break;

		case HIDDEN_SKIP_TO_MACRO_TOK:
		{
			token * name_tp = (token *) ptr_tok_ptr(tp);

			ASSERT_TRACE(*name_tp == ID_TOK || *name_tp == IDX_TOK,
				es("*tp: "); es(tok_name(*tp)));

			tp = name_tp;
			bump_tp_macro(tp, BIG_TOKEN_SIZE);
			break;
		}

		default:

			ASSERT_TRACE(!is_hidden(*tp),
				es(ftag); es(": "); es(tok_name(*tp)); es(" is hidden");
			);

			goto done;
		}
	}

done:
	ASSERT(*tp &lt; BAD_LAST_TOK &amp;&amp; *tp &gt; 0);

	#if 0 /* This distorts the statistics too much. */
		STATX(ftag);
	#endif

	return tp;

}</t>
<t tx="ekr.20080529093004.476">@ end tok_skip_hidden
Convert a visible token back to a string.  Created strings reside in tok_buffer[], which will be reused on the next call to tok_2string, so the caller is responsible for copying the strings returned by tok_2string to a permanent location.  If the stringize flag is TRUE, strings and character constants are "stringized" by preceding backslashes and " (including the opening and closing " of a string) by a backslash.  If the stringize flag is FALSE, strings and character constants are converted to their "print format" by surrounding them by " or '.
@c

#define MAX_BUF 1000
static char buffer [MAX_BUF+1];

char *
tok_2string(register token * tp, int * length_p, bool stringize_flag)
{
	FTAG("tok_2string");
	register char * ptr = ptr_tok_ptr(tp);
	register int buf_p = 0;
	register token kind = *tp;
	register int length = 0;
	register char delim = 0;

	SL_DISABLE();

	switch(kind) {

	case CHAR_TOK:

char_tok:
		delim = '\'';
		goto char_or_string;

	case ERROR_CHAR_TOK:
	{
		char c = (long) ptr;
		buffer[0] = c;
		buffer[1] = '\0';
		*length_p = 1;
		return buffer;
	}

	case FLOAT_TOK:
	case INT_TOK:
	case LONG_TOK:
		*length_p = strlen(ptr);
		return ptr;

	case HIDDEN_LINE_ADJUST_TOK:
	case HIDDEN_NL_IN_COMMENT_TOK:

		/* These are not even white space! */
		*length_p = 0;
		return "";

		/* Preprocessor special macros. */

	case KM_DATE:
		cvt_date(buffer, MAX_BUF, TRUE);
		*length_p = strlen(buffer);
		return buffer;

	case KM_FILE:
		*length_p = strlen(err_file_name());
		return err_file_name();

	case KM_LINE:
		cvt_long(buffer, MAX_BUF, err_line+err_line_offset);
		*length_p = strlen(buffer);
		return buffer;

	case KM_TIME:
		cvt_time(buffer, MAX_BUF, TRUE);
		*length_p = strlen(buffer);
		return buffer;

	case STRING_TOK:

string_tok:
		delim = '"';

char_or_string:
		length = strlen(ptr);
		if (length + buf_p &gt;= MAX_BUF) {
			error(es("stringized token is too large"));
			*length_p = 0;
			return "";
		}
		else if (!stringize_flag) {
			/* Surround with delim's. */
			buffer[buf_p++] = delim;
			strcpy(buffer + buf_p, ptr);
			buf_p += length;
			buffer[buf_p++] = delim;
			buffer[buf_p++] = '\0';
			*length_p = buf_p;
			return buffer;
		}
		else {
			/* Strinize but do not surround with delims. */
			if (delim == '"') {
				buffer[buf_p++] = '\\';
				buffer[buf_p++] = '"';
			}
			else {
				buffer[buf_p++] = '\'';
			}
			while (*ptr) {
				if (length + buf_p + 4 &gt;= MAX_BUF) {
					error(es("stringized token is too large"));
					*length_p = 0;
					return "";
				}
				else if (*ptr == '"' || *ptr == '\\') {
					buffer[buf_p++] = '\\';
					buffer[buf_p++] = *ptr++;
				}
				else {
					buffer[buf_p++] = *ptr++;
				}
			}
			if (delim == '"') {
				buffer[buf_p++] = '\\';
				buffer[buf_p++] = '"';
			}
			else {
				buffer[buf_p++] = '\'';
			}
			*length_p = buf_p;
			return buffer;
		}

	case WIDE_CHAR_TOK:
		buffer[buf_p++] = 'L';
		goto char_tok;

	case WIDE_STRING_TOK:
		buffer[buf_p++] = 'L';
		goto string_tok;

	case WS_NL_TOK:			/* Bug fix: 5/1/93. */
	case WS_BLANKS_TOK:
	case WS_COMMENT_TOK:
		*length_p = 1; /* White space converts to a blank. */
		return " ";

	default:
		if (is_id(kind) || kind == IDX_TOK) {
			*length_p = strlen(((spell_node *) ptr) -&gt; spell_name);
			return ((spell_node *) ptr) -&gt; spell_name;
		}
		else if (is_hidden(kind)) {
			*length_p = 0;
			return "";
		}
		else {
			*length_p = strlen(tok_name(kind));
			return tok_name(kind);
		}
	}

}</t>
<t tx="ekr.20080529093004.477">/*
	CC2: tokenizing pass.

	Scan the input buffer, adding to the token list, the spelling table and
	string space blocks.  This routine is called in a variety of contexts.

	The input block must end with a IO_EOF_CHAR character.

	source:  CCtokize.c
	started: September 25, 1991
	version:
		December 31, 1994.
			Bug fix:  eat + or - 
		September 4, 1994.
			Folded a float expression by hand to work around a compiler bug.
		August 27, 1994.
			Return regular STRING_TOK and CHAR_TOK for wide characters.
			(There's no difference anyway and the compiler doesn't handle wide variants.)
		July 31, 1993.
			sl_theTicks is referenced only if SHERLOCK is #defined.
		July 19, 1993.
			Allow constants of the form nnnExxx.
			(The e starts a float--it is not an erroneous hex digit!)
		June 6, 1993.
			Bug fix: &gt;&gt;= was not not being recognized properly.
		May 23, 1993.
			Create a WS_COMMENT_TOK for single-line comments instead of ignoring them.
		September 29, 1992.
			Changed (double) 60 * 1000 to ((double) 60) * 1000 to remove warning.
		September 17, 1992.
			Fixed bugs in '&lt;' and '&gt;' logic.
		July 3, 1992
			Added tok_hash and tok_enter routines.
		June 4, 1992
			Eliminated spell_union.
		June 1, 1992
			Name changed to tokize.c for compatibility with short DOS file names.
			Simplified next_string macro.
			Renamed tresreve_macro to tok_protect.
			New tok_init_hash_tab, tok_reinit_stats routines.
			New tok_dump_speed, tok_dump_stat routines.
		May 29, 1992
			Eliminated most treserve_macro calls!
			(The calls to treserve_macro now occur inside the put_xxx_macros.)
			Added put_small, put_id, put_ptr and put_val abbreviations.
		May 28, 1992
			Replaced strp by str_ptr.
			Replaced string statistics by global statistics.
			Eliminated sreserve_macro.
			Replaced scopy_macro and sbig_copy_macro by str_copy2block routine.
			Print tokize_speed only for outer files.
			string_start and string_length are now register variables.
		May 19, 1992
			Added more ASSERT's.
			Added defensive code to initialize avail fields of blocks.
		May 11, 1992
			Eliminate error for missing floating exponent.
		May 7, Added treserve_macro to init code.
		May 6, 1992
			Create ERROR_MESSAGE_TOK on errors.
		May 3, 1992
			Added END_PROG_TOK.
		April 25, 1992
			sblocks param added to sreserve_macro.
		April 24, 1992
			All "error characters" converted to ERROR_TOK's.
		April 17, 1992
			Replaced #ifdef TOK_FULL_WS by if (arg_full_ws_flag).
		April 16, 1992
			Replaced WS_NEWLINES_TOK by HIDDEN_LINE_ADJUST_TOK.
		April 11, 1992
			Test for is_ws in case '&lt;' rather than individual tokens.
		April 8, 1992
			Added WS_NEWLINES_TOK after comments.
		April 7, 1992
			Changed tokize_m_v tracepoint to tokize_obj_v.
			Removed ftag param from all macros.
			Added tentries param to treserve_macro and all put_xxx_tok macros.
		April 1, 1992
			Installed ASSERT_TRACE macros.
		March 29, 1992
			Handle POUND_POUND_TOK.
			Made POUND_TOK a pointer tok.
		March 24, 1992
			Use tok_save_params_macro and tok_restore_params_macro.
			Various types made global.
			hwaste statastic eliminated.
		March 17, 1992.
			Added FTAG logic.
			Changed name of sym_lookup* to tok_lookup*
		March 4, 1992
			Installed new object routines.
		February 26, 1992:
			Insert HIDDEN_END_FILE_TOK if fip != NULL.
		February 19, 1992.
		February 14, 1992:
			retain spelling table after this routine exits.
			eliminate unbound variables from macros.
			tokize now returns first_token, not first_token_block.
		January 29, 1992:
			tp argument added to put_small_tok, put_big_tok, next_tok.
			( ) { } [ ] operators made big_ops.
			hash table made global and inited only on first entrance.
			hash_blocks created.
			added attribute byte to the spelling header.
		January 28, 1992:
			NO_OBJECTS eliminated: it does not affect speed.
			use CC2_FULL_WS instead of DO_FULL_WS
			add obj_new_type, change obj_alloc to obj_base_alloc.
		January 17, 1992;
		October 23, 1991;
*/

&lt;&lt; CCtokize #includes &gt;&gt;
&lt;&lt; CCtokize declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.478">#include "CC.h"

#include "CCarg.h"
#include "CCmem.h"
#include "CCtokens.h"
#include "CCtokize.h"

#include &lt;LIBio.h&gt;
#include &lt;LIBlist.h&gt;
#include &lt;LIBobj.h&gt;

#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.479">/*
	Define globals owned by this file.
*/
token *	tok_first_token = NULL;	/* First token of the outer file. */

/* Global token statistics. */

long tok_bigs = 0;			/* Number of big tokens. */
long tok_blocks = 0;		/* Number of token blocks. */
long tok_bytes = 0;			/* Total allocated bytes. */
long tok_end_blocks = 0;	/* Number of end block tokens. */
long tok_number = 0;		/* Total number of tokens. */
long tok_smalls = 0; 		/* Number of small tokens. */
long tok_waste = 0;			/* Number of wasted bytes. */

/*
	Define abbreviation macros.  These simplify the appearance of the
	source code and indicate relationships between groups of statements.

	? The 'put_small', 'put_ptr', 'put_id' and 'put_val' macros are
	local versions of put_xxx_tok macros defined in AS2tok.h.
	These allow the tp and tavail parameters to be fully bound in
	the put_xxx_macros without cluttering up the code in this file.

	? The 'next' macro gets a character and updates ws_count.
	 This must be done on *every* character so tabs are handled proplerly.

	? The 'next_number' macro gets the next character of a number.

	? The 'next_string' macro gets the next string character and
	updates the proper statistic depending on string_delim.
*/
#define put_small(a,statistic) \
{\
	TOKIZE_STATS(tok_number++; tok_smalls++; statistic++);\
	MEM_UPDATE_STATS(small_token_stats, SMALL_TOKEN_SIZE);\
	MEM_STATS(\
		token_life -&gt; mem_cur_nodes ++;\
		token_life -&gt; mem_cur_bytes += (SMALL_TOKEN_SIZE));\
	put_small_tok(tp, tavail, a);\
}

#define put_ptr(a,b,statistic) \
{\
	TOKIZE_STATS(tok_number++; tok_bigs++; statistic++);\
	MEM_UPDATE_STATS(ptr_token_stats, BIG_TOKEN_SIZE);\
	MEM_STATS(\
		token_life -&gt; mem_cur_nodes ++;\
		token_life -&gt; mem_cur_bytes += (BIG_TOKEN_SIZE));\
	put_ptr_tok(tp, tavail, a, b);\
}

#define put_id(a,b,statistic) \
{\
	TOKIZE_STATS(tok_number++; tok_bigs++; statistic++);\
	MEM_UPDATE_STATS(id_token_stats, BIG_TOKEN_SIZE);\
	MEM_STATS(\
		token_life -&gt; mem_cur_nodes ++;\
		token_life -&gt; mem_cur_bytes += (BIG_TOKEN_SIZE));\
	put_id_tok(tp, tavail, a, b);\
}

#define put_val(a,b,statistic) \
{\
	TOKIZE_STATS(tok_number++; tok_bigs++; statistic++);\
	MEM_UPDATE_STATS(val_token_stats, BIG_TOKEN_SIZE);\
	MEM_STATS(\
		token_life -&gt; mem_cur_nodes ++;\
		token_life -&gt; mem_cur_bytes += (BIG_TOKEN_SIZE));\
	put_val_tok(tp, tavail, a, b);\
}

#define next(statistic) { c = *ip++; ws_count++; TOKIZE_STATS(statistic++;) }

#define next_number() { next(number_chars); string_length++;}

#define next_string()\
	if (string_delim == '"') { next(string_chars); }\
	else { next(char_constant_chars); }

/*
	Define slightly quicker versions of &lt;ctype.h&gt; macros.
*/
#undef isalpha
#undef isspace
#undef isdigit
#undef isxdigit

#define isalpha(c) (((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z') || ((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'Z'))
#define isspace(c) ((c) == ' ' || (c) == '\t' || (c) == '\n' || (c) == '\f' || (c) == '\v' )
#define isdigit(c) ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9')
#define isxdigit(c) (isdigit(c) || ((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'f') || ((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'F'))

/*
	Function prototypes of internal routines.
*/
static void	stats1			(char * title, long tokens, long chars);
static void	tok_dump_speed	(long ticks, long start_newlines);

/*
	Define globals owned by this module.
*/
#define SPELL_PRIME 1009	/* The size of the spelling hash table. (It should be prime) */

spell_node **sym_hash_tab = NULL;	/* Global spelling hash table. */

/*
	The following statistics are always kept in case Sherlock is enabled.
*/
static long	input_chars = 0;	/* Number of input characters. */
static long	newlines = 0;		/* Number of newlines. */

#ifndef PRODUCTION
	static long	junk = 0;			/* Ignored statistic. */
	static long	found_ids = 0;		/* Id's found in searches. */
	static long	bad_chars = 0;
	static long	begin_prog_tokens = 0;
	static long	char_constants = 0;
	static long	char_constant_chars = 0;
	static long	comments = 0;
	static long	comment_chars = 0;
	static long	end_prog_tokens = 0;
	static long	error_tokens = 0;
	static long	ids = 0;
	static long	id_chars = 0;
	static long	id_found_chars = 0;
	static long	ints = 0;
	static long	file_names = 0;
	static long	file_name_chars = 0;
	static long	floats = 0;
	static long	long_ints = 0;
	static long	newline_toks = 0;
	static long	number_chars = 0;		/* Includes ints, floats and long ints. */
	static long	regulars = 0;
	static long	regular_chars = 0;
	static long	strings = 0;
	static long	string_chars = 0;
	static long	tokens = 0;
	static long	total_chars = 0;
	static long	tot_strings = 0;
	static long	tot_string_chars = 0;
	static long	wide_chars = 0;
	static long	wide_strings = 0;
	static long	ws = 0;
	static long	ws_chars = 0;
	
#endif

</t>
<t tx="ekr.20080529093004.480">/*
	Create a token block from the input block.
	Return a pointer to the first token of the first token block.

	The last token created depends on skip_flag:
		TRUE:	the last token is HIDDEN_SKIP_TOK(skip_tp);
		FALSE:	the last token is HIDDEN_END_FILE_TOK(return_fip);

	This code also creates string blocks and symbol table blocks.
*/
token *
tokize(
	io_mem_block * input_block,		/* Descriptor for input block. */
	file_info_node * return_fip,	/* For HIDDEN_END_FILE_TOK. */
	char * file_name,			/* For HIDDEN_BEGIN_FILE_TOK. */
	bool skip_flag,					/* TRUE: output HIDDEN_SKIP_TOK. */
	token * skip_tp)				/* For HIDDEN_SKIP_TOK. */
{
	&lt;&lt; declare and initialize local variables &gt;&gt;
	&lt;&lt; initialize global variables &gt;&gt;

loop: // The main loop, which must be as fast as possible!
	&lt;&lt; trace the main loop &gt;&gt;
	switch(c) {
		&lt;&lt; cases of the main switch &gt;&gt;
	}
error:
	&lt;&lt; handle errors &gt;&gt;
	goto loop;
done:
	&lt;&lt; output final tokens &gt;&gt;
	&lt;&lt; Save global variables &gt;&gt;
	&lt;&lt; Output dumps and statistics &gt;&gt;

	/* Return a pointer to the first token created by this call. */
	return first_token;
}</t>
<t tx="ekr.20080529093004.481">FTAG("tokize");
FTAGV("-tokize_v");

/*
	Warning: Registers are only assigned as indicated if the Think C
	'automatic register assignment' setting is OFF.
*/

/* The 3 most important A registers. */
register char * ip;				/* Input pointer. */
register token * tp;			/* Token pointer. */
register char * string_start;	/* Start of string. */

/* The 5 most important D registers. */
register char c;			/* The current character. */
register long tavail = 0;	/* Available token chars. */
register int hash;			/* Hash code for id. */
register int string_length;	/* Length of string. */

/* Spelling blocks and the hash table. */
spell_node * spell_p;	/* Spell node pointer. */
spell_node * spell_p2;	/* Temp spell node pointer. */

/* Token blocks and string blocks. */
token * first_token;	/* Start of first token. */

/* Processing of file name tokens. */
token * old_tp;		/* Start of possible file name. */
long old_tavail;	/* Saved tavail for restart. */

/* White space. */
long nl_in_ws = 0;		/* Accumulated newlines in white space. */
token * nl_mark = NULL;	/* Marker to previous newline. */
long ws_count = 0;		/* Count of characters in the current line. */
long start_ws_count;	/* Starting line count. */
int tab_size = 4;		/* Size of a tab. */

/* Errors in tokize. */
char * error_ptr = NULL;	/* defered error message. */
bool error_flag = FALSE;	/* TRUE: an error was seen. */

/* Strings. */
bool wide_flag;		/* TRUE: wide char or string. */
token final_token;	/* token to output (changed by error code. */
char string_delim;	/* " for strings, ' for char constants. */

/* Local statistics. */
long ticks = 0;					/* Ticks spent in tokize. */
long start_newlines = newlines;	/* Starting newline in the current file. */</t>
<t tx="ekr.20080529093004.482">STATB(ftag);
ASSERT(sym_hash_tab);
TOKIZE_STATS(tok_reinit_stats());

/* Point at the start of the input block. */
input_chars = input_block -&gt; mem_length;
ip = input_block -&gt; mem_start;

/*
	Restore local variables from globals.
	Allocate a new token block if none has been allocated.
*/
if (token_life -&gt; mem_ptr == NULL) {
	mem_new_block(0, token_life);
}
ASSERT(token_life -&gt; mem_ptr);
tavail = token_life -&gt; mem_avail;
first_token = tp = token_life -&gt; mem_ptr;

TRACEP(ftagv, es(file_name); enl());

if (!skip_flag) {
	char * p = NULL;

	/* Put in a HIDDEN_BEGIN_FILE_TOK. */
	new_file_string_macro(p, file_name);
	put_ptr(HIDDEN_BEGIN_FILE_TOK, p, begin_prog_tokens);

	/* Put in a dummy newline token. */

	/* Careful: make the mark *after* calling tok_protect_macro. */
	tok_protect_macro(tp, tavail);
	nl_mark = tp;
	put_small(WS_NL_TOK, begin_prog_tokens);
}

/* Initialize c. */
next(bad_chars);

nl_in_ws = 0;</t>
<t tx="ekr.20080529093004.483">#if 0 /* Too Expensive */
	TRACE("tokize_obj_v", obj_checkMem());
#endif

#if 0 /* Much too expensive. */
	#ifdef THINK_C
		if (sl_applEvent(0) == FALSE) {
			end_quit();
		}
	#endif
#endif</t>
<t tx="ekr.20080529093004.484">&lt;&lt; letter cases &gt;&gt;
&lt;&lt; whitespace cases &gt;&gt;
&lt;&lt; slashes or comments cases &gt;&gt;
&lt;&lt; strings and characters constants cases &gt;&gt;
&lt;&lt; '&lt;' and filenames cases &gt;&gt;
&lt;&lt; simple tokens cases &gt;&gt;
&lt;&lt; integer or floating constant cases &gt;&gt;
case IO_EOF_CHAR:
	goto done;
&lt;&lt; default case &gt;&gt;
</t>
<t tx="ekr.20080529093004.485">case 'L':

/* An upper case 'L' may start either a wide string or an id. */
if (*ip == '\'') {

	/* Skip the L */
	next(char_constant_chars);
	
	#if 0 /* Wide chars are the same as normal chars. */
		goto wide_char_constant;
	#else
		goto char_constant;
	#endif
}
if (*ip == '"') {
	/* Skip the L */
	next(char_constant_chars);
	
	#if 0 /* Wide strings are the same as normal strings. */
		goto wide_string_constant;
	#else
		goto string_constant;
	#endif
}

/* Fall through. */

case '_':
case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':
case 'h': case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':
case 'o': case 'p': case 'q': case 'r': case 's': case 't': case 'u':
case 'v': case 'w': case 'x': case 'y': case 'z':
case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':
case 'H': case 'I': case 'J': case 'K': /* L */   case 'M': case 'N':
case 'O': case 'P': case 'Q': case 'R': case 'S': case 'T': case 'U':
case 'V': case 'W': case 'X': case 'Y': case 'Z':

/* Compute the hash code of the identifier. */
hash = 0;
string_start = ip - 1;
string_length = 0;
while (isalpha(c) || isdigit(c) || c == '_') {
	hash *= 3; hash += c; hash %= SPELL_PRIME;
	next(id_chars); string_length++;
}

/* See if the id is already in the spelling table. */

#if 1 /* Faster in-line version. */

for (spell_p2 = sym_hash_tab[hash]; spell_p2 != NULL; spell_p2 = spell_p2 -&gt; spell_next) {
	if (string_length == spell_p2 -&gt; spell_length) {
		int i;
		for (i = 0; i &lt; string_length; i++) {
			if (string_start[i] != spell_p2 -&gt; spell_name[i]) {
				break;
			}
		}

		if (i == string_length) {
			STATS(found_ids++; id_found_chars += string_length);
			put_id(spell_p2 -&gt; spell_token, spell_p2, ids);
			goto loop;
		}
	}
}

#else /* Significantly slower version using tok_lookup. */

spell_p2 = tok_lookup(string_start, string_length, hash);
if (spell_p2 != NULL) {
	STATS(found_ids++; id_found_chars += string_length);
	put_id(spell_p2 -&gt; spell_token, spell_p2, ids);
	goto loop;
}

#endif

/*
	Symbol not found. (It can not be a keyword.)

	Enter the string into the spelling table.
*/
new_file_macro(spell_p, spell_stats)

spell_p -&gt; spell_next = sym_hash_tab[hash]; sym_hash_tab[hash] = spell_p;
spell_p -&gt; spell_length = string_length;
spell_p -&gt; spell_name = mem_str_copy(string_start, string_length);
spell_p -&gt; spell_token = ID_TOK;
spell_p -&gt; spell_macro = NULL;
spell_p -&gt; spell_symbol = NULL;

put_id(ID_TOK, spell_p, ids);
goto loop;
</t>
<t tx="ekr.20080529093004.486">/*
	Handle white space, which may continue into comments.

	If the full_ws command line option is on, return one or more of:

		WS_VTAB_TOK		'\v'
		WS_FF_TOK		'\f'
		WS_NL_TOK		'\n'
		WS_COMMENT_TOK	comments
		WS_BLANKS_TOK	white space with space count.
		WS_TOK			white space

	Otherwise, return one or more of:

		WS_NL_TOK		'\n'
		WS_TOK			white space
*/

case '\r':

	fatal(es("unexpected \\r in tokize"));

case ' ': case '\f': case '\t': case '\n': case '\v':
continue_ws:

if (arg_full_ws_flag) {
	goto continue_full_ws;
}
else {
	goto continue_partial_ws;
}

/*
	Handle a white space character when full_ws option is on.
*/
continue_full_ws:

start_ws_count = ws_count;

for(;;) {

	switch(c) {

	case '\v':
		next(ws_chars);
		start_ws_count = ws_count = 0;
		put_small(WS_VTAB_TOK, ws);
		break;

	case '\f':
		next(ws_chars);
		start_ws_count = ws_count = 0;
		put_small(WS_FF_TOK, ws);
		break;

	case ' ':
		next(ws_chars);
		break;

	case '\t':
		next(ws_chars);
		ws_count--;
		ws_count += (tab_size - (ws_count % tab_size));
		break;

	case '\n':
		next(junk); newlines++;
		start_ws_count = ws_count = 0;

		/* Careful: make the mark *after* calling tok_protect_macro. */
		tok_protect_macro(tp, tavail);
		nl_mark = tp;
		put_small(WS_NL_TOK, newline_toks);
		break;

	default:
		/* A non white-space character. */
		if (ws_count - start_ws_count &gt; 0) {
			ws_count -= start_ws_count;
			put_val(WS_BLANKS_TOK, ws_count, ws);
			ws_count += start_ws_count;
		}
		goto loop;
	}
}

/*
	Handle a white space character when full_ws option is off.
*/

continue_partial_ws:

ASSERT(isspace(c));

while(isspace(c)) {
	if (c == '\n')  {
		next(junk); newlines++;
		nl_in_ws++;
	}
	else {
		next(ws_chars);
	}
}

/* skip the '/' before going to begin_partial_comment. */
if (c == '/' &amp;&amp; *ip == '*') {
	next(ws_chars);
	goto begin_partial_comment;
}
else goto end_partial_ws;</t>
<t tx="ekr.20080529093004.487">/*
	Handle comments or / or /= or //
*/

case '/':

next(regular_chars);
if (c == '*') {
	if (arg_full_ws_flag) {
		goto begin_full_comment;
	}
	else {
		goto begin_partial_comment;
	}
}
else if (c == '=') {
	next(regular_chars);
	put_small(DIV_ASSN_TOK, regulars);
}
else if (c == '/') {

	STATS(comments++);
	STATS(regular_chars--; comment_chars++);

	/* Single-line comment. */

	/*
		5/23/93: Create a WS_COMMENT_TOK so single line-comments will print
		properly in error messages.
	*/
	string_start = ip-2;
	string_length = +2;
	while (c != '\n') {
		string_length++;
		next(comment_chars);
	}

	if (arg_full_ws_flag) {

		/* Output a comment string token */
		put_ptr(WS_COMMENT_TOK, mem_str_copy(string_start, string_length), comments);
	}
}
else {
	put_small(DIV_TOK, regulars);
}
goto loop;

/*
	Handle the start of a comment when the full_ws option is on.
*/

begin_full_comment:

ASSERT(c == '*');

string_start = ip-2;
string_length = +2;
next(comment_chars);
STATS(regular_chars--; comment_chars++);

for(;;) {

	if (c == '\n') {

		/* Output a comment string token */
		put_ptr(WS_COMMENT_TOK, mem_str_copy(string_start, string_length), comments);

		/* Skip the newline and reset the counts */
		next(comment_chars);
		string_start = ip-1;
		string_length = 0;
		newlines++;
		nl_in_ws = 0;

		if (*ip == IO_EOF_CHAR) {
			error_ptr = "File ends in a comment";
			error_flag = TRUE;
			goto error;
		}
		else {
			put_small(HIDDEN_NL_IN_COMMENT_TOK, ws);
		}
	}
	else if (c == '*' &amp;&amp; *ip == '/') {

		int bslashes = 0;
		char * ip2 = ip - 1;

		/*
			Count the backslashes preceding the '*'
			We can't underrun the buffer since we are in a comment.
			The comment ends only if there is an even number of backslashes.
		*/
		while (*--ip2 == '\\') {
			bslashes++;
		}

		if (bslashes &amp; 1) {

			/* The comment continues. */
			next(comment_chars);
			string_length++;
		}
		else {

			/* The comment is over. */
			next(comment_chars);
			next(comment_chars);
			string_length += 2;

			/* Output the closing comment string token */
			put_ptr(WS_COMMENT_TOK,
				mem_str_copy(string_start, string_length), comments);
			nl_in_ws = 0;
			goto loop;
		}
	}
	else {
		next(comment_chars);
		string_length++;
	}

} /* end full comment for loop */

/*
	Handle the start of a comment when -full_ws option is in effect.
	c should be * here.
*/

begin_partial_comment:

ASSERT(c == '*');
STATS(regular_chars--; comment_chars++);

for(;;) {

	/* The first instance of this skips the opening '*' */
	next(comment_chars);

	if (c == '\n') {

		STATS(comment_chars--);
		newlines++;
		nl_in_ws++;

		if (*ip == IO_EOF_CHAR) {
			error_ptr = "File ends in a comment";
			goto error;
		}
	}

	if (c == '*' &amp;&amp; *ip == '/') {

		int bslashes = 0;
		char * ip2 = ip - 1;

		/*
			Count the preceding backslashes.
			We can't underrun the buffer since we are in a comment.
		*/
		while (*--ip2 == '\\') {
			bslashes++;
		}

		/* An even number of preceeding backslashes ends the comment. */
		if (! (bslashes &amp; 1)) {
			next(comment_chars);
			next(comment_chars);

			STATS(comments++);

			if (isspace(c)) {
				goto continue_partial_ws;
			}
			goto end_full_ws;
		}
	}

}/* End partial comment for. */

/* End (at last) of the whitespace code. */

end_partial_ws:
end_full_ws:

if (nl_in_ws == 0) {
	put_small(WS_TOK, ws);
}
else {
	int i;

	/* Output all newlines accumulated during the scan of white space. */
	for (i = 0; i &lt; nl_in_ws; i++) {

		/* Careful: mark the location *after* calling tok_protect_macro. */
		tok_protect_macro(tp, tavail);
		nl_mark = tp;
		put_small(WS_NL_TOK, newline_toks);
	}
	nl_in_ws = 0;
}
goto loop;</t>
<t tx="ekr.20080529093004.488">/*
	Handle both strings and character constants and their wide variants.

	Create an ERROR_MESSAGE_TOK followed by the appropriate variety of
	PARTIAL_STRING_TOK if a newline is seen before the end of the string.

	Recall that compress has already deleted all backslash newlines.
*/

wide_char_constant:

wide_flag = TRUE;
final_token = WIDE_CHAR_TOK;
string_delim = '\'';
STATS(wide_chars++);
goto start_string;

wide_string_constant:

wide_flag = TRUE;
final_token = WIDE_STRING_TOK;
string_delim = '"';
STATS(wide_strings++);
goto start_string;

case '\'':
char_constant:

wide_flag = FALSE;
final_token = CHAR_TOK;
string_delim = '\'';
STATS(char_constants++);
goto start_string;

case '"':
string_constant:

wide_flag = FALSE;
final_token = STRING_TOK;
string_delim = '"';
STATS(strings++);
goto start_string;

start_string:

string_start = ip;
string_length = 0;

/* Skip the opening delim. */
next_string();

for(;;) {

	if (c == string_delim) {

		/* Skip the closing delim. */
		next_string();
		put_ptr(final_token, mem_str_copy(string_start, string_length), junk);
		goto loop;
	}
	else if (c == '\\') {

		/* Skip the back slash. */
		next_string();
		string_length++;

		/* Skip the next character. */
		ASSERT(c != '\n' &amp;&amp; c != IO_EOF_CHAR);
		next_string();
		string_length++;
	}
	else if (c == '\n') {
		goto error_in_string_constant;
	}
	else {
		next_string();
		string_length++;
	}

} /* end string for loop */

/*
	Create an error token followed by an error message token.
*/

error_in_string_constant:

/* Do not make the newline part of the string. */
if (*ip == IO_EOF_CHAR) {
	if (string_delim == '"') {
		error_ptr = "File ends in a string";
	}
	else {
		error_ptr = "File ends in a character constant";
	}
}
else {
	if (string_delim == '"') {
		error_ptr = "String crosses a line";
	}
	else {
		error_ptr = "Character constant crosses a line";
	}
}

switch(final_token) {

case WIDE_STRING_TOK:	final_token = PARTIAL_WIDE_STRING_TOK;	break;
case WIDE_CHAR_TOK:		final_token = PARTIAL_WIDE_CHAR_TOK;	break;
case STRING_TOK:		final_token = PARTIAL_STRING_TOK;		break;
case CHAR_TOK:			final_token = PARTIAL_CHAR_TOK;			break;
default:				fatal(es("bad final token"));

}

put_ptr(final_token, mem_str_copy(string_start, string_length), junk);
goto error;
</t>
<t tx="ekr.20080529093004.489">/*
	The following is a major kludge to handle file names that
	are delimited by &lt; and &gt;.  In effect, these file names
	are strings, but strings which only exist in a very limited
	context.

	If a '&lt;' is seen, we look *backward* in the token file,
	starting with NL_MARK, looking for #define &lt;whitespace&gt;

	If we find that, followed by the current character, we
	create a FILE_NAME_TOK.

	Otherwise, we back up, using old_tp and old_tavail, and
	process a regular '&lt;' token.

	By the way, once we start looking for a FILE_NAME_TOK, a newline
	before the ending '&gt;' is an error which we signal by creating
	a ERROR_MESSAGE_TOK followed by a PARTIAL_FILE_NAME_TOK.

	The alternative to this kludge, namely to have cpp paste
	together a file name from an *arbitrary* sequence of tokens,
	would be an even worse kludge.
*/

case '&lt;':	/* #define&lt;file name&gt; or &lt; or or &lt;= or &lt;&lt; or &lt;&lt;= */

old_tp = tp;
old_tavail = tavail;

/*
	nl_mark points at the previous WS_NL_TOK in the token space.
	Look for POUND_TOK WS_TOK(opt) K_DEFINE WS_TOK(opt) in
	the token space, followed by the current position in the token
	space.  If found, treat the '&lt;' as the start of a file name.
*/

if (nl_mark == NULL) goto do_less_than;
tp = nl_mark;
next_tok(tp);
if (is_ws(*tp)) next_tok(tp);
if (*tp != POUND_TOK) goto do_less_than;
next_tok(tp);
if (is_ws(*tp)) next_tok(tp);
if (*tp != K_INCLUDE) goto do_less_than;

/*
	We have to be *very* careful here.
	old_tp may be BAD_TOK.
*/
tp = next_raw_tok(tp);
while(tp != old_tp &amp;&amp; (is_hidden(*tp) || is_ws(*tp))) {
	tp = tok_next_raw(tp);
}
if (tp != old_tp) goto do_less_than;

/*
	We have found #define &lt;
	Create a FILE_NAME_TOK.
*/

/* The string starts after the &lt; */
string_start = ip;
string_length = 0;

/* Don't put &lt; in the string space */
next(regular_chars);

for(;;) {

	if (c == '&gt;') {
		next(regular_chars);
		if (string_length == 0) {
			put_ptr(ERROR_MESSAGE_TOK, "Missing file name", error_tokens);
		}
		put_ptr(FILE_NAME_TOK,
			mem_str_copy(string_start, string_length), file_names);
		goto loop;
	}
	else if (c == '\n') {
		put_ptr(ERROR_MESSAGE_TOK, "&gt; expected", error_tokens);
		put_ptr(PARTIAL_FILE_NAME_TOK,
			mem_str_copy(string_start, string_length), file_names);
		goto loop;
	}
	else {
		next(file_name_chars);
		string_length++;
	}

} /* End file name for loop */

/*
	We have seen a '&lt;' that is not part of #define &lt;
	Valid tokens are '&lt;', '&lt;&lt;', '&lt;=' or '&lt;&lt;='.
*/

do_less_than:

tavail = old_tavail;
tp = old_tp;
nl_mark = NULL;

/* Eat the *first* '&lt;'. */
next(regular_chars);
if (c == '&lt;') {
	next(regular_chars);
	if (c == '=') {
		next(regular_chars);
		put_small(LSHIFT_ASSN_TOK, regulars);
	}
	else {
		put_small(LSHIFT_TOK, regulars);
	}
}
else if (c == '=') {
	/* Bug fix: 9/17/92. */
	next(regular_chars);
	put_small(LE_TOK, regulars);
}
else {
	put_small(LT_TOK, regulars);
}
goto loop;
</t>
<t tx="ekr.20080529093004.490">/*
	The start of simple tokens.
*/

case '&gt;':	/* &gt; or &gt;= or &gt;&gt; or &gt;&gt;= */

next(regular_chars);
if (c == '&gt;') {
	next(regular_chars);
	if (c == '=') {
		next(regular_chars);
		put_small(RSHIFT_ASSN_TOK, regulars);	/* Bug fix: 6/2/93. */
	}
	else {
		put_small(RSHIFT_TOK, regulars);	/* Bug fix: 6/2/93. */
	}
}
else if (c == '=') {
	/* Bug fix: 9/17/92. */
	next(regular_chars);
	put_small(GE_TOK, regulars);
}
else {
	put_small(GT_TOK, regulars);
}
goto loop;

case '%':	/* % or %= */

next(regular_chars);
if (c == '=') {
	next(regular_chars);
	put_small(MOD_ASSN_TOK, regulars);
}
else {
	put_small(MOD_TOK, regulars);
}
goto loop;

case '=':	/* = or == */

next(regular_chars);
if (c == '=') {
	next(regular_chars);
	put_small(EQUAL_TOK, regulars);
}
else {
	put_small(ASSN_TOK, regulars);
}
goto loop;

case '+':	/* + or ++ or += */

/*
	We can *not* recognize +number here because
	we don't know whether the minus sign is unary or binary.
*/

next(regular_chars);
if (c == '+') {
	next(regular_chars);
	put_small(INC_TOK, regulars);
}
else if (c == '=') {
	next(regular_chars);
	put_small(PLUS_ASSN_TOK, regulars);
}
else {
	put_small(PLUS_TOK, regulars);
}
goto loop;

case '-':	/* - or or -= or -- or -&gt; */

/*
	We can *not* recognize -number here because
	we don't know whether the minus sign is unary or binary.
*/

next(regular_chars);
if (c == '=') {
	next(regular_chars);
	put_small(MINUS_ASSN_TOK, regulars);
}
else if (c == '-') {
	next(regular_chars);
	put_small(DEC_TOK, regulars);
}
else if (c == '&gt;') {
	next(regular_chars);
	put_small(ARROW_TOK, regulars);
}
else {
	put_small(MINUS_TOK, regulars);
}
goto loop;

case '*':	/* * or *= */

next(regular_chars);
if (c == '=') {
	next(regular_chars);
	put_small(STAR_ASSN_TOK, regulars);
}
else {
	put_small(STAR_TOK, regulars);
}
goto loop;


case '!':	/* ! or != */

next(regular_chars);
if (c == '=') {
	next(regular_chars);
	put_small(NE_TOK, regulars);
}
else {
	put_small(NOT_TOK, regulars);
}
goto loop;

case '|':	/* | or |= or || */

next(regular_chars);
if (c == '=') {
	next(regular_chars);
	put_small(OR_ASSN_TOK, regulars);
}
else if (c == '|') {
	next(regular_chars);
	put_small(LOR_TOK, regulars);
}
else {
	put_small(OR_TOK, regulars);
}
goto loop;

case '&amp;':	/* &amp; or &amp;= or &amp;&amp; */

next(regular_chars);
if (c == '=') {
	next(regular_chars);
	put_small(AND_ASSN_TOK, regulars);
}
else if (c == '&amp;') {
	next(regular_chars);
	put_small(LAND_TOK, regulars);
}
else {
	put_small(AND_TOK, regulars);
}
goto loop;

case '^':	/* ^ or ^= */

next(regular_chars);
if (c == '=') {
	next(regular_chars);
	put_small(XOR_ASSN_TOK, regulars);
}
else {
	put_small(XOR_TOK, regulars);
}
goto loop;

case '#':

next(regular_chars);
if(c == '#') {
	next(regular_chars);
	put_ptr(POUND_POUND_TOK, NULL, regulars);
}
else {
	put_ptr(POUND_TOK, NULL, regulars);
}
goto loop;

case '?':

next(regular_chars);
put_small(QUESTION_TOK, regulars);
goto loop;

case ':':

next(regular_chars);
put_small(COLON_TOK, regulars);
goto loop;

case '~':

next(regular_chars);
put_small(TILDE_TOK, regulars);
goto loop;

case ',':

next(regular_chars);
put_small(COMMA_TOK, regulars);
goto loop;

case ';':

next(regular_chars);
put_small(SEMICOLON_TOK, regulars);
goto loop;

case '(':

next(regular_chars);
put_small(LPAREN_TOK, regulars);
goto loop;

case ')':

next(regular_chars);
put_small(RPAREN_TOK, regulars);
goto loop;

case '[':

next(regular_chars);
put_small(LBRACK_TOK, regulars);
goto loop;

case ']':

next(regular_chars);
put_small(RBRACK_TOK, regulars);
goto loop;

case '{':

next(regular_chars);
put_small(LCURLY_TOK, regulars);
goto loop;

case '}':

next(regular_chars);
put_small(RCURLY_TOK, regulars);
goto loop;
</t>
<t tx="ekr.20080529093004.491">/*
	Parse an integer or floating constant.

	Because of token pasting requirements, the created tokens
	contain pointers to the *spelling* of these constants,
	not their value.

	Legal integer forms:	ddd,	0ddd,	0xddd
	Legal float forms:	xxx.yyyE+-zzz

	+-zzz is optional
	one of xxx and yyy may be omitted
	one of . and E+-zzz may be omitted

	Recall that according to the ANSI Standard each token must
	contain the longest possible valid sequence of characters.

	However, at this point there is no such thing as a missing
	character in a numeric token. Consider a macro such as:

		#define ten_to_the_x(x) 10.0E##x

	The token 10.0E would be erroneous by itself, but it is made valid
	by the token pasting.  So just accumulate what we can and hope for the
	best later on.
*/

/*
	We have seen and skipped a plus or minus.
	The current character is '.'
*/

case '.':

if (!isdigit(*ip)) {
	if (*ip == '.' &amp;&amp; *(ip+1) == '.') {
		next(regular_chars);
		next(regular_chars);
		next(regular_chars);
		put_small(DOTS3_TOK, regulars);
	}
	else {
		put_small(DOT_TOK, regulars);
		next(regular_chars);
	}
	goto loop;
}

string_start = ip-1;
string_length = 0;
goto begin_float;

/*
	We have seen and skipped a minus.
	The current character is '.'
*/

case '0':

string_start = ip-1;
string_length = 0;

/* Leading 0 or 0x changes base. */
next_number();

if (c == 'x' || c == 'X') {
	next_number();
	while (isxdigit(c)) {
		next_number();
	}
}
else {
	while (isxdigit(c)) {
		if (c &lt; '0' || c &gt; '7') {
			error_ptr = "Non octal digit in octal constant";
			error_flag = TRUE;
			goto put_int;
		}
		next_number();
	}
}
goto end_int_part;

/* case '0' handled above. */

case '1': case '2': case '3': case '4':
case '5': case '6': case '7': case '8': case '9':

string_start = ip-1;
string_length = 0;

while (isxdigit(c)) {

	/* Bug fix 7/19/93: assume the e starts a floating constant. */
	if (c == 'e' || c == 'E') {
		goto begin_float;
	}

	if (!isdigit(c)) {
		error_ptr = "Hex digit in decimal constant";
		error_flag = TRUE;
		goto put_int;
	}
	next_number();
}

end_int_part:

/* Trailing u, l, ul, or lu terminate the int or long constant. */

if (c == 'l' || c == 'L') {
	next_number();
	if(c == 'u' || c == 'U') {
		next_number();
	}
	goto put_long_int;
}

if (c == 'u' || c == 'U') {
	next_number();
	if (c == 'l' || c == 'L') {
		next_number();
		goto put_long_int;
	}
	else {
		goto put_int;
	}
}

/* Only . or e will continue the constant. */

if (c != '.' &amp;&amp; c != 'e' &amp;&amp; c != 'E') {
	goto put_int;
}

/* c is either '.' or 'e' or 'E' here. */

begin_float:

/* All tokens after here are floats. */

if (c == '.') {
	next_number();
	while (isdigit(c)) {
		next_number();
	}
}

/* Trailing l or f terminate the floating constant. */

if (c == 'l' || c == 'L' || c == 'f' || c == 'F') {
	next_number();
	goto put_float;
}

/*
	Only E, E+ or E- will continue the floating constant.
	Bug fix 12/31/91:
		+ or - here does *not* continue the float.
		0.5+e5 is 0.5 + e5.
		eat the + or - only after the E or -.
*/
if (c == 'e' || c == 'E') {
	next_number();
}
else {
	goto put_float;
}

if (c == '+' || c == '-') {
	next_number();
}
		
if (!isdigit(c)) {

	/*
		99.999% of the time this really will be an error, but do not
		complain now because of the possibility of token pasting.
	*/
	#if 0
		error_ptr = "Missing exponent in floating constant";
		error_flag = TRUE;
	#endif

	goto put_float;
}

/* Scan the exponent. */
while (isdigit(c)) {
	next_number();
}

/* Trailing l or f are possible. */
if (c == 'l' || c == 'L' || c == 'f' || c == 'F') {
	next_number();
	goto put_float;
}
goto put_float;

put_int:

put_ptr(INT_TOK, mem_str_copy(string_start, string_length), ints);
goto end_number;

put_long_int:

put_ptr(LONG_TOK, mem_str_copy(string_start, string_length), long_ints);
goto end_number;

put_float:

put_ptr(FLOAT_TOK, mem_str_copy(string_start, string_length), floats);
goto end_number;

end_number:

if (error_flag) {
	goto error;
}
else {
	goto loop;
}
</t>
<t tx="ekr.20080529093004.492">/*
	Because of stringizing and other weirdnesses,
	there is no such thing here as a "bad input character."

	Convert all other characters to a (big) ERROR_CHAR_TOK.
*/

default:
	put_val(ERROR_CHAR_TOK, (long) c, junk);
	next(bad_chars);
	goto loop;
</t>
<t tx="ekr.20080529093004.493">/*
	An error has been seen and error_ptr points to an error message.

	Create an ERROR_MESSAGE_TOK so cpp can print the message in
	context when the token list is complete.
*/

ASSERT(error_ptr != NULL);
put_ptr(ERROR_MESSAGE_TOK, error_ptr, error_tokens);
error_ptr = NULL;
error_flag = FALSE;
</t>
<t tx="ekr.20080529093004.494">/* Output any remaining newlines. */
{
	int i;
	for (i = 0; i &lt; nl_in_ws; i++) {
		put_small(WS_NL_TOK, newline_toks);
	}
}

/* Output the last token. */
if (skip_flag) {
	put_ptr(HIDDEN_SKIP_TOK, skip_tp, end_prog_tokens);
}
else if (return_fip == NULL) {
	put_small(END_PROG_TOK, end_prog_tokens);

	TRACEP("-tokize_tdump",
		tok_dump_delim2(first_token, END_PROG_TOK, PRINT_HIDDEN_TOKS));
}
else {
	put_ptr(HIDDEN_END_FILE_TOK, return_fip, end_prog_tokens);

	TRACEP("-tokize_tdump",
		tok_dump_delim2(first_token, HIDDEN_END_FILE_TOK, PRINT_HIDDEN_TOKS));
}</t>
<t tx="ekr.20080529093004.495">/*
	Save the global avail pointers in the current blocks.
	These will be restored when tokize is re-entered.
*/
token_life -&gt; mem_avail = tavail;
token_life -&gt; mem_ptr = tp;

TRACEPX(ftag, es(file_name); es(": chars: "); elong(input_chars); enl());
</t>
<t tx="ekr.20080529093004.496">#ifndef PRODUCTION
	ticks = sl_theTicks;
#endif

TRACE("-tokize_tdump1",     tok_dump(tok_first_token, DONT_PRINT_HIDDEN_TOKS));
TRACE("-tokize_tdump_all1", tok_dump(tok_first_token, PRINT_HIDDEN_TOKS));

TOKIZE_STATS(
	TRACE("-tokize_stats",
		/* Ignore include files and command-line arguments. */
		if (!skip_flag &amp;&amp; return_fip == NULL &amp;&amp; input_chars &gt; 100) {
			tok_dump_stats();
		}
	);

	TRACE("-tokize_speed",
		/* Ignore include files and command-line arguments. */
		if (!skip_flag &amp;&amp; return_fip == NULL &amp;&amp; input_chars &gt; 100) {
			tok_dump_speed(ticks, start_newlines);
		}
	);
);</t>
<t tx="ekr.20080529093004.497">@ Print one line of statistics.
@c

static void
stats1(char * title, long tokens, long chars)
{
	bool not_token_flag = (title [0] == '(');
	bool not_char_flag =  (title [1] == '(');

	SL_DISABLE();

	if (not_token_flag) title++;
	if (not_char_flag) title++;

	ecnl();
	epads(title, 25);

	if (not_token_flag) {
		epadparenlong(tokens, 9);
	}
	else if (tokens &gt;= 0) {
		epadlong(tokens, 9);
	}
	else {
		eblanks(9);
	}

	if (not_char_flag) {
		epadparenlong(chars, 9);
	}
	else if (chars &gt;= 0) {
		epadlong(chars, 9);
	}

	if (tokens &gt; 0 &amp;&amp; chars &gt;= 0) {
		epadfrac(chars, tokens, 12);
	}
	enl();
}
</t>
<t tx="ekr.20080529093004.498">@ Output the speed of tokize.
@c

static void
tok_dump_speed(long ticks, long start_newlines)
{
	long nl = newlines - start_newlines;
	// long double d6 = ((double) 60) * 1000;
	long double d6 = 60000.0; // work around a compiler bug
	long double chars_per_min = d6 * (input_chars / (double) ticks2msec(ticks));
	long double lines_per_min = d6 * (nl / (double) ticks2msec(ticks));

	ecnl();
	es("chars/min: "); elong((long) chars_per_min);
	es(" lines/min: "); elong((long) lines_per_min);

	if (arg_full_ws_flag) {
		es(" (+full_ws)");
	}

#ifndef PRODUCTION
	es(" (+Assersions)");
#endif

	enl(); enl();
}
</t>
<t tx="ekr.20080529093004.499">@ Output the tokize statistics.
@c

#ifndef PRODUCTION

void
tok_dump_stats(void)
{
	tokens =

	tok_end_blocks +
	begin_prog_tokens + end_prog_tokens +
	wide_chars + wide_strings +
	regulars + ws + newline_toks + file_names +
	ids + strings + char_constants + ints + long_ints + floats;

	total_chars =

	regular_chars + ws_chars + comment_chars + newlines + file_name_chars +
	id_chars + string_chars + char_constant_chars + number_chars;

	tot_strings =

	 (ids - found_ids) + ints + long_ints + floats +
	 strings + char_constants + wide_chars + wide_strings + file_names;

	tot_string_chars =

	 (id_chars - id_found_chars) + number_chars +
	 string_chars + char_constant_chars + file_name_chars +

	 /* Add for each token: one for the trailing '\0' */

	+ (ids - found_ids) + ints + long_ints + floats +
	strings + char_constants + wide_chars + wide_strings + file_names

	 /*
 		Subtract two for strings and char_constants.
 		(the " or '  or &lt; &gt; are not stored.)
 		Subtract 4 for comments.
	 */

	 - 2*(strings + char_constants + wide_chars + wide_strings + file_names);

	tokens += comments;
	tot_strings += comments;
	tot_string_chars += (comment_chars - 4 * comments);

	sl_edump();

	ecnls(2);
	epads("token type",25);
	epads("tokens", 9);
	epads("chars", 9);
	eblanks(5);
	es("chars/token");
	enl();

	stats1("newlines", newline_toks, newlines);
	stats1("ints", ints, -1);
	stats1("longs", long_ints, -1);
	stats1("floats", floats,  -1);
	stats1("(int + long + float chars",ints+long_ints+floats, number_chars);
	stats1("regular tokens", regulars, regular_chars);
	stats1("ws and not comments", ws, ws_chars);
	stats1(arg_full_ws_flag ? "comments" : "(comments", comments, comment_chars);
	stats1("ids", ids, id_chars);
	stats1("((ids found", found_ids, id_found_chars);
	stats1("((ids not found", ids - found_ids, id_chars - id_found_chars);
	stats1("strings", strings, string_chars);
	stats1("wide strings", wide_strings, -1);
	stats1("char constants", char_constants, char_constant_chars);
	stats1("wide char constants", wide_chars, -1);
	stats1("&lt;file names&gt;", file_names, file_name_chars);
	stats1("end block tokens", tok_end_blocks, -1);
	stats1("begin prog tokens", begin_prog_tokens, -1);
	stats1("end prog tokens", end_prog_tokens, -1);
	stats1("((string table", tot_strings, tot_string_chars);
	stats1("TOTALS", tokens, total_chars);
	stats1("input chars", -1, input_chars);
	enl();
}

#endif /* PRODUCTION */
</t>
<t tx="ekr.20080529093004.500">/*
	Initialize the hash table.
*/
#define create_spell_node_macro(spell_p, name, length, index, hash) \
{\
	new_file_macro(spell_p, keyword_spell_stats);\
	spell_p -&gt; spell_length = length;\
	spell_p -&gt; spell_name = name;\
	spell_p -&gt; spell_token = index;\
	\
	/* Hang the node off the hash table. */\
	spell_p -&gt; spell_next = sym_hash_tab[hash];\
	sym_hash_tab[hash] = spell_p;\
}

#define compute_hash_macro(hash, name) \
{\
	register char * p = name;\
	hash = 0;\
	while (*p) {\
		hash *= 3; hash += *p; hash %= SPELL_PRIME;\
		p++;\
	}\
}

#define compute_hash_and_length_macro(hash, name, length) \
{\
	register char * p = name;\
	hash = 0;\
	length = 0;\
	while (*p) {\
		hash *= 3; hash += *p; hash %= SPELL_PRIME;\
		p++;\
		length++;\
	}\
}

void
tok_init_hash_tab(void)
{
	FTAG("tok_init_hash_tab");
	register spell_node * spell_p;
	register char * string_start;
	register long hash;
	register int tok_index;
	register long string_length;
	STATB(ftag);

	/* Allocate the symbol table. */
	ASSERT(sym_hash_tab == NULL);
	obj_new_macro(sym_hash_tab, SPELL_PRIME * sizeof(spell_node *), "symbol table");

	/* Initialize the table. */
	for (tok_index = 0; tok_index &lt; SPELL_PRIME; tok_index++) {
		sym_hash_tab[tok_index] = 0;
	}

	/*
		Enter keywords into the hash table.
		This must be done after string space is allocted!
	*/
	for (tok_index = 0; tok_index &lt; BAD_LAST_TOK; tok_index++) {

		/* Only enter keywords. */
		if (!is_key(tok_index) &amp;&amp; !is_ppkey(tok_index)) {
			continue;
		}

		/* Enter the keyword as is. */
		string_start = tok_name(tok_index);
		compute_hash_and_length_macro(hash, string_start, string_length);
		{
			char * name = mem_str_copy(string_start, string_length);
			create_spell_node_macro(spell_p, name, string_length, tok_index, hash);
		}
	}

	TICKX(ftag);
}
</t>
<t tx="ekr.20080529093004.501">@ Enter a symbol whose hash is given into the symbol table.  The *caller* is responsible to see that the symbol does not already exist.
@c

#if 0 /* Not used. */
spell_node *
tok_enter(char * string_start, int string_length, long hash)
{
	spell_node * spell_p = NULL;		/* Spell node pointer. */

	/*
		Enter the string into the spelling table.
	*/
	new_file_macro(spell_p, spell_stats);
	spell_p -&gt; spell_next = sym_hash_tab[hash]; sym_hash_tab[hash] = spell_p;
	spell_p -&gt; spell_length = string_length;
	spell_p -&gt; spell_name = mem_str_copy(string_start, string_length);
	spell_p -&gt; spell_token = ID_TOK;
	spell_p -&gt; spell_macro = NULL;

	return spell_p;
}
#endif</t>
<t tx="ekr.20080529093004.502">/*
	Look up the string in the hash table.
*/
spell_node *
tok_lookup(
	register char * string_start,
	register long string_length,
	register long hash)
{
	register spell_node * spell_p;

	ASSERT(sym_hash_tab != NULL);

	for (spell_p = sym_hash_tab[hash]; spell_p != NULL; spell_p = spell_p -&gt; spell_next) {
		if (string_length == spell_p -&gt; spell_length) {
			int i;
			for (i = 0; i &lt; string_length; i++) {
				if (string_start[i] != spell_p -&gt; spell_name[i]) {
					break;
				}
			}

			if (i == string_length) {
				return spell_p;
			}
		}
	}
	return NULL;
}
</t>
<t tx="ekr.20080529093004.503">@ Return the hash code for a symbol.
@c

long
tok_hash(char * s)
{
	register long hash = 0;

	SL_DISABLE();

	while (isalpha(*s) || isdigit(*s) || *s == '_') {
		hash *= 3; hash += *s; hash %= SPELL_PRIME;
		s++;
	}

	return hash;
}
</t>
<t tx="ekr.20080529093004.504">@ Look up the symbol Return a pointer to the spelling node if found. Return NULL if not found.
@c

spell_node *
tok_lookup_hash(char * s)
{
	return tok_lookup(s, strlen(s), tok_hash(s));
}
</t>
<t tx="ekr.20080529093004.505">@ Initialize all the tokize statistics.
@c

void
tok_reinit_stats(void)
{
	input_chars = 0;
	newlines = 0;

#ifndef PRODUCTION
	junk = 0;
	bad_chars = 0;
	begin_prog_tokens = 0;
	char_constants = 0;
	char_constant_chars = 0;
	comments = 0;
	comment_chars = 0;
	end_prog_tokens = 0;
	error_tokens = 0;
	file_names = 0;
	file_name_chars = 0;
	floats = 0;
	found_ids = 0;
	ids = 0;
	id_chars = 0;
	id_found_chars = 0;
	ints = 0;
	long_ints = 0;
	newline_toks = 0;
	number_chars = 0;
	regulars = 0;
	regular_chars = 0;
	strings = 0;
	string_chars = 0;
	tokens = 0;
	total_chars = 0;
	tot_strings = 0;
	tot_string_chars = 0;
	wide_chars = 0;
	wide_strings = 0;
	ws = 0;
	ws_chars = 0;

#endif /* PRODUCTION */

}
</t>
<t tx="ekr.20080529093004.506"></t>
<t tx="ekr.20080529093004.507"></t>
<t tx="ekr.20080529093004.508">/*
	CC2: define compiler globals.

	Use 4-space tabs.

	source:  CCcomp.h
	started: September 15, 1991
	version:
		August 28, 1992.
			Added comp_perm_init.
		May 31, 1992
			Most globals moved to cpp.h.
		March 29, 1992
			Added bound_tp argument to mac_expand.
		March 19, 1992
			Added mac_expand.
		March 14, 1992.
			Added mac_define_string.
		February 25, 1992.
			Added mac_define.
		February 19, 1992.
			Added end_ptr argument to tokize.
		November 14, 1991
*/

/*
	Make sure this header is included only once.
*/

#ifndef comp_h_
#define comp_h_

#ifdef THINK_C
#define _H_comp
#pragma once
#endif

#include "CCtokens.h"

/*
	Compiler globals.
*/
extern char * comp_file_name;	/* Name of current file. */
extern long comp_files;			/* Number of files compiled. */

/*
	Function prototypes for the main passes of the compiler.
*/
void	compile			(void);
void	comp_perm_init	(void);

#endif /* comp_h_ */</t>
<t tx="ekr.20080529093004.509">/*
	CC2: header file for initialization module.

	source:  init.h
	started: November 29, 1990
	version: April 11, 1991
*/

/*
	Make sure this file is included only once.
*/
#ifndef init_h_
#define init_h_

#ifdef THINK_C
#define _H_init
#pragma once
#endif

/*
	Include headers for all modules that must be initialized.
*/

void	init_all	(int argc, char ** argv);
bool	init_again	(void);

#endif /* init_h_ */
</t>
<t tx="ekr.20080529093004.510">/*
	CC: header for CCmain.c.

	source:  CCmain.h.
	started: June 2, 1994.
	version: June 2, 1994.
*/

void main			(int argc, char **argv);
void main_free_all	(void);
void main_quit		(void);
</t>
<t tx="ekr.20080529093004.511">/*
	CC2: header for parser.

	Source: CCparser.h
	Started: May 22, 1992.
	Version:
		August 30, 1994.
			Made eval_fstring global for use by folding routines.
		October 29, 1993.
			Added allow_assn_to_const_flag to ct_type2.
		August 27, 1993.
			Added ct_eq_proto.
		July 19, 1993.
			Added unary_expr_flag to expr1.
		July 13, 1993.
			Changed ct_type2 so it returns a possibly altered expression tree.
		April 11, 1993.
			Added expr_is_const.
		March 18, 1993.
			Made par_list global.
		March 12, 1993.
			Made par_expect global for dcl2.c.
		March 8, 1993.
			Added par_line_ptr.
		January 29, 1993.
			Removed xxx_ETYPE constants and expr_check_type.
			Removed the etype parameter from expr_list.
			Made par_list static.
		January 28, 1993.
			Removed expr_massage and expr_retype.
		January 19, 1993.
			expr_check_type changed to void type.
		November 18, 1992.
			Removed eval_string function and t_value macro
		October 23, 1992.
			Changed the routines in ct.c.
		September 28, 1992.
			Added expr_is_init_const.
		September 18, 1992.
			Removed dcl_msize.
		September 17, 1992.
			Removed dcl_tcopy.
		September 10, 1992.
			Removed dcl_alloc.
			Removed enum offset.
		September 2, 1992.
			Redefined st_enter routines.
			Added par_invalid routine.
		August 30, 1992.
			Defined par_next as a macro.
			Added prototype of tok_par_next.
		August 21, 1992.
			Added st_stats.
		August 16, 1992.
			Added expr_const_int.
		August 6, 1992.
			Converted dcl_nodes to st_nodes.
		August 4, 1992.
			Installed new symbol table routines.
		July 30, 1992.
			Added prototypes for new symbol table routines.
		July 28, 1992.
			Removed par_body function.
			Added par_body_node global variable.
		July 24, 1992.
			New calling sequence for dcl_list.
			Scope param added to all symbol table routines.
			Enabled dcl_definition_flag and dcl_previous_flag.
		July 16, 1992.
			Defined t_value as a macro, not a variable.
		July 5, 1992.
			Changed expr so it returns an expr_node, not an enode.
		June 23, 1992.
			Function prototypes for back end moved to gen.h.
		June 12, 1992.
			Added par_call_1arg.
		June 11, 1992.
			New enum etype enumeration.
			pe_check changed to pe_check_type
		June 9, 1992.
			Definitions of nodes moved to CCnodes.h.
		June 4, 1992.
			C* fields merged into this file.
		May 22, 1992.
*/

/*
	Make sure this file is inluded only once.
*/
#ifndef parser_h_
#define parser_h_

/* CC2tok.h is included by CCnodes.h. */

#include "CCtokens.h"
#include "CCnodes.h"

/*
	Abbreviation macros.
*/
#define t_spell  ( id_tok_ptr(par_token_ptr))
#define t_ptr	 (ptr_tok_ptr(par_token_ptr))

#define t_symbol (t_spell -&gt; spell_name)
#define t_type	 (*par_token_ptr)

#define is(a) (t_type == a)

/*
	Global variables.
*/

	/* var: dcl2.c. */

extern bool dcl_definition_flag;	/* TRUE: function definition seen. */
extern bool dcl_in_function_flag;	/* TRUE: inside a function (use local stream). */
extern bool dcl_initializer_flag;	/* TRUE: parsing an initializer. */

	/* var: par2.c */

extern long par_cur_lab;		/* The current label index. */
extern token * par_token_ptr;	/* Ptr to the current token. */
extern token * par_line_ptr;	/* Ptr to the newline before the current line. */

/*
	Function prototypes.
*/

	/* cc2.c */

void	cc2_quit	(void);

	/* ctype.c */

	/* Define synonyms for allow_assn_to_const_flag flag. */
	#define ALLOW_ASSN_TO_CONST			TRUE
	#define DONT_ALLOW_ASSN_TO_CONST	FALSE

bool		ct_eq		(tnode *t1, tnode *t2);
bool		ct_eq_proto	(snode *s_p1, snode *s_p2);
void		ct_type1	(op1_enode * p);
op2_enode *	ct_type2	(op2_enode * p, bool allow_assn_to_const_flag);
void		ct_type3	(op3_enode * p);

	/* dcl2.c */

snode *	dcl				(int scope);
tnode *	dcl_cast		(void);
snode *	dcl_is_typedef	(void);
snode *	dcl_list		(int scope);
void	dcl_orphan		(tnode *t);
void	dcl_reg_check	(tnode *type, int regtype, char *symbol);

	/* exp2.c */

	/* Define synonyms for comma_ok flag. */
	#define ALLOW_COMMAS		TRUE
	#define DONT_ALLOW_COMMAS	FALSE

	/* Define synonyms for unary_expr_flag. */
	#define UNARY_EXPRESSION		TRUE
	#define ARBITRARY_EXPRESSION	FALSE

enode *	expr				(bool comma_ok);
enode *	expr1				(bool comma_ok, bool unary_expr_flag);
double	eval_fstring 		(char * s);
long	expr_const_int		(bool * err_flag);
bool	expr_is_const		(enode * ep);
bool	expr_is_init_const	(enode * ep);
enode *	expr_list			(void);
uint	expr_strval			(char *d);

	/* fold.c */

enode *	fold (enode * ep);

	/* par2.c */

/*
	Logically par_next belongs in par2.c, but its implementation belongs
	in tokens.c so that new hidden tokens may be more easily added to it.
*/
#define par_next() tok_par_next()
void	tok_par_next	(void);

void	ll_init			(void);
void	par_expect		(token expected_tok);
void	par_invalid		(char * s);
pnode *	par_list		(bool one_flag);
void	par_need		(token the_tok);
bool	par_needend		(token the_tok);
bool	par_needsemi	(void);
void	par_program		(void);
pnode *	par_statement	(void);

	/* st3.c */

void	st_begin_block	(void);
void	st_end_block	(void);
void 	st_enter		(snode * s);
void	st_enter_field	(snode * s);
void	st_enter_tag	(snode * s);
void	st_init			(void);
snode *	st_lookup		(spell_node * spell_p);
snode *	st_lookup_field	(spell_node * spell_p, snode * parent);
snode *	st_lookup_tag	(spell_node * spell_p);
void	st_stats		(void);

#endif /* parser_h_ */
</t>
<t tx="ekr.20080529093004.512"></t>
<t tx="ekr.20080529093004.513">/*
	CC2: Compiler main line.

	source:  CCcomp.c
	Started: September 15, 1991
	Version:
		July 26, 1994.
			Don't print message about detected but not reported notes.
		February 18, 1993.
			New comp_sherlock_adj_stats.
		February 17, 1993.
			Improved comp_sherlock_stats by grouping the traces.
		January 23, 1993.
			Open and close the output stream.
		September 19, 1992.
			Give message but do not abort if a file is not found.
		August 21, 1992.
			Added comp_st_stats.
		July 3, 1992
			Added call to par_init.
		May 26, 1992
			Added call to par_program.
		May 19, 1992
			Added logic for cpp command-line option.
		March 17, 1992
			Added Sherlock - logic.
		March 4, 1992
			Installed new object routines.
		February 6, 1992
			Added call to cpp().
		January 29, 1992:
			Defined global list heads here.
		January 17, 1992;
		November 14, 1991;
*/

/* Always allow Sherlock macros in this file. */
#undef NO_SHERLOCK

&lt;&lt; CCcomp #includes &gt;&gt;
&lt;&lt; CCcomp declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.514">#include "CC.h"

#include "CCarg.h"
#include "CCcomp.h"
#include "CCcpp.h"
#include "CCerr.h"
#include "CCgen.h"
#include "CCmacro.h"
#include "CCmain.h"
#include "CCmem.h"
#include "CCparser.h"
#include "CCpass12.h"
#include "CCregs.h"
#include "CCtokize.h"

#include &lt;LIBio.h&gt;
#include &lt;LIBobj.h&gt;
#include &lt;LIBos.h&gt;
</t>
<t tx="ekr.20080529093004.515">/*
	Global variables owned by this module.
*/
char * comp_file_name = NULL;	/* Name of current file. */
long comp_files = 0;			/* Number of files compiled. */

/*
	Prototypes of internal routines.
*/
static void	count_test				(char *buf);
static void comp_dump_block			(io_mem_block *block);
static void comp_init				(void);
static void	comp_sherlock_report	(void);
static void	comp_sherlock_stats		(void);
static void comp_sherlock_adj_stats	(void);
static void	comp_timer_test			(void);
</t>
<t tx="ekr.20080529093004.516">void
compile(void)
{
	FTAG("compile");
	io_mem_block * input_block = NULL;
	long token_length = 0L;
	char * p = NULL;

	/* Disable context messages until the preprocessor is finished. */
	err_context_flag = FALSE;

	/*
		Bug fix: 9/28/92.
		We can't call main_free_all here because the macro table
		has already been initialized.
	*/

	/* Update the global description variables. */
	comp_files++;
	err_begin_file(arg_in_path);
	comp_file_name = err_file_name();

	TRACEP("-comp_files",
		es("input file: ");  es(arg_in_path); ecnl();
		es("output file: "); es(arg_out_path); ecnl());

	TRACEP("-comp_obj_show",	obj_dump_objects());
	TRACEP("-comp_obj_stat",	obj_dump_stats());

	/* Compiler main line. */

	/*
		Open the input file.
		In the call to io_read_all, lead_char (' ') can be anything except backslash.
	*/
	input_block = io_read_pad_all(arg_in_path, 1, ' ', 3 ,
		IO_EOF_CHAR, NO_CANT_MESSAGE, IO_TEXT_FILE);
	if (input_block == NULL) {
		/* Always report this error. */
		force_error(es("Can not open "); es(arg_in_path));
		return;
	}

	/*
		Open the output file if it exists.
		Otherwise, output is sent to the log file.
	*/
	if (arg_out_path) {

		ASSERT(os_text_file == NULL);
		os_text_file = io_create(arg_out_path, FALSE, IO_TEXT_FILE);
		if (os_text_file == NULL) {
			force_error(es("Can not create "); es(arg_out_path));
			return;
		}
	}

	if (err_verbose) {
		ecnl(); es("Preprocessing "); es(comp_file_name); es("...\n");
	}

	/* Make sure the file ends in a physical newline. */
	p = input_block -&gt; mem_start;

	/* 7/28/93: Make the code more portable.  Allow either '\n' or '\r'. */
	if (
		p [input_block -&gt; mem_length -1] != '\n' &amp;&amp;
		p [input_block -&gt; mem_length -1] != '\r'
	) {
		p [input_block -&gt; mem_length] =  '\n';
		input_block -&gt; mem_length++;
		TRACEP("compile", es("trailing newline added\n"));
	}
	TRACEP("-comp_counttest", count_test(input_block -&gt; mem_start));

	/*
		Pass 1: Eliminate trigraphs and backslash newlines.
	*/
	compress(input_block);
	TRACE("-comp_block_dump", comp_dump_block(input_block));

	/*
		Pass 2:
		o Create the main token block
		o Create the spelling table.
	*/

	tok_first_token = tokize(input_block, NULL, err_fname, END_WITH_EOF_TOK, NULL);

	/* The input block can be freed directly after tokize is finished. */
	obj_free_macro(input_block -&gt; mem_freep);
	obj_free_macro(input_block);

	TRACEPN("-comp_tdump1",     tok_dump(tok_first_token, DONT_PRINT_HIDDEN_TOKS));
	TRACEPN("-comp_tdump_all1", tok_dump(tok_first_token, PRINT_HIDDEN_TOKS));

	/* Preprocess the token block. */
	tok_first_token = cpp(tok_first_token);

	/* Patch ( ) { } [ ] tokens to point at their mates. */

#ifndef PRODUCTION
	tok_scan(tok_first_token);
#endif

	/* Handle +cpp option command-line option. */
	if (arg_cpp_flag) {
		tok_dump(tok_first_token, DONT_PRINT_HIDDEN_TOKS);
	}

	/* Enable context messages now that the preprocessor is finished. */
	err_context_flag = TRUE;

	/* CPP dumps. */
	TRACEPN("-comp_tdump2",     tok_dump(tok_first_token, DONT_PRINT_HIDDEN_TOKS));
	TRACEPN("-comp_tdump_all2", tok_dump(tok_first_token, PRINT_HIDDEN_TOKS));

	/* Handle +cpp_only command-line option. */
	if (arg_cpp_only_flag) {
		goto done;
	}

	/* Parse the program! */
	err_begin_file(arg_in_path);

	if (err_verbose) {
		ecnl(); es("Compiling "); eblanks(4); es(err_file_name()); es("...\n");
	}
	comp_init();
	par_program();
done:

	/* Close the output stream, if it is open. */
	io_close(os_text_file);
	os_text_file = NULL;

	/* Report any hidden errors, but only in vervose mode. */
	if (err_verbose) {

		if (!err_err_flag &amp;&amp; err_count) {
			ecnl(); elong (err_count);
			es(" error"); es( (err_count == 1) ? " was" : "s were");
			es(" detected but not reported.\n");
		}

		if (!err_warn_flag &amp;&amp; err_warning) {
			ecnl(); elong (err_warning);
			es(" warning");es( (err_warning == 1) ? " was" : "s were");
			es(" detected but not reported.\n");
		}


		#if 0 /* Notes don't deserve to be reported here. */
			if (!err_help_flag &amp;&amp; err_help) {
				ecnl(); elong (err_help);
				es(" note"); es( (err_help == 1) ? " was" : "s were");
				es(" detected but not reported.\n");
			}
		#endif
	}

	main_free_all();

	TRACE("-comp_io_stats",
		ecnls(2); es("io_read_chars: ");
		elong(io_read_chars); es(" total characters\n"));
	TRACE("-comp_st_stats", st_stats());
	TRACE("-comp_all_sherlock_stats", SL_DUMP());
	TRACE("-comp_sherlock_adj_stats", comp_sherlock_adj_stats());

	TRACE("-comp_sherlock_stats", comp_sherlock_stats());
}
</t>
<t tx="ekr.20080529093004.517">@ Print a block.
@c

static void
comp_dump_block (io_mem_block * block)
{
	register int i;
	register char * p = block -&gt; mem_start;

	for (i = 0; i &lt; block -&gt; mem_length; i++) {
		echar(*p++);
	}
}
</t>
<t tx="ekr.20080529093004.518">@ Initialize the compiler for another file.
@c

static void
comp_init(void)
{
	FTAG("comp_init");
	STATB(ftag);

	/* No function active yet. */
	dcl_in_function_flag = FALSE;
	dcl_definition_flag = FALSE;
	ll_init();
	reg_init();
	gen_init();

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.519">@ Initialize all of the parser's dynamic data with permanent lifetime. This routine must be called only once.
@c

void
comp_perm_init(void)
{
	FTAG("comp_perm_init");
	static bool init_flag = FALSE;
	STATB(ftag);

	ASSERT(init_flag == FALSE);
	init_flag = TRUE;

	reg_perm_init();
	gen_perm_init();
	st_init();

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.520">static void
comp_sherlock_adj_stats(void)
{

	#ifndef PRODUCTION
		sl_use_adjust_flag = TRUE;
		comp_sherlock_report();
	#endif

}
</t>
<t tx="ekr.20080529093004.521">static void
comp_sherlock_report(void)
{

#ifndef PRODUCTION
	sl_dump_start();
	sl_dump_header(TRUE);

	sl_dump_subtotal_start();
		sl_dump_name("comp_init");
		sl_dump_name("comp_perm_init");
		sl_dump_name("init_all");
		sl_dump_name("str_eq");				/* ! */
		sl_dump_name("tok_scan");			/* A benchmark: only in non-production. */
	sl_dump_subtotals();

	sl_dump_subtotal_start();				/* Corresponds to the "Reading" trace. */
		sl_dump_name("io_open");
		sl_dump_name("io_read");
		sl_dump_name("io_read_all");
	sl_dump_subtotals();

	sl_dump_subtotal_start();				/* Corresponds to the "Preprocessing" trace. */
		sl_dump_name("compress");
		sl_dump_name("tokize");
		sl_dump_name("cpp");
		sl_dump_name("inner_cpp");
		sl_dump_name("skip_lines");
		sl_dump_name("skip_past");
		sl_dump_name("mac_define");
		sl_dump_name("mac_define_string");
	sl_dump_subtotals();

	sl_dump_subtotal_start();				/* Parting of the "Compiling" trace. */
	  	sl_dump_name("dcl");
		sl_dump_name("dcl_enum");
		sl_dump_name("dcl_fbody");
		sl_dump_name("dcl_finish");
		sl_dump_name("dcl_head");
		sl_dump_name("dcl_head_sclass");	/* ! */
		sl_dump_name("dcl_head_tmods");		/* ! */
		sl_dump_name("dcl_head_type");		/* ! */
		sl_dump_name("dcl_list");
		sl_dump_name("dcl_post");
		sl_dump_name("dcl_proto");
		sl_dump_name("dcl_struct_union");
		sl_dump_name("dcl_tail");			/* ! */
		sl_dump_name("dcl_tail1");
	sl_dump_subtotals();

	sl_dump_subtotal_start();				/* Parting of the "Compiling" trace. */
		sl_dump_name("eval_string");
		sl_dump_name("expr");
		sl_dump_name("expr1");
		sl_dump_name("expr_const_int");
		sl_dump_name("expr_cprim");
		sl_dump_name("expr_list1");
		sl_dump_name("expr_prim");
		sl_dump_name("expr_reduce");
	sl_dump_subtotals();

	sl_dump_subtotal_start();				/* Parting of the "Compiling" trace. */
		sl_dump_name("par_outer_dcl");
		sl_dump_name("par_program");
		sl_dump_name("par_block");
	    sl_dump_name("par_list");
		sl_dump_name("par_statement");
		sl_dump_name("st_enter");
		sl_dump_name("st_lookup");
		sl_dump_name("tok_par_next");
		sl_dump_name("tok_skip_hidden");
	sl_dump_subtotals();

	sl_dump_subtotal_start();				/* Parting of the "Compiling" trace. */
		sl_dump_name("g_args");
		sl_dump_name("gen_block");
		sl_dump_name("gen_e1");
		sl_dump_name("gen_expr");
		sl_dump_name("gen_fbody");
		sl_dump_name("gen_list");
		sl_dump_name("gen_outer_expr");
		sl_dump_name("peep_hole");
	sl_dump_subtotals();

	sl_dump_subtotal_start();
		sl_dump_name("obj_balloc");
		sl_dump_name("obj_calloc");
		sl_dump_name("obj_free");
	    sl_dump_name("obj_free_check");
	    sl_dump_name("obj_new");
	sl_dump_subtotals();

	if (!arg_no_out_flag) {						/* Parting of the "Compiling" trace. */
		sl_dump_subtotal_start();
			sl_dump_name("io_putc");
			sl_dump_name("io_puts");
			sl_dump_name("io_write");
			sl_dump_name("lib_err_context");	/* prints context lines in output file. */
			sl_dump_name("tok_scan_file");
			sl_dump_name("tok_scan_line");
		    sl_dump_name("out_anode");			/* !!! */
		    sl_dump_name("out_cinode");			/* !!! */
		    sl_dump_name("out_cnode");
		    sl_dump_name("out_constant");
		    sl_dump_name("out_decl");
		    sl_dump_name("out_function");
		    sl_dump_name("out_list");
	    sl_dump_subtotals();
    }

    sl_dump_subtotal_start();			/* Corresponds to the "Closing" trace. */
   		sl_dump_name("io_close");		/* The actual write happens at closing time. */
	    sl_dump_name("io_close_all");
		sl_dump_name("io_close_stream");
		sl_dump_name("comp_free_all");
	sl_dump_subtotals();

	sl_dump_totals();
#endif /* n PRODUCTION */

}
</t>
<t tx="ekr.20080529093004.522">@ Print a summary of key Sherlock stats.
@c

static void
comp_sherlock_stats(void)
{
	#ifndef PRODUCTION
		sl_use_adjust_flag = FALSE;
		comp_sherlock_report();
		sl_use_adjust_flag = TRUE;
	
	#endif
}
</t>
<t tx="ekr.20080529093004.523">@ Test how long it takes to scan through the file buffer.
@c

static void
count_test(register char *buf)
{
	FTAG("count_test");
	unsigned long count = 0;
	register char c = 0;

	if (buf != NULL) {

		SL_ON(ftag);
		STATB(ftag);
		while (c = *buf++) {
			count++;
		}
		TICKX(ftag);
		eulong(count); enl();
	}
}
</t>
<t tx="ekr.20080529093004.524">@ Timer test.
@c

static void
comp_timer_test(void)
{
	FTAG("comp_timer_test");
	long k = 0;
	extern long VIA_ticks(void);

	STATB(ftag);

	for (k = 0; k &lt; 5; k++) {
			long i;
			long j;

			/* Wait a while.*/
			for (i = 0; i &lt; 1000000; i++) {
				j = 25;
			}
			ecnl(); es("ticks: "); ehex(VIA_ticks()); enl();
	}

	TRACEPX(ftag, es("ticks: "); ehex(VIA_ticks()); enl());
}
</t>
<t tx="ekr.20080529093004.525">/*
	CC2: declaration parser.

	To do:
	? Declare s_p in dcl_head_tmods after seeing whether extern or static is present.
	  (This might allow storage to be reclaimed after each function.)
	? Missing dcls of old-style formals should default to int and
	  give a delayed warning instead of a delayed error.
	  (This is low priority since old_stlye formals are on their way out anyway.)

	Source:  CCdcl.c
	Started: October 21, 1985
	Version:
		August 30, 1994.
			Bug fix: Set t -&gt; tsize of enums to INT_SIZE in dcl_enum.
		August 27, 1994.
			Moved initializer code from dcl_finish to dcl_tail.
			This is required so that the tag name is known when
			an initializer is processed.  For example,
				struct s { void * f } = (&amp;s.f};
		June 10, 1994.
			Bug fix to dcl_cast.  Change CAST_TYPE to CAST_SCOPE(!)
			This kind of pun is no longer possible with the unified tok_info array.
		July 19, 1993.
			Bug fix to dcl_head_type.
		July 5, 1993.
			Added code to pad all fields of a struct to an even number of bytes,
			except char fields immediately followed by a second char field.
		July 2, 1993.
			Bug fix: Changed dcl_init_finish to correctly count the elements of
			an initializer for an array of structs.
			HOWEVER, this code is assumes the initializer for an array of structs
				uses a consistent style of braces.
		June 22, 1993.
			Bug fix to dcl_check_type: the ttype field is overloaded for
				structs/unions and enums.  Do not follow it!
		May 25, 1993.
			Removed unused scope parameter from dcl_arrays, dcl_enum and dcl_init_finish.
			Converted dcl_size_array to a void routine.
		May 5, 1993.
			Printed copy sent to tuple
		May 4, 1993.
			Reset dcl_proto_flag for declarations of pointers to functions.
			Implicitly declare Think C low-memory variables to be extern.
			(This eliminates the definitions of these variables.)
		May 2, 1993.
			Added static to function *definitions* of static prototypes.
		April 26, 1993.
			Do s_set_defined for function definitions or prototypes in the main file.
			This is a workaround to suppress IMPORTS of all functions defined in a file.
		April 13, 1993.
			Added calls to p_set_line_count_macro.
		March 31, 1993.
			Changed dcl_init_any_list to allow non-constant initializers for auto vars.
		March 25, 1993.
			New dcl_size_array routine.
			New dcl_check_type routine.
			Removed dcl_post routine.
			Merged dcl_tail and dcl_tail1 routines.
		March 24, 1993.
			Set s_set_proto in dcl_proto.
		March 14, 1993.
			Removed dcl_init1, dcl_init_list, dcl_init_blist, dcl_init_expr.
			(All these have been replaced by dcl_init_any_list.)
			Added dcl_init_any_list and dcl_init_finish.
		March 3, 1993.
			Changed dcl_size_struct to allow undefined elements.
			Changed ASSERT in dcl_struct_union to an error message.
		March 2, 1993.
			Enum constants do not inherit the typedef smod.
			(Added dcl_proto_flag kludge to make this work.)
		February 15, 1993.
			Bug fix: set dcl_initializer_flag in dcl_init_blist, not dcl_init_expr.
		February 12, 1993.
			Added dcl_initializer_flag.
			(This is used to suppress labels for big initializer constants.)
		February 7, 1993.
			Bug fix: s_set_code(s_p) done in dcl_finish.
			(s_is_code is now true for function prototypes or functions.)
		January 30, 1993.
			Set s_set_su_elem(s_p) in dcl_size_struct and dcl_size_union.
		January 29, 1993.
			Fixed bug in dcl_arrays.
		January 26. 1993.
			Replaced ENUM_ITYPE with EXPR_ITYPE.
		January 12, 1993.
			Use s_set_array in dcl_finish.
		December 8, 1992.
			Replaced bit operations on tmods with access macros.
		November 14, 1992.
			Added BRACE_ITYPE inode to dcl_init_blist.
		September 26, 1992.
			Called st_begin_block and st_end_block in dcl_fbody to
				give formal parameters their own name scope.
		September 23, 1992.
			Call ll_init() before parsing the body of a function.
		September 19, 1992.
			Fixed pointer bug in dcl_init_list.
		September 18, 1992.
			Moved dcl_msize to expr.c.
		September 10, 1992.
			Removed dcl_alloc.
			Added dcl_size_struct and dcl_size_union.
		September 8, 1992.
			Allow array dimensions after prototypes.
			Added function_t argument to dcl_finish.
			Added support for un-named bit fields.
		September 3, 1992.
			Added recurse_flag to dcl_tail and dcl_finish.
		September 1, 1992.
			Renamed and alphabatized routines.
		August 15, 1992.
			Added calls to st_begin_block and st_end_block.
		August 3, 1992.
			Added processing of 'cdecl' and 'pascal' extended keywords.
		July 23, 1992.
			Created dcl function.
		June 14, 1992.
			Created dcl_arrays and dcl_proto.
			Removed regtype param from dcl_tail.
		June 11, 1992.
			Made variable p in dcl_tail a local variable.
		June 8, 1992.
			Converted from C* code.
			Replaced t_symbol by id_tok_ptr(par_token_ptr).
			Used new field names for type nodes.
		March 4, 1992: new object routines installed.
		February 25, 1989: New Sherlock macros added.
*/
&lt;&lt; CCdcl #includes &gt;&gt;
&lt;&lt; CCdcl declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.526">#include "CC.h"
#include "CCarg.h"
#include "CCtarget.h"

#include "CCdump.h"
#include "CCgen.h"
#include "CCmem.h"
#include "CCparser.h"

#include &lt;LIBend.h&gt;

#include &lt;string.h&gt;		/* 1/20/92: for memmove */
</t>
<t tx="ekr.20080529093004.527">/*
	Global variables owned by this module.
*/
bool dcl_in_function_flag = FALSE;	/* TRUE: inside a function (use local stream). */
bool dcl_definition_flag = FALSE;	/* TRUE: par_outer_dcl outputs definition. */
bool dcl_initializer_flag = FALSE;	/* TRUE: parsing an initializer. */

/*
	Local variables of this module.
*/
static bool dcl_body_flag = FALSE;	/* TRUE: start of function body seen. */
static bool dcl_proto_flag = FALSE;	/* TRUE: prototype or function def seen. */

/*
	Internal routines:
*/
static tnode *	dcl_arrays		(snode * s_p, tnode * t);
static void		dcl_check_type	(register tnode *t);
static void		dcl_enum		(snode * s_p, tnode * t);
static tnode *	dcl_finish		(int scope, snode * s_p, tnode *t,
	bool lparen_seen, bool fndef_ok, bool recurse_flag, tnode ** function_t);
static void		dcl_fbody		(snode * s_p);
static tnode *	dcl_head		(int scope, snode * s_p);
static void		dcl_head_sclass	(int scope, snode * s_p);
static void		dcl_head_tmods	(tnode * t);
static tnode *	dcl_head_type	(int scope, snode * s_p, tnode * t);
static void		dcl_init		(int scope, snode * s_p);
static inode *	dcl_init_any_list
	(int scope, snode * s_p, bool outer_brace_flag, int *count);
static void		dcl_init_finish	(snode * s_p);
snode *			dcl_old_formals	(void);
static void		dcl_size_array	(tnode * t);
static ulong	dcl_size_struct	(snode * s_p);
static ulong	dcl_size_union	(snode * s_p);
static tnode *	dcl_struct_union(int scope, snode * s_p, tnode * t);
static tnode *	dcl_tail		(int scope, snode * s_p, tnode * t, bool recurse_flag);
static tnode *	dcl_proto		(int scope, snode * s_p, tnode * t, bool fndef_ok);
</t>
<t tx="ekr.20080529093004.528">@ Parse a single declaration, i.e., one type head and 0 or more type tails separated by commas. In NEW_FORMAL_SCOPE the declaration ends with a comma or a close paren.  Return a *list* of symbol nodes (one for each tail.) linked by the n_next field.  The caller is responsible for eating the final delimiter. However, a function *definition* eats the last '}'. This is signalled by setting dcl_definiton_flag to TRUE in dcl_fbody.
@c

snode *
dcl(int scope)
{
	FTAG("dcl");
	register snode * tail_p = NULL;
	register snode * s_p = NULL;
	tnode * head_type = NULL;
	int head_smods = 0;
	snode root;
	TRACEPB(ftag,
		elistx(es(tok_name(scope));); es("token: "); etok(par_token_ptr));

	/* Set up the root node. This makes appending nodes easier. */
	root . n_next = NULL;
	tail_p = &amp;root;

	/* Create a new default symbol node for the head and first tail. */
	new_snode_macro(s_p, KP_VAR);

	/* Add the symbol to the *end* of the declaration list. */
	root . n_next = s_p;
	tail_p = s_p;

	/* Remember the common head type and head smods. */
	head_type = dcl_head(scope, s_p);
	head_smods = s_p -&gt; smods;
	ASSERT(head_type);

	/*
		Check for a declaration consisting only of '...'
		If so, it has been handled in dcl_head.
	*/
	if (is(DOTS3_TOK)) {
		par_next();
		goto done;
	}

	/*
		Check for a declaration with neither tag nor object.
	*/
	if (is(SEMICOLON_TOK)) {

		int prim = head_type -&gt; tprim;

		/*
			For struct/union we need only a real tag node.
			For enums, we must have both a tag and a declaration list.

			The following are valid:

				struct tag;
				enum tag {a = 1};
				enum {a = 1};

			The following are not valid:

				enum tag;
				struct {int a};
				int;
		*/

		if (
			(prim == STRUCT_TYPE || prim == UNION_TYPE) &amp;&amp;
			head_type -&gt; ttype &amp;&amp; snode_ptr(head_type -&gt; ttype) -&gt; spell
		) {

			/* A named tag exists. */
			s_p -&gt; n_type = KP_NULL_VAR;
			goto done;
		}
		else if (t_is_enum(head_type) &amp;&amp; head_type -&gt; ttype) {

			/* A (possibly unnamed) tag exists. */
			s_p -&gt; n_type = KP_NULL_VAR;
			goto done;
		}
		else {

			/* We don't have to test the scope since we have a semicolon. */
			error(es("missing object name"));
			goto done;
		}
	}

	/* parse a list of tails, until a non-comma */
	for(;;) {

		/*
			Parse the tail.
			Set the ctype and spell fields of the symbol node.
		*/
		s_p -&gt; smods = head_smods;
		dcl_tail(scope, s_p, head_type, FALSE);
		TRACEPN(ftag, es("s_p: "); esnode(s_p); enl());

		/* Check for more tails. */
		if (scope == NEW_FORMAL_SCOPE || scope == CAST_SCOPE || !is(COMMA_TOK)) {
			break;
		}
		else {
			/* Eat the comma. */
			par_next();

			/* Create a new default symbol node for the next tail. */
			new_snode_macro(s_p, KP_VAR);

			/* Add the symbol to the *end* of the declaration list. */
			tail_p -&gt; n_next = s_p;
			tail_p = s_p;
		}
	}

	/* Drop the root node. */
done:

	/* Set the number of lines spanned by the declaration. */
	ASSERT(s_p);
	p_set_line_count_macro(pnode_ptr(s_p), err_line - s_p -&gt; p_line);

	TRACEPX(ftag,
		elistx(es(tok_name(scope))); eret(); edcls(root . n_next); ecnl());
	return root . n_next;

}
</t>
<t tx="ekr.20080529093004.529">@ Parse any array dimensions in a type tail.
@c

static tnode *
dcl_arrays(snode * s_p, tnode * tail)
{
	FTAG("dcl_arrays");
	register tnode * t = NULL;
	bool first_dimension_flag = TRUE;
	TICKB(ftag);
	ASSERT(s_p);

	while (is(LBRACK_TOK)) {

		/* Append an array node at the end of the type list. */
		new_tnode_macro(t, ARRAY_TYPE, INT_SIZE);
		tail -&gt; ttype = t;
		tail = t;

		/* Eat the '[' */
		par_next();

		TRACEPN(ftag, es("after [: token: "); etok(par_token_ptr); ecnl());

		if (is(RBRACK_TOK)) {

			if (first_dimension_flag) {

				if (s_is_formal(s_p)) {

					/* formal array of indefinite dim */
					t -&gt; tprim = POINTER_TYPE;
					t -&gt; tsize = POINTER_SIZE;
				}
			}

			/* Eat the closing bracket. */
			par_next();
			break;
		}
		else {

			bool err_flag;
			long dimension;

			/* Get the dimension. */
			dimension = expr_const_int(&amp;err_flag);
			TRACEPN(ftag, es("dimension "); elong(dimension); enl());

			if (err_flag || dimension &lt; 0) {
				error(es("array dimension must be a positive constant"));
				t -&gt; tdim = 0;
			}
			else {
				t -&gt; tdim = dimension;
			}
		}

		par_need(RBRACK_TOK);
		first_dimension_flag = FALSE;
	}

	STATX(ftag);
	return tail;
}
</t>
<t tx="ekr.20080529093004.530">@ Handle the innards of a cast. Return NULL if not cast.  The opening parenthesis has already been read. This form is also called by expr_sizeof()
@c

tnode *
dcl_cast(void)
{
	FTAG("dcl_cast");
	register tnode * t = NULL;
	register snode * id = NULL;
	int class = 0;
	TICKB(ftag);

	if (is_kdecl(t_type) || dcl_is_typedef()) {

		/* dcl_head *always* returns something. */
		t = dcl_head(CAST_SCOPE, NULL);
		ASSERT(t);
		t = dcl_tail(CAST_SCOPE, NULL, t, FALSE);

		TRACEPX(ftag, eret(); etnode(t); ecnl());
		return t;
	}

	TRACEPX(ftag, eret(); es("NULL\n"));
	return NULL;
}
</t>
<t tx="ekr.20080529093004.531">static void
dcl_check_type(register tnode *t)
{
	FTAG("dcl_check_type");
	TRACEPB(ftag, etnode(t); ecnl());

	if (
		t == NULL ||
		t -&gt; tprim == STRUCT_TYPE || t -&gt; tprim == UNION_TYPE ||
		t_is_enum(t)
	) {

		/* Bug fix: 6/22/93: the ttype field points to the parent for structs/unions/enums. */
		goto done;
	}

	ASSERT_TRACE(t -&gt; tprim != NULL_TYPE, etnode(t));

	if (
		t -&gt; tprim == FUNCTION_TYPE &amp;&amp;
		t -&gt; ttype &amp;&amp; t -&gt; ttype -&gt; tprim == FUNCTION_TYPE
	) {
		error(es("functions may not return a function"));
	}
	else {
		dcl_check_type(t -&gt; ttype);
	}

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.532">@ Parse an 'enum' and enter the enum constants into the symbol table.  s_p represents the (possibly nonexistent) declarator (i.e., object) that may be created as the result of the enum declaration.
@c

static void
dcl_enum(snode * s_p, tnode * t)
{
	FTAG("dcl_enum");
	register snode * tag_p = NULL;	/* The (possibly nameless) enum tag. */
	long enum_val = 0; 				/* The current default value for the enum constant. */
	spell_node * tag_spell = NULL;
	long start_line = err_line;
	STATB(ftag);

	ASSERT(t);
	t -&gt; tprim = INT_TYPE;
	t_set_enum(t);

	if (t -&gt; tsize) {
		error(es("long, short, etc. do not apply to enum"));
		t -&gt; tsize = 0;
	}
	else {
		/* Bug fix: 8/30/94. */
		t -&gt; tsize = INT_SIZE;
	}

	/* Eat the 'enum' */
	par_next();

	/* Remember an optional tag. */
	if (is(ID_TOK)) {
		tag_spell = t_spell;
		tag_p = st_lookup_tag (tag_spell);
		par_next();
	}
	else if (is(LCURLY_TOK)) {
		tag_spell = NULL;
		tag_p = NULL;
	}
	else {
		error(es("tag or enum list expected after 'enum'"));
		goto done;
	}

	/*
		Create a tag snode if it does not exist.
		The tag snode will be nameless if there was no tag.
	*/
	if (tag_p == NULL) {
		new_snode_macro(tag_p, KP_ENUM_TAG);
		tag_p -&gt; spell = tag_spell;
		tag_p -&gt; smods = s_p -&gt; smods;

		/* Enter only named tags into the symbol table. */
		if (tag_spell) {
			st_enter_tag(tag_p);
		}
	}

	/*
		Point to the parent.

		Bug fix: 9/25/92
		Since an enum can be a member of a struct or union, we can not
		use the tdcls field as both a type and a parent field.
		Use the ttype field to point at the type of a struct.
		In effect, the ttype field becomes a union.
	*/
	t -&gt; ttype = (tnode *) tag_p;

	if (!is(LCURLY_TOK)) {
		goto done;
	}

	/* Eat the curly bracket. */
	par_next();

	for (;;) {

		spell_node * spell_p;

		/* Remember the spelling of the enum constant. */
		if (is(ID_TOK)) {
			spell_p = t_spell;
			par_next();
		}
		else {
			error(es("Identifier expected in enum list"));
			break;
		}

		/* Get the enum value if it is has been specified. */
		if (is(ASSN_TOK)) {

			bool err_flag;

			par_next();
			enum_val = expr_const_int(&amp;err_flag);
			if (err_flag) {
				error(es("enum expression must be a constant"));
				enum_val = 0;
			}
		}

		/* Enter the enum value into the symbol table as a constant. */
		{
			tnode * t = NULL;
			snode * id_p = NULL;
			inode * ib_p = NULL;
			enode * ep = NULL;

			/* Create a new symbol node for the enum constant. */
			new_snode_macro(id_p, KP_ENUM_ELEM);
			id_p -&gt; spell = spell_p;
			id_p -&gt; smods = s_p -&gt; smods;

			/* 3/2/93 Bug fix: clear the typedef mod. */
			s_clear_typedef(id_p);

			/* Put the symbol on tag_p's dcl list. */
			id_p -&gt; n_next = tag_p -&gt; dcls;
			tag_p -&gt; dcls = id_p;

			/* Create an integer constant type. */
			new_tnode_macro(t, INT_TYPE, INT_SIZE);
			t_set_const(t);
			t -&gt; ttype = (tnode *) tag_p;

			/* Create an constant expression node to hold the constant. */
			new_enode_macro(ep, sizeof(const_enode), INT_TOK);
			ep -&gt; e_ctype = t;
			econst_long(ep)  = enum_val;

			/* Create an inode for the constant. */
			new_xnode_macro(ib_p, sizeof(inode));
			ib_p -&gt; itype = EXPR_ITYPE;
			ib_p -&gt; i_expr = ep;

			/* Attach the type and init list to the symbol. */
			id_p -&gt; ctype = t;
			id_p -&gt; vlist = ib_p;

			/*
				Enter the enum constant as an *ordinary* symbol.
				(Such constants are neither tags nor struct/union elements.)
			*/
			st_enter(id_p);
		}

		/* Bump the default. */
		enum_val++;

		if (is(COMMA_TOK)) {
			par_next();
		}
		else {
			break;
		}
	}

	par_need(RCURLY_TOK);

done:

	/* Set the number of lines spanned by the enum declaration. */
	ASSERT(tag_p);
	p_set_line_count_macro(pnode_ptr(tag_p), err_line - start_line);

	TRACEPX(ftag,
		es("t: "); etnode(t); ecnl();
		es(", tag snode:"); esnode(tag_p); enl());
}
</t>
<t tx="ekr.20080529093004.533">@ Parse a function body and set the fields of the global par_body_node structure.  Code will be generated by par_outer_dcl using par_body_node.
@c

static void
dcl_fbody(snode * dcls)
{
	FTAG("dcl_fbody");
	TRACEPB(ftag, elistx(esnode(dcls)); es("token: "); etok(par_token_ptr); ecnl());

	/* Allocate all pnodes from the local stream. */
	dcl_in_function_flag = TRUE;

	/* Echo the function name if requested. */
	if (arg_v_func_flag) {
		ecnl(); eblanks(2); es(gen_fname); es("()\n");
	}

	/* Output the start of the function. */
	out_func_head();

	/* Remember the formals. */
	gen_formals = dcls;

	/* Begin the symbol table block for the formals. */
	st_begin_block();

	/*
		Define all formals except void or ...
		All symbols are in their own name space.
	*/
	{
		register snode * dp;

		for (dp = dcls; dp; dp = dp -&gt; n_next) {

			if (dp -&gt; spell) {
				st_enter(dp);
			}
			else if (
				dp -&gt; n_type != KP_VOID_VAR &amp;&amp;
				dp -&gt; n_type != KP_DOTS3
			) {
				/*
					We don't know this is an error until now.
					dcl_proto_line tells where it really happened.
				*/
				delayed_error(dp -&gt; p_line, /* dcl_proto_line, */
					es("missing formal parameter name"));
			}
		}
	}

	/* Initialize the label table for every function. */
	ll_init();

	/* Eat the opening curly bracket of the function. */
	ASSERT(is(LCURLY_TOK));
	par_next();

	/* Check for block declarations. */
	if (is_kdecl(t_type) || dcl_is_typedef()) {

		/*
			Parse the body of the function.

			The difference between this code and the code in par_statement is
			that a new symbol table scope is *not* created for the function body.
			Thus, conflicts between formal parameter and names in the outer
			block of the function body will be detected.
		*/
		block_node * bp = NULL;
		new_pnode_macro(bp, sizeof(block_node), KP_BLOCK);

		/* Parse the block. */
		bp -&gt; block_dcls = dcl_list(BLOCK_SCOPE);
		bp -&gt; block_body = par_list(FALSE);

		gen_parse_tree = pnode_ptr(bp);
	}
	else {
		gen_parse_tree = par_list(FALSE);
	}

	/* Eat the closing bracket of the function. */
	par_need(RCURLY_TOK);

	/* End the symbol table block for the formals. */
	st_end_block();

	/* Allocate nodes from the global stream. */
	dcl_in_function_flag = FALSE;

	TICKX(ftag);
}
</t>
<t tx="ekr.20080529093004.534">@ Parse the final parts of a declaration, i.e., function prototypes, array bounds and initializers. Point function_t in the caller to a FUNCTION_TYPE tnode, if any.  lparen_seen: TRUE if a left paren has just been eaten. fndef_ok:  TRUE if a function definition is valid in this context. recurse_flag: TRUE if this results from a recursive call of dcl_tail.   (If so, initializers are not valid.)
@c

static tnode *
dcl_finish
	(
		int scope, snode * s_p, tnode *tail,
		bool lparen_seen, bool fndef_ok, bool recurse_flag,
		tnode ** function_t
	)
{
	FTAG("dcl_finish");
	bool proto_flag = FALSE;
	TICKB(ftag);

	/* Initialize function_t in the caller. */
	ASSERT(function_t);
	*function_t = NULL;

	/* Parse a prototype if we have already seen the opening paren. */
	if (lparen_seen) {
		tail = dcl_proto(scope, s_p, tail, fndef_ok);
		*function_t = tail;
		if (dcl_body_flag) {
			goto done;
		}
		proto_flag = TRUE;
	}

	/* Check for a bit field after id. */
	if (scope == STRUCT_SCOPE &amp;&amp; is(COLON_TOK)) {

		long bit_val = 0;
		bool err_flag = FALSE;

		/* Eat the colon. */
		par_next();

		s_set_bit_field(s_p);

		bit_val = expr_const_int(&amp;err_flag);
		if (err_flag || bit_val &lt; 0) {
			error(es("bit field width must be a non-negative constant"));
		}

		goto done;
	}

	/* Parse a list of prototypes and array dimensions. */
	for (;;) {

		if (is(LPAREN_TOK)) {
			par_next();
			if (proto_flag) {
				par_invalid("function prototype");
				par_next();
				goto done;
			}
			else {
				proto_flag = TRUE;
				tail = dcl_proto(scope, s_p, tail, fndef_ok);
				s_set_code(s_p);
				*function_t = tail;
				if (dcl_body_flag) {

					/* A function *definition* was seen. */
					s_set_defined(s_p);
					goto done;
				}
				else {

					s_set_proto(s_p);
				}
			}
		}
		else if (is(LBRACK_TOK)) {
			s_set_array(s_p);
			tail = dcl_arrays(s_p, tail);
		}
		else if (is(ASSN_TOK)) {
		
			/*
				The recurse_flag prevents, e.g.,

					int * (*f=5) (void);

				from being valid.
			*/

			if (
				recurse_flag == TRUE ||
				scope == NEW_FORMAL_SCOPE ||
				scope == STRUCT_SCOPE ||
				scope == UNION_SCOPE
			) {
				par_invalid("An initializer");
			}
			
			/* 8/29/94: Bug fix: handled this later. */
			goto done;
		}
		else if (is(LCURLY_TOK) &amp;&amp; proto_flag) {
			dcl_body_flag = TRUE;
			goto done;
		}

	#ifdef THINK_C

		/*
			Handle Think C extension for low memory variables.

			For example:	ProcPtr ExtStsDT[] : 0x2BE;
		*/
		else if (is(COLON_TOK)) {

			enode * ep;

			/* Eat the colon. */
			par_next();

			/* Get the expression. */
			ep = expr(DONT_ALLOW_COMMAS);

			/*
				5/4/93:
				Implicitly make these extern so no definition of them will be created.
			*/
			s_set_extern(s_p);
			goto done;
		}

	#endif

		else {
			goto done;
		}
	}

done:
	TICKX(ftag);
	return tail;
}
</t>
<t tx="ekr.20080529093004.535">@ Parse the head of a declaration.  Return a type tree. A non-NULL type is *always* returned. The default is an int.
@c

static tnode *
dcl_head(int scope, snode * s_p)
{
	FTAG("dcl_head");
	tnode * t = NULL;
	TICKB(ftag);

	/* The default is an auto int. */
	new_tnode_macro(t, INT_TYPE, 0);

	/*
		Special case for '...'
		Leave the DOTS3_TOK so dcl can also handle it.
	*/
	if (is(DOTS3_TOK)) {
		s_p -&gt; n_type = KP_DOTS3;
		t -&gt; tprim = DOTS3_TYPE;
		t -&gt; tsize = 0;
		if (scope != NEW_FORMAL_SCOPE) {
			par_invalid("'...'");
		}
		goto done;
	}

	/* Parse the storage class. */
	dcl_head_sclass(scope, s_p);

	/* Parse the type modifiers. */
	dcl_head_tmods(t);

	/* Parse the base type. */
	t = dcl_head_type(scope, s_p, t);

done:
	TRACEPX(ftag, eret(); eblank(); etnode(t); ecnl());
	return t;
}
</t>
<t tx="ekr.20080529093004.536">@ Handle storage-class specifiers and set s_p -&gt; smods. The default depends on the current scope.
@c

static void
dcl_head_sclass(int scope, snode * s_p)
{
	FTAG("dcl_head_sclass");
	register int sc_count = 0;
	snode dummy_sp;
	TRACEPB(ftag,
		elistx(es(tok_name(scope))); es("token: "); etok(par_token_ptr); ecnl());

	/* Make sure we have a proper target for the s_set_xxx macros. */
	if (s_p == NULL) {
		s_p = &amp;dummy_sp;
	}

	/* Set the default smods. */
	switch(scope) {

	case NEW_FORMAL_SCOPE:
	case OLD_FORMAL_SCOPE:
	case OLD_FORMAL_DEF_SCOPE:

		s_set_auto(s_p);
		s_set_formal(s_p);
		break;

	case FUNCTION_SCOPE:
	case BLOCK_SCOPE:

		s_set_auto(s_p);
		break;

	default:
		s_set_global(s_p);
	}

	for(;;) {

		switch(t_type) {

		case K_AUTO:

			if (
				scope == NEW_FORMAL_SCOPE ||
				scope == OLD_FORMAL_DEF_SCOPE ||
				scope == BLOCK_SCOPE ||
				scope == FUNCTION_SCOPE
			) {
				s_set_auto(s_p);
			}
			else {
				par_invalid("'auto'");
			}

			sc_count++;
			par_next();
			continue;

		case K_EXTERN:

			if (scope == NEW_FORMAL_SCOPE || scope == OLD_FORMAL_SCOPE) {
				par_invalid("'extern'");
			}
			else {
				s_clear_auto(s_p);
				s_set_extern(s_p);
			}

			sc_count++;
			par_next();
			continue;

		case K_REGISTER:

			if (
				scope == NEW_FORMAL_SCOPE ||
				scope == OLD_FORMAL_DEF_SCOPE ||
				scope == BLOCK_SCOPE ||
				scope == FUNCTION_SCOPE
			) {
				s_set_register(s_p);
			}
			else {
				par_invalid("'register'");
			}

			sc_count++;
			par_next();
			continue;

		case K_STATIC:

			if (scope == NEW_FORMAL_SCOPE || scope == OLD_FORMAL_DEF_SCOPE) {
				par_invalid("'static'");
			}
			else {
				s_clear_auto(s_p);
				s_set_static(s_p);
			}

			sc_count++;
			par_next();
			continue;

		case K_TYPEDEF:

			if (scope == NEW_FORMAL_SCOPE ||
				scope == OLD_FORMAL_DEF_SCOPE
			) {
				par_invalid("'typedef'");
			}
			else {
				s_clear_auto(s_p);
				s_set_typedef(s_p);
			}

			sc_count++;
			par_next();
			continue;

		default:
			break;
		}
		break;
	}

	if (sc_count &gt; 1) {
		error(es("more than one storage class specifier in declaration"));
	}
	else if (
		sc_count == 1 &amp;&amp;
		(scope == CAST_SCOPE || scope == STRUCT_SCOPE || scope == UNION_SCOPE)
	) {
		par_invalid("A storage class specifier");
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.537">@ Handle type modifiers.
@c

static void
dcl_head_tmods(tnode * t)
{
	FTAG("dcl_head_tmods");
	bool err_flag = FALSE;
	TICKB(ftag);

	for(;;) {

		switch(t_type) {

		case K_CHAR:

			if (t -&gt; tsize) {
				err_flag = TRUE;
			}
			t_set_char(t);
			par_next();
			continue;

		case K_CONST:

			t_set_const(t);
			par_next();
			continue;

		case K_LONG:

			if (t -&gt; tsize) {
				err_flag = TRUE;
			}

			/*
				6/15/93: Assume we have a long int,
				and remember that we have seen the long keyword so that
				we can handle long double properly later.
			*/
			t_set_long(t);
			t_set_long_dcl(t);
			par_next();
			continue;

#ifdef TARGET_PASCAL_KEYWORD

		case K_PASCAL:
			par_next();
			continue;

#endif

		case K_SHORT:

			if (t -&gt; tsize) {
				err_flag = TRUE;
			}

			t_set_short(t);
			par_next();
			continue;

		case K_SIGNED:

			t_set_signed(t);
			par_next();
			continue;

		case K_UNSIGNED:

			t_set_unsigned(t);
			par_next();
			continue;

		case K_VOLATILE:

			t_set_volatile(t);
			par_next();
			continue;

		default:
			break;
		}

		break;
	}

	if (err_flag) {
		error(es("conflicting lengths specified"));
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.538">@ Parse a base type in a type header.  The base type consists of 1) a typedef tag, 2) a noun (e.g. int), 3) struct or union or 4) an enum.  Anything else, including parentheses, asterisks, brackets or identifiers (except typedef tags) ends the type header.  Set the t_prim and t_size fields in t.
@c

static tnode *
dcl_head_type(int scope, snode * s_p, tnode * t)
{
	FTAG("dcl_head_type");
	TRACEPB(ftag,
		elistx(es(tok_name(scope))); es("token: "); etok(par_token_ptr); ecnl());

	switch(t_type) {

	case K_DOUBLE:

		/* FLOAT_TYPE means float, double or long double. */
		t -&gt; tprim = FLOAT_TYPE;
		if (t_is_long_dcl(t)) {
			t_set_long_double(t);
		}
		else {
			t_set_double(t);
		}

		par_next();
		break;

	case K_ENUM:

		dcl_enum(s_p, t);
		break;

	case K_FLOAT:

		t -&gt; tprim = FLOAT_TYPE;
		t_set_float(t);
		par_next();
		break;

	case K_INT:

		/*
			INT_TYPE means char, short, int or long.
			The tsize field has been set by the t_set_xxx macros.
		*/
		t -&gt; tprim = INT_TYPE;
		/* Bug fix: 3/3/93 */
		if (t -&gt; tsize == 0) {
			t_set_int(t);
		}
		par_next();
		break;

	case K_STRUCT:
	case K_UNION:

		t = dcl_struct_union(scope, s_p, t);
		break;

	case K_VOID:

		t -&gt; tprim = VOID_TYPE;
		t -&gt; tsize = 0;
		if (t -&gt; tsize) {
			error(es("long, short, etc. do not apply to void"));
			t -&gt; tsize = 0;
		}
		par_next();
		break;

	case ID_TOK:	/* A possible typedef id. */
	{

		register snode * s_p2 = NULL;

		/* Eat a typedef tag, but leave a regular id alone. */
		s_p2 = st_lookup(t_spell);

		if (s_is_typedef(s_p2)) {

			/* Attach the meaning of the typedef. */
			TRACEPN(ftag,
				es("typedef tag found: ");
				es(t_spell -&gt; spell_name); enl());

			ASSERT_TRACE(s_p2 -&gt; ctype,
				es("typedef tag has NO TYPE: "); es(t_symbol));

			/*
				*Copy* the typedef type so that we can change the
				type (smods or tdcls) for one typedef'ed id without
				making unwanted changes in other copies.
			*/
			memmove(t, s_p2 -&gt; ctype, sizeof(tnode));
			par_next();
		}
		else if (t -&gt; tprim == INT_TYPE &amp;&amp; t -&gt; tsize == 0) {

			/*
				Bug fix: 7/19/93: simplify the test above.

				We have seen no explicit type.
				The signed and unsigned type modifiers can serve as an int and
				the extern and static storage classes can serve as an int.

				We must wait till this point to do the t_set_int because setting
				t -&gt; size earlier would prevent constructions such as
					unsigned int a;
				from being accepted.
			*/
			if (
				t_is_signed(t)   || t_is_unsigned(t) ||
				s_is_extern(s_p) || s_is_static(s_p)
			) {
				t_set_int(t);
			}
			else {
				/*
					This error message is appropriate for non-functions,
					but according to K&amp;R, second edition,
					"bare" function with no return type are still permitted.

					However, the way I read the Standard,
					it seems that bare functions are *not* allowed:
					either a storage class, or type specifier or qualifier is required.

					The problem is moot at present since CC2 requires prototypes,
					and prototypes must specify a return type.
				*/
				error(es("type name expected at: "); es(t_spell -&gt; spell_name));
			}
		}
		else {

			/* Assume the identifier is the name of a variable. */
		}
		break;
	}

	default:
		break;
	}

	/*
		Bug fix: 7/20/93:

		Make sure a "bare" types gets a proper size.

		This can happen in casts, as in

			int a = sizeof(unsigned);
	*/
	if (
		t -&gt; tprim == INT_TYPE &amp;&amp; t -&gt; tsize == 0 &amp;&amp;
		(
			t_is_signed(t)   || t_is_unsigned(t) ||
			s_is_extern(s_p) || s_is_static(s_p)
		)
	) {
		t_set_int(t);
	}

	ASSERT(t);
	TRACEPX(ftag, eret(); etnode(t); ecnl());
	return t;
}
</t>
<t tx="ekr.20080529093004.539">@ Parse a complete initializer.  Section 3.5.7.  Constraints  "There shall be no more initializers in an initializer list than there are objects to be initialized."  "The type of the entity to be initialized shall be an object type or an array of unknown size."  "All the expressions in an initializer for an object that has static storage duration or in an initializer list for an object that has aggragate or union type shall be constant expressions."  "If the declaration of an identifier has block scope, and the identifier has external or internal linkage, the declaration shall have no initializer for the identifier."  Semantics  "All unnamed structure or union members are ignored during initialization."  "...If an object that has static storage duration is not initialized explicitly, it is initialized implicitly as if every member that has arithmetic type were assigned 0 and every member that has pointer type were assigned a null pointer constant."  "The initializer for a scalar shall be a single expression, optionally enclosed in braces. The initial value of the object is that of the expression; the same type constraints and conversions as for simple assignment apply, taking the type of the scalar to be the unqualified version of its declared type."  "A brace-enclosed initializer for a union object initializes the member that appears first in the declaration list of the union type."  "The initializer for a structure or union object that has automatic storage duration either shall be an initializer list as described below, or shall be a single expression that has compatible structure or union type. In the latter case, the initial value of the object is that of the expression."  The rest of this section deals with initializers for objects that have aggregate or union type.  "An array of character type may be initialized by a character string literal, optionally enclosed in braces. Successive characters of the character string literal (including the terminating zero-valued code if there is room or if the array is of unknown size) initialize the element of the array."  "An array with element type compatible with wchar_t may be initialized by a wide string literal (including the terminating zero-valued code if there is room or if the array is of unknown size) initialize the element of the array."  "Otherwise, the initializer for an object that has aggregate type shall be a brace-enclosed list of initializers for the members of the aggregate, written in increasing subscript or member order; and the initializer for an object that has union type shall be a brace-enclosed list of initializers for the first member of the union."  "If the aggregate contains members that are aggregates or unions, or if the first mmember of a union is an aggregate or union, the rules apply recursively to the subaggregates or contained unions. If the initializer of a subaggregate or contained union begins with a left brace, the initializers enclosed by that brace and its matching right brace initialize the members of the subaggregate or the first member of the contained union. Otherwise, only enought initializers from the list are taken to account for members of the subaggregate or the first member of the contained union; any remaining initializers are left to initialize the next member of the aggregate of which the current subaggregate or contained union is a part."  "If there are fewer initializers in a brace-enclosed list than there are members of an aggregate, the remainder of the aggregate shall be initialized impliciitly the same as objects that have static storage duration."  "If any array of unknown size is initialized, its size is determined by the number of initializers provided for its elements. At the end of its initializer list, the array no longer has incomplete type."
@c

static bool init_message_flag;

static void
dcl_init(int scope, snode * s_p)
{
	FTAG("dcl_init");
	register inode * ip = NULL;
	int count = 0;
	TRACEPB(ftag,
		es(tok_name(scope)); es(" token: "); etok(par_token_ptr));

	/* Eat the initial equal sign. */
	ASSERT(is(ASSN_TOK));
	par_next();

	/* There have been no error messages relating to this initializer. */
	init_message_flag = FALSE;

	/*
		dcl_initializer_flag is used in expr_cprim to
		suppresses labels for big initializer constants.

		We can't generate these constants yet because there
		may be padding in between constants.
	*/
	dcl_initializer_flag = TRUE;
	ip = dcl_init_any_list(scope, s_p, FALSE, &amp;count);
	dcl_initializer_flag = FALSE;

	/* Don't pass through erroneous initializers. */
	if (init_message_flag) {
		ip = NULL;
	}
	else if (ip -&gt; itype == EXPR_ITYPE &amp;&amp; count &gt; 1) {

		ip = NULL;
		if (!init_message_flag) {
			error(es("Lists of initializers must be enclosed in braces"));
		}
	}

	s_p -&gt; vlist = ip;

	TRACEPX(ftag, es("sets s_p -&gt; vlist to: "); einode(s_p -&gt; vlist));
}
</t>
<t tx="ekr.20080529093004.540">@ Parse a list of initializer expressions. Brace-enclosed lists are valid only if outer_brace_flag is TRUE; Set count in the caller to the number of items in the list.
@c

static inode *
dcl_init_any_list(int scope, snode * s_p, bool outer_brace_flag, int * count)
{
	FTAG("dcl_init_any_list");
	inode ip_root;
	register inode * ip_tail = &amp;ip_root;
	STATB(ftag);

	/*
		Parse a list of initializer expressions.
		This list may include other brace-enclosed lists.
	*/
	for(;;) {

		register inode * ip = NULL;

		TRACEPN(ftag,
			es(tok_name(scope));
			es(" token: "); etok(par_token_ptr);
			es(", outer_brace_flag: "); ebool(outer_brace_flag);
		);

		if (is(LCURLY_TOK)) {

			/* Recursively parse the inner brace-enclosed list. */
			inode * inner_ip = NULL;
			int inner_count = 0;

			/* Eat the '{' */
			par_next();

			/* Recursively get the inner list. */
			inner_ip = dcl_init_any_list(scope, s_p, TRUE, &amp;inner_count);

			/* Eat the '}' */
			if (is(RCURLY_TOK)) {
				par_next();
			}
			else {
				if (!init_message_flag) {
					par_expect(RCURLY_TOK);
					init_message_flag = TRUE;
				}
				ip = NULL;
				goto done;
			}

			/* Create a "brace" inode. */
			new_xnode_macro(ip, sizeof(inode));
			ip -&gt; itype = BRACE_ITYPE;
			ip -&gt; i_brace = inner_ip;
			ip -&gt; icount = inner_count;
		}
		else {

			/* Add an single expression node to the current list. */

			enode * ep = expr(DONT_ALLOW_COMMAS);

			new_xnode_macro(ip, sizeof(inode));
			ip -&gt; itype = EXPR_ITYPE;
			ip -&gt; i_expr = ep;
			ip -&gt; icount = 1;

			/*
				Make sure the expression is a constant expression.
				Keep parsing even if an error is found.
			*/

			if (
				ep &amp;&amp;
				!expr_is_init_const(ep) &amp;&amp;
				!s_is_auto(s_p) &amp;&amp;				/* Bug fix: 3/31/93. */
				!init_message_flag
			) {
				init_message_flag = TRUE;
				error(
					es("initializer must be a constant");
					TRACEN(ftag, es(": "); eenode(ep));
				);
			}
		}

		/* Append the newly created inode to the list. */
		ASSERT(ip -&gt; inext == NULL);
		ip_tail -&gt; inext = ip;
		ip_tail = ip;

		/* Increment the count in the caller. */
		(*count)++;

		/* Only a comma can continue the list, and only if we are in braces. */
		if (is(COMMA_TOK) &amp;&amp; outer_brace_flag) {
			par_next();
		}
		else {
			break;
		}

		/* Allow a trailing comma, followed by a close brace. */
		if (is(RCURLY_TOK)) {
			break;
		}
	}

done:

	/* Drop the root node. */
	TRACEPX(ftag, eret(); einode(ip_root . inext); enl());
	return ip_root . inext;
}
</t>
<t tx="ekr.20080529093004.541">@ Complete a declaration of an array based on the size of an initializer.  To repeat the relevant part of Section 3.5.7 of The Standard...  "Otherwise, the initializer for an object that has aggregate type shall be a brace-enclosed list of initializers for the members of the aggregate, written in increasing subscript or member order; and the initializer for an object that has union type shall be a brace-enclosed list of initializers for the first member of the union."  "If the aggregate contains members that are aggregates or unions, or if the first mmember of a union is an aggregate or union, the rules apply recursively to the subaggregates or contained unions. If the initializer of a subaggregate or contained union begins with a left brace, the initializers enclosed by that brace and its matching right brace initialize the members of the subaggregate or the first member of the contained union. Otherwise, only enought initializers from the list are taken to account for members of the subaggregate or the first member of the contained union; any remaining initializers are left to initialize the next member of the aggregate of which the current subaggregate or contained union is a part."  "If there are fewer initializers in a brace-enclosed list than there are members of an aggregate, the remainder of the aggregate shall be initialized impliciitly the same as objects that have static storage duration."  7/2/93:  At present, this only handles fully bracketed subaggregates properly.  This must be a recursive routine to handle subaggregates!
@c

static void
dcl_init_finish(snode * s_p)
{
	FTAG("dcl_init_finish");
	register inode * ip = NULL;
	register tnode * t = NULL;
	TRACEPB(ftag, esnode(s_p); ecs(); einode(s_p -&gt; vlist));

	if (
		s_p == NULL || s_p -&gt; vlist == NULL ||
		s_p -&gt; ctype == NULL || !s_is_array(s_p)
	) {
		goto done;
	}

	ip = s_p -&gt; vlist;
	t =  s_p -&gt; ctype;

	if (t -&gt; tprim != ARRAY_TYPE || t -&gt; ttype == NULL) {
		goto done;
	}

	/* Special case an array of characters. */
	if (t -&gt; ttype -&gt; tprim == INT_TYPE &amp;&amp; t -&gt; ttype -&gt; tsize == CHAR_SIZE) {

		/* See if the initializer is a single string, possibly enclosed in braces. */
		if (
			ip -&gt; itype == BRACE_ITYPE &amp;&amp;
			ip -&gt; icount == 1 &amp;&amp;
			ip -&gt; i_brace -&gt; itype == EXPR_ITYPE &amp;&amp;
			ip -&gt; i_brace -&gt; inext == NULL &amp;&amp;
			ip -&gt; i_brace -&gt; i_expr &amp;&amp;
			ip -&gt; i_brace -&gt; i_expr -&gt; n_type == STRING_TOK
		) {

			/* We have an itializer of the form: char *s[] = { "abc" }; */
			t -&gt; tdim = 1 + strlen(econst_defstr(ip -&gt; i_brace -&gt; i_expr));
			t -&gt; tsize = t -&gt; tdim;

			TRACEPN(ftag,
				es("bracketed string: dimension set to strlen: ");
				elong(t -&gt; tdim));

			/* Simplify the initializer expression by skipping the brace node. */
			s_p -&gt; vlist = ip -&gt; i_brace;
		}
		else if (
			ip -&gt; itype == EXPR_ITYPE &amp;&amp;
			ip -&gt; i_expr &amp;&amp;
			ip -&gt; i_expr -&gt; n_type == STRING_TOK
		) {

			/* We have an initializer of the form: char *s[] = "abc" ; */
			t -&gt; tdim = 1 + strlen(econst_defstr(ip -&gt; i_expr));
			t -&gt; tsize = t -&gt; tdim;
			TRACEPN(ftag,
				es("string: dimension set to strlen: ");
				elong(t -&gt; tdim));
		}
		else {

			/* The initializer is not a single stirng. */
			ulong count = (ip -&gt; itype == BRACE_ITYPE) ? ip -&gt; icount : 1;
			t -&gt; tdim = count;
			t -&gt; tsize = count;
		}
	}
	else if (t -&gt; ttype -&gt; tprim == STRUCT_TYPE) {

		/*
			7/2/93:
			We must scan the list to correctly count the number of structures
			in the array.  For example...

				struct s {int a; int b};
				struct s s_array [] = {
					1, 2,
					{3, 4},
					{0},		-- same as {0, 0}
					5,6,
					7			-- same as {7, 0}
				};

			creates an array of 5 elements, one for each line.
		*/

		ulong elem_count = 0;	/* The number of elements in the struct. */
		ulong array_count = 0;	/* The number of array elements. */

		/* Count the number of elements in the struct. */
		{
			snode * tag_p = (snode *) t -&gt; ttype -&gt; ttype;
			snode * s_p = tag_p -&gt; dcls;
			while(s_p) {
				elem_count++;
				s_p = s_p -&gt; n_next;
			}
		}
		TRACEPN(ftag, es("elem_count: "); eulong(elem_count); enl());

		if (ip -&gt; itype != BRACE_ITYPE) {
			error(es("initializers for structs must appear in braces"));
		}
		else {

			/*
				Testing only:  assume a consistent style of using braces.
				That is, assume all initializers are braceted, or none are.
			*/
			if (ip -&gt; i_brace &amp;&amp; ip -&gt; i_brace -&gt; itype == BRACE_ITYPE) {

				array_count = ip -&gt; icount;
				t -&gt; tdim = array_count;
				t -&gt; tsize = array_count * (t -&gt; ttype -&gt; tsize);
			}
			else {

				array_count = ip -&gt; icount / elem_count;
				t -&gt; tdim = array_count;
				t -&gt; tsize = array_count * (t -&gt; ttype -&gt; tsize);
			}
			TRACEPN(ftag, es("array_count: "); eulong(array_count); enl());
		}
	}
	else if (t -&gt; ttype -&gt; tprim == STRUCT_TYPE) {

		/* Only the first member of a union may be initialized. */

		error(es("initializers of arrays of unions not ready yet"));
	}
	else {

		/* The initialized identifier is not an array of characters. */
		int count = (ip -&gt; itype == BRACE_ITYPE) ? ip -&gt; icount : 1;
		t -&gt; tdim = count;
		t -&gt; tsize = count * (t -&gt; ttype -&gt; tsize);
	}

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.542">@ Return a pointer to the symbol table node if the symbol is a typedef.
@c

snode *
dcl_is_typedef(void)
{
	FTAG("dcl_is_typedef");
	snode *s_p = NULL;

	if (!is(ID_TOK)) {
		return NULL;
	}

	TICKB(ftag);

	s_p = st_lookup(t_spell);
	if (s_p &amp;&amp; !s_is_typedef(s_p)) {
		s_p = NULL;
	}

	TRACEPX(ftag, elistx(etok(par_token_ptr)); eret(); esnode(s_p); ecnl());
	return s_p;
}
</t>
<t tx="ekr.20080529093004.543">@ Return a list of symbol nodes linked by their n_next field.  Each declaration consists of exactly one type head followed by a list of type tails separated by commas.  Eat the last deliminter of the list: a comma, semicolon or a close paren.
@c

snode *
dcl_list(int scope)
{
	FTAG("dcl_list");
	register snode * tail_p = NULL;
	snode root;

	TRACEPB(ftag,
		elist(es(tok_name(scope)); ecs(); es("token: "); etok(par_token_ptr)));

	/* Set up the root node. This makes appending nodes easier. */
	root . n_next = NULL;
	tail_p = &amp;root;

	for (;;) {

		ASSERT(tail_p);

		/* Parse the next declaration. */
		tail_p -&gt; n_next = dcl(scope);

		/* Append the node or nodes to the end of the list. */
		while (tail_p -&gt; n_next) {
			tail_p = tail_p -&gt; n_next;
		}

		/*
			Check for end of declaration.

			Outer declarations are handled by par_outer_dcl,
			so a function *definition* is not valid here.
		*/
		ASSERT(scope != FILE_SCOPE);

		if (scope == NEW_FORMAL_SCOPE || scope == OLD_FORMAL_SCOPE) {

			/* New style formals never share declaration heads. */
			if (is(COMMA_TOK)) {
				par_next();
			}
			else if (is(RPAREN_TOK)) {
				par_next();
				goto done;
			}
			else {
				par_needend(RPAREN_TOK);
				goto fix_error;
			}
		}
		else if (is(SEMICOLON_TOK)) {
			par_next();
		}
		else {
			par_need(SEMICOLON_TOK);
			goto fix_error;
		}

		/*
			Continue while we see the start of another declaration.

			A colon in a structure starts an unnamed bit field.
			'...' in new-style prototype is valid.
		*/
		if (
				is_kdecl(t_type) ||
				dcl_is_typedef() ||
				(is(COLON_TOK) &amp;&amp; scope == STRUCT_SCOPE) ||
				(is(DOTS3_TOK) &amp;&amp; scope == NEW_FORMAL_SCOPE)
		) {
			continue;
		}
		else {
			goto done;
		}

	} /* End of loop. */

fix_error:

	if (is(DOTS3_TOK) || is_kdecl(t_type) || dcl_is_typedef() || is(LCURLY_TOK)) {

		tnode * type = tail_p -&gt; ctype;

		if (type != NULL &amp;&amp; type -&gt; tprim == FUNCTION_TYPE) {
			error(
				es("check brace structure\n");
				es("function definition in code");
				end_abort();
			);
		}
	}

done:

	/* Drop the root node. */
	TRACEPX(ftag, eret(); edcls(root . n_next); ecnl());
	return root . n_next;
}
</t>
<t tx="ekr.20080529093004.544">@ Parse an old_style formal parameter list, which is simply a list of identifiers.
@c

snode *
dcl_old_formals(void)
{
	FTAG("dcl_old_formals");
	register snode * tail = NULL;
	register snode * dp = NULL;
	snode root;
	TRACEPB(ftag, es("token: "); etok(par_token_ptr); ecnl());

	/* Clear out the dummy root. */
	root . n_next = NULL;
	tail = &amp;root;

	for(;;) {

		ASSERT(is(ID_TOK));

		/* Check for duplicates. */
		for (dp = root . n_next; dp; dp = dp -&gt; n_next) {
			if (t_spell == dp -&gt; spell) {
				delayed_error(dp -&gt; p_line,
					es("duplicate formal parameter: ");
					es(t_symbol);
				);
				break;
			}
		}

		if (dp == NULL) {

			/* Create a new declaration node. */
			TRACEPN(ftag,
				es("Creating dcl node for: ");
				es(t_symbol); enl());

			new_snode_macro(dp, KP_VAR);
			dp -&gt; spell = t_spell;

			/* Attach to the end of the list. */
			tail -&gt; n_next = dp;
			tail = dp;
		}

		par_next();
		if (!is(COMMA_TOK)) {
			break;
		}
		par_next();
		if (!is(ID_TOK)) {
			error(es("missing formal parameter"));
			break;
		}
	}

	par_need(RPAREN_TOK);

	/* Drop the root. */
	TRACEPX(ftag, eret(); esnode(root . n_next); ecnl());
	return root . n_next;

}
</t>
<t tx="ekr.20080529093004.545">@ Process one parameter prototype. The opening parenthesis has already been eaten.  Return a pointer to the type list.  fndef_ok is TRUE if an identifier has been seen.
@c

static tnode *
dcl_proto(int scope, snode * s_p, tnode * tail, bool fndef_ok)
{
	FTAG("dcl_proto");
	register tnode * t = NULL;
	TRACEPB(ftag,
		elistx(es(tok_name(scope))); es("token: "); etok(par_token_ptr); ecnl());

	/* Create a function-returning node. */
	new_tnode_macro(t, FUNCTION_TYPE, 0L);

	/* Put the node at the end of the type list. */
	t -&gt; ttype = tail;
	tail -&gt; ttype = t;
	tail = t;

	/* Handle the formal parameter list. */
	if (is(RPAREN_TOK)) {

		/* NULL parameter list. */
		par_next();
		if (is(LCURLY_TOK) &amp;&amp; fndef_ok) {
			TRACEPN(ftag, es("setting dcl_body_flag\n"));
			dcl_body_flag = TRUE;
		}
		goto done;
	}
	else if (is(DOTS3_TOK) || is_kdecl(t_type) || dcl_is_typedef()) {

		/* New formals. */
		s_p -&gt; dcls = t -&gt; tdcls = dcl_list(NEW_FORMAL_SCOPE);
		if (is(LCURLY_TOK) &amp;&amp; fndef_ok) {
			if (scope != FILE_SCOPE) {
				goto bad_def;
			}

			/* Parse the body *after* s_p is entered into the symbol table. */
			TRACEPN(ftag, es("setting dcl_body_flag\n"));
			dcl_body_flag = TRUE;
		}
	}
	else if (is(ID_TOK)) {

		snode * ids = NULL;

		if (scope != FILE_SCOPE) {
			goto bad_def;
		}

		/* Old formals. */
		ids = dcl_old_formals();
		ASSERT(ids);

		/* After an old-style prototype we expect to see defintions. */
		if (is_kdecl(t_type) || dcl_is_typedef()) {
			s_p -&gt; dcls = t -&gt; tdcls = dcl_list(OLD_FORMAL_DEF_SCOPE);
		}
		else {
			error(es("Expecting declarations of formal parameters"));
			goto done;
		}

		/* Make sure the two lists agree. */
		{
			snode * idp = NULL;
			snode * fdp = NULL;

			/*
				Make sure all identifiers appear in the formal list.
				Give a warning, not an error, if not.
			*/
			for (idp = ids; idp; idp = idp -&gt; n_next) {
				for(fdp = s_p -&gt; dcls; fdp; fdp = fdp -&gt; n_next) {
					if (idp -&gt; spell == fdp -&gt; spell) {
						break;
					}
				}
				if (fdp == NULL) {
					delayed_warning(idp -&gt; p_line,
						es("Formal parameter: ");
						es(idp -&gt; spell -&gt; spell_name);
						es(" is not declared"));
				}
			}

			/* Make sure all formals in the formal list appear in the id list. */
			for(fdp = s_p -&gt; dcls; fdp; fdp = fdp -&gt; n_next) {
				for (idp = ids; idp; idp = idp -&gt; n_next) {

					if (idp -&gt; spell == fdp -&gt; spell) {
						break;
					}
				}
				if (idp == NULL) {
					delayed_error(fdp -&gt; p_line,
						es(fdp -&gt; spell -&gt; spell_name);
						es(" does not appear in the identifier list"));
				}
			}
		}

		/* Parse the function body *after* s_p is entered into the symbol table. */
		/* 3/3/93: set dcl_body flag only if '{' is seen. */
		if (is(LCURLY_TOK) &amp;&amp; fndef_ok) {
			TRACEPN(ftag, es("setting dcl_body_flag\n"));
			dcl_body_flag = TRUE;
		}
	}

done:
	dcl_proto_flag = TRUE;
	STATX(ftag);
	return tail;

bad_def:
	user_fatal(es("Nested function defintion"));
	return NULL;
}
</t>
<t tx="ekr.20080529093004.546">@ Set the tsize field for an array and all sub-arrays.
@c

static void
dcl_size_array(tnode * t)
{
	FTAG("dcl_size_array");
	register tnode * subtype = NULL;
	STATB(ftag);

	ASSERT(t);
	subtype = t -&gt; ttype;

	if (subtype == NULL) {
		goto done;
	}

	if (subtype -&gt; tprim == FUNCTION_TYPE) {
		error(es("array may not contain functions"));
		goto done;
	}

	if (subtype -&gt; tprim == ARRAY_TYPE) {

		/* Compute the size of the inner dimensions first. */
		dcl_size_array(subtype);
	}

	/* Assign the array size at this recursion level. */
	t -&gt; tsize = t -&gt; tdim * subtype -&gt; tsize;

done:
	TRACEPX(ftag, etnode(t); enl());
}
</t>
<t tx="ekr.20080529093004.547">@ Set the offset field of each element of a struct and return the total size of a structure.  While we are at it, do s_set_su_elem(s) for each item s of the struct.
@c

static ulong
dcl_size_struct(snode * s_p)
{
	FTAG("dcl_size_struct");
	register ulong offset = 0;
	STATB(ftag);
	ASSERT(s_p);

	for ( ; s_p; s_p = s_p -&gt; n_next) {

		tnode * t = s_p -&gt; ctype;

		/* Mark the item as an element of a struct/union. */
		s_set_su_elem(s_p);

		/* 3/3/93: t -&gt; tsize may be 0 as the result of user error. */
		if (t &amp;&amp; t -&gt; tsize) {

			/*
				7/5/93: Make sure *all* structs occupy an even number of bytes
				by padding a trailing char field.
				This is important when allocating arrays of structs and also
				makes it unnecessary to add padding following structs.
			*/

			if (t -&gt; tsize == 1) {

				if (offset &amp; 1) {
					/* Don't pad: this is the second character in a row. */
					s_p -&gt; offset = offset;
					offset += 1;
				}
				else if (
					s_p -&gt; n_next &amp;&amp;
					snode_ptr(s_p -&gt; n_next) -&gt; ctype &amp;&amp;
					snode_ptr(s_p -&gt; n_next) -&gt; ctype -&gt; tsize == 1
				) {
					/* No padding needed: the item is followed by a char. */
					s_p -&gt; offset = offset;
					offset += 1;
				}
				else {
					/* Allocate one extra byte for the data item. */
					s_p -&gt; offset = offset + 1;
					offset += (t -&gt; tsize + 1);
				}
			}
			else if ((t -&gt; tsize) &amp; 1) {
				/* Allocate one extra byte for the data item. */
				s_p -&gt; offset = offset + 1;
				offset += (t -&gt; tsize + 1);
			}
			else {
				s_p -&gt; offset = offset;
				offset += t -&gt; tsize;
			}
		}
	}

	/* Make sure *all* structs have an even number of bytes. */
	ASSERT(!(offset &amp; 1));

	TRACEPX(ftag, eret(); eulong(offset); enl());
	return offset;
}
</t>
<t tx="ekr.20080529093004.548">@ Return the size of a union, i.e., the maximum size of any element of the union.  While we are at it, do s_set_su_elem(s) for each item s of the union.
@c

static ulong
dcl_size_union(snode * s_p)
{
	FTAG("dcl_size_union");
	register ulong offset = 0;
	TRACEPB(ftag, esnode(s_p));
	ASSERT(s_p);

	for ( ; s_p; s_p = s_p -&gt; n_next) {

		tnode * t = s_p -&gt; ctype;

		TRACEPN(ftag, es("doing node "); etnode(t); ecnl());
		ASSERT(t);

		/* Mark the item as an element of a struct/union. */
		s_set_su_elem(s_p);

		offset = max(offset, t -&gt; tsize);
	}

	TRACEPX(ftag, eret(); eulong(offset); enl());
	return offset;
}
</t>
<t tx="ekr.20080529093004.549">@ Parse a 'struct' or 'union' and enter the fields into the symbol table.  s_p represents the (possibly nonexistent) declarator (i.e., object) that may be created as the result of the struct or union declaration.  A tnode is attached to new tag snodes because some place is needed in order to represent the total size of the structure.
@c

static tnode *
dcl_struct_union(int scope, snode * s_p, tnode * t)
{
	FTAG("dcl_struct_union");
	register snode *tag_p = NULL;
	spell_node * tag_spell = NULL;
	bool undefined_flag = FALSE;
	long start_line = err_line;
	TICKB(ftag);
	ASSERT(t &amp;&amp; s_p);

	if (is(K_STRUCT)) {
		scope = STRUCT_SCOPE;
		t -&gt; tprim = STRUCT_TYPE;
	}
	else {
		scope = UNION_SCOPE;
		t -&gt; tprim = UNION_TYPE;
	}

	if (t -&gt; tsize) {
		error(es("long, short, etc. do not apply to struct/union"));
		t -&gt; tsize = 0;
	}

	/* Eat the 'struct' or 'union' keyword. */
	par_next();

	/* Remember an optional tag. */
	if (is(ID_TOK)) {
		tag_spell = t_spell;
		tag_p = st_lookup_tag (tag_spell);
		undefined_flag = (tag_p == NULL);
		TRACEPN(ftag,
			if (tag_p) {
				es("previous tag: "); es(tag_spell -&gt; spell_name);
				es(" sz: "); elong(tag_p -&gt; ctype -&gt; tsize); enl();
			}
			else {
				es("new tag: "); es(tag_spell -&gt; spell_name); enl();
			}
		);
		par_next();
	}
	else if (is(LCURLY_TOK)) {
		tag_spell = NULL;
		tag_p = NULL;
	}
	else {
		error(es("tag or field list expected after 'struct' or 'union'"));
		goto done;
	}

	/*
		Create a tag snode if it does not exist.
		The tag snode will be nameless if there was no tag.
	*/
	if (tag_p == NULL) {
		new_snode_macro(tag_p,
			(scope == STRUCT_SCOPE) ? KP_STRUCT_TAG : KP_UNION_TAG);
		tag_p -&gt; spell = tag_spell;
		tag_p -&gt; smods = s_p -&gt; smods;
		tag_p -&gt; ctype = t;

		/*
			Bug fix: 9/25/92
			Since a struct can be a member of another struct, we can not
			use the tdcls field as both a type and a parent field.
			Use the ttype field to point at the type of a struct.
			In effect, the ttype field becomes a union.
		*/
		t -&gt; ttype = (tnode *) tag_p;

		/* Enter only named tags into the symbol table. */
		if (tag_spell) {
			st_enter_tag(tag_p);
		}
	}
	else {

		/* Use the existing tag's type, *not* the caller's type. */
		ASSERT(tag_p -&gt; ctype);
		t = tag_p -&gt; ctype;
	}

	if (!is(LCURLY_TOK)) {

		/*
			Only now can we issue an error message about an undefined tag.
			Indeed, a definitions such as

				struct tag;
				typedef struct tag tag;

			are valid. Any other undefined tag is an error here.
		*/
		if (undefined_flag) {
			ASSERT(tag_spell);
			if (!is(SEMICOLON_TOK) &amp;&amp; !s_is_typedef(s_p)) {
				error(
					es("undefined struct/union tag: ");
					es(tag_spell -&gt; spell_name));
			}
		}
		goto done;
	}

	ASSERT(tag_p);

	/* Eat the opening curly bracket. */
	par_next();

	/* Parse the struct/union definition. */
	tag_p -&gt; dcls = dcl_list(scope);
	if (tag_p -&gt; dcls == NULL) {
		error(es("empty structure definition"));
	}
	par_need(RCURLY_TOK);

	/* Set the tsize field. */
	if (scope == STRUCT_SCOPE) {
		t -&gt; tsize = dcl_size_struct(tag_p -&gt; dcls);
	}
	else {
		t -&gt; tsize = dcl_size_union(tag_p -&gt; dcls);
	}

	/* Set the size in the tag's type. */
	ASSERT(tag_p -&gt; ctype);
	tag_p -&gt; ctype -&gt; tsize = t -&gt; tsize;

	/*
		Set the tdcls field in all elements and
		enter them into the symbol table.
	*/
	{
		snode * sp2;
		int ntype = KP_VAR;
		for (sp2 = tag_p -&gt; dcls; sp2; sp2 = sp2 -&gt; n_next) {

			sp2 -&gt; n_type = ntype;

			/* 3/3/93: last chance to catch bad struct/union fields. */
			if (
				sp2 -&gt; ctype &amp;&amp;
				(
					sp2 -&gt; ctype -&gt; tdcls == NULL ||
					sp2 -&gt; ctype -&gt; tdcls == tag_p
				)
			) {
				sp2 -&gt; ctype -&gt; tdcls = tag_p;
				st_enter_field(sp2);
			}
			else {
				error(
					es("bad struct/union field: ");
					if (sp2 -&gt; spell) {
						es(sp2 -&gt; spell -&gt; spell_name);
					}
				);
			}
		}
	}

done:

	/* Set range of lines spanned by the declaration. */
	ASSERT(tag_p);
	p_set_line_count_macro(pnode_ptr(tag_p), err_line - start_line);

	TRACEPX(ftag, eret(); es("t: "); eptr(t); eblank(); etnode(t); enl());
	return t;
}
</t>
<t tx="ekr.20080529093004.550">@ Parse one type tail and return a pointer to a type node.  The type tail contains asterisks, the id (or where the id is presumed to be for casts), and function parameter lists and array dimensions.  The tail may contain the identifier inside grouping parentheses. Parse these grouping parentheses by recursive descent.  recurse_flag: TRUE if this results from a recursive call of dcl_tail.   (If so, initializers are not valid.)
@c

static tnode *
dcl_tail(int scope, snode * s_p, tnode * head_type, bool recurse_flag)
{
	FTAG("dcl_tail");
	register tnode * tail = NULL;
	tnode * star_head = NULL;
	tnode * star_tail = NULL;
	tnode * function_t = NULL;
	bool fndef_ok = FALSE;
	bool lparen_seen = FALSE;
	tnode root;
	TRACEPB(ftag,
		elistx(es(tok_name(scope)); ecs(); etnode(head_type));
		es("token: "); etok(par_token_ptr));

	ASSERT(s_p  || scope == CAST_SCOPE);

	/*
		root_node is a dummy type that makes adding elements to
		the declaration list much easier.
	*/

	root . ttype = NULL;
	tail = &amp;root;

	/*
		Point star_head and star_tail at the list of
		all asterisks occuring *before* the identifier part.
	*/
	star_head = NULL;

	if (is(STAR_TOK)) {

		register tnode * t = NULL;

		/* first prepending */
		new_tnode_macro(t, POINTER_TYPE, POINTER_SIZE);
		star_head = star_tail = t;

		for(par_next(); ; par_next()) {

			switch(t_type) {

			case STAR_TOK:

				/* subsequent prependings */
				new_tnode_macro(t, POINTER_TYPE, POINTER_SIZE);
				t -&gt; ttype = star_head;
				star_head = t;
				continue;

			case K_CONST:
				t_set_const(t);
				continue;

			case K_VOLATILE:
				t_set_volatile(t);
				continue;
			}
			break;
		}
	}

	/*
		Handle the core, i.e., the identifier part of the tail.

		This could be either a plain id or a parenthesized expression.

		A '(' could be grouping parenthesis or it could
		be function parameter list parenthesis inside a cast.

		If it is a function parenthesis, there can be no
		more left-parentheses for grouping, since the
		identifier or the missing identifier must be
		inside the innermost pair of grouping parentheses.
	*/

	if(is(LPAREN_TOK)) {

		par_next();

		if (is(RPAREN_TOK)) {
			/*
				We should be in a cast for a function.
				Eventually, test for type declarator.

			*/
			lparen_seen = TRUE;
		}
		else {

			/*
				The initial '(' was a grouping parenthesis.
				Parse the rest of the core recursively.
			*/

			tnode * t2 = dcl_tail(scope, s_p, NULL, TRUE);
			if (t2 != NULL) {

				/* append core item */
				tail -&gt; ttype = t2;
				tail = t2;

				/* reset tail */
				while (tail -&gt; ttype) {
					tail = tail -&gt; ttype;
				}
			}
			par_need(RPAREN_TOK);
		}
	}
	else if (is(ID_TOK)) {

		/*
			Remember the spelling for later.
			s_p is NULL in cast scope.
		*/
		if (s_p) {
			TRACEPN(ftag, es("setting spell: "); es(t_symbol); enl());
			s_p -&gt; spell = t_spell;
		}

		/* It is now valid for a function definition to appear. */
		fndef_ok = TRUE;

		/* Move past the identifier. */
		par_next();
	}
	else if (scope == STRUCT_SCOPE &amp;&amp; is(COLON_TOK)) {

		long bit_val = 0;
		bool err_flag = FALSE;

		/* bit field without id. */
		par_next();
		bit_val = expr_const_int(&amp;err_flag);
		if (err_flag || bit_val &lt; 0) {
			error(es("invalid width of bit field"));
		}
	}
	else if (
		recurse_flag == FALSE &amp;&amp;
		scope != CAST_SCOPE &amp;&amp;
		scope != NEW_FORMAL_SCOPE &amp;&amp;
		head_type -&gt; tprim != STRUCT_TYPE &amp;&amp;
		head_type -&gt; tprim != UNION_TYPE &amp;&amp;
		!(head_type -&gt; tprim == INT_TYPE &amp;&amp; t_is_enum(head_type))
	) {
		error(es("missing object name in declaration"));
	}

	/*
		The Great Divide.

		fndef_ok is TRUE only if we have actually seen an id.
		lparen_tok is TRUE if we have seen the opening of a param list.
		recurse is TRUE here only if we are still parsing the core.
	*/

	tail = dcl_finish(
				scope, s_p, tail,
				lparen_seen, fndef_ok, recurse_flag, &amp;function_t);

	if (is(LPAREN_TOK)) {
		error(es("unexpected ("));
	}

	/*
		The parsing of the declaration is complete.
		The remainder of dcl_tail finishes semanitic processing of the declaration.
	*/

	/* Append stars, which may carry their consts and volatiles */
	if (star_head) {
		tail -&gt; ttype = star_head;
		tail = star_tail;
	}

	/* Append head_type node */
	tail -&gt; ttype = head_type;

	/*
		The rest of this processing is handled only at the outer level of dcl_tail.
	*/
	if (recurse_flag || s_p == NULL) {
		goto done;
	}

	/*
		Complete the type.  Only now can we...

		1. complete the information that depends on an initializer.
		2. compute the correct size of an array.
	*/

	/* At long last, a correct type can be attached to the symbol. */
	s_p -&gt; ctype = root . ttype;

	if (s_is_proto(s_p)) {

		/* 5/4/93: Declarations of pointers to functions are *not* prototypes. */
		if (s_p -&gt; ctype -&gt; tprim != FUNCTION_TYPE) {

			s_clear_proto(s_p);
			dcl_proto_flag = FALSE;
		}
		else {

			/*
				A horrible kludge to satisfy the MPW assembler...

				We establish the bogus convention that a prototype in the
				main file (tok_file_level==1) that is neither *explicitly* extern
				nor static indicates that the function mentioned in
				the prototype will be *defined* later in the file.

				All prototypes in the main file supress IMPORT direcitives.
				Non-external prototypes create ENTRY directives.
			*/
			if (tok_file_level == 1) {
				s_set_defined(s_p);
				ASSERT(s_p -&gt; spell);
				if (!s_is_extern(s_p)) {
					out_entry(s_p -&gt; spell -&gt; spell_name, s_is_static(s_p));
				}
			}
		}
	}

	/* Check the final type. */
	dcl_check_type(s_p -&gt; ctype);

	/*
		Enter the symbol into the symbol table, if possible.
		We want to enter the symbol *after* its full type is known because
		some duplicate definitions, for example, prototypes, are valid,
		while others are an error.
		
		However, some names must be entered before full type information is known.
		For example,
		
		struct FILE f = { ..., &amp;f.field, ... }
	*/
	if (s_p -&gt; spell == NULL) {

		if (s_p -&gt; ctype &amp;&amp; s_p -&gt; ctype -&gt; tprim == VOID_TYPE) {
			/* s_p is void, not a real variable. */
			s_p -&gt; n_type = KP_VOID_VAR;
		}
	}
	else if (scope == FILE_SCOPE || scope == FUNCTION_SCOPE || scope == BLOCK_SCOPE) {

		/* Enter the regular symbol. */
		st_enter(s_p);
	}
	else {

		/* Formal parameters are entered into the symbol table by dcl_fbody. */
	}
	
	/* Parse initializers now, *after* the symbol is in the symbol table. */
	if (is(ASSN_TOK)) {
		
		/* Parse the initializer regardless of whether it is valid. */
		dcl_init(scope, s_p);
	}
	
	/* Complete the dimensions of arrays. */
	if (s_is_array(s_p) &amp;&amp; s_p -&gt; ctype &amp;&amp; s_p -&gt; ctype -&gt; tprim == ARRAY_TYPE) {

		if (s_p -&gt; vlist &amp;&amp; s_p -&gt; ctype -&gt; tdim == 0) {

			/* Complete the dimension from an initializers. */
			dcl_init_finish(s_p);
		}

		/* Propagate the sizes of an array. */
		dcl_size_array(s_p -&gt; ctype);
	}

	/*
		Allocate anodes and create static data area.

		In effect, this part of dcl becomes a separate code generation pass
		that creates initial data areas.

		The calls to gen_init_data must be made here rather than in dcl_init
		because gen_init_data requires the completed type of s_p be available.
	*/
	if (dcl_proto_flag) {

		/*
			Create an anode for a prototype or function definition.

			Prototypes need anodes because they
			are used to make function calls to external functions.

			Note: function prototypes can appear inside functions, so
			allocating anodes for them in par_outer_decl does not work.
		*/
		gen_alloc_function(s_p);
	}
	else if (scope == FILE_SCOPE || s_is_static(s_p)) {

		/* Create an anode for an outer or static variable. */
		gen_alloc_outers(s_p);

		/* Generate and output a defining label and the initial data area. */
		gen_init_data(s_p);
	}
	else if (scope == FUNCTION_SCOPE || scope == BLOCK_SCOPE) {

		/*
			An auto variable.

			Generate and output an internal defining label and an initial data area.

			Do *not* create an anode for the variable here.
			anodes for auto variables are created later by gen_alloc_locals
			so that stack offsets can be computed in one place.

			gen_init_data creates no initial data area auto for structs or unions
			whose initializer is a single non-constant expression.
			gen_auto_inits generates all code for such initializers.

			Otherwise, the initializer is a list of one or more constants.
			gen_init_data creates an initial data area and replaces the list of inodes
			representing the padded initializer by a single AUTO_ITYPE inode that
			holds the label and the size of the generated initial data area.
			This kludge is done because no anode exists yet for an auto variable.
		*/
		gen_init_data(s_p);
	}
	else {

		/* A dummy variable.  Do *not* call gen_init_data here! */
		ASSERT_TRACE(
			(scope != FILE_SCOPE &amp;&amp; scope != FUNCTION_SCOPE &amp;&amp; scope != BLOCK_SCOPE) ||
			(s_p -&gt; n_type == KP_VOID_VAR || s_p -&gt; n_type == KP_NULL_VAR),
			es(tok_name(scope)); ecs(); etoknum(s_p -&gt; n_type));

		ASSERT(s_p -&gt; vlist == NULL);
	}
	dcl_proto_flag = FALSE;

	/*
		Parse the body of a function *after* the
		function's name has been entered into the symbol table.
	*/
	if (dcl_body_flag) {

		/* Reset this flag *before* calling dcl_fbody. */
		dcl_body_flag = FALSE;

		ASSERT_TRACE(function_t -&gt; tprim == FUNCTION_TYPE,
			es("function_t -&gt; tprim: "); es(tok_name(function_t -&gt; tprim)));

		if (scope != FILE_SCOPE) {
			error(es("Nested functions are not allowed"));
		}

		/* Set the global function type, mods and name. */
		gen_fsnode = s_p;
		gen_ftype = function_t;
		gen_fname = (s_p -&gt; spell) ? s_p -&gt; spell -&gt; spell_name : NULL;

		dcl_fbody(s_p -&gt; dcls);

		/* dcl_definition_flag is used by par_outer_dcl. */
		dcl_definition_flag = TRUE;
	}

	/* Return the head of the type list. */
done:
	TRACEPX(ftag, eret(); etnode(root . ttype);  ecnls(3));
	return root . ttype;
}
</t>
<t tx="ekr.20080529093004.551">/*
	CC2: Expression parsing routines.

	source:  CCexp.c
	started: November 2, 1985
	version:
		August 24, 1994.
			Bug fix to expr_is_init_const.  Allow &amp;struct or &amp;union.
		November 2, 1993.
			Bug fix: expr_is_init_const now recursively checks the expression tree.
			This is still not a completely general solution...
		June 29, 1993.
			Bug fix: call eval_ustring, not eval_string in expr_cprim.
		April 11, 1993.
			Added expr_is_const.
		April 7, 1993.
			Give error for function calls without prototypes.
		March 3, 1993.
			Allow null type in expr_sizeof, which can be caused by user error.
		February 22, 1993.
			Replaced expr_epush, expr_epop, expr_etop by corresponding macros.
		January 30, 1993.
			Printed copy sent to Tuple.
			Replaced the make_xxx macros by the improved t_set_xxx macros.
			Folding routines moved to fold.c.
		January 29, 1993.
			Simplified the make_xxx_macros by eliminating the cep and val parameters.
			Eliminated the infamous copy_unsigned_macro.
			Eliminated expr_check_type.
		January 28, 1993.
			Eliminated expr_massage, expr_retype, expr_check_class!
			Eliminated expr_msize and expr_oversize!
			Simplified expr_const_int and eliminated expr_is_int_const.
			(enums id's have always been converted to const_enodes by expr_prim.)
		January 27, 1993.
			New fold.
			Rewrote expr_fold1.
			Called ct_type1 and ct_type2 *before* calling expr_fold1 and expr_fold2.
			Changed expr_fold1 and expr_fold1 so they always return the result.
			Eliminated the calls to expr_retype in fold2
				(The retyping is done by a previous call to ct_type2.)
			Eliminated expr_is_prim.
		January 24, 1993.
			Bug fix: set tsize in make_long_macro.
		January 19, 1993.
			Undefined variables get NULL type so error messages are suppressed.
		December 19, 1992.
			Changed expr_cprim to use gen_new_big_anode.
		December 8, 1992.
			Changed int to tnode * in expr_retype, expr_check_type, expr_msize.
			Added copy_unsigned macro
		November 18, 1992.
			Rewrote expr_cprim.
			Rewrote eval_string.
			Added eval_fstring and eval_ustring.
		November 6, 1992.
			Changed all loc_nodes to various flavors of enodes.
		November 1, 1992.
			change expr_prec to use a lookup table.
		October 22, 1992.
			expr_typex routine moved to ct.c and renamed ctx.
		September 30, 1992.
			Do not warn about retyping bit operators in expr_retype.
		September 29, 1992.
			Removed expr_tcheck.
			Added expr_tdump.
			Separated tstack, estack and xstack.
			Changed expr_npop, etc. to expr_epop, etc.
		September 28, 1992.
			Added stub for expr_is_init_const.
		September 18, 1992.
			Added expr_msize.
		September 8, 1992.
			Rewrote ct_type2.
		August 23, 1992.
			Changed expr (again) so it returns an enode, not a pnode.
		July 16, 1992.
			New eval_string routine.
		July 5, 1992.
			Changed expr so it returns an expr_node, not an enode.
		June 23, 1992.
			Changed reduce because now ++ and -- are unary ops.
		June 12, 1992.
			Distinguished properly between loc nodes, enode's and pnode's.
		June 5, 1991
			First CC2 version.
		January 20, 1992
		March 7, 1989
		February 17, 1987
*/
&lt;&lt; CCexp #includes &gt;&gt;
&lt;&lt; CCexp declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.552">#include "CC.h"
#include "CCtarget.h"

#include "CCcpp.h"	/* for char_val. */
#include "CCdump.h"
#include "CCgen.h"
#include "CCmem.h"
#include "CCparser.h"

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.553">/*
	Inline functions.
*/
#define junk_top_macro(the_count)\
{\
	ASSERT(the_count &gt; 0);\
	--the_count;\
}

#define ejunk_top_macro() junk_top_macro(ecount)
#define tjunk_top_macro() junk_top_macro(tcount)
#define xjunk_top_macro() junk_top_macro(xcount)

#define pop_macro(the_val, the_count, the_stack)\
{\
	ASSERT(the_count &gt; 0);\
	(the_val) = the_stack[--the_count];\
}

#define epop_macro(the_val) pop_macro(the_val, ecount, estack)
#define tpop_macro(the_val) pop_macro(the_val, tcount, tstack)
#define xpop_macro(the_val) pop_macro(the_val, xcount, xstack)

#define push_macro(the_val, the_count, the_stack, the_limit)\
{\
	if (the_count &gt;= the_limit) {\
		err_too_complex();\
	}\
	else {\
		the_stack[the_count++] = (the_val);\
	}\
}

#define epush_macro(the_val) push_macro(the_val, ecount, estack, MAX_ESTACK)
#define tpush_macro(the_val) push_macro(the_val, tcount, tstack, MAX_TSTACK)
#define xpush_macro(the_val) push_macro(the_val, xcount, xstack, MAX_XSTACK)

#define top_macro(the_count, the_stack, the_null_val)\
	((the_count &lt;= 0) ? the_null_val : the_stack[the_count-1])

#define etop_macro() top_macro(ecount, estack, NULL)
#define ttop_macro() top_macro(tcount, tstack, BAD_TOK)
#define xtop_macro() top_macro(xcount, xstack, NULL)

/*
	Function prototypes of internal routines.
*/
static void		err_too_complex	(void);
static long		eval_string		(char * s);
static ulong	eval_ustring	(char * s);

static bool		expr_can_reduce	(token opr1, token opr2);
static enode *	expr_cprim		(void);
static enode *	expr_list1		(void);
static int		expr_prec		(int op);
static enode *	expr_prim		(void);
static void		expr_reduce		(int op, tnode *t);
static ulong	expr_sizeof		(void);
static void		expr_tdump		(void);

/*
	Define data structures used only by this file.

	The operator precedence algorithm uses an operator stack and a enode stack.
	These stacks are housed in expr_stk[], and are managed by
	expr_tpush(), expr_tpop(), expr_epush() and expr_epop();

	The expr_list1() and expr_expr1() routines call each other without resetting
	the token and enode stacks.  The externally visible versions do reset
	those stacks.
*/

#define MAX_TSTACK 200
#define MAX_ESTACK 400
#define MAX_XSTACK 100

static int     tstack [MAX_TSTACK];	/* The token stack. */
static enode * estack [MAX_ESTACK];	/* The expression (operand) stack. */
static tnode * xstack [MAX_XSTACK];	/* Auxialliary type stack. */

static int tcount = 0;	/* Index into tstack. */
static int ecount = 0;	/* Index into estack. */
static int xcount = 0;	</t>
<t tx="ekr.20080529093004.554">@ Index into xstack.
@c

static void
err_too_complex(void)
{
	user_fatal(es("expression too complex"));
}
</t>
<t tx="ekr.20080529093004.555">@ Return the value of a string representing a float, double or long double.  This conversion is complicated by the fact that there is no ANSI C library routine to convert from strings to long doubles!  Not true: one can use sscanf!  The present code ignores the difficulty and simply uses the strtod function. Constants too big too fit in a double are thus not possible yet.
@c

double
eval_fstring (char * s)
{
	FTAG("eval_fstring");
	double dval = 0.0;
	char * end = NULL;
	STATB(ftag);
	ASSERT(s);

	if (strlen(s) &gt; 0) {

		dval = strtod(s, &amp;end);
		if (*end != '\0' &amp;&amp; *end != 'f' &amp;&amp; *end != 'F' &amp;&amp; *end != 'l' &amp;&amp; *end != 'L') {
			error(es("bad or oversize floating constant: "); es(s));
			dval = 0.0;
		}
	}

	TRACEPX(ftag, es("s: "); es(s); eblank(); eret(); edouble(dval); enl());
	return dval;
}
</t>
<t tx="ekr.20080529093004.556">@ Return the value of a string representing a signed int or signed long
@c

static long
eval_string (char * s)
{
	FTAG("eval_string");
	char * end = NULL;
	long val = 0L;
	STATB(ftag);
	ASSERT(s);

	val = strtol(s, &amp;end, 0);

	/* Allow constants of the form xxxL, xxxU, xxxUL, xxxLU */
	if (*end != '\0' &amp;&amp; *end != 'u' &amp;&amp; *end != 'U' &amp;&amp; *end != 'l' &amp;&amp; *end != 'L') {

		error(es("bad signed constant: "); es(s); es("--0 assumed"));
		val = 0;
	}

	TRACEPX(ftag, es("s: "); es(s); eblank(); eret(); elong(val); enl());
	return val;
}
</t>
<t tx="ekr.20080529093004.557">@ Return the value of a string representing an unsigned int or signed long
@c

static ulong
eval_ustring (char * s)
{
	FTAG("eval_ustring");
	char * end = NULL;
	ulong uval = 0L;
	STATB(ftag);
	ASSERT(s);

	uval = strtoul(s, &amp;end, 0);

	/* Allow constants of the form xxxL, xxxU, xxxUL, xxxLU */
	if (*end != '\0' &amp;&amp; *end != 'u' &amp;&amp; *end != 'U' &amp;&amp; *end != 'l' &amp;&amp; *end != 'L') {
		error(es("bad unsigned constant: "); es(s); es("--0 assumed"));
		uval = 0;
	}

	TRACEPX(ftag, es("s: "); es(s); eblank(); eret(); eulong(uval); enl());
	return uval;
}
</t>
<t tx="ekr.20080529093004.558">@ Parse an arbitrary C expression, commas allowed if comma_ok is TRUE.  Two considerations complicate this routine.  1. The comma_ok flag indicates that commas are to be treated as comma operators rather than commas that separate items in a list of expressions. There are subtle differences between these two ues of commas. The comma operator associates left-to-right, while lists are created as if comma operators associate right-to-left. Also, the routines in edump print CONS_TOK's and COMMA_TOKS differently. Finally, the folding routines issue a warning on expressions such as (1,2); such a warning is inappropriate for lists of expressions.  2. The current code uses a single set of stacks instead of allocating a new set of stacks each time expr1 is called recursively. This saves a lot of storage, since stacks usually contain few elements.  Simpler alternatives for allocating the stacks have drawbacks:  o A new set of stacks could be allocated each time expr were called. This allow the expr and expr1 routines to be merged and would eliminate the tcount and ecount variables and some ugly code. Alas, allocating stacks would waste a lot of storage, especially for expressions containing large numbers of nested subexpressions.  o The expr routine could be called to parenthesized or bracketed expressions. The stacks would be allocated on the stack instead of the heap. This is the "elegant" solution. However, in my opion the elegant solution is unacceptable because there is no way to limit the size of the stack. An expression that starts off with 100 open parenthesise might crash the parser. One could limit the recursion using a count, but there is no way in general to know what a "safe" count would be. Besides, if we are going to artificially limit the level of recursion, there is no advantage to the user in changing the current scheme.
@c

enode *
expr(bool comma_ok)
{
	FTAG("expr");
	enode * ep = NULL;
	TICKB(ftag);

	tcount = 0;
	ecount = 0;
	ep = expr1(comma_ok, ARBITRARY_EXPRESSION);

	TRACEPX(ftag,
		es("comma ok: "); ebool(comma_ok); eblank();
		eret(); eenode(ep); enl());
	return ep;
}
</t>
<t tx="ekr.20080529093004.559">@ Expr1 is visible for use by dcl.c in parsing array subscripts in casts.
@c

enode *
expr1(bool comma_ok, bool unary_expr_flag)
{
	FTAG("expr1");
	FTAGV("-expr1_v");

	/* Save-and-restore items. */
	int tsave = 0;
	int esave = 0;

	register enode * p = NULL;
	register enode * p2 = NULL;
	register tnode *t = NULL;

	register int op = 0;
	register int ternary = 0;
	register int get_flag = 0;

	/* Return NULL on empty expressions. */
	if (is(SEMICOLON_TOK) ||
		is(RPAREN_TOK) ||
		(is(COMMA_TOK) &amp;&amp; !comma_ok)
	) {
		return NULL;
	}

	TICKB(ftag);

	/* Save the stacks */
	tsave = tcount;
	esave = ecount;

/*
	State s1_pre_ops:  Start of expression

	Push unary ops or '('.
*/
s1_pre_ops:

	TRACEP(ftagv, es("s1_pre_ops at: "); etok(par_token_ptr); enl());

	/*
		The sizeof operator is handled by expr_prim().
	*/
	switch (t_type) {

	case AND_TOK:		t_type = UAND_TOK;		break;
	case DEC_TOK:		t_type = PRE_DEC_TOK;	break;
	case INC_TOK:		t_type = PRE_INC_TOK;	break;
	case MINUS_TOK:		t_type = UMINUS_TOK;	break;
	case NOT_TOK:								break;
	case PLUS_TOK:		t_type = UPLUS_TOK;		break;
	case STAR_TOK:		t_type = USTAR_TOK;		break;
	case TILDE_TOK:								break;

	case LPAREN_TOK:

		/* Possible cast, look ahead */
		TRACEP(ftagv, es("s1_pre_ops: check for cast\n"));

		par_next();
		t = dcl_cast();
		if (t != NULL) {
			TRACEP(ftagv, es("s1_pre_ops: dcl_cast returns a cast\n"));

			xpush_macro(t);
			tpush_macro(CAST_TOK);
			par_need(RPAREN_TOK);
		}
		else {
			TRACEP(ftagv, es("s1_pre_ops: not a cast\n"));

			tpush_macro(LPAREN_TOK);
			comma_ok++;

			TRACEP(ftagv, es("comma_ok++, comma_ok: "); elong(comma_ok); enl());
		}
		goto s1_pre_ops;

	default:
		goto s2_operand;
	}

	TRACEP(ftagv, es("s1_pre_ops: fall-through\n"));

	tpush_macro(t_type);
	par_next();
	goto s1_pre_ops;

/*
	State s2_operand:

	Get a primitive operand(i.e., an identifier or constant) and push
	it onto the operand stack.
*/
s2_operand:

	TRACEP(ftagv, es("s2_operand at: "); etok(par_token_ptr); enl());

	p = (enode *) expr_prim();

	/*
		WARNING: we have to keep the books balanced or else an
		expression will be totally botched by too many pulls
		on expr_epop, given that an incomplete expression is
		present in an argument parsed underneath by expr_list()
	*/
	if (p == NULL) {

		enode * var = NULL;
		new_enode_macro(var, sizeof(var_enode), ID_TOK);
		new_tnode_macro(var -&gt; e_ctype, INT_TYPE, INT_SIZE);
		epush_macro(var);
	}
	else {
		epush_macro(p);
	}

/*
	State s3_post_ops: After an identifier

	Take care of any post-operators
*/

s3_post_ops:

	TRACEP(ftagv, es("s3_post_ops at: "); etok(par_token_ptr); enl());

	switch (t_type) {

	case INC_TOK:
		t_type = POST_INC_TOK;
		get_flag = TRUE;
		break;

	case DEC_TOK:
		t_type = POST_DEC_TOK;
		get_flag = TRUE;
		break;

	case POST_DEC_TOK:
	case POST_INC_TOK:
		break;

	case LPAREN_TOK:
	case LBRACK_TOK:
		get_flag = FALSE;
		break;

	default:
		goto s4_binop_or_rparen;
	}

	TRACEP(ftagv, es("s3_post_ops 2: "); etok(par_token_ptr); enl());

	if (tcount &gt; tsave &amp;&amp; expr_can_reduce(ttop_macro(), t_type)) {

		/* Reduce what is already on the stack. */
		tpop_macro(op);
		if (op == CAST_TOK) {
			xpop_macro(t);
		}
		else {
			t = NULL;
		}
		expr_reduce(op, t);
	}
	else {
		expr_reduce(t_type, NULL);
		if (get_flag) {
			par_next();
		}
	}
	goto s3_post_ops;

/*
	State s4_binop_or_rparen:

	A binary operator or balanced right paren continues the expresssion.
	Otherwise, reduce the whole stack and exit.

	If it is a continuation, the op stack gets popped only until
	t_type has a higher precedence than the operator on top.
*/
s4_binop_or_rparen:

	TRACEP(ftagv, es("s4_binop_or_rparen at: "); etok(par_token_ptr); enl());

	/*
		7/19/93: Don't allow binary operators if only uary operators are allowed.
		However, the dot and arrow operators must be allowed since they are
		part of primitives.
	*/
	if (unary_expr_flag &amp;&amp; t_type != DOT_TOK &amp;&amp; t_type != ARROW_TOK) {
		goto s6_final;
	}

	if (tcount &gt; tsave) {
		goto s5_reduce;
	}

	TRACEP(ftagv, es("stack empty at: "); etok(par_token_ptr); enl());

	switch(t_type) {

	case RCURLY_TOK:
	case RBRACK_TOK:
	case RPAREN_TOK:
	case SEMICOLON_TOK:
		goto s6_final;

	case COMMA_TOK:
		if (!comma_ok) {
			goto s6_final;
		}
		tpush_macro(t_type);
		par_next();
		goto s1_pre_ops;

	case COLON_TOK:

		/* There is no matching '?' since the operator stack is empty. */
		TRACEP(ftagv, es("terminal ':'\n"));
		goto s6_final;

	case QUESTION_TOK:

		/* Count question marks to be able to detect an excess ':' */
		TRACEP(ftagv, es("ternary++\n"));
		ternary++;
		tpush_macro(t_type);
		par_next();
		goto s1_pre_ops;

	case LONG_TOK:
	case INT_TOK:
	case STRING_TOK:
		error(es("extra constant ignored"));
		par_next();
		goto s4_binop_or_rparen;

	case ID_TOK:
		error(es("extra identifier ignored: "); es(t_symbol));
		par_next();
		goto s4_binop_or_rparen;

	default:
		if (is_binop(t_type)) {
			/* Valid operator.  Push it and enter S1. */
			tpush_macro(t_type);
			par_next();
			goto s1_pre_ops;
		}
		else if (is_unop(t_type)) {
			error(es("extra unary operator ignored: "); etok(par_token_ptr));
			par_next();
			goto s4_binop_or_rparen;
		}
		else {
			error(es("run on expression at "); etok(par_token_ptr));
			goto s6_final;
		}
	}

	/*
		s5_reduce:

		The operator stack is not empty.
		Compare the operator on the op stack with the current operator.
		The operator on the stack may be a cast operator

		Operators are popped here and in reduce()
	*/
s5_reduce:

	op = ttop_macro();

	TRACEP("expr",
		es("s5_reduce op: "); etoknum(op);
		es(" ternary = "); eint(ternary); enl());

	/*
		Unknown or known reducible t_types get reduced.
		Other t_types get pushed at push_it.
	*/

	switch(t_type) {

	case RPAREN_TOK:

		if (op == LPAREN_TOK) {

			if (comma_ok &gt; 0) {
				comma_ok--;
			}

			TRACEP(ftagv, es("comma_ok: "); elong(comma_ok); enl());

			/* Cancel the matching '(' and look for any post ops. */
			tjunk_top_macro();
			par_next();
			goto s3_post_ops;
		}

		/*
			There is no matching '(' so the ')' terminates the expression.
			Reduce all elements of the stack.
		*/
		goto reduce_it;

	case QUESTION_TOK:

		if (expr_can_reduce(op, t_type)) {
			goto reduce_it;
		}

		/* first of ternary pair */
		TRACEP(ftagv, es("QUESTION_TOK: ternary++\n"));
		ternary++;
		goto push_it;

	case COLON_TOK:

		/* second of ternary pair */
		if (expr_can_reduce(op, t_type) || ternary == 0) {
			goto reduce_it;
		}
		ternary--;
		goto push_it;

	case COMMA_TOK:

		if (!comma_ok || expr_can_reduce(op, t_type)) {
			goto reduce_it;
		}
		else {
			goto push_it;
		}

	default:

		if (!is_binop(t_type)) {
			TRACEP(ftagv, es("not binop: "); etok(par_token_ptr); enl());
			goto reduce_it;
		}
		if (expr_can_reduce(op, t_type)) {
			goto reduce_it;
		}
		else {
			goto push_it;
		}
	}

	/* Push the operator and look for an operand. */

push_it:

	TRACEP(ftagv, es("push_it\n"));

	tpush_macro(t_type);
	par_next();
	goto s1_pre_ops;

	/* Reduce the operator that's on the stack and try again. */

reduce_it:

	TRACEP(ftagv, es("reduce_it\n"));

	tjunk_top_macro();
	if (op == CAST_TOK) {
		xpop_macro(t);
		TRACEP(ftagv, es("cast type: "); etnode(t); enl());
	}
	else if (op == LPAREN_TOK) {
		error(es("excess or misplaced '(' in expression"));
		goto s4_binop_or_rparen;
	}
	else {
		t = NULL;
	}
	expr_reduce (op,t);
	goto s4_binop_or_rparen;

/*
	State s6_final: End of expression.
*/

s6_final:

	TRACEP(ftagv, es("s6_final: ecount: "); elong(ecount);
		es(" ecount-esave: "); elong(ecount-esave); enl());

	epop_macro(p); /* the last one off the stack */

	TRACEP(ftagv, eenode(p); enl());

	if (ecount != esave) {
		error(es("too many operands"));
	}
	tcount = tsave;
	ecount = esave;

	TRACEPX(ftag,
		es(comma_ok ? "ALLOW_COMMAS" : "DONT_ALLOW_COMMAS"); ecs();
		es(unary_expr_flag ? "UNARY_EXP" : "ARB_EXP"); eblank();
		eret(); eenode(p); enl());
	return p;
}
</t>
<t tx="ekr.20080529093004.560">@ Return TRUE if we can reduce opr1 when opr2 follows.  This code reflects the table on page 49 of K &amp; R, except that LPAREN_TOK has the *lowest* precedence and associates R to L.
@c

static bool
expr_can_reduce(register token opr1, register token opr2)
{
	FTAG("expr_can_reduce");
	register int prec1 = 0, prec2 = 0;
	bool result = TRUE;
	STATB(ftag);

	if (opr1 == LPAREN_TOK) {

		/* Force the pushing of opr2. */
		goto false_ret;
	}

	prec1 = expr_prec(opr1);
	prec2 = expr_prec(opr2);

	if (prec1 &gt; prec2) {
		goto true_ret;
	}

	if (prec1 &lt; prec2) {
		goto false_ret;
	}

	/* prec1 == 3 is the ternary */
	if (prec1 == 14 || prec1 == 3 || prec1 == 2) {

		/* Associate right to left. */
		goto false_ret;
	}

	/* Associate left to right. */
	goto true_ret;

true_ret:
	result = TRUE;
	goto done;

false_ret:
	result = FALSE;
	goto done;

done:
	TRACEPX(ftag,
		eret(); ebool(result); ecs();
		etoknum(opr1); ecs(); etoknum(opr2); enl());

	return result;
}
</t>
<t tx="ekr.20080529093004.561">@ Parse a primitive constant and return an enode node corresponding to it.  Constants can not be converted to values in the preprocessor because token pasting can create valid parser tokens from preprocessing tokens that are not, by themselves, valid parser tokens.  It is still not clear whether this routine should actually convert the characters representing constants into "execution-time" values. When generating assembly-language output, simply passing the spelling of a constant to the assembler may be convenient.  When generating relocatable code, however, the conversion must indeed be made, and this is the place to do it. This conversion is complicated by the fact that there is no ANSI library routine to convert from strings to long doubles! The present code ignores the difficulty and simply uses the strtod function. Constants too big too fit in a double are thus not possible yet.  The type of a floating constant is not affected by its value. Indeed, only the presence or absence of the l, L, f or F suffixes affect the type of a floating constant.
@c

static enode *
expr_cprim(void)
{
	FTAG("expr_cprim");
	register const_enode * cep = NULL;
	register tnode * t  = NULL;
	STATB(ftag);

	switch(t_type) {

	case CHAR_TOK:
	{
		long val = char_val(t_ptr);;

		TRACEPN(ftag,
			es("char (byte) "); elong(val); es(" = "); ehex(val); es(" hex\n"));

		new_tnode_macro(t, INT_TYPE, 1);
		t_set_const(t);
		t_set_char(t);

		new_enode_macro(cep, sizeof(const_enode), INT_TOK);
		cep -&gt; e_ctype = t;
		econst_long(cep) = val;

		par_next();
		break;
	}

	/*
		Section 3.1.3.1: Floating constants.

		"An unsuffixed floating constant has type double.
		If suffixed by the letter f or F, it has type float.
		If suffixed by the letter l or L, if has type long double."

		Unlike integer constants, the value of a float constant does
		not affect the type of the constant.

		Floating constants are represented by const_anodes containing
		the value of the constant and a pointer to the label of the constant.
		The a_length field of the constant is always REGISTER_SIZE
		because constants are represented by their addresses.
	*/
	case FLOAT_TOK:
	{
		int gkind = 0;
		int ckind = 0;
		char * s = ptr_tok_ptr(par_token_ptr);

		new_tnode_macro(t, FLOAT_TYPE, FLOAT_SIZE);
		t_set_const(t);

		/*
			Set the t -&gt; tmods field depending on the suffixes.
			It may be desirable to remove the suffix from the spelling,
			but this need only be done if we actually need the spelling!
		*/
		{
			size_t length = strlen(s);

			if (s &amp;&amp; (s[length-1] == 'l' || s[length-1] == 'L')) {

				/* Long double constant. */
				if (LONG_DOUBLE_SIZE &gt; DOUBLE_SIZE) {
					t_set_long_double(t);
					ckind = LONG_DOUBLE_CKIND;
				}
				else {
					t_set_double(t);
					ckind = DOUBLE_CKIND;
				}
				s[length-1] = '\0';
			}
			else if (s &amp;&amp; (s[length-1] == 'f' || s[length-1] == 'F')) {

				/* Float constant. */
				if (FLOAT_SIZE &lt; DOUBLE_SIZE) {
					t_set_float(t);
					ckind = FLOAT_CKIND;
				}
				else {
					t_set_double(t);
					ckind = DOUBLE_CKIND;
				}
				s[length-1] = '\0';
			}
			else {

				/* Double constant is the default. */
				t_set_double(t);
				ckind = DOUBLE_CKIND;
			}
		}

		{
			anode * ap = NULL;

			/* Create an anode representing the constant. */
			ap = gen_new_big_anode(ckind, t_ptr);
			ap -&gt; a_length = REGISTER_SIZE;

			new_enode_macro(cep, sizeof(const_enode), FLOAT_TOK);
			cep -&gt; e_ctype = t;
			econst_anode(cep) = ap;
			econst_defstr(cep) = t_ptr;
			
			#if 0 /* Never used */
				econst_long_double(cep) = eval_fstring(t_ptr);
			#endif

			if (!dcl_initializer_flag) {
				out_data_clabel(
					const_anode_ptr(ap) -&gt; a_label, DEFINE_THE_LABEL, NO_COMMENT);
				out_data_float(t_ptr, ckind);
			}
		}
		par_next();
		break;
	}

	/*
		Section 3.1.3.2: Integer constants.

		"The value of a decimal constant is computed base 10;
		that of an octal constant, base 8;
		that of a hexadecimal constant, base 16."

		"The type of an integer constant is the first of the corresponding list
		in which its value can be represented.
		Unsuffixed decimal: int, long int, unsigned long int;
		unsuffixed octal or hexadecimal: int, unsigned int, unsigned long int;
		suffixed by the letter u or U: unsigned int, unsigned long int;
		suffixed by the letter l or L: long int, unsigned long int;
		suffixed by both the letters u or U or l or L: unsigned long int."

		EKR: It is clear that both the form and the value of an integer constant
		are significant in determining the C type of the constant.
		Consequently, care must be taken to evaluate the constant correctly here,
		even if the value is not retained in the constant enode.

		By the way, the actual evaluation of an integer constant is handled
		by eval_string.
	*/

	case INT_TOK:
	case LONG_TOK:
	{
		char * s = ptr_tok_ptr(par_token_ptr);
		size_t len = 0;
		bool u_flag = FALSE;
		bool l_flag = FALSE;

		ASSERT(s);
		len = strlen(s);
		ASSERT(len &gt; 0);

		/*
			Create the default type and enodes.
			The tmods and tsize field of t may be changed below.
		*/
		new_tnode_macro(t, INT_TYPE, 0);
		t_set_const(t);

		new_enode_macro(cep, sizeof(const_enode), INT_TOK);
		cep -&gt; e_ctype = t;

		/* Look for trailing U, UL, L, LU or the lower-case variants. */
		u_flag =
			(len &gt; 0 &amp;&amp; (s[len-1] == 'U' || s[len-1] == 'u')) ||
			(len &gt; 1 &amp;&amp; (s[len-2] == 'U' || s[len-2] == 'u'));

		l_flag =
			(len &gt; 0 &amp;&amp; (s[len-1] == 'L' || s[len-1] == 'l')) ||
			(len &gt; 1 &amp;&amp; (s[len-2] == 'L' || s[len-2] == 'l'));

		if (u_flag &amp;&amp; l_flag) {

			econst_ulong(cep) = eval_ustring(t_ptr);
			t_set_unsigned(t);
			t_set_long(t);
		}
		else if (u_flag) {

			econst_ulong(cep) = eval_ustring(t_ptr);
			t_set_unsigned(t);
			t -&gt; tsize = c_ulong2mlen(econst_ulong(cep));
		}
		else if (l_flag) {

			econst_long(cep) = eval_string(t_ptr);
			t_set_long(t);
		}
		else {

			/*
				The type of the constant depends on its value.
				Bug fix: call eval_ustring, not eval_string.
				This allows big unsigned to be treated properly
			*/
			econst_long(cep) = eval_ustring(t_ptr);

			if (econst_long(cep) &lt; -INT_MAX - 1) {
				t_set_long(t);
			}
			else if (econst_long(cep) &gt; UINT_MAX) {
				t_set_unsigned(t);
				t_set_long(t);
			}
			else if (econst_long(cep) &gt; INT_MAX) {
				t_set_long(t);
			}
			else if (econst_long(cep) &lt; -256 || econst_long(cep) &gt; 255) {
				t_set_short(t);
			}
			else {
				t_set_char(t);
			}
		}

		ASSERT(t -&gt; tsize);

		par_next();
		break;
	}

	case K_SIZEOF:

		new_tnode_macro(t, INT_TYPE, INT_SIZE);
		t_set_const(t);
		t_set_unsigned(t);

		new_enode_macro(cep, sizeof(const_enode), INT_TOK);
		cep -&gt; e_ctype = t;
		econst_ulong(cep) = expr_sizeof();
		break;

	case STRING_TOK:
	{
		tnode * t1 = NULL;
		snode * sp = NULL;
		anode * ap = NULL;

		/* Create tnode t describing an array of chars. */
		new_tnode_macro(t1, INT_TYPE, CHAR_SIZE);
		t_set_const(t1);
		t_set_char(t1);

		new_tnode_macro(t, ARRAY_TYPE, INT_SIZE);
		t -&gt; ttype = t1;
		t_set_const(t);

		/* Create an anode representing the string. */
		ap = gen_new_big_anode(STRING_CKIND, t_ptr);

		/* Create a new const_enode. */
		new_enode_macro(cep, sizeof(const_enode), STRING_TOK);
		cep -&gt; e_ctype = t;
		econst_defstr(cep) = t_ptr;
		econst_anode(cep) = ap;

		if (!dcl_initializer_flag) {
			out_string_clabel(const_anode_ptr(ap) -&gt; a_label, NO_COMMENT);
			out_data_string(t_ptr, ADD_TRAILING_ZERO, DONT_FORCE_DATA_AREA);
		}

		par_next();
		break;
	}

	default:
		fatal(es("called with bad type at: "); es(t_symbol));
	}

	TICKX(ftag);
	return enode_ptr(cep);
}
</t>
<t tx="ekr.20080529093004.562">@ Parse and return the value of an *signed integer* constant expression. Set err_flag in the caller if the expression is not a constant integer.  Section 3.4: Constant Expressions.  "Constant expressions shall not contain assignment, increment, decrement, function-call, or comma operators, except when they are contained in a sizeof operator."  "An *integral constant expression" shall have integral type and shall only have operands that are integer constants, enumeration constants, character constants, sizeof expressions, and floating constants that are the immediate operands of casts. Cast operators in an integral canstant expression shall only convert arithmetic types to integral types, except as part of an operand to a sizeof operator."  More latitude is permitted for constant expressions in initializers... (See expr_is_init_const for the rest of more details from The Standard.)
@c

long
expr_const_int(bool * err_flag)
{
	FTAG("expr_const_int");
	enode * ep = NULL;
	long val = 0L;
	TICKB(ftag);

	/* Do not allow commas. */
	ep = expr(DONT_ALLOW_COMMAS);

	/* This test is trivial because of constant folding. */
	*err_flag = (ep -&gt; n_type != INT_TOK);
	val = *err_flag ? 0L : econst_long(ep);

	TRACEPX(ftag, eret(); elong(val); es(", *err_flag: "); ebool(*err_flag); enl());
	return val;
}
</t>
<t tx="ekr.20080529093004.563">@ Return TRUE if ep represents a constant that would shortcut a flow-of-control construct such as 'if', 'for' or 'while'.
@c

bool
expr_is_const(enode * ep)
{
	FTAG("expr_is_const");

	return ep &amp;&amp; ep -&gt; n_type == INT_TOK;
}
</t>
<t tx="ekr.20080529093004.564">@ Return TRUE if ep represents a constant valid in an initializer.  Section 3.4: Constant Expressions.  ...More latitude is permitted for constant expressions in initializers. Such a constant expression shall evaluate to one of the following:  o an arithmetic constant expression, o a null pointer constant, o an address constant, or o an address constant for an object type plus or minus an integral constant  expression."  "An *arithmetic constant expression* shall have arithmetic type and shall only have operands that are integer constants, floating constants, enumeration constants, character constants and sizeof expressions. Cast operators in an integral canstant expression shall only convert arithmetic types to integral types, except as part of an operand to a sizeof operator."  "An *address constant* is a pointer to an lvalue designating an object of static storage duration, or to a function designator; it shall be created explicitly, using the &amp; operator, or implicitly, by the use of an expression of array or function type. The array-subscript [ ] and member-access . and -&gt; operators, the address &amp; and indirection * unary operators, and pointer casts may be used in the creation of an address constant, but the value of an object shall not be accessed by the use of these operators."  "An implementation may accept other forms of constant expresssions."
@c

bool
expr_is_init_const(enode * ep)
{
	FTAG("expr_is_init_constant");

	if (ep == NULL) {
		return FALSE;
	}

	switch (ep -&gt; n_type) {
	
	case UPLUS_TOK:
	case UMINUS_TOK:
	
		/*
			8/27/94: Floating constants are not folded yet,
			so this is essential to handle initializers.
		*/
		return op1_ptr(ep) -&gt; arg1 &amp;&amp; expr_is_init_const(op1_ptr(ep) -&gt; arg1);

	case FLOAT_TOK:
	case INT_TOK:
	case STRING_TOK:

		/* Normal constant. */
		return TRUE;

	case ID_TOK:

		/*
			An identifier may only be used to initialize a pointer.
			Only names of arrays with static storage duration are valid.
		*/
		return

			ep -&gt; e_ctype &amp;&amp;
				(
					ep -&gt; e_ctype -&gt; tprim == POINTER_TYPE ||
					ep -&gt; e_ctype -&gt; tprim == ARRAY_TYPE
				) &amp;&amp;
			s_is_array(var_enode_ptr(ep) -&gt; e_var) &amp;&amp;
			!s_is_auto(var_enode_ptr(ep) -&gt; e_var) &amp;&amp;
			!s_is_formal(var_enode_ptr(ep) -&gt; e_var);

	case CAST_TOK:
	{
		enode * arg1 = op1_ptr(ep) -&gt; arg1;

		if (arg1 == NULL || arg1 -&gt; e_ctype == NULL) {
			return FALSE;
		}
		else {
			return expr_is_init_const(arg1);
		}
	}

	case ARRAY_TOK:
	case ARROW_TOK:
	case CALL_TOK:
	case DOT_TOK:
	case UAND_TOK:
	case USTAR_TOK:

		/* Address constant: The type of the expression should be a pointer. */
		return
			ep -&gt; e_ctype &amp;&amp;
			(
				ep -&gt; e_ctype -&gt; tprim == POINTER_TYPE ||
				ep -&gt; e_ctype -&gt; tprim == ARRAY_TYPE
			);

	case PLUS_TOK:
	case MINUS_TOK:
	case STAR_TOK:
	case DIV_TOK:

		return	expr_is_init_const(op2_ptr(ep) -&gt; arg1) &amp;&amp;
				expr_is_init_const(op2_ptr(ep) -&gt; arg2);

	default:
		return FALSE;
	}
}
</t>
<t tx="ekr.20080529093004.565">@ Parse a list of expressions separated by commas. Make a cons_enode there is more than one argument.  The type tells the expected type of the list.
@c

static enode *
expr_list1(void)
{
	FTAG("expr_list1");
	register enode * p = NULL;
	register cons_enode * q = NULL;
	enode * head = NULL;
	enode * prev = NULL;
	TICKB(ftag);

	for (;;) {

		p = expr1(DONT_ALLOW_COMMAS, ARBITRARY_EXPRESSION);
		if (p == NULL) {
			break;
		}

		if (head == NULL) {
			/* No cons enode needed yet. */
			head = p;
		}
		else {
			new_enode_macro(q, sizeof(cons_enode), CONS_TOK);

			if (prev == NULL) {
				/* Initial cons enode.  No unlinking to do. */
				q -&gt; cons_car = head;
				q -&gt; n_next = p;
				head = (enode *) q;
				prev = (enode *) q;
			}
			else {
				/* Change the list structure. */
				q -&gt; cons_car = prev -&gt; n_next;
				q -&gt; n_next = p;
				prev -&gt; n_next = q;
				prev = (enode *) q;
			}
		}

		/* Continue as long as comma is seen. */
		if (!is(COMMA_TOK)) {
			break;
		}
		par_next();
	}

	TRACEPX(ftag, eret(); eenode(head); enl());
	return head;
}
</t>
<t tx="ekr.20080529093004.566">@ Return the precedence of an operator. Parentheses are handled separately.  This code reflects the table on page 49 of K &amp; R.  If an operator can be both unary and binary, the default form (not known yet whether unary or binary) must be the binary form. Consider a + b &amp;
@c

typedef struct prec_struct prec_node;

static struct prec_struct {
	int 	precedence;
	token	check_token;
};

/*
	Warning: the order of the elements of this table must
	match the order in which the tokens are defined in CC2tok.h.
*/
static prec_node prec_tab [] = {

	-1,	UNOP_RANGE_BEGIN,

	14,	CAST_TOK,
	14,	DEC_TOK,
	14,	INC_TOK,
	14,	POST_DEC_TOK,
	14,	POST_INC_TOK,
	14,	PRE_DEC_TOK,
	14,	PRE_INC_TOK,
	14,	NOT_TOK,
	14,	TILDE_TOK,
	14,	UAND_TOK,
	14,	UMINUS_TOK,
	14,	UPLUS_TOK,
	14,	USTAR_TOK,

	-1, UNOP_RANGE_END,

	-1, BINOP_RANGE_BEGIN,		/* Start of binary operators... */

	 8,	AND_TOK,
	 2,	AND_ASSN_TOK,
	 0, ARRAY_TOK,		/* Precedence is unused. */
	15,	ARROW_TOK,
	 2,	ASSN_TOK,
	 0, CALL_TOK,		/* Precedence is unused. */
	 1,	COMMA_TOK,
	13,	DIV_TOK,
	 2,	DIV_ASSN_TOK,
	15,	DOT_TOK,
	 9,	EQUAL_TOK,
	10,	GE_TOK,
	10,	GT_TOK,
	 5,	LAND_TOK,
	10,	LE_TOK,
	 4,	LOR_TOK,
	11,	LSHIFT_TOK,
	 2,	LSHIFT_ASSN_TOK,
	10,	LT_TOK,
	12,	MINUS_TOK,
	 2,	MINUS_ASSN_TOK,
	13,	MOD_TOK,
	 2,	MOD_ASSN_TOK,
	 9,	NE_TOK,
	 6,	OR_TOK,
	 2,	OR_ASSN_TOK,
	12,	PLUS_TOK,
	 2,	PLUS_ASSN_TOK,
	11,	RSHIFT_TOK,
	 2,	RSHIFT_ASSN_TOK,
	13,	STAR_TOK,
	 2,	STAR_ASSN_TOK,
	 7,	XOR_TOK,
	 2,	XOR_ASSN_TOK,

	 -1,BINOP_RANGE_END,

	 3,	COLON_TOK,
	 3,	QUESTION_TOK,

	 15, LBRACK_TOK, /* Has precedence, but is not an operator. */
	 15, LPAREN_TOK, /* Has precedence, but is not an operator. */
};

static int
expr_prec(int op)
{
	FTAG("expr_prec");

	if (op == K_SIZEOF) {
		return 14;
	}
	else {
		ASSERT(op &gt; OP_RANGE_BEGIN &amp;&amp; op &lt; OP_RANGE_END);
		TRACEPN(ftag,
			es(tok_name(op)); es(" = "); eint(prec_tab [op-OP_RANGE_BEGIN-1] . precedence));
		return prec_tab [op-OP_RANGE_BEGIN-1] . precedence;
	}
}
</t>
<t tx="ekr.20080529093004.567">@ Parse a (syntactical) primitive and return a pointer.  Return a pointer to a suitable enode.  Items treated as primitives are:  identifier  constant (including sizeof)  Dn, An
@c

static enode *
expr_prim(void)
{
	FTAG("expr_prim");
	register enode * ep = NULL;
	register snode * id = NULL;
	int reduce_tok = NULL_TOK;
	TRACEPB(ftag,
		es("at "); etok(par_token_ptr); enl());

	switch (t_type) {

	case INT_TOK:
	case LONG_TOK:
	case CHAR_TOK:
	case FLOAT_TOK:
	case K_SIZEOF:
	case STRING_TOK:
		ep = expr_cprim();
		break;

	case ID_TOK:

		new_enode_macro(ep, sizeof(var_enode), ID_TOK);

		{
			int tok = ttop_macro();
			enode * top_loc = etop_macro();

			if (tok == ARROW_TOK) {

				/* Make sure the top of the stack is a pointer to a struct or union. */
				if (
					top_loc &amp;&amp;
					top_loc -&gt; e_ctype &amp;&amp;
					top_loc -&gt; e_ctype -&gt; tprim == POINTER_TYPE &amp;&amp;
					top_loc -&gt; e_ctype -&gt; ttype &amp;&amp;
					(top_loc -&gt; e_ctype -&gt; ttype -&gt; tprim == STRUCT_TYPE ||
					 top_loc -&gt; e_ctype -&gt; ttype -&gt; tprim == UNION_TYPE)
				) {

					/* Check for a field name b in a -&gt; b */
					id = st_lookup_field(
						t_spell, snode_ptr(top_loc -&gt; e_ctype -&gt; ttype -&gt; ttype));

					if (id == NULL) {

						error(
							es(t_spell -&gt; spell_name);
							es(" is not a field");
							if (snode_ptr(top_loc -&gt; e_ctype -&gt; ttype -&gt; ttype) -&gt; spell) {
								es(" of ");
								es(snode_ptr(top_loc -&gt; e_ctype -&gt; ttype -&gt; ttype) -&gt;
									spell -&gt; spell_name);
							}
							else {
								es(" of the '-&gt;' expresssion.");
							}
						);
					}

					/* Reduce the ARROW_TOK on exit even if there was an error. */
					reduce_tok = ARROW_TOK;
				}
				else {
					error(es("'-&gt;. requires a struct/union pointer"));
				}
			}
			else if (tok == DOT_TOK) {

				if (
					top_loc &amp;&amp;
					top_loc -&gt; e_ctype &amp;&amp;
					(top_loc -&gt; e_ctype -&gt; tprim == STRUCT_TYPE ||
					 top_loc -&gt; e_ctype -&gt; tprim == UNION_TYPE)
				) {

					/* Check for a field name b in a . b */
					id = st_lookup_field(
						t_spell, snode_ptr(top_loc -&gt; e_ctype -&gt; ttype));

					if (id == NULL) {
						error(
							es(t_spell -&gt; spell_name);
							es(" is not a field");
							if (snode_ptr(top_loc -&gt; e_ctype -&gt; ttype) -&gt; spell) {
								es(" of ");
								es(snode_ptr(top_loc -&gt; e_ctype -&gt; ttype) -&gt;
									spell -&gt; spell_name);
							}
							else {
								es(" of the '.' expresssion.");
							}
						);
					}

					/* Reduce the DOT_TOK on exit even if there was an error. */
					reduce_tok = DOT_TOK;
				}
				else {
					error(es("'.' requires a struct/union"));
				}
			}
			else {
				id = st_lookup(t_spell);

			}

		} /* end block. */

		if (id == NULL) {

			register tnode * t = NULL;
			new_tnode_macro(t, INT_TYPE, INT_SIZE);
			new_snode_macro(id, KP_VAR);
			id -&gt; ctype = t;
			id -&gt; spell = t_spell;

			/* Bug fix: 4/7/92: Set the e_var field. */
			ASSERT(ep &amp;&amp; ep -&gt; n_type == ID_TOK);
			var_enode_ptr(ep) -&gt; e_var = id;

			st_enter(id);
			par_next();

			if (is(LPAREN_TOK)) {

				/* Assume it's a function returning an int. */
				tnode * func_t = NULL;
				new_tnode_macro(func_t, FUNCTION_TYPE, 0L);
				func_t -&gt; ttype = t;
				id -&gt; ctype = func_t;
				s_set_code(id);
			}
			else if (reduce_tok == NULL_TOK) {

				/* Null out the type--this will suppress error messages later. */
				id -&gt; ctype = NULL;
				error(
					es("undefined variable: ");
					es(id -&gt; spell -&gt; spell_name));
			}
		}
		else if (id -&gt; n_type == KP_ENUM_ELEM) {

			/* An enumeration constant. */
			tnode * t = NULL;
			new_tnode_macro(t, INT_TYPE, INT_SIZE);
			t_set_const(t);

			/* Create a new constant enode. */
			new_enode_macro(ep, sizeof(const_enode), INT_TOK);

			/* Get the value from the initializer. */
			ASSERT(
				id -&gt; vlist &amp;&amp;
				id -&gt; vlist -&gt; itype == EXPR_ITYPE &amp;&amp;
				id -&gt; vlist -&gt; i_expr &amp;&amp;
				id -&gt; vlist -&gt; i_expr -&gt; n_type == INT_TOK);

			econst_long(ep) = econst_long(id -&gt; vlist -&gt; i_expr);
			ep -&gt; e_ctype = t;

			TRACEPN(ftag,
				es("converting enum id: "); es(t_symbol);
				es(" to "); elong(econst_long(ep)); enl());
			par_next();
			break;
		}
		else {
			ASSERT(ep -&gt; n_type == ID_TOK);
			var_enode_ptr(ep) -&gt; e_var = id;
			var_enode_ptr(ep) -&gt; e_ctype = id -&gt; ctype;
			par_next();
		}
		break;

	default:
		error(es("primitive expected at "); etok(par_token_ptr));
		par_next();
		ep = NULL;
	}

	/* A kludge: reduce an ARROW_TOK or DOT_TOK if necessary. */
	if (reduce_tok != NULL_TOK) {
		epush_macro(ep);
		tjunk_top_macro();
		expr_reduce(reduce_tok, NULL);
		epop_macro(ep);
	}

	TRACEPX(ftag,
		eret(); eenode(ep);
		ecs(); etnode(ep -&gt; e_ctype); enl());
	return ep;
}
</t>
<t tx="ekr.20080529093004.568">@ Reduce any operator (including '[') by popping operands off the enode stack and pushing a result.  The type t is used only for unops, presumably for casts.
@c

static void
expr_reduce(int op, tnode *t)
{
	FTAG("expr_reduce");
	TRACEPB(ftag, etoknum(op); enl());

	switch (op) {

	case LBRACK_TOK:
	{
		register op2_enode * op2 = NULL;
		register enode * ep = NULL;

		par_next();
		new_enode_macro(op2, sizeof(op2_enode), ARRAY_TOK);
		op2 -&gt; e_nargs = 2;
		op2 -&gt; arg2 = expr1(ALLOW_COMMAS, ARBITRARY_EXPRESSION);
		epop_macro(op2 -&gt; arg1); /* array-id expression */

		TRACEPN(ftag, es("array\n"));

		/* Type the expression *before* folding constants. */
		op2 = ct_type2(op2, DONT_ALLOW_ASSN_TO_CONST);

		/* Fold constant expressions. */
		ep = fold(enode_ptr(op2));

		epush_macro(ep);

		(void) par_needend(RBRACK_TOK);
		break;
	}

	case LPAREN_TOK:
	{
		op2_enode * opc = NULL;
		register enode * ep = NULL;
		register int count = 0;

		par_next();
		new_enode_macro(opc, sizeof(op2_enode), CALL_TOK);
		opc -&gt; e_nargs = 2;

		opc -&gt; arg2 = expr_list1();

		/*
			Check the types of the arguments.
		*/
		for (ep = opc -&gt; arg2; ep; ep = ep -&gt; n_next) {

			enode * ep2 = (ep -&gt; n_type == CONS_TOK) ? cons_ptr(ep) -&gt; cons_car : ep;
			ASSERT(ep2);
			count++;

			if (ep2 &amp;&amp; ep2 -&gt; e_ctype) {

				int prim = ep2 -&gt; e_ctype -&gt; tprim;

				if (
					prim != ARRAY_TYPE &amp;&amp;
					prim != CAST_TYPE &amp;&amp;
					prim != INT_TYPE &amp;&amp;
					prim != FLOAT_TYPE &amp;&amp;
					prim != POINTER_TYPE &amp;&amp;
					prim != STRUCT_TYPE &amp;&amp;
					prim != UNION_TYPE
				) {
					error(
						es("function argument ");
						eint(count); es(" is invalid"));
				}
			}
		}

		/*
			Count the number of calls to functions g1, g2...gn with one argument
			IN THE CURRENT FUNCTION, say f.
			See extensive comments in gen.c concerning gen_call_1arg.
		*/
		if (opc -&gt; arg2 &amp;&amp; opc -&gt; arg2 -&gt; n_type != CONS_TOK) {
			gen_call_1arg++;
		}

		epop_macro(opc -&gt; arg1); /* function-id expression */
		if (
			! (
				opc -&gt; arg1 &amp;&amp;
				opc -&gt; arg1 -&gt; e_ctype &amp;&amp;
				opc -&gt; arg1 -&gt; e_ctype -&gt; tprim == FUNCTION_TYPE
			)
		) {
			error(
				es("function prototype required");
				if (
					opc -&gt; arg1 &amp;&amp;
					opc -&gt; arg1 -&gt; n_type == ID_TOK &amp;&amp;
					var_enode_ptr(opc -&gt; arg1) -&gt; e_var &amp;&amp;
					var_enode_ptr(opc -&gt; arg1) -&gt; e_var -&gt; spell
				) {
					es(" for ");
					es(var_enode_ptr(opc -&gt; arg1) -&gt; e_var -&gt; spell -&gt; spell_name);
				}
			);
		}
		else {
			opc = ct_type2(opc, DONT_ALLOW_ASSN_TO_CONST);
		}
		epush_macro( (enode *) opc);

		(void) par_needend(RPAREN_TOK);
		break;
	}

	case COLON_TOK:

		if (tcount &gt; 0 &amp;&amp; (op = ttop_macro()) == QUESTION_TOK) {

			op3_enode * op3 = NULL;

			tjunk_top_macro();
			new_enode_macro(op3, sizeof(op3_enode), QUESTION_TOK);
			op3 -&gt; e_nargs = 3;
			epop_macro(op3 -&gt; arg3);
			epop_macro(op3 -&gt; arg2);
			epop_macro(op3 -&gt; arg1);

			ct_type3(op3);
			epush_macro( (enode *) op3);
		}
		else {

			/* Just align the stack. */
			ejunk_top_macro();
			error(es("unexpected ':'"));
		}
		break;

	case QUESTION_TOK:

		/* Just align the stack. */
		ejunk_top_macro();
		error(es("'?' without associated ':'"));
		break;

	default:

		if (is_binop(op)) {

			op2_enode * op2 = NULL;
			enode * ep = NULL;

			/* Create a binary enode. */
			new_enode_macro(op2, sizeof(op2_enode), op);
			op2 -&gt; e_nargs = 2;
			epop_macro(op2 -&gt; arg2);
			epop_macro(op2 -&gt; arg1);

			/* Type the expression *before* folding constants. */
			op2 = ct_type2(op2, DONT_ALLOW_ASSN_TO_CONST);
			ep = fold(enode_ptr(op2));

			epush_macro(ep);
		}
		else if (is_unop(op)) {

			register op1_enode * op1 = NULL;
			register enode * ep = NULL;

			/* Create a new unary enode. */
			new_enode_macro(op1, sizeof(op1_enode), op);
			op1 -&gt; e_nargs = 1;
			epop_macro(op1 -&gt; arg1);

			op1 -&gt; e_ctype = t;

			/* Set the type of the result *before* folding. */
			ct_type1(op1);

			/* Fold constant expressions. */
			ep = fold(enode_ptr(op1));
			epush_macro(ep);

			/*
				Count the number of calls to functions g1, g2...gn with one argument
				IN THE CURRENT FUNCTION, say f.
				See extensive comments in gen.c concerning gen_call_1arg.

				4/15/93:
				Floating unary ops are implemented via function call
				to a function with possibly one argument.
			*/
			if (ep -&gt; e_ctype -&gt; tprim == FLOAT_TYPE) {
				gen_call_1arg++;
			}
		}
		else {

			/* A bad op should never be pushed in the first place! */
			fatal(es("bad operator"));
		}
		break;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.569">@ Return the *result* of a sizeof expression, i.e., a number, not a enode.
@c

static ulong
expr_sizeof(void)
{
	FTAG("expr_sizeof");
	register enode * p = NULL;
	register tnode * t = NULL;
	register ulong size = 0L;
	bool paren_flag = FALSE;
	TICKB(ftag);

	/* Eat the 'sizeof' */
	par_next();

	/* Bug fix: 7/19/93: only types must be parenthesized. */
	paren_flag = is(LPAREN_TOK);
	if (paren_flag) {
		par_next();
	}

	t = dcl_cast();
	if (t == NULL) {

		/*
			Bug fix: 7/19/93:
			Only unary expressions are allowed when there is no parens.
			For example, consider:

				long a = (sizeof 1 == sizeof 2);

			This must be equivalent to:

				long a = (sizeof(1) == sizeof(2))

			rather than:

				long a = (sizeof (1 == sizeof(s)))
		*/
		if (paren_flag) {
			p = expr1(ALLOW_COMMAS, ARBITRARY_EXPRESSION);
		}
		else {
			p = expr1(DONT_ALLOW_COMMAS, UNARY_EXPRESSION);
		}

		if (p == NULL) {
			error(es("sizeof has no argument"));
			size = 0;
		}
		else if (p -&gt; e_ctype == NULL) {
			/* This can happen because of user error. */
			size = 0;
		}
		else {
			size = p -&gt; e_ctype -&gt; tsize;
			if (size == 0) {
				error(es("sizeof returns zero"));
			}
		}
	}
	else {
		/* We got a type. */
		size = t -&gt; tsize;
		if (size == 0) {
			error(es("sizeof returns zero"));
		}
	}

	if (paren_flag) {
		par_need(RPAREN_TOK);
	}

	TRACEPX(ftag, eret(); eint(size); enl());

	return size;
}
</t>
<t tx="ekr.20080529093004.570">@ Dump the token stack.
@c

static void
expr_tdump(void)
{
	register int i = 0;

	for (i = tcount-1; i &gt;= 0; i--) {
		eblank(); etoknum(tstack[i]);
	}
	ecnl();
}
</t>
<t tx="ekr.20080529093004.571">/*
	CC2: initialization code.

	Use 4-space tabs for best appearance.

	Source: CCinit.c
	Started: November 12, 1990
	Version:
		June 2, 1994.
			Rewritten based on new memory routines.
*/

/* Always allow Sherlock macros, especially SL_PARSE. */
#undef NO_SHERLOCK

/* include these *before* Sherlock is included. */

#ifdef applec
	#ifndef __size_t__	/* This is used in the MPW headers. */
  	#define __size_t__
		typedef unsigned long size_t;
	#endif

&lt;&lt; CCinit #includes &gt;&gt;
&lt;&lt; CCinit declarations &gt;&gt;
@others

#endif /* THINK_C */

</t>
<t tx="ekr.20080529093004.572">#include &lt;Memory.h&gt;	/* For MaxApplZone. */
</t>
<t tx="ekr.20080529093004.573">#endif

#ifdef THINK_C

#if 0 // don't use when using Universal Headers
	#include &lt;LoMem.h&gt;
#endif

#include &lt;Dialogs.h&gt;
#include &lt;Fonts.h&gt;
#include &lt;Menus.h&gt;
#include &lt;Quickdraw.h&gt;
#include &lt;OSEvents.h&gt;
#include &lt;Windows.h&gt;

#include &lt;LIBdialog.h&gt;

#include &lt;mac_gui.h&gt;
#endif

#include "CC.h"

#include "CCarg.h"
#include "CCinit.h"
#include "CCcpp.h"
#include "CCcomp.h"
#include "CCdump.h"
#include "CCgen.h"
#include "CCinit.h"
#include "CCmem.h"
#include "CCmst.h"
#include "CCtokize.h"

#include &lt;LIBcmnd.h&gt;
#include &lt;LIBend.h&gt;
#include &lt;LIBenv.h&gt;
#include &lt;LIBlog.h&gt;
#include &lt;LIBobj.h&gt;

/*
Function prototypes for internal routines.
The call-back routines are only needed when windows are used.
*/
#ifdef THINK_C
static void dump1_call_back	(void);
static void dump2_call_back	(void);
static void dump3_call_back	(void);
static void	event_call_back	(void);
</t>
<t tx="ekr.20080529093004.574">#endif

/*
	Initialize the environment, Sherlock and all modules.

	The argv vector is not used in some environments, so it is possible
	that a compiler could generate a warning to that effect,
	but trying to eliminate that warning would not be wise:
	we definitely want all initialization done by a single routine.
*/
void
init_all(int argc, char ** argv)
{
	FTAG("init_all");

/*
	When using Think C, we must completely initialize the Mac Toolbox,
	since we are building a stand-along application.

	When using MPW, we must *not* initialize the Toolbox, nor call MaxApplZone.
	Also, we do *not* call InitGraf, since Sherlock uses standard io under MPW.
*/

#ifdef THINK_C

	void * ApplLimit1;		/* Original values before heap and stack are changed. */
	void * CurStackBase1;
	void * HeapEnd1;
	void * ApplZone1;

	/*
		Initialize the ToolBox routines.

		Warning:

		*never* put anything before the follwing instructions.
		Even an inocuous-looking routine like tok_init will crash MaxApplZone().
	*/
	InitGraf( (Ptr) &amp;(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent,0);
	InitWindows();
	InitMenus();
	TEInit();
	InitDialogs(0L);
	InitCursor();

	/* These are defined in LoMem.h, which only exists for Think C, and not on PowerMacs */
	#if 0
		ApplLimit1 = ApplLimit;
		CurStackBase1 = CurStackBase;
		HeapEnd1 = HeapEnd;
		ApplZone1 = ApplZone;
	
		SetApplLimit( (Ptr)(CurStackBase - 9000));
	#endif
	MaxApplZone();

#endif

/*
		Initialize the memory manager.
		This can and should be done before all other initializations.
	*/
	perm_life	= mem_init_life("perm lifetime");
	file_life	= mem_init_life("file lifetime");
	token_life	= mem_init_life("token lifetime");

		/* Statistics for file lifetime. */

	anode_stats =			mem_init_stats (file_life, "anodes");
	cnode_stats =			mem_init_stats (file_life, "cnodes");
	cpp_stats =				mem_init_stats (file_life, "cpp nodes");
	enode_stats =			mem_init_stats (file_life, "enodes");
	inhibit_stats =			mem_init_stats (file_life, "inhibit nodes");
	keyword_spell_stats =	mem_init_stats (file_life, "keyword spell nodes");
	macro_stats =			mem_init_stats (file_life, "macro nodes");
	narg_block_stats =		mem_init_stats (file_life, "narg blocks");
	pnode_stats =			mem_init_stats (file_life, "pnodes");
	skip_stats =			mem_init_stats (file_life, "skip nodes");
	spell_stats =			mem_init_stats (file_life, "spell nodes");
	snode_stats =			mem_init_stats (file_life, "snodes");
	string_stats =			mem_init_stats (file_life, "strings");
	string_node_stats =		mem_init_stats (file_life, "string nodes");
	tnode_stats =			mem_init_stats (file_life, "tnodes");
	xnode_stats =			mem_init_stats (file_life, "xnodes");

		/* Statistics for permanent lifetime. */

	perm_anode_stats =		mem_init_stats (perm_life, "anodes");
	perm_arg_stats =		mem_init_stats (perm_life, "args areas");
	perm_enode_stats =		mem_init_stats (perm_life, "enodes");
	perm_import_stats =		mem_init_stats (perm_life, "import nodes");
	perm_macro_stats =		mem_init_stats (perm_life, "macro nodes");
	perm_reg_stats =		mem_init_stats (perm_life, "reg nodes");
	perm_snode_stats = 		mem_init_stats (perm_life, "snodes");
	perm_spell_stats =		mem_init_stats (perm_life, "spell nodes");
	perm_string_stats =		mem_init_stats (perm_life, "strings");
	perm_st_block_stats =	mem_init_stats (perm_life, "st block nodes");
	perm_tnode_stats =		mem_init_stats (perm_life, "tnodes");
	perm_with_node_stats =	mem_init_stats (perm_life, "with nodes");

		/* Statistics for token lifetime. */

	id_token_stats =	mem_init_stats (token_life, "id tokens");
	ptr_token_stats =	mem_init_stats (token_life, "ptr tokens");
	small_token_stats =	mem_init_stats (token_life, "small tokens");
	val_token_stats =	mem_init_stats (token_life, "val tokens");

#ifdef THINK_C

	/*
		CC2 *always* uses Sherlock for output, so use
		sl_macInit here instead of SL_MAC_INIT.

		Notice that the Sherlock menu is used only if Sherlock is defined.
	*/
	w_mac_init(
		FALSE,					/* Initialize the Macintosh ToolBox. */
		TRUE,					/* TRUE: output to Sherlock window. */
		"CC2 LOG",				/* Name of Sherlock window (if used). */
		TRUE,					/* TRUE: open Sherlock window. */
		TRUE,					/* TRUE: Insert standard menus. */
		SHERLOCK_DEFINED,		/* TRUE: Insert Sherlock menu. */
		TRUE,					/* TRUE: Insert first item in apple menu. */
		(pstring) "\pAbout CC2...",	/* Title of first item in apple menu. */
		&amp;about_dialog,			/* CallBack routine for first apple item. */
		TRUE,					/* TRUE: Insert menus immediately. */
		&amp;event_call_back,		/* Event callback routine. */
		&amp;dump1_call_back,		/* First user callback routine. */
		(pstring) "\pObjects",	/* Name of first user menu item. */
		&amp;dump2_call_back,		/* Second user callback routine. */
		(pstring) "\pObject Stats",	/* Name of second user menu item. */
		&amp;dump3_call_back,			/* Third user callback routine. */
		(pstring) "\pHeap Stats"	/* Name of third user menu item. */
	);

#endif

	/* Sherlock must be initialized now. */
	SL_INIT();

	/*
		Check and initialize the token and opcode description arrays.
		Do this *before* any tokens are used!
	*/
	tok_init();

	/*
		Check and initialize the token and opcode description arrays.
		Do this *before* any tokens are used!
	*/
	tok_check();

	/*
		Initialize the macro symbol table before processing user arguments, so
		that constants can be #define'd or #undef'd from the command line.

		Sherlock traces are disabled since Sherlock arguments have not been handled.
	*/
	tok_init_hash_tab();
	mst_init();

	/*
		Process user arguments, including Sherlock arguments.
		No Sherlock traces will be in effect before this point.
	*/
	init_args(&amp;argc, &amp;argv, lib_arg_file_name);

	SL_PARSE(argc, argv, "++", "--");

	STATB(ftag);

	/* Watch location 0.  This test catches *p = x where p is NULL. */
	SL_WATCH(0, 4, "loc 0");

	arg_do_argv(argc, argv, "++", "--");

	/* Sign on *after* opening the log file. */
	ecnl(); es(lib_version); ecnl();

	TRACEPN("-show_args",

		int i = 0;
		ecnl();
		while (argv[i]) {
			es("argv["); eint(i); es("]: "); es(argv[i]); enl();
			i++;
		}
	);

#define line(a) epads(#a,14); epadptr(a ## 1, 10); epadptr(a, 10); enl();

	TRACEN("-mst_show", mst_show());

	#if 0 // can not be used with Universal Headers
		#ifdef THINK_C
			TRACEN("-zone",
				void * Sp = env_stackPtr();
				ecnl();
				epads(" ", 14); epads("Before", 10); epads("After", 10); enl();
				line(CurStackBase);
				line(ApplLimit);
				line(HeapEnd);
				line(ApplZone);
				enl();
			);
		#endif
	#endif

#undef line

	/* Initialize dynamic data structures with permanent life. */
	comp_perm_init();

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.575">@ The call-back routines are only needed when windows are used.
@c

#ifdef THINK_C

/*
	"Call-back" routines for event processing when Sherlock outputs a line.
*/
static void
event_call_back(void)
{
	SL_DISABLE();

	#ifdef THINK_C
		if (w_applEvent(0) == FALSE) {
			end_quit();
		}
	#endif
}
</t>
<t tx="ekr.20080529093004.576">static void
dump1_call_back(void)
{
	SL_DISABLE();

	#ifndef PRODUCTION
		ecnls(2);
		obj_dump_objects();
	#endif

	ecnl();
}
</t>
<t tx="ekr.20080529093004.577">static void
dump2_call_back(void)
{
	SL_DISABLE();

	#ifndef PRODUCTION
		ecnls(2);
		obj_dump_stats();
		ecnl();
	#endif

	ecnl();
}
</t>
<t tx="ekr.20080529093004.578">static void
dump3_call_back(void)
{
	SL_DISABLE();

	#ifndef PRODUCTION
		ecnls(2); es("Sherlock User Report: ");
		env_dump_stats();
		ecnl();
	#endif
}
</t>
<t tx="ekr.20080529093004.579">/*
	CC2: Main routine.

	Use 4-space tabs for best appearance.

	source:  CC.c
	started: October 7, 1985
	Version:
		December 30, 1994.
			Installed tuple_float_test code.
		November 4, 1994.
			Moved tests to Tuple Test Bed.
		April 16, 1993.
			Removed path and path2 variables from main().
		August 16, 1992.
			Removed obsolete definition of char_val.
		May 27, 1992
			Removed call to sl_timetest.
		January 29, 1992
			add code to print sizes of data types.
		September 29, 1991
*/

&lt;&lt; CCmain #includes &gt;&gt;
&lt;&lt; CCmain declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.580">#include "CC.h"

#include "CCarg.h"
#include "CCcomp.h"
#include "CCinit.h"
#include "CCmacro.h"
#include "CCmain.h"
#include "CCmem.h"
#include "CCmst.h"
#include "CCtokens.h"
#include "CCtokize.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBenv.h&gt;
#include &lt;LIBmath.h&gt;
#include &lt;LIBobj.h&gt;
</t>
<t tx="ekr.20080529093004.581">int dummy_extern;
</t>
<t tx="ekr.20080529093004.582">void
main(int argc, char **argv)
{
	SL_DISABLE();

	#if 0 /* Remember: this will not work if the Think C debugger is on. */
		DebugStr("\pmain");
	#endif

	/* Absolutely *no* calls to Sherlock before init_all is called! */
	init_all(argc, argv);

	#if 0 /* This statistic just distorts the overall picture. */
		STATB("main");
	#endif

	/*
		Put once-only tests here.
	*/
	TRACEP("-show_sizes",
		es("short: ");   eint(sizeof(short));
		es(" int: ");    eint(sizeof(int));
		es(" long: ");   eint(sizeof(long));
		es(" char *: "); eint(sizeof(char *));
		es(" float: ");  eint(sizeof(float));
		enl();
	);
	
	TRACEP("-tuple_float_test",
		extern void tuple_float_test(void);
		tuple_float_test();
	);
	
	/*
		Warning: This can *not* be compiled with Think C because
		it uses the StdClib version of headers that Think C *also* uses.
	*/
	#ifdef TUPLE_C
		TRACEP("-tuple_stdclib_test",
			extern void tuple_stdclib_test(void);
			tuple_stdclib_test();
		);
		
		TRACEP("-float_test",
			extern void float_test(void);
			float_test();
		);
	#endif

	/* Compile each file in turn. */
	while (arg_in_path != NULL) {

		compile();
		if (arg_do_argv(0, NULL, NULL, NULL) == NO_MORE_FILES_REMAIN) {
			break;
		}

		/* Reinitialize. */
		err_init_again();
		mst_init_again();
		TRACEPN("-mst_show", mst_show());
	}

	main_quit();

	#if 0 /* This statistic just distorts the overall picture. */
		STATX("main");
	#endif

	end_done();
}
</t>
<t tx="ekr.20080529093004.583">@ Free all compiler data structures that can be freed after one source file has been completely compiled.  Data with permanent lifetime must *not* be freed here!  This routine can only work properly if *all* aspects of memory allocation are correct. The acid test is whether CC2 can compile 2 files without crashing.  WARNING: Add *nothing* to this routine without making sure that CC2 can compile 2 files.
@c

void
main_free_all(void)
{
	FTAG("main_free_all");
	STATB(ftag);

	/* Free all all blocks with file and token lifetimes. */
	mem_free_life(file_life);
	mem_free_life(token_life);

	/* Re-initialize all global lists. */
	mac_mdef_list = NULL;

	/*
		Reinitialize the hash table.
		This must be done here, *before* processing additional command-line args.
	*/
	tok_first_token = NULL;
	if (sym_hash_tab) {
		obj_free_macro(sym_hash_tab);
		sym_hash_tab = NULL;
	}
	tok_init_hash_tab();

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.584">@ Free all dynamic structures and do end-of-program dumps. This is also called on normal termination and also by lib_quit when the user interrupts the compiler.
@c

void
main_quit(void)
{

#ifndef PRODUCTION

	/* Free all paths, path names and argument strings. */
	mem_free_life(file_life);
	mem_free_life(perm_life);

	TRACEP("-cc2_mem_stat",
		mem_dump_stats(perm_life);
		mem_dump_stats(file_life);
		mem_dump_stats(token_life);
	);

	TRACEP("-cc2_obj_stat",	obj_dump_stats());
	TRACEP("-cc2_obj_show",	obj_dump_objects());
	TRACEP("-cc2_env_stat",	env_dump_stats());
	TRACEP("-cc2_sldump",	sl_dump());

#endif

}
</t>
<t tx="ekr.20080529093004.585">/*
	CC2: Statement parser.

	source:  CCpar.c
	started: October 22, 1985
	version:
		November 1, 1993.
			Bug fix: allow "default" at the start of a switch.
			Bug fix: change FLOAT_TOK to FLOAT_TYPE in par_return.
		October 29, 1993.
			Suppress warning about possibly useless comma operators.
		March 12, 1993.
			Made par_expect global for dcl2.c.
		March 8, 1993.
			Add par_line_ptr.
		March 3, 1993.
			Allow NULL return type (it can arise because of user error.)
		February 25,1993.
			Add casts to list of allowed operators in test of possibly useless expressions.
		September 21, 1992.
			Convert function value in par_return.
		September 19, 1992.
			Fixed bug in par_goto.
		August 30, 1992.
			Changed par_list to handle labels properly when one_flag is TRUE.
			Added stronger test for 'case' or label after a 'switch'.
		August 28, 1992.
			Removed par_init.  (It is now part of comp_init).
		August 16, 1992.
			Added par_needsemi.
		August 15, 1992.
			Added parsing for blocks to par_statement.
			Added calls to st_begin_block and st_end_block.
		July 29, 1992
			Added tracing to par_expect.
		July 10, 1992
			Changed signon message.
		June 10, 1992
			First clean compile.
			Eliminated par_1astat.
			Eliminated global label list.
			Eliminated par_append routine.
			Used list.c routines in label routines.
			Added token lookahead to check for labels in par_list.
		June 5, 1992
			First CC2 version.
		January 22, 1992
			new typedefs added for lab_st_node.
		March 7, 1989
		March 5, 1987
*/
&lt;&lt; CCpar #includes &gt;&gt;
&lt;&lt; CCpar declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.586">#include "CC.h"

#include "CCarg.h"
#include "CCcpp.h"
#include "CCdump.h"
#include "CCgen.h"
#include "CCmem.h"
#include "CCparser.h"

#include &lt;LIBlist.h&gt;
</t>
<t tx="ekr.20080529093004.587">/*
	Globals owned by this module.
*/
long par_cur_lab = 0;		/* The current label index. */
token * par_token_ptr = NULL;	/* Pointer to the current token. */
token * par_line_ptr = NULL;	/* Ptr to the newline before the current line. */


/*
	Local variables.

	The break_ref, continue_ref, switch_ref are pointers to the statement
	to which the next 'break', 'continue' or 'default' statements will refer.

	These variables are initialized by par_program().
*/
static pnode * break_ref = NULL;	 	/* Current 'for', 'do','while' or 'switch' */
static pnode * continue_ref = NULL; 	/* Current 'for', 'do' or 'while'. */
static switch_node * switch_ref = NULL;	/* Current 'switch' statement. */

/*
	Label nodes.
*/
typedef struct lab_node_struct	lab_st_node;

static struct lab_node_struct {
	TYPE_LIST(lab_st_node);
	bool			lab_defined;	/* Defined flag. */
	ulabel_cnode *	lab_label;		/* Label node for the label. */
};

static lab_st_node * ll_list;

/*
	Function prototypes of internal routines.
*/
static void				ll_check	(void);
static lab_st_node *	ll_enter	(char * symbol);
static lab_st_node *	ll_lookup	(char * symbol);

static block_node *		par_block		(void);
static bc_node *		par_break		(void);
static case_node *		par_case		(void);
static bc_node *		par_continue	(void);
static case_node *		par_default		(void);
static do_node *		par_do			(void);
static for_node *		par_for			(void);
static goto_node *		par_goto		(void);
static if_node *		par_if			(void);
static ulabel_node *	par_label		(void);
static void				par_outer_dcl	(void);
static enode *			par_parenexp	(void);
static return_node *	par_return		(void);
static switch_node *	par_switch		(void);
static while_node *		par_while		(void);
</t>
<t tx="ekr.20080529093004.588">@ Check for labels that have been referenced but not defined.
@c

static void
ll_check(void)
{
	FTAG("ll_check");
	register lab_st_node * p = NULL;
	STATB(ftag);

	lst_every_macro(p, ll_list) {

		if (p -&gt; lab_defined == FALSE) {
			error(
				es("undefined label: ");
				es(p -&gt; lab_label -&gt; c_labsym));
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.589">@ Enter a symbol in the label list and mark it undefined.
@c

static lab_st_node *
ll_enter(char * symbol)
{
	FTAG("ll_enter");
	register lab_st_node * p = NULL;
	STATB(ftag);

	/* Make a new entry entry in the local label list. */
	new_xnode_macro(p, sizeof(lab_st_node));
	p -&gt; lab_defined   = FALSE;

	/* Create a user label cnode contain *both* the user label and an internal label. */
	new_ulabel_macro(p -&gt; lab_label, symbol);

	/* Link it to the head of the list. */
	lst_add_macro(p, ll_list);

	TRACEPX(ftag, elist(es(symbol)));
	return p;
}
</t>
<t tx="ekr.20080529093004.590">@ Initialize the label list.
@c

void
ll_init(void)
{
	FTAG("ll_init");
	STAT(ftag);

	/*
		Label nodes never need to be explicitly freed since
		they will be freed when all local blocks are freed.
	*/
	ll_list = NULL;
}
</t>
<t tx="ekr.20080529093004.591">@ Look up a symbol in the label list.
@c

static lab_st_node *
ll_lookup(register char * symbol)
{
	FTAG("ll_lookup");
	register lab_st_node * p = NULL;
	STATB(ftag);

	lst_every_macro(p, ll_list) {
		if (str_eq(symbol, p -&gt; lab_label -&gt; c_labsym)) {

			TRACEPX(ftag, es(symbol); es(" found\n"));
			return p;
		}
	}

	TRACEPX(ftag, es(symbol); es(" not found\n"));
	return NULL;
}
</t>
<t tx="ekr.20080529093004.592">@ Parse a block.
@c

static block_node *
par_block(void)
{
	FTAG("par_block");
	block_node * bp = NULL;
	STATB(ftag);

	/* Create a new scope for the block.*/
	st_begin_block();

	/* Create a new block node. */
	new_pnode_macro(bp, sizeof(block_node), KP_BLOCK);

	/* Parse the block. */
	bp -&gt; block_dcls = dcl_list(BLOCK_SCOPE);
	bp -&gt; block_body = par_list(FALSE);
	par_need(RCURLY_TOK);

	/* End the block's scope.*/
	st_end_block();

	STATX(ftag);
	return bp;
}
</t>
<t tx="ekr.20080529093004.593">@ Parse a 'break' statement.
@c

static bc_node *
par_break(void)
{
	FTAG("par_break");
	register bc_node * p = NULL;
	STATB(ftag);

	/* Read the "break" */
	par_next();

	/* Make sure the break appears in a switch, do, while or for. */
	if (break_ref == NULL) {
		error(es("'break' statement not valid here"));
		STATX(ftag);
		return NULL;
	}

	/* Create a bc_node (break/continue node). */
	new_pnode_macro(p, sizeof(bc_node), K_BREAK);

	par_need(SEMICOLON_TOK);

	STATX(ftag);
	return p;
}
</t>
<t tx="ekr.20080529093004.594">@ Parse a 'case' statement.
@c

static case_node *
par_case(void)
{
	FTAG("par_case");
	register case_node * case_p = NULL;	/* Pointer to the new case node. */
	register case_node * case_p1 = NULL;
	register long con = 0L;
	STATB(ftag);

	/* Read the "case" */
	par_next();

	/*
		Get the expression.

		SEE K&amp;R p. 211; the expression will be folded to an INT
		primitive if and only if it is proper.  Expressions using
		unary &amp; are not proper--and in almost all cases will not fold.
	*/
	{
		bool err_flag;
		con = expr_const_int(&amp;err_flag);
		if (err_flag) {
			error(es("Constant expected after 'case'"));
			goto case_error;
		}
	}

	/* Make sure we are in a switch body. */
	if (switch_ref == NULL) {
		error(es("'case' statement not valid here"));
		goto case_error;
	}

	/* Create a new case_node. */
	new_pnode_macro(case_p, sizeof(case_node), K_CASE);
	case_p -&gt; case_constant = con;

	/* Check the case list for duplicate entries. */
	case_p1 = switch_ref -&gt; switch_list;
	if (case_p1) {

		for(;;) {

			TRACEPN(ftag,
				es("checking "); epnode( (pnode *) case_p1); es("for duplicate\n"));

			if (case_p1 -&gt; case_constant == con) {
				error(es("duplicate case "); elong(con); es(" ignored"));
				goto case_error;
			}

			if (case_p1 -&gt; case_list) {
				case_p1 = case_p1 -&gt; case_list;
			}
			else {
				/* Add the new case at the end of the list. */
				case_p1 -&gt; case_list = case_p;
				break;
			}
		}
	}
	else {
		switch_ref -&gt; switch_list = case_p;
	}

	par_need(COLON_TOK);

	STATX(ftag);
	return case_p;

case_error:
	par_need(COLON_TOK);
	STATX(ftag);
	return NULL;
}
</t>
<t tx="ekr.20080529093004.595">@ Parse a 'continue' statement.
@c

static bc_node *
par_continue(void)
{
	FTAG("par_continue");
	register bc_node * p = NULL;
	STATB(ftag);

	/* Read the "continue" */
	par_next();

	/* Make sure the 'continue' appears in a 'do', 'while' or 'for'. */
	if (continue_ref == NULL) {
		error(es("'continue' statement not valid here"));
		STATX(ftag);
		return NULL;
	}

	/* Create a new bc_node (break/continue node). */
	new_pnode_macro(p, sizeof(bc_node), K_CONTINUE);

	par_need(SEMICOLON_TOK);

	STATX(ftag);
	return p;
}
</t>
<t tx="ekr.20080529093004.596">@ Parse a 'default' statement.
@c

static case_node *
par_default(void)
{
	FTAG("par_default");
	register case_node * p = NULL;
	STATB(ftag);

	/* Read the "default" */
	par_next();

	/* Make sure we are in a 'switch' statement. */
	if (switch_ref == NULL) {
		error(es("'default' statement not valid here"));
		goto default_error;
	}

	if (switch_ref -&gt; switch_default) {
		error(es("duplicate 'default' statement ignored"));
		goto default_error;
	}

	/* Create a new case_node. */
	new_pnode_macro(p, sizeof(case_node), K_DEFAULT);

	/* Link it as the default field of the parent switch. */
	switch_ref -&gt; switch_default = p;

	par_need(COLON_TOK);

	STATX(ftag);
	return p;

default_error:
	STATX(ftag);
	return NULL;
}
</t>
<t tx="ekr.20080529093004.597">@ Parse a 'do' statement.
@c

static do_node *
par_do(void)
{
	FTAG("par_do");
	register pnode * old_continue = continue_ref;
	register pnode * old_break = break_ref;
	register do_node * p = NULL;
	STATB(ftag);

	/* Read the "do" */
	par_next();

	/* Create a new do_node. */
	new_pnode_macro(p, sizeof(do_node), K_DO);

	/* Update reference lists. */
	continue_ref = (pnode *) p;
	break_ref	 = (pnode *) p;

	/* Parse. */
	p -&gt; do_body = par_statement();

	/* Remember the start of the expression. */
	p -&gt; p_line2 = err_line;
	p -&gt; p_line2_ptr = par_line_ptr;

	par_need(K_WHILE);
	p -&gt; do_bool = par_parenexp();

	/* Include the expression in the dump of the "do" statement. */
	p_set_line2_count_macro(p, err_line - p -&gt; p_line2);

	/* Restore reference lists. */
	continue_ref = old_continue;
	break_ref  = old_break;

	TRACEPX(ftag, eret(); epnode( (pnode *) p); enl());
	return p;
}
</t>
<t tx="ekr.20080529093004.598">@ Give an error message about an expected symbol.
@c

void
par_expect(token expected_tok)
{
	FTAG("par_expect");

	error(
		es(tok_name(expected_tok));
		es(" expected at: "); etok(par_token_ptr);

		/* A *very* effective trace for debugging the parser. */
		TRACE(ftag,
			es(" in: "); es(current_ftag);
			es(" from: "); es(caller_ftag);
			es(" from: "); es(caller2_ftag);
			es(" from: "); es(caller3_ftag);
		);
	);
}
</t>
<t tx="ekr.20080529093004.599">@ Parse a 'for' statement.
@c

static for_node *
par_for(void)
{
	FTAG("par_for");
	register for_node * p = NULL;
	pnode * old_continue = continue_ref;
	pnode * old_break = break_ref;
	STATB(ftag);

	/* Read the "for" */
	par_next();

	/* Create a for_node. */
	new_pnode_macro(p, sizeof(for_node), K_FOR);

	/* Update reference lists. */
	continue_ref = (pnode *) p;
	break_ref	 = (pnode *) p;

	/* Parse. */
	par_need(LPAREN_TOK);
	p -&gt; for_list1 = expr(ALLOW_COMMAS);

	if (is(SEMICOLON_TOK)) {
		par_next();

		/* Allow commas in the expression. */
		p -&gt; for_bool = expr(ALLOW_COMMAS);
		if (is(SEMICOLON_TOK)) {
			par_next();
			p -&gt; for_list2 = expr(ALLOW_COMMAS);
		}
		else {
			error(es("missing ';' in 'for' statement"));
		}
	}
	else {
		error(es("missing ';' in 'for' statement"));
	}

	(void) par_needend(RPAREN_TOK);

	/* Set the number of lines spanned by the start of the 'for' statement. */
	p_set_line_count_macro(p, err_line - p -&gt; p_line);

	p -&gt; for_body = par_statement();

	/* Restore reference lists. */
	continue_ref = old_continue;
	break_ref  = old_break;

	STATX(ftag);
	return p;
}
</t>
<t tx="ekr.20080529093004.600">@ Parse an 'if' statement.
@c

static if_node *
par_if(void)
{
	FTAG("par_if");
	register if_node * p = NULL;
	STATB(ftag);

	/* Skip the "if" */
	par_next();

	/* Create a new if_node. */
	new_pnode_macro(p, sizeof(if_node), K_IF);

	/* Parse. */
	p -&gt; if_bool = par_parenexp();

	/* Include the expression in the dump of the "if" statement. */
	p_set_line_count_macro(p, err_line - p -&gt; p_line);

	p -&gt; if_then_body = par_statement();
	if (is(K_ELSE)) {
		par_next();
		if (is(K_IF)) {
			/* else if is like a new keyword. */
			p -&gt; if_else_body = par_statement();
		}
		else {
			p -&gt; if_else_body = par_statement();
		}
	}
	else {
		p -&gt; if_else_body = NULL;
	}

	STATX(ftag);
	return p;
}
</t>
<t tx="ekr.20080529093004.601">@ Parse a 'goto' statement.
@c

static goto_node *
par_goto(void)
{
	FTAG("par_goto");
	register goto_node * p = NULL;
	register lab_st_node *q = NULL;
	TICKB(ftag);

	/* Read the "goto" */
	par_next();

	/* Create a new goto_node. */
	if (is(ID_TOK)) {
		new_pnode_macro(p, sizeof(goto_node), K_GOTO);

		/* Get a pointer to the label node. */
		q = ll_lookup(t_symbol);
		if (q == NULL) {
			q = ll_enter(t_symbol);
		}
		p -&gt; goto_label = q -&gt; lab_label;

		/* Read the label */
		par_next();
	}
	else {
		/* Bug fix: 9/19/92. */
		p = NULL;
		par_expect(ID_TOK);
	}

	(void) par_needend(SEMICOLON_TOK);

	TICKX(ftag);
	return p;
}
</t>
<t tx="ekr.20080529093004.602">@ Give an error message that some token is invalid.
@c

void
par_invalid(char * s)
{
	error(es(s); es(" is not valid here"));
}
</t>
<t tx="ekr.20080529093004.603">@ Parse a user defined label.
@c

static ulabel_node *
par_label(void)
{
	FTAG("par_label");
	register ulabel_node *p = NULL;	/* Parser label node. */
	register lab_st_node *q = NULL;	/* Label_table node. */
	STATB(ftag);

	/* Create a new ulabel_node (parser label node). */
	new_pnode_macro(p, sizeof(ulabel_node), ULABEL_TOK);

	/* The label should not exist. */
	q = ll_lookup(t_symbol);
	if (q != NULL &amp;&amp; q -&gt; lab_defined == TRUE) {
		error(es("duplicate label: "); es(t_symbol));
		p -&gt; ulab_label = 0L;
	}
	else if (q != NULL) {
		/* Mark a previously referenced label as defined. */
		q -&gt; lab_defined = TRUE;
		p -&gt; ulab_label = q -&gt; lab_label;
	}
	else {
		/* Enter the new label. */
		q = ll_enter(t_symbol);
		q -&gt; lab_defined = TRUE;
		p -&gt; ulab_label = q -&gt; lab_label;
	}

	/* Skip over the label. */
	par_next();
	par_need(COLON_TOK);

	TRACEPX(ftag, elist(es(t_symbol)));
	return p;
}
</t>
<t tx="ekr.20080529093004.604">@ Parse a list of statements, not including '{' and '}'. Parse a single statement if one_flag is TRUE. The n_next field contains the list pointers.
@c

pnode *
par_list(bool one_flag)
{
	FTAG("par_list");
	FTAGV("-par_list_v");
	register linked_node * p = NULL;
	register linked_node * head = NULL;
	register linked_node * last = NULL;
	TRACEPB(ftag, elistx(ebool(one_flag); es(" token: "); etok(par_token_ptr)));

	/* Nothing has been seen yet. */
	goto around;

linkit:

	if (p != NULL) {

		int count = 0;

		TRACEPN(ftagv,
			es("last: "); eptr(last); es(", head: "); eptr(head); enl());

		/* Enter p on the list and remember the head node. */
		if (head == NULL) {
			head = p;
		}
		else {
			ASSERT(last);
			last -&gt; n_next = p;
		}

		while(p -&gt; n_next) {
			ASSERT(count++ &lt; 5000);
			p = p -&gt; n_next;
		}

		last = p;

		TRACEPN(ftagv,
			es("last: "); eptr(last); es(", head: "); eptr(head); enl());
	}

next:
	/*
		Allow multiple labels even if one_flag is TRUE.
		This makes the following execrable examples legal:

			if (1 == 2) test_label: {int a = 1; a = 2;}
			{int a = 1; if (1 == 2) test_label2: a = 2;}

		Both are indeed accepted by the Think C compiler.
	*/
	if (one_flag &amp;&amp; (last == NULL || last -&gt; n_type != ULABEL_TOK)) {
		STATX(ftag);
		return (pnode *) head;
	}

around:
	switch(t_type) {

	case END_PROG_TOK:
	case RCURLY_TOK:

		TRACEPX(ftag, eret(); epnode((pnode *) head));
		return (pnode *) head;

	case LCURLY_TOK:
		p = (linked_node *) par_statement();
		goto linkit;

	case SEMICOLON_TOK:
		par_next();
		goto next;

	case K_BREAK:	 p = (linked_node *) par_break();	 goto linkit;
	case K_CASE:	 p = (linked_node *) par_case();	 goto linkit;
	case K_CONTINUE: p = (linked_node *) par_continue(); goto linkit;
	case K_DEFAULT:	 p = (linked_node *) par_default();	 goto linkit;
	case K_DO:	 	 p = (linked_node *) par_do();		 goto linkit;
	case K_FOR:	 	 p = (linked_node *) par_for();		 goto linkit;
	case K_GOTO:	 p = (linked_node *) par_goto();	 goto linkit;
	case K_IF:	 	 p = (linked_node *) par_if();		 goto linkit;
	case K_RETURN:	 p = (linked_node *) par_return();	 goto linkit;
	case K_SWITCH:	 p = (linked_node *) par_switch();	 goto linkit;
	case K_WHILE:	 p = (linked_node *) par_while();	 goto linkit;

	case ID_TOK:

	/* This could be either a label or the start of an expression. */
	{
		/* Save the current token */
		token * old_ptr = par_token_ptr;
		long line = err_line;

		/* Look ahead to the next token to see if we have a label. */
		TRACEPN("par_next", es("looking ahead for a label\n"));
		par_next();

		if (is(COLON_TOK)) {

			/* Back up so t_symbol points to the label. */
			par_token_ptr = old_ptr;
			p = (linked_node *) par_label();
			goto linkit;
		}

		/* Back up and try for an expression. */
		TRACEPN("par_next", es("backing up, label not found\n"));
		par_token_ptr = old_ptr;
		err_line = line;
		goto expression;
	}

	default:

		if (is_kdecl(t_type) || dcl_is_typedef()) {
			error(es("ignoring declaration in code"));
			dcl(NULL_SCOPE);
			goto around;
		}
		else {
			goto expression;
		}
	}

expression:

	TRACEPN(ftag, es("presumed expression\n"));

	/* Allocate an expression node (a pnode, not an enode). */
	{
		expr_node * expr_p;
		new_pnode_macro(expr_p, sizeof(expr_node), EXPRESSION_TOK);

		/* Allow commas in the expression. */
		expr_p -&gt; expr = expr(ALLOW_COMMAS);
		p = (linked_node *) expr_p;
		ASSERT(p -&gt; n_next == NULL);

		/* Set the number of lines spanned by the expression. */
		p_set_line_count_macro(expr_p, err_line - expr_p -&gt; p_line);

		/* Check the expression to make sure it does something. */
		if (expr_p -&gt; expr) {
			register int op = expr_p -&gt; expr -&gt; n_type;

			/*
				Arrange the following tests in approximate order of frequency.
				The 'if' will be fast in spite on the large number of cases.
			*/
			if (
				op != ASSN_TOK &amp;&amp;			/* Most frequent. */
				op != CALL_TOK &amp;&amp;

				op != PRE_DEC_TOK &amp;&amp;		/* Next frequent. */
				op != PRE_INC_TOK &amp;&amp;
				op != POST_DEC_TOK &amp;&amp;
				op != POST_INC_TOK &amp;&amp;
				
				/*
					8/24/94:
					Expressions such as x += 0 are folded to just x.
					The fold2 routine flags such folds so we can ignore them here.
				*/
				!e_is_folded(expr_p -&gt; expr) &amp;&amp;

				op != AND_ASSN_TOK &amp;&amp;		/* Least frequent. */
				op != CAST_TOK &amp;&amp;
				op != DIV_ASSN_TOK &amp;&amp;
				op != LSHIFT_ASSN_TOK &amp;&amp;
				op != MINUS_ASSN_TOK &amp;&amp;
				op != MOD_ASSN_TOK &amp;&amp;
				op != OR_ASSN_TOK &amp;&amp;
				op != PLUS_ASSN_TOK &amp;&amp;
				op != RSHIFT_ASSN_TOK &amp;&amp;
				op != STAR_ASSN_TOK &amp;&amp;
				op != XOR_ASSN_TOK &amp;&amp;

				/*
					10/29/93: constructions such as
						if (x) a=b,c=d;
					are hideous style, and they exists in the Standard C library!
				*/
				op != COMMA_TOK &amp;&amp;

				op != QUESTION_TOK	/* We should check both branches. */
			) {
				warning(
					es("possibly useless outer expression.  ");
					es("operator is: "); etoknum(op));
			}
		}
	}

	if (!par_needend(SEMICOLON_TOK)) {
		TRACEPN(ftag, es("skipping expression\n"));
		goto around;
	}

	ASSERT(p -&gt; n_next == NULL);
	goto linkit;
}
</t>
<t tx="ekr.20080529093004.605">@ Skip the current token if it is what we think it is.
@c

void
par_need(token tok)
{
	FTAG("par_need");
	TRACEP(ftag, elp(); es(tok_name(tok)); erpnl());

	if (is(tok)) {
		par_next();
	}
	else {
		par_expect(tok);
	}
}
</t>
<t tx="ekr.20080529093004.606">@ If the current token is tok, eat it and return TRUE.  Otherwise: o Scan to the next instance of tok, semicolon or brace. o If tok is found before semicolon or brace, eat it. o Return false.
@c

bool
par_needend(token tok)
{
	FTAG("par_needend");
	STATB(ftag);

	if (is(tok)) {
		par_next();
		STATX(ftag);
		return TRUE;
	}
	par_expect(tok);

	while (
		t_type != SEMICOLON_TOK &amp;&amp; t_type != END_PROG_TOK &amp;&amp;
		t_type != LCURLY_TOK    &amp;&amp; t_type != RCURLY_TOK
	) {
		par_next();
		if (is(tok)) {
			par_next();
			break;
		}
	}

	STATX(ftag);
	return FALSE;
}
</t>
<t tx="ekr.20080529093004.607">@ If the current token is semicolon, eat it and return TRUE.  Otherwise, skip to the next semicolon and return FALSE;
@c

bool
par_needsemi(void)
{
	FTAG("par_needsemi");
	STATB(ftag);

	if (is(SEMICOLON_TOK)) {
		par_next();
		STATX(ftag);
		return TRUE;
	}
	par_expect(SEMICOLON_TOK);

	for(;;) {
		if (is(SEMICOLON_TOK)) {
			par_next();
			break;
		}
		else if (is(END_PROG_TOK)) {
			break;
		}
		else {
			par_next();
		}
	}

	STATX(ftag);
	return FALSE;
}
</t>
<t tx="ekr.20080529093004.608">@ Parse an declaration or definition and generate code.  Release streams after code is generated.
@c

static void
par_outer_dcl(void)
{
	FTAG("par_outer_dcl");
	TICKB(ftag);

	dcl_definition_flag = FALSE;

	/*
		dcl will parse the function body if it exists.
		If so, dcl_definition_flag will be set to TRUE.
	*/
	dcl(FILE_SCOPE);

	if (dcl_definition_flag) {

		/* Check for referenced but not defined labels. */
		ll_check();

		/* Generate code for the function. */
		gen_fbody();
	}
	else if (is(SEMICOLON_TOK)) {

		/* Eat the semicolon. */
		par_next();
	}
	else {
		par_needsemi();
	}

	TICKX(ftag);
}
</t>
<t tx="ekr.20080529093004.609">@ Parse a parenthesized expression. This is used in parsing 'do', 'if', 'switch' and 'while' statements.
@c

static enode *
par_parenexp(void)
{
	FTAG("par_parenexp");
	register enode * p = NULL;
	STATB(ftag);

	par_need(LPAREN_TOK);

	/* Allow commas in the expression. */
	p = expr(ALLOW_COMMAS);

	/* Make sure the expression exists and is valid. */
	{
		register int op = (p == NULL) ? NULL_TYPE : p -&gt; e_ctype -&gt; tprim;

		if (op == ARRAY_TYPE) {
			error(es("array name will always be true"));
		}
		else if (op != INT_TYPE &amp;&amp; op != FLOAT_TYPE &amp;&amp; op != POINTER_TYPE) {
			error(es("null, void or improper boolean expression"));
		}
	}

	(void) par_needend(RPAREN_TOK);

	STATX(ftag);
	return p;
}
</t>
<t tx="ekr.20080529093004.610">@ The main routine of the parser.  Look for external declarations and function definitions. Abort if anything else is found.
@c

void
par_program(void)
{
	FTAG("par_program");
	register snode * id = NULL;
	STATB(ftag);

	/* Enter the "global" block. */
	st_begin_block();

	/* Initialize chains of references. */
	break_ref  = NULL;
	continue_ref = NULL;
	switch_ref   = NULL;

	/* Generate the start of the output file. */
	if (!arg_no_gen_flag) {
		out_begin_file();
	}

	/*
		Get the first token of the program.

		We can assert that the first non-hidden token is a newline
		because tokize puts a newline at the start of the token
		list.  (This makes the first real line be line number 1).

		We skip to that newline so that par_next can assert
		!is_hidden(par_token_ptr) on its initial entry.  Clearly,
		since par_next only returns visible tokens, par_next never
		needs to check for hidden tokens on entry.

		All this makes par_next a bit faster, which is important.
		Notice: par_next will skip the WS_NL_TOK *without* bumping
		err_line, so we must do it here.
	*/

	tok_file_level = 0;

	#if 1 /* This allows par_next to be faster. */

		par_token_ptr = tok_skip_hidden(tok_first_token);
		ASSERT(is(WS_NL_TOK));
		err_line++;
		par_next();

	#else /* This requires par_next to check for hidden tokens on entry. */

		par_token_ptr = tok_first_token;
		par_next();

	#endif

	while (!is(END_PROG_TOK)) {

		if (is(ID_TOK) || is_kdecl(t_type)) {
			par_outer_dcl();
		}
		else {
			error(etok(par_token_ptr); es(" ignored in outer context"));
			par_next();
		}
	}

	/* Exit the "global" block. */
	st_end_block();

	/* Generate the end of the output file. */
	if (!arg_no_gen_flag) {
		if (err_count) {
			out_error();
		}
		else {
			out_end_file();
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.611">@ Parse a 'return' statement.  Section 3.6.6.3: The return Statement.  "If the expression has a type different from that of the function in which it appears, it is converted as if it were assigned to an object of that type."
@c

static return_node *
par_return(void)
{
	FTAG("par_return");
	register return_node * p = NULL;
	register tnode *ftype = NULL;
	register tnode *rtype = NULL;
	STATB(ftag);

	/* Read the "return" */
	ASSERT(is(K_RETURN));
	par_next();

	/* Create a return_node. */
	new_pnode_macro(p, sizeof(return_node), K_RETURN);

	/* Access the return type. */
	ftype = gen_ftype;

	/* ftype is FUNCTION_TYPE.  Now get the type it returns. */
	ASSERT_TRACE(ftype &amp;&amp; ftype -&gt; tprim == FUNCTION_TYPE,
		es("ftype: "); eptr(ftype); es(" = "); etnode(ftype); enl());
	ftype = ftype -&gt; ttype;
	ASSERT(ftype);

	/* Parse an optional expression. */
	if (is(SEMICOLON_TOK)) {
		if (ftype -&gt; tprim != VOID_TYPE) {
			error(es("void return not valid here"));
		}
		goto done;
	}

	/* Allow commas in the expression. */
	p -&gt; return_val = expr(ALLOW_COMMAS);

	/* Include the expression in the dump of the 'return' statement. */
	p_set_line_count_macro(p, err_line - p -&gt; p_line);

	/* Check the expression. */
	if (p == NULL || p -&gt; return_val == NULL) {
		if (ftype -&gt; tprim != VOID_TYPE) {
			error(es("void return not valid here"));
		}
		goto done;
	}

	/* 3/3/93: rtype may be NULL due to user error. */
	rtype = p -&gt; return_val -&gt; e_ctype;

	if (rtype &amp;&amp; !ct_eq(ftype, rtype)) {

		/*
			We can't use ct_cast_arg1 here because we link the cast node
			to p -&gt; return_val rather than the arg1 field of an enode.

			Bug fix: 11/1/93: typo: change FLOAT_TOK to FLOAT_TYPE.
		*/
		if(rtype -&gt; tprim == INT_TYPE || rtype -&gt; tprim == FLOAT_TYPE) {

			op1_enode * op1;

			/* Create a cast node. */
			new_enode_macro(op1, sizeof(op1_enode), CAST_TOK);
			op1 -&gt; e_ctype = ftype;

			/* Link the cast node into the tree. */
			op1 -&gt; arg1 = p -&gt; return_val;
			p -&gt; return_val = (enode *) op1;
		}
		else {

			/* There is no way to create a cast to a struct/union. */
			error(
				es("function's type does not match returned type");
				TRACEN("return",
					ecnl(); etnode(ftype);
					ecnl(); etnode(p -&gt; return_val -&gt; e_ctype));
			);
		}
	}

done:
	par_need(SEMICOLON_TOK);

	STATX(ftag);
	return p;
}
</t>
<t tx="ekr.20080529093004.612">@ Parse a single statement--one statement followed by ';' or a block enclosed in curly braces.
@c

pnode *
par_statement(void)
{
	FTAG("par_statement");
	register pnode *p = NULL;
	TICKB(ftag);

	if (is(LCURLY_TOK)) {
		par_next();

		/* Check for block declarations. */
		if (is_kdecl(t_type) || dcl_is_typedef()) {
			p = (pnode *) par_block();
		}
		else {
			p = par_list(FALSE);
			par_need(RCURLY_TOK);
		}
	}
	else {
		p = par_list(TRUE);
	}

	TRACEPX(ftag, eret(); epnode(p));
	return p;
}
</t>
<t tx="ekr.20080529093004.613">@ Parse a 'switch' statement.
@c

static switch_node *
par_switch(void)
{
	FTAG("par_switch");
	register switch_node * old_switch = switch_ref;
	register pnode * old_break  = break_ref;
	register switch_node *p = NULL;
	register enode *p1 = NULL;
	long start_line = 0;
	STATB(ftag);

	/* Read the "switch" */
	par_next();

	/* Create a switch_node. */
	new_pnode_macro(p, sizeof(switch_node), K_SWITCH);

	/* Update reference lists. */
	switch_ref  = p;
	break_ref   = (pnode *) p;

	/* Parse the switch expression. */
	p -&gt; switch_val = p1 = par_parenexp();

#if 0 /* This assumes sizeof(int) &lt; sizeof(long). */
	if (p1 &amp;&amp; t_is_long(p1 -&gt; e_ctype)) {
		error(es("switch variable is long"));
	}
#endif

	/* Include the expression in the dump of the 'switch' statement. */
	p_set_line_count_macro(p, err_line - p -&gt; p_line);

	/* Save the current line for use in later error messages. */
	start_line = err_line;

	/* Parse the body of the switch. */
	p -&gt; switch_body = par_statement();

	/* Make sure a case or default or a label starts the body of the switch. */
	{
		register pnode * p2 = p -&gt; switch_body;

		for(;;) {

			/* Bug fix: 11/1/93: default is also valid at the start of a switch! */
			if (p2 &amp;&amp;
				(
					p2 -&gt; n_type == ULABEL_TOK ||
				 	p2 -&gt; n_type == K_CASE ||
				 	p2 -&gt; n_type == K_DEFAULT
				)
			) {
				break;
			}
			else if (p2 &amp;&amp; p2 -&gt; n_type == KP_BLOCK) {

				/* Look for a case in the block. */
				p2 = block_ptr(p2) -&gt; block_body;
			}
			else {
				/* Report the error at the start of the switch. */
				delayed_error(start_line,
					es("'case' or label expected after 'switch' statement"));
				break;
			}
		}
	}

	switch_ref = old_switch;
	break_ref  = old_break;

	STATX(ftag);
	return p;
}
</t>
<t tx="ekr.20080529093004.614">@ Parse a 'while' statement.
@c

static while_node *
par_while(void)
{
	FTAG("par_while");
	register pnode * old_continue = continue_ref;
	register pnode * old_break = break_ref;
	register while_node * p = NULL;
	STATB(ftag);

	/* Read the "while" */
	par_next();

	/* Create a while_node. */
	new_pnode_macro(p, sizeof(while_node), K_WHILE);

	/* Update reference lists. */
	continue_ref = (pnode *) p;
	break_ref    = (pnode *) p;

	/* Parse. */
	p -&gt; while_bool = par_parenexp();

	/* Set the number of lines spanned by the start of the 'while' statement. */
	p_set_line_count_macro(p, err_line - p -&gt; p_line);

	p -&gt; while_body = par_statement();

	/* Restore reference lists. */
	continue_ref = old_continue;
	break_ref  = old_break;

	STATX(ftag);
	return p;
}
</t>
<t tx="ekr.20080529093004.615">/*
	CC2: ANSI Symbol table routines.

	source:  CCst.c
	started: August 4, 1992.
	version:
		May 1, 1993.
			Propagate static attribute from previous prototype to current function definition.
		April 8, 1993.
			Added caller tracing to st_enter, st_lookup.
		March 24, 1993.
			Added proper check for duplicate tag definitions in st_enter_tag.
			Added proper check for duplicate definitions in st_enter.
		September 18, 1992.
			Removed all old checking code.
		August 21, 1992.
			Added statistics variables and st_stats.
		August 4, 1992.
*/

#undef NO_STATS		/* #defined: Disable statistics code in CC2debug.h. */

&lt;&lt; CCst #includes &gt;&gt;
&lt;&lt; CCst declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.616">#include "CC.h"

#include "CCdump.h"
#include "CCgen.h"
#include "CCmem.h"
#include "CCparser.h"
</t>
<t tx="ekr.20080529093004.617">/*
	Define statistics variables.
*/
#ifndef PRODUCTION
	static long st_probes = 0;		/* Total number of probes. */
	static long st_calls = 0;		/* Number of calls to lookup routines. */
	static long st_misses = 0;		/* Number of conflicts between name spaces. */

	static long st_fields = 0;		/* Current number of allocated items. */
	static long	st_objects = 0;
	static long st_tags = 0;

	static long st_max_fields = 0;	/* Max number of allocated items. */
	static long st_max_objects = 0;
	static long st_max_tags = 0;

	static long st_tot_fields = 0;	/* Current number of allocated items. */
	static long	st_tot_objects = 0;
	static long st_tot_tags = 0;
#endif

/*
	Define variables used only by this module.
*/

typedef struct st_block_struct st_block;

static struct st_block_struct {
	st_block *	stb_next;
	long		stb_block;	/* Block number of this block. */
	snode *		stb_life;	/* Head of lifetime list for this block. */
};

static st_block * st_block_list = NULL;	/* List of current blocks. */
static st_block * st_free_list = NULL;	/* List of free blocks. */
static snode * st_global_list = NULL;	/* List of vars in file scope. */
static long st_current_block = 0;		/* Current block number. */
static long	 st_max_block = 0;			/* Maximum block number. */

/*
	Function prototypes for internal routines.
*/
static void			st_detach(snode * life);
</t>
<t tx="ekr.20080529093004.618">@ Define macros serving as in-line functions
@c

#define attach_macro(sp, spell_p, current_stat, max_stat, total_stat)\
{\
	/* Update statistics. */\
	STATS(current_stat++; total_stat++; max_stat = max(current_stat, max_stat));\
	\
	/* Add the block number. */\
	sp -&gt; block = st_current_block;\
	\
	/* Add the symbol to the current lifetime list. */\
	sp -&gt; life = st_block_list -&gt; stb_life;\
	st_block_list -&gt; stb_life = sp;\
	\
	/* Hang node from the spelling node. */\
	sp -&gt; next = spell_p -&gt; spell_symbol;\
	if (spell_p -&gt; spell_symbol) {\
		spell_p -&gt; spell_symbol -&gt; back = sp;\
	}\
	spell_p -&gt; spell_symbol = sp;\
}

/*
	Begin a block.

	This routine is called...
	o at the begining of a file to manage global variables,
	o at the start of each new-style prototype to manage prototype names,
	o at the start of each function to manage function variables,
	o at the start of each block to manage block variables.
*/
void
st_begin_block	(void)
{
	FTAG("st_begin_block");
	st_block * stb_p = NULL;
	TRACEPB(ftag,
		elong(st_max_block + 1); enl());

	/* Enter a new block. */
	st_current_block = ++st_max_block;

	/* Allocate a new block. */
	new_perm_macro(stb_p, perm_st_block_stats);

	/* Attach it to the head of the block list. */
	stb_p -&gt; stb_next = st_block_list;
	stb_p -&gt; stb_block = st_current_block;
	st_block_list = stb_p;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.619">@ Free all symbol nodes on a lifetime list from their position on a bucket list.  Each bucket list starts with a spelling node, and the first node on the bucket list has a NULL back field.
@c

static void
st_detach(snode * list)
{
	FTAG("st_detach");
	FTAGV("st_detach_v");
	snode * st_p = NULL;
	long detach_count = 0;
	STATB(ftag);

	for (st_p = list; st_p; st_p = st_p -&gt; life) {

		TRACEN(ftagv,
			es("Detaching: ");
			es(st_p -&gt; spell -&gt; spell_name); ecs(); etnode(st_p -&gt; ctype); enl());
		detach_count++;

		STATS(
			if (st_p -&gt; nspace == FIELD_NSPACE) {
				st_fields--;
			}
			else if (st_p -&gt; nspace == OBJECT_NSPACE) {
				st_objects--;
			}
			else {
				ASSERT(st_p -&gt; nspace == TAG_NSPACE);
				st_tags--;
			}
		);

		if (st_p -&gt; back == NULL) {

			/* The node is the first node on the bucket list. */
			ASSERT(st_p -&gt; spell -&gt; spell_symbol == st_p);

			/* Set the forward link in the spelling node. */
			st_p -&gt; spell -&gt; spell_symbol = st_p -&gt; next;

			/* Set the back link in the next node, if it exists. */
			if (st_p -&gt; next) {
				ASSERT(st_p -&gt; next -&gt; back == st_p);
				st_p -&gt; next -&gt; back = NULL;
			}
		}
		else {

			/* The node is *not* the first node on the bucket list. */
			ASSERT(st_p -&gt; back -&gt; next == st_p);
			ASSERT(st_p -&gt; back != st_p -&gt; next);

			/* Set the next link in the previous node. */
			st_p -&gt; back -&gt; next = st_p -&gt; next;

			/* Set the back link in the next node, if it exists. */
			if (st_p -&gt; next) {
				ASSERT(st_p -&gt; next -&gt; back == st_p);
				st_p -&gt; next -&gt; back = st_p -&gt; back;
			}
		}
	}

	TRACEPX(ftag, elong(detach_count); es(" nodes detached\n"));
}
</t>
<t tx="ekr.20080529093004.620">@ Exit a block, i.e., detach all nodes on the current lifetime list from their spelling nodes.  The block is *never* actually freed, but only entered on a free list.
@c

void
st_end_block (void)
{
	FTAG("st_end_block");
	TRACEPB(ftag, elong(st_current_block); enl());

	/* Detach all nodes with this block's lifetime. */
	ASSERT(st_block_list);
	st_detach(st_block_list -&gt; stb_life);

	/* Free the current st_block. */
	st_free_list = st_block_list;
	st_block_list = st_block_list -&gt; stb_next;

	/* Reset the current block number. */
	st_current_block = (st_block_list) ? st_block_list -&gt; stb_block : 0;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.621">@ Enter a symbol into the symbol table.
@c

void
st_enter (register snode * new_sp)
{
	FTAG("st_enter");
	register spell_node * spell_p = NULL;
	TRACEPB(ftag,
		es(caller_ftag); es(": ");
		es(caller2_ftag); es(": ");
		es(caller3_ftag); ecs();
		es("new_sp: "); esnode(new_sp); ecnl());
	ASSERT(new_sp);

	/* Check for a null symbol, which can be caused by user errors. */
	spell_p = new_sp -&gt; spell;
	if (spell_p == NULL || new_sp -&gt; ctype == NULL) {
		TRACEPN(ftag, es("NULL symbol name or type\n"));
		goto done;
	}

	ASSERT(st_current_block &gt; 0 &amp;&amp; st_block_list != NULL);

	/* Set the name space. */
	new_sp -&gt; nspace = OBJECT_NSPACE;

	/*
		Check for duplicate defintions in the current block.
		This loop is very fast because few items are typically on the list.
	*/
	{
		snode * old_sp = spell_p -&gt; spell_symbol;

		for ( ; old_sp; old_sp = old_sp -&gt; next) {

			if (old_sp -&gt; nspace == OBJECT_NSPACE &amp;&amp;
				old_sp -&gt; block == st_current_block
			) {

				/* 3/3/93: KLUDGE: user errors can cause this. */
				if (old_sp -&gt; ctype == NULL || new_sp -&gt; ctype == NULL) {
					goto done;
				}
				else if (s_is_proto(old_sp)) {

					if (s_is_proto(new_sp)) {

						/* 8/27/93: use ct_eq_proto, not ct_eq */
						if (ct_eq_proto(old_sp, new_sp)) {

							/* Don't re-enter the new equivalent prototype. */
							goto done;
						}
						else if (new_sp -&gt; dcls == NULL) {

							/* Always ignore an old-style prototype. */
							goto done;
						}
						else if (old_sp -&gt; dcls == NULL) {

							/* A new-style prototype overrides an old-style prototype. */
							goto attach;
						}
						else {
							error(es("prototypes do not match. Ignoring new prototype"));
							goto done;
						}
					}
					else if (ct_eq_proto(old_sp, new_sp)) {

						/*
							Enter the new function definition.
							5/1/93: propagate static attribute to new definition.
						*/
						if (s_is_static(old_sp)) {
							s_set_static(new_sp);
						}
						goto attach;
					}
					else {
						error(es("function does not match prototype"));
						goto done;
					}
				}
				else if (s_is_code(old_sp)) {

					if (s_is_proto(new_sp)) {

						if (ct_eq_proto(old_sp, new_sp)) {

							/* Ignore the new prototype. */
							goto done;
						}
						else if (new_sp -&gt; dcls == NULL) {

							/* Always ignore an old-style prototype. */
							goto done;
						}
						else {
							error(
								es("Prototype for ");
								es(old_sp -&gt; spell -&gt; spell_name);
								es(" does not match previous function"));
							goto done;
						}
					}
					else if (s_is_code(new_sp)) {
						error(
							es("Duplicate definition of ");
							es(old_sp -&gt; spell -&gt; spell_name));
						goto done;
					}
				}
				else if ((s_is_extern(old_sp) || s_is_extern(new_sp))) {

					if (ct_eq(old_sp -&gt; ctype, new_sp -&gt; ctype)) {

						/* Enter the new definition. */
						goto attach;
					}
					else {
						error(
							es("Definition of ");
							es(old_sp -&gt; spell -&gt; spell_name);
							es(" does not match previous extern definition"));
						goto done;
					}
				}
				else {
					error(
						es("Duplicate definition of ");
						es(old_sp -&gt; spell -&gt; spell_name));
					goto done;
				}
			}
		}
	}

	/* Actually enter the symbol. */
attach:
	attach_macro(new_sp, spell_p, st_objects, st_max_objects, st_tot_objects);

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.622">@ Enter a field name into the symbol table.
@c

void
st_enter_field (register snode * sp)
{
	FTAG("st_enter_field");
	register spell_node * spell_p = NULL;
	STATB(ftag);
	ASSERT(sp);

	/* Check for a null symbol, which can be caused by user errors. */
	spell_p = sp -&gt; spell;
	if (spell_p == NULL || sp -&gt; ctype == NULL) {
		TRACEPN(ftag, es("NULL symbol name or type\n"));
		goto done;
	}

	ASSERT(
		sp -&gt; ctype &amp;&amp; sp -&gt; ctype -&gt; tdcls &amp;&amp;
		st_current_block &gt; 0 &amp;&amp; st_block_list != NULL);

	/* Set the name space. */
	sp -&gt; nspace = FIELD_NSPACE;

	/*
		Check for duplicate defintions in the current block.
		This loop is very fast because few items are typically on the list.
	*/
	{
		register snode * sp2 = spell_p -&gt; spell_symbol;

		for ( ; sp2; sp2 = sp2 -&gt; next) {

			if (sp2 -&gt; nspace == FIELD_NSPACE &amp;&amp;
				sp2 -&gt; block == st_current_block &amp;&amp;
				sp2 -&gt; ctype -&gt; tdcls == sp -&gt; ctype -&gt; tdcls
			) {
				/* A duplicate definition. */
				error(
					es("duplicate definition of field: ");
					es(spell_p -&gt; spell_name);
					es(" in: ");
					if (sp -&gt; ctype -&gt; tdcls -&gt; spell) {
						es(sp -&gt; ctype -&gt; tdcls -&gt; spell -&gt; spell_name);
					}
					else {
						es("unnamed struct/union");
					}
				);
				goto done;
			}
		}
	}

	/* Actually enter the symbol. */
	attach_macro(sp, spell_p, st_fields, st_max_fields, st_tot_fields);

done:

	TRACEPX(ftag,
		es(sp -&gt; spell -&gt; spell_name); es(" parent: ");
		if (sp -&gt; ctype -&gt; tdcls -&gt; spell) {
			es(sp -&gt; ctype -&gt; tdcls -&gt; spell -&gt; spell_name);
		}
		else {
			es("unnamed");
		}
		es(" type: "); etnode(sp -&gt; ctype);
		ecnl();
	);
}
</t>
<t tx="ekr.20080529093004.623">@ Enter a tag.
@c

void
st_enter_tag (register snode * sp)
{
	FTAG("st_enter_tag");
	register spell_node * spell_p = NULL;
	TRACEPB(ftag,
		esnode(sp); ecnl());

	ASSERT(sp);

	/* Check for a null symbol, which can be caused by user errors. */
	spell_p = sp -&gt; spell;
	if (spell_p == NULL || sp -&gt; ctype == NULL) {
		TRACEPN(ftag, es("NULL symbol name or type\n"));
		goto done;
	}

	ASSERT(st_current_block &gt; 0 &amp;&amp; st_block_list != NULL);

	/* Set the name space. */
	sp -&gt; nspace = TAG_NSPACE;

	/*
		Check for duplicate defintions in the current block.
		This loop is very fast because few items are typically on the list.
	*/
	{
		register snode * sp2 = spell_p -&gt; spell_symbol;

		for ( ; sp2; sp2 = sp2 -&gt; next) {

			if (sp2 -&gt; nspace == TAG_NSPACE &amp;&amp;
				sp2 -&gt; block == st_current_block
			) {
				/*
					Duplicate tags are only erroneous if both contain fields.
				*/
				if (sp -&gt; dcls == NULL) {

					/* A "dummy" definition is always fine. */
					goto attach;
				}
				else if (sp2 -&gt; dcls == NULL) {

					/* Complete the definition. */
					sp2 -&gt; dcls = sp -&gt; dcls;
					goto attach;
				}
				else {
					error(
						es("Duplicate definition of ");
						es(spell_p -&gt; spell_name); enl());
					goto done;
				}
			}
		}
	}

	/* Actually enter the symbol. */
attach:
	attach_macro(sp, spell_p, st_tags, st_max_tags, st_tot_tags);

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.624">void
st_init (void)
{
	FTAG("st_init");
	TICK(ftag);

	STATS(
		st_calls = st_misses = st_probes = 0;
		st_fields = st_objects = st_tags = 0;
		st_max_fields = st_max_objects = st_max_tags = 0;
	);
}
</t>
<t tx="ekr.20080529093004.625">snode *
st_lookup (spell_node * spell_p)
{
	FTAG("st_lookup");
	register snode * sp = NULL;
	STATB(ftag);

	ASSERT(spell_p);
	STATS(st_calls++);

	/* Look for any non-tag, non-field. */
	for (sp = spell_p -&gt; spell_symbol; sp; sp = sp -&gt; next) {

		STATS(st_probes++);

		/* Look for the next object. */
		if (sp -&gt; nspace == OBJECT_NSPACE) {
			TRACEPX(ftag,
				es(caller_ftag); es(": ");
				es(caller2_ftag); es(": ");
				es(caller3_ftag); es(": ");
				es(spell_p -&gt; spell_name); es(" found: "); esnode(sp); ecnl());
			return sp;
		}

		STATS(st_misses++);
	}

	TRACEPX(ftag, es(spell_p -&gt; spell_name); es(" not found\n"));
	return NULL;
}
</t>
<t tx="ekr.20080529093004.626">snode *
st_lookup_field (spell_node * spell_p, register snode * parent)
{
	FTAG("st_lookup_field");
	register snode * sp = NULL;
	STATB(ftag);

	ASSERT(spell_p &amp;&amp; parent);
	STATS(st_calls++);

	/* Look for a field with the proper parent. */
	for (sp = spell_p -&gt; spell_symbol; sp; sp = sp -&gt; next) {

		STATS(st_probes++);

		/* Look for the next field element. */
		if (sp -&gt; nspace == FIELD_NSPACE &amp;&amp;
			sp -&gt; ctype &amp;&amp;
			sp -&gt; ctype -&gt; tdcls == parent
		) {
			TRACEPX(ftag,
				es(spell_p -&gt; spell_name); es(" found");
				if (parent -&gt; spell &amp;&amp; parent -&gt; spell -&gt; spell_name) {
					es(" in parent "); es(parent -&gt; spell -&gt; spell_name);
				}
				es(" type: "); etnode(sp -&gt; ctype);
				enl());
			return sp;
		}

		STATS(st_misses++);
	}

	TRACEPX(ftag,
		es(spell_p -&gt; spell_name); es(" not found");
		if (parent -&gt; spell &amp;&amp; parent -&gt; spell -&gt; spell_name) {
			es(" in parent "); es(parent -&gt; spell -&gt; spell_name);
		}
		enl());
	return NULL;
}
</t>
<t tx="ekr.20080529093004.627">snode *
st_lookup_tag (spell_node * spell_p)
{
	FTAG("st_lookup_tag");
	register snode * sp = NULL;
	STATB(ftag);
	ASSERT(spell_p);
	STATS(st_calls++);

	/* Look for any tag. */
	for (sp = spell_p -&gt; spell_symbol; sp; sp = sp -&gt; next) {

		STATS(st_probes++);

		/* Look for the next tag. */
		if (sp -&gt; nspace == TAG_NSPACE) {

			TRACEPX(ftag, es(spell_p -&gt; spell_name); es(" found\n"));
			return sp;
		}

		STATS(st_misses++);
	}

	TRACEPX(ftag, es(spell_p -&gt; spell_name); es(" not found\n"));
	return NULL;
}
</t>
<t tx="ekr.20080529093004.628">@ Print all symbol table stats.
@c

void
st_stats (void)
{

#define line0(a,b,c,d) epads(a, 10); epads(b, 8); epads(c, 8); epads(d, 8); enl();
#define line(a,b,c,d) epads(a, 10); epadlong(b, 8); epadlong(c, 8); epadlong(d, 8); enl();

#ifndef PRODUCTION

	ecnls(2);
	es("Symbol table statistics...\n\n");

	line0("name space", "current", "maximum", "total");
	line("objects", st_objects, st_max_objects, st_tot_objects);
	line("tags", st_tags, st_max_tags, st_tot_tags);
	line("fields", st_fields, st_max_fields, st_tot_fields);
	line("totals",
		st_objects + st_tags + st_fields,
		st_max_objects + st_max_tags + st_max_fields,
		st_tot_objects + st_tot_tags + st_tot_fields);
	enl();

	es("calls: "); elong(st_calls);
	es(" probes: "); elong(st_probes);
	es(" misses: "); elong(st_misses);
	enl();

#endif

}
</t>
<t tx="ekr.20080529093004.629"></t>
<t tx="ekr.20080529093004.630"></t>
<t tx="ekr.20080529093004.631"></t>
<t tx="ekr.20080529093004.632">/*
	CC2: Header files for dump routines.

	Source:  CCdump.h
	Started: June 5, 1992.
	Version:
		February 7, 1993.
			esmods made public.
		December 8, 1992.
			etmods now takes a tnode * argument.
		September 24, 1992.
			Added etnode_full();
			Added etnode_brief_flag.
		July 23, 1992.
			Added flag param to etmods.
		June 5, 1992.
*/

/*
	Make sure this file is included only once.
*/
#ifndef edump_h_
#define edump_h_

#pragma once

#include "CCparser.h"

/* Global variables. */

extern bool eline_flag;			/* TRUE: print line numbers in eline(). */
extern bool etnode_brief_flag;	/* TRUE: print brief type nodes. */

/* Function prototypes. */

	/* enums */

void eetype	(int etype);			/* Expression type. */
void etmods	(tnode *, int flag);	/* 'tmods' fields of type node. */
void etoknum(token tok);			/* Token number. */
void etprim	(int tprim);			/* 'tprim' field of type node. */

	/* Tokens. */

void	etok	(token * p);

	/* Code nodes. */

void	eanode		(anode * p);
void	ecinode		(cinode * p);
void	ecnode		(cnode * p);
void	ecodelist	(cnode * p);

	/* Expression nodes */

void	eenode		(enode * p);
void	eop1node	(op1_enode * p);
void	eop2node	(op2_enode * p);
void	eop3node	(op3_enode * p);

	/* Statement nodes. */

void	edcls	(snode * p);
void	epnode	(pnode * p);
void	esnode	(snode * p);
void 	esmods	(snode * s_p);


	/* Stand alone parser nodes. */

void	einode		(inode * p);
void	escope_node	(scope_node * p);

	/* Type nodes. */

void	etnode		(tnode * p);
void	etnode_full	(tnode * p);
void	ettype		(int ttype);

#endif /* edump_h_ */
</t>
<t tx="ekr.20080529093004.633">/*
	CC2: Function prototypes for Code Generation and Output routines.

	Source:  CCgen.h
	Started: June 4, 1992
	Version:
		January 11, 1995.
			Changed the meaning of the unsigned flag to c_ext and c_ext_constant.
			It must represent the whether the *old* value is unsigned,
			not whether the new value is unsigned.
		January 6, 1995.
			Added gen_current_base.
		January 5, 1995.
			Added arguments to out_stack_comment.
		December 16, 1994.
			Added c_2clab.
		November 11, 1994.
			Added src_address_flag and dst_address_flag to c_memmove.
		November 10, 1994.
			Added c_load_big.
		August 27, 1994.
			Added out_data_name_offset.
		August 25, 1994.
			Added force_data_area_flag to out_data_string.
			This makes *sure* that initializers for static strings are in the data area.
			(Strings are the only data that are kludged into the code area by default.)
		July 26, 1993.
			Added out_switch_offset.
		July 20, 1993.
			Added out_data_offset.
		July 14, 1993.
			Added ep argument to c_push_float.
		July 12, 1993.
			Added constants representing TRUE/FALSE in function arguments.
		July 8, 1993.
			Added c_lea.
			Removed gf_call1.
			Added c_ext_constant.
		July 7, 1993.
			Removed mask_7f_anode and mask_7fff_anode.
			Added mask_00ff_anode, mask_000000ff_anode, mask_0000ffff_anode.
		June 18, 1993.
			Added c_long2mlen and c_ulong2mlen.
		June 16, 1993.
			Added gen_switch_size.
		June 3, 1993.
			Added gen_expr_line.
		June 1, 1993.
			Added gen_func_init.
		May 25, 1993.
			Removed unused parameter from gen_fbody.
		May 23, 1993.
			Added c_line2.
		May 11, 1993.
			Added export_flag to out_data_ulabel.
		May 9, 1993.
			Removed copy_flag from c_ap2address.
		April 28, 1993.
			Added out_data_clabel.
		April 27, 1993.
			Added out_entry.
		April 22, 1993.
			Added no_push_anode.
			Added gen_switch_list and gen_switch_tables..
			Added gen_import, gen_all_imports and out_import.
			Added import_list_node.
		April 20, 1993.
			Added GEN_GLOBAL_ADDRESS.
		April 15, 1993.
			Added gf_call_nz.
			c_push and c_push float now return the number of bytes pushed on the stack.
		April 14, 1993.
			Removed gf_call0.
		April 13, 1993.
			Changed c_line so now it just points to a pnode.
			Added gen_vprefix.
		April 12, 1993.
			Changed gen_call_1arg to long.
			Added one_arg_flag to c_push and c_push_float.
		April 11, 1993.
			Added comment_flag and value args to out_data_clabel_ref.
		April 8, 1993.
			Added c_check_ptr routine.
		April 4, 1993.
			Added comment arg to out_clabel.
		April 3, 1993.
			Added out_data_f2i and out_data_i2f.
		April 2, 1993.
			Added out_data_clabel_ref.
			Added c_memmove.
		April 1, 1993.
			Added out_data_xxx routines.
			Added out_stack_comment.
		March 31, 1993.
			Added gen_init_data.
			Removed out_decl.
			Added out_data_ulabel and out_zero.
			Made out_clabel global and added the define_flag parameter.
		March 27, 1993.
			Removed gkind and label_flag fields from gen_new_big_anode.
			Removed out_constants.
		March 26, 1993.
			Added gen_alloc_function.
		March 25, 1993.
			Added out_auto_decl.
		March 18, 1993.
			Changed gen_dealloc_locals to reg_free_locals.
		March 17, 1993.
			Added bp argument to get_dcl_reg.
			Added bp argument to get_reg.
			Added bp argument to gen_free_user.
			New reg_free_formals routine.
		March 12, 1993.
			Made c_put global.
		March 7, 1993.
			Added reg_init_check.
		February 12, 1993.
			gen_new_big_anode now takes a label_flag parameter.
		February 11, 1993.
			Added gen_formal_reg_list.
			gen_alloc_locals now takes a pointer to a block
			(instead a pointer to a list of snodes).
		February 10, 1993.
			Merged gen.c and gexpr.c to gen.c.
		February 2, 1993.
			New c_clr routine.
			Replaced gen_abool by gen_bool.
		January 22, 1993.
			Added gen_auto_inits.
		January 21, 1993.
			Added c_ext.
		January 18, 1993.
			c_push_float made global.
			New c_push routine.
		January 14, 1993.
			Added gf_assn2, gf_cast, gf_op2, gf_pre_post, gf_uminus.
			Removed gen_fexpr, gen_iexpr.
		January 13, 1993.
			Added gf_relop.
		January 12, 1993.
			Made g_args local to gint.c.
			Removed GEN_DO_ONLY.
		January 11, 1993.
			Made get_reg global.
		January 2, 1993.
			Made c_copy global.
		December 31, 1992.
			Removed gen_a0exp, gen_d0exp, gen_dexpr and gen_expr_init.
		December 28, 1992.
			Added c_s2mlen.
		December 23, 1992.
			Added c_2len2.
			Added c_move_len.
		December 19, 1992.
			Added f_one_anode,fd_one_anode, fld_one_anode.
			Added gen_new_big_anode
		December 13, 1992.
			Added c_adj_stack.
		December 12, 1992.
			Added out_begin_file, out_end_file, out_error.
		December 2, 1992.
			Removed g_dcl_name and g_str_name.
		November 12, 1992.
			Defined globals formerly part of fbody_gnode's.
		November 6, 1992.
			changed g_mlen to  g_e2mlen.
		November 3, 1992.
			Reorganized code generator files.
			Added reg_spill_all.
			Added g_call_libx routines.
		September 21, 1992.
			Added gen_call_1arg.
		September 6, 1992.
			Added out_comment.
		August 28, 1992.
			Removed regs_clear.
			Added reg_perm_init.
			Added gne_perm_init.
		August 6, 1992.
			Converted dcl_nodes to st_nodes.
		July 16, 1992
			g_str_name and g_dcl_name now return a spell node.
		July 5, 1992.
			g_line now takes a long argument.
		June 23, 1992
			Removed definitions of nodes.
			Added global variables.
		June 4, 1992
			Created from: tmp.h (C*:3/7/89) and node.h (C*: 3/5/87).
*/

/*
	Make sure this header is included only once.
*/
#ifndef gen_h_
#define gen_h_

#pragma once

	/* Data structures for code generation. */

/*
	CC2 will generate address of global, i.e., non-stack, variables
	only if the compile-time constant GEN_GLOBAL_ADDRESS is #defined.

	In the Macintosh world globals are accessed as an offset from the A5 register,
	that points to the "application global area."
	Thus, the MPW assembler does not and can not allow instructions such as

		movea.l	#function,a0	;GEN_GLOBAL_ADDRESS is #define'd.

	that would move the *address* of function into register a0.
	Instead, CC2 generates

		lea	function(a5),a0		;GEN_GLOBAL_ADDRESS is #undef'ed

	instead.
*/

#if defined(THINK_C) || defined(applec) || defined(TUPLE_C)
	#undef GEN_GLOBAL_ADDRESS
#else
	#define GEN_GLOBAL_ADDRESS
#endif

/*
	A NULL true_label or false_label tells the code generators to
	let the flow of control fall through to the next instruction.
*/

#define FALL_THROUGH NULL


	/* Owned by cput.c */

extern cnode * code_head;	/* Head of list of global code list. */
extern cnode * code_tail;	/* Pointer to last node in list. */

extern tnode * 	byte_type;	/* Fixed byte node for g2.c. */
extern tnode * int_type;	/* Fixed int node for g2.c. */
extern tnode * long_type;	/* Fixed long node. */

extern int cur_lab;	/* Number of the current internal label. */
extern int u_lab;	/* Number of the current user label. */

			/* Owned by gen.c */

	/*
		The following globals describe the current function.
	*/

extern char * gen_fname;	/* Print name. */
extern snode * gen_fsnode;	/* Function's snode. */
extern tnode * gen_ftype;	/* C Language type. */

	/*
		The following globals are used by the code generators.

		gen_current_alloc is the offset of the next auto var or temp
		to be allocated on the stack.
		It is incremented whenever a variable is allocated to the stack,
		and is decremented to a saved value by gen_block when code
		for a block is complete.
		
		gen_current_base is the offset of the last local variable.
		Temporaries are allocated below this base.
		Temporaries are reallocated by setting gen_current_alloc = gen_current_base
		after each outer expression.

		gen_max_alloc is the maximum value of gen_current_alloc for a function.
		It is used to generate code that allocates stack space.

		gen_formals is a list of formal parameters.
		It is needed so that space can be allocated to formal parameters.

		gen_formal_size is used only to see whether LINK/UNLK instructions
		must be generated.

		The offsets for formal parameters assume that a LINK instruction is present,
		so we had better generate LINK/UNLK unless *both* gen_max_alloc
		and gen_formal_size are zero!

		Count the number of calls to functions g1, g2...gn with one argument
		IN THE CURRENT FUNCTION, say f.
		See extensive comments in gen.c concerning gen_call_1arg.

		gen_vprefix is the next nn used to disambiguat names of statics.
		Such names have the form file@name@nn.

		gen_switch_list is a list of all switches in the current function.
		This list is kept so jump tables can be generated after the function,
		thereby eliminating forward references.

		gen_expr_line is the line number of the current expression.
		This is used to generate warnings and errors in the code generators.
	*/

extern ulong gen_current_alloc;
extern ulong gen_current_base;
extern ulong gen_max_alloc;

extern snode * gen_formals;
extern ulong gen_formal_size;
extern pnode * gen_parse_tree;
extern long	 gen_call_1arg;
extern long	 gen_vprefix;
extern switch_node * gen_switch_list;
extern long	 gen_expr_line;

extern anode * one_anode;		/* Constant 1 */
extern anode * zero_anode;		/* Constant 0 */

extern anode * mask_00ff_anode;		/* Constant 0x00ff */
extern anode * mask_000000ff_anode;	/* Constant 0x000000ff */
extern anode * mask_0000ffff_anode;	/* Constant 0x0000ffff */

extern anode * f_one_anode;		/* Constant 1.0 (float) */
extern anode * fd_one_anode;	/* Constant 1.0 (double) */
extern anode * fld_one_anode;	/* Constant 1.0 (long double) */

	/* Ownded by gstat.c */

extern label_cnode * gen_break_label;
extern label_cnode * gen_continue_label;
extern label_cnode * gen_ret_label;

/*
		These anodes represent particular locations and are to be used *only*
		as arguments to routines in cput.c which guarantee not to change them.

		They must *never* be used as a return value of a function
		because the routines in this file would not know they were
		in use and so might reallocate them.
*/
extern anode * a0_anode;	/* anode representing a0. */
extern anode * a6_anode;	/* anode representing a6. */
extern anode * a7_anode;	/* anode representing a7. */
extern anode * d0_anode;	/* anode representing d0. */
extern anode * d7_anode;	/* Reserved to spill nodes to huge stack frames. */

extern anode * no_push_anode;	/* anode representing (a7) */
extern anode * pop_anode;		/* anode representing (a7)+. */
extern anode * push_anode;		/* anode representing -(a7). */

extern anode * hidden_anode;	/* anode representing 8(a6), the hidden argument. */

	/* Function prototypes. */

	/* cout.c */

	/* Define synonyms for export flag. */
	#define EXPORT_THE_LABEL 		TRUE
	#define DONT_EXPORT_THE_LABEL	FALSE

	/* Define synonyms for the define_flag. */
	#define DEFINE_THE_LABEL		TRUE
	#define DONT_DEFINE_THE_LABEL	FALSE

	/* Define synonyms for comment_flag and a NULL comment. */
	#define PRINT_A_COMMENT			TRUE
	#define DONT_PRINT_A_COMMENT	FALSE
	#define NO_COMMENT				NULL

	/* Define synonyms for trailing_zero_flag. */
	#define ADD_TRAILING_ZERO		TRUE
	#define DONT_ADD_TRAILING_ZERO	FALSE

	/* Define synonyms for formal_flag. */
	#define FORMAL_ARG		TRUE
	#define NON_FORMAL_ARG	FALSE
	
	/* Synonms for the force_data_area_flag. */
	#define FORCE_DATA_AREA      TRUE
	#define DONT_FORCE_DATA_AREA FALSE

void	out_begin_file		(void);
void	out_clabel			(label_cnode * p, bool define_flag, char * comment);
void	out_data_address	(snode * s_p);
void	out_data_clabel		(label_cnode * p, bool define_flag, char * comment);
void	out_data_clabel_ref	(label_cnode * label, bool comment_flag, long value);
void	out_data_float		(char * defstr, int ckind);
void	out_data_f2i		(char * defstr, tnode * itype);
void	out_data_i2f		(long val, int ckind);
void	out_data_int		(long val, int msize);
void	out_data_name_offset(char * name, long offset);
void	out_data_offset		(snode * s_p, long offset);
void	out_data_string		(char * s, bool trailing_zero_flag, bool force_data_area_flag);
void	out_data_ulabel		(snode * s_p, bool define_flag, bool export_flag);
void	out_end_file		(void);
void	out_entry			(char * name, bool static_flag);
void	out_export_clabel	(label_cnode * label);
void	out_error			(void);
void	out_func_head		(void);
void	out_function		(int r_push, int do_addq);
void	out_import			(snode * s_p, bool lib_flag);
void	out_stack_comment	(anode * ap, ulong size, char * tag, char * name);
void	out_string_clabel	(label_cnode * label, char * comment);
void	out_switch_offset
	(label_cnode * switch_label, label_cnode * case_label, bool comment_flag, long value);
void	out_zero			(ulong size);

	/* cpeep.c */

void	peep_hole	(void);

	/* cput.c */
	
	/* Define synonyms for unsigned_flag. */
	#define UNSIGNED_EXTEND TRUE
	#define SIGNED_EXTEND FALSE
	
	/* Define synonums for address_flag. */
		#define PUSH_ADDRESS TRUE
		#define PUSH_VALUE   FALSE
		
		#define TAKE_ADDRESS TRUE
		#define TAKE_VALUE   FALSE
	
	/* Define synonyms for one_arg_flag. */
	#define ONE_ARG			TRUE
	#define MULTIPLE_ARGS	FALSE
	
	/* Define synonyms for free_flag. */
	#define FREE_AP			TRUE
	#define DONT_FREE_AP	FALSE

void	c_0			(int opcode);
void	c_1			(int opcode, anode *ap);
void	c_1len		(int opcode, anode *ap, int length);
void	c_1len1		(int opcode, anode *ap);
void	c_1clab		(int opcode, label_cnode *lp);
void	c_1ulab		(int opcode, ulabel_cnode *lp);
void	c_2			(int opcode, anode *ap1, anode *ap2);
void	c_2clab		(int opcode, anode *ap, label_cnode *lp);
void	c_2len		(int opcode, anode *ap1, anode *ap2, int length);
void	c_2len2		(int opcode, anode *ap1, anode *ap2);
void	c_adj_stack	(long size);
anode *	c_ap2address(anode * ap);
void	c_chk_ptr	(anode *ap);
void	c_clabel	(label_cnode *lp);
void	c_clr		(anode *ap);
anode *	c_copy		(anode *ap);
int		c_e2mlen	(enode *ep);

anode *	c_ext			(anode *ap, int length, bool old_unsigned_flag);
anode *	c_ext_constant	(anode *ap, int mlen,   bool old_unsigned_flag);

anode *	c_lea		(anode * ap);
anode *	c_lea_temp	(anode * ap);
anode *	c_lea_opt	(anode * ap, bool free_flag);
void	c_line		(pnode * p);
void	c_line2		(do_node * p);

anode *	c_load_big	(anode *ap, enode * ep);

short	c_long2mlen		(long n);
short	c_ulong2mlen	(ulong n);

void	c_memmove	(anode * dst_ap, bool dst_address_flag,
					 anode * src_ap, bool src_address_flag, ulong size);

anode *	c_move2atreg	(anode * ap);
anode *	c_move2dtreg	(anode * ap);

void	c_move			(anode *ap1, anode *ap2);
void	c_move_big		(anode * src_ap, bool src_address_flag,
						 anode * dst_ap, bool dst_address_flag, ulong size);
void	c_move_len		(anode *ap1, anode *ap2, int length);
ulong	c_push			(anode *ap, bool one_arg_flag);
ulong	c_push_address	(anode *ap, bool one_arg_flag);
ulong	c_push_big		(anode *ap, bool one_arg_flag, ulong size);
ulong	c_push_float	(anode *ap, bool one_arg_flag, enode * ep);
void	c_put			(cnode *cp);
void	c_ulabel		(ulabel_cnode * lp);
int		c_s2mlen		(snode *s_p);
int		c_t2mlen		(tnode *t);

	/* gbody.c */

	/* Define synonyms for lib_flag. */
	#define USE_LIB_PREFIX		TRUE
	#define DONT_USE_LIB_PREFIX	FALSE

void	gen_alloc_function	(snode * s_p);
void	gen_alloc_locals	(block_node * bp);
void	gen_alloc_outers	(snode * s_p);
void	gen_all_imports		(void);
void	gen_auto_inits		(snode * s_p);
void	gen_fbody			(void);
void	gen_import			(snode * s_p, bool lib_flag);
void	gen_import_name		(char * name, bool lib_flag);
void	gen_init_data		(snode * s_p);

	/* gbool.c */

void	gen_bool	(enode *ep, label_cnode *true_lab, label_cnode *false_lab);

	/* gen.c */

	/* Define synonyms for the translate_flag of gen_pp. */
	#define      TRANSLATE_POST_OPS	TRUE
	#define DONT_TRANSLATE_POST_OPS	FALSE
	
	/* Define synonym for a NULL name. */
	#define NO_NAME NULL
	
	/* Define synonyms for update_base_flag. */
	#define UPDATE_GEN_CURRENT_BASE			TRUE
	#define DONT_UPDATE_GEN_CURRENT_BASE	FALSE


void	gen_call2			(anode *ap1, anode *ap2, char *string);
anode *	gen_expr			(enode *ep);
void	gen_func_init		(void);
void	gen_init			(void);
anode *	gen_new_big_anode	(int ckind, char * def);
anode *	gen_new_stack_anode	(ulong size, short a_length, char * tag, char * name);
void	gen_outer_expr		(enode *ep);
void	gen_perm_init		(void);
void	gen_pp				(enode *ep, bool translate_flag);

	/* gfloat.c */

anode *	gf_assn2	(op2_enode * op2_p, register anode * dst_ap, register anode * src_ap);
anode *	gf_call_nz	(enode *ep, anode * ap1);
anode *	gf_cast2i	(op1_enode * ep);
anode *	gf_cast2f	(op1_enode * ep);
anode *	gf_op2		(op2_enode *ep, char *op_name);
anode *	gf_pre_post (op1_enode *ep, bool pre_flag, bool inc_flag);
anode * gf_relop	(op2_enode *ep);
anode *	gf_uminus	(op1_enode * ep);

	/* gint.c */

anode *	gen_e1		(enode *ep);
anode *	g_call		(op2_enode *ep);
bool	g_cmp		(anode *ap1, anode *ap2);
anode *	g_comma		(op2_enode *ep);
anode *	g_cons		(cons_enode *ep);
anode *	g_index		(op2_enode *ep);
anode *	g_prim		(enode *ep);
anode *	g_ternary	(op3_enode *ep);
anode *	g_uplus		(op1_enode *ep);

	/* gstat.c */

void	gen_list			(pnode * p);
void	gen_switch_tables	(void);
uint	gen_switch_size		(void);

#endif /* gen_h_ */
</t>
<t tx="ekr.20080529093004.634">/*
	CC: header for CCregs.h

	source:  CCregs.h
	started: June 8, 1994.
	version: June 8, 1994.
*/

/*
	Make sure this header is included only once.
*/
#ifndef CCregs_h_
#define CCregs_h_

#pragma once

/*
	Abbreviations.
*/
#define reg_is_free(i)		reg_free_array[reg_index(i)]
#define reg_is_used(i)		reg_used_array[reg_index(i)]
#define reg_is_pushed(i)	reg_push_array[reg_index(i)]
#define reg_index(i)		(i - R_FIRST_REG)

/*
	Define macros indicating register ranges...

	? Registers A0, A1, D0, D1 and D2 are scratch registers and
	  are never saved or restored by a function.
	  The caller of any function must assume that these registers are clobbered.

	? Registers A2, A3, A4, D3, D4, D5 and D6 may be allocated to user variables.

	? Register D7 is reserved for use as an index register
	  when spilling to stack frame larger than 32K.

	? Registers A5, A6 and A7 are reserved for the global pointer,
	  frame pointer and stack pointer, respectively.

	? Functions return non-pointer values (if any) in D0.
	  Pointer values are returned in A0, or D0 if arg_d0_only_flag option is enabled.

	? Register temporaries are assigned to scratch registers or unallocated
	  user registers.

	Warning: code in gen_function() must be changed if these macros are changed.
*/
#define A_FIRST_SCRATCH	R_A0
#define A_LAST_SCRATCH	R_A1

#define D_FIRST_SCRATCH	R_D0
#define D_LAST_SCRATCH	R_D2

#define A_FIRST_USER	R_A2
#define A_LAST_USER		R_A4

#define D_FIRST_USER	R_D3
#define D_LAST_USER		R_D6

#define A_FIRST_TEMP	R_A0
#define A_SECOND_TEMP	R_A1
#define A_LAST_TEMP		R_A4

#define D_FIRST_TEMP	R_D0
#define D_SECOND_TEMP	R_D1
#define D_LAST_TEMP		R_D6

/*
	These macros indicate the number of registers available in each category.
*/
#define A_SCRATCH_TOTAL	(A_LAST_SCRATCH - A_FIRST_SCRATCH + 1)
#define D_SCRATCH_TOTAL	(D_LAST_SCRATCH - D_FIRST_SCRATCH + 1)

#define A_USER_TOTAL	(A_LAST_USER - A_FIRST_USER + 1)
#define D_USER_TOTAL	(D_LAST_USER - D_FIRST_USER + 1)

#define A_TEMP_TOTAL	(A_LAST_TEMP - A_FIRST_TEMP + 1)
#define D_TEMP_TOTAL	(D_LAST_TEMP - D_FIRST_TEMP + 1)

/*
	Global variables.
*/

extern reg_node * reg_node_avail_list;	/* Available reg_list_nodes. */

extern sbool reg_free_array [R_LAST_REG-R_FIRST_REG+1]; /* TRUE: the register is not in use. */
extern sbool reg_used_array [R_LAST_REG-R_FIRST_REG+1]; /* TRUE: the register has been used. */
extern sbool reg_push_array [R_LAST_REG-R_FIRST_REG+1]; /* TRUE: the register must be pushed on entry. */

extern int reg_na_free;	/* Number of free A-regs. */
extern int reg_nd_free;	/* Number of free D-regs. */

extern int reg_na_user;	/* Number of user A-regs. */
extern int reg_nd_user;	/* Number of user D-regs. */

extern bool reg_ret_a;	/* TRUE if a0 is used for function return. */
extern bool	reg_ret_d;	/* TRUE if d0 is used for function return. */

/*
	Function prototypes.
*/

anode *	get_dcl_reg	(snode *s_p, block_node *bp);

void	free_temp	(anode * ap);

anode *	get_atemp		(int length);
anode *	get_a0			(int length);
anode *	get_dtemp		(int length);
anode *	get_d0			(int length);
anode *	get_reg			(int the_reg, int length, bool temp_flag, block_node *bp);
anode *	get_temp		(int length);

bool	is_equiv	(anode * ap1, anode * ap2);

void	reg_free_all	(void);
void	reg_free_formals(void);
void	reg_free_locals	(block_node * bp);
void	reg_free_user	(reg_node * rp, block_node * bp);
void	reg_init		(void);
void	reg_init_check	(void);
void	reg_perm_init	(void);
void	reg_spill_all	(void);

#endif /* CCregs_h_ */
</t>
<t tx="ekr.20080529093004.635"></t>
<t tx="ekr.20080529093004.636">/*
	CC2: type checking and conversion routines.

	Source:  CCctype.c
	Started: August 20, 1992
	Version:
		November15, 1994.
			Bug fix to ct_check_args.
				Passing an int when a char is expected resulted in a cast to char.
				This is incorrect.  The int must be pushed on the stack.
		August 26, 1994.
			Added ternop code to ct_is_lval.
		June 4, 1994.
			bug fix: is_scalar_type must include arrays.
		November 1, 1993.
			Allow unary minus applied to an unsigned variable.
		July 23, 1993.
			Changed ct_cvt_r2l to eliminate do-nothing floating casts.
			(This helps c_push_float make proper assumptions about floating arguments.)
		July 21, 1993.
			Removed all old code.
		July 13, 1993.
			Added ct_copy_expr_tree.
			Added ct_cast_arg1 and ct_cast_arg2.
		July 12, 1993.
			? Changed ct_convert2 to convert all floating temporary results to long double.
			This is allowed by the "as if" rule and gives maximum precision.
			It also simplifies the run-time library: only long double routines are needed.
			? Changed ct_cvt_r2l to convert a op= b to a = a op b if either a or b is a float.
			This is necessary so that all floating temps have long double size.
		July 7, 1993.
			Bug fix: call ct_convert2(op_p) in EQUAL_TOK and NE_TOK, just like other relops.
		July 5, 1993.
			Bug fix: changed POINTER_TYPE to is_gen_ptr_prim in MINUS_TOK case of ct_type2.
		June 30, 1993.
			Added code to ct_check_args to cast byte actual parameters to ints.
			This allows the ctype of the argument to stay char,
			while putting the pushed byte in the spot allocated by gen_formal_alloc.
		June 23, 1993.
			Bug fix to ct_copy_type_tree: don't follow ttype for structs/unions/enums.
		June 15, 1993.
			Rewrote the logic of the usual arithmetic conversion to use only
				the t_size field and t_is_unsigned.
				(This avoids unnecessary casts when the machine sizes of two
				differently declared variables are actually the same.
				More importantly, it makes the code independent of the actual
				machine sizes of short, int, long, float, double and long double.)
			Eliminated calls to t_set_xxx macros.
				(These are not necessary now that there is not tmods field.
				The tsize field alone is sufficient to determine machine type.)
			Bug fix: Added test of tsize field for float types in ct_eq.
		June 8, 1993.
			Bug fix: convert (int) 0 to (void *) 0 in ct_check_args.
		June 3, 1993.
			Do not promote shift operators based on the shift count.
			(This resulted from a disagreement between Standard and Rationale!)
		May 23, 1993.
			Added ct_func_name for better error messages concerning function calls.
		May 5, 1993.
			Printed copy sent to Tuple.
		April 7, 1993.
			Completed ct_check_args.
		March 8, 1993.
			Convert 0 to pointer constant if required.
		March 3, 1993.
			Bug fix in ct_check_args.
		February 25, 1993.
			Removed help message about ambiguous casts.
		February 23, 1993.
			Allow operands to have NULL types, which can arise from user errors.
			This produced changes throughout the code.
		January 21, 1993.
			Bug fix in ct_check_args.
		January 19, 1993.
			Allow NULL types as long as err_count &gt; 0.
		January 13, 1993.
			is_scalar_prim changed to include floating types (!)
		October 23, 1992.
			The ct_typex routines now are void routines.
			Added abbreviation macros.
			Use ct_eq instead of ct_eq_array and ct_eq_ptr.
			Added ct_copy_type_tree.
		October 22, 1992.
			Several routines moved to this file from expr.c.
			Simplified ct_is_null.
		August 20, 1992.
			Original version created from dcl2.c.
*/
&lt;&lt; CCctype #includes &gt;&gt;
&lt;&lt; CCctype declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.637">#include "CC.h"

#include "CCdump.h"
#include "CCmem.h"
#include "CCparser.h"
</t>
<t tx="ekr.20080529093004.638">/*
	The following abbreviation macros hide some of the details of how
	types are represented.
*/
#define is_arith_prim(p)  ((p) == INT_TYPE || (p) == FLOAT_TYPE)
#define is_su_prim(p)     ((p) == STRUCT_TYPE || (p) == UNION_TYPE)
#define is_gen_ptr_prim(p)((p) == POINTER_TYPE || (p) == ARRAY_TYPE)
#define is_scalar_prim(p) \
	((p) == INT_TYPE || (p) == FLOAT_TYPE || (p) == POINTER_TYPE || (p) == ARRAY_TYPE)
#define is_ptr_to_void(t) ((t) &amp;&amp; (t) -&gt; tprim == VOID_TYPE)

/*
	Prototypes of internal routines.
*/
	/* Synonyms for message_flag. */
	enum { GIVE_ERROR_MESSAGE = TRUE, DONT_GIVE_ERROR_MESSAGE = FALSE };

static void		 ct_cast_arg1		(enode * ep, tnode * t);
static void		 ct_cast_arg2		(enode * ep, tnode * t);
static void		 ct_check_args		(op2_enode * op_p, tnode * t);
static tnode *	 ct_convert2		(op2_enode * op_p);
static tnode *	 ct_convert3		(op3_enode * op_p);
static enode *	 ct_copy_expr_tree	(enode * ep);
static tnode *	 ct_copy_type_tree	(tnode * ep);
static op2_enode *	ct_cvt_r2l		(op2_enode * op_p);
static char *	 ct_func_name		(op2_enode * p);
static bool		 ct_is_lval			(enode *p, bool message_flag);
static bool		 ct_is_null			(enode *p);
static void		 ct_promote			(op1_enode * op1);
</t>
<t tx="ekr.20080529093004.639">@ Cast the arg1 field of ep to t.
@c

static void
ct_cast_arg1(enode * ep, tnode * t)
{
	FTAG("ct_cast_arg1");
	op1_enode * cast_p = NULL;
	STATB(ftag);

	ASSERT(ep &amp;&amp; (is_unop(ep -&gt; n_type) || is_binop(ep -&gt; n_type)));

	/* Create a new cast node. */
	new_enode_macro(cast_p, sizeof(op1_enode), CAST_TOK);
	cast_p -&gt; e_ctype = t;

	/* Hang the cast node from ep -&gt; arg1. */
	cast_p -&gt; arg1 = op2_ptr(ep) -&gt; arg1;
	op2_ptr(ep) -&gt; arg1 = enode_ptr(cast_p);

	TRACEPX(ftag, es("cast "); eenode(cast_p -&gt; arg1); es(" to "); etnode(t); ecnl());
}
</t>
<t tx="ekr.20080529093004.640">@ Cast the arg1 field of ep to t.
@c

static void
ct_cast_arg2(enode * ep, tnode * t)
{
	FTAG("ct_cast_arg2");
	op1_enode * cast_p = NULL;
	STATB(ftag);

	ASSERT(ep &amp;&amp; (is_unop(ep -&gt; n_type) || is_binop(ep -&gt; n_type)));

	/* Create a new cast node. */
	new_enode_macro(cast_p, sizeof(op1_enode), CAST_TOK);
	cast_p -&gt; e_ctype = t;

	/* Hang the cast node from ep -&gt; arg2. */
	cast_p -&gt; arg1 = op2_ptr(ep) -&gt; arg2;
	op2_ptr(ep) -&gt; arg2 = enode_ptr(cast_p);

	TRACEPX(ftag, es("cast "); eenode(cast_p -&gt; arg1); es(" to "); etnode(t); ecnl());
}
</t>
<t tx="ekr.20080529093004.641">@ This function compares the list of actual arguments against the list of formal parameters.  Actually, this comparison should be made only if a function prototype for the function has already been seen. At present that fine point is ignored.  Section 3.3.2.2 Function calls.  "if the expression that denotes the called function has a type that does not include a prototype, the integral promostions are performed on each argument and arguments that have type float are promoted to double. These are the *default argument promotions*..."  "If the expression that denotes the called function has a type that includes a prototype, the arguments are implicitly converted, as if by assignment, to the types of the corresponding parameters. The ellipsis notation in a function prototype declarator causes argument type conversion to stop after the last declared parameter. The default promotions are performed on trailing arguments..."  "No other conversions are performed implicitly; in particular, the number and types of arguments are not compared with those of the parameters in a function definition that does not include a function prototype declarator."  The link_cast_macro links the cast node into the expression tree. The first parameter is hung from p -&gt; arg2. All other parameters are hung from the preceding param, pointed to by back.
@c

#define link_cast_macro(cast_ep, ap, p, back) \
ASSERT(p -&gt; arg2 == ap || (back &amp;&amp; back -&gt; n_next == ap));\
if (ap -&gt; n_type == CONS_TOK) {\
	cons_ptr(ap) -&gt; cons_car = cast_ep;\
}\
else if (back) {\
	back -&gt; n_next = cast_ep;\
}\
else {\
	p -&gt; arg2 = cast_ep;\
}\
TRACEP(ftag, es("new parameters: "); eenode(p -&gt; arg2); ecnl());

static void
ct_check_args(op2_enode * p, tnode * t)
{
FTAG("ct_check_args");
snode * fp = t -&gt; tdcls;		/* Pointer to list of formal names. */
enode * ap = p -&gt; arg2; 		/* Pointer to list of actual expressions. */
register enode * back = NULL;	/* Either back -&gt; n_next == ap or p -&gt; arg2 == ap. */
register tnode * at = NULL;		/* Type of the actual param. */
register tnode * ft = NULL;		/* Type of the formal param. */
register int aprim = 0;			/* at -&gt; tprim or 0. */
register int fprim = 0;			/* ft -&gt; tprim. */
int param_count = 1;			/* Parameter counter. */
char * name = ct_func_name(p);	/* Name of function being called. */

TRACEPB(ftag, es("parameters on entry: "); eenode(p -&gt; arg2); ecnl());

while(fp &amp;&amp; ap) {

	enode * ap2 = (ap -&gt; n_type == CONS_TOK) ? cons_ptr(ap) -&gt; cons_car : ap;
	ASSERT(ap2);
	at = ap2 -&gt; e_ctype;

	if (fp -&gt; n_type == KP_DOTS3) {

		/*
			CC2 is more strict than standard C.
			the default argument promotions are *only* done here.
		*/
		goto do_default_promotions;
	}
	else {
		ft = fp -&gt; ctype;
	}

	ASSERT_TRACE(ft, esnode(fp));
	fprim = ft -&gt; tprim;
	aprim = at ? at -&gt; tprim : 0;

	if (at == NULL) {
		/* Don't warn again about undefined variables. */
		if (err_count == 0) {
			fatal(es("NULL actual argument"));
		}
	}		
	else if (ft -&gt; tprim == INT_TYPE &amp;&amp; ft -&gt; tsize == 1) {

		/*
			7/1/93: Push a char parameter as an int by casting the actual parameter.

			We have to do this because the LSB of an int is not
			at the same address as the int.

			Real EXT instructions *must* be generated when pushing char variables,
			for several reasons.

			1.  We can't rely on the fact that the hardware changes 1-byte
			pushes to 2-byte pushes because an int may be 4 bytes.
			Besides, the call_1arg optimization results in a move, not a push.

			2.  We can't just change the size of the operand to INT_SIZE since
			mult-byte operands must be word-aligned.

			Without this constraint pushing garbage in the high bytes might work.
			That is, instead of generating, for instance,

				move.b	var,Dn
				ext.w	Dn
				ext.l	Dn
				move.l	Dn,-(a7)

			We could just change c_push so it generates

				move.l	var-3,-(a7)

			Still this is truly ugly, and *very* hard to understand.

			We cast the *actual* parameter, not the formal parameter.
			This allows casts to work properly when required on the formal param.

			Note that gen_formal_alloc creates an anode describing only
			the LSB of the pushed int.
			This allows the ctype of the formal to remain char,
			and that is essential to handling prototypes correctly.
			
			Bug 11/15/94:
				Create a cast to int unless ap is already an *int* (not a char).
		*/

		if (at -&gt; tprim == INT_TYPE &amp;&amp; at -&gt; tsize == INT_SIZE) {
		
			/* No type conversion is needed. */
			;
		}
		else {

			/* Cast the parameter to int. */
			enode * cast_ep = NULL;
			new_enode_macro(cast_ep, sizeof(op1_enode), CAST_TOK);
			op1_ptr(cast_ep) -&gt; arg1 = ap2;
			new_tnode_macro(cast_ep -&gt; e_ctype, INT_TYPE, INT_SIZE);

			/* Link the new cast node into the tree. */
			link_cast_macro(cast_ep, ap, p, back);
		}
	}
	else if (ct_eq(at, ft)) {
	
		/* No type conversion is needed. */
			;
	}
	else if (is_arith_prim(aprim) &amp;&amp; is_arith_prim(fprim)) {

		/* Create a cast node to convert ap2 to ft. */
		enode * cast_ep = NULL;
		new_enode_macro(cast_ep, sizeof(op1_enode), CAST_TOK);
		op1_ptr(cast_ep) -&gt; arg1 = ap2;
		op1_ptr(cast_ep) -&gt; e_ctype = ct_copy_type_tree(ft);

		/* Link the cast node into the tree. */
		link_cast_macro(cast_ep, ap, p, back);
	}
	else if (aprim == fprim &amp;&amp; is_su_prim(aprim)) {
		;
	}
	else if (
		is_gen_ptr_prim(aprim) &amp;&amp;
		is_gen_ptr_prim(fprim) &amp;&amp;
		(is_ptr_to_void(at) || is_ptr_to_void(ft))
	) {
		;
	}
	else if (
		fprim == POINTER_TYPE &amp;&amp;
			(
				is_gen_ptr_prim(aprim) ||
			 	ct_is_null(ap2)			/* Bug fix: 3/2/92 */
			)
	) {
		/*
			Bug fix: 6/8/93:
			Convert MPW (int) 0 to (void *) 0.
			This corrects the length of the argument.
		*/
		if (aprim != POINTER_TYPE) {

			/* Create a cast node to convert (int) 0 to (void *) 0. */
			enode * cast_ep = NULL;
			new_enode_macro(cast_ep, sizeof(op1_enode), CAST_TOK);
			op1_ptr(cast_ep) -&gt; arg1 = ap2;
			new_tnode_macro(cast_ep -&gt; e_ctype, POINTER_TYPE, POINTER_SIZE);
			new_tnode_macro(cast_ep -&gt; e_ctype -&gt; ttype, VOID_TYPE, 0);

			/* Link the new cast node into the tree. */
			link_cast_macro(cast_ep, ap, p, back);
		}
	}
	else {
		error(
			es("type mismatch at parameter "); eint(param_count);
			if (name) {
				es(" of "); es(name); es("()");
			}
			TRACEN(ftag, ecnl();
				es("ft: "); etnode(ft); ecnl(); es("at: "); etnode(at););
		);
	}

	back = ap;
	ap = ap -&gt; n_next;
	fp = fp -&gt; n_next;
	param_count++;
}

if (fp &amp;&amp; fp -&gt; n_type != KP_VOID_VAR &amp;&amp; fp -&gt; n_type != KP_DOTS3) {
	error(
		es("too few actual parameters");
		if (name) {
			es(" to "); es(name); es("()");
		}
	);
}

if (ap &amp;&amp; fp &amp;&amp; fp -&gt; n_type != KP_DOTS3) {
	error(
		es("too many actual parameters");
		if (name) {
			es(" to "); es(name); es("()");
		}
	);
}
goto done;

do_default_promotions:

while(ap) {

	enode * ap2 = (ap -&gt; n_type == CONS_TOK) ? cons_ptr(ap) -&gt; cons_car : ap;
	ASSERT(ap2);
	at = ap2 -&gt; e_ctype;

	if (at == NULL) {
		/* Don't warn again about undefined variables. */
		if (err_count == 0) {
			fatal(es("NULL actual argument"));
		}
	}
	else if (at -&gt; tprim == INT_TYPE &amp;&amp; at -&gt; tsize &lt; PROMOTE_SIZE) {

		/* Create a cast node to promote the int type to full int. */
		enode * cast_ep = NULL;
		new_enode_macro(cast_ep, sizeof(op1_enode), CAST_TOK);
		op1_ptr(cast_ep) -&gt; arg1 = ap2;
		new_tnode_macro(cast_ep -&gt; e_ctype, INT_TYPE, PROMOTE_SIZE);

		/* Link the new cast node into the tree. */
		link_cast_macro(cast_ep, ap, p, back);

		TRACEPN(ftag,
			es("cast "); eenode(ap);
			es(" to "); etnode(cast_ep -&gt; e_ctype); ecnl());
	}
	else if (
		at -&gt; tprim == FLOAT_TYPE &amp;&amp;
		at -&gt; tsize == FLOAT_SIZE &amp;&amp;
		FLOAT_SIZE != DOUBLE_SIZE
	) {

		/* Create a cast node to convert the float to double. */
		enode * cast_ep = NULL;
		new_enode_macro(cast_ep, sizeof(op1_enode), CAST_TOK);
		op1_ptr(cast_ep) -&gt; arg1 = ap2;
		new_tnode_macro(cast_ep -&gt; e_ctype, FLOAT_TYPE, DOUBLE_SIZE);
		t_set_double(cast_ep -&gt; e_ctype);

		/* Link the new cast node into the tree. */
		link_cast_macro(cast_ep, ap, p, back);

		TRACEPN(ftag,
			es("cast "); eenode(ap);
			es(" to "); etnode(cast_ep -&gt; e_ctype); ecnl());
	}
	else {

		/* No conversion is possible, since there is no formal type. */
		;
	}

	back = ap;
	ap = ap -&gt; n_next;
}

done:
TRACEPX(ftag, es("parameters on exit: "); eenode(p -&gt; arg2); ecnl());
}
</t>
<t tx="ekr.20080529093004.642">@ Perform the "usual arithmetic conversions" as needed on a binary operator to convert a narrower operator to a wider.  Return the type of the wider argument.  Section 3.2.1.1 Characters and Integers.  "A char, a short int, or an int bit-field, or their signed or unsigned varieties, or an enumeration type, may be used in an expression wherever an int or unsigned int may be used. If an int can represent all values of the original type, the value is converted to int; otherwise it is converted to an unsigned int. These are called the *integral promotions*."  [The following code does not handle bit fields.]  Section 3.2.1.5: Usual Arithmetic Conversions.  "If either operand has type long double, the other operand is converted to long double. Otherwise, if either operand has type double, the other operand is converted to double. Otherwise, if either operand has type float, the other operand is converted to float. Otherwise, the integral promotions are performed on both operands. Then the following rules are applied:  If either operand has type unsigned long int, the other operand is converted to unsigned long int. Otherwise, if one operand has type long int and the other has type unsigned int, if a long int can represent all values of an unsigned int, the operand of type unsigned int is converted to type long int; if a long int cannot represent all the values of an unsigned int, both operands are converted to unsigned long int. Otherwise, if either operand has type long int, the other operand is converted to long int. Otherwise, if either operand has type unsigned int, the other operand is converted to unsigned int. Otherwise, both operands have type int."  6/15/93: These conversions are simplified by noting that the *declared* type of an integer can and *should* be ignored. All that matters is the actual *machine* size of an integer and whether it is unsigned or not.  7/12/93: All floating operations are done in long-double size. This is permissible under the "as if" rule. This is consistent with how MPW C works and gives the best possible accuracy. It also decreases the number of floating point library routines.
@c

static tnode *
ct_convert2 (op2_enode * op_p)
{
	FTAG("ct_convert2");
	register tnode * t1 = NULL;
	register tnode * t2 = NULL;
	register int prim1 = 0;
	register int prim2 = 0;
	tnode * result_t = NULL;
	TRACEPB(ftag,
		eenode(enode_ptr(op_p)); enl());

	/* Make sure both arguments exist. */
	if (op_p == NULL || op_p -&gt; arg1 == NULL || op_p -&gt; arg2 == NULL) {
		goto done;
	}

	/* Make sure both types exist. */
	t1 = op_p -&gt; arg1 -&gt; e_ctype;
	t2 = op_p -&gt; arg2 -&gt; e_ctype;

	if (t1 == NULL || t2 == NULL) {
		goto done;
	}

	/* Make the default return the type of argument 1. */
	result_t = t1;

	/* Make sure both primitives are arithmetic. */
	prim1 = t1 -&gt; tprim;
	prim2 = t2 -&gt; tprim;

	/* Bug fix: 10/23/92 */
	if (!is_arith_prim(prim1) || !is_arith_prim(prim2)) {
		goto done;
	}

	if (prim1 == INT_TYPE &amp;&amp; prim2 == INT_TYPE) {

		if (t1 -&gt; tsize &gt; t2 -&gt; tsize) {
			goto widen2;
		}
		else if (t2 -&gt; tsize &gt; t1 -&gt; tsize) {
			goto widen1;
		}
		else if (t_is_unsigned(t1) &amp;&amp; !t_is_unsigned(t2)) {
			goto widen2;
		}
		else if (t_is_unsigned(t2) &amp;&amp; !t_is_unsigned(t1)) {
			goto widen1;
		}
		else {
			/* Promoting chars to ints is done elsewhere. */
			goto done;
		}
	}
	else {

		ASSERT(prim1 == FLOAT_TYPE || prim2 == FLOAT_TYPE);

		/* Create casts as needed to widen *both* arguments to long double. */
		if (
			prim1 == INT_TYPE ||
			(prim1 == FLOAT_TYPE &amp;&amp; t1 -&gt; tsize != LONG_DOUBLE_SIZE)
		) {

			new_tnode_macro(result_t, FLOAT_TYPE, LONG_DOUBLE_SIZE);
			ct_cast_arg1(enode_ptr(op_p), result_t);
		}

		if (
			prim2 == INT_TYPE ||
			(prim2 == FLOAT_TYPE &amp;&amp; t2 -&gt; tsize != LONG_DOUBLE_SIZE)
		) {

			new_tnode_macro(result_t, FLOAT_TYPE, LONG_DOUBLE_SIZE);
			ct_cast_arg2(enode_ptr(op_p), result_t);
		}

		goto done;
	}

	fatal(es("fall into widen1"));

	/* Create a cast to convert op_p -&gt; arg1 to t2. */

widen1:
	result_t = ct_copy_type_tree(t2);
	ct_cast_arg1(enode_ptr(op_p), result_t);
	goto done;

	/* Create a cast to convert op_p -&gt; arg2 to t1. */

widen2:

	result_t = ct_copy_type_tree(t1);
	ct_cast_arg2(enode_ptr(op_p), result_t);
	goto done;

done:
	TRACEPX(ftag, eret(); etnode(result_t));
	return result_t;
}
</t>
<t tx="ekr.20080529093004.643">@ Same as ct_convert2, except that the arg2 and arg3 fields of an op3_enode are converted instead of the arg1 and arg2 fields of an op2_enode.
@c

static tnode *
ct_convert3(op3_enode * op_p)
{
	FTAG("ct_convert3");
	tnode * t = NULL;
	STATB(ftag);

	/*
		Fill in the arg1 and arg2 fields for ct_convert2.
		Put in a dummy n_type field for eenode.
	*/
	if (op_p) {

		op2_enode op2;
		op2 . n_type = PLUS_TOK;	/* A dummy operator; it could be any binary op. */
		op2 . arg1 = op_p -&gt; arg2;
		op2 . arg2 = op_p -&gt; arg3;

		/* Do the actual conversions in ct_convert2(). */
		t = ct_convert2(&amp;op2);

		/* Copy the results back to the op3_enode. */
		op_p -&gt; arg2 = op2 . arg1;
		op_p -&gt; arg3 = op2 . arg2;
	}

	STATX(ftag);
	return t;
}
</t>
<t tx="ekr.20080529093004.644">@ Create a copy of an expression tree. This is done so we can convert a op= x to a = a op x.
@c

#define copy_enode_macro(dest, src, size)\
{\
	new_enode_macro(dest, size, src -&gt; n_type);\
	memcpy(dest,src,size);\
}

static enode *
ct_copy_expr_tree(register enode * ep)
{
	FTAG("ct_copy_expr_tree");
	register enode * root = NULL;
	register short op = 0;
	STATB(ftag);

	if (ep == NULL) {
		goto done;
	}

	op = ep -&gt; n_type;

	if (is_unop(op)) {

		copy_enode_macro(root, ep, sizeof(op1_enode));
		op1_ptr(root) -&gt; arg1 = ct_copy_expr_tree(op1_ptr(ep) -&gt; arg1);
	}
	else if (is_binop(op)) {

		copy_enode_macro(root, ep, sizeof(op2_enode));
		op2_ptr(root) -&gt; arg1 = ct_copy_expr_tree(op2_ptr(ep) -&gt; arg1);
		op2_ptr(root) -&gt; arg2 = ct_copy_expr_tree(op2_ptr(ep) -&gt; arg2);
	}
	else if (op == QUESTION_TOK) {

		copy_enode_macro(root, ep, sizeof(op3_enode));
		op3_ptr(root) -&gt; arg1 = ct_copy_expr_tree(op3_ptr(ep) -&gt; arg1);
		op3_ptr(root) -&gt; arg2 = ct_copy_expr_tree(op3_ptr(ep) -&gt; arg2);
		op3_ptr(root) -&gt; arg3 = ct_copy_expr_tree(op3_ptr(ep) -&gt; arg3);
	}
	else if (op == CONS_TOK) {

		copy_enode_macro(root, ep, sizeof(cons_enode));
		cons_ptr(root) -&gt; cons_car = ct_copy_expr_tree(cons_ptr(ep) -&gt; cons_car);
	}
	else if (op == INT_TOK || op == FLOAT_TOK || op == STRING_TOK) {

		copy_enode_macro(root, ep, sizeof(const_enode));
	}
	else {
		ASSERT(op == ID_TOK);

		copy_enode_macro(root, ep, sizeof(var_enode));
	}

done:
	TRACEPX(ftag, eret(); eenode(root); ecnl());
	return root;
}
</t>
<t tx="ekr.20080529093004.645">@ Create a copy of a type tree. This is done so that the attributes of the new tree may be changed as needed.
@c

#define copy_tnode_macro(dest, src)\
{\
	new_tnode_macro(dest, 0, 0);\
	memcpy(dest,src,sizeof(tnode));\
}

static tnode *
ct_copy_type_tree(register tnode * tp)
{
	FTAG("ct_copy_type_tree");
	tnode * root = NULL;
	register tnode * newp = NULL;
	STATB(ftag);

	if (tp == NULL) {
		goto done;
	}

	copy_tnode_macro(newp, tp);
	root = newp;
	tp = tp -&gt; ttype;

	/*
		Bug fix 6/23/93: ttype is over-loaded:
		it points to snodes for structs/unions/enums.
	*/
	while (
		tp &amp;&amp;
		tp -&gt; tprim != STRUCT_TYPE &amp;&amp; tp -&gt; tprim != UNION_TYPE &amp;&amp;
		!t_is_enum(tp)
	) {
		copy_tnode_macro(newp -&gt; ttype, tp);
		newp = newp -&gt; ttype;
		tp = tp -&gt; ttype;
	}

done:
	TRACEPX(ftag, eret(); etnode(root); ecnl());
	return root;
}
</t>
<t tx="ekr.20080529093004.646">@ Cast the right side to the type of the left side if necessary. (op_p -&gt; arg1 is the left side, op_p -&gt; arg2 is the right side.)  7/12/93: Translate a op= b into a = a op b if either a or b is a float. This allows all operations to be done in long double width.  7/23/93: Eliminate do-nothing floating casts. This allows the code generators (especially c_push_float) to assume that *all* floating sub-expressions return a result in a floating temporary. (c_push_float shouldn't need to assume this, and right now it does.)
@c

static op2_enode *
ct_cvt_r2l (op2_enode * op_p)
{
	FTAG("ct_cvt_r2l");
	register tnode * t1 = NULL;
	register tnode * t2 = NULL;
	register int tmods1 = 0;
	register int tmods2 = 0;
	op2_enode * return_ep = op_p;
	STATB(ftag);

	/* Make sure both arguments exist. */
	if (op_p == NULL || op_p -&gt; arg1 == NULL || op_p -&gt; arg2 == NULL) {
		goto done;
	}

	/* Make sure both types exist. */
	t1 = op_p -&gt; arg1 -&gt; e_ctype;
	t2 = op_p -&gt; arg2 -&gt; e_ctype;

	if (t1 == NULL || t2 == NULL) {
		goto done;
	}

	/*
		7/12/93: If either a or x has any floating type, translate a op= expr to
			a = (t) ( (long double) a op (long double) expr)
		where t is the type of a.
	*/
	if (t1 -&gt; tprim == FLOAT_TYPE || t2 -&gt; tprim == FLOAT_TYPE) {

		/* We must have an assignment op. */
		short op = op_p -&gt; n_type;
		short new_op = 0;
		enode * copy_of_lhs = NULL;
		enode * new_assn_ep = NULL;
		enode * new_op_ep = NULL;

		ASSERT(
			op == ASSN_TOK ||
			op == DIV_ASSN_TOK ||
			op == MINUS_ASSN_TOK ||
			op == PLUS_ASSN_TOK ||
			op == STAR_ASSN_TOK);

		/*
			Bug fix: 7/16/93.
			You would think that long doubles would not have to be converted.
			However, we must not confuse the LHS of an assign op with the
			intermediate result, so *all* floating assn-ops must be converted here.
		*/
		switch(op) {

			case ASSN_TOK:			goto cast_r2l;
			case DIV_ASSN_TOK:		new_op = DIV_TOK;	break;
			case MINUS_ASSN_TOK:	new_op = MINUS_TOK;	break;
			case PLUS_ASSN_TOK:		new_op = PLUS_TOK;	break;
			case STAR_ASSN_TOK:		new_op = STAR_TOK;	break;
			default: fatal(es("cast_r2l"));
		}

		/* Make a copy of the left expression tree. */
		copy_of_lhs = ct_copy_expr_tree(op_p -&gt; arg1);

		/* Create a node representing the new operator. */
		ASSERT(is_binop(new_op));
		new_enode_macro(new_op_ep, sizeof(op2_enode), new_op);
		op2_ptr(new_op_ep) -&gt; arg1 = copy_of_lhs;
		op2_ptr(new_op_ep) -&gt; arg2 = op2_ptr(op_p) -&gt; arg2;
		new_tnode_macro(new_op_ep -&gt; e_ctype, FLOAT_TYPE, LONG_DOUBLE_SIZE);

		/*
			Set the types of the arguments of the new arguments.
			Warning: the types of the assignment must be reset below.
		*/
		t1 = op2_ptr(new_op_ep) -&gt; arg1 -&gt; e_ctype;
		t2 = op2_ptr(new_op_ep) -&gt; arg2 -&gt; e_ctype;

		ASSERT(t1 &amp;&amp; t2);

		/* Cast the operator's left operand to long double. */
		if (t1 -&gt; tsize != LONG_DOUBLE_SIZE) {

			/* Create a tnode representing long double. */
			tnode * ld_type = NULL;
			new_tnode_macro(ld_type, FLOAT_TYPE, LONG_DOUBLE_SIZE);

			/* Cast the new_op_ep -&gt; arg1 to long double. */
			ct_cast_arg1(new_op_ep, ld_type);
		}

		/* Cast the operator's right operand to long double. */
		if (t2 -&gt; tsize != LONG_DOUBLE_SIZE) {

			/* Create a tnode representing long double. */
			tnode * ld_type = NULL;
			new_tnode_macro(ld_type, FLOAT_TYPE, LONG_DOUBLE_SIZE);

			/* Cast new_op_ep -&gt; arg2 to long double. */
			ct_cast_arg2(new_op_ep, ld_type);
		}

		/* Create a node representing the new assignment. */
		{

			new_enode_macro(new_assn_ep, sizeof(op2_enode), ASSN_TOK);
			op2_ptr(new_assn_ep) -&gt; arg1 = op2_ptr(op_p) -&gt; arg1;
			op2_ptr(new_assn_ep) -&gt; arg2 = new_op_ep;
			op2_ptr(new_assn_ep) -&gt; e_ctype = op_p -&gt; arg1 -&gt; e_ctype;
		}

		TRACEPN(ftag, es("new_assn_ep: "); eenode(new_assn_ep); ecnl());

		/* Replace op_p by new_assn_ep. */
		return_ep = op2_ptr(new_assn_ep);

		TRACEPN(ftag, es("new return_op: "); eenode(enode_ptr(return_ep)); ecnl());

		/*
			Continue in order to cast the assignment operator correctly.
			Note: we use the *old* type of the lhs and the *new* type of the rhs.
		*/
		t1 = op_p -&gt; arg1 -&gt; e_ctype;
		t2 = return_ep -&gt; arg2 -&gt; e_ctype;

		if (t1 == NULL || t2 == NULL) {
			goto done;
		}
	}

	/* Create a cast node to convert the left side to the right side. */

cast_r2l:

	/* Create a cast only if the types differ. */
	if (ct_eq(t1, t2)) {
		goto done;
	}

	ct_cast_arg2(enode_ptr(return_ep), ct_copy_type_tree(t1));
	goto done;

done:
	TRACEPX(ftag, es("return_ep: "); eenode(enode_ptr(return_ep)); ecnl());
	return return_ep;
}
</t>
<t tx="ekr.20080529093004.647">@ Check that t1 and t2 denote the same type. Do *not* check type modifiers; they are checked by setype.
@c

bool
ct_eq(tnode *t1, tnode *t2)
{
	FTAG("ct_eq");
	register bool result = FALSE;
	tnode * old_t1 = t1;
	tnode * old_t2 = t2;
	STATB(ftag);

	while (t1 &amp;&amp; t2) {

		/* Handle most of the cases here. */
		if (t1 == t2) {
			goto true_ret;
		}

		/* Replace a function by what it returns. */
		if (t1 -&gt; tprim == FUNCTION_TYPE) {
			t1 = t1 -&gt; ttype;
			if (t1 == NULL) {
				goto false_ret;
			}
		}

		if (t2 -&gt; tprim == FUNCTION_TYPE) {
			t2 = t2 -&gt; ttype;
			if (t2 == NULL) {
				goto false_ret;
			}
		}

		/* Pointers may match arrays. */
		if (is_gen_ptr_prim(t1 -&gt; tprim) &amp;&amp; is_gen_ptr_prim(t2 -&gt; tprim)) {

			/* pointer to void matches pointer to anything else. */
			if (is_ptr_to_void(t1 -&gt; ttype) || is_ptr_to_void(t2 -&gt; ttype)) {
				goto true_ret;
			}
			goto linkit;
		}

		/* All other combinations of types must match exactly. */
		if (t1 -&gt; tprim != t2 -&gt; tprim) {
			goto false_ret;
		}

		switch (t1 -&gt; tprim) {

		case ARRAY_TYPE:

			if (t1 -&gt; tdim  != t2 -&gt; tdim) {
				goto false_ret;
			}
			goto linkit;

		case FLOAT_TYPE:	/* Bug fix: 6/15/93 */
		case INT_TYPE:

			/*
				Examine only the length for type comparison.
			*/
			if (t1 -&gt; tsize != t2 -&gt; tsize) {
				goto false_ret;
			}
			goto true_ret;

		case POINTER_TYPE:

			/* pointer to void matches pointer to anything else. */
			if (is_ptr_to_void(t1 -&gt; ttype) || is_ptr_to_void(t2 -&gt; ttype)) {
				goto true_ret;
			}
			goto linkit;

		case STRUCT_TYPE:
		case UNION_TYPE:

			/* Note: the ttype field of structs/unions points to a tag snode. */
			result =	t1 -&gt; ttype &amp;&amp; t2 -&gt; ttype &amp;&amp;
						t1 -&gt; ttype == t2 -&gt; ttype;
			goto done;

		linkit:
		default:
			t1 = t1 -&gt; ttype;
			t2 = t2 -&gt; ttype;
		}
	}

	result = (t1 == t2);
	goto done;

done:
	if(result) {
		goto true_ret;
	}
	else {
		goto false_ret;
	}

true_ret:
	TRACEPX(ftag, eret(); ebool(TRUE); ecs();
		etnode(old_t1); ecs(); etnode(old_t2); enl());
	return TRUE;

false_ret:
	TRACEPX(ftag, eret(); ebool(FALSE); ecs();
		etnode(old_t1); ecs(); etnode(old_t2); enl());
	return FALSE;
}
</t>
<t tx="ekr.20080529093004.648">@ Compare two function prototypes for equality.
@c

bool
ct_eq_proto(snode *old_sp, snode *new_sp)
{
	FTAG("ct_eq");
	register bool result = FALSE;
	snode * save_old = old_sp;
	snode * save_new = new_sp;
	STATB(ftag);
	ASSERT(old_sp &amp;&amp; new_sp);

	/* Make sure the returned types are the same. */
	ASSERT(old_sp -&gt; ctype -&gt; tprim == FUNCTION_TYPE);
	ASSERT(new_sp -&gt; ctype -&gt; tprim == FUNCTION_TYPE);
	if (!ct_eq(old_sp -&gt; ctype -&gt; ttype, new_sp -&gt; ctype -&gt; ttype)) {
		goto false_ret;
	}

	old_sp = old_sp -&gt; dcls;
	new_sp = new_sp -&gt; dcls;
	for (;;) {

		if (old_sp == NULL) {

			if (new_sp == NULL || new_sp -&gt; n_type == KP_DOTS3) {
				goto true_ret;
			}
			else {
				goto false_ret;
			}
		}
		else if (new_sp == NULL) {

			if (old_sp -&gt; n_type == KP_DOTS3) {
				goto true_ret;
			}
			else {
				goto false_ret;
			}
		}
		else if (!ct_eq(old_sp -&gt; ctype, new_sp -&gt; ctype)) {
			goto false_ret;
		}
		else {
			old_sp = old_sp -&gt; n_next;
			new_sp = new_sp -&gt; n_next;
		}
	}

true_ret:
	TRACEPX(ftag, eret(); ebool(TRUE); ecs();
		esnode(save_old); ecs(); esnode(save_new); enl());
	return TRUE;

false_ret:
	TRACEPX(ftag, eret(); ebool(FALSE); ecs();
		esnode(save_old); ecs(); esnode(save_new); enl());
	return FALSE;
}
</t>
<t tx="ekr.20080529093004.649">@ Return the name of the function referred to in a call operator or NULL.
@c

char *
ct_func_name(op2_enode * p)
{
	if (
		p -&gt; n_type == CALL_TOK &amp;&amp;
		p -&gt; arg1 &amp;&amp;
		p -&gt; arg1 -&gt; n_type == ID_TOK &amp;&amp;
		var_enode_ptr(p -&gt; arg1) -&gt; e_var &amp;&amp;
		var_enode_ptr(p -&gt; arg1) -&gt; e_var -&gt; spell
	) {
		return var_enode_ptr(p -&gt; arg1) -&gt; e_var -&gt; spell -&gt; spell_name;
	}
	else {
		return NULL;
	}
}
</t>
<t tx="ekr.20080529093004.650">@ Return TRUE if a p is an lvalue. Otherwise, Give the error, "lvalue required," if message flag is TRUE.  Lvalue form has root as an identifier, U*, array, ., or -&gt;.
@c

static bool
ct_is_lval(register enode *p, bool message_flag)
{
	FTAG("ct_is_lval");
	bool result = FALSE;
	STATB(ftag);

	switch (p -&gt; n_type) {

	case ID_TOK:

		/* TRUE if it is not a constant. */
		result = var_enode_ptr(p) -&gt; e_var != NULL;
		break;

	case USTAR_TOK:
	case DOT_TOK:
	case ARROW_TOK:
	case ARRAY_TOK:

		result = TRUE;
		break;

	case CAST_TOK:

		/* Recurse. */
		result = ct_is_lval(op1_ptr(p) -&gt; arg1, DONT_GIVE_ERROR_MESSAGE);
		break;
		
	case QUESTION_TOK:
	
		/* New code: 8/24/94. */
		result = 
			op3_ptr(p) -&gt; arg2 &amp;&amp;
			op3_ptr(p) -&gt; arg3 &amp;&amp;
			ct_is_lval(op3_ptr(p) -&gt; arg2, DONT_GIVE_ERROR_MESSAGE) &amp;&amp;
			ct_is_lval(op3_ptr(p) -&gt; arg3, DONT_GIVE_ERROR_MESSAGE);
		break;
			

	default:
		result = FALSE;
		break;
	}

	if (message_flag &amp;&amp; result == FALSE) {
		error(es("lvalue required"));
	}

	TRACEPX(ftag, eret(); ebool(result); ecs();
		eenode(p); enl());

	return result;
}
</t>
<t tx="ekr.20080529093004.651">@ Return TRUE if an enode is a NULL scalar constant.
@c

static bool
ct_is_null(enode *p)
{
	FTAG("ct_is_null");
	bool result = FALSE;
	STATB(ftag);

	while(p &amp;&amp; p -&gt; n_type == CAST_TOK) {
		p = op1_ptr(p) -&gt; arg1;
	}

	result = p &amp;&amp; p -&gt; n_type == INT_TOK &amp;&amp; econst_long(p) == 0;

	TRACEPX(ftag, eenode(p); enl(); eret(); ebool(result); enl());
	return result;
}
</t>
<t tx="ekr.20080529093004.652">@ Create a cast to convert ep to int and link the cast into the tree.  Section 3.2.1.1: Characters and Integers.  "A char, a short int, or an int bit-field, or their signed or unsigned varieties, or an enumeration type, may be used in an expression wherever an int or unsigned int may be used. If an int can represent all values of the original type, the value is converted to int; otherwise it is converted to an unsigned int. These are called the *integral promotions*."  Since an int can represent all chars, shorts, bit fields and enums, this code need only convert chars to ints.
@c

static void
ct_promote(op1_enode * op1)
{
	FTAG("ct_promote");
	STATB(ftag);

	if (
		op1 &amp;&amp; op1 -&gt; arg1 &amp;&amp; op1 -&gt; e_ctype &amp;&amp;
		op1 -&gt; e_ctype -&gt; tprim == INT_TOK &amp;&amp;
		op1 -&gt; e_ctype -&gt; tsize == CHAR_SIZE
	) {

		/* Create an integer tnode. */
		tnode * t = NULL;
		new_tnode_macro(t, INT_TYPE, PROMOTE_SIZE);

		ct_cast_arg1(enode_ptr(op1), t);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.653">@ Attach a type to a unary operator node.
@c

void
ct_type1(register op1_enode * op1)
{
	FTAG("ct_type1");
	register enode * arg_p = NULL;
	register tnode * op_ctype = NULL;
	register tnode * arg_ctype = NULL;
	register int arg_prim = 0;
	char * message = NULL;
	STATB(ftag);

	if (op1 == NULL) {
		goto done;
	}

	arg_p = op1 -&gt; arg1;
	if (arg_p == NULL) {
		goto done;
	}

	arg_ctype = arg_p -&gt; e_ctype;
	if (arg_ctype == NULL) {
		goto done;
	}

	arg_prim = arg_ctype -&gt; tprim;

	/*
		Save the original e_ctype field for casts.
		Then set the default e_ctype field.
	*/
	op_ctype = op1 -&gt; e_ctype;
	op1 -&gt; e_ctype = arg_ctype;

	switch (op1 -&gt; n_type) {

	case CAST_TOK:

		/* Set the type of the result. */
		op1 -&gt; e_ctype = op_ctype;

		/*
			Check the old type.
			Arrays *may* be cast, as in:  (unsigned char *) "abc";
		*/
		if (
			arg_prim == POINTER_TYPE &amp;&amp;
			op_ctype -&gt; tsize &lt; arg_ctype -&gt; tsize &amp;&amp;
			op_ctype -&gt; tprim != VOID_TYPE
		) {
			warning(es("Casting pointer to a narrower type"));
		}
		else if (is_su_prim(arg_prim) || arg_prim == FUNCTION_TYPE) {
			error(es("Can not cast structs, unions or functions"));
			goto done;
		}

		/* Check the new type. */
		#if 0 /* This message is a nuisance. */
			if (
				op_ctype -&gt; tprim == INT_TYPE &amp;&amp;  t_is_unsigned(op_ctype) &amp;&amp;
				arg_prim          == INT_TYPE &amp;&amp; !t_is_unsigned(arg_ctype) &amp;&amp;
				op_ctype -&gt; tsize &gt; arg_ctype -&gt; tsize
			) {
				help(es("Ambiguous cast will extend then convert"));
			}
			else
		#endif

		if (is_su_prim(op_ctype -&gt; tprim) || op_ctype -&gt; tprim == FUNCTION_TYPE) {
			error(es("Can not cast to structs, unions or functions"));
		}
		goto done;

	/*
		Section 3.3.3.3: Unary Arithmetic Operators.

		"The operand ... of the ! operator [shall have] scalar type."

		"The result of the logical negation operator ! ... has type int."
	*/
	case NOT_TOK:

		if (!is_scalar_prim(arg_prim)) {
			message = "scalar required";
			goto message_ret;
		}
		new_tnode_macro(op1 -&gt; e_ctype, INT_TYPE, RELOP_SIZE);
		goto done;

	/*
		Section 3.3.3.1: Prefix Increment and Decrement Operators.

		"The operand of the prefix increment or decrement operator shall
		have qualified or unqualified scalar type and shall be a modifiable
		lvalue."
	*/
	case PRE_INC_TOK:
	case PRE_DEC_TOK:
	case POST_INC_TOK:
	case POST_DEC_TOK:

		if (!is_scalar_prim(arg_prim)) {
			message = "scalar required";
			goto message_ret;
		}
		else if (!ct_is_lval(arg_p, GIVE_ERROR_MESSAGE)) {
			goto done;
		}
		else if (arg_prim == POINTER_TYPE &amp;&amp; is_ptr_to_void(arg_ctype -&gt; ttype)) {
			message = "can not increment pointer to void";
			goto message_ret;
		}
		goto done;

	/*
		Section 3.3.3.3: Unary Arithmetic Operators.

		"The operand of the unary ~ operator shall have integral type;"

		"The integral promotion is performed on the operand, and the result
		has the promoted type."
	*/
	case TILDE_TOK:

		if (arg_prim != INT_TYPE) {
			message = "integer required";
			goto message_ret;
		}
		if (arg_ctype -&gt; tsize == CHAR_SIZE) {
			ct_promote(op1);
		}
		goto done;

	/*
		Section 3.3.3.2: Adress and Indirection Operators.

		"The operand of the unary &amp; operator shall be either a function designator
		or an lvalue that designates an object that is not a bit-field and is not
		declared with the register storage-class specifier."

		"If the operand [of the &amp; operator] has type "type", the result has
		type "pointer to type."
	*/
	case UAND_TOK:

		if (!ct_is_lval(arg_p, GIVE_ERROR_MESSAGE)) {
			goto done;
		}

		new_tnode_macro(op_ctype, POINTER_TYPE, POINTER_SIZE);
		op_ctype -&gt; ttype = arg_ctype;
		op1 -&gt; e_ctype = op_ctype;
		goto done;

	/*
		Section 3.3.3.3: Unary Arithmetic Operators.

		"The operand of the unary - operator shall have arithmetic type;"

		"The integral promotion is performed on the operand, and the result
		has the promoted type."
	*/
	case UMINUS_TOK:

		if (!is_arith_prim(arg_prim)) {
			message = "arithmetic operand required";
			goto message_ret;
		}

		/*
			Bug fix: 11/1/93:
			In C, unlike C*, it is perfectly permissible to "negate"
			an unsigned variable.
		*/
		if (arg_prim == INT_TYPE &amp;&amp; arg_ctype -&gt; tsize == CHAR_SIZE) {
			ct_promote(op1);
		}
		goto done;

	/*
		Section 3.3.3.3: Unary Arithmetic Operators.

		"The operand of the unary + operator shall have arithmetic type;"

		"The result of the unary + operator is the value of its operand.
		The integral promotion is performed on the operand, and the result
		has the promoted type."
	*/
	case UPLUS_TOK:

		if (!is_arith_prim(arg_prim)) {
			message = "arithmetic operand required";
			goto message_ret;
		}
		if (arg_prim == INT_TYPE &amp;&amp; arg_ctype -&gt; tsize == CHAR_SIZE) {
			ct_promote(op1);
		}
		goto done;

	/*
		Section 3.3.3.2: Adress and Indirection Operators.

		"The operand of the unary * operator shall have pointer type."

		"The unary * operator denotes indirection. If the operand points to a function,
		the result is a function designator; if it points to an object, the result
		is an lvalue designating the object.  If the operand has type "pointer to type,"
		the result has type "type."
	*/
	case USTAR_TOK:

		if (is_gen_ptr_prim(arg_prim)) {
			op1 -&gt; e_ctype = arg_ctype -&gt; ttype;
			goto done;
		}
		else {
			message = "Argument to '*' is not a pointer";
			goto message_ret;
		}

	default:
		fatal(es("unknown unary op"));
	}

	goto done;

message_ret:

	error(es(message); es(" '"); etoknum(op1 -&gt; n_type); es("'"));

done:

TRACEPX(ftag, eenode( (enode *) op1); ecs(); etnode(op1 -&gt; e_ctype); enl());

}
</t>
<t tx="ekr.20080529093004.654">@ Attach a type to a binary operator node.
@c

op2_enode *
ct_type2(register op2_enode * op_p, bool allow_assn_to_const_flag)
{
	FTAG("ct_type2");
	FTAGV("ct_type2_v");

	char * message = NULL;

	/* Define some useful abbreviations. */
	register tnode * t1 = op_p -&gt; arg1 ? op_p -&gt; arg1 -&gt; e_ctype : NULL;
	register tnode * t2 = op_p -&gt; arg2 ? op_p -&gt; arg2 -&gt; e_ctype : NULL;
	register int prim1 = t1 ? t1 -&gt; tprim : NULL_TYPE;
	register int prim2 = t2 ? t2 -&gt; tprim : NULL_TYPE;
	int op_n_type = op_p -&gt; n_type;

	STATB(ftag);

	if (t1 == NULL || (t2 == NULL &amp;&amp; op_n_type != CALL_TOK)) {

		/*
			Second arg of call is a list which presently has no type.
			This can happen because of user errors.
			Just make sure that an error has occured.
		*/
		if (err_count == 0) {
			fatal(
				es("untyped operand of: "); etoknum(op_n_type);
				ecs(); eop2node(op_p));
		}
		goto done;
	}

	/*
		The default type of the result is the type of the first argument.
		This is also the type of the LHS of an assignment.
	*/
	op_p -&gt; e_ctype = t1;

	/*
		The cases of this switch are organized by Section of the C Standard.
	*/
	switch (op_n_type) {

	/*
		Section 3.3.2.1: Array Subscripting.

		"One of the expressions shall have type "pointer to object 'type',"
		and the other expression shall have integral type,
		and the result has type 'type'."

		"The definition of the subscript operator [] is that
		E1[ E2 ]  is identical to  (*(E1 + (E2)))."
	*/
	case ARRAY_TOK:

		/* Either array[int] or int[array] is valid. */

		if (is_gen_ptr_prim(prim1)) {

			if (prim2 == INT_TYPE) {

				/* The type of array[int] is the ttype of the array. */
				op_p -&gt; e_ctype = t1 -&gt; ttype;
				goto done;
			}
			else {
				message = "non-integral array subscript";
				goto message_ret;
			}
		}
		else if (is_gen_ptr_prim(prim2)) {

			if (prim1 == INT_TYPE) {

				/* The type of int[array] is the ttype of the array. */
				op_p -&gt; e_ctype = t2 -&gt; ttype;
				goto done;
			}
			else {
				message = "non-integral array subscript";
				goto message_ret;
			}
		}
		else {
			message = "missing array name";
			goto message_ret;
		}

	/*
		Section 3.3.2.2 Function Calls.

		"The expression that denotes the called function shall have type pointer
		to function returning void or returning an object type other than
		array type."

		"If the expression that denotes the called function has
		a type that includes a prototype,
		the number of arguments shall agree with the number of parameters.
		Each argument shall have a type such that its value may be assigned to
		an object with the unqualified version of the type of the
		corresponding parameter."
	*/
	case CALL_TOK:

		if (prim1 == FUNCTION_TYPE) {

			/* The type of a function returning t is t. */
			op_p -&gt; e_ctype = t1 -&gt; ttype;

			/* Compare the types of the actual and formal params. */
			ct_check_args(op_p, t1);
		}
		else {
			error(es("call of non-function"));
		}
		goto done;

	/*
		3.3.2.3 Structure and Union Members.

		"The first operand of the . operator shall have a qualified or unqualified
		structure or union type, and the second operand shall name a member of
		that type."

		"The first operand of the -&gt; operator shall have type
		'pointer to qualified or unqualified structure' or
		'pointer to qualified or unqualified union,'
		and the second operand shall name a member of the type pointed too."
	*/
	case ARROW_TOK:

		if (prim1 != POINTER_TYPE) {
			message = "non pointer";
			goto message_ret;
		}
		else if (t1 -&gt; ttype == NULL || !is_su_prim(t1 -&gt; ttype -&gt; tprim)) {
			message = "non struct/union pointer";
			goto message_ret;
		}
		else {

			/* The type of p -&gt; f is the type of f. */
			op_p -&gt; e_ctype = t2;
			goto done;
		}

	case DOT_TOK:

		if (is_su_prim(prim1)) {

			/* The type of p . f is the type of f */
			op_p -&gt; e_ctype = t2;
			goto done;
		}
		else {

			message = "non-struct/union";
			goto message_ret;
		}

	/*
		Compound assignment operators are grouped with their corresponding
		binary operator because of the following from section 3.3.16.2:

		"For the other operators [i.e., the other compound assignment
		operators except += and -=] each operator shall have arithmetic
		type consistent with those allowed by the corresponding binary operator."
	*/

	/*
		Section 3.3.5: Multiplicative Operators [ * / % ].

		"Each of the operands shall have arithmetic type.
		The arguments of % shall have integral type."

		"The usual arithmetic conversions are performed on both operands."
	*/
	case DIV_TOK:
	case STAR_TOK:

		if (is_arith_prim(prim1) &amp;&amp; is_arith_prim(prim2)) {
			op_p -&gt; e_ctype = ct_convert2(op_p);
			goto done;
		}
		else {
			message = "non-arithmetic operand";
			goto message_ret;
		}

	case DIV_ASSN_TOK:
	case STAR_ASSN_TOK:

		if (is_arith_prim(prim1) &amp;&amp; is_arith_prim(prim2)) {
			op_p = ct_cvt_r2l(op_p);
			goto done;
		}
		else {
			message = "non-arithmetic operand";
			goto message_ret;
		}

	case MOD_TOK:

		if (prim1 == INT_TYPE &amp;&amp; prim2 == INT_TYPE) {
			op_p -&gt; e_ctype = ct_convert2(op_p);
			goto done;
		}
		else {
			message = "non-integral operand";
			goto message_ret;
		}

	case MOD_ASSN_TOK:

		if (prim1 == INT_TYPE &amp;&amp; prim2 == INT_TYPE) {
			op_p = ct_cvt_r2l(op_p);
			goto assign_check;
		}
		else {
			message = "non-integral operand";
			goto message_ret;
		}

	/*
		Section 3.3.6: Additive operators.

		"For addition, either both operands shall have arithmetic type,
		or one operand shall be a pointer to an object and the other shall
		have integral type."

		"If both operands have arithmetic type, the usual arithmetic
		conversions are performed on them."
	*/
	case PLUS_TOK:

		if (is_arith_prim(prim1) &amp;&amp; is_arith_prim(prim2)) {
			op_p -&gt; e_ctype = ct_convert2(op_p);
			goto done;
		}
		else if (is_gen_ptr_prim(prim1) &amp;&amp; prim2 == INT_TYPE) {

			if (is_ptr_to_void(t1 -&gt; ttype)) {
				message = "invalid add to void pointer";
				goto message_ret;
			}
			else {
				/* Type of p + n is the type of p. */
				op_p -&gt; e_ctype = t1;
				goto done;
			}
		}
		else if (is_gen_ptr_prim(prim2) &amp;&amp; prim1 == INT_TYPE) {

			if (is_ptr_to_void(t2 -&gt; ttype)) {
				message = "invalid add to void pointer";
				goto message_ret;
			}
			else {
				/* Type of n + p is the type of p. */
				op_p -&gt; e_ctype = t2;
				goto done;
			}
		}
		else {
			goto mismatch_ret;
		}

		fatal(es("fall through '+'"));

	/*
		Section 3.3.6: Additive operators, continued.

		"For subtraction, one of the following shall hold:
		o both operands have arithmetic type;
		o both operands are pointers to objects that have compatible type;
		o both operands are pointers to objects that have qualified or
		  unqualified versions of compatible type; or
		o the left operand is a pointer to an object and the right operand
		  has integral type."

		"If both operands have arithmetic type, the usual arithmetic
		conversions are performed on them."

		"The size [of the difference of two pointers] is implementation
		defined, and is type (a signed intgegral type) is ptrdiff_t,
		defined in the &lt;stddef.h&gt; header."
	*/
	case MINUS_TOK:

		if (is_arith_prim(prim1) &amp;&amp; is_arith_prim(prim2)) {
			op_p -&gt; e_ctype = ct_convert2(op_p);
			goto done;
		}
		else if (is_gen_ptr_prim(prim1) &amp;&amp; is_gen_ptr_prim(prim2)) {

			if (t1 -&gt; ttype == NULL || t2 -&gt; ttype == NULL) {

				/* This defines ptrdiff_t as signed long. */
				new_tnode_macro(op_p -&gt; e_ctype, INT_TYPE, LONG_SIZE);
				goto done;
			}
			else if (
				is_ptr_to_void(t1 -&gt; ttype) ||
				is_ptr_to_void(t2 -&gt; ttype)
			) {
				message = "invalid subtraction from void pointer";
				goto message_ret;
			}
			else if (!ct_eq(t1, t2)) {
				message = "pointer types do not match";
				goto message_ret;
			}
			else {
				/* This defines ptrdiff_t as signed long. */
				new_tnode_macro(op_p -&gt; e_ctype, INT_TYPE, LONG_SIZE);
				goto done;
			}
		}
		else if (is_gen_ptr_prim(prim1) &amp;&amp; prim2 == INT_TYPE) {

			if (is_ptr_to_void(t1 -&gt; ttype)) {
				message = "invalid subtraction from void pointer";
				goto message_ret;
			}
			else {
				goto done;
			}
		}
		else {
			goto mismatch_ret;
		}

		fatal(es("fall through '-'"));

	/*
		Section 3.3.7: Bitwise shift operators.

		"Each of the operands shall have integral type."

		"The integral promotions are performed on each of the operands.
		The type of the result is that of the promoted left operand.
		If the value of the right operand is negative or greater than or equal to
		the width in bits of the promoted left operand, the behavior is undefined."

		EKR: 6/3/93:
		The Standard does not agree with the Rationale on this point!

		The Rationale says:

		"The discription of shift operators in K&amp;R suggests that shifting a long
		count should force the left operand to long before being shifted.
		A more intuitive practice, endorsed by the Committee,
		is that the type of the shift count has no bearing on the type of the result."

		"QUIET CHANGE:
		Shifting by a long count no longer coerces the shifted operand."

		EKR: Clearly, the Rationale is correct, and the Standard is wrong.  A botch.
	*/
	case LSHIFT_TOK:
	case RSHIFT_TOK:

		if (prim1 == INT_TYPE &amp;&amp; prim2 == INT_TYPE) {

			/*
				The Standard says to do...
					op_p -&gt; e_ctype = ct_convert2(op_p);
			*/
			op_p -&gt; e_ctype = op_p -&gt; arg1 -&gt; e_ctype;
			goto done;
		}
		else {
			message = "non-integral operand";
			goto message_ret;
		}

	case LSHIFT_ASSN_TOK:
	case RSHIFT_ASSN_TOK:

		if (prim1 == INT_TYPE &amp;&amp; prim2 == INT_TYPE) {

			/*
				The Standard says to do...
					ct_convert2(op_p);
			*/
			op_p -&gt; e_ctype = op_p -&gt; arg1 -&gt; e_ctype;
			goto assign_check;
		}
		else {
			message = "non-numeric shift operand";
			goto message_ret;
		}

	/*
		Section 3.3.8: Relational operators.

		"One of the following shall hold:
		o both operands have arithmetic type;
		o both operands are pointers to compatible object types;
		o both operands are pointers to compatible incomplete types;
		o both operands are pointers ot objects that have qualified; or
		  unqualified versions of compatible types."

		"If both operands have arithmetic type, the usual arithmetic
		conversions are performed on them."

		"The result has type int."
	*/
	case GE_TOK:
	case GT_TOK:
	case LE_TOK:
	case LT_TOK:

		/* The result has type int. */
		new_tnode_macro(op_p -&gt; e_ctype, INT_TYPE, RELOP_SIZE);

		if (is_arith_prim(prim1) &amp;&amp; is_arith_prim(prim2)) {

			/* Make the arguments compatible, but do *not* change the result type. */
			ct_convert2(op_p);
			goto done;
		}
		else if (
			(is_gen_ptr_prim(prim1) || is_su_prim(prim1)) &amp;&amp; ct_eq(t1, t2)) {
			goto done;
		}
		else {
			goto mismatch_ret;
		}

	/*
		Section 3.3.9: Equality operators.

		One of the following shall hold:
		o both operands have arithmetic type;
		o both operands are pointers to compatible types;
		o both operands are pointers to objects that have qualified or
		  unqalified versions of compatible types;
		o one operand is a pointer to an object or an incomplete type and
		  the other is a pointer to void; or
		o one operand is a pointer and the other is a null pointer constant.

		"[These] operators are analogous to the relational operators..."
		(In particular, If both operands have arithmetic type,
		the usual arithmetic conversions are performed on them.)
	*/
	case EQUAL_TOK:
	case NE_TOK:

		/* The type of the result is int. */
		new_tnode_macro(op_p -&gt; e_ctype, INT_TYPE, RELOP_SIZE);

		if (is_arith_prim(prim1) &amp;&amp; is_arith_prim(prim2)) {

			/* Make the arguments compatible, but do *not* change the result type. */
			ct_convert2(op_p);
			goto done;
		}
		else if (ct_eq(t1, t2)) {
			goto done;
		}
		else if (prim1 == POINTER_TYPE) {

			if (
				(prim2 == POINTER_TYPE &amp;&amp; is_ptr_to_void(t2)) ||
				ct_is_null(op_p -&gt; arg2)
			) {
				goto done;
			}
			else {
				goto mismatch_ret;
			}
		}
		else if (prim2 == POINTER_TYPE) {

			if (
				(prim1 == POINTER_TYPE &amp;&amp; is_ptr_to_void(t1)) ||
				ct_is_null(op_p -&gt; arg1)
			) {
				goto done;
			}
			else {
				goto mismatch_ret;
			}
		}
		else {
			goto mismatch_ret;
		}

	/*
		Sections 3.3.10, 3.3.11, 3.3.12: Bitwise operators.

		"Each of the operands shall have integral type."

		"The usual arithmetic conversions are performed on the operands."
	*/
	case AND_TOK:
	case OR_TOK:
	case XOR_TOK:

		if (prim1 == INT_TYPE &amp;&amp; prim2 == INT_TYPE) {
			op_p -&gt; e_ctype = ct_convert2(op_p);
			goto done;
		}
		else {
			message = "non-integral operand";
			goto message_ret;
		}

	case AND_ASSN_TOK:
	case OR_ASSN_TOK:
	case XOR_ASSN_TOK:

		if (prim1 == INT_TYPE &amp;&amp; prim2 == INT_TYPE) {
			/*
				Bug fix: 6/9/93: call ct_cvt_r2l, not ct_convert2.
				Never convert the LHS: that would put the LHS into a temporary reg!
			*/
			op_p = ct_cvt_r2l(op_p);
			goto assign_check;
		}
		else {
			message = "non-integral operand";
			goto message_ret;
		}

	/*
		Sections 3.3.13, 3.3.14: Logical operators.

		"Each of the operands shall have scalar type."
		("Arithmetic types and pointer types are collectively called scalar types")

		"The result has type int."
	*/
	case LAND_TOK:
	case LOR_TOK:

		/* The result has type int. */
		new_tnode_macro(op_p -&gt; e_ctype, INT_TYPE, RELOP_SIZE);

		if (
			(is_arith_prim(prim1) || is_gen_ptr_prim(prim1)) &amp;&amp;
			(is_arith_prim(prim2) || is_gen_ptr_prim(prim2))
		) {
			goto done;
		}
		else {
			message = "Non-scalar operand";
			goto message_ret;
		}

	/*
		Section 3.3.16: Assignment operators.

		(The following apply to *all* assignment operators.)

		"An assignment operator shall have a modifiable lvalue as
		its left operand"

		(This is checked by code at the assign_check label.)

		"The type of an assignment is the type of the left operand
		unless the left operand has qualified type, in which case it
		is the unqualified version of the type of the left operand."
	*/

	/*
		Section 3.3.16.1: Simple assignment.

		One of the following shall hold:
		o the left operand has qualified or unqualified arithmetic type
		  and the right operand has arithmetic type;
		o the left operand has a qualified or unqualified version of a structure
		  or union type compatible with the type of the right;
		o both operands are pointers to qualified or unqualifed versions of
		  compatible types, and the type pointed to by the left has all the
		  qualifiers of the type pointed to by the right;
		o one operand is a pointer to an object or incomplete type and the
		  other is a pointer to a qualified or unqualified version of 'void',
		  and the type pointed to by the left has all the qualifiers of the
		  type pointed to by the right; or
		o the left operater is a pointer and the right is a null pointer constant.

		"...the value of the right operand is converted to the type
		of the assignment expression..."
	*/
	case ASSN_TOK:

		if (is_arith_prim(prim1) &amp;&amp; is_arith_prim(prim2)) {
			op_p = ct_cvt_r2l(op_p);
			goto assign_check;
		}
		else if (prim1 == prim2 &amp;&amp; is_su_prim(prim2)) {
			goto assign_check;
		}
		else if (is_gen_ptr_prim(prim1)) {

			if (
				is_gen_ptr_prim(prim2) &amp;&amp;
				(
					is_ptr_to_void(t1 -&gt; ttype) ||
					is_ptr_to_void(t2 -&gt; ttype) ||
					ct_eq(t1, t2)
				)
			) {
				goto assign_check;
			}
			else if (ct_is_null(op_p -&gt; arg2)) {

				/*
					Bug fix. 3/8/93:
					Convert the int 0 to pointer 0 so the length will be correct.
				*/
				op_p = ct_cvt_r2l(op_p);
				goto assign_check;
			}
			else {
				goto mismatch_ret;
			}
		}
		else {
			goto mismatch_ret;
		}

	case PLUS_ASSN_TOK:
	case MINUS_ASSN_TOK:

		if (is_arith_prim(prim1) &amp;&amp; is_arith_prim(prim2)) {
			/*
				Bug fix: 6/9/93: call ct_cvt_r2l, not ct_convert2.
				Never convert the LHS: that would put the LHS into a temporary reg!
			*/
			op_p = ct_cvt_r2l(op_p);
			goto assign_check;
		}
		else if (prim1 == POINTER_TYPE &amp;&amp; prim2 == INT_TYPE) {
			goto assign_check;
		}
		else {
			goto mismatch_ret;
		}

	/*
		Section 3.3.17: Comma operator.

		"The result has [the right operand's] type and value."
	*/
	case COMMA_TOK:

		/* The type of a , b is the type of b. */
		op_p -&gt; e_ctype = t2;
		goto done;

	default:
		fatal(es("unknown binop"));
	}

	fatal(es("fall out of main switch"));

	/* check assignments */

assign_check:

	if (!ct_is_lval(op_p -&gt; arg1, GIVE_ERROR_MESSAGE)) {
		goto done;
	}
	else if (t_is_const(t1) &amp;&amp; !allow_assn_to_const_flag) {
		error(es("Can not assign into a const object"));
	}
	goto done;

	/* Common exit points. */

mismatch_ret:

	message = "type mismatch";

message_ret:

	error(es(message); es(" '"); etoknum(op_n_type); es("'"));

done:
	TRACEPX(ftag,
		eret(); eenode( (enode *) op_p);
		es(", returned type: "); etnode(op_p -&gt; e_ctype); ecnl());
	return op_p;
}
</t>
<t tx="ekr.20080529093004.655">@ Set type of an expression involving a ternary operator.
@c

void
ct_type3(register op3_enode * op_p)
{
	FTAG("ct_type3");
	register tnode *t1 = NULL;
	register tnode *t2 = NULL;
	register tnode *t3 = NULL;
	register int prim1 = 0;
	register int prim2 = 0;
	register int prim3 = 0;
	TICKB(ftag);

	if (
		op_p == NULL ||
		op_p -&gt; arg1 == NULL ||
		op_p -&gt; arg2 == NULL ||
		op_p -&gt; arg3 == NULL ||
		op_p -&gt; n_type != QUESTION_TOK
	) {
		goto done;
	}

	t1 = op_p -&gt; arg1 -&gt; e_ctype;
	t2 = op_p -&gt; arg2 -&gt; e_ctype;
	t3 = op_p -&gt; arg3 -&gt; e_ctype;

	if (t1 == NULL || t2 == NULL || t3 == NULL) {
		goto done;
	}

	prim1 = t1 -&gt; tprim;
	prim2 = t2 -&gt; tprim;
	prim3 = t3 -&gt; tprim;

	/*
		Section 3.3.15: Conditional operator.

		"The first argument shall have scalar type.

		"One of the following shall hold for the second and third operands:
		o both operands have arithmetic type;
		o both operands have compatible structure or union types;
		o both operands have void type;
		o both operands are pointers to qualified or unqualified versions of
		  compatible types;
		o one operand is a pointer and the other is a null pointer constant; or
		o one operand is a pointer to an object or incomplete type and the
		  other is a pointer to a qualified or unqualified verions of void."

		"If both the second and third operands have arithmetic type,
		the usual arithmetic conversions are performed to bring them to a
		common type and the result has that type.  If both the operands have
		structure or union type, the result has that type.  If both operands have
		void type, the result has void type."

		"If both the second and third operands are pointers or one is a null
		pointer constant and the other is a pointer, the result type is a pointer
		to a type qualified with all the type qualifiers of the types pointed-to
		by both operands.  Furthermore, if both operands are pointers to compatible
		types or differently qualified versions of a compatible type, the result
		has the composite type; if one operand is a null pointer constant, the result
		has the type of the other operand; otherwise one operand is a pointer to void
		or a qualified version of void, in which case the other operand is converted
		to a type pointer to void, and the result has that type."
	*/

	if (!is_arith_prim(prim1) &amp;&amp; !is_gen_ptr_prim(prim1)) {
		error(es("non-scalar argument to '?:'"));
	}
	else if (is_arith_prim(prim2) &amp;&amp; is_arith_prim(prim3)) {
		op_p -&gt; e_ctype = ct_convert3(op_p);
	}
	else if (prim2 == prim3 &amp;&amp; is_su_prim(prim2)) {
		op_p -&gt; e_ctype = t2;
	}
	else if (is_gen_ptr_prim(prim2) &amp;&amp; is_ptr_to_void(t3 -&gt; ttype)) {
		op_p -&gt; e_ctype = t2;
	}
	else if (is_gen_ptr_prim(prim3) &amp;&amp; is_ptr_to_void(t2 -&gt; ttype)) {
		op_p -&gt; e_ctype = t3;
	}
	else if (
		prim2 == POINTER_TYPE &amp;&amp;
			(
				is_gen_ptr_prim(prim3) ||
			 	ct_is_null(op_p -&gt; arg3) ||
			 	ct_eq(t2, t3)
			)
	) {
		op_p -&gt; e_ctype = t2;

		/*	Bug fix: 5/12/93:
			Convert NULL pointers to the actual type of the pointer.
			This conversts a NULL defined as 0 to (t2 *) 0.
		*/
		if (ct_is_null(op_p -&gt; arg3)) {
			op_p -&gt; arg3 -&gt; e_ctype = t2;
		}
	}
	else if (
		prim3 == POINTER_TYPE &amp;&amp;
			(
				is_gen_ptr_prim(prim2) ||
			 	ct_is_null(op_p -&gt; arg2) ||
			 	ct_eq(t2, t3)
			)
	) {
		op_p -&gt; e_ctype = t3;

		/*
			Bug fix: 5/12/93:
			Convert NULL pointers to the actual type of the pointer.
			This conversts a NULL defined as 0 to (t3 *) 0.
		*/
		if (ct_is_null(op_p -&gt; arg2)) {
			op_p -&gt; arg2 -&gt; e_ctype = t3;
		}
	}
	else if (ct_eq(t2, t3)) {
		op_p -&gt; e_ctype = t2;
	}
	else {
		error(es(" '?' and ':' select items of different types"));
	}

done:
	TRACEPX(ftag,
		eenode( (enode *) op_p); ecs();
		etnode(op_p -&gt; e_ctype); ecnl());
}
</t>
<t tx="ekr.20080529093004.656">/*
	CC2 -- Debugging output routines.

	source:  CCdump.c
	started: May 19, 1986
	version:
		June 10, 1994.
			Removed print tables.  These are now defined in CCtokens.h.
			Removed edump_check.
		July 24, 1993.
			Started all tracepoints with - to disable tracine when
			PRINT_EVERYTHING is on in sl_macro.c.
		April 20, 1993.
			Added support for GEN_GLOBAL_ADDRESS.
		April 17, 1993.
			Displacement modes have the form nn(Ax), not #nn(Ax)
		April 2, 1993.
			Added tracing for AUTO inodes.
			Corrected the tracing of structs in etnode.
			(The ttype kludge had not been applied.)
		March 6, 1993.
			Better handling of NULL cnodes.
		February 10, 1993.
			Added support for table_cnode's.
			Added support for a_voffset and a_vprefix fields of var_anodes.
		February 7, 1993.
			esmods made public.
		January 29, 1993.
			Removed eetype.
		November 14, 1992.
			Added tracing for BRACE_ITYPE in einode.
			Changed ecnode to call eanode.
		September 24, 1992.
			Print brief info about types in dumps of casts.
			Added etnode_full().
		September 22, 1992.
			Print type for CAST_TOK in eop1node.
		Septmeber 14, 1992.
			Added cons_indent_flag.
		September 8, 1992.
			Added eline_flag.
		September 3, 1992.
			Increment tab level after cons nodes.
		August 20, 1992.
			Added support for KP_BLOCK to epnode.
			Added edcls.
		July 23, 1992
			Removed trace of NULL_TMOD.
		July 2, 1992
			Removed calls to enl(), ecnl(), etc so code nodes can be
			dumped from inside Sherlock macros.
		May 26, 1992
			Converted from pr.c from CC2.
		January 24, 1992
			Last SPP version.

	The routines in this file all use es and related routines.

	No routine in this file calls e2file, e2echo or e2normal, so the
	output from these routines can easily be redirected by the caller.
*/

&lt;&lt; CCdump #includes &gt;&gt;
&lt;&lt; CCdump declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.657">#include "CC.h"

#include "CCcpp.h"
#include "CCdump.h"
#include "CCgen.h"
#include "CCparser.h"
</t>
<t tx="ekr.20080529093004.658">/*
	Global variables.
*/
bool eline_flag = FALSE;		/* TRUE: print line numbers in eline(). */
bool etnode_brief_flag = TRUE;	/* TRUE: print brief type nodes. */
bool etnode_full_flag = FALSE;	/* TRUE: print full type nodes: over-rides brief. */

/*
	Local variables.
*/
static long	tab_level = 0;				/* Current number of leading tabs. */
static bool cons_indent_flag = FALSE;	/* Allow only one cons indent per &lt;expr&gt;. */

/*
	Internal routines:
*/
static void	estat	(pnode * p);
static void	eline	(pnode * p, long tabs);
static void	etdcls	(tnode * t, char * tag1, char * t2, char * t3);
</t>
<t tx="ekr.20080529093004.659">@ Dump an anode or a label.  Kludge: Although labels are really cnodes, they are printed here because they can be used as arguments to cinodes.
@c

void
eanode(anode * arg)
{
	FTAG("-eanode");

	if (arg == NULL) {
		es("&lt;NULL anode&gt;");
		return;
	}

	STATB(ftag);

	switch(arg -&gt; n_type) {

	case O_CLABEL:			/* compiler label. */

		es("&lt;clab:"); eint(label_ptr(arg) -&gt; c_labnum);
		es("[ref:"); eint(label_ptr(arg) -&gt; c_refcount); es("]&gt;:");
		break;

	case O_ULABEL:			/* User label. */

		es(ulabel_cnode_ptr(arg) -&gt; c_labsym);
		es("[ref:"); eint(ulabel_cnode_ptr(arg) -&gt; c_refcount); es("]:");
		break;

	case ADDRESS_EA:

		#ifdef GEN_GLOBAL_ADDRESS
			es("#");
		#endif

		/* Fall through. */

	case ABSOLUTE_EA:		/* address */
	{
		int kind = var_anode_ptr(arg) -&gt; a_vkind;
		var_anode * vap = var_anode_ptr(arg);

		if (kind == ADDRESS_VKIND) {
			elong(vap -&gt; a_vaddress);
		}
		else if (kind == LIBNAME_VKIND) {
			es("flib@");
		}
		else if (kind == NAME_VKIND) {
			es("&lt;prefix&gt;");
		}
		else {
			ASSERT(kind == XNAME_VKIND);
		}

		/* Print common part of symbolic fields. */
		if (kind != ADDRESS_VKIND) {
			es(vap -&gt; a_vname);
		}
		if (vap -&gt; a_vprefix) {
			es("@");
			eint(vap -&gt; a_vprefix);
		}
		if (vap -&gt; a_voffset) {
			es("+");
			eint(vap -&gt; a_voffset);
		}
		break;
	}

	case AREG_EA:			/* a4 */
	case DREG_EA:			/* d5 */

		es(tok_name(spill_anode_ptr(arg) -&gt; a_sreg));
		break;

	case DISPLACEMENT_EA:	/* word(a6) */

		es("{"); es(spill_anode_ptr(arg) -&gt; a_sname); es("}");
		elong(spill_anode_ptr(arg) -&gt; a_slong);
		es("(");
		es(tok_name(spill_anode_ptr(arg) -&gt; a_sreg));
		es(")");
		break;

	case IMMEDIATE_EA:		/* #data */

		if (const_anode_ptr(arg) -&gt; a_debug) {
			if (const_anode_ptr(arg) -&gt; a_ckind == STRING_CKIND) {
				es("{\"");
				es(const_anode_ptr(arg) -&gt; a_debug);
				es("\"}");
			}
			else {
				es("{");
				es(const_anode_ptr(arg) -&gt; a_debug);
				es("}");
			}
		}

		if (
			const_anode_ptr(arg) -&gt; a_ckind == BLOCK_CKIND ||
			const_anode_ptr(arg) -&gt; a_ckind == FLOAT_CKIND ||
			const_anode_ptr(arg) -&gt; a_ckind == DOUBLE_CKIND ||
			const_anode_ptr(arg) -&gt; a_ckind == LONG_DOUBLE_CKIND ||
			const_anode_ptr(arg) -&gt; a_ckind == STRING_CKIND ||
			const_anode_ptr(arg) -&gt; a_ckind == STRING_REF_CKIND

		) {
			#ifdef GEN_GLOBAL_ADDRESS
				os("#");
			#endif
			eanode(anode_ptr(const_anode_ptr(arg) -&gt; a_label));
		}
		else if (const_anode_ptr(arg) -&gt; a_ckind == LONG_CKIND) {
			es("#");
			elong(const_anode_ptr(arg) -&gt; a_long);
		}
		else {
			fatal(es("unknown CKIND"));
		}
		break;

	case INDIRECT_EA:		/* (a0) */

		es("(");
		es(tok_name(spill_anode_ptr(arg) -&gt; a_sreg));
		es(")");
		break;

	case INDEX_EA:			/* byte(a4,d4) */

		es("{"); es(spill_anode_ptr(arg) -&gt; a_sname); es("}");
		elong(spill_anode_ptr(arg) -&gt; a_slong);
		es("(");
		es(tok_name(spill_anode_ptr(arg) -&gt; a_sreg));
		es(",");
		es(tok_name(spill_anode_ptr(arg) -&gt; a_sxreg));
		es(")");
		break;

	case PC_DISP_EA:		/* word(pc) */

		elong(spill_anode_ptr(arg) -&gt; a_slong);
		es("(pc)");
		break;

	case PC_INDEX_EA:		/* byte(pc,xn) */

		elong(spill_anode_ptr(arg) -&gt; a_slong);
		es("(pc,");
		es(tok_name(spill_anode_ptr(arg) -&gt; a_sxreg));
		es(")");
		break;

	case POST_INC_EA:		/* (a0)+ */

		es("(");
		es(tok_name(spill_anode_ptr(arg) -&gt; a_sreg));
		es(")+");
		break;

	case PRE_DEC_EA:		/* -(a0) */

		es("-(");
		es(tok_name(spill_anode_ptr(arg) -&gt; a_sreg));
		es(")");
		break;

	default:
		es("unknown arg: ");
	}

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.660">@ Output a code node.
@c

void
ecnode(cnode * p)
{
	FTAG("-ecnode");

	if (p == NULL) {
		es("&lt;NULL or FALL_THROUGH cnode&gt;");
		return;
	}

	STATB(ftag);

	switch(p -&gt; n_type) {

	case O_CLABEL:			/* compiler label. */
	case O_ULABEL:			/* User label. */

		/*
			Kludge: Although labels are really cnodes,
			they are handled by eanode because they can
			be used as aguments to cinodes.
		*/
		eanode(anode_ptr(p));
		break;

	case O_LINE_NUMBER:		/* line number node. */
	{
		token * tp = line_ptr(p) -&gt; c_line_ptr;
		int count = line_ptr(p) -&gt; c_line_count + 1;
		long line = line_ptr(p) -&gt; c_line;

		while(count--) {
			next_tok(tp);
			ecnls(2);
			es("line"); epadlong(line++, 4);
			es(": ");
			tp = tok_dump_line2(tp,
				DONT_PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_USER_TOKENS);
			ecnls(2);
		}

		break;
	}

	default:

		if (is_xtok(p -&gt; n_type)) {
			ecinode(cinode_ptr(p));
		}
		else {
			eanode(anode_ptr(p));
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.661">@ Output a code instruction node.
@c

void
ecinode(cinode * cip)
{
	FTAG("-ecinode");
	STATB(ftag);

	es(tok_name(cip -&gt; n_type));

	/* Output the instruction length. */
	switch(cinode_ptr(cip) -&gt; c_length) {
	case 0:	es("    ");	break;
	case 1:	es(".b  ");	break;
	case 2:	es(".w  ");	break;
	case 4:	es(".l  ");	break;
	default:
		es("&lt;bad opcode length:");
		eint(cinode_ptr(cip) -&gt; c_length); es("&gt;");
	}
	etab();

	/* Output the arguments. */
	eanode (cip -&gt; c_arg1);
	if (cip -&gt; c_arg2) {
		es(",");
		eanode (cip -&gt; c_arg2);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.662">@ Dump the code list.
@c

void
ecodelist(register cnode *p)
{
	FTAG("-ecodelist");
	STATB(ftag);

	while(p) {
		ecnode(p); ecnl();
		p = p -&gt; n_next;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.663">@ Print a list of declarations threaded by their n_next field.
@c

void
edcls(snode * sp)
{
	FTAG("-edcls");
	STATB(ftag);

	for ( ; sp; sp = sp -&gt; n_next) {
		eline(pnode_ptr(sp), tab_level);
		es("&lt;dcl&gt;");  esnode(sp);
		if (sp -&gt; vlist) {
			es(" = "); einode(sp -&gt; vlist);
		}
		es(";");
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.664">@ Print an expression. See the file par.h for the definitions of these nodes.
@c

void
eenode(register enode * p)
{
	FTAG("-eenode");

	register int type;
	long old_tab_level = tab_level;

	STATB(ftag);

	if (p == NULL) {
		es("&lt;NULL expr&gt;");
		STATX(ftag);
		return;
	}

	type = p -&gt; n_type;

	ASSERT(type &gt; 0 &amp;&amp; type &lt; BAD_LAST_TOK);

	switch (type) {

	case CONS_TOK:

		es("cons(");
		eenode(cons_ptr(p) -&gt; cons_car);
		ecs();
		if (p -&gt; n_next &amp;&amp; enode_ptr(p -&gt; n_next) -&gt; n_type == CONS_TOK) {
			if (cons_indent_flag == FALSE) {
				tab_level++;
				cons_indent_flag = TRUE;
			}
			eline(NULL, tab_level);
		}
		eenode(p -&gt; n_next);
		es(")");
		break;

	case ID_TOK:

		esnode(var_enode_ptr(p) -&gt; e_var);
		break;

	case FLOAT_TOK:

		ASSERT(p -&gt; e_ctype);
		es("&lt;float"); eint(p -&gt; e_ctype -&gt; tsize); es("&gt;");
		es("{"); es(econst_defstr(p)); es("}");
		// eanode(econst_anode(p));
		break;

	case INT_TOK:

		ASSERT(p -&gt; e_ctype);
		es("&lt;int"); eint(p -&gt; e_ctype -&gt; tsize); es("&gt;");
		if (t_is_unsigned(p -&gt; e_ctype)) {
			eulong(econst_ulong(p));
		}
		else {
			elong(econst_long(p));
		}
		break;

	case STRING_TOK:

		es("&lt;string&gt;");
		if (econst_defstr(p)) {
			es("{"); es(econst_defstr(p)); es("}");
		}
		if (econst_anode(p)) {
			eanode(econst_anode(p));
		}
		break;

	default:

		if (is_unop(type)) {
			eop1node( (op1_enode *) p);
		}
		else if (is_binop(type)) {
			eop2node( (op2_enode *) p);
		}
		else if (type == QUESTION_TOK) {
			eop3node( (op3_enode *) p);
		}
		else {
			ecnl();
			es(ftag); es("&lt;"); etoknum(p -&gt; n_type); es("&gt;");
			es(" does not belong in enode\n");
		}
	}

	/* Restore the level that may have been changed by a cons node. */
	tab_level = old_tab_level;
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.665">@ Print an initializer block.
@c

void
einode(inode * ip)
{
	FTAG("-einode");
	STATB(ftag);

	for ( ; ip; ip = ip -&gt; inext) {

		switch(ip -&gt; itype) {

		case AUTO_ITYPE:
			es("AUTO inode: ");
			es("{icount: "); eint(ip -&gt; icount); ecs();
			es("label: "); eanode(ip -&gt; i_auto);
			es("}");
			break;

		case BRACE_ITYPE:
			es("BRACE inode: ");
			es("{icount: "); eint(ip -&gt; icount); ecs();
			einode(ip -&gt; i_brace);
			es("}");
			break;

		case EXPR_ITYPE:
			es("EXPR inode: "); eenode(ip -&gt; i_expr);
			break;

		default:
			es("&lt;unknown inode!&gt;");
		}

		if (ip -&gt; inext) {
			ecs(); enl();
		}
	}

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.666">@ Print a line number from a pnode.
@c

static long last_eline = -1;

static void
eline(pnode * p, long tabs)
{
	ecnl();
	if (eline_flag == FALSE || p == NULL || p -&gt; p_line == last_eline) {
		epads(" ", 4 + 1);
	}
	else {
		epadlong(p -&gt; p_line, 4);
		es(":");
		last_eline = p -&gt; p_line;
	}
	etabs(tabs+1);
}
</t>
<t tx="ekr.20080529093004.667">@ Print operator nodes.
@c

void
eop1node(op1_enode * op1)
{
	FTAG("-eop1node");
	STATB(ftag);

	ASSERT(op1 -&gt; n_type &gt; 0 &amp;&amp; op1 -&gt; n_type &lt; BAD_LAST_TOK);

	if (op1 -&gt; n_type == CAST_TOK) {

		/* Print brief info about types in dumps of casts. */
		bool save_brief = etnode_brief_flag;
		etnode_brief_flag = TRUE;
			es("&lt;cast to ");
			etnode(op1 -&gt; e_ctype);
			es("&gt;[");
			eenode(op1 -&gt; arg1);
			es("]");
		etnode_brief_flag = save_brief;
	}
	else if (is_unop(op1 -&gt; n_type)) {
		etoknum(op1 -&gt; n_type);
		es("[");
		eenode(op1 -&gt; arg1);
		es("]");
	}
	else {
		ecnl(); es("&lt;unknown unary op: "); etoknum(op1 -&gt; n_type); ecnl();
	}
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.668">void
eop2node(op2_enode * op2)
{
	FTAG("-eop2node");
	STATB(ftag);

	ASSERT(op2 -&gt; n_type &gt; 0 &amp;&amp; op2 -&gt; n_type &lt; BAD_LAST_TOK);

	if (op2 -&gt; n_type == CALL_TOK) {
		es("CALL[");
		eenode(op2 -&gt; arg1);
		es(",[");
		eenode(op2 -&gt; arg2);
		es("]]");
	}
	else if (is_binop(op2 -&gt; n_type)) {
		etoknum(op2 -&gt; n_type);
		es("[");
		eenode(op2 -&gt; arg1);
		ecs();
		eenode(op2 -&gt; arg2);
		es("]");
	}
	else {
		ecnl(); es("&lt;unknown binary op: ");
		etoknum(op2 -&gt; n_type); ecnl();
	}
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.669">void
eop3node(op3_enode * op3)
{
	FTAG("-eop3node");
	STATB(ftag);

	if (op3 -&gt; n_type == QUESTION_TOK) {
		es("?:[");
		eenode(op3 -&gt; arg1);
		ecs();
		eenode(op3 -&gt; arg2);
		ecs();
		eenode(op3 -&gt; arg3);
		es("]");
	}
	else {
		ecnl(); es("&lt;unknown ternary op: ");
		etoknum(op3 -&gt; n_type); ecnl();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.670">@ Print a list of parse nodes.  See the file par.h for the definitions of these nodes.
@c

void
epnode(pnode * p)
{
	FTAG("-epnode");
	STATB(ftag);

	if (p == NULL) {
		es("&lt;NULL parse tree&gt;\n");
		STATX(ftag);
		return;
	}

	ASSERT(p -&gt; n_type &gt; 0 &amp;&amp; p -&gt; n_type &lt; BAD_LAST_TOK);

	do {

		switch (p -&gt; n_type) {

		case EXPRESSION_TOK:

			eline(p, tab_level);
			es("&lt;expr&gt; ");
			cons_indent_flag = FALSE;
			eenode( expr_ptr(p) -&gt; expr); es(";");
			break;

		case K_BREAK:

			eline(p, tab_level);
			es("break;\n");
			break;

		case K_CASE:

			eline(p, tab_level-1);
			es("case ");
			elong(case_ptr(p) -&gt; case_constant);
			es(":\n");
			break;

		case K_CONTINUE:

			eline(p, tab_level);
			es("continue;\n");
			break;

		case K_DEFAULT:

			eline(p, tab_level-1);
			es("default:\n\n");
			break;

		case K_DO:

			eline(p, tab_level);
			es("do ");
			estat(do_ptr(p) -&gt; do_body);
			es(" while (");
			eenode(do_ptr(p) -&gt; do_bool);
			es(")\n");
			break;

		case K_FOR:

			eline(p, tab_level);
			es("for (");
			eenode(for_ptr(p) -&gt; for_list1);
			es("; ");
			eenode(for_ptr(p) -&gt; for_bool);
			es("; ");
			eenode(for_ptr(p) -&gt; for_list2);
			es(") ");
			estat(for_ptr(p) -&gt; for_body);
			break;

		case K_GOTO:

			eline(p, tab_level);
			es("goto ");
			es(goto_ptr(p) -&gt; goto_label -&gt; c_labsym);  es(";");
			break;

		case K_IF:

			eline(p, tab_level);
			es("if (");
			eenode(if_ptr(p) -&gt; if_bool);
			es(") ");
			estat(if_ptr(p) -&gt; if_then_body);
			if (if_ptr(p) -&gt; if_else_body) {
				eline(NULL, tab_level);
				es("else ");
				estat(if_ptr(p) -&gt; if_else_body);
			}
			break;

		case K_RETURN:

			eline(p, tab_level);
			es("return");
			if (return_ptr(p) -&gt; return_val) {
				es(" (");
				eenode(return_ptr(p) -&gt; return_val);
				es(");");
			}
			break;

		case K_SWITCH:

			eline(p, tab_level);
			es("switch(");
			eenode(switch_ptr(p) -&gt; switch_val);
			es(") ");
			estat(switch_ptr(p) -&gt; switch_body);
			break;

		case K_WHILE:

			eline(p, tab_level);
			es("while (");
			eenode(while_ptr(p) -&gt; while_bool);
			es(")");
			estat(while_ptr(p) -&gt; while_body);
			break;

		case ULABEL_TOK:

			eline(p, tab_level-1);
			es(ulabel_ptr(p) -&gt; ulab_label -&gt; c_labsym);
			es(":\n");
			break;

		case KP_BLOCK:

			eline(p, tab_level);
			es("{&lt;block2&gt;\n"); tab_level++;
			if (block_ptr(p) -&gt; block_dcls) {
				edcls(block_ptr(p) -&gt; block_dcls);
			}
			if (block_ptr(p) -&gt; block_body) {
				epnode(block_ptr(p) -&gt; block_body);
			}
			eline(NULL, --tab_level); es("}\n");
			break;

		default:

			eline(NULL, tab_level);
			es("&lt;INAPPROPRIATE PNODE:"); elong(p -&gt; n_type);
			es(" = "); etoknum(p -&gt; n_type); es("&gt;\n");
			break;
		}

	} while ( (p = p -&gt; n_next) != NULL);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.671">@ Print a statement list enclosed in curly braces.
@c

static void
estat(pnode * p)
{
	SL_DISABLE();

	if (p &amp;&amp; p -&gt; n_type == KP_BLOCK) {
		es("{&lt;block&gt;\n"); tab_level++;
		if (block_ptr(p) -&gt; block_dcls) {
			edcls(block_ptr(p) -&gt; block_dcls);
		}
		if (block_ptr(p) -&gt; block_body) {
			epnode(block_ptr(p) -&gt; block_body);
		}
		eline(NULL, --tab_level); es("}\n");
	}
	else {
		es("{\n"); tab_level++;
		if (p != NULL) {
			epnode(p);
		}
		eline(NULL, --tab_level); es("}\n");
	}
}
</t>
<t tx="ekr.20080529093004.672">@ Print the smods field of a symbol node.
@c

#define print_macro(a, b)\
if (a) {\
	if (flag) {\
		eblank();\
	}\
	es(b);\
	flag = TRUE;\
}

void
esmods(register snode * s_p)
{
FTAG("-esmods");
register bool flag = FALSE;
STATB(ftag);

if (s_p &amp;&amp; s_p -&gt; smods) {

	es("smods{");

	print_macro(s_is_global(s_p),	 "global");

	/* We expect only one of the following to be in effect. */
	print_macro(s_is_auto(s_p),     "auto");
	print_macro(s_is_extern(s_p),   "extern");
	print_macro(s_is_formal(s_p),   "formal");
	print_macro(s_is_static(s_p),   "static");
	print_macro(s_is_typedef(s_p),  "typedef");

	/* Only one of the following will be in effect. */
	print_macro(s_is_array(s_p),	 "array");
	print_macro(s_is_bit_field(s_p), "bit_field");
	print_macro(s_is_code(s_p),		 "code");
	print_macro(s_is_su_elem(s_p),	 "su_elem");
	print_macro(s_is_register(s_p),  "register");

	es("}");
}

STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.673">@ Print a symbol node.
@c

void
esnode(snode * sp)
{
	FTAG("-esnode");
	static bool recursive_print_flag = TRUE;
	STATB(ftag);

	if (sp == NULL) {
		es("&lt;NULL&gt;");
		STATX(ftag);
		return;
	}

	if (sp -&gt; spell) {
		es(sp -&gt; spell -&gt; spell_name);
	}
	else {
		es("&lt;no name&gt;");
	}

	TRACEN("-esnode_brief", goto done;);

	etoknum(sp -&gt; n_type);
	es("o:"); elong(sp -&gt; offset);
	eblank(); esmods(sp);
	eblank(); etnode(sp -&gt; ctype);

    if (recursive_print_flag &amp;&amp;
    		(
    			sp -&gt; n_type == KP_ENUM_TAG ||
    		 	sp -&gt; n_type == KP_STRUCT_TAG ||
    		 	sp -&gt; n_type == KP_UNION_TAG
    		)
    ) {
    	snode * sp2;

		/* Print the snodes recursively and inhibit further recursion. */
		recursive_print_flag = FALSE;
    	for (sp2 = sp -&gt; dcls; sp2; sp2 = sp2 -&gt; n_next) {
    		eline(NULL, tab_level); es("&lt;field&gt;");
    		esnode(sp2);
    	}
    	recursive_print_flag = TRUE;
    }

done:
    STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.674">@ Print a list of declarations from a struct, union or enum. The list is parenthesized, preceded by tag1 and followed by tag2.
@c

static void
etdcls(tnode * t, char * tag1, char * tag2, char * tag3)
{
	FTAG("-etdcls");
	register snode * sp = NULL;
	STATB(ftag);

	if (t &amp;&amp; t -&gt; tdcls) {

		es(tag1); es(" (");
		tab_level++;

		for (sp = t -&gt; tdcls; sp; sp = sp -&gt; n_next) {
			eline(NULL, tab_level);
			es(tag3); esnode(sp);
		}
		tab_level--;
		es(") "); es(tag2); eblank();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.675">@ Print a type node.
@c

void
etnode(register tnode *t)
{
	FTAG("-etnode");

	if (t == NULL) {
		es("&lt;NULL&gt;");
		return;
	}

	STATB(ftag);

	TRACEN("etnode_full", etnode_full_flag = TRUE);

	for ( ; t; t = t -&gt; ttype) {

		/* Print storage modifiers. */
		if (t_is_const(t)) {
			es("const ");
		}
		if (t_is_volatile(t)) {
			es("volatile ");
		}

		switch (t -&gt; tprim) {

		case ARRAY_TYPE:

			es("array (sz: ");
			eint(t -&gt; tsize);
			es(") [");
			elong(t -&gt; tdim);
			es("] of ");
			break;

		case CAST_TYPE:

			es("cast to ");
			break;

		case DOTS3_TYPE:

			es("...");
			goto done;

		case FLOAT_TYPE:

			/* Possible double or long double. */
			if (t_is_long_double(t)) {
				es("long double");
			}
			else if (t_is_double(t)) {
				es("double");
			}
			else {
				es("float");
			}
			break;

		case FUNCTION_TYPE:

			etdcls(t, "function", "returning ", "&lt;formal&gt;");
			break;

		case INT_TYPE:

			/* Possible enum or char or long int. */
			if (t_is_enum(t)) {
				es("enum ");
				break;
			}

			if (t_is_unsigned(t)) {
				es("unsigned ");
			}

			es("int"); elong(t -&gt; tsize);
			break;

		case NULL_TYPE:

			es("NULL_TYPE type");
			goto done;

		case POINTER_TYPE:

			es("pointer to ");
			break;

		case UNION_TYPE:
		case STRUCT_TYPE:

			es("struct");
			if (t -&gt; ttype &amp;&amp; snode_ptr(t -&gt; ttype) -&gt; spell &amp;&amp;
				snode_ptr(t -&gt; ttype) -&gt; spell -&gt; spell_name
			) {
				eblank(); es(snode_ptr(t -&gt; ttype) -&gt; spell -&gt; spell_name);
			}
			es(" sz: "); elong(t -&gt; tsize);

			TRACEN("brief_struct", goto done;);

			if (!etnode_brief_flag &amp;&amp; snode_ptr(t -&gt; ttype)) {

				/* 4/2/93: the ttype field now points to the parent. */
				etnode_brief_flag = TRUE;
				edcls(snode_ptr(t -&gt; ttype));
				etnode_brief_flag = FALSE;
			}
			goto done;

		case VOID_TYPE:

			es("void");
			break;
			
		case KP_STRUCT_TAG:
		case KP_UNION_TAG:
		case KP_ENUM_TAG:
			es(tok_name(t -&gt; tprim));
			break;

		default:

			es("etnode: unknown type "); eint(t -&gt; tprim);
			goto done;
		}
	}

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.676">void
etnode_full(tnode *t)
{
	etnode_full_flag = TRUE;
	etnode(t);
}
</t>
<t tx="ekr.20080529093004.677">@ Print a token, given a *pointer* to it.
@c

void
etok(token * tp)
{
	tok_dump1(tp, DONT_PRINT_HIDDEN_TOKS);
}
</t>
<t tx="ekr.20080529093004.678">@ Print a token, given a token number.
@c

void
etoknum(token tok)
{
	if (tok &lt; 0 || tok &gt; BAD_LAST_TOK) {
		es("&lt;out of range: "); eint(tok); es("&gt;");
	}
	else {
		es(tok_name(tok));
	}
}
</t>
<t tx="ekr.20080529093004.679">@ Print a type.
@c

void
ettype(int t)
{
	if (t &lt; 0 || t &gt; BAD_LAST_TYPE) {
		es("&lt;out of range: "); eint(t); es("&gt;");
	}
	else {
		es(tok_name(t));
	}
}
</t>
<t tx="ekr.20080529093004.680">/*
	CC2: Constant folding routines.

	source:  CCfold.c
	started: November 2, 1985
	version:
		September 4, 1994.
			Bug fix: fold_float_to_int *must* allocate a new const_enode because
			the target enode may not be big enough.
		September 3, 1994.
			Added fold_float_to_float.
			Added ep arg to fold_new_constant so that the
			proper size of anodes can be created.
		September 2, 1994.
			Added better tracing of fold, fold1 and fold2.
		August 31, 1994.
			Added fold_new_constant.
		August 30, 1994.
			Added fold_float_to_int, fold_int_to_float and fold_negate_float.
			Added fold_float2.
		November 2, 1993.
			Change fold1 and fold2 to handle casts and floating constants.
		June 15, 1993.
			The result of relops is short, not int.
		May 11, 1993.
			Not being able to fold a unary op (like * and CALL) is not a compiler error.
		March 4, 1993.
			Bug fix: do not fold casts that convert INT_TYPE's to FLOAT_TYPES.
		February 23, 1993.
			Allow NULL types, which may arise from user errors.
			This produced changes throughout the code.
		January 30, 1993.
			Printed copy sent to Tuple.
*/
&lt;&lt; CCfold #includes &gt;&gt;
&lt;&lt; CCfold declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.681">#include "CC.h"

#include "CCdump.h"
#include "CCgen.h"
#include "CCmem.h"
#include "CCparser.h"
</t>
<t tx="ekr.20080529093004.682">/*
	Prototypes of routines local to this file.
*/
static enode * fold1 				(enode * ep);
static enode * fold2 				(enode * ep);
static enode * fold_float2 			(enode * ep);
static enode * fold_float_to_int	(enode * result_ep, enode * arg_p);
static enode * fold_float_to_float	(enode * result_ep, enode * arg_p);
static enode * fold_int_to_float	(enode * result_ep, enode * arg_p);
static enode * fold_negate_float	(enode * ep);
static enode * fold_new_constant	(char * def_string, enode * result_ep);
</t>
<t tx="ekr.20080529093004.683">@ Fold an integer expression. Return the resulting expression.  By the way, this routine is called only from inside the expression parser, so it is perfectly valid to modify the original ep tree. That is, the output of this routine defines the parse tree and nothing uses the parse tree until after this routine is finished.
@c

enode *
fold(register enode * ep)
{
	FTAG("fold");
	enode * result = ep;
	TRACEPB(ftag, eenode(ep); ecnl());

	if(is_unop(ep -&gt; n_type)) {
		result = fold1(ep);
	}
	else if (is_binop(ep -&gt; n_type)) {
		result = fold2(ep);
	}

	TRACEPX(ftag,
		if (ep != result) {
			eenode(ep);
		}
		enl(); eret(); eenode(result); ecnls(2);
	);
	return result;
}
</t>
<t tx="ekr.20080529093004.684">@ Fold integer expressions involving a unary operator. Return the resulting expression.  This may be routine is called to retype constants such as ((void *) 0). The result is a const_enode of the appropriate type.
@c

static enode *
fold1(register enode * ep)
{
	FTAG("fold1");
	register enode *arg_p = NULL;
	register enode *result = ep;
	TRACEPB(ftag, eenode(ep); ecnl());

	if (!is_unop(ep -&gt; n_type) || ep -&gt; e_ctype == NULL) {
		goto done;
	}

	/* Fold the operand first. */
	arg_p = fold(op1_ptr(ep) -&gt; arg1);

	/* Only constant integers or floats can be folded. */
	if (
		arg_p == NULL ||
		(arg_p -&gt; n_type != INT_TOK &amp;&amp; arg_p -&gt; n_type != FLOAT_TOK)
	) {
		goto done;
	}

	/* Assume the result will be arg_p */
	result = arg_p;

	switch(ep -&gt; n_type) {

	case CAST_TOK:
		
		switch (ep -&gt; e_ctype -&gt; tprim) {
		
		case VOID_TYPE:

			/* Do not elimiate casts to void! */
			result = ep;
			goto done;
			
		case INT_TYPE:
		
			/* A cast from one int type to another.  Just change the size.  */
			if (arg_p -&gt; n_type == INT_TOK) {
				result = arg_p;
				result -&gt; e_ctype = ep -&gt; e_ctype;
			}
			else {
				ASSERT(arg_p -&gt; n_type == FLOAT_TOK);
				result = fold_float_to_int(ep, arg_p);
			}
			goto done;
		
		case FLOAT_TYPE:
		
			/* A cast to a float.  */
			if (arg_p -&gt; n_type == INT_TOK) {
				result = fold_int_to_float(ep, arg_p);
			}
			else {
				ASSERT(arg_p -&gt; n_type == FLOAT_TOK);
				result = fold_float_to_float(ep, arg_p);
			}
			goto done;

		case POINTER_TYPE:
		
			/* A cast to a pointer.  */
			if (arg_p -&gt; n_type == INT_TOK) {

				/* Change the type to return an integer constant with a pointer type. */
				result = arg_p;
				result -&gt; e_ctype = ep -&gt; e_ctype;
			}
			else {
				/* Do not allow this cast. */
				ASSERT(arg_p -&gt; n_type == FLOAT_TOK);
				result = ep;
			}
			goto done;
		
		default:
			/* No other casts can be folded, and they are probably errors. */
			result = ep;
			goto done;
		}
		
	case NOT_TOK:
	
		if (arg_p -&gt; n_type == INT_TOK) {

			econst_long(arg_p) = ! econst_long(arg_p);
	
			/*
				The result is a short int (not long or char)
				All we have to do is clear the tmod field since the constant is
				already an INT_TYPE.
			*/
			ASSERT(arg_p -&gt; e_ctype &amp;&amp; arg_p -&gt; e_ctype -&gt; tprim == INT_TYPE);
			t_set_short(arg_p -&gt; e_ctype);
		}
		else {
		
			/* The ! operator does not apply to floats. */
			ASSERT(arg_p -&gt; n_type == FLOAT_TOK);
			result = ep;
		}
		goto done;

	case TILDE_TOK:
	
		if (arg_p -&gt; n_type == INT_TOK) {
			econst_long(arg_p) = ~ econst_long(arg_p);
		}
		else {

			/* The ~ operator does not apply to floats. */
			ASSERT(arg_p -&gt; n_type == FLOAT_TOK);
			result = ep;
		}
		goto done;

	case UMINUS_TOK:

		if (arg_p -&gt; n_type == INT_TOK) {

			if (t_is_unsigned(const_enode_ptr(arg_p) -&gt; e_ctype)) {
				help(es("negation of unsigned constant; result still unsigned"));
			}
			econst_long(arg_p) = - econst_long(arg_p);
		}
		else {
			result = fold_negate_float(arg_p);
		}
		goto done;

	case UPLUS_TOK:

		goto done;

	default:

		/*
			No folding is possible after all.
			5/11/93: This is *not* a compiler error!
		*/
		result = ep;
		goto done;
	}

done:
	TRACEPX(ftag,
		enl(); eret(); eenode(result); ecs();
		etnode(result -&gt; e_ctype); ecnls(2));
	return result;
}
</t>
<t tx="ekr.20080529093004.685">@ Fold an integer expression involving a binary operator. Only arithmetic and relational operators are folded at present.  Section 3.4: Constant Expressions.  "The semantic rules for the evaluation of a constant expression are the same as for nonconstant expressions. Thus, in the following initialization,  static int i = 2 || 1 / 0;  the expression is a valid integral constant expression with value one."
@c

static enode *
fold2(enode * ep)
{
	FTAG("fold2");

	union {
		long sval;
		ulong uval;
	} value, val1, val2;

	register int op = ep -&gt; n_type;
	register enode *ep1 = NULL;
	register enode *ep2 = NULL;
	enode * result = ep;

	TRACEPB(ftag, eenode(ep); ecnl());

	/* A NULL ep -&gt; e_ctype indicates a problem caught by ct_type2. */
	if (!is_binop(op) || ep -&gt; e_ctype == NULL) {
		goto done;
	}

	/* Fold the operands first and modify the original operation. */
	op2_ptr(ep) -&gt; arg1 = ep1 = fold(op2_ptr(ep) -&gt; arg1);
	op2_ptr(ep) -&gt; arg2 = ep2 = fold(op2_ptr(ep) -&gt; arg2);

	if (ep1 == NULL || ep2 == NULL) {
		goto done;
	}
	
	/* Handle floating arguments separately. */
	if (ep1 -&gt; n_type == FLOAT_TOK || ep2 -&gt; n_type == FLOAT_TOK) {
		result = fold_float2(ep);
		goto done;
	}

	/* Identities that require only ep1 be a constant 0... */
	if (ep1 -&gt; n_type == INT_TOK &amp;&amp; econst_long(ep1) == 0) {

		if (
			op == PLUS_TOK ||		/* 0 +  x == x */
			op == PLUS_ASSN_TOK		/* 0 += x == x */
		) {
			goto return_ep2;
		}
		else if (
			op == STAR_TOK ||		/* 0 *  x == 0 */
			op == STAR_ASSN_TOK		/* 0 *= x == 0 */
		) {
			goto return_ep1;
		}
		else if (
			op == DIV_TOK ||		/* 0 /  x == 0 (x not zero) */
			op == DIV_ASSN_TOK ||	/* 0 /= x == 0 (x not zero) */
			op == MOD_TOK ||		/* 0 %  x == 0 (x not zero) */
			op == MOD_ASSN_TOK		/* 0 %= x == 0 (x not zero) */
		) {
			if (ep2 -&gt; n_type == INT_TOK &amp;&amp; econst_long(ep2) == 0) {
				error(es("division by zero"));
				goto done;
			}
			else {
				goto return_ep1;
			}
		}
	}

	/* We get here only if none of the identities above do apply. */

	/* Identities that require only ep2 be a constant 0... */
	if (ep2 -&gt; n_type == INT_TOK &amp;&amp; econst_long(ep2) == 0) {

		if (
			op == MINUS_TOK ||			/* x -  0 == x */
			op == MINUS_ASSN_TOK ||		/* x -= 0 == x */
			op == PLUS_TOK ||			/* x +  0 == x */
			op == PLUS_ASSN_TOK			/* x += 0 == x */
		) {
			goto return_ep1;
		}
		else if (
			op == STAR_TOK ||			/* x * 0  == 0 */
			op == STAR_ASSN_TOK			/* x *= 0 == 0 */
		) {
			goto return_ep2;
		}
		else if (
			op == DIV_TOK ||
			op == DIV_ASSN_TOK ||
			op == MOD_TOK ||
			op == MOD_ASSN_TOK
		) {
			error(es("division by zero"));
			goto done;
		}
	}

	/* We get here only if none of the identities above do apply. */

	/* Identities that require only ep2 be a constant 1... */
	if (ep2 -&gt; n_type == INT_TOK &amp;&amp; econst_long(ep2) == 1) {

		if (
			op == DIV_TOK ||		/* x / 1  == x */
			op == DIV_ASSN_TOK		/* x /= 1 == x */
		) {
			goto return_ep1;
		}
	}

	/*
		We get here only if none of the identities above do apply.
		Both operands must now be a constant to do any folding.

		The correct type of the result is *already* ep -&gt; ctype
		because ct_type2 has already been called.
	*/
	if (
		ep1 -&gt; n_type != INT_TOK || ep2 -&gt; n_type != INT_TOK ||
		ep1 -&gt; e_ctype == NULL || ep2 -&gt; e_ctype == NULL
	) {
		goto done;
	}

	TRACEPN(ftag, es("folding two integer constants\n"));

	if (op == COMMA_TOK) {
		warning(es("constant , constant"));
		goto return_ep2;
	}

	/* The val1 union eliminates casts. */
	val1.sval = econst_long(ep1);
	val2.sval = econst_long(ep2);

	if (t_is_unsigned(ep -&gt; e_ctype)) {

		switch (op) {

		/* 6 relational operators. */

		case GE_TOK:	value.uval = (val1.uval &gt;= val2.uval);	goto fold2;
		case GT_TOK:	value.uval = (val1.uval &gt;  val2.uval);	goto fold2;
		case LE_TOK:	value.uval = (val1.uval &lt;= val2.uval);	goto fold2;
		case LT_TOK:	value.uval = (val1.uval &lt;  val2.uval);	goto fold2;
		case EQUAL_TOK:	value.uval = (val1.uval == val2.uval);	goto fold2;
		case NE_TOK:	value.uval = (val1.uval != val2.uval);	goto fold2;

		/* 10 arithmetic operators. */

		case LSHIFT_TOK: value.uval = (val1.uval &lt;&lt; val2.uval);	goto fold2;
		case RSHIFT_TOK: value.uval = (val1.uval &gt;&gt; val2.uval);	goto fold2;
		case AND_TOK:	 value.uval = (val1.uval &amp;  val2.uval);	goto fold2;
		case OR_TOK:	 value.uval = (val1.uval |  val2.uval);	goto fold2;
		case XOR_TOK:	 value.uval = (val1.uval ^  val2.uval);	goto fold2;
		case PLUS_TOK:	 value.uval = (val1.uval +  val2.uval);	goto fold2;
		case MINUS_TOK:	 value.uval = (val1.uval -  val2.uval);	goto fold2;
		case STAR_TOK:	 value.uval = (val1.uval *  val2.uval);	goto fold2;

		case DIV_TOK:

			/* Division by zero will be caught above. */
			ASSERT(value.uval != 0);
			value.uval = val1.uval / val2.uval;
			goto fold2;

		case MOD_TOK:

			/* Division by zero will be caught above. */
			ASSERT(value.uval != 0);
			value.uval = val1.uval % val2.uval;
			goto fold2;

		default:
			goto done;
		}
	}
	else {

		switch (op) {

		/* 6 relational operators. */

		case GE_TOK:	 value.sval = (val1.sval &gt;= val2.sval);	goto fold2;
		case GT_TOK:	 value.sval = (val1.sval &gt;  val2.sval);	goto fold2;
		case LE_TOK:	 value.sval = (val1.sval &lt;= val2.sval);	goto fold2;
		case LT_TOK:	 value.sval = (val1.sval &lt;  val2.sval);	goto fold2;
		case EQUAL_TOK:	 value.sval = (val1.sval == val2.sval);	goto fold2;
		case NE_TOK:	 value.sval = (val1.sval != val2.sval);	goto fold2;

		/* 10 arithmetic operators. */

		case LSHIFT_TOK: value.sval = (val1.sval &lt;&lt; val2.sval);	goto fold2;
		case RSHIFT_TOK: value.sval = (val1.sval &gt;&gt; val2.sval);	goto fold2;
		case AND_TOK:	 value.sval = (val1.sval &amp;  val2.sval);	goto fold2;
		case OR_TOK:	 value.sval = (val1.sval |  val2.sval);	goto fold2;
		case XOR_TOK:	 value.sval = (val1.sval ^  val2.sval);	goto fold2;
		case PLUS_TOK:	 value.sval = (val1.sval +  val2.sval);	goto fold2;
		case MINUS_TOK:	 value.sval = (val1.sval -  val2.sval);	goto fold2;
		case STAR_TOK:	 value.sval = (val1.sval *  val2.sval);	goto fold2;

		case DIV_TOK:

			/* Division by zero will be caught by the identities above. */
			ASSERT(value.uval != 0);
			value.sval = val1.sval / val2.sval;
			goto fold2;

		case MOD_TOK:

			/* Division by zero will be caught by the identities above. */
			ASSERT(value.uval != 0);
			value.sval = val1.sval % val2.sval;
			goto fold2;

		default:
			goto done;
		}
	}

	/*
		At this point a fold between 2 constants has occured.
		value.sval contains the correct result of the fold.
		Put the new value in ep1 and set the type depending on the *value* of the result.
	*/

fold2:

	/*
		The type of the folded constant depends on its value.
		Use the smallest possible type here.
		If needed, it will be cast to a larger size later.
	*/
	{
		tnode * t = ep1 -&gt; e_ctype;
		ASSERT(t);

		if (t_is_unsigned(ep -&gt; e_ctype)) {
			t_set_unsigned(t);
			t -&gt; tsize = c_ulong2mlen(value.uval);
			econst_long(ep1) = value.uval;
		}
		else {
			t -&gt; tsize = c_long2mlen(value.sval);
			econst_long(ep1) = value.sval;
		}

		/* Bug fix: 6/3/93: use the new t. */
		result = ep1;
		result -&gt; e_ctype = t;
		goto done;
	}

	/*
		Common exit points.
		
		return_ep1 and return_ep2 are used when one operand *replaces*
		the original expression.
		We set the folded bit to inhibit warnings about
		"possibly useless outer expressions."
	*/

return_ep1:
	e_set_folded(ep1);
	result = ep1;
	result -&gt; e_ctype = ep -&gt; e_ctype;
	goto done;

return_ep2:
	e_set_folded(ep2);
	result = ep2;
	result -&gt; e_ctype = ep -&gt; e_ctype;
	goto done;

done:
	TRACEPX(ftag, enl(); eret();
		eenode(result); ecs(); etnode(result -&gt; e_ctype); enl());
	return result;
}
</t>
<t tx="ekr.20080529093004.686">@ Fold a floating expression involving a binary operator and one or two floating constants.  Both subexpressions of the binary operator have already been folded.
@c

static enode *
fold_float2(enode * ep)
{
	FTAG("fold_float2");
	
		register int op = ep -&gt; n_type;
		enode * result = ep;
		enode * ep1 = op2_ptr(ep) -&gt; arg1;
		enode * ep2 = op2_ptr(ep) -&gt; arg2;

		double val1 = 0.0;
		double val2 = 0.0;
		double val = 0.0;
		bool ival = 0;

	TRACEPB(ftag, eenode(ep); ecnl());
	
	ASSERT(ep &amp;&amp; ep1 &amp;&amp; ep2);
	ASSERT(is_binop(op));
	ASSERT(ep -&gt; e_ctype);
	
	/* Only ints and/or floats can be folded. */
	if (ep1 -&gt; n_type != FLOAT_TOK &amp;&amp; ep1 -&gt; n_type != INT_TOK) {
		goto done;
	}
	if (ep2 -&gt; n_type != FLOAT_TOK &amp;&amp; ep2 -&gt; n_type != INT_TOK) {
		goto done;
	}
	
	/* Convert ints to floats and modify the original operator. */
	if (ep1 -&gt; n_type == INT_TOK) {
		op2_ptr(ep) -&gt; arg1 = ep1 = fold_int_to_float(ep, ep1);
	}
	if (ep2 -&gt; n_type == INT_TOK) {
		op2_ptr(ep) -&gt; arg1 = ep2 = fold_int_to_float(ep, ep2);
	}
	
	ASSERT(ep1 -&gt; n_type == FLOAT_TOK &amp;&amp; ep2 -&gt; n_type == FLOAT_TOK);
	
	/* Get the value of each operand. */
	val1 = eval_fstring(econst_defstr(ep1));
	val2 = eval_fstring(econst_defstr(ep2));
	
	switch (op) {
	
		/* 4 floating arithmetic operators. */
	
		case PLUS_TOK:	val = (val1 + val2);	goto return_float;
		case MINUS_TOK:	val = (val1 - val2);	goto return_float;
		case STAR_TOK:	val = (val1 * val2);	goto return_float;

		case DIV_TOK:	val = (val2?(val1/val2):0);	goto return_float;

		/* 6 floating relational operators. */
	
		case GE_TOK:	ival = (val1 &gt;= val2);	goto return_int;
		case GT_TOK:	ival = (val1 &gt;  val2);	goto return_int;
		case LE_TOK:	ival = (val1 &lt;= val2);	goto return_int;
		case LT_TOK:	ival = (val1 &lt;  val2);	goto return_int;
		case EQUAL_TOK:	ival = (val1 == val2);	goto return_int;
		case NE_TOK:	ival = (val1 != val2);	goto return_int;
	
		default: goto done;
	}
	
	/* The result of the operation is an int. */

return_int:
	new_enode_macro(result, sizeof(const_enode), INT_TOK);
	econst_long(result) = ival;
	e_set_folded(result);
	result -&gt; e_ctype = ep -&gt; e_ctype;
	goto done;

	/* The result of the operation is a float. */
	
return_float:
	
	
	/*
		Create a defining string for the float.
		Bug fix 1/12/95: some floats can have *very* long defining strings.
	*/
	{
		char temp_def_string[400];
		cvt_double(temp_def_string, 400, val);
		result = fold_new_constant(temp_def_string, ep);
	}
	goto done;

done:
	TRACEPX(ftag, enl(); eret();
		eenode(result); ecs(); etnode(result -&gt; e_ctype); ecnls(2));
	return result;
}
</t>
<t tx="ekr.20080529093004.687">@ Convert a floating constant node to an integer constant node. The conversion of value must be as accurate as possible.
@c

static enode *
fold_float_to_int(enode * target_p, enode * arg_p)
{
	FTAG("fold_float_to_int");
	enode * result_p = NULL;
	TRACEPB(ftag,
		eenode(result_p); ecs(); eenode(arg_p); ecnl());
	ASSERT(
		target_p &amp;&amp; target_p -&gt; e_ctype &amp;&amp; target_p -&gt; e_ctype -&gt; tprim == INT_TYPE &amp;&amp;
		arg_p -&gt; n_type == FLOAT_TOK);
	
	new_enode_macro(result_p, sizeof(const_enode), INT_TOK);
	result_p -&gt; e_ctype = target_p -&gt; e_ctype;
	econst_long(result_p) = eval_fstring(econst_defstr(arg_p));

	TRACEPX(ftag, enl(); eret(); eenode(result_p); ecnls(2));
	return result_p;
}
</t>
<t tx="ekr.20080529093004.688">@ Convert one floating constant to another. We *must* generate a new anode to describe the new constant.
@c

static enode *
fold_float_to_float	(enode * result_ep, enode * arg_p)
{
	FTAG("fold_float_to_float");
	enode * result = NULL;
	STATB(ftag);
	result = fold_new_constant(econst_defstr(arg_p), result_ep);
	STATX(ftag);
	return result;
}
</t>
<t tx="ekr.20080529093004.689">@ Convert an integer constant node to a float constant node. The conversion of value must be as accurate as possible.
@c

static enode *
fold_int_to_float(enode * result_p, enode * arg_p)
{
	FTAG("fold_int_to_float");
	enode * result = NULL;
	char temp_def_string[402];
	TRACEPB(ftag,
		eenode(result_p); ecs(); eenode(arg_p); ecnl());
	
	/*
		Create a defining string for the float.
		Just add .0 to the old defining string.
	*/
	cvt_int(temp_def_string, 400, econst_long(arg_p));
	strcat(temp_def_string, ".0");
	ASSERT(strlen(temp_def_string) &lt; 400);
	
	result = fold_new_constant(temp_def_string, result_p);

	TRACEPX(ftag, enl(); eret(); eenode(result); ecnls(2));
	return result;
}
</t>
<t tx="ekr.20080529093004.690">@ Negate a float constant node. The conversion of value must be as accurate as possible.
@c

static enode *
fold_negate_float(enode * ep)
{
	FTAG("fold_negate_float");
	enode * result = NULL;
	TRACEPB(ftag,
		eenode(ep); ecnl());
	
	/* Create a new defining string. */
	if (*econst_defstr(ep) != '-') {
	
		char temp_def_string[402];
		temp_def_string[0] = '-';
		strcpy(temp_def_string + 1, econst_defstr(ep));
		
		result = fold_new_constant(temp_def_string, ep);
	}
	else {

		/* Move past the leading minus sign. */
				
		result = fold_new_constant(econst_defstr(ep) + 1, ep);
	}
	
	TRACEPX(ftag, enl(); eret(); eenode(result); ecnls(2));
	return result;
}
</t>
<t tx="ekr.20080529093004.691">@ Create a new constant enode from the given defining string.  Also create a new anode. This replaces an earlier anode and will often result in useless declarations. For example:   double d = -0.5;   results in :  label1: ; generated in expr_cprim  DC.D  "0.5" label2: ; generated here   DC.D  "-0.5"    Thus, the present scheme is a botch: probably anodes should be generated later.
@c

static enode *
fold_new_constant(char * temp_def_string, enode * target_p)
{
	FTAG("fold_new_constant");
	char * def_string = NULL;
	anode * ap = NULL;
	enode * result_p = NULL;
	tnode * t = target_p -&gt; e_ctype;
	int ckind = 0;
	int size = 0;
	TRACEPB(ftag,
		es(temp_def_string); enl());
	ASSERT(temp_def_string &amp;&amp; strlen(temp_def_string) &lt; 400);
	ASSERT(
		target_p &amp;&amp; target_p -&gt; e_ctype &amp;&amp;
		target_p -&gt; e_ctype -&gt; tprim == FLOAT_TYPE);
	
	/* Create a defining string with permanent lifetime. */
	new_string_macro(def_string, temp_def_string, perm_life, perm_string_stats);

	/* Create the result enode. */
	new_enode_macro(result_p, sizeof(const_enode), FLOAT_TOK);
	econst_defstr(result_p) = def_string;
	
	/*
		Set the folded flag to inhibit the message about
		"possibly useless outer expression.
	*/
	e_set_folded(result_p);
	
	/* Set the kind of constant. */
	if (t_is_double(t)) {
		ckind = DOUBLE_CKIND;
		size = DOUBLE_SIZE;
	}
	else if (t_is_float(t)) {
		ckind = FLOAT_CKIND;
		size = FLOAT_SIZE;
	}
	else if (t_is_long_double(t)) {
		ckind = LONG_DOUBLE_CKIND;
		size = LONG_DOUBLE_SIZE;
	}
	else {
		fatal(es("fold_new_constant: can't happen"));
	}

	/* Set the new type. */
	new_tnode_macro(t, FLOAT_TYPE, size);
	t_set_const(t);
	result_p -&gt; e_ctype = t;

	/* Create an anode representing the constant. */
	ap = gen_new_big_anode(ckind, def_string);
	ap -&gt; a_length = REGISTER_SIZE;
	econst_anode(result_p) = ap;
	
	/* Generate the new label and data area. */
	if (!dcl_initializer_flag) {
		out_data_clabel(
			const_anode_ptr(ap) -&gt; a_label, DEFINE_THE_LABEL, NO_COMMENT);
		out_data_float(def_string, ckind);
	}

	TRACEPX(ftag, enl(); eret(); eenode(result_p); ecnls(2));
	return result_p;
}</t>
<t tx="ekr.20080529093004.692">/*
	CC2: Code generation for function body.

	source:  CCgbody.c
	started: November 9, 1985
	version:
		January 24, 1995.
			Bug fix to gen_auto_list.
		December 15, 1994.
			Added t argument to gen_alloc_formals.
		December 12, 1994.
			Changed gen_alloc_formals and gen_alloc_locals so that actual
				structs/unions/floats are pushed instead of their addresses.
		November 11, 1994.
			Bug fix to gen_alloc_locals.
				Structs and unions have a_length == 4, regardless of their real length.
			Bug fix to gen_alloc_locals.
				Make sure that abs(offset) for any struct is at least 3 * REGISTER_SIZE.
		August 27, 1994.
			Fixed several bugs in initializers.
			? Allow initializers of the form ((struct s *) 0) -&gt; field.
			? Allow non-zero constants to initialize a pointer.
			? Allow leading + or - signs in floating constants.
			  (CC2 does not yet fold floating constants)
		August 26, 1994.
			Created gen_init_pointer routine.
		August 24, 1994.
			Bug fix in gen_inner_data: use t, not s_p -&gt; ctype to
			determine type of pointer.
			This may have been the cause of the { 0 } bug too!!
		August 24, 1994.
			Bug fix: gen_init_data does nothing if errors have been seen.
			Handle initializers of the form &amp;p . field1 . field2.
		July 14, 1994.
			Bug fix to gen_inner_data.
				Scale constant array indices as in
					short array [5]
					short * p1 = &amp;array[1];	-- must be scaled by sizeof(short)
					short * p2 = array + 1;  -- must be scaled by sizeof(short)
		November 2, 1993.
			Added support for static initializers of the form &amp;array[constant].
			This is just a kludge: what is needed is a general method of
			folding a constant expression into an identifier part an a constant part.
		July 21, 1993.
			Output strings immediately if string_ref_flag is off.
			Don't output string refs for auto strings.
		July 19, 1993.
			Replaced ASSERT and ASSERT_TRACE by GEN_ASSERT and GEN_ASSERT_TRACE.
			Set gen_expr_line in various gen_alloc_xxx routines.
		July 16, 1993.
			Added string_ref_flag field to gen_inner_data.
			Made several bug fixes to gen_init_data.
		July 14, 1993.
			Bug fix to gen_inner_data: inialize floats based on variables type.
		July 2, 1993.
			Eliminated gen_init_strings and ilist_node's.
				Pointers to strings are handled uniformly now.
				In particular, the special case in gen_inner_data that
				handled arrays of pointers to strings is gone.
			Pointers to char initialized by strings now generate
				*two* initial data areas (IDA's).
				The first IDA points to the second IDA.
				The second IDA contains the actual string and is
				generated at the end of gen_init_data so it will not
				appear in the middle of a struct!
			gen_inner_data puts a string_list_node describing the string
				and its label on the global string_list.
				This string_list is used by gen_init_data to output the IDA
				for the actual strings.
		June 29, 1993.
			Bug fix to gen_fbody.  We *must* set addq_flag when registers are saved.
		June 19, 1993.
			Corrected gen_alloc_formals and added extensive comments.
			Do not set offset field in snodes here!
		June 1, 1993.
			Bug fix: push the scratch registers(!)
		May 25, 1993.
			Removed unused parameter from gen_fbody.
		May 23, 1993.
			Rewrote err_line logic.
				err_line is now never set permanently by the code generators.
				delayed_error(s_p -&gt; p_line, ...) is used instead of error.
		May 11. 1993.
			Bug fix to gen_init_data:
				added export_flag to out_data_ulabel so we will
				call out_export for non-static variables.
		May 5, 1993.
			Printed copy sent to Tuple.
		May 3, 1993.
			Added extensive comments to gen_init_data.
			Fixed bug in gen_init_data.
		May 2, 1993.
			Added gen_init_tree.
		April 22, 1993.
			Added gen_import and gen_all_imports
		April 13, 1993.
			Set a_vprefix field in gen_alloc_outers.
		April 2, 1993.
			Added gen_init_strings.
		April 1, 1993.
			Added gen_init_data, gen_init_inner.
		March 17, 1993.
			Call reg_free_formals from gen_fbody.
		March 4, 1993.
			Changed push_flag to push_count so out_function can easily
			tell whether to use a movem or a move instruction.
			Bug fix: the *size* of char formals is 1, even though their offset is 2.
		February 25, 1993.
			The a_length field of arrays is always POINTER_SIZE.
			Several == changed to '=' (found by CC2).
		February 12, 1993.
			Changed gen_alloc_formals to create formal_reg_nodes.
		February 2, 1993.
			Add the return label to the code list so that
			all peephole optimizations may apply to it.
		January 26, 1993.
			Moved gen_auto_inits to this file.
			Changed gen_auto_inits to handle all snodes in the snodes list.
		January 12, 1993.
			Replaced GEN_D0_ONLY by arg_d0_only_flag.
		December 19, 1992.
			Fixed gen_alloc_locals so statics never take stack space.
		November 3, 1992.
			Created from g1.c.
		September 12, 1992.
			Added dump of formals in gen_fbody.
		September 10, 1992.
			Added gen_alloc_formals, gen_alloc_locals.
*/

&lt;&lt; CCgbody #includes &gt;&gt;
&lt;&lt; CCgbody declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.693">#include "CC.h"

#include "CCarg.h"
#include "CCdump.h"
#include "CCgen.h"
#include "CCmem.h"
#include "CCparser.h"
#include "CCregs.h"
#include "CCtarget.h"

#include &lt;LIBlist.h&gt;
</t>
<t tx="ekr.20080529093004.694">/*
	Define synonyms for the string_ref_flag argument to gen_inner_data.
*/
#define MAKE_STRING_REFS		TRUE
#define DONT_MAKE_STRING_REFS	FALSE

/*
	string_init_list is a list of nodes describing IDA's for strings to be created later.
	These strings are pointed to by IDA's that have already been created.
*/
typedef struct string_node_struct string_node;

static struct string_node_struct {
	TYPE_LIST(string_node);
	label_cnode *	string_label;
	char * 			string_def;
};

string_node * string_list;

/*
	import_list is a list of all snodes for which IMPORT directives
	will be generated at the start of the current function.
	gen_import_avail list is used to recycle old import nodes.
*/
typedef struct import_node_struct import_node;

struct import_node_struct {
	TYPE_LIST(import_node);
	snode * the_snode;
	bool	lib_flag;
};

static import_node * import_list = NULL;
static import_node * import_avail_list = NULL;

/*
	Function prototypes of internal functions
*/
static void 	gen_alloc_formals	(snode * s_p, tnode * t);
static void		gen_auto_list		(snode * s_p, inode * ip);
static bool		gen_init_float		(enode * ep, tnode * t);
static bool		gen_init_pointer	(snode * s_p, enode * ep, tnode * t, bool string_ref_flag);
static void		gen_init_tree		(enode * ep);
static inode *	gen_inner_data		(snode * s_p, inode * ip, tnode * t, bool string_ref_flag);
</t>
<t tx="ekr.20080529093004.695">@ Set the s_p field for a list of formal variables. No space is allocated on the stack, since formal paramters preceded the stack frame and have positive offsets from the stack pointer.  Also allocate registers to formals and blocks using get_dcl_reg.  6/19/93: *Inside* any called function containing formal parameters, the argument on the top of the stack is located at 8(a6). This is true *regardless* of the size or type of the argument. (A LINK instruction is the first instruction for any function containing formal params.)  *Inside* any called function, (after the LINK instruction) the stack frame is...  argument n   8+sizeof(all previous arguments)(a6)  ...  argument 2   8+sizeof(argument 1)(a6)  argument 1   8(a6)  return address   4(a6)  a6 saved by LINK  0(a6)  nn bytes of local data  pre_reserved space (4 bytes) -nn-4(a6) (sp points at these 4 bytes)  *Inside* the called function (after the LINK instruction) a7 points at the 4 bytes of pre-reserved stack space used by the call_1arg optimization. Thus, -nn-4(a6) and (a7) reference the same location just after the LINK instruction. The pre-reserved stack space has larger negative offset than any local data, so moving data into the location at (a7) will not trash any local variable.  Character arguments occupy 2 bytes on the stack. Recall that the 68000 hardware pushes *two* bytes on the stack when it executes  MOVE.B &lt;any&gt;,-(a7)  Thus, *all* arguments occupy an even number of bytes on the stack and the offset of *any* argument must also be even.  The following code assigns stack offsets to each formal parameter. These offsets are used *inside the called function* to access the actual parameters pushed on the stack by the caller.  Parameters are examined from first to last and since they are pushed in reverse order, the first parameter appears at the top of the stack at 8(a6), the next parameter appears at 8+n(a6), where n is the size of the *first* parameter, and so on.  12/15/94 Functions that return a big float, struct or union allocate a stack temp and push a pointer to the stack temp after all arguments have been pushed. Therefore, all offsets are REGISTER_SIZE bigger in such cases.
@c

static void
gen_alloc_formals(snode * s_p, tnode * t)
{
	FTAG("gen_alloc_formals");
	
		register ulong offset = 2 * REGISTER_SIZE;	/* Size of initial stack frame. */
		long size = 0;

	TRACEPB(ftag, esnode(s_p));
	
	/* 12/19/94 Adjust for the hidden pointer to large return area. */
	if (t -&gt; tsize &gt; REGISTER_SIZE) {
		size   += REGISTER_SIZE;
		offset += REGISTER_SIZE;
	}

	for ( ; s_p; s_p = s_p -&gt; n_next) {

		tnode * t = NULL;
		anode * ap = NULL;
		anode * reg_ap = NULL;

		TRACEPN(ftag, etnode(t); ecnl());

		if (s_p -&gt; n_type == KP_VOID_VAR || s_p -&gt; n_type == KP_NULL_VAR) {
			continue;
		}

		if (s_p -&gt; n_type == KP_DOTS3) {
			break;
		}

		t = s_p -&gt; ctype;

		/* Set the line for GEN_ASSERT. */
		gen_expr_line = s_p -&gt; p_line;

		GEN_ASSERT(t);

		/*
			Assign offsets to formals first, *then* update the offset by the size of the formal.
			With an initial offset of 8, this ensures that first formal has offset 8(a6)
			and the next formal has offset 8+n(at), where n is the size of the first formal.

			The first time I wrote this code, I incremented the offset *before* assigning the
			offset to the parameter.
			This must be wrong, since the offset of the first parameter would depend on its size.
			I made this error because params are pushed using -(a7) address mode,
			and this decrements the offset before pushing.  Alas, this is a false analogy;
			indeed, we allocate offsets in the opposite order in which parameters are pushed.

			6/30/93: Byte parameters are passed as an int.
			The 68000 architecture assigns the most significant byte (MSB) to the
			address of the word.
			Thus, the address of the LSB is *not* the same as the address of its word.
		*/

		/*
			All formal parameters, even those that are eventually moved into registers,
			are initially allocated on the stack, so we must allocate space for them!
		*/

		new_anode_macro(ap, sizeof(spill_anode), DISPLACEMENT_EA);
		spill_anode_ptr(ap) -&gt; a_sreg = R_A6;
		spill_anode_ptr(ap) -&gt; a_slong = offset;
		if (s_p -&gt; offset &gt; 0x7fff) {
			spill_anode_ptr(ap) -&gt; n_type = INDEX_EA;
		}
		if (s_p -&gt; spell) {
			spill_anode_ptr(ap) -&gt; a_sname = s_p -&gt; spell -&gt; spell_name;
		}

		/*
			Increment offset by the number of bytes occupied by the parameter on the stack.
			Set the machine size of the parameter.
		*/
		if (t -&gt; tsize &lt;= 0) {
			delayed_error(s_p -&gt; p_line,
				es(ftag); es(": non-positive tsize: "); elong(t -&gt; tsize);
				ecs(); es(s_p -&gt; spell -&gt; spell_name));
		}
		else if (t -&gt; tprim == ARRAY_TYPE) {

			/* 2/25/93: The size of an array is irrelevant. */
			size    = POINTER_SIZE;
			offset += POINTER_SIZE;
		}
		else if (t -&gt; tsize == 1) {

			/*
				7/1/93: After quite a bit of experimentation
				I have chosen to handle char arguments as follows.

				1.  This routine allocates stack space for an int.
				This is required in order to be compatible with MPW library functions.

				2.  This routine does *not* change the C type of the argument,
				nor does it require any casting of the argument,
				except by ct_check_args when the argument is pushed.
				This keeps prototyping absolutely correct.

				3.  This routine returns an anode describing only the LSB of the pushed int.
				Note: the LSB has a *different* address from the pushed int!

				Therefore, ap -&gt; a_length remains equal to t -&gt; tsize,
				and that is required by numerous GEN_ASSERT's in the code.

				Section 3.7.1 of the Rationale applies here...

					"Some current implementations rewrite the type of a (for instance)
					char parameter as if it were declared int,
					since the argument is known to be passed as an int (in the absence of prototypes).
					The Standard requires, however, that the received argument be converted *as if*
					by assignment upon function entry.
					Type rewriting is thus no longer permissible."

				This scheme is absolutely correct, and may result in extra extensions.
				Indeed, byte arguments are extended when they are pushed,
				but the size remains 1 so they may be extended again inside the function.

				However, we can't just set size to INT_SIZE because t -&gt; tsize is still 1
				and various GEN_ASSERT's in gint.c would fail.
				To eliminate extra extensions we would have to change the type of the char argument
				to int, but *only* while generating code.
				It is invalid to change the function's prototype.
			*/
			size    = 1;
			offset += INT_SIZE;		/* Bug fix: 6/30/93: use INT_SIZE, not 2! */

			/*
				6/30/93: add (sizeof(int)-1) to the offset field to get
				the address of the byte, i.e. the address of the LSB of the int.
			*/
			spill_anode_ptr(ap) -&gt; a_slong = offset-1;
		}
		else if (t -&gt; tsize == 2 || t -&gt; tsize == 4) {
			/* Word or long size argument. */
			size    = t -&gt; tsize;
			offset += t -&gt; tsize;
		}
		else {
			/* 12/12/94 Structs/unions and floats are now passed on the stack. */
			size    = t -&gt; tsize;
			offset += t -&gt; tsize;
		}

		/* Set the machine size of the parameter. */
		spill_anode_ptr(ap) -&gt; a_length = size;

		/*
			Try to get a register for register variables.
			This must be done *after* the a_length field is set properly.
		*/
		if (s_is_register(s_p)) {

			/* Attempt to allocate a register. */
			reg_ap = get_dcl_reg(s_p, NULL);

			if (reg_ap) {

				/*
					Generate a move from the stack to the register.
					This can and should be done here!

					Expand the size of char registers from byte to long.
				*/
				GEN_ASSERT(ap -&gt; a_length == reg_ap -&gt; a_length);
				c_move(ap, reg_ap);

				/*
					Use the register, not the stack location,
					as the variable's typical location.
				*/
				ap = reg_ap;
			}
		}
		s_p -&gt; sarg = ap;

		/* Output a comment concerning the formal. */		
		GEN_ASSERT(s_p &amp;&amp; s_p -&gt; spell &amp;&amp; s_p -&gt; sarg);
		out_stack_comment(s_p -&gt; sarg, size, "formal", s_p -&gt; spell -&gt; spell_name);
	}

	TRACEPX(ftag, es("offset: "); eulong(offset); enl());
}
</t>
<t tx="ekr.20080529093004.696">@ Allocate an anode for a function prototype or definition.
@c

void
gen_alloc_function(register snode * s_p)
{
	FTAG("gen_alloc_function");
	register anode * ap = NULL;
	STATB(ftag);

	GEN_ASSERT(s_p -&gt; sarg == NULL);

	/* Allocate the anodes. */
	new_anode_macro(ap, sizeof(var_anode), ABSOLUTE_EA);
	var_anode_ptr(ap) -&gt; a_length = (s_p -&gt; ctype) ? s_p -&gt; ctype -&gt; tsize : 0;
	var_anode_ptr(ap) -&gt; a_vkind  = s_is_static(s_p) ? NAME_VKIND : XNAME_VKIND;
	var_anode_ptr(ap) -&gt; a_vname  = (s_p -&gt; spell) ? s_p -&gt; spell -&gt; spell_name : NULL;
	s_p -&gt; sarg = ap;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.697">@ Allocate stack space for a list of local variables. Also allocate registers to formals and blocks using get_dcl_reg.
@c

void
gen_alloc_locals(block_node * bp)
{
	FTAG("gen_alloc_locals");
	register snode * s_p = NULL;
	STATB(ftag);

	/* Set the line for GEN_ASSERT. */
	gen_expr_line = bp -&gt; p_line;

	GEN_ASSERT(bp);
	s_p = bp -&gt; block_dcls;

	for ( ; s_p; s_p = s_p -&gt; n_next) {

		register tnode * t = NULL;
		ulong a_length = 0;

		if (s_p -&gt; n_type == KP_VOID_VAR || s_p -&gt; n_type == KP_NULL_VAR) {
			continue;
		}

		t = s_p -&gt; ctype;

		/* Set the line for GEN_ASSERT. */
		gen_expr_line = s_p -&gt; p_line;

		GEN_ASSERT(t);

		if (t -&gt; tprim == FUNCTION_TYPE) {
			continue;
		}

		/* Only arrays are represented as pointers now. */
		a_length = (t -&gt; tprim == ARRAY_TYPE) ? REGISTER_SIZE : t -&gt; tsize;

		GEN_ASSERT_TRACE(t -&gt; tsize &gt; 0,
			es("non-positive tsize: "); elong(t -&gt; tsize); ecs();
			es(s_p -&gt; spell -&gt; spell_name);
			es(", type: "); etoknum(s_p -&gt; n_type);
		);

		if (s_is_static(s_p)) {

			/* This has been allocated by gen_alloc_outers. */
			continue;
		}

		if (s_is_register(s_p)) {

			/* Attempt to allocate a register. */
			s_p -&gt; sarg = get_dcl_reg(s_p, bp);
			if (s_p -&gt; sarg) {

				/* The allocation was successful. */
				continue;
			}
		}

		/* Allocate an even number of bytes of stack space. */
		{
			char * name = s_p -&gt; spell ? s_p -&gt; spell -&gt; spell_name : NULL;
			ulong size = t -&gt; tsize;
			if (size &amp; 1) {
				size++;
			}

			s_p -&gt; sarg = gen_new_stack_anode(size, a_length, "auto", name);
			if (s_p -&gt; sarg -&gt; n_type == DISPLACEMENT_EA) {
				spill_anode_ptr(s_p -&gt; sarg) -&gt; a_sname = name;
			}
		}
	}
	
	/* 1/6/94: Set the base for all temporaries. */
	gen_current_base = gen_current_alloc;

	TRACEPX(ftag,
		es("gen_current_alloc: ");	eulong(gen_current_alloc); ecs();
		es("gen_max_alloc: ");		eulong(gen_max_alloc));
}
</t>
<t tx="ekr.20080529093004.698">@ Create anodes for variables declared outside any function.
@c

void
gen_alloc_outers(snode * s_p)
{
	FTAG("gen_alloc_outers");
	TRACEPB(ftag, esnode(s_p));

	for ( ; s_p; s_p = s_p -&gt; n_next) {

		register anode * ap = NULL;
		tnode * t = NULL;
		long size = 0;

		if (
			s_p -&gt; n_type == KP_VOID_VAR ||
			s_p -&gt; n_type == KP_NULL_VAR ||
			s_p -&gt; spell == NULL
		) {
			continue;
		}

		/* Set the line for GEN_ASSERT. */
		gen_expr_line = s_p -&gt; p_line;

		GEN_ASSERT(s_p -&gt; spell);
		GEN_ASSERT(s_p -&gt; ctype);

		size = s_p -&gt; ctype -&gt; tsize;
		
		/* Arrays always are represented as pointers. */
		if (s_p -&gt; ctype -&gt; tprim == ARRAY_TYPE) {
			size = 4;
		}

		new_anode_macro(ap, sizeof(var_anode), ABSOLUTE_EA);
		var_anode_ptr(ap) -&gt; a_length = size;
		var_anode_ptr(ap) -&gt; a_vkind = s_is_static(s_p) ? NAME_VKIND : XNAME_VKIND;
		var_anode_ptr(ap) -&gt; a_vprefix = s_is_static(s_p) ? ++gen_vprefix : 0;
		var_anode_ptr(ap) -&gt; a_vname = s_p -&gt; spell -&gt; spell_name;
		s_p -&gt; sarg = ap;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.699">@ Generate an IMPORT statment for each item on gen_import list. Clear gen_import list afterwards.  This routine is needed to handle the MPW assembler.
@c

void
gen_all_imports(void)
{
	FTAG("gen_all_imports");
	import_node * ip = NULL;
	STATB(ftag);

	if (import_list) {

		for (ip = import_list; ip; ip = ip -&gt; next) {
			out_import(ip -&gt; the_snode, ip -&gt; lib_flag);
		}

		/* Unmark all nodes on the list. */
		ip = import_list;
		while(ip) {

			GEN_ASSERT(ip -&gt; the_snode);
			s_clear_import(ip -&gt; the_snode);
			ip = ip -&gt; next;
		}

		/* Transfer all nodes to import_avail_list. */
		if (import_avail_list == NULL) {
			import_avail_list = import_list;
		}
		else {

			/* Find the end of the avail list. */
			for (ip = import_avail_list; ip &amp;&amp; ip -&gt; next; ip = ip -&gt; next) {
				;
			}
			GEN_ASSERT(ip);
			ip -&gt; next = import_list;
		}
		import_list = NULL;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.700">@ Generate code for each auto initializer in the list s_p. This routine is called from gen_block.
@c

void
gen_auto_inits(register snode *s_p)
{
	FTAG("gen_auto_inits");
	STATB(ftag);

	/* Set the line for GEN_ASSERT. */
	gen_expr_line = s_p -&gt; p_line;

	GEN_ASSERT(s_p);

	for ( ; s_p; s_p = s_p -&gt; n_next) {

		if (s_p -&gt; n_type == KP_VOID_VAR || s_p -&gt; n_type == KP_NULL_VAR) {
			continue;
		}

		if (s_p -&gt; n_type == KP_DOTS3) {
			break;
		}

		if (!s_is_auto(s_p) || s_is_formal(s_p)) {
			continue;
		}

		c_line(pnode_ptr(s_p));

		/* Generate the list of auto initializers. */
		gen_auto_list(s_p, s_p -&gt; vlist);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.701">@ Generate code for all auto initializers.  At this point initial data areas have been generated for *all* variables. All that remains is to move the initial data area into the variable.
@c

static void
gen_auto_list(snode * s_p, register inode * ip)
{
	FTAG("gen_auto_list");
	STATB(ftag);

	for (; ip; ip = ip -&gt; inext) {

		if (ip -&gt; itype == EXPR_ITYPE) {

			op2_enode * op2 = NULL;
			var_enode * var_ep = NULL;

			/* Create an enode to refer to s_p. */
			new_enode_macro(var_ep, sizeof(var_enode), ID_TOK);
			var_ep -&gt; e_ctype = s_p -&gt; ctype;
			var_ep -&gt; e_var = s_p;

			/* Create an assignment statement. */
			new_enode_macro(op2, sizeof(op2_enode), ASSN_TOK);
			op2 -&gt; e_nargs = 2;
			op2 -&gt; arg1 = enode_ptr(var_ep);
			op2 -&gt; arg2 = ip -&gt; i_expr;

			/*
				The following calls can generate errors.
				Set the line number for them.
			*/
			{
				long save_line = err_line;
				err_line = s_p -&gt; p_line;

				/* Set the proper type of the assignment. */
				op2 = ct_type2(op2, ALLOW_ASSN_TO_CONST);

				/* Generate code for the newly created assignment. */
				(void) gen_e1(enode_ptr(op2));

				err_line = save_line;
			}
		}
		else if (ip -&gt; itype == BRACE_ITYPE) {
		
			long save_line = err_line;
			err_line = s_p -&gt; p_line;

			// not ready yet
			// Call gen_init_data to create initial data area in the *DATA* segment.
			// Generate code to move the data into the variable.
			error(es("braces not ready yet here"));
			
			err_line = save_line;
		}
		else {

			int kind = const_anode_ptr(ip -&gt; i_auto) -&gt; a_ckind;

			GEN_ASSERT(
				s_p &amp;&amp; s_p -&gt; sarg &amp;&amp;
				ip -&gt; itype == AUTO_ITYPE &amp;&amp;
				ip -&gt; i_auto &amp;&amp;
				ip -&gt; i_auto -&gt; n_type == IMMEDIATE_EA);

			/*
				7/22/93:
					Handle the special cases here.
					Don't contaminate the logic of c_move_big.
			*/
			if (kind == BLOCK_CKIND) {
			
				ulong size = ip -&gt; icount;
				
				
				/*
					Bug fix: 1/24/95.
					Don't test for t_is_big_type here.
					t_is_big_type is FALSE for arrays and we must initialize arrays too!
				*/				
				if (s_p -&gt; ctype &amp;&amp; s_p -&gt; ctype -&gt; tsize &gt; REGISTER_SIZE) {
					c_move_big(
						ip -&gt; i_auto, TAKE_ADDRESS,
						s_p -&gt; sarg, TAKE_ADDRESS, size);
					free_temp(s_p -&gt; sarg);
					free_temp(ip -&gt; i_auto);
				}
				else {
					c_2len(X_MOVE, ip -&gt; i_auto, s_p -&gt; sarg, size);
				}
			}
			else {
				GEN_ASSERT(kind == STRING_REF_CKIND);
				c_move_len(ip -&gt; i_auto, s_p -&gt; sarg, ip -&gt; icount);
			}
		}
	}
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.702">@ Generate code for a function body.  This routine does the following:  o Dump debugging info if requested. o Call gen_alloc_formals to allocate space for formal parameters. o Set reg_ret_a and reg_ret_d globals. o Allocate the global return label: gen_ret_label. o Call gen_list to create the code list for the body. o Call the peephole optimizer. o Set reg_push_array indicating which registers must be pushed. o Set addq_flag if the ADDQ optimization is to be performed. o Set push_count to the number of registers to be pushed. o Call out_function(push_count, addq_flag) to write all code.  CAUTION: The long link frame size is of an unsigned type; not signed long. It causes the stack to be offset by an unsigned negative amount, although it is not itself treated as unsigned negative.
@c

void
gen_fbody(void)
{
	FTAG("gen_fbody");
	int push_count = 0;			/* The number of registers to be pushed. */
	bool addq_flag = FALSE;		/* TRUE: do the ADDQ optimization. */
	TRACEPB(ftag,
		es(gen_fname); enl();
		es("formals...\n");
		esnode(gen_formals);
		es("returning...\n");
		etnode(gen_ftype); ecnl();
		es("gen_call_1arg: "); eint(gen_call_1arg);
	);

	if (arg_tree_flag) {
		ecnls(2); es("&gt;&gt;&gt;&gt;&gt; Begin parse tree for ");
		es(gen_fname); es("()\n\n");
		eline_flag = TRUE;
		etnode_brief_flag = FALSE;
		es("formals...\n");
		edcls(gen_formals);
		ecnls(2); es("body...\n");
		epnode(gen_parse_tree);
		eline_flag = FALSE;
		etnode_brief_flag = TRUE;
		ecnls(2); es("&gt;&gt;&gt;&gt;&gt; End parse tree for ");
		es(gen_fname);
		es("()\n\n");
	}

	if (arg_no_gen_flag || err_count &gt; 0) {
		/* Suppress code generation. */
		goto done;
	}

	/* Size the formals and locals, generating register moves as needed. */
	gen_alloc_formals(gen_formals, gen_ftype -&gt; ttype);

	/* Set the globals reg_ret_a and reg_ret_d indicating the return register. */
	{
		int prim = gen_ftype -&gt; ttype -&gt; tprim;

		reg_ret_a = reg_ret_d = FALSE;
		if (prim == INT_TYPE || prim == FLOAT_TYPE) {
			reg_ret_d = TRUE;
		}
		else if (prim != VOID_TYPE) {
			if (arg_d0_only_flag) {
				reg_ret_d = TRUE;
			}
			else {
				reg_ret_a = TRUE;
			}
		}
	}

	TRACEPN(ftag,
		es("reg_ret_d = "); eint(reg_ret_d);
		es(", reg_ret_a = "); eint(reg_ret_a); enl());

	/* Set the global return label for this function. */
	new_clabel_macro(gen_ret_label);

	/* Generate the code list for the body. */
	gen_list(gen_parse_tree);
	#ifndef PRODUCTION
		reg_init_check();
	#endif

	/*
		Generate the exit label *before* the peephole
		so that all optimizations may apply to it.
	*/
	c_clabel(gen_ret_label);

	/* Call the peep hole optimizer. */
	if (!arg_no_peep_flag) {

		if (arg_code1_flag) {
			ecnls(2);
			es("&gt;&gt;&gt;&gt;&gt; code before peephole...\n\n");
			ecodelist(code_head);
			ecnls(2);
		}

		peep_hole();

		if (arg_code1_flag) {
			ecnls(2);
			es("&gt;&gt;&gt;&gt;&gt; code after peephole...\n\n");
			ecodelist(code_head);
			ecnls(2);
			es("&gt;&gt;&gt;&gt;&gt; end of code after peephole...\n\n");
		}
	}

	/* gen_max_alloc now indicates how much stack space is needed. */

	/* Set the global reg_push_array. */
	{
		register int i;
		for (i = R_A0; i &lt;= R_D7; i++) {
			reg_push_array[reg_index(i)] = reg_used_array[reg_index(i)];
		}
	}

	/* Don't push the return reg: popping it would clobber the return! */
	if (reg_ret_a) {
		reg_push_array[reg_index(R_A0)] = FALSE;
	}
	else if (reg_ret_d) {
		reg_push_array[reg_index(R_D0)] = FALSE;
	}

	TRACEPN(ftag,
		es("push: ");
		{
			register int i;
			for (i = R_D0; i &lt;= R_D7; i++) {
				if (reg_is_pushed(i)) {
					es("D"); eint(i); ecs();
				}
			}
			for (i = R_A0; i &lt;= R_A7; i++) {
				if (reg_is_pushed(i)) {
					es("A"); eint(i); ecs();
				}
			}
		}
		enl();
	);

	/* Count the number of registers to be pushed. */
	push_count = 0;
	{
		register int i;
		for (i = R_A0; i &lt;= R_D7; i++) {
			if (reg_is_pushed(i)) {
				push_count++;
			}
		}
	}
	TRACEPN(ftag, es("push_count = "); eint(push_count); enl());

	/*
		gen_call_1arg is the number of calls to functions g1, g2...gn with one argument
		IN THE CURRENT FUNCTION, say f.  See the extensive comments in gen.c.

		If gen_call_1arg &gt;= 1, f will *pre_allocate* stack space.

		Bug fix: 6/29/93:

		If push_count &gt; 0 we will push registers just after the link instruction and
		we must reserve space *after* those pushes.
		We indicate that this space must be reserved explicitly using the addq_flag.

		Otherwise, no registers will be pushed so we can reserve stack space simply
		by adjusting gen_current_allocand gen_max_alloc.
	*/
	addq_flag = FALSE;
	if (gen_call_1arg &gt;= 1) {
		if (push_count &gt; 0) {
			addq_flag = TRUE;
		}
		else {

			/*
				Bug fix: 6/29/93: we must increase the *maximum* allocation,
				not just the current allocation!
				Indeed, the *maximum* allocation is used to reserve stack space,
				and the current allocation is essentially irrelevant here.
			*/
			gen_max_alloc += 4;
			gen_current_alloc += 4;
			gen_current_base += 4;
			addq_flag = FALSE;
		}
	}

	/* Output the entry code, the body and the exit code. */
	out_function(push_count, addq_flag);

	/* Reclaim all formal register variables. */
	reg_free_formals();

	/*
		6/1/93: Re-initialize.
		Call these functions *before* entering dcl().
	*/
	reg_init();
	gen_func_init();

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.703">@ Add an element to the global import list.  This routine is needed to handle the MPW assembler.
@c

void
gen_import(snode * s_p, bool lib_flag)
{
	FTAG("gen_import");
	STATB(ftag);
	GEN_ASSERT(s_p);

	/*
		Add a s_p to the list.
		If s_is_import, the symbol is already on the list.

		The s_is_defined hack works around a problem with the MPW assembler,
		that does not allow both IMPORT and EXPORT directives to coexist (boo hiss).

		A kludge on a kludge:
		explicitly declared extern prototypes always generate a prototype.
	*/
	if (
		!s_is_import(s_p) &amp;&amp;
		(
			(s_is_extern(s_p) /* !s_is_proto(s_p) */) ||
			(
				s_is_proto(s_p) &amp;&amp;
				!s_is_static(s_p) &amp;&amp;
				!s_is_defined(s_p)
			)
		)

	) {

		import_node * ip = NULL;

		/* Mark the symbol as already imported. */
		s_set_import(s_p);

		/* Get a new import_node. */
		if (import_avail_list) {
			ip = import_avail_list;
			import_avail_list = ip -&gt; next;
		}
		else {
			new_perm_macro(ip, perm_import_stats);
		}
		ip -&gt; the_snode = s_p;
		ip -&gt; lib_flag = lib_flag;

		/* Add the import_node to the global import_list. */
		ip -&gt; next = import_list;
		import_list = ip;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.704">@ Generate an import statement for a name. The name is the name of a compiler library function if lib_flag is TRUE.  This routine is needed to handle the MPW assembler.
@c

void
gen_import_name(char * name, bool lib_flag)
{
	FTAG("gen_import_name");
	static snode * lib_snode_list = NULL;
	register snode * s_p = lib_snode_list;
	spell_node * spell_p = NULL;
	STATB(ftag);
	GEN_ASSERT(name);

	/*
		Search the list of library nodes, looking for the name.
		The list can be kept in the s_next field since these are minimal snodes.

		This code assumes that name is a static string.
		(It is, since the string is an argument to lib_name in gfloat.c)
		We simply compare the *addresses* of the strings to see if they are equal.
		This is fast, but means that duplicate strings will create duplicate snodes.
	*/
	while (s_p) {
		GEN_ASSERT(s_p -&gt; n_type == 0);
		if (s_p -&gt; spell &amp;&amp; s_p -&gt; spell -&gt; spell_name == name) {

			/* Just add to the import list. */
			gen_import(s_p, lib_flag);
			goto found;
		}
		s_p = s_p -&gt; n_next;
	}

	/*
		The string has not been found.
		Create a dummy snode for gen_import.
		The node must have *permanent* lifetime since it is *never* freed.
	*/

	/* Create a minimal spelling node. */
	new_perm_macro(spell_p, perm_spell_stats);

	spell_p -&gt; spell_name = name;

	/* Create a minimal snode for a prototype. */
	new_perm_macro(s_p, perm_snode_stats);

	GEN_ASSERT(s_p -&gt; n_type == 0);
	s_p -&gt; spell = spell_p;
	s_set_proto(s_p);
	s_set_code(s_p);

	/* Add the snode to the local snode list. */
	s_p -&gt; n_next = lib_snode_list;
	lib_snode_list = s_p;

	/* Add the snode to the import list. */
	gen_import(s_p, lib_flag);

found:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.705">@ Create the initial data area for a variable. This routine must be called after the type of s_p is completely known.  I have heard writers of C compilers refer in hushed tones to the code that handles initializers. Now I know why.  First some terms:  The *allies* of this routine are the routines called by it, namely gen_inner_data and gen_init_tree. The gen_auto_init routine, while not an ally, is intimately connected with the process of generating initializers.  A *static data area* is an area of memory whose address is constant. That is, the area is created at "link time" and the address is not relative to the stack pointer. Only static data areas have labels.  On the Macintosh there is a static data area called the "application globals" whose address is expressed as an offset to the A5 register. The value of A5 must be preserved throughout the execution of a Mac application. The Macintosh MPW assembler knows that application globals are accessed via A5, so the following two assembly statements are equivalent,  TST global_var(a5)  TST global_var  The *initial data area* of a variable is a static data area used to initialize that variable.  This code is complicated by the following considerations.  1. The initial data area for a *non*-auto variable defines the variable directly. For example:  static int a, b = 5;  Creates the following code,  file_prefix@a: DC.W 0  file_prefix@b: DC.W 5  2. The initial data area for an *auto* variable does not define the variable, since the location of the auto variable changes during execution. Therefore, when an auto variable is initialized, run-time code must be generated to move the initial data area for the auto variable into the location currently occupied by the auto variable. For example:  auto int a, b = 5;  Creates the following code,  file_prefix@1: DC.W 0 ;initial data area for a  file_prefix@2: DC.W 5 ;initial data area for b  ...  move.w file_prefix@1,a(a6)  move.w file_prefix@2,b(a6)  3. Initializers for arrays of structs must be padded to reflect missing constants. It is not enough to call gen_init_tree! All structures that are initialized by a list of constants, as opposed to an expression of type struct, must be initialized using a properly padded initial data area. For example,  struct sa {  int i;  int j;  };  static struct sa sa_vect [] = { {1}, {2} };  The initial data area for sa_vect must be:  file_prefix@sa_vect:  DC.W 1  DC.W 0 ;padding  DC.W 2  DC.W 0 ;padding  4. The initial data area for *auto* structs must be prepared as usual, but the actual initialization must be done at run_time by a block move instruction. Such data areas are represented by an inode of AUTO_ITYPE, that replaces the original list of constants. gen_auto_inits knows to generate a block move when it sees an AUTO_ITYPE inode.  5. Expressions are allowed to initialize auto variables. Even though gen_auto_init generates run-time code for auto initializers, initial data areas must be generated for constants appearing in those expressions. For example, an initial data area for "abc" must be generated for  int n = sprintf("abc");  Such initialization is handled by gen_init_tree.  6. From the foregoing it can be seen that initialializers for auto variables are handled in two different ways. o Initializers for structs consisting of a brace-enclosed list of constants, as opposed to an expression of type struct, must create an initial data area and a block move. o Initializers for all other auto variables result in code to evaluate the expression, which may or may not be a constant.  In summary, the rules for creating initial data areas are:  A. Create an initial data area for all non_auto variables.  B. Create an initial data area for all auto structs.  C. Create an initial data area for all constants in non-struct auto variables.  7. The parsers of initializers (done by dcl_init and *its* allies) have set up inodes so that they reflect the presence or absence of braces in the original text. Remembering these braces are essential so that padding may be done properly. Alas, the rules of C permit braces to be elided. Not only is this a bad idea from the point of view of language design (the compiler has no way of catching some nasty programmer mistakes) but these routines must maintain global counts to make sure when the initializer for a struct has been exhausted.
@c

static bool init_err_flag;	/* TRUE: some error was detected. */
void
gen_init_data(snode * s_p)
{
	FTAG("gen_init_data");
	label_cnode *auto_lab = NULL;
	char * error_mess = NULL;
	bool auto_string_flag = FALSE;
	STATB(ftag);
	
	/* Bug fix 8/24/94: do nothing if errors have been seen. */
	if (err_count &gt; 0) {
		goto done;
	}

	/* Set the line for GEN_ASSERT. */
	gen_expr_line = s_p -&gt; p_line;

	GEN_ASSERT(s_p);
	GEN_ASSERT(string_list == NULL);

	/* Do nothing if there is no type attached. */
	if (s_p -&gt; ctype == NULL) {
		goto done;
	}

	/* Ignore dummy variables. */
	if (
		s_p -&gt; n_type == KP_VOID_VAR ||
		s_p -&gt; n_type == KP_NULL_VAR ||
		s_p -&gt; n_type == KP_DOTS3 ||
		s_p -&gt; spell == NULL ||
		s_is_typedef(s_p) ||
		s_is_su_elem(s_p) ||
		s_is_formal(s_p)
	) {
		goto done;
	}

	/*
		Generate the defining label or pseudo-op.
		o an external pseudo-op for external variables.
		o a user-related label for statics and outer variables.
		o an internal label for auto variables.
	*/
	if (s_is_extern(s_p)) {

		if (s_p -&gt; vlist) {
			error_mess = "Can not initialize an external variable";
			goto error;
		}
		goto done;
	}
	else if (s_is_static(s_p)) {

		/* Output the label. */
		out_data_ulabel(s_p, DEFINE_THE_LABEL, DONT_EXPORT_THE_LABEL);
	}	
	else if (
		s_is_global(s_p) &amp;&amp;
		!(s_is_code(s_p) &amp;&amp; s_p -&gt; ctype &amp;&amp; s_p -&gt; ctype -&gt; tprim == FUNCTION_TYPE)
	) {
		
		/*
			Bug fix: 8/29/94:
			
			s_is_code is set even for pointers to functions,
			so make an additional test here.
		*/
		
		/* Output the externally visible label. */
		out_data_ulabel(s_p, DEFINE_THE_LABEL, EXPORT_THE_LABEL);
	}
	else if (s_is_auto(s_p)) {

		inode * expr_ip = NULL;

		/* Do nothing if there is no initializer. */
		if (s_p -&gt; vlist == NULL) {
			goto done;
		}

		/*
			Do not generate an initial data area for auto variables that
			are initialized with a single non-constant expression.

			See if the initializer consists of a single expression,
			which may be enclosed in braces.
			If so, set expr_ip to the single "expr" inode.
		*/
		if (
			s_p -&gt; vlist -&gt; itype == BRACE_ITYPE &amp;&amp;
			s_p -&gt; vlist -&gt; icount == 1 &amp;&amp;
			s_p -&gt; vlist -&gt; i_brace &amp;&amp;
			s_p -&gt; vlist -&gt; i_brace -&gt; itype == EXPR_ITYPE &amp;&amp;
			s_p -&gt; vlist -&gt; i_brace -&gt; inext == NULL
		) {
			expr_ip = s_p -&gt; vlist -&gt; i_brace;
		}
		else if (
			s_p -&gt; vlist &amp;&amp;
			s_p -&gt; vlist -&gt; itype == EXPR_ITYPE &amp;&amp;
			s_p -&gt; vlist -&gt; inext == NULL
		) {
			expr_ip = s_p -&gt; vlist;
		}

		/*
			See if expr_ip is a constant.
			If not, just exit: no initial data area will be generated.
		*/
		if (expr_ip) {

			enode * ep = expr_ip -&gt; i_expr;

			while (ep &amp;&amp; ep -&gt; n_type == CAST_TOK) {
				ep = op1_ptr(ep) -&gt; arg1;
			}
			GEN_ASSERT(ep);

			switch (ep -&gt; n_type) {

				/*
					A single constant.

					Generate an initial data area.
					This is an optimization because any type conversion
					is handled at compile time, not run time.
					However, type conversion for constants appearing inside
					expression is done at run time.
					For example,

						void f(int, float);
						f(1.0, 2);

					The conversion of 1.0 to int and 2 to float is done at run time.
				*/


			/*
				6/1/93:
				Generate an initial data area only if a type conversion is needed.
				This makes most initializers more efficient.
			*/
			case INT_TOK:

				if (s_p -&gt; ctype &amp;&amp; s_p -&gt; ctype -&gt; tprim != FLOAT_TYPE) {
					goto done;
				}
				else {
					new_clabel_macro(auto_lab);
					out_data_clabel(auto_lab,
						DEFINE_THE_LABEL, s_p -&gt; spell -&gt; spell_name);
					break;
				}

			case FLOAT_TOK:
				new_clabel_macro(auto_lab);
				out_data_clabel(auto_lab, DEFINE_THE_LABEL, s_p -&gt; spell -&gt; spell_name);
				break;

			case STRING_TOK:

				/*
					7/15/93
					Set string flag so that we know the auto initializer
					must load the reference, not a pointer to the reference.
				*/
				auto_string_flag = TRUE;

				new_clabel_macro(auto_lab);

				/* 7/21/93: There are no string references for auto string variables. */
				out_string_clabel(auto_lab, s_p -&gt; spell -&gt; spell_name);
				break;

			/*
				Bug fix: 5/3/93:
				We must generate code for address constants because
				their address may not be known until run time.
				For example:

					auto inode ip;
					auto inode * ip_tail = &amp;ip;
			*/
			case UAND_TOK:
			default:

				/*
					A non-constant expression.

					5/1/93:  This expression can contain constants!
					Generate the initial data area for them here.
					For example, we must generate the initial data are for "abc" in

						int n = sprintf("abc");

					The initial data area has not been generated yet,
					because dcl_initializer flag was TRUE in expr_cprim.
				*/
				TRACEPN(ftag, es("non-constant auto-initializer\n"));
				gen_init_tree(ep);
				goto done;
			}
		}
		else {

			/*
				After all this, we know we have a list of one or more constants.
				Generate and output a local label.
			*/
			new_clabel_macro(auto_lab);
			out_data_clabel(auto_lab, DEFINE_THE_LABEL, s_p -&gt; spell -&gt; spell_name);
		}
	}

	if (s_p -&gt; vlist == NULL) {

		/* Zero the entire initial data area if there are no initializers. */
		out_zero(s_p -&gt; ctype -&gt; tsize);
	}
	else {

		inode * ip = NULL;

		/* No errors yet. */
		init_err_flag = FALSE;

		/*
			Start off the process.
			Reserve space for all non-auto string variables (MAKE_STRING_REFS).
			There must be non-stack space reserved for the actual pointer.

			No additional space needs to be reserved for auto variables
			since that stack space has already been allocated.
		*/
		ip = gen_inner_data(s_p, s_p -&gt; vlist, s_p -&gt; ctype,
			auto_string_flag ? DONT_MAKE_STRING_REFS : MAKE_STRING_REFS);

		if (ip) {
			error_mess = "too many initializers";
			goto error;
		}

		/* 7/2/93: Generate the strings described by the string list. */
		{
			string_node * sp = NULL;
			for (sp = string_list; sp; sp = sp -&gt; next) {

				out_string_clabel(sp -&gt; string_label, NO_COMMENT);
				out_data_string(sp -&gt; string_def, ADD_TRAILING_ZERO, DONT_FORCE_DATA_AREA);
			}
			string_list = NULL;
		}
	}

	GEN_ASSERT(string_list == NULL);

	/* Replace an initializer for an auto variable by an AUTO_ITYPE inode. */
	if (auto_lab) {

		anode * lap = NULL;
		inode * auto_ip = NULL;

		/*
			Create the anode to hold the label of a block or string ref.
			For auto strings, we will load a *pointer* to the string.
			For all others, we will block move the constant itself.
		*/
		new_anode_macro(lap, sizeof(const_anode), IMMEDIATE_EA);
		const_anode_ptr(lap) -&gt; a_ckind =
			auto_string_flag ? STRING_REF_CKIND : BLOCK_CKIND;
		const_anode_ptr(lap) -&gt; a_length = POINTER_SIZE;
		const_anode_ptr(lap) -&gt; a_label = auto_lab;

		/* Create an "auto" inode. */
		new_xnode_macro(auto_ip, sizeof(inode));
		auto_ip -&gt; itype = AUTO_ITYPE;
		auto_ip -&gt; i_auto = lap;
		auto_ip -&gt; icount = s_p -&gt; ctype -&gt; tsize;

		/* Replace the initializer by the auto inode. */
		s_p -&gt; vlist = auto_ip;
	}

done:
	if (init_err_flag) {
		s_p -&gt; vlist = NULL;
	}

	STATX(ftag);
	return;

error:
	s_p -&gt; vlist = NULL;
	GEN_ASSERT(error_mess);
	delayed_error(s_p -&gt; p_line, es(error_mess));
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.706">@ Generate the initializer for a float, optionally preceeded by '+' or '-'.  Return FALSE if an error was seen.
@c

static bool
gen_init_float (enode * ep, tnode * t)
{
	FTAG("gen_init_float");
	char * def_string = NULL;
	STATB(ftag);
	ASSERT(t &amp;&amp; t -&gt; tprim == FLOAT_TYPE);
	
	/*
		Handle a unary plus or minus.
		As yet these don't get folded.  (They should).
	*/
	if (ep -&gt; n_type == FLOAT_TOK) {
		def_string = econst_defstr(ep);
	}
	else if (
		ep -&gt; n_type == UPLUS_TOK &amp;&amp;
		op1_ptr(ep) -&gt; arg1 &amp;&amp;
		op1_ptr(ep) -&gt; arg1 -&gt; n_type == FLOAT_TOK
	) {
		/* Just generate the inner constant. */
		ep = op1_ptr(ep) -&gt; arg1;
		def_string = econst_defstr(ep);
	}
	else if (
		ep -&gt; n_type == UMINUS_TOK &amp;&amp;
		op1_ptr(ep) -&gt; arg1 &amp;&amp;
		op1_ptr(ep) -&gt; arg1 -&gt; n_type == FLOAT_TOK
	) {
		ep = op1_ptr(ep) -&gt; arg1;

		/* Prepend a minus sign to the defining string. */
		if (*econst_defstr(ep) != '-') {
			new_cat2_macro(def_string, "-" , econst_defstr(ep),
				perm_life, perm_string_stats);
		}
	}
	else {
		def_string = NULL;
	}

	/*
		Initialize the variable based on the *variable's* type,
		not the previously declared type of the constant.
	*/
	if (def_string) {
	
		short ckind = 0;

		/* 1/1/95: The preferred size is double. */
		if (t_is_double(t)) {
			ckind = DOUBLE_CKIND;
		}
		else if (t_is_float(t)) {
			ckind = FLOAT_CKIND;
		}
		else {
			ASSERT(t_is_long_double(t));
			ckind = LONG_DOUBLE_CKIND;
		}

		out_data_float(econst_defstr(ep), ckind);
	}
	
	STATX(ftag);
	return def_string != NULL;
}
</t>
<t tx="ekr.20080529093004.707">@ Generate the initializer for a pointer.  Return FALSE if an error was seen.
@c

static bool
gen_init_pointer (snode * s_p, enode * ep, tnode * t, bool string_ref_flag)
{
	FTAG("gen_init_pointer");
	STATB(ftag);

	if (ep -&gt; n_type == STRING_TOK) {

		if (string_ref_flag) {

			/* 7/2/93: This code replaces gen_init_strings. */
			label_cnode * the_label = NULL;
			string_node * the_string_node = NULL;

			/* Get the string's label from its anode. */
			GEN_ASSERT(econst_anode(ep));

			the_label = const_anode_ptr(econst_anode(ep)) -&gt; a_label;

			/*
				Create a string_node describing the IDA for the string.
				(gen_init_data will create the IDA later using this string_node.)
			*/
			new_file_macro(the_string_node, string_node_stats);
			the_string_node -&gt; string_label = the_label;
			the_string_node -&gt; string_def = econst_defstr(ep);

			/* Add the string node to the string list. */
			lst_append_macro(the_string_node, string_list, string_node);

			/* Create an IDA containing a *pointer* to the actual string. */
			out_data_clabel_ref(the_label, DONT_PRINT_A_COMMENT, 0);
		}
		else {
			/* Output the string immediately. */
			out_data_string(econst_defstr(ep), ADD_TRAILING_ZERO, 
				s_is_static(s_p) ? FORCE_DATA_AREA : DONT_FORCE_DATA_AREA);
		}
	}
	else if (ep -&gt; n_type == ID_TOK) {

		/* Only names of arrays with static storage duration are valid. */
		out_data_address(var_enode_ptr(ep) -&gt; e_var);
	}
	else if (ep -&gt; n_type == INT_TOK) {
	
		/* Convert the constant to a pointer. */
		out_data_int (econst_long(ep), POINTER_SIZE);
	}
	else if (ep -&gt; n_type == UAND_TOK) {

		/*
			Handle expressions of the form:

			&amp;id
			&amp;array_name[constant]
			
			Bug fix: 7/14/94:
			The constant must be scaled by the sizeof of an array element.
			
			Bug fix: 8/24/94:
			Also handle &amp;struct . field
		*/
		register enode * arg1 = op1_ptr(ep) -&gt; arg1;

		if (arg1 == NULL) {
			goto bad_pointer_init;
		}
		else if (arg1 -&gt; n_type == ID_TOK) {
			out_data_address(var_enode_ptr(arg1) -&gt; e_var);
		}
		else if (op1_ptr(ep) -&gt; arg1 -&gt; n_type == ARRAY_TOK) {
			enode * arg11 = op2_ptr(arg1) -&gt; arg1;
			enode * arg12 = op2_ptr(arg1) -&gt; arg2;
			snode * s_p = NULL;
			long val = 0;

			if (arg11 == NULL || arg12 == NULL) {
				goto bad_pointer_init;
			}

			if (arg11 -&gt; n_type == ID_TOK &amp;&amp; arg12 -&gt; n_type == INT_TOK) {
			
				s_p = var_enode_ptr(arg11) -&gt; e_var;
				val = econst_long(arg12);
			}
			else if (arg12 -&gt; n_type == ID_TOK &amp;&amp; arg11 -&gt; n_type == INT_TOK) {
			
				s_p = var_enode_ptr(arg12) -&gt; e_var;
				val = econst_long(arg11);
			}
			else {
				goto bad_pointer_init;
			}
			
			/* 
				Bug fix 7/14/94:
				scale the constant by the size of each array element.
			*/
			ASSERT(
				s_p &amp;&amp;
				s_p -&gt; ctype &amp;&amp;
				s_p -&gt; ctype -&gt; tprim == ARRAY_TYPE &amp;&amp;
				s_p -&gt; ctype -&gt; ttype &amp;&amp;
				s_p -&gt; ctype -&gt; ttype -&gt; tsize
			);
			{
				long scale = s_p -&gt; ctype -&gt; ttype -&gt; tsize;
				out_data_offset (s_p, scale * val);
			}
		}
		else if (
			op1_ptr(ep) -&gt; arg1 -&gt; n_type == DOT_TOK ||
			op1_ptr(ep) -&gt; arg1 -&gt; n_type == ARROW_TOK
		) {
			/*
				We expect a list of fields, as in &amp; (s . f1 . f2)  or &amp; (s -&gt; f1 . f2)

				The expression tree looks like:
				
					ep:		&amp;
							 \
					arg1:  -&gt; or dot
							 /  \
						  arg11  arg12
						  
				The *type* of arg11 must be struct or pointer to struct.
				The following *form* of arg1 are all valid:
				
					((struct s *) constant) -&gt; f;
					s_ptr -&gt; f;
					s .f;
		
				arg12 must be a field name or a list of one or a dot list.
				Examples:
				
					((struct s *) constant) -&gt; f1 . f2;
					s_ptr -&gt; f1 . f2;
					s . f1 . f2;
			*/
		
			/* New code: 8/24/94. */
			enode * arg11 = op2_ptr(arg1) -&gt; arg1;
			enode * arg12 = op2_ptr(arg1) -&gt; arg2;
			ulong field_offset = 0;
			snode * first_sp = s_p;
			snode * s_p = NULL;
			snode * parent = NULL;
			token the_tok = op1_ptr(ep) -&gt; arg1 -&gt; n_type;
		
			/*
				Make sure the *type* of the field is pointer to struct.
				The only reliable way to do this is to look at the type of arg11
				because the type of arg1 or ep may have been changed by a cast.
			*/
			/* Make sure we have a struct or a union. */
			if (arg11 == NULL || arg12 == NULL || arg11 -&gt; e_ctype == NULL) {
				goto bad_pointer_init;
			}
			
			if (the_tok == ARROW_TOK) {
			
				/* We expect an expression of type pointer to a struct or union. */
				if (
					arg11 -&gt; e_ctype -&gt; tprim != POINTER_TYPE ||
					arg11 -&gt; e_ctype -&gt; ttype == NULL ||
					(
						arg11 -&gt; e_ctype -&gt; ttype -&gt; tprim != STRUCT_TYPE &amp;&amp;
						arg11 -&gt; e_ctype -&gt; ttype -&gt; tprim != UNION_TYPE
					)
				) {
					goto bad_pointer_init;
				}
				parent = (snode *) (arg11 -&gt; e_ctype -&gt; ttype -&gt; ttype);
			}
			else {
			
				/* We expect a struct or union. */
				if (
					arg11 -&gt; e_ctype -&gt; tprim != STRUCT_TYPE &amp;&amp;
					arg11 -&gt; e_ctype -&gt; tprim != UNION_TYPE
				) {
					goto bad_pointer_init;
				}
				parent = (snode *) (arg11 -&gt; e_ctype -&gt; ttype);
			}
			
			/* Move done a sequence of dot operators. */
			#if 0 // not tested
				while (arg12 -&gt; n_type == DOT_TOK) {
				
					enode * arg11 = op2_ptr(arg12) -&gt; arg1;
					enode * arg12 = op2_ptr(arg12) -&gt; arg2;
					
					if (
						arg11 -&gt; n_type != ID_TOK ||
						arg11 -&gt; e_ctype == NULL ||
						(
							arg11 -&gt; e_ctype -&gt; tprim != STRUCT_TYPE &amp;&amp;
							arg11 -&gt; e_ctype -&gt; tprim != UNION_TYPE
						)
					) {
						goto bad_pointer_init;
					}
					
					/* Look up the field name. */
					s_p = st_lookup_field(var_enode_ptr(arg11) -&gt; e_var -&gt; spell, s_p);
					if (s_p == NULL) {
						goto bad_pointer_init;
					}
					
					/* Point s_p at the parent type of the first field. */
					if (s_p &amp;&amp; s_p -&gt; ctype &amp;&amp; s_p -&gt; ctype -&gt; ttype) {
					
						/*
							Remember the kludge:
							ttype points to an *snode* for structs, not a tnode.
						*/
						parent = (snode *) (s_p -&gt; ctype -&gt; ttype);
					}
					else {
						goto bad_pointer_init;
					}
					
					/* All is well. */
					field_offset += s_p -&gt; offset;
					arg11 = arg12;
				}
			#endif
			
			/*
				The type of the field whose address is being taken does *not* matter.
				We already know that the field *being initialized* has type pointer.
			*/
			
			/* Add the offset of the last field. */
			{
				/* Look up the field name. */
				s_p = st_lookup_field(var_enode_ptr(arg12) -&gt; e_var -&gt; spell, parent);
				if (s_p == NULL) {
					goto bad_pointer_init;
				}
				field_offset += s_p -&gt; offset;
			}
		
			/* Add the offset of the field to offset of the address of the variable. */
			if (first_sp) {
				if (first_sp -&gt; sarg) {
					out_data_offset (first_sp, field_offset);
				}

				#if 0 /* This looks too risky to me.  I don't think it is needed. */
					else if (first_sp -&gt; spell &amp;&amp; first_sp -&gt; spell -&gt; spell_name) {
						out_data_name_offset(first_sp -&gt; spell -&gt; spell_name, field_offset);
					}
				#endif

				else {
					goto bad_pointer_init;
				}
			}
			else if (arg11 -&gt; n_type == INT_TOK) {
			
				/* Add the offset to the constant. */
				out_data_int (econst_long(arg11) + field_offset, POINTER_SIZE);
			}
			else {
				/* Only an integer can reasonably be cast to a pointer to struct. */
				goto bad_pointer_init;
			}
		}
		else {
			goto bad_pointer_init;
		}
	}
	else if (ep -&gt; n_type == PLUS_TOK || ep -&gt; n_type == MINUS_TOK) {

		register enode * arg1 = op2_ptr(ep) -&gt; arg1;
		register enode * arg2 = op2_ptr(ep) -&gt; arg2;
		long val = 0;
		snode * s_p = NULL;

		if (arg1 == NULL || arg2 == NULL) {
			goto bad_pointer_init;
		}

		/* Allow initializers of the form x +- constant or constant + x. */
		if (arg1 -&gt; n_type == ID_TOK &amp;&amp; arg2 -&gt; n_type == INT_TOK) {
		
			/* scale the constant by the size of what the pointer points to. */
			s_p = var_enode_ptr(arg1) -&gt; e_var;
			val = econst_long(arg2);
		}
		else if (
			ep -&gt; n_type == PLUS_TOK &amp;&amp;
			arg1 -&gt; n_type == INT_TOK &amp;&amp; arg2 -&gt; n_type == ID_TOK
		) {
			/* scale the constant by the size of what the pointer points to. */
			s_p = var_enode_ptr(arg2) -&gt; e_var;
			val = econst_long(arg1);
		}
		else {
			goto bad_pointer_init;
		}
		
		/*
			Bug fix: 7/14/94 scale the value.
			Bug fix: 8/25/94 scale the value by what ***t*** points to, not s_p.
		*/
		ASSERT(t -&gt; ttype &amp;&amp; t -&gt; ttype -&gt; tsize);
		val = val * (t -&gt; ttype -&gt; tsize);

		/* Assume a positive offset. */
		if (ep -&gt; n_type == MINUS_TOK) {
			val = -val;
		}

		/* Output the initializer. */
		out_data_offset(s_p, val);
	}
	else {
		goto bad_pointer_init;
	}
	
	STATX(ftag);
	return TRUE;
	
bad_pointer_init:

	/* The caller will issue an error message. */
	STATX(ftag);
	return FALSE;
}
</t>
<t tx="ekr.20080529093004.708">@ Generate an initial data area for all simple constants in an expression tree.  This routine is called to generate the constants in a non-constant auto initializer. For example, this routine generates the initial data area containing "abc" in,  int n = sprintf("abc");  There is no need to do type conversion of constants here as in gen_init_data because such conversions are handled at run-time. For example,  extern int f(int, float);  auto int a = f(1.0, 2);  The run-time code that is generated for f(1.0, 2) handles the conversion of the floating constant 1.0 to int and the integer constant 2 to float.
@c

static void
gen_init_tree(enode * ep)
{
	FTAG("gen_init_tree");
	register int op = 0;
	STATB(ftag);

	if (ep == NULL) {
		goto done;
	}

	op = ep -&gt; n_type;

	if (op == CONS_TOK) {

		gen_init_tree(cons_ptr(ep) -&gt; n_next);
		gen_init_tree(cons_ptr(ep) -&gt; cons_car);
	}
	else if (op == FLOAT_TOK) {

		const_anode * cap = const_anode_ptr(econst_anode(ep));

		out_data_clabel(cap -&gt; a_label, DONT_DEFINE_THE_LABEL, NO_COMMENT);
		out_data_float(econst_defstr(ep), cap -&gt; a_ckind);
	}
	else if (op == STRING_TOK) {

		const_anode * cap = const_anode_ptr(econst_anode(ep));
		out_string_clabel(cap -&gt; a_label, NO_COMMENT);
		out_data_string(econst_defstr(ep), ADD_TRAILING_ZERO, DONT_FORCE_DATA_AREA);
	}
	else if (is_unop(op)) {

		gen_init_tree(op1_ptr(ep) -&gt; arg1);
	}
	else if (is_binop(op)) {

		gen_init_tree(op2_ptr(ep) -&gt; arg1);
		gen_init_tree(op2_ptr(ep) -&gt; arg2);
	}
	else if (op == QUESTION_TOK) {

		gen_init_tree(op3_ptr(ep) -&gt; arg1);
		gen_init_tree(op3_ptr(ep) -&gt; arg2);
		gen_init_tree(op3_ptr(ep) -&gt; arg3);
	}
	else {

		/* Do nothing. */
	}

done:
	TICKX(ftag);
}
</t>
<t tx="ekr.20080529093004.709">@ Pad an initializer list based on the type t. Return a pointer to the next item on the initializer list.
These macros hide some details associated with optional braces. o At the inner levels, only brace lists can have too many initializers. o The next inode of a brace-enclose list is the node following the closing brace,  regardless of how many items the brace list contains.
@c

#define check_limit_macro(ip, limit)\
if (brace_flag &amp;&amp; ip -&gt; icount &gt; limit) {\
	TRACEPN(ftag,\
		es("brace count: "); eulong(ip -&gt; icount); ecs();\
		es("limit: "); eulong(limit); enl());\
	goto too_many;\
}

#define enter_brace_macro(ip, ret_ip) \
if (brace_flag) {\
	/* Point at the inode following the brace list. */\
	ret_ip = ip -&gt; inext;\
	/* Move into the brace list. */\
	ip = ip -&gt; i_brace;\
}

static inode *
gen_inner_data(snode * s_p, inode * ip, tnode * t, bool string_ref_flag)
{
FTAG("gen_inner_data");
FTAGV("gen_inner_data_v");
register inode * ret_ip = NULL;
register ulong count = 0;
bool brace_flag = ip &amp;&amp; ip -&gt; itype == BRACE_ITYPE;
char * error_mess = NULL;
TRACEPB(ftag,
	enl();
	enl(); etab(); es("s_p: "); esnode(s_p);
	enl(); etab(); es("ip:  ");
	enl(); einode(ip);
	enl(); etab(); es("t:   "); etnode(t);
	ecnls(2));

GEN_ASSERT(t);

/* Zero the entire object if there are no initializers. */
if (ip == NULL) {
	out_zero(t -&gt; tsize);
	goto done;
}

switch (t -&gt; tprim) {

case ARRAY_TYPE:

	GEN_ASSERT(t -&gt; tdim &amp;&amp; t -&gt; ttype &amp;&amp; t -&gt; ttype -&gt; tsize);
	GEN_ASSERT(t -&gt; tsize == t -&gt; tdim * t -&gt; ttype -&gt; tsize);

	/* We could have an array of aggregates so check_limit_macro won't work here. */
	#if 0
		check_limit_macro(ip, t -&gt; tdim);
	#endif

	/* Move into the brace list if needed. */
	enter_brace_macro(ip, ret_ip);

	/* Check for an array of characters initialized by a string. */
	if (
		t -&gt; ttype &amp;&amp;
		ip -&gt; itype == EXPR_ITYPE &amp;&amp;
		ip -&gt; i_expr -&gt; n_type == STRING_TOK
	) {

		if (
			t -&gt; ttype -&gt; tprim == INT_TYPE &amp;&amp;
			t -&gt; ttype -&gt; tsize == CHAR_SIZE
		) {
			/* An array of characters. */
			char * the_string = econst_defstr(ip -&gt; i_expr);
			size_t length = strlen(the_string);

			if (length &gt; t -&gt; tdim) {
				goto too_many;
			}

			/*
				The standard allows initializers such as:

					char * s[3] = "abc";

				This will not contain the trailing zero byte!
			*/
			if (length == t -&gt; tdim) {
				warning(es("initializer string does not contain trailing zero"));
			}

			out_data_string(the_string, length &lt; t -&gt; tdim,
				s_is_static(s_p) ? FORCE_DATA_AREA : DONT_FORCE_DATA_AREA);
			if (!brace_flag) {
				ret_ip = ip -&gt; inext;
			}
			goto done;
		}
	}

	/*
		Scan down the list of initializers, counting them and
		generating constants via recursive calls to this function.
	*/
	while(ip) {

		/* Generate the constant and point ip at the next element. */
		ip = gen_inner_data(s_p, ip, t -&gt; ttype, MAKE_STRING_REFS);
		if (init_err_flag) {
			goto error;
		}

		if (++count == t -&gt; tdim) {

			/* No padding is needed. */
			/* 7/2/93 */
			if (brace_flag &amp;&amp; ip) {
				goto too_many;
			}
			if (!brace_flag) {
				ret_ip = ip;
			}
			goto done;
		}
	}

	/* Padding is required. */
	out_zero(t -&gt; ttype -&gt; tsize * (t -&gt; tdim - count));

	/* 7/2/93 */
	if (brace_flag &amp;&amp; ip) {
		goto too_many;
	}
	if (!brace_flag) {
		ret_ip = NULL;
	}
	goto done;

case FLOAT_TYPE:

	/* Move into the brace list if needed. */
	check_limit_macro(ip, 1);
	enter_brace_macro(ip, ret_ip);

	if (ip == NULL || ip -&gt; itype != EXPR_ITYPE) {
		goto bad_init;
	}

	{
		enode * ep = ip -&gt; i_expr;

		if (ep == NULL) {
			goto bad_init;
		}
		
		if (ep -&gt; n_type == CAST_TOK &amp;&amp; ep -&gt; e_ctype -&gt; tprim == FLOAT_TYPE) {

			/*
				We have an explicit cast to float.
				Just substitue the argument of the cast and go on.
			*/
			ep = op1_ptr(ep) -&gt; arg1;
			GEN_ASSERT(ep);
		}

		if (ep -&gt; n_type == INT_TOK) {

			/* Convert the int constant to a float constant. */
			int kind = NO_CKIND;
			if (t_is_double(t)) {
				kind = DOUBLE_CKIND;
			}
			else if (t_is_float(t)) {
				kind = FLOAT_CKIND;
			}
			else {
				GEN_ASSERT(t_is_long_double(t));
				kind = LONG_DOUBLE_CKIND;
			}
			out_data_i2f(econst_long(ep), kind);
		}
		else if (
			ep -&gt; n_type == FLOAT_TOK ||
			ep -&gt; n_type == UPLUS_TOK ||
			ep -&gt; n_type == UMINUS_TOK
		) {
		
			/* A float constant. */
			if (gen_init_float (ep, t) == FALSE) {
				goto bad_init;
			}
		}
		else {
			error_mess = "float initializer expected";
			goto error;
		}
	}

	if (!brace_flag) {
		ret_ip = ip -&gt; inext;
	}
	goto done;

case INT_TYPE:

	/* Move into the brace list if needed. */
	check_limit_macro(ip, 1);
	enter_brace_macro(ip, ret_ip);

	if (ip == NULL || ip -&gt; itype != EXPR_ITYPE) {
		goto bad_init;
	}

	{
		register enode * ep = ip -&gt; i_expr;
		bool cast_flag = FALSE;

		if (ep == NULL) {
			goto bad_init;
		}

		if (ep -&gt; n_type == CAST_TOK &amp;&amp; ep -&gt; e_ctype -&gt; tprim == INT_TYPE) {

			/*
				We have an explicit cast to int.
				Just remember that we saw it it and go on.
			*/
			ep = op1_ptr(ep) -&gt; arg1;
			cast_flag = TRUE;
			GEN_ASSERT(ep);
		}

		if (ep -&gt; n_type == INT_TOK) {

			/* An integer constant. */
			out_data_int(econst_long(ep), t -&gt; tsize);
		}
		else if (ep -&gt; n_type == FLOAT_TOK) {

			/* Convert the floating constant to an integer. */
			out_data_f2i(econst_defstr(ep), t);
		}
		else if (t -&gt; tprim == INT_TYPE &amp;&amp; t -&gt; tsize == CHAR_SIZE) {
			error_mess = "character initializer expected";
			goto error;
		}
		else if (cast_flag) {
		
			/* We have a cast of a non-int to an int. */
			
			if (ep -&gt; e_ctype &amp;&amp; ep -&gt; e_ctype -&gt; tprim == POINTER_TYPE) {
				if (gen_init_pointer (s_p, ep, t, string_ref_flag) == FALSE) {
					goto bad_init;
				}
			}
			else if (ep -&gt; n_type == FLOAT_TOK) {

				/* Convert the floating constant to an integer. */
				out_data_f2i(econst_defstr(ep), t);
			}
			else {
				goto bad_init;
			}
		}
		else {
			error_mess = "integer initializer expected";
			goto error;
		}
	}
	if (!brace_flag) {
		ret_ip = ip -&gt; inext;
	}
	goto done;

/*

	Section 3.4 Constant expressions.

	"An address constant is a pointer to an lvalue designating an object
	of static storage duration or to a function designator;
	it shall be created explicitly, using the unary &amp; operator,
	or implicitly by the use of an expression of array or function type.
	The array subscript [] and member access . and -&gt; operators,
	the address &amp; and indirection operators,
	and pointer casts may be used in the creation of an address constant,
	but the value of the object shall not be accessed by use of these
	operators."

	11/2/93: One can imagine a huge variety of initialization expressions.
	Until I can devise more general code, initializers for pointers will
	be limited to the following forms.

		strings
		identifiers
		the integer constant 0
		id + integer constant
		id - integer constant
		&amp;id
		&amp;array[integer constant]
*/

case POINTER_TYPE:
{
	register enode * ep = NULL;

	/* Move into the brace list if needed. */
	check_limit_macro(ip, 1);
	enter_brace_macro(ip, ret_ip);

	if (ip == NULL || ip -&gt; itype != EXPR_ITYPE) {
		goto bad_init;
	}

	ep = ip -&gt; i_expr;

	if (
		ep == NULL ||
		gen_init_pointer (s_p, ep, t, string_ref_flag) == FALSE
	) {
		goto bad_init;
	}

	if (!brace_flag) {
		ret_ip = ip -&gt; inext;
	}
	goto done;
}

case STRUCT_TYPE:
{
	snode * parent = snode_ptr(t -&gt; ttype);
	snode * field = NULL;

	TRACEPN(ftag, etnode_full(t); enl());

	if (parent == NULL) {
		error_mess = "structure has no parent";
		goto error;
	}

	/*
		Move into the brace list if needed.
		Don't check for too many initializers: fields may have subfields.
	*/
	enter_brace_macro(ip, ret_ip);

	/* Generate initializers for each field. */
	for (field = parent -&gt; dcls; field; field = field -&gt; n_next) {

		if (field -&gt; ctype == NULL) {
			error_mess = "field has no type";
			goto error;
		}

		/* The MPW assembler handles alignment of data automatically. */
		if (ip) {

			/* Generate the initializer for the field. */
			ip = gen_inner_data(s_p, ip, field -&gt; ctype, MAKE_STRING_REFS);
			if (init_err_flag) {
				goto error;
			}
		}
		else {

			/* Pad the field. */
			out_zero(field -&gt; ctype -&gt; tsize);
		}
	}

	if (brace_flag &amp;&amp; ip) {
		goto too_many;
	}

	if (!brace_flag) {
		ret_ip = ip;
	}
	goto done;
}

case UNION_TYPE:
{
	snode * parent = snode_ptr(t -&gt; ttype);
	snode * field = NULL;

	TRACEPN(ftag, etnode_full(t); enl());

	if (parent == NULL) {
		error_mess = "union has no parent";
		goto error;
	}
	field = parent -&gt; dcls;

	if (field -&gt; ctype == NULL) {
		error_mess = "first field of union has no type";
		goto error;
	}

	/*
		Move into the brace list if needed.
		Don't check for too many initializers:
		the first field of the union may have subfields.
	*/
	enter_brace_macro(ip, ret_ip);

	/* Generate the initializer for *only* the first element of the union. */
	ip = gen_inner_data(s_p, ip, field -&gt; ctype, MAKE_STRING_REFS);
	if (init_err_flag) {
		goto error;
	}
	if (!brace_flag) {
		ret_ip = ip;
	}
	goto done;
}

default:
	goto bad_init;
}

/* We should never fall through. */
goto done;

too_many:
error_mess = "too many initializers";
goto error;

bad_init:
error_mess = "bad initializer";
goto error;

error:
GEN_ASSERT(init_err_flag || error_mess);
GEN_ASSERT(s_p);
if (error_mess) {
	delayed_error(s_p -&gt; p_line,
		if (s_p -&gt; spell) {
			es(s_p -&gt; spell -&gt; spell_name);
			es(": ");
		}
		es(error_mess);
	);
}
init_err_flag = TRUE;
ret_ip = NULL;
goto done;

done:
TRACEPN(ftagv, eret(); enl(); einode(ret_ip); enl());
STATX(ftag);
return ret_ip;
}
</t>
<t tx="ekr.20080529093004.710">/*
	CC2: Code generation for boolean expressions.

	source: CCgbool.c
	started: January 21, 1986
	version:
		June 6, 1994.
			Bug fix to gen_nz:  strings are *always* true constants in comparisions.
		July 19, 1993.
			Replaced ASSERT and ASSERT_TRACE by GEN_ASSERT and GEN_ASSERT_TRACE.
		July 12, 1993.
			Removed float case in gen_cmp.  (It is handled in gen_branch.)
		July 8, 1993.
			Bug fix in gen_b1: call gf_relop if either argument is a float.
		May 27, 1993.
			Bug fix: Do not generate branch on Q_BRN op code.
		March 4, 1993.
			Bug fix to gen_nz so that pointers are handled properly.
		January 14, 1993.
			Call gf_relop from gen_cmp.
		December 30, 1992.
			gen_cmp calls g_cmp.
		November 6, 1992.
			Defined diop_node here instead of CCnodes.h.
		November 3, 1992.
			Separate file created from g2.c.
			Removed must_pop parameter from gen_b1.
			Simplified code by assuming that reg spills do not affect the stack.
*/

&lt;&lt; CCgbool #includes &gt;&gt;
&lt;&lt; CCgbool declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.711">#include "CC.h"

#include "CCdump.h"
#include "CCgen.h"
#include "CCmem.h"
#include "CCregs.h"
</t>
<t tx="ekr.20080529093004.712">/*
	Op node a node used to hold TRUE/FALSE return values.
*/
typedef struct diop_node_struct diop_node;

static struct diop_node_struct {
	int o_true;
	int o_false;
};

/*
	Define data used only by this module.
*/
static diop_node ops_true  = {X_BRA, Q_BRN};
static diop_node ops_false = {Q_BRN, X_BRA};
static diop_node ops_cond  = {X_BNE, X_BEQ};

/*
	Function prototypes for internal routines.
*/
static void	gen_b1	(enode *ep, label_cnode *true_lab,label_cnode *false_lab);
static diop_node *	gen_branch
	(
		op2_enode *p,
		int  utcode, int  tcode, int  ufcode, int  fcode,
		int xutcode, int xtcode, int xufcode, int xfcode
	);
static bool			gen_cmp	(op2_enode *p);
static diop_node *	gen_nz	(enode *p);
</t>
<t tx="ekr.20080529093004.713">@ Generate code to evaluate a boolean expression, ep.  Generate a to branch to true_lab if ep evaluates to TRUE at run time. Generate a to branch to false_lab if ep evaluates to FALSE at run time.  The value of either true_lab or false_lab (but not both) may be FALL_THROUGH, indicating that the generated code should fall through to then next instruction.  gen_b1 is called by gexp.c to generate the actual value of relation operators in those contexts where the value is actually used.
@c

static void
gen_b1(enode *ep, label_cnode *true_lab, label_cnode *false_lab)
{
	FTAG("gen_b1");

	register int op = 0;
	diop_node *diop_p = NULL;

	if (ep == NULL) {
		return;
	}

	TRACEPB(ftag,
		eenode(ep); ecs();
		ecnode( (cnode *) true_lab); ecs();
		ecnode( (cnode *) false_lab);
		enl());

	op = ep -&gt; n_type;

	switch(op) {

	case NOT_TOK:

		/* Just exchange labels. */
		gen_b1(op2_ptr(ep) -&gt; arg1, false_lab, true_lab);
		goto done;

	case LAND_TOK:

		/* Logical "and" fails directly to false_lab. */
		TRACEPN(ftag, es("logical and\n"));

		if (false_lab == FALL_THROUGH) {

			label_cnode *imm_lab = NULL;
			new_clabel_macro(imm_lab);
			gen_b1(op2_ptr(ep) -&gt; arg1, FALL_THROUGH, imm_lab);

			/* This is the FALL_THROUGH point for the statment above. */
			gen_b1(op2_ptr(ep) -&gt; arg2, true_lab, FALL_THROUGH);
			c_clabel(imm_lab);
		}
		else {
			gen_b1(op2_ptr(ep) -&gt; arg1, FALL_THROUGH, false_lab);

			/* This is the FALL_THROUGH point for the statment above. */
			gen_b1(op2_ptr(ep) -&gt; arg2, true_lab, false_lab);
		}
		goto done;

	case LOR_TOK:

		/* Logical "or" succeeds directly to true_lab */
		TRACEPN(ftag, es("logical or\n"));

		if (true_lab == FALL_THROUGH) {

			label_cnode *imm_lab = NULL;
			new_clabel_macro(imm_lab);
			gen_b1(op2_ptr(ep) -&gt; arg1, imm_lab, FALL_THROUGH);

			/* This is the FALL_THROUGH point for the statment above. */
			gen_b1(op2_ptr(ep) -&gt; arg2, true_lab, false_lab);
			c_clabel(imm_lab);
		}
		else {

			gen_b1(op2_ptr(ep) -&gt; arg1, true_lab, FALL_THROUGH);

			/* This is the FALL_THROUGH point for the statment above. */
			gen_b1(op2_ptr(ep) -&gt; arg2, true_lab, false_lab);
		}
		goto done;
	}

	TRACEPN(ftag, es("arithmetical op: "); etoknum(op); enl());

	/*
		Bug fix: 7/8/93.
		Relational operators operating on floats must be handled separately.
	*/
	if (
		is_binop(ep -&gt; n_type) &amp;&amp;
		op2_ptr(ep) -&gt; arg1 -&gt; e_ctype -&gt; tprim == FLOAT_TYPE
	) {

		/*
			Generate code for the floating test.
			Register d0 contains the result, either 0 or 1.
		*/
		anode * d0_anode = gf_relop(op2_ptr(ep));

		c_1len(X_TST, d0_anode, 1);
		free_temp(d0_anode);
		diop_p = &amp;ops_cond;
		goto generate_branch;
	}

	/* These generate arithmetical code. */

	switch (op) {

		/*
			The true/false alternatives are mutually exclusive
			and exactly cover the comparision possibilities
			(which are of an underlying ternary nature).
			They represent what happens if you exchange true_lab
			with false_lab.

			The exchange alternatives represent what happens
			if you exchange the operands of the relop.
		*/

	case EQUAL_TOK:
		diop_p = gen_branch(op2_ptr(ep),
			X_BEQ, X_BEQ, X_BNE, X_BNE,		/* &lt;-&gt; true/false */
			X_BEQ, X_BEQ, X_BNE, X_BNE);	/* exchange */
		break;

	case NE_TOK:
		diop_p = gen_branch(op2_ptr(ep),
			X_BNE, X_BNE, X_BEQ, X_BEQ,
			X_BNE, X_BNE, X_BEQ, X_BEQ);
		break;

	case LT_TOK:
		diop_p = gen_branch(op2_ptr(ep),
			X_BLO, X_BLT, X_BHS, X_BGE,
			X_BHI, X_BGT, X_BLS, X_BLE);
		break;

	case GT_TOK:
		diop_p = gen_branch(op2_ptr(ep),
			X_BHI, X_BGT, X_BLS, X_BLE,		/* &lt;-&gt; true/false */
			X_BLO, X_BLT, X_BHS, X_BGE);	/* exchange */
		break;

	case LE_TOK:
		diop_p = gen_branch(op2_ptr(ep),
			X_BLS, X_BLE, X_BHI, X_BGT,
			X_BHS, X_BGE, X_BLO, X_BLT);
		break;

	case GE_TOK:
		diop_p = gen_branch(op2_ptr(ep),
			X_BHS, X_BGE, X_BLO, X_BLT,
			X_BLS, X_BLE, X_BHI, X_BGT);
		break;

	default:
		/* Arithmetic op or ID_TOK */
		diop_p = gen_nz(ep);
	}

	/*
		Generate the actual branch.
		6/9/93:
			The test for Q_BRN probably is not necessary.
			It arose originally because of the bug fixed today in gen_nz.
	*/
generate_branch:
	if (true_lab != FALL_THROUGH &amp;&amp; diop_p -&gt; o_true != Q_BRN) {
		c_1clab(diop_p -&gt; o_true, true_lab);
	}

	if (false_lab != FALL_THROUGH &amp;&amp; diop_p -&gt; o_false != Q_BRN) {
		c_1clab(diop_p -&gt; o_false, false_lab);
	}

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.714">@ Generate code for an outer boolean expression.  We must *pre-spill* all registers before generating such an expression! This step is essential--otherwise different branches of the boolean expression might spill different registers in the environment. There would then be no way to know how to access the (potentially) spilled registers.  This is a very subtle point. Usually there will not be any registers to spill because the environment of a boolean expression is empty. Indeed, pre-spilling will only be needed in cases such as:  a + (b || c);  where expressions a, b and c are complex enough to require one or more spills.
@c

void
gen_bool(enode *ep, label_cnode *true_lab, label_cnode *false_lab)
{
	FTAG("gen_bool");
	STATB(ftag);

	reg_spill_all();
	gen_b1(ep, true_lab, false_lab);

	/* All registers had better be free here. */
	GEN_ASSERT_TRACE(
		reg_nd_free + reg_nd_user == D_TEMP_TOTAL,
		es("reg_nd_free: "); eint(reg_nd_free);
		es(" reg_nd_user: "); eint(reg_nd_user);
		es(" D_TEMP_TOTAL: "); eint(D_TEMP_TOTAL);
	);
	GEN_ASSERT_TRACE(reg_na_free + reg_na_user == A_TEMP_TOTAL,
		es("reg_na_free: "); eint(reg_na_free);
		es(" reg_na_user: "); eint(reg_na_user);
		es(" A_TEMP_TOTAL: "); eint(A_TEMP_TOTAL);
 	);
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.715">@ Evaluate comparison followed by a branch.  This code is really a piece of gen_b1 and shouldn't be used elsewhere.
@c

static diop_node *
gen_branch(
	op2_enode *op2_p,
	int  utcode, int  tcode, int  ufcode, int  fcode,
	int xutcode, int xtcode, int xufcode, int xfcode)
{
	FTAG("gen_branch");
	register tnode *t = NULL;
	static diop_node diop_p;
	TRACEPB(ftag,
		elist(
			eenode( (enode *) op2_p); enl();
			es(tok_name( utcode)); ecs();
			es(tok_name(  tcode)); ecs();
			es(tok_name( ufcode)); ecs();
			es(tok_name(  fcode)); ecs(); enl();
			es(tok_name(xutcode)); ecs();
			es(tok_name( xtcode)); ecs();
			es(tok_name(xufcode)); ecs();
			es(tok_name( xfcode)); ecs()));


	/* Bug fix: 7/8/93: relops between floats must be handled elsewhere. */
	t = op2_p -&gt; arg1 -&gt; e_ctype;

	GEN_ASSERT_TRACE(t &amp;&amp; t -&gt; tprim != FLOAT_TYPE, etnode(t));

	if (t_is_unsigned(t)) {

		/* Unsigned pairs. */

		if (gen_cmp(op2_p)) {

			/* Operands in reverse order. */
			diop_p . o_true  = xutcode;	/* exchange */
			diop_p . o_false = xufcode;
		}
		else {

			diop_p . o_true  = utcode;
			diop_p . o_false = ufcode;
		}
	}
	else {

		/* Signed pairs. */

		if (gen_cmp(op2_p)) {

			/* Operands in reverse order. */
			diop_p . o_true  = xtcode;	/* exchange */
			diop_p . o_false = xfcode;
		}
		else {
			diop_p . o_true  = tcode;
			diop_p . o_false = fcode;
		}
	}

	TRACEPX(ftag, eret();
		es(tok_name(diop_p.o_true)); ecs();
		es(tok_name(diop_p.o_false)); enl());

	return &amp;diop_p;
}
</t>
<t tx="ekr.20080529093004.716">@ Generate code to compare the arguments of op2_p. Return TRUE if the order of the compare was reversed from "normal order."
@c

static bool
gen_cmp(op2_enode *op2_p)
{
	FTAG("gen_cmp");
	bool switch_flag = FALSE;
	anode * ap1 = NULL;
	anode * ap2 = NULL;
	STATB(ftag);

	GEN_ASSERT(op2_p -&gt; e_ctype);

	ap1 = gen_e1(op2_p -&gt; arg1);
	ap2 = gen_e1(op2_p -&gt; arg2);

	/* 7/12/93: relops between floats are handled in gen_branch. */
	GEN_ASSERT(op2_p -&gt; e_ctype -&gt; tprim == INT_TYPE);

	/* Invert the switch flag so we generate code in same order as Think C. */
	switch_flag = !g_cmp(ap1, ap2);

	TRACEPX(ftag, eret(); ebool(switch_flag); ecnl());
	return switch_flag;
}
</t>
<t tx="ekr.20080529093004.717">@ Test for nonzero ep.  If the result is a constant, return a suitable BRA/BRN pair for the ensuing code generation to use. Otherwise generate an instruction to set the flags and return a BNE/BEQ pair for the ensuing code generation to use.  The idea is to present the peephole with unconditional branches as much as possible.
@c

static diop_node *
gen_nz(enode *ep)
{
	FTAG("gen_nz");
	anode * ap1 = NULL;
	int mlength = c_e2mlen(ep);
	STATB(ftag);
	GEN_ASSERT(ep &amp;&amp; ep -&gt; e_ctype);

	/* Generate code for the argument. */
	ap1 = gen_e1(ep);

	if (ep -&gt; e_ctype -&gt; tprim == FLOAT_TYPE) {

		/* The library routine returns 1 in d0 if the float is non-zero. */
		anode *test_ap = gf_call_nz(ep, ap1);
		c_1len(X_TST, test_ap, 1);
		free_temp(test_ap);

		STATX(ftag);
		return &amp;ops_cond;
	}

	if (ap1 -&gt; n_type == IMMEDIATE_EA) {

		diop_node * result = NULL;

		/*
			4/12/93: compute the result *before* freeing ap1.
			6/9/93:  ap1 is an const_anode, not a const_enode!!
		*/
		if (const_anode_ptr(ap1) -&gt; a_ckind == LONG_CKIND) {
			result = (const_anode_ptr(ap1) -&gt; a_long) ? &amp;ops_true : &amp;ops_false;
		}
		else {
			/*
				Bug fix: 6/6/94:
				Strings are *always* true in comparisons because
				their address is never NULL.
			*/
			result = &amp;ops_true;
		}

		free_temp(ap1);
		STATX(ftag);
		return result;
	}
	else {

		/*
			This code may be redundant, because, for example,
			the process of loading a primitive may set flags.
			If so, an arithmetic peephole can eliminate it.
		*/
		if (a_is_areg(ap1)) {
			c_2len(X_CMPA, zero_anode, ap1, mlength);
		}
		else {
			c_1len(X_TST, ap1, mlength);
		}
		free_temp(ap1);

		STATX(ftag);
		return &amp;ops_cond;
	}
}
</t>
<t tx="ekr.20080529093004.718">/*
	CC2: global variables and initialization routines for the code generators.

	source:  CCgen.c
	started: November 16, 1992.
	version:
		January 6, 1995.
			Added gen_current_base.
		December 21, 1994.
			Added gen_new_stack_anode.
		July 28, 1993.
			Added translate_flag to gen_pp.
		July 19, 1993.
			Replaced ASSERT and ASSERT_TRACE by GEN_ASSERT and GEN_ASSERT_TRACE.
		July 7, 1993.
			Removed mask_7f_anode and mask_7fff_anode.
			Added mask_00ff_anode, mask_000000ff_anode, mask_0000ffff_anode.
		June 15, 1993.
			Changed gen_pp to handle comma operators.
		June 3, 1993.
			Added gen_expr_line.
			Cleaned up gen_pp.
		April 13, 1993.
			Added gen_vprefix and initialized it in gen_init.
		April 12, 1993.
			gen_call_1arg changed to long.
			I finally understand gen_call_1arg!
		March 26, 1993.
			Removed gkind parameter from gen_new_big_anode.
		February 12, 1993.
			gen_new_big_anode now takes a label_flag parameter.
			Added gen_formal_avail_list.
		February 11, 1993.
			Added gen_formal_reg_list.
		February 10, 1993.
			Merged gexp.c into this file.
		January 29, 1993.
			Floating constants now created by out_begin_file.
		January 23, 1993.
			Set a_debug field in gen_new_big_anode.
		December 19, 1992.
			Defined all constant anodes in gen_perm_init.
			Added gen_new_big_anode().
*/
&lt;&lt; CCgen #includes &gt;&gt;
&lt;&lt; CCgen declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.719">#include "CC.h"

#include "CCarg.h"
#include "CCdump.h"
#include "CCgen.h"
#include "CCmem.h"
#include "CCregs.h"
</t>
<t tx="ekr.20080529093004.720">/*
	The following globals describe the current function.
*/

char *	gen_fname = NULL;	/* Print name. */
snode *	gen_fsnode = NULL;	/* Function's snode. */
tnode *	gen_ftype = NULL;	/* Type of current function. */

/*
	The following globals are used by the code generators.
*/

/*

	gen_current_alloc is the offset of the next auto var or temp
	to be allocated on the stack.
	It is incremented whenever a variable is allocated to the stack,
	and is decremented to a saved value by gen_block when code
	for a block is complete.
	
	gen_current_base is the offset of the last local variable.
	Temporaries are allocated below this base.
	Temporaries are reallocated by setting gen_current_alloc = gen_current_base
	after each outer expression.

	gen_max_alloc is the maximum value of gen_current_alloc for a function.
	It is used to generate code that allocates stack space.

	gen_formals is a list of formal parameters.
	It is needed so that space can be allocated to formal parameters.

	gen_formal_size is used only to see whether LINK/UNLK instructions
	must be generated.
	The offsets for formal parameters assume that a LINK instruction is present,
	so we had better generate LINK/UNLK unless *both* gen_max_alloc
	and gen_formal_size are zero!

	gen_parse_tree is the root of the parse tree for the function.

	gen_call_1arg is the number of calls to functions g1, g2...gn with one argument
	IN THE CURRENT FUNCTION, say f.  If gen_call_1arg &gt;= 1,
	f will *pre-reserve* space for the single argument as follows:

		f:
			...entry code...
			subq.l	#4,7	;allocate pre-reserve space for the first argument

		The g_args can then generate:

			move	arg,a7
			jsr		gi

		instead of:

			move	arg,-a7
			jsr		gi
			addq.l	#4,a7

		The end of f will look like:

			addq.l	#4,7	;free the pre-reserved space
			...exit code...
			rts.

	Only when gen_call_1arg &gt; 1 is a real savings is made,
	since when the cost of allocating and freeing the pre-reserved space
	offsets the savings made in speeding up a single function call.

	gen_vprefix is the next nn used to disambiguat names of statics.
	Such names have the form file@name@nn.

	gen_switch_list is a list of all switches in the current function.
	This list is kept so jump tables can be generated after the function,
	thereby eliminating forward references.

	gen_expr_line is the line number of the current expression.
	This is used to generate warnings and errors in the code generators.
*/

	/* Stack offsets. */

ulong	gen_current_alloc = 0;
ulong	gen_current_base = 0;
ulong	gen_max_alloc = 0;

snode *			gen_formals = NULL;
ulong			gen_formal_size = 0;
pnode *			gen_parse_tree = NULL;
long  			gen_call_1arg = 0;
long			gen_vprefix = 0;
switch_node *	gen_switch_list = NULL;
long			gen_expr_line = 0;


	/* Anodes representing constants. */

anode * one_anode = NULL;		/* Constant 1 */
anode * zero_anode = NULL;		/* Constant 0 */

anode * mask_00ff_anode;		/* Constant 0x00ff */
anode * mask_000000ff_anode;	/* Constant 0x000000ff */
anode * mask_0000ffff_anode;	/* Constant 0xffff0000 */

anode * f_one_anode = NULL;		/* Constant 1.0 (float) */
anode * fd_one_anode = NULL;	/* Constant 1.0 (double) */
anode * fld_one_anode = NULL;	
</t>
<t tx="ekr.20080529093004.721">@ Constant 1.0 (long double)
Generate code for a complete arithmetic expression, but do not free the result. This code is used in gstat.c.
@c

anode *
gen_expr(enode *ep)
{
	FTAG("gen_expr");
	anode * ap1 = NULL;

	if (ep == NULL) {
		return ap1;
	}

	STATB(ftag);

	/* Only outer expressions may translate post operators to pre-operators. */
	gen_pp(ep, TRANSLATE_POST_OPS);
	reg_free_all();
	ap1 = gen_e1(ep);

	TRACEPX(ftag, eret(); eanode(ap1); ecnl());
	return ap1;
}
</t>
<t tx="ekr.20080529093004.722">@ Initialize all code generators. This is called once per input *file*.
@c

void
gen_init(void)
{
	FTAG("gen_init");
	TICKB(ftag);

	/*
		Add a do-nothing node to the start of the global code list.
		This makes c_put() a bit faster.
	*/
	new_cnode_macro(code_head, sizeof(cinode), X_DUMMY);
	code_tail = code_head;

	/* Initialize all code generation globals. */
	par_cur_lab = 0;
	gen_vprefix = 0;

	/*
		Do the initial "per-function" initialization.
		This is also done *after* code generation so as not to intefere with
		gen_fname and other globals set in dcl2.c.
	*/
	gen_func_init();

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.723">@ This routine must be called once per compiled function.
@c

void
gen_func_init(void)
{
	gen_fname = NULL;
	gen_fsnode = NULL;
	gen_ftype = NULL;

	gen_current_alloc = 0;
	gen_formals = NULL;
	gen_formal_size = 0;
	gen_max_alloc = 0;
	gen_parse_tree = NULL;

	gen_break_label = NULL;
	gen_continue_label = NULL;
	gen_ret_label = NULL;

	gen_call_1arg = 0;
	gen_switch_list = NULL;
}
</t>
<t tx="ekr.20080529093004.724">@ Create an anode representing a big constant.  If label_flag is TRUE: Create a label for the constant and put the constant on gen_constant list. Otherwise, the constant will be generated when the initializer is generated. (This is required so that padding can be placed into initializers.)
@c

anode *
gen_new_big_anode(int ckind, char * defstr)
{
	FTAG("gen_new_big_anode");
	anode * ap = NULL;
	label_cnode * lp = NULL;
	STATB(ftag);

	/* Create a new code label. */
	new_clabel_macro(lp);

	/* Create a new anode representing the big constant and its label. */
	new_anode_macro(ap, sizeof(const_anode), IMMEDIATE_EA);
	const_anode_ptr(ap) -&gt; a_ckind = ckind;
	const_anode_ptr(ap) -&gt; a_length = REGISTER_SIZE;
	const_anode_ptr(ap) -&gt; a_label = lp;
	const_anode_ptr(ap) -&gt; a_debug = defstr;

	STATX(ftag);
	return ap;
}
</t>
<t tx="ekr.20080529093004.725">@ Create a stack node of the indicated size. The tag is a comment used by out_stack_comment.
@c

anode *
gen_new_stack_anode(ulong size, short a_length, char * tag, char * name)
{
	FTAG("gen_new_stack_anode");
	anode * result_ap = NULL;
	STATB(ftag);

	/* Allocate the stack for the floating variable. */
	gen_current_alloc += size;
	gen_max_alloc = max(gen_current_alloc, gen_max_alloc);

	/* Point result_ap at the stacl space. */
	if (gen_current_alloc &lt; 0xffff &amp;&amp; a_length &lt; 128) {

		spill_anode * sap_p = NULL;
		new_anode_macro(sap_p, sizeof(spill_anode), DISPLACEMENT_EA);
		sap_p -&gt; a_sreg = R_A6;
		sap_p -&gt; a_slong = -gen_current_alloc;
		sap_p -&gt; a_length = a_length;

		result_ap = anode_ptr(sap_p);
	}
	else {

		//  Warning: this probably will not work!!
		anode * cap = NULL;
		
		fatal(
			es("big stack frames not ready yet!"); enl();
			es("size: "); eint(size);
			es(", gen_current_alloc: "); eint(gen_current_alloc);
		);
		new_const_anode_macro(cap, -gen_current_alloc, POINTER_SIZE);

		result_ap = get_atemp(POINTER_SIZE);
		c_move(cap, result_ap);
		c_2len(X_ADDA, a6_anode, result_ap, POINTER_SIZE);
	}
	
	out_stack_comment(result_ap, size, tag, name);

	STATX(ftag);
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.726">@ Generate code for a complete arithmetic expression and free the result.
@c

void
gen_outer_expr(enode *ep)
{
	FTAG("gen_outer_expr");
	anode * ap1 = NULL;
	STATB(ftag);

	ap1 = gen_expr(ep);
	free_temp(ap1);

	/* All registers had better be free here. */
	GEN_ASSERT_TRACE(
		reg_nd_free + reg_nd_user == D_TEMP_TOTAL,
		es("reg_nd_free: "); eint(reg_nd_free);
		es(" reg_nd_user: "); eint(reg_nd_user);
		es(" D_TEMP_TOTAL: "); eint(D_TEMP_TOTAL);
	);
	GEN_ASSERT_TRACE(reg_na_free + reg_na_user == A_TEMP_TOTAL,
		es("reg_na_free: "); eint(reg_na_free);
		es(" reg_na_user: "); eint(reg_na_user);
		es(" A_TEMP_TOTAL: "); eint(A_TEMP_TOTAL);
	);
	
	/*
		1/6/95: cut back gen_current_alloc to gen_current_base.
		This allows temporaries to share stack space.
	*/
	if (gen_current_base != gen_current_alloc) {
		out_stack_comment(NULL, gen_current_base, "pop temps", NO_NAME);
	}
	gen_current_alloc = gen_current_base;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.727">@ Allocate all dynamic data for this module with permanent lifetime. This routine should be called only once.
@c

void
gen_perm_init(void)
{
	FTAG("gen_perm_init");
	static bool init_flag = FALSE;
	STATB(ftag);

	ASSERT(init_flag == FALSE);
	init_flag = TRUE;

	/* Create base types. */
	new_perm_tnode_macro(int_type,  INT_TYPE, INT_SIZE);
	new_perm_tnode_macro(byte_type, INT_TYPE, CHAR_SIZE);
	new_perm_tnode_macro(long_type, INT_TYPE, LONG_SIZE);

	/* Create constant anodes. */
	new_perm_anode_macro(one_anode, sizeof(const_anode), IMMEDIATE_EA);
	const_anode_ptr(one_anode) -&gt; a_ckind = LONG_CKIND;
	const_anode_ptr(one_anode) -&gt; a_length = LONG_SIZE;
	const_anode_ptr(one_anode) -&gt; a_long = 1L;

	new_perm_anode_macro(zero_anode, sizeof(const_anode), IMMEDIATE_EA);
	const_anode_ptr(zero_anode) -&gt; a_ckind = LONG_CKIND;
	const_anode_ptr(zero_anode) -&gt; a_length = LONG_SIZE;
	const_anode_ptr(zero_anode) -&gt; a_long = 0L;

	new_perm_anode_macro(mask_000000ff_anode, sizeof(const_anode), IMMEDIATE_EA);
	const_anode_ptr(mask_000000ff_anode) -&gt; a_ckind = LONG_CKIND;
	const_anode_ptr(mask_000000ff_anode) -&gt; a_length = LONG_SIZE;
	const_anode_ptr(mask_000000ff_anode) -&gt; a_long = 0x00000000ff;

	new_perm_anode_macro(mask_0000ffff_anode, sizeof(const_anode), IMMEDIATE_EA);
	const_anode_ptr(mask_0000ffff_anode) -&gt; a_ckind = LONG_CKIND;
	const_anode_ptr(mask_0000ffff_anode) -&gt; a_length = LONG_SIZE;
	const_anode_ptr(mask_0000ffff_anode) -&gt; a_long = 0x0000ffff;

	new_perm_anode_macro(mask_00ff_anode, sizeof(const_anode), IMMEDIATE_EA);
	const_anode_ptr(mask_00ff_anode) -&gt; a_ckind = LONG_CKIND;
	const_anode_ptr(mask_00ff_anode) -&gt; a_length = SHORT_SIZE;
	const_anode_ptr(mask_00ff_anode) -&gt; a_long = 0x00ff;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.728">@ Post-process the parse tree.  Translate an *outer* postfix ++/-- to a prefix ++/--. This makes life easier for the code generators.
@c

void
gen_pp(enode *ep, bool translate_flag)
{
	FTAG("gen_pp");
	STATB(ftag);

	if (ep &amp;&amp; translate_flag == TRANSLATE_POST_OPS) {

		if (ep -&gt; n_type == COMMA_TOK) {
			gen_pp(op2_ptr(ep) -&gt; arg1, TRANSLATE_POST_OPS);
			gen_pp(op2_ptr(ep) -&gt; arg2, TRANSLATE_POST_OPS);
		}
		else if (ep -&gt; n_type == POST_INC_TOK) {
			ep -&gt; n_type = PRE_INC_TOK;
		}
		else if (ep -&gt; n_type == POST_DEC_TOK) {
			ep -&gt; n_type = PRE_DEC_TOK;
		}
		else {

			/* Do nothing. */
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.729">/*
	CC2: Code generators for floating operands.

	Notes on the order of operands:
	The gf_routines use C lanaguage order: they return ep -&gt; arg1 op ep -&gt; arg2.
	The librarary routines also use C language order: they compute OP(ap1,ap2).

	source: CCgfloat.c
	started: November 4, 1992.
	version:
		December 31, 1994.
			Bug fix to gf_get_push_ftemp: set a_length field of result.
		December 23, 1994.
			Changed order of pushing arguments in gf_call2.
		December 21, 1994.
			Make sure to extend arguments to _lib_l2f, _lib_l2d and _lib_l2ld to long.
		September 4, 1994
			Spill all registers when calling the routines in LIBdmath.
			This protects the result from later calls to these routines.
			(They clobber a1).
		July 23, 1993.
			Rewrote gf_pre_post to use different library routines.
		July 19, 1993.
			Replaced ASSERT and ASSERT_TRACE by GEN_ASSERT and GEN_ASSERT_TRACE.
		July 12, 1993.
			Changed name of _lib_fl_moveto _lib_fd_move.
		July 8, 1993.
			Call g_ext_constant from within gf_cast2f.
		June 3, 1993.
			Changed gf_call1 and gf_call2 so they leave integer results in d0.
				This saves a usually useless move and is perfectly safe.
		May 27, 1993.
			Bug fix to gf_call1: *always* adjust the stack pointer following the call.
		May 5, 1993.
			Printed copy sent to Tuple.
		April 14, 1993.
			Rewrote this file using the new lib_name function.
			Many changes were made due to new arguments for c_call_lib1 and c_call_lib2.
		February 4, 1993.
			Printed copy sent to Tuple.
		January 22, 1993.
			Call c_ext instead of generating extends directly.
		January 18, 1993.
			Floats are represented as pointers, so f_move routine is required.
		January 14, 1993.
			Eliminated gen_fexpr.
			(gf_ routines now called from g_ routines.)
			Wrote first draft of gf_cast2i.
		January 13, 1993.
			? Eliminated gf_call, gf_comma, gf_cons, gf_prim,
			gf_subscript, gf_ternary, gf_uand and gf_uplus.
			The corresponding g_ routines are called instead.
			? Merged binary operators into the gf_op2 routine.
			? Created gf_relop.
*/

&lt;&lt; CCgfloat #includes &gt;&gt;
&lt;&lt; CCgfloat declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.730">#include "CC.h"

#include "CCdump.h"
#include "CCgen.h"
#include "CCmem.h"
#include "CCregs.h"
#include "CCtarget.h"
</t>
<t tx="ekr.20080529093004.731">/*
	Prototypes of internal routines.
*/
static anode *	gf_call1	(char *name, op1_enode *ep1_p, anode *ap1);
static anode *	gf_call2	(char *name, op2_enode *op2_p, anode *ap1, anode *ap2);
static anode *	gf_get_push_ftemp	(tnode * t, ulong * stack_size);
static char *	lib_name	(tnode *t, char *int_name, char *f_name,
							char *fl_name, char *fld_name);
</t>
<t tx="ekr.20080529093004.732">@ Move src_ap into dst_ap and free the source operand. Do *not* free the dst_ap.
@c

anode *
gf_assn2 (op2_enode * op2_p, register anode * dst_ap, register anode * src_ap)
{
	FTAG("gf_assn2");
	STATB(ftag);
	GEN_ASSERT(op2_p &amp;&amp; op2_p -&gt; e_ctype);
		
	c_move_big(src_ap, TAKE_ADDRESS, dst_ap, TAKE_ADDRESS, op2_p -&gt; e_ctype -&gt; tsize);
	free_temp(src_ap);

	TRACEPX(ftag, eret(); eanode(dst_ap); enl());
	return dst_ap;
}
</t>
<t tx="ekr.20080529093004.733">@ Call a floating library routine with 1 argument and free the argument. Return an anode describing the result.  Some library routines convert integers to float and vice versa, so either the argument or the result may be int instead of float.
@c

static anode *
gf_call1 (char * name, op1_enode * op1_p, anode * ap1)
{
	FTAG("gf_call1");
	anode * d0_ap = NULL;
	anode * result_ap = NULL;
	tnode * result_t = NULL;
	bool one_arg_flag = FALSE;
	ulong stack_size = 0;
	TRACEPB(ftag,
		es(name); ecs(); eenode(enode_ptr(op1_p)); ecs(); eanode(ap1); ecnl());

	GEN_ASSERT(
		op1_p &amp;&amp; op1_p -&gt; e_ctype &amp;&amp;
		op1_p -&gt; arg1 &amp;&amp; op1_p -&gt; arg1 -&gt; e_ctype);
		
	/* Set up some abbreviations. */
	result_t = op1_p -&gt; e_ctype;
		
	/* Push the argument. */
	if (op1_p -&gt; arg1 -&gt; e_ctype -&gt; tprim == FLOAT_TYPE) {
		stack_size += c_push_float(ap1, ONE_ARG, op1_p -&gt; arg1);
	}
	else {
		stack_size += c_push(ap1, ONE_ARG);
		free_temp(ap1);
	}

	/* Allocate space for the return value. */
	if (result_t -&gt; tprim == FLOAT_TYPE) {
	
		/* Push a hidden pointer to a stack temp. */
		result_ap = gf_get_push_ftemp(result_t, &amp;stack_size);
	}
	else {
		GEN_ASSERT(result_t -&gt; tprim == INT_TYPE);
		result_ap = d0_ap = get_d0(result_t -&gt; tsize);
	}

	/* Generate the function call. */
	{
		/* Create an anode for the library name. */
		anode * ap = NULL;
		new_anode_macro(ap, sizeof(var_anode), ABSOLUTE_EA);
		var_anode_ptr(ap) -&gt; a_vkind = LIBNAME_VKIND;
		var_anode_ptr(ap) -&gt; a_vname = name;

		c_1(X_JSR, ap);
		gen_import_name(name, USE_LIB_PREFIX);
	}

	/* Generate the code to reset the stack pointer. */
	c_adj_stack(stack_size);
	
	/* Move D0 back to result_ap for non-floating results. */
	if (result_t -&gt; tprim != FLOAT_TYPE &amp;&amp; result_ap != d0_ap) {

		c_move_len(d0_ap, result_ap, result_ap -&gt; a_length);
		free_temp(d0_ap);
	}

	STATX(ftag);
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.734">@ Call a floating library routine with 2 arguments. Return an anode representing the result if void_flag is FALSE. Always free src_ap.  Note: The order of operands corresponds to *machine-language* order! Since arguments are pushed in reverse order in C, the dst_ap is below the src_ap on the stack.
@c

static anode *
gf_call2 (char *name, op2_enode * op2_p, anode * src_ap, anode * dst_ap)
{
	FTAG("gf_call2");
	anode * result_ap = NULL;
	anode * d0_ap = NULL;
	tnode * result_t = NULL;
	ulong stack_size = 0;
	TRACEPB(ftag,
		es(name);
		es(", src_ap: ");  eanode(src_ap);
		es(", dst_ap: ");  eanode(dst_ap); enl(); enl());

	GEN_ASSERT(
		op2_p &amp;&amp; op2_p -&gt; e_ctype &amp;&amp;
		op2_p -&gt; arg1 &amp;&amp; op2_p -&gt; arg1 -&gt; e_ctype &amp;&amp;
		op2_p -&gt; arg2 &amp;&amp; op2_p -&gt; arg2 -&gt; e_ctype);

	/* Define a useful abbreviation. */
	result_t = op2_p -&gt; e_ctype;

	/* Push the arguments in reverse order. */
	stack_size += c_push_float(src_ap, MULTIPLE_ARGS, op2_p -&gt; arg2);
	stack_size += c_push_float(dst_ap, MULTIPLE_ARGS, op2_p -&gt; arg1);
	
	/* Allocate space for the return value. */
	if (result_t -&gt; tprim == FLOAT_TYPE) {
	
		/* Push a hidden pointer to a stack temp. */
		result_ap = gf_get_push_ftemp(result_t, &amp;stack_size);
	}
	else {
		GEN_ASSERT(result_t -&gt; tprim == INT_TYPE);
		result_ap = d0_ap = get_d0(result_t -&gt; tsize);
	}

	/* Generate the function call. */
	{
		/* Create an anode for the library name. */
		anode * ap = NULL;
		new_anode_macro(ap, sizeof(var_anode), ABSOLUTE_EA);
		var_anode_ptr(ap) -&gt; a_vkind = LIBNAME_VKIND;
		var_anode_ptr(ap) -&gt; a_vname = name;

		c_1(X_JSR, ap);
		gen_import_name(name, USE_LIB_PREFIX);
	}

	/* Generate the code to reset the stack pointer */
	c_adj_stack(stack_size);
	
	/* Move D0 back to result_ap for non-float functions. */
	if (result_t -&gt; tprim != FLOAT_TYPE) {

		GEN_ASSERT(d0_ap);
		c_move_len(d0_ap, result_ap, result_ap -&gt; a_length);
	}

	TRACEPX(ftag, eret(); eanode(result_ap); ecnl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.735">@ Call f_nz, d_nz or ld_nz, depending on ep. These routines take one FLOAT_TYPE argument and return a boolean (2-byte int.)  This is essentially a special case of g_call1 and this routine simplifies gf_call1, the calls to gf_call1 and the calls to gf_call_nz.
@c

anode *
gf_call_nz(enode * ep, anode * ap1)
{
	FTAG("g_call_nz");
	anode * d0_ap = NULL;
	anode * result_ap = NULL;
	ulong stack_size = 0;
	TRACEPB(ftag,
		eenode(ep); ecnl());

	GEN_ASSERT(ep &amp;&amp; ep -&gt; e_ctype &amp;&amp; ep -&gt; e_ctype -&gt; tprim == FLOAT_TYPE);

	/* Push and free the argument. */
	stack_size += c_push_float(ap1, ONE_ARG, ep);
	free_temp(ap1);

	/* f_nz returns the result in D0. */
	d0_ap = get_d0(RELOP_SIZE);
	result_ap = get_dtemp(RELOP_SIZE);

	/* Make sure that d0 was not spilled by the call to get_dtemp. */
	GEN_ASSERT(d0_ap &amp;&amp; d0_ap -&gt; n_type == DREG_EA);

	/* Generate the function call. */
	{
		/* Create an anode for the library name. */
		anode * name_ap = NULL;
		new_anode_macro(name_ap, sizeof(var_anode), ABSOLUTE_EA);
		var_anode_ptr(name_ap) -&gt; a_vkind = LIBNAME_VKIND;
		var_anode_ptr(name_ap) -&gt; a_vname =
			lib_name(ep -&gt; e_ctype, NULL, "f_nz", "d_nz", "ld_nz");

		c_1(X_JSR, name_ap);

		/* Bug fix: 6/3/93 */
		gen_import_name(var_anode_ptr(name_ap) -&gt; a_vname, USE_LIB_PREFIX);
	}

	/* Generate the code to reset the stack pointer. */
	c_adj_stack(stack_size);

	/* Move D0 to result_ap. */
	c_move_len(d0_ap, result_ap, result_ap -&gt; a_length);
	free_temp(d0_ap);

	STATX(ftag);
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.736">@ Generate code for cast operator resulting in some floating type.
@c

anode *
gf_cast2f (op1_enode * op1_p)
{
	FTAG("gf_cast2f");
	anode * ap1 = NULL;
	tnode * t = NULL;
	tnode * t1 = NULL;
	anode * result_ap = NULL;
	char * the_lib_name = NULL;
	STATB(ftag);
	GEN_ASSERT(op1_p &amp;&amp; op1_p -&gt; arg1);

	/* Define some useful abbreviations. */
	t = op1_p -&gt; e_ctype;
	t1 = op1_p -&gt; arg1 -&gt; e_ctype;
	GEN_ASSERT(t &amp;&amp; t1);

	/* Set the library name. */
	if (FLOAT_SIZE == LONG_DOUBLE_SIZE) {
		the_lib_name = lib_name(t1, "l2d", NULL, NULL, NULL);
	}
	else if (DOUBLE_SIZE == LONG_DOUBLE_SIZE) {
	
		ASSERT(FLOAT_SIZE &lt; DOUBLE_SIZE);
		if (t_is_float(t)) {
			the_lib_name = lib_name(t1, "l2f", NULL, "d2f", "d2f");
		}
		else {
			ASSERT(t_is_double(t));
			the_lib_name = lib_name(t1, "l2d", "f2d", NULL, NULL);
		}
	}
	else {
		if (t_is_float(t)) {
			the_lib_name = lib_name(t1, "l2f", NULL, "d2f", "ld2f");
		}
		else if (t_is_double(t)) {
			the_lib_name = lib_name(t1, "l2d", "f2d", NULL, "ld2d");
		}
		else {
			GEN_ASSERT(t_is_long_double(t));
			the_lib_name = lib_name(t1, "l2ld", "f2ld", "d2ld", NULL);
		}
	}

	/* Evaluate the argument. */
	ap1 = gen_e1(op1_p -&gt; arg1);

	/* Convert an int parameter to long. */
	if (t1 -&gt; tprim == INT_TYPE) {
	
		if (a_is_constant(ap1)) {

			/* Integer constants can be widened without generating code. */
			ap1 = c_ext_constant(ap1, LONG_SIZE,
					t_is_unsigned(op1_p -&gt; arg1 -&gt; e_ctype));
		}
		else {
		
			/* Convert the integer to long. */
			ap1 = c_ext(ap1, LONG_SIZE,
					t_is_unsigned(op1_p -&gt; arg1 -&gt; e_ctype));
		}
	}

	if (the_lib_name) {
		result_ap = gf_call1(the_lib_name, op1_p, ap1);
	}
	else {
		result_ap = ap1;
	}

	GEN_ASSERT(result_ap);
	TRACEPX(ftag, eret(); eanode(result_ap); ecnl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.737">@ Generate code for cast from a floating type to an char, int or long.
@c

anode *
gf_cast2i (op1_enode * op1_p)
{
	FTAG("gf_cast2f");
	anode * ap1 = NULL;
	anode * result_ap = NULL;
	STATB(ftag);
	GEN_ASSERT(op1_p &amp;&amp; op1_p -&gt; arg1);

	/* Evaluate the floating argument. */
	ap1 = gen_e1(op1_p -&gt; arg1);

	/* First convert the float to a long. */
	result_ap =
		gf_call1(
			lib_name(op1_p -&gt; arg1 -&gt; e_ctype, NULL, "f2l", "d2l", "ld2l"), op1_p, ap1);

	/* Now truncate the temporary as needed. */
	GEN_ASSERT(result_ap);
	result_ap -&gt; a_length = c_t2mlen(op1_p -&gt; e_ctype);

	TRACEPX(ftag, eret(); eanode(result_ap); enl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.738">@ Allocate space on the stack for a floating temporary,  and update stack_size in the caller.  Return an a-temp which points to the stack space.  This routine is ugly because it combines two separate tasks: 1) allocating a temporary and 2) generating code to push the temporary. Doing both tasks here is an optimization that allows us to generate  pea offset(a6)  instead of the two instructions that would otherwise result.  lea offset(a6),An ;allocate a temporary and return its address in An  move An,-(a7) ;push the allocated temporary.
@c

static anode *
gf_get_push_ftemp(tnode * t, ulong * stack_size)
{
	FTAG("gf_get_push_ftemp");
	anode * result_ap = NULL;
	STATB(ftag);
	GEN_ASSERT(t &amp;&amp; t -&gt; tprim == FLOAT_TYPE);

	/*
		Set the size of the actual floating variable.
		Warning: c_t2mlen returns POINTER_SIZE for all kinds of floats.
	*/
	result_ap = gen_new_stack_anode(t -&gt; tsize, t -&gt; tsize, "ftemp", NO_NAME);
	GEN_ASSERT(result_ap -&gt; n_type == DISPLACEMENT_EA);
	c_1(X_PEA, result_ap);
	(*stack_size) += POINTER_SIZE;

	TRACEPX(ftag, eret(); eanode(result_ap));
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.739">@ Generate code for an binary floating operator that returns a float.  All floating operations are now done in long double precision.  All floating assign-ops have already been translated to a sequence of operations. That is, a op= b has been translated to a = a op b. This is required so proper casting of operands can be done.
@c

anode *
gf_op2(op2_enode *op2_p, char * op_name)
{
	FTAG("gf_op2");
	anode * result_ap = NULL;
	register anode * dst_ap = NULL;
	register anode * src_ap = NULL;
	TRACEPB(ftag,
		eenode(enode_ptr(op2_p)); ecs(); es(op_name); enl());

	GEN_ASSERT(op2_p &amp;&amp; op2_p -&gt; arg1 &amp;&amp; op2_p -&gt; arg2);

	/* Generate the arguments. */
	dst_ap = gen_e1(op2_p -&gt; arg1);
	src_ap = gen_e1(op2_p -&gt; arg2);

	GEN_ASSERT_TRACE(
		op2_p -&gt; e_ctype -&gt; tsize == LONG_DOUBLE_SIZE,
		etnode(op2_p -&gt; e_ctype));

	result_ap = gf_call2(op_name, op2_p, src_ap, dst_ap);

	GEN_ASSERT(result_ap);
	TRACEPX(ftag, eret(); eanode(result_ap); ecnl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.740">@ Generate code for the pre- and post- increment and decrement operators applied to floating operators. This code is exactly analogous to g_pre_post.
@c

anode *
gf_pre_post (op1_enode *op1_p, bool pre_flag, bool inc_flag)
{
	FTAG("gf_pre_post");
	anode * result_ap = NULL;
	anode * dst_ap = NULL;
	char * the_lib_name = NULL;
	STATB(ftag);

	GEN_ASSERT(op1_p &amp;&amp; op1_p -&gt; e_ctype);

	dst_ap = gen_e1(op1_p -&gt; arg1);

	/* Set the library name. */
	if (pre_flag) {

		if (inc_flag) {
			the_lib_name = lib_name(op1_p -&gt; e_ctype, NULL,
				"f_pre_add1", "d_pre_add1", "ld_pre_add1");
		}
		else {
			the_lib_name = lib_name(op1_p -&gt; e_ctype, NULL,
				"f_pre_sub1", "d_pre_sub1", "ld_pre_sub1");
		}

	}
	else {

		if (inc_flag) {
			the_lib_name = lib_name(op1_p -&gt; e_ctype, NULL,
				"f_post_add1", "d_post_add1", "ld_post_add1");
		}
		else {
			the_lib_name = lib_name(op1_p -&gt; e_ctype, NULL,
				"f_post_sub1", "d_post_sub1", "ld_post_sub1");
		}
	}

	result_ap = gf_call1(the_lib_name, op1_p, dst_ap);

	GEN_ASSERT(result_ap);
	TRACEPX(ftag, eanode(result_ap); ecnl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.741">@ Generate code for comparisons of floating operands.  These comparisons always yield an *integer* result, so this routine is called only from g_relop.
@c

anode *
gf_relop (op2_enode * op2_p)
{
	FTAG("gf_relop");
	anode * dst_ap = NULL;
	anode * src_ap = NULL;
	anode * result_ap = NULL;
	char * the_name = NULL;
	STATB(ftag);

	GEN_ASSERT(op2_p &amp;&amp; op2_p -&gt; e_ctype &amp;&amp; op2_p -&gt; e_ctype -&gt; tprim == INT_TYPE);

	GEN_ASSERT(
		op2_p -&gt; arg1 &amp;&amp; op2_p -&gt; arg1 -&gt; e_ctype &amp;&amp;
		op2_p -&gt; arg2 &amp;&amp; op2_p -&gt; arg2 -&gt; e_ctype &amp;&amp;
		ct_eq(op2_p -&gt; arg1 -&gt; e_ctype, op2_p -&gt; arg2 -&gt; e_ctype));

	/*
		6/6/93:
		While the *ultimate* type of any compare is int,
		we examine the types of the operands to determine what compare to do.
	*/
	{
		tnode * t = op2_p -&gt; arg1 -&gt; e_ctype;

		/* 7/12/93: All operands are long double sized. */
		GEN_ASSERT(t -&gt; tsize == LONG_DOUBLE_SIZE);

		if (DOUBLE_SIZE == LONG_DOUBLE_SIZE) {
			switch(op2_p -&gt; n_type) {
			case EQUAL_TOK:	the_name = "d_eq"; break;
			case GE_TOK:	the_name = "d_ge"; break;
			case GT_TOK:	the_name = "d_gt"; break;
			case LE_TOK:	the_name = "d_le"; break;
			case LT_TOK:	the_name = "d_lt"; break;
			case NE_TOK:	the_name = "d_ne"; break;
			default:
				fatal(es(ftag); es("unknown floating compare"));
			}
		}
		else {
			switch(op2_p -&gt; n_type) {
			case EQUAL_TOK:	the_name = "ld_eq"; break;
			case GE_TOK:	the_name = "ld_ge"; break;
			case GT_TOK:	the_name = "ld_gt"; break;
			case LE_TOK:	the_name = "ld_le"; break;
			case LT_TOK:	the_name = "ld_lt"; break;
			case NE_TOK:	the_name = "ld_ne"; break;
			default:
				fatal(es(ftag); es("unknown floating compare"));
			}
		}
	}

	/* Generate the arguments. */
	dst_ap = gen_e1(op2_p -&gt; arg1);
	src_ap = gen_e1(op2_p -&gt; arg2);

	/*
		Generate the floating compare.
		Free both src_ap and dst_ap.
		The result_ap will represent register D0 (void_flag = FALSE).
	*/
	result_ap = gf_call2(the_name, op2_p, src_ap, dst_ap);

	GEN_ASSERT(result_ap);
	TRACEPX(ftag, eret(); eanode(result_ap); enl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.742">@ Generate code for the floating unary '-' operator.
@c

anode *
gf_uminus (op1_enode * op1_p)
{
	FTAG("gf_uminus");
	anode * result_ap = NULL;
	register anode * ap1 = NULL;
	STATB(ftag);
	GEN_ASSERT(op1_p &amp;&amp; op1_p -&gt; e_ctype);

	/* Evaluate the argument. */
	ap1 = gen_e1(op1_p -&gt; arg1);

	/* Generate the unary minus. */
	result_ap =
		gf_call1(
			lib_name(op1_p -&gt; e_ctype, NULL, "f_neg", "d_neg", "ld_neg"), op1_p, ap1);

	GEN_ASSERT(result_ap);

	TRACEPX(ftag, eret(); eanode(result_ap); ecnl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.743">@ Set the library name based on the type t. No check is made for a NULL name, which may be passed back to the caller.
@c

static char *
lib_name(tnode * t, char * int_name, char * f_name, char * fl_name, char * fld_name)
{
	FTAG("t2lib_name");
	char * the_lib_name = NULL;
	STATB(ftag);
	GEN_ASSERT(t);

	if (t -&gt; tprim == INT_TYPE) {
		the_lib_name = int_name;
	}
	else if (t_is_float(t)) {
		the_lib_name = f_name;
	}
	else if (t_is_double(t)) {
		the_lib_name = fl_name;
	}
	else {
		GEN_ASSERT(t_is_long_double(t));
		the_lib_name = fld_name;
	}

	STATX(ftag);
	return the_lib_name;
}</t>
<t tx="ekr.20080529093004.744">/*
	CC2: Code generators for all non-floating operands.

	The main difference between this file and the routines in cput.c are:
	These routines allocate and free temporary variables.
	These routines make sure that machine arguments have the proper form
	  before calling the routines in cput.c.

	source: CCgint.c
	started: January 21, 1986; December 21, 1992.
	version:
		January 2, 1994.
			Bug fix to g_call.
		December 28, 1994.
			Bug fix to g_relop.
			Now that RELOP_SIZE is a variable, we cant do #if RELOP_SIZE &gt; 1 !
		December 24, 1994.
			Added PLUS_TOK and MINUS_TOK cases to g_address.
			Bug fix to g_not.
		December 20, 1994.
			Changed code in g_ternary to handle large objects.
		November 11, 1994.
			Bug fix to g_assn: small structs may have size less than POINTER_SIZE.
			Bug fix to g_prim: large formal structs are represented as a pointer.
			Bug fix to g_arg1: large formal structs are represented as a pointer.
		August 26, 1994.
			Added code to handle &amp;(a ? b : c).
			This is valid as long as b and c *have* addresses.
		June 13, 1994.
			Bug fix to several routines.
				Integers *can* end up in a-regs as the result of casts.
				Created move_aregs_to_dregs_macro to handle this.
		May 31, 1994.
			Bug fix to g_assn.  Relax ASSERT's to allow for structure assigns.
		November 2, 1993.
			Bug fix to g_ternary.  Allow either branch to be cast to void.
			Bug fix to g_address.  Evaluate &amp;*e as e for any e.
		July 26, 1993.
			Rewrote "address of" logic.
				Created g_add_dots, g_add_offset and g_address.
				Added take_address_flag to g_add_sub_ip;
		July 20, 1993.
			Replaced TRUE/FALSE flags with more meaningful synonyms.
			Bug fix to g_ustar: make sure ep2 is meaningful before evaluating it.
		July 19, 1993.
			Replaced ASSERT and ASSERT_TRACE by GEN_ASSERT and GEN_ASSERT_TRACE.
		July 5, 1993.
			Bug fix: Allow arrays in add_sub_any and add_sub_ip.
		July 1, 1993.
			Bug fix: all more address modes for shrinking casts.
		June 30, 1993.
			Bug fix: disable call_1arg optimization for function calls appearing
				in the argument of a function.
			Bug fix: shrinking casts must adjust addresses.
		June 29, 1993.
			Bug fix: added g_call_math2.
		June 6, 1993.
			The destination of an assign-op can be a D-reg instead of a D-temp.
		June 3, 1993.
			Bug fix to g_cast: Add warning and truncate oversize constants.
			Bug fixes to g_shift, g_mult.
			Removed most inline "setup" macros.
			(These turned out to be impossible to understand in the long run.)
		June 2, 1993.
			Rewrote g_and_or so code for assn_ops is better.
			Rewrote g_eor to make code clearer.
		June 1, 1993.
			Bug fixes: g_eor and g_sub_pp now use assn_flag(!)
		May 5,1993.
			Printed copy sent to Tuple.
		May 1, 1993.
			Bug fix in g_eor.  Unlike other opcodes, the *source* must be in a D-reg.
		April 30, 1993.
			Bug fix in g_scale.  MULU only works on 16 bit data.
		April 17, 1993.
			Output an IMPORT directive before making any function call.
		April 12, 1993.
			Changed g_call to support the gen_call_1arg optimization.
		April 4, 1993.
			Bug fix: rewrote add_sub_ip to get proper opcodes and opcode lengths.
		April 3, 1993.
			Do nothing in g_add_sub_ii and g_add_sub_ip if we are add or subtract 0.
		April 2, 1993.
			Replaced code in g_assn by a call to c_memmove.
		March 26, 1993.
			Changed g_prim so that anodes for strings are taken from enode.
		March 5, 1993.
			Changed g_prim so all anodes are now alterable.
			Removed all calls to c_copy (except in g_ternary) outside g_prim.
		March 4, 1993.
			Bug fix: removed ASSERT(spill_anode_ptr(ap) -&gt; a_sreg == R_A6)
			from code that generates LEA instructions.
		February 25, 1993.
			Change g_uand to allow address of arrays.
		February 15, 1993.
			Added code for &amp;f == f for all floats to g_uand.
			Change g_prim to load the address of all floats.
		February 2, 1993.
			Printed copy sent to Tuple.
			Changed c_put(X_MOVE...) to c_move(...).
		January 31, 1993.
			Bug fix to g_scale: make sure the calculations happen in a D-reg.
			Bug fix to g_add_sub_ip: convert ABSOLUTE_EA to ADDRESS_EA.
		January 30, 1993.
			Various fixes to g_prim to handle -&gt; operator.
		January 29, 1993.
			QUESTION_TOK introduces a ternary, not COLON_TOK.
			Fixed bug in g_args. (Must call g_args on the cdr, not the car).
		January 18, 1993
			Bug fix: floating constants in g_prim.
		January 14, 1993.
			gen_iexpr changed to gen_e1.
			g_ routines call gf_ routines directly.
		January 13, 1993.
			Called gf_relop from g_relop.
		January 12, 1993.
			Completed g_uand, g_ustar, g_prim, g_call.
		January 9, 1993.
			Merged two routines into g_uneg.
			Revised g_shift.
			Removed g_sub_ii.
		January 4, 1993.
			Rewrote g_add_sub_ii.
			Added g_add_sub_ip, g_sub_pp.
			Breakthrough: treat code for assn_flag, !assn_flag separately.
		January 2, 1993.
			g_cast makes copies of anodes for non-temps.
		December 30, 1992.
			Added g_cmp.
*/

/*
	Overview.

	The only link between the data structures used by the output routines
	and the data structures used by the parser is the sarg field in snodes.
	This field dramatically simplifies the code generators, especially g_prim,
	because the code generators no longer need to know where operands are.

	The "usual arithmetic conversions" are handled by ct.c and g_cast,
	so we can GEN_ASSERT(ap1 -&gt; a_length == ap2 -&gt; a_length) in the routines
	that generate code for most binary operations.
	This also simplifies the code a lot.

	Non-static routines in this file are called by the routines in gfloat.c.
	These routines must accept floating arguments and be able to
	generate floating results!

	Notes on the order of operands:

	? The g_routines use C language order: they return ep -&gt; arg1 op ep -&gt; arg2
	when generating code for non-abelian operators.
	The code generators may rearrange the operands of abelean operators
	if this would reduce the number of registers needed to evaluate an expression.

	? The c_2, c2len, c2len2, the *setup macros* defined below and the librarary routines
	used machine language order, which is opposite from C language order.
	These routines and macros compute OP ap1,ap2
	where the source argument is first, follwed by the destination argument.

	The routines in this file express all the quirks of the instruction set.
	Even for the 68000, which has a fairly uniform instruction set,
	there are enough variation in each instruction to make sharing
	code much more challenging than it might at first appear.

	The *Machine Patterns* refered to throughout this file are defined
	in ops.c and ops.h.
	See these files for a complete explanation of what the patterns mean.

	This code only looks simple, and it looks simple because parts of
	it were rewritten more than 10 times.
	Previous versions of the code were ugly beyond description.
	I now know why people are tempted to write compiler compilers.
	However, I believe that hand-coding this file was well worth the effort.
*/

&lt;&lt; CCgint #includes &gt;&gt;
&lt;&lt; CCgint declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.745">#include "CC.h"

#include "CCarg.h"
#include "CCdump.h"
#include "CCgen.h"
#include "CCmem.h"
#include "CCregs.h"
#include "CCtarget.h"

#include &lt;LIBos.h&gt;
</t>
<t tx="ekr.20080529093004.746">/*
	Define synonyms for flags used in this file.
*/
#define PRE_OP			TRUE	/* pre_flag of g_pre_post. */
#define POST_OP			FALSE

#define INC_OP			TRUE	/* inc_flag of g_pre_post. */
#define DEC_OP			FALSE

#define EVAL_STAR		TRUE	/* star_flag of g_pre_post. */
#define DONT_EVAL_STAR	FALSE

#define ASSN_OP			TRUE	/* assn_flag of various routines. */
#define NON_ASSN_OP		FALSE

#define ADD_OP			TRUE	/* add_flag of various routines. */
#define SUB_OP			FALSE

#define MOD_OP			TRUE	/* mod_flag of g_div_mod. */
#define DIV_OP			FALSE

#define ONES_COMPLEMENT	TRUE	/* ones_flag of g_uneg. */
#define TWOS_COMPLEMENT FALSE

#define RIGHT_SHIFT_OP	TRUE	/* right_flag of g_shift. */
#define LEFT_SHIFT_OP	FALSE

#define AND_OP			TRUE	/* and_flag of g_and_or. */
#define OR_OP			FALSE

#define TOP_LEVEL		TRUE	/* top_flag of g_args. */
#define NOT_TOP_LEVEL	FALSE

#define TAKE_ADDRESS		TRUE	/* take_address_flag of g_add_sub_ip */
#define DONT_TAKE_ADDRESS	FALSE

#define TARGET_IS_ARRAY		TRUE	/* array_flag set by g_add_dots. */
#define TARGET_ISNT_ARRAY	TRUE

/*
	Function prototypes of local routines.
*/
static ulong	g_add_dots		(enode * ep, bool * array_flag);
static anode *	g_add_offset	(anode * ap, ulong offset);
static anode *	g_add_sub_any	(op2_enode *ep, bool assn_flag, bool add_flag);
static anode *	g_add_sub_ii	(op2_enode *ep, bool assn_flag, bool add_flag);
static anode *	g_add_sub_ip
	(op2_enode *ep, bool assn_flag, bool add_flag, bool take_address_flag);
static anode *	g_address		(enode * ep);
static anode *	g_and_or		(op2_enode *ep, bool assn_flag, bool and_flag);

static ulong	g_arg1		(enode *ep, bool one_arg_flag);
static ulong	g_args		(enode *ep, bool top_flag);
static anode *	g_assn		(op2_enode *ep);
static anode *	g_call_math2
	(char *name, op2_enode * op2_p, anode * src_ap, anode * dst_ap);
static anode *	g_cast		(op1_enode *ep);
static anode *	g_div_mod	(op2_enode *ep, bool assn_flag, bool mod_flag);
static anode *	g_eor		(op2_enode *ep, bool assn_flag);
static anode *	g_logical	(enode *ep);
static anode *	g_not		(op1_enode *ep);
static anode *	g_pre_post	(op1_enode *ep, bool pre_flag, bool inc_flag, bool star_flag);
static anode *	g_relop		(op2_enode *ep,
								int signed_op, int unsigned_op,
								int signed_switched_op, int unsigned_switched_op);
static anode *	g_scale		(anode * iap, long scale);
static anode *	g_shift		(op2_enode *ep, bool assn_flag, bool right_flag);
static anode *	g_mult		(op2_enode *ep, bool assn_flag);
static anode *	g_sub_pp	(op2_enode *ep, bool assn_flag);
static anode *	g_uand		(op1_enode *ep);
static anode *	g_uneg		(op1_enode *ep, bool ones_flag);
static anode *	g_ustar		(op1_enode *ep);
</t>
<t tx="ekr.20080529093004.747">@ Define abbreviation macros.
@c

#define c_bra(ep) c_1clab(X_BRA, ep)

#define swap_ap(ap1,ap2) {anode * at_ = ap1; ap1 = ap2; ap2 = at_; }

/*
	Prepare for an abelian operator which is *not* an assignment operator.
	That is: make src a constant if possible, then force dst to be a D-temp.

	This is coded as a macro because it may change its arguments.
	In other words, this macro simulates C++ call-by-reference.
*/
#define setup_abelian_op_macro(ftag,src,dst)\
{\
	if (a_is_constant(dst) &amp;&amp; !a_is_constant(src)) {\
		swap_ap(dst, src);\
	}\
	else if (a_is_dtreg(src) &amp;&amp; !a_is_dtreg(dst)) {\
		swap_ap(dst, src);\
	}\
	dst = c_move2dtreg(dst);\
}

/*
	June 13, 1994.
		Move an operand out of an A-reg.
		This can happen as the result of a cast such as ((ulong) pointer).
*/
#define move_aregs_to_dregs_macro(src,dst)\
{\
	if (a_is_areg(src)) {\
		src = c_move2dtreg(src);\
	}\
	if (a_is_areg(dst)) {\
		dst = c_move2dtreg(dst);\
	}\
}

/*
	Generate code from a parse tree whose root has integer or non-floating type.
*/
anode *
gen_e1(register enode *ep)
{
	FTAG("gen_e1");
	register anode * ap = NULL;
	TRACEPB(ftag, eenode(ep); ecnl());

	GEN_ASSERT(ep);

	if (ep -&gt; e_ctype == NULL) {
		error(es(ftag); es(" NULL type"));
		goto done;
	}

	/*
		Operator tokens are defined in a range so that
		this switch can be implemented as a table jump.
	*/
	switch (ep -&gt; n_type) {

	case AND_TOK:		ap = g_and_or (op2_ptr(ep), NON_ASSN_OP, AND_OP); break;
	case AND_ASSN_TOK:	ap = g_and_or (op2_ptr(ep), ASSN_OP,     AND_OP); break;

	case ARRAY_TOK:		ap = g_index(op2_ptr(ep));	break;
	case ARROW_TOK:		ap = g_prim	(ep);			break;
	case ASSN_TOK:		ap = g_assn	(op2_ptr(ep));	break;
	case CALL_TOK:		ap = g_call	(op2_ptr(ep));	break;
	case CAST_TOK:		ap = g_cast	(op1_ptr(ep));	break;
	case COMMA_TOK:		ap = g_comma(op2_ptr(ep));	break;
	case CONS_TOK:		ap = g_cons	(cons_ptr(ep));	break;

	case DIV_TOK:		ap = g_div_mod (op2_ptr(ep), NON_ASSN_OP, DIV_OP); break;
	case DIV_ASSN_TOK:	ap = g_div_mod (op2_ptr(ep), ASSN_OP,     DIV_OP); break;

	case DOT_TOK:		ap = g_prim (ep); break;

	case EQUAL_TOK:		ap = g_relop(op2_ptr(ep), X_SEQ, X_SEQ, X_SEQ, X_SEQ); break;

	case FLOAT_TOK:		ap = g_prim (ep); break;

	case GE_TOK:		ap = g_relop(op2_ptr(ep), X_SGE, X_SHS, X_SLE, X_SLS); break;
	case GT_TOK:		ap = g_relop(op2_ptr(ep), X_SGT, X_SHI, X_SLT, X_SLO); break;

	case ID_TOK:		ap = g_prim (ep); break;
	case INT_TOK:		ap = g_prim (ep); break;

	case LAND_TOK:		ap = g_logical	(ep); break;

	case LE_TOK:		ap = g_relop(op2_ptr(ep), X_SLE, X_SLS, X_SGE, X_SHS); break;

	case LOR_TOK:		ap = g_logical	(ep); break;

	case LSHIFT_TOK:		ap = g_shift (op2_ptr(ep), NON_ASSN_OP, LEFT_SHIFT_OP); break;
	case LSHIFT_ASSN_TOK:	ap = g_shift (op2_ptr(ep), ASSN_OP,     LEFT_SHIFT_OP); break;

	case LT_TOK:		ap = g_relop(op2_ptr(ep), X_SLT, X_SLO, X_SGT, X_SHI); break;

	case MINUS_TOK:			ap = g_add_sub_any	(op2_ptr(ep), NON_ASSN_OP, SUB_OP); break;
	case MINUS_ASSN_TOK:	ap = g_add_sub_any	(op2_ptr(ep), ASSN_OP,     SUB_OP); break;

	case MOD_TOK:		ap = g_div_mod (op2_ptr(ep), NON_ASSN_OP, MOD_OP); break;
	case MOD_ASSN_TOK:	ap = g_div_mod (op2_ptr(ep), ASSN_OP,     MOD_OP); break;

	case NE_TOK:		ap = g_relop(op2_ptr(ep), X_SNE, X_SNE, X_SNE, X_SNE); break;

	case NOT_TOK:		ap = g_not	(op1_ptr(ep)); break;

	case OR_TOK:		ap = g_and_or (op2_ptr(ep), NON_ASSN_OP, OR_OP); break;
	case OR_ASSN_TOK:	ap = g_and_or (op2_ptr(ep), ASSN_OP,     OR_OP); break;

	case PLUS_TOK:		ap = g_add_sub_any (op2_ptr(ep), NON_ASSN_OP, ADD_OP); break;
	case PLUS_ASSN_TOK:	ap = g_add_sub_any (op2_ptr(ep), ASSN_OP,     ADD_OP); break;

	case QUESTION_TOK:	ap = g_ternary (op3_ptr(ep));	break;

	case POST_DEC_TOK:	ap = g_pre_post (op1_ptr(ep), POST_OP, DEC_OP, DONT_EVAL_STAR); break;
	case POST_INC_TOK:	ap = g_pre_post (op1_ptr(ep), POST_OP, INC_OP, DONT_EVAL_STAR); break;
	case PRE_DEC_TOK:	ap = g_pre_post (op1_ptr(ep), PRE_OP,  DEC_OP, DONT_EVAL_STAR); break;
	case PRE_INC_TOK:	ap = g_pre_post (op1_ptr(ep), PRE_OP,  INC_OP, DONT_EVAL_STAR); break;

	case RSHIFT_TOK:		ap = g_shift (op2_ptr(ep), NON_ASSN_OP, RIGHT_SHIFT_OP); break;
	case RSHIFT_ASSN_TOK:	ap = g_shift (op2_ptr(ep), ASSN_OP,     RIGHT_SHIFT_OP); break;

	case STAR_TOK:		ap = g_mult (op2_ptr(ep), NON_ASSN_OP); break;
	case STAR_ASSN_TOK:	ap = g_mult (op2_ptr(ep), ASSN_OP);     break;
	case STRING_TOK:	ap = g_prim (ep); break;

	case TILDE_TOK:		ap = g_uneg (op1_ptr(ep), ONES_COMPLEMENT); break;
	case UAND_TOK:		ap = g_uand (op1_ptr(ep)); break;
	case UMINUS_TOK:	ap = g_uneg (op1_ptr(ep), TWOS_COMPLEMENT); break;

	case UPLUS_TOK:		ap = g_uplus (op1_ptr(ep));	break;
	case USTAR_TOK:		ap = g_ustar (op1_ptr(ep));	break;

	case XOR_TOK:		ap = g_eor (op2_ptr(ep), NON_ASSN_OP); break;
	case XOR_ASSN_TOK:	ap = g_eor (op2_ptr(ep), ASSN_OP);     break;

	default:
		fatal(es("unknown operator: "); es(tok_name(ep -&gt; n_type)));
	}

done:
	TRACEPX(ftag, eret(); eanode(ap); ecnl());
	return ap;
}
</t>
<t tx="ekr.20080529093004.748">@ Compute the address of an expression.  This code is similar to g_prim.
@c

static anode *
g_address(enode * ep)
{
	FTAG("g_address");
	anode * ap = NULL;
	STATB(ftag);
	GEN_ASSERT(ep);

	switch (ep -&gt; n_type) {

	case ARRAY_TOK:

		/* &amp; a [b] == &amp;*(a + b) = (a + b) */
		ap = g_add_sub_ip (op2_ptr(ep), NON_ASSN_OP, ADD_OP, TAKE_ADDRESS);
		goto done;
		
	case PLUS_TOK:
	
		/* Added 12/21/94 */
		ap = g_add_sub_ip (op2_ptr(ep), NON_ASSN_OP, ADD_OP, TAKE_ADDRESS);
		goto done;
		
	case MINUS_TOK:
	
		/* Added 12/21/94 */
		ap = g_add_sub_ip (op2_ptr(ep), NON_ASSN_OP, SUB_OP, TAKE_ADDRESS);
		goto done;

	case ARROW_TOK:
	case DOT_TOK:
	{
		enode * e1 = op2_ptr(ep) -&gt; arg1;
		enode * e2 = op2_ptr(ep) -&gt; arg2;

		GEN_ASSERT(e1 &amp;&amp; e2);

		/* Evaluate the left side: expressions such as a[n].x are valid. */
		if (ep -&gt; n_type == ARROW_TOK) {

			/* &amp; a -&gt; b == *a + b  */
			ap = gen_e1(e1);
		}
		else {
			/* &amp; a . b	 == &amp;a + b */
			ap = g_address(e1);
		}

		/* Add the offset of the right side of the -&gt; or . operator. */
		{
			bool junk_array_flag;
			ap = g_add_offset(ap, g_add_dots(e2, &amp;junk_array_flag));
			ap = c_lea(ap);
		}
		goto done;
	}

	case ID_TOK:

		gen_import(var_enode_ptr(ep) -&gt; e_var, DONT_USE_LIB_PREFIX);

		/* Make *sure* that the anode is alterable. */
		ap = c_copy(var_enode_ptr(ep) -&gt; e_var -&gt; sarg);

		GEN_ASSERT_TRACE(ap,
			es("NULL sarg for "); esnode(var_enode_ptr(ep) -&gt; e_var));

		/* Compute the address. */
		ap = c_lea(ap);
		goto done;

	case USTAR_TOK:		/* Bug fix: 11/2/93 */
	{
		enode * e1 = op2_ptr(ep) -&gt; arg1;

		GEN_ASSERT(e1);

		/* &amp; *a == a  */
		ap = gen_e1(e1);
		goto done;
	}
	case QUESTION_TOK:
	{
		/*
			8/26/94: It appears that code &amp;(a ? b : c) is valid
			as long as both b and c have address.
			
			The ANSI Standard is far from clear on this point,
			but Think C handles this case, and &amp;(a ? b : c) [mon] apears in StdClib.
			
			That is &amp;(a ? b : c) is the same as (a ? &amp;b : &amp;c).
			
			The following code is similar to, but not the same as, g_ternary
		*/
		enode * e1 = op3_ptr(ep) -&gt; arg1;
		enode * e2 = op3_ptr(ep) -&gt; arg2;
		enode * e3 = op3_ptr(ep) -&gt; arg3;
				
		anode * old_ap2 = NULL;
		anode * ap2 = NULL;
		anode * ap3 = NULL;

		label_cnode *else_lab = NULL;
		label_cnode *end_lab = NULL;
	
		/* Allocate label nodes. */
		new_clabel_macro(else_lab);
		new_clabel_macro(end_lab);
	
		/*
			Generate the boolean. Note:
			1) gen_bool spills all registers before generating code.
			2) all register are free after gen_bool is finished.
	
			If the above conditions were not true, it would be possible
			for registers to be spilled in one branch of the code
			generated by gen_bool and not the other branche.
		*/
		gen_bool(e1, FALL_THROUGH, else_lab);
	
		/* Generate the *address* of "fall through" branch. */
		ap2 = g_address(e2);
		ASSERT(ap2);
	
		/*
			Create a *copy* of ap2 so a record of it will exist after ap2 is freed.
			(We had better *not* free this copy!)
			Then free ap2 so its register is available to the else branch.
	
			This should be the only call to c_copy outside g_prim or cput.c.
		*/
		ap2 = c_move2atreg(ap2);
		old_ap2 = c_copy(ap2);
		free_temp(ap2);
		c_bra(end_lab);
	
		/* Generate the "else" branch. */
		c_clabel(else_lab);
		ap3 = g_address(e3);
		ASSERT(ap3);
	
		/*
			Make sure both branches leave their result in the same place.
			Also make sure old_ap2 has been freed in both branches.
		*/
		if (!is_equiv(old_ap2, ap3)) {
			c_move(ap3, old_ap2);
		}
		free_temp(ap3);
	
		/* Generate the label to which the "fall through" branch jumps. */
		c_clabel(end_lab);
	
		/*
			old_ap2 represents an A-reg which contains the result of both branches.
			This A-reg has been freed by both branches, so re-reserve it now.
		*/
		{
			int the_reg = spill_anode_ptr(old_ap2) -&gt; a_sreg;
			GEN_ASSERT(reg_is_free(the_reg));
			ap2 = get_reg(the_reg, old_ap2 -&gt; a_length, TRUE, NULL);
		}
		
		/* Return ap2. */
		ap = ap2;
		break;
	}
	
	/* 8/26/94: User errors should have beem caught in ctype.c. */
		
	default:
		PERM_ASSERT_TRACE(FALSE, es(" can not take the address of "); eenode(ep));
	}

done:
	ap -&gt; a_length = REGISTER_SIZE;

	TRACEPX(ftag, eenode(ep); eblank(); eret(); eanode(ap); ecnl());
	return ap;
}
</t>
<t tx="ekr.20080529093004.749">@ Return the offset of the last item in a chain of '.' operators. Examples: a.b.c.d or a -&gt; b.c.d
@c

static ulong
g_add_dots(enode * ep, bool * array_flag)
{
	FTAG("g_add_dots");
	ulong offset = 0;
	STATB(ftag);
	GEN_ASSERT(ep -&gt; n_type == ID_TOK || ep -&gt; n_type == DOT_TOK);

	while (ep -&gt; n_type == DOT_TOK) {

		/* Add the offset of the left side. */
		enode * ap1 = op2_ptr(ep) -&gt; arg1;
		GEN_ASSERT(ap1 &amp;&amp; ap1 -&gt; n_type == ID_TOK);
		GEN_ASSERT(s_is_su_elem(var_enode_ptr(ap1) -&gt; e_var));
		offset += var_enode_ptr(ep) -&gt; e_var -&gt; offset;

		/* Move down the chain. */
		ep = op2_ptr(ep) -&gt; arg2;
	}

	/* Compute the offset of the right side. */
	GEN_ASSERT(ep &amp;&amp; ep -&gt; n_type == ID_TOK);
	GEN_ASSERT(s_is_su_elem(var_enode_ptr(ep) -&gt; e_var));
	offset += var_enode_ptr(ep) -&gt; e_var -&gt; offset;

	/* Set the array flag in the caller. */
	(*array_flag) = s_is_array(var_enode_ptr(ep) -&gt; e_var);

	TRACEPX(ftag, eret(); eulong(offset); enl());
	return offset;
}
</t>
<t tx="ekr.20080529093004.750">@ Return an anode representing ap + offset.
@c

static anode *
g_add_offset(anode * ap, ulong offset)
{
	FTAG("g_add_offset");
	STATB(ftag);

	ap = c_move2atreg(ap);
	if (offset == 0) {
		ap -&gt; n_type = INDIRECT_EA;
	}
	else if (offset &lt; 0xffff) {

		/* Return offset(ap -&gt; s_areg) */
		anode * offset_ap;
		new_const_anode_macro(offset_ap, offset, REGISTER_SIZE);
		ap -&gt; n_type = DISPLACEMENT_EA;;
		spill_anode_ptr(ap) -&gt; a_slong = offset;
	}
	else {

		/* Return 0(ap -&gt; s_reg, D7) */
		anode * offset_ap;
		new_const_anode_macro(offset_ap, offset, REGISTER_SIZE);
		c_move_len(offset_ap, d7_anode, REGISTER_SIZE);
		ap -&gt; n_type = INDEX_EA;
		spill_anode_ptr(ap) -&gt; a_sxreg = R_D7;
	}

	TRACEPX(ftag, eret(); eanode(ap); ecnl());
	return ap;
}
</t>
<t tx="ekr.20080529093004.751">@ Generate code for the binary '+', '+=', '-' and '-=' operators applied to arbitrary operands.
@c

static anode *
g_add_sub_any (op2_enode *op2_p, bool assn_flag, bool add_flag)
{
	FTAG("g_add_sub_any");
	register anode * ap = NULL;
	register int prim1 = op2_p -&gt; arg1 -&gt; e_ctype -&gt; tprim;
	register int prim2 = op2_p -&gt; arg2 -&gt; e_ctype -&gt; tprim;
	TRACEPB(ftag, eenode(enode_ptr(op2_p)); ecnl());


	if (op2_p -&gt; e_ctype -&gt; tprim == FLOAT_TYPE) {

		/* Floating assign-ops have been translated to a sequence of operations. */
		ASSERT(!assn_flag);
		if (DOUBLE_SIZE == LONG_DOUBLE_SIZE) {
			ap = gf_op2 (op2_p, add_flag ? "d_add" : "d_sub");
		}
		else {
			ap = gf_op2 (op2_p, add_flag ? "ld_add" : "ld_sub");
		}
	}
	else if (prim1 == INT_TYPE &amp;&amp; prim2 == INT_TYPE) {
		ap = g_add_sub_ii(op2_p, assn_flag, add_flag);
	}
	else if (
		(prim1 == POINTER_TYPE || prim1 == ARRAY_TYPE) &amp;&amp;
		(prim2 == POINTER_TYPE || prim2 == ARRAY_TYPE)
	) {
		/* pointer + pointer and pointer += pointer are invalid. */
		GEN_ASSERT(!add_flag);
		ap = g_sub_pp(op2_p, assn_flag);
	}
	else {
		ap = g_add_sub_ip(op2_p, assn_flag, add_flag, DONT_TAKE_ADDRESS);
	}

	TRACEPX(ftag, eret(); eanode(ap); enl());
	return ap;
}
</t>
<t tx="ekr.20080529093004.752">@ Generate code for the '+', '+=", '-' and '-=' operators applied to two integer operands.

Machine patterns:
entry_(2, MODE1_PAT, ANY_PAT, QUICK8_PAT, DALT_PAT, X_ADDQ)
entry_(2, ANY_PAT,  AS_1_PAT, IMM_PAT,  DALT_PAT, X_ADDI)
entry_(2, ANY_PAT,  AS_1_PAT, DATA_PAT,  DN_PAT,  X_ADD)
entry_(2, ANY_PAT,  AS_1_PAT, DN_PAT,   MALT_PAT, X_ADD)
entry_(2, MODE1_PAT, ANY_PAT, QUICK8_PAT, DALT_PAT, X_SUBQ)
entry_(2, ANY_PAT,  AS_1_PAT, IMM_PAT,  DALT_PAT, X_SUBI)
entry_(2, ANY_PAT,  AS_1_PAT, DATA_PAT,  DN_PAT,  X_SUB)
entry_(2, ANY_PAT,  AS_1_PAT, DN_PAT,   MALT_PAT, X_SUB)  This routine has been revised more than 10 times!
@c

static anode *
g_add_sub_ii(op2_enode *op2_p, bool assn_flag, bool add_flag)
{
	FTAG("g_add_sub_ii");
	anode * dst_ap = NULL;
	anode * src_ap = NULL;
	TRACEPB(ftag, eenode(enode_ptr(op2_p)); ecnl());

	dst_ap = gen_e1(op2_p -&gt; arg1);
	src_ap = gen_e1(op2_p -&gt; arg2);
	GEN_ASSERT(dst_ap -&gt; a_length == src_ap -&gt; a_length);

	/* Integers *are* sometimes held in an A-reg. */
	move_aregs_to_dregs_macro(src_ap,dst_ap);

	if (a_is_zero(src_ap)) {
		/* Do nothing! */
		goto done;
	}

	if (assn_flag) {
		/* No temporary is needed for -= constant or += constant. */
		if (a_is_quick8(src_ap)) {
			c_2len2(add_flag ? X_ADDQ : X_SUBQ, src_ap, dst_ap);
		}
		else if (a_is_constant(src_ap)) {
			c_2len2(add_flag ? X_ADDI : X_SUBI, src_ap, dst_ap);
		}
		else if (a_is_dreg(dst_ap) || a_is_dreg(src_ap)) {

			/* 6/6/93: We only need *either* operand to be a D-reg, not a d-temp. */
			c_2len2(add_flag ? X_ADD : X_SUB, src_ap, dst_ap);
		}
		else {

			/* Move the *source* to the temp.  This saves a move. */
			src_ap = c_move2dtreg(src_ap);
			c_2len2(add_flag ? X_ADD : X_SUB, src_ap, dst_ap);
		}
	}
	else {
		if (add_flag) {
			setup_abelian_op_macro(ftag, src_ap, dst_ap);
		}
		else {
			dst_ap = c_move2dtreg(dst_ap);
		}

		if (a_is_quick8(src_ap)) {
			c_2len2(add_flag ? X_ADDQ : X_SUBQ, src_ap, dst_ap);
		}
		else if (a_is_constant(src_ap)) {
			c_2len2(add_flag ? X_ADDI : X_SUBI, src_ap, dst_ap);
		}
		else if (a_is_dtreg(dst_ap)) {
			c_2len2(add_flag ? X_ADD : X_SUB, src_ap, dst_ap);
		}
		else {
			c_2len2(add_flag ? X_ADD : X_SUB, src_ap, dst_ap);
		}
	}

done:
	free_temp(src_ap);

	TRACEPX(ftag, eret(); eanode(dst_ap); ecnl());
	return dst_ap;
}
</t>
<t tx="ekr.20080529093004.753">@ Gernerate code for an '+', '+=', '-' and '-=' operators involving an integer operand and a pointer operand. The result is a pointer and is returned in an A-reg.  We are computing an address instead of a value if take_address_flag is TRUE.

Machine patterns:
entry_(2, MODE1_PAT, NOT8_PAT, QUICK8_PAT, AN_PAT, X_ADDQ)
entry_(1, LEN16_PAT, LEN32_PAT, GEN_PAT,  AN_PAT, X_ADDA)
entry_(2, NOT8_PAT, AS_1_PAT, GEN_PAT,  AN_PAT, X_ADDA)
entry_(2, MODE1_PAT, NOT8_PAT, QUICK8_PAT, AN_PAT, X_SUBQ)
entry_(1, LEN16_PAT, LEN32_PAT, GEN_PAT,  AN_PAT, X_SUBA)
entry_(2, NOT8_PAT, AS_1_PAT, GEN_PAT,  AN_PAT, X_SUBA)
@c

static anode *
g_add_sub_ip (op2_enode *op2_p, bool assn_flag, bool add_flag, bool take_address_flag)
{
	FTAG("g_add_sub_ip");
	anode * pap = NULL;
	anode * iap = NULL;
	enode * the_ptr = NULL;
	TRACEPB(ftag, eenode(enode_ptr(op2_p)); ecnl());

	/* The type of op2_p is what the pointer points to or the type of the array element. */
	GEN_ASSERT(op2_p -&gt; e_ctype);
	GEN_ASSERT(op2_p -&gt; arg1 &amp;&amp; op2_p -&gt; arg1 -&gt; e_ctype);
	GEN_ASSERT(op2_p -&gt; arg2 &amp;&amp; op2_p -&gt; arg2 -&gt; e_ctype);

	/* Make iap the integer part and pap the pointer part. */
	if (op2_p -&gt; arg1 -&gt; e_ctype -&gt; tprim == INT_TYPE) {

		GEN_ASSERT(
			op2_p -&gt; arg2 -&gt; e_ctype -&gt; tprim == POINTER_TYPE ||
			op2_p -&gt; arg2 -&gt; e_ctype -&gt; tprim == ARRAY_TYPE);

		the_ptr = op2_p -&gt; arg2;
		iap = gen_e1(op2_p -&gt; arg1);

		if (op2_p -&gt; arg2 -&gt; e_ctype -&gt; tprim == ARRAY_TYPE) {
			pap = g_address(op2_p -&gt; arg2);
		}
		else {
			pap = gen_e1(op2_p -&gt; arg2);
		}
	}
	else {

		GEN_ASSERT(op2_p -&gt; arg2 -&gt; e_ctype -&gt; tprim == INT_TYPE);
		GEN_ASSERT(
			op2_p -&gt; arg1 -&gt; e_ctype -&gt; tprim == POINTER_TYPE ||
			op2_p -&gt; arg1 -&gt; e_ctype -&gt; tprim == ARRAY_TYPE);

		the_ptr = op2_p -&gt; arg1;
		iap = gen_e1(op2_p -&gt; arg2);

		if (op2_p -&gt; arg1 -&gt; e_ctype -&gt; tprim == ARRAY_TYPE) {
			pap = g_address(op2_p -&gt; arg1);
		}
		else {
			pap = gen_e1(op2_p -&gt; arg1);
		}
	}

	GEN_ASSERT(the_ptr);

	/* Multiply iap by the size of an array element. */
	GEN_ASSERT(
		the_ptr -&gt; e_ctype -&gt; tprim == POINTER_TYPE ||
		the_ptr -&gt; e_ctype -&gt; tprim == ARRAY_TYPE);

	GEN_ASSERT(the_ptr -&gt; e_ctype -&gt; ttype);

	/* Multiply iap by the scale factor. */
	if (op2_p -&gt; n_type == ARRAY_TOK) {

		/* The scale factor is the size of array element. */
		iap = g_scale(iap, op2_p -&gt; e_ctype -&gt; tsize);
	}
	else {

		/* The scale factor is the size of what the pointer points to. */
		iap = g_scale(iap, op2_p -&gt; e_ctype -&gt; ttype -&gt; tsize);
	}

	/*
		Handle all constant operands here.

		Attempt to do the operation in the address mode itself.
		This is an extremely important and effective optimization.

		Warning: some assemblers and linkers may not accept address
		modes of the form sym+n where sym is an external symbol.
	*/
	if (a_is_constant(iap)) {

		long val = const_anode_ptr(iap) -&gt; a_long;

		/* 4/3/93: Do nothing if the value is zero. */
		if (val == 0) {
			goto done;
		}

		if (
			pap -&gt; n_type == ADDRESS_EA &amp;&amp;
			val + var_anode_ptr(pap) -&gt; a_voffset &lt; 0xffff
		) {
			if (add_flag) {
				var_anode_ptr(pap) -&gt; a_voffset += val;
			}
			else {
				var_anode_ptr(pap) -&gt; a_voffset -= val;
			}
			goto done;
		}

		/* Real code is required. */
		if (!assn_flag) {
			pap = c_move2atreg(pap);
		}

		GEN_ASSERT(pap -&gt; a_length == POINTER_SIZE);
		if (a_is_quick8(iap)) {

			/*
				All operands are allowed as the destination of ADDQ,
				but only word and long size is allowed for a-regs.
			*/
			c_2len(add_flag ? X_ADDQ : X_SUBQ, iap, pap, POINTER_SIZE);

		}
		else if (a_is_areg(pap)) {

			/* ADDA allows only word and long size. */
			c_2len(add_flag ? X_ADDA : X_SUBA, iap, pap, POINTER_SIZE);
		}
		else {

			/* ADDI allows all sizes, but the source must not be an a-reg. */
			c_2len(add_flag ? X_ADDI : X_SUBI, iap, pap, POINTER_SIZE);
		}
		goto done;
	}

	/* iap is not a constant here so the following statement is defensive coding. */
	iap = c_move2dtreg(iap);

	/* Real code is required.  Move pap into a temp if required. */
	if (!assn_flag) {
		pap = c_move2atreg(pap);
	}
	GEN_ASSERT(pap -&gt; a_length == 4);

	if (a_is_areg(pap)) {

		/*
			We only need to extend bytes to word because
			ADDA affects all bits of the destination.
		*/
		if (iap -&gt; a_length == 1) {
			c_1len(X_EXT, iap, 2);
		}
		c_2len(add_flag ? X_ADDA : X_SUBA, iap, pap, max(2, iap -&gt; a_length));
	}
	else {

		/* We must extend both bytes and words to long. */
		if (iap -&gt; a_length == 1) {
			c_1len(X_EXT, iap, 2);
			c_1len(X_EXT, iap, 4);
		}
		else if (iap -&gt; a_length == 2) {
			c_1len(X_EXT, iap, 4);
		}
		c_2len(add_flag ? X_ADD : X_SUB, iap, pap, 4);
	}

done:
	free_temp(iap);

	TRACEPX(ftag, eret(); eanode(pap); ecnl());
	return pap;
}
</t>
<t tx="ekr.20080529093004.754">@ Generate code for the binary '&amp;' and '&amp;=' and '|' and '|=' operators. These operators take only integral arguments.

valid machine patterns:
entry_(2, ANY_PAT, AS_1_PAT, DATA_PAT, DN_PAT,  X_AND)
entry_(2, ANY_PAT, AS_1_PAT, DN_PAT,  MALT_PAT, X_AND)
entry_(2, ANY_PAT, AS_1_PAT, IMM_PAT, DALT_PAT, X_ANDI)
entry_(1, ANY_PAT, AS_1_PAT, DATA_PAT, DN_PAT,  X_OR)
entry_(2, ANY_PAT, AS_1_PAT, DN_PAT,  MALT_PAT, X_OR)
entry_(2, ANY_PAT, AS_1_PAT, IMM_PAT, DALT_PAT, X_ORI)
@c

static anode *
g_and_or (op2_enode *op2_p, bool assn_flag, bool and_flag)
{
	FTAG("g_and_or");
	anode * dst_ap = NULL;
	anode * src_ap = NULL;
	STATB(ftag);

	dst_ap = gen_e1(op2_p -&gt; arg1);
	src_ap = gen_e1(op2_p -&gt; arg2);
	GEN_ASSERT(dst_ap -&gt; a_length == src_ap -&gt; a_length);

	/* Integers *are* sometimes held in an A-reg. */
	move_aregs_to_dregs_macro(src_ap,dst_ap);

	/* 6/2/93: Rewrote code so code for assn_ops is better. */
	if (assn_flag) {
		if (a_is_constant(src_ap)) {

			/* *Any* destination is valid when the source is a constant. */
			c_2len2(and_flag ? X_ANDI: X_ORI, src_ap, dst_ap);
		}
		else if (a_is_dreg(dst_ap)) {
			/* 6/6/93: The destination need only be a D-reg, not a D-temp. */
			c_2len2(and_flag ? X_AND : X_OR, src_ap, dst_ap);
		}
		else {
			src_ap = c_move2dtreg(src_ap);
			c_2len2(and_flag ? X_AND : X_OR, src_ap, dst_ap);
		}
	}
	else {
		setup_abelian_op_macro(ftag, src_ap, dst_ap);
		GEN_ASSERT(a_is_dtreg(dst_ap));

		if (a_is_constant(src_ap)) {
			c_2len2(and_flag ? X_ANDI: X_ORI, src_ap, dst_ap);
		}
		else {
			c_2len2(and_flag ? X_AND : X_OR, src_ap, dst_ap);
		}
	}

	free_temp(src_ap);

	TRACEPX(ftag, eret(); eanode(dst_ap); ecnl());
	return dst_ap;
}
</t>
<t tx="ekr.20080529093004.755">@ Push a series of call arguments and return a value to be used in the compensating ADDQ following the JSR.
@c

static ulong
g_args(enode *ep, bool top_flag)
{
	FTAG("g_args");
	register ulong size = 0;
	STATB(ftag);
	
	if (ep) {

		if (ep -&gt; n_type == CONS_TOK) {

			/* There is more than one argument. */
			size =  g_args(cons_ptr(ep) -&gt; n_next,   NOT_TOP_LEVEL);
			size += g_arg1(cons_ptr(ep) -&gt; cons_car, NOT_TOP_LEVEL);
		}
		else {
			size = g_arg1(ep, top_flag);
		}
	}

	GEN_ASSERT((size &amp; 1) == 0);
	TRACEPX(ftag, eret(); eulong(size); enl());
	return size;
}
</t>
<t tx="ekr.20080529093004.756">@ Push a call argument and return a value to be used in the compensating ADDQ following the JSR. The argument is the function's only argument if one_arg_flag is true.  An inner use of the call_1arg optimization is valid *only* if one_arg_flag is true.

Example1 (valid): z(y(x));

move x(sp) ;inner call to y(x)
jsr y;
move d0,(sp)
jsr z ;outer call to z(y(x))

Example 2: (invalid): z(y(x),w);
move w,-(sp);  move x,(sp); ;wipes out previously pushed w!
jsr y  move d0,-(sp)  jsr z
@c

static ulong
g_arg1(enode *ep, bool one_arg_flag)
{
	FTAG("g_arg1");
	ulong stack_size = 0;
	anode * ap = NULL;
	tnode * t = ep -&gt; e_ctype;
	STATB(ftag);

	if (t == NULL) {
		goto done;
	}

	if (one_arg_flag) {
		ap = gen_e1(ep);
	}
	else {

		/* Disable the call_1arg optimization in inner function calls. */
		long save_1arg_flag = gen_call_1arg;
		gen_call_1arg = 0;
		ap = gen_e1(ep);
		gen_call_1arg = save_1arg_flag;
	}

	if (t -&gt; tprim == FLOAT_TYPE) {
		stack_size = c_push_float(ap, one_arg_flag, ep);
	}
	else {
		stack_size = c_push(ap, one_arg_flag);
		free_temp(ap);
	}

done:
	TRACEPX(ftag, eret(); eulong(stack_size); enl());
	return stack_size;
}
</t>
<t tx="ekr.20080529093004.757">@ Generate code for the '=' operator.
@c

static anode *
g_assn (op2_enode *op2_p)
{
	FTAG("g_assn");
	anode * dst_ap = NULL;
	anode * src_ap = NULL;
	TRACEPB(ftag, eenode(enode_ptr(op2_p)); enl());

	/*
		Bug fix: 3/6/93.
		Generate the source first so spills in the source do not affect the destination.
		This can happen as the result of the ternary operator.
	*/
	src_ap = gen_e1(op2_p -&gt; arg2);
	dst_ap = gen_e1(op2_p -&gt; arg1);

	GEN_ASSERT_TRACE(
		dst_ap -&gt; a_length == src_ap -&gt; a_length ||
		op2_p -&gt; e_ctype -&gt; tprim == FLOAT_TYPE || /* 12/14/94 */
		op2_p -&gt; e_ctype -&gt; tprim == STRUCT_TYPE ||	/* 5/31/94 */
		op2_p -&gt; e_ctype -&gt; tprim == UNION_TYPE,
		es("dst len: "); eint(dst_ap -&gt; a_length);
		es(", src len: "); eint(src_ap -&gt; a_length));
	GEN_ASSERT(op2_p -&gt; e_ctype);

	if (op2_p -&gt; e_ctype -&gt; tprim == FLOAT_TYPE) {

		/* Bug fix: 3/8/93: let gf_assn2 free regs as needed. */
		dst_ap = gf_assn2(op2_p, dst_ap, src_ap);
	}
	else if (
		op2_p -&gt; e_ctype -&gt; tprim == INT_TYPE ||
		op2_p -&gt; e_ctype -&gt; tprim == POINTER_TYPE ||
		op2_p -&gt; e_ctype -&gt; tprim == ARRAY_TYPE
	) {

		/* Bug fix, 4/30/93: can't move a byte from an A-reg. */
		if (a_is_areg(src_ap) &amp;&amp; src_ap -&gt; a_length == 1) {

			/* Set the length to 4 so we will get a valid move. */
			src_ap -&gt; a_length = 4;
			src_ap = c_move2dtreg(src_ap);
			src_ap -&gt; a_length = 1;
		}
		c_move(src_ap, dst_ap);
		free_temp(src_ap);
	}
	else {
		c_move_big(
			src_ap, TAKE_ADDRESS, dst_ap, TAKE_ADDRESS, op2_p -&gt; e_ctype -&gt; tsize);
		free_temp(src_ap);
	}

	TRACEPX(ftag, eret(); eanode(dst_ap); ecnl());
	return dst_ap;
}
</t>
<t tx="ekr.20080529093004.758">@ Generate code for function calls.
@c

anode *
g_call (op2_enode *op2_p)
{
	FTAG("g_call");
	
		anode * ap = NULL;
		anode * ap_addr = NULL;
		anode * stack_ap = NULL;

		int   mlen = 0;
		ulong size = 0;
		int   tprim = 0;
		ulong tsize = 0;
	
	STATB(ftag);
	GEN_ASSERT(op2_p -&gt; e_ctype);
	
	tprim = op2_p -&gt; e_ctype -&gt; tprim;
	tsize = op2_p -&gt; e_ctype -&gt; tsize;
	mlen = c_e2mlen(enode_ptr(op2_p));

	/*
		Generate the argument list.
		Bug fix 12/29/94:
			Disable the call_1arg optimization for functions returning large values
			so the hidden pointer does not clobber other args.
	*/
	size = g_args(op2_p -&gt; arg2,
		(tprim != VOID_TYPE &amp;&amp; tsize &gt; REGISTER_SIZE) ? NOT_TOP_LEVEL : TOP_LEVEL);
	
	/* Generate a hidden pointer to a stack temp for large values. */
	if (tprim != VOID_TYPE &amp;&amp; tsize &gt; REGISTER_SIZE) {

		stack_ap = gen_new_stack_anode(tsize, REGISTER_SIZE, "hidden ptr", NO_NAME);

		/* Push a pointer to the stack temp. */
		c_1(X_PEA, stack_ap);
		size += REGISTER_SIZE;
	}

	/*
		Generate the address of the function.
		Usually, the address will be the function's name,
		but computed addresses are possible.
	*/
	ap_addr = gen_e1(op2_p -&gt; arg1);

	/*
		A trick: free ap_addr *before* calling the function.
		This way, ap_addr will not be spilled if it happens to conflict
		with the register used for the return value.
		This is safe because the following code can never alter ap_addr.
	*/
	free_temp(ap_addr);

	/*
		Allocate the register that is to hold the result.
		
		12/15/94
		Functions that return large floats, structs or unions
		return the value in a stack temporary.
	*/
	if (tprim == VOID_TYPE) {
		ap = NULL;
	}
	else if (tsize &gt; REGISTER_SIZE) {
		ap = stack_ap;
	}
	else if (tprim == INT_TYPE ||arg_d0_only_flag) {
		ap = get_d0(mlen);
	}
	else {
		ap = get_a0(mlen);
	}

	/*
		Generate the function call.
		This works even if ap_addr is the recently freed address.
	*/
	c_1(X_JSR, ap_addr);

	/* Generate the code to reset the stack pointer */
	c_adj_stack(size);

	/* The value of the function is the return register. */
	TRACEPX(ftag, eret(); eanode(ap); ecnl());
	return ap;
}
</t>
<t tx="ekr.20080529093004.759">@ Call an integer math library routine with 2 arguments. Return an anode representing the result. Free src_ap but not dst_ap.  The order of operands is the order needed by the calls such as:  _lib_ldivu(u, v)  computing u/v. Since u must be the destination (consider u /= v), we push the source first, then the destination.
@c

static anode *
g_call_math2 (char *name,
	op2_enode * op2_p,
	anode * src_ap,
	anode * dst_ap)
{
	FTAG("g_call_math2");
	anode * result_ap = NULL;
	anode * d0_ap = NULL;
	tnode * result_t = NULL;
	ulong stack_size = 0;
	TRACEPB(ftag,
		es(name);
		es(", src_ap: ");  eanode(src_ap);
		es(", dst_ap: ");  eanode(dst_ap);
		enl());

	GEN_ASSERT(
		op2_p &amp;&amp; op2_p -&gt; e_ctype &amp;&amp;
		op2_p -&gt; arg1 &amp;&amp; op2_p -&gt; arg1 -&gt; e_ctype &amp;&amp;
		op2_p -&gt; arg2 &amp;&amp; op2_p -&gt; arg2 -&gt; e_ctype);

	/* Define a useful abbreviation. */
	result_t = op2_p -&gt; e_ctype;

	/* Push the arguments in reverse order. */
	stack_size += c_push(src_ap, MULTIPLE_ARGS);
	stack_size += c_push(dst_ap, MULTIPLE_ARGS);
	free_temp(src_ap);

	/*
		The result will be returned in D0.
		Make sure we preserve D0 before calling the function.

		Allocate stack space for the result and push a pointer to that space.
	*/

	GEN_ASSERT(result_t -&gt; tprim == INT_TYPE);
	d0_ap = get_d0(result_t -&gt; tsize);
	result_ap = d0_ap;

	/* This assert checks that d0 has not been spilled. */
	GEN_ASSERT(d0_ap &amp;&amp; d0_ap -&gt; n_type == DREG_EA);

	/* Generate the function call. */
	{
		/* Create an anode for the library name. */
		anode * ap = NULL;
		new_anode_macro(ap, sizeof(var_anode), ABSOLUTE_EA);
		var_anode_ptr(ap) -&gt; a_vkind = LIBNAME_VKIND;
		var_anode_ptr(ap) -&gt; a_vname = name;

		c_1(X_JSR, ap);
		gen_import_name(name, USE_LIB_PREFIX);
	}

	/* Generate the code to reset the stack pointer */
	c_adj_stack(stack_size);

	TRACEPX(ftag, eret(); eanode(result_ap); ecnl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.760">@ Generate code for operators casting to an integer.  Code is generated only for widening casts or for conversion of floats to ints. Truncating casts merely change the a_length field, though the node must be copied. The determination that a widening cast is needed has already been done by ct.c.  The new type is op1_p -&gt; ctype; the old type is op1_p -&gt; arg1 -&gt; ctype.
@c

static anode *
g_cast (op1_enode *op1_p)
{
	FTAG("g_cast");
	anode * result_ap = NULL;
	anode * ap1 = NULL;
	tnode * t1 = NULL;
	int mlen = 0;
	int old_mlen = 0;
	STATB(ftag);

	GEN_ASSERT(op1_p -&gt; arg1);
	GEN_ASSERT(op1_p -&gt; e_ctype &amp;&amp; op1_p -&gt; arg1 -&gt; e_ctype);
	t1  = op1_p -&gt; arg1 -&gt; e_ctype;

	/*
		Bug fix: 11/4/93: Casts to void return a NULL result,
		but the argument to the cast must be evaluated!
		For example, consider the function call

			(void) f(a);

		We must also free ap1 here, since NULL, not ap1, is returned.
	*/
	if (op1_p -&gt; e_ctype -&gt; tprim == VOID_TYPE) {
		ap1 = gen_e1(op1_p -&gt; arg1);
		free_temp(ap1);
		result_ap = NULL;
		goto done;
	}

	/* Casts to or from floating operands are handled in gfloat.c. */
	if (op1_p -&gt; e_ctype -&gt; tprim == FLOAT_TYPE) {
		result_ap = gf_cast2f(op1_p);
		goto done;
	}
	else if (
		op1_p -&gt; e_ctype -&gt; tprim == INT_TYPE &amp;&amp;
		t1 -&gt; tprim == FLOAT_TYPE
	) {
		result_ap = gf_cast2i(op1_p);
		goto done;
	}

	ap1 = gen_e1(op1_p -&gt; arg1);
	mlen = c_e2mlen(enode_ptr(op1_p));

	TRACEPN(ftag, es("converting "); eanode(ap1); es(" to size "); eint(mlen); enl());

	/*
		6/3/93:
		A cast that truncates a constant can cause problems later.
		For example, MOVE.B #300,var is invalid.
	*/
	if (mlen &lt;= ap1 -&gt; a_length &amp;&amp; a_is_constant(ap1)) {

		ulong mask = 0;
		long old_val = const_anode_ptr(ap1) -&gt; a_long;
		ulong old_bits = 0;
		ulong new_bits = 0;

		result_ap = c_copy(ap1);
		result_ap -&gt; a_length = mlen;

		/*
			See if the value is preserved after being truncated.
			Mask off the sign bits only on negative numbers.
		*/
		switch(mlen) {
		case 1: mask = 0xff; break;
		case 2: mask = 0xffff; break;
		case 4: mask = 0xffffffff; break;
		default: fatal(es("bad mlen"));
		}

		old_bits = (old_val &lt; 0) ? (old_val &amp; mask) : old_val;
		new_bits = (old_val &amp; mask);

		/* Print unsigned values in the warning so the truncation is clear. */
		if (old_bits != new_bits) {
			delayed_warning(gen_expr_line,
				es("constant truncated from: "); eulong(old_bits);
				es(" to: "); eulong(new_bits));
		}

		const_anode_ptr(result_ap) -&gt; a_long = new_bits;
		goto done;
	}

	/* 6/8/93: Constants can be widened without generating code. */
	if (a_is_constant(ap1)) {

		/*
			Bug fix: 7/25/93: The *result* type controls sign extention.
			Bug fix: 1/11/95:
			According to the Standard, the *old* type controls sign extension.
			(See comments in c_ext.)
		*/
		// result_ap = c_ext_constant(ap1, mlen, t_is_unsigned(op1_p -&gt; e_ctype));
		result_ap = c_ext_constant(ap1, mlen, t_is_unsigned(op1_p -&gt; arg1 -&gt; e_ctype));
		goto done;
	}

	/*
		Integer truncating casts or casts that convert from signed to unsigned or
		vice versa never change the bit pattern of the argument.
		This works because the argument a_length changes.

		6/30/93: However...

		We must change the *address* of the narrower constant because
		on the 68000 the address of a datum is the address of its *most*
		significant byte.

		For example, to truncate a long to a byte, we must add 3 to the address
		of the long to get the address of the byte.
	*/
	if (mlen &lt;= ap1 -&gt; a_length) {

		int difference = ap1 -&gt; a_length - mlen;
		result_ap = ap1;
		result_ap -&gt; a_length = mlen;
		if (difference == 0) {
			goto done;
		}

		switch(result_ap -&gt; n_type) {

		case AREG_EA:			/* An */
		case DREG_EA:			/* Dn */

			/* The length specifier will adjust the address. */
			goto done;

		case INDIRECT_EA:		/* (An) */

			/* Convert (An) to difference(An) */
			result_ap -&gt; n_type = DISPLACEMENT_EA;
			spill_anode_ptr(result_ap) -&gt; a_slong += difference;
			goto done;

		case ABSOLUTE_EA:		/* address */
		case ADDRESS_EA:

			/* create address + difference */
			var_anode_ptr(result_ap) -&gt; a_voffset += difference;
			goto done;

		case DISPLACEMENT_EA:	/* word(An) */
		case INDEX_EA:			/* byte(An,Dn);
		case PC_DISP_EA:		/* word(pc) */
		case PC_INDEX_EA:		/* byte(pc,xn) */

			/* Just adjust the offset. */
			spill_anode_ptr(result_ap) -&gt; a_slong += difference;
			goto done;

		case IMMEDIATE_EA:		/* #data */

			/* Leave integer constants alone. */
			if (const_anode_ptr(result_ap) -&gt; a_ckind == LONG_CKIND) {
				goto done;
			}

			/* Fall through. */

		default:
			os("&lt;can't shrink this address mode: ");
			os(tok_name(result_ap -&gt; n_type));
			os("&gt;\n");

			fatal(
				es("&lt;can't shrink this address mode: ");
				es(tok_name(result_ap -&gt; n_type));
				es("&gt;\n");
			);
		}
	}

	/*
		At this point we know that mlen &gt; mlen1.
		7/7/93: just use c_ext.

		Bug fix: 7/25/93: The *result* type controls sign extention.
		Bug fix: 1/11/95:
			According to the Standard, the *old* type controls sign extention.
			(See comments in c_ext.)
	*/
	result_ap = c_ext(ap1, mlen, t_is_unsigned(op1_p -&gt; arg1 -&gt; e_ctype));

done:
	TRACEPX(ftag, eret(); eanode(result_ap); ecnl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.761">@ Generate an integer comparison. (This code is also used by gbool.c.) Return TRUE if the the compare was reversed from "normal order."  The compare instruction has the following variants:    dest  src

TST &lt;ea&gt;  &lt;ea&gt; - 0 (&lt;ea&gt; does not include an)
CMP &lt;ea&gt;,dn dn  - &lt;ea&gt;
CMPA &lt;ea&gt;,an an  - &lt;ea&gt;
CMPI #&lt;data&gt;,&lt;ea&gt; &lt;ea&gt; - &lt;data&gt; (&lt;ea&gt; does not include an)
@c

bool
g_cmp(anode *src_ap, anode *dst_ap)
{
	FTAG("g_cmp");
	register bool switch_flag = FALSE;
	STATB(ftag);

	if (a_is_constant(src_ap) &amp;&amp; a_is_constant(dst_ap)) {
		dst_ap = c_move2dtreg(dst_ap);
		c_2len2(X_CMPI, src_ap, dst_ap);
	}
	else if (a_is_areg(dst_ap)) {
		c_2len2(X_CMPA, src_ap, dst_ap);
	}
	else if (a_is_areg(src_ap)) {
		switch_flag = TRUE;
		c_2len2(X_CMPA, dst_ap, src_ap);
	}
	else if (a_is_constant(src_ap)) {
		/*
			The only modes not allowed for dst_ap,
			namely immediate and A-reg, have already been handled.
		*/
		if (a_is_zero(src_ap)) {
			c_1len1(X_TST, /* 0, */ dst_ap);
		}
		else {
			c_2len2(X_CMPI, src_ap, dst_ap);
		}
	}
	else if (a_is_constant(dst_ap)) {
		switch_flag = TRUE;

		/*
			The only modes not allowed for src_ap,
			namely immediate and A-reg, have already been handled.
		*/
		if (a_is_zero(dst_ap)) {
			c_1len1(X_TST, /* 0, */ src_ap);
		}
		else {
			c_2len2(X_CMPI, dst_ap, src_ap);
		}
	}
	else if (a_is_dreg(dst_ap)) {
		c_2len2(X_CMP, src_ap, dst_ap);
	}
	else if (a_is_dreg(src_ap)) {
		switch_flag = TRUE;
		c_2len2(X_CMP, dst_ap, src_ap);
	}
	else {
		dst_ap = c_move2dtreg(dst_ap);
		c_2len2(X_CMP, src_ap, dst_ap);
	}

	free_temp(src_ap);
	free_temp(dst_ap);

	STATX(ftag);
	return switch_flag;
}
</t>
<t tx="ekr.20080529093004.762">@ Generate code for the binary comma operator.
@c

anode *
g_comma (op2_enode *op2_p)
{
	FTAG("g_comma");
	anode * result_ap = NULL;
	STATB(ftag);

	/* Generate first subtree and discard. */
	result_ap = gen_e1(op2_p -&gt; arg1);
	free_temp(result_ap);

	/* Generate second subtree. */
	result_ap = gen_e1(op2_p -&gt; arg2);

	TRACEPX(ftag, eret(); eanode(result_ap); ecnl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.763">@ Generate code for the list separator. This is the same as for the comma operator, except for the name of the first subfield.
@c

anode *
g_cons(cons_enode *ep)
{
	FTAG("g_cons");
	register anode * result_ap = NULL;
	STATB(ftag);

	/* Generate first subtree and discard the result */
	result_ap = gen_e1(ep -&gt; cons_car);
	free_temp(result_ap);

	/* Now generate the second subtree. */
	result_ap = gen_e1(ep -&gt; n_next);

	TRACEPX(ftag, eret(); eanode(result_ap); ecnl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.764">@ Generate code for the '/' and '/=' and '%' and '%=' operators. Compute ep -&gt; arg1 op ep -&gt; arg2.  Machine patterns:  entry_(0, LEN16_PAT, NOT8_PAT, DATA_PAT, DN_PAT, X_DIVS)  At present no divisions are done by shifting. Remember that only *unsigned* quantities may be divided by shifting.
@c

static anode *
g_div_mod (op2_enode *op2_p, bool assn_flag, bool mod_flag)
{
	FTAG("g_div_mod");
	register anode * dst_ap = NULL;
	register anode * src_ap = NULL;
	anode * old_dst = NULL;
	STATB(ftag);

	/* Floating division is handled in gfloat.c. */
	if (op2_p -&gt; e_ctype -&gt; tprim == FLOAT_TYPE &amp;&amp; !mod_flag) {

		/* Floating assign-ops have been translated to a sequence of operations. */
		ASSERT(!assn_flag);
		dst_ap = gf_op2(op2_p, (DOUBLE_SIZE == LONG_DOUBLE_SIZE) ? "d_div" : "ld_div");
		goto done;
	}

	dst_ap = gen_e1(op2_p -&gt; arg1);
	src_ap = gen_e1(op2_p -&gt; arg2);
	GEN_ASSERT(dst_ap -&gt; a_length == src_ap -&gt; a_length);

	/* Long division is different since it uses a function call. */
	if (dst_ap -&gt; a_length == 4) {

		char * lib_name = NULL;
		anode * temp_ap = NULL;

		if (t_is_unsigned(op2_p -&gt; e_ctype)) {
			lib_name = mod_flag ? "lmodu" : "ldivu";
		}
		else {
			lib_name = mod_flag ? "lmod" : "ldiv";
		}
		temp_ap = g_call_math2(lib_name, op2_p, src_ap, dst_ap);

		if (assn_flag) {
			/* The size of temp_ap is still 4. */
			c_move(temp_ap,dst_ap);
		}
		free_temp(dst_ap);
		dst_ap = temp_ap;
		goto done;
	}

	/*
		Make sure dst_ap is a D-temp.
		For assign ops, copy old_dst to dst_ap *without* freeing old_dst!
	*/
	if (assn_flag) {

		old_dst = dst_ap;
		if (!a_is_dtreg(dst_ap)) {
			/* Do not free old_dst! */
			dst_ap = get_dtemp(dst_ap -&gt; a_length);
			c_move(old_dst, dst_ap);
		}
	}
	else {
		dst_ap = c_move2dtreg(dst_ap);
	}

	if (dst_ap -&gt; a_length == 1) {
		src_ap = c_move2dtreg(src_ap);
		c_1len(X_EXT,src_ap, 2);
		c_1len(X_EXT,dst_ap, 2);
	}

	c_1len(X_EXT,dst_ap,4);
	c_2(t_is_unsigned(op2_p -&gt; e_ctype) ? X_DIVU : X_DIVS, src_ap, dst_ap);
	if (mod_flag) {
		c_1(X_SWAP, dst_ap);
	}

	/* Complete the assignment. */
	if (assn_flag &amp;&amp; old_dst != dst_ap) {
		c_move(dst_ap, old_dst);
		free_temp(old_dst);
	}
	free_temp(src_ap);

done:
	TRACEPX(ftag, eret(); eanode(dst_ap); ecnl());
	return dst_ap;
}
</t>
<t tx="ekr.20080529093004.765">@ Generate code for the '^' and '^=' operators. These operators require integral operands.  valid machine patterns:
entry_(2, ANY_PAT, AS_1_PAT, DN_PAT,  DALT_PAT, X_EOR)
entry_(2, ANY_PAT, AS_1_PAT, IMM_PAT,  DALT_PAT, X_EORI)

Unlike the X_AND and X_OR machine instructions, the X_EOR machine instructions requires the source to be a D-reg or an immediate. This changes the code significanly.
@c

static anode *
g_eor (op2_enode *op2_p, bool assn_flag)
{
	FTAG("g_eor");
	anode * result_ap = NULL;
	anode * dst_ap = NULL;
	anode * src_ap = NULL;
	STATB(ftag);

	dst_ap = gen_e1(op2_p -&gt; arg1);
	src_ap = gen_e1(op2_p -&gt; arg2);
	GEN_ASSERT(dst_ap -&gt; a_length == src_ap -&gt; a_length);

	/* Integers *are* sometimes held in an A-reg. */
	move_aregs_to_dregs_macro(src_ap,dst_ap);

	/*
		The EOR instruction is different from the other instructions.
		The *source* must either be a D-reg or an immediate operator.
	*/
	if (assn_flag) {

		if (a_is_constant(src_ap)) {

			/* *Any* destination is valid when the source is a constant. */
			c_2len2(X_EORI, src_ap, dst_ap);
		}
		else {
			src_ap = c_move2dtreg(src_ap);
			c_2len2(X_EOR, src_ap, dst_ap);
		}
	}
	else {
		/*
			This is slightly different from setup_abelian_op_macro because
			*both* the source and destination must be D-regs if the
			source is not a constant.
		*/
		if (a_is_constant(dst_ap) &amp;&amp; !a_is_constant(src_ap)) {
			swap_ap(dst_ap, src_ap);
		}
		dst_ap = c_move2dtreg(dst_ap);

		if (a_is_constant(src_ap)) {
			c_2len2(X_EORI, src_ap, dst_ap);
		}
		else {
			src_ap = c_move2dtreg(src_ap);
			c_2len2(X_EOR, src_ap, dst_ap);
		}
	}

	free_temp(src_ap);

	TRACEPX(ftag, eret(); eanode(dst_ap); ecnl());
	return dst_ap;
}
</t>
<t tx="ekr.20080529093004.766">@ Generate code for the array subscripting operator.
@c

anode *
g_index (op2_enode *op2_p)
{
	FTAG("g_index");
	anode * ap = NULL;
	STATB(ftag);

	/* Generate op2_p -&gt; arg1 + op2_p -&gt; arg2. */
	ap = g_add_sub_ip (op2_p, NON_ASSN_OP, ADD_OP, DONT_TAKE_ADDRESS);

	/*
		Convert the A-reg to (An).
		That is, perform an implicit indirection.
	*/
	if(!a_is_areg(ap)) {
		ap = c_move2atreg(ap);
	}
		
	/*
		Bug fix: 9/3/93: Don't do the indirection for floating types.
		We must be left with a pointer to the array.
	*/
	ASSERT(op2_p -&gt; e_ctype);
	if (op2_p -&gt; e_ctype -&gt; tprim != FLOAT_TYPE) {
		ap -&gt; n_type = INDIRECT_EA;
		ap -&gt; a_length = c_e2mlen(enode_ptr(op2_p));
	}

	TRACEPX(ftag, eret(); eanode(ap); ecnl());
	return ap;
}
</t>
<t tx="ekr.20080529093004.767">@ Generate code for the '||' and '&amp;&amp;' operators where the value (0 or 1) of the logical operator will actually be used.  Generate the follwing code:  [code generated from gen_bool(ep,FALL_THROUGH,else_lab) ]   MOVE #1,dtemp  BRA end_lab  else_lab:  CLR dtemp  end_lab:
@c

static anode *
g_logical(register enode *ep)
{
	FTAG("g_logical");
	register anode *ap = NULL;
	label_cnode *else_lab = NULL;
	label_cnode *end_lab = NULL;
	int mlength = c_e2mlen(ep);
	STATB(ftag);

	new_clabel_macro(else_lab);
	new_clabel_macro(end_lab);

	gen_bool(ep, FALL_THROUGH, else_lab);
	ap = get_dtemp(mlength);

	c_move_len(one_anode, ap, ap -&gt; a_length);
	c_bra(end_lab);
	c_clabel(else_lab);
	c_clr(ap);
	c_clabel(end_lab);

	TRACEPX(ftag, eret(); eenode(ep); eret(); eanode(ap));
	return ap;
}
</t>
<t tx="ekr.20080529093004.768">@ Generate code for the binary '*' and '*=' operators.

Machine patterns:

entry_(0, LEN16_PAT, NOT8_PAT, DALT_PAT, DN_PAT, X_MULS)
entry_(0, LEN16_PAT, NOT8_PAT, DALT_PAT, DN_PAT, X_MULU)
@c

static anode *
g_mult (op2_enode *op2_p, bool assn_flag)
{
	FTAG("g_mult");
	anode * result_ap = NULL;
	anode * src_ap = NULL;
	anode * dst_ap = NULL;
	anode * old_dst = NULL;
	TRACEPB(ftag,
		eenode(enode_ptr(op2_p)); ecs(); ebool(assn_flag); ecnl());

	/* Floating multiplication is handled in gfloat.c. */
	if (op2_p -&gt; e_ctype -&gt; tprim == FLOAT_TYPE) {

		/* Floating assign-ops have been translated to a sequence of operations. */
		ASSERT(!assn_flag);
		dst_ap = gf_op2(op2_p, (DOUBLE_SIZE == LONG_DOUBLE_SIZE) ? "d_mul" : "ld_mul");
		goto done;
	}

	dst_ap = gen_e1(op2_p -&gt; arg1);
	src_ap = gen_e1(op2_p -&gt; arg2);
	GEN_ASSERT(dst_ap -&gt; a_length == src_ap -&gt; a_length);

	/* Integers *are* sometimes held in an A-reg. */
	move_aregs_to_dregs_macro(src_ap,dst_ap);

	/* Long multiplication is handled with function calls. */
	if (dst_ap -&gt; a_length == 4) {

		anode * temp_ap = g_call_math2 (
			t_is_unsigned(op2_p -&gt; e_ctype) ? "lmulu" : "lmul", op2_p, src_ap, dst_ap);

		if (assn_flag) {
			/* The size of temp_ap is still 4. */
			c_move(temp_ap,dst_ap);
		}
		free_temp(dst_ap);
		dst_ap = temp_ap;
		goto done;
	}

	/*
		Set up the registers properly.
		That is, at least one of dst_ap and src_ap is a D-reg.
		In addition, dst_ap is a D-temp for non-assignment operators.
	*/
	if (assn_flag) {

		old_dst = dst_ap;
		if (!a_is_dtreg(dst_ap)) {

			/* Copy old_dst to dst_ap *without* freeing old_dst! */
			dst_ap = get_dtemp(dst_ap -&gt; a_length);
			c_move(old_dst, dst_ap);
		}
	}
	else {
		setup_abelian_op_macro(ftag, src_ap, dst_ap);
	}
	GEN_ASSERT(a_is_dtreg(dst_ap));

	if (src_ap -&gt; a_length == 1) {
		src_ap = c_move2dtreg(src_ap);
		c_1len(X_EXT, src_ap, 2);
	}

	if (dst_ap -&gt; a_length == 1) {
		c_1len(X_EXT, dst_ap, 2);
	}

	/* Bug fix: 6/3/93: use explicit length of 2 so byte multiplies work. */
	c_2len(t_is_unsigned(op2_p -&gt; e_ctype) ? X_MULU : X_MULS, src_ap, dst_ap, 2);

	/* Make sure we assign to the original destination. */
	if (assn_flag &amp;&amp; old_dst != dst_ap) {
		c_move(dst_ap, old_dst);
		free_temp(old_dst);
	}

	free_temp(src_ap);

done:
	TRACEPX(ftag, eret(); eanode(dst_ap); ecnl());
	return dst_ap;
}
</t>
<t tx="ekr.20080529093004.769">@ Generate code for the '!' operator.
@c

static anode *
g_not (op1_enode *op1_p)
{
	FTAG("g_not");
	anode * result_ap = NULL;
	bool flip = FALSE;
	STATB(ftag);

	/*
		Do a series of '!' operators here.
		flip will be FALSE if there is an even number of '!' operators.
	*/
	while (op1_p -&gt; arg1 -&gt; n_type == NOT_TOK) {
		flip = !flip;
		op1_p = op1_ptr(op1_p -&gt; arg1);
	}

	/*
		!(a &amp;&amp; b) or !(a || b) generates the same code as
		 (a &amp;&amp; b) or  (a || b), but the "true" and "false" labels are swapped.
	*/
	if (op1_p -&gt; arg1 -&gt; n_type == LOR_TOK || op1_p -&gt; arg1 -&gt; n_type == LAND_TOK) {

		label_cnode *else_lab;
		label_cnode *end_lab;

		new_clabel_macro(else_lab);
		new_clabel_macro(end_lab);

		gen_bool(op1_p -&gt; arg1, FALL_THROUGH, else_lab);

		/* gen_bool pre-spills all regs, so no spill can happen here. */
		GEN_ASSERT(reg_nd_free &gt; 0);
		
		/* Bug fix 12/21/94: use op1_p -&gt; e_ctype -&gt; tsize, not INT_SIZE. */
		GEN_ASSERT(op1_p -&gt; e_ctype &amp;&amp; op1_p -&gt; e_ctype -&gt; tsize &gt; 0);
		result_ap = get_dtemp(op1_p -&gt; e_ctype -&gt; tsize);

		/* Generate code at the "fall through" point. */
		if (flip) {
			c_move_len(one_anode, result_ap, result_ap -&gt; a_length);
			c_bra(end_lab);
			c_clabel(else_lab);
			c_clr(result_ap);
			c_clabel(end_lab);
		}
		else {
			c_clr(result_ap);
			c_bra(end_lab);
			c_clabel(else_lab);
			c_move_len(one_anode, result_ap, result_ap -&gt; a_length);
			c_clabel(end_lab);
		}
	}
	else {

		/* Generate the subexpression. */
		anode * ap1 = gen_e1(op1_p -&gt; arg1);

		/*
			Get the temp *before* the compare so flags are not disrupted.
			Bug fix 12/21/94: use op1_p -&gt; e_ctype -&gt; tsize, not INT_SIZE.
		*/
		GEN_ASSERT(op1_p -&gt; e_ctype &amp;&amp; op1_p -&gt; e_ctype -&gt; tsize &gt; 0);
		result_ap = get_dtemp(op1_p -&gt; e_ctype -&gt; tsize);

		/* Generate a compare. */
		if (a_is_areg(ap1)) {
			c_2len2(X_CMPA, zero_anode, ap1);
		}
		else {
			c_1len1(X_TST, ap1);
		}
		free_temp(ap1);

		/* Put 0 or 1 in result_ap. CAUTION: this sets *only* the low byte! */
		if (flip) {
			c_1(X_SNE, result_ap);
		}
		else {
			c_1(X_SEQ, result_ap);
		}

		/*
			As mentioned in the 68000 book,
			following an Sxx by a NEG is a quick way of converting to TRUE/FALSE.

			Bug fix 6/10/94: SEQ and SNE only set the low byte.  It must be extended!
		*/
		if (result_ap -&gt; a_length &gt; 1) {
			c_1len(X_EXT, result_ap, 2);
		}
		if (result_ap -&gt; a_length == 4) {
			c_1len(X_EXT, result_ap, 4);
		}
		c_1len(X_NEG, result_ap, result_ap -&gt; a_length);
	}

	TRACEPX(ftag, eret(); eanode(result_ap); ecnl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.770">@ Generate code for the pre- and post- increment and decrement operators.  gen_pp converts post- operators at the outer level to pre- operators. This conversion allows this routine to genenerate straightforward code without worrying about whether the D-temp created by the post- operators will actually be needed.  If star_flag is TRUE, return an anode representing either *--p or *p++, depending on inc_flag.  star_flag is an important kludge, allowing us to evaluate p only once, here, *before* deciding whether we can evaluate *--p as -(An) or *p++ as (An)+. We can't do this optimization in g_ustar because if p does *not* evaluate to an A-reg there would be no easy way for g_ustar to generate correct code.
@c

static anode *
g_pre_post (op1_enode *op1_p, bool pre_flag, bool inc_flag, bool star_flag)
{
	FTAG("g_pre_post");
	anode * result_ap = NULL;
	anode * dst_ap = NULL;
	anode * temp_ap = NULL;
	TRACEPB(ftag,
		es(pre_flag ? "PRE" : "POST"); ecs();
		es(inc_flag ? "INC" : "DEC"); ecs();
		es(star_flag ? "TAKE_STAR" : "DONT_TAKE_STAR"); enl());

	GEN_ASSERT(op1_p);

	/* The floating version of these operators is handled in gfloat.c. */
	if (op1_p -&gt; e_ctype -&gt; tprim == FLOAT_TYPE) {
		result_ap = gf_pre_post (op1_p, pre_flag, inc_flag);
		goto done;
	}

	dst_ap = gen_e1(op1_p -&gt; arg1);

	/* Special case *--p or *p++ where p evaluates to an A-reg. */
	if (star_flag &amp;&amp; dst_ap &amp;&amp; dst_ap -&gt; n_type == AREG_EA) {

		/* The special case is possible. */
		dst_ap -&gt; n_type = inc_flag ? POST_INC_EA : PRE_DEC_EA;
		result_ap = dst_ap;
		goto done;
	}

	if (!pre_flag) {

		/*
			Save the initial value in a temporary.
			6/15/93: the kind of temp depends on the result type.
		*/
		if (op1_p -&gt; e_ctype -&gt; tprim == POINTER_TYPE) {
			result_ap = get_atemp(dst_ap -&gt; a_length);
		}
		else {
			result_ap = get_dtemp(dst_ap -&gt; a_length);
		}
		c_move(dst_ap, result_ap);
	}

	if (op1_p -&gt; e_ctype -&gt; tprim == POINTER_TYPE) {

		/*
			Add the scale to the pointer.
		*/
		long scale = 1;

		/* Follow the pointer to get the scale factor. */
		GEN_ASSERT(op1_p -&gt; e_ctype -&gt; ttype);
		scale = op1_p -&gt; e_ctype -&gt; ttype -&gt; tsize;

		if (scale == 1) {
			c_2len2(inc_flag ? X_ADDQ : X_SUBQ, one_anode, dst_ap);
		}
		else if (scale &lt;= 8) {
			anode * const_ap = NULL;
			new_const_anode_macro(const_ap, scale, POINTER_SIZE);
			c_2len2(inc_flag ? X_ADDQ : X_SUBQ, const_ap, dst_ap);
		}
		else {
			anode * const_ap = NULL;
			new_const_anode_macro(const_ap, scale, POINTER_SIZE);
			if (a_is_areg(dst_ap)) {
				c_2len2(inc_flag ? X_ADDA : X_SUBA, const_ap, dst_ap);
			}
			else {
				c_2len2(inc_flag ? X_ADD : X_SUB, const_ap, dst_ap);
			}
		}
	}
	else {
		GEN_ASSERT(op1_p -&gt; e_ctype -&gt; tprim == INT_TYPE);

		c_2len2(inc_flag ? X_ADDQ : X_SUBQ, one_anode, dst_ap);
	}

	if (pre_flag) {
		result_ap = dst_ap;
	}
	else {
		/* result_ap has already been set. */
		free_temp(dst_ap);
	}

	if (star_flag) {

		/*
			If we get here, the star_flag optimization was not possible.
			Complete the indirection.
		*/
		result_ap = c_move2atreg(result_ap);
		result_ap -&gt; n_type = INDIRECT_EA;
	}

done:
	GEN_ASSERT(result_ap);
	TRACEPX(ftag, eret(); eanode(result_ap); ecnl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.771">@ Return an *alterable* anode representing the *value* of a primitive. This anode must be convertable to an anode representing the *address* of the primitive.  The following table shows how primitives are represented:  kind of object anode  n_type  example ?????????????? ?????  ??????  ??????? simple static var_anode ABSOLUTE_EA  var address of static var_anode ADDRESS_EA  #var static field spill_anode DISPLACEMENT_EA 25(a0) simple auto  spill_anode DISPLECEMENT_EA 10(a6)    spill_anode INDEX_EA  0(a6,a0) auto field  spill_anode DISPLACEMENT_EA 30(a6)    spill_anode INDEX_EA  10(a6,a0)  INDEX_EA is used only if the displacement in disp_cnode would exceed 16 bits.  anodes representing simple static values may be converted to an address merely by changing ABSOLUTE_EA to ADDRESS_EA. All other anodes are converted to addresses using the LEA instruction.  3/5/93: The code generators must be able to modify any anode returned by g_prim *without* having to first make copy of it. Indeed, copying a temporary anode is not allowed by free_temp, which expects the same anode as was allocated by get_temp, get_atemp, etc. It would be possible to make free_temp more lenient, but that would slow it down.  4/20/93: ADDRESS_EA can not be used in the Mac world. (See notes in gen.h). Thus, an LEA instruction must be used to load the address of a global variable into an A-register.
@c

anode *
g_prim (enode * ep)
{
	FTAG("g_prim");
	anode * ap = NULL;
	register long size = 0;
	STATB(ftag);

	GEN_ASSERT(ep);

	switch (ep -&gt; n_type) {

	case ARROW_TOK:
	case DOT_TOK:
	{
		anode * ap1 = NULL;
		enode * e1 = op2_ptr(ep) -&gt; arg1;
		enode * e2 = op2_ptr(ep) -&gt; arg2;
		long offset = 0;
		bool array_flag = FALSE;

		/* Evaluate the left side. */
		GEN_ASSERT(e1 &amp;&amp; e2);

		/* Bug fix: 3/8/93: expressions of the form: a[n].x are valid. */
		ap1 = gen_e1(e1);

		/* Follow a chain of '.' operators, e.g., a.b.c.d or a -&gt; b.c.d */
		offset = g_add_dots(e2, &amp;array_flag);

		/*
			Point ap at the base of the struct.
		*/
		if (ep -&gt; n_type == ARROW_TOK) {

			/*
				6/6/93: We only need an A-reg, not an A-temp.
				This saves a useless move of a user A-reg into an A-temp.

				We need not copy an A-reg since a copy is made in g_prim.
			*/
			if (a_is_areg(ap1)) {
				ap = ap1;
			}
			else {
				ap = c_move2atreg(ap1);
			}
		}
		else {
			// warning: this assumes c_lea can handle big nodes
			ap = c_lea(ap1);
		}

		/* Combine the offset and ap1. */
		ap = g_add_offset(ap, offset);

		/*
			Use address of the array, not the contents of the first element,
			so that "bare" array names will be handled correctly.
		*/
		if (array_flag == TARGET_IS_ARRAY) {

			ap = c_lea(ap);
		}
		else {

			/* The resulting a_length depends on the size of the struct/union field. */
			ap -&gt; a_length = c_e2mlen(e2);
		}
		goto done;
	}

	case ID_TOK:

		/* 3/5/93: make *sure* that the anode is alterable. */
		ap = c_copy(var_enode_ptr(ep) -&gt; e_var -&gt; sarg);
		GEN_ASSERT_TRACE(ap,
			es("NULL sarg for "); esnode(var_enode_ptr(ep) -&gt; e_var));

		gen_import(var_enode_ptr(ep) -&gt; e_var, DONT_USE_LIB_PREFIX);

		/*
			Use address of the array, not the contents of the first element,
			so that "bare" array names will be handled correctly.
		*/
		if (s_is_array(var_enode_ptr(ep) -&gt; e_var)) {

			ap = c_lea(ap);
		}
		goto done;

	case INT_TOK:	/* All char, int and long constants are represented by INT_TOK. */

		GEN_ASSERT(ep -&gt; e_ctype);
		new_const_anode_macro(ap, econst_long(ep), ep -&gt; e_ctype -&gt; tsize);
		goto done;

	case FLOAT_TOK:

		/* 1/18/93: Anodes have been created by expr_cprim. */
		ap = econst_anode(ep);
		goto done;

	case STRING_TOK:

		/* 3/26/93: Anodes have been created by expr_cprim. */
		ap = econst_anode(ep);
		goto done;

	default:

		/* User errors should have beem caught in ct.c. */
		fatal(es("Internal compiler error: g_prim: "); eenode(ep));
	}

done:
	GEN_ASSERT(ap);
	TRACEPX(ftag, eret(); eanode(ap); ecnl());
	return ap;
}
</t>
<t tx="ekr.20080529093004.772">@ Generate code for a relational operator that generates a 0/1. Code in gbool.c handles relational operators used only for side effect.  The normal_op is used unless the order of operands must be switched.
@c

static anode *
g_relop
	(
		op2_enode *op2_p,
		int signed_op, int unsigned_op,
		int signed_switched_op, int unsigned_switched_op
	)
{
	FTAG("g_relop");
	register anode * ap1 = NULL;
	register anode * ap2 = NULL;
	anode * result_ap = NULL;
	register bool switch_flag = FALSE;
	STATB(ftag);

	/*
		The result of any relational operator is int,
		but that operator's arguments may be pointers or floats.
	*/
	if (
		op2_p -&gt; arg1 &amp;&amp; op2_p -&gt; arg1 -&gt; e_ctype &amp;&amp;
		op2_p -&gt; arg1 -&gt; e_ctype -&gt; tprim == FLOAT_TYPE
	) {
		result_ap = gf_relop(op2_p);
		goto done;
	}

	ap1 = gen_e1(op2_p -&gt; arg1);
	ap2 = gen_e1(op2_p -&gt; arg2);

	/*
		Get the result temporary now so that it will be spilled,
		if necessary, *before* the comparison is made.
		A spill after the compare would ruin the condition codes.

		Bug fix: 6/3/93: relops return short int, not int.
	*/
	result_ap = get_dtemp(RELOP_SIZE);

	/* Flip the switch_flag so tests can be performed in the same order as Think C. */
	switch_flag = !g_cmp(ap1, ap2);

	if (!a_is_dtreg(result_ap)) {

		/*
			The following call to get_dtemp will never spill a register.

			Proof: ap2 has just been freed by g_cmp since
			otherwise result_ap would not not have been spilled.
		*/
		GEN_ASSERT(reg_nd_free &gt; 0);
		result_ap = get_dtemp(RELOP_SIZE);
	}

	/* Generate an Sxx instruction. */
	GEN_ASSERT(op2_p -&gt; e_ctype);
	if (op2_p -&gt; e_ctype -&gt; tprim != INT_TYPE || t_is_unsigned(op2_p -&gt; e_ctype)) {

		/* pointer or unsigned */
		c_1(switch_flag ? unsigned_switched_op : unsigned_op, result_ap);
	}
	else {

		/* signed */
		c_1(switch_flag ? signed_switched_op : signed_op, result_ap);
	}

	/*
		Convert 0xffff in result_ap to 1.

		The NEG and EXT instructions are used so the code is the same as
		generated by Think C.  This helps in testing the code.

		Warning: the Scc instructions are *byte-only* instructions.
		The EXT instruction is required to produce a result greater than 1 byte.
	*/
	c_1len(X_NEG, result_ap, 1);

	if (RELOP_SIZE &gt; 1) {
		c_1len(X_EXT, result_ap, 2);
	}
	if (RELOP_SIZE &gt; 2) {
		c_1len(X_EXT, result_ap, 4);
	}

done:
	TRACEPX(ftag, eret(); eanode(result_ap); ecnl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.773">@ If iap represents a constant, say c, return an anode representing c x scale. Otherwise, generate code to multiply iap by the scale factor. The result is *always* a long constant.  Bug fix 7/15/93: use *unsigned* extends for scaling!
@c

static anode *
g_scale(anode * iap, long scale)
{
	FTAG("g_scale");
	static anode * name_ap = NULL;
	STATB(ftag);
	GEN_ASSERT(scale &gt; 0);

	if (scale == 1) {
		/* Do nothing: iap is the correct answer. */
	}
	else if (a_is_constant(iap)) {

		/* Return the constant val x scale. */
		long val = const_anode_ptr(iap) -&gt; a_long;
		new_const_anode_macro(iap, val * scale, LONG_SIZE);
	}
	else if (scale == 2) {

		/* Do the multiplication by addition. */
		iap = c_move2dtreg(iap);
		iap = c_ext(iap, 4, UNSIGNED_EXTEND);
		c_2len2(X_ADD, iap, iap);
	}
	else if (scale == 4) {

		/* Do the multiplication by addition. */
		iap = c_move2dtreg(iap);
		iap = c_ext(iap, 4, UNSIGNED_EXTEND);
		c_2len2(X_ADD, iap, iap);
		c_2len2(X_ADD, iap, iap);
	}
	else if (iap -&gt; a_length == 4) {

		/* Long multiplication is handled with a function call. */
		ulong stack_size = 0;
		anode * d0_ap = NULL;
		anode * cap = NULL;

		/* Represent the scale as an anode. */
		new_const_anode_macro(cap, scale, LONG_SIZE);

		/* Push the arguments. */
		stack_size += c_push(iap, MULTIPLE_ARGS);
		free_temp(iap);
		stack_size += c_push(cap, MULTIPLE_ARGS);

		/* The result will be returned in D0. */
		d0_ap = get_d0(LONG_SIZE);
		iap = d0_ap;

		/* Generate the function call. */
		if (name_ap == NULL) {

			/* Create an anode for the library name. */
			new_perm_anode_macro(name_ap, sizeof(var_anode), ABSOLUTE_EA);
			var_anode_ptr(name_ap) -&gt; a_vkind = LIBNAME_VKIND;
			var_anode_ptr(name_ap) -&gt; a_vname = "lmulu";
		}

		c_1(X_JSR, name_ap);
		gen_import_name("lmulu", USE_LIB_PREFIX);

		/* Generate the code to reset the stack pointer */
		c_adj_stack(stack_size);
	}
	else {

		/*
			Multiply the constant scale by iap.

			Machine pattern:
				entry_(0, LEN16_PAT, NOT8_PAT, DALT_PAT, DN_PAT, X_MULU)
		*/
		anode * scale_ap = NULL;
		new_const_anode_macro(scale_ap, scale, LONG_SIZE);
		iap = c_ext(iap, 2, UNSIGNED_EXTEND);
		iap = c_move2dtreg(iap);
		c_2len2(X_MULU, scale_ap, iap);
	}

done:
	TRACEPX(ftag, eret(); eanode(iap); ecnl());
	return iap;
}
</t>
<t tx="ekr.20080529093004.774">@ Generate code for the '&lt;&lt;' and '&lt;&lt;=' and '&gt;&gt;' and '&gt;&gt;=' operators.

Machine patterns:

entry_(2, ANY_PAT,  ANY_PAT, DN_PAT,   DN_PAT, X_ASL1) dreg dyn
entry_(2, MODE1_PAT, ANY_PAT, QUICK8_PAT, DN_PAT, X_ASL1) dreg stat
entry_(2, ANY_PAT,  ANY_PAT, DN_PAT,   DN_PAT, X_ASR1) dreg dyn
entry_(2, MODE1_PAT, ANY_PAT, QUICK8_PAT, DN_PAT, X_ASR1) dreg stat
entry_(2, ANY_PAT,  ANY_PAT, DN_PAT,   DN_PAT, X_ROXL1) dreg dyn
entry_(2, MODE1_PAT, ANY_PAT, QUICK8_PAT, DN_PAT, X_ROXL1) dreg stat
entry_(2, ANY_PAT,  ANY_PAT, DN_PAT,   DN_PAT, X_ROXL1) dreg dyn
entry_(2, MODE1_PAT, ANY_PAT, QUICK8_PAT, DN_PAT, X_ROXL1) dreg stat

Unused patterns:
entry_(1, LEN16_PAT, NONE_PAT, MALT_PAT, NONE_PAT, X_ASL2) memory x1
entry_(1, LEN16_PAT, NONE_PAT, MALT_PAT, NONE_PAT, X_ASR2) memory x1
entry_(2, LEN16_PAT, NONE_PAT, MALT_PAT, NONE_PAT, X_ROXL2) memory x1
entry_(2, LEN16_PAT, NONE_PAT, MALT_PAT, NONE_PAT, X_ROXL2) memory x1
@c

static anode *
g_shift (op2_enode *op2_p, bool assn_flag, bool right_flag)
{
	FTAG("g_shift");
	register anode * dst_ap = NULL;
	register anode * src_ap = NULL;
	register int op = 0;
	STATB(ftag);

	/* Set the proper operator. */
	if (right_flag) {
		op = t_is_unsigned(op2_p -&gt; e_ctype) ? X_LSR : X_ASR;
	}
	else {
		op = t_is_unsigned(op2_p -&gt; e_ctype) ? X_LSL : X_ASL;
	}

	dst_ap = gen_e1(op2_p -&gt; arg1);
	src_ap = gen_e1(op2_p -&gt; arg2);

	#if 0 /* The shift count length need not be the length of the shifted operand! */
		GEN_ASSERT(dst_ap -&gt; a_length == src_ap -&gt; a_length);
	#endif

	/* Make sure the source has the proper form. */
	if (!a_is_dreg(src_ap) &amp;&amp; !a_is_quick8(src_ap)) {
		src_ap = c_move2dtreg(src_ap);
	}

	/* Bug fix: 6/3/93: the length of the operation is the length of dst_ap. */
	if (assn_flag) {

		if (a_is_dtreg(dst_ap)) {
			c_2len2(op, src_ap, dst_ap);
		}
		else {
			anode * old_dst = dst_ap;
			dst_ap = get_dtemp(dst_ap -&gt; a_length);
			c_move(old_dst, dst_ap);
			c_2len2(op, src_ap, dst_ap);
			c_move(dst_ap, old_dst);
			free_temp(old_dst);
		}
	}
	else {

		dst_ap = c_move2dtreg(dst_ap);
		c_2len2(op, src_ap, dst_ap);
	}
	free_temp(src_ap);

	TRACEPX(ftag, eret(); eanode(dst_ap); ecnl());
	return dst_ap;
}
</t>
<t tx="ekr.20080529093004.775">@ Generate code to for the '-' or '-=' operators applied to two pointers.  Machine patterns:  entry_(2, MODE1_PAT, NOT8_PAT, QUICK8_PAT, AN_PAT, X_SUBQ)
entry_(1, LEN16_PAT, LEN32_PAT, GEN_PAT,  AN_PAT, X_SUBA)
entry_(2, NOT8_PAT, AS_1_PAT, GEN_PAT,  AN_PAT, X_SUBA)
@c

static anode *
g_sub_pp (op2_enode *op2_p, bool assn_flag)
{
	FTAG("g_sub_pp");
	anode * dst_ap = NULL;
	anode * src_ap = NULL;
	STATB(ftag);

	GEN_ASSERT(
		(
			op2_p -&gt; arg1 -&gt; e_ctype -&gt; tprim == POINTER_TYPE ||
			op2_p -&gt; arg1 -&gt; e_ctype -&gt; tprim == ARRAY_TYPE
		)
			&amp;&amp;
		(
			op2_p -&gt; arg2 -&gt; e_ctype -&gt; tprim == POINTER_TYPE ||
			op2_p -&gt; arg2 -&gt; e_ctype -&gt; tprim == ARRAY_TYPE
		));

	dst_ap = gen_e1(op2_p -&gt; arg1);
	src_ap = gen_e1(op2_p -&gt; arg2);

	/* Bug fix: 6/1/93: generated code depends on assn_flag! */
	if (assn_flag) {

		anode * old_dst = dst_ap;

		/* Move dst_ap to an A-temp *without* freeing old_dst. */
		if (!a_is_atreg(dst_ap)) {
			dst_ap = get_dtemp(dst_ap -&gt; a_length);
			c_move(old_dst, dst_ap);
		}

		/* Do the operation. */
		dst_ap = c_move2atreg(dst_ap);
		c_2len2(X_SUBA, src_ap, dst_ap);
		free_temp(src_ap);

		/* Complete the assignment. */
		if (old_dst != dst_ap) {
			c_move(dst_ap, old_dst);
			free_temp(old_dst);
		}
	}
	else {

		/* Do the operation in a temporary. */
		dst_ap = c_move2atreg(dst_ap);
		c_2len2(X_SUBA, src_ap, dst_ap);
		free_temp(src_ap);
	}

	/*
		Bug fix: 3/8/93.
		The difference of two pointers is an int, and the other
		code generators always expect ints in D-regs.
	*/
	dst_ap = c_move2dtreg(dst_ap);

	TRACEPX(ftag, eret(); eanode(dst_ap); ecnl());
	return dst_ap;
}
</t>
<t tx="ekr.20080529093004.776">@ Generate code for the ternary ('?:') operator.
@c

anode *
g_ternary (op3_enode *op3_p)
{
	FTAG("g_ternary");
	anode * old_ap2 = NULL;
	anode * ap2 = NULL;
	anode * ap3 = NULL;
	anode * result_ap = NULL;
	label_cnode *else_lab = NULL;
	label_cnode *end_lab = NULL;
	STATB(ftag);

	/* Allocate label nodes. */
	new_clabel_macro(else_lab);
	new_clabel_macro(end_lab);

	/*
		Generate the boolean. Note:
		1) gen_bool spills all registers before generating code.
		2) all register are free after gen_bool is finished.

		If the above conditions were not true, it would be possible
		for registers to be spilled in one branch of the code
		generated by gen_bool and not the other branche.
	*/
	gen_bool(op3_p -&gt; arg1, FALL_THROUGH, else_lab);
	
	/* 12/20/94 Use special case code for objects too large to fit in registers. */	
	if (t_is_big_type(op3_p -&gt; e_ctype)) {
	
		ulong tsize = op3_p -&gt; e_ctype -&gt; tsize;
			
		/* Create a stack temporary to hold each branch. */
		result_ap = gen_new_stack_anode(tsize, tsize, "big temp", NO_NAME);
		
		/* Generate the "fall through" branch. */
		ap2 = gen_e1(op3_p -&gt; arg2);
		
		/* Copy the result to the stack temp. */
		c_move_big(ap2, TAKE_ADDRESS, result_ap, TAKE_ADDRESS, tsize);
		free_temp(ap2);
		
		c_bra(end_lab);
		c_clabel(else_lab);
		
		/* Generate the "else" branch. */
		ap3 = gen_e1(op3_p -&gt; arg3);
		
		/* Copy the result to the stack temp. */
		c_move_big(ap3, TAKE_ADDRESS, result_ap, TAKE_ADDRESS, tsize);
		free_temp(ap3);
		
		c_clabel(end_lab);
	}
	else {

		/* Generate the "fall through" branch. */
		ap2 = gen_e1(op3_p -&gt; arg2);
	
		/*
			Create a *copy* of ap2 so a record of it will exist after ap2 is freed.
			(We had better *not* free this copy!)
			Then free ap2 so its register is available to the else branch.
	
			This should be the only call to c_copy outside g_prim or cput.c.
	
			11/2/93: Be careful: either branch could be cast to void.
			That is, ap2, old_ap2 or ap3 could be NULL.
		*/
		if (ap2) {
			ap2 = c_move2dtreg(ap2);
			old_ap2 = c_copy(ap2);
			free_temp(ap2);
		}
		c_bra(end_lab);
	
		/* Generate the "else" branch. */
		c_clabel(else_lab);
		ap3 = gen_e1(op3_p -&gt; arg3);
	
		/*
			Make sure both branches leave their result in the same place.
			Also make sure old_ap2 has been freed in both branches.
		*/
		if (ap3) {
			if (!is_equiv(old_ap2, ap3)) {
				c_move(ap3, old_ap2);
			}
			free_temp(ap3);
		}
	
		/* Generate the label to which the "fall through" branch jumps. */
		c_clabel(end_lab);
	
		/*
			old_ap2 represents a D-reg which contains the result of both branches.
			This D-reg has been freed by both branches, so re-reserve it now.
		*/
		if (old_ap2) {
			int the_reg = spill_anode_ptr(old_ap2) -&gt; a_sreg;
			GEN_ASSERT(reg_is_free(the_reg));
			ap2 = get_reg(the_reg, old_ap2 -&gt; a_length, TRUE, NULL);
		}
		result_ap = ap2;
	}

	TRACEPX(ftag, eret(); eanode(result_ap); ecnl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.777">@ Generate code for the address of (unary '&amp;') operator.
@c

static anode *
g_uand (op1_enode *op1_p)
{
	FTAG("g_uand");
	anode * ap = NULL;
	STATB(ftag);
	GEN_ASSERT(op1_p -&gt; arg1);

	ap = g_address(op1_p -&gt; arg1);

	TRACEPX(ftag, eret(); eanode(ap); ecnl());
	return ap;
}
</t>
<t tx="ekr.20080529093004.778">@ Generate code for the unary '-' and '~' operators.  Machine patterns:  entry_(1, ANY_PAT, NONE_PAT, DALT_PAT, NONE_PAT, X_NEG)  entry_(1, ANY_PAT, NONE_PAT, DALT_PAT, NONE_PAT, X_NOT)
@c

static anode *
g_uneg (op1_enode *op1_p, bool ones_flag)
{
	FTAG("g_uneg");
	anode * dst_ap = NULL;
	STATB(ftag);

	/* Handle floating negation. */
	if (!ones_flag &amp;&amp; op1_p -&gt; e_ctype -&gt; tprim == FLOAT_TYPE) {
		dst_ap = gf_uminus(op1_p);
		goto done;
	}

	/* Generate code for the subtree. */
	dst_ap = gen_e1(op1_p -&gt; arg1);

	/* Make dst_ap a D-temp. */
	dst_ap = c_move2dtreg(dst_ap);

	/* Generate either the 1's or the 2's complement. */
	c_1len1(ones_flag ? X_NOT : X_NEG, dst_ap);

done:
	TRACEPX(ftag, eret(); eanode(dst_ap); ecnl());
	return dst_ap;
}
</t>
<t tx="ekr.20080529093004.779">@ Generate code for the unary '+' operator.
@c

anode *
g_uplus (op1_enode *op1_p)
{
	FTAG("g_uplus");
	anode * ap1 = NULL;
	STATB(ftag);

	ap1 = gen_e1(op1_p -&gt; arg1);

	TRACEPX(ftag, eret(); eanode(ap1); ecnl());
	return ap1;
}
</t>
<t tx="ekr.20080529093004.780">@ Generate code for the indirection (unary '*') operator.
@c

static anode *
g_ustar (op1_enode *op1_p)
{
	FTAG("g_ustar");
	anode * ap = NULL;
	ulong osize = 0;
	register enode * ep1 = NULL;
	register enode * ep2 = NULL;
	STATB(ftag);

	GEN_ASSERT(op1_p);

	ep1 = op1_p -&gt; arg1;
	GEN_ASSERT(ep1);

	osize = c_e2mlen(enode_ptr(op1_p));

	/*  *&amp;a == a for any a. */
	if (ep1 -&gt; n_type == UAND_TOK) {

		ep2 = op1_ptr(ep1) -&gt; arg1;
		GEN_ASSERT(ep2);

		ap = gen_e1(ep2);
		GEN_ASSERT(ap -&gt; a_length == osize);
		goto done;
	}

	/*
		Special case *--p and *p++ where *p is an object of size 1, 2 or 4.

		This special case *must* be done in g_pre_post:
		there would be no easy way of evaluating ep1 here if
		ep2 does not evaluate to an A-reg.

		Bug fix: 7/20/93:
		We must be sure that ep1 is a unop before we can evaluate ep2.
	*/

	if (ep1 -&gt; n_type == PRE_DEC_TOK) {

		ep2 = op1_ptr(ep1) -&gt; arg1;
		GEN_ASSERT(ep2);

		if (
			ep2 -&gt; e_ctype &amp;&amp;
			ep2 -&gt; e_ctype -&gt; tprim == POINTER_TYPE &amp;&amp;
			(osize == 1 || osize == 2 || osize == 4)
		) {

			ap = g_pre_post(op1_ptr(ep1), PRE_OP, DEC_OP, EVAL_STAR);
			goto done;
		}
	}
	else if (ep1 &amp;&amp; ep1 -&gt; n_type == POST_INC_TOK) {

		ep2 = op1_ptr(ep1) -&gt; arg1;
		GEN_ASSERT(ep2);
		if (
			ep2 -&gt; e_ctype &amp;&amp;
			ep2 -&gt; e_ctype -&gt; tprim == POINTER_TYPE &amp;&amp;
			(osize == 1 || osize == 2 || osize == 4)
		) {
			ap = g_pre_post(op1_ptr(ep1), POST_OP, INC_OP, EVAL_STAR);
			goto done;
		}
	}
	else {
		/* Fall through to the general case. */
	}

	/* The general case. */
	ap = gen_e1(ep1);

	/*
		We only need an A-reg, not an A-temp.
		We need not copy an A-reg since a copy is made in g_prim.
	*/
	if (!a_is_areg(ap)) {
		ap = c_move2atreg(ap);
	}
	ap -&gt; n_type = INDIRECT_EA;

done:

	GEN_ASSERT(ap);
	ap -&gt; a_length = osize;

	TRACEPX(ftag, eret(); eanode(ap); ecnl());
	return ap;
}
</t>
<t tx="ekr.20080529093004.781">/*
	CC2: Code generation for statments.

	source:  CCgstat.c
	started: November 9, 1985
	version:
		November 11, 1994.
			Bug fix to gen_return: floats and large aggregates are returned as pointers.
		July 28, 1993.
			Removed calls to gen_pp.
			(These must have DONT_TRANSLATE_POST_OPS and so are no-ops.)
		July 19, 1993.
			Replaced ASSERT and ASSERT_TRACE by GEN_ASSERT and GEN_ASSERT_TRACE.
		May 25, 1993.
			Removed unused case_num parameter from gen_switch_jump.
		May 24, 1993.
			Bug fix: handle NULL expressions in for statements like constants.
		May 5, 1993.
			Printed copy sent to Tuple.
		April 11, 1993.
			Replaced is_vbool by expr_is_const.
			Added gen_switch_jump and gen_switch_tests.
		March 7, 1993.
			Bug fix: added missing else clause in gen_return.
		February 13, 1993.
			Simplified gen_block by adding block_alloc field to block_node's.
			(This eliminates the stack_info nodes!)
			Call reg_free_locals from gen_block.
		January 23, 1993.
			Call gen_auto_inits from gen_block.
		December 31, 1992.
			Revised gen_return and gen_switch to call gen_expr.
			Changed other calls to gen_expr to gen_outer_expr.
		November 3, 1992.
			This file now contains only statement generators
		August 15, 1992
			Added gen_block.
		June 22, 1992
			First installed CC2 version.
		June 5, 1991
			First CC2 version.
		January 24, 1992
			call pr_list, not out_tree.
		January 22, 1992.
		February 22, 1989:
			all out_* routines moved to out.c
		March 6, 1987
*/
&lt;&lt; CCgstat #includes &gt;&gt;
&lt;&lt; CCgstat declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.782">#include "CC.h"

#include "CCarg.h"
#include "CCdump.h"
#include "CCgen.h"
#include "CCmem.h"
#include "CCparser.h"
#include "CCregs.h"
#include "CCtarget.h"
</t>
<t tx="ekr.20080529093004.783">/*
	Define inline functions.
*/
#define g_bra(p) c_1clab(X_BRA, p)

/*
	Global data owned by this module.
*/
label_cnode * gen_break_label = NULL;
label_cnode * gen_continue_label = NULL;
label_cnode * gen_ret_label = NULL;

/*
	Function prototypes of internal functions
*/
static void	gen_break		(void);
static void	gen_case		(case_node *p);
static void	gen_continue	(void);
static void	gen_default		(case_node *p);
static void	gen_do			(do_node *p);
static void	gen_goto		(goto_node *p);
static void	gen_if			(if_node *p);
static void	gen_label		(ulabel_node *p);
static void	gen_for			(for_node *p);
static void	gen_return		(return_node *p);
static void	gen_switch		(switch_node *p);
static void gen_switch_jump	(switch_node *p, anode *ap, long min, long max);
static void	gen_switch_table(switch_node * switch_p);
static void gen_switch_tests(switch_node *p, anode *ap, long num);
static void	gen_while		(while_node *p);
</t>
<t tx="ekr.20080529093004.784">@ Generate code for a block statement.  This updates a stack of alloc_nodes, which are used to keep track of the maximum stack space used be auto variables and stack temps.
@c

static void
gen_block(block_node *p)
{
	FTAG("gen_block");
	TICKB(ftag);

	/* Remember the current allocation point. */
	p -&gt; block_alloc = gen_current_alloc;

	/*
		Allocate stack space for local auto variables,
		generate code to handle initializers of auto variables,
		then generate the executable code for the block.

		This initializer code is executed every time the block is entered,
		but not when the block is entered via a goto statement.
	*/
	gen_alloc_locals(p);
	gen_auto_inits(p -&gt; block_dcls);
	gen_list(p -&gt; block_body);
	reg_free_locals(p);

	/*
		Both gen_alloc_locals and gen_list may increase gen_current_alloc.
		Restore gen_current_alloc so that the stack space may be shared.
	*/
	if (gen_current_alloc != p -&gt; block_alloc) {
		out_stack_comment(NULL, p -&gt; block_alloc, "new base", NO_NAME);
	}
	gen_current_alloc = p -&gt; block_alloc;
	gen_current_base = gen_current_alloc;
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.785">@ Generate code for the break statement.
@c

static void
gen_break(void)
{
	FTAG("gen_break");
	TICKB(ftag);

	g_bra(gen_break_label);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.786">@ Generate code for the case statement.  4/22/93: Bump the reference count of the label so the peephole won't get rid of the label. This is required now that jump tables may be generated after the cases themselves are generated.
@c

static void
gen_case(register case_node * p)
{
	FTAG("gen_case");
	TICKB(ftag);

	p -&gt; case_label -&gt; c_refcount++;
	c_clabel(p -&gt; case_label);
	c_set_perm_label(p -&gt; case_label);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.787">@ Generate code for the continue statement.
@c

static void
gen_continue(void)
{
	FTAG("gen_continue");
	TICKB(ftag);

	g_bra(gen_continue_label);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.788">@ Generate code for the default statement.
@c

static void
gen_default(case_node *p)
{
	FTAG("gen_default");
	TICKB(ftag);

	c_clabel(p -&gt; case_label);
	c_set_perm_label(p -&gt; case_label);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.789">@ Generate code for the do statement.
@c

static void
gen_do(register do_node * p)
{
	FTAG("gen_do");
	label_cnode *loop_label = NULL;
	label_cnode *old_continue = gen_continue_label;
	label_cnode *old_break = gen_break_label;
	TICKB(ftag);

	/* Get new values. */
	new_clabel_macro(loop_label);
	new_clabel_macro(gen_continue_label);
	new_clabel_macro(gen_break_label);

	if (expr_is_const(p -&gt; do_bool)) {
		c_clabel(gen_continue_label);
		gen_list(p -&gt; do_body);
		c_line2(p);
		g_bra(gen_continue_label);
		c_clabel(gen_break_label);
	}
	else {
		c_clabel(loop_label);
		gen_list(p -&gt; do_body);
		c_line2(p);
		c_clabel(gen_continue_label);
		gen_bool(p -&gt; do_bool, loop_label, FALL_THROUGH);
		c_clabel(gen_break_label);
	}

	/* Restore old values. */
	gen_break_label = old_break;
	gen_continue_label = old_continue;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.790">@ Generate code for the for statement.
@c

static void
gen_for(register for_node * p)
{
	FTAG("gen_for");
	label_cnode *lab0 = NULL;
	label_cnode *lab1 = NULL;
	label_cnode *old_break = gen_break_label;
	label_cnode *old_continue = gen_continue_label;
	TICKB(ftag);

	new_clabel_macro(lab0);
	new_clabel_macro(lab1);
	new_clabel_macro(gen_break_label);
	new_clabel_macro(gen_continue_label);

	/* Bug fix: 5/24/93: handle NULL expressions here. */
	if (expr_is_const(p -&gt; for_bool) || p -&gt; for_bool == NULL) {
		gen_outer_expr(p -&gt; for_list1);
		c_clabel(lab1);
		gen_list(p -&gt; for_body);
		c_clabel(gen_continue_label);
		gen_outer_expr(p -&gt; for_list2);
		g_bra(lab1);
		c_clabel(gen_break_label);
	}
	else {
		gen_outer_expr(p -&gt; for_list1);
		g_bra(lab0);
		c_clabel(lab1);
		gen_list(p -&gt; for_body);
		c_clabel(gen_continue_label);
		gen_outer_expr(p -&gt; for_list2);
		c_clabel(lab0);
		gen_bool(p -&gt; for_bool, lab1, FALL_THROUGH);
		c_clabel(gen_break_label);
	}

	/* Restore old values. */
	gen_break_label  = old_break;
	gen_continue_label = old_continue;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.791">@ Generate code for a goto to a user defined label.
@c

static void
gen_goto(goto_node * p)
{
	FTAG("gen_goto");
	TICKB(ftag);

	c_1ulab(X_BRA, p -&gt; goto_label);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.792">@ Generate code for an "if" statement.  In general, we need to generate an else clause even if none was given explicitly so that there will be a place to put the sequence points for each branch of the boolean expression.
@c

static void
gen_if(register if_node * p)
{
	FTAG("gen_if");
	label_cnode * else_lab = NULL;
	label_cnode * end_lab = NULL;
	TICKB(ftag);

	new_clabel_macro(else_lab);
	gen_bool(p -&gt; if_bool, FALL_THROUGH, else_lab);
	gen_list(p -&gt; if_then_body);

	/*
		Do not generate spurious nodes
		when there is no else clause.
	*/
	if (p -&gt; if_else_body) {
		new_clabel_macro(end_lab);
		g_bra(end_lab);
		c_clabel(else_lab);
		gen_list(p -&gt; if_else_body);
		c_clabel(end_lab);
	}
	else {
		c_clabel(else_lab);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.793">@ Generate a user defined label from a parse label node.
@c

static void
gen_label(ulabel_node *p)
{
	FTAG("gen_label");
	TICKB(ftag);

	c_ulabel(p -&gt; ulab_label);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.794">@ Append code generated for a list of statements to the global code list.
@c

void
gen_list(register pnode * p)
{
	FTAG("gen_list");
	TICKB(ftag);

	for (; p; p = p -&gt; n_next) {

		c_line(p);

		TRACEPN(ftag, etoknum(p -&gt; n_type));

		switch (p -&gt; n_type) {

		case EXPRESSION_TOK:

			/* 6/3/93: Set global gen_expr_line for errors in code generators. */
			gen_expr_line = p -&gt; p_line;
			gen_outer_expr	(expr_ptr(p) -&gt; expr);
			break;

		case KP_BLOCK:	 gen_block		((block_node *) p);		break;
		case K_BREAK:	 gen_break		();						break;
		case K_CASE:	 gen_case		((case_node *) p);		break;
		case K_CONTINUE: gen_continue	();						break;
		case K_DEFAULT:	 gen_default	((case_node *) p);		break;
		case K_DO:		 gen_do			((do_node *) p);		break;
		case K_GOTO:	 gen_goto		((goto_node *) p);		break;
		case K_FOR:		 gen_for		((for_node *) p);		break;
		case K_IF:		 gen_if			((if_node *) p);		break;
		case K_RETURN:	 gen_return		((return_node *) p);	break;
		case K_SWITCH:	 gen_switch		((switch_node *) p);	break;
		case K_WHILE:	 gen_while		((while_node *) p);		break;

		case ULABEL_TOK: gen_label 		((ulabel_node *) p);	break;

		default:
			fatal(es("bad pnode: "); es(tok_name(p -&gt; n_type)));
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.795">@ Generate code for the return statement.  gen_fbody, the code generators for the function body, sets the reg_ret_a, reg_ret_d, and gen_ret_label fields of the global par_body_node structure.
@c

static void
gen_return(register return_node * p)
{
	FTAG("gen_return");
	anode * ap1 = NULL;
	TICKB(ftag);

	if (p -&gt; return_val == NULL) {
		goto done;
	}

	ap1 = gen_expr(p -&gt; return_val);
	
	/*
		Special case for large floats and aggregates.
		The caller has placed a hidden pointer to a stack temp to which
		the returned value must be placed.
		The hidden pointer is pushed after all arguments,
		so its location is known, namely 8(a6)
	*/
	if (t_is_big_type(p -&gt; return_val -&gt; e_ctype)) {
		
		enode * ep = p -&gt; return_val;
		int prim = ep -&gt; e_ctype -&gt; tprim;
		GEN_ASSERT(prim == STRUCT_TYPE || prim == UNION_TYPE || prim == FLOAT_TYPE);
		
		/* Move the value to 8(a6) */
		c_move_big(
			ap1, TAKE_ADDRESS, hidden_anode, TAKE_VALUE,
			p -&gt; return_val -&gt; e_ctype -&gt; tsize);
		free_temp(ap1);
		goto done;
	}

	if (reg_ret_a &amp;&amp; !is_equiv(ap1, a0_anode)) {

		anode * a0_ap = get_a0(ap1 -&gt; a_length);
		c_move(ap1, a0_ap);
		free_temp(ap1);
		free_temp(a0_ap);
	}
	else if (reg_ret_d &amp;&amp; !is_equiv(ap1, d0_anode)) {

		anode * d0_ap = get_d0(ap1 -&gt; a_length);
		c_move(ap1, d0_ap);
		free_temp(ap1);
		free_temp(d0_ap);
	}
	else {
		/* Bug fix: 3/7/93 */
		free_temp(ap1);
	}
	
done:

	/* Jump to the return label. */
	g_bra(gen_ret_label);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.796">@ Generate code for the switch statement.  Note: this may end up handling long cases if no fundamental  problems turn up
@c

static void
gen_switch(register switch_node * switch_p)
{
	FTAG("gen_switch");
	register anode * val_ap = NULL;
	label_cnode * old_break = gen_break_label;
	long case_min = 0L;
	long case_max = 0L;
	long case_num = 0L;
	TICKB(ftag);

	/* Generate break label. */
	new_clabel_macro(gen_break_label);

	/*
		Generate labels for all case statements.
		Also compute case_min, case_max, case_n.
	*/
	{
		register case_node * case_p = NULL;

		if (switch_p -&gt; switch_list) {
			case_min = case_max = switch_p -&gt; switch_list -&gt; case_constant;
		}

		for (
			case_p = switch_p -&gt; switch_list;
			case_p;
			case_p = case_p -&gt; case_list
		) {
			case_min = min(case_min, case_p -&gt; case_constant);
			case_max = max(case_max, case_p -&gt; case_constant);
			new_clabel_macro(case_p -&gt; case_label);
			case_num++;
		}
	}

	/*
		Generate and remember the label for the default case if it exists.
		This must be done here to remember the current value of gen_break_label.
	*/
	if (switch_p -&gt; switch_default) {
		new_clabel_macro(switch_p -&gt; switch_default -&gt; case_label);
		switch_p -&gt; switch_default_label = switch_p -&gt; switch_default -&gt; case_label;
	}
	else {
		switch_p -&gt; switch_default_label = gen_break_label;
	}

	/*
		Generate code to evaluate the switch expression.
	*/
	val_ap = gen_expr(switch_p -&gt; switch_val);
	if (!a_is_dtreg(val_ap)) {
		val_ap = c_move2dtreg(val_ap);
	}

	/*
		Generate code to jump to the proper cases.

		There are a number of possible ways of going to the cases, including
		a (possibly balanced) binary tree of compares and branches or table jump.

		We generate a table jump if the table would be "compact enough," i.e.,
		if more than half the entries of the tables are occupied.
		An entry in the jump table is smaller than the corresponding test and jump
		so using a table jump will never waste huge amounts of space.
	*/
	if (case_num &gt; 5 &amp;&amp; (2*case_num &gt; (case_max - case_min))) {
		gen_switch_jump(switch_p, val_ap, case_min, case_max);
	}
	else {

		if (case_num &gt; 10) {
			delayed_help(switch_p -&gt; p_line,
				es("Switch does not create a jump table...");
				es("cases: "); elong(case_num);
				es(", min: "); elong(case_min);
				es(", max: "); elong(case_max);
			);
		}
		gen_switch_tests(switch_p, val_ap, case_num);
	}

	/*
		A fine point:
		gen_list can call gen_outer_expression, which frees all registers.
		Free val_ap here to avoid freeing val_ap twice
		(which causes the GEN_ASSERT in free_temp to fail).
	*/
	free_temp(val_ap);

	/* Generate the body. */
	gen_list(switch_p -&gt; switch_body);
	c_clabel(gen_break_label);

	/* Restore old break label. */
	gen_break_label = old_break;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.797">@ Generate code to branch through a table based on the value of ap.

1. Put the switch expression in D0.w.
2. Compute the address of the jump table entry
CMPI.W  #case_max,D0
BHI    *+$1F02    ;the address of the default
LEA    *+$2294,A1  ;the address of a jump table (at end of function)
ADD.W   D0,D0  ;the entry is at A1 + D0
3. Fetch the address at the jump table entry and *add* that entry to A1(!) Thus, the table entries are not 32-bit address, but 16-bit offsets from the address of the jump table. This is reasonable because Mac segments are limited to 32K.
ADDA.W  $00(A1,D0.W),A1 ;A1 += *(A1 + D0)
4. Jump to A1 + that the index table.  JMP    (A1)
@c

static void
gen_switch_jump (
	switch_node * switch_p,
	anode * val_ap,
	long case_min,
	long case_max)
{
	FTAG("gen_switch_jump");
	anode * atemp = get_atemp(REGISTER_SIZE);
	label_cnode * jump_table_label = NULL;
	label_cnode * default_label = NULL;
	STATB(ftag);

	/* The call to get_atemp must not have spilled val_ap. */
	GEN_ASSERT(switch_p &amp;&amp; val_ap &amp;&amp; a_is_dtreg(val_ap));

	/* Set an convenient abbreviation. */
	default_label = switch_p -&gt; switch_default_label;
	GEN_ASSERT(default_label);

	/*
		Bump the reference count of the default label to make *sure*
		it will survive the peephole.
		This is necessary now that the jump table can be generated after the peephole.
	*/
	default_label -&gt; c_refcount++;

	/* Generate the label for the jump table. */
	new_clabel_macro(jump_table_label);
	switch_p -&gt; switch_jtab = jump_table_label;

	/* Add the switch to the global switch list. */
	switch_p -&gt; switch_next = gen_switch_list;
	gen_switch_list = switch_p;

	/* Make sure we have a word operand. */
	c_ext(val_ap, 2, SIGNED_EXTEND);

	/*
		The entries in the jump table start at case_min, which may not be zero.
		Subtract case_min from val_ap so that the range of val_ap
		runs from 0 to case_max - case_min.
	*/
	if (case_min != 0) {

		anode * const_ap = NULL;
		new_const_anode_macro(const_ap, case_min, 2);
		c_2len(X_SUBI, const_ap, val_ap, 2);
	}

	/* Generate code to jump to the default label if the expression is out of range. */
	{
		anode * const_ap = NULL;
		new_const_anode_macro(const_ap, case_max - case_min, 2);
		c_2len(X_CMP, const_ap, val_ap, 2);
		c_1clab(X_BHI, default_label);
	}

	/*
		Generate the code to jump to the jump table.

			LEA       jump_table_label,atemp
			ADD.W     val_ap,val_ap
			ADDA.W    $00(atemp,val_ap.w),atemp
			JMP       (atemp)
	*/
	jump_table_label -&gt; c_refcount++;
	c_2(X_LEA, anode_ptr(jump_table_label), atemp);

	c_2len(X_ADD, val_ap, val_ap, 2);
	{
		spill_anode * sap = NULL;
		new_anode_macro(sap, sizeof(spill_anode), INDEX_EA);
		sap -&gt; a_sreg = spill_anode_ptr(atemp) -&gt; a_sreg;
		sap -&gt; a_sxreg = spill_anode_ptr(val_ap) -&gt; a_sreg;
		c_2len(X_ADDA, anode_ptr(sap), atemp, 2);
	}
	{
		spill_anode * sap = NULL;
		new_anode_macro(sap, sizeof(spill_anode), INDIRECT_EA);
		sap -&gt; a_sreg = spill_anode_ptr(atemp) -&gt; a_sreg;
		c_1(X_JMP, anode_ptr(sap));
	}

	free_temp(atemp);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.798">@ Return the size in bytes of all the switch tables. This size is used to compute the size of the optional data area that follows embedded labels.
@c

uint
gen_switch_size(void)
{
	FTAG("gen_switch_size");
	switch_node * switch_p = NULL;
	uint result = 0;
	STATB(ftag);

	/* For each switch in the switch list... */
	for(switch_p = gen_switch_list; switch_p; switch_p = switch_p -&gt; switch_next) {

		/* Calculate the maximum and minimum values in the case list. */
		case_node * cp = switch_p -&gt; switch_list;
		if (cp) {
			long val = cp -&gt; case_constant;
			long min_case = val;
			long max_case = val;
			cp = cp -&gt; case_list;
			while (cp) {
				val = cp -&gt; case_constant;
				if (val &gt; max_case) {
					max_case = val;
				}
				if (val &lt; min_case) {
					min_case = val;
				}
				cp = cp -&gt; case_list;
			}

			/* The size of each entry is 2 bytes. */
			result += (2 * (max_case - min_case + 1));
		}
	}
	STATX(ftag);
	return result;
}
</t>
<t tx="ekr.20080529093004.799">@ Generate all jump tables on the global gen_switch_list.
@c

void
gen_switch_tables(void)
{
	FTAG("gen_switch_tables");
	switch_node * switch_p = NULL;
	STATB(ftag);

	for(switch_p = gen_switch_list; switch_p; switch_p = switch_p -&gt; switch_next) {
		gen_switch_table(switch_p);
	}
	gen_switch_list = NULL;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.800">@ Generate the jump table corresponding to the given switch_node.  The cases have already been sorted by gen_switch.
@c

static void
gen_switch_table(register switch_node * switch_p)
{
	FTAG("gen_switch_tables");
	label_cnode * default_label = NULL;
	STATB(ftag);
	GEN_ASSERT(
		switch_p &amp;&amp;
		switch_p -&gt; switch_list &amp;&amp;
		switch_p -&gt; switch_jtab &amp;&amp;
		switch_p -&gt; switch_default_label);

	/* Set an convenient abbreviation. */
	default_label = switch_p -&gt; switch_default_label;

	/* Generate the label of the jump table. */
	out_clabel(switch_p -&gt; switch_jtab, DEFINE_THE_LABEL, "jump table");

	/*
		Sort the case entries.
		We wait till now to sort the entries to preserve the indicated
		order in case a table jump is not generated.
	*/
	{
		case_node * old = switch_p -&gt; switch_list;
		case_node * new = NULL;
		case_node * cp = NULL;

		/* There are at least 5 cases. */
		GEN_ASSERT(old);

		/* Add nodes to the new list in sorted order. */
		while (old) {

			/* Remove the node from the old list. */
			cp = old;
			old = old -&gt; case_list;

			/* Add the node to the new list in the proper place. */
			if (new == NULL) {

				/* Insert in an empty list. */
				new = cp;
				cp -&gt; case_list = NULL;
			}
			else if (cp -&gt; case_constant &lt; new -&gt; case_constant) {

				/* Insert at the head of the list. */
				cp -&gt; case_list = new;
				new = cp;
			}
			else {

				register case_node * head = new;
				register long val = cp -&gt; case_constant;

				/* Duplicate cases should already have been caught. */
				GEN_ASSERT(head &amp;&amp; val &gt; head -&gt; case_constant);

				/* Scan down the new list. */
				for(;;) {
					if (head -&gt; case_list == NULL) {

						/* Insert at end of list. */
						head -&gt; case_list = cp;
						cp -&gt; case_list = NULL;
						break;
					}
					else if (val &lt; head -&gt; case_list -&gt; case_constant) {

						/* Insert cp between head and head -&gt; case_list. */
						cp -&gt; case_list = head -&gt; case_list;
						head -&gt; case_list = cp;
						break;
					}
					else {
						head = head -&gt; case_list;
					}
				}
			}
		}

		switch_p -&gt; switch_list = new;
		TRACEPN(ftag,
			{
				case_node * cp = NULL;
				ecnl(); es("new switch list:\n");
				for(cp = new; cp; cp = cp -&gt; case_list) {
					elong(cp -&gt; case_constant); enl();
				}
			}
		);
	}

	/*
		Generate the a table containing the addresses of code for the cases,
		or the addresses of the 'break' or 'default' case for missing entries.
	*/
	{
		register case_node * cp = NULL;
		register label_cnode * switch_label = switch_p -&gt; switch_jtab;

		for (cp = switch_p -&gt; switch_list; cp; cp = cp -&gt; case_list) {

			/* Generate the current case. */
			out_switch_offset(switch_label, cp -&gt; case_label,
				PRINT_A_COMMENT, cp -&gt; case_constant);

			/* Generate any missing cases. */
			if (cp -&gt; case_list) {
				long this_val = cp -&gt; case_constant;
				long next_val = cp -&gt; case_list -&gt; case_constant;
				GEN_ASSERT(this_val &lt; next_val);
				while (++this_val &lt; next_val) {
					out_switch_offset(switch_label, cp -&gt; case_label,
						DONT_PRINT_A_COMMENT, 0);
				}
			}
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.801">@ Generate a series of tests and branches.
@c

static void
gen_switch_tests (switch_node * switch_p, anode * val_ap, long case_num)
{
	FTAG("gen_switch_tests");
	case_node * case_p = NULL;
	STATB(ftag);

	/* Generate a series of tests and branches. */
	for (case_p = switch_p -&gt; switch_list; case_p; case_p = case_p -&gt; case_list) {

		anode * const_ap = NULL;
		new_const_anode_macro(const_ap, case_p -&gt; case_constant, REGISTER_SIZE);
		c_2len(X_CMP, const_ap, val_ap, c_e2mlen(switch_p -&gt; switch_val));
		c_1clab(X_BEQ, case_p -&gt; case_label);
	}

	/* Generate the branch to the default label. */
	g_bra(
		switch_p -&gt; switch_default ?
		switch_p -&gt; switch_default -&gt; case_label : gen_break_label);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.802">@ Generate code for the while statement.
@c

static void
gen_while(register while_node * p)
{
	FTAG("gen_while");
	label_cnode *loop_label;
	label_cnode *old_continue = gen_continue_label;
	label_cnode *old_break = gen_break_label;
	TICKB(ftag);

	/* Generate new labels. */
	new_clabel_macro(loop_label);
	new_clabel_macro(gen_continue_label);
	new_clabel_macro(gen_break_label);

	if (expr_is_const(p -&gt; while_bool)) {
		c_clabel(gen_continue_label);
		gen_list(p -&gt; while_body);
		g_bra(gen_continue_label);
		c_clabel(gen_break_label);
	}
	else {
		g_bra(gen_continue_label);
		c_clabel(loop_label);
		gen_list(p -&gt; while_body);
		c_clabel(gen_continue_label);
		gen_bool(p -&gt; while_bool, loop_label, FALL_THROUGH);
		c_clabel(gen_break_label);
	}

	/* Restore old values. */
	gen_break_label  = old_break;
	gen_continue_label = old_continue;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.803">/*	CC2: output routines for code nodes.

	These functions produce assembly-language output;
	the routines in edump.h produce debugging information.
	Most code that depends on the assembler being used is in this file.

	Externally visible routines should do nothing if output_is_disabled is TRUE.
	Routines local to this file need not test output_is_disabled.

	source:  CCout.c
	started: February 22, 1989
	version:
		February 3, 1995.
			Changed out_cnode to output '@ ' before line number comments.
		February 2, 1995.
			Changed out_stack_comment to make comments easier to parse in AS.
		January 5, 1995.
			Made out_stack_comment more general.  Eliminated related routines.
		December 16, 1994.
			Added out_float_dc routine.
		September 5, 1994.
			Bug fix to out_anode_tag: mask off the value before calling isprint.
		August 27, 1994.
			Added out_data_name_offset to handle case where a structure name
			is referenced before its anode has been created.
		August 25, 1994.
			Added force_data_area_flag to out_data_string.
			This makes *sure* that initializers for static strings are in the data area.
			(Strings are the only data that are kludged into the code area by default.)
		July 26, 1994.
			Bug fix to out_end_file: end a RECORD not followed by a PROC.
			Added verbose message about writing the output file.
		June 6, 1994.
			Bug fix: initialize static variables in out_begin_file.
		June 3, 1994.
			Bug fix to set_file_prefix:  Don't change err_fname!
		July 29, 1993.
			Use arg_asm_comment_flag, not ++out_cinode, to enable assembly comments.
		July 26, 1993.
			Added out_switch_offset.
		July 19, 1993.
			Replaced ASSERT and ASSERT_TRACE by GEN_ASSERT and GEN_ASSERT_TRACE.
		July 7, 1993.
			Added check for ADDRESS_EA in out_anode.
		June 26, 1993.
			I finally figured out why fputc wasn't working in sl_cout.c.
			MPW C generates a 0x0d ('\r') when it sees a '\n' (!)
		June 23, 1993.
			Export all labels.
		June 19, 1993.
			Bug fix to out_data_string.  Do *not* switch '\n' and '\r' (!)
		June 17, 1993.
			Added arg_gen_link_flag to force generation of LINK/UNLK instructions.
		June 15, 1993.
			Use tsize field instead of t_is_xxx macros.
		June 14, 1993.
			Added code associated with ++debugger_trap trapepoint
		June 10, 1993.
			Added prefer_hex_flag.
		May 27, 1993.
			Added out_anode_tag.
		May 24, 1993.
			Rewrote out_record and out_endr so strings are put in the code space.
		May 11, 1993.
			Added export flag to out_data_ulabel.
		May 5, 1993.
			Printed version sent to Tuple.
		May 4, 1993.
			Bug fix: set_file_prefix is set only once, from out_begin_file.
				This ensures that the file prefix is the name of the main file.
			Made out_file_prefix local to this file.
				It is now initialized in out_begin_file.
		May 2, 1993.
			Bug fix to out_data_address: use sarg field, not spell field to print address.
			Bug fix: align gen_max_alloc in out_function so it the argument to LINK is even.
		May 1, 1993.
			Bug fix to out_function: Use MOVE, never MOVEA, when pushing registers.
				Pushing and poping are asymmetrical in this regard:
				the destination of a push is never an A-reg.
		April 28, 1993.
			Added out_data_clabel_ref.
			Rewrote out_data_string to translate escaped char constants to integers.
		April 22, 1993.
			Call gen_switch_tables at end of out_function.
		April 20, 1993.
			Added support for GEN_GLOBAL_ADDRESS.
			Added out_raw_clabel.
		April 18, 1993.
			Created with_node's and with lists.
			Added out_record and out_endr.
		April 17, 1993.
			Displacement modes have the form nn(Ax), not #nn(Ax)
			Use DCB nn,0.
			Removed float constants from start of file.
			(They will be put into the startup file.)
		April 5, 1993.
			Added output_is_disabled logic to all externally visible routines.
		April 3, 1993.
			Added out_data_f2i and out_data_i2f.
		April 1, 1993.
			Added out_data_xxx routines.
			Added out_stack_comment routine.
			Removed out_decl and related routines.
		March 4, 1993.
			Changed out_function so MOVE is generated when only one register is pushed.
		February 18, 1993.
			The routines in this file, and those called from this file,
			consume 1/5 of the time consumed by the entire compiler!
			This is just slightly less than the time spent parsing!
		February 12, 1993.
			Changed out_function to move formal register params to registers.
		February 10, 1993.
			Added support for table_cnode's.
			Added support for a_voffset and a_vprefix fields of var_anodes.
		February 7, 1993.
			Remove redundant label for procedure.
		February 2, 1993.
			Clear code list in out_function after outputting it.
		January 22, 1993.
			Added support for ADDRESS_EA.
		December 12, 1992.
			Added out_begin_file, out_end_file.
			Changed pseudo ops for MPW assembler.
		September 6, 1992
			Added out_comment.
		June 28, 1992
			First cc2 version.
		January 20, 1992: unsigned char changed to char.
*/

&lt;&lt; CCout #includes &gt;&gt;
&lt;&lt; CCout declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.804">#include "CC.h"

#include "CCarg.h"
#include "CCcpp.h"
#include "CCdump.h"
#include "CCgen.h"
#include "CCmem.h"
#include "CCparser.h"
#include "CCregs.h"
#include "CCtarget.h"
#include "CCtokens.h"

#include &lt;LIBlist.h&gt;
#include &lt;LIBlog.h&gt;
#include &lt;LIBos.h&gt;

#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;		/* For atof. */
#include &lt;ctype.h&gt;
</t>
<t tx="ekr.20080529093004.805">/*
	Define possible values of segments.
*/
#define VAR_SEPARATOR	"@"
#define LABEL_SEPARATOR	"@"
#define LIB_PREFIX	"_lib_"

/*
	Define local types and data structures.

	with_list is a list of the labels of RECORD directives.
	At the start of each function,
	a WITH directive is issued for each item on this list.

	with_avail_list is a list of available with_nodes.
	These nodes are allocated with permanent lifetime,
	which makes it possible to handle them entirely in this file.

	in_record_flag is TRUE if we are currently generating declarations
	appearing inside a RECORD directive.
*/
typedef struct with_node_struct with_node;

static struct with_node_struct {
	TYPE_LIST(with_node);
	label_cnode * the_label;
};

static with_node * with_list = NULL;
static with_node * with_avail_list = NULL;

static bool in_data_flag = FALSE;		/* TRUE: in range of a DATA directive. */
static bool in_function_flag = FALSE;	/* TRUE: generating code inside a function. */
static bool in_record_flag = FALSE;		/* TRUE: in range of a RECORD directive. */
static bool force_code_flag = FALSE;	/* TRUE: all data goes to code space. */

static char * out_file_prefix = NULL;
static bool prefer_hex_flag = FALSE;	/* TRUE: out_anode prints hex constants. */

/*
	Define in-line functions and macros.
*/
#define out_comment() { ocnl(); os("* "); }
#define output_is_disabled (arg_no_out_flag || err_count &gt; 0)

/*
	This macro is not currently used,
	and it would be useful to trace the callers of routines like c_data_xxx.
*/
#define out_callers() \
	if (arg_gen_trace_flag) {\
		TRACEN(ftag,\
			es(current_ftag); es(": ");\
			es(caller_ftag); es(": ");\
			es(caller2_ftag); es(": ");\
			es(caller3_ftag); es(": ");\
			ecblanks(55);\
		);\
	}

/*
	Prototypes of internal functions
*/
static void	out_anode			(anode * p);
static bool	out_anode_tag		(anode * arg, bool out_flag);
static void	out_cinode			(cinode * p);
static void	out_cnode			(cnode * p);
static void	out_comment_field	(void);
static void	out_embedded_label	(uint optional_data_size);
static void out_endr			(void);
static void	out_float_dc		(int ckind);
static void	out_list			(cnode *p);
static void	out_raw_clabel		(label_cnode * p);
static void	out_record			(void);
static void out_rlist			(void);
static void out_with			(void);
static void set_file_prefix		(void);
</t>
<t tx="ekr.20080529093004.806">@ Output an anode or a label.
@c

static void
out_anode(register anode * arg)
{
	FTAG("out_anode");
	STATB(ftag);

	if (arg == NULL) {
		os("&lt;NULL anode&gt;");
		fatal(es("NULL anode!"));
	}

	switch(arg -&gt; n_type) {

	case O_CLABEL:

		/* Put no colon at the end of label *arguments* */
		out_clabel(label_ptr(arg), DONT_DEFINE_THE_LABEL, NO_COMMENT);
		break;

	case O_ULABEL:

		/* Put no colon at the end of label *arguments* */
		out_clabel(label_ptr(arg), DONT_DEFINE_THE_LABEL, NO_COMMENT);

		/* Assume the label is the last argument.  Output a comment. */
		out_comment_field(); os(ulabel_cnode_ptr(arg) -&gt; c_labsym); onl();
		break;

	case ADDRESS_EA:

	/* 7/7/93: Make sure this address mode is never generated on the Mac. */
	#ifdef GEN_GLOBAL_ADDRESS
		os("#");
	#else
		fatal(es("ADDRESS_EA not valid on this machine"));
	#endif

		/* Fall through. */

	case ABSOLUTE_EA:		/* address */
	{
		int kind = var_anode_ptr(arg) -&gt; a_vkind;
		var_anode * vap = var_anode_ptr(arg);

		if (kind == ADDRESS_VKIND) {
			olong(vap -&gt; a_vaddress);
		}
		else if (kind == LIBNAME_VKIND) {
			os(LIB_PREFIX);
		}
		else if (kind == NAME_VKIND) {
			os(out_file_prefix); os(VAR_SEPARATOR);
		}
		else {
			GEN_ASSERT(kind == XNAME_VKIND);
		}

		/* Print common part of symbolic fields. */
		if (kind != ADDRESS_VKIND) {
			os(vap -&gt; a_vname);
		}
		if (vap -&gt; a_vprefix) {
			os("@");
			oint(vap -&gt; a_vprefix);
		}
		if (vap -&gt; a_voffset) {
			os("+");
			oint(vap -&gt; a_voffset);
		}

		break;
	}

	case AREG_EA:			/* a4 */
	case DREG_EA:			/* d5 */

		os(tok_name(spill_anode_ptr(arg) -&gt; a_sreg));
		break;

	case DISPLACEMENT_EA:	/* #word(a6) */

		TRACEN(ftag,
			os("{");
			os(spill_anode_ptr(arg) -&gt; a_sname);
			os("}");
		);

		olong(spill_anode_ptr(arg) -&gt; a_slong);
		os("(");
		os(tok_name(spill_anode_ptr(arg) -&gt; a_sreg));
		os(")");
		break;

	case IMMEDIATE_EA:		/* #data */

		TRACEN(ftag,
			if (const_anode_ptr(arg) -&gt; a_debug) {
				if (const_anode_ptr(arg) -&gt; a_ckind == STRING_CKIND) {
					os("{#\"");
					os(const_anode_ptr(arg) -&gt; a_debug);
					os("\"}");
				}
				else {
					os("{#");
					os(const_anode_ptr(arg) -&gt; a_debug);
					os("}");
				}
			}
		);

		if (const_anode_ptr(arg) -&gt; a_ckind == LONG_CKIND) {

			os("#");
			if (prefer_hex_flag) {
				os("$");
				ohex(const_anode_ptr(arg) -&gt; a_long);
			}
			else {
				olong(const_anode_ptr(arg) -&gt; a_long);
			}
		}
		else {

			int kind = const_anode_ptr(arg) -&gt; a_ckind;

			GEN_ASSERT(
				kind == BLOCK_CKIND ||
				kind == FLOAT_CKIND ||
				kind == DOUBLE_CKIND ||
				kind == LONG_DOUBLE_CKIND ||
				kind == STRING_CKIND ||
				kind == STRING_REF_CKIND);

			/*
				In the Mac world, an LEA instruction should have already
				loaded this address into an A-register.
			*/
			#ifdef GEN_GLOBAL_ADDRESS
				os("#");
			#endif
			out_clabel(const_anode_ptr(arg) -&gt; a_label, DONT_DEFINE_THE_LABEL, NO_COMMENT);
		}
		break;

	case INDIRECT_EA:		/* (a0) */

		os("(");
		os(tok_name(spill_anode_ptr(arg) -&gt; a_sreg));
		os(")");
		break;

	case INDEX_EA:			/* byte(a4,d4) */

		olong(spill_anode_ptr(arg) -&gt; a_slong);
		os("(");
		os(tok_name(spill_anode_ptr(arg) -&gt; a_sreg));
		os(",");
		os(tok_name(spill_anode_ptr(arg) -&gt; a_sxreg));
		os(")");
		break;

	case PC_DISP_EA:		/* word(pc) */

		olong(spill_anode_ptr(arg) -&gt; a_slong);
		os("(pc)");
		break;

	case PC_INDEX_EA:		/* byte(pc,xn) */

		olong(spill_anode_ptr(arg) -&gt; a_slong);
		os("(pc,");
		os(tok_name(spill_anode_ptr(arg) -&gt; a_sxreg));
		os(")");
		break;

	case POST_INC_EA:		/* (a0)+ */

		os("(");
		os(tok_name(spill_anode_ptr(arg) -&gt; a_sreg));
		os(")+");
		break;

	case PRE_DEC_EA:		/* -(a0) */

		os("-(");
		os(tok_name(spill_anode_ptr(arg) -&gt; a_sreg));
		os(")");
		break;

	default:

		os("&lt;bad anode: ");
		os("arg: "); optr(arg);
		os(", n_type: "); oint(arg -&gt; n_type);
		os(", tok_name: "); os(tok_name(arg -&gt; n_type));
		os("&gt;\n");

		fatal(
			es("bad anode: ");
			es("arg: "); eptr(arg);
			es(", n_type: "); eint(arg -&gt; n_type);
			es(", tok_name: "); es(tok_name(arg -&gt; n_type)));
	}

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.807">@ Output additional symbolic information about an anode. Return TRUE if such information was, or will be output. out_flag allows us two call this routine twice:  the first fime with out_flag FALSE, so see if we return TRUE.  the second time with out_flag TRUE to actually do the output.
@c

static bool
out_anode_tag(register anode * arg, bool out_flag)
{
	FTAG("out_anode_tag");
	bool result = FALSE;
	STATB(ftag);

	if (arg == NULL) {
		goto done;
	}

	switch(arg -&gt; n_type) {

	case DISPLACEMENT_EA:	/* #word(a6) */

		if (spill_anode_ptr(arg) -&gt; a_sname) {
			if (out_flag) {
				os(spill_anode_ptr(arg) -&gt; a_sname);
				os("{");
					os("`");
					opadhex((spill_anode_ptr(arg) -&gt; a_slong) &amp; 0xffff, 2);
					os("(");
						os(tok_name(spill_anode_ptr(arg) -&gt;a_sreg));
					os(")");
				os("}");
			}
			result = TRUE;
		}
		break;

	case IMMEDIATE_EA:		/* #data */

		if (const_anode_ptr(arg) -&gt; a_debug) {
			if (out_flag) {
				os("#");
				if (const_anode_ptr(arg) -&gt; a_ckind == STRING_CKIND) {
					os("\"");
				}

				/*
					6/10/93: Be careful about the MPW continuation convention.
					Replace '\' by [BS].
				*/
				{
					char * p = const_anode_ptr(arg) -&gt; a_debug;
					while (*p) {
						if (*p == '\\') {
							os("[BS]");
						}
						else {
							ochar(*p);
						}
						p++;
					}
				}

				if (const_anode_ptr(arg) -&gt; a_ckind == STRING_CKIND) {
					os("\"");
				}
			}
			result = TRUE;
			goto done;
		}

		if (const_anode_ptr(arg) -&gt; a_ckind == LONG_CKIND) {

			long val = const_anode_ptr(arg) -&gt; a_long;

			/*
				Print bytes as a character or a small negative number.
				
				Bug fix 9/5/94:
				make sure val can be represented as an unsigned char
				before calling isprint.
				
				9/5/94: Workaround for another CC2 bug:
				Only call isprint when the sign bit of the unsigned char is off.
				(The isprint macro should do a (int)(unsigned char) val,
				but CC2 doesn't handle this cast properly anyway).
			*/
			if (arg -&gt; a_length == 1 &amp;&amp; val == (val &amp; 0x7f) &amp;&amp; isprint(val)) {
				if (out_flag) {
					os("#");
					os("'");
					ochar(val);
					os("'");
					os(" = ");
				}
			}
			if (out_flag) {
				os("0x"); opadhex(val, 2);
			}
			result = TRUE;
		}
		break;

	case AREG_EA:
	case DREG_EA:
	case INDIRECT_EA:
	case POST_INC_EA:
	case PRE_DEC_EA:
	case INDEX_EA:
	case PC_INDEX_EA:

		if (spill_anode_ptr(arg) -&gt; a_sname) {
			if (out_flag) {
					os(spill_anode_ptr(arg) -&gt; a_sname);
			}
			result = TRUE;

		}
		goto done;
	}

done:
	STATX(ftag);
	return result;
}
</t>
<t tx="ekr.20080529093004.808">@ Print the name of an internal compiler label, with a trailing colon and newline if define_flag is TRUE. The label has the form: &lt;file name&gt; LABEL_SEPARATOR.  This routine is also used to print the internal compiler label corresponding to a user label.
@c

void
out_clabel(label_cnode * p, bool define_flag, char * comment)
{
	FTAG("out_clabel");
	STATB(ftag);

	if (!output_is_disabled &amp;&amp; p) {

		GEN_ASSERT(p -&gt; n_type == O_CLABEL || p -&gt; n_type == O_ULABEL);

		/* Generate the actual label. */
		if (define_flag) {
			ocnl();

			/* Generate and EXPORT directive. */
			#if 0 /* data labels cause problems. */
				ocnl(); os("\tEXPORT\t");
				os(out_file_prefix);
				os(LABEL_SEPARATOR);
				oint(p -&gt; c_labnum);
				onl();
			#endif
		}

		os(out_file_prefix);
		os(LABEL_SEPARATOR);
		oint(p -&gt; c_labnum);

		if (define_flag) {
			os(":");
			if (comment) {
				out_comment_field(); os(comment);
			}
			onl();
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.809">@ Output whatever is needed at the start of a source (.c) file.
@c

void
out_begin_file(void)
{
	FTAG("out_begin_file");
	STATB(ftag);

	/* Re-initialize this module. */
	in_data_flag = FALSE;
	in_function_flag = FALSE;
	in_record_flag = FALSE;
	force_code_flag = FALSE;
	out_file_prefix = NULL;
	prefer_hex_flag = FALSE;

	/* Free all the with nodes by adding them to the with_avail_list. */
	if (with_avail_list == NULL) {
		with_avail_list = with_list;
		with_list = NULL;
	}
	else {

		/* Add the with_list to the end of the with_avail_list. */
		with_node * wp = NULL;

		for (wp = with_avail_list; wp &amp;&amp; wp -&gt; next; wp = wp -&gt; next) {
			;
		}
		GEN_ASSERT(wp);
		wp -&gt; next = with_list;
		with_list = NULL;
	}

	/* Set the file prefix. */
	set_file_prefix();

	if (!output_is_disabled) {
	
		/* 7/25/94. */
		if (err_verbose) {
			ecnl(); es("Writing       "); es(arg_out_path); es("...\n");
		}

		out_comment(); os("----- CC2 compilation\n");

		/* Output default directives. */
		out_comment(); onl();

		os("\tSTRING ASIS");
			out_comment_field(); os("all strings are exactly as written\n");

		#if 0 /*  This results in too many warnings. */
			os("\tOPT NONE");
				out_comment_field(); os("no assembler optimization\n");
		#endif

		os("\tCASE ON");
			out_comment_field(); os("upper and lower case are distinct\n");
		os("\tSEG "); os("'"); os(arg_segment); os("'");
			out_comment_field(); os("set segment name\n");
		out_comment(); onl();

		/* 6/14/93: Add definition of Macintosh Debugger trap. */
		TRACEN("debugger_trap",
			ocnl();
			os("_Debugger\tOPWORD\t$A9FF\n");
		);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.810">@ Output a cinode.  3/5/93: Defer an abort so the whole instruction can be printed.
@c

static void
out_cinode(register cinode * p)
{
	FTAG("out_cinode");
	bool fatal_flag = FALSE;
	STATB(ftag);

	/* Output machine code to file. */
	ocnl();
	otab();
	os(tok_name(p -&gt; n_type));

	/* Output the instruction length. */
	switch(p -&gt; c_length) {

	case 0:	os("  ");	break;
	case 1:	os(".b");	break;
	case 2:	os(".w");	break;
	case 4:	os(".l");	break;
	default:
		os("&lt;bad opcode length:"); oint(p -&gt; c_length); os("&gt;");
		fatal_flag = TRUE;
	}
	otab();

	/* Output the arguments. */
	if (p -&gt; c_arg1 || p -&gt; c_arg2) {

		int opcode = p -&gt; n_type;

		prefer_hex_flag = (opcode == X_ANDI || opcode == X_EORI || opcode == X_ORI);
			out_anode(p -&gt; c_arg1);
		prefer_hex_flag = FALSE;
	}
	if (p -&gt; c_arg2) {
		ochar(',');
		out_anode(p -&gt; c_arg2);
	}

	/* Output the optional comment field. */
	if (arg_asm_comment_flag) {
		if (out_anode_tag(p -&gt; c_arg1, FALSE) &amp;&amp; out_anode_tag(p -&gt; c_arg2, FALSE)) {
			out_comment_field();
				out_anode_tag(p -&gt; c_arg1, TRUE);
				ocs();
				out_anode_tag(p -&gt; c_arg2, TRUE);
		}
		else if (out_anode_tag(p -&gt; c_arg1, FALSE)) {
			out_comment_field(); out_anode_tag(p -&gt; c_arg1, TRUE);
		}
		else if (out_anode_tag(p -&gt; c_arg2, FALSE)) {
			out_comment_field(); out_anode_tag(p -&gt; c_arg2, TRUE);
		}
	}
	ocnl();

	if (fatal_flag) {
		fatal(es("&lt;bad opcode length:"); eint(p -&gt; c_length); es("&gt;"));
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.811">@ Output one code node.
@c

static void
out_cnode(cnode * p)
{
	FTAG("out_cnode");
	STATB(ftag);

	switch (p -&gt; n_type) {

	case O_CLABEL:

		out_clabel(label_ptr(p), DEFINE_THE_LABEL, NO_COMMENT);
		break;

	case O_ULABEL:

		out_clabel(label_ptr(p), DONT_DEFINE_THE_LABEL, NO_COMMENT);

		/* Output a comment. */
		os(":"); out_comment_field(); os(ulabel_cnode_ptr(p) -&gt; c_labsym); onl();
		break;

	case O_LINE_NUMBER:
	{
		register token * tp = line_ptr(p) -&gt; c_line_ptr;
		register int count = line_ptr(p) -&gt; c_line_count + 1;
		register long line = line_ptr(p) -&gt; c_line;

		if (arg_asm_comment_flag) {

			/* Start with a blank line. */
			ocnls(2);

			/* 4/20/93: Set err_line here for fatal. */
			{
				long save_line = err_line;
				err_line = line;

				while(count--) {
					out_comment();
						next_tok(tp);
						os("@ line"); opadlong(line++, 4);
						os(": ");
						es2os_flag = TRUE;
						tp = tok_dump_line2(tp,
							DONT_PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_USER_TOKENS);
						es2os_flag = FALSE;
					ocnl();
				}

				err_line = save_line;
			}
		}

		/*
			Yet another surprise from the MPW Assembler.
			Some characters in the comment line can continue the line.
			Make sure the line *really* ends by output another comment line.
		*/
		os("*\n");
		break;
	}

	default:

		if (is_xtok(p -&gt; n_type)) {
			out_cinode(cinode_ptr(p));
		}
		else {
			out_anode(anode_ptr(p));
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.812">@ Start an end-of-line comment field at column COMMENT_FIELD_COLUMN.
@c

#define COMMENT_FIELD_COLUMN 35

static void
out_comment_field(void)
{
	FTAG("out_comment_field");
	STATB(ftag);

	if (io_line_count &lt; COMMENT_FIELD_COLUMN) {
		opads(" ", COMMENT_FIELD_COLUMN-io_line_count);
	}
	else {
		oblank();
	}
	os(";");

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.813">@ Output part of an initial data area consisting of the address of an id.  Example: DC.L name
@c

void
out_data_address(snode * s_p)
{
	FTAG("out_data_address");
	STATB(ftag);
	GEN_ASSERT(s_p &amp;&amp; s_p -&gt; spell);

	if (!output_is_disabled) {
		out_record();
		ocnl(); os("\tDC.L\t"); out_anode(s_p -&gt; sarg); onl();
	}
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.814">@ Output a label in a data area.  This routine allows us to make out_record local to this file, which is desirable since out_record depends on the MPW assembler.  Example: label:
@c

void
out_data_clabel(label_cnode * label, bool define_flag, char * comment)
{
	FTAG("out_data_clabel");
	STATB(ftag);

	if (!output_is_disabled) {

		out_record();
		ocnl();
		out_clabel(label, define_flag, comment);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.815">@ Output a data word consisting of the address of an internal compiler label.  Example: DC.L label ; value
@c

void
out_data_clabel_ref (label_cnode * label, bool comment_flag, long value)
{
	FTAG("out_data_clabel_ref");
	STATB(ftag);

	if (!output_is_disabled) {

		out_record();

		#if 0 /* defining all these labels doesn't seem to work. */
			ocnl(); os("\tEXPORT\t"); out_raw_clabel(label); onl();
		#endif

		ocnl(); os("\tDC.L\t");
		out_raw_clabel(label);
		if (comment_flag) {
			otab(); os("; "); opadlong(value, 3);
		}
		ocnl();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.816">@ Given a string defining a floating constant, output a string defining the integer part of that constant.
@c

void
out_data_f2i(char * defstr, tnode * itype)
{
	FTAG("out_data_f2i");
	register char * op = NULL;
	register long mask = 0;
	STATB(ftag);

	if (output_is_disabled) {
		goto done;
	}

	GEN_ASSERT(itype &amp;&amp; itype -&gt; tprim == INT_TYPE);

	if (itype -&gt; tsize == 1) {
		mask = 0xff;
		op = "DC.B";
	}
	else if (itype -&gt; tsize == 2) {
		mask = 0xffff;
		op = "DC.W";
	}
	else {
		GEN_ASSERT(itype -&gt; tsize == 4);
		mask = 0xffffffff;
		op = "DC.L";
	}

	/* Convert the float to an int. */
	{
		long val = (long) atof(defstr);
		ulong uval = val;

		if (
			( t_is_unsigned(itype) &amp;&amp; (uval != (mask &amp; uval))) ||
			(!t_is_unsigned(itype) &amp;&amp; ( val != (mask &amp; uval)))
		) {
			warning(es("floating constant truncated when converted"));
		}

		out_record();

		ocnl(); otab(); os(op); otab();
		if (t_is_unsigned(itype)) {
			oulong(mask &amp; uval);
		}
		else {
			olong(mask &amp; val);
		}
		ocnl();
	}

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.817">@ Given a string defining an integer constant, output a string defining a floating constant of the indicated ckind.
@c

void
out_data_i2f(long val, int ckind)
{
	FTAG("out_data_i2f");
	STATB(ftag);

	if (!output_is_disabled) {

		/*
			Simply append ".0" to the integer constant.
			For MPW: Enclose the constant in double quotes.
		*/
		out_record();
		ocnl(); otab(); out_float_dc(ckind);
		os("\t\""); olong(val); os(".0"); os("\""); onl();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.818">@ Output part of an initial data area consisting of a float constant.
@c

void
out_data_float (char * defstr, int ckind)
{
	FTAG("out_data_float");
	STATB(ftag);

	if (!output_is_disabled) {		

		/* For MPW: Enclose the constant in double quotes. */
		out_record();
		ocnl(); otab(); out_float_dc(ckind); os("\t\""); os(defstr); os("\""); onl();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.819">@ Output part of an initial data area consisting of an integer constant.
@c

void
out_data_int (long val, int msize)
{
	FTAG("out_data_int");
	char * op = NULL;
	STATB(ftag);

	if (!output_is_disabled) {

		switch(msize) {
		case 1:		op = "DC.B"; break;
		case 2:		op = "DC.W"; break;
		case 4: 	op = "DC.L"; break;
		default:	fatal(es("bad msize: "); eint(msize)); break;
		}

		out_record();
		ocnl(); otab(); os(op); otab();	olong(val);

		/* 7/5/93: Output the hex value as a comment. */
		out_comment_field(); os("0x"); opadhex(val,2*msize);
		onl();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.820">@ Output an initializer corresponding to the address of name + offset.
@c

void
out_data_name_offset (char * name, long offset)
{
	FTAG("out_data_name_offset");
	STATB(ftag);

	GEN_ASSERT(name);

	if (!output_is_disabled) {
		out_record();
		ocnl(); os("\tDC.L\t"); os(name); os("+"); olong(offset);
		onl();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.821">@ Output an initializer corresponding to the address of s_p + offset.
@c

void
out_data_offset (snode * s_p, long offset)
{
	FTAG("out_data_offset");
	STATB(ftag);

	GEN_ASSERT(s_p &amp;&amp; s_p -&gt; spell);

	if (!output_is_disabled) {
		out_record();
		ocnl(); os("\tDC.L\t"); out_anode(s_p -&gt; sarg); os("+"); olong(offset);
		onl();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.822">@ Output part of an initial data area consisting of a string. Output a trailing zero byte if trailing_zero_flag is true.  6/26/93: The MPW C compiler generates '\r' for '\n' and vice versa. We could make that translation here, but the best place to do that translation is in sl_cout.  7/16/93: Allow strings longer than 255 characters.  8/25/94: Static variables *must* be placed in the data segment since the label has already been put in the data segment.
@c

void
out_data_string (char * s, bool trailing_zero_flag, bool force_data_area_flag)
{
	FTAG("out_data_string");
	register bool previous_char_flag = FALSE;
	register char c = ' ';
	size_t length = strlen(s);
	int string_count = 0;
	STATB(ftag);

	if (output_is_disabled) {
		goto done;
	}

	/* Strings are held in the code space inside functions. */
	if (dcl_in_function_flag &amp;&amp; !force_data_area_flag) {
		out_endr();
	}
	else {
		out_record();
	}

	if (*s == '\0') {

		ocnl(); os("\tDC.B\t0,0\n");
		goto done;
	}

	/*
		For MPW: enclose the string in single quotes.
		Single quotes are represented as two successive single quotes.
	*/
	ocnl(); os("\tDC.B\t");

	while(c = *s++) {

		/* MPW has a maximum string size of 255, but any positive even number will do. */
		if (string_count == 100) {

			/* End the string. */
			if (previous_char_flag) {
				os("'");
			}
			previous_char_flag = FALSE;

			/* Start a new string. */
			ocnl(); os("\tDC.B\t");

			string_count = 0;
		}

		/* Every character adds one to the string count, no matter how printed. */
		string_count++;

		if (c == '\'') {

			/* Start a string if necessary. */
			if (previous_char_flag == FALSE) {
				os("'");
			}
			os("''");
			previous_char_flag = TRUE;
		}
		else if (c == '\\') {

			/* Break out of a previous string. */
			if(previous_char_flag) {
				os("',");
			}

			/* User errors should have been caught in tokize. */
			GEN_ASSERT(*s);

			/* Adjust the length: only one character is output. */
			length--;

			/* Convert the escape character to a decimal constant. */
			switch(c = *s++) {

				case 'a':	oint('\a');	break;
				case 'f':	oint('\f');	break;
				case 'n':	oint('\n');	break;
				case 'r':	oint('\r');	break;
				case 't':	oint('\t');	break;
				case 'v':	oint('\v');	break;
				default:	oint(c);	break;
			}

			/* Separate the integer from what comes next if anything remains. */
			if (*s) {
				os(",");
			}
			previous_char_flag = FALSE;
		}
		else {

			/* Start a string if necessary. */
			if (previous_char_flag == FALSE) {
				os("'");
			}
			ochar(c);
			previous_char_flag = TRUE;
		}
	}

	/* End any string. */
	if (previous_char_flag) {
		os("'");
	}

	/* Add the trailing zero byte. */
	if (trailing_zero_flag) {
		os(",0");

		/* Add padding. */
		if ((length &amp; 1) == 0) {
			os(",0");
		}
	}
	else {
		if ((length &amp; 1) == 1) {
			os(",0");
		}
	}

	ocnl();

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.823">@ Output a user label in the data area.
@c

void
out_data_ulabel(snode * s_p, bool define_flag, bool export_flag)
{
	FTAG("out_data_ulabel");
	STATB(ftag);

	if (!output_is_disabled &amp;&amp; s_p &amp;&amp; s_p -&gt; sarg) {

		out_record();

		#if 1
			if (export_flag) {
				ocnl(); os("\tEXPORT\t"); out_anode(s_p -&gt; sarg); onl();
			}
		#else

			/* Generate an export: this makes the label show up in TMON. */
			ocnl(); os("\tEXPORT\t"); out_anode(s_p -&gt; sarg); onl();
		#endif


		out_anode(s_p -&gt; sarg);

		if (define_flag) {
			os(":\n");
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.824">@ Output whatever is needed at the end of a source (.c) file.
@c

void
out_end_file(void)
{
	FTAG("out_end_file");
	STATB(ftag);

	/* Output this statement despite user errors. */
	if (!arg_no_out_flag) {
	
		/* Bug fix: 7/26/94: end a RECORD not followed by a PROC. */
		if (in_record_flag) {
			out_endr();
		}
		ocnl(); os("\tEND\n");
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.825">@ Output a "long embedded label" following the routine's RTS. The format of a long embedded label is as follows:  0x80  length byte  0 to 255 characters  a pad byte, if needed to align to a word boundary.  word containing the size of the optional data area.
@c

static void
out_embedded_label(uint optional_data_size)
{
	FTAG("out_embedded_label");

	size_t n = strlen(gen_fname);

	ocnl();

	/* Output the 0x80. */
	os("\tDC.B\t$80"); out_comment_field(); os("embedded label\n");

	/* Output the length byte. */
	os("\tDC.B\t"); oint(n); onl();

	/* Output the label itself. */
	os("\tDC.B\t'"); os(gen_fname); os("'");

	/* Output the pad byte. */
	if (n &amp; 1) {
		os(",0");
	}
	onl();

	/* Output the size of the optional data area. */
	os("\tDC.W\t"); ouint(optional_data_size);
	out_comment_field(); os("size of optional data\n");
}
</t>
<t tx="ekr.20080529093004.826">@ Output an ENDR record directive if we are in the range of a RECORD directive. Output a CODE directive if we are in the range of a DATA directive.
@c

static void
out_endr(void)
{
	FTAG("out_endr");
	STATB(ftag);

	/* End the previous record. */
	if (in_record_flag) {

		in_record_flag = FALSE;
		ocnl(); os("\tENDR\n");
	}

	/* Move back to the code space. */
	if (in_data_flag) {

		in_data_flag = FALSE;
		ocnl(); os("\tCODE\n"); os("\tALIGN\n");
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.827">@ Output an entry directive *outside* any data module.
@c

void
out_entry(char * name, bool static_flag)
{
	FTAG("out_entry");
	STATB(ftag);

	if (!output_is_disabled) {

		out_endr();
		ocnl();	os("\tENTRY\t");
		if (static_flag) {
			os(out_file_prefix); os(LABEL_SEPARATOR);
		}
		os(name); onl();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.828">@ Signal an error at the end of the output file. Re-enable the output.
@c

void
out_error(void)
{
	FTAG("out_error");
	STATB(ftag);

	/* Put something in the file to make the assembler complain. */
	ocnl(); os("&amp;&amp; error"); onl();
	out_end_file();

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.829">@ Output a DC.xx instruction for a floating constant.
@c

static void
out_float_dc(int ckind)
{
	FTAG("out_float_dc");
	char * op = NULL;
	STATB(ftag);
	
	/*
		1/1/95 Double is now the preferred type.
		Floats will never be generated unless FLOAT_SIZE &lt; DOUBLE_SIZE
	*/
	switch (ckind) {

		case FLOAT_CKIND:
			GEN_ASSERT(FLOAT_SIZE &lt; DOUBLE_SIZE);
			op = "DC.S"; break;

		case DOUBLE_CKIND:
			op = "DC.D"; break;
		
		case LONG_DOUBLE_CKIND:
			GEN_ASSERT(DOUBLE_SIZE &lt; LONG_DOUBLE_SIZE);
			op = "DC.X"; break;

		default:
			fatal(es("bad ckind")); break;
	}
	os(op);
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.830">@ Output a function to the output file.  This routine is a hybrid. It contains output code that depends on the assembler being used, as well as calls to code generators that are independent of the assembler.  Output entry code:   LINK instruction and register pushes.   If do_addq is TRUE, output an *additional* SUBQ.L #4,a7.   (This will reserve space for a single argument that is   on the stack but for which a7 has not been decremented.)   Move formal registers to allocated registers. Call peephole. Output body. Output register pops and ULNK instruction.   If do_addq is TRUE, output an *additional* ADDQ.L #4,a7.   (This adjusts the stack, so the caller doesn't have to.) Output final return  The global gen_max_alloc is the size of the stack space to allocate.
@c

void
out_func_head(void)
{
	FTAG("out_func_head");
	STATB(ftag);
	GEN_ASSERT(gen_fsnode);

	if (output_is_disabled) {
		goto done;
	}

	/* End any record definition. */
	out_endr();

	/* Enter the function. */
	in_function_flag = TRUE;

	/*
		Output the function header.

		We *never* generate a MAIN in MPW because the "real" main
		function is the compiler startup code.  This was a big Aha!
	*/
	#if 0
		ocnl(); otab(); os(str_eq(gen_fname, "main") ? "MAIN" : "PROC"); onl();
	#endif
	ocnl(); os("\tPROC\n");

	if (s_is_static(gen_fsnode)) {

		/* Output an ENTRY directive. */
		ocnl(); os("\tENTRY\t");
		os(out_file_prefix); os(LABEL_SEPARATOR); os(gen_fname); onl();
	}
	else {

		/* Output an EXPORT directive. */
		ocnl(); os("\tEXPORT\t"); os(gen_fname); onl();
	}

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.831">void
out_function(int r_push, int do_addq)
{
	FTAG("out_function");
	STATB(ftag);
	GEN_ASSERT(gen_fsnode);

	if (output_is_disabled) {
		goto done;
	}

	/* End a RECORD directive or data area. */
	out_endr();

	/* Output an IMPORT directive for each item on gen_import_list. */
	gen_all_imports();

	/* Output a WITH directive for each item on with_list. */
	out_with();

	/* Output the entry code. */
	if (arg_asm_comment_flag) {
		out_comment(); os("Entry code...\n");
	}
	ocnl();

	/* Output the function's label. */

	if (s_is_static(gen_fsnode)) {
		os(out_file_prefix); os(LABEL_SEPARATOR);
	}
	os(gen_fname); os(":\n");

	if (gen_max_alloc || gen_formal_size || arg_gen_link_flag) {

		/* Make sure gen_max_alloc is even here. */
		if (gen_max_alloc &amp; 1) {
			gen_max_alloc++;
		}

		if (gen_max_alloc &lt; 32768L) {
			os("\tlink a6,#");

			/* Print 0 as 0, not -0. */
			if (gen_max_alloc &gt; 0) {
				os("-");
			}
			oulong(gen_max_alloc); onl();
		}
		else {
			/* This is what a 32-bit LINK instruction would do. */
			os("\tmove.l a6,-(a7)\n");
			os("\tmove.l a7,a6\n");
			os("\tsuba.l #"); oulong(gen_max_alloc); os(",a7\n");
		}
	}

	/* Output the register saves */
	if (r_push) {

		/* 3/4/93: Use MOVE for one register, MOVEM for more than one. */
		otab();
		if (r_push == 1) {
			int i;
			for (i = R_A0; i &lt;= R_D7; i++) {
				if (reg_is_pushed(i)) {
					/* 5/1/93: movea.l is used only when the *destination* is an a-reg. */
					os("move.l");
					break;
				}
			}
		}
		else {
			os("movem.l");
		}
		otab(); out_rlist(); os(",-(a7)"); out_comment_field(); os("save regs\n");
	}

	if (do_addq) {
		os("\tsubq.l #4, a7"); out_comment_field(); os("allocate call_1arg space\n");
	}

	/* 6/14/93: Add invocation of Macintosh Debugger trap to main(). */
	TRACEN("debugger_trap",
		if (str_eq(gen_fname, "main")) {
			ocnl();
			os("\t_Debugger\n");
		}
	);

	/* Output the code list! */
	if (arg_asm_comment_flag) {
		out_comment(); os("Code list...\n");
	}
	ocnl();
	out_list(code_head);

	/* Remove the nodes following the code head. */
	GEN_ASSERT(code_head);
	code_head -&gt; n_next = NULL;
	code_head -&gt; c_back = NULL;
	code_tail = code_head;

	/*
		Generate the exit code.

		The offsets for formal parameters assume that LINK/UNLK instructions are present,
		so we had better generate the UNLK even if gen_max_alloc is 0!
	*/
	if (arg_asm_comment_flag) {
		out_comment(); os("Exit code...\n");
	}
	ocnl();

	/* Output the register restores. */
	if (do_addq) {
		os("\taddq.l #4,a7"); out_comment_field(); os("free call_1arg space\n");
	}
	if (r_push) {
		/* 3/4/93: Use MOVE or MOVEA for one register, MOVEM for more than one. */
		otab();
		if (r_push == 1) {
			int i;
			for (i = R_A0; i &lt;= R_D7; i++) {
				if (reg_is_pushed(i)) {
					os( (i &lt;= R_A7) ? "movea.l" : "move.l");
					break;
				}
			}
		}
		else {
			os("movem.l");
		}
		os("\t(a7)+,"); out_rlist(); out_comment_field(); os("restore regs\n");
	}

	/* Output the UNLK and RTS. */
	if (gen_max_alloc || gen_formal_size || arg_gen_link_flag) {
		if (gen_max_alloc &lt; 32768L) {
			os("\tunlk a6");
			onl();
		}
		else {
			os("\tmove.l a6,a7");
			onl();
			os("\tmove.l (a7)+,a6");
			onl();
		}
	}
	ocnl(); os("\trts"); onl();

	/*
		Output an embedded label, followed by the size of the optional data area.
		Only output an embedded label if a true UNLK instruction was generated.
	*/
	if (
		(gen_max_alloc &amp;&amp; gen_max_alloc &lt; 32768L) ||
		gen_formal_size || arg_gen_link_flag
	) {
		out_embedded_label(gen_switch_size());
	}

	/*
		Output any accumulated jump tables in the *code* segment.
	*/
	force_code_flag = TRUE;
	gen_switch_tables();
	force_code_flag = FALSE;

	/* End the code segment. */
	ocnl(); os("\tENDPROC\n");

	/* Exit the function. */
	in_function_flag = FALSE;

done:
	STATX(ftag);
}

</t>
<t tx="ekr.20080529093004.832">@ Output IMPORT directives for a single import_node.
@c

void
out_import(snode * s_p, bool lib_flag)
{
	FTAG("out_import");
	STATB(ftag);

	if (!output_is_disabled) {

		GEN_ASSERT(s_p &amp;&amp; s_p -&gt; spell &amp;&amp; s_p -&gt; spell -&gt; spell_name);
		ocnl();
		os("\tIMPORT\t");
		if (lib_flag) {
			os(LIB_PREFIX);
		}
		os(s_p -&gt; spell -&gt; spell_name);
		os(s_is_code(s_p) ? ":code" : ":data");
		onl();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.833">@ Go down the global code list and output code.
@c

static void
out_list(register cnode *p)
{
	FTAG("out_list");
	STATB(ftag);

	/* Skip the dummy node. */
	GEN_ASSERT(p);
	p = p -&gt; n_next;
	while(p) {
		out_cnode(p);
		p = p -&gt; n_next;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.834">@ Output a label_cnode with no frills.
@c

static void
out_raw_clabel(label_cnode * p)
{
	FTAG("out_raw_clabel");
	STATB(ftag);

	if (!output_is_disabled &amp;&amp; p) {

		GEN_ASSERT(p -&gt; n_type == O_CLABEL);
		os(out_file_prefix);
		os(LABEL_SEPARATOR);
		oint(p -&gt; c_labnum);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.835">@ Output a RECORD or DATA directive, depending on whether we are in a function.  Do nothing if force_code_flag is TRUE.
@c

static void
out_record(void)
{
	FTAG("out_record");
	STATB(ftag);

	if (force_code_flag) {
		goto done;
	}

	if (in_function_flag &amp;&amp; !in_data_flag) {

			ocnl(); os("\tDATA\n"); os("\tALIGN\n");
			in_data_flag = TRUE;
	}
	else if (!in_function_flag &amp;&amp; !in_record_flag) {

		with_node * wp = NULL;
		label_cnode * label = NULL;

		/* Create a new label and a new with_node. */
		new_clabel_macro(label);

		if (with_avail_list) {
			wp = with_avail_list;
			with_avail_list = wp -&gt; next;
		}
		else {
			new_perm_macro(wp, perm_with_node_stats);
		}
		wp -&gt; the_label = label;

		/* Add the with_node to the with_list. */
		lst_add_macro(wp, with_list);

		/* Create the RECORD dirctive. */
		ocnl(); out_raw_clabel(label); os("\tRECORD\n");

		/* Create an ALIGN directive. */
		ocnl(); os("\tALIGN\n");

		in_record_flag = TRUE;
	}

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.836">@ Output a list of registers separated by slashes.
@c

static void
out_rlist(void)
{
	FTAG("out_rlist");
	register int i;
	register bool slash_flag = FALSE;
	STATB(ftag);

	for (i = R_A0; i &lt;= R_D7; i++) {
		if (reg_is_pushed(i)) {
			if (slash_flag) {
				os("/");
			}
			os(tok_name(i));
			slash_flag = TRUE;
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.837">@ Output a comment telling where a formal or auto variable is allocated. ap may be NULL for some global comments.  1/30/94: Changes to make these comments easier to parse in AS. ? the tag is now left justified and preceded by @  ? a colon precedes names, and only names.
@c

void
out_stack_comment(anode * ap, ulong size, char * tag, char * name)
{
	FTAG("out_stack_comment");
	STATB(ftag);

	if (!output_is_disabled &amp;&amp; arg_asm_comment_flag) {
	
		out_comment();
		os("@ ");
		opads(tag, -10);
		os(" size="); opadulong(size, 3);
		os(",");
		if (ap) {
			if (ap -&gt; n_type == DISPLACEMENT_EA) {
				spill_anode * sap = spill_anode_ptr(ap);
				opadlong(sap -&gt; a_slong, 4);
				os("[`"); opadhex(sap -&gt; a_slong &amp; 0xffff, 4); os("]");
				os("("); os(tok_name(sap -&gt; a_sreg)); os(")");
			}
			else {
				oblank();
				out_anode(ap);
			}
			if (name) {
				oblank(); os(":"); os(name);
			}
		}
		ocnl();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.838">@ Output the label of a string.
@c

void
out_string_clabel(label_cnode * label, char * comment)
{
	FTAG("out_string_clabel");
	STATB(ftag);

	if (!output_is_disabled) {

		if (dcl_in_function_flag) {
			out_endr();
		}
		else {
			out_record();
		}
		ocnl(); out_clabel(label, DEFINE_THE_LABEL, comment);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.839">@ Output DC.W switch_label-case_label ;comment
@c

void
out_switch_offset(
	label_cnode * switch_label, label_cnode * case_label,
	bool comment_flag, long value)
{
	FTAG("out_switch_offset");
	STATB(ftag);

	if (!output_is_disabled) {

		ocnl(); os("\tDC.W\t");
		out_raw_clabel(case_label); os("-"); out_raw_clabel(switch_label);
		if (comment_flag) {
			otab(); os("; "); opadlong(value, 3);
		}
		ocnl();
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.840">@ Output a WITH directive for each item on the with_list.
@c

static void
out_with(void)
{
	FTAG("out_with");
	with_node * wp = with_list;
	STATB(ftag);

	while(wp) {
		ocnl(); os("\tWITH\t"); out_raw_clabel(wp -&gt; the_label); onl();
		wp = wp -&gt; next;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.841">@ Output a definition of block of memory all filled with zeros.
@c

void
out_zero(ulong size)
{
	FTAG("out_zero");
	STATB(ftag);

	if (!output_is_disabled &amp;&amp; size &gt; 0) {
		ocnl();	os("\tDCB\t"); oulong(size); os(",0\n");
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.842">@ Set the file prefix if needed.
@c

static void
set_file_prefix(void)
{
	FTAG("set_file_prefix");
	char * file_name = cvt_short_fn(err_fname);
	size_t n = strlen(file_name)-2;
	int i = 0;
	STATB(ftag);
	GEN_ASSERT(err_fname);

	/* Allocate temporary space for the file name. */
	new_file_string_macro(out_file_prefix,file_name);

	/* Scan backwards looking for a period. */
	for (i = n; i &gt;= 0; i--) {
		if (out_file_prefix[i] == '.') {
			out_file_prefix[i] = '\0';
			break;
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.843">/*
	CC2: Peephole optimizer for code nodes.

	source:  CCpeep.c
	started: October 26, 1985
	version:
		February 2, 1993.
			Printed copy sent to Tuple.
			Removed pass1 only optimizations: these must be done in cput.c!
			Removed X_ADD changes: these are already properly handled by gint.c.
		February 22, 1989
*/

&lt;&lt; CCpeep #includes &gt;&gt;
&lt;&lt; CCpeep declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.844">#include "CC.h"

#include "CCdump.h"
#include "CCgen.h"
#include "CCnodes.h"
#include "CCregs.h"
</t>
<t tx="ekr.20080529093004.845">/*
	Declare routines local to this file.
*/
static void		c_delete	(cnode *p);
static cnode *	ph_bxx2bxx	(cinode *cip);
static cnode *	ph_bxx2next	(cinode *cip);
static cnode *	ph_dead		(cinode *cip);
static cnode *	ph_dec_ref	(register label_cnode *p);
static cnode *	ph_flip_bxx	(cinode *cip);
static int 		ph_flip_op	(int code);
static cnode *	ph_merge	(label_cnode *lab_cp);
static cnode *	ph_tst		(cinode *cip);
</t>
<t tx="ekr.20080529093004.846">@ Unlink cnode p from doubly-linked code list.
@c

static void
c_delete(register cnode *p)
{
	FTAG("c_delete");

	if (p == NULL) {
		return;
	}

	TRACEPB(ftag, ecnode(p));

	/*
		Remove the forward link to p.
		We can make the following assertion because of the dummy cnode.
	*/
	ASSERT(p -&gt; c_back);
	p -&gt; c_back -&gt; n_next = p -&gt; n_next;

	/* Remove the back link to p. */
	if (p -&gt; n_next == NULL) {
		code_tail = p -&gt; c_back;
	}
	else {
		cnode_ptr(p -&gt; n_next) -&gt; c_back = p -&gt; c_back;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.847">@ Peephole optimizer loop.  This almost always finishes in two passes over the code.  All called routines set changed to TRUE if any change was made.
@c

static int changed;

void
peep_hole(void)
{
	FTAG("peep_hole");
	FTAGV("-peep_hole_v");
	register cnode *cp = NULL;
	register int g_chg = FALSE;
	register int type = 0;
	int pass = 0;
	TRACEPB(ftag,
		es("\n&gt;&gt; Peep Hole Optimizer...\n\n"));

	do {
		g_chg = FALSE;
		changed = FALSE;

		pass++;
		TRACEPN(ftag, es("pass "); eint(pass); enl());

		cp = code_head;
		while (cp) {

			if (changed) {
				g_chg = TRUE;

				/* Try to avoid multiple passes. */
				if (cp -&gt; c_back) {
					cp = cp -&gt; c_back;
				}
			}
			changed = FALSE;

			type = cp -&gt; n_type;

			TRACEPN(ftagv, ecnode(cp); enl());

			if (type == X_TST &amp;&amp; cp -&gt; c_back) {

				cp = ph_tst(cinode_ptr(cp));
				if (changed) { continue; }
			}
			else if (type == O_CLABEL) {

				if (label_ptr(cp) -&gt; c_refcount == 0) {

					TRACEPN(ftag, es("remove label: "); ecnode(cp); enl());
					c_delete(cp);
					changed = TRUE;
					continue;
				}
				else {
					cp = ph_merge(label_ptr(cp));
					if (changed) { continue; }
				}
			}
			else if (type == X_BRA) {

				cp = ph_bxx2bxx(cinode_ptr(cp));
				if (changed) { continue; }

				cp = ph_bxx2next(cinode_ptr(cp));
				if (changed) { continue; }

				cp = ph_dead(cinode_ptr(cp));
				if (changed) { continue; }
			}
			else if (is_bxx(type)) {

				cp = ph_bxx2bxx(cinode_ptr(cp));
				if (changed) { continue; }

				cp = ph_bxx2next(cinode_ptr(cp));
				if (changed) { continue; }

				cp = ph_flip_bxx(cinode_ptr(cp));
				if (changed) { continue; }
			}

			cp = cp -&gt; n_next;
		}

	} while (g_chg);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.848">@ Decrement the referece count of a label cnode and remove the label if it falls to zero.  Return the pointer to the label cnode or the following cnode if the label cnode was eliminated.
@c

static cnode *
ph_dec_ref(register label_cnode * lab_p)
{
	FTAG("ph_dec_ref");
	cnode * result_p = cnode_ptr(lab_p);
	TRACEPB(ftag,
		ecnode(cnode_ptr(lab_p)));

	ASSERT(lab_p &amp;&amp; (lab_p -&gt; n_type == O_CLABEL || lab_p -&gt; n_type == O_ULABEL));

	if (--(lab_p -&gt; c_refcount) == 0) {

		TRACEN(ftag, es("remove label: "); ecnode(cnode_ptr(lab_p)); enl());

		changed = TRUE;
		result_p = lab_p -&gt; n_next;
		c_delete(cnode_ptr(lab_p));
	}

	STATX(ftag);
	return result_p;
}
</t>
<t tx="ekr.20080529093004.849">@ Remove jumps to jumps.  Replace: bxx lab1   ...   lab1:  bra lab2   ...   lab2:  by:  bxx lab2   ...   lab1: bra lab2   ...   lab2:  Increment the refcount of lab2 and decrement refcount of lab1. Eliminate lab1 if its reference count falls to zero.  Cycles of jumps in this context indicate potential infinite loops; if the cycle closes, there is no way out.  TERMINATION PROOF: if this optimization encounters a closed cycle, it fails and generates an error. If it encounters an open cycle, it carries the branch reference forward to the end of the cycle, and thus eliminates the cycle, and will not succeed again at that same place.  At the present time, all other optimizations remove some code, so restoring a pattern visible to this one requires removal of code and must terminate. This does not rule out the possibility of a cyclic interaction between this one and some future optimizer that only rearranges code.
@c

static cnode *
ph_bxx2bxx(register cinode *cip)
{
	FTAG("ph_bxx2bxx");
	FTAGV("-ph_bxx2bxx_v");
	register label_cnode *lab_cp = NULL;
	register label_cnode *target = NULL;
	STATB(ftag);
	TRACEPN(ftagv, ecnode(cnode_ptr(cip)); enl());

	ASSERT(cip &amp;&amp; cip -&gt; n_type == X_BRA || is_bxx(cip -&gt; n_type));

	/* Check for a closed cycle by marking the labels. */
	lab_cp = label_ptr(cip -&gt; c_arg1);
	while (lab_cp) {

		ASSERT_TRACE(
			lab_cp -&gt; n_type == O_CLABEL || lab_cp -&gt; n_type == O_ULABEL,
			es("jump to non label"));

		/* Check for cycle and mark the label cnode. */
		if (c_is_marked(lab_cp)) {

			/* Disable optimization. */
			error(es("closed cycle of branches!"));
			target = NULL;
			break;
		}
		else {
			TRACEPN(ftagv, epads("mark:", 8); ecnode(cnode_ptr(lab_cp)); enl());
			c_set_mark(lab_cp);
		}

		/* See if the next instruction is an unconditional branch. */
		do {
			lab_cp = lab_cp -&gt; n_next;
		}
		while (lab_cp &amp;&amp; lab_cp -&gt; n_type == O_LINE_NUMBER);

		if (lab_cp == NULL || (lab_cp -&gt; n_type != X_BRA)) {
			break;
		}

		/* We have (another) jump to an unconditional jump. */
		target = lab_cp = label_ptr(cinode_ptr(lab_cp) -&gt; c_arg1);

		TRACEPN(ftag, es("new target: "); ecnode(cnode_ptr(cip)); enl());
	}

	/* Unmark all the marked nodes before the optimization. */
	for (
		lab_cp = label_ptr(cip -&gt; c_arg1);
		lab_cp &amp;&amp; c_is_marked(lab_cp);
		lab_cp = label_ptr(cinode_ptr(lab_cp) -&gt; c_arg1)
	) {

		ASSERT_TRACE(
			lab_cp -&gt; n_type == O_CLABEL || lab_cp -&gt; n_type == O_ULABEL,
			es("marked non label"));

		TRACEPN(ftagv, epads("unmark:", 8); ecnode(cnode_ptr(lab_cp)); enl());
		c_clear_mark(lab_cp);

		do {
			lab_cp = lab_cp -&gt; n_next;
		}
		while (lab_cp &amp;&amp; lab_cp -&gt; n_type == O_LINE_NUMBER);

		if (lab_cp == NULL || lab_cp -&gt; n_type != X_BRA) {
			break;
		}
	}

	/* Do the optimization. */
	if (target) {

		TRACEPN(ftag,
			es("retarget branch: "); ecnode(cnode_ptr(cip));
			es(" to "); ecnode(cnode_ptr(target)); enl());

		(void) ph_dec_ref(label_ptr(cip -&gt; c_arg1));
		cip -&gt; c_arg1 = anode_ptr(target);
		target -&gt; c_refcount++;
		changed = TRUE;
	}

	/* This optimization never alters the code pointer. */
	STATX(ftag);
	return cnode_ptr(cip);
}
</t>
<t tx="ekr.20080529093004.850">@ Delete any jump to an immediately following label.  Replace  jmp lab1  lab1: by  lab1:  Decrement the reference count of lab1 and eliminate lab1 if its reference count falls to zero.
@c

static cnode *
ph_bxx2next(register cinode *cip)
{
	FTAG("ph_bxx2next");
	FTAGV("-ph_bxx2bnext_v");
	register cnode *next_cp = NULL;
	cnode * result_cp = cnode_ptr(cip);
	STATB(ftag);
	TRACEPN(ftagv, ecnode(cnode_ptr(cip)); enl());

	ASSERT(cip -&gt; n_type == X_BRA || is_bxx(cip -&gt; n_type));

	/* Does the jump go to the next instruction? */
	next_cp = cip -&gt; n_next;
	while (next_cp &amp;&amp; next_cp -&gt; n_type == O_LINE_NUMBER) {
		next_cp = next_cp -&gt; n_next;
	}

	if (next_cp &amp;&amp; cnode_ptr(cip -&gt; c_arg1) == next_cp) {

		TRACEPN(ftag,
			es("remove jump to next:\n");
			es("  cip:     "); ecnode(cnode_ptr(cip)); ecnl();
			es("  next_cp: "); ecnode(next_cp); enl());

		c_delete(cnode_ptr(cip));
		result_cp = ph_dec_ref(label_ptr(next_cp));
		changed = TRUE;
	}

	STATX(ftag);
	return result_cp;
}
</t>
<t tx="ekr.20080529093004.851">@ Remove dead or unreachable code, i.e., all code between an unconditional jump and the next label having any references
@c

static cnode *
ph_dead(register cinode *cip)
{
	FTAG("ph_dead");
	FTAGV("-ph_dead_v");
	register cnode *next_cp = NULL;
	STATB(ftag);
	TRACEPN(ftagv, ecnode(cnode_ptr(cip)); enl());

	ASSERT(cip &amp;&amp; cip -&gt; n_type == X_BRA);

	/*
		Remove the next instruction until it is a label with references.
		Adjust reference counts when removing branches!
	*/
	next_cp = cip -&gt; n_next;
	while (next_cp) {

		register int type = next_cp -&gt; n_type;

		if (type == X_BRA || is_bxx(type)) {
			(void) ph_dec_ref(label_ptr(cinode_ptr(next_cp) -&gt; c_arg1));
		}

		if (
			(type == O_CLABEL || type == O_ULABEL) &amp;&amp;
			label_ptr(next_cp) -&gt; c_refcount
		) {
			break;
		}

		if (type != O_LINE_NUMBER) {

			#if 0 /* This is too intrusive. */

				if (changed == FALSE &amp;&amp; err_warn_flag) {

					/*
						Using warning here doesn't work because the parse tree
						has been completely processed.
					*/
					ecnls(2);
					es("Warning: removinging dead code from ");
					es(gen_fname); es("()\n\n");
				}
			#endif

			TRACEPN(ftag, es("remove dead code: "); ecnode(next_cp); enl());

			changed = TRUE;
			c_delete(next_cp);
		}

		next_cp = next_cp -&gt; n_next;
	}

	STATX(ftag);
	return cnode_ptr(cip);
}
</t>
<t tx="ekr.20080529093004.852">@ Flip conditional branches as follows...
Replace:
	bxx lab1  bra lab2  lab1:
by
	byy lab2  lab1:
	
Also adjust and possibly remove lab1.
@c

static cnode *
ph_flip_bxx(register cinode *cip)
{
	FTAG("ph_flip_bxx");
	FTAGV("-ph_flip_bxx_v");
	register cnode *next_cp = NULL;
	STATB(ftag);
	TRACEPN(ftagv, ecnode(cnode_ptr(cip)); enl());

	ASSERT(cip &amp;&amp; is_bxx(cip -&gt; n_type));

	/* Followed by an unconditional jump? */
	next_cp = cip -&gt; n_next;

	while (next_cp &amp;&amp; next_cp -&gt; n_type == O_LINE_NUMBER) {
		next_cp = next_cp -&gt; n_next;
	}

	if (
		next_cp &amp;&amp;
		next_cp -&gt; n_type == X_BRA &amp;&amp;
		next_cp -&gt; n_next &amp;&amp;
		next_cp -&gt; n_next == cip -&gt; c_arg1
	) {

		/* Do the optimization. */
		TRACEPN(ftag,
			es("switching bxx polarity:\n");
			es("  cip:           "); ecnode(cnode_ptr(cip)); ecnl();
			es("  cip -&gt; n_next: "); ecnode(cip -&gt; n_next); ecnl();
			es("  next_cp:       "); ecnode(next_cp); ecnl(););

		changed = TRUE;
		cip -&gt; n_type = ph_flip_op(cip -&gt; n_type);
		cip -&gt; c_arg1 = cinode_ptr(next_cp) -&gt; c_arg1;
		{
			register cnode *next2_cp = next_cp -&gt; n_next;
			c_delete(next_cp);
			(void) ph_dec_ref(label_ptr(next2_cp));
		}
	}

	STATX(ftag);
	return cnode_ptr(cip);
}
</t>
<t tx="ekr.20080529093004.853">@ Return the negation of a conditional jump code.
@c

static int
ph_flip_op(int code)
{
	FTAG("ph_flip_op");
	TRACEP(ftag, es(tok_name(code)));

	switch(code) {

	case X_BEQ:	return X_BNE;
	case X_BNE:	return X_BEQ;

	case X_BLT:	return X_BGE;
	case X_BGE:	return X_BLT;

	case X_BGT:	return X_BLE;
	case X_BLE:	return X_BGT;

	case X_BHI:	return X_BLS;	/* Note */
	case X_BLS:	return X_BHI;

	case X_BCC:	return X_BCS;
	case X_BCS:	return X_BCC;

	case X_BVC:	return X_BVS;
	case X_BVS:	return X_BVC;

	case X_BPL:	return X_BMI;
	case X_BMI:	return X_BPL;

	default:
		fatal(es("bad code "); etoknum(code));
		return 0;
	}
}
</t>
<t tx="ekr.20080529093004.854">@ Merge adjacent compiler labels. User labels and permanent labels are never deleted.
@c

static cnode *
ph_merge(register label_cnode *lab_cp)
{
	FTAG("ph_merge");
	FTAGV("-ph_merge_v");
	register label_cnode *lab_cp2 = NULL;
	cnode * result_p = cnode_ptr(lab_cp);
	STATB(ftag);
	TRACEPN(ftagv, ecnode(cnode_ptr(lab_cp)); enl());

	ASSERT(lab_cp &amp;&amp; lab_cp -&gt; n_type == O_CLABEL);

	if (c_is_perm_label(lab_cp)) {
		goto done;
	}

	/* Skip past all line number nodes. */
	lab_cp2 = lab_cp -&gt; n_next;

	while (lab_cp2 &amp;&amp; lab_cp2 -&gt; n_type == O_LINE_NUMBER) {
		lab_cp2 = lab_cp2 -&gt; n_next;
	}

	if (c_is_perm_label(lab_cp2)) {
		goto done;
	}

	/*
		Replace all references to lab_cp by references to lab_cp2 and
		update the reference count in lab_cp2.
	*/
	if (lab_cp2 &amp;&amp; lab_cp2 -&gt; n_type == O_CLABEL) {

		register cnode * cp = NULL;
		register long count = 0L;

		TRACEPN(ftag,
			es("merge adjacent labels: ");
			ecnode(cnode_ptr(lab_cp)); ecs(); ecnode(cnode_ptr(lab_cp2)); enl());

		/* Convert references to the first label into the second label. */
		for (cp = code_head; cp; cp = cp -&gt; n_next) {

			if (
				(cp -&gt; n_type == X_BRA || is_bxx(cp -&gt; n_type)) &amp;&amp;
				cinode_ptr(cp) -&gt; c_arg1 == anode_ptr(lab_cp)
			) {
				count++;
				cinode_ptr(cp) -&gt; c_arg1 = anode_ptr(lab_cp2);
			}
		}

		/*
			This ASSERT had to be removed because jump table entries
			are valid references that appear nowhere in the code list.

			Fortunately, the assembler will complain about an undefined
			label if the ASSERT would have failed.
		*/
		#if 0
			ASSERT_TRACE (count == lab_cp -&gt; c_refcount,
				es("mismatched reference counts"));
		#endif

		count = lab_cp -&gt; c_refcount;
		lab_cp2 -&gt; c_refcount += count;

		changed = TRUE;
		c_delete(cnode_ptr(lab_cp));
		result_p = cnode_ptr(lab_cp2);
	}

done:
	STATX(ftag);
	return result_p;
}
</t>
<t tx="ekr.20080529093004.855">@ Delete a TST following an instruction that sets the flag if the argument of the TST matches the destination of the previous instruction.
@c

static cnode *
ph_tst(register cinode *cip)
{
	FTAG("ph_tst");
	FTAGV("-ph_tst_v");
	cinode * prev_cip = NULL;
	cnode * result_cp = cnode_ptr(cip);
	TRACEPB(ftag,
		ecnode(cnode_ptr(cip)); enl());

	ASSERT(cip &amp;&amp; cip -&gt; n_type == X_TST &amp;&amp; cip -&gt; c_back);

	/* See if the previous instruction could set the flag. */
	prev_cip = cinode_ptr(cip -&gt; c_back);

	/* Skip over line numbers. */
	while (prev_cip &amp;&amp; prev_cip -&gt; n_type == O_LINE_NUMBER) {
		prev_cip = cinode_ptr(prev_cip -&gt; c_back);
	}

	ASSERT(prev_cip);

	switch (prev_cip -&gt; n_type) {

	case X_ADD:	case X_ADDI: case X_ADDQ:
	case X_AND: case X_ANDI:
	case X_DIVS:
	case X_DIVU:
	case X_EOR:
	case X_EXT:
	case X_MOVE: case X_MOVEA: case X_MOVEQ:
	case X_MULS:
	case X_MULU:
	case X_OR:  case X_ORI:
	case X_SUB: case X_SUBI: case X_SUBQ:

		if (
			is_equiv(cip -&gt; c_arg1, prev_cip -&gt; c_arg2) &amp;&amp;
			cip -&gt; c_length == prev_cip -&gt; c_length
		) {
			result_cp = cip -&gt; n_next;
			c_delete(cnode_ptr(cip));
			changed = TRUE;
		}
		goto done;

	case X_NEG:
	case X_NOT:
	case X_TST:

		if (
			is_equiv(cip -&gt; c_arg1, prev_cip -&gt; c_arg1) &amp;&amp;
			cip -&gt; c_length == prev_cip -&gt; c_length
		) {
			result_cp = cip -&gt; n_next;
			c_delete(cnode_ptr(cip));
			changed = TRUE;
		}
		goto done;

	default:
		goto done;
	}

done:
	STATX(ftag);
	return result_cp;
}
</t>
<t tx="ekr.20080529093004.856">/*
	CC2: Routines that create code nodes.

	source: CCput.c
	started: February 3, 1986
	version:
		January 11, 1995
			Removed experiment regarding extentions of unsigned ints.
			We *must* prevent the sign bit of a short from propagating to a long!
		December 30, 1994.
			Bug fix to c_push_big: Adjust an so we can use -(an),-(sp).
		December 16, 1994.
			Added address_flags to c_move_big.
		December 15, 1994.
			Added c_move_big and c_push_big routines.
		November 10, 1994.
			Added c_load_big routine.
		August 27, 1994.
			Bug fix to c_push_float.  Allow named stack variables as arguments.
		June 10, 1994.
			Bug fix to c_ext_constant.
		May 31, 1994.
			Bug fix to c_push_address: push d-regs as is: assume they contain an address.
		November 2, 1993.
			Bug fix to c_movemem: do not free any temporaries. (That is up to the caller.)
		July 23, 1993.
			Added and documented a crucial ASSERT to c_push_float.
		July 21, 1993.
			Removed kludge in c_memmove dealing with initializers.
		July 19, 1993.
			Replaced ASSERT and ASSERT_TRACE by GEN_ASSERT and GEN_ASSERT_TRACE.
		July 15, 1993.
			Bug fix to c_push_float.
		July 8, 1993.
			Added c_ext_constant.
		July 7, 1993.
			Bug fix to c_ap2address: an LEA must be generated on the Mac
			to convert from ABSOLUTE_EA to ADDRESS_EA.
		June 30, 1993.
			Bug fix to c_put.
		June 18, 1993.
			Made c_push_address global.
		June 1, 1993.
			Change c_push, c_push_address and c_move_len so PEA is generated more often.
			Removed most, but not all, dependencies on GEN_GLOBAL_ADDRESS.
		May 27, 1993.
			Bug fixes (again!) to c_move_len.
		May 9, 1993.
			Removed copy_flag from c_ap2address.
		May 5, 1993.
			Printed copy sent to Tuple.
		May 2, 1993.
			Changed c_move_len so it generates PEA instead of LEA followd by MOVE an,-(sp).
		April 27, 1993.
			Change chk_ptr so it doesn't check the stack pointer.
			(A separate routine could be used for that.)
		April 22, 1993.
			Bug fix to c_push: use no_push_anode instead of a7_anode.
		April 20, 1993.
			Added support for GEN_GLOBAL_ADDRESS.
			Added c_push_address.
		April 14, 1993.
			Removed c_call_lib0.
			Allocated floating temporaries inside c_call_flib1 and c_call_flib2.
		April 8, 1993.
			Added pointer checking code to c_move_len.
			Added c_check_ptr.
		March 26, 1993.
			Changed c_move_len so that MOVE #0,any is converted to CLR any.
			Added c_ap2address.
		March 12, 1993.
			Made c_put global.
		March 8, 1993.
			Added c_line_ptr field to line_nodes.
			Added line_ptr argument to c_line function.
		February 2, 1993.
			Printed copy sent to Tuple.
			Change c_move_len so that moves-to-self are never generated.
			Change c_push so it calls c_move_len.
			Created c_clr routine to avoid a peephole case.
		January 26, 1993.
			Changed c_line to avoid duplicate line nodes.
		January 22, 1993.
			Added c_ext.
			Added support for ADDRESS_EA.
		January 18, 1993.
			c_push_float generates either PEA or MOVE, depending on the argument.
			c_push_float made global.
			New c_push routine.
		December 28, 1992.
			Added c_s2mlen and c_t2mlen.
		December 23, 1992.
			Rewrote c_put.
		December 2, 1992.
			Added arg_gen_trace_flag logic to c_put.
			Removed g_dcl_name and g_str_name.
		November 6, 1992.
			Changed loc_nodes to anodes.
		July 16, 1992
			g_dcl_name now returns a spell_node.
			Use TARGET parameters to create unique string and static id's.
		July 10, 1992
			Removed () from c_put trace.
		July 9, 1992
			Added caller's ftag to c_put trace.
		June 25, 1992
			Replace g_label by c_clabel and c_ulabel.
		June 23, 1992
			First clean compile under CC2.
		June 5, 1991
			First CC2 version.
		March 7, 1989
		August 5, 1986
*/
&lt;&lt; CCput #includes &gt;&gt;
&lt;&lt; CCput declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.857">#include "CC.h"

#include "CCarg.h"
#include "CCcpp.h"
#include "CCdump.h"
#include "CCgen.h"
#include "CCnodes.h"
#include "CCmem.h"
#include "CCregs.h"
#include "CCtarget.h"

#include &lt;LIBlog.h&gt;

#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.858">/*
	Define global variables owned by this module.
*/
cnode * code_head;	/* Head of list of global code list. */
cnode * code_tail;	/* Pointer to last node in list. */

tnode * byte_type;	/* Fixed byte node for g2.c. */
tnode * int_type;	/* Fixed int node for g2.c. */
tnode * long_type;	/* Fixed long node. */

int cur_lab;		/* Number of the current internal label. */
int u_lab;	</t>
<t tx="ekr.20080529093004.859">@ Number of the current user label.
Generate a 0 argument instruction.
@c

void
c_0(int opcode)
{
	FTAG("c_0");
	register cinode * cip = NULL;
	STATB(ftag);

	/* Create a code node. */
	new_cnode_macro(cip, sizeof(cinode), opcode);

	/* Append to code list. */
	c_put(cnode_ptr(cip));

	TRACEPX(ftag, es(tok_name(opcode)));
}
</t>
<t tx="ekr.20080529093004.860">@ Generate a 1 argument instruction with no length.
@c

void
c_1(int opcode, anode *ap)
{
	FTAG("c_1");
	register cinode * cip = NULL;
	STATB(ftag);

	/* Create a code node. */
	new_cnode_macro(cip, sizeof(cinode), opcode);
	cip -&gt; c_arg1 = ap;

	/* Append to code list. */
	c_put(cnode_ptr(cip));

	TRACEPX(ftag, es(tok_name(opcode)); ecs(); eanode(ap); ecnl());
}
</t>
<t tx="ekr.20080529093004.861">@ Generate a 1 argument instruction with explicit length.
@c

void
c_1len(int opcode, anode *ap, int length)
{
	FTAG("c_1len");
	register cinode * cip = NULL;
	STATB(ftag);

	/* Create a code node. */
	new_cnode_macro(cip, sizeof(cinode), opcode);
	cip -&gt; c_arg1 = ap;
	cip -&gt; c_length = length;

	/* Append to code list. */
	c_put(cnode_ptr(cip));

	TRACEPX(ftag, es(tok_name(opcode)); ecs(); eanode(ap); ecnl());
}
</t>
<t tx="ekr.20080529093004.862">@ Generate a 1 argument instruction with length determined by the operand.
@c

void
c_1len1(int opcode, anode *ap)
{
	FTAG("c_1len");
	register cinode * cip = NULL;
	STATB(ftag);

	/* Create a code node. */
	new_cnode_macro(cip, sizeof(cinode), opcode);
	cip -&gt; c_arg1 = ap;
	cip -&gt; c_length = ap -&gt; a_length;

	/* Append to code list. */
	c_put(cnode_ptr(cip));

	TRACEPX(ftag, es(tok_name(opcode)); ecs(); eanode(ap); ecnl());
}
</t>
<t tx="ekr.20080529093004.863">@ Generate a jump or call to a compiler label.
@c

void
c_1clab(int opcode, label_cnode *lp)
{
	FTAG("c_1clab");
	register cinode * cip = NULL;
	STATB(ftag);

	GEN_ASSERT(lp -&gt; n_type == O_CLABEL);
	GEN_ASSERT(is_xtok(opcode));

	/* Bump the reference count in the target. */
	lp -&gt; c_refcount++;

	/* Create a code node to handle the goto. */
	new_cnode_macro(cip, sizeof(cinode), opcode);
	cip -&gt; c_arg1 = anode_ptr(lp);

	/* Append to code list. */
	c_put(cnode_ptr(cip));

	TRACEPX(ftag, es(tok_name(opcode)); ecs(); ecnode(cnode_ptr(lp)); ecnl());
}
</t>
<t tx="ekr.20080529093004.864">@ Generate a jump or call to a user label.
@c

void
c_1ulab(int opcode, ulabel_cnode *lp)
{
	FTAG("c_1ulab");
	register cinode * cip = NULL;
	STATB(ftag);

	GEN_ASSERT(lp -&gt; n_type == O_ULABEL);

	/* Bump the reference count in the target. */
	lp -&gt; c_refcount++;

	/* Create a code node to handle the goto. */
	new_cnode_macro(cip, sizeof(cinode), opcode);
	cip -&gt; c_arg1 = anode_ptr(lp);

	/* Append to code list. */
	c_put(cnode_ptr(cip));

	TRACEPX(ftag, es(tok_name(opcode)); ecs(); ecnode(cnode_ptr(lp)); ecnl());
}
</t>
<t tx="ekr.20080529093004.865">@ Generate a 2 argument instruction with no length.
@c

void
c_2(int opcode, anode *ap1, anode *ap2)
{
	FTAG("c_2");
	register cinode * cip = NULL;
	STATB(ftag);

	/* Create a code node. */
	new_cnode_macro(cip, sizeof(cinode), opcode);
	cip -&gt; c_arg1 = ap1;
	cip -&gt; c_arg2 = ap2;

	/* Append to code list. */
	c_put(cnode_ptr(cip));

	TRACEPX(ftag,
		es(tok_name(opcode)); ecs(); eanode(ap1); ecs(); eanode(ap2); ecnl());
}
</t>
<t tx="ekr.20080529093004.866">@ Generate a jump or call to a compiler label.
@c

void
c_2clab(int opcode, anode * ap, label_cnode *lp)
{
	FTAG("c_2clab");
	register cinode * cip = NULL;
	STATB(ftag);

	GEN_ASSERT(lp -&gt; n_type == O_CLABEL);
	GEN_ASSERT(is_xtok(opcode));

	/* Bump the reference count in the target. */
	lp -&gt; c_refcount++;

	/* Create a code node to handle the goto. */
	new_cnode_macro(cip, sizeof(cinode), opcode);
	cip -&gt; c_arg1 = ap;
	cip -&gt; c_arg2 = anode_ptr(lp);

	/* Append to code list. */
	c_put(cnode_ptr(cip));

	TRACEPX(ftag, es(tok_name(opcode)); ecs(); ecnode(cnode_ptr(lp)); ecnl());
}
</t>
<t tx="ekr.20080529093004.867">@ Generate a 2 argument instruction with an explicit length.
@c

void
c_2len(int opcode, anode *ap1, anode *ap2, int length)
{
	FTAG("c_2len");
	register cinode * cip = NULL;
	STATB(ftag);

	/* Create a code node. */
	new_cnode_macro(cip, sizeof(cinode), opcode);
	cip -&gt; c_arg1 = ap1;
	cip -&gt; c_arg2 = ap2;
	cip -&gt; c_length = length;

	/* Append to code list. */
	c_put(cnode_ptr(cip));

	TRACEPX(ftag,
		es(tok_name(opcode)); ecs(); eanode(ap1); ecs(); eanode(ap2); ecnl());
}
</t>
<t tx="ekr.20080529093004.868">@ Generate a 2 argument instruction with an implied length equal to the length of the second argument.
@c

void
c_2len2(int opcode, anode *ap1, anode *ap2)
{
	FTAG("c_2len2");
	register cinode * cip = NULL;
	int length = ap2 -&gt; a_length;
	STATB(ftag);

	/* Create a code node. */
	new_cnode_macro(cip, sizeof(cinode), opcode);
	cip -&gt; c_arg1 = ap1;
	cip -&gt; c_arg2 = ap2;
	cip -&gt; c_length = length;

	/* Append to code list. */
	c_put(cnode_ptr(cip));

	TRACEPX(ftag,
		es(tok_name(opcode)); ecs(); eanode(ap1); ecs(); eanode(ap2); ecnl());
}
</t>
<t tx="ekr.20080529093004.869">@ Generate code to add the indicated amount to the stack pointer.
@c

void
c_adj_stack(long size)
{
	FTAG("c_adj_stack");
	STATB(ftag);

	if (size) {
		anode * ap_val = NULL;
		new_const_anode_macro(ap_val, size, REGISTER_SIZE);
		c_2len(X_ADDA, ap_val, a7_anode, REGISTER_SIZE);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.870">@ Return an anode representing the address of the original anode.  Actual code, i.e., the LEA instruction, must sometimes be generated. In particular, the addresses of Macintosh global variables (application globals) are not known at link time. Indeed the addresses of application globals are expressed as offsets from A5. Thus, LEA instructions can not be avoided on the Macintosh.
@c

anode *
c_ap2address(register anode * ap)
{
	FTAG("c_ap2address");
	STATB(ftag);

	/*
		Convert the address mode to one representing an address.
		WARNING: g_prim must make sure that this can always be done.
	*/
	switch(ap -&gt; n_type) {

	case ABSOLUTE_EA:

		/*
			ABSOLUTE_EA is used by g_prim for all static symbols.

			7/7/93: Actual code must be generated on the Mac for the &amp; operator.
			It is tempting to not generate code here, because this
			code will result in...

				LEA	name,An
				MOVE An,-(a7)

			which obviously could be written as

				PEA name

			However, there are cases where an LEA is required that won't
			evenutually be pushed, so to be safe we have to do the following.

			A peephole could optimize this code if needed.
		*/

		#ifdef GEN_GLOBAL_ADDRESS
			ap -&gt; n_type = ADDRESS_EA;
		#else
			/* The destination of an LEA must be an A-reg. */
			ap = c_lea(ap);
		#endif
		goto done;


	case DISPLACEMENT_EA:
	case INDEX_EA:

		/*
			DISPLACEMENT_EA is used by g_prim for all stack variables and temps,
			except where the displacement would exceed 16 bits,
			in which case g_prim uses INDEX_EA.

			Real code must be generated here since the address of
			stack variables and temps can not be known until run-time,
		*/
		ap = c_lea(ap);
		goto done;

	case INDIRECT_EA:

		/* INDIRECT_EA is used by g_prim for complex structs/unions/arrays. */
		ap -&gt; n_type = AREG_EA;
		goto done;

	case IMMEDIATE_EA:

		/*
			Only certain constants are may have their address computed.
			The address of blocks is used when calling memmove.
		*/

			if (
				const_anode_ptr(ap) -&gt; a_ckind == STRING_CKIND ||
				const_anode_ptr(ap) -&gt; a_ckind == BLOCK_CKIND
			) {
				goto done;
			}

		/* Fall through. */

	default:
		fatal(
			es(ftag); es(" bad address mode ");
			es(tok_name(ap -&gt; n_type)));
	}

done:
	TRACEPX(ftag, eret(); eanode(ap); ecnl());
	return ap;
}
</t>
<t tx="ekr.20080529093004.871">@ Generate a call to the pointer checking routine.  WARNING: The _chk_ptr library routine must save and restore all registers!
@c

void
c_chk_ptr (anode * indirect_ap)
{
	FTAG("c_chk_ptr");
	bool save_arg = arg_chk_ptr_flag;
	cinode * cip = NULL;
	anode * ptr_ap = NULL;
	ulong stack_size = 0;
	static anode * name_ap = NULL;
	STATB(ftag);
	GEN_ASSERT(indirect_ap &amp;&amp; indirect_ap -&gt; n_type == INDIRECT_EA);

	/* Do not check the stack pointer. */
	if (indirect_ap == push_anode || indirect_ap == no_push_anode) {
		goto done;
	}

	/* Turn off pointer checking, otherwise c_push will call c_chk_ptr! */
	arg_chk_ptr_flag = FALSE;

	/* Generate code to push the *pointer*, not what is being pointer to. */
	ptr_ap = c_copy(indirect_ap);
	ptr_ap -&gt; n_type = AREG_EA;
	ptr_ap -&gt; a_length = POINTER_SIZE;
	stack_size += c_push(ptr_ap, ONE_ARG);

	/* Create an anode for the name of the checking routine. */
	if (name_ap == NULL) {
		new_perm_anode_macro(name_ap, sizeof(var_anode), ABSOLUTE_EA);
		var_anode_ptr(name_ap) -&gt; a_vkind = XNAME_VKIND;
		var_anode_ptr(name_ap) -&gt; a_vname = "_chk_ptr";
	}

	/* Create a code node. */
	new_cnode_macro(cip, sizeof(cinode), X_JSR);
	cip -&gt; c_arg1 = name_ap;

	gen_import_name("_chk_ptr", DONT_USE_LIB_PREFIX);

	/* Append to code list. */
	c_put(cnode_ptr(cip));

	/* Generate the code to reset the stack pointer */
	c_adj_stack(stack_size);

	/* Restore the user's arg_chk_ptr setting. */
	arg_chk_ptr_flag = save_arg;

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.872">@ Link a compiler label node into the code list.  Label nodes:  o Are created during code generation. o Represent all labels generated by the program. o Are created when first referenced. o Are linked into the code list when and if needed. o contain a reference count field so unneeded labels are not output.  Internal (non-user) label nodes contain a count. The count is used to generate a unique label. The count needs to be assigned when the label is first generated so jumps to the label can be output before the label is actually output.
@c

void
c_clabel(label_cnode *lp)
{
	FTAG("c_clabel");
	STATB(ftag);

	/* Append to code list. */
	c_put(cnode_ptr(lp));

	TRACEPX(ftag, ecnode(cnode_ptr(lp)); ecnl());
}
</t>
<t tx="ekr.20080529093004.873">@ Extend an operand and set the length as needed.  Section 3.2.1.2 Signed and Unsigned Integers  When a value with integral type is converted to another integral type, if the value can be represented by the new type, its value is unchanged.  [EKR: therefore, when converting from *unsigned* short to *unsigned* long the extra bits must be 0 bits since the value of the original is non-negative.]  When a *signed* integer is converted to unsigned integer with equal or greater size, if the value of the signed integer is nonnegative, its value is unchanged.  [EKR: That is, the extra bits must be zero bits.]  Otherwise: if the unsigned integer has greater size, the signed integer is first promoted to the signed integer corresponding to the unsigned integer; the value is converted to unsigned by adding to it one greater than the largest number that can be represented by the unsigned integer type.  Footnote: In a two's complement representation, there is no actual change in the bit pattern except filling the high-order bits with copies of the sign bit if the unsigned integer has greater size.  7/7/93: Rewrote this routine. It is not valid to mask off the original high bit when extending an unsigned!  1/11/95: There are four cases to consider when sizeof(new type) &gt; sizeof(old type)  new type old type --- ---- --- ---- signed  signed extend: result must be negative. unsigned signed extend: footnote applies if negative, otherwise value is unchanged. signed  unsigned don't extend: result must be positive. unsigned unsigned don't extend: result must be positive.  As a result, we must know only whether the *old* value is unsigned.
@c

anode *
c_ext(anode * ap, int new_length, bool old_unsigned_flag)
{
	FTAG("c_ext");
	int old_length = ap -&gt; a_length;
	STATB(ftag);

	GEN_ASSERT(new_length == 2 || new_length == 4);
	GEN_ASSERT(ap);

	if (new_length &lt;= old_length) {
		goto done;
	}

	ap = c_move2dtreg(ap);

	/*
		At this point we have new_length &gt; old_length.

		1/11/94: We must treat unsigned differently.
		This may not always be the best place (compare Think C),
		but there is no alternative at present.
	*/
	if (old_unsigned_flag) {

		if (new_length == 2) {

			/* old_length == 1. */
			c_2len(X_ANDI, mask_00ff_anode, ap, 2);
		}
		else {		/* new_length == 4. */

			if (old_length == 1) {
				c_2len(X_ANDI, mask_000000ff_anode, ap, 4);
			}
			else {
				/* old_length == 2. */
				c_2len(X_ANDI, mask_0000ffff_anode, ap, 4);
			}
		}
	}
	else {

		if (old_length == 1) {
			c_1len(X_EXT, ap, 2);
		}

		if (new_length == 4) {
			c_1len(X_EXT, ap, 4);
		}
	}

	ap -&gt; a_length = new_length;

done:
	TRACEPX(ftag, eret(); eanode(ap); ecnl());
	return ap;
}
</t>
<t tx="ekr.20080529093004.874">@ Create a new anode representing the extension a constant anode to the indicated length. No code is generated.  See the important comments for c_ext.
@c

anode *
c_ext_constant(anode * ap, int mlen, bool old_unsigned_flag)
{
	FTAG("c_ext_constant");
	register anode * result_ap = NULL;
	STATB(ftag);

	GEN_ASSERT(ap &amp;&amp; a_is_constant(ap));

	result_ap = c_copy(ap);
	result_ap -&gt; a_length = mlen;

	/* 6/18/93: Sign extend signed constants. */
	if (!old_unsigned_flag) {

		long val = const_anode_ptr(result_ap) -&gt; a_long;

		/*
			Bug fix: 6/10/94
			Generate code depending on *both* mlen and old_mlen.
		*/
		int old_mlen = ap -&gt; a_length;
		
		/* 11/13/94 allow mlen == old_mlen. */
		if (mlen != old_mlen) {
			GEN_ASSERT(mlen &gt; old_mlen);
	
			if (mlen == 4) {
				if (old_mlen == 1) {
					if (val &amp;  0x00000080) {
						val |= 0xffffff00;
					}
				}
				else {
					GEN_ASSERT(old_mlen == 2);
					if (val &amp;  0x00008000) {
						val |= 0xffff0000;
					}
				}
			}
			else {
				GEN_ASSERT(mlen == 2 &amp;&amp; old_mlen == 1);
				if (val &amp;  0x00000080) {
					val |= 0x0000ff00;
				}
			}
		}

		const_anode_ptr(result_ap) -&gt; a_long = val;
	}

	TRACEPX(ftag, eret(); eanode(result_ap); enl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.875">@ Create an anode representing the adddress of ap and free ap.  Warning: don't call this routine if ap can not be freed!
@c

anode *
c_lea(anode * ap)
{
	c_lea_opt(ap, FREE_AP);
}
</t>
<t tx="ekr.20080529093004.876">anode *
c_lea_temp(anode * ap)
{
	c_lea_opt(ap, DONT_FREE_AP);
}
</t>
<t tx="ekr.20080529093004.877">anode *
c_lea_opt (anode * ap, bool free_flag)
{
	FTAG("c_lea");
	anode * result_ap = NULL;
	STATB(ftag);
	GEN_ASSERT(ap);

	if (a_is_temp(ap) &amp;&amp; ap -&gt; n_type == INDIRECT_EA) {
	
		/* LEA (A1),A1 is a no-op, so just convert (An) to An */
		if (free_flag) {
			result_ap = ap;
		}
		else {
			result_ap = get_atemp(REGISTER_SIZE);
			ap -&gt; n_type = AREG_EA;
			c_move_len(ap, result_ap, REGISTER_SIZE);
			ap -&gt; n_type = INDIRECT_EA;
		}
		result_ap -&gt; n_type = AREG_EA;
		result_ap -&gt; a_length = REGISTER_SIZE;
	}
	else {
		result_ap = get_atemp(REGISTER_SIZE);
		c_2(X_LEA, ap, result_ap);
		if (free_flag) {
			free_temp(ap);
		}
	}

	GEN_ASSERT(result_ap);
	TRACEPX(ftag, eret(); eanode(result_ap); ecnl());
	return result_ap;
}
</t>
<t tx="ekr.20080529093004.878">@ Generate a code node representing a line number.
@c

static last_line = -1;

void
c_line(pnode * p)
{
	FTAG("c_line");

	/* Avoid duplicate line nodes. */
	if (p -&gt; p_line != last_line) {

		line_cnode * clp = NULL;

		STATB(ftag);

		last_line = p -&gt; p_line;

		/* Create a line node. */
		new_cnode_macro(clp, sizeof(line_cnode), O_LINE_NUMBER);

		clp -&gt; c_line = p -&gt; p_line;
		clp -&gt; c_line_ptr = p -&gt; p_line_ptr;
		clp -&gt; c_line_count = p -&gt; p_line_count;

		/* Append to code list. */
		c_put(cnode_ptr(clp));

		TRACEPX(ftag, eint(p -&gt; p_line); enl());
	}
}
</t>
<t tx="ekr.20080529093004.879">@ Same as c_line except that the p_line2_xxx fields are used instead of p_line.
@c

void
c_line2(do_node * p)
{
	FTAG("c_line2");

	/* Avoid duplicate line nodes. */
	if (p -&gt; p_line2 != last_line) {

		line_cnode * clp = NULL;

		STATB(ftag);

		last_line = p -&gt; p_line2;

		/* Create a line node. */
		new_cnode_macro(clp, sizeof(line_cnode), O_LINE_NUMBER);

		clp -&gt; c_line = p -&gt; p_line2;
		clp -&gt; c_line_ptr = p -&gt; p_line2_ptr;
		clp -&gt; c_line_count = p -&gt; p_line2_count;

		/* Append to code list. */
		c_put(cnode_ptr(clp));

		TRACEPX(ftag, eint(p -&gt; p_line); enl());
	}
}
</t>
<t tx="ekr.20080529093004.880">@ Zero an object whose size is 1, 2 or 4.
@c

void
c_clr(anode * ap)
{
	FTAG("c_clr");
	STATB(ftag);

	if (a_is_areg(ap)) {
		c_move_len(zero_anode, ap, ap -&gt; a_length);
	}
	else {
		c_1len(X_CLR, ap, ap -&gt; a_length);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.881">@ Return the size of the smallest signed integer type that will contain the signed constant n.
@c

short
c_long2mlen(long n)
{
	FTAG("c_ulong2mlen");
	short result = 0;
	STATB(ftag);

	if (n &lt; -INT_MAX - 1 || n &gt; INT_MAX) {
		result = 4;
	}
	else if (n &lt; -256 || n &gt; 255) {
		result = 2;
	}
	else {
		result = 1;
	}

	STATX(ftag);
	return result;
}
</t>
<t tx="ekr.20080529093004.882">@ Return the size of the smallest unsigned integer type that will contain the unsigned constant n.
@c

short
c_ulong2mlen(ulong n)
{
	FTAG("c_ulong2mlen");
	short result = 0;
	STATB(ftag);

	if (n &gt; UINT_MAX) {
		result = 4;
	}
	else if (n &gt; 255) {
		result = 2;
	}
	else {
		result = 1;
	}

	STATX(ftag);
	return result;
}
</t>
<t tx="ekr.20080529093004.883">@ Make a copy of an anode.
@c

anode *
c_copy(anode * ap)
{
	FTAG("c_copy");
	register anode * new_ap = NULL;
	register size_t size = 0;
	STATB(ftag);

	GEN_ASSERT(ap);

	/* Find the size of the node. */
	switch (ap -&gt; n_type) {

	case ABSOLUTE_EA:
	case ADDRESS_EA:
		size = sizeof(var_anode);
		break;

	case IMMEDIATE_EA:
		size = sizeof(const_anode);
		break;

	case AREG_EA:
	case DISPLACEMENT_EA:
	case DREG_EA:
	case INDIRECT_EA:
	case POST_INC_EA:
	case PRE_DEC_EA:
	case INDEX_EA:
	case PC_INDEX_EA:
		size = sizeof(spill_anode);
		break;

	default:
		fatal(es("unknown anode type: "); es(tok_name(ap -&gt; n_type)));
	}

	/* Create a new node and copy the old node to it.. */
	TRACEPN(ftag, eanode(ap); ecnl());
	new_anode_macro(new_ap, size, 0);
	memcpy(new_ap, ap, size);

	STATX(ftag);
	return new_ap;
}
</t>
<t tx="ekr.20080529093004.884">@ Return the effective machine length of an enode.  This is not the same as the length of the corresponding c-language object because arrays and structures stand for concealed pointer values in the contexts where this is used.
@c

int
c_e2mlen(enode *p)
{
	GEN_ASSERT(p &amp;&amp; p -&gt; e_ctype);
	return c_t2mlen(p -&gt; e_ctype);
}
</t>
<t tx="ekr.20080529093004.885">@ Generate a possibly quick move. It is tempting to have this routine call free_temp(ap1), but there are situations where that would not work.
@c

void
c_move(register anode *ap1, register anode *ap2)
{
	SL_DISABLE();
	c_move_len(ap1, ap2, ap1 -&gt; a_length);
}
</t>
<t tx="ekr.20080529093004.886">@ Move the source to the destination. Free the temporary operands but not the argument operands.
@c

void
c_move_big(
	anode * src_ap, bool src_address_flag,
	anode * dst_ap, bool dst_address_flag,
	ulong size)
{
	FTAG("c_move_big");
	
		anode * temp_src_ap = NULL;
		anode * temp_dst_ap = NULL;
	
	STATB(ftag);
	
	if (size == 1 || size == 2 || size == 4) {
		c_move_len(src_ap, dst_ap, size);
		goto done;
	}
	
	/* Generate the address of the souce operand. */
	if (src_address_flag) {
		if (a_is_areg(src_ap) || a_is_dreg(src_ap)) {
			temp_src_ap = get_atemp(REGISTER_SIZE);
			c_move_len(src_ap, temp_src_ap, REGISTER_SIZE);
		}
		else {
			temp_src_ap = c_lea_temp(src_ap);
		}
		temp_src_ap -&gt; n_type = POST_INC_EA;
	}
	else {
		temp_src_ap = get_atemp(REGISTER_SIZE);
		c_move_len(src_ap, temp_src_ap, REGISTER_SIZE);
		temp_src_ap -&gt; n_type = POST_INC_EA;
	}
	GEN_ASSERT(temp_src_ap &amp;&amp; a_is_temp(temp_src_ap) &amp;&amp; a_has_areg(temp_src_ap));
	
	/* Generate the address of the destination operand. */
	if (dst_address_flag) {
		if (a_is_areg(dst_ap) || a_is_dreg(dst_ap)) {
			temp_dst_ap = get_atemp(REGISTER_SIZE);
			c_move_len(dst_ap, temp_dst_ap, REGISTER_SIZE);
		}
		else {
			temp_dst_ap = c_lea_temp(dst_ap);
		}
		temp_dst_ap -&gt; n_type = POST_INC_EA;
	}
	else {
		temp_dst_ap = get_atemp(REGISTER_SIZE);
		c_move_len(dst_ap, temp_dst_ap, REGISTER_SIZE);
		temp_dst_ap -&gt; n_type = POST_INC_EA;
	}
	GEN_ASSERT(temp_dst_ap &amp;&amp; a_is_temp(temp_dst_ap) &amp;&amp; a_has_areg(temp_dst_ap));
	
	if (size &lt;= 28) {

		/*
			Generate
				move.l	(SrcAn)+,(DstAn)+
				...
				move.w	(SrcAn)+,(DstAn)+	(if needed)
		*/
		while (size &gt;= 4) {
			c_move_len(temp_src_ap, temp_dst_ap, 4);
			size -= 4;
		}
		if (size &gt; 0) {
			GEN_ASSERT(size == 2);
			c_move_len(temp_src_ap, temp_dst_ap, size);
		}
	}
	else {
	
		/*
			Generate
				move.l	#size/4,Dn
			loop:
				move.l	(SrcAn)+,(DstAn)+
				dbf		d0,loop
				move.w	(SrcAn)+,(DstAn)+		(If needed)
		*/
		anode * size_ap = NULL;
		anode * dn_ap = get_dtemp(REGISTER_SIZE);
		label_cnode * loop_lab = NULL;

		new_const_anode_macro(size_ap, size/4, 4);
		
		c_move_len(size_ap, dn_ap,4);
		new_clabel_macro(loop_lab);
		c_clabel(loop_lab);
		c_move_len(temp_src_ap, temp_dst_ap, 4);
		c_2clab(X_DBF, dn_ap, loop_lab);
		free_temp(dn_ap);

		if (size % 4) {
			GEN_ASSERT((size % 4) == 2);
			c_move_len(src_ap, dst_ap,2);
		}
	}
	
	free_temp(temp_src_ap);
	free_temp(temp_dst_ap);
	
done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.887">@ Generate the best move instruction depending on the operands. Also generate a pointer test is one of the arguments is (An).  Do nothing if the instruction moves the source to itself. This is safe because the code generators never use move-to_self to set flags.  This routine generates MOVE, MOVEA, MOVEQ or CLR, depending on the types of the source and destination arguments. This routine may also generate an LEA if the address of an object is required.  WARNING!! The following code is tricky. Don't "fix" it without careful thought!  6/1/93: c_push and c_push_address call this routine only in special cases.
@c

void
c_move_len(register anode *ap1, register anode *ap2, int length)
{
	FTAG("c_move_len");
	STATB(ftag);

	if (!is_equiv(ap1, ap2)) {

		/* Generate pointer checking code. */
		if (arg_chk_ptr_flag) {
			if (a_is_indirect(ap1)) {
				c_chk_ptr(ap1);
			}
			if (a_is_indirect(ap2)) {
				c_chk_ptr(ap2);
			}
		}

		/* We can generate an LEA only if ap2 is an A-reg. */
		if (a_is_areg(ap2)) {

			/* Don't mess with this code ! */
			if (ap1 -&gt; n_type == ADDRESS_EA ||
				(
					ap1 -&gt; n_type == IMMEDIATE_EA &amp;&amp;
					const_anode_ptr(ap1) -&gt; a_ckind != LONG_CKIND
				)
			) {

				/* The destination of an LEA is an A-reg: all is well. */
				c_2(X_LEA, ap1, ap2);
			}
			else {
				c_2len(X_MOVEA, ap1, ap2, length);
			}
		}
		else if (a_is_constant(ap1)) {

			if (const_anode_ptr(ap1) -&gt; a_long == 0) {
				c_1len(X_CLR, ap2, length);
			}
			else if (
				a_is_dtreg(ap2) &amp;&amp;
				const_anode_ptr(ap1) -&gt; a_long &lt;= 127 &amp;&amp;
				const_anode_ptr(ap1) -&gt; a_long &gt;= -128
			) {
				/*
					Warning: this sets the *whole* register.
					At present, this can cause no problems,
					since registers represent only one quantity.
				*/
				c_2(X_MOVEQ, ap1, ap2);
			}
			else {
				c_2len(X_MOVE, ap1, ap2, length);
			}
		}
		else {

			/*
				Don't mess with this code !
				Strings, floats, doubles and long doubles are represented by pointers.
				Therefore, we move the address of these constants.
			*/
			if (
				ap1 -&gt; n_type == ADDRESS_EA ||
				(
					ap1 -&gt; n_type == IMMEDIATE_EA &amp;&amp;
					const_anode_ptr(ap1) -&gt; a_ckind != LONG_CKIND
				)
			) {

				if (is_equiv(ap2, push_anode)) {
					c_1(X_PEA, ap1);
				}
				else {

					#ifdef GEN_GLOBAL_ADDRESS
						c_2len(X_MOVE, ap1, ap2, length);
					#else

						/*
							The destination of an LEA must be an A-reg.
							Don't call c_lea: we can't free ap1 here.
						*/
						anode * temp_ap = get_atemp(POINTER_SIZE);
						c_2(X_LEA, ap1, temp_ap);
						c_2len(X_MOVE, temp_ap, ap2, POINTER_SIZE);
						free_temp(temp_ap);
					#endif
				}
			}
			else {
				c_2len(X_MOVE, ap1, ap2, length);
			}
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.888">@ Generate code to move ap to an A-reg temp if needed. If the move is made, the old ap is freed.
@c

anode *
c_move2atreg (anode * ap)
{
	FTAG("c_move2atreg");
	register anode * new_ap = NULL;
	STATB(ftag);

	if (a_is_atreg(ap)) {
		new_ap = ap;
	}
	else {
		new_ap = get_atemp(ap -&gt; a_length);
		c_move(ap, new_ap);
		free_temp(ap);
	}

	TRACEPX(ftag, eret(); eanode(anode_ptr(new_ap)); ecnl());
	return new_ap;
}
</t>
<t tx="ekr.20080529093004.889">@ Generate code to move ap to an D-reg temp if needed. If the move is made, the old ap is freed.
@c

anode *
c_move2dtreg(anode * ap)
{
	FTAG("c_move2dtreg");
	register anode * new_ap = NULL;
	STATB(ftag);

	if (a_is_dtreg(ap)) {
		new_ap = ap;
	}
	else {
		new_ap = get_dtemp(ap -&gt; a_length);
		c_move(ap, new_ap);
		free_temp(ap);
	}

	TRACEPX(ftag, eret(); eanode(anode_ptr(new_ap)); ecnl());
	return new_ap;
}
</t>
<t tx="ekr.20080529093004.890">@ Push one argument on the stack. The argument is the function's only argument if one_arg_flag is TRUE  Return the number of bytes pushed on the stack, which is zero if one_arg_flag is TRUE.  Note: the 68000 treats byte pushes as a special cases, incrementing the stack pointer by 2 instead of 1.  6/1/93: On the Mac, *always* generate  PEA ap  even if there is only one argument. This "looks" better than generating  LEA ap, An ;Note: LEA ap,(sp) does not exist!  MOVE An,(sp)  In reality, these two sequences take about the same time since the stack must be adjusted following the JSR if PEA is used. The only real advantage of using PEA is that the An scratch register is not used.  On machines with true global addresses, generate  MOVE #ap,(sp)  if possible.
@c

ulong
c_push(anode * ap, bool one_arg_flag)
{
	FTAG("c_push");
	ulong push_length = 0;
	ulong alength = 0;
	STATB(ftag);

	GEN_ASSERT(ap);
	alength = ap -&gt; a_length;

	if (ap -&gt; n_type == ADDRESS_EA) {

		#ifdef GEN_GLOBAL_ADDRESS

			/* This allows the call_1arg optimization:	MOVE #xx,(sp)  */
			c_2(X_MOVE,
				ap1,
				(one_arg_flag &amp;&amp; gen_call_1arg &gt; 0) ? no_push_anode : push_anode,
				alength);
			push_length = (one_arg_flag &amp;&amp; gen_call_1arg &gt; 0) ? 0 : POINTER_SIZE;

		#else

			c_1(X_PEA, ap);
			push_length = POINTER_SIZE;

		#endif

	}
	else if (
		ap -&gt; n_type == IMMEDIATE_EA &amp;&amp;
		const_anode_ptr(ap) -&gt; a_ckind != LONG_CKIND
	) {

		/*
			This is work no matter how big constants are represented.
			Don't change it unless you *really* need better code here.
		*/
		c_1(X_PEA, ap);
		push_length = POINTER_SIZE;
	}
	else {
	
		/*
			11/15/94: Make *sure* that we never try to push a byte!
			ct_check_args checks for a bad size,
			but the call_1arg optimization sometimes defeats that check.
		*/
		GEN_ASSERT(alength &gt; 1);

		/* Generate MOVE ap,-(a7) -- or -- MOVE ap,(a7) */
		c_move_len(
			ap,
			(one_arg_flag &amp;&amp; gen_call_1arg &gt; 0) ? no_push_anode : push_anode,
			alength);

		push_length = (one_arg_flag &amp;&amp; gen_call_1arg &gt; 0) ? 0 : alength;
	}

	STATX(ftag);
	return push_length;
}
</t>
<t tx="ekr.20080529093004.891">@ Generate code to push the address of ap.  This routine generates LEA or PEA instructions. PEA is used if the anode represents an address.  6/1/93: The one_arg_flag is used only for (An) address mode, generating  MOVE An, (sp)  Usually, we will generate a PEA, even though the stack will be adjusted later. See the similar comment in c_push.
@c

ulong
c_push_address(register anode * ap, bool one_arg_flag)
{
	FTAG("c_push_address");
	ulong length = 0;
	STATB(ftag);

	/*
		Convert the address mode to one representing an address.
		WARNING: g_prim must make sure that this can always be done.
	*/
	switch(ap -&gt; n_type) {
	
	case AREG_EA:		/* 6/30/94 */
	
		TRACEPN(ftag, es("address already in A-reg\n"));

	case DREG_EA:
		/*
			Bug fix 5/31/94:
			Function calls can return the address of a struct/union in a D-reg.
			Simply push the dreg.
		*/
		ASSERT(ap -&gt; a_length == POINTER_SIZE);
		length = c_push(ap, one_arg_flag);
		goto done;

	case ABSOLUTE_EA:
	case DISPLACEMENT_EA:
	case INDEX_EA:
	{
		/*
			ABSOLUTE_EA is used by g_prim for all static symbols.

			DISPLACEMENT_EA is used by g_prim for all stack variables and temps,
			except where the displacement would exceed 16 bits,
			in which case g_prim uses INDEX_EA.

			Real code must be generated here since the address of
			stack variables and temps can not be known until run-time.

			6/1/93: *always* generate

				PEA ap

			even if

				MOVE #ap,-(sp)

			is valid in a particular environment. (It is invalid on the Mac.)
		*/
		c_1(X_PEA, ap);
		length = POINTER_SIZE;
		goto done;
	}

	case INDIRECT_EA:

		/* INDIRECT_EA is used by g_prim for complex structs/unions/arrays. */
		ap = c_copy(ap);
		ap -&gt; n_type = AREG_EA;
		length = c_push(ap, one_arg_flag);
		goto done;

	case IMMEDIATE_EA:

		/*
			Only certain constants are may have their address computed.
			The address of blocks is used when calling memmove.
		*/

			if (
				const_anode_ptr(ap) -&gt; a_ckind == STRING_CKIND ||
				const_anode_ptr(ap) -&gt; a_ckind == BLOCK_CKIND
			) {

				/* 6/1/93: We must convert addresses using LEA in *all* worlds. */
				c_1(X_PEA, ap);
				length = POINTER_SIZE;
				goto done;
			}

		/* Fall through. */

	default:
		fatal(
			es(ftag); es(" bad address mode ");
			es(tok_name(ap -&gt; n_type)));
	}

done:
	STATX(ftag);
	return length;
}
</t>
<t tx="ekr.20080529093004.892">@ Push a large argument of the indicated size and free ap. Return the number of actual bytes pushed.  Be careful here. Make sure that the object on the stack has the same layout as the object in memory. We do this by pushing bytes from *high* addresses to low addresses.
@c

ulong
c_push_big(anode *ap, bool one_arg_flag, ulong size)
{
	FTAG("c_push_big");
		ulong stack_size;
	STATB(ftag);
	
	if (size &amp; 1) {
		size++;
	}
	stack_size = size;
	
	if (size &lt;= REGISTER_SIZE) {
		stack_size = c_push(ap, one_arg_flag);
		free_temp(ap);
		goto done;
	}
	
	/*
		Generate
		
		lea		ap, an
		adda.l	#size,an
	*/
	{
		if (a_is_areg(ap) || a_is_dreg(ap)) {
			anode * ap1 = get_atemp(REGISTER_SIZE);
			c_move_len(ap, ap1, REGISTER_SIZE);
			free_temp(ap);
			ap = ap1;
		}
		else {
			ap = c_lea(ap);
		}
		
		GEN_ASSERT(ap &amp;&amp; a_is_atreg(ap));
		
		{
			const_anode * cap = NULL;
			new_const_anode_macro(cap, size, 4);
			c_2len(X_ADDA, anode_ptr(cap), ap, 4);
		}
	}
	
	if (size &lt;= 28) {
	
		/*
			Generate
				move.l	-(an),-(sp)
				...
				move.w	-(an),-(sp)		(if needed)
		*/
		ap -&gt; n_type = PRE_DEC_EA;

		while (size &gt;= 4) {
			c_move_len(ap, push_anode, 4);
			size -= 4;
		}
		if (size &gt; 0) {
			GEN_ASSERT(size == 2);
			c_move_len(ap, push_anode, 2);
		}
	}
	else {
	
		/*
			Generate
				move.l	Dn,size/4
				lea		ap,An
			loop:
				move.l	-(An),-(sp)
				dbf		d0,loop
				move.w	-(An),-(sp)		(If needed)
		*/
		
		anode * one_ap = NULL;
		anode * size_ap = NULL;
		anode * dn_ap = get_dtemp(REGISTER_SIZE);
		label_cnode * loop_lab = NULL;
		
		ap -&gt; n_type = PRE_DEC_EA;

		new_const_anode_macro(size_ap, size/4, 4);
		new_const_anode_macro(one_ap, 1, 4);
		
		c_move_len(size_ap, dn_ap,4);
		new_clabel_macro(loop_lab);
		c_clabel(loop_lab);
		c_move_len(ap, push_anode, 4);
		c_2clab(X_BNE, dn_ap, loop_lab);
		
		if (size % 4) {
			GEN_ASSERT((size % 4) == 2);
			c_move_len(ap, push_anode,2);
		}
	}
	free_temp(ap);

done:
	STATX(ftag);
	return stack_size;
}
</t>
<t tx="ekr.20080529093004.893">@ Push one floating argument represented by ep and ap. Do *not* free ap. one_arg_flag: TRUE if this is the argument's only function.  WARNING: The current code assumes that *all* subexpressions of the parse tree actually generate code, so that all subexpressions are represented by a temporary containing the *address* of a floating temporary. The PERM_GEN_ASSERT_TRACE below will fail if this is not true.  This is an unpleasant assumption because it constrains the entire parse tree. For instance, I had to eliminate do-nothing floating casts in ct_cvt_r2l.  It would be more consistent and safer to ignore the ep paramter, using the ap parameter to choose between c_push_address or c_push.  Perhaps a mixed approach would be best: using ep to find formals and using ap to handle other cases.
@c

ulong
c_push_float(anode *ap, bool one_arg_flag, enode * ep)
{
	FTAG("c_push_float");
	ulong stack_size = 0;
	STATB(ftag);
	GEN_ASSERT(ep &amp;&amp; ep -&gt; e_ctype);
	
	{
		ulong size = ep -&gt; e_ctype -&gt; tsize;
		GEN_ASSERT(size &gt; 0 &amp;&amp; (size &amp; 1) == 0);

		stack_size = c_push_big(ap, one_arg_flag, size);
	}

	STATX(ftag);
	return stack_size;
}
</t>
<t tx="ekr.20080529093004.894">@ Append a single code node to the end of the global code list.  Before this is done, all arguments are "frozen" by making a copy of them. Freezing the arguments here insures that generated code can not possibly change as the result of changing an arg_node later. Such changes can occur when a node is spilled.
@c

void
c_put(cnode * cp)
{
	FTAG("c_put");

	/* Not tracing this routine makes for clearer traces. */
	GEN_ASSERT(cp);

	/*
		Freeze both arguments of cinodes.
	*/
	if (is_xtok(cp -&gt; n_type)) {

		register cinode * cip = cinode_ptr(cp);

		/* Bug fix: 6/29/93: the c_arg fields can be an O_LABEL, etc.! */
		if (cip -&gt; c_arg1 &amp;&amp; c_arg_will_freeze(cip -&gt; c_arg1)) {
			cip -&gt; c_arg1 = c_copy(cip -&gt; c_arg1);
		}
		if (cip -&gt; c_arg2 &amp;&amp; c_arg_will_freeze(cip -&gt; c_arg2)) {
			cip -&gt; c_arg2 = c_copy(cip -&gt; c_arg2);
		}
	}

	/*
		Append the "frozen" node to the code list.
		The code list has at least one node because a dummy
		node is added to the list by gen_init.
	*/
	GEN_ASSERT(code_tail);
	cp -&gt; c_back = code_tail;
	code_tail -&gt; n_next = cp;
	code_tail = cp;

	if (arg_gen_trace_flag) {
		SL_NOT(ftag, es("\t\t"));
		TRACEN(ftag,
			ecnl();
			es(current_ftag); es(": ");
			es(caller_ftag); es(": ");
			es(caller2_ftag); es(": ");
			es(caller3_ftag); es(": ");
			ecblanks(50);
		);
		ecnode(cp); ecnl();
	}
}
</t>
<t tx="ekr.20080529093004.895">@ Return the effective machine length of an snode or tnode.  This is not the same as the length of the corresponding c-language object because arrays and structures stand for concealed pointer values in the contexts where this is used.
@c

int
c_s2mlen(snode *s_p)
{
	GEN_ASSERT(s_p &amp;&amp; s_p -&gt; ctype);
	return c_t2mlen(s_p -&gt; ctype);
}
</t>
<t tx="ekr.20080529093004.896">int
c_t2mlen(tnode *t)
{
	FTAG("c_t2mlen");
	register int result = 0;
	STATB(ftag);

	switch (t -&gt; tprim) {

	case FLOAT_TYPE:

		/* All floating types are represented by pointers. */
		result = POINTER_SIZE;
		break;

	case INT_TYPE:
		result = t -&gt; tsize;
		break;

	case POINTER_TYPE:
	case ARRAY_TYPE:
	case STRUCT_TYPE:
	case UNION_TYPE:	/* Bug fix: 3/8/93 */
	case FUNCTION_TYPE:	/* 3/6/93: a function's "size" is the size of a pointer to it. */
		result = POINTER_SIZE;
		break;

	case VOID_TYPE:
		result = 0;
		break;

	default:
		fatal(
			es(ftag); es(" bad type "); eint(t -&gt; tprim);
			es(" = "); es(tok_name(t -&gt; tprim)));
	}

	TRACEPX(ftag, etnode(t); eblank(); eret(); eint(result); enl());
	return result;
}
</t>
<t tx="ekr.20080529093004.897">@ Link a compiler label node into the code list.
@c

void
c_ulabel(ulabel_cnode *lp)
{
	FTAG("c_ulabel");
	STATB(ftag);

	/* Append to code list. */
	c_put(cnode_ptr(lp));

	TRACEPX(ftag, ecnode(cnode_ptr(lp)); ecnl());
}
</t>
<t tx="ekr.20080529093004.898">/*
	CC2: Register allocation code -- version 2.

	source:  CCregs.c
	started: August 4, 1986 (reg.c); December 11, 1992 (reg2.c)
	version:
		August 24, 1994.
			Bug fix to reg_spill_all.
		July 19, 1993.
			Replaced ASSERT and ASSERT_TRACE by GEN_ASSERT and GEN_ASSERT_TRACE.
		May 5, 1993.
			Printed copy sent to Tuple.
		April 20, 1993.
			Added and initialized no_push_anode.
		March 17, 1993.
			Added bp parameter to get_reg.
		March 7, 1993.
			Added reg_init_check.
		March 6, 1993
			Improved tracing in get_reg.
			Bug fix in free_temp: temp regs involving A6 have been spilled,
			so should not be freed.
		February 11, 1993.
			Define reg_node's in CCnodes.h so they can be part of block nodes.
		February 10, 1993.
			Changed ASSERT to PERM_ASSERT_TRACE in free_temp.
			Completed spill_reg in cases where INDEX_EA is used.
			Removed get_f_temp. (Use get_atemp).
		February 6, 1993.
			Fixed bug in get_dcl_reg.
			(reg_na_user was updated both in get_dcl_reg and get_reg.)
		February 2, 1993.
			Made is_equiv more accurate.
		December 29, 1992.
			New formal_list.
		December 28, 1992.
			Bug fixes to get_atemp, get_dtemp.
			New temp_flag to get_reg.
*/

&lt;&lt; CCregs #includes &gt;&gt;
&lt;&lt; CCregs declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.899">#include "CC.h"

#include "CCdump.h"
#include "CCgen.h"
#include "CCnodes.h"
#include "CCmem.h"
#include "CCregs.h"
#include "CCtarget.h"

#include &lt;LIBlist.h&gt;

#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.900">/*
	The code generators are simplified greatly by the convention that
	the c_put routine *freezes* all spill_anodes by making copies of them.

	Thus, the code generators and the peephole can change a frozen anode
	without worrying about unintended side effects.

	Freezing anodes eliminates the copying of anodes that complicated
	the C* code generators.
*/

/*
	Define abbreviation macros.
*/
#define sap  spill_anode_ptr(ap)
#define sap1 spill_anode_ptr(ap1)
#define sap2 spill_anode_ptr(ap2)

/*
	Define global data structures...
	They may be read but not be changed by routines outside this file.
*/

	/*
		The permanent list of available reg_list_nodes.
		This list is used by new_reg_node_macro.
	*/

reg_node * reg_node_avail_list = NULL;	/* Available reg_list_nodes. */


	/*
		These arrays describe the current state of each register.

		WARNING: The code in this file tacitly assumes that
		o R_A0 is the first register defined in the token definition table.
		o R_D7 is the last  register defined in the token definition table.
		o the token index of R_DO is a small number, say 0 or 1.

		6/8/94: It would be better to make the following changes:
		o Use R_FIRST_REG to indicate the first register in a for loop.
		o Use R_LAST_REG  to indicate the last  register in a for loop.
		o Use reg_index macro, defined in CCregs.h, to access the following arrays.

		At present, this has not been done.
	*/
sbool reg_free_array [R_LAST_REG-R_FIRST_REG+1];	/* TRUE: the register is free. */
sbool reg_used_array [R_LAST_REG-R_FIRST_REG+1];	/* TRUE: the register has been used. */
sbool reg_push_array [R_LAST_REG-R_FIRST_REG+1];	/* TRUE: the register must be pushed on entry. */

	/* Counts of free registers. */

int reg_na_free = A_SCRATCH_TOTAL+A_USER_TOTAL;	/* Number of free A-regs. */
int reg_nd_free = D_SCRATCH_TOTAL+D_USER_TOTAL;	/* Number of free D-regs. */

int reg_na_user = 0;	/* Number of user A-regs. */
int reg_nd_user = 0;	/* Number of user D-regs. */

	/*
		These variables indicate whether a0 may be used for a function return.
		They are set by gen_function and used by the code generators.
	*/

bool reg_ret_a = TRUE;	/* TRUE if a0 is used for function return. */
bool reg_ret_d = TRUE;	/* TRUE if d0 is used for function return. */

	/*
		These anodes represent particular locations and are to be used *only*
		as arguments to routines in cput.c which guarantee not to change them.
		They are initialized in reg_perm_init.

		They must *never* be used as a return value of a function
		because the routines in this file would not know they were
		in use and so might reallocate them.
	*/

anode * a0_anode;	/* Functions returning pointers use A0. */
anode * a6_anode;	/* anode representing a6. */
anode * a7_anode;	/* anode representing a7. */
anode * d0_anode;	/* Functions returning integers use D0. */
anode * d7_anode;	/* Reserved to spill nodes to huge stack frames. */

anode * no_push_anode;	/* anode representing (a7) */
anode * pop_anode;		/* anode representing (a7)+ */
anode * push_anode;		/* anode representing -(a7) */
anode * hidden_anode;	/* anode representing 8(a6) */

/*
	Define variables local to this file.
*/

	/*
		Allocated temporaries are added to the front of temp_list.
		Registers are spilled from the *back* of the temp_list.
		This ensures that a second call to get_atemp or get_dtemp does not
		spill the register allocated in an immediately preceding call.

		Allocated formal register variables are added to the front of formal_list.
		Allocated block register variables are added to the front of the block's list.
	*/

static reg_node * temp_list = NULL;	/* Head of temp reg list. */
static reg_node * temp_tail = NULL;	/* Tail of temp reg list. */
static reg_node * formal_list = NULL;	/* Head of formal reg list.

	/*
		free_ptr points to the temp_list item for any temporary reg.
		GEN_ASSERT(ap == free_ptr[sap -&gt; a_sreg] -&gt; the_node);
	*/

static reg_node * free_ptr [BAD_LAST_REG];	/* Pointer into temp list. */

/*
	Function prototypes of internal routines.
*/
static void		free_treg	(int the_reg);
static void		spill_reg	(int the_reg);
</t>
<t tx="ekr.20080529093004.901">@ Free an anode if it represents a temporary register. Otherwise, do nothing.  Warning: it is a bug to free the same temporary twice. Doing so will cause the PERM_GEN_ASSERT_TRACE below to fail.
@c

void
free_temp (anode * ap)
{
	FTAG("free_temp");
	TRACEPB(ftag,
		eanode(ap); es(", callers: ");
		es(caller_ftag); es(": ");
		es(caller2_ftag); es(": ");
		es(caller3_ftag);
		ecnl());

	if (a_is_temp(ap)) {

		/* Free the main register. */
		if ((a_has_areg(ap) &amp;&amp; sap -&gt; a_sreg != R_A6) || a_is_dreg(ap)) {

			/* This check is too important ever to disable. */
			PERM_GEN_ASSERT_TRACE(ap == free_ptr[sap -&gt; a_sreg] -&gt; the_anode,
				es("improper c_copy or temp reg freed twice\n");
				es("ap: ");
					eanode(ap); es(" at "); eptr(ap);
					ecnl();
				es("free_ptr[sap -&gt; a_sreg] -&gt; the_anode: ");
					eanode(free_ptr[sap -&gt; a_sreg] -&gt; the_anode);
					es(" at "); eptr(free_ptr[sap -&gt; a_sreg] -&gt; the_anode);
					ecnl();
				es(caller_ftag); es(": ");
				es(caller2_ftag); es(": ");
				es(caller3_ftag); es(": ");
			);
			free_treg(sap -&gt; a_sreg);
		}

		/*
			The index register D7 is never freed because it is never allocated.
			Warning:
				if more than one register is allocated to an anode this
				code will have to change and so will get_reg.
		*/
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.902">@ Free a register known to be a temporary register.
@c

static void
free_treg(int the_reg)
{
	FTAG("free_treg");
	reg_node * rp = NULL;
	STATB(ftag);

	rp = free_ptr[the_reg];
	GEN_ASSERT(rp);

	/* Mark the register as free. */
	reg_free_array [reg_index(the_reg)] = TRUE;

	if (is_areg(the_reg)) {
		reg_na_free++;
		GEN_ASSERT(reg_na_free &lt;= A_TEMP_TOTAL);
	}
	else {
		reg_nd_free++;
		GEN_ASSERT(reg_nd_free &lt;= D_TEMP_TOTAL);
	}

	/* Reset the tail pointer. */
	if (rp == temp_tail) {
		temp_tail = temp_tail -&gt; back2;
	}

	/* Remove the reg_node from the temp list and add it to the avail list. */
	free_ptr[the_reg] = NULL;
	rp -&gt; the_anode = NULL;

	lst2_remove_macro(rp, temp_list);
	lst2_add_macro(rp, reg_node_avail_list);

	TRACEPX(ftag, es("frees "); es(tok_name(the_reg)); enl());
}
</t>
<t tx="ekr.20080529093004.903">@ Return an anode representing register a0. Spill a0 if it is in use.
@c

anode *
get_a0 (int length)
{
	FTAG("get_a0");
	anode * ap = NULL;
	STATB(ftag);

	if (!reg_is_free(R_A0)) {
		spill_reg(R_A0);
	}
	ap = get_reg(R_A0, length, TRUE, NULL);

	STATX(ftag);
	return ap;
}
</t>
<t tx="ekr.20080529093004.904">@ Return an anode representing a temporary A register. Spill a temporary A register if all are in use.
@c

anode *
get_atemp(int length)
{
	FTAG("get_atemp");
	register reg_node * rp = NULL;
	register anode * ap = NULL;
	register int the_reg = 0;
	STATB(ftag);

	if (reg_na_free == 0) {

		/* Search from the *back* of the temp list for an A-reg to spill. */
		for (rp = temp_tail; rp; rp = rp -&gt; back2) {
			the_reg = spill_anode_ptr(rp -&gt; the_anode) -&gt; a_sreg;
			if (is_areg(the_reg)) {
				GEN_ASSERT(free_ptr[the_reg] == rp &amp;&amp; a_is_temp(rp -&gt; the_anode));
				break;
			}
		}
		GEN_ASSERT(rp);

		/* Spill the register. */
		spill_reg(the_reg);
	}
	else {

		/*
			Search for a free A-reg.
			Return A0 (i.e., A_FIRST_TEMP) only if all others are used.
		*/
		for (
			the_reg = A_SECOND_TEMP;
			the_reg &lt;= A_LAST_TEMP &amp;&amp; !reg_is_free(the_reg);
			the_reg++
		) {
			;
		}
		if (the_reg &gt; A_LAST_TEMP) {
			GEN_ASSERT(reg_is_free(R_A0));
			the_reg = R_A0;
		}
	}

	ap = get_reg(the_reg, length, TRUE, NULL);

	STATX(ftag);
	return ap;
}
</t>
<t tx="ekr.20080529093004.905">@ Return an anode representing register d0. Spill d0 if it is in use.
@c

anode *
get_d0 (int length)
{
	FTAG("get_d0");
	anode * ap = NULL;
	STATB(ftag);

	if (!reg_is_free(R_D0)) {
		spill_reg(R_D0);
	}
	ap = get_reg(R_D0, length, TRUE, NULL);

	STATX(ftag);
	return ap;
}
</t>
<t tx="ekr.20080529093004.906">@ Return an anode representing a user variable, or NULL if none is available.
@c

anode *
get_dcl_reg	(snode * s_p, block_node * bp)
{
	FTAG("get_dcl_reg");
	anode * ap = NULL;
	register int the_reg;

	if (s_p -&gt; ctype == NULL) {
		return NULL;
	}

	STATB(ftag);

	if (s_p -&gt; ctype -&gt; tprim == INT_TYPE) {

		/* Search for a free user D-reg. */
		for (
			the_reg = D_FIRST_USER;
			the_reg &lt;= D_LAST_USER &amp;&amp; !reg_is_free(the_reg);
			the_reg++
		) {
			;
		}
		ap = (the_reg &gt; D_LAST_USER) ? NULL : get_reg(the_reg, c_s2mlen(s_p), FALSE, bp);

	}
	else {

		/* Search for a free user A-reg. */
		for (
			the_reg = A_FIRST_USER;
			the_reg &lt;= A_LAST_USER &amp;&amp; !reg_is_free(the_reg);
			the_reg++
		) {
			;
		}
		ap = (the_reg &gt; A_LAST_USER) ? NULL : get_reg(the_reg, c_s2mlen(s_p), FALSE, bp);
	}

	if (s_p -&gt; spell) {
		spill_anode_ptr(ap) -&gt; a_sname = s_p -&gt; spell -&gt; spell_name;
	}

	STATX(ftag);
	return ap;
}
</t>
<t tx="ekr.20080529093004.907">@ Return an anode representing a temporary D register. Spill a temporary D register if all are in use.
@c

anode *
get_dtemp (int length)
{
	FTAG("get_dtemp");
	register reg_node * rp = NULL;
	register anode * ap = NULL;
	register int the_reg = 0;
	STATB(ftag);

	if (reg_nd_free == 0) {

		/* Search from the *back* of the temp list for an D-reg to spill. */
		for (rp = temp_tail; rp; rp = rp -&gt; back2) {

			the_reg = spill_anode_ptr(rp -&gt; the_anode) -&gt; a_sreg;
			if (is_dreg(the_reg)) {
				GEN_ASSERT(free_ptr[the_reg] == rp &amp;&amp; a_is_temp(rp -&gt; the_anode));
				break;
			}
			TRACEPN(ftag, es("rejected: "); eanode(rp -&gt; the_anode); ecnl());
		}
		GEN_ASSERT(rp);

		/* Spill the register. */
		spill_reg(the_reg);
	}
	else {

		/*
			Search for a free D-reg.
			Return D0 (i.e., D_FIRST_TEMP) only if all others are used.
		*/
		for (
			the_reg = D_SECOND_TEMP;
			the_reg &lt;= D_LAST_TEMP &amp;&amp; !reg_is_free(the_reg);
			the_reg++
		) {
			;
		}
		if (the_reg &gt; D_LAST_TEMP) {
			GEN_ASSERT(reg_is_free(R_D0));
			the_reg = R_D0;
		}
	}

	ap = get_reg(the_reg, length, TRUE, NULL);

	STATX(ftag);
	return ap;
}
</t>
<t tx="ekr.20080529093004.908">@ Return an anode corresponding to the indicated register. Make the register a temporary if temp_flag is TRUE.  If temp_flag is false, the register is a user variable. A user variable is a formal register variable if bp is NULL.
@c

anode *
get_reg (int the_reg, int length, bool temp_flag, block_node * bp)
{
	FTAG("get_reg");
	anode * ap = NULL;
	reg_node * rp = NULL;
	STATB(ftag);

	GEN_ASSERT(length &lt;= REGISTER_SIZE);
	GEN_ASSERT(is_xreg(the_reg));
	GEN_ASSERT(reg_is_free(the_reg));

	/* Mark the register as not free and used. */
	reg_free_array [reg_index(the_reg)] = FALSE;
	reg_used_array [reg_index(the_reg)] = TRUE;

	/* Allocate a new anode. */
	new_anode_macro(ap, sizeof(spill_anode), is_areg(the_reg) ? AREG_EA : DREG_EA);
	sap -&gt; a_length = length;
	sap -&gt; a_sreg = the_reg;
	if (temp_flag) {
		a_set_temp(ap);
	}

	/* Get a reg_node describing ap. */
	new_reg_node_macro(rp, ap);
	free_ptr [the_reg] = rp;

	/* Add rp to the start of the appropriate list. */
	if (temp_flag) {

		/* A temporary register variable. */
		lst2_add_macro(rp, temp_list);
		if (rp -&gt; next2 == NULL) {
			temp_tail = rp;
		}

		TRACEPN(ftag,
			reg_node * rlp = temp_list;
			es("allocates temp: "); eanode(ap);
			es(" at: "); eptr(ap);
			es(", temp list: ");
			while(rlp) {
				eanode(rlp -&gt; the_anode); eblank();
				rlp = rlp -&gt; next2;
			}
			ecnl();
			es("callers: ");
			es(caller_ftag); es(": ");
			es(caller2_ftag); es(": ");
			es(caller3_ftag);
			ecnl();
		);
	}
	else if (bp) {

		/* A user register variable allocated in a block. */
		lst2_add_macro(rp, bp -&gt; block_regs);

		TRACEPN(ftag,
			reg_node * rlp = bp -&gt; block_regs;
			es("allocates block register: "); eanode(ap);
			es(", block list: ");
			while(rlp) {
				eanode(rlp -&gt; the_anode); eblank();
				rlp = rlp -&gt; next2;
			}
			ecnl();
		);
	}
	else {

		/* A formal register variable. */
		lst2_add_macro(rp, formal_list);

		TRACEPN(ftag,
			reg_node * rlp = formal_list;
			es("allocates formal register: "); eanode(ap);
			es(", formal list: ");
			while(rlp) {
				eanode(rlp -&gt; the_anode); eblank();
				rlp = rlp -&gt; next2;
			}
			ecnl();
		);
	}

	/* Update the counts. */
	if (is_areg(the_reg)) {
		reg_na_free--;
		if (!temp_flag) {
			reg_na_user++;
		}
		GEN_ASSERT(reg_na_free &gt;= 0);
		spill_anode_ptr(ap) -&gt; a_sname = "An";

	}
	else {
		reg_nd_free--;
		if (!temp_flag) {
			reg_nd_user++;
		}
		GEN_ASSERT(reg_nd_free &gt;= 0);
		spill_anode_ptr(ap) -&gt; a_sname = "Dn";
	}

	STATX(ftag);

	return ap;
}
</t>
<t tx="ekr.20080529093004.909">@ Get a temp, either A or D doesn't matter. Spill a D register if all temporaries are in use.
@c

anode *
get_temp (int length)
{
	FTAG("get_temp");
	register reg_node * rp = NULL;
	register anode * ap = NULL;
	STATB(ftag);

	if (reg_nd_free &gt; 0) {
		ap = get_dtemp(length);
	}
	else if (reg_na_free &gt; 0) {
		ap = get_atemp(length);
	}
	else {

		int the_reg = 0;

		/* Search from the *back* of the temp list for a D-reg to spill. */
		for (rp = temp_tail; rp; rp = rp -&gt; back2) {
			the_reg = spill_anode_ptr(rp -&gt; the_anode) -&gt; a_sreg;
			if (is_dreg(the_reg)) {
				break;
			}
		}
		GEN_ASSERT(rp);

		/* Spill the register. */
		spill_reg(the_reg);

		/* And return it. */
		ap = get_reg(the_reg, length, TRUE, NULL);
	}

	STATX(ftag);
	return ap;
}
</t>
<t tx="ekr.20080529093004.910">@ Return TRUE if ap1 is essentially equal to ap2 so that either can be used in place of the other.
@c

bool
is_equiv(register anode *ap1, register anode *ap2)
{
	FTAG("is_equiv");
	bool result = FALSE;
	STATB(ftag);

	if (ap1 -&gt; n_type != ap2 -&gt; n_type) {
		result = FALSE;
		goto done;
	}

	switch(ap1 -&gt; n_type) {

	case AREG_EA:
	case DREG_EA:
	case INDIRECT_EA:
	case POST_INC_EA:
	case PRE_DEC_EA:

		result = sap1 -&gt; a_sreg == sap2 -&gt; a_sreg;
		goto done;

	case DISPLACEMENT_EA:

		result =
			sap1 -&gt; a_sreg  == sap2 -&gt; a_sreg  &amp;&amp;
			sap1 -&gt; a_slong == sap2 -&gt; a_slong;
		goto done;

	case INDEX_EA:

		result =
			sap1 -&gt; a_sreg  == sap2 -&gt; a_sreg  &amp;&amp;
			sap1 -&gt; a_sxreg == sap2 -&gt; a_sxreg &amp;&amp;
			sap1 -&gt; a_slong == sap2 -&gt; a_slong;
		goto done;

	case ABSOLUTE_EA:
	case ADDRESS_EA:

		result =
			var_anode_ptr(ap1) -&gt; a_vkind == var_anode_ptr(ap2) -&gt; a_vkind &amp;&amp;
			var_anode_ptr(ap1) -&gt; a_vname == var_anode_ptr(ap2) -&gt; a_vname;
		goto done;

	default:

		/* Other cases are "don't cares." */
		result = FALSE;
		goto done;
	}

done:
	TRACEPX(ftag,
		eanode(ap1); ecs(); eanode(ap2);
		eblank(); eret(); ebool(result); enl());
	return result;
}
</t>
<t tx="ekr.20080529093004.911">@ Free all *temporary* registers. This routine is called before generating an outer expression. User registers must be freed when exiting from a block.
@c

void
reg_free_all (void)
{
	FTAG("reg_free_all");
	register int the_reg = 0;
	STATB(ftag);

	for (the_reg = A_FIRST_TEMP; the_reg &lt;= A_LAST_TEMP; the_reg++) {
		if (!reg_is_free(the_reg)) {
			GEN_ASSERT(free_ptr[the_reg]);
			if (a_is_temp(free_ptr[the_reg] -&gt; the_anode)) {
				free_treg(the_reg);
			}
		}
	}

	for (the_reg = D_FIRST_TEMP; the_reg &lt;= D_LAST_TEMP; the_reg++) {
		if (!reg_is_free(the_reg)) {
			GEN_ASSERT(free_ptr[the_reg]);
			if (a_is_temp(free_ptr[the_reg] -&gt; the_anode)) {
				free_treg(the_reg);
			}
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.912">void
reg_free_formals(void)
{
	FTAG("gen_free_formals");
	reg_node * rlp = formal_list;
	STATB(ftag);

	while (rlp) {

		/* Save the next pointer. */
		reg_node * the_next = rlp -&gt; next2;

		/* Mark the register as free. */
		reg_free_user(rlp, NULL);

		rlp = the_next;
	}

	/* Make sure the list is never used again. */
	formal_list = NULL;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.913">@ Deallocate all user register variables in the current block, bp.
@c

void
reg_free_locals	(block_node * bp)
{
	FTAG("reg_free_locals");
	reg_node * rlp =  bp -&gt; block_regs;
	STATB(ftag);
	GEN_ASSERT(bp);

	while (rlp) {

		/* Save the next pointer. */
		reg_node * the_next = rlp -&gt; next2;

		/* Mark the register as free. */
		reg_free_user(rlp, bp);

		rlp = the_next;
	}

	/* Make sure the list is never used again. */
	bp -&gt; block_regs = NULL;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.914">@ Free the indicated user register.
@c

void
reg_free_user(reg_node * rp, block_node * bp)
{
	FTAG("reg_free_user");
	anode * ap = NULL;
	int the_reg = 0;
	STATB(ftag);

	GEN_ASSERT(rp);
	ap = rp -&gt; the_anode;
	GEN_ASSERT(ap);
	the_reg = spill_anode_ptr(ap) -&gt; a_sreg;

	GEN_ASSERT(is_xreg(the_reg));
	GEN_ASSERT(!reg_is_free(the_reg));

	/* Mark the register as free. */
	reg_free_array [reg_index(the_reg)] = TRUE;

	/* Remove the node from the user list and add it to the avail list. */
	if (bp == NULL) {
		lst2_remove_macro(rp, formal_list);
	}
	else {
		lst2_remove_macro(rp, bp -&gt; block_regs);
	}
	lst2_add_macro(rp, reg_node_avail_list);

	TRACEPN(ftag,
		reg_node * rlp = formal_list;
		es("frees: "); eanode(ap); ecs();
		es(bp ? "block" : "user formal");
		es(" list: ");
		while(rlp) {
			eanode(rlp -&gt; the_anode); eblank();
			rlp = rlp -&gt; next2;
		}
		ecnl();
	);

	/* Update the counts. */
	if (is_areg(the_reg)) {
		reg_na_free++;
		reg_na_user--;
	}
	else {
		reg_nd_free++;
		reg_nd_user--;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.915">@ Initialize this module.
@c

void
reg_init(void)
{
	FTAG("reg_init");
	register int i = 0;
	STATB(ftag);

	ASSERT(temp_list == NULL);
	ASSERT(temp_tail == NULL);

	/* All potential temporaries are free and none are user regs. */
	reg_na_free = A_TEMP_TOTAL;
	reg_nd_free = D_TEMP_TOTAL;
	reg_na_user = 0;
	reg_nd_user = 0;

	for (i = R_A0; i &lt;= R_A7; i++) {
		reg_free_array [reg_index(i)] = FALSE;	/* Temp regs are marked TRUE below. */
		reg_used_array [reg_index(i)] = FALSE;
		reg_push_array [reg_index(i)] = FALSE;
		free_ptr [i] = NULL;
	}

	for (i = A_FIRST_TEMP; i &lt;= A_LAST_TEMP; i++) {
		reg_free_array [reg_index(i)] = TRUE;
	}

	for (i = R_D0; i &lt;= R_D7; i++) {
		reg_free_array [reg_index(i)] = FALSE;	/* Temp regs are marked TRUE below. */
		reg_used_array [reg_index(i)] = FALSE;
		reg_push_array [reg_index(i)] = FALSE;
		free_ptr [i] = NULL;
	}

	for (i = D_FIRST_TEMP; i &lt;= D_LAST_TEMP; i++) {
		reg_free_array [reg_index(i)] = TRUE;
	}

	reg_init_check();

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.916">@ This little kludge allows checks to be made after every function.
@c

void
reg_init_check(void)
{
	ASSERT(temp_list == NULL);
	ASSERT(temp_tail == NULL);
}
</t>
<t tx="ekr.20080529093004.917">@ Allocate all dynamic data of this module with permanent lifetime.
@c

void
reg_perm_init(void)
{
	FTAG("reg_perm_init");
	static bool init_flag = FALSE;
	STATB(ftag);

	ASSERT(init_flag == FALSE);
	init_flag = TRUE;

	ASSERT(A_TEMP_TOTAL == A_SCRATCH_TOTAL+A_USER_TOTAL);
	ASSERT(D_TEMP_TOTAL == D_SCRATCH_TOTAL+D_USER_TOTAL);

	new_perm_reg_anode_macro(a0_anode,   	AREG_EA,	R_A0);
	new_perm_reg_anode_macro(d0_anode,   	DREG_EA,	R_D0);
	new_perm_reg_anode_macro(d7_anode,   	DREG_EA,	R_D7);
	new_perm_reg_anode_macro(a6_anode,   	AREG_EA,	R_A6);
	new_perm_reg_anode_macro(a7_anode,   	AREG_EA,	R_A7);
	new_perm_reg_anode_macro(no_push_anode, INDIRECT_EA,  R_A7);
	new_perm_reg_anode_macro(pop_anode, 	POST_INC_EA, R_A7);
	new_perm_reg_anode_macro(push_anode,	PRE_DEC_EA,  R_A7);
	
	/* 12/15/94
		Create an anode representing 8(a6).
		This is the address of the hidden argument used to point
		to the return area for large floats, structs and unions.
	*/
	new_perm_reg_anode_macro(hidden_anode,	DISPLACEMENT_EA,  R_A6);
	spill_anode_ptr(hidden_anode) -&gt; a_slong = 8;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.918">@ Spill all temporary registers. This routine must be called whenever generating code for constructs which could contain branches. This ensures that registers are treated uniformly in both branches.
@c

void
reg_spill_all (void)
{
	FTAG("reg_spill_all");
	register int the_reg;
	reg_node * rp = NULL;\
	anode * ap = NULL;
	TICKB(ftag);

	for (the_reg = A_FIRST_TEMP; the_reg &lt;= A_LAST_TEMP; the_reg++) {
		if (!reg_is_free(the_reg)) {

			rp = free_ptr [the_reg];
			GEN_ASSERT(rp);

			ap = rp -&gt; the_anode;
			GEN_ASSERT(ap);

			/* Bug fix 8/24/94: changed a_is_dtreg (!) to a_is_temp. */
			if (a_is_temp(ap)) {
				spill_reg(the_reg);
			}
		}
	}

	for (the_reg = D_FIRST_TEMP; the_reg &lt;= D_LAST_TEMP; the_reg++) {
		if (!reg_is_free(the_reg)) {

			rp = free_ptr [the_reg];
			GEN_ASSERT(rp);

			ap = rp -&gt; the_anode;
			GEN_ASSERT(ap);

			if (a_is_dtreg(ap)) {
				spill_reg(the_reg);
			}
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.919">@ Spill the indicated register and make it free.
@c

static void
spill_reg (int the_reg)
{
	FTAG("spill_reg");
	register reg_node * rp = NULL;
	register anode * ap = NULL;
	spill_anode dummy_anode = {0,0,0,0,0,0,0};
	TRACEPB(ftag,
		es(tok_name(the_reg)); enl());

	GEN_ASSERT(is_xreg(the_reg));
	rp = free_ptr[the_reg];
	GEN_ASSERT(rp);

	ap = rp -&gt; the_anode;
	GEN_ASSERT(ap &amp;&amp; a_is_temp(ap));
	
	/* Allocate the stack space. */
	gen_current_alloc += REGISTER_SIZE;
	gen_max_alloc = max(gen_current_alloc, gen_max_alloc);

	/*
		Set dummy_anode to refer to a new stack temp.
	*/
	a_set_temp(anode_ptr(&amp;dummy_anode));
	dummy_anode . a_length = ap -&gt; a_length;
	dummy_anode . a_sreg = R_A6;

	/*
		If the stack offset is greater than 32K we must have an index register
		in order to reference the stack location!
		We can't spill another register here to get that index register
		so we must reserve register D7 for that purpose.
	*/
	if (gen_current_alloc &gt;= 0xffff) {

		anode * cap = NULL;

		/* generate code to move  gen_current_alloc to D7 */
		new_const_anode_macro(cap, gen_current_alloc, REGISTER_SIZE);
		c_move_len(cap, d7_anode, REGISTER_SIZE);

		dummy_anode . n_type = INDEX_EA;
		dummy_anode . a_slong = 0;
		dummy_anode . a_sxreg = R_D7;
	}
	else {
		dummy_anode . n_type = DISPLACEMENT_EA;
		dummy_anode . a_slong = - gen_current_alloc;
		dummy_anode . a_sxreg = 0;
	}

	/*
		Generate code to move the old anode to the dummy_anode.
		c_put will freeze dummy_anode because it is a temporary spill node
		so the fact that dummy_anode is local to this routine is unimportant.
	*/
	GEN_ASSERT(c_arg_will_freeze(anode_ptr(&amp;dummy_anode)));
	c_move_len(ap, anode_ptr(&amp;dummy_anode), REGISTER_SIZE);

	/* Only now can we convert the old anode to refer to the stack temp. */
	memcpy(ap, &amp;dummy_anode, sizeof(spill_anode));

	/* Free the register! */
	free_treg(the_reg);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.920"></t>
<t tx="ekr.20080529093004.921"></t>
<t tx="ekr.20080529093004.922">/*
	CC2: header file for user arguments.

	Use 4-space tabs.

	source:  CCarg.h
	started: November 29, 1990
	version:
		June 2, 1994.
*/

/*
	Make sure this header is included only once.
*/

#ifndef CCarg_h_
#define CCarg_h_

#pragma once

/*
	Define the structure used by -s2 processing to associate
	file names with direcories. This eliminates searching for files.

	This is the precursor to project information.
*/

typedef struct dir_info_struct dir_info;

struct dir_info_struct {
	TYPE_LIST(dir_info);
	char *	dir_long_file_name;	/* Full file name. */
	char *	dir_file_name;		/* File name as used in #include. */
	char *	dir_name;			/* Directory name. */
	char *	dir_path;			/* Full directory path. */
};

/*
	User Flags.
*/

	/* Preprocessor flags. */

extern bool	arg_cpp_flag;			/* TRUE: output cpp results to output file. */
extern bool	arg_cpp_only_flag;		/* TRUE: exit after cpp finishes. */
extern bool	arg_full_ws_flag;		/* TRUE: tokize retains all whitespace. */
extern bool arg_line_flag;			/* TRUE: #line directive in cpp output. */
extern bool arg_once_flag;			/* TRUE: include all files only once. */
extern bool arg_proto_flag;			/* TRUE: require prototypes. */
extern bool arg_trigraph_flag;		/* TRUE: recognize trigraphs. */
extern bool arg_v_full_include_flag; /* TRUE: use full file names in include messages. */
extern bool arg_v_func_flag;		/* +-v_function verbose messages about functions. */
extern bool arg_v_include_flag; 	/* TRUE: verbose messages about include files. */

	/* Code generation flags. */

extern bool	arg_array_opt_flag;		/* TRUE: strict array subscript handling. */
extern bool arg_asm_comment_flag;	/* TRUE: generate assembly-language comments. */
extern bool arg_chk_ptr_flag;		/* TRUE: generate pointer checking. */
extern bool arg_d0_only_flag;		/* TRUE: function always return in d0. */
extern bool arg_far_data_flag;		/* TRUE: allow more than 32K global data. */
extern bool arg_gen_link_flag;		/* TRUE: force LINK/UNLK instructions for all routines. */

	/* Code generation debugging flags. */

extern bool arg_code1_flag;		/* TRUE: output code list before/after peephole pass. */
extern bool arg_gen_trace_flag; /* TRUE: trace the code generators. */
extern bool arg_no_gen_flag;	/* TRUE: suppress code generation. */
extern bool arg_no_out_flag;	/* TRUE: suppress output, not code generation. */
extern bool arg_no_peep_flag;	/* TRUE: suppress peephole optimizer. */
extern bool arg_tree_flag;		/* TRUE: output parse tree. */

/*
	Define buffers for communication between arg.c and arg_dialog.c.

	These buffers are used only when the the argument dialog is used.
	The buffers are allocated in arg_dialog.c.
	The size of these buffers is ARG_BUF_SIZE.
*/
#define ARG_BUF_SIZE 256

extern char * arg_def_buf;
extern char * arg_undef_buf;

/*
	Declare variables describing the input and output file paths.
	These are used to open files and to search for include paths.
*/
extern char * arg_segment;

extern char * arg_arg_path;
extern char * arg_in_path;
extern char * arg_out_path;
extern char * arg_syn_path;
extern char * arg_paths;

extern io_path_list * arg_search_paths;
extern io_file * arg_arg_file;

/*
	Function prototypes.
*/

	/* Synonyms for the return values from arg_do_argv. */
	enum { MORE_FILES_REMAIN = TRUE, NO_MORE_FILES_REMAIN = FALSE };

bool arg_do_argv 		(int argc, char **argv, char * on_str, char * off_str);
void arg_massage_string	(char * s);
int  arg_string2argv	(char *** argvp, char * buf);

#endif /* CCarg_h_ */</t>
<t tx="ekr.20080529093004.923">/*
	CC: header file for CCend.c.

	source:  CCend.h
	started: June 2, 1994.
	version: June 2, 1994.
*/

#ifndef CCend_h_
#define CCend_h_

#pragma once

void end_close_all	(void);

#endif /* CCend_h_ */</t>
<t tx="ekr.20080529093004.924">/*
	CC: Header file for CCerr.c.

	source:  CCerr.h
	started: June 1, 1994.
	version: June 1, 1994.
		March 7, 1994.
			Added support for buffering error messages.
			Defined err_nodes.
*/

#ifndef CCerr_h_
#define CCerr_h_

#pragma once

	/*
		Application-specific error reporting macros.
		error and fatal are defined in LIBdebug.h
	*/

#define help(stat)		if(help_begin()) { stat; err_context(); }
#define user_fatal(stat){user_fatal_begin(); stat; user_fatal_end();}
#define warning(stat)	if(warn_begin()) { stat; err_context(); }

	/* Use line instead of err_line. */

#define delayed_error(line, stat)\
	{long save=err_line; err_line=line; error(stat); err_line = save;}
#define delayed_help(line, stat)\
	{long save=err_line; err_line=line; help(stat); err_line = save;}
#define delayed_warning(line, stat)\
	{long save=err_line; err_line=line; warning(stat); err_line = save;}

	/* Give error regardless of err_err_flag. */

#define force_error(stat)\
	{bool save=err_err_flag; err_err_flag=TRUE; error(stat); err_err_flag = save;}

#define PERM_GEN_ASSERT_TRACE(a,statements)\
	if(!(a)) {\
		long save_line = err_line;\
		err_line = gen_expr_line;\
			es_internal_err(#a, __LINE__, __FILE__); ecnl();\
			statements; fatal_end();\
		err_line = save_line;\
	}

#ifdef PRODUCTION

	#define DEBUG(a)
	#define GEN_ASSERT(a)
	#define GEN_ASSERT_TRACE(a, statements)

#else

	#define DEBUG(a) a

	#define GEN_ASSERT(a)\
		if(!(a)) {\
			long save_line = err_line;\
			err_line = gen_expr_line;\
				es_assert_failed(#a, __LINE__, __FILE__); fatal_end();\
			err_line = save_line;\
		}

	#define GEN_ASSERT_TRACE(a,statements)\
		if(!(a)) {\
			long save_line = err_line;\
			err_line = gen_expr_line;\
				es_assert_failed(#a, __LINE__, __FILE__);\
				enl(); statements;\
				fatal_end();\
			err_line = save_line;\
		}
#endif

/*
	Function prototypes.
	Some of these are also defined in LIBdebug.h
*/

	/* Routines called by macros in this file. */

bool	err_begin			(void);
void	fatal_begin			(void);
void	fatal_end			(void);
bool	help_begin			(void);
void	user_fatal_begin	(void);
void	user_fatal_end		(void);
bool	warn_begin			(void);

void	es_assert_failed	(char * condition, int line, char * file);
void	err_context			(void);
void	es_internal_err		(char * condition, int line, char * file);
void	err_lines			(long the_line, int lead_context, int trail_context);

	/* Other routines in CCerr.c */

void	err_begin_file	(char * file_name);
void	err_begin_func	(char * func_name);
char *	err_file_name	(void);
void	err_init		(void);
void	err_init_again	(void);
void	err_test		(void);

/*
	Global variables defined in CCerr.c.
*/

extern long	err_count;			/* Error counts... */
extern long err_help;
extern long	err_warning;
extern bool err_err_flag;		/* Enable message flags... */
extern bool err_fatal_flag;
extern bool err_help_flag;
extern bool err_warn_flag;
extern long	err_line;			/* Current line number. */
extern long err_line_offset;	/* Current line offset. */
extern int err_pass;			/* Current pass number. */
extern bool err_verbose;		/* Verbose flag. */
extern char * err_fname ;		/* Current file name. */
extern char * err_func_name;	/* Current function name. */
extern bool err_context_flag;	/* TRUE: print context of errors. */

#endif /* CCerr_h_ */
</t>
<t tx="ekr.20080529093004.925">/*
	CC2: header file for application-specific routines.

	source:  CCes.h.
	started: June 2, 1994.
	version: June 2, 1994.
*/

#ifndef CCes_h_
#define CCes_h_

#pragma once

void es (char * s);

#endif /* CCes_h_ */</t>
<t tx="ekr.20080529093004.926">/*
	CC: Application-specific memory allocation macros and routines.
		See LIBmem.h for general memory allocation macros and routines.

		CCmem.h and LIBmem.h own the suffixes _life and _stat and
		the prefixes mem_ and new_.

	source:  CCmem.h
	started: June 1, 1994.
	version: June 2, 1994.
*/

#ifndef CCmem_h_
#define CCmem_h_

#pragma once

#include &lt;LIBmem.h&gt;

#include &lt;string.h&gt;

/*
	Abbreviations.
*/

#define new_file_macro(p, stats)	new_macro(p,file_life,stats)
#define new_perm_macro(p, stats)	new_macro(p,perm_life,stats)

#define new_file_cat2_macro(p,s1,s2)	new_cat2_macro(p,s1,s2,file_life,string_stats)
#define new_perm_cat2_macro(p,s1,s2)	new_cat2_macro(p,s1,s2,perm_life,perm_string_stats)

#define new_perm_cat3_macro(p,s1,s2,s3)	   new_cat3_macro(p,s1,s2,s3,perm_life,perm_string_stats)
#define new_perm_cat4_macro(p,s1,s2,s3,s4) new_cat4_macro(p,s1,s2,s3,s4,perm_life,perm_string_stats)

#define new_file_string_macro(p,s1)	new_string_macro(p,s1,file_life,string_stats)
#define new_perm_string_macro(p,s1) new_string_macro(p,s1,perm_life,perm_string_stats)

/*
	General allocation macros.

	These macros are the fundamental lifetime-based storage allocation macro.

	This macro is used by tokize, and must be as fast as possible.
	In particular, the MEM_STATS and MEM_UPDATE_STATS macro must expand to null code
	in the production version; otherwise the performace of the assembler would suffer.

	What makes all the new macros simpler *and* safer is the definition of new_macro.
	In particular, using sizeof(*p) istead of the older sizeof(type_name_param)
	*guarantees* that p must be a pointer.
	It also eliminates the possibility of having a macro expand to sizeof(sizeof(x)).
*/

#ifdef PRODUCTION
	#define mem_check_macro(life,size)
#else
	#define mem_check_macro(life,size) mem_check(life,size)
#endif


#define new_macro(p, life, stat) \
{\
	ASSERT(sizeof(*p) &gt; 4);\
	new_size_macro(p, sizeof(*p), life, stat);\
}

#define new_size_macro(p, the_size, life, stat) \
{\
	size_t size_ = (the_size);\
	ASSERT(life);\
	MEM_UPDATE_STATS(stat, size_);\
	MEM_STATS(life -&gt; mem_cur_nodes ++; life -&gt; mem_cur_bytes += (size_));\
	if (size_ &gt; life -&gt; mem_avail) {\
		p = mem_new_block(size_, life);\
	}\
	else {\
		mem_check_macro(life,size_);\
		p = life -&gt; mem_ptr;\
		life -&gt; mem_ptr    = (((char *) (life -&gt; mem_ptr)) + size_);\
		life -&gt; mem_avail -= size_;\
	}\
	/* TRACEP("new", es(life -&gt; name); eptr(p); enl()); */\
}

	/* strings. */

#define new_string_macro(p,s1,the_life,the_stat)\
{\
	ASSERT(s1);\
	new_size_macro(p, strlen(s1)+1, the_life, the_stat);\
	strcpy(p, s1);\
}

#define new_cat2_macro(p,s1,s2,the_life,the_stat)\
{\
	ASSERT(s1 &amp;&amp; s2);\
	new_size_macro(p, strlen(s1)+strlen(s2)+1,the_life,the_stat);\
	strcpy(p, s1);\
	strcat(p, s2);\
}

#define new_cat3_macro(p,s1,s2,s3,the_life,the_stat)\
{\
	ASSERT(s1 &amp;&amp; s2 &amp;&amp; s3);\
	new_size_macro(p, strlen(s1)+strlen(s2)+strlen(s3)+1,the_life, the_stat);\
	strcpy(p, s1);\
	strcat(p, s2);\
	strcat(p, s3);\
}

#define new_cat4_macro(p,s1,s2,s3,s4,the_life,the_stat)\
{\
	ASSERT(s1 &amp;&amp; s2 &amp;&amp; s3 &amp;&amp; s4);\
	new_size_macro(p,strlen(s1)+strlen(s2)+strlen(s3)+strlen(s4)+1,the_life, the_stat);\
	strcpy(p, s1);\
	strcat(p, s2);\
	strcat(p, s3);\
	strcat(p, s4);\
}

	/* anodes */

#define new_anode_macro(p, size, the_type)\
	{\
		new_size_macro(p, size, file_life, anode_stats) \
		anode_ptr(p) -&gt; n_type = the_type;\
	}

#define new_const_anode_macro(p, val, alen)\
	{\
		new_anode_macro(p, sizeof(const_anode), IMMEDIATE_EA);\
		const_anode_ptr(p) -&gt; a_ckind = LONG_CKIND;\
		const_anode_ptr(p) -&gt; a_length = alen;\
		const_anode_ptr(p) -&gt; a_long = val;\
	}

#define new_perm_anode_macro(p, size, the_type)\
	{\
		new_size_macro(p, size, perm_life, perm_anode_stats);\
		anode_ptr(p) -&gt; n_type = the_type;\
	}

#define new_perm_reg_anode_macro(p, address_mode, the_reg)\
	{\
		new_perm_anode_macro(p, sizeof(spill_anode), address_mode);\
		spill_anode_ptr(p) -&gt; a_sreg = the_reg;\
		spill_anode_ptr(p) -&gt; a_length = REGISTER_SIZE;\
	}

		/* cnodes */

#define new_cnode_macro(p, size, the_type)\
	{\
		new_size_macro(p, size, file_life, cnode_stats);\
		cnode_ptr(p) -&gt; n_type = the_type;\
	}

#define new_clabel_macro(p)\
	{\
		new_cnode_macro(p, sizeof(label_cnode), O_CLABEL);\
		c_clear_mark(p);\
		p -&gt; c_labnum = ++par_cur_lab;\
	}

#define new_ulabel_macro(p, symbol)\
	{\
		new_cnode_macro(p, sizeof(ulabel_cnode), O_ULABEL);\
		c_clear_mark(p);\
		p -&gt; c_labsym = symbol;\
		p -&gt; c_labnum = ++par_cur_lab;\
	}

		/* enodes */

#define new_enode_macro(p, size, ntype)\
	{\
		/* 6/2/94: both local and global have *file* lifetime. */\
		new_size_macro(p, size, file_life, enode_stats);\
		enode_ptr(p) -&gt; n_type = ntype;\
	}

#define new_perm_enode_macro(p, size, ntype)\
	{\
		new_size_macro(p, size, perm_life, perm_enode_stats);\
		enode_ptr(p) -&gt; n_type = ntype;\
	}

		/* pnodes */

#define new_pnode_macro(p, size, ntype)\
{\
	new_size_macro(p, size, file_life, pnode_stats);\
	pnode_ptr(p) -&gt; n_type = ntype;\
	pnode_ptr(p) -&gt; p_line = err_line;\
	pnode_ptr(p) -&gt; p_line_ptr = par_line_ptr;\
}

		/* reg nodes */

/*
	Get a new perm reg_node.
	The global reg_node_avail_list contains a list of currently unassigned nodes.
*/
#define new_reg_node_macro(rp, ap)\
{\
	if (reg_node_avail_list == NULL) {\
		new_size_macro(rp, sizeof(reg_node), perm_life, perm_reg_stats);\
	}\
	else {\
		rp = reg_node_avail_list;\
		reg_node_avail_list = rp -&gt; next2;\
	}\
	rp -&gt; next2 = NULL;\
	rp -&gt; back2 = NULL;\
	rp -&gt; the_anode = ap;\
}

		/* snodes */

#define new_snode_macro(p, ntype)\
{\
	new_size_macro(p, sizeof(snode), file_life, snode_stats);\
	p -&gt; n_type = ntype;\
	p -&gt; p_line = err_line;\
	p -&gt; p_line_ptr = par_line_ptr;\
}

		/* tnodes */

#define new_perm_tnode_macro(p, t_prim, t_size)\
{\
	new_size_macro(p, sizeof(tnode), perm_life, perm_tnode_stats);\
	p -&gt; tprim = t_prim;\
	p -&gt; tsize = t_size;\
}

#define new_tnode_macro(t, t_prim, t_size)\
{\
	new_size_macro(t, sizeof(tnode), file_life, tnode_stats);\
	t -&gt; tprim = t_prim;\
	t -&gt; tsize = t_size;\
}

		/* xnodes */

#define new_xnode_macro(p, size)\
{\
	/* 6/2/94: All such nodes have file_life. */\
	new_size_macro(p, size, file_life, xnode_stats);\
}

/*
	Duplicate source into dest.
	This code works even if source and dest are the same.
*/
#define node_dupl_macro(dest, size, source)\
	{\
		void * dupl_p_;\
		new_size_macro(dupl_p_, size, file_life, xnode_stats);\
		memmove(dupl_p_, source, size);\
		dest = dupl_p_;\
	}

/*
	Function prototypes for application-specific routines.
*/
token * mem_new_tok_block	(token * tp, long tavail);
void	mem_check			(mem_life * life, ulong size);

/*
	Define global variables.

	The actual lifetimes used in the program.
	Tokens must have a separate lifetime so token blocks
	will contain only tokens.
*/
extern mem_life * file_life;	/* Description of file lifetime. */
extern mem_life * perm_life;	/* Description of permanent lifetime. */
extern mem_life * token_life;	/* Description of token lifetime. */

	/* Parser statistics. */

extern mem_stat * anode_stats;
extern mem_stat * cnode_stats;
extern mem_stat * enode_stats;
extern mem_stat * macro_stats;
extern mem_stat * pnode_stats;
extern mem_stat * snode_stats;
extern mem_stat * string_node_stats;
extern mem_stat * tnode_stats;
extern mem_stat * xnode_stats;

extern mem_stat * perm_arg_stats;
extern mem_stat * perm_anode_stats;
extern mem_stat * perm_enode_stats;
extern mem_stat * perm_import_stats;
extern mem_stat * perm_macro_stats;
extern mem_stat * perm_reg_stats;
extern mem_stat * perm_snode_stats;
extern mem_stat * perm_spell_stats;
extern mem_stat * perm_st_block_stats;
extern mem_stat * perm_string_stats;
extern mem_stat * perm_tnode_stats;
extern mem_stat * perm_with_node_stats;

	/* Preprocessor stats. */

extern mem_stat * cpp_stats;
extern mem_stat * id_token_stats;
extern mem_stat * inhibit_stats;
extern mem_stat * keyword_spell_stats;
extern mem_stat * narg_block_stats;
extern mem_stat * ptr_token_stats;
extern mem_stat * skip_stats;
extern mem_stat * spell_stats;
extern mem_stat * string_stats;
extern mem_stat * small_token_stats;
extern mem_stat * val_token_stats;

#endif /* CCmem_h_ */
</t>
<t tx="ekr.20080529093004.927"></t>
<t tx="ekr.20080529093004.928">/*
	CC2: Argument processing module

	Use 4-space tabs for best appearance.

	Not all the routines in this module are used in
	all programming environments.

	source:  CCarg.c
	started: November 30, 1990
	version:
		August 28, 1994.
			Added -bell option and -quit as a synonym for -exit.
		June 5, 1994.
			Added arg_prefix.
		November 2, 1993.
			Added @goto logic.
		July 29, 1993.
			Added +-asm_comment option and arg_asm_comment_flag.
		June 17, 1993.
			Added +-gen_link option and arg_gen_link_flag.
		May 20, 1993.
			Added +-far_data option.
		May 14, 1993.
			Added +-v_full_include option.
		May 1, 1993.
			Removed prototypes of routines no longer in this file.
		April 8, 1993.
			Added +-chk_ptr option.
			Removed arg_no_local_flag.
		March 16, 1993.
			Added +-v_function flag.
			Added +-out_path option.
			Added +-segment option.
		March 8, 1993.
			Added +-v_include flag.
		February 11, 1993.
			Require prototypes on by default.
		January 12, 1993.
			Added d0_only option.
		December 9, 1992.
			Added +-no_output option.
		December 2, 1992.
			Added +-gen_trace option.
		September 8, 1992.
			Added +-proto option.
		August 3, 1992
			Added +-note, +-error, +-warning options.
		July 1, 1992
			Added the following command line arguments:
				array_opt, code1, code2, no_gen, no_local, no_peep and tree
		May 27, 1992
			Replaced check_ptr with ASSERT.
		May 6, 1992
			Added +- trigraph option.
		April 22, 1992
			Added +-line option.
		April 18, 1992
			arg_do_argv now returns TRUE if more arguments remain.
			Added -exit option.
		April 17, 1992
			Added support for +- args.
			Added +-cpp, +-cpp_only and +-full_ws options.
		April 11, 1992
			Added -once command line option and arg_once_flag.
		April 6, 1992
			Removed all ftag parameters.
		March 18, 1992
			Use mst_init_again instead of mst_restore, mst2_init.
			Use mst_init_define and mst_init_undef.
		March 4, 1992
			Installed new object routines.
		March 2, 1992
			-s2 argument processing added.
		February 6, 1992
			&lt;init2.c&gt; used for getting arguments from a file.
		September 29, 1991
*/

&lt;&lt; CCarg #includes &gt;&gt;
&lt;&lt; CCarg declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.929">#include "CC.h"

#include "CCarg.h"
#include "CCmem.h"
#include "CCmst.h"
#include "CCver.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBenv.h&gt;
#include &lt;LIBio.h&gt;
#include &lt;LIBlist.h&gt;
#include &lt;LIBlog.h&gt;

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.930">/*
	Define global user flags;
*/

	/* Preprocessor flags. */

bool arg_cpp_flag = FALSE; 				/* +-cpp 		 output cpp results to file. */
bool arg_cpp_only_flag = FALSE; 		/* +-cpp_only	 exit after cpp finishes. */
bool arg_full_ws_flag = TRUE;	 		/* +-full_ws	 tokize retains all whitespace. */
bool arg_line_flag = TRUE;	 			/* +-line		 #line directive in cpp output. */
bool arg_once_flag = FALSE; 			/* +-once		 include all files only once. */
bool arg_proto_flag = TRUE;	 			/* +-proto		 require prototypes. */
bool arg_trigraph_flag = FALSE; 		/* +-trigraph	 recognize trigraphs. */
bool arg_v_include_flag = FALSE; 		/* +-v_include	 verbose messages about include files. */
bool arg_v_full_include_flag = FALSE; 	/* +-v_full_include: full names of include files. */
bool arg_v_func_flag = FALSE; 			/* +-v_function verbose messages about functions. */

	/* Code generation flags. */

bool arg_array_opt_flag = TRUE;		/* +-array_opt	strict array subscript handling. */
bool arg_asm_comment_flag = TRUE;	/* +- asm_comment generate assembly-language comments. */
bool arg_chk_ptr_flag = FALSE;		/* +-chk_ptr    generate pointer checking. */
bool arg_d0_only_flag = FALSE;		/* +-d0_only    function always return in d0. */
bool arg_far_data_flag = FALSE;		/* +-far_data	allow more than 32K global data. */
bool arg_gen_link_flag = TRUE;		/* +-gen_link   force LINK/UNLK instructions for all routines. */

	/* Code generation debugging flags. */

bool arg_code1_flag  = FALSE;	 /* +-code1		Output code list before/after peephole. */
bool arg_gen_trace_flag = FALSE; /* +-gen_trace Trace the code generators. */
bool arg_no_gen_flag = FALSE;	 /* +-no_gen	Suppress code generation. */
bool arg_no_out_flag = FALSE;	 /* +-no_output	Suppress output, not code generation. */
bool arg_no_peep_flag = FALSE;	 /* +-no_peep	Suppress peephole optimizer. */
bool arg_tree_flag   = FALSE;	 /* +-tree		Output parse tree. */

	/* Error reporting options. */

								/* +-error		Enable error messages. */
								/* +-note		Enable notes. */
								/* +-warning	Enable warning messages. */
/*
	Define the global file paths and files.
*/
char * arg_segment = "MAIN";	/* Do not re-initialize. */
char * arg_arg_path = NULL;
char * arg_in_path = NULL;
char * arg_out_path = NULL;
char * arg_syn_path = NULL;

io_path_list * arg_search_paths = NULL;	/* Do not re-initialize. */
char * arg_paths = NULL;				/* Do not re-initialize. */
io_file * arg_arg_file = NULL; 			/* Do not re-initialize. */

/*
	Define dynamically allocated buffers.
	arg_def_buf and arg_undef buf are used arg_dialog.c.
*/
#define ARG_FILE_BUF_SIZE 2000

char * arg_def_buf = NULL;		/* Do not re-initialize. */
char * arg_undef_buf = NULL;	/* Do not re-initialize. */

static char * arg_file_buf = NULL; /* Do not re-initialize. */

static int arg_save_argc = 0;		/* Saved argc. */
static char ** arg_save_argv = NULL;	/* Saved argp. */

/*
	Declare internal routines.
*/
static void	arg_help	(void);
static bool	arg_prefix	(char *p, char *s);
</t>
<t tx="ekr.20080529093004.931">@ Set up the program's arguments which are found in an argv vector.  This routine may be re-entered. Return TRUE if any more arguments remain.
@c

#define debug_arg_do_argv(a)

bool
arg_do_argv(int argc, char ** argv, char * on_str, char * off_str)
{
	FTAG("arg_do_argv");
	register char * arg = NULL;
	char * in = NULL,  * out = NULL;
	static char * path_tag = "path name";
	static char * default_opath = NULL;

	/*
		Do not put Sherlock macros here: Sherlock has not been initialized!
	*/
	SL_DISABLE();

	debug_arg_do_argv(TRACEP(ftag, elp(); eint(argc); ecs(); eptr(argv); erpnl()));

	if (argv == NULL) {
		argc = arg_save_argc;
		argv = arg_save_argv;
	}
	if (argv == NULL) {
		return NO_MORE_FILES_REMAIN;
	}

	/* Indicate that no file arguments have been seen yet. */
	in  = NULL;
	out = NULL;

	/* Process all the arguments on the command line. */
	ASSERT(argv);
	argc--;
	argv++;
	while (argc-- &gt; 0) {

		ASSERT(*argv != NULL);
		arg = *argv++;
		debug_arg_do_argv(TRACEPN(ftag, es("arg: "); es(arg); enl() ));

		if (arg[0] == '@') {
			if (str_eq(arg+1, "goto")) {
				if (argc--) {

					/* Scan forward for the label. */
					char * label = *argv++;
					ecnl(); es("@goto "); es(label); enl();
					while(argc--) {
						arg = *argv++;
						if (str_eq(label, arg)) {
							break;
						}
					}
				}
				else {
					es("Trailing @goto\n");
					end_usage();
				}
			}
			else {
				/* Ignore the label. */
				;
			}
		}
		else if (arg[0] == '+' || arg[0] == '-') {

			bool arg_bool = (arg[0] == '+');

			arg++;

			switch(arg[0]) {

			case 'a':

				if (str_eq(arg, "array_opt")) {
					arg_array_opt_flag = arg_bool;
				}
				else if (str_eq(arg, "asm_comment")) {
					arg_asm_comment_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'b':
			
				if (str_eq(arg, "bell")) {
					ebell();
				}
				else {
					goto unknown_option;
				}
				break;

			case 'c':

				if (str_eq(arg, "chk_ptr")) {
					arg_chk_ptr_flag = arg_bool;
				}
				else if (str_eq(arg, "cpp")) {
					arg_cpp_flag = arg_bool;
				}
				else if (str_eq(arg, "cpp_only")) {
					arg_cpp_only_flag = arg_bool;
				}
				else if (str_eq(arg, "code1")) {
					arg_code1_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'd':

				if (str_eq(arg, "d")) {
					/* Define a variable. */
					if (argc--) {
						char * def = NULL;
						arg = *argv++;
						/* Scan for an optional equal sign. */
						for (def = arg;	*def; def++) {
							if (*def == '=') {
								*def = '\0';
								def++;
								break;
							}
						}
						mst_init_define(arg, def, TRUE);
					}
					else {
						es("Trailing +-d\n");
						end_usage();
					}
				}
				else if (str_eq(arg, "d0_only")) {
					arg_d0_only_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'e':

				if (str_eq(arg, "error")) {
					err_err_flag = arg_bool;
				}
				else if (str_eq(arg, "exit")) {
					return NO_MORE_FILES_REMAIN;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'f':

				if (str_eq(arg, "far_data")) {
					arg_far_data_flag = arg_bool;
				}
				else if (str_eq(arg, "full_ws")) {
					arg_full_ws_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'g':

				if (str_eq(arg, "gen_link")) {
					arg_gen_link_flag = arg_bool;
				}
				else if (str_eq(arg, "gen_trace")) {
					arg_gen_trace_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'h':
			case 'i':
			case 'j':
			case 'k':

				goto unknown_option;

			case 'l':

				if (str_eq(arg, "line")) {
					arg_line_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'm':
			case 'n':

				if (str_eq(arg, "note")) {
					err_help_flag = arg_bool;
				}
				else if (str_eq(arg, "no_gen")) {
					arg_no_gen_flag = arg_bool;
				}
				else if (str_eq(arg, "no_output")) {
					arg_no_out_flag = arg_bool;
				}
				else if (str_eq(arg, "no_peep")) {
					arg_no_peep_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'o':

				if (str_eq(arg, "of")) {
					if (argc--) {
						out = arg = *argv++;
					}
					else {
						es("Trailing +-d\n");
						end_usage();
					}
				}
				else if (str_eq(arg, "once")) {
					arg_once_flag = arg_bool;
				}
				else if (str_eq(arg, "out_path")) {

					/* Define the default output path. */
					if (argc--) {
						arg = *argv++;
						if(arg[strlen(arg)-1] == ENV_PATH_SEPARATOR_CHAR) {
							new_perm_string_macro(default_opath, arg);
						}
						else {
							new_perm_cat2_macro(default_opath, arg, ENV_PATH_SEPARATOR_STRING);
						}
					}
					else {
						es("Trailing +-out_path.\n");
						end_usage();
					}
				}
				else {
					goto unknown_option;
				}
				break;

			case 'p':
				if (str_eq(arg, "proto")) {
					arg_proto_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'q':
			
				if (str_eq(arg, "quit")) {
					return NO_MORE_FILES_REMAIN;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'r':

				goto unknown_option;

			case 's':

				if (str_eq(arg, "s")) {

					/* Define a path. */
					if (argc--) {

						char * name = NULL;
						io_path_list * path_p = NULL;

						arg = *argv++;
						if(arg[strlen(arg)-1] == ENV_PATH_SEPARATOR_CHAR) {
							new_perm_string_macro(name, arg);
						}
						else {
							new_perm_cat2_macro(name, arg, ENV_PATH_SEPARATOR_STRING);
						}
						new_perm_macro(path_p, perm_arg_stats);
						path_p -&gt; io_path_name = name;
						lst_append_macro(path_p, arg_search_paths, io_path_list);
					}
					else {
						es("Trailing +-s.\n");
						end_usage();
					}
				}

				#if 0 /* no longer used. */
					else if (str_eq(arg, "s2")) {

						char * arg1, * arg2;
						dir_info * info;

						/* Define a path. */
						if (argc--) {
							arg1 = *argv++;
						}
						if (argc--) {
							arg2 = *argv++;

							obj_new_macro(info, sizeof(dir_info), "arg dir info");
							lst_add_macro(info, arg_s2_paths);

							if(arg1[strlen(arg1)-1] == ENV_PATH_SEPARATOR_CHAR) {
								str_2alloc_macro(info -&gt; dir_long_file_name,
									arg1, arg2, arg_dealloc_list, "arg long fname");
								str_alloc_macro(info -&gt; dir_name,
									arg1, arg_dealloc_list, "arg dir");
							}
							else {
								str_3alloc_macro(info -&gt; dir_long_file_name,
									arg1, ENV_PATH_SEPARATOR_STRING, arg2,
									 arg_dealloc_list, "arg long fname sep");
								str_2alloc_macro(info -&gt; dir_name,
									arg1, ENV_PATH_SEPARATOR_STRING,
									 arg_dealloc_list, "arg dir sep");
							}
							str_alloc_macro(info -&gt; dir_file_name,
								arg2, arg_dealloc_list, "arg file");
							info -&gt; dir_path = io_new_path(info -&gt; dir_name);

							TRACEN("-arg_s2", es("-s2: ");
								es(info -&gt; dir_long_file_name); eblank();
								es(info -&gt; dir_file_name); enl());
						}
						else {
							es("Trailing +-s2.\n");
							end_usage();
						}
					}
				#endif
				else if (str_eq(arg, "segment")) {

					char * arg1 = NULL;
					if (argc--) {
						arg1 = *argv++;
						new_perm_string_macro(arg_segment, arg1);
					}
					else {
						es("Trailing +-segment.\n");
						end_usage();
					}
				}
				else {
					goto unknown_option;
				}
				break;

			case 't':

				if (str_eq(arg, "tree")) {
					arg_tree_flag = arg_bool;
				}
				else if (str_eq(arg, "trigraph")) {
					arg_trigraph_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'u':

				if(str_eq(arg, "u")) {
					/* Suppress the initial definition of a variable. */
					if (argc--) {
						arg = *argv++;
						/* Put new u_node on global list. */
						mst_init_undef(arg);
					}
					else {
						es("Trailing +-u.\n");
						end_usage();
					}
				}
				else {
					goto unknown_option;
				}
				break;

			case 'v':

				if (str_eq(arg, "v")) {
					err_verbose = arg_bool;
				}
				else if (str_eq(arg, "v_full_include")) {
					arg_v_full_include_flag = arg_bool;
				}
				else if (str_eq(arg, "v_function")) {
					arg_v_func_flag = arg_bool;
				}
				else if (str_eq(arg, "v_include")) {
					arg_v_include_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'w':

				if (str_eq(arg, "warning")) {
					err_warn_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			default:

				if (str_eq(arg, "?")) {
					/* Tell the version number and go on. */
					enl(); es(VER_VERSION); enl();
					arg_help();
					break;
				}

			unknown_option:

				#ifdef PRODUCTION
					if (on_str &amp;&amp; arg_prefix(on_str+1, arg)) {

						/* Ignore a Sherlock argument. */
						char * s = arg + strlen(on_str) - 1;
						if (*s == '&gt;' &amp;&amp; *(s+1) == '&gt;') {
							log_open(s+2);
						}
					}
					else if (off_str &amp;&amp; arg_prefix(off_str+1, arg)) {
						/* Ignore a Sherlock argument. */
						;
					}
					else {
						es("ignoring unknown command-line option: ");
						es(arg_bool ? "+" : "-"); es(arg); enl();
					}
				#else
					es("ignoring unknown command-line option: ");
					es(arg_bool ? "+" : "-"); es(arg); enl();
				#endif

			} /* end +- option switch */
		}
		else if (in == NULL) {
			in = arg;
			break;
		}
	}

	/* Make sure that the input file name was provided. */
	if (in == NULL) {
		es("Missing input file argument.\n");
		end_usage();
	}

	/* Remember the input and output paths. */
	arg_in_path  = in;

	if (out == NULL) {

		/* Create a file name from the input file name. */
		size_t ilen = strlen(in);
		if (ilen &gt; 2 &amp;&amp; in[ilen-2] == '.' &amp;&amp; (in[ilen-1] == 'c' || in[ilen-1] == 'C')) {

			/* Prepend the default output path if it exists. */
			if (default_opath) {

				/*
					Scan backwards from end of input file name,
					looking for ENV_PATH_SEPARATOR_CHAR.
				*/
				size_t back_count = ilen - 1;
				char * back = in + ilen - 1;
				while(*back != ENV_PATH_SEPARATOR_CHAR &amp;&amp; back_count) {
					back--;
					back_count--;
				}
				if (*back == ENV_PATH_SEPARATOR_CHAR) {
					back++;
				}

				if (default_opath[strlen(default_opath)-1] == ENV_PATH_SEPARATOR_CHAR) {
					new_perm_cat2_macro(out, default_opath, back);
				}
				else {
					new_perm_cat3_macro(out, default_opath, back, ENV_PATH_SEPARATOR_STRING);
				}
			}
			else {
				new_perm_string_macro(out, arg);
			}
			out[strlen(out)-1] = 'a';
			arg_out_path = out;
		}
		else {
			es("Missing -of or input file does not end in .c"); es(in); ecnl();
			end_usage();
		}
	}
	else {
		arg_out_path = out;
	}

	if (argc &gt; 0) {
		arg_save_argv = argv - 1;
		arg_save_argc = argc + 1;
	}
	else {
		arg_save_argv = NULL;
	}
	return MORE_FILES_REMAIN;

}</t>
<t tx="ekr.20080529093004.932">@ End arg_do_arg
@c

#undef debug_arg_do_argv

/*
	Handle the options gotten from arg_dialog().

	The arg_dialog has set all the flag variables and the file paths.
	All that remains is to process arg_def_buf[] and arg_undef_buf[].
*/
#if 0 /* no longer used. */
	void
	arg_do_dialog(void)
	{
		FTAG("arg_do_dialog");
		int  argc;
		char ** argv;
		char * arg, * def;
		int i;

		/*
			Do not put Sherlock macros here: Sherlock has not been initialized!
		*/
		SL_DISABLE();

		/* Do nothing if no input file has been specified.
		if (arg_in_path == NULL) {
			return;
		}

		/*
			Enter predefined names into the macro table.
		*/
		argc = init_arg_parse(&amp;argv, arg_def_buf);
		for (i = 0; i &lt; argc; i++) {

			ASSERT(argv[i] != NULL);
			arg = argv[i];

			/* Scan for an optional equal sign. */
			for (def = arg;	*def; def++) {
				if (*def == '=') {
					*def = '\0';
					def++;
					break;
				}
			}
			mst_init_define(arg, def, TRUE);
		}

		/*
			initially undefine names.
		*/
		argc = init_arg_parse(&amp;argv, arg_undef_buf);
		for (i = 0; i &lt; argc; i++) {

			/* mst_undef_arg will check for null */
			arg = argv[i];
			mst_init_undef(arg);
		}
	}
</t>
<t tx="ekr.20080529093004.933">#endif

/*
	Output a usage message.
*/
static void
arg_help(void)
{

#ifdef PRODUCTION
	es("\nusage: cc2 [options] in out\n");
#else
	es("\nusage: cc2db [++--routine] [options] input_file\n");
#endif

	es("\noptions...\n");
	es("+-bell            Make a bell sound\n");
	es("+-cpp             Output results of cpp\n");
	es("+-cpp_only        Exit after cpp is done\n");
	es("-d id=value       Define a preprocessor constant\n");
	es("+-error           Enable error messages\n");
	es("-exit or quit     Terminate option list\n");
	es("+-d0_only         All functions return value in d0\n");
	es("-f &lt;file&gt;         Use synonym file\n");
	es("+-far_data        Allow more than 32K global data\n");
	es("+-full_ws         Full white space\n");
	es("+-gen_trace       Trace code generation\n");
	es("+-line            #line numbers in cpp output\n");
	es("+-no_gen          Suppress code generation\n");
	es("+-no_local        Suppress local names in assembly\n");
	es("+-no_output       Suppress output, not code generation\n");
	es("+-no_peep         Suppress peephole optimizer\n");
	es("+-note            Enable notes\n");
	es("-of               Specify output file\n");
	es("+-once            Include header files only once\n");
	es("-s &lt;path&gt;         Look for include files in path\n");
	es("-s2&lt;path&gt; &lt;name&gt;  Look for &lt;name&gt; at &lt;path&gt;\n");
	es("-segment &lt;name&gt;   Set the name of the segment\n");
	es("+-trigraph        Translate trigraph sequences\n");
	es("-u id             Undefine a preprocessor constant\n");
	es("+-v               Verbose output\n");
	es("+-v_include       Verbose include messages\n");
	es("+-v_function      Verbose function messages\n");
	es("+-warning         Enable warning messages\n");
	es("-?                Print the version number and exit\n");
}
</t>
<t tx="ekr.20080529093004.934">@ arg_prefix: Return TRUE if string p is a prefix of string s.
@c

static bool
arg_prefix(char *p, char *s)
{
	while (*p) {
		if (*p++ != *s++) {
			return FALSE;
		}
	}
	return TRUE;
}
</t>
<t tx="ekr.20080529093004.935">/*
	CC: application-specific program termination module.

	source:  CCend.c
	started: June 2, 1994.
	version: June 2, 1994.
*/

&lt;&lt; CCend #includes &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.936">#include "CC.h"
#include "CCend.h"
#include &lt;LIBos.h&gt;
</t>
<t tx="ekr.20080529093004.937">@ Close all application files. Do not close the log file.
@c

void
end_close_all(void)
{
	FTAG("end_close_all");
	STATB(ftag);

	io_close(os_bytes_file);
	io_close(os_text_file);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.938">/*
	CC2: Application-specific error handling routines

	Source:  CCerr.c
	Started: November 30, 1990
	Version:
		June 2, 1994.
*/

&lt;&lt; CCerr #includes &gt;&gt;
&lt;&lt; CCerr declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.939">#include "CC.h"

#include "CCerr.h"
#include "CCmem.h"
#include "CCtokens.h"
#include "CCtokize.h"

#include &lt;LIBend.h&gt;

#include &lt;stdlib.h&gt;	/* For abort. */
#include &lt;string.h&gt; /* For strlen. */
</t>
<t tx="ekr.20080529093004.940">/*
	Define global status variables.
*/
long	err_count = 0;				/* Error counts... */
long	err_help = 0;
long	err_fatal = 0;
long	err_warning = 0;
bool	err_err_flag = TRUE;		/* Enable message flags... */
bool	err_fatal_flag = TRUE;
bool	err_help_flag = TRUE;
bool	err_warn_flag = TRUE;
long	err_last_line = -1;			/* Line number of last error. */
long	err_line = 0;				/* Current line number. */
long	err_line_offset = 0;		/* Current line offset. (set by #line) */
int		err_pass = 0;				/* Current pass number. */
bool	err_verbose = FALSE;		/* Verbose flag. */
char *	err_fname = NULL;			/* Current file name. */
char *	err_func_name = NULL;		/* Current function name. */
bool	err_context_flag = FALSE;	/* TRUE: print context of errors. */

/*
	Function prototypes internal routines.
*/
static void	err_begin_mess	(char * message);

/*
	Define internal variables.
*/
static bool 	err_abort_flag = FALSE;
</t>
<t tx="ekr.20080529093004.941">@ Initialize all types used by this module.
@c

void
err_init(void)
{}
</t>
<t tx="ekr.20080529093004.942">@ Initialize all the internal variables declared above.
@c

void
err_init_again(void)
{
	FTAG("err_init_again");
	STATB(ftag);

	err_func_name = NULL;

	err_line = 0;
	err_line_offset = 0;
	err_pass = 0;

	err_count = 0;
	err_help = 0;
	err_warning = 0;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.943">@ Set the file name used in error message. The file name will exist until the end of compile.
@c

void
err_begin_file (char * file_name)
{
	FTAG("err_begin_file");
	static watch_flag = FALSE;
	STATB(ftag);

	/* Allocate the new buffer. */
	new_file_string_macro(err_fname, file_name);

	err_func_name = NULL;
	err_last_line = -1;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.944">void
err_begin_func (char * func_name)
{
	FTAG("err_begin_func");
	STATB(ftag);

	new_file_string_macro(err_func_name, func_name);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.945">@ Output the common start of an error message.
@c

#define F_WIDTH 10

static void
err_begin_mess(char * message)
{
	register char * name = (err_func_name == NULL) ? "" : err_func_name;

	ecnls(2);
	epads(message, 8);
	es(" line: "); epadlong(err_line+err_line_offset, 4); es(" ");
	epads(err_file_name(), 10);
	es(" ("); etrunc(name, F_WIDTH); es(") ");
	epadlen(strlen(name), F_WIDTH);

	/* Put error message on new line. */
	ecnl();
}
</t>
<t tx="ekr.20080529093004.946">@ Return the name of the current file or "(no file)".
@c

char *
err_file_name(void)
{
	if (err_fname == NULL) {
		return "(no file)";
	}
	else {
		return cvt_short_fn(err_fname);
	}
}
</t>
<t tx="ekr.20080529093004.947">@ Print the context of an error, using err_line and err_file_name.
@c

#define CONTEXT_WIDTH 4	/* Width of the line number field. */

void
err_context(void)
{
	SL_DISABLE();
	err_lines(err_line, 2, 2);
}
</t>
<t tx="ekr.20080529093004.948">void
err_lines(long the_line, int lead_context, int trail_context)
{
	FTAG("-err_lines");
	register token *tp = NULL;
	register int lead_lines = 0;
	register int trail_lines = 0;
	register int i = 0;
	long actual_line = 0;
	bool update_save = tok_update_flag;
	STATB(ftag);

	/*
		End the error message with a period and a newline.
		Putting this here makes the error macros shorter.
	*/
	es(".\n");

	/* Careful: there may be no tokens yet. */
	if (!err_context_flag || tok_first_token == NULL) {
		STATX(ftag);
		return;
	}

	/* Disable the updating of line numbers. */
	tok_update_flag = FALSE;

	if (the_line &lt;= 1 || lead_context &lt; 0) {
		lead_lines = 0;
	}
	else if (the_line &lt;= lead_context) {
		lead_lines = the_line - 1;
	}
	else {
		lead_lines = lead_context;
	}
	trail_lines = trail_context;

	/* Bug fix: 3/7/93.
		The scanning of the output happens after the function has been scanned,
		so err_fname is unreliable.
	*/
	tp = tok_scan_file(err_fname, tok_first_token);
	ASSERT(tp != NULL);
	tp = tok_scan_line(tp, the_line - lead_lines, err_fname, &amp;actual_line);

	ASSERT(tok_update_flag == FALSE);

	/* Skip over the newline to which tp points. */
	if (*tp == WS_NL_TOK || *tp == HIDDEN_NL_IN_COMMENT_TOK) {
		next_raw_tok(tp);
	}

	/*
		Before the days of err_line_offset, the actual leading line
		returned by tok_scan_line could be different from the_line - lead_lines.

		Not any more, but leave the code this way to be defensive.
	*/
	lead_lines = the_line - actual_line;

	/* Visually separate the leading lines for error messages. */
	ecnl(); enl();

	/* Print the leading lines. */
	if (lead_lines &gt; 0) {
		for (i = 0; i &lt; lead_lines &amp;&amp; *tp != HIDDEN_END_FILE_TOK; i++) {
			epadlong(the_line + err_line_offset - lead_lines + i, CONTEXT_WIDTH); es(": ");
			tp = tok_dump_line2(tp,
				DONT_PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_USER_TOKENS);
			ecnl();
			next_raw_tok(tp);
		}
	}

	/* Print the "middle" line. */
	epadlong(the_line + err_line_offset, CONTEXT_WIDTH);
	es((lead_context || trail_context) ? "* " : ": ");
	tp = tok_dump_line2(tp,
		DONT_PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_USER_TOKENS);
	enl();
	next_raw_tok(tp);

	/* Print the trailing lines. */
	if (trail_lines &gt; 0) {
		for (i = 0; i &lt; trail_lines &amp;&amp; *tp != HIDDEN_END_FILE_TOK; i++) {
			epadlong(the_line + err_line_offset + 1 + i, CONTEXT_WIDTH); es(": ");
			tp = tok_dump_line2(tp,
				DONT_PRINT_HIDDEN_TOKS, DONT_SPLIT_LONG_LINES, PRINT_USER_TOKENS);
			ecnl();
			next_raw_tok(tp);
		}
	}

	/* Visually separate the trailing lines for error messages. */
	ecnl(); enl();

	/* Restore the previous settings. */
	ASSERT(tok_update_flag == FALSE);
	tok_update_flag = update_save;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.949">@ Minimal test of this module.
@c

void
err_test(void)
{
	FTAG("err_test");
	STATB(ftag);

	ecnl();
	err_begin();	es("error message\n");
	help_begin();	es("explanatory note\n");
	fatal_begin();	es("fatal_begin test: will not really terminate\n");
	warn_begin();	es("warning message\n");

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.950">@ Start an error message.
@c

bool
err_begin(void)
{
	bool result = err_err_flag &amp;&amp; err_last_line != err_line;
	err_count++;
	if (result) {
		err_begin_mess("error:");
	}
	err_last_line = err_line;
	return result;
}
</t>
<t tx="ekr.20080529093004.951">@ Start a fatal error message. User errors should never result in a call to fatal.
@c

void
fatal_begin(void)
{
	/*7/19/93: Abort if we take a fatal error while processing a fatal error. */
	static bool in_fatal = FALSE;

	err_fatal++;
	ecnl(); enl();
	es("Oh Dear...There is something wrong me\n");
	es("in: "); es(current_ftag);
	es(" called from "); es(caller_ftag);
	es(" called from "); es(caller2_ftag);
	enl();

	if (in_fatal) {
		es("Encountered a second fatal error...aborting now!\n");
		end_abort();
		abort();
	}
	in_fatal = TRUE;
	err_begin_mess("oops:"); enl();
}
</t>
<t tx="ekr.20080529093004.952">@ Terminate a fatal error message that was begun with fatal_start.
@c

void
fatal_end(void)
{
	err_context();
	ecnl();
	if (err_fatal_flag) {
		end_abort();
		abort();
	}
}
</t>
<t tx="ekr.20080529093004.953">@ Start a help message.
@c

bool
help_begin(void)
{
	bool result = err_help_flag &amp;&amp; err_last_line != err_line;
	err_help++;
	if (result) {
		err_begin_mess("note:");
	}
	err_last_line = err_line;
	return result;
}
</t>
<t tx="ekr.20080529093004.954">@ Start and end an unrecoverable user error.
@c

void
user_fatal_begin(void)
{
	err_fatal++;
	ecnl();
	err_begin_mess("oops:"); enl();
}
</t>
<t tx="ekr.20080529093004.955">void
user_fatal_end(void)
{
	TRACE("fatal", err_context());
	ecnl();
	if (err_fatal_flag) {
		end_abort();
		abort();
	}
}
</t>
<t tx="ekr.20080529093004.956">@ Formatted warning routines.
@c

bool
warn_begin(void)
{
	bool result = err_warn_flag &amp;&amp; err_last_line != err_line;
	err_warning++;
	if (result) {
		err_begin_mess("warning:");
	}
	err_last_line = err_line;
	return result;
}
</t>
<t tx="ekr.20080529093004.957">/*
	CC2: application-specific version of es routine.
	
	November 30, 1995.
		es_assert_failed and es_internal_err are application-defined.
	November 7, 1995.
		ecblanks, ecnl and ecnls are now defined by the application.
*/

&lt;&lt; CCes #includes &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.958">#include "CC.h"

#include "CCes.h"

#include &lt;LIBes.h&gt;
#include &lt;LIBlog.h&gt;
#include &lt;LIBos.h&gt;
</t>
<t tx="ekr.20080529093004.959">void
es(char * s)
{
	if (s) {
		if (es2os_flag) {
			os(s);
		}
		else {
			log_sout(s);
		}
	}
}
</t>
<t tx="ekr.20080529093004.960">void
ecblanks(short n)
{
	if (es2os_flag) {
		ocblanks(n);
	}
	else {
		log_cblanks(n);
	}
}
</t>
<t tx="ekr.20080529093004.961">void
ecnl(void)
{
	if (es2os_flag) {
		ocnl();
	}
	else {
		log_cnl();
	}
}
</t>
<t tx="ekr.20080529093004.962">void
ecnls(short requested_newlines)
{
	if (es2os_flag) {
		ocnls(requested_newlines);
	}
	else {
		log_cnls(requested_newlines);
	}
}
</t>
<t tx="ekr.20080529093004.963">void
es_assert_failed(char * condition, int line, char * file)
{
	fatal_begin();
	ecnl();
	es("Assert failed: "); es(condition); enl();
	es("line: "); eint(line); es(" file: "); es(file);
}
</t>
<t tx="ekr.20080529093004.964">void
es_internal_err(char * condition, int line, char * file)
{
	fatal_begin();
	ecnl();
	es("Internal error: Assert failed: "); es(condition); enl();
	es("file: "); eint(line); es(" line: "); es(file);
}
</t>
<t tx="ekr.20080529093004.965">/*
	CC: interface to devlib.

	source:  CClib.c
	started: June 2, 1994.
	version: June 2, 1994.
*/

&lt;&lt; CClib #includes &gt;&gt;

	/* Define variables used by devlib. */

pstring	lib_about_title = "\pAbout CC";			/* Must be a pascal string. */
char * lib_log_file_prompt = "CC log file...";	/* Prompt for file name. */

// char * lib_dialog_version = "CC version 1.0:\r\rCopyright ? 1994 by Tuple, Inc.";

char * lib_log_window_name = "CC log";	/* The name of log window. */
char * lib_program_name = "CC";			/* The name of the program. */
bool   lib_stderr_flag = FALSE;			/* TRUE: send log output to stderr on the Mac. */

#if defined(THINK_C)
	char * lib_arg_file_name = "CC2args";	/* The name of the argument file. */
	char * lib_log_file_name = "CC2log";	/* The name of the argument file. */
#elif defined(applec)
	char * lib_arg_file_name = "CC2 MPW args";
	char * lib_log_file_name = "CC2log";	/* The name of the argument file. */
#else
	char * lib_arg_file_name = "CCargs.txt";
	char * lib_log_file_name = "CC2log.txt";	/* The name of the argument file. */
#endif

char * lib_version = "CC version 1.0";
</t>
<t tx="ekr.20080529093004.966">#include &lt;LIBlib.h&gt;
</t>
<t tx="ekr.20080529093004.967">/*
	CC: Application-specific memory management routines

	source:  CCmem.c
	started: June 1, 1994.
	version:
		November 15, 1995.
			Added lib_calloc and lib_free.
		June 2, 1994.
*/

&lt;&lt; CCmem #includes &gt;&gt;
&lt;&lt; CCmem declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.968">#include "CC.h"
#include "CCmem.h"
#include "CCtokens.h"
#include "CCtokize.h"

#include &lt;LIBlib.h&gt;
#include &lt;LIBlist.h&gt;
#include &lt;LIBmem.h&gt;
#include &lt;LIBobj.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.969">/*
	Define the actual lifetimes used in the program.
	Tokens must have a separate lifetime so that only tokens will appear in token blocks.
*/
mem_life * file_life = NULL;	/* Description of file lifetime. */
mem_life * perm_life = NULL;	/* Description of permanent lifetime. */
mem_life * token_life = NULL;	/* Description of token lifetime. */

	/* Parser statistics. */

mem_stat * anode_stats = NULL;
mem_stat * cnode_stats = NULL;
mem_stat * enode_stats = NULL;
mem_stat * macro_stats = NULL;
mem_stat * pnode_stats = NULL;
mem_stat * snode_stats = NULL;
mem_stat * string_node_stats = NULL;
mem_stat * tnode_stats = NULL;
mem_stat * xnode_stats = NULL;

mem_stat * perm_arg_stats = NULL;
mem_stat * perm_anode_stats = NULL;
mem_stat * perm_enode_stats = NULL;
mem_stat * perm_import_stats = NULL;
mem_stat * perm_macro_stats = NULL;
mem_stat * perm_reg_stats = NULL;
mem_stat * perm_snode_stats = NULL;
mem_stat * perm_spell_stats = NULL;
mem_stat * perm_string_stats = NULL;
mem_stat * perm_st_block_stats = NULL;
mem_stat * perm_tnode_stats = NULL;
mem_stat * perm_with_node_stats = NULL;

	/* Preprocessor stats. */

mem_stat * cpp_stats = NULL;
mem_stat * id_token_stats = NULL;
mem_stat * inhibit_stats = NULL;
mem_stat * keyword_spell_stats = NULL;
mem_stat * narg_block_stats = NULL;
mem_stat * ptr_token_stats = NULL;
mem_stat * skip_stats = NULL;
mem_stat * spell_stats = NULL;
mem_stat * string_stats = NULL;
mem_stat * small_token_stats = NULL;
mem_stat * val_token_stats = NULL;

static long mem_max_node_tag = 12;	</t>
<t tx="ekr.20080529093004.970">@ strlen("big blocks:")+1
Application-specific version of calloc. We define yet another level of allocation so we can call the Mac Toolbox directly. Speed is not important at this level: actually reusing memory is _very_ important.  Don't put Sherlock traces here! Sherlock may not have been initialized.
@c

#undef  USE_CALLOC
#define USE_CALLOC

void *
lib_calloc(size_t n1, size_t n2)
{
	FTAG("lib_calloc");
	
	long size = n1 * n2;
	void * result = NULL;
	
	#ifdef USE_CALLOC
		return calloc(n1, n2);
	#else
		result = NewPtr(size);
		if (result) {
			memset(result, 0, size);
		}
		return result;
	#endif
}
</t>
<t tx="ekr.20080529093004.971">void
lib_free (void * p)
{
	#ifdef USE_CALLOC
		free(p);
	#else
		DisposePtr(p);
	#endif
}
</t>
<t tx="ekr.20080529093004.972">@ Make sure about-to-be allocated memory is pristine.
@c

void
mem_check(mem_life * life, ulong size)
{
	FTAG("mem_check");
	STATB(ftag);

	ASSERT(life);
	ASSERT(size);
	ASSERT(life -&gt; mem_avail &gt;= size);
	{
		ulong n = 0;
		char * p = life -&gt; mem_ptr;
		for (n = 0; n &lt; size; n++) {
			ASSERT_TRACE(p[n] == 0, es("corrupted allocation at: "); eptr(p + n));
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.973">@ Allocate a new token block and put an end-block token in the old block.
@c

token *
mem_new_tok_block(token * tp, long tavail)
{
	FTAG("mem_new_tok_block");
	void * new_tp = NULL;
	STATB(ftag);

	ASSERT_TRACE(
		(tavail &gt;= BIG_TOKEN_SIZE &amp;&amp; tavail &lt; MAX_TOKEN_SIZE) ||
		token_life -&gt; mem_ptr == NULL,
		es("tavail: "); elong(tavail);
	);

	TOKIZE_STATS(
		tok_blocks++;
		tok_waste += (tavail - BIG_TOKEN_SIZE);
		tok_number++;
		tok_bigs++;
		tok_end_blocks++;
	);

	/*
		Set the globals for mem_new_block.
		This affects the statistics only.
	*/
	token_life -&gt; mem_ptr = tp;
	token_life -&gt; mem_avail = tavail;

	/*
		Put the end-block token in the old block.
		We can't use put_ptr_tok because it calls this routine!
	*/
	new_tp = mem_new_block(0, token_life);
	*tp++ = HIDDEN_END_BLOCK_TOK;
	* ((char **) tp) = new_tp;

	STATX(ftag);
	return new_tp;
}
</t>
<t tx="ekr.20080529093004.974">@ Copy a string of the indicated length into a block with file lifetime. Do not assume the string ends with a zero byte.
@c

char *
mem_str_copy(char * start, size_t length)
{
	FTAG("mem_str_copy");
	char * result = NULL;
	STATB(ftag);

	ASSERT(file_life);

	new_size_macro(result, length+1, file_life, string_stats);
	
	/* Warning: do not use strncpy here; the string may not be zero terminated! */
	memcpy(result, start, length);
	result[length]='\0';
	
	ASSERT(strlen(result) == length &amp;&amp; file_life -&gt; mem_ptr == result + length + 1);
	
	STATX(ftag);
	return result;
}
</t>
<t tx="ekr.20080529093004.975">/*
	MPW Runtime Library (bridge) Routines.
	
	This file *must* be compiled only with MPW C with -mc68881 option on.
	The -mc68881 option means that 12-byte long double format will be used,
	which is the format created by the DC.X instructions generated by CC2.
	
	It can also be compiled with Think C for use as "bridge" routines.
	In that case, put jumps to these routines in LIBjtab.a.
	
	Source:  LIBrlib.c
	Started: May 11, 1993
	Version:
		August 31, 1994.
			Added _lib_d_nz.
		July 2, 1994.
			Added #include &lt;LIBend.h&gt;
		July 23,1993.
			New pre_add1, pre_sub1, post_add1 and post_add2 routines.
			Reversed order of arguments to add1 and sub1 routines.
			Added _lib_f2d, _lib_d2f
		July 15, 1993.
			Added _lib_cvt_double
		July 12, 1993.
			Rewrote the entire file.
				All arithmetic and relational operators take only long double operands.
				Only conversions to and from long double operands are supplied.
				Names of routines were simplified.
		May 11, 1993.
*/

&lt;&lt; CCrunlib #includes &gt;&gt;
&lt;&lt; CCrunlib declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.976">#include "CC.h"

#include &lt;LIBend.h&gt;
</t>
<t tx="ekr.20080529093004.977">/*
	Check for a use of a NULL pointer.
*/

void _chk_ptr (void * p);
</t>
<t tx="ekr.20080529093004.978">void _chk_ptr (void * p)
{
	if (p == NULL) {
		es("Using a NULL pointer at: "); eptr(p);
		end_abort();
	}
}
</t>
<t tx="ekr.20080529093004.979">@ This routine converts from the CC2 to the MPW calling convention regarding floats.  In cvt.c the prototype of _lib_cvt_double is   int _lib_cvt_double(char *buffer, double d);   When CC2 compiles the call to _lib_cvt_double it will pass a *pointer* to d. Therefore, the prototype for _lib_cvt_double in runlib.c must be   int _lib_cvt_double(char *buffer, double *d); (note: *d instead of d)   WARNING: For this kludge to work, there must be *no* calls in CC2 to MPW library routines that use any kind of float, double or long double arguments.
@c

int _lib_cvt_double(char *buffer, double *d);
int _lib_cvt_double(char *buffer, double *d)
{
	return sprintf(buffer, "%f", *d);
}
</t>
<t tx="ekr.20080529093004.980">@ Move a floating point number.
@c

float * _lib_f_move (float *fp1, float *fp2);
float * _lib_f_move (float *fp1, float *fp2)
{
	*fp2 = *fp1;
	return fp2;
}
</t>
<t tx="ekr.20080529093004.981">double * _lib_d_move (double *dp1, double *dp2);
double * _lib_d_move (double *dp1, double *dp2)
{
	*dp2 = *dp1;
	return dp2;
}
</t>
<t tx="ekr.20080529093004.982">long double * _lib_ld_move (long double *ldp1, long double *ldp2);
long double * _lib_ld_move (long double *ldp1, long double *ldp2)
{
	*ldp2 = *ldp1;
	return ldp2;
}
</t>
<t tx="ekr.20080529093004.983">@ Conversion operators.
@c

float * _lib_d2f (double * dp, float * fp);
float * _lib_d2f (double * dp, float * fp)
{
	*fp = *dp;
	return fp;
}
</t>
<t tx="ekr.20080529093004.984">long _lib_d2l (double * dp);
long _lib_d2l (double * dp)
{
	return (long) (*dp);
}
</t>
<t tx="ekr.20080529093004.985">long double * _lib_d2ld (double * dp, long double * ldp);
long double * _lib_d2ld (double * dp, long double * ldp)
{
	*ldp = *dp;
	return ldp;
}
</t>
<t tx="ekr.20080529093004.986">double * _lib_f2d (float * fp, double * dp);
double * _lib_f2d (float * fp, double * dp)
{
	*dp = *fp;
	return dp;
}
</t>
<t tx="ekr.20080529093004.987">long _lib_f2l (float * fp);
long _lib_f2l (float * fp)
{
	return (long) (*fp);
}
</t>
<t tx="ekr.20080529093004.988">long double * _lib_f2ld (float * fp, long double * ldp);
long double * _lib_f2ld (float * fp, long double * ldp)
{
	*ldp = *fp;
	return ldp;
}
</t>
<t tx="ekr.20080529093004.989">double * _lib_l2d (long l, double * dp);
double * _lib_l2d (long l, double * dp)
{
	*dp = l;
	return dp;
}
</t>
<t tx="ekr.20080529093004.990">float * _lib_l2f (long l, float * fp);
float * _lib_l2f (long l, float * fp)
{
	*fp = l;
	return fp;
}
</t>
<t tx="ekr.20080529093004.991">long double * _lib_l2ld (long l, long double * ldp);
long double * _lib_l2ld (long l, long double * ldp)
{
	*ldp = l;
	return ldp;
}
</t>
<t tx="ekr.20080529093004.992">double * _lib_ld2d (long double * ldp, double * dp);
double * _lib_ld2d (long double * ldp, double * dp)
{
	*dp = *ldp;
	return dp;
}
</t>
<t tx="ekr.20080529093004.993">float * _lib_ld2f (long double * ld, float * fp);
float * _lib_ld2f (long double * ld, float * fp)
{
	*fp = *ld;
	return fp;
}
</t>
<t tx="ekr.20080529093004.994">long _lib_ld2l (long double * ldp);
long _lib_ld2l (long double * ldp)
{
	return (long) (*ldp);
}
</t>
<t tx="ekr.20080529093004.995">@ Arithmetic operators. All floating arithmetic is done in extended (long double) length.
@c

long double * _lib_ld_add (long double * result, long double * ldp1, long double * ldp2);
long double * _lib_ld_add (long double * result, long double * ldp1, long double * ldp2)
{
	*result = (*ldp2) + (*ldp1);
	return result;
}
</t>
<t tx="ekr.20080529093004.996">float * _lib_f_pre_add1 (float * fp, float * result);
float * _lib_f_pre_add1 (float * fp, float * result)
{
	*fp = (*fp) + ((float) 1.0);
	*result = *fp;
	return result;
}
</t>
<t tx="ekr.20080529093004.997">float * _lib_f_post_add1 (float * fp, float * result);
float * _lib_f_post_add1 (float * fp, float * result)
{
	*result = *fp;
	*fp = (*fp) + ((float) 1.0);
	return result;
}
</t>
<t tx="ekr.20080529093004.998">double * _lib_d_pre_add1 (double * dp, double * result);
double * _lib_d_pre_add1 (double * dp, double * result)
{
	*dp = (*dp) + ((double) 1.0);
	*result = *dp;
	return result;
}
</t>
<t tx="ekr.20080529093004.999">double * _lib_d_post_add1 (double * dp, double * result);
double * _lib_d_post_add1 (double * dp, double * result)
{
	*result = *dp;
	*dp = (*dp) + ((double) 1.0);
	return result;
}
</t>
<t tx="ekr.20080529093004.1000">long double * _lib_ld_pre_add1 (long double * ldp, long double * result);
long double * _lib_ld_pre_add1 (long double * ldp, long double * result)
{
	*ldp = (*ldp) + ((long double) 1.0);
	*result = *ldp;
	return result;
}
</t>
<t tx="ekr.20080529093004.1001">long double * _lib_ld_post_add1 (long double * ldp, long double * result);
long double * _lib_ld_post_add1 (long double * ldp, long double * result)
{
	*result = *ldp;
	*ldp = (*ldp) + ((long double) 1.0);
	return result;
}
</t>
<t tx="ekr.20080529093004.1002">long double * _lib_ld_div (long double * result, long double * ldp1, long double * ldp2);
long double * _lib_ld_div (long double * result, long double * ldp1, long double * ldp2)
{
	/* The order of operands is like the DIVS instruction. */
	*result = (*ldp2) / (*ldp1);
	return result;
}
</t>
<t tx="ekr.20080529093004.1003">long double * _lib_ld_mul (long double * result, long double * ldp1, long double * ldp2);
long double * _lib_ld_mul (long double * result, long double * ldp1, long double * ldp2)
{
	*result = (*ldp1) * (*ldp2);
	return result;
}
</t>
<t tx="ekr.20080529093004.1004">long double * _lib_ld_neg (long double * result, long double * ldp);
long double * _lib_ld_neg (long double * result, long double * ldp)
{
	*result = - (*ldp);
	return result;
}
</t>
<t tx="ekr.20080529093004.1005">long double * _lib_ld_sub (long double * result, long double * ldp1, long double * ldp2);
long double * _lib_ld_sub (long double * result, long double * ldp1, long double * ldp2)
{
	/* The order of operands is like the SUB instruction. */
	*result = (*ldp2) - (*ldp1);
	return result;
}
</t>
<t tx="ekr.20080529093004.1006">float * _lib_f_pre_sub1 (float * fp, float * result);
float * _lib_f_pre_sub1 (float * fp, float * result)
{
	*fp = (*fp) - ((float) 1.0);
	*result = *fp;
	return result;
}
</t>
<t tx="ekr.20080529093004.1007">float * _lib_f_post_sub1 (float * fp, float * result);
float * _lib_f_post_sub1 (float * fp, float * result)
{
	*result = *fp;
	*fp = (*fp) - ((float) 1.0);
	return result;
}
</t>
<t tx="ekr.20080529093004.1008">double * _lib_d_pre_sub1 (double * dp, double * result);
double * _lib_d_pre_sub1 (double * dp, double * result)
{
	*dp = (*dp) - ((double) 1.0);
	*result = *dp;
	return result;
}
</t>
<t tx="ekr.20080529093004.1009">double * _lib_d_post_sub1 (double * dp, double * result);
double * _lib_d_post_sub1 (double * dp, double * result)
{
	*result = *dp;
	*dp = (*dp) - ((double) 1.0);
	return result;
}
</t>
<t tx="ekr.20080529093004.1010">long double * _lib_ld_pre_sub1 (long double * ldp, long double * result);
long double * _lib_ld_pre_sub1 (long double * ldp, long double * result)
{
	*ldp = (*ldp) - ((long double) 1.0);
	*result = *ldp;
	return result;
}
</t>
<t tx="ekr.20080529093004.1011">long double * _lib_ld_post_sub1 (long double * ldp, long double * result);
long double * _lib_ld_post_sub1 (long double * ldp, long double * result)
{
	*result = *ldp;
	*ldp = (*ldp) - ((long double) 1.0);
	return result;
}
</t>
<t tx="ekr.20080529093004.1012">@ Relational operators.
@c

long _lib_d_nz (double * dp);
long _lib_d_nz (double * dp)
{
	return *dp != 0.0;
}
</t>
<t tx="ekr.20080529093004.1013">long _lib_ld_eq (long double * ldp1, long double * ldp2);
long _lib_ld_eq (long double * ldp1, long double * ldp2)
{
	return *ldp1 == *ldp2;
}
</t>
<t tx="ekr.20080529093004.1014">long _lib_ld_ge (long double * ldp1, long double * ldp2);
long _lib_ld_ge (long double * ldp1, long double * ldp2)
{
	return *ldp1 &gt;= *ldp2;
}
</t>
<t tx="ekr.20080529093004.1015">long _lib_ld_gt (long double * ldp1, long double * ldp2);
long _lib_ld_gt (long double * ldp1, long double * ldp2)
{
	return *ldp1 &gt; *ldp2;
}
</t>
<t tx="ekr.20080529093004.1016">long _lib_ld_le (long double * ldp1, long double * ldp2);
long _lib_ld_le (long double * ldp1, long double * ldp2)
{
	return *ldp1 &lt;= *ldp2;
}
</t>
<t tx="ekr.20080529093004.1017">long _lib_ld_lt (long double * ldp1, long double * ldp2);
long _lib_ld_lt (long double * ldp1, long double * ldp2)
{
	return *ldp1 &lt; *ldp2;
}
</t>
<t tx="ekr.20080529093004.1018">long _lib_ld_ne (long double * ldp1, long double * ldp2);
long _lib_ld_ne (long double * ldp1, long double * ldp2)
{
	return *ldp1 != *ldp2;
}
</t>
<t tx="ekr.20080529093004.1019">long _lib_ld_nz (long double * ldp);
long _lib_ld_nz (long double * ldp)
{
	return *ldp != 0.0;
}
</t>
<t tx="ekr.20080529093004.1020"></t>
<t tx="ekr.20080529093004.1021">/*
	Tests of floating point routines called from CC2.
	
	source:  CCfloat_test.c.
	version: January 9, 1996.
*/

&lt;&lt; CCfloat_test #includes &gt;&gt;
&lt;&lt; CCfloat_test declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1022">#include "CC.h"
#include &lt;LIBes.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
</t>
<t tx="ekr.20080529093004.1023">static double test	(double d);
static double test2	(double d);

void tuple_float_test(void);
</t>
<t tx="ekr.20080529093004.1024">void tuple_float_test(void)
{
	double d = 78.6;
	
	es("\nStart of Tuple float test\n\n");
	
	#if 1 // minimal test
	
		es("d += 1.0; d = ");
		d += 1.0;
		edouble(d); enl();
	
	#else
	
		es("edouble(5.6)...");
		edouble(5.6); enl();
	
		d = test(2.2);
		ecnl();
		es("test(2.2) returns "); edouble(d); enl();
		
	#endif
		
	es("\nEnd of Tuple float test.\n\n");
}
</t>
<t tx="ekr.20080529093004.1025">static double
test(double x3)
{
	int n = 3;
	double x = 5.0;
	double x1 = 15.0;
	double x2 = 9.99;
	double * xp = &amp;x;
	static double fac[] = {0, 1e8, 1e16, 1e24, 1e32};
	
	ecnl();
	es("Enter test.  x3 = "); edouble(x3); enl();
		
	es("x3 = 3.0; x3 = ");
	x3 = 3.0;
	edouble(x3); enl();
	
	es("x2 = *xp;  x2 = ");
	x2 = *xp;
	edouble(x2); enl();
	
	{
		long lo[20];
		int i;
		lo[5] = 78.5;
		
		es("x += fac[n] * (double)lo[5];  x = ");
		x += fac[n] * (double)lo[5];
		edouble(x); enl();
	}
	
	{
		es("x = 5.6; x = ");
		x = 5.6;
		edouble(x); enl();
		
		es("xp = &amp;x; xp = ");
		xp = &amp;x;
		eptr(xp); enl();
		
		es("x2 = *xp; x2 = ");
		x2 = *xp;
		edouble(x2); enl();
		
		es("x = fac[n]; x = ");
		x = fac[n];
		edouble(x); enl();
		
		es("x2 += 1.0; x2 = ");
		x2 += 1.0;
		edouble(x2); enl();
	}
	
	es("x3 = x2 * x1; x3 = ");
	x3 = x2 * x1; edouble(x3); enl();

	es("x1 = test2(999.0); x1 = ");
	x1 = test2(999.0); edouble(x1); enl();
	
	{
		x1 = 55.0; es("x1 == 55.0"); enl();
		n = 3; es("n = 3"); enl();

		es("x3 = x2 / x1; x3 = ");
		x3 = x2 / x1;
		edouble(x3); enl();
		
		es("x3 = 5 * x1; x3 = ");
		x3 = 5 * x1;
		edouble(x3); enl();
		
		es("x3 = x2 / 6; x3 = ");
		x3 = x2 / 6;
		edouble(x3); enl();
		
		es("x3 = n * x1; x3 = ");
		x3 = n * x1;
		edouble(x3); enl();
		
		es("x3 = x2 / n; x3 = ");
		x3 = x2 / n;
		edouble(x3); enl();
	}
	
	{
		char * end_ptr = NULL;
		double d;

		es("strtod(\"1.1\", &amp;end_ptr) = ");
		d = strtod("1.1", &amp;end_ptr);
		edouble(d); enl();
	}
	
	{
		double d0 = (double) 1;
		double d1 = (double) (5 * 6);
		double d2 = 1.0 * 2.0;
		double d3 = (double) (1.0 - 2.0);
		double d4 = (double) (2.0 * 3.0);
		double d5 = (double) (10.0 / 5.0);
		
		double * pint = &amp;d0;
		
		int i;
		
		es("i = 1.0 &lt; 2.0; i = ");
		i = (1.0 &lt; 2.0);
		eint(i); enl();
		
		es("test done.  returns: ");
		if (i) {
			edouble(x - *pint);
		}
		else {
			edouble(x3);
		}
		enl();
			
		return i ? (x - *pint) : x3;
	}
}
</t>
<t tx="ekr.20080529093004.1026">double
test2 (double d)
{
	ecnl(); es("test2.  d = "); edouble(d); enl();
	es("returns d + 5.0 = "); edouble(d + 5.0); enl();

	return d + 5.0;
}
</t>
<t tx="ekr.20080529093004.1027">/*
	Tests of StdClib called from Tuple version of CC2.
	Warning: This can *not* be compiled from Think C because
	it uses StdClib headers that are also used by Think C.
	
	source: CCstdclib_test.c
	started: July 12, 1994.
	version: January 9, 1995.
*/

&lt;&lt; CCstdclib_test #includes &gt;&gt;
&lt;&lt; CCstdclib_test declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1028">#include "CC.h"
</t>
<t tx="ekr.20080529093004.1029">#undef NDEBUG
#include &lt;assert.h&gt;
#include &lt;ctype.h&gt;
#include &lt;errno.h&gt;
#include &lt;float.h&gt;
#include &lt;limits.h&gt;
#include &lt;locale.h&gt;
#include &lt;math.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

static	void ekr_test	(void);

static	void print				(long double ld);
static	void print_double		(double d);
static	void print_float		(float f);
static	void print_long_double	(long double d);
static	void print_short_hex	(short * p, int n);

extern	void _print_free_list(void);	/* Defined in alloc.c */

static	void test_alloc (void);
static	int test_assert	(void);
static	int test_ctype	(void);
static	int test_errno	(void);
static	int test_float	(void);
static	int test_limits	(void);
static	int test_locale	(void);
static	int test_math1	(void);
static	int test_math2	(void);
static	int test_math3	(void);
static	int test_setjmp	(void);
static	int test_signal	(void);
static	int test_stdarg	(void);
static	int test_stddef	(void);
static	int test_stdio1	(void);
static	int test_stdio2	(void);
static	int test_stdlib	(void);
static	int test_string	(void);
static	int test_time	(void);

void tuple_stdclib_test(void);
</t>
<t tx="ekr.20080529093004.1030">void
tuple_stdclib_test(void)
{

	TRACEP("ekr_test",		ekr_test());

	TRACEP("test_alloc",	test_alloc());
	TRACEP("test_ctype",	test_ctype());
	TRACEP("test_errno",	test_errno());
	TRACEP("test_limits",	test_limits());
	TRACEP("test_float",	test_float());	
	TRACEP("test_locale",	test_locale());
	TRACEP("test_stddef",	test_stddef());
	TRACEP("test_stdlib",	test_stdlib());
	TRACEP("test_string",	test_string());
	TRACEP("test_time",		test_time());
	
	TRACEP("test_stdarg",	test_stdarg());
	
	TRACEP("test_stdio1",	test_stdio1());
	TRACEP("test_stdio2",	test_stdio2());
	
	TRACEP("test_math1",	test_math1());
	TRACEP("test_math2",	test_math2());
	TRACEP("test_math3",	test_math3());
	
	TRACEP("test_assert",	test_assert());	// Will abort if successful.
	TRACEP("test_signal",	test_signal());	// Will abort if successful.

	TRACEP("test_setjmp",	test_setjmp()); // Not ready yet
}
</t>
<t tx="ekr.20080529093004.1031">static void
print(long double ld)
{
	printf("\n");
	// print_float(ld);
	fflush(stdout);
	print_double(ld);
	fflush(stdout);
	// print_long_double(ld);
	fflush(stdout);
}
</t>
<t tx="ekr.20080529093004.1032">static void
print_float(float f)
{
	short * fp = (short *) &amp;f;
	printf("float %f\n", f);
	print_short_hex(fp, 2);
}
</t>
<t tx="ekr.20080529093004.1033">static void
print_double(double d)
{
	short * dp = (short *) &amp;d;
	printf("double %f\n", d);
	print_short_hex(dp, 4);
}
</t>
<t tx="ekr.20080529093004.1034">static void
print_long_double(long double ld)
{
	short * ldp = (short *) &amp;ld;
	printf("long double %Lf\n", ld);
	print_short_hex(ldp, 5);
}
</t>
<t tx="ekr.20080529093004.1035">static void
print_short_hex(short * p, int n)
{
	int i;
	for (i = 0; i &lt; n; i++) {
		printf("%04hx ", p[i]);
	}
	printf("\n");
	fflush(stdout);
}
</t>
<t tx="ekr.20080529093004.1036">static void
ekr_test(void)
{
	fprintf(stderr, "This is a test of stderr\n");
	fprintf(stdout, "This is a test of stdout\n");
	
	printf("sizeof(long double) = %ld, sizeof(double) = %ld\n\n",
		sizeof(long double), sizeof(double));
		
	{
		int i;
		union {
			short fs [2];
			float f;
		} u;
		short s[2] = { 126 &lt;&lt; 7, 0 };
		for (i = 0; i &lt; 2; i++) {
			u.fs[i] = s[i];
		}
		print_float (u.f);
	}

	/* Look at actual bit patterns. */
	
	print(0.25);
	print(0.5);
	print(1.0);
	print(2.0);
	print(4.0);
}
</t>
<t tx="ekr.20080529093004.1037">@ A test to see whether obj_free_db really is freeing memory.
@c

#define MAX_I 8
#define MAX_J 500

#define request(i, j) ((100 * i * j) + 23)

static void
test_alloc (void)
{
	register int i = 0, j = 0;
	register void ** p = NULL;
	int success = 0;
	unsigned long total = 0;

	fprintf(stderr, "\nstart of allocation test\n\n");
	
	p = calloc(1, MAX_J * sizeof(void *));

	/* Start loops at 1 so we do not request 0 bytes. */
	for (i = 1; i &lt; MAX_I; i++) {

		total = 0;
		success = MAX_J;
	
		for (j = 1; j &lt; MAX_J; j++) {
			p [j] = malloc(request(i,j));
			if (p[j]) {
				total += request(i,j);
			}
			fprintf(stderr,
				"malloc(%5d) returns: %p, i:%3d, j:%3d, total: %6d\n",
				request(i,j), p[j], i, j, total);
			if (p[j] == NULL) {
				success = j - 1;
				break;
			}
		}
		
		for (j = 1; j &lt;= success; j++) {
			free(p [j]);
		}
		
		_print_free_list();

		fprintf(stderr, "End of iteration %d\n", i);
		
		if (success &lt;= 1) {
			break;
		}
	}
	
	free(p);

	fprintf(stderr, "Allocation test complete\n\n");
}
</t>
<t tx="ekr.20080529093004.1038">@ test assert macro
@c

/* static data */
static int val = 0;

/* handle SIGABRT */

static void field_abort(int sig);

static void
field_abort(int sig)
{
if (val == 1)
{	/* expected result */
puts("SUCCESS testing &lt;assert.h&gt;");
exit(EXIT_SUCCESS);
}
else
{	/* unexpected result */
puts("FAILURE testing &lt;assert.h&gt;");
exit(EXIT_FAILURE);
}
}
</t>
<t tx="ekr.20080529093004.1039">static void dummy(void);

static void
dummy(void)
{
	int i = 0;
	assert(i == 0);
	assert(i == 1);
}
</t>
<t tx="ekr.20080529093004.1040">static int
test_assert(void)
{	
	/* EKR: prepare for an abort.  When we abort below we will execute field_abort. */

	assert(signal(SIGABRT, &amp;field_abort) != SIG_ERR);
	dummy();
	assert(val == 0);	/* should not abort */
	++val;
	fputs("Sample assertion failure message --\n", stderr);
	assert(val == 0);	/* should abort */

	puts("FAILURE testing &lt;assert.h&gt;");
	return (EXIT_FAILURE);
}
</t>
<t tx="ekr.20080529093004.1041">@ test ctype functions and macros
display a printable character class
@c

static void prclass(const char *name, int (*fn)(int));
static void
prclass(const char *name, int (*fn)(int))
{
	int c;

	fputs(name, stdout);
	fputs(": ", stdout);
	for (c = EOF; c &lt;= UCHAR_MAX; ++c)
		if ((*fn)(c))
			fputc(c, stdout);
	fputs("\n", stdout);
}
</t>
<t tx="ekr.20080529093004.1042">static int
test_ctype(void)
{	
	char *s;
	int c;

	/* display printable classes */
	prclass("ispunct", &amp;ispunct);
	prclass("isdigit", &amp;isdigit);
	prclass("islower", &amp;islower);
	prclass("isupper", &amp;isupper);
	prclass("isalpha", &amp;isalpha);
	prclass("isalnum", &amp;isalnum);

	/* test macros for required characters */
	for (s = "0123456789"; *s; ++s)
		assert(isdigit(*s) &amp;&amp; isxdigit(*s));
	for (s = "abcdefABCDEF"; *s; ++s)
		assert(isxdigit(*s));
	for (s = "abcdefghijklmnopqrstuvwxyz"; *s; ++s)
		assert(islower(*s));
	for (s = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; *s; ++s)
		assert(isupper(*s));
	for (s = "!\"#%&amp;'();&lt;=&gt;?[\\]*+,-./:^_{|}~"; *s; ++s)
		assert(ispunct(*s));
	for (s = "\f\n\r\t\v"; *s; ++s)
		assert(isspace(*s) &amp;&amp; iscntrl(*s));

	assert(isspace(' ') &amp;&amp; isprint(' '));
	assert(iscntrl('\a') &amp;&amp; iscntrl('\b'));
	
	/* test macros for all valid codes */
	for (c = EOF; c &lt;= UCHAR_MAX; ++c)
	{	/* test for proper class membership */
		if (isdigit(c))
			assert(isalnum(c));
		if (isupper(c))
			assert(isalpha(c));
		if (islower(c))
			assert(isalpha(c));
		if (isalpha(c))
			assert(isalnum(c) &amp;&amp; !isdigit(c));
		if (isalnum(c))
			assert(isgraph(c) &amp;&amp; !ispunct(c));
		if (ispunct(c))
			assert(isgraph(c));
		if (isgraph(c))
			assert(isprint(c));
		if (isspace(c))
			assert(c == ' ' || !isprint(c));
		if (iscntrl(c))
			assert(!isalnum(c));
	}

	/* test functions for required characters */
	for (s = "0123456789"; *s; ++s)
		assert((isdigit)(*s) &amp;&amp; (isxdigit)(*s));
	for (s = "abcdefABCDEF"; *s; ++s)
		assert((isxdigit)(*s));
	for (s = "abcdefghijklmnopqrstuvwxyz"; *s; ++s)
		assert((islower)(*s));
	for (s = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; *s; ++s)
		assert((isupper)(*s));
	for (s = "!\"#%&amp;'();&lt;=&gt;?[\\]*+,-./:^_{|}~"; *s; ++s)
		assert((ispunct)(*s));
	for (s = "\f\n\r\t\v"; *s; ++s)
		assert((isspace)(*s) &amp;&amp; (iscntrl)(*s));

	assert((isspace)(' ') &amp;&amp; (isprint)(' '));
	assert((iscntrl)('\a') &amp;&amp; (iscntrl)('\b'));
	
	/* test functions for all valid codes */
	for (c = EOF; c &lt;= UCHAR_MAX; ++c)
	{	/* test for proper class membership */
		if ((isdigit)(c))
			assert((isalnum)(c));
		if ((isupper)(c))
			assert((isalpha)(c));
		if ((islower)(c))
			assert((isalpha)(c));
		if ((isalpha)(c))
			assert((isalnum)(c) &amp;&amp; !(isdigit)(c));
		if (isalnum(c))
			assert((isgraph)(c) &amp;&amp; !(ispunct)(c));
		if ((ispunct)(c))
			assert((isgraph)(c));
		if ((isgraph)(c))
			assert((isprint)(c));
		if ((isspace)(c))
			assert(c == ' ' || !(isprint)(c));
		if ((iscntrl)(c))
			assert(!(isalnum)(c));
	}

	puts("SUCCESS testing &lt;ctype.h&gt;");
	return (0);
}
</t>
<t tx="ekr.20080529093004.1043">static int
test_errno(void)
{
	assert(errno == 0);
	perror("No error reported as");
	errno = ERANGE;
	assert(errno == ERANGE);
	perror("Range error reported as");
	errno = 0;
	assert(errno == 0);
	sqrt(-1.0);
	assert(errno == EDOM);
	perror("Domain error reported as");

	puts("SUCCESS testing &lt;errno.h&gt;");
	return (0);
}
</t>
<t tx="ekr.20080529093004.1044">static int
test_float(void)
{
	double radlog;
	int digs;
	static int radix = FLT_RADIX;

	printf("FLT_RADIX = %i\n\n", FLT_RADIX);

	printf("DBL_DIG        = %5i, DBL_MANT_DIG = %6i\n", DBL_DIG, DBL_MANT_DIG);
	printf("DBL_MAX_10_EXP = %5i, DBL_MAX_EXP  = %6i\n", DBL_MAX_10_EXP, DBL_MAX_EXP);
	printf("DBL_MIN_10_EXP = %5i, DBL_MIN_EXP  = %6i\n\n", DBL_MIN_10_EXP, DBL_MIN_EXP);

	printf(" DBL_EPSILON = %le\n",   DBL_EPSILON);
	printf(" DBL_MAX     = %le\n",   DBL_MAX);
	printf(" DBL_MIN     = %le\n\n", DBL_MIN);

	printf("FLT_DIG        = %5i, FLT_MANT_DIG = %6i\n", FLT_DIG, FLT_MANT_DIG);
	printf("FLT_MAX_10_EXP = %5i, FLT_MAX_EXP  = %6i\n", FLT_MAX_10_EXP, FLT_MAX_EXP);
	printf("FLT_MIN_10_EXP = %5i, FLT_MIN_EXP  = %6i\n\n", FLT_MIN_10_EXP, FLT_MIN_EXP);

	printf("  FLT_EPSILON = %e\n",   FLT_EPSILON);
	printf("  FLT_MAX     = %e\n",   FLT_MAX);
	printf("  FLT_MIN     = %e\n\n", FLT_MIN);
	
	printf("LDBL_DIG        = %5i, LDBL_MANT_DIG = %6i\n", LDBL_DIG, LDBL_MANT_DIG);
	printf("LDBL_MAX_10_EXP = %5i  LDBL_MAX_EXP =  %6i\n", LDBL_MAX_10_EXP, LDBL_MAX_EXP);
	printf("LDBL_MIN_10_EXP = %5i  LDBL_MIN_EXP =  %6i\n\n", LDBL_MIN_10_EXP, LDBL_MIN_EXP);

	printf("  LDBL_EPSILON = %Le\n", LDBL_EPSILON);
	printf("  LDBL_MAX     = %Le\n", LDBL_MAX);
	printf("  LDBL_MIN     = %Le\n\n", LDBL_MIN);
	
	radlog = log10(radix);

	/* test double properties */

	assert(10 &lt;= DBL_DIG &amp;&amp; FLT_DIG &lt;= DBL_DIG);
	assert(DBL_EPSILON &lt;= 1e-9);

	digs = DBL_MANT_DIG * radlog;

	assert(digs &lt;= DBL_DIG &amp;&amp; DBL_DIG &lt;= digs + 1);
	assert(1e37 &lt;= DBL_MAX);
	assert(37 &lt;= DBL_MAX_10_EXP);

	#if FLT_RADIX == 2
		assert(ldexp(1.0, DBL_MAX_EXP - 1) &lt; DBL_MAX);
		assert(ldexp(1.0, DBL_MIN_EXP - 1) == DBL_MIN);
	#endif

	assert(DBL_MIN &lt;= 1e-37);
	assert(DBL_MIN_10_EXP &lt;= -37);

	/* test float properties */
		
	assert(6 &lt;= FLT_DIG);
	assert(FLT_EPSILON &lt;= 1e-5);
	

	digs = FLT_MANT_DIG * radlog;
	assert(digs &lt;= FLT_DIG &amp;&amp; FLT_DIG &lt;= digs + 1);
	assert(1e37 &lt;= FLT_MAX);
	assert(37 &lt;= FLT_MAX_10_EXP);

	#if FLT_RADIX == 2
		assert(ldexp(1.0, FLT_MAX_EXP - 1) &lt; FLT_MAX);
		assert(ldexp(1.0, FLT_MIN_EXP - 1) == FLT_MIN);
	#endif

	assert(FLT_MIN &lt;= 1e-37);
	assert(FLT_MIN_10_EXP &lt;= -37);
	
	/* test unversal properties */
		
#if FLT_RADIX &lt; 2
#error bad FLT_RADIX
#endif

	assert(-1 &lt;= FLT_ROUNDS &amp;&amp; FLT_ROUNDS &lt;= 3);
	
	/* test long double properties */

	assert(10 &lt;= LDBL_DIG &amp;&amp; DBL_DIG &lt;= LDBL_DIG);
	assert(LDBL_EPSILON &lt;= 1e-9);

	digs = LDBL_MANT_DIG * radlog;
	assert(digs &lt;= LDBL_DIG &amp;&amp; LDBL_DIG &lt;= digs + 1);
	assert(1e37 &lt;= LDBL_MAX);
	assert(37 &lt;= LDBL_MAX_10_EXP);

	#if FLT_RADIX == 2
		assert(DBL_MAX_EXP &lt; LDBL_MAX_EXP
			|| ldexp(1.0, LDBL_MAX_EXP - 1) &lt; LDBL_MAX);
		assert(LDBL_MIN_EXP &lt; DBL_MIN_EXP
			|| ldexp(1.0, LDBL_MIN_EXP - 1) == LDBL_MIN);
	#endif

	assert(LDBL_MIN &lt;= 1e-37);
	assert(LDBL_MIN_10_EXP &lt;= -37);

	puts("SUCCESS testing &lt;float.h&gt;");
	return (0);
}
</t>
<t tx="ekr.20080529093004.1045">static int
test_limits(void)
{
	printf("CHAR_BIT = %2i   MB_LEN_MAX = %2i\n\n", CHAR_BIT, MB_LEN_MAX);

	printf(" CHAR_MAX = %10i, CHAR_MIN  = %10i\n", CHAR_MAX, CHAR_MIN);
	printf("SCHAR_MAX = %10i, SCHAR_MIN = %10i\n", SCHAR_MAX, SCHAR_MIN);
	printf("UCHAR_MAX = %10u\n\n", UCHAR_MAX);
	
	printf(" SHRT_MAX = %10i, SHRT_MIN  = %10i\n", SHRT_MAX, SHRT_MIN);
	printf("USHRT_MAX = %10u\n\n", USHRT_MAX);

	printf("  INT_MAX = %10i, INT_MIN   = %10i\n", INT_MAX, INT_MIN);
	printf(" UINT_MAX = %10u\n\n", UINT_MAX);

	printf(" LONG_MAX = %10li, LONG_MIN  = %10li\n", LONG_MAX, LONG_MIN);
	printf("ULONG_MAX = %10lu\n", ULONG_MAX);
	
#if UINT_MAX / 2 &lt; INT_MAX
	#error bad unsigned int properties2
#endif

#if UINT_MAX &lt; USHRT_MAX
	#error bad unsigned int properties3
#endif

#if UINT_MAX &lt; 65535
	#error bad unsigned int properties1
#endif
	
#if CHAR_BIT &lt; 8 || CHAR_MAX &lt; 127 || 0 &lt; CHAR_MIN || \
	CHAR_MAX != SCHAR_MAX &amp;&amp; CHAR_MAX != UCHAR_MAX
	#error bad char properties
#endif

#if INT_MAX &lt; 32767 || -32767 &lt; INT_MIN || INT_MAX &lt; SHRT_MAX
	#error bad int properties
#endif

#if LONG_MAX &lt; 2147483647 || -2147483647 &lt; LONG_MIN || LONG_MAX &lt; INT_MAX
	#error bad long properties
#endif

#if MB_LEN_MAX &lt; 1
	#error bad MB_LEN_MAX
#endif

#if SCHAR_MAX &lt; 127 || -127 &lt; SCHAR_MIN
	#error bad signed char properties
#endif

#if SHRT_MAX &lt; 32767 || -32767 &lt; SHRT_MIN || SHRT_MAX &lt; SCHAR_MAX
	#error bad short properties
#endif

#if UCHAR_MAX &lt; 255 || UCHAR_MAX / 2 &lt; SCHAR_MAX
	#error bad unsigned char properties
#endif

#if ULONG_MAX &lt; 4294967295 || ULONG_MAX / 2 &lt; LONG_MAX || ULONG_MAX &lt; UINT_MAX
#endif

#if USHRT_MAX &lt; 65535 || USHRT_MAX / 2 &lt; SHRT_MAX || USHRT_MAX &lt; UCHAR_MAX
	#error bad unsigned short properties
#endif

	puts("SUCCESS testing &lt;limits.h&gt;");
	return (0);
}
</t>
<t tx="ekr.20080529093004.1046">static void testclocale(struct lconv *p);
static void
testclocale(struct lconv *p)
{
	assert(strcmp(p-&gt;currency_symbol, "") == 0);
	assert(strcmp(p-&gt;decimal_point, ".") == 0);
	assert(strcmp(p-&gt;grouping, "") == 0);
	assert(strcmp(p-&gt;int_curr_symbol, "") == 0);
	assert(strcmp(p-&gt;mon_decimal_point, "") == 0);
	assert(strcmp(p-&gt;mon_grouping, "") == 0);
	assert(strcmp(p-&gt;mon_thousands_sep, "") == 0);
	assert(strcmp(p-&gt;negative_sign, "") == 0);
	assert(strcmp(p-&gt;positive_sign, "") == 0);
	assert(strcmp(p-&gt;thousands_sep, "") == 0);
	assert(p-&gt;frac_digits == CHAR_MAX);
	assert(p-&gt;int_frac_digits == CHAR_MAX);
	assert(p-&gt;n_cs_precedes == CHAR_MAX);
	assert(p-&gt;n_sep_by_space == CHAR_MAX);
	assert(p-&gt;n_sign_posn == CHAR_MAX);
	assert(p-&gt;p_cs_precedes == CHAR_MAX);
	assert(p-&gt;p_sep_by_space == CHAR_MAX);
	assert(p-&gt;p_sign_posn == CHAR_MAX);
}
</t>
<t tx="ekr.20080529093004.1047">static int
test_locale(void)
{
	static int cats[] = {
		LC_ALL, LC_COLLATE, LC_CTYPE,
		LC_MONETARY, LC_NUMERIC, LC_TIME
	};
	struct lconv *p = NULL;
	char buf[32], *s;

	assert((p = localeconv()) != NULL);
	testclocale(p);
	assert((s = setlocale(LC_ALL, NULL)) != NULL);
	assert(strlen(s) &lt; sizeof (buf));	/* OK if longer */
	strcpy(buf, s);	/* but not safe for this program */
	assert(setlocale(LC_ALL, "") != NULL);
	assert(localeconv() != NULL);
	assert((s = setlocale(LC_MONETARY, "C")) != NULL);
	puts(strcmp(s, "C") ? "Native locale differs from \"C\""
		: "Native locale same as \"C\"");
	assert(setlocale(LC_NUMERIC, "C") != NULL);
	assert((p = localeconv()) != NULL);
	testclocale(p);
	assert(setlocale(LC_ALL, buf) != NULL);
	assert((p = localeconv()) != NULL);
	testclocale(p);

	puts("SUCCESS testing &lt;locale.h&gt;");
	return (0);
}
</t>
<t tx="ekr.20080529093004.1048">@ Math tests 1
@c

static double eps;

/* test for approximate equality */

static int approx(double d1, double d2);
static int
approx(double d1, double d2)
{
	if (d2 != 0)
		return (fabs((d2 - d1) / d2) &lt; eps);
	else
		return (fabs(d1) &lt; eps);
}
</t>
<t tx="ekr.20080529093004.1049">#define assert_equal(a,b,c) \
{\
	if (a != b) {\
		printf(#a " = %f, expected: %f\n", a, b);\
		fflush(stdout);\
	}\
}

static int
test_math1(void)
{
	double huge_val, x;
	int xexp;

	huge_val = HUGE_VAL;
	eps = DBL_EPSILON * 4.0;
	printf("eps = %f\n", eps);

	assert_equal(ceil(-5.1), -5.0, ceil(-5.1) == -5.0);
	assert_equal(ceil(-5.0), -5.0, ceil(-5.0) == -5.0);
	assert_equal(ceil(-4.9), -4.0, ceil(-4.9) == -4.0);
	assert_equal(ceil(0.0),   0.0, ceil(0.0)  ==  0.0);
	assert_equal(ceil(4.9),   5.0, ceil(4.9)  ==  5.0);
	assert_equal(ceil(5.0),   5.0, ceil(5.0)  ==  5.0);
	assert_equal(ceil(5.1),   6.0, ceil(5.1)  ==  6.0);
	
	assert_equal(fabs(-5.0), 5.0, fabs(-5.0) == 5.0);
	assert_equal(fabs(0.0),  0.0, fabs(0.0)  == 0.0);
	assert_equal(fabs(5.0),  5.0, fabs(5.0)  == 5.0);
	
	assert_equal(floor(-5.1), -6.0, floor(-5.1) == -6.0);
	assert_equal(floor(-5.0), -5.0, floor(-5.0) == -5.0);
	assert_equal(floor(-4.9), -5.0, floor(-4.9) == -5.0);
	assert_equal(floor(0.0),   0.0, floor(0.0)  ==  0.0);
	assert_equal(floor(4.9),   4.0, floor(4.9)  ==  4.0);
	assert_equal(floor(5.0),   5.0, floor(5.0)  ==  5.0);
	assert_equal(floor(5.1),   5.0, floor(5.1)  ==  5.0);

	assert_equal(fmod(-7.0, 3.0), -1.0, fmod(-7.0, 3.0) == -1.0);
	assert_equal(fmod(-3.0, 3.0),  0.0, fmod(-3.0, 3.0) ==  0.0);
	assert_equal(fmod(-2.0, 3.0), -2.0, fmod(-2.0, 3.0) == -2.0);
	assert_equal(fmod(0.0, 3.0),   0.0, fmod(0.0, 3.0)  ==  0.0);
	assert_equal(fmod(2.0, 3.0),   2.0, fmod(2.0, 3.0)  ==  2.0);
	assert_equal(fmod(3.0, 3.0),   0.0, fmod(3.0, 3.0)  ==  0.0);
	assert_equal(fmod(7.0, 3.0),   1.0, fmod(7.0, 3.0)  ==  1.0);
	
	assert(approx(frexp(-3.0, &amp;xexp), -0.75) &amp;&amp; xexp == 2);
	assert(approx(frexp(-0.5, &amp;xexp), -0.5)  &amp;&amp; xexp == 0);
	
	assert(frexp(0.0, &amp;xexp) == 0.0 &amp;&amp; xexp == 0);
	
	assert(approx(frexp(0.33, &amp;xexp), 0.66) &amp;&amp; xexp == -1);
	assert(approx(frexp(0.66, &amp;xexp), 0.66) &amp;&amp; xexp ==  0);
	assert(approx(frexp(96.0, &amp;xexp), 0.75) &amp;&amp; xexp ==  7);
	
	assert(ldexp(-3.0, 4) == -48.0);
	assert(ldexp(-0.5, 0) == - 0.5);
	assert(ldexp(0.0, 36) ==   0.0);
	
	assert(approx(ldexp(0.66, -1), 0.33));
	
	assert(ldexp(96, -3) == 12.0);
	
	assert(approx(modf(-11.7, &amp;x), -11.7 + 11.0) &amp;&amp; x == -11.0);
	
	assert(modf(-0.5, &amp;x) == -0.5 &amp;&amp; x ==  0.0);
	assert(modf( 0.0, &amp;x) ==  0.0 &amp;&amp; x ==  0.0);
	assert(modf( 0.6, &amp;x) ==  0.6 &amp;&amp; x ==  0.0);
	assert(modf(12.0, &amp;x) ==  0.0 &amp;&amp; x == 12.0);
	
	printf("HUGE_VAL prints as %.16e\n", huge_val);

	puts("SUCCESS testing &lt;math.h&gt;, part 1");
	return (0);
}
</t>
<t tx="ekr.20080529093004.1050">@ static data
@c

#define assert2(a) { printf("%40s: ", #a); a;}
#define enl() { printf("\n"); fflush(stdout); }

/* test for approximate equality */

static int approx2(double d1, double d2);
static int
approx2(double d1, double d2)
{
	printf("d1 = %e, d2 = %e", d1, d2);
	if (!((d2 ? fabs((d2 - d1) / d2) : fabs(d1)) &lt; eps)) {
		printf(" -- wrong");
	}
	printf("\n");
	fflush(stdout);
	return ((d2 ? fabs((d2 - d1) / d2) : fabs(d1)) &lt; eps);
}
</t>
<t tx="ekr.20080529093004.1051">static int
test_math2(void)
{
	double x;
	int xexp;

	static double piby4 = {0.78539816339744830962};
	static double rthalf = {0.70710678118654752440};

	eps = DBL_EPSILON * 4.0;
	printf("eps: %e\n", eps);
	enl();
	
	assert2(approx2(acos(-1.0), 4.0 * piby4));
	assert2(approx2(acos(-rthalf), 3.0 * piby4));
	assert2(approx2(acos(0.0), 2.0 * piby4));
	assert2(approx2(acos(rthalf), piby4));
	assert2(approx2(acos(1.0), 0.0));

	assert2(approx2(asin(-1.0), -2.0 * piby4));
	assert2(approx2(asin(-rthalf), -piby4));
	assert2(approx2(asin(0.0), 0.0));
	assert2(approx2(asin(rthalf), piby4));
	assert2(approx2(asin(1.0), 2.0 * piby4));

	assert2(approx2(atan(-DBL_MAX), -2.0 * piby4));
	assert2(approx2(atan(-1.0), -piby4));
	assert2(approx2(atan(0.0), 0.0));
	assert2(approx2(atan(1.0), piby4));
	assert2(approx2(atan(DBL_MAX), 2.0 * piby4));

	assert2(approx2(atan2(-1.0, -1.0), -3.0 * piby4));
	assert2(approx2(atan2(-1.0, 0.0), -2.0 * piby4));
	assert2(approx2(atan2(-1.0, 1.0), -piby4));
	assert2(approx2(atan2(0.0, 1.0), 0.0));
	assert2(approx2(atan2(1.0, 1.0), piby4));
	assert2(approx2(atan2(1.0, 0.0), 2.0 * piby4));
	assert2(approx2(atan2(1.0, -1.0), 3.0 * piby4));

#if 0
	assert2(approx2(atan2(0.0, -1.0), 4.0 * piby4)
		|| approx2(atan2(0.0, -1.0), -4.0 * piby4));
#else
	assert2(approx2(atan2(0.0, -1.0), 4.0 * piby4));
#endif

	assert2(approx2(atan2(0.0, -1.0), 4.0 * piby4));

	assert2(approx2(cos(-3.0 * piby4), -rthalf));
	assert2(approx2(cos(-2.0 * piby4), 0.0));
	assert2(approx2(cos(-piby4), rthalf));
	assert2(approx2(cos(0.0), 1.0));
	assert2(approx2(cos(piby4), rthalf));
	assert2(approx2(cos(2.0 * piby4), 0.0));
	assert2(approx2(cos(3.0 * piby4), -rthalf));
	assert2(approx2(cos(4.0 * piby4), -1.0));

	assert2(approx2(sin(-3.0 * piby4), -rthalf));
	assert2(approx2(sin(-2.0 * piby4), -1.0));
	assert2(approx2(sin(-piby4), -rthalf));
	assert2(approx2(sin(0.0), 0.0));
	assert2(approx2(sin(piby4), rthalf));
	assert2(approx2(sin(2.0 * piby4), 1.0));
	assert2(approx2(sin(3.0 * piby4), rthalf));
	assert2(approx2(sin(4.0 * piby4), 0.0));
	
	assert2(approx2(tan(-3.0 * piby4), 1.0));
	assert2(approx2(tan(-piby4), -1.0));
	assert2(approx2(tan(0.0), 0.0));
	assert2(approx2(tan(piby4), 1.0));
	assert2(approx2(tan(3.0 * piby4), -1.0));
	
	puts("SUCCESS testing &lt;math.h&gt;, part 2");
	return (0);
}
</t>
<t tx="ekr.20080529093004.1052">static int equal(double d1, double d2);
static int
equal(double d1, double d2)
{
	printf("d1 = %e, d2 = %e", d1, d2);
	if (d1 != d2) {
		printf(" -- wrong");
	}
	printf("\n");
	fflush(stdout);
	return (d1 == d2);
}
</t>
<t tx="ekr.20080529093004.1053">static int
test_math3(void)
{
	double x;
	int xexp;
	static double e = {2.71828182845904523536};
	static double ln2 = {0.69314718055994530942};
	static double rthalf = {0.70710678118654752440};

	eps = DBL_EPSILON * 4.0;
	printf("eps = %e\n", eps);
	enl();

	assert2(approx2(cosh(-1.0),(e+1.0/e)/2.0));
	assert2(approx2(cosh(0.0),1.0));
	assert2(approx2(cosh(1.0),(e+1.0/e)/2.0));
	
	assert2(approx2(exp(-1.0),1.0/e));
	assert2(approx2(exp(0.0),1.0));
	assert2(approx2(exp(ln2),2.0));
	assert2(approx2(exp(1.0),e));
	assert2(approx2(exp(3.0),e*e*e));
	
	assert2(equal(log(1.0),0.0));
	
	assert2(approx2(log(e),1.0));
	assert2(approx2(log(e*e*e),3.0));
	
	assert2(approx2(log10(1.0),0.0));
	//	assert2(approx2(log10(5.0),1.0-log10(2.0)));
	assert2(approx2(log10(1e5),5.0));

	assert2(approx2(pow(-2.5,2.0),6.25));
	assert2(approx2(pow(-2.0,-3.0),-0.125));
	
	assert2(equal(pow(0.0,6.0),0.0));
	
	assert2(approx2(pow(2.0,-0.5),rthalf));
	assert2(approx2(pow(3.0,4.0),81.0));
	
	assert2(approx2(sinh(-1.0),-(e-1.0/e)/2.0));
	assert2(approx2(sinh(0.0),0.0));
	assert2(approx2(sinh(1.0),(e-1.0/e)/2.0));
	
	assert2(approx2(sqrt(0.0),0.0));
	assert2(approx2(sqrt(0.5),rthalf));
	assert2(approx2(sqrt(1.0),1.0));
	assert2(approx2(sqrt(2.0),1.0/rthalf));
	assert2(approx2(sqrt(144.0),12.0));
	
	assert2(approx2(tanh(-1.0),-(e*e-1.0)/(e*e+1.0)));
	assert2(approx2(tanh(0.0),0.0));
	assert2(approx2(tanh(1.0),(e*e-1.0)/(e*e+1.0)));
	enl();

	puts("SUCCESS testing &lt;math.h&gt;, part 3");
	return (0);
}
</t>
<t tx="ekr.20080529093004.1054">@ test setjmp functions
@c

#if 0 // not ready yet--jump_buf is not defined in &lt;setjmp.h&gt;

static int ctr;
static jmp_buf b0;

/* jump on static buffer */
static void jmpto(int n);
static void
jmpto(int n)
{
	longjmp(b0, n);
}
</t>
<t tx="ekr.20080529093004.1055">@ test for stack creep
@c

static char * stackptr(void);
static char *
stackptr(void)
{
	char ch;

	return (&amp;ch);
}
</t>
<t tx="ekr.20080529093004.1056">@ exercise jumps
@c

static int try_jump(void);
static int
try_jump(void)
{
	jmp_buf b1;
	char *sp = stackptr();

	ctr = 0;
	
	/* jump among cases */
	switch (setjmp(b0)) {	
	case 0:
		assert(sp == stackptr());
		assert(ctr == 0);
		++ctr;
		jmpto(0);	/* should return 1 */
		break;

	case 1:
		assert(sp == stackptr());
		assert(ctr == 1);
		++ctr;
		jmpto(2);
		break;

	case 2:
		assert(sp == stackptr());
		assert(ctr == 2);
		++ctr;
		
		/* test nesting */
		switch (setjmp(b1)) {	
		case 0:
			assert(sp == stackptr());
			assert(ctr == 3);
			++ctr;
			longjmp(b1, -7);
			break;
		case -7:
			assert(sp == stackptr());
			assert(ctr == 4);
			++ctr;
			jmpto(3);
		case 5:
			return (13);
		default:
			return (0);
		}

	case 3:
		longjmp(b1, 5);
		break;
	}
	return (-1);
}
</t>
<t tx="ekr.20080529093004.1057">#endif

static int
test_setjmp(void)
{
#if 0 // not ready yet
	assert(try_jump() == 13);
	printf("sizeof (jmp_buf) = %u\n", sizeof (jmp_buf));

	puts("SUCCESS testing &lt;setjmp.h&gt;");
	return (0);
#else
	puts("setjump/longjump not ready yet!\n");
#endif
}
</t>
<t tx="ekr.20080529093004.1058">@ test signal functions
@c

static int sigs[] = {
	SIGABRT, SIGFPE, SIGILL, SIGINT, SIGSEGV, SIGTERM
};
static void (*rets[])(int) = {
	SIG_DFL, SIG_ERR, SIG_IGN
};
static sig_atomic_t atomic;

/* handle SIGFPE */
static void field_fpe(int sig);
static void
field_fpe(int sig)
{
	assert(sig == SIGFPE);
	puts("SUCCESS testing &lt;signal.h&gt;");
	exit(EXIT_SUCCESS);
}
</t>
<t tx="ekr.20080529093004.1059">static int
test_signal(void)
{
	printf("sizeof (sig_atomic_t) = %u\n",
		sizeof (sig_atomic_t));
	assert(signal(SIGFPE, &amp;field_fpe) == SIG_DFL);
	assert(signal(SIGFPE, &amp;field_fpe) == &amp;field_fpe);
	raise(SIGFPE);

	puts("FAILURE testing &lt;signal.h&gt;");
	return (EXIT_FAILURE);
}
</t>
<t tx="ekr.20080529093004.1060">@ test stdarg macros
@c

typedef struct {
	char c;
} Cstruct;

static int tryarg(const char *fmt, ...);	// was tryit
static int
tryarg(const char *fmt, ...)
{
	int ctr = 0;
	va_list ap;

	va_start(ap, fmt);
	for (; *fmt; ++fmt)
		switch (*fmt)
			{	/* switch on argument type */
		case 'i':
			assert(va_arg(ap, int) == ++ctr);
			break;
		case 'd':
			assert(va_arg(ap, double) == ++ctr);
			break;
		case 'p':
			assert(va_arg(ap, char *)[0] == ++ctr);
			break;
		case 's':
			// Apparently a problem with Think C
			// I get the message: structure has no members
			#if 0
				assert(va_arg(ap, Cstruct).c == ++ctr);
			#else
				++ctr;
			#endif
			}
	va_end(ap);
	return (ctr);
}
</t>
<t tx="ekr.20080529093004.1061">static int
test_stdarg(void)
{
	// CC2 doesn't handle auto initializers of structs yet.
	// Cstruct x = {3};

	#if 0 // x case doesn't work
		assert(tryarg("iisdi", '\1', 2, x, 4.0, 5) == 5);
	#else
		assert(tryarg("iidi", '\1', 2, 3.0, 4) == 4);
	#endif

	assert(tryarg("") == 0);
	assert(tryarg("pdp", "\1", 2.0, "\3") == 3);
	printf("sizeof (va_list) = %u\n", sizeof (va_list));

	puts("SUCCESS testing &lt;stdarg.h&gt;");
	return (0);
}
</t>
<t tx="ekr.20080529093004.1062">@ test stddef definitions
@c

typedef struct {
	char f1;
	struct {
		float flt;
	} f2;
	int f3;
} Str;

static char *pc = NULL;
static double *pd = NULL;
static size_t offs[] = {
	offsetof(Str, f1),
	offsetof(Str, f2),
	offsetof(Str, f3)};

static int
test_stddef(void)
{
	ptrdiff_t pd = &amp;pc[INT_MAX] - &amp;pc[0];
	wchar_t wc = L'Z';
	Str x = {1, 2, 3};
	char *ps = (char *)&amp;x;

	assert(sizeof (ptrdiff_t) == sizeof (size_t));
	assert(sizeof (size_t) == sizeof (sizeof (char)));
	assert(pd == &amp;pc[INT_MAX] - &amp;pc[0]);
	assert(wc == L'Z');
	assert(offs[0] &lt; offs[1]);
	assert(offs[1] &lt; offs[2]);
	assert(*(char *)(ps + offs[0]) == 1);
	assert(*(float *)(ps + offs[1]) == 2);
	assert(*(int *)(ps + offs[2]) == 3);
	printf("sizeof (size_t) = %u\n", sizeof (size_t));
	printf("sizeof (wchar_t) = %u\n", sizeof (wchar_t));

	puts("SUCCESS testing &lt;stddef.h&gt;");
	return (0);
}
</t>
<t tx="ekr.20080529093004.1063">@ test stdio functions, part 1
test vfprintf
@c

static void vfp(const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	vfprintf(stdout, fmt, ap);
	va_end(ap);
}
</t>
<t tx="ekr.20080529093004.1064">@ test vprintf
@c

static void vp(const char *fmt, ...)
{	
	va_list ap;

	va_start(ap, fmt);
	vprintf(fmt, ap);
	va_end(ap);
}
</t>
<t tx="ekr.20080529093004.1065">@ test vsprintf
@c

static void vsp(char *s, const char *fmt, ...)
{	
	va_list ap;

	va_start(ap, fmt);
	vsprintf(s, fmt, ap);
	va_end(ap);
}
</t>
<t tx="ekr.20080529093004.1066">static int
test_stdio1(void)
{
	char buf[32], ch;
	double db;
	float fl;
	int in;
	long lo;
	long double ld;
	short sh;
	void *pv;

	assert(sprintf(buf, "%2c|%-4d|%.4o|%#lX", 'a', -4, 8, 12L) == 16);
	assert(strcmp(buf, " a|-4  |0010|0XC") == 0);
	assert(sscanf(buf, " %c|%hd |%i|%lx", &amp;ch, &amp;sh, &amp;in, &amp;lo) == 4);
	assert(ch == 'a' &amp;&amp; sh == -4 &amp;&amp; in == 8 &amp;&amp; lo == 12);
	assert(sprintf(buf, "%E|%.2f|%Lg", 1.1e20, -3.346, .02L) == 23);
	assert(strcmp(buf, "1.100000E+20|-3.35|0.02") == 0);
	assert(sscanf(buf, "%e|%lg|%Lf", &amp;fl, &amp;db, &amp;ld) == 3);
	
	assert(fabs(fl - 1.1e20) / 1.1e20 &lt; 4 * FLT_EPSILON);
	assert(fabs(db + 3.35) / 3.35 &lt; 4 * DBL_EPSILON);
	assert(fabs(ld - 0.02) / 0.02 &lt; 4 * LDBL_EPSILON);

	assert(4 &lt;= sprintf(buf, "|%%%n %p",
		&amp;in, (void *)&amp;ch) &amp;&amp; in == 2);
	assert(sscanf(buf, "|%%%n %p", &amp;in, &amp;pv) == 1 &amp;&amp; in == 2);
	
	/* test formatted I/O */
	{
		char buf[10];
		const char *tn = tmpnam(NULL);
		FILE *pf;
		fpos_t fp1, fp2;
		int in1, in2;
		long off;
	
		assert(tn != NULL &amp;&amp; (pf = fopen(tn, "w+")) != NULL);
		setbuf(pf, NULL);
		assert(fprintf(pf, "123\n") == 4);
		assert((off = ftell(pf)) != -1);
		assert(fprintf(pf, "456\n") == 4);
		assert(fgetpos(pf, &amp;fp1) == 0);
		assert(fprintf(pf, "789\n") == 4);
		rewind(pf);
		assert(fscanf(pf, "%i", &amp;in1) == 1 &amp;&amp; in1 == 123);
		assert(fsetpos(pf, &amp;fp1) == 0);
		assert(fscanf(pf, "%i", &amp;in1) == 1 &amp;&amp; in1 == 789);
		assert(fseek(pf, off, SEEK_SET) == 0);
		assert(fscanf(pf, "%i", &amp;in1) == 1 &amp;&amp; in1 == 456);
		assert(fclose(pf) == 0
			&amp;&amp; freopen(tn, "r", stdin) == stdin);
		assert(setvbuf(stdin, buf, _IOLBF, sizeof (buf)) == 0);
		assert(scanf("%i", &amp;in1) == 1 &amp;&amp; in1 == 123);
		assert(fclose(stdin) == 0);
		assert((pf = fopen(tn, "w+b")) != NULL);
	}
	printf("BUFSIZ = %u\n", BUFSIZ);
	printf("L_tmpnam = %u\n", L_tmpnam);
	printf("FILENAME_MAX = %u\n", FILENAME_MAX);
	printf("FOPEN_MAX = %u\n", FOPEN_MAX);
	printf("TMP_MAX = %u\n", TMP_MAX);
	vsp(buf, "SUC%c%s", 'C', "ESS");

	vfp("%s testing %s", buf, "&lt;stdio.h&gt;");
	vp(", part 1\n");
	return (0);
}
</t>
<t tx="ekr.20080529093004.1067">static int
test_stdio2(void)
{
	char buf[32], tname[L_tmpnam], *tn;
	FILE *pf;
	static int macs[] = {
		_IOFBF, _IOLBF, _IONBF, BUFSIZ, EOF, FILENAME_MAX,
		FOPEN_MAX, TMP_MAX, SEEK_CUR, SEEK_END, SEEK_SET};

	assert(256 &lt;= BUFSIZ &amp;&amp; EOF &lt; 0);
	assert(8 &lt;= FOPEN_MAX &amp;&amp; 25 &lt;= TMP_MAX);
	
	assert(tmpnam(tname) == tname &amp;&amp; strlen(tname) &lt; L_tmpnam);
	assert((tn = tmpnam(NULL)) != NULL &amp;&amp; strcmp(tn, tname) != 0);
	
	pf = fopen(tname, "w");
	
	assert(pf != NULL &amp;&amp; pf != stdin &amp;&amp; pf != stdout &amp;&amp; pf != stderr);
	
	assert(feof(pf) == 0 &amp;&amp; ferror(pf) == 0);
	assert(fgetc(pf) == EOF &amp;&amp; feof(pf) == 0 &amp;&amp; ferror(pf) != 0);
	clearerr(pf);

	assert(ferror(pf) == 0);
	assert(fputc('a', pf) == 'a' &amp;&amp; putc('b', pf) == 'b');

	assert(0 &lt;= fputs("cde\n", pf));
	assert(0 &lt;= fputs("fghij\n", pf));
	assert(fflush(pf) == 0);

	assert(fwrite("klmnopq\n", 2, 4, pf) == 4);
	assert(fclose(pf) == 0);

	assert(freopen(tname, "r", stdin) == stdin);
	
	assert(fgetc(stdin) == 'a' &amp;&amp; getc(stdin) == 'b');
	assert(getchar() == 'c');
	assert(fgets(buf, sizeof (buf), stdin) == buf &amp;&amp; strcmp(buf, "de\n") == 0);
	assert(ungetc('x', stdin) == 'x');
	assert(gets(buf) == buf &amp;&amp; strcmp(buf, "xfghij") == 0);
	
	assert(fread(buf, 2, 4, stdin) == 4 &amp;&amp; strncmp(buf, "klmnopq\n", 8) == 0);
	assert(getchar() == EOF &amp;&amp; feof(stdin) != 0);
	
	remove(tn);
	assert(rename(tname, tn) == 0 &amp;&amp; fopen(tname, "r") == NULL);
	assert((pf = fopen(tn, "r")) != NULL &amp;&amp; fclose(pf) == 0);
	assert(remove(tn) == 0 &amp;&amp; fopen(tn, "r") == NULL);
	
	assert((pf = tmpfile()) != NULL &amp;&amp; fputc('x', pf) == 'x');
	
	errno = EDOM;
	perror("Domain error reported as");

	putchar('S'), puts("UCCESS testing &lt;stdio.h&gt;, part 2");
	return (0);
}
</t>
<t tx="ekr.20080529093004.1068">@ test stdlib functions
@c

static void abrt(int sig);
static void
abrt(int sig)
{
	/* handle SIGABRT */
	exit(EXIT_SUCCESS);
}
</t>
<t tx="ekr.20080529093004.1069">@ compare function for bsearch and qsort
@c

static int cmp(const void *p1, const void *p2);
static int
cmp(const void *p1, const void *p2)
{	
	unsigned char c1 = *(unsigned char *)p1;
	unsigned char c2 = *(unsigned char *)p2;

	return (*(unsigned char *)p1 - *(unsigned char *)p2);
}
</t>
<t tx="ekr.20080529093004.1070">@ get control from atexit
@c

static void done(void);
static void
done(void)
{	
	puts("SUCCESS testing &lt;stdlib.h&gt;");
}
</t>
<t tx="ekr.20080529093004.1071">static int
test_stdlib(void)
{
	char buf[10], *s1, *s2;
	div_t iqr;
	ldiv_t lqr;
	int i1 = EXIT_FAILURE;
	int i2 = EXIT_SUCCESS;
	int i3 = MB_CUR_MAX;
	wchar_t wcs[10];
	static char abc[] = "abcdefghijklmnopqrstuvwxyz";
	static int rmax = RAND_MAX;

	assert(32767 &lt;= rmax);
	assert(1 &lt;= MB_CUR_MAX &amp;&amp; MB_CUR_MAX &lt;= MB_LEN_MAX);
	assert((s1 = malloc(sizeof (abc))) != NULL);
	strcpy(s1, abc);
	assert((s2 = calloc(sizeof (abc), 1)) != NULL
		&amp;&amp; s2[0] == '\0');
	assert(memcmp(s2, s2 + 1, sizeof (abc) - 1) == 0);
	assert(strcmp(s1, abc) == 0);
	assert((s1 = realloc(s1, 2 * sizeof (abc) - 1)) != NULL);
	strcat(s1, abc);
	assert(strrchr(s1, 'z') == s1 + 2 * strlen(abc) - 1);
	free(s2);
	assert((s1 = realloc(s1, sizeof (abc) - 3)) != NULL);
	assert(memcmp(s1, abc, sizeof (abc) -3) == 0);
	assert(getenv("ANY") || system(NULL) || abc[0]);
	assert(abs(-4) == 4 &amp;&amp; abs(4) == 4);
	assert(labs(-4) == 4 &amp;&amp; labs(4) == 4);
	
	assert(div(7, 2).quot == 3 &amp;&amp; div(7, 2).rem == 1);
	iqr = div(-7, 2);
	assert(iqr.quot == -3 &amp;&amp; iqr.rem == -1);
	
	assert(ldiv(7, 2).quot == 3 &amp;&amp; ldiv(7, 2).rem == 1);
	lqr = ldiv(-7, 2);
	assert(lqr.quot == -3 &amp;&amp; lqr.rem == -1);
	
	assert(0 &lt;= (i1 = rand()) &amp;&amp; i1 &lt;= RAND_MAX);
	assert(0 &lt;= (i2 = rand()) &amp;&amp; i2 &lt;= RAND_MAX);
	srand(1);
	assert(rand() == i1 &amp;&amp; rand() == i2);
	assert(bsearch("0", abc, sizeof (abc) - 1, 1, &amp;cmp)
		== NULL);
	assert(bsearch("d", abc, sizeof (abc) - 1, 1, &amp;cmp)
		== &amp;abc[3]);
	qsort(strcpy(buf, "mishmash"), 9, 1, &amp;cmp);
	assert(memcmp(buf, "\0ahhimmss", 9) == 0);
	assert(atof("3.0") == 3.0);
	assert(atof("-1e-17-") == -1e-17);
	assert(atoi("37") == 37 &amp;&amp; atoi("-7192X") == -7192);
	assert(atol("+29") == 29 &amp;&amp; atol("-077") == -77);
	assert(strtod("28G", &amp;s1) == 28.0
		&amp;&amp; s1 != NULL &amp;&amp; *s1 == 'G');
	assert(strtol("-a0", &amp;s1, 11) == -110
		&amp;&amp; s1 != NULL &amp;&amp; *s1 == '\0');
	assert(strtoul("54", &amp;s1, 4) == 0
		&amp;&amp; s1 != NULL &amp;&amp; *s1 == '5');
	assert(strtoul("0xFfg", &amp;s1, 16) == 255
		&amp;&amp; s1 != NULL &amp;&amp; *s1 == 'g');
	assert(mbstowcs(wcs, "abc", 4) == 3 &amp;&amp; wcs[1] == 'b');
	assert(wcstombs(buf, wcs, 10) == 3
		&amp;&amp; strcmp(buf, "abc") == 0);
	mblen(NULL, 0);
	wctomb(NULL, 0);
	assert(mblen("abc", 4) == 1);
	assert(mbtowc(&amp;wcs[0], "abc", 4) == 1 &amp;&amp; wcs[0] == 'a');
	assert(wctomb(buf, wcs[0]) == 1 &amp;&amp; buf[0] == 'a');
	assert(mblen("", 1) == 0);
	assert(mbtowc(&amp;wcs[0], "", 1) == 0 &amp;&amp; wcs[0] == 0);
	assert(wctomb(buf, wcs[0]) == 1 &amp;&amp; buf[0] == '\0');
	printf("RAND_MAX = %ld\n", (long)RAND_MAX);
	printf("MB_CUR_MAX = %u\n", MB_CUR_MAX);
	printf("Multibyte strings%s have shift states\n",
		mbtowc(NULL, NULL, 0) ? "" : " don't");

	atexit(&amp;done);
	signal(SIGABRT, &amp;abrt);
	abort();
	puts("FAILURE testing &lt;stdlib.h&gt;");
	return (EXIT_FAILURE);
}
</t>
<t tx="ekr.20080529093004.1072">static int
test_string(void)
{
	char s[20];
	size_t n;
	static const char abcde[] = "abcde";
	static const char abcdx[] = "abcdx";

	assert(memchr(abcde, 'c', 5) == &amp;abcde[2]);
	assert(memchr(abcde, 'e', 4) == NULL);
	assert(memcmp(abcde, abcdx, 5) != 0);
	assert(memcmp(abcde, abcdx, 4) == 0);
	
	/* the following tests are interrelated */
	assert(memcpy(s, abcde, 6) == s &amp;&amp; s[2] == 'c');
	assert(memmove(s, s + 1, 3) == s);
	assert(memcmp(memmove(s, s + 1, 3), "aabce", 6));
	assert(memcmp((char *)memmove(s + 2, s, 3) - 2,
		"bcece", 6));
	assert(memset(s, '*', 10) == s &amp;&amp; s[9] == '*');
	assert(memset(s + 2, '%', 0) == s + 2 &amp;&amp; s[2] == '*');
	assert(strcat(memcpy(s, abcde, 6), "fg") == s);
	assert(s[6] == 'g');
	assert(strchr(abcde, 'x') == NULL);
	assert(strchr(abcde, 'c') == &amp;abcde[2]);
	assert(strchr(abcde, '\0') == &amp;abcde[5]);
	assert(strcmp(abcde, abcdx) != 0);
	assert(strcmp(abcde, "abcde") == 0);
	assert(strcoll(abcde, "abcde") == 0);
	assert(strcpy(s, abcde) == s &amp;&amp; strcmp(s, abcde) == 0);
	assert(strcspn(abcde, "xdy") == 3);
	assert(strcspn(abcde, "xzy") == 5);
	assert(strerror(EDOM) != 0);
	assert(strlen(abcde) == 5);
	assert(strlen("") == 0);
	assert(strncat(strcpy(s, abcde), "fg", 1) == s
		&amp;&amp; strcmp(s, "abcdef") == 0);
	assert(strncmp(abcde, "abcde", 30) == 0);
	assert(strncmp(abcde, abcdx, 30) != 0);
	assert(strncmp(abcde, abcdx, 4) == 0);
	assert(strncpy(s, abcde, 7) == s
		&amp;&amp; memcmp(s, "abcde\0", 7) == 0);
	assert(strncpy(s, "xyz", 2) == s
		&amp;&amp; strcmp(s, "xycde") == 0);
	assert(strpbrk(abcde, "xdy") == &amp;abcde[3]);
	assert(strpbrk(abcde, "xzy") == NULL);
	assert(strrchr(abcde, 'x') == NULL);
	assert(strrchr(abcde, 'c') == &amp;abcde[2]);
	assert(strcmp(strrchr("ababa", 'b'), "ba") == 0);
	assert(strspn(abcde, "abce") == 3);
	assert(strspn(abcde, abcde) == 5);
	assert(strstr(abcde, "xyz") == NULL);
	assert(strstr(abcde, "cd") == &amp;abcde[2]);
	assert(strtok(strcpy(s, abcde), "ac") == &amp;s[1]);
	assert(strtok(NULL, "ace") == &amp;s[3]);
	assert(strtok(NULL, "ace") == NULL
		&amp;&amp; memcmp(s, "ab\0d\0\0", 6) == 0);
	n = strxfrm(NULL, abcde, 0);
	if (n &lt; sizeof (s) - 1)
		assert(strxfrm(s, abcde, n + 1) == n
			&amp;&amp; strlen(s) == n);

	puts("SUCCESS testing &lt;string.h&gt;");
	return (0);
}
</t>
<t tx="ekr.20080529093004.1073">static int
test_time(void)
{
	char buf[32];
	clock_t tc = clock();
	struct tm ts1, ts2;
	time_t tt1, tt2;
	static char *dstr = "Sun Dec 02 06:55:15 1979\n";
	static char *ptr = NULL;

	tt1 = time(&amp;tt2);
	assert(tt1 == tt2);
	ts1.tm_sec = 15;
	ts1.tm_min = 55;
	ts1.tm_hour = 6;
	ts1.tm_mday = 2;
	ts1.tm_mon = 11;
	ts1.tm_year = 79;
	ts1.tm_isdst = -1;
	tt1 = mktime(&amp;ts1);
	assert(ts1.tm_wday == 0);
	assert(ts1.tm_yday == 335);
	++ts1.tm_sec;
	tt2 = mktime(&amp;ts1);
	assert(difftime(tt1, tt2) &lt; 0.0);
	assert(strcmp(asctime(localtime(&amp;tt1)), dstr) == 0);
	assert(strftime(buf, sizeof (buf), "%S",
		gmtime(&amp;tt2)) == 2);
	assert(strcmp(buf, "16") == 0);
	assert(tc &lt;= clock());
	fputs("Current date -- ", stdout);
	time(&amp;tt1);
	fputs(ctime(&amp;tt1), stdout);

	puts("SUCCESS testing &lt;time.h&gt;");
	return (0);
}
</t>
<t tx="ekr.20080529093004.1074">@ignore
@language c</t>
<t tx="ekr.20080529093004.1075"></t>
<t tx="ekr.20080529093004.1076">/*
	Link: Master header file

	source:  LK.h
	started: November 4, 1993.
	version:
		December 27, 1993.
			Type definiions moved to LKtypes.h.
*/

#ifndef lk_h_
#define lk_h_

#pragma once

#include &lt;LIBlib.h&gt;		/* Must be first. */
#include "LKtypes.h"	/* Must be second. */
#include "LKerr.h"

/*
	Define common abbreviation macros.
*/

#define bit(field,the_bits) ((field) &amp; (the_bits))
#define clear_bit(field,the_bits) (field) &amp;= ~(the_bits)

#endif /* lk_h_ */

</t>
<t tx="ekr.20080529093004.1077">/*
	Link: Common type definitions.
	
	source:  LKtypes.h
	started: December 27, 1993.
	version:
		May 27, 1994.
			Added dlist_nodes's.
		May 10, 1994.
			Types relating to the format of the object file are now defined in LIBofile.h.
		January 8, 1994.
		
	Global types are needed so that
	? function prototypes in headers can refer to types without #including other headers.
	? definitions of structs/unions/enums in headers can refer to other nodes
	  without #including other headers.
*/

#ifndef LKtypes_h_
#define LKtypes_h_

#pragma once
	
	/* Types used by LKnodes.h */
	
#ifndef TYPEDEF_LK_NODES
	#define TYPEDEF_LK_NODES
	typedef struct area_node_struct		area_node;
	typedef struct dict_node_struct 	dict_node;
	typedef struct dlist_node_struct	dlist_node;
	typedef struct file_node_struct 	file_node;
	typedef struct flist_struct			flist_node;
	typedef struct ref_node_struct		ref_node;
	typedef struct unit_node_struct	unit_node;
#endif

#endif /* LKtypes_h_ */
</t>
<t tx="ekr.20080529093004.1078"></t>
<t tx="ekr.20080529093004.1079"></t>
<t tx="ekr.20080529093004.1080">/*
	Link: header file for LKend.c.
	
	source:  LKend.h
	started: December 13, 1993.
	version: January 8, 1994.
*/

#ifndef LKend_h_
#define LKend_h_

#pragma once

void end_close_all (void);

#endif /* LKend_h_ */
</t>
<t tx="ekr.20080529093004.1081">/*
	Link: Header file for LKerr.c.

	source:  LKdebug.h
	started: November 4, 1993.
	version: January 8, 1994.
*/

/*
	Make sure this header is included only once.
*/

#ifndef LKerr_h_
#define LKerr_h_

#pragma once

	/* Declare global variables. */
	
extern char *	err_fname;	/* Current file name. */

	/* Function prototypes. */

bool	err_begin		(void);
void	err_begin_file	(char * file_name);
char *	err_file_name	(void);
void	err_init		(void);

void	es_assert_failed	(char * condition, int line, char * file);
void	es_internal_err		(char * condition, int line, char * file);

void	fatal_begin	(void);
void	fatal_end	(void);

#endif /* LKerr_h_ */
</t>
<t tx="ekr.20080529093004.1082">/*
	Link: memory allocation functions.

	source:  LKmem.h
	started: November 10, 1993.
	version:
		May 27, 1994.
			Added alist_stats and dlist_stats.
		May 21, 1994.
			Added new_string_macro and new_perm_string_macro.
			Added ref_stats.
		April 30, 1994.
			Revised to used LIBmem.h macros and routines.
		November 10, 1993.
*/

#ifndef LKmem_h_
#define LKmem_h_

#pragma once

#include &lt;LIBmem.h&gt;

#include &lt;string.h&gt;

/*
	Abbreviations.
*/

#define new_perm_string_macro(p,s) new_string_macro(p,s,perm_life,string_stats)

/*
	General allocation macros.

	These macros are the fundamental lifetime-based storage allocation macro.

	Using sizeof(*p) in new_perm_macro *guarantees* that p must be a pointer and
	eliminates macro calls that expand to sizeof(sizeof(x)).
*/

#define new_perm_macro(p, stat) \
{\
	ASSERT(sizeof(*p) &gt; 4);\
	new_size_macro(p, sizeof(*p), perm_life, stat);\
}

#define new_size_macro(p, the_size, life, stat) \
{\
	size_t size = the_size;\
	ASSERT(life);\
	MEM_UPDATE_STATS(stat, size);\
	MEM_STATS(life -&gt; mem_cur_nodes ++; life -&gt; mem_cur_bytes += (size));\
	if (size &gt; life -&gt; mem_avail) {\
		p = mem_new_block(size, life);\
	}\
	else {\
		p = life -&gt; mem_ptr;\
		life -&gt; mem_ptr    = (((char *) (life -&gt; mem_ptr)) + size);\
		life -&gt; mem_avail -= size;\
	}\
	ASSERT(life -&gt; mem_avail &gt;= 0);\
	/* TRACEP("new", es(life -&gt; name); eptr(p); enl()); */\
}

#define new_string_macro(p,s1,life,stat)\
{\
	ASSERT(s1);\
	new_size_macro(p, strlen(s1)+1, life, stat);\
	strcpy(p, s1);\
}

	/* All variables in the linker have permanent lifetime. */

extern mem_life * perm_life;	/* Description of permanent lifetime. */

	/* Statistics nodes. */

extern mem_stat * area_stats;
extern mem_stat * area_bytes_stats;
extern mem_stat * info_stats;
extern mem_stat * dict_stats;
extern mem_stat * dlist_stats;
extern mem_stat * flist_stats;
extern mem_stat * ref_stats;
extern mem_stat * string_stats;
extern mem_stat * unit_stats;

#endif /* LKmem_h_ */
</t>
<t tx="ekr.20080529093004.1083"></t>
<t tx="ekr.20080529093004.1084">/*
	Link: application-specific termination module.

	source:  LKend.c
	started: November 4, 1993.
	version: January 8, 1994.
*/

&lt;&lt; LKend #includes &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1085">#include "LK.h"

#include "LKend.h"

#include &lt;LIBos.h&gt;
</t>
<t tx="ekr.20080529093004.1086">@ Close all user files, but not the log file.
@c

void
end_close_all(void)
{
	FTAG("end_close_all");
	STATB(ftag);

	io_close(os_bytes_file);
	io_close(os_text_file);
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1087">/*
	Link: General error handling.

	source:  LKerr.c
	started: November 4, 1993.
	version:
		January 9, 1994.
			Added dummy err_context() to keep the new devlib happy.
		December 10, 1993.
			Removed all logic involving lines and function names.
			Removed warning and help logic.
			Replaced err_count with link_err_count.
*/

&lt;&lt; LKerr #includes &gt;&gt;
&lt;&lt; LKerr declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1088">#include "LK.h"

#include "LKerr.h"
#include "LKmain.h"	/* For link_err_count. */
#include "LKnodes.h"

#include "LIBend.h"

#include &lt;stdlib.h&gt;	/* For abort. */
#include &lt;string.h&gt; /* For strlen. */
</t>
<t tx="ekr.20080529093004.1089">/*
	Define global status variables.
*/
long	err_fatal = 0;				/* Fatal error counts. */
char *	err_fname = NULL;			/* Current file name. */

/*
	Function prototypes internal routines.
*/
static void	err_begin_mess	(char * message);
</t>
<t tx="ekr.20080529093004.1090">@ Set the file name used in error message. The file name will exist until the end of compile.
@c

void
err_begin_file (char * file_name)
{
	FTAG("err_begin_file");
	STATB(ftag);

	err_fname = file_name;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1091">@ Output the common start of an error message.
@c

static void
err_begin_mess(char * message)
{
	ecnls(2);
	epads(message, 8); eblank();
	if (*err_file_name() != '\0') {
		epads(err_file_name(), 10); ecnl();
	}
}
</t>
<t tx="ekr.20080529093004.1092">@ Print the context of an error. This routine is called from dev lib; it does nothing in the linker.
@c

void
err_context(void)
{}
</t>
<t tx="ekr.20080529093004.1093">@ Return the name of the current file or "(no file)".
@c

char *
err_file_name(void)
{
	return ((err_fname == NULL) ? "(no file)" : cvt_short_fn(err_fname));
}
</t>
<t tx="ekr.20080529093004.1094">@ Start an error message.
@c

bool
err_begin(void)
{
	link_err_count++;
	err_begin_mess("error:");
	return TRUE;
}
</t>
<t tx="ekr.20080529093004.1095">@ Start a fatal error message. User errors should never result in a call to fatal.
@c

void
fatal_begin(void)
{
	/*7/19/93: Abort if we take a fatal error while processing a fatal error. */
	static bool in_fatal = FALSE;

	ecnl(); enl();
	es("Oh Dear...There is something wrong me\n");
	es("in: "); es(current_ftag);
	es(" called from "); es(caller_ftag);
	es(" called from "); es(caller2_ftag);
	enl();

	if (in_fatal) {
		es("Encountered a second fatal error...aborting now!\n");
		end_abort();
		abort();
	}
	in_fatal = TRUE;
	err_begin_mess("oops:"); enl();
}
</t>
<t tx="ekr.20080529093004.1096">@ Terminate a fatal error message that was begun with fatal_start.
@c

void
fatal_end(void)
{
	ecnl();
	end_abort();
	abort();
}
</t>
<t tx="ekr.20080529093004.1097">/*
	Link: Application-specific error-stream routines.
	
	source:  LKes.c
	started: March 11, 1994.
	version: March 11, 1994.
		Prototypes for all routines in this file are found in LIBes.h.
*/

&lt;&lt; LKes #includes &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1098">#include "LK.h"

#include &lt;LIBes.h&gt;
#include &lt;LIBlog.h&gt;
</t>
<t tx="ekr.20080529093004.1099">@ All error output eventually comes here. Defining es here allows each application to define es as it sees fit.
@c

void
es(char * s)
{
	if (s) {
		log_sout(s);
	}
}
</t>
<t tx="ekr.20080529093004.1100">/*
	LK: interface to devlib.
	
	source:  LKlib.c
	started: January 8, 1994.
	version:
		June 19, 1994.
			Added lib_modem_flag and lib_serial_flag;
*/

&lt;&lt; LKlib #includes &gt;&gt;

	/* Define variables used by devlib. */
	
pstring	lib_about_title		= "\pAbout Link";		/* Must be a pascal string. */
char *	lib_arg_file_prompt = "Link log file...";	/* Prompt for file name. */

char *	lib_log_window_name	= "Link log";	/* The name of log window. */
char *	lib_program_name	= "Link";		/* The name of the program. */

bool	lib_modem_flag = TRUE;		/* 0/1 send output to modem/printer port. */
bool	lib_serial_flag = FALSE;	/* TRUE: S-record output goes to serial port. */
bool	lib_stderr_flag = FALSE;	/* TRUE: send log output to stderr on the Mac. */

#if defined(THINK_C)
	char *	lib_arg_file_name = "Link Args";	/* The name of the argument file. */
#elif defined(applec)
	char *	lib_arg_file_name = "Link MPW args";
#else
	char *	lib_arg_file_name = "Linkargs.txt";
#endif

char *	lib_version = "Link version 1.0";
</t>
<t tx="ekr.20080529093004.1101">#include &lt;LIBlib.h&gt;
</t>
<t tx="ekr.20080529093004.1102">/*
	Link: Memory management routines.

	source:  LKmem.c
	started: November 4, 1993.
	version:
		May 27, 1994.
			Added alist_stats and dlist_stats.
		May 21, 1994.
			Added ref_stats.
		April 30, 1994.
			Rewritten to use dev lib routines and macros.
*/

&lt;&lt; LKmem #includes &gt;&gt;

	/* All variables in the linker have permanent lifetime. */

mem_life * perm_life = NULL;	/* Description of permanent lifetime. */

	/* Statistics nodes. */

mem_stat * area_stats = NULL;
mem_stat * area_bytes_stats = NULL;
mem_stat * info_stats = NULL;
mem_stat * dict_stats = NULL;
mem_stat * dlist_stats = NULL;
mem_stat * flist_stats = NULL;
mem_stat * ref_stats = NULL;
mem_stat * string_stats = NULL;
mem_stat * unit_stats = NULL;
</t>
<t tx="ekr.20080529093004.1103">#include "LK.h"
#include "LKmem.h"
</t>
<t tx="ekr.20080529093004.1104"></t>
<t tx="ekr.20080529093004.1105"></t>
<t tx="ekr.20080529093004.1106">/*
	Link: header file for user arguments.

	source:  LKarg.h
	started: November 4, 1993
	version: June 28, 1994.
*/

/*
	Make sure this header is included only once.
*/

#ifndef arg_h_
#define arg_h_

#pragma once

/*
	User Flags.
*/

	/* Code generation flags. */
	
extern char *	arg_code_address;	/* Starting address of code areas. */
extern bool		arg_code_flag;		/* TRUE: use arg_data_address. */
extern char *	arg_data_address ;	/* Starting address of data areas. */
extern bool		arg_data_flag;		/* TRUE: use arg_data_address. */
extern char *	arg_main_name;		/* Default name of the start function. */

	/* Flags relating to the map file. */

extern bool 	arg_map_flag;			/* TRUE: generate a human-readable map file. */
extern char *	arg_map_path;			/* Name of the map file. */
extern bool		arg_verbose_map_flag;	/* TRUE: generate a verbose map. */
extern bool		arg_map_tree_flag;		/* TRUE: generate a map of the parent tree. */
extern bool		arg_tuple_map_flag;		/* TRUE: generate a Tuple compatible load map. */


	/* Debugging and testing flags. */

extern bool arg_obj_dump_flag;	/* TRUE: dump obj files to debugging stream. */
extern bool arg_go_flag;		/* TRUE: load program and go. */
extern bool arg_no_out_flag;	/* TRUE: suppress output, not code generation. */

	/* Other flags. */
	
extern bool	arg_stats_flag;			/* TRUE: dump statistics on exit. */
extern bool arg_verbose_flag;		/* TRUE: verbose messages. */
extern bool arg_srec_flag;			/* TRUE: generate S-records. */


/*
	Declare variables describing the input and output file paths.
*/

extern char *	arg_in_path;	/* The current input file. */
extern char *	arg_out_path;	/* The output file. */

/*
	Define synonyms for the return values from arg_do_argv.
*/
#define MORE_FILES_REMAIN	TRUE
#define NO_MORE_FILES_REMAIN FALSE

/*
	Function prototypes.
*/
bool	arg_do_argv 		(int argc, char **argv, char * on_str, char * off_str);
void	arg_massage_string	(char * s);
int		arg_string2argv		(char *** argvp, char * buf);

#endif /* arg_ */</t>
<t tx="ekr.20080529093004.1107">/*
	Link: header file for initialization module.

	source:  LKinit.h
	started: November 4, 1993.
	version: December 10, 1993.
*/

/*
	Make sure this file is included only once.
*/
#ifndef init_h_
#define init_h_

#pragma once

/*
	Include headers for all modules that must be initialized.
*/

void init_all	(int argc, char ** argv);

#endif /* init_h_ */
</t>
<t tx="ekr.20080529093004.1108">/*
	Link: linker globals and prototypes for main linker routines.

	source:  LKmain.h
	started: November 4, 1993.
	version:
		May 22, 1994.
			Made main_read global.
		April 30, 1994.
			Removed all statistics variables.  These are now handled in LKmem.h.
		December 12, 1993.
*/

/*
	Make sure this header is included only once.
*/

#ifndef main_h_
#define main_h_

#pragma once

/*
	Declare compiler globals variables.
*/

	/* The user memory. */

extern char * main_user_mem;


	/* General status information. */
	
extern long		link_err_count;			/* Non-zero: don't create output file. */
extern bool		link_freeze_args_flag;	/* TRUE: don't allow changes to some arguments. */
extern ulong	max_file_name;			/* Maximum full file name. */
extern ulong	max_short_file_name;	/* Maximum short file name. */

extern area_node * main_area;	/* The area containing the main function. */
extern dict_node * main_dict;	/* The dict node for the main function. */
extern file_node * main_file;	/* The file containing the main function. */
extern unit_node * main_unit;	/* The unit containing the main function. */

	/* Global lists of nodes. */

extern file_node *	file_info_list;			/* List of all file info nodes. */
extern dict_node *	dict_list;				/* List of all dict nodes. */

/*
	Function prototypes.
*/
void		main_quit	(void);
file_node * main_read	(file_node * finfo);
void		main_unload	(file_node * finfo);

#endif /* main_h_ */</t>
<t tx="ekr.20080529093004.1109"></t>
<t tx="ekr.20080529093004.1110">/*
	Link: Argument processing module

	Not all the routines in this module are used in
	all programming environments.

	source:  LKarg.c
	started: November 4, 1993.
	version:
		August 28, 1994.
			Added -bell option and -quit as a synonym for -exit.
		June 26, 1994.
			Added arg_go_flag.
		June 20, 1994.
			Added tuple_map argument.
		May 25, 1994.
			Added code and data command-line arguments.
		May 22, 1994.
			Added +-multi_pass option.
		December 12, 1993.
			Added -start option and arg_main_name variable.
		December 4, 1993.
			Added +-obj_dump option.
		November 22, 1993.
			Bug fix: added break after 'm' case.
		November 5, 1993.
			Removed arg_init_again.  It was replaced by arg_do_argv.
			Removed arg_paths variable.
		November 4, 1993.
			Removed arg_do_dialog.
			Removed most flags.
*/

&lt;&lt; LKarg #includes &gt;&gt;
&lt;&lt; LKarg declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1111">#include "LK.h"

#include "LKarg.h"
#include "LKmain.h"
#include "LKmem.h"
#include "LKnodes.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBlog.h&gt;
#include &lt;LIBos.h&gt;

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.1112">#define MAP_FILE_SUFFIX ".map"

/*
	Define global user flags;
*/

	/* Code generation flags. */
	
char *	arg_code_address = 0;	/* Starting address of code areas. */
bool	arg_code_flag = FALSE;	/* TRUE: use arg_data_address. */
char *	arg_data_address = 0;	/* Starting address of data areas. */
bool	arg_data_flag = FALSE;	/* TRUE: use arg_data_address. */
char *	arg_main_name = "main";	/* Default name of the start function. */

	/* Flags relating to the map file. */

bool 	arg_map_flag = FALSE;			/* TRUE: generate a human-readable map file. */
char *	arg_map_path = NULL;			/* Name of the map file. */
bool	arg_verbose_map_flag = TRUE;	/* TRUE: generate a verbose map. */
bool	arg_map_tree_flag = FALSE;		/* TRUE: generate a map of the parent tree. */
bool	arg_tuple_map_flag = FALSE;		/* TRUE: generate a Tuple compatible load map. */

	/* Debugging and testing flags. */

bool arg_no_out_flag = FALSE;	/* TRUE: suppress output, not code generation. */
bool arg_obj_dump_flag = FALSE;	/* TRUE: dump obj files to debugging stream. */
bool arg_go_flag = FALSE;		/* TRUE: load program and go. */

	/* Other flags. */
	
bool arg_stats_flag = FALSE;		/* TRUE: dump statistics on exit. */
bool arg_verbose_flag = FALSE;		/* TRUE: verbose messages. */
bool arg_srec_flag = FALSE;			/* TRUE: generate S-records. */


/*
	Define the global file paths and files.
*/
char * arg_in_path	= NULL;	/* The current input file. */
char * arg_out_path	= NULL;	/* The current output file. */

static int		arg_save_argc	= 0;	/* Saved argc: used to re-enter arg_do_argv. */
static char **	arg_save_argv	= NULL;	/* Saved argp: used to re-enter arg_do_argv. */

static bool arg_start_flag = FALSE;	/* TRUE: start item already set. */

/*
	Declare internal routines.
*/
static void	arg_help	(void);
static bool arg_prefix	(char *p, char *s);
</t>
<t tx="ekr.20080529093004.1113">@ Set up the program's arguments which are found in an argv vector.  This routine may be re-entered. Return MORE_FILES_REMAIN if no more arguments remain, else NO_MORE_FILES_REMAIN.
@c

#define debug_arg_do_argv(a)

bool
arg_do_argv(int argc, char ** argv, char * on_str, char * off_str)
{
	FTAG("arg_do_argv");
	register char * arg = NULL;
	char * in = NULL,  * out = NULL;
	static char * path_tag = "path name";

	/*
		Do not put Sherlock macros here: Sherlock has not been initialized!
	*/
	SL_DISABLE();

	debug_arg_do_argv(TRACEP(ftag, elp(); eint(argc); ecs(); eptr(argv); erpnl()));

	arg_in_path = NULL;

	if (argv == NULL) {
		argc = arg_save_argc;
		argv = arg_save_argv;
	}

	/* Indicate that no file arguments have been seen yet. */
	in  = NULL;
	out = NULL;

	/* Process all the arguments on the command line. */
	ASSERT(argv != NULL);
	argc--;
	argv++;
	while (argc-- &gt; 0) {

		ASSERT(*argv != NULL);
		arg = *argv++;
		debug_arg_do_argv(TRACEPN(ftag, es("arg: "); es(arg); enl() ));

		if (arg[0] == '@') {
			if (str_eq(arg+1, "goto")) {
				if (argc--) {

					/* Scan forward for the label. */
					char * label = *argv++;
					ecnl(); es("@goto "); es(label); enl();
					while(argc--) {
						arg = *argv++;
						if (str_eq(label, arg)) {
							break;
						}
					}
				}
				else {
					es("Trailing @goto\n");
					end_usage();
				}
			}
			else {
				/* Ignore the label. */
				;
			}
		}
		else if (arg[0] == '+' || arg[0] == '-') {

			bool arg_bool = (arg[0] == '+');

			arg++;

			switch(arg[0]) {

			case 'a':
			case 'b':
				
				if (str_eq(arg, "bell")) {
					#ifdef THINK_C
						SysBeep(20);
					#endif
				}
				else {
					goto unknown_option;
				}
				break;
				
			case 'c':
				if (str_eq(arg, "code")) {
					if (argc--) {
						char *	end = NULL;
						arg = *argv++;
						arg_code_address = (char *) strtoul(arg, &amp;end, 16);
						if (*end == '\0') {
							arg_code_flag = TRUE;
							if (arg_verbose_flag) {
								ecnl(); es("code areas start at: ");
								eptr(arg_code_address); ecnl();
							}
						}
						else {
							error(es("bad code address: "); es(arg); es(", 0 assumed"));
							arg_code_address = 0;
						}				
					}
					else {
						es("Trailing 'code' argument\n");
						end_usage();
					}
				}
				else {
					goto unknown_option;
				}
				break;
				
			case 'd':
				if (str_eq(arg, "data")) {
					if (argc--) {
						char *	end = NULL;
						arg = *argv++;
						arg_data_address = (char *) strtoul(arg, &amp;end, 16);
						if (*end == '\0') {
							arg_data_flag = TRUE;
							if (arg_verbose_flag) {
								ecnl(); es("data areas start at: ");
								eptr(arg_data_address); ecnl();
							}
						}
						else {
							error(es("bad data address: "); es(arg); es(", 0 assumed"));
							arg_data_address = 0;
						}				
					}
					else {
						es("Trailing 'data' argument\n");
						end_usage();
					}
				}
				else {
					goto unknown_option;
				}
				break;

			case 'e':

				if (str_eq(arg, "exit")) {
					return NO_MORE_FILES_REMAIN;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'f':
				goto unknown_option;

			case 'g':
			
				if (str_eq(arg, "go")) {
					arg_go_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'h':
			case 'i':
			case 'j':
			case 'k':
				goto unknown_option;

			case 'm':

				if (str_eq(arg, "map")) {
					arg_map_flag = arg_bool;
				}
				else if (str_eq(arg, "map_name")) {

					if (argc--) {

						/* Override a previos definition.  This is harmless. */
						arg = *argv++;
						arg_map_path = arg;
					}
					else {
						es("Trailing +-map_name\n");
						end_usage();
					}

				}
				else if (str_eq(arg, "map_tree")) {
					arg_map_tree_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'n':

				if (str_eq(arg, "no_output")) {
					arg_no_out_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'o':

				if (str_eq(arg, "obj_dump")) {
					arg_obj_dump_flag = arg_bool;
				}
				else if (str_eq(arg, "of")) {
					if (argc--) {
						out = arg = *argv++;
						if (os_bytes_file) {
							es("Ignoring duplicate -of "); es(out); ecnl();
						}
					}
					else {
						es("Trailing +-of\n");
						end_usage();
					}
				}
				else {
					goto unknown_option;
				}
				break;

			case 'p':
			case 'q':
			
				if (str_eq(arg, "quit")) {
					return NO_MORE_FILES_REMAIN;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'r':
				goto unknown_option;

			case 's':
			
				if (str_eq(arg, "srec")) {
					arg_srec_flag = arg_bool;
				}
				else if (str_eq(arg, "start")) {
					if (argc--) {
						arg = *argv++;
						if (arg_start_flag) {
							es("Ignoring -start "); es(arg); ecnl();
						}
						else {
							arg_main_name = arg;
							arg_start_flag = TRUE;
						}
					}
					else {
						es("Trailing +-start\n");
						end_usage();
					}
				}
				else if (str_eq(arg, "stats")) {
					arg_stats_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 't':
				if (str_eq(arg, "tuple_map")) {
					arg_tuple_map_flag = arg_bool;
					arg_map_flag = TRUE;
				}
				else {
					goto unknown_option;
				}

			case 'u':
				goto unknown_option;

			case 'v':

				if (str_eq(arg, "v")) {
					arg_verbose_flag = arg_bool;
				}
				else if (str_eq(arg, "verbose_map")) {
					arg_verbose_map_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'w':
				goto unknown_option;

			default:

				if (str_eq(arg, "?")) {
					/* Write the help message and go on. */
					arg_help();
					break;
				}

			unknown_option:

			#ifdef PRODUCTION
				if (on_str &amp;&amp; arg_prefix(on_str+1, arg)) {
				
					/* Ignore a Sherlock argument. */
					char * s = arg + strlen(on_str) - 1;
					if (*s == '&gt;' &amp;&amp; *(s+1) == '&gt;') {
						log_open(0, s+2);
					}
				}
				else if (off_str &amp;&amp; arg_prefix(off_str+1, arg)) {
					/* Ignore a Sherlock argument. */
					;
				}
				else {

					es("ignoring unknown command-line option: ");
					es(arg_bool ? "+" : "-"); es(arg); enl();
				}
			#else
				;
			#endif

			} /* end +- option switch */
		}
		else if (in == NULL) {
			in = arg;
			break;
		}
	}

	/* Make sure that the input file name was provided. */
	if (in == NULL) {
		es("Missing input file argument.\n");
		end_usage();
	}

	/* Remember the input path. */
	arg_in_path = in;

	/* Create the output path if the output file has not been opened. */
	if (arg_out_path == NULL) {
		if (out) {
			arg_out_path = out;
		}
		else {
			es("Missing -of: input file: "); es(in); ecnl();
			end_usage();
		}
	}
	
	/*
		Create the name of the map file from the output file
		unless the name of the map file was given explicitly.
	*/
	if (arg_map_flag &amp;&amp; arg_map_path == NULL) {
	
		/* Create a file name from the output file name. */
		ASSERT(arg_out_path);
		new_size_macro(
			arg_map_path,
			strlen(arg_out_path) + strlen(MAP_FILE_SUFFIX) + 1,
			perm_life, string_stats);
		strcpy(arg_map_path, arg_out_path);
		strcat(arg_map_path, MAP_FILE_SUFFIX);
	}

	if (argc &gt; 0) {
		arg_save_argv = argv - 1;
		arg_save_argc = argc + 1;
	}
	else {
		arg_save_argv = NULL;
	}
	return MORE_FILES_REMAIN;

}</t>
<t tx="ekr.20080529093004.1114">@ End arg_do_arg
@c

#undef debug_arg_do_argv

/*
	Output a usage message.
*/
static void
arg_help(void)
{
	ecnls(2);

#ifdef SHERLOCK
	es("usage: Link [++--routine] [options] &lt;list of input files&gt;\n");
#else
	es("usage: Link [options] &lt;list of input files&gt;\n");
#endif

	ecnls(2);
	es("options...\n");
	es("+-bell            Make a bell sound\n");
	es("code &lt;hex addr&gt;   Starting address of code areas\n");
	es("data &lt;hex addr&gt;   Starting address of data areas\n");
	es("-exit             Terminate option list\n");
	es("@goto &lt;label&gt;     Scan forward to label\n");
	es("+-map             Generate a map file\n");
	es("+-map_name &lt;file&gt; Specify the name of the map file\n");
	es("+-map_tree        Generate the calling tree in the map file\n");
	es("+-no_output       Suppress output\n");
	es("+-obj_dump        Dump the object files\n");
	es("-of &lt;file&gt;        Specify output file (required)\n");
	es("+-srec            Generate Motorola S-records\n");
	es("-start &lt;name&gt;     Specify name of entry point (default is \"main\"\n");
	es("+-stats           Dump statistics\n");
	es("+-tuple_map       Generate a Tuple format map file\n");
	es("+-v               Verbose output\n");
	es("+-verbose_map     Generate a verbose map file\n");
	es("-?                Print this message\n");
	enl();
}
</t>
<t tx="ekr.20080529093004.1115">@ Return TRUE if string p is a prefix of string s.
@c

static bool
arg_prefix(char *p, char *s)
{
	while (*p) {
		if (*p++ != *s++) {
			return FALSE;
		}
	}
	return TRUE;
}
</t>
<t tx="ekr.20080529093004.1116">/*
	Link: initialization code.

	source:  LKinit.c
	started: November 4, 1993.
	version:
		April 30, 1994.
			Added code to initialize memory lifetimes and statistics.
		January 8, 1994.
*/

/* Always allow Sherlock macros, especially SL_PARSE. */
#undef NO_SHERLOCK

/* include these *before* Sherlock is included. */

#ifdef applec
	#ifndef __size_t__	/* This is used in the MPW headers. */
  	#define __size_t__
		typedef unsigned long size_t;
	#endif

&lt;&lt; LKinit #includes &gt;&gt;
&lt;&lt; LKinit declarations &gt;&gt;
@others

#endif /* THINK_C */
</t>
<t tx="ekr.20080529093004.1117">#include &lt;Memory.h&gt;	/* For MaxApplZone. */
</t>
<t tx="ekr.20080529093004.1118">#endif

#ifdef THINK_C

#include &lt;LoMem.h&gt;

#include &lt;Dialogs.h&gt;
#include &lt;Fonts.h&gt;
#include &lt;Menus.h&gt;
#include &lt;Quickdraw.h&gt;
#include &lt;OSEvents.h&gt;
#include &lt;Windows.h&gt;
#endif

#include "LK.h"

#include "LKarg.h"
#include "LKinit.h"
#include "LKmain.h"
#include "LKmem.h"
#include "LKnodes.h"
#include "LKst.h"

#include &lt;mac_about_dialog.h&gt;
#include &lt;mac_gui.h&gt;

#include &lt;LIBcmnd.h&gt;
#include &lt;LIBend.h&gt;
#include &lt;LIBenv.h&gt;
#include &lt;LIBlog.h&gt;
#include &lt;LIBobj.h&gt;

/*
Function prototypes for internal routines.
The call-back routines are only needed when windows are used.
*/
#ifdef THINK_C
static void dump1_call_back	(void);
static void dump2_call_back	(void);
static void dump3_call_back	(void);
static void	event_call_back	(void);
</t>
<t tx="ekr.20080529093004.1119">#endif

/*
	Initialize the environment, Sherlock and all modules.

	The argv vector is not used in some environments, so it is possible
	that a compiler could generate a warning to that effect,
	but trying to eliminate that warning would not be wise:
	we definitely want all initialization done by a single routine.
*/
void
init_all(int argc, char ** argv)
{
	FTAG("init_all");

/*
	When using Think C, we must completely initialize the Mac Toolbox,
	since we are building a stand-along application.

	When using MPW, we must *not* initialize the Toolbox, nor call MaxApplZone.
	Also, we do *not* call InitGraf, since Sherlock uses standard io under MPW.
*/

#ifdef THINK_C

	void * ApplLimit1;		/* Original values before heap and stack are changed. */
	void * CurStackBase1;
	void * HeapEnd1;
	void * ApplZone1;

	/*
		Initialize the ToolBox routines.

		Warning:

		*never* put anything before the follwing instructions.
		Even an inocuous-looking routine like tok_init will crash MaxApplZone().
	*/
	InitGraf( (Ptr) &amp;(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent,0);
	InitWindows();
	InitMenus();
	TEInit();
	InitDialogs(0L);
	InitCursor();

	/* These are defined in LoMem.h, which only exists for Think C. */
	ApplLimit1 = ApplLimit;
	CurStackBase1 = CurStackBase;
	HeapEnd1 = HeapEnd;
	ApplZone1 = ApplZone;

	SetApplLimit( (Ptr)(CurStackBase - 9000));
	MaxApplZone();
	
	/*
		Initialize the memory manager.
		This can and should be done before all other initializations.
	*/
	perm_life =	mem_init_life("perm lifetime");
	
	area_stats =		mem_init_stats (perm_life, "area nodes");
	area_bytes_stats =	mem_init_stats (perm_life, "area bytes");
	dict_stats =		mem_init_stats (perm_life, "dict nodes");
	dlist_stats =		mem_init_stats (perm_life, "dict list nodes");
	info_stats =		mem_init_stats (perm_life, "file info nodes");
	flist_stats =		mem_init_stats (perm_life, "file list nodes");
	ref_stats = 		mem_init_stats (perm_life, "ref nodes");
	string_stats =		mem_init_stats (perm_life, "strings");
	unit_stats =		mem_init_stats (perm_life, "unit nodes");

	/*
		Notice that the Sherlock menu is used only if Sherlock is defined.
	*/
	w_mac_init(
		SL_VERSION_NAME,			/* version name from sl.h. */
		FALSE,						/* Initialize the Macintosh ToolBox. */
		TRUE,						/* TRUE: output to Sherlock window. */
		"Link Log",					/* Name of Sherlock window (if used). */
		TRUE,						/* TRUE: open Sherlock window. */
		TRUE,						/* TRUE: Insert standard menus.	 */
		SHERLOCK_DEFINED,			/* TRUE: Insert Sherlock menu. */
		TRUE,						/* TRUE: Insert first item in apple menu. */
		(pstring) "\pAbout Link...",	/* Title of first item in apple menu. */
		&amp;about_dialog,				/* CallBack routine for first apple item. */
		TRUE,						/* TRUE: Insert menus immediately. */
		&amp;event_call_back,			/* Event callback routine. */
		&amp;dump1_call_back,			/* First user callback routine. */
		(pstring) "\pObjects",		/* Name of first user menu item. */
		&amp;dump2_call_back,			/* Second user callback routine. */
		(pstring) "\pObject Stats",	/* Name of second user menu item. */
		&amp;dump3_call_back,			/* Third user callback routine.	*/
		(pstring) "\pHeap Stats"	/* Name of third user menu item. */
	);

#endif

	SL_INIT();

	#ifdef THINK_C
		init_args(&amp;argc, &amp;argv, "Link Args", "++", "--");
	#endif

	#ifdef applec
		init_args(&amp;argc, &amp;argv, "Link MPW args", "++", "--");
	#endif

	/* Enable traces of routines used to read Sherlock arguments. */
	SL_PARSE(argc, argv, "++", "--");

	STATB(ftag);

	/* Watch location 0.  This test catches *p = x where p is NULL. */
	SL_WATCH(0, 4, "loc 0");

	/* Parse the program arguments. */
	arg_do_argv(argc, argv, "++", "--");

	/* Sign on *after* opening the log file. */
	ecnl(); es(lib_version); ecnl();

	TRACEPN("-show_args",

		int i = 0;
		ecnl();
		while (argv[i]) {
			es("argv["); eint(i); es("]: "); es(argv[i]); enl();
			i++;
		}
	);

#define line(a) epads(#a,14); epadptr(a ## 1, 10); epadptr(a, 10); enl();

	#ifdef THINK_C
		TRACEN("-zone",
			void * Sp = env_stackPtr();
			ecnl();
			epads(" ", 14); epads("Before", 10); epads("After", 10); enl();
			line(CurStackBase);
			line(ApplLimit);
			line(HeapEnd);
			line(ApplZone);
			enl();
		);
	#endif

#undef line

	/* Perform once-only initialization of various modules. */
	st_init();

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1120">@ The call-back routines are only needed when windows are used.
@c

#ifdef THINK_C

/*
	"Call-back" routines for event processing when Sherlock outputs a line.
*/
static void
event_call_back(void)
{
	SL_DISABLE();

	#ifdef THINK_C
		if (w_applEvent(0) == FALSE) {
			end_quit();
		}
	#endif
}
</t>
<t tx="ekr.20080529093004.1121">static void
dump1_call_back(void)
{
	SL_DISABLE();

	#ifndef PRODUCTION
		ecnls(2);
		obj_dump_objects("Sherlock User Report");
	#endif

	ecnl();
}
</t>
<t tx="ekr.20080529093004.1122">static void
dump2_call_back(void)
{
	SL_DISABLE();

	#ifndef PRODUCTION

		ecnls(2);
		obj_dump_stats("Sherlock User Report: ");
		ecnl();

	#endif

	ecnl();
}
</t>
<t tx="ekr.20080529093004.1123">static void
dump3_call_back(void)
{
	SL_DISABLE();

	#ifndef PRODUCTION
		ecnls(2); es("Sherlock User Report: ");
		env_dump_stats();
		ecnl();
	#endif
}
</t>
<t tx="ekr.20080529093004.1124">/*
	Link: Main routine.

	source:  LKmain.c
	started: November 4, 1993.
	version: October 31, 1994.
		++TMON_symbols passes symbols to TMON.
		(was actually installed in September.)
*/

/* Always allow Sherlock macros in this file. */
#undef NO_SHERLOCK

&lt;&lt; LKmain #includes &gt;&gt;
&lt;&lt; LKmain declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1125">#include "LK.h"

#include "LKarg.h"
#include "LKfscan.h"
#include "LKinit.h"
#include "LKlink.h"
#include "LKload.h"
#include "LKmain.h"
#include "LKmap.h"
#include "LKmark.h"
#include "LKmem.h"
#include "LKnodes.h"
#include "LKout.h"
#include "LKst.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBenv.h&gt;
#include &lt;LIBio.h&gt;
#include &lt;LIBobj.h&gt;
#include &lt;LIBos.h&gt;

#include &lt;pascal.h&gt;
</t>
<t tx="ekr.20080529093004.1126">/*
	Global variables owned by this module.
*/

	/* The user memory. */
	
char * main_user_mem = NULL;

	/* General status information. */
	
long	link_err_count = 0;				/* Non-zero: don't create output file. */
bool	link_freeze_args_flag = FALSE;	/* TRUE: don't allow changes to some arguments. */
ulong	max_file_name = 5;				/* Maximum full file name. */
ulong	max_short_file_name = 5;		/* Maximum short file name. */


	/* Info about the main function. */

area_node *	main_area = NULL;	/* The area containing the main function. */
dict_node * main_dict = NULL;	/* The dict node for the main function. */
file_node *	main_file = NULL;	/* The file containing the main function. */
unit_node * main_unit = NULL;	/* The unit containing the main function. */

	/*
		Global lists of files and items.
		
		The file_info_list is the root of the tree of all in-memory nodes.
		link_check() uses dict_list to check for undefined or multiply-defined labels.
		The mapping routines use the code and data area lists to produce sorted maps.
	*/

file_node *	file_info_list = NULL;			/* List of all file info nodes. */
dict_node * dict_list = NULL;				/* List of all dict nodes. */

/*
	Prototypes of internal routines.
*/
static void main_dump			(char * mem_start, long mem_length);
static void main_TMON_area		(area_node * ap);
static void main_TMON_symbols	(void);
</t>
<t tx="ekr.20080529093004.1127">@ The main line of the linker.
@c

void
main(int argc, char **argv)
{
	/* Call to STATB and STATX in this routine would just distort the statistics. */
	SL_DISABLE();

	#if 0 /* Remember: this will not work if the Think C debugger is on. */
		DebugStr("\pmain");
	#endif

	/* Absolutely *no* calls to Sherlock before init_all is called! */
	init_all(argc, argv);

	/* Open the map file now so that some error messages can be sent to the map file. */
	if (arg_map_flag) {
	
		ASSERT(os_text_file == NULL);

		/* Open the .map file. */
		os_text_file = io_create(arg_map_path, FALSE, IO_TEXT_FILE);
		if (os_text_file == NULL) {
			error(es("Can not create "); es(arg_map_path));
		}
		else {
			map_header();
		}
	}
	
	/* Read each file only once. */
	while (arg_in_path) {
	
		file_node * finfo = NULL;
	
		/* "Can not open" error message should not refer to the previous file. */
		err_begin_file("");
	
		/* Read the input block and describe it in an info node. */
		finfo = main_read(NULL);
			
		/* Convert the object file into in-memory data structures. */
		if (finfo) {
		
			TRACEP("-main_dump",
				main_dump(char_ptr(finfo -&gt; file_header), finfo -&gt; file_length));

			fscan_preprocess(finfo);
		}
		
		#if 0 /* No longer used. */
		if (arg_multi_pass_flag) {
			main_unload(finfo);
		}
		#endif

		if (arg_do_argv(0, NULL, NULL, NULL) != MORE_FILES_REMAIN) {
			break;
		}
	}
	
	/* Error messages from here on should not refer to a specific file. */
	err_begin_file("");
	
	/* Mark all files to be included in the application. */
	mark();
	
	/*
		Allocate space for the program.
		Set the code and data load addresses so link() will use the correct values.
	*/
	if (arg_go_flag) {
		load_create_user_mem();
	}
	
	/*
		Compute the load address of all marked areas,
		resolve all references and write all marked areas.
	*/
	link();
	
	/* Create the map file if requested. */
	if (arg_map_flag &amp;&amp; os_text_file) {

		if (arg_verbose_flag) {
			ecnl(); es("Writing: "); es(arg_map_path); ecnl();
		}

		if (arg_tuple_map_flag) {
			map_all_areas();
		}
		else {
			if (arg_map_tree_flag) {
				map_tree();
			}
			map_all_areas();
			map_all_files();
		}
		io_close(os_text_file);
	}
	
	/* Create the load file unless we are in load/go mode. */
	if (!arg_go_flag &amp;&amp; arg_out_path) {

		ASSERT(os_bytes_file == NULL);
		os_bytes_file = io_create(arg_out_path, FALSE, IO_BINARY_FILE);

		if (link_err_count) {
			ecnl(); es(arg_out_path); es(" not written because of errors\n");
			io_close(os_bytes_file);
			os_bytes_file = NULL;
		}
		else if (os_bytes_file == NULL) {
			error(es("Can not create "); es(arg_out_path));
		}
		else {

			if (arg_verbose_flag) {
				ecnl(); es("Writing: "); es(arg_out_path); ecnl();
			}
			
			/* Output the executable file. */
			out_file();
			
			io_close(os_bytes_file);
			os_bytes_file = NULL;
		}
	}
	
	/* Execute the user program if +go was specified. */
	if (arg_go_flag) {
		if (link_err_count) {
			ecnl(); es("Errors prevent execution.\n");
		}
		else {
		
			/*
				Pass the address of all areas to TMON using
				AddLabel commands embedded in DebugStr strings.
			*/
			TRACEP("TMON_symbols",
				main_TMON_symbols();
			);
			load_user_mem();
			ecnl(); es("LKmain: calling _user_startup...\n");
			_user_startup();
		}
	}
	
	/* Report statistics and exit. */
	main_quit();
	end_done();
}
</t>
<t tx="ekr.20080529093004.1128">@ Print a block.
@c

static void
main_dump (char * mem_start, register long mem_length)
{
	FTAG("main_dump");
	register int i = 0;
	register char * p = mem_start;
	STATB(ftag);

	for (i = 0; i &lt; mem_length; i++) {
		echar(*p++);
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1129">@ Free all dynamic structures and do end-of-program dumps. This is also called on normal termination and when the user interrupts the compiler.
@c

void
main_quit(void)
{
	FTAG("main_quit");
	STATB(ftag);

#ifndef PRODUCTION

	/* Free all paths, path names and argument strings. */
	mem_free_life(perm_life);

	TRACEP("-link_mem_stat",	mem_dump_stats(perm_life, FALSE));
	TRACEP("-link_obj_stat",	obj_dump_stats("link dumps"));
	TRACEP("-link_obj_show",	obj_dump_objects("link dumps"));
	TRACEP("-link_env_stat",	env_dump_stats());
	TRACEP("-link_sldump",		sl_dump());

#endif

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1130">@ Read one relocatable file. If finfo is NULL, create a file info node.
@c

file_node *
main_read(register file_node * finfo)
{
	FTAG("main_read");
	register io_mem_block * input_block = NULL;
	register long hash = 0;
	TRACEPB(ftag, es("reading "); es(finfo ? finfo -&gt; file_name : arg_in_path); ecnl());
	ASSERT(arg_in_path || finfo);
	
	/* Return NULL if the input file has already been read in pass 1. */
	if (finfo == NULL) {
		hash = fst_hash(arg_in_path);
		if (fst_lookup(arg_in_path, hash)) {
			error(es("ignoring duplicate file: "); es(arg_in_path); ecnl());
			finfo = NULL;
			goto done;
		}
	}
	else {
	
		/*
			There is no need to check for duplicate files in pass 2 since
			pass 1 does not create info nodes for duplicate files.
		*/
		arg_in_path = finfo -&gt; file_name;
	}
	
	max_file_name		= max(max_file_name, strlen(arg_in_path));
	max_short_file_name = max(max_short_file_name, strlen(cvt_short_fn(arg_in_path)));

	/* Read the object file into a buffer. */
	input_block = io_read_all(arg_in_path, CANT_MESSAGE, IO_BINARY_FILE);
	if (input_block == NULL) {
		finfo = NULL;
		goto done;
	}
	
	/* Set the input file name for error messages. */
	err_begin_file(arg_in_path);

	/* Create an info node and link it into the global file list. */
	if (finfo == NULL) {
	
		if (arg_verbose_flag) {
			ecnl(); es("Reading..."); es(arg_in_path); ecnl();
		}
	
		/* Create a file info node describing the current input file. */
		new_perm_macro(finfo, info_stats);
		finfo -&gt; file_name = arg_in_path;
		finfo -&gt; file_header = f_header_ptr(input_block -&gt; mem_start);
		finfo -&gt; file_length = input_block -&gt; mem_length;
		finfo -&gt; file_mem_block = input_block;

		/* Add the info node to the global file list. */
		finfo -&gt; file_next = file_info_list;
		file_info_list = finfo;

		/* Remember that we have seen this file. */
		fst_enter(finfo, hash);
	}
	else {
	
		/* Reset the buffer parameters for the re-read file. */
		finfo -&gt; file_header = f_header_ptr(input_block -&gt; mem_start);
		finfo -&gt; file_length = input_block -&gt; mem_length;
		finfo -&gt; file_mem_block = input_block;
	}

done:
	STATX(ftag);
	return finfo;
}
</t>
<t tx="ekr.20080529093004.1131">@ Pass the address of all areas to TMON using AddLabel commands embedded in DebugStr strings.
@c

static void
main_TMON_symbols(void)
{
	FTAG("main_TMON_symbols");
	register file_node * finfo = NULL;
	register unit_node * up = NULL;
	register area_node * ap = NULL;
	STATB(ftag);
	
	/* Output all labels in data areas. */
	for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
		for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
			ap = up -&gt; unit_data_area;
			if (ap &amp;&amp; area_is_marked(ap)) {
				main_TMON_area(ap);
			}
		}
	}
	
	/* Output all labels in code areas. */		
	for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
		for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
			ap = up -&gt; unit_code_area;
			if (ap &amp;&amp; area_is_marked(ap)) {
				main_TMON_area(ap);
			}
		}
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1132">static void
main_TMON_area(register area_node * ap)
{
	FTAG("main_TMON_area");
	register dlist_node * dlp = NULL;
	char buf [1000];
	char num [100];
	STATB(ftag);
	
	/*
		Just output the area dict.
		Defining all labels overflows TMON's tables.
		Even as it is, we must give TMON about 500K of heap space.
	*/
	if (ap -&gt; area_dict) {

		dict_node * dp = ap -&gt; area_dict;
		char * name = dp -&gt; dict_name;
		
		/*
			Don't add labels containing "@sl_h_@".
			These Sherlock handles are useless.
		*/
		if (strstr(name, "@sl_h_@") != NULL) {
			goto done;
		}
				
		/* Create a TMON AddLabel command, preceded by ??  */
		strcpy(buf, "?? AddLabel ");
		
		/* Change @ signs to underscores. */
		{
			register char * s = name;
			register char * p = &amp;buf[strlen(buf)];
			while (*s) {
				*p = (*s == '@') ? '_' : *s;
				p++; s++;
			}
			*p = '\0';
		}
		strcat(buf, ", $");
		cvt_ptr(num, 100, dp -&gt; dict_offset + ap -&gt; area_base);
		strcat(buf, num);
		strcat(buf, "//");
		
		TRACEPN("TMON_symbols_v", es(buf); enl());

		c2pstr(buf);
		
		#if 1 /* Remember: this will not work if the Think C debugger is on. */
			DebugStr( (unsigned char *) buf);
		#endif
	}
	
done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1133">@ Unload the indicated file from memory.
@c

void
main_unload(file_node * finfo)
{
	FTAG("main_unload");
	TRACEPB(ftag, es("unloading "); es(finfo -&gt; file_name); ecnl());
	ASSERT(finfo &amp;&amp; finfo -&gt; file_mem_block &amp;&amp; finfo -&gt; file_mem_block -&gt; mem_freep);

	obj_free_macro(finfo -&gt; file_mem_block -&gt; mem_freep);
	obj_free_macro(finfo -&gt; file_mem_block);
	finfo -&gt; file_mem_block = NULL;
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1134"></t>
<t tx="ekr.20080529093004.1135"></t>
<t tx="ekr.20080529093004.1136">/*
	Link: header file for the file checking routines.

	source:  LKcheck.h
	started: May 16, 1994
	version: May 16, 1993.
*/

/*
	Make sure this header is included only once.
*/

#ifndef LKcheck_h_
#define LKcheck_h_

#pragma once

void check_ofile	(file_node * finfo);
void	check_oops	(char * message, file_node * finfo);

#endif /* LKcheck_h_ */
</t>
<t tx="ekr.20080529093004.1137">/*
	Link: header file for dumping routines.

	source:  LKdump.h
	started: May 16, 1994.
	version: May 18, 1994.
*/

/*
	Make sure this header is included only once.
*/

#ifndef LKdump_h_
#define LKdump_h_

#pragma once

#include &lt;LIBofile.h&gt;

	/* Information used in dumps. */

extern short max_area_name;		/* Width of longest area name. */
extern short max_dict_name;		/* Width of longest label. */
extern short max_unit_name;		/* Width of longest unit name. */

void dump_area		(area_node * ap);
void dump_dict		(dict_node * dp);
void dump_f_area	(f_area_node * a);
void dump_f_header	(f_header * h);
void dump_f_unit	(f_unit_node * u);
void dump_trailer	(file_node * finfo);
void dump_unit		(unit_node * up);

#endif /* LKdump_h_ */
</t>
<t tx="ekr.20080529093004.1138">/*
	Link: header file for the file scanning routines.

	source:  LKfscan.h
	started: November 21, 1993
	version: May 22, 1994.
*/

/*
	Make sure this header is included only once.
*/

#ifndef fscan_h_
#define fscan_h_

#pragma once

	/* Synonyms for link_code_flag are defined in LKlink.h */

void fscan_preprocess	(file_node * finfo);
void fscan_rescan		(file_node * finfo, bool link_code_flag);

#endif /* fscan_h_ */
</t>
<t tx="ekr.20080529093004.1139">/*
	Link: header file for reference linking routines.

	source:  LKlink.h
	started: November 21, 1993
	version: June 28, 1994.
*/

#ifndef LKlink_h_
#define LKlink_h_

#pragma once

	/* Synonyms for link_code_flag argument of various routines. */
	enum {LINK_CODE_AREA = TRUE, LINK_DATA_AREA = FALSE};

void link (void);

#endif /* LKlink_h_ */
</t>
<t tx="ekr.20080529093004.1140">/*
	Link: header file LKload.c

	source:  LKload.h
	started: June 27, 1994.
	version: January 20, 1995.
*/

/*
	Make sure this header is included only once.
*/

#ifndef LKload_h_
#define LKload_h_

#pragma once

	/* Define the table that initializes the jump table. */
	
#define JUMP_TABLE_ENTRIES 31

#define JMP_ABS_LONG 0x4ef9		/* JMP (xxx).l */

typedef struct jump_struct jump;		/* A jump instruction in the jump table. */

struct jump_struct {
	short	op_code;
	void *	address;
};

extern void * jump_table_address[JUMP_TABLE_ENTRIES];

	/* Prototypes. */
	
void load_create_user_mem	(void);
void load_user_mem			(void);
void _user_startup			(void);

#endif /* LKload_h_ */
</t>
<t tx="ekr.20080529093004.1141">/*
	Link: header file for the map output routines.

	source:  LKmap.h
	started: November 21, 1993
	version: May 28, 1994.
*/

/*
	Make sure this header is included only once.
*/

#ifndef map_h_
#define map_h_

#pragma once

void map_all_areas 			(void);
void map_all_files 			(void);
void map_begin_comment_line	(void);
void map_header				(void);
void map_grand_totals		(char * message);
void map_one_file 			(file_node * finfo);
io_file * map_open			(void);
void map_tree				(void);

#endif /* map_h_ */
</t>
<t tx="ekr.20080529093004.1142">/*
	Link: header file for the item marking routines.

	source:  LKmark.h
	started: November 21, 1993
	version: June 19, 1994.
*/

#ifndef LKmark_h_
#define LKmark_h_

#pragma once

extern ulong mark_code_total;	/* Sum of sizes of all marked code areas. */
extern ulong mark_data_total;	/* Sum of sizes of all marked code areas. */

void mark (void);

#endif /* LKmark_h_ */
</t>
<t tx="ekr.20080529093004.1143">/*
	Link:	Header file describing all in-memory data structures.
			See LIBofile.h for f_xxx nodes describing the format of the object file.
	
	This file is the heart of the linker.

	source:  LKnodes.h
	started: November 4, 1993.
	version:
		February 6, 1995.
			Added area_comments field.
		May 9, 1994.
			Removed definitions of object file.
			These are now defined in LIBofile.h.
		April 30, 1994.
			Removed all mem_xxx_macros.
		December 20, 1993.
			Protected all typedefs.
		December 9, 1993.
			Added item_def_count field.
		December 6, 1993.
			Bug fix: xxx_ptr macros must expand to ((xxx *) (p))
			That is, the parenthesese around p are *required*.
		November 19, 1993.
			Added LOCAL_IFLAG and related macros.
		November 11, 1993.
			Added definitions of headers, info nodes, item nodes and ref nodes.
*/

#ifndef LKnodes_h_
#define LKnodes_h_

	/* This file inherits the definition of flag bits from LIBofile.h. */
	
#include &lt;LIBofile.h&gt;

#pragma once

/*
	Define abbreviations.
*/

#define char_ptr(p) ((char *) (p))
#define ref_ptr(p)	((ref_node *) (p))

/*
	Define typedefs for all structures defined in this file.
*/

#ifndef TYPEDEF_LK_NODES
	#define TYPEDEF_LK_NODES
	typedef struct area_node_struct		area_node;
	typedef struct dict_node_struct 	dict_node;
	typedef struct dlist_node_struct	dlist_node;
	typedef struct file_node_struct 	file_node;
	typedef struct flist_struct			flist_node;
	typedef struct ref_node_struct		ref_node;
	typedef struct unit_node_struct		unit_node;
#endif

/*
	An area consists of an ordered sequence of bits, specified by a byte list.
*/
struct area_node_struct {

		/* About the area. */

	unit_node *	area_unit;	/* The unit containing this area. */
	dict_node * area_dict;	/* The dict node for the label, or NULL. */
	char	 *	area_name;	/* The first label of this area, or NULL. */

		/* Lists. */
			
	dlist_node * area_dict_def_list;	/* List of all labels defined in the area. */
	dlist_node * area_dict_ref_list;	/* List of all labels referenced in the area. */
	f_comment *	 area_comments;			/* Pointer to comment list. */
	
		/* Definition fields. */
			
	ulong		area_length;	/* Size of the area in bytes. */
	char *		area_pointer;	/* Pointer to the area in memory. */
	char *		area_base;		/* Address of the area in the of application. */
	ref_node *	area_refs;		/* The references from this area to dict nodes. */
	unit_node *	area_parent;	/* The *unit* causing the area to be marked. */
	
		/* Flags are local to the linker. */
		
	ushort	area_flags;		/* Flags: defined below. */
};

	enum {
		MARK_AFLAG = 0x01	/* TRUE: the area has been marked for inclusion. */
	};

#define area_is_marked(i)	((((i) -&gt; area_flags) &amp; MARK_AFLAG) != 0)
#define area_set_marked(i)	{ (i) -&gt; area_flags |= MARK_AFLAG; }

/*
	dict nodes describe a label, that is, an address in an area.
	
	Preprocessing creates dict_nodes from the symbol dictionary in the object file.
*/

static struct dlist_node_struct {
	dlist_node *dlist_next;
	dict_node *	dlist_dict;
};

static struct dict_node_struct {

		/* Lists. */
		
	dict_node *	dict_global_next;	/* List of all dict nodes. */
	dict_node * dict_file_next;		/* List of all dict nodes in the file. */
	flist_node *dict_def_flist;		/* List head of files in which label is defined. */
	flist_node *dict_ref_flist;		/* List head of files in which label is referenced. */

		/* Symbol table. */

	dict_node *	dict_st_next;	/* Pointer to next node on the bucket list. */
	char *		dict_name;		/* The name of the label. */
	
		/* Semantic information. */
		
	area_node *	dict_area;		/* The area in which the label is defined. */
	ulong		dict_offset;	/* Offset of the label within the area, in bytes. */
	ulong		dict_def_count;	/* The number of times this label has been defined. */
	ulong		dict_ref_count;	/* The number of times this label has been referenced. */
	
		/* Dictionary flags are the same whether on disk or in memory. */

	short	dict_flags;		/* Dict flags:  see LIBofile.h. */
};

/*
	File info nodes describe object files.
	They are used during scanning and when making error messages, statistics,
	and map files.
	
	All nodes can be found by scanning down the global list of file nodes.
*/
struct file_node_struct {

		/* General file info. */
	
	char *			file_name;			/* Name of the file. */
	f_header *		file_header;		/* The file header. */
	ulong			file_length;		/* Length of file. */
	unit_node *		file_unit_list;		/* List of unit nodes in the file. */
	io_mem_block *	file_mem_block;		/* Description of the file in memory. */
	ulong			file_marked_areas;	/* Number of marked areas in the file. */

		/* Lists of info nodes. */

	file_node *	file_next;			/* Pointer to next node on the info list. */
	file_node *	file_st_next;		/* Next bucket on hash table. */
	
		/* Saved array of pointers to units.  Used only by fscan_rescan. */
		
	unit_node **	file_unit_ptrs;	/* Pointers to each unit. */
	ulong			file_units;		/* The number of units. */
};

/*
	File list nodes are lists of file info nodes.
*/

struct flist_struct {
	TYPE_LIST(flist_node);
	file_node *	flist_info;
	area_node * flist_area;
};

/*
	Each area contains a list of references contained within the area.
	This list is used by the linker in two ways:
	1) To determine what units to link into the application.
	2) To patch fields within included units.

	Reference nodes represent a reference to a label (dict node)
	with the indicated size and offset from the area containing the list of references.
*/

struct ref_node_struct {

	ref_node *	ref_next;	/* The next node on the reference list. */
	dict_node *	ref_dict;	/* The dict node describing the reference. */
	ulong		ref_offset;	/* Offset from start of area to be patched, in bytes. */
	short		ref_size;	/* The size of the field to be patched, in bytes. */
	short		ref_flags;	/* See LIBofile.h. */
};

/*
	A unit is the smallest element that can be included or excluded from an
	application by the linker.
	
	A unit contains two areas, a data area and a code area, either of which may be empty.
	Both areas of a unit are included in the application if either is referenced.
*/

struct unit_node_struct {

		/* About the unit. */

	char *		unit_name;		/* The first label of this unit, or NULL. */
	area_node *	unit_code_area;	/* The unit's code area. */
	area_node *	unit_data_area;	/* The unit's data area. */

		/* Unit lists. */
	file_node * unit_file;		/* The file containing the unit. */
	unit_node *	unit_file_next;	/* The next unit in the file. */
	unit_node * unit_scan_next;	/* The next unit to be scanned. */
	
		/* Unit flags are the same whether on disk or in memory. */

	short unit_flags;	/* Various flags:  see LIBofile.h. */
};

#endif /* LKnodes_h_ */
</t>
<t tx="ekr.20080529093004.1144">/*
	Link: header file for the output routines.

	source:  LKout.h
	started: November 21, 1993
	version: May 28, 1994.
*/

#ifndef out_h_
#define out_h_

#pragma once

void out_file	(void);

#endif /* out_h_ */
</t>
<t tx="ekr.20080529093004.1145">/*
	Link: header file for the linker symbol table.
	
	source: LKst.h
	started: November 10, 1993.
	version:
		December 10, 1993.
			Added fst_hash routines.
			Added has argument to enter and lookup routines.
*/

/*
	Make sure this file is included only once.
*/

#ifndef st_h_
#define st_h_

#pragma once

/*
	Fuction prototypes.
*/

	/* Symbol table for file info nodes. */

void		fst_enter 	(file_node * fip, long hash);
long 		fst_hash 	(char * s);
file_node *	fst_lookup	(char * symbol, long hash);

	/* Symbol table for item nodes. */

void		st_dump 	(void);
void		st_enter 	(dict_node * ip, long hash);
long 		st_hash 	(char * s);
void		st_init		(void);
dict_node *	st_lookup	(char * symbol, long hash);

#endif /* st_h_ */</t>
<t tx="ekr.20080529093004.1146"></t>
<t tx="ekr.20080529093004.1147">/*	Link: Routines to check the format of object files.
		
	source:  LKcheck.c
	started: May 16, 1994.
	version:
		February 6, 1995.
			Added check_comments.
		May 16, 1994.
*/

&lt;&lt; LKcheck #includes &gt;&gt;
&lt;&lt; LKcheck declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1148">#include "LK.h"

#include "LKarg.h"
#include "LKcheck.h"
#include "LKdump.h"
#include "LKmain.h"
#include "LKnodes.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBofile.h&gt;

#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.1149">/*	
	The ob2p macro returns a pointer equivalent to a file offset or NULL.
	The nzob2p is the same as ob2p except that the offset is known to be non-zero.
	Return NULL if the offset is zero.
	
*/
#define ob2p(offset,base)	((offset) ? nzob2p(offset,base) : NULL)
#define nzob2p(offset,base)	((void *)((offset)+(char_ptr(base))))

/*
	Prototypes of internal routines.
*/
static void	check_area			(file_node * finfo, f_area_node * ap);
static void check_comments		(file_node * finfo, f_offset o);
static void	check_dictionary	(file_node * finfo);
static void	check_header		(file_node * finfo);
static void check_refs			(file_node * finfo, f_offset o);
static void	check_trailer		(file_node * finfo);
static void	check_unit			(file_node * finfo, f_unit_node * up);
static void	check_units			(file_node * finfo);
</t>
<t tx="ekr.20080529093004.1150">@ Check a file area.
@c

static void
check_area (file_node * finfo, f_area_node * ap)
{
	FTAG("check_area");
	f_header * base = finfo -&gt; file_header;
	ulong file_length = finfo -&gt; file_length;
	f_ref_node * rp = NULL;
	STATB(ftag);
	ASSERT(finfo &amp;&amp; ap);
	
	if (ap -&gt; f_area_refs &gt; file_length) {
		check_oops("bad pointer to reference list", finfo);
	}
	
	if (ap -&gt; f_area_refs) {
		check_refs(finfo, ap -&gt; f_area_refs);
	}
	
	if (ap -&gt; f_area_comments) {
		check_comments(finfo, ap -&gt; f_area_comments);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1151">@ Check an area's comments list.
@c

static void
check_comments (file_node * finfo, f_offset o)
{
	FTAG("check_comments");
	
		register f_header * base = finfo -&gt; file_header;
		register f_comment * cp = NULL;
		register ulong file_length = finfo -&gt; file_length;

	STATB(ftag);
	ASSERT(finfo);

	while (o) {

		/* Check for bus errors. */
		if ((o &amp; 0xffff0000) == 0xffff0000) {
			ecnls(2); es("o: "); epadhex(o,4); enl();
			check_oops("bad o", finfo);
		}

		/* Check the address of the ref node. */
		if (o &gt;= file_length) {
			check_oops("bad comment offset", finfo);
		}
		
		/* Point rp at the ref node. */
		cp = nzob2p(o, base);
		
		if (cp -&gt; f_comment_kind &gt;= C_BAD_LAST_COMMENT) {
			check_oops("bad comment kind", finfo);
		}
		
		/* Get the offset of the next ref node. */
		o = (cp -&gt; f_comment_kind) ? o + sizeof(f_comment) : 0;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1152">@ Check the label dictionary.
@c

static void
check_dictionary (file_node * finfo)
{
	FTAG("check_dictionary");
	register f_header * base = finfo -&gt; file_header;
	STATB(ftag);
	ASSERT(finfo);
		
	if (base -&gt; fh_dictionary == 0) {
		if (base -&gt; fh_symbols != 0) {
			check_oops("Non-zero dict size", finfo);
		}
	}
	else {
		register ulong o = base -&gt; fh_dictionary;
		register ulong dict_count = 0;
		register f_dict_node * fdp = NULL;
		char * label_p = NULL;

		for (dict_count = 1; dict_count &lt;= base -&gt; fh_symbols; dict_count++) {
		
			/* Point fdp at the f_dict_node. */
			fdp = ob2p(o, base);
			
			/* The spelling of the label immediately follows the f_dict_node. */
			o += sizeof(f_dict_node);
			label_p = ob2p(o, base);			
			
			/*
				Calculate the offset of the next dict node.
				If the length is odd, add just the trailing 0 byte.
				Otherwise, add a zero byte and a pad byte.
			*/
			if (fdp -&gt; f_dict_length) {
				if (fdp -&gt; f_dict_length != strlen(label_p)) {
					ecnls(2);
					es("dict: "); eulong(dict_count);
					es(", o: "); epadhex(o, 4);
					es(", f_dict_length: "); eulong(fdp -&gt; f_dict_length);
					check_oops("bad label length", finfo);
				}
				o += fdp -&gt; f_dict_length;
				if ( (fdp -&gt; f_dict_length) &amp; 1) {
					o++;
				}
				else {
					o += 2;
				}
			}
			else {
				if (fdp -&gt; f_dict_length != 0) {
					check_oops("non-zero void label length", finfo);
				}
			}
		}
		
		/* The first unit must follow the dictionary. */
		if (base -&gt; fh_unit != 0 &amp;&amp; o != base -&gt; fh_unit) {
			check_oops("bad dictionary size", finfo);
		}
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1153">@ Check all fields in the file header.
@c

static void
check_header (file_node * finfo)
{
	FTAG("check_header");
	register f_header * base = finfo -&gt; file_header;
	STATB(ftag);
	ASSERT(finfo);
	
	/* Check the magic field.  This should catch most non-object files. */
	if (base -&gt; fh_magic != LINK_MAGIC) {
		check_oops("bad file format", finfo);
	}
	
	/* Check the version and revision fields. */
	if (base -&gt; fh_version &gt; LINK_VERSION) {
		check_oops("bad version number", finfo);
	}
	if (base -&gt; fh_revision &gt; MAX_REVISION) {
		check_oops("bad revision number", finfo);
	}
	
	/* Make sure the reserved fields are zero. */
	if (base -&gt; fh_reserved1 != 0) {
		check_oops("bad reserved field1", finfo);
	}
	if (base -&gt; fh_reserved2 != 0) {
		check_oops("bad reserved field2", finfo);
	}
	
	/* Compute and check the address of the trailer. */
	if (((finfo -&gt; file_length - sizeof(f_trailer)) % LINKER_PADDING) != 0) {
		check_oops("bad trailer padding", finfo);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1154">@ Check the header and trailer of the indicated file.
@c

void
check_ofile(file_node * finfo)
{
	FTAG("check_ofile");
	STATB(ftag);
	ASSERT(finfo);
	
	/* Check everything. */
	check_header(finfo);
	check_trailer(finfo);
	check_dictionary(finfo);
	check_units(finfo);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1155">static void
check_refs (file_node * finfo, f_offset o)
{
	FTAG("check_refs");
	register f_header * base = finfo -&gt; file_header;
	register f_ref_node * rp = NULL;
	register ulong file_length = finfo -&gt; file_length;
	STATB(ftag);
	ASSERT(finfo);

	while (o) {

		/* Check for bus errors. */
		if ((o &amp; 0xffff0000) == 0xffff0000) {
			ecnls(2); es("o: "); epadhex(o,4); enl();
			check_oops("bad o", finfo);
		}

		/* Check the address of the ref node. */
		if (o &gt;= file_length) {
			check_oops("bad pointer to next ref node", finfo);
		}
		
		/* Point rp at the ref node. */
		rp = nzob2p(o, base);
		
		/*
			Test the ref node.
			
			We don't test the f_ref_offset field because
			there is no easy way of getting the size of the area.
		*/
		if (rp -&gt; f_ref_dict == 0) {
			check_oops("zero dict index", finfo);
		}
		if (rp -&gt; f_ref_dict &gt; base -&gt; fh_symbols) {
			check_oops("bad dict index", finfo);
		}
		if (rp -&gt; f_ref_size != 2 &amp;&amp; rp -&gt; f_ref_size != 4) {
			check_oops("bad ref size", finfo);
		}
		
		/* Get the offset of the next ref node. */
		o = rp -&gt; f_ref_next;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1156">@ Check all fields in the trailer.
@c

static void
check_trailer (file_node * finfo)
{
	FTAG("check_trailer");
	f_header * base = finfo -&gt; file_header;
	ulong file_length = finfo -&gt; file_length;
	f_trailer * tp =
		f_tail_ptr(char_ptr(base) + file_length - padding(sizeof(f_trailer)));
	STATB(ftag);
	ASSERT(finfo);
	
	if (tp -&gt; t_end != LINK_MAGIC) {
		check_oops("bad trailer", finfo);
	}
	if (tp -&gt; t_file_size != finfo -&gt; file_length) {
		ecnl();
		es("trailer file length: "); ehex(tp -&gt; t_file_size);
		es(", actual file length: "); ehex(finfo -&gt; file_length); enl();
		check_oops("bad file size in trailer", finfo);
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1157">@ Check a single unit.
@c

static void
check_unit (file_node * finfo, f_unit_node * up)
{
	FTAG("check_unit");
	f_header * base = finfo -&gt; file_header;
	ulong file_length = finfo -&gt; file_length;
	f_area_node * ap = NULL;
	STATB(ftag);
	
	/* Check each area. */
	if (up -&gt; f_unit_code_area &gt; file_length) {
		check_oops("bad pointer to code area", finfo);
	}
	
	if (up -&gt; f_unit_code_area) {
		ap = nzob2p(up -&gt; f_unit_code_area, base);
		check_area(finfo, ap);
	}
	
	if (up -&gt; f_unit_data_area &gt; file_length) {
		check_oops("bad pointer to data area", finfo);
	}
	
	if (up -&gt; f_unit_data_area) {
		ap = nzob2p(up -&gt; f_unit_data_area, base);
		check_area(finfo, ap);
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1158">@ Check all units of a file.
@c

static void
check_units(file_node * finfo)
{
	FTAG("check_units");
	f_header * base = finfo -&gt; file_header;
	ulong file_length = finfo -&gt; file_length;
	STATB(ftag);
	ASSERT(finfo);

	if (base -&gt; fh_units == 0) {
		if (base -&gt; fh_unit != 0) {
			check_oops("Non-zero unit size", finfo);
		}
	}
	else {
		register ulong o = 0;
		register ulong unit_count = 0;
		register f_unit_node * fup = NULL;

		for (
			unit_count = 1, o = base -&gt; fh_unit;
			unit_count &lt;= base -&gt; fh_units;
			unit_count++, o = fup -&gt; f_unit_next
		) {
		
			/* Check the address of the unit. */
			if (o == 0) {
				check_oops("NULL pointer to next unit", finfo);
			}
			if (o &gt;= file_length) {
				check_oops("bad pointer to next unit", finfo);
			}
			
			/* Point up at the unit. */
			fup = nzob2p(o, base);
			
			/* Test the unit. */
			check_unit(finfo, fup);
		}
		
		/* Make sure the list ends with a zero offset. */
		if (base -&gt; fh_units &amp;&amp; o != 0) {
			check_oops("extra unit", finfo);
		}
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1159">@ A problem has been found with the object file. Print an error message and the header and trailer.
@c

void
check_oops(char * message, file_node * finfo)
{
	FTAG("check_oops");
	STATB(ftag);
	ASSERT(message);
	
	link_err_count++;
	ecnls(2);
	es("----- Bad object file: "); es(err_file_name());
	ecnl(); es(message); ecnl();
	
	if (finfo) {
		ecnl(); es("Header for file: "); es(finfo -&gt; file_name); ecnl();
		dump_f_header(finfo -&gt; file_header);
		ecnls(2); es("Trailer for file: "); es(finfo -&gt; file_name); ecnl();
		dump_trailer(finfo);
		ecnl();
	}
	
	end_usage();
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1160">/*	Link: Routines to dump various nodes to the error stream.
		
	source:  LKdump.c
	started: May 16, 1994.
	version:
		May 18, 1994.
			Added dump_area and dump_unit.
		May 16, 1994.
*/

&lt;&lt; LKdump #includes &gt;&gt;
&lt;&lt; LKdump declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1161">#include "LK.h"

#include "LKdump.h"
#include "LKnodes.h"

#include &lt;LIBofile.h&gt;
</t>
<t tx="ekr.20080529093004.1162">/* Information used in dumps. */

short max_area_name = 6;	/* Width of longest area name. */
short max_dict_name = 6;	/* Width of longest label: strlen("&lt;NULL&gt;"); */
short max_unit_name = 6;	</t>
<t tx="ekr.20080529093004.1163">@ Width of longest unit name.
Dump a single area node.
@c

void
dump_area(register area_node * ap)
{
	FTAG("dump_area");
	STATB(ftag);
	
	if (ap) {
		es("&lt;area: ");
			epads(ap -&gt; area_name, max_area_name);
		es(", area pointer: ");
			eptr(ap -&gt; area_pointer);
		es(", area length: ");
			epadulong(ap -&gt; area_length, 4);
		es("&gt;");
	}
	else {
		es("&lt;NULL&gt;");
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1164">@ Dump a single dict node.
@c

#define DICT_NAME_WIDTH 12
void
dump_dict(register dict_node * dp)
{
	FTAG("dump_dict");
	STATB(ftag);

	if (dp) {
		es("&lt;dict: ");
			epads(dp -&gt; dict_name, max_dict_name);
		es(", area: ");
			if (dp -&gt; dict_area) {
				epads(dp -&gt; dict_area -&gt; area_name, max_area_name);
			}
			else {
				epads("&lt;NULL&gt;", max_area_name);
			}
		es(", offset:");
			epadhex(dp -&gt; dict_offset, 4);
		es(", flags:");
			if (dp -&gt; dict_flags == 0)	es(" NONE");
			if (dict_is_defined(dp))	es(" DEF");
			if (dict_is_global(dp))		es(" GLB");
			if (dict_is_imported(dp))	es(" IMP");
			if (dict_is_referenced(dp))	es(" REF");
		es("&gt;");
	}
	else {
		es("&lt;NULL&gt;");
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1165">@ Dump a file area node.
@c

void
dump_f_area (f_area_node * ap)
{
	FTAG("dump_area");
	STATB(ftag);

	if (ap) {
		es("&lt;area: app length: ");	eulong(ap -&gt; f_area_app_length);
		es(", file length: ");		eulong(ap -&gt; f_area_file_length);
		es(", ref list offset: ");	epadhex(ap -&gt; f_area_refs, 4);
		es(", byte list offset: ");	epadhex(ap -&gt; f_area_bytes, 4);
		es(", name index");			eulong(ap -&gt; f_area_name);
		es("&gt;");
	}
	else {
		es("&lt;NULL&gt;");
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1166">@ Dump the file header.
@c

#define HEADER_WIDTH 14
void
dump_f_header(f_header * h)
{
	FTAG("dump_f_header");
	STATB(ftag);

	ecnl();
	epads("version: ",		HEADER_WIDTH);	eint(h -&gt; fh_version);			enl();
	epads("revision: ",		HEADER_WIDTH);	eint(h -&gt; fh_revision);			enl();
	epads("magic: ",		HEADER_WIDTH);	eulong(h -&gt; fh_magic);			enl();
	epads("reserved1: ", 	HEADER_WIDTH);	eulong(h -&gt; fh_reserved1);		enl();
	epads("reserved2: ", 	HEADER_WIDTH);	eulong(h -&gt; fh_reserved2);		enl();
	epads("labels: ",		HEADER_WIDTH);	eulong(h -&gt; fh_symbols);		enl();
	epads("units: ",		HEADER_WIDTH);	eulong(h -&gt; fh_units);			enl();
	epads("areas: ",		HEADER_WIDTH);	eulong(h -&gt; fh_areas);			enl();
	epads("dict offset: ",	HEADER_WIDTH);	epadhex(h -&gt; fh_dictionary, 4);	enl();
	epads("unit offset: ",	HEADER_WIDTH);	epadhex(h -&gt; fh_unit, 4);		enl();
	ecnl();
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1167">@ Dump the file trailer.
@c

void
dump_trailer(file_node * finfo)
{
	FTAG("dump_trailer");
	f_trailer * tp = NULL;
	char * cp = NULL;
	STATB(ftag);
	ASSERT(finfo);
	
	cp = char_ptr(finfo -&gt; file_header);
	tp = f_tail_ptr(cp + finfo -&gt; file_length - padding(sizeof(f_trailer)));

	ecnl();
	epads("file size: ", HEADER_WIDTH);	eulong(tp -&gt; t_file_size);	enl();
	epads("magic: ", 	 HEADER_WIDTH);	eulong(tp -&gt; t_end);		enl();
	ecnl();
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1168">@ Dump a file unit node.
@c

void
dump_f_unit(f_unit_node * up)
{
	FTAG("dump_unit");
	STATB(ftag);
	
	if (up) {
		es("&lt;unit: code offset: ");	epadhex(up -&gt; f_unit_code_area, 4);
		es(", data offset: ");		epadhex(up -&gt; f_unit_data_area, 4);
		es(", flags:");
		if (up -&gt; unit_flags == 0)		es(" NONE");
		if (unit_is_on_scan_list(up))	es(" SCAN");
		if (unit_is_proc(up))			es(" PROC");
		if (unit_is_record(up))			es(" REC");
		es("&gt;");
	}
	else {
		es("&lt;NULL&gt;");
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1169">@ Dump a single unit node.
@c

void
dump_unit(register unit_node * up)
{
	FTAG("dump_unit");
	STATB(ftag);
	
	if (up) {
		es("&lt;unit: ");	epads(up -&gt; unit_name, max_unit_name);
		es(", code area: ");	eptr(up -&gt; unit_code_area);
		es(", data area: ");	eptr(up -&gt; unit_data_area);
		es(", flags:");
		if (up -&gt; unit_flags == 0)		es(" NONE");
		if (unit_is_on_scan_list(up))	es(" SCAN");
		if (unit_is_proc(up))			es(" PROC");
		if (unit_is_record(up))			es(" REC");
		es("&gt;");
	}
	else {
		es("&lt;NULL&gt;");
	}
	
	STATX(ftag);
}</t>
<t tx="ekr.20080529093004.1170">/*	Link: Routines to convert data structures from file format to in-memory format.
	
	This file checks all object files thoroughly for consistency.
	
	source:  LKfscan.c
	started: November 20, 1993.
	version
		July 14, 1994.
			Bug fix: word-align all areas.
		July 2, 1994.
			Bug fix to fscan_make_dicts: set dict_offset only when it is defined.
		May 21, 1994.
			Copied strings to permanent string space for two-pass algorithm.
			Revised fscan_make_refs to handle both one or two pass algorithms.
		May 17, 1994.
*/

&lt;&lt; LKfscan #includes &gt;&gt;
&lt;&lt; LKfscan declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1171">#include "LK.h"

#include "LKarg.h"
#include "LKcheck.h"
#include "LKdump.h"
#include "LKfscan.h"
#include "LKlink.h"
#include "LKmain.h"
#include "LKmem.h"
#include "LKnodes.h"
#include "LKst.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBobj.h&gt;
#include &lt;LIBofile.h&gt;

#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.1172">/*
	arg_multi_pass_flag is no longer used.
	However, I don't want to remove this code yet.
*/
static bool arg_multi_pass_flag = FALSE;

/*	
	The ob2p macro returns a pointer equivalent to a file offset or NULL.
	The nzob2p is the same as ob2p except that the offset is known to be non-zero.
	Return NULL if the offset is zero.
	
*/
#define ob2p(offset,base)	((offset) ? nzob2p(offset,base) : NULL)
#define nzob2p(offset,base)	((void *)((offset)+(char_ptr(base))))

/*
	Variables local to this file.
*/

	/* Arrays of pointers used to translate indices to pointers. */

static area_node **area_ptrs = NULL;	/* Pointers to each area. */
static dict_node **dict_ptrs = NULL;	/* Pointers to each dict node. */
static unit_node **unit_ptrs = NULL;	/* Pointers to each unit. */

	/* Counts of nodes defined in the file. */
		
static ulong n_areas;	/* The number of areas  defined in the file. */
static ulong n_dicts;	/* The number of labels defined in the file. */
static ulong n_units;	/* The number of units  defined in the file. */		

/*
	Prototypes of internal routines.
*/
static area_node *	fscan_make_area
	(file_node * finfo, f_area_node * fap, unit_node * up);
static void			fscan_make_bytes	(file_node * finfo, f_area_node * fap, area_node * ap);
static void			fscan_make_dicts	(file_node * finfo);
static ref_node *	fscan_make_refs		(file_node * finfo, f_area_node * fap, area_node * ap);
static void 		fscan_make_units	(file_node * finfo);
</t>
<t tx="ekr.20080529093004.1173">@ Make in-memory area nodes from the area nodes in the object file. Return a pointer to the newly created node.
@c

static area_node *
fscan_make_area (file_node * finfo, f_area_node * fap, unit_node * up)
{
	FTAG("fscan_make_area");
	f_header * base = finfo -&gt; file_header;
	area_node * ap = NULL;
	STATB(ftag);
	ASSERT(finfo &amp;&amp; fap);
	
	/* Point at this area node. */
	if (fap -&gt; f_area_index &lt; 1 || fap -&gt; f_area_index &gt; base -&gt; fh_areas) {
		check_oops("bad area index", finfo);
	}
	ap = area_ptrs [fap -&gt; f_area_index];
	
	/*
		Fill in all non-pointer fields.
		Bug fix: 7/14/94: Make sure all areas are word-aligned.
	*/
	ap -&gt; area_length = fap -&gt; f_area_app_length;
	if ((ap -&gt; area_length) &amp; 1) {
		ap -&gt; area_length++;
	}
	ap -&gt; area_unit = up;
	if (ap == main_area) {
		main_unit = up;
	}
	
	/* Set the area name. */
	if (fap -&gt; f_area_name == 0) {
		ap -&gt; area_dict = NULL;
		ap -&gt; area_name = "&lt;unnamed area&gt;";
	}
	else if (fap -&gt; f_area_name &gt; 0 &amp;&amp; fap -&gt; f_area_name &lt;= n_dicts) {
		char * s = NULL;
		ap -&gt; area_dict = dict_ptrs[fap -&gt; f_area_name];
		s = ap -&gt; area_dict -&gt; dict_name;
		
		if (arg_multi_pass_flag) {
			new_perm_string_macro(ap -&gt; area_name, s);
		}
		else {
			ap -&gt; area_name = s;
		}
	}
	else {
		check_oops("bad area name dict index", finfo);
	}
	
	/* Set the maximum area name for dumps. */
	max_area_name = max(max_area_name, strlen(ap -&gt; area_name));
	
	/* Convert the reference list. */
	ap -&gt; area_refs = fscan_make_refs(finfo, fap, ap);
	
	/* Allocate and fill the byte area. */
	if (!arg_multi_pass_flag) {
		fscan_make_bytes(finfo, fap, ap);
	}
	
	/*
		Create the pointer to the comment array.
		No change is made to the array in memory.
	*/
	ap -&gt; area_comments = ob2p(fap -&gt; f_area_comments, finfo -&gt; file_header);

	STATX(ftag);
	
	return ap;
}
</t>
<t tx="ekr.20080529093004.1174">@ Fill in the bytes of area ap using the byte list in the file area node fap.
@c

static void
fscan_make_bytes (file_node * finfo, f_area_node * fap, area_node * ap)
{
	FTAG("fscan_make_bytes");
	register f_header * base = finfo -&gt; file_header;
	register f_byte_node * fbp = NULL;
	ulong o = fap -&gt; f_area_bytes;
	ulong count = 0;
	TRACEPB(ftag, es("ap: "); eptr(ap); ecnl());
	ASSERT(finfo &amp;&amp; fap &amp;&amp; ap);
	
	/* Allocate the byte area. */
	ASSERT(ap -&gt; area_pointer == NULL);
	new_size_macro(ap -&gt; area_pointer,
		fap -&gt; f_area_app_length, perm_life, area_bytes_stats);

	for (
		o = fap -&gt; f_area_bytes, fbp = ob2p(o, base);
		fbp;
		o = fbp -&gt; f_byte_next, fbp = ob2p(o, base)
	) {
	
		switch(fbp -&gt; f_byte_type) {
		
		case F_ALIGN_TYPE:
			count += f_align_ptr(fbp) -&gt; f_align_pad;
			break;
		
		case F_BYTE_TYPE:
		{
			ulong i = f_byte_ptr(fbp) -&gt; f_byte_size;
			char * fcp = (char_ptr(fbp) + sizeof(f_byte_node));
			char * cp = ap -&gt; area_pointer + count;
			while (i--) {
				*cp++ = *fcp++;
			}
			count += f_byte_ptr(fbp) -&gt; f_byte_size;
			break;
		}
		
		case F_FILL_TYPE:
		{
			ulong i = f_fill_ptr(fbp) -&gt; f_fill_count;
			ulong c = f_fill_ptr(fbp) -&gt; f_fill_val;
			char * cp = ap -&gt; area_pointer + count;
			while (i--) {
				*cp++ = c;
			}
			count += f_fill_ptr(fbp) -&gt; f_fill_count;
			break;
		}
		
		default:
			ecnl(); es("bad byte type: "); eulong(fbp -&gt; f_byte_type); enl();
			es("o: "); epadhex(o, 4); enl();
			check_oops("", finfo);
		}
		
		if (count &gt; ap -&gt; area_length) {
			check_oops("byte area too big", finfo);
		}
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1175">@ Mke a new dict node for each local symbol and each global symbol not already in the symbol table. Point the appropriate entries in dict_ptrs at the new dict nodes.
@c

static void
fscan_make_dicts (file_node * finfo)
{
	FTAG("fscan_make_dicts");
	
	register f_header * base = finfo -&gt; file_header;
	register ulong o = base -&gt; fh_dictionary;

	register f_dict_node * fdp = NULL;	/* The file dict node. */
	register dict_node * dp = NULL;		/* The in-memory dict node. */
	
	register ulong dict_count = 0;
	char * name_p = NULL;
	long hash = 0;
	
	STATB(ftag);
	ASSERT(finfo);
	
	for (dict_count = 1; dict_count &lt;= base -&gt; fh_symbols; dict_count++) {
		
		/* Point fdp at the f_dict_node. */
		fdp = ob2p(o, base);
		
		/*
			The spelling of the label immediately follows the f_dict_node,
			but only if there is a label.
			
		*/
		o += sizeof(f_dict_node);
		if (fdp -&gt; f_dict_length) {
		
			char * f_name_p = ob2p(o, base);
			if (arg_multi_pass_flag) {
				new_perm_string_macro(name_p, f_name_p);
			}
			else {
				name_p = f_name_p;
			}

			/* Move past the label. */
			o += fdp -&gt; f_dict_length;
			if ( (fdp -&gt; f_dict_length) &amp; 1) {
				o++;
			}
			else {
				o += 2;
			}
		}
		else {
			name_p = "&lt;void label&gt;";
		}
		
		/* Set the maximum label name for dumps. */
		max_dict_name = max(max_dict_name, fdp -&gt; f_dict_length);

		/* Set the info_dict_ptr entry to the global dict node if it exists. */
		if (dict_is_global(fdp) || dict_is_imported(fdp)) {
			if (fdp -&gt; f_dict_length == 0) {
				ecnl();
				check_oops("unnamed global or imported label", finfo);
			}
			hash = st_hash(name_p);
			dp = st_lookup(name_p, hash);
		}
		else {
			dp = NULL;
		}
		
		/* Create a new dict node if a *global* dict node has not been found. */
		if (dp == NULL) {
	
			/* Create a new dict node that overrides other labels with the same name. */
			new_perm_macro(dp, dict_stats);
			
			/* Add the dict node to the global list of all dict nodes. */
			dp -&gt; dict_global_next = dict_list;
			dict_list = dp;

			/*
				Copy the other fields, but *not* the flags field.
				We won't merge the flags until we are done testing the fdp flags.
			*/
			dp -&gt; dict_name	= name_p;
			
			/* Only enter global or imported items into the symbol table. */
			if (dict_is_global(fdp) || dict_is_imported(fdp)) {
				st_enter(dp, hash);
			}
		}
		else {
		
			/* The dict node is already in the symbol table */
			ASSERT(dp &amp;&amp; (dict_is_global(fdp) || dict_is_imported(fdp)));
		}
		
		/* Make sure to set the dict_area and offset if we have just defined it. */
		if (dict_is_defined(fdp)) {
			if (fdp -&gt; f_dict_area == 0) {
				check_oops("no area for defined label", finfo);
			}
			if (fdp -&gt; f_dict_area &gt; n_areas) {
				check_oops("bad dict area index", finfo);
			}
			
			/* Bug fix 7/2/94: Set the offset when the symbol is defined! */
			dp -&gt; dict_offset = fdp -&gt; f_dict_offset;

			/*
				WARNING: This will over-ride a previous definition.
				This shouldn't matter because link_check will eventually
				report the duplicate definition.
			*/
			dp -&gt; dict_area = area_ptrs[fdp -&gt; f_dict_area];
			ASSERT(dp -&gt; dict_area);

			/* Point at the main dict node. */
			if (str_eq("main", name_p)) {
				main_dict = dp;
				main_area = dp -&gt; dict_area;
				ASSERT(main_area);
				main_file = finfo;
			}
		}
		
			/* Update semantic information. */
		
		/* Set the dict_ptrs entry. */
		ASSERT(dict_count &gt; 0 &amp;&amp; dict_count &lt; n_dicts + 2);
		dict_ptrs [dict_count] = dp;
		
		if (dict_is_defined(fdp)) {
		
			flist_node * flp = NULL;
			dlist_node * dlp = NULL;
			ASSERT(dp -&gt; dict_area);
		
			/*
				Add the file to the list of files in which the label is defined.
				Multiply-defined error messages use this list.
			*/
			new_perm_macro(flp, flist_stats);
			flp -&gt; flist_info = finfo;
			flp -&gt; flist_area = dp -&gt; dict_area;
			flp -&gt; next = dp -&gt; dict_def_flist;
			dp -&gt; dict_def_flist = flp;
			
			/* Add the dict node to the list of labels defined in the area. */
			new_perm_macro(dlp, dlist_stats);
			dlp -&gt; dlist_dict = dp;
			dlp -&gt; dlist_next = dp -&gt; dict_area -&gt; area_dict_def_list;
			dp -&gt; dict_area -&gt; area_dict_def_list = dlp;
			
			/* Update the count. */
			dp -&gt; dict_def_count++;
		}
			
		if (dict_is_referenced(fdp)) {
		
			/*
				Add the file to the list of files in which the item is referenced.
				Referenced-but-undefined error messages use this list.
			*/
			
			flist_node * flp = NULL;
			new_perm_macro(flp, flist_stats);
			flp -&gt; flist_info = finfo;
			flp -&gt; next = dp -&gt; dict_ref_flist;
			dp -&gt; dict_ref_flist = flp;
			
			/*
				Do *not* update dp -&gt; dict_ref_count here.
				We only do that when we know the referencing area is marked.
			*/
		}
		
		/* Merge the flags *after* checking the fdp flags. */
		dp -&gt; dict_flags |= fdp -&gt; dict_flags;
	}

	ASSERT(dict_count == n_dicts + 1);
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1176">@ Create a new ref_node corresponding to each f_ref_node in the ref list of an area. References *must* be attached to their own area node since the offset of length fields refer to the owning area, *not* the referenced area.  We translate ref nodes *in place* when using the single-pass algorithm. This saves more storage than the multi-pass algorithm does!  We could eliminate the o and next_o variables, but they are handy when tracing this routine.
@c

static ref_node *
fscan_make_refs (file_node * finfo, register f_area_node * fap, area_node * ap)
{
	FTAG("fscan_make_refs");
	register f_header * base = finfo -&gt; file_header;
	register f_ref_node * frp = NULL;
	register ref_node * rp = NULL;
	register ulong o = 0;
	register ulong next_o = 0;
	
	ref_node * first_rp = NULL;
	ref_node * prev_rp = NULL;
	STATB(ftag);
	ASSERT(finfo &amp;&amp; fap &amp;&amp; ap);
	PERM_ASSERT_TRACE(sizeof(ref_node) == sizeof(f_ref_node),
		es("sizes of ref nodes do not match"));
	
	/* Convert all offsets to pointers in the reference list. */
	for (
		o = fap -&gt; f_area_refs, frp = ob2p(o, base);
		frp;
		o = next_o, frp = ob2p(o, base)
	) {
	
		if ((o &amp; 0xffff0000) == 0xffff0000) {
			ecnls(2); es("o: "); epadhex(o,4); enl();
			check_oops("make_refs: bad o", finfo);
		}
	
		prev_rp = rp;
		
		/* Create a new ref_node */
		if (arg_multi_pass_flag) {
			new_perm_macro(rp, ref_stats);
		}
		else {
			rp = ref_ptr(frp);
		}
		
		/* Remember the start of the list. */
		if (first_rp == NULL) {
			first_rp = rp;
		}
		
		TRACEPN(ftag,
			es("converting frp.  ");
			es("frp offset: ");		epadhex(o, 2);
			es(", frp: ");			eptr(frp);
			es(", next offset: ");	epadhex(frp -&gt; f_ref_next, 2);
			es(", next: ");			eptr(ob2p(frp -&gt; f_ref_next, base)));
			
		/* Convert the f_ref_dict field to a pointer. */
		if (frp -&gt; f_ref_dict &lt; 1 &amp;&amp; frp -&gt; f_ref_dict &gt;= n_dicts) {
			check_oops("bad ref dict index", finfo);
		}
		rp -&gt; ref_dict = dict_ptrs[frp -&gt; f_ref_dict];
		
		/* Check the f_ref_next field. */
		if (frp -&gt; f_ref_next &gt;= finfo -&gt; file_length) {
			check_oops("bad ref next", finfo);
		}
		
		/* Set next_frp *before* changing the f_ref_next field! */
		next_o = frp -&gt; f_ref_next;
		
		/* Warning: this changes the f_ref_next field in the single-pass algorithm. */
		rp -&gt; ref_next = NULL;
		if (prev_rp) {
			prev_rp -&gt; ref_next = rp;
		}

		/* Check the f_ref_size field. */
		if (frp -&gt; f_ref_size != 2 &amp;&amp; frp -&gt; f_ref_size != 4) {
			check_oops("bad ref size", finfo);
		}
		rp -&gt; ref_size = frp -&gt; f_ref_size;
	
		/* We can't check the offset field until all areas have been created. */
		rp -&gt; ref_offset = frp -&gt; f_ref_offset;
		
		/* Copy the flags. */
		rp -&gt; ref_flags = frp -&gt; ref_flags;
	}
	
	STATX(ftag);
	return first_rp;
}
</t>
<t tx="ekr.20080529093004.1177">@ Make in-memory unit nodes from file unit nodes. No further conversion of unit nodes is needed here. Point the appropriate entries in unit_ptrs at the new unit nodes.
@c

static void
fscan_make_units (file_node * finfo)
{
	FTAG("fscan_make_units");
	
	register f_header *	base = finfo -&gt; file_header;
	register f_unit_node * fup = NULL;
	register unit_node * up = NULL;
	
	register ulong o = base -&gt; fh_unit;
	register ulong unit_count = 0;
	
	STATB(ftag);
	ASSERT(finfo);

	for (
		unit_count = 1, o = base -&gt; fh_unit;
		unit_count &lt;= base -&gt; fh_units;
		unit_count++, o = fup -&gt; f_unit_next
	) {
	
		up = unit_ptrs[unit_count];
		ASSERT(up);

		/* Point up at the file unit node. */
		fup = nzob2p(o, base);
		
		/* Set the unit name. */
		if (fup -&gt; f_unit_name == 0) {
			up -&gt; unit_name = "&lt;unnamed unit&gt;";
		}
		else if (fup -&gt; f_unit_name &gt; 0 &amp;&amp; fup -&gt; f_unit_name &lt;= n_dicts) {
			char * s = dict_ptrs[fup -&gt; f_unit_name] -&gt; dict_name;
			if (arg_multi_pass_flag) {
				new_perm_string_macro(up -&gt; unit_name, s);
			}
			else {
				up -&gt; unit_name = s;
			}
		}
		else {
			check_oops("bad unit name dict index", finfo);
		}
		
		/* Set the maximum unit name for dumps. */
		max_unit_name = max(max_unit_name, strlen(up -&gt; unit_name));
		
		/* Point at the owning file. */
		up -&gt; unit_file = finfo;
		
		/* Copy the unit flags. */
		up -&gt; unit_flags = fup -&gt; unit_flags;
		
		/* Add the unit to the list of units of the file. */
		up -&gt; unit_file_next = finfo -&gt; file_unit_list;
		finfo -&gt; file_unit_list = up;

		/* Make any area node attached to this unit. */
		if (fup -&gt; f_unit_code_area) {
			f_area_node * fap = nzob2p(fup -&gt; f_unit_code_area, base);
			up -&gt; unit_code_area = fscan_make_area(finfo, fap, up);
		}
		if (fup -&gt; f_unit_data_area) {
			f_area_node * fap = nzob2p(fup -&gt; f_unit_data_area, base);
			up -&gt; unit_data_area = fscan_make_area(finfo, fap, up);
		}
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1178">@ Preprocess an object file, converting all file structures to in-memory structures.
@c

void
fscan_preprocess(register file_node * finfo)
{
	FTAG("fscan_preprocess");
	f_header * base = finfo -&gt; file_header;
	STATB(ftag);
	ASSERT(finfo);
	
	/* Check all data structures in the object file. */
	check_ofile(finfo);
	
	/* All is well.  Dump only the header here.  Dump the trailer later. */
	if (arg_obj_dump_flag) {
		dump_f_header(finfo -&gt; file_header);
	}
	
	/* Set node counts. */
	n_areas = base -&gt; fh_areas;
	n_dicts = base -&gt; fh_symbols;
	n_units = base -&gt; fh_units;
	
	/* Initiatilze the file's list of units. */
	finfo -&gt; file_unit_list = NULL;
	
	/*
		Allocate the arrays of pointers to dict nodes, unit nodes and area nodes.
		The first element of each array remains NULL because 0 is not a valid index.
		The last  element of each array remains NULL as a safety measure.
	*/
	obj_new_macro(area_ptrs, (n_areas + 2) * sizeof(area_node *), "area ptrs array");
	obj_new_macro(dict_ptrs, (n_dicts + 2) * sizeof(dict_node *), "dict ptrs array");
	obj_new_macro(unit_ptrs, (n_units + 2) * sizeof(unit_node *), "unit ptrs array");
	
	/*
		We allocate all area nodes and unit nodes here and set pointers to
		them in the area_ptrs and unit_ptrs arrays.
		This allows us to translate f_indices to pointers as we go along.
		That is, we can create a pointer to a node before filling it in.
		This greatly simplifies the code because nodes can be filled in in any order.
	*/
	{
		register ulong i = 0;
		for (i = 1; i &lt;= n_areas; i++) {
			new_perm_macro(area_ptrs[i], area_stats);
		}
		for (i = 1; i &lt;= n_units; i++) {
			new_perm_macro(unit_ptrs[i], unit_stats);
		}
	}

	/*
		We can *not* allocate all dict nodes as easily because some
		dict nodes in the object file may refer to dict nodes that
		have already been allocated as the result of scanning another object file.

		fscan_make_dicts allocates local dict nodes and global dict nodes
		that have not already been entered into the symbol table and
		completely sets the dict_ptrs array.
	*/
	fscan_make_dicts(finfo);

	/*
		We now scan through the unit list and recursively through all attached nodes,
		copying information from the object file into unit nodes, area nodes,
		ref nodes and the byte areas attached to each area.
		
		During this scanning phase,
		we use area_ptrs, dict_ptrs and unit_ptrs arrays
		to translate f_indices to real pointers.
		
		The scanning phase also completes consistency checks of the object file.
		
		There is no need to create arrays of pointers to ref nodes or byte nodes.
		o f_offsets to ref nodes are in the reference list itself
		so the f_offsets can be converted to pointers in a single scan.
		o f_offsets to byte nodes are never converted to pointers because
		the byte list of an area is scanned only once to set bytes in the area's byte region.
	*/
	fscan_make_units(finfo);

	/*
		At this point *all* entries in the pointer arrays should be filled in.
		Any NULL entries indicate a bug in the assembler or more likely the linker.
	*/
	{
		register ulong i = 0;
		for (i = 1; i &lt;= n_areas; i++) {
			if (area_ptrs[i] == NULL) {
				fatal(es("NULL area_ptrs["); eulong(i); es("]"));
			}
		}
		for (i = 1; i &lt;= n_dicts; i++) {
			if (dict_ptrs[i] == NULL) {
				fatal(es("NULL dict_ptrs["); eulong(i); es("]"));
			}
		}
		for (i = 1; i &lt;= n_units; i++) {
			if (unit_ptrs[i] == NULL) {
				fatal(es("NULL unit_ptrs["); eulong(i); es("]"));
			}
		}
	}

	/* Only now can we properly dump all the in-memory data structures. */
	if (arg_obj_dump_flag) {
	
		register ulong i;
		
		ecnl(); es("Dump of area_ptrs[]...\n");
		for(i = 0; i &lt;= n_areas + 1; i++) {
			es("["); eulong(i); es("] = "); eptr(area_ptrs[i]);
			es(": "); dump_area(area_ptrs[i]); ecnl();
		}
		
		ecnl(); es("Dump of dict_ptrs[]...\n");
		for(i = 0; i &lt;= n_dicts + 1; i++) {
			es("["); eulong(i); es("] = "); eptr(dict_ptrs[i]);
			es(": "); dump_dict(dict_ptrs[i]); ecnl();
		}
		
		ecnl(); es("Dump of unit_ptrs[]...\n");
		for(i = 0; i &lt;= n_units + 1; i++) {
			es("["); eulong(i); es("] = "); eptr(unit_ptrs[i]);
			es(": "); dump_unit(unit_ptrs[i]); ecnl();
		}

		dump_trailer(finfo);
	}
	
	/*
		Free the pointer arrays.
		There are not needed now that all indices have been converted to pointers.
		
		When using the multi-pass algorithm we save the unit pointers
		in the file node.
		This allows fscan_rescan to work without assuming anything
		about the order of units in the global unit list.
	*/
	obj_free_macro(area_ptrs);
	obj_free_macro(dict_ptrs);

	if (arg_multi_pass_flag) {
		finfo -&gt; file_units = n_units;
		finfo -&gt; file_unit_ptrs = unit_ptrs;
	}
	else {
		obj_free_macro(unit_ptrs);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1179">@ Fill in the byte areas attached to the areas of the indicated file. The link_code_flag tells whether code or data areas are to be scanned. This code is used in the multi-pass algorithm.  This code assumes that the re-read file has exactly the same structure as the original file. If not, the ASSERT's will fail.
@c

void
fscan_rescan(file_node * finfo, bool link_code_flag)
{
	FTAG("fscan_rescan");
	register f_header *	base = finfo -&gt; file_header;
	register unit_node * up = NULL;
	register area_node * ap = NULL;
	
	f_area_node * fap = NULL;
	f_unit_node * fup = NULL;
	
	register ulong o = 0;
	register ulong i = 0;

	TRACEPB(ftag,
		es(link_code_flag ? "code" : "data");
		es(" areas of "); es(finfo -&gt; file_name); ecnl());

	ASSERT(finfo &amp;&amp; base &amp;&amp; finfo -&gt; file_unit_ptrs);
	ASSERT(link_code_flag == LINK_CODE_AREA || link_code_flag == LINK_DATA_AREA);
	
	if (arg_verbose_flag) {
		ecnl(); es("Re-reading: "); es(finfo -&gt; file_name); ecnl();
	}
	
	/* Scan all units of the file. */
	for (
		i = 1, o = base -&gt; fh_unit;
		i &lt;= finfo -&gt; file_units;
		i++, o = fup -&gt; f_unit_next
	) {
	
		up = finfo -&gt; file_unit_ptrs[i];
		fup = ob2p(o, base);
		if (fup == NULL) {
			check_oops("rescanned file different from original file", finfo);
		}
	
		/* Allocate and fill the byte areas. */
		ap = link_code_flag ? up -&gt; unit_code_area : up -&gt; unit_data_area;
		if (ap) {
			fap = link_code_flag ?
				ob2p(fup -&gt; f_unit_code_area, base) :
				ob2p(fup -&gt; f_unit_data_area, base);
			fscan_make_bytes (finfo, fap, ap);
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1180">/*
	Link: routines that link references with their proper run-time values.
	
	source:  LKlink.c
	started: November 21, 1993.
	version:
		May 27, 1994.
			Unmarked files do not count when checking for
			undefined or multiply defined symbols.
		May 26, 1994.
			Print list of unneeded files.
		May 21, 1994.
			Added multi_pass logic.
		May 20, 1994.
			Rewrote for new file format.
			Added support for negative references.
		December 9, 1993.
*/

&lt;&lt; LKlink #includes &gt;&gt;
&lt;&lt; LKlink declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1181">#include "LK.h"

#include "LKarg.h"
#include "LKcheck.h"
#include "LKdump.h"
#include "LKfscan.h"
#include "LKlink.h"
#include "LKload.h"
#include "LKmain.h"
#include "LKmem.h"
#include "LKmark.h"
#include "LKnodes.h"
#include "LKst.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBobj.h&gt;
#include &lt;LIBos.h&gt;

#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.1182">/*
	Variables local to this file.
*/
static char * load_address = 0;

/*
	Prototypes of internal routines.
*/
	/* Synonyms for link_code_flag are defined in LKlink.h */
	
	/* Synonyms for map_file_flag. */
	enum { TO_MAP_FILE = TRUE, TO_LOG_FILE = FALSE};
	
	/* Synonyms for data_area_flag. */
	enum { DATA_AREA = TRUE, CODE_AREA = FALSE};

static void link_adjust			(void);
static void link_check			(void);
static void link_adjust_area 	(area_node * ap, file_node * finfo, bool data_area_flag);
static void link_one_file 		(file_node * finfo, bool link_code_flag);
static void link_print_flist	(flist_node * flist, int leading_blanks, bool map_file_flag);
static void link_print_file_name(file_node * finfo, bool map_flag);
static void link_resolve		(void);
</t>
<t tx="ekr.20080529093004.1183">@ Resolve all references in all marked items.
@c

void
link(void)
{
	FTAG("link");
	STATB(ftag);
	
	/* Check for multiply-defined or undefined labels. */
	link_check();

	/* This test will fail on some user errors. */
	if (
		main_file &amp;&amp; main_file == file_info_list &amp;&amp;
		main_unit &amp;&amp; main_unit == file_info_list -&gt; file_unit_list
	) {
	
		/* Resolve the load address for all marked areas. */
		link_resolve();
		
		/* Adjust all references in all marked areas. */
		if (link_err_count == 0) {
			link_adjust();
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1184">@ Adjust all references in all marked areas.
@c

static void
link_adjust(void)
{
	FTAG("link_adjust");
		register file_node * finfo = NULL;
		register unit_node * up = NULL;
		register area_node * ap = NULL;
	STATB(ftag);
	
	if (arg_verbose_flag) {
		ecnl(); es("Adjusting references...\n");
	}

	/* Adjust all data areas. */
	for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
		for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
			ap = up -&gt; unit_data_area;
			if (ap &amp;&amp; area_is_marked(ap)) {
				link_adjust_area(ap, finfo, DATA_AREA);
			}
		}
	}

	/* Adjust all code areas. */
	for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
		for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
			ap = up -&gt; unit_code_area;
			if (ap &amp;&amp; area_is_marked(ap)) {
				link_adjust_area(ap, finfo, CODE_AREA);
			}
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1185">@ Adjust all references in one marked area. That is: add the proper values to all fields described in a reference list.
@c

static void
link_adjust_area (register area_node * ap, file_node * finfo, bool data_area_flag)
{
	FTAG("link_adjust_area");
	FTAGV("link_adjust_area2");

	register ref_node * rp = NULL;
	register area_node * ref_area = NULL;	

	TRACEPB(ftag,
		es("resolving refs in "); es(data_area_flag ? "data" : "code");
		es(" area of: "); es(ap -&gt; area_name); ecnl());
	ASSERT(ap &amp;&amp; ap -&gt; area_pointer &amp;&amp; area_is_marked(ap));
	
	/* We don't use a for loop here because the inner while loop also changes rp. */
	rp = ap -&gt; area_refs;
	while (rp) {
	
		long patch_val = 0;			/* The amount to be added or subtracted from the patched field. */
		long prev = 0;				/* The previous value of the patched field. */
		short ref_size = 0;			/* The size in bytes of the patched field: 2 or 4. */
		char * cp = NULL;			/* Pointer to the patched field. */
		long sum2 = 0;				/* Sum of all 2-byte references. */
		
		ASSERT(rp -&gt; ref_dict &amp;&amp; rp -&gt; ref_dict -&gt; dict_area);
		ref_area = rp -&gt; ref_dict -&gt; dict_area;
		
		/* Set abbreviations. */
		cp = ap -&gt; area_pointer + rp -&gt; ref_offset;
		patch_val = (long) (ref_area -&gt; area_base + rp -&gt; ref_dict -&gt; dict_offset);
		prev = (rp -&gt; ref_size == 2) ? (*((short *) cp)) : (*((long *) cp));
	
		/* Make sure the patch is within the area *containing* the reference. */
		if (rp -&gt; ref_offset + rp -&gt; ref_size &gt; ap -&gt; area_length) {
			ecnls(2);
			es("reference address + size too large!\n");
			es("reference to label: ");
			es(rp -&gt; ref_dict -&gt; dict_name);
			if (ref_area -&gt; area_name) {
				es(", in area: "); es(ref_area -&gt; area_name);
			}
			else {
				es(", in unnamed area");
			}
			es(", area size: "); eulong(ap -&gt; area_length);
			ecnl();
			es("Reference in area: ");	es(ap -&gt; area_name);
			es(", ref offset: ");		eulong(rp -&gt; ref_offset);
			es(", ref size: ");			eint(rp -&gt; ref_size);
			
			ecnl();
			check_oops ("", finfo);
		}
		
		/* 4-byte references are simple because the patch will always fit in 4 bytes. */
		if (rp -&gt; ref_size == 4) {
		
			if (ref_is_neg(rp)) {
				(* ((long *) cp))  -= patch_val;
			}
			else {
				(* ((long *) cp))  += patch_val;
			}
			
			TRACEPN(ftag,
				es("at: ");	epadhex(rp -&gt; ref_offset, 4);
				es("(");	eulong(rp -&gt; ref_size); es(") ");
				epadhex(prev, 8); es(" -&gt; ");
				epadhex(*((long *) cp), 8); eblank();
				epads(rp -&gt; ref_dict -&gt; dict_name, 20); es(" = ");
				es(ref_area -&gt; area_name); es("+"); epadhex(rp -&gt; ref_dict -&gt; dict_offset,4);
				ecnl();
			);
			
			rp = rp -&gt; ref_next;
			continue;
		}
		
		/*
			At this point we have a 2-byte reference.
			Accumulate 2-byte references to the same location.
			When no more such references remain,
			make sure the sum of all patch values will fit in 2 bytes.
			
			This is just a bit of a kludge,
			because it relies on the fact that the assembler will output
			all references to the same location with no intervening references
			to other locations.
		*/
		while(rp &amp;&amp; rp -&gt; ref_size == 2) {
		
			/* Stop accumating if the reference isn't to the previous patch area. */
			ASSERT(rp -&gt; ref_dict &amp;&amp; rp -&gt; ref_dict -&gt; dict_area);

			if (ap -&gt; area_pointer + rp -&gt; ref_offset != cp) {
				break;
			}
			
			/* Make sure the patch is within the area *containing* the reference. */
			if (rp -&gt; ref_offset + rp -&gt; ref_size &gt; ap -&gt; area_length) {
				ecnls(2);
				es("reference address + size too large!\n");
				es("reference to label: ");
				es(rp -&gt; ref_dict -&gt; dict_name);
				if (ref_area -&gt; area_name) {
					es(", in area: "); es(ref_area -&gt; area_name);
				}
				else {
					es(", in unnamed area");
				}
				es(", area size: "); eulong(ap -&gt; area_length);
				ecnl();
				es("Reference in area: ");	es(ap -&gt; area_name);
				es(", ref offset: ");		eulong(rp -&gt; ref_offset);
				es(", ref size: ");			eint(rp -&gt; ref_size);
				
				ecnl();
				check_oops ("", finfo);
			}
		
			/* A reference to the same patch location as before. */
			patch_val = (long) (ref_area -&gt; area_base + rp -&gt; ref_dict -&gt; dict_offset);

			if (ref_is_neg(rp)) {
				sum2 -= patch_val;
			}
			else {
				sum2 += patch_val;
			}
			
			TRACEPN(ftagv,
				es("at: ");	epadhex(rp -&gt; ref_offset, 4);
				es("(");	eulong(rp -&gt; ref_size); es(") ");
				es("current sum2: "); epadhex(sum2,8); eblank();
				epads(rp -&gt; ref_dict -&gt; dict_name, 20); es(" = ");
				es(ref_area -&gt; area_name); es("+"); epadhex(rp -&gt; ref_dict -&gt; dict_offset,4);
				ecnl();
			);
			
			rp = rp -&gt; ref_next;
		}

		/* Make sure a 2-byte reference will fit in two bytes. */
		if (
			(sum2 &lt;  0 &amp;&amp; (sum2 &amp; 0xffff0000) != 0xffff0000) ||
			(sum2 &gt;= 0 &amp;&amp; (sum2 &amp; 0xffff0000) != 0)
		) {

			ecnls(2);
			es("total of 2-byte references will not fit in two bytes!\n");
			es("sum2: "); epadhex(sum2, 4);
			ecnl();
			check_oops ("", finfo);
		}
		
		/* Adjust the reference. */
		(* ((short *) cp)) += (short) (sum2 &amp; 0xffff);
		
		TRACEPN(ftagv,
			es("at: ");	epadhex(rp -&gt; ref_offset, 4);
			es("(");	eulong(rp -&gt; ref_size); es(") ");
			epadhex(prev, 4); es(" -&gt; ");
			epadhex( ((*((short *) cp)) &amp; 0xffff), 4); eblank();
			ecnl();
		);
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1186">@ Check for referenced and undefined labels and doubly defined labels.
@c

static void
link_check (void)
{
	FTAG("link_check");
	register dict_node * dp = NULL;
	ulong max_bad_name = 10;
	ulong def_count = 0;
	ulong ref_count = 0;
	ulong unneeded_count = 0;
	STATB(ftag);
	
	/* Define the label _jump_table if needed. */
	{
		char * jump_name = "_jump_table";
		long hash = 0;
		dict_node * dp = NULL;
		area_node * ap = NULL;
		dlist_node * dlp = NULL;
		
		hash = st_hash(jump_name);
		dp = st_lookup(jump_name, hash);
		
		if (dp &amp;&amp; dp -&gt; dict_def_count &gt; 0) {
			error(es("_jump_table must be defined by the linker"));
		}
		else if (dp) {

			/*
				The symbol has been referenced but not defined.
				Define the symbol as offset of 0 from
				a dummy area starting at main_user_mem.
			*/
			ASSERT(dp -&gt; dict_def_count == 0);
			ASSERT(main_user_mem);
			
			/* Only one dict node is defined in the area. */
			new_perm_macro(dlp, dlist_stats);
			dlp -&gt; dlist_dict = dp;
			dlp -&gt; dlist_next = NULL;
			
			/*
				Create a dummy area node.
				This node should remain hidden from the linker
				so link_resolve won't allocate memory for it.
			*/
			new_perm_macro(ap, area_stats);
			area_set_marked(ap);
			ap -&gt; area_unit = NULL;
			ap -&gt; area_dict = dp;
			ap -&gt; area_name = "_jump_table";
			ap -&gt; area_dict_def_list = dlp;
			ap -&gt; area_base = main_user_mem;
			
			/* Define the label as offset 0 from the dummy area. */
			dp -&gt; dict_def_count++;
			dict_set_defined(dp);
			dp -&gt; dict_area = ap;
			dp -&gt; dict_offset = 0;
		}
	}

	/* Compute the maximum width of the undefined or multiply-defined names. */
	for (dp = dict_list; dp; dp = dp -&gt; dict_global_next) {
	
		if (dp -&gt; dict_def_count &gt; 1) {
			def_count++;
			max_bad_name = max(max_bad_name, strlen(dp -&gt; dict_name));
		}
		
		if (dp -&gt; dict_ref_count &gt; 0 &amp;&amp; dp -&gt; dict_def_count == 0) {
			ref_count++;
			max_bad_name = max(max_bad_name, strlen(dp -&gt; dict_name));
		}
	}
	
	/* Count the number of unneeded files. */
	{
		file_node * finfo = NULL;
		for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
			if (finfo -&gt; file_marked_areas == 0) {
				unneeded_count++;
			}
		}
	}

	/* Print list of multiply-defined labels to the log file. */
	if (def_count) {
	
		ecnls(2); es("Multiply-defined labels...\n");
		epads("LABEL", max_bad_name); eblank(); es("DEFINING FILES");
	
		for (dp = dict_list; dp; dp = dp -&gt; dict_global_next) {
		
			if (dp -&gt; dict_def_count &gt; 1) {
			
				/* Multiply-defined items. */
				link_err_count++;
				ecnl();
				epads(dp -&gt; dict_name, max_bad_name); eblank(); 
				link_print_flist(dp -&gt; dict_def_flist, max_bad_name+1, TO_LOG_FILE);
				ecnl();
				
			}
		}
		ecnls(2);
	}
	
	/* Print list of multiply-defined labels to the map file. */
	if (def_count &amp;&amp; arg_map_flag &amp;&amp; !arg_tuple_map_flag &amp;&amp; os_text_file) {
	
		ocnls(2); os("Multiply-defined labels...\n");
		opads("LABEL", max_bad_name); oblank(); os("DEFINING FILES");
	
		for (dp = dict_list; dp; dp = dp -&gt; dict_global_next) {
		
			if (dp -&gt; dict_def_count &gt; 1) {
			
				/* Multiply-defined items. */
				link_err_count++;
				ocnl();
				opads(dp -&gt; dict_name, max_bad_name); oblank(); 
				link_print_flist(dp -&gt; dict_def_flist, max_bad_name+1, TO_MAP_FILE);
				ocnl();
				
			}
		}
		ocnls(2);
	}
	
	/* Print list of uefined labels to the log file. */
	if (ref_count) {
	
		ecnls(2); es("Undefined labels...\n");
		epads("LABEL", max_bad_name); eblank(); es("REFERENCING FILES");

		for (dp = dict_list; dp; dp = dp -&gt; dict_global_next) {
			
			if (dp -&gt; dict_ref_count &gt; 0 &amp;&amp; dp -&gt; dict_def_count == 0) {
			
				/* Referenced but not defined items. */
				link_err_count++;
				ecnl();
				epads(dp -&gt; dict_name, max_bad_name); eblank();
				link_print_flist(dp -&gt; dict_ref_flist, max_bad_name+1, TO_LOG_FILE);
				ecnl();
			}
		}
		ecnls(2);
	}
	
	/* Print list of undefined labels to the map file. */
	if (ref_count &amp;&amp; arg_map_flag &amp;&amp; !arg_tuple_map_flag &amp;&amp; os_text_file) {
	
		ocnls(2); os("Undefined labels...\n");
		opads("LABEL", max_bad_name); oblank(); os("REFERENCING FILES");

		for (dp = dict_list; dp; dp = dp -&gt; dict_global_next) {
			
			if (dp -&gt; dict_ref_count &gt; 0 &amp;&amp; dp -&gt; dict_def_count == 0) {
			
				/* Referenced but not defined items. */
				link_err_count++;
				ocnl();
				opads(dp -&gt; dict_name, max_bad_name); oblank();
				link_print_flist(dp -&gt; dict_ref_flist, max_bad_name+1, TO_MAP_FILE);
				ocnl();
			}
		}
		ocnls(2);
	}
	
	/* Print the list of unneeded source files to the log file. */
	if (unneeded_count) {
		file_node * finfo = NULL;
		ecnls(2); es("Unneeded files...\n");
		for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
			if (finfo -&gt; file_marked_areas == 0) {
				es(finfo -&gt; file_name); enl();
			}
		}
		ecnls(2);
	}
	
	/* Print the list of unneeded source files to the map files file. */
	if (unneeded_count &amp;&amp; !arg_tuple_map_flag) {
		file_node * finfo = NULL;
		ocnls(2); os("Unneeded files...\n");
		for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
			if (finfo -&gt; file_marked_areas == 0) {
				os(finfo -&gt; file_name); onl();
			}
		}
		ocnls(2);
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1187">@ Print a file name. Print the name in brackets if the file is not marked.
@c

static void
link_print_file_name(file_node * finfo, bool map_flag)
{
	FTAG("link_print_file_name");
	char * s = NULL;
	STATB(ftag);
	ASSERT(finfo);
	s = cvt_short_fn(finfo -&gt; file_name);
	
	if (map_flag == TO_MAP_FILE) {
		if (finfo -&gt; file_marked_areas == 0) {
			os("["); os(s); os("]");
		}
		else {
			os(s);
		}
	}
	else {
		if (finfo -&gt; file_marked_areas == 0) {
			es("["); es(s); es("]");
		}
		else {
			es(s);
		}
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1188">@ Print the names of all files in a file list.
@c

static void
link_print_flist(register flist_node * flist, int leading_blanks, bool map_flag)
{
	FTAG("link_print_flist");
	register first_flag = TRUE;
	register short col = leading_blanks;
	STATB(ftag);

	for (flist = flist; flist; flist = flist -&gt; next) {

		file_node * finfo = flist -&gt; flist_info;
		char * s = cvt_short_fn(finfo -&gt; file_name);
		size_t length = strlen(s);
		ASSERT(finfo);
		
		if (first_flag) {
			/* Always print at least one file name per line. */
			link_print_file_name(finfo, map_flag);
			first_flag = FALSE;
		}
		else if (strlen(s) + col &gt; 80) {
			col = leading_blanks;
			if (map_flag == TO_MAP_FILE) {
				ocnl(); oblanks(leading_blanks); link_print_file_name(finfo, map_flag);
			}
			else {
				ecnl(); eblanks(leading_blanks); link_print_file_name(finfo, map_flag);
			}
			first_flag = FALSE;
		}
		else {
		
			if (map_flag == TO_MAP_FILE) {
				os(", ");
			}
			else {
				es(", ");
			}
			link_print_file_name(finfo, map_flag);
			col = col + 2 + length;
		}
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1189">@ Resolve the load address for all marked areas.
@c

static void
link_resolve (void)
{
	FTAG("link_resolve");
	
		register file_node * finfo = NULL;
		register unit_node * up = NULL;
		register area_node * ap = NULL;
		
		char * code_start = NULL;
		char * code_end = NULL;
		char * data_start = NULL;
		char * data_end = NULL;
	STATB(ftag);
	
	/* Initialize the data load address. */
	if (arg_data_flag) {
		load_address = arg_data_address;
	}
	else {
		arg_data_address = (char *) (JUMP_TABLE_ENTRIES * sizeof(jump));
	}
	
	/*
		Calculate the addresses of all marked data areas.
		WARNING: this order must match the order in which data areas are output.
	*/
	if (((ulong)load_address) &amp; 1) {
		load_address++;
	}	
	data_start = load_address;
	for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
		for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
			ap = up -&gt; unit_data_area;
			if (ap &amp;&amp; area_is_marked(ap)) {
				ap -&gt; area_base = load_address;
				load_address += ap -&gt; area_length;
				ASSERT((((ulong)load_address) &amp; 1) == 0);
				TRACEPN(ftag,
					es("data area: "); eptr(ap -&gt; area_base);
					es(", length: ");	epadulong(ap -&gt; area_length, 4);
					ecs(); es(ap -&gt; area_name); ecnl());
			}
		}
	}
	data_end = load_address - 1;
		
	/* Initialize the load address. */
	if (arg_code_flag) {
		load_address = arg_code_address;
	}
	
	/*
		Calculate the addresses of all marked code areas.
		WARNING: this order must match the order in which data areas are output.
	*/
	
	if (((ulong)load_address) &amp; 1) {
		load_address++;
	}

	code_start = load_address;
	for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
		for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
			ap = up -&gt; unit_code_area;
			if (ap &amp;&amp; area_is_marked(ap)) {
				ap -&gt; area_base = load_address;
				load_address += ap -&gt; area_length;
				ASSERT((((ulong)load_address) &amp; 1) == 0);
				TRACEPN(ftag,
					es("code area: "); eptr(ap -&gt; area_base);
					es(" : ");			eptr(ap -&gt; area_base + ap -&gt; area_length);
					ecs(); es(ap -&gt; area_name); ecnl());
			}
		}
	}
	code_end = load_address - 1;
	
	/*
		Check for overlapping code and data addresses.
		This check only makes sense if mark_data_total &gt; 0 &amp;&amp; mark_code_total &gt; 0.
	*/
	if (
		mark_data_total &gt; 0 &amp;&amp; mark_code_total &gt; 0 &amp;&amp;
		(
			(code_start &gt;= data_start &amp;&amp; code_start &lt;= data_end) ||
			(code_end   &gt;= data_start &amp;&amp; code_end   &lt;= data_end) ||
			(data_start &gt;= code_start &amp;&amp; data_start &lt;= code_end) ||
			(data_end   &gt;= code_start &amp;&amp; data_end   &lt;= code_end)
		)
	) {
		error(
			es("code and data areas overlap");  enl();
			es("data start: "); eptr(data_start); ecs();
			es("data end: ");	eptr(data_end);   enl();
			es("code start: "); eptr(code_start); ecs();
			es("code end: ");	eptr(code_end);   enl();
		);
	}

	STATX(ftag);
}</t>
<t tx="ekr.20080529093004.1190">/*
	Link: routines to load the linked program and called by the linked program.
	
	source:  LKload.c.
	started: June 27, 1994.
	version:
		January 25, 1995.
			Bug fix to _Open.  Set O_BINARY flag for binary files.
		January 20, 1995.
			Added entries in jtab for testing floating point routines.
		January 16, 1995.
			Cleaned up the code by removing commented out routines.
		January 12, 1995.
			Removed _THINK_cvt_double
		January 4, 1995.
			Added _THINK_cvt_double as a way of avoiding
			calls to fprintf with float arguments.
		November 2, 1994.
			++TMON_symbols calls debug_str.
		August 31, 1994.
			Complete the new jump table used for the minimal system interface.
			Send _Write output for stdout and stderr to exxx stream.
		July 16, 1994.
			Patch into log_xxx routines instead of exxx routines.
			This allows the exxx routines to use the proper es2os_flag.
			Also, replace the patch to edouble by the new log_cblanks routine.
			edouble uses cvt_double, which is all that needs to be patched.
*/

&lt;&lt; LKload #includes &gt;&gt;
&lt;&lt; LKload declarations &gt;&gt;
@others

#endif</t>
<t tx="ekr.20080529093004.1191">#include "LK.h"

#include "LKarg.h"
#include "LKload.h"
#include "LKmain.h"
#include "LKmap.h"
#include "LKmark.h"
#include "LKnodes.h"
#include "LKst.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBlog.h&gt;
#include &lt;LIBobj.h&gt;
#include &lt;LIBos.h&gt;

#include &lt;stdio.h&gt;		/* For jump table... */
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#include &lt;fcntl.h&gt;
#include &lt;unix.h&gt;	
</t>
<t tx="ekr.20080529093004.1192">/*
	Prototypes of routines local to this module.
	Don't declare these static so they can be traced more easily.
*/

	/* Synonyms for data_area_flag. */
	enum { DATA_AREA = TRUE, CODE_AREA = FALSE};

static void		load_one_area	(area_node * ap, bool data_area_flag);
		
	void	_user_exit		(void);

	void	_chk_ptr(void * p);
	int		_Close	(int);
	void	_Exit	(int);
	int 	_Execl	(const char *, const char *, const char *);
	int		_Fork	(void);	
	void *	_Getmem	(size_t size);
	int		_Getpid	(void);
	int		_Open	(const char *, int, int);
	long	_Lseek	(int, long, int);
	int		_Read	(int, unsigned char *, int);
	int		_Remove	(const char *);
	int		_Rename	(const char *, const char *);
	long	_Ticks	(void);
	time_t	_Time	(time_t *);
	int		_Write	(int, const unsigned char *, int);
	int		_Wait	(int *);
	
	/* Temporary floating point tests. */

	double	_add	(double, double);
	double	_sub	(double, double);
	double	_mul	(double, double);
	double	_div	(double, double);

	short	_eq		(double, double);
	short	_gt		(double, double);

	long	_d2l	(double);
	double	_l2d	(long);
	float	_d2f	(double);
	double	_f2d	(float);
	
	double	_neg	(double);
</t>
<t tx="ekr.20080529093004.1193">@ Move all code and data areas into the program area.
@c

static void
load_all_areas (void)
{
	FTAG("load_all_areas");
	register file_node * finfo = NULL;
	register unit_node * up = NULL;
	register area_node * ap = NULL;
	STATB(ftag);

	/* Set the initial load point to just after the jump table. */
	
	/* Load all data areas. */
	for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
		for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
			ap = up -&gt; unit_data_area;
			if (ap &amp;&amp; area_is_marked(ap)) {
				load_one_area(ap, DATA_AREA);
			}
		}
	}
		
	/* Load all code areas. */
	for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
		for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
			ap = up -&gt; unit_code_area;
			if (ap &amp;&amp; area_is_marked(ap)) {
				load_one_area(ap, CODE_AREA);
			}
		}
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1194">@ Load one area into the program area.
@c

static void
load_one_area(register area_node * ap, bool data_area_flag)
{
	FTAG("load_one_area");
	TRACEPB(ftag,
		es(data_area_flag ? "data" : "code"); eblank();
		es("address: ");		eptr(ap -&gt; area_base);
		es(" length: ");	epadhex(ap -&gt; area_length, 5);
		ecs(); es(ap -&gt; area_name);
		ecnl());
	
	/* Move the area's bytes into the program area. */
	memcpy( (void *) ap -&gt; area_base, ap -&gt; area_pointer, ap -&gt; area_length);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1195">@ Allocate and fill in the user area for the link and go option.
@c

void * jump_table_address[JUMP_TABLE_ENTRIES] = {

	/* Entry and exit. */

		&amp;_user_startup,	/* 0: do not change. */
		&amp;_user_exit,	/* 1: do not change. */
		NULL,			/* 2: reserved.  No longer used. */
		
	/* The address of main. */
	
		NULL,		/* 3 : Filled in below. */

	/* Memory allocation */

		&amp;_Getmem,	/* 4 */
		
	/* File i/o */
	
		&amp;_Close,	/*  5 */
		&amp;_Lseek,	/*  6 */
		&amp;_Open,		/*  7 */
		&amp;_Read,		/*  8 */
		&amp;_Remove,	/*  9 */
		&amp;_Rename,	/* 10 */
		&amp;_Write,	/* 11 */
		
	/* Time routines.  _Time can be defined in terms of mktime, or vice versa. */

		NULL,			/* 12: reserved for mktime. */
		&amp;_Time,			/* 13 */
		
	/*
		Process control
		None of these are used by the tools.
		StdClib references these in essentially a dummy manner.
	*/
		&amp;_Execl,	/* 14 */
		&amp;_Fork,		/* 15 */
		&amp;_Getpid,	/* 16 */
		&amp;_Wait,		/* 17 */
		
	/* Miscellaneous. */

		&amp;_chk_ptr,	/* 18 */
		&amp;_Ticks,	/* 19 */
		
	/* Temporary floating point tests. */
	
		&amp;_add,		/* 20 */
		&amp;_sub,		/* 21 */
		&amp;_mul,		/* 22 */
		&amp;_div,		/* 23 */
		&amp;_eq,		/* 24 */
		&amp;_gt,		/* 25 */
		&amp;_d2l,		/* 26 */
		&amp;_l2d,		/* 27 */
		&amp;_d2f,		/* 28 */
		&amp;_f2d,		/* 29 */
		&amp;_neg,		/* 30 */
};

/*
	Allocate space large enough for the jump table, code and data areas.
	The loaded program will use the *linker's* heap,
	so we don't have to allocate a separate heap space.
	Set the arg_code_address and arg_data_address globals for link.
	
	This routine must be called *before* link for two reasons:
	1. This routine sets arg_code_address and arg_data_address used by link.
	2. This routine sets main_user_mem used by link_check.
*/ 
void
load_create_user_mem(void)
{
	FTAG("load_create_user_mem");
		ulong jump_table_size = (JUMP_TABLE_ENTRIES * sizeof(jump));
		ulong total_size = jump_table_size + mark_code_total + mark_data_total;
	STATB(ftag);

	obj_new_macro(main_user_mem, total_size, "user memory");
	if (main_user_mem) {
		
		/* Set the starting addresses. */
		arg_code_flag = TRUE;
		arg_data_flag = TRUE;
		arg_data_address = main_user_mem + jump_table_size;
		arg_code_address = arg_data_address + mark_data_total;
		
		TRACEPN(ftag, 
			eulong(total_size); es(" bytes allocated to user memory\n");
			es("jump table: "); eptr(main_user_mem);
			es(", data area: "); eptr(arg_data_address);
			es(", code area: "); eptr(arg_code_address);
			enl();
		);
		
		/* Output this information to the map file. */
		if (os_text_file &amp;&amp; arg_verbose_flag) {

			ocnls(2);
			map_begin_comment_line();
			oulong(total_size);	 os(" bytes allocated to user memory\n");
			
			map_begin_comment_line();
			os("jump table: "); optr(main_user_mem);
			os(", data area: "); optr(arg_data_address);
			os(", code area: "); optr(arg_code_address);
			ocnls(2);
		}
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1196">@ Fill in the jump table with jumps to routines in the linker. (This allows the loaded program to access Macintosh routines.) Copy all marked code and data areas into the allocated area.  This routine must be called *after* link.
@c

void
load_user_mem(void)
{
	FTAG("load_user_mem");
	STATB(ftag);
	
	/* Fill in the entry in the address table for the main routine. */
	{
		ASSERT(main_dict &amp;&amp; main_area);
		ASSERT(jump_table_address[3] == NULL);
		jump_table_address[3] = main_area -&gt; area_base + main_dict -&gt; dict_offset;
	}
	
	/* Fill in the jump table. */
	{
		int i = 0;
		jump * j = (jump *) main_user_mem;
		for (i = 0; i &lt; JUMP_TABLE_ENTRIES; i++, j++) {
			j -&gt; op_code = JMP_ABS_LONG;	/* JMP (xxx).L */
			j -&gt; address = jump_table_address[i];
			TRACEPN(ftag,
				es("jump["); eint(i); es("] ");
				es("at: "); eptr(j); eblank();
				epadhex(JMP_ABS_LONG,4); eblank(); eptr(j -&gt; address); enl());
		}
	}
	
	/* Load all data and code areas. */
	load_all_areas();
	
	TRACEPN(ftag, st_dump());
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1197">@ The following routines are called from the *loaded* program via the jump table.
@c

</t>
<t tx="ekr.20080529093004.1198">static void
_user_abort	(void)
{
	es("User program called abort\n");
	main_quit();
	end_done();
}
</t>
<t tx="ekr.20080529093004.1199">static void
_user_exit (void)
{
	es("User program called exit\n");
	main_quit();
	end_done();
}
</t>
<t tx="ekr.20080529093004.1200">@ The main routine calls _user_startup to begin execution of the program.
@c

void
_user_startup (void)
{
	void (*f) (int argc, char **argv, char ** env) = jump_table_address [3];
	char * argv [] = { "user program", NULL };
	
	/* Jump to the user program in jump_table_address [3]. */
	ASSERT(arg_go_flag);
	ASSERT(jump_table_address [3]);
		
	es("_user_startup: calling main at: "); eptr(f); enl();
	
	/* Remember: this will not work if the Think C debugger is on. */
	TRACEP("TMON_symbols", DebugStr("\pmain"));

	/* Call the user code with minimal argv, argc, arg_env. */
	(*f) (1, argv, NULL);
	
	es("_user_startup: user program returned\n");
	
	main_quit();
	end_done();
}
</t>
<t tx="ekr.20080529093004.1201">@ ----- Start of library routines ------


Only these routines need be ported to port the entire Standard C Library.

Define a dummy environment.
_Environ is referenced only by the _Envp macro in yfuns.h.
_Envp is used only by getenv, figure , page 380, file getenv.c.
_Environ points to a list of NULL terminated strings. A NULL pointer terminates the list.  We can add extra strings to environs[] if needed.
@c

</t>
<t tx="ekr.20080529093004.1202">static const char * environs[] = { NULL };

const char **_Environ = &amp;environs[1];

/*
	Check for a use of a NULL pointer.
*/
void
_chk_ptr (void * p)
{
	if (p == NULL) {
		es("Using a NULL pointer at: "); eptr(p);
		end_abort();
	}
}
</t>
<t tx="ekr.20080529093004.1203">@ Glue routine for unix close call.
@c

int
_Close (int fd)
{
	return close(fd);
}
</t>
<t tx="ekr.20080529093004.1204">@ Glue routine for unix execl call.  This routine is different on the Mac than on unix: ? No arguments are passed to the executed program. Think_exec always exits, even if the program is not found.  This is called only by system, figure 13.37 page 380, file system.c.  Actually this routine will *never* be called because fork always fails.
@c

int
_Execl (const char * program_name, const char * s2, const char * s3)
{
	/* Never returns, even if the program is not found. */
	exec( (char *) program_name);
}
</t>
<t tx="ekr.20080529093004.1205">void
_Exit (int i)
{
	es("User program called exit\n");
	main_quit();
	end_done();
}
</t>
<t tx="ekr.20080529093004.1206">@ Glue routine for unix fork.  This is not available on the Mac so fail by returning -1.
@c

int
_Fork(void)
{
	return -1;
}
</t>
<t tx="ekr.20080529093004.1207">@ Glue routine for unix getpid routine.  This is called only from tmpnam, figure 12.10, page 284, file tmpname.c.  Because it used only to generate a unique name, it might be better simply to implement tmpnam directly.  This makes even more sense because:
o The StdClib version of tmpnam returns /tmp/t&lt;seed&gt;  (The slashes are different between DOS and Unix).
o The Think C version of getpid always returns 57 (!)
@c

int
_Getpid	(void)
{
	/*
		Generate a different number each time this is called.
		However, the number always starts at zero when the program first starts.
	*/
	static int pid = 0;
	return ++pid;
}
</t>
<t tx="ekr.20080529093004.1208">void *
_Getmem(size_t size)
{
	static ulong total = 0;
	static ulong max_size = 0;
	FTAG("_Getmem");
	void * p = NULL;
	obj_new_macro(p, size, "_Getmem");

	TRACEP(ftag,
		total += size;
		max_size = max(size, max_size);
		es("size: "); epadlong(size,5); eblank();
		eret(); eptr(p);
		es(", max_size: "); eulong(max_size); 
		es(", total: "); eulong(total); enl());

	return p;
}
</t>
<t tx="ekr.20080529093004.1209">@ Rename old file to be the new file. Return 0 on success, non-zero on error.  This is called only by the rename routine.
@c

int
_Rename (const char * old, const char * new)
{
	return rename(old, new);
}
</t>
<t tx="ekr.20080529093004.1210">@ Glue routine to the unix seek routine.  Called from:
o _Fgpos, figure 12.12, page 285, file xfgpos.c.
o _Fspos, figure 12.13, page 286, file xfspos.c.
@c

long
_Lseek (int fd, long offset, int way)
{
	int whence = 0;
	
	#if 0 /* Constants from StdClib version of stdio.h */
		#define SEEK_SET	0
		#define SEEK_CUR	1
		#define SEEK_END	2
	#endif
	
	/*
		whence is one of:
		SEEK_SET: beginning of file.
		SEEK_CUR: current position of file.
		SEEK_END: end of file.
		
		The constants 0, 1 and 2 come from StdClib version of stdio.h.
	*/
	
	#if 0 /* These constants are defined the same in stdio.h and Think_stdio.h. */
		if (way == 0) {
			whence = SEEK_SET;
		}
		else if (way == 1) {
			whence = SEEK_CUR;
		}
		else {
			whence = SEEK_END;
		}
	#else
		whence = way;
	#endif

	return lseek (fd, offset, whence);
}
</t>
<t tx="ekr.20080529093004.1211">@ Glue routine to the unix open routine.  It is called only from _Fopen, figure 12.11, page 284, file xfopen.c.
@c

int
_Open (const char * filename, int acc, int dummy)
{
	int mode = 0;

	#if 0 /* This is the calling code in _Fopen. */
		acc = (smode &amp; (_MOPENR|_MOPENW)) == (_MOPENR|_MOPENW) ? 2
			: smode &amp; _MOPENW ? 1 : 0;
		if (smode &amp; _MOPENA)
			acc |= 010;		/* O_APPEND */
		if (smode &amp; _MTRUNC)
			acc |= 02000;	/* O_TRUNC */
		if (smode &amp; _MCREAT)
			acc |= 01000;	/* O_CREAT */
			
		/*
			1/25/95.
			Plauger's code clearly has a bug here.
			_Foprep sets the _MBIN bits in smode, but they are never used.
		*/
		if (smode &amp; _MBIN) {
			acc |= 0100;	/* EKR: new O_BINARY code for use only by _Open */
		}
	#endif

	/*
		Must have exactly one of O_WRONLY, O_RDONLY or O_RDWR.
		
		The constants 0, 1 and 2 come from the _Fopen code above.
		
		acc == 2: read/write:	_MOPENR and _MOPENW set
		acc == 1: write:		_MOPENW set				
		acc == 0: read:			neither set
	*/
	if (acc &amp; 2) {
		mode |= O_RDWR;
	}
	else if (acc &amp; 1) {
		mode |= O_WRONLY;
	}
	else {
		mode |= O_RDONLY;
	}
	
	/*
		May have any number of O_APPEND, O_CREAT, O_TRUNC, O_EXCL.
		
		The "magic constants" come from the _Fopen code above.
	*/
	if (acc &amp; 010) {
		mode |= O_APPEND;
	}
	if (acc &amp; 02000) {
		mode |= O_TRUNC;
	}
	if (acc &amp; 01000) {
		mode |= O_CREAT;
	}
	
	/* 1/25/95: new code to handle bug in Plauger's code. */
	if (acc &amp; 0100) {
		mode |= O_BINARY;
	}
	else {
		mode |= O_TEXT;
	}

	return open( (char *) filename, mode);
}
</t>
<t tx="ekr.20080529093004.1212">@ Glue routine to the unix read routine.  Called via the expansion of the _Fread macro defined in yfuns.h.  _Fread is called only from _Frprep, figure 12.32, page 295, file xfrprep.c.
@c

int
_Read (int fd, unsigned char * buffer, int n)
{
	return read (fd, (char *) buffer, n);
}
</t>
<t tx="ekr.20080529093004.1213">@ Glue routine for ticks routine.
@c

long
_Ticks(void)
{
	long VIA_ticks(void);
	return VIA_ticks();	/* Mac VIA timer. */
}
</t>
<t tx="ekr.20080529093004.1214">@ Glue routine for unit time routine.  This is called only from time, figure 15.2, page 426, file time.c.
@c

time_t
_Time(time_t * t)
{
	return time(t);
}
</t>
<t tx="ekr.20080529093004.1215">@ Remove the indicated file from the file system. Return 0 on success, non-zero on error.  This is called only by the remove function.
@c

int
_Remove (const char * filename)
{
	remove(filename);
}
</t>
<t tx="ekr.20080529093004.1216">@ Glue routine for unix wait.  This is called only by system, figure 13.37 page 380, file system.c.  Actually this routine will *never* be called because fork always fails.  This is not available on the Mac so fail by returning -1.
@c

int
_Wait(int * ip)
{
	return -1;
}
</t>
<t tx="ekr.20080529093004.1217">@ Glue routine to the unix write routine.  Called via the expansion of the _Fwrite macro defined in yfuns.h.  _Fwrite is called only from fflush, figure 12.37, page 295, file fflush.c.
@c

int
_Write (int fd, const unsigned char * buf, int n)
{
	if (fd == 1 || fd == 2) {
		/* Put the "console to the exxx stream. */
		int i;
		for (i = 0; i &lt; n; i++) {
			echar(buf[i]);
		}
		return n;
	}
	else {
		return write(fd, (char *) buf, n);
	}
}
</t>
<t tx="ekr.20080529093004.1218">@ Floating point tests. To have any purpose, these must be compiled by Think C.
@c

#ifdef THINK_C

double	_add	(double d1, double d2)	{ return d1 + d2; }
</t>
<t tx="ekr.20080529093004.1219">double	_sub	(double d1, double d2)	{ return d1 - d2; }
</t>
<t tx="ekr.20080529093004.1220">double	_mul	(double d1, double d2)	{ return d1 * d2; }
</t>
<t tx="ekr.20080529093004.1221">double	_div	(double d1, double d2)	{ return d1 / d2; }
</t>
<t tx="ekr.20080529093004.1222">short	_eq		(double d1, double d2)	{ return d1 == d2; }
</t>
<t tx="ekr.20080529093004.1223">short	_gt		(double d1, double d2)	{ return d1  &gt; d2; }
</t>
<t tx="ekr.20080529093004.1224">long	_d2l	(double d)	{ return (long) d; }
</t>
<t tx="ekr.20080529093004.1225">double	_l2d	(long l)	{ return (double) l; }
</t>
<t tx="ekr.20080529093004.1226">float	_d2f	(double d)	{ return (float) d; }
</t>
<t tx="ekr.20080529093004.1227">double	_f2d	(float f)	{ return (double) f; }
</t>
<t tx="ekr.20080529093004.1228">double	_neg	(double d)	{ return -d; }
</t>
<t tx="ekr.20080529093004.1229">/*
	Link: map file output routines.

	source:  LKmap.c
	started: November 21, 1993.
	version:
		May 10, 1994.
			Revised to handle the new object file.
		January 8, 1994.
*/

&lt;&lt; LKmap #includes &gt;&gt;
&lt;&lt; LKmap declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1230">#include "LK.h"

#include "LKarg.h"
#include "LKmain.h"
#include "LKmap.h"
#include "LKmem.h"
#include "LKnodes.h"

#include &lt;LIBio.h&gt;
#include &lt;LIBlist.h&gt;
#include &lt;LIBos.h&gt;

#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.1231">/*
	Define local statistics variables.
*/
static ulong map_files = 0;

static ulong map_file_areas = 0;		/* Number of areas in the current file. */
static ulong map_file_area_bytes = 0;	/* Size of itmes in the current file. */

static ulong map_global_areas = 0;		/* Number of areas in all files. */
static ulong map_global_area_bytes = 0;	/* Size of areas in all files. */

/*
	Prototypes for local routines.
*/

	/* Synonyms for dump_labels_flag */
	enum { DUMP_LABELS = TRUE, DONT_DUMP_LABELS = FALSE };
	
static void map_area		(area_node * ap, bool dump_labels_flag);
static void	map_one_area	(area_node * ap);
static ulong map_out_dict	(dict_node * dp, char * name);
static void map_subtree		(unit_node * up, ulong tree_level);
</t>
<t tx="ekr.20080529093004.1232">@ Write the portion of the map that is organized by load address.
@c

void
map_all_areas(void)
{
	FTAG("map_all_areas");
		register file_node * finfo = NULL;
		register unit_node * up = NULL;
		register area_node * ap = NULL;
	STATB(ftag);
	ASSERT(os_text_file);
	
	/* Initialize stats. */
	map_global_areas = 0;
	map_global_area_bytes = 0;
	map_file_areas = 0;
	map_file_area_bytes = 0;
	
	if (arg_verbose_flag) {
		ecnl(); eblanks(4); es("Writing map of code and data areas...\n");
	}

	if (arg_verbose_map_flag) {
		ocnls(2);
		map_begin_comment_line();
		os("Data areas and labels...");
	}
	
	/* Get stats for data areas and output any map info. */		
	for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
		for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
			ap = up -&gt; unit_data_area;
			if (ap &amp;&amp; area_is_marked(ap)) {
				map_area(ap, DUMP_LABELS);
			}
		}
	}

	/* Write grand totals. */
	map_global_areas = map_file_areas;
	map_global_area_bytes = map_file_area_bytes;
	map_grand_totals("Totals for data areas");

	/* Initialize stats. */
	map_global_areas = 0;
	map_global_area_bytes = 0;
	map_file_areas = 0;
	map_file_area_bytes = 0;

	if (arg_verbose_map_flag) {
		ocnls(2);
		map_begin_comment_line();
		os("Code areas and labels...\n");
	}

	/* Get stats for code areas and output any map info. */		
	for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
		for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
			ap = up -&gt; unit_code_area;
			if (ap &amp;&amp; area_is_marked(ap)) {
				map_area(ap, DUMP_LABELS);
			}
		}
	}

	/* Write grand totals. */
	map_global_areas = map_file_areas;
	map_global_area_bytes = map_file_area_bytes;
	map_grand_totals("Totals for code areas");

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1233">@ Write the portion of the map that is organized by file.
@c

void
map_all_files (void)
{
	FTAG("map_all_files");
	register file_node * finfo = NULL;
	register bool first_flag = TRUE;
	STATB(ftag);
	ASSERT(os_text_file);
	
	/* Initialize stats. */
	map_global_areas = 0;
	map_global_area_bytes = 0;
	map_file_areas = 0;
	map_file_area_bytes = 0;
	
	if (arg_verbose_flag) {
		ecnl(); eblanks(4); es("Writing map of file info...\n");
	}

	ocnls(2); os("File information...");

	/* For each file info node. */
	for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
		
		/* Write info about each marked area in the file. */
		if (finfo -&gt; file_marked_areas &gt; 0) {
			map_one_file (finfo);
		}
	}
	
	/* Write grand totals. */
	map_grand_totals("Totals for entire file");
		
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1234">@ Output the map information about one area.
@c

static void
map_area(area_node * ap, bool dump_labels_flag)
{
	FTAG("map_area");
	STATB(ftag);
	ASSERT(ap);

	if (arg_tuple_map_flag &amp;&amp; ap -&gt; area_dict_def_list) {
	
		dlist_node * dlp = NULL;

		/* Print the name of the area. */
		/* Write a comment. */
		ocnl();
		if (ap -&gt; area_name) {
			ocnls(2);
			map_begin_comment_line();
			os(ap -&gt; area_name); onl(); onl();
		}
		
		/* Reverse the label list so it prints in increasing order. */
		lst_general_reverse_macro(ap -&gt; area_dict_def_list, dlist_next, dlist_node);				
		
		for (dlp = ap -&gt; area_dict_def_list; dlp; dlp = dlp -&gt; dlist_next) {
			dict_node * dp = dlp -&gt; dlist_dict;
			ASSERT(dp);
			ocnl(); 
			optr(dp -&gt; dict_offset + ap -&gt; area_base);
			oblank();
			os(dp -&gt; dict_name);
			onl();
		}
	}
	else if (arg_verbose_map_flag) {
		ocnls(dump_labels_flag ? 2 : 1);
		optr(ap -&gt; area_base);
		if (dump_labels_flag == DUMP_LABELS) {
			os(" length: "); opadhex(ap -&gt; area_length, 4);
		}
		else {
			oblank(); opadhex(ap -&gt; area_length, 6);
		}
		oblank();
		{
			ulong count = map_out_dict(ap -&gt; area_dict, ap -&gt; area_name);
			oblanks(30-count);
			if (dump_labels_flag == DUMP_LABELS) {
				os(" parent: ");
			}
			os(ap -&gt; area_parent ? ap -&gt; area_parent -&gt; unit_name : "&lt;NONE&gt;");
		}
		ocnl();
		
		if (dump_labels_flag == DUMP_LABELS &amp;&amp; ap -&gt; area_dict_def_list) {
			dlist_node * dlp = NULL;
			
			/* Reverse the label list so it prints in increasing order. */
			lst_general_reverse_macro(ap -&gt; area_dict_def_list, dlist_next, dlist_node);				
			
			for (dlp = ap -&gt; area_dict_def_list; dlp; dlp = dlp -&gt; dlist_next) {
				dict_node * dp = dlp -&gt; dlist_dict;
				ASSERT(dp);
				ocnl(); 
				optr(dp -&gt; dict_offset + ap -&gt; area_base);
				oblank();
				map_out_dict(dp, dp -&gt; dict_name);
				onl();
			}
		}
	}
	
	/* Update statistics. */
	map_file_areas++;
	map_file_area_bytes += ap -&gt; area_length;
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1235">@ Write the header of the map file.
@c

void
map_header(void)
{
	FTAG("map_header");
	STATB(ftag);
	
	ocnl();
	map_begin_comment_line();
	os("Map file for "); os(arg_out_path); onl();
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1236">@ Begin a comment line.
@c

void
map_begin_comment_line (void)
{
	ocnl();
	if (arg_tuple_map_flag) {
		os("! ");
	}
}
</t>
<t tx="ekr.20080529093004.1237">@ Write the grand totals.
@c

void
map_grand_totals(char * message)
{
	FTAG("map_grand_totals");
	STATB(ftag);

	ocnls(2);
	map_begin_comment_line();
	os(message);
	if (arg_verbose_map_flag) {
		os(": areas: ");		oulong(map_global_areas);
		os(", area bytes: ");	oulong(map_global_area_bytes);
		onl();
	}
	else {
		os(": areas: ");		opadulong(map_global_areas, 4);
		os(", area bytes: ");	opadulong(map_global_area_bytes, 7);
		onl();
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1238">@ Write the map info about one file. Write info about each marked area in the file. Also write the file statistics and update the global statistics.
@c

void
map_one_file(file_node * finfo)
{
	FTAG("map_one_file");
	register unit_node * up = NULL;
	register area_node * ap = NULL;
	STATB(ftag);
	ASSERT(finfo);
	
	/* Initialize statistics. */
	map_files++;
	map_file_areas = 0;
	map_file_area_bytes = 0;
	
	/* Write the file info. */
	if (arg_verbose_map_flag) {
		ocnls(2);
		os("File "); os(finfo -&gt; file_name); onl();
		os("OFFSET"); oblank(); os("LENGTH"); opads("PARENT", 37);
	}

	/* For each unit node. */
	for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {

		ap = up -&gt; unit_code_area;
		if (ap &amp;&amp; area_is_marked(ap)) {
			map_area(ap, DONT_DUMP_LABELS);
		}
		
		ap = up -&gt; unit_data_area;
		if (ap &amp;&amp; area_is_marked(ap)) {
			map_area(ap, DONT_DUMP_LABELS);
		}
	}
	
	ocnls(arg_verbose_map_flag ? 2 : 1);
	oblanks(4);
	os("Totals for ");
	if (arg_verbose_map_flag) {
		os(cvt_short_fn(finfo -&gt; file_name));
		os(", areas: "); 		oulong(map_file_areas);
		os(", area bytes: ");	oulong(map_file_area_bytes);
		onl();
	}
	else {
		opads(cvt_short_fn(finfo -&gt; file_name), max_short_file_name);
		os(", areas: "); 		opadulong(map_file_areas, 4);
		os(", area bytes: ");	opadulong(map_file_area_bytes, 7);
		onl();
	}
	
	/* Update grand totals. */
	map_global_areas += map_file_areas;
	map_global_area_bytes += map_file_area_bytes;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1239">@ Output a label name to the map file. Enclose the name in angle brackets if the dict is unmarked. Enclose the name in curly brackets if the dict is undefined.
@c

static ulong
map_out_dict(dict_node * dp, char * name)
{
	FTAG("out_dict");
	ulong result = strlen(name);
	STATB(ftag);
	
	if (dp == NULL) {
		os(name);
	}
	else {
		if (!dict_is_defined(dp)) {
			os("{"); result+=2;
		}
		if (!dict_is_global(dp)) {
			os("&lt;"); result+=2;
		}
		os(name);
		if (!dict_is_global(dp)) {
			os("&gt;");
		}
		if (!dict_is_defined(dp)) {
			os("}");
		}
	}

	STATX(ftag);
	return result;
}
</t>
<t tx="ekr.20080529093004.1240">@ Output the tree of marked units to the map file.
@c

static void
map_subtree(unit_node * parent_up, ulong tree_level)
{
	FTAG("map_subtree");
	TRACEPB(ftag, es(parent_up -&gt; unit_name); enl());
	ASSERT(parent_up);
		
	/* Print the code and data areas at the proper indentation level. */
	{
		register int i = 0;
		area_node * ap = NULL;
		
		ap = parent_up -&gt; unit_code_area;
		if (ap) {
				
			for (i = 0; i &lt; tree_level; i++) {
				os(".");
			}
			map_out_dict(ap -&gt; area_dict, ap -&gt; area_name);
			ocnl();
		}
		ap = parent_up -&gt; unit_data_area;
		if (ap) {
			for (i = 0; i &lt; tree_level; i++) {
				os(".");
			}
			map_out_dict(ap -&gt; area_dict, ap -&gt; area_name);
			onl();
		}
	}
	
	/*
		Recursively print all areas with this unit as their parent.
		Make *sure* we don't get into recursion trouble.
	*/
	if (tree_level &lt; 80) {
		register file_node * finfo = NULL;
		register unit_node * up = NULL;
		for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
			for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
				if (
					(
						up -&gt; unit_code_area &amp;&amp;
						area_is_marked(up -&gt; unit_code_area) &amp;&amp;
						up -&gt; unit_code_area -&gt; area_parent == parent_up
					)
						||
					(
						up -&gt; unit_data_area &amp;&amp;
						area_is_marked(up -&gt; unit_data_area) &amp;&amp;
						up -&gt; unit_data_area -&gt; area_parent == parent_up)
				) {
					if (up != parent_up) {
						map_subtree(up, tree_level+1);
					}
				}
			}
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1241">void
map_tree(void)
{
	FTAG("map_tree");
	STATB(ftag);
	
	if (arg_verbose_map_flag &amp;&amp; arg_map_tree_flag &amp;&amp; main_unit) {
	
		register file_node * finfo = NULL;
		register unit_node * up = NULL;
		
		if (arg_verbose_flag) {
			ecnl(); es("Writing tree of marked areas...\n");
		}

		/* Start off with all areas with no parent. */
		ocnl(); os("Tree of marked areas...\n");
		
		for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
			for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
				if (
					(
						up -&gt; unit_code_area &amp;&amp;
						area_is_marked(up -&gt; unit_code_area) &amp;&amp;
						up -&gt; unit_code_area -&gt; area_parent == NULL
					)
						||
					(
						up -&gt; unit_data_area &amp;&amp;
						area_is_marked(up -&gt; unit_data_area) &amp;&amp;
						up -&gt; unit_data_area -&gt; area_parent == NULL
					)
				) {
					map_subtree(up, 0);
				}
			}
		}
		ocnls(2);
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1242">/*
	Link: the marking phase.
	
	Mark all areas referenced directly and indirectly from the 
	unit containing the main function.
	
	source:  LKmark.c.
	started: November 19, 1993.
	version:
		June 28, 1994.
			Eliminated marked_code_area_list and marked_data_area_list so
			that areas area always groupted by object file.
		June 19, 1994.
			Added mark_data_total, mark_code_total.
		May 11, 1994.
			Revised to handle the new format of the object file.
			Added scan_unit routine.
			Allocate code and data areas on separate lists.
		December 14, 1993.
*/

&lt;&lt; LKmark #includes &gt;&gt;
&lt;&lt; LKmark declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1243">#include "LK.h"

#include "LKarg.h"
#include "LKdump.h"
#include "LKfscan.h"
#include "LKmain.h"
#include "LKmark.h"
#include "LKmem.h"
#include "LKnodes.h"

#include &lt;LIBlist.h&gt;
</t>
<t tx="ekr.20080529093004.1244">/*
	Globals owned by this module.
*/
ulong mark_code_total = 0;	/* Sum of sizes of all marked code areas. */
ulong mark_data_total = 0;	/* Sum of sizes of all marked code areas. */


/*
	Prototypes of functions local to this module.
*/
static void mark_reorder(void);
static void scan_area	(unit_node * up, area_node *ap);
static void scan_unit	(unit_node * up);

/*	
	Mark all areas reachable via references from the main unit.
	Also set the area_parent field of each marked area to
	the unit causing each it to be marked.
*/
static unit_node * unit_scan_list = NULL; </t>
<t tx="ekr.20080529093004.1245">@ Head of lists of units to be scanned.
@c

void
mark(void)
{
	FTAG("mark");
	FTAGV("mark_v");
	STATB(ftag);

	/* Do nothing if there is no main function. */
	if (main_area == NULL) {
		error(es("No main function"));
		goto done;
	}

	if (main_unit == NULL) {
		fatal(es("no main unit"));
	}
	
	if (arg_verbose_flag) {
		ecnl(); es("Marking...\n");
	}
	
	/* Reorder the file and unit lists so the main file and unit are scanned first. */
	mark_reorder();
	
	/* Start off the scanning. This may place units on the scan list. */
	scan_unit(main_unit);

	/*
		Scan each unit on the scan list.
		This loop terminates since a unit can only be added once to the scan list
		and each execution of the loop removes one unit from the scan list.
	*/
	{
		register unit_node * up = NULL;

		TRACEPN(ftag, es("processing the code area scanning list\n"));
	
		while(unit_scan_list) {
	
			/* Remove the first unit from the scan list. */
			up = unit_scan_list;
			unit_scan_list = up -&gt; unit_scan_next;
			up -&gt; unit_scan_next = NULL;
			
			scan_unit(up);
		}
	}
	
	/* We must have marked main()! */
	ASSERT(area_is_marked(main_area));

	#if 0 /* these lists are no longer used: we always organize areas by file! */
		/* Put the marked code and data areas in the marked code and data lists. */
		{
			register file_node * finfo = NULL;
			register unit_node * up = NULL;
			register area_node * ap = NULL;
	
			for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
				for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
					ap = up -&gt; unit_data_area;
					if (ap &amp;&amp; area_is_marked(ap)) {
						ap -&gt; area_load_next = marked_data_area_list;
						marked_data_area_list = ap;
					}
					ap = up -&gt; unit_code_area;
					if (ap &amp;&amp; area_is_marked(ap)) {
						ap -&gt; area_load_next = marked_code_area_list;
						marked_code_area_list = ap;
					}
				}
			}
		}
		
		/* Reverse the lists so they correspond to the order in the object files. */
		lst_general_reverse_macro(marked_code_area_list, area_load_next, area_node);
		lst_general_reverse_macro(marked_data_area_list, area_load_next, area_node);
	#endif
	
	TRACEPN(ftag,
		register file_node * finfo = NULL;
		register unit_node * up = NULL;
		register area_node * ap = NULL;
		
		ecnl();
		es("The marked data areas are...\n");
		epads("AREA", max_area_name); eblank(); es("PARENT"); ecnl();

		for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
			for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
				ap = up -&gt; unit_data_area;
				if (ap &amp;&amp; area_is_marked(ap)) {
					epads(ap -&gt; area_name, max_area_name); eblank();
					es(ap -&gt; area_parent ? ap -&gt; area_parent -&gt; unit_name : "&lt;none&gt;");
					ecnl();
				}
			}
		}
		
		ecnl();
		es("The marked code areas are...\n");
		epads("AREA", max_area_name); eblank(); es("PARENT"); ecnl();

		for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
			for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
				ap = up -&gt; unit_code_area;
				if (ap &amp;&amp; area_is_marked(ap)) {
					epads(ap -&gt; area_name, max_area_name); eblank();
					es(ap -&gt; area_parent ? ap -&gt; area_parent -&gt; unit_name : "&lt;none&gt;");
					ecnl();
				}
			}
		}
		ecnl();
	);

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1246">@ Reorder the file and unit lists so that the main file and unit are scanned first.
@c

static void
mark_reorder(void)
{
	FTAG("mark_reorder");
	STATB(ftag);

	/* Reorder the file list so that the main file is scanned first. */
	if (file_info_list != main_file) {

		file_node * fp_prev = file_info_list;
		file_node * fp = fp_prev -&gt; file_next;
		ASSERT(fp &amp;&amp; fp_prev);
		
		/* Set fp to the main file and fp_prev to the file before it. */
		while (fp != main_file) {
			ASSERT(fp);
			fp_prev = fp;
			fp = fp -&gt; file_next;
		}
		
		/* Remove fp from the list. */
		fp_prev -&gt; file_next = fp -&gt; file_next;
		
		/* Insert fp at the head of the list. */
		fp -&gt; file_next = file_info_list;
		file_info_list = fp;
	}
	
	/* 	Reorder the unit list of the main file so the main unit is scanned first. */
	if (main_unit != main_file -&gt; file_unit_list) {			
			
		unit_node * up_prev = main_file -&gt; file_unit_list;
		unit_node * up = up_prev -&gt; unit_file_next;
		ASSERT(up_prev &amp;&amp; up);
		
		/* Set fp to the main file and fp_prev to the file before it. */
		while (up != main_unit) {
			ASSERT(up);
			up_prev = up;
			up = up -&gt; unit_file_next;
		}
		
		/* Remove up from the list. */
		up_prev -&gt; unit_file_next = up -&gt; unit_file_next;
		
		/* Insert fp at the head of the list. */
		up -&gt; unit_file_next = main_file -&gt; file_unit_list;
		main_file -&gt; file_unit_list = up;
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1247">@ Mark the given area and put it on one of the marked area lists. A kludge: don't add the main code area to the marked area list. The main code area will be added later.  Scan the reference nodes for the given area that is part of the given unit.
@c

static void
scan_area(unit_node * up, area_node *ap)
{
	FTAG("scan_area");
	FTAGV("scan_area_v");
	register ref_node * rp = NULL;
	area_node * ref_ap = NULL;
	unit_node * ref_up = NULL;
	STATB(ftag);
	ASSERT(up &amp;&amp; ap);
	
	/* Do nothing if we have already scanned the area. */
	if (area_is_marked(ap)) {
		goto done;
	}
	
	/* Mark the area. */
	TRACEPN(ftag, es("Marking "); es(ap -&gt; area_name); ecnl());
	area_set_marked(ap);
	ASSERT(up == ap -&gt; area_unit &amp;&amp; ap -&gt; area_unit &amp;&amp; ap -&gt; area_unit -&gt; unit_file);
	(ap -&gt; area_unit -&gt; unit_file -&gt; file_marked_areas)++;
	
	/* Update the total code and data sizes. */
	if (ap == up -&gt; unit_code_area) {
		mark_code_total += ap -&gt; area_length;
	}
	else {
		mark_data_total += ap -&gt; area_length;
	}

	/*
		Scan ap's reference list.
		Add all unscanned units refered to by this list to the scan list.
		Set all NULL area_parent fields in areas refered to by the reference list.
	*/
	for (rp = ap -&gt; area_refs; rp; rp = rp -&gt; ref_next) {
		
		ASSERT(rp -&gt; ref_dict);
		
		/* Increment the refenence count of the referenced label. */
		rp -&gt; ref_dict -&gt; dict_ref_count++;
		
		/* An undefined label can cause this. */
		if (rp -&gt; ref_dict -&gt; dict_area == NULL) {
			TRACEPN(ftag,
				es("Not marked: ");
				es(rp -&gt; ref_dict -&gt; dict_name); ecnl());
			continue;
		}
		
		ASSERT(rp -&gt; ref_dict -&gt; dict_area -&gt; area_unit);
	
		TRACEPN(ftagv,
			es("ref node at: "); eptr(rp);
			es(", referenced area: "); es(rp -&gt; ref_dict -&gt; dict_area -&gt; area_name); ecnl());

		ref_ap = rp -&gt; ref_dict -&gt; dict_area;
		ref_up = ref_ap -&gt; area_unit;
		
		/* Set the parent field of the referenced area. */
		if (ref_ap -&gt; area_parent == NULL) {
			ref_ap -&gt; area_parent = up;
		}
		
		/* Add the referenced unit to the scan list. */
		if (!unit_is_on_scan_list(ref_up)) {
		
			unit_set_on_scan_list(ref_up);
			
			TRACEPN(ftag, es("Add to scan list: "); es(ref_up -&gt; unit_name); ecnl());
			ref_up -&gt; unit_scan_next = unit_scan_list;
			unit_scan_list = ref_up;
		}
	}

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1248">@ Mark both areas of the given unit. Add all unscanned units referenced by the given unit's areas to the scan list.
@c

static void
scan_unit (unit_node * up)
{
	FTAG("scan_unit");
	STATB(ftag);
	
	/* Make sure we never scan this unit again. */
	unit_set_on_scan_list(up);

	/* Scan both areas of the parent unit. */
	if (up -&gt; unit_code_area) {
		scan_area(up, up -&gt; unit_code_area);
	}
	
	if (up -&gt; unit_data_area) {
		scan_area(up, up -&gt; unit_data_area);
	}
	
	STATX(ftag);
}</t>
<t tx="ekr.20080529093004.1249">/*
	Link: output routines.
	
	source: LKout.c
	started: November 21, 1993.
	version:
		June 19, 1994.
			Added support for output to S-records.
		May 21, 1994.
*/

&lt;&lt; LKout #includes &gt;&gt;
&lt;&lt; LKout declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1250">#include "LK.h"

#include "LKarg.h"
#include "LKload.h"
#include "LKmain.h"
#include "LKload.h"
#include "LKnodes.h"
#include "LKout.h"

#include &lt;LIBos.h&gt;
#include &lt;LIBsrec.h&gt;

#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.1251">/*
	Prototypes of internal routines.
*/
static void out_area (area_node * ap, char * load_address);
</t>
<t tx="ekr.20080529093004.1252">@ Output one area.
@c

static void
out_area(register area_node * ap, char * load_address)
{
	FTAG("out_area");
	TRACEPB(ftag,
		es("address: ");	eptr(load_address);
		es(", length: ");	epadulong(ap -&gt; area_length, 4);
		ecs(); es(ap -&gt; area_name);
		ecnl());

	/* Output the area */
	#if 0 // no longer used
		if (arg_srec_flag) {
			srec_data ((ulong) load_address, ap -&gt; area_pointer, ap -&gt; area_length);
		}
		else {
			out_bytes(ap -&gt; area_pointer, ap -&gt; area_length, ap -&gt; area_name);
		}
	#else
		out_bytes(ap -&gt; area_pointer, ap -&gt; area_length, ap -&gt; area_name);
	#endif

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1253">@ Output the entire load file.
@c

void
out_file (void)
{
	FTAG("link_out_file");
		register file_node * finfo = NULL;
		register unit_node * up = NULL;
		register area_node * ap = NULL;
		char * load_address = NULL;
	STATB(ftag);
	
	/* Output the load file header. */
	
		// to do
	
	/* The *Tuple* OS must fill in the jump table. */
	{
		char dummy_jump_table  [JUMP_TABLE_ENTRIES * sizeof(jump)];
		ulong jump_table_size = JUMP_TABLE_ENTRIES * sizeof(jump);
		
		memset(dummy_jump_table, 0, jump_table_size);
		out_bytes(dummy_jump_table, jump_table_size, "jump table");
	}

	/* Output the data areas. */
	{
		load_address = arg_data_address;

		for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
		
			for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
	
				ap = up -&gt; unit_data_area;
				if (ap) {
					ASSERT(load_address == ap -&gt; area_base);
					out_bytes(ap -&gt; area_pointer, ap -&gt; area_length, ap -&gt; area_name);
					load_address += ap -&gt; area_length;
				}
			}
		}
	}
	
	/* Output the code areas. */
	{
		load_address = arg_code_address;

		for (finfo = file_info_list; finfo; finfo = finfo -&gt; file_next) {
		
			for (up = finfo -&gt; file_unit_list; up; up = up -&gt; unit_file_next) {
	
				ap = up -&gt; unit_code_area;
				if (ap) {
					ASSERT(load_address == ap -&gt; area_base);
					out_bytes(ap -&gt; area_pointer, ap -&gt; area_length, ap -&gt; area_name);
					load_address += ap -&gt; area_length;
				}
			}
		}
	}
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1254">/*
	Link: Linker symbol table routines.
	
	fst_xxx routines deal with file names.
	st_xxx  routines deal with dict names.
	
	source:  LKst.c
	started: November 10, 1993.
	version:
		July 2, 1994.
			Added st_dump.
		May 9, 1994.
			st_xxx routines now deal with dict nodes.
		January 8, 1994.
*/

&lt;&lt; LKst #includes &gt;&gt;
&lt;&lt; LKst declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1255">#include "LK.h"

#include "LKdump.h"
#include "LKmem.h"
#include "LKnodes.h"
#include "LKst.h"

#include &lt;LIBobj.h&gt;

#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.1256">/*
	Define the size of the hash tables.
	The size must be prime for fst_hash() and st_hash() to compute good hash values.
*/
#define FST_HASH_SIZE  101
#define ST_HASH_SIZE  1009

/*
	Define the hash tables.
	These tables will be dynamically allocated by st_init().
*/
static file_node **	fst_hash_tab = NULL;
static dict_node **	st_hash_tab = NULL;
</t>
<t tx="ekr.20080529093004.1257">@ Enter an file name with the indicated hash code into the symbol table.
@c

void
fst_enter (register file_node * finfo, long hash)
{
	FTAG("fst_enter");
	TRACEPB(ftag, es(finfo -&gt; file_name));
	ASSERT(
		finfo &amp;&amp; finfo -&gt; file_name &amp;&amp;
		hash == fst_hash(finfo -&gt; file_name));

	finfo -&gt; file_st_next = fst_hash_tab[hash];
	fst_hash_tab[hash] = finfo;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1258">@ Return the hash code for a file name.
@c

long
fst_hash(char * s)
{
	FTAG("fst_hash");
	register long hash = 0;
	register char c;
	STATB(ftag);

	while (c = *s++) {
		hash *= 3; hash += c; hash %= FST_HASH_SIZE;
	}

	ASSERT(hash &gt;= 0 &amp;&amp; hash &lt; FST_HASH_SIZE);
	STATX(ftag);
	return hash;
}
</t>
<t tx="ekr.20080529093004.1259">@ Return the file info node for the given file name.
@c

file_node *
fst_lookup(char * name, long hash)
{
	FTAG("fst_lookup");
	register file_node * finfo;
	STATB(ftag);
	ASSERT(name &amp;&amp; fst_hash(name) == hash);

	for (finfo = fst_hash_tab[hash]; finfo; finfo = finfo -&gt; file_st_next) {
	
		if (str_eq(name, finfo -&gt; file_name)) {
		
			TRACEPX(ftag, es(name); es(" found: "); ecnl());
			return finfo;
		}
	}

	TRACEPX(ftag, es(name); es(" not found\n"));
	return NULL;
}
</t>
<t tx="ekr.20080529093004.1260">@ Dump all entries from symbol table.
@c

void
st_dump (void)
{
	FTAG("st_dump");
	dict_node * dp = NULL;
	int i;
	STATB(ftag);
	
	ecnl(); es("Dump of symbol table...\n");
	for (i = 0; i &lt; ST_HASH_SIZE; i++) {
		for (dp = st_hash_tab[i]; dp; dp = dp -&gt; dict_st_next) {
			dump_dict(dp);
			ecnl();
		}
	}
	
	STATX(ftag);
}</t>
<t tx="ekr.20080529093004.1261">@ Enter an dict node with the indicated hash code into the symbol table.
@c

void
st_enter (register dict_node * dp, long hash)
{
	FTAG("st_enter");
	TRACEPB(ftag, es(dp -&gt; dict_name));
	ASSERT(dp &amp;&amp; dp -&gt; dict_name &amp;&amp; hash == st_hash(dp -&gt; dict_name));

	dp -&gt; dict_st_next = st_hash_tab[hash];
	st_hash_tab[hash] = dp;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1262">@ Return the hash code for a dict name.
@c

long
st_hash(char * s)
{
	FTAG("sl_hash");
	register long hash = 0;
	register char c;
	STATB(ftag);

	while (c = *s++) {
		hash *= 3; hash += c; hash %= ST_HASH_SIZE;
	}

	ASSERT(hash &gt;= 0 &amp;&amp; hash &lt; ST_HASH_SIZE);
	STATX(ftag);
	return hash;
}
</t>
<t tx="ekr.20080529093004.1263">@ Initialize the hash tables.
@c

void
st_init (void)
{
	FTAG("st_init");
	STATB(ftag);

	if (st_hash_tab == NULL) {
		obj_new_macro(st_hash_tab, (sizeof(dict_node *) * ST_HASH_SIZE), "st hash tab");
	}

	if (fst_hash_tab == NULL) {
		obj_new_macro(fst_hash_tab, (sizeof(file_node *) * FST_HASH_SIZE), "fst hash tab");
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1264">@ Return the dict node for the given dict name.
@c

dict_node *
st_lookup(char * name, long hash)
{
	FTAG("st_lookup");
	register dict_node * dp;
	STATB(ftag);
	ASSERT(name &amp;&amp; st_hash(name) == hash);

	for (dp = st_hash_tab[hash]; dp; dp = dp -&gt; dict_st_next) {
	
		if (str_eq(name, dp -&gt; dict_name)) {
		
			TRACEPX(ftag, es(name); es(" found: "); ecnl());
			return dp;
		}
	}

	TRACEPX(ftag, es(name); es(" not found\n"));
	return NULL;
}
</t>
<t tx="ekr.20080529093004.1265">@ignore
@language c</t>
<t tx="ekr.20080529093004.1266"></t>
<t tx="ekr.20080529093004.1267">/*
	Header file for resident debugger for the Tuple board.
	
	source: LIBtrm.h
	started: June 20, 1994.
	version: June 20, 1994.
*/

#ifndef LIBtrm_h_
#define LIBtrm_h_

#pragma once

	/* Function prototypes. */
	
int trm_main(void);

#endif /* LIBtrm_h_ */
</t>
<t tx="ekr.20080529093004.1268">/*
	Tuple Loader: Master header file

	source:  LD.h
	started: March 10, 1994.
	version: March 10, 1994.
*/

#ifndef as_h_
#define as_h_

#pragma once

/*
	Include files that should be included in each file.
	LDtypes.h must be included first.
*/

#include &lt;LIBlib.h&gt;		/* Must be first. */
#include "LDtypes.h"	/* Must be second. */
#include "LDerr.h"

/*
	Define abbreviations for the assembler.
	Standard abbreviations are defined in &lt;LIBlib.h&gt;
*/

#define bit(field,the_bits)			((field) &amp; (the_bits))
#define clear_bit(field,the_bits)	{(field) &amp;= ~(the_bits);}
#define set_bit(field,the_bits) 	{(field) |= (the_bits);}

#endif /* as_h_ */
</t>
<t tx="ekr.20080529093004.1269">/*
	Tuple Loader: header file for user arguments.

	source:  LDarg.h
	started: November 8, 1993.
	version: February 15, 1995.
*/

#ifndef LDarg_h_
#define LDarg_h_

#pragma once

/*
	Define globals owned by this class.
*/

extern char * arg_in_path;

/*
	Function prototypes.
*/

	/* Synonyms for the return values from arg_do_argv. */
	enum { MORE_FILES_REMAIN = TRUE, NO_MORE_FILES_REMAIN = FALSE };

bool	arg_do_argv 		(int argc, char **argv, char * on_str, char * off_str);

#endif /* LDarg_h_ */
</t>
<t tx="ekr.20080529093004.1270">/*
	Tuple loader: Header for disassembler.

	source:  LDdisasm.h
	started: March 10, 1994.
	version: March 10, 1994.
*/

#ifndef LDdisasm_h_
#define LDdisasm_h_

#pragma once

void disassemble(char * ip);

#endif /* LDdisasm_h_ */
</t>
<t tx="ekr.20080529093004.1271">/*
	Tuple Loader: header file for LDend.c.

	source:  LDend.h
	started: December 13, 1993.
	version: November 4, 1994.
*/

#ifndef LDend_h_
#define LDend_h_

#pragma once

void end_close_all	(void);

#endif /* LDend_h_ */
</t>
<t tx="ekr.20080529093004.1272">/*
	Tuple Loader: header file for application-specific routines.
	
	source:  LDes.h.
	started: March 10, 1994.
	version: March 10, 1994.
*/

#ifndef LDes_h_
#define LDes_h_

#pragma once

/*
	The function prototype for es also appears in LIBes.h.
*/

void es (char * s);

#endif /* LDes_h_ */
</t>
<t tx="ekr.20080529093004.1273">/*
	Tuple Loader: header file for initialization module.

	source:  LDinit.h
	started: November 8, 1993.
	version: November 4, 1994.
*/

#ifndef LDinit_h_
#define LDinit_h_

#pragma once

/*
	Include headers for all modules that must be initialized.
*/

void	init_all	(int argc, char ** argv);
void	init_again	(void);

#endif /* LDinit_h_ */
</t>
<t tx="ekr.20080529093004.1274">/*
	Tuple Loader: header file for loader class

	source:  LDload.h
	started: February 15, 1995.
	version: February 15, 1995.
*/

#ifndef LDload_h_
#define LDload_h_

#pragma once

/*
	Function prototypes.
*/

void load (void);

#endif /* LDload_h_ */
</t>
<t tx="ekr.20080529093004.1275">/*
	Tuple Loader: Header for LDmain.c.

	source:  LDmain.h
	started: November 28, 1993.
	version: November 4, 1994.
*/

#ifndef LDmain_h_
#define LDmain_h_

#pragma once

void main_quit	(void);

#endif /* LDmain_h_ */
</t>
<t tx="ekr.20080529093004.1276">/*
	Tuple Loader: Application-specific memory allocation macros and routines.
		See LIBmem.h for general memory allocation macros and routines.

	source:  LDmem.h
	started: March 10, 1994.
	version: March 10, 1994.
*/

#ifndef LDmem_h_
#define LDmem_h_

#pragma once

#include &lt;LIBmem.h&gt;

#include &lt;string.h&gt; 

/*
	General allocation macros.
*/

#define mem_new_perm_macro(p, size)		mem_new_macro(p, size, mem_perm_life)

#define mem_new_macro(p, size, life) \
{\
	ASSERT(life);\
	MEM_STATS(life -&gt; mem_cur_nodes ++; life -&gt; mem_cur_bytes += (size));\
	if (size &gt; life -&gt; mem_avail) {\
		p = mem_new_block(size, life);\
	}\
	else {\
		p = life -&gt; mem_ptr;\
		life -&gt; mem_ptr    = (((char *) (life -&gt; mem_ptr)) + size);\
		life -&gt; mem_avail -= size;\
	}\
	/* TRACEP("new", es(life -&gt; name); eptr(p); enl()); */\
}

	/* strings. */

#define new_perm_string_macro(p,s1)\
{\
	ASSERT(s1);\
	MEM_UPDATE_STATS(mem_perm_string_stats, strlen(s1)+1);\
	mem_new_perm_macro(p, strlen(s1)+1);\
	strcpy(p, s1);\
}

#define new_perm_cat2_macro(p,s1,s2)\
{\
	ASSERT(s1 &amp;&amp; s2);\
	MEM_UPDATE_STATS(mem_perm_string_stats, strlen(s1)+strlen(s2)+1);\
	mem_new_perm_macro(p, strlen(s1)+strlen(s2)+1);\
	strcpy(p, s1);\
	strcat(p, s2);\
}

#define new_perm_cat3_macro(p,s1,s2,s3)\
{\
	ASSERT(s1 &amp;&amp; s2 &amp;&amp; s3);\
	MEM_UPDATE_STATS(mem_perm_string_stats,strlen(s1)+strlen(s2)+strlen(s3)+1);\
	mem_new_perm_macro(p, strlen(s1)+strlen(s2)+strlen(s3)+1);\
	strcpy(p, s1);\
	strcat(p, s2);\
	strcat(p, s3);\
}

#define new_perm_cat4_macro(p,s1,s2,s3,s4)\
{\
	ASSERT(s1 &amp;&amp; s2 &amp;&amp; s3 &amp;&amp; s4);\
	MEM_UPDATE_STATS(mem_perm_string_stats,strlen(s1)+strlen(s2)+strlen(s3)+strlen(s4)+1);\
	mem_new_perm_macro(p, strlen(s1)+strlen(s2)+strlen(s3)+strlen(s4)+1);\
	strcpy(p, s1);\
	strcat(p, s2);\
	strcat(p, s3);\
	strcat(p, s4);\
}

/*
	Define global variables.

	The actual lifetimes used in the program.
	Tokens must have a separate lifetime so token blocks
	will contain only tokens.
*/

extern mem_life * mem_life_list;			/* List of all lifetimes. */

extern mem_life * mem_perm_life;
extern mem_stat * mem_perm_string_stats;

#endif /* LDmem_h_ */
</t>
<t tx="ekr.20080529093004.1277">/*
	Tuple Loader: global type definitions and type-related macros.
		Library types are defined in LIBtypes.h, not here.

	source: LDtypes.h
	started: March 10, 1994.
	version: March 10, 1994.
			
	This file defines "friend" types, that is,
	types that are refered to in other headers.
	All other types need not, and should not be defined here.
*/

#ifndef LDtypes_h_
#define LDtypes_h_

#pragma once

/*
	Define types unique to the debugger.
*/

	/* General: the following are used in several header files. */

#define COMMON_NODE_HEAD	/* Common part of all nodes. */\
	int	n_type				/* Node type. */

#define LINKED_NODE_HEAD	/* Header for all linked nodes. */\
	COMMON_NODE_HEAD;\
	void *	next

typedef struct linked_struct linked_node;	/* Common part of all linked nodes. */

struct linked_struct {
	LINKED_NODE_HEAD;
};

	/* LDexp.h */

#define LD_EXP_TYPEDEFS
typedef struct enode_struct enode;

#endif /* LDtypes_h_ */
</t>
<t tx="ekr.20080529093004.1278">/*
	Tuple Loader: Header file for LDerr.c.

	source:  LDerr.h
	started: March 10, 1994.
	version: March 10, 1994.
*/

#ifndef LDerr_h_
#define LDerr_h_

#pragma once

	/* 
		Application-specific error reporting macros.
		error and fatal are defined in LIBdebug.h
	*/

#define help(stat)		{help_begin(); stat; err_context(); }
#define user_fatal(stat){user_fatal_begin(); stat; user_fatal_end();}
#define warning(stat)	{warn_begin(); stat; err_context(); }


#ifdef PRODUCTION
	#define DEBUG(a)
#else
	#define DEBUG(a) a
#endif

/*
	Function prototypes.
	Some of these are also defined in LIBdebug.h
*/

	/* Routines called by macros in this file. */

bool	err_begin			(void);
void	fatal_begin			(void);
void	fatal_end			(void);
bool	help_begin			(void);
void	user_fatal_begin	(void);
void	user_fatal_end		(void);
bool	warn_begin			(void);

void	es_assert_failed	(char * condition, int line, char * file);
void	err_context			(void);
void	es_internal_err		(char * condition, int line, char * file);

	/* Other routines in LDerr.c */

void	err_init		(void);
void	err_init_again	(void);

/*
	Global variables defined in LDerr.c.
*/

extern long		err_count;			/* Error counts... */
extern long		err_help;
extern long		err_warning;
extern bool		err_err_flag;		/* Enable message flags... */
extern bool		err_fatal_flag;
extern bool		err_help_flag;
extern bool		err_warn_flag;

extern bool		err_verbose;		/* Verbose flag. */

#endif /* LDerr_h_ */
</t>
<t tx="ekr.20080529093004.1279"></t>
<t tx="ekr.20080529093004.1280">/*
	Resident debugger for the Tuple board.
	Commands are based on TRM.
	
	source: LIBtrm.c
	started: June 20, 1994.
	version: November 4, 1994.
*/

/*
	TESTING
	? defines a dummy machine state.
	? defines dummy routines,
	? disables patching of memory,
	? gets commands from an array of strings.
*/

#ifdef THINK_C
	#define TESTING
#endif

#ifdef TESTING
&lt;&lt; Debugger #includes &gt;&gt;
&lt;&lt; Debugger declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1281">#include &lt;LIBlib.h&gt;
#include &lt;LIBio.h&gt;
</t>
<t tx="ekr.20080529093004.1282">#else
#include "hdr.h"		/* for ulong, etc	*/
#include "menu.h"		/* for CONTINUE	= 0 */
#include "term.h"		/* for gets() prototype	*/
#endif

#include "Debugger.h"

#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

/*
eptr in devlib uses %p.  Define it properly here.
*/
#define eptr(p) epadhex((long)p,6)

/*
The caller stores registers and status in the following struct.
To change registers or status, simply change this struct.
*/
typedef struct machine_state_struct machine_state;

struct machine_state_struct {
ulong regs [18];	/* The general registers, ssp, upc */		
short status;
};

char * reg_name [19] = {
"d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7",
"a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7",
"ssp", "pc", "ssr"
};

/*
Declare global variables defined in LIBtrm.a
*/

/* Machine state. */

extern machine_state trm_regs;
extern ulong trm_pc;
extern ulong trm_ssp;
extern char trm_ssr;
extern char trm_ccr;

/* Used by trm_asm_p. */

extern ulong trm_patch_address;
extern short trm_patch_data;

/* Set by trm_break. */

extern char trm_break_flag;

/* Set by trm_trace. */

extern char trm_trace_flag;
extern char * trm_trace_address;

/*
Define breakpoint stuff.
*/
#define TRAP_OPCODE		0x4e47	/* TRAP 7 instruction. */

#define EXCEPTION_BASE	0x8fff000
#define TRACE_VECTOR	(EXCEPTION_BASE+0x0024)
#define TRAP_VECTOR		(EXCEPTION_BASE+0x009c)	/* $80 + 28: exception vector for TRAP 7. */

typedef struct breakpoint_struct breakpoint;

struct breakpoint_struct {

breakpoint *break_next;		/* The next breakpoint. */
short *		break_address;	/* The address of the breakpoint. */
short		break_save;		/* The saved code replaced by the breakpoint. */
short		break_count;	/* The proceed count. */
};

#define MAX_BREAKS 20

static breakpoint break_array [MAX_BREAKS];	/* Breakpoint nodes. */
static breakpoint * avail = NULL;	/* The list of all free breakpoint nodes. */
static breakpoint * breaks = NULL;	/* The list of all set breakpoint nodes. */
static breakpoint * current_break = NULL;	/* The current breakpoint address. */
static bool current_break_flag = FALSE;		/* TRUE: current_break is valid. */
static ulong repeat_count = 0;				/* Count for S and T instructions. */
static bool single_step_flag = 0;			/* TRUE: S, FALSE: T */
static ulong dot = 0;						/* The default address argument. */

/*
Prototypes of internal routines.
*/
/* Synonyms for return values from trm_command. */
enum { CONTINUE_TYPE, QUIT_TYPE, G_TYPE, P_TYPE, T_TYPE };

static bool get_dec			(char * arg, ulong * arg_val);
static bool get_hex			(char * arg, ulong * arg_val);
static bool get_radix		(char * arg, ulong * arg_val, short radix);
static bool trm_br			(ulong address);
static void trm_br_display	(void);
static short trm_command	(void);
static void trm_help		(void);
static void trm_init		(void);
static void trm_md			(ulong start, ulong end, short dump_size);
static void trm_mm			(ulong start, ulong new_val);
static bool trm_nobr		(ulong address);
static bool trm_nobr_all	(void);
static void trm_p			(short count);
static void trm_rd 			(machine_state * s, short regnum);
static void	trm_rd_all		(void);
static void trm_rm 			(machine_state * s, short regnum, ulong new_value);

/*
Prototypes of routines defined in LIBtrm.a
*/

/* Exception handlers. */

extern void trm_asm_break_handler(void);
extern void trm_asm_trace_handler(void);

/* Called by this file. */

extern void trm_asm_g	(void);
extern void trm_asm_p	(void);
extern void trm_asm_quit(void);
extern void trm_asm_t	(void);

#ifdef  TESTING /* Dummy machine state. */

machine_state trm_regs = {
	0, 1,  2,  3,  4,  5,  6, 7,	/* D regs */
	8, 9, 10, 11, 12, 13, 14, 15,	/* A regs */
	16, /* ssp */
	17, /* pc */
	0xff /* ssr */
};

char * args[] = {
	"",
	"break 0",
	"break 100",
	"br",
	"go 1000",
	"help",
	"dmb 350 400",
	"dm",
	"dmw 500 650",
	"dmw",
	"dml 730 740",
	"dml",

	"mm 1000 55",
	"md 104",
	"md",
	"mdw 204",
	"mdw",
	"mdl 304",
	"mdl",
	"nobrk",
	"proceed", 
	"p 4",

	"dr",
	"dr d0", "dr d1", "dr d2", "dr d3", "dr d4", "dr d5", "dr d6", "dr d7",
	"dr a0", "dr a1", "dr a2", "dr a3", "dr a4", "dr a5", "dr a6", "dr a7",
	"dr ssp", "dr pc", "dr ssr",
	
	"rm d0 00", "rm d1 10", "rm d2 20", "rm d3 30",
	"rm d4 40", "rm d5 50", "rm d6 60", "rm d7 70",
	"rm a0 05", "rm a1 15", "rm a2 25", "rm a3 35",
	"rm a4 45", "rm a5 55", "rm a6 65", "rm a7 75",
	"rm ssp 1000", "rm pc 2000", "rm ssr ffff",
	
	"s",
	"s 4",
	"t",
	"t 4",
	"quit",
	NULL
};

static arg_count = 0;

ulong trm_patch_address = 0;
short trm_patch_data = 0;
ulong trm_pc = 0;
char trm_trace_flag = 0;
char trm_break_flag = 0;
</t>
<t tx="ekr.20080529093004.1283">void trm_asm_g(void)	{ es("dummy asm_g\n"); }
</t>
<t tx="ekr.20080529093004.1284">void trm_asm_p(void)	{ es("dummy asm_p\n"); }
</t>
<t tx="ekr.20080529093004.1285">void trm_asm_quit(void) { es("dummy asm_quit\n"); }
</t>
<t tx="ekr.20080529093004.1286">void trm_asm_t(void)	{ es("dummy asm_t\n"); }
</t>
<t tx="ekr.20080529093004.1287">static nl_count = 0;	/* Used by ecnl(). */

#else /* n TESTING */

#define str_eq(a,b) (strcmp(a,b)==0)

static nl_count = 0;	/* Used by ecnl(). */

void eblank(void);
void eblanks(register int n);
void echar(int c);
void ecnl(void);
void ecnls(int requested_newlines);
void enl(void);
void epadhex(long hex, int field);
void es(char * s);
void eulong (unsigned long ul);

void
eblank(void) {
	es(" ");
}
</t>
<t tx="ekr.20080529093004.1288">void
eblanks(register int n)
{
	register int i;
	for(i = 0; i &lt; n; i++) {
		eblank();
	}
}
</t>
<t tx="ekr.20080529093004.1289">void
echar(int c)
{
	/* 6/30/93: Speed up this routine by calling es directly. */
	char buffer[2];

	buffer [0] = c;
	buffer [1] = '\0';
	es(buffer);
}
</t>
<t tx="ekr.20080529093004.1290">void
ecnl(void)
{
	if (nl_count == 0) {
		enl();
	}
}
</t>
<t tx="ekr.20080529093004.1291">void
ecnls(int requested_newlines)
{
	int n = requested_newlines - nl_count;
	while (n-- &gt; 0 ) {
		enl();
	}
}
</t>
<t tx="ekr.20080529093004.1292">void
enl(void)
{
	es("\n");
}
</t>
<t tx="ekr.20080529093004.1293">void
epadhex(long hex, int field)
{
	char buf [100];
	int n;

	sprintf(buf, "%lx", hex);
	n = field - strlen(buf);
	while (n-- &gt; 0) {
		es("0");
	}
	es(buf);
}
</t>
<t tx="ekr.20080529093004.1294">void
es(char * s)
{
	while (*s) {
		nl_count = (*s == '\n') ? (nl_count) + 1 : 0;
		printf("%c", *s);
		s++;
	}
}
</t>
<t tx="ekr.20080529093004.1295">void
eulong (unsigned long ul)
{
	printf("%lu", ul);
}
</t>
<t tx="ekr.20080529093004.1296">#endif /* TESTING */

/*
	Convert one decimal argument.
	Return TRUE if it is valid.
*/
static bool
get_dec (char * arg, ulong * arg_val) 
{
	return get_radix(arg, arg_val, 10);
}
</t>
<t tx="ekr.20080529093004.1297">static bool
get_hex (char * arg, ulong * arg_val) 
{
	return get_radix(arg, arg_val, 16);
}
</t>
<t tx="ekr.20080529093004.1298">@ Convert one hex argument. Return TRUE if it is valid.
@c

static bool
get_radix (char * arg, ulong * arg_val, short radix)
{	
	if (arg == NULL || *arg == '\0') {
		return FALSE;
	}

	/* Compute the value and check for non-hex digits. */
	{
		int i = 0;
		ulong val = 0;
		size_t len = strlen(arg);
		for (i = 0; i &lt; len; i++) {

			char c = *arg++;
			val = val * radix;
			
			if (c &gt;= '0' &amp;&amp; c &lt;= '9') {
				if (radix == 8 &amp;&amp; (c == '8' || c == '9')) {
					return FALSE;
				}
				val += (c - '0');
			}
			else if (radix == 16 &amp;&amp; c &gt;= 'a' &amp;&amp; c &lt;= 'f') {
				val += ((c - 'a') + 10);
			}
			else if (radix == 16 &amp;&amp; c &gt;= 'A' &amp;&amp; c &lt;= 'F') {
				val += ((c - 'A') + 10);
			}
			else {
				return FALSE;
			}
		}
		*arg_val = val;
	}
	return TRUE;
}
</t>
<t tx="ekr.20080529093004.1299">@ Parse and execute one command. Return an exit code for the B, P, Q, S, or T commands.
@c

static short
trm_command(void)
{
	char * command = NULL;
	char * command_line = NULL;
	char * arg1 = NULL;
	char * arg2 = NULL;
	ulong arg1_val = 0;
	ulong arg2_val = 0;
	char buffer[150];

	/* Enter the prompt. */
	ecnl(); es("debug: ");
	
	/* Get the command. */
#ifdef TESTING
	command_line = command = args[arg_count++];
	es(command); ecnl();
	if (command_line == NULL) {
		return QUIT_TYPE;
	}
#else
	{
		command_line = command = gets(buffer);
		if (strlen(buffer) &gt; 150-2) {
			ecnl(); es("command line too long\n");
			goto bad_arg;
		}
	}
#endif	
	
	/* Isolate the command and arguments. */
	{
		char * p = command_line;
		
		/* Initialize everything. */
		arg1 = arg2 = NULL;
		arg1_val = arg2_val = 0;
		
		/* Skip to the start of the command. */
		if (*p) {
			while (*p &amp;&amp; isspace(*p)) {
				p++;
			}
		}
		
		/* Isolate the command and convert it to lower case. */
		if (*p) {
			command = p;
			while (*p &amp;&amp; !isspace(*p)) {
				*p = tolower(*p);
				p++;
			}
			if (*p) {
				*p++ = '\0';
			}
		}

		/* Skip to arg1. */
		if (*p) {
			while (*p &amp;&amp; isspace(*p)) {
				p++;
			}
		}
		
		/* Isolate arg1 and convert it to lower case. */
		if (*p) {
			arg1 = p;
			while (*p &amp;&amp; !isspace(*p)) {
				*p = tolower(*p);
				p++;
			}
			if (*p) {
				*p++ = '\0';
			}
		}
		
		/* Skip to arg2. */
		if (*p) {
			while (*p &amp;&amp; isspace(*p)) {
				p++;
			}
		}
		
		/* Isolate arg2 and convert it to lower case. */
		if (*p) {
			arg2 = p;
			while (*p &amp;&amp; !isspace(*p)) {
				*p = tolower(*p);
				p++;
			}
			if (*p) {
				*p++ = '\0';
			}
		}
	}

	/* Get optional arguments and execute the commands. */
	switch (tolower(command[0])) {

	case '\0':	break;

	case 'b':	/* break address */
	
		if (
			str_eq(command, "b") ||
			str_eq(command, "br") ||
			str_eq(command, "break")
		) {
			if (arg1 == NULL) {
				trm_br_display();
			}
			else if (get_hex(arg1, &amp;arg1_val)) {
				trm_br(arg1_val);
			}
			else {
				goto bad_arg1;
			}
			break;
		}
		goto bad_command;
		
	case 'd':

		if (command[1] == 'm') {
			/* turn dm into md. */
			command[0] = 'm';
			command[1] = 'd';
			goto case_m;
		}
		else if (command[1] == 'r') {
			/* turn dr into rd. */
			command[0] = 'r';
			command[1] = 'd';
			goto case_r;
		}
		goto bad_command;

	case 'g':	/* go &lt;address&gt; */
	
		if (str_eq(command, "g") || str_eq(command, "go")) {
		
			if (arg1) {
				if (get_hex(arg1, &amp;arg1_val)) {
					trm_pc = arg1_val;
					dot = arg1_val;
					return G_TYPE;
				}
				else goto bad_arg1;
			}
			else {
				/* G is the same as p 0 if there is a current breakpoint. */
				if (current_break_flag) {
					trm_p(0);
					dot = (ulong) (current_break -&gt; break_address);
					return P_TYPE;
				}
				else {
					ecnl();es("no g address\n");
					goto done;
				}
			}
		}
		goto bad_command;

	case 'h':	/* help */

		if (str_eq(command, "h") || str_eq(command, "help")) {
			trm_help();
			break;
		}
		goto bad_command;
			
	case 'm':	/* md &lt;address&gt; or mm &lt;address&gt; value_list */

case_m:
		if (
			str_eq(command, "md")  || str_eq(command, "mdb") ||
			str_eq(command, "mdw") || str_eq(command, "mdl")
		) {
		
			short size = 0;

			if (command[2] == 'w') {
				size = 2;
			}
			else if (command[2] == 'l') {
				size = 4;
			}
			else {
				size = 1;
			}
		
			/* Arg 1 defaults to the current value of dot. */
			if (arg1) {
				if (!get_hex(arg1, &amp;arg1_val)) {
					goto bad_arg1;
				}
			}
			else {
				arg1_val = dot;
			}
			
			/* Arg 2 defaults so that we will print 0x40 - (arg1_val % 16) bytes. */
			if (arg2) {
				if (!get_hex(arg2, &amp;arg2_val)) {
					goto bad_arg2;
				}
			}
			else {
				arg2_val = arg1_val + 0x40 - (arg1_val % 16) -1;
			}
			
			trm_md(arg1_val, arg2_val, size);
			dot = arg2_val+1;
			break;
		}
		else if (str_eq(command, "mm")) {
		
			/* Arg 1 defaults to the current value of dot. */
			if (arg1) {
				if (!get_hex(arg1, &amp;arg1_val)) {
					goto bad_arg1;
				}
			}
			else {
				arg1_val = dot;
			}
			
			/* Arg2 must be given explicitly and must be a valid char val. */
			if (
				arg2 == NULL ||
				!get_hex(arg2, &amp;arg2_val) ||
				arg2_val &gt; 255
			) {
				goto bad_arg2;
			}
			
			trm_mm(arg1_val, arg2_val);
			break;
		}
		goto bad_command;
		
	case 'n':	/* nobrk &lt;address&gt; */
	
		if (str_eq(command, "n") || str_eq(command, "nobrk")) {
		
			if (arg1) {
				if (get_hex(arg1, &amp;arg1_val)) {
					trm_br(arg1_val);
				}
				else {
					goto bad_arg1;
				}
			}
			else {
				trm_nobr_all();
			}
			break;
		}
		goto bad_command;

	case 'p':	/* proceed &lt;address&gt; &lt;n&gt; */

		if (str_eq(command, "p") || str_eq(command, "proceed")) {
		
			/* Arg1 defaults to current_break -&gt; break_address. */
			if (arg1) {
				if (!get_hex(arg1, &amp;arg1_val)) {
					goto bad_arg1;
				}
			}
			else if (current_break_flag) {
				arg1_val = (ulong) current_break -&gt; break_address;
			}
			else {
				ecnl(); es("no current breakpoint\n");
				goto bad_arg;
			}
			
			if (arg1 &amp;&amp; arg2) {
				if (get_dec(arg2, &amp;arg2_val)) {
					goto bad_arg2;
				}
			}
			else {
				arg2 = NULL;
			}
			
			/*
				arg1_val must be the address of a breakpoint.
				If it is, make it the current breakpoint.
			*/
			{
				breakpoint * bp = breaks;
				while (bp) {
					if (arg1_val == (ulong) bp -&gt; break_address) {
						current_break = bp;
						trm_p(arg2_val);
						dot = arg1_val;
						return P_TYPE;
					}
				}
				ecnl(); eptr(arg1_val);
				es(" is not a breakpoint address\n");
				goto bad_arg;
			}
		}
		goto bad_command;

	case 'q':
		if (str_eq(command, "quit")) {
			return QUIT_TYPE;
		}
		goto bad_command;

	case 'r':	/* rd &lt;reg&gt; or rm &lt;reg&gt; value */

case_r:
		if (str_eq(command, "rd")) {
		
			short regnum = -1;
		
			if (arg1 == NULL) {
				trm_rd_all();
			}
			else if (arg1[0] == 'd') {
				if (get_dec(arg1+1, &amp;arg1_val) &amp;&amp; arg1_val &lt; 8) {
					regnum = arg1_val;
				}
				else {
					ecnl(); es("bad register name\n");
					goto bad_arg;
				}
			}
			else if (arg1[0] == 'a') {
				if (get_dec(arg1+1, &amp;arg1_val) &amp;&amp; arg1_val &lt; 8) {
					regnum = arg1_val+8;
				}
				else {
					ecnl(); es("bad register name\n");
					goto bad_arg;
				}
			}
			else if (str_eq(arg1, "ssp")) {
				regnum = 16;
			}
			else if (str_eq(arg1, "pc")) {
				regnum = 17;
			}
			else if (str_eq(arg1, "ssr")) {
				regnum = 18;
			}
			else {
				ecnl(); es("bad register name\n");
				goto bad_arg;
			}
			
			if (regnum != -1) {
				es(reg_name[regnum]); es(": ");
				trm_rd(&amp;trm_regs, regnum); eblank();
			}
			break;
		}
		else if (str_eq(command, "rm")) {
		
			short regnum = -1;
		
			if (arg1 == NULL) {
				goto bad_arg1;
			}
			if (arg2 == NULL || !get_hex(arg2, &amp;arg2_val)) {
				goto bad_arg2;
			}

			if (arg1[0] == 'd') {
				if (get_dec(arg1+1, &amp;arg1_val) &amp;&amp; arg1_val &lt; 8) {
					regnum = arg1_val;
				}
				else {
					ecnl(); es("bad register name\n");
					goto bad_arg;
				}
			}
			else if (arg1[0] == 'a') {
				if (get_dec(arg1+1, &amp;arg1_val) &amp;&amp; arg1_val &lt; 8) {
					regnum = arg1_val+8;
				}
				else {
					ecnl(); es("bad register name\n");
					goto bad_arg;
				}
			}
			else if (str_eq(arg1, "ssp")) {
				regnum = 16;
			}
			else if (str_eq(arg1, "pc")) {
				regnum = 17;
			}
			else if (str_eq(arg1, "ssr")) {
				regnum = 18;
			}
			else {
				ecnl(); es("bad register name\n");
				goto bad_arg;
			}
			
			if (regnum != -1) {
				trm_rm(&amp;trm_regs, regnum, arg2_val); eblank();
			}		
			break;
		}
		goto bad_command;

	case 's':	/* s &lt;count&gt; */

		if (str_eq(command, "s") || str_eq(command, "step")) {
		
			if (arg1 &amp;&amp; !get_dec(arg1, &amp;repeat_count)) {
				goto bad_arg1;
			}
			else {
				repeat_count = 1;
			}
			dot = trm_pc;
			single_step_flag = TRUE;
			return T_TYPE;
		}
		goto bad_command;

	case 't':	/* t &lt;count&gt; */

		if (str_eq(command, "t") || str_eq(command, "trace")) {
		
			if (arg1 &amp;&amp; !get_dec(arg1, &amp;repeat_count)) {
				goto bad_arg1;
			}
			else {
				repeat_count = 1;
			}
			dot = trm_pc;
			single_step_flag = FALSE;
			return T_TYPE;
		}
		goto bad_command;

	default:
		goto bad_command;
	}
	
	/* Valid command. */
done:
	return CONTINUE_TYPE;
	
bad_command:
	es("bad command.  H for help\n");
	return CONTINUE_TYPE;
	
bad_arg:
	return CONTINUE_TYPE;
	
bad_arg1:
	ecnl(); es("missing or invalid first argument: "); es(arg1); ecnl();
	return CONTINUE_TYPE;
	
bad_arg2:
	ecnl(); es("missing or invalid second argument: "); es(arg2); ecnl();
	return CONTINUE_TYPE;
}
</t>
<t tx="ekr.20080529093004.1300">@ Output the help message.
@c

static void
trm_help (void)
{
	ecnls(2); 
	es("b&lt;reak&gt;   &lt;addr&gt;          Set or display breakpoints\n");
	es("g&lt;o&gt;      &lt;addr&gt;          Go to address\n");
	es("h&lt;elp&gt;                    Display this message\n");
	es("md        &lt;addr&gt; &lt;addr&gt;   Display memory\n");
	es("mdl       &lt;addr&gt; &lt;addr&gt;   Display memory\n");
	es("mdw       &lt;addr&gt; &lt;addr&gt;   Display memory\n");
	es("mm         addr   value   Modify memory bytes\n");
	es("nobrk     &lt;addr&gt;          Delete one or all breakpoints\n");
	es("p&lt;roceed&gt; &lt;addr&gt; &lt;n&gt;      Proceed through breakpoint n times\n");
	es("quit                      Quit\n");
	es("rd        &lt;reg&gt;           Display registers\n");
	es("rm         reg   value    Modify register\n");
	es("s&lt;tep&gt;    &lt;n&gt;             Single step through n instructions\n");
	es("t&lt;race&gt;   &lt;n&gt;             Trace through n instructions\n");
	ecnls(2);
}
</t>
<t tx="ekr.20080529093004.1301">@ Initialize this module.
@c

void
trm_init(void)
{
	/* Put all break nodes on the avail list. */
	{
		register int i = 0;
		for (i = 0; i &lt; MAX_BREAKS - 1; i++) {
			break_array[i] . break_next = &amp;(break_array [i+1]);
		}
		break_array [MAX_BREAKS - 1] . break_next = NULL;
		avail = &amp;(break_array [0]);
		breaks = NULL;
	}
	
	/* Reset status variables. */
	repeat_count = 0;
	trm_break_flag = 0;	
	trm_trace_flag = 0;
	
	/* Set the exception vector. */
	#ifndef TESTING
		/* Set the TRAP7 vector. */
		{
			long * long_ptr = (long *) TRAP_VECTOR;
			if (*long_ptr != (long) (&amp;trm_asm_break_handler)) {
				ecnl(); es("Setting TRAP7 vector\n");
				* long_ptr = (long) (&amp;trm_asm_break_handler);
			}
		}
		
		/* Set the trace vector. */
		{
			long * long_ptr = (long *) TRACE_VECTOR;
			if (*long_ptr != (long) (&amp;trm_asm_trace_handler)) {
				ecnl(); es("Setting trace vector\n");
				* long_ptr = (long) (&amp;trm_asm_trace_handler);
			}
		}
	#endif

}
</t>
<t tx="ekr.20080529093004.1302">@ The main routine of the debugger.  WARNING: This routine must never have any parameters becuase that would break the assembly language routines.
@c

int
trm_main(void)
{
	/*
		Code in Debugger.a sets various flags indicating the context
		in which the debugger was entered.
	*/
	if (trm_break_flag) {
		breakpoint * bp = breaks;

		trm_break_flag = FALSE;
		ecnl(); es("Break at: "); eptr(trm_pc); enl();
		
		current_break_flag = FALSE;
		while (bp) {
			if (trm_pc == (ulong) bp -&gt; break_address) {
				current_break = bp;
				current_break_flag = TRUE;
				break;
			}
		}
		if (!current_break_flag) {
			ecnl(); es("Break address is not valid!");
		}
	}
	else if (trm_trace_flag) {
		trm_trace_flag = FALSE;
		
		if (--repeat_count &lt;= 0 || !single_step_flag) {
			ecnl(); es("pc: "); eptr(trm_pc); enl();
		}
		if (repeat_count &gt; 0) {
			trm_asm_t();
		}
	}
	else {
		ecnl(); es(lib_version); ecnl();
		trm_init();
	}
	
	/*
		The calls to the assembly language routines are really jumps
		because they discard the return address.
		This keeps the stack from growning with each command.
		
		The assembly-language routines reenter this routine by jumping
		to its start address with various flags set.
		
		Don't use a switch here: it's impossible to trace
	*/
	for (;;) {
		short exit_type = trm_command();
		if (exit_type == CONTINUE_TYPE) {
			continue;
		}
		else if (exit_type == QUIT_TYPE) {
		
			/* Clear all breakpoints. */
			trm_nobr_all();
			#ifdef TESTING
				return;
			#else
				/* return CONTINUE. */
				trm_regs . regs[0] = CONTINUE;
				trm_asm_quit();
			#endif
		}
		else if (exit_type == G_TYPE) {
			trm_asm_g();
		}
		else if (exit_type == P_TYPE) {
			trm_asm_p();
		}
		else if (exit_type == T_TYPE) {
			trm_asm_t();
		}
		else {
			ecnl(); es("bad exit type\n");
		}
	}
}
</t>
<t tx="ekr.20080529093004.1303">@ Set a breakpoint.
@c

static bool
trm_br (ulong address)
{
	breakpoint * bp = NULL;
	short * short_ptr = (short *) address;

	/* Return FALSE if no breakpoint node is available. */
	if (avail == NULL) {
		ecnl(); es("No more breakpoints allowed\n");
		return FALSE;
	}

	/* Allocate a breakpoint node. */
	bp = avail;
	avail = bp -&gt; break_next;
	
	/* Put the breakpoint node on the breakpoint list. */
	bp -&gt; break_next = breaks;
	breaks = bp;
	
	/* Fill in the breakpoint node. */
	bp -&gt; break_address = short_ptr;
	bp -&gt; break_save = * short_ptr;
	bp -&gt; break_count = 0;
	
	/* Set the breakpoint. */
#ifndef TESTING
	* short_ptr = TRAP_OPCODE;
#endif
	
	/* Make sure the breakpoint was actually set. */
	if (* short_ptr == TRAP_OPCODE) {
		/* All is well. */
		return TRUE;
	}
	else {
	
		/* Remove the node from the breakpoint list. */
		breaks = bp -&gt; break_next;
		
		/* Put the node back on the avail list. */
		es("unable to set a breakpoint at "); eptr(short_ptr); enl();
		bp -&gt; break_next = avail;
		avail = bp;
		return FALSE;
	}
}
</t>
<t tx="ekr.20080529093004.1304">@ Display breakpoints.
@c

static void
trm_br_display (void)
{
	if (breaks) {
		breakpoint * bp = NULL;
		ecnl(); es("breakpoints...\n");
		for (bp = breaks; bp; bp = bp -&gt; break_next) {
			eptr(bp -&gt; break_address); es(" ("); eulong(bp -&gt; break_count); es(") ");
		}
		ecnl();
	}
	else {
		ecnl(); es("no breakpoint set\n");
	}
}
</t>
<t tx="ekr.20080529093004.1305">@ Display memory. dump_size is 1 2 or 4 for byte, word and long displays.
@c

#define CHARS_PER_LINE 16

static void
trm_md (ulong start, ulong end, short dump_size)
{
	char * p = NULL;
	char * line_p = NULL;
	long count = 0;
	short line_count = 0;
	bool first_line_flag = TRUE;
	short leading_pad = 0;
	
	if (dump_size &lt; 0 || dump_size &gt; 4 || dump_size == 3) {
		ecnl(); es("bad dump_size\n");
		return;
	}
	
	if (start &lt;= end) {
		p = (char *) start;
		count = end-start+1;
	}
	else {
		p = (char *) end;
		count = start-end+1;
	}
	
	/* Start on an appropriate boundary. */
	if (dump_size &gt; 1) {
		start -= (start % dump_size);
		p = (char *) start;
	}

	while(count &gt; 0) {
		
		/* Start a new line by writing the address. */
		if (first_line_flag || (((ulong)p) % 16 == 0)) {
		
			first_line_flag = FALSE;
			ecnl(); eptr(p); eblank();
			line_p = p;
			line_count = 0;
			leading_pad = (((ulong) p) % 16);
		
			/* Pad the start of a partial line with blanks. */
			if (leading_pad) {
				while(line_count &lt; leading_pad) {
					eblanks(2);
					line_count++;
					if ((line_count % dump_size) == 0) {
						eblanks(dump_size);
					}
					if ((line_count % 4) == 0) {
						eblank();
					}
					else if ((line_count % 8) == 0) {
						eblank();
					}
				}
			}
		}
		
		/* Advance to the next character, word or long. */
		{
			int i;
			
			for (i = 0; i &lt; dump_size; i++) {
				
				/* Write the character in hex. */
				epadhex( ((*p) &amp; 0x00ff), 2);

				p++;
				line_count++;
				count--;
				
				if ((line_count % dump_size) == 0) {
					eblanks(dump_size);
				}
				
				if ((line_count % 4) == 0) {
					eblank();
				}
				else if ((line_count % 8) == 0) {
					eblank();
				}
			}
		}
		
		/* Finish the line by writing the printable characters. */
		if (((((ulong)p) % 16) == 0) || count == 0 || line_count == CHARS_PER_LINE) {
		
			/* Pad the hex area with blanks. */
			{
				register int i;
				short save_line_count = line_count;
				while (line_count &lt; CHARS_PER_LINE) {
					eblanks(2);
					line_count++;
					if ((line_count % dump_size) == 0) {
						eblank();
					}
					if ((line_count % 4) == 0) {
						eblank();
					}
					else if ((line_count % 8) == 0) {
						eblank();
					}
				}
				line_count = save_line_count;
			}
		
			/* Write each character. */
			{
				char * save_p = p;
				register int i;
				for (i = 0; i &lt; leading_pad; i++) {
					es("*");
				}
				for (i = 0, p = line_p; i &lt; line_count-leading_pad; i++, p++) {
					register char c = (*p) &amp; 0x7f;
					if (isprint(c) &amp;&amp; c != '\n' &amp;&amp; c != '\r' &amp;&amp; c != '\f') {
						echar(c);
					}
					else {
						echar('.');
					}
				}
				p = save_p;
				enl();
			}
			
			/* Reset the line count. */
			line_count = 0;
			leading_pad = 0;
			
			/* Any key interrupts the display. */
			#ifndef TESTING
			{
				int key_waiting (void);
				if (key_waiting()) {
					getchar();
					break;
				}
			}
			#endif
				
		}
	}
}
</t>
<t tx="ekr.20080529093004.1306">@ Modify memory.
@c

static void
trm_mm (ulong start, ulong new_val)
{
	char * p = (char *) start;
	eptr(start); eblank();
	epadhex(*p, 2); es(" -&gt; "); epadhex(new_val, 2); eblank();
	
	/* Modify the memory! */
#ifndef TESTING
	/* The high bytes of new_val are known to be zero. */
	*p = new_val;
#endif

}
</t>
<t tx="ekr.20080529093004.1307">@ Remove a breakpoint.  High level: remove a breakpoint node. Low level: remove the breakpoint patch.
@c

static bool
trm_nobr (ulong address)
{
	bool result = 0;
	register breakpoint * bp = NULL;
	register short * short_ptr = (short *) address;
	
	/* Search the list of breakpoints.  Return FALSE if the address is not found. */
	for (bp = breaks; bp; bp = bp -&gt; break_next) {
		 if (bp -&gt; break_address == short_ptr) {
		 	goto found;
		 }
	}
	
not_found:
	es("no breakpoint at "); eptr(short_ptr); enl();
	return FALSE;
	
	/* Remove the breakpoint, making sure it *is* a breakpoint. */
found:
	result = (*short_ptr == TRAP_OPCODE);
	if (result) {
		*short_ptr = bp -&gt; break_save;
	}
	else {
		ecnl(); es("Oh dear, the breakpoint at ");
		eptr(short_ptr); es(" has been damaged!\n");

		es("expecting: "); epadhex(TRAP_OPCODE, 4);
		es(", got: "); epadhex(*short_ptr, 4); enl();
	}
	
	/* Remove the node from the breakpoint list. */
	if (breaks == bp) {
		breaks = bp -&gt; break_next;
	}
	else {
		breakpoint * prev_bp = breaks;
		while (prev_bp -&gt; break_next != bp) {
			prev_bp = prev_bp -&gt; break_next;
		}
		prev_bp -&gt; break_next = bp -&gt; break_next;
	}
	
	/* Put the breakpoint node on the avail list. */
	bp -&gt; break_next = avail;
	avail = bp;
		
	return result;
}
</t>
<t tx="ekr.20080529093004.1308">@ Remove all breakpoint nodes.
@c

static bool
trm_nobr_all (void)
{
	while(breaks) {
		trm_nobr((ulong) (breaks -&gt; break_address)); 
	}
}
</t>
<t tx="ekr.20080529093004.1309">@ Proceed through a breakpoint the given number of times. This will return only if there is an error.
@c

static void
trm_p (short count)
{
	if (!current_break_flag) {
		es("No current breakpoint\n");
		return;
	}
	
	/* Set the proceed count. */
	current_break -&gt; break_count = count;
	
	/* Exit the debugger. */
	trm_patch_address = (ulong) (current_break -&gt; break_address);
	trm_patch_data = current_break -&gt; break_save;
	trm_asm_p();
}
</t>
<t tx="ekr.20080529093004.1310">@ Display registers.
@c

static void
trm_rd (machine_state * s, short regnum)
{
	if (regnum &lt; 18) {
		epadhex(s -&gt; regs [regnum], 8);
	}
	else if (regnum == 18) {
		epadhex(s -&gt; status, 4);
	}
	else {
		ecnl(); es("bad call to trm_rd\n");
	}
}
</t>
<t tx="ekr.20080529093004.1311">@ Display all regs.
@c

static void
trm_rd_all(void)
{
	int i = 0;
	
	ecnl();
	eblanks(3);
	for (i = 0; i &lt; 8; i++) {
		eblanks(7); eulong(i); eblank();
	}
	ecnl();
	es("d: ");
	for (i = 0; i &lt; 8; i++) {
		trm_rd(&amp;trm_regs, i); eblank();
	}
	ecnl();
	es("a: ");
	for (i = 8; i &lt; 16; i++) {
		trm_rd(&amp;trm_regs, i); eblank();
	}
	ecnl();
	for (i = 16; i &lt; 19; i++) {
		es(reg_name[i]); es(": ");
		trm_rd(&amp;trm_regs, i); eblank();
	}
	ecnl();
}
</t>
<t tx="ekr.20080529093004.1312">@ Modify registers.
@c

static void
trm_rm (machine_state * s, short regnum, ulong new_val)
{
	ecnl();
	if (regnum &lt; 18) {
		es(reg_name[regnum]); es(": ");
		es(": "); epadhex(s -&gt; regs [regnum], 8); es(" -&gt; "); epadhex(new_val, 8);  eblank();
		s -&gt; regs [regnum] = new_val;
	}
	else if (regnum == 18) {
		es(reg_name[regnum]); es(": ");
		epadhex(s -&gt; status, 4); es(" -&gt; "); epadhex(new_val, 4);  eblank();
		s -&gt; status = new_val;
	}
	else {
		ecnl(); es("bad call to trm_rm\n");
	}

}
</t>
<t tx="ekr.20080529093004.1313">/*
	Tuple Loader: Argument processing module

	source:  LDarg.c
	started: March 10, 1994.
	version: February 15, 1995.
*/

&lt;&lt; LDarg #includes &gt;&gt;
&lt;&lt; LDarg declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1314">#include "LD.h"

#include "LDarg.h"
#include "LDmem.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBenv.h&gt;
#include &lt;LIBio.h&gt;
#include &lt;LIBlist.h&gt;
#include &lt;LIBlog.h&gt;

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
</t>
<t tx="ekr.20080529093004.1315">/*
	Define globals owned by this class.
*/

char * arg_in_path = NULL;

/*
	Define internal flags;
*/

static int		arg_save_argc	= 0;	/* Saved argc.			*/
static char **	arg_save_argv	= NULL;	/* Saved argp.			*/

/*
	Declare internal routines.
*/
static void	arg_help	(void);
static bool arg_prefix	(char *p, char *s);
</t>
<t tx="ekr.20080529093004.1316">@ Process the arguments found in an argv vector.  This routine may be re-entered. Return TRUE if any more arguments remain.
@c

#define debug_arg_do_argv(a)

bool
arg_do_argv(int argc, char ** argv, char * on_str, char * off_str)
{
	FTAG("arg_do_argv");
	register char * arg = NULL;
	char * in = NULL;

	/*
		Do not put Sherlock macros here: Sherlock has not been initialized!
	*/
	SL_DISABLE();

	debug_arg_do_argv(TRACEP(ftag, elp(); eint(argc); ecs(); eptr(argv); erpnl()));

	if (argv == NULL) {
		argc = arg_save_argc;
		argv = arg_save_argv;
	}

	/* Indicate that no file arguments have been seen yet. */
	in  = NULL;

	/* Process all the arguments on the command line. */
	ASSERT(argv);
	argc--;
	argv++;
	while (argc-- &gt; 0) {

		ASSERT(*argv);
		arg = *argv++;
		debug_arg_do_argv(TRACEPN(ftag, es("arg: "); es(arg); enl() ));

		if (arg[0] == '@') {
			if (str_eq(arg+1, "goto")) {
				if (argc--) {

					/* Scan forward for the label. */
					char * label = *argv++;
					ecnl(); es("@goto "); es(label); enl();
					while(argc--) {
						arg = *argv++;
						if (str_eq(label, arg)) {
							break;
						}
					}
				}
				else {
					es("Trailing @goto\n");
					end_usage();
				}
			}
			else {
				/* Ignore the label. */
				;
			}
		}
		else if (arg[0] == '+' || arg[0] == '-') {

			bool arg_bool = (arg[0] == '+');

			arg++;

			switch(arg[0]) {

			case 'a':
			case 'b':
			case 'c':
			case 'd':

				goto unknown_option;
		
			case 'e':

				if (str_eq(arg, "error")) {
					err_err_flag = arg_bool;
				}
				else if (str_eq(arg, "exit")) {
					return NO_MORE_FILES_REMAIN;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'f':
			case 'g':
			case 'h':
			case 'i':
			case 'j':
			case 'k':
			case 'l':
			case 'm':
			case 'n':			
			case 'o':
			case 'p':
			case 'q':
			case 'r':
			case 's':
			case 't':
			case 'u':

				goto unknown_option;
			
			case 'v':

				if (str_eq(arg, "v")) {
					err_verbose = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			case 'w':

				if (str_eq(arg, "warning")) {
					err_warn_flag = arg_bool;
				}
				else {
					goto unknown_option;
				}
				break;

			default:

				if (str_eq(arg, "?")) {
					/* Tell the version number and go on. */
					enl(); es(lib_version); enl();
					arg_help();
					break;
				}

			unknown_option:

				#ifdef PRODUCTION
					if (on_str &amp;&amp; arg_prefix(on_str+1, arg)) {

						/* Ignore a Sherlock argument. */
						char * s = arg + strlen(on_str) - 1;
						if (*s == '&gt;' &amp;&amp; *(s+1) == '&gt;') {
							log_open(0, s+2);
						}
					}
					else if (off_str &amp;&amp; arg_prefix(off_str+1, arg)) {
						/* Ignore a Sherlock argument. */
						;
					}
					else {

						es("ignoring unknown command-line option: ");
						es(arg_bool ? "+" : "-"); es(arg); enl();
					}
				#else
					;
				#endif

			} /* end +- option switch */
		}
		else if (in == NULL) {
		
			/* Set the name of the input file. */
			in = arg;
			break;
		}
	}
	
	/* Make sure that the input file name was provided. */
	if (in == NULL) {
		es("Missing input file argument.\n");
		end_usage();
	}

	/* Remember the input and output paths. */
	arg_in_path  = in;

	if (argc &gt; 0) {
		arg_save_argv = argv - 1;
		arg_save_argc = argc + 1;
	}
	else {
		arg_save_argv = NULL;
	}
	return MORE_FILES_REMAIN;

}</t>
<t tx="ekr.20080529093004.1317">@ End arg_do_arg
@c

#undef debug_arg_do_argv

/*
	Output a usage message.
*/
static void
arg_help(void)
{

#ifdef PRODUCTION
	es("\nusage: Load [options] in out\n");
#else
	es("\nusage: LoadDB [++--routine] [options] input_file\n");
#endif

	es("\noptions...\n");
	es("+-error           Enable error messages\n");
	es("-exit             Terminate option list\n");
	es("+-note            Enable notes\n");
	es("+-v               Verbose output\n");
	es("+-warning         Enable warning messages\n");
	es("-?                Print the version number and exit\n");
}
</t>
<t tx="ekr.20080529093004.1318">@ Return TRUE if string p is a prefix of string s.
@c

static bool
arg_prefix(char *p, char *s)
{
	while (*p) {
		if (*p++ != *s++) {
			return FALSE;
		}
	}
	return TRUE;
}
</t>
<t tx="ekr.20080529093004.1319">/*
	Tuple loader/debugger: internal disassembler.

	This is useful as a check on the assembler bit patterns.

	source: LDdisasm.c
	started: March 10, 1994.
	version:
		March 11, 1994.
			Represent the mnemonic by a string instead of a token code.
*/

&lt;&lt; LDdisasm #includes &gt;&gt;
&lt;&lt; LDdisasm declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1320">#include "LD.h"

#include "LDdisasm.h"
</t>
<t tx="ekr.20080529093004.1321">/*
	Define various fields of an instruction word.
*/

	/* These fields have "official" names. */

#define cc			((opword &amp; 0x0f00) &gt;&gt;  8)	/* Bits  8 - 11	*/
#define eamode		((opword &amp; 0x0034) &gt;&gt;  3)   /* Bits  3 -  5 */
#define eafield		 (opword &amp; 0x007f)			/* Bits  0 -  7	*/
#define eareg		 (opword &amp; 0x0007)			/* Bits  0 -  3 */
#define op			((opword &amp; 0xf000) &gt;&gt; 12)	/* Bits 12 - 15	*/
#define opmode		((opword &amp; 0x01c0) &gt;&gt;  6)	/* Bits  6 -  8	*/

	/* These fields have no "official" names. */

#define bit3		((opword &amp; 0x0008) &gt;&gt;  3)	/* Bit   3		*/
#define bits34		((opword &amp; 0x0018) &gt;&gt;  3)	/* Bits  3 -  4	*/
#define bits345		((opword &amp; 0x0038) &gt;&gt;  3)	/* Bits  3 -  5 */
#define bit5		((opword &amp; 0x0020) &gt;&gt;  5)	/* Bit   5		*/
#define bits67		((opword &amp; 0x00c0) &gt;&gt;  6)	/* Bits  6 -  7 */
#define bit8		((opword &amp; 0x0010) &gt;&gt;  8)	/* Bit   8		*/
#define bits8910	((opword &amp; 0x0700) &gt;&gt;  8)	/* Bits  8 - 10 */
#define bits891011	((opword &amp; 0x0f00) &gt;&gt;  8)	/* Bits  8 - 11 */
#define bits910		((opword &amp; 0x0600) &gt;&gt;  9)	/* Bits  9 - 10 */
#define bits91011	((opword &amp; 0x0e00) &gt;&gt;  9)	/* Bits  9 - 11 */
#define bit11		((opword &amp; 0x0800) &gt;&gt; 11)	/* Bit  11		*/

#define xopword (*((short *)(ip+1)))

#define xbit11		((xopword &amp; 0x0800) &gt;&gt; 11)	/* Bit 11 of extension word */

/*
	Define abbreviations for case that indicate context
*/
#define main_case case

/*
	Define sizes: these values must correspond to the default size encoding.
*/
enum { B = 0, W = 1, L = 2, NO_LEN = 3 };

/*
	Define encoding for fields
*/
enum {
	NO_ARG,
	/*
		disp: bits 0-8 of the opword:

		0x00: 16 bit displacement in extension word
		0xff: 32 bit displacement in extension word
		else:  8 bit displacement
	*/
	disp,		/* 8,16, or 32-bit displacement depending on bits 0-8 of opword */
	data,		/* Data in low 8 bits of opword */
	data2,		/* Data field in bits 9-11 of opword. */
	size2,		/* Size in bits 9 and 10 (instead of bits 6 and 7) */
	vector,		/* Vector number in low 3 bits of opword. */

	/*
		Effective address in bits 0-5 of opword.
		This has several variants, depending on which modes are valid.
		The code must arrange matters so that all invalid modes
		that are used in special-case opcodes are handled *before* the xxx_ea modes.
	*/
	ea,				/* General effective address.  All modes valid. */
	alt_ea,			/* Alterable:		  not mode 7      (modes 7:0, 7:1 are valid) */
	control_ea,		/* Control:			  not 0,1,3,4 or 7:4 */
	control_alt_ea,	/* Control alterable: not 0,1,3,4,7   (modes 7:0, 7:1 are valid) */
	dn_ctl_alt_ea,	/* Dn and control alterable */
	pd_ctl_alt_ea,	/* Predecrement  plus control alterable. */
	pi_ctl_alt_ea,	/* Postincrement plus control alterable. */
	data_ea,		/* Data				  not mode 1 */
	data_ximm_ea,	/* Data except immediate: not modes 1, 7:4 */
	data_alt_ea,	/* Data alterable:    not modes 1, 7, (modes 7:0, 7:1 are valid) */
	mem_alt_ea,		/* Memory alterable:  not modes 0,1,7 (modes 7:0, 7:1 are valid) */


	ea2,		/* Effective address in bits 6-11 of opword (reg and mode reversed!) */

	An,			/* Address register in bits 0-3 */
	An2,		/* Address register in bits 9-11 (reg field of ea2) */

	Anpredec,	/* Address register (implied predecrement mode) in bits 0-3 */
	Anpredec2,	/* Address register (implied predecrement mode) in data2 field. */
	Anpostinc,	/* Address register (implied postincrement mode) in bits 0-3 */
	Anpostinc2,	/* Address register (implied postincrement mode) in data2 field. */
	An_xdisp16,	/* Address register (implied (xdisp16,An) mode) in bits 0-3 */

	Dn,			/* Data register in bits 0-3 */
	Dn2,		/* Data register in bits 9-11 (reg field of ea2) */

	xdata_size,	/* Data in extention word(s) whose size depends on size field */
	xdata_8,	/* Data in low  8 bits of extension word (high bits are 0) */
	xdata_16,	/* Data in all 16 bits of extension word */
	xdata_32,	/* Data in two exention words. */

	xbit,		/* Dit number in low 8 bits of extension word (high bits are 0) */
	xsize,		/* Bit 10 of extension word. */
	xtype,		/* Bit 11 of extension word. */

	xoffset,	/* Offset in bits 6-10 of extension word, flag in bit 11 of extension */
	xwidth,		/* Width  in bits 0-4  of extension word, flag in bit  5 of extension */

	xDhigh,		/* Data register in bits 12-14 of extension word. */
	xDlow,		/* Data register in low 3 bits of extension word. */
	xDn,		/* Data register in bits 12-14 of extension word. */

	xDq,		/* Data register in bits 12-14 of extension word. */
	xDr,		/* Data register in low 3 bits of extension word. */

	xcreg,		/* Control register in low 12 bits of extension word. */
	xgreg,		/* General register in high 4 bits of extension word. */
	xreglist,	/* Register list mask in extension word. */

	cr_implied,		/* Condition code register implicit in opcode */
	sr_implied,		/* Status register implied by opcode */
	usp_implied		/* User stack pointer implied by opcode */
};

/*
	Define abbreviations for control structure.
*/
#define bad_switch(tag) fatal(es(ftag); es("Bad switch: "); es(tag));
#define bad goto bad_opcode

#define op0(op) 			 	{op0df(ip,op,NO_LEN);				goto done;}
#define op1(op,f1)			 	{op1df(ip,op,NO_LEN,f1); 			goto done;}
#define op2(op,f1,f2)		 	{op2df(ip,op,NO_LEN,f1,f2);			goto done;}
#define op3(op,f1,f2,f3)		{op3df(ip,op,NO_LEN,f1,f2,f3);		goto done;}
#define op4(op,f1,f2,f3,f4)		{op4df(ip,op,NO_LEN,f1,f2,f3,f4);	goto done;}
#define op0len(op,len)		 	{op0df(ip,op,len); 					goto done;}
#define op1len(op,len,f1)	 	{op1df(ip,op,len,f1); 				goto done;}
#define op2len(op,len,f1,f2) 	{op2df(ip,op,len,f1,f2); 			goto done;}
#define op3len(op,len,f1,f2,f3)	{op3df(ip,op,len,f1,f2,f3);			goto done;}
#define opcc0(op,cc)			{opcc0df(ip,op,cc,NO_LEN);			goto done;}
#define opcc1(op,cc,f1)	 		{opcc1df(ip,op,cc,NO_LEN,f1);		goto done;}
#define opcc2(op,cc,f1,f2) 		{opcc2df(ip,op,cc,NO_LEN,f2,f2);	goto done;}
#define opcc1len(op,cc,len,f1)	{opcc1df(ip,op,cc,len,f1); 			goto done;}

// temps
#define cas2(length)	{goto done;}
#define cas 			{goto done;}

/*
	Prototypes on internal routines.
*/
static void op0df	(char *ip, char * mnemonic, int len);
static void op1df	(char *ip, char * mnemonic, int len, int f);
static void op2df	(char *ip, char * mnemonic, int len, int f1, int f2);
static void op3df	(char *ip, char * mnemonic, int len, int f1, int f2, int f3);
static void op4df	(char *ip, char * mnemonic, int len, int f1, int f2, int f3, int f4);
static void opcc0df	(char *ip, char * mnemonic, int the_cc, int len);
static void opcc1df	(char *ip, char * mnemonic, int the_cc, int len, int f1);
static void opcc2df	(char *ip, char * mnemonic, int the_cc, int len, int f1, int f2);
</t>
<t tx="ekr.20080529093004.1322">@ Disassemble a single instruction located at ip.
@c

void
disassemble(char * ip)
{
	FTAG("disassemble");
	register word opword = *((short *)ip);
	register int size = bits67;
	STATB(ftag);
	ASSERT(ip);

	/*
		Select the category of instruction based on the high four bits.
		See page 3-201 of the Motorola 68030 manual.
	*/
	switch(op) {

	main_case 0:	/* Bit manipulation, MOVEP, Immediate */

		/* 0x3c (mode 7, register 4) is not usually a valid effective address. */
		if (eafield == 0x3c) {
			switch (opword) {
			case 0x003c: op2("ori", xdata_8, cr_implied)
			case 0x007c: op2("ori", xdata_16,sr_implied)
			case 0x023c: op2("andi",xdata_8, cr_implied)
			case 0x027c: op2("andi",xdata_16,sr_implied)
			case 0x063c: op2("eori",xdata_8, cr_implied)
			case 0x067c: op2("eori",xdata_16,sr_implied)
			case 0x0cfc: cas2(W)
			case 0x0dfc: cas2(L)
			default:	 bad;
			}
		}

		if (eamode == 1) {
			/*
				Mode 1 is usually invalid for type 0 instructions
				since these instructions use D-regs, not A-regs.
			*/
			switch(opmode) {
			case 4:	op2("movep.w",An_xdisp16,Dn2)
			case 5:	op2("movep.l",An_xdisp16,Dn2)
			case 6:	op2("movep.w",Dn2,An_xdisp16)
			case 7:	op2("movep.l",Dn2,An_xdisp16)
			default: bad;
			}
		}

		if (bit8) {
			/*
				Bit 8 is 0 for all instructions with op == 1 except for
				MOVEP (tested above) and dynamic bit instructions.
				Cases 0-3 are impossible since bit 8 is the high bit of the opmode field.
			*/
			switch (opmode) {
			case 4:	op2("btst",Dn2,data_alt_ea)	/* Dynamic...*/
			case 5: op2("bchg",Dn2,data_alt_ea)
			case 6:	op2("bclr",Dn2,data_alt_ea)
			case 7:	op2("bset",Dn2,data_alt_ea)
			}
		}

		/*
			At this point bits 9, 10 and 11 mostly determine the operation.
			However, Bits 6 and 7 are used as flags in various circumstances.
		*/
		if (bits67 == 3) {

			if (bit11 == 1 &amp;&amp; bits910 != 0) cas //
			else if (bit11 == 0) {
				if (xbit11) op2len("chk2",size2,control_ea,xgreg)
				else 		op2len("cmp2",size2,control_ea,xgreg)
			}
			else {
				/* This is a static bit operation handled below. */
			}
		}

		if (size == 3 &amp;&amp; bits91011 != 4) bad;

		switch(bits91011) {
		case 0:	op2len("ori", size,xdata_size,data_alt_ea)
		case 1: op2len("andi",size,xdata_size,data_alt_ea)
		case 2:	op2len("subi",size,xdata_size,data_alt_ea)
		case 3: op2len("addi",size,xdata_size,data_alt_ea)
		case 5: op2len("eori",size,xdata_size,data_alt_ea)
		case 6: op2len("cmpi",size,xdata_size,data_ximm_ea)
		case 7:	if (xbit11) op2len("moves",size,xgreg,mem_alt_ea)
				else		op2len("moves",size,mem_alt_ea,xgreg)
		case 4:	/* Bit static */
			switch(size) {
			case 0:	op2("btst",xbit,data_alt_ea)
			case 1:	op2("bchg",xbit,data_alt_ea)
			case 2:	op2("bclr",xbit,data_alt_ea)
			case 3:	op2("bset",xbit,data_alt_ea)
			}
		}
		bad_switch("main 0");

	main_case 1:	/* Move byte */

		op2("move.b",ea2,data_alt_ea)

	main_case 2:	/* Move long */

		if (opmode == 1)	op2("movea.l",ea,An2)
		else				op2("move.l",ea2,data_alt_ea)

	main_case 3:	/* Move word */

		if (opmode == 1)	op2("movea.w",ea,An2)
		else				op2("move.w",ea2,data_alt_ea)

	main_case 4:	/* Miscellaneous */

		if (bit8) {
			switch (size) {
			case 0:	op2("chk.l",data_ea,Dn2)
			case 1: bad;
			case 2: op2("chk.w",data_ea,Dn2)
			case 3: if (eamode == 0)	op1("extb.l",Dn)
					else				op2("lea",control_ea,An2)
			}
		}

		/* Bit 8 is zero from here on. */
		switch (bits91011) {
		case 0: if (size == 3)	op2("move",sr_implied,data_alt_ea)
				else			op1len("negx",size,data_alt_ea)
		case 1: if (size == 3)	op2("move",cr_implied,data_alt_ea)
				else			op1len("clr",size,data_alt_ea)
		case 2: if (size == 3)	op2("move",data_ea,cr_implied)
				else			op1len("move",size,data_alt_ea)
		case 3: if (size == 3)	op2("move",data_ea,sr_implied)
				else			op1len("not",size,data_alt_ea)
		case 4:
			switch(size) {
			case 0: if (eamode == 0)	op2("link.l",An,xdata_size)
					else				op1("nbcd",data_alt_ea)
			case 1:	if (eamode == 0)	op1("swap",Dn)
					else if (eamode==1)	op1("bkpt",vector)
					else				op1("pea",control_ea)
			case 2: if (eamode == 0)	op1("ext.w",Dn)
					else				op2("movem.w",xreglist,pd_ctl_alt_ea)
			case 3: if (eamode == 0)	op1("ext.l",Dn)
					else				op2("movem.l",xreglist,pd_ctl_alt_ea)
			}
		case 5:
			switch(size) {
			case 0:
			case 1:
			case 2: op1len("tst",size,data_ea)
			case 3:
				if (eafield == 0x3c)	op0("illegal")
				else					op1("tas", data_alt_ea)
			}
		case 6:
			switch (size) {
			case 0: /* xDq may *not* be the same register as xDr */
				if (xsize)	op3(xtype ? "mulsl.l" : "mulul.l", ea, xDhigh, xDlow)
				else		op2(xtype ? "mulsl.l" : "mulul.l", ea, xDlow)
			case 1: /* xDq *may* be the same register as xDr */
				if (xsize)	op3(xtype ? "divsl.l" : "divul.l", data_ea, xDq, xDr)
				else		op3(xtype ? "divsl.l" : "divul.l", data_ea, xDq, xDr)
			case 2:	op2("movem.w", pi_ctl_alt_ea,xreglist)
			case 3: op2("movem.l", pi_ctl_alt_ea,xreglist)
			}
		case 7:
			switch (size) {
			case 0: bad;
			case 1:
				switch (eamode) {
				case 0:	op1("trap",vector)	/* vector field is low bit of eamode field */
				case 1:	op1("trap",vector)
				case 2: op2("link.w",An,xdata_size)
				case 3:	op1("unlk",An)
				case 4: op2("move",An,usp_implied)
				case 5: op2("move",usp_implied,An)
				case 6: 
					switch (eareg) {
					case 0:	op0("reset")
					case 1: op0("nop")
					case 2: op1("stop",xdata_16)
					case 3: op0("rte")
					case 4: op1("rtd",xdata_16)
					case 5: op0("rts")
					case 6: op0("trapv")
					case 7:	op0("rtr")
					}
				case 7:
					switch (eareg) {
					case 2:	op2("movec",xcreg,xgreg)
					case 3:	op2("movec",xgreg,xcreg)
					default: bad;
					}
				}
			case 2: op1("jsr",control_ea)
			case 3: op1("jmp",control_ea)
			}
		}
		bad_switch("Main 4");

	main_case 5:	/* ADDQ, SUBQ, Scc, DBcc, TRAPcc */

		if (size == 3) {
			switch(eamode) {
			case 1: opcc2("db",cc,Rn,xdata_16)	/* Label */
			case 7:
				switch(eareg) {
					case 0: opcc1("s",cc,data_alt_ea)
					case 1: opcc1("s",cc,data_alt_ea)
					case 2: opcc1len("trap",cc,W,xdata_16)
					case 3: opcc1len("trap",cc,L,xdata_32)
					case 4: opcc0("trap",cc)
					default: bad;
				}
			default: opcc1("s",cc,data_alt_ea)
			}
		}
		else if (bit8)	op2len("subq",size,data2,alt_ea)
		else			op2len("addq",size,data2,alt_ea)
		
	bad_switch("Main 5");

	main_case 6:	/* Bcc, BSR, BRA */

		switch(cc) {
		case 0:  op1("bra",disp)
		case 1:  op1("bsr",disp)
		default: opcc1("b",cc,disp)
		}

	main_case 7:	/* MOVEQ */

		if (bit8)	bad;
		else		op2("moveq",data,Dn2)

	main_case 8:	/* OR, DIV, SBCD, PACK, UNPK */

		/* One *must* consider opmode before eamode. */
		switch(opmode) {
		case 0:
		case 1:
		case 2:
			op2len("or",size,data_ea,Dn2)
		case 3:
			op2("divu",data_ea,Dn2)
		case 4:
			switch(eamode) {
			case 0:  op2("sbcd",Dn,Dn2)
			case 1:  op2("sbcd",Anpredec,Anpredec2)
			default: op2("or.b",Dn2,mem_alt_ea)
			}
		case 5:
			switch(eamode) {
			case 0:  op2("pack",Dn,Dn2)
			case 1:  op2("pack",Anpredec,Anpredec2)
			default: op2("or.w",Dn2,mem_alt_ea)
			}
		case 6:
			switch(eamode) {
			case 0:  op3("unpk",Dn,Dn2,xdata_16)
			case 1:  op3("unpk",Anpredec,Anpredec2,xdata_16)
			default: op2("or.w",Dn2,mem_alt_ea)	// should be long ???
			}
		case 7: op2("divs",data_ea,Dn2)
		}
		
	bad_switch("Main 8");

	main_case  9:	/* SUB, SUBA, SUBX */

		switch(opmode) {
		case 0:
		case 1:
		case 2:
			op2len("sub",size,ea,Dn2)
		case 4:
		case 5:
		case 6:
			switch(eamode) {
			case 0:  op2len("subx",size,Dn,Dn2)
			case 1:  op2len("subx",size,Anpredec,Anpredec2)
			default: op2len("sub", size,Dn2,mem_alt_ea)
			}
		case 3:	op2("suba.w",ea,An2)
		case 7:	op2("suba.l",ea,An2)
		}
		
	bad_switch("Main 9");

	main_case 10:	/* A-trap (reserved) */

		bad;

	main_case 11:	/* CMP, CMPA, EOR */

		switch(opmode) {
		case 0:
		case 1:
		case 2:
			op2len("cmp",size,ea,Dn2)
		case 4:
		case 5:
		case 6:
			if (eamode == 1)	op2len("cmpm",size,Anpostinc,Anpostinc2)
			else				op2len("eor",size,Dn2,data_alt_ea)
		case 3:	op2("cmpa.w",ea,An2)
		case 7:	op2("cmpa.l",ea,An2)
		}
		
	bad_switch("Main 11");

	main_case 12:	/* AND, MUL, ABCD, EXG */

		switch(opmode) {
		case 0:
		case 1:
		case 2:
			op2len("and",size,data_ea,Dn2)
		case 4:
			switch(eamode) {
			case 0:  op2("abcd",Dn,Dn2)
			case 1:  op2("abcd",Anpredec,Anpredec2)
			default: op2("and.b",Dn2,mem_alt_ea)
			}
		case 5:
			switch(eamode) {
			case 0:  op2("exg",Dn2,Dn)
			case 1:  op2("exg",An2,An)
			default: op2("and.w",Dn2,mem_alt_ea)
			}
		case 6:
			switch(eamode) {
			case 0:  bad;
			case 1:  op2("exg",Dn2,An)
			default: op2("and.l",Dn2,mem_alt_ea)
			}
		case 3: op2("mulu",data_ea,Dn2)
		case 7: op2("muls",data_ea,Dn2)
		}
		
	bad_switch("Main 12");

	main_case 13:	/* ADD, ADDA, ADDX */

		switch(opmode) {
		case 0:
		case 1:
		case 2:
			op2len("add",size,ea,Dn)
		case 4:
		case 5:
		case 6:
			switch(eamode) {
			case 0:  op2len("addx",size,Dn,Dn2)
			case 1:  op2len("addx",size,Anpredec,Anpredec2)
			default: op2len("add",size,Dn2,mem_alt_ea)
			}
		case 3: op2("adda.w",ea,An2)
		case 7: op2("adda.l",ea,An2)
		}
		
	bad_switch("Main 13");

	main_case 14:	/* Shift, Rotate, Bit Field */

		if (size == 3) {
			switch(bits891011) {
			case  0: op1("asr", mem_alt_ea)			/* Shift/Rotate Memory */
			case  1: op1("asl", mem_alt_ea)
			case  2: op1("lsr", mem_alt_ea)
			case  3: op1("lsl", mem_alt_ea)
			case  4: op1("roxr",mem_alt_ea)
			case  5: op1("roxl",mem_alt_ea)
			case  6: op1("ror", mem_alt_ea)
			case  7: op1("rol", mem_alt_ea)
			case  8: op3("bftst", dn_ctl_alt_ea,xoffset,xwidth)		/* Bit field */
			case  9: op4("bfextu",dn_ctl_alt_ea,xoffset,xwidth,xDn)
			case 10: op3("bfchg", dn_ctl_alt_ea,xoffset,xwidth)
			case 11: op4("bfexts",dn_ctl_alt_ea,xoffset,xwidth,xDn)
			case 12: op3("bfclr", dn_ctl_alt_ea,xoffset,xwidth)
			case 13: op4("bfffo", dn_ctl_alt_ea,xoffset,xwidth,xDn)
			case 14: op3("bfset", dn_ctl_alt_ea,xoffset,xwidth)
			case 15: op4("bfins", dn_ctl_alt_ea,xoffset,xwidth,xDn)
			}
		}
		else {	/* Shift/Rotate Register */
			switch(bits345) { 
			case 0: op2len(bit8 ? "asl"  : "asr",  size, data2, eareg)
			case 1: op2len(bit8 ? "lsl"  : "lsr",  size, data2, eareg)
			case 2: op2len(bit8 ? "roxl" : "roxr", size, data2, eareg)
			case 3: op2len(bit8 ? "rol"  : "ror",  size, data2, eareg)
			case 4: op2len(bit8 ? "asl"  : "asr",  size, Dn2, eareg)
			case 5: op2len(bit8 ? "lsr"  : "lsr",  size, Dn2, eareg)
			case 6: op2len(bit8 ? "roxl" : "roxr", size, Dn2, eareg)
			case 7: op2len(bit8 ? "rol"  : "ror",  size, Dn2, eareg)
			}
		}
		
	bad_switch("Main 14");

	main_case 15:	/* Coprocessor Interface */

		// not ready yet
		bad;

	default: break;

	}
	fatal(es(ftag); es("Bad outer switch.  case: "); eint(op));

bad_opcode:
	error(es("Bad opcode"));

done:
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1323">static void
op0df (char *ip, char * mnemonic, int len)
{}
</t>
<t tx="ekr.20080529093004.1324">static void
op1df (char *ip, char * mnemonic, int len, int f)
{}
</t>
<t tx="ekr.20080529093004.1325">static void
op2df (char *ip, char * mnemonic, int len, int f1, int f2)
{}
</t>
<t tx="ekr.20080529093004.1326">static void
op3df (char *ip, char * mnemonic, int len, int f1, int f2, int f3)
{}
</t>
<t tx="ekr.20080529093004.1327">static void
op4df (char *ip, char * mnemonic, int len, int f1, int f2, int f3, int f4)
{}
</t>
<t tx="ekr.20080529093004.1328">static void
opcc0df (char *ip, char * mnemonic, int the_cc, int len)
{}
</t>
<t tx="ekr.20080529093004.1329">static void
opcc1df (char *ip, char * mnemonic, int the_cc, int len, int f1)
{}
</t>
<t tx="ekr.20080529093004.1330">static void
opcc2df (char *ip, char * mnemonic, int the_cc, int len, int f1, int f2)
{}
</t>
<t tx="ekr.20080529093004.1331">/*
	Tuple Loader: application-specific program termination module.

	source:  LDend.c
	started: January 7, 1994.
	version: February 15, 1995.
*/

&lt;&lt; LDend #includes &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1332">#include "LD.h"
#include "LDend.h"
#include &lt;LIBos.h&gt;
</t>
<t tx="ekr.20080529093004.1333">@ Close all application files. Do not close the log file.
@c

void
end_close_all(void)
{
	FTAG("end_close_all");
	STATB(ftag);

	// io_close(os_bytes_file);
	// io_close(os_text_file);

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1334">/*
	Tuple Loader: General error handling.

	source:  LDerr.c
	started: March 10, 1994.
	version: February 15, 1995.
*/

&lt;&lt; LDerr #includes &gt;&gt;
&lt;&lt; LDerr declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1335">#include "LD.h"

#include "LDarg.h"
#include "LDes.h"

#include &lt;LIBend.h&gt;

#include &lt;stdlib.h&gt;	/* For abort. */
</t>
<t tx="ekr.20080529093004.1336">/*
	Define global status variables.
*/
long	err_count = 0;				/* Error counts...			*/
long	err_help = 0;
long	err_fatal = 0;
long	err_warning = 0;

bool	err_err_flag = TRUE;		/* Enable message flags... */
bool	err_fatal_flag = TRUE;
bool	err_help_flag = TRUE;
bool	err_warn_flag = TRUE;

bool	err_verbose = FALSE;		/* Verbose flag. */

/*
	Function prototypes internal routines.
*/
static void	err_begin_mess	(char * message);

/*
	Define internal variables.
*/
static bool err_abort_flag = FALSE;
</t>
<t tx="ekr.20080529093004.1337">@ Print the "context" of an error. In the case of the debugger, this does nothing.
@c

void
err_context(void)
{}
</t>
<t tx="ekr.20080529093004.1338">@ Initialize all the internal variables declared above.
@c

void
err_init_again(void)
{
	FTAG("err_init_again");
	STATB(ftag);

	err_count		= 0;
	err_help		= 0;
	err_warning		= 0;

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1339">@ Output the common start of an error message.
@c

#define F_WIDTH 10

static void
err_begin_mess(char * message)
{
	ecnls(2);
	epads(message, 8);

	/* Put error message on new line. */
	ecnl();
}
</t>
<t tx="ekr.20080529093004.1340">@ Start an error message.
@c

bool
err_begin(void)
{
	err_count++;
	err_begin_mess("error:");
	return TRUE;
}
</t>
<t tx="ekr.20080529093004.1341">@ Start a fatal error message. User errors should never result in a call to fatal.
@c

void
fatal_begin(void)
{
	/*7/19/93: Abort if we take a fatal error while processing a fatal error. */
	static bool in_fatal = FALSE;

	err_fatal++;
	ecnl(); enl();
	es("Oh Dear...There is something wrong me\n");
	es("in: "); es(current_ftag);
	es(" called from "); es(caller_ftag);
	es(" called from "); es(caller2_ftag);
	enl();

	if (in_fatal) {
		es("Encountered a second fatal error...aborting now!\n");
		end_abort();
		abort();
	}
	in_fatal = TRUE;
	err_begin_mess("oops:"); enl();
}
</t>
<t tx="ekr.20080529093004.1342">@ Terminate a fatal error message that was begun with fatal_start.
@c

void
fatal_end(void)
{
	err_context();
	ecnl();
	if (err_fatal_flag) {
		end_abort();
		abort();
	}
}
</t>
<t tx="ekr.20080529093004.1343">@ Start a help message.
@c

bool
help_begin(void)
{
	err_help++;
	err_begin_mess("note:");
	return TRUE;
}
</t>
<t tx="ekr.20080529093004.1344">@ Start and end an unrecoverable user error.
@c

void
user_fatal_begin(void)
{
	err_fatal++;
	ecnl();
	err_begin_mess("oops:"); enl();
}
</t>
<t tx="ekr.20080529093004.1345">void
user_fatal_end(void)
{
	TRACE("fatal", err_context());
	ecnl();
	if (err_fatal_flag) {
		end_abort();
		abort();
	}
}
</t>
<t tx="ekr.20080529093004.1346">@ Formatted warning routines.
@c

bool
warn_begin(void)
{
	err_warning++;
	err_begin_mess("warning:");
	return TRUE;
}
</t>
<t tx="ekr.20080529093004.1347">/*
	Tuple loader: Application-specific error-stream routines.
	
	source:  LDes.c
	started: March 7, 1994.
	version: February 15, 1995.
		Prototypes for all routines in this file are found in LIBes.h.
*/

&lt;&lt; LDes #includes &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1348">#include "LD.h"
#include "LDes.h"

#include &lt;LIBes.h&gt;
#include &lt;LIBlog.h&gt;
</t>
<t tx="ekr.20080529093004.1349">@ All error output eventually comes here. Defining es here allows each application to define es as it sees fit.
@c

void
es(char * s)
{
	if (s) {
		log_sout(s);
	}
}
</t>
<t tx="ekr.20080529093004.1350">/*
	Tuple Loader: initialization code.

	source:  LDinit.c
	started: March 10, 1994.
	version: February 15, 1995
*/

/* Always allow Sherlock macros, especially SL_PARSE. */
#undef NO_SHERLOCK

/* include these *before* Sherlock is included. */

#ifdef applec
	#ifndef __size_t__	/* This is used in the MPW headers. */
  	#define __size_t__
		typedef unsigned long size_t;
	#endif

&lt;&lt; LDinit #includes &gt;&gt;
&lt;&lt; LDinit declarations &gt;&gt;
@others

#endif /* THINK_C */
</t>
<t tx="ekr.20080529093004.1351">#include &lt;Memory.h&gt;	/* For MaxApplZone. */
</t>
<t tx="ekr.20080529093004.1352">#endif

#ifdef THINK_C

#include &lt;LoMem.h&gt;

#include &lt;Dialogs.h&gt;
#include &lt;Fonts.h&gt;
#include &lt;Menus.h&gt;
#include &lt;Quickdraw.h&gt;
#include &lt;OSEvents.h&gt;
#include &lt;Windows.h&gt;
#endif

#include "LD.h"

#include "LDarg.h"
#include "LDinit.h"
#include "LDmain.h"
#include "LDmem.h"

#include &lt;LIBcmnd.h&gt;
#include &lt;LIBend.h&gt;
#include &lt;LIBenv.h&gt;
#include &lt;LIBlog.h&gt;
#include &lt;LIBmem.h&gt;
#include &lt;LIBobj.h&gt;

#ifdef THINK_C
#include &lt;mac_about_dialog.h&gt;
#include &lt;mac_gui.h&gt;
#endif

/*
Function prototypes for internal routines.
The call-back routines are only needed when windows are used.
*/
#ifdef THINK_C
static void dump1_call_back	(void);
static void dump2_call_back	(void);
static void dump3_call_back	(void);
static void	event_call_back	(void);
</t>
<t tx="ekr.20080529093004.1353">#endif

/*
	Initialize the environment, Sherlock and all modules.

	The argv vector is not used in some environments, so it is possible
	that a compiler could generate a warning to that effect,
	but trying to eliminate that warning would not be wise:
	we definitely want all initialization done by a single routine.
*/
void
init_all(int argc, char ** argv)
{
	FTAG("init_all");

/*
	When using Think C, we must completely initialize the Mac Toolbox,
	since we are building a stand-along application.

	When using MPW, we must *not* initialize the Toolbox, nor call MaxApplZone.
	Also, we do *not* call InitGraf, since Sherlock uses standard io under MPW.
*/

#ifdef THINK_C

	void * ApplLimit1;		/* Original values before heap and stack are changed. */
	void * CurStackBase1;
	void * HeapEnd1;
	void * ApplZone1;

	/*
		Initialize the ToolBox routines.

		Warning:

		*never* put anything before the follwing instructions.
		Even an inocuous-looking routine like tok_init will crash MaxApplZone().
	*/
	InitGraf( (Ptr) &amp;(qd.thePort));
	InitFonts();
	FlushEvents(everyEvent,0);
	InitWindows();
	InitMenus();
	TEInit();
	InitDialogs(0L);
	InitCursor();

	/* These are defined in LoMem.h, which only exists for Think C. */
	ApplLimit1 = ApplLimit;
	CurStackBase1 = CurStackBase;
	HeapEnd1 = HeapEnd;
	ApplZone1 = ApplZone;

	SetApplLimit( (Ptr)(CurStackBase - 9000));
	MaxApplZone();

	/*
		Initialize the memory manager.
		This can and should be done before all other initializations.
	*/
	mem_perm_life = mem_init_life("lifetime: perm");
	
	mem_perm_string_stats =	mem_init_stats (mem_perm_life, "strings(perm)");

	/*
		Notice that the Sherlock menu is used only if Sherlock is defined.
	*/
	w_mac_init(
		SL_VERSION_NAME,			/* version name from sl.h. */
		FALSE,						/* Initialize the Macintosh ToolBox. */
		TRUE,						/* TRUE: output to log window. */
		lib_log_window_name,		/* Name of log window. */
		TRUE,						/* TRUE: open Sherlock window. */
		TRUE,						/* TRUE: Insert standard menus.	 */
		SHERLOCK_DEFINED,			/* TRUE: Insert Sherlock menu. */
		TRUE,						/* TRUE: Insert first item in apple menu. */
		lib_about_title,			/* Title of first item in apple menu. */
		&amp;about_dialog,				/* CallBack routine for first apple item. */
		TRUE,						/* TRUE: Insert menus immediately. */
		&amp;event_call_back,			/* Event callback routine. */
		&amp;dump1_call_back,			/* First user callback routine. */
		(pstring) "\pObjects",		/* Name of first user menu item. */
		&amp;dump2_call_back,			/* Second user callback routine. */
		(pstring) "\pObject Stats",	/* Name of second user menu item. */
		&amp;dump3_call_back,			/* Third user callback routine.	*/
		(pstring) "\pHeap Stats"	/* Name of third user menu item. */
	);

#endif

	/* Sherlock must be initialized now. */
	SL_INIT();
	init_args(&amp;argc, &amp;argv, lib_arg_file_name, "++", "--");

	/* Enable traces of routines used to read Sherlock arguments. */
	SL_PARSE(argc, argv, "++", "--");

	STATB(ftag);

	/* Watch location 0.  This test catches *p = x where p is NULL. */
	SL_WATCH(0, 4, "loc 0");

	/* Parse the program arguments. */
	arg_do_argv(argc, argv, "++", "--");

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1354">@ The call-back routines are only needed when windows are used.
@c

#ifdef THINK_C

/*
	"Call-back" routines for event processing when Sherlock outputs a line.
*/
static void
event_call_back(void)
{
	SL_DISABLE();

	#ifdef THINK_C
		if (w_applEvent(0) == FALSE) {
			end_quit();
		}
	#endif
}
</t>
<t tx="ekr.20080529093004.1355">static void
dump1_call_back(void)
{
	SL_DISABLE();

	#ifndef PRODUCTION
		ecnls(2);
		obj_dump_objects("Sherlock User Report");
	#endif

	ecnl();
}
</t>
<t tx="ekr.20080529093004.1356">static void
dump2_call_back(void)
{
	SL_DISABLE();

	#ifndef PRODUCTION
		ecnls(2);
		obj_dump_stats("Sherlock User Report: ");
		ecnl();
	#endif

	ecnl();
}
</t>
<t tx="ekr.20080529093004.1357">static void
dump3_call_back(void)
{
	SL_DISABLE();

	#ifndef PRODUCTION
		ecnls(2); es("Sherlock User Report: ");
		env_dump_stats();
		ecnl();
	#endif
}
</t>
<t tx="ekr.20080529093004.1358">/*
	Tuple Loader: interface to devlib.

	source:  LDlib.c
	started: March 10, 1994.
	version: February 15, 1995.
*/

&lt;&lt; LDlib #includes &gt;&gt;

	/* Define variables used by devlib. */

pstring	lib_about_title		= "\pAbout Load";		/* Must be a pascal string. */
char *	lib_arg_file_prompt = "Load log file...";	/* Prompt for file name. */

char *	lib_dialog_version	= "Load version 1.0:\r\rCopyright ? 1995 by Tuple, Inc.";

char *	lib_log_window_name	= "Load log";			/* The name of log window. */
char *	lib_program_name	= "Load";				/* The name of the program. */

#if defined(THINK_C)
	char *	lib_arg_file_name = "Load Args";	/* The name of the argument file. */
#elif defined(applec)
	char *	lib_arg_file_name = "Load MPW args";
#else
	char *	lib_arg_file_name = "LoadArgs.txt";
#endif

bool   lib_stderr_flag = FALSE;			/* TRUE: send log output to stderr on the Mac. */

char *	lib_version = "Load version 1.0";
</t>
<t tx="ekr.20080529093004.1359">#include &lt;LIBlib.h&gt;
</t>
<t tx="ekr.20080529093004.1360">/*
	Tuple Loader: the loader class.
	
	This file contains all routines called from the jump table.

	source:  LDload.h
	started: February 15, 1995.
	version: February 15, 1995.
*/

&lt;&lt; LDload #includes &gt;&gt;
&lt;&lt; LDload declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1361">#include "LD.h"

#include "LDarg.h"
#include "LDload.h"
#include "LDmem.h"

#include "Debugger.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBio.h&gt;
#include &lt;LIBobj.h&gt;

#include &lt;fcntl.h&gt;
#include &lt;time.h&gt;
#include &lt;unix.h&gt;
</t>
<t tx="ekr.20080529093004.1362">/*
	Prototypes of routines local to this module.
	Don't declare these static so they can be traced more easily.
*/
	void	_user_abort		(void);
	void	_user_exit		(void);
	void 	_user_startup	(void);

	void	_chk_ptr(void * p);
	int		_Close	(int);
	void	_Exit	(int);
	int 	_Execl	(const char *, const char *, const char *);
	int		_Fork	(void);	
	void *	_Getmem	(size_t size);
	int		_Getpid	(void);
	int		_Open	(const char *, int, int);
	long	_Lseek	(int, long, int);
	int		_Read	(int, unsigned char *, int);
	int		_Remove	(const char *);
	int		_Rename	(const char *, const char *);
	long	_Ticks	(void);
	time_t	_Time	(time_t *);
	int		_Write	(int, const unsigned char *, int);
	int		_Wait	(int *);
	
#if 1 // Temporary (I think)

#define JUMP_TABLE_ENTRIES 20
	
void * jump_table_address[JUMP_TABLE_ENTRIES] = {

	/* Entry and exit. */

		&amp;_user_startup,	/* 0: do not change. */
		&amp;_user_exit,	/* 1: do not change. */
		NULL,			/* 2: reserved.  No longer used. */
		
	/* The address of main. */
	
		NULL,		/* 3 : Filled in below. */

	/* Memory allocation */

		&amp;_Getmem,	/* 4 */
		
	/* File i/o */
	
		&amp;_Close,	/*  5 */
		&amp;_Lseek,	/*  6 */
		&amp;_Open,		/*  7 */
		&amp;_Read,		/*  8 */
		&amp;_Remove,	/*  9 */
		&amp;_Rename,	/* 10 */
		&amp;_Write,	/* 11 */
		
	/* Time routines.  _Time can be defined in terms of mktime, or vice versa. */

		NULL,			/* 12: reserved for mktime. */
		&amp;_Time,			/* 13 */
		
	/*
		Process control
		None of these are used by the tools.
		StdClib references these in essentially a dummy manner.
	*/
		&amp;_Execl,	/* 14 */
		&amp;_Fork,		/* 15 */
		&amp;_Getpid,	/* 16 */
		&amp;_Wait,		/* 17 */
		
	/* Miscellaneous. */

		&amp;_chk_ptr,	/* 18 */
		&amp;_Ticks,	/* 19 */
};
</t>
<t tx="ekr.20080529093004.1363">#endif // Temporary

/*
	The loader.
*/
void
load(void)
{
	FTAG("load");
	
	STATB(ftag);
	ASSERT(arg_in_path);
	
	/* Load the header of the input file. */
	
	/* Get the addresses of memory areas from the header. */
	
	/*
		Allocate memory for the loaded program.
		The allocated memory must cover the same addresses used by the program!

		(The following code is a kludge to handle Macintosh's inability to
		directly allocate space at a particular address.)
	*/
	
	/* Move the program into memory. */
	
	/* Fill in the jump table. */
	
	/* Set debugging symbols for the debugger. */
	
	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1364">@ The following routines are called from the *loaded* program via the jump table.
@c

void
_user_abort	(void)
{
	es("User program called abort\n");
	main_quit();
	end_done();
}
</t>
<t tx="ekr.20080529093004.1365">void
_user_exit (void)
{
	es("User program called exit\n");
	main_quit();
	end_done();
}
</t>
<t tx="ekr.20080529093004.1366">@ The main routine calls _user_startup to begin execution of the program.
@c

void
_user_startup (void)
{
	void (*f) (int argc, char **argv, char ** env) = jump_table_address [3];
	char * argv [] = { "user program", NULL };
	
	/* Jump to the user program in jump_table_address [3]. */
	ASSERT(jump_table_address [3]);
		
	es("_user_startup: calling main at: "); eptr(f); enl();
	
	/* Remember: this will not work if the Think C debugger is on. */
	TRACEP("TMON_symbols", DebugStr("\pmain"));

	/* Call the user code with minimal argv, argc, arg_env. */
	(*f) (1, argv, NULL);
	
	es("_user_startup: user program returned\n");
	
	main_quit();
	end_done();
}
</t>
<t tx="ekr.20080529093004.1367">@ ----- Start of library routines ------  Only these routines need be ported to port the entire Standard C Library.
Define a dummy environment.  _Environ is referenced only by the _Envp macro in yfuns.h.  _Envp is used only by getenv, figure , page 380, file getenv.c.  _Environ points to a list of NULL terminated strings. A NULL pointer terminates the list.  We can add extra strings to environs[] if needed.
@c

static const char * environs[] = { NULL };

const char **_Environ = &amp;environs[1];

/*
	Check for a use of a NULL pointer.
*/
void
_chk_ptr (void * p)
{
	if (p == NULL) {
		es("Using a NULL pointer at: "); eptr(p);
		end_abort();
	}
}
</t>
<t tx="ekr.20080529093004.1368">@ Glue routine for unix close call.
@c

int
_Close (int fd)
{
	return close(fd);
}
</t>
<t tx="ekr.20080529093004.1369">@ Glue routine for unix execl call.  This routine is different on the Mac than on unix: o No arguments are passed to the executed program. o Think_exec always exits, even if the program is not found.  This is called only by system, figure 13.37 page 380, file system.c.  Actually this routine will *never* be called because fork always fails.
@c

int
_Execl (const char * program_name, const char * s2, const char * s3)
{
	/* Never returns, even if the program is not found. */
	exec( (char *) program_name);
}
</t>
<t tx="ekr.20080529093004.1370">void
_Exit (int i)
{
	es("User program called exit\n");
	main_quit();
	end_done();
}
</t>
<t tx="ekr.20080529093004.1371">@ Glue routine for unix fork.  This is not available on the Mac so fail by returning -1.
@c

int
_Fork(void)
{
	return -1;
}
</t>
<t tx="ekr.20080529093004.1372">@ Glue routine for unix getpid routine.  This is called only from tmpnam, figure 12.10, page 284, file tmpname.c.  Because it used only to generate a unique name, it might be better simply to implement tmpnam directly.  This makes even more sense becuase: o The StdClib version of tmpnam returns /tmp/t&lt;seed&gt;  (The slashes are different between DOS and Unix). o The Think C version of getpid always returns 57 (!)
@c

int
_Getpid	(void)
{
	/*
		Generate a different number each time this is called.
		However, the number always starts at zero when the program first starts.
	*/
	static int pid = 0;
	return ++pid;
}
</t>
<t tx="ekr.20080529093004.1373">void *
_Getmem(size_t size)
{
	static ulong total = 0;
	static ulong max_size = 0;
	FTAG("_Getmem");
	void * p = NULL;
	obj_new_macro(p, size, "_Getmem");

	TRACEP(ftag,
		total += size;
		max_size = max(size, max_size);
		es("size: "); epadlong(size,5); eblank();
		eret(); eptr(p);
		es(", max_size: "); eulong(max_size); 
		es(", total: "); eulong(total); enl());

	return p;
}
</t>
<t tx="ekr.20080529093004.1374">@ Rename old file to be the new file. Return 0 on success, non-zero on error.  This is called only by the rename routine.
@c

int
_Rename (const char * old, const char * new)
{
	return rename(old, new);
}
</t>
<t tx="ekr.20080529093004.1375">@ Glue routine to the unix seek routine.  Called from: o _Fgpos, figure 12.12, page 285, file xfgpos.c. o _Fspos, figure 12.13, page 286, file xfspos.c.
@c

long
_Lseek (int fd, long offset, int way)
{
	int whence = 0;
	
	#if 0 /* Constants from StdClib version of stdio.h */
		#define SEEK_SET	0
		#define SEEK_CUR	1
		#define SEEK_END	2
	#endif
	
	/*
		whence is one of:
		SEEK_SET: beginning of file.
		SEEK_CUR: current position of file.
		SEEK_END: end of file.
		
		The constants 0, 1 and 2 come from StdClib version of stdio.h.
	*/
	
	#if 0 /* These constants are defined the same in stdio.h and Think_stdio.h. */
		if (way == 0) {
			whence = SEEK_SET;
		}
		else if (way == 1) {
			whence = SEEK_CUR;
		}
		else {
			whence = SEEK_END;
		}
	#else
		whence = way;
	#endif

	return lseek (fd, offset, whence);
}
</t>
<t tx="ekr.20080529093004.1376">@ Glue routine to the unix open routine.  It is called only from _Fopen, figure 12.11, page 284, file xfopen.c.
@c

int
_Open (const char * filename, int acc, int dummy)
{
	int mode = 0;

	#if 0 /* This is the calling code in _Fopen. */
		acc = (smode &amp; (_MOPENR|_MOPENW)) == (_MOPENR|_MOPENW) ? 2
			: smode &amp; _MOPENW ? 1 : 0;
		if (smode &amp; _MOPENA)
			acc |= 010;		/* O_APPEND */
		if (smode &amp; _MTRUNC)
			acc |= 02000;	/* O_TRUNC */
		if (smode &amp; _MCREAT)
			acc |= 01000;	/* O_CREAT */
			
		/*
			1/25/95.
			Plauger's code clearly has a bug here.
			_Foprep sets the _MBIN bits in smode, but they are never used.
		*/
		if (smode &amp; _MBIN) {
			acc |= 0100;	/* EKR: new O_BINARY code for use only by _Open */
		}
	#endif

	/*
		Must have exactly one of O_WRONLY, O_RDONLY or O_RDWR.
		
		The constants 0, 1 and 2 come from the _Fopen code above.
		
		acc == 2: read/write:	_MOPENR and _MOPENW set
		acc == 1: write:		_MOPENW set				
		acc == 0: read:			neither set
	*/
	if (acc &amp; 2) {
		mode |= O_RDWR;
	}
	else if (acc &amp; 1) {
		mode |= O_WRONLY;
	}
	else {
		mode |= O_RDONLY;
	}
	
	/*
		May have any number of O_APPEND, O_CREAT, O_TRUNC, O_EXCL.
		
		The "magic constants" come from the _Fopen code above.
	*/
	if (acc &amp; 010) {
		mode |= O_APPEND;
	}
	if (acc &amp; 02000) {
		mode |= O_TRUNC;
	}
	if (acc &amp; 01000) {
		mode |= O_CREAT;
	}
	
	/* 1/25/95: new code to handle bug in Plauger's code. */
	if (acc &amp; 0100) {
		mode |= O_BINARY;
	}
	else {
		mode |= O_TEXT;
	}

	return open( (char *) filename, mode);
}
</t>
<t tx="ekr.20080529093004.1377">@ Glue routine to the unix read routine.  Called via the expansion of the _Fread macro defined in yfuns.h.  _Fread is called only from _Frprep, figure 12.32, page 295, file xfrprep.c.
@c

int
_Read (int fd, unsigned char * buffer, int n)
{
	return read (fd, (char *) buffer, n);
}
</t>
<t tx="ekr.20080529093004.1378">@ Glue routine for ticks routine.
@c

long
_Ticks(void)
{
	long VIA_ticks(void);
	return VIA_ticks();	/* Mac VIA timer. */
}
</t>
<t tx="ekr.20080529093004.1379">@ Glue routine for unit time routine.  This is called only from time, figure 15.2, page 426, file time.c.
@c

time_t
_Time(time_t * t)
{
	return time(t);
}
</t>
<t tx="ekr.20080529093004.1380">@ Remove the indicated file from the file system. Return 0 on success, non-zero on error.  This is called only by the remove function.
@c

int
_Remove (const char * filename)
{
	remove(filename);
}
</t>
<t tx="ekr.20080529093004.1381">@ Glue routine for unix wait.  This is called only by system, figure 13.37 page 380, file system.c.  Actually this routine will *never* be called because fork always fails.  This is not available on the Mac so fail by returning -1.
@c

int
_Wait(int * ip)
{
	return -1;
}
</t>
<t tx="ekr.20080529093004.1382">@ Glue routine to the unix write routine.  Called via the expansion of the _Fwrite macro defined in yfuns.h.  _Fwrite is called only from fflush, figure 12.37, page 295, file fflush.c.
@c

int
_Write (int fd, const unsigned char * buf, int n)
{
	if (fd == 1 || fd == 2) {
		/* Put the "console to the exxx stream. */
		int i;
		for (i = 0; i &lt; n; i++) {
			echar(buf[i]);
		}
		return n;
	}
	else {
		return write(fd, (char *) buf, n);
	}
}
</t>
<t tx="ekr.20080529093004.1383">/*
	Tuple Loader: Main routines and globals.

	source:  LDmain.c
	started: March 10, 1994.
	version: February 15, 1995.
*/

/* Always allow Sherlock macros in this file. */
#undef NO_SHERLOCK

&lt;&lt; LDmain #includes &gt;&gt;
&lt;&lt; LDmain declarations &gt;&gt;
@others
</t>
<t tx="ekr.20080529093004.1384">#include "LD.h"

#include "LDarg.h"
#include "LDinit.h"
#include "LDload.h"
#include "LDmain.h"
#include "LDmem.h"

#include "Debugger.h"

#include &lt;LIBend.h&gt;
#include &lt;LIBenv.h&gt;
#include &lt;LIBio.h&gt;
#include &lt;LIBlist.h&gt;
#include &lt;LIBmath.h&gt;
#include &lt;LIBobj.h&gt;
#include &lt;LIBos.h&gt;

#include &lt;time.h&gt;
</t>
<t tx="ekr.20080529093004.1385">/*
	Prototypes of internal routines.
*/
static void main_db		(void);
static void	main_free_all	(void);
static void	main_report		(void);
</t>
<t tx="ekr.20080529093004.1386">@ The main line of the program...
@c

void
main(int argc, char **argv)
{
	/* Calls to Sherlock from this routine just distort statistics. */
	SL_DISABLE();

	#if 0 /* Remember: this will not work if the Think C debugger is on. */
		DebugStr("\pmain");
	#endif

	/* Absolutely *no* calls to Sherlock before init_all is called! */
	init_all(argc, argv);
	
	/* Load each file in turn. */
	while (arg_in_path != NULL) {

		load();
		
		// We probably will never get here!!

		if (arg_do_argv(0, NULL, NULL, NULL) == NO_MORE_FILES_REMAIN) {
			break;
		}
	}

	TRACEP("debug", trm_main());

	/* Report statistics and exit. */
	main_quit();
	end_done();
}
</t>
<t tx="ekr.20080529093004.1387">@ Debug one source file.
@c

void
main_db(void)
{
	FTAG("main_db");

	/* Free all memory. */
	main_free_all();

	/* Print statistics. */

	#ifndef PRODUCTION
		TRACE("-asm_sl_dump",		SL_DUMP());
		TRACE("-asm_object_stats",	obj_dump_stats(ftag));
	#endif
}
</t>
<t tx="ekr.20080529093004.1388">@ Free all assembler data structures that can be freed after one source file has been completely assembled.  Data with permanent lifetime must *not* be freed here!  This routine can only work properly if *all* aspects of memory allocation are correct. The acid test is whether Load can handle 2 files without crashing.  WARNING: Add *nothing* to this routine without making sure that Load can handle 2 files.
@c

static void
main_free_all(void)
{
	FTAG("main_free_all");
	STATB(ftag);

	/* Re-initialize all global lists. */

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1389">@ Free all dynamic structures and do end-of-program reporting.  This routine is called on normal termination and also by lib_quit when the user interrupts the assembly.
@c

void
main_quit(void)
{

#ifndef PRODUCTION

	/* Free all paths, path names and argument strings. */
	mem_free_life(mem_perm_life);

	/* Report statistics for all lifetimes. */
	TRACE("-quit_mem_stats",
		mem_life * mlp = NULL;
		for (mlp = mem_life_list; mlp; mlp = mlp -&gt; mem_life_list) {
			mem_dump_stats(mlp, DONT_DUMP_CURRENT_STATS);
		}
	);

	/* Report heap stats, Sherlock stats and object stats. */
	TRACEP("-quit_env_stats",	env_dump_stats());
	TRACEP("-quit_sl_dump", 	sl_dump());

	#ifndef PRODUCTION
		TRACEP("-quit_obj_stats",	obj_dump_stats("main_dumps"));
		TRACEP("-quit_obj_objects",	obj_dump_objects("main_dumps"));
	#endif

#endif /* PRODUCTION */

}
</t>
<t tx="ekr.20080529093004.1390">@ Report any hidden errors, but only in verbose mode.
@c

static void
main_report()
{
	FTAG("main_report");
	STATB(ftag);

	if (err_verbose) {

		if (!err_err_flag &amp;&amp; err_count) {
			ecnl(); elong (err_count);
			es(" error"); es( (err_count == 1) ? " was" : "s were");
			es(" detected but not reported.\n");
		}

		if (!err_warn_flag &amp;&amp; err_warning) {
			ecnl(); elong (err_warning);
			es(" warning");es( (err_warning == 1) ? " was" : "s were");
			es(" detected but not reported.\n");
		}

		if (!err_help_flag &amp;&amp; err_help) {
			ecnl(); elong (err_help);
			es(" note"); es( (err_help == 1) ? " was" : "s were");
			es(" detected but not reported.\n");
		}
	}

	STATX(ftag);
}
</t>
<t tx="ekr.20080529093004.1391">/*
	Tuple Loader: Application-specific memory management routines and variables.

	source:  LDmem.c
	started: March 10, 1994.
	version: February 15, 1995.
*/

&lt;&lt; LDmem #includes &gt;&gt;

/*
	Define the lifetimes used in the program.
*/
mem_life * mem_perm_life = NULL;	/* Description of permanent lifetime. */

/*
	Define the statistics nodes.
*/
mem_stat * mem_perm_string_stats = NULL;
</t>
<t tx="ekr.20080529093004.1392">#include "LD.h"
#include "LDmem.h"
</t>
<t tx="ekr.20080529093004.1393">@language c
@ignore</t>
</tnodes>
</leo_file>
