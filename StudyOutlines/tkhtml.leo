<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="6446" clone_windows="0"/>
<globals body_outline_ratio="0.59649122807">
	<global_window_position top="38" left="163" height="855" width="907"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20041214071955" a="E"><vh>tkHTML</vh>
<v t="ekr.20041214071955.1"><vh>Copyright</vh></v>
<v t="ekr.20041214071955.2"><vh>src/tokenlist.txt</vh></v>
<v t="ekr.20041214071955.3"><vh>src/html.h</vh>
<v t="ekr.20041214071955.4"><vh>DEBUG</vh></v>
<v t="ekr.20041214071955.5"><vh>Version info</vh></v>
<v t="ekr.20041214071955.6"><vh>Sanity checking macros</vh></v>
<v t="ekr.20041214071955.7"><vh>TRACE macro</vh></v>
<v t="ekr.20041214071955.8"><vh>Macros to allocate and free memory</vh></v>
<v t="ekr.20041214071955.9" a="E"><vh>data types</vh></v>
<v t="ekr.20041214071955.10"><vh>struct HtmlStyle</vh></v>
<v t="ekr.20041214071955.11" a="EM"><vh>struct HtmlElements</vh></v>
<v t="ekr.20041214073047"><vh>HtmlBaseElement</vh></v>
<v t="ekr.20041214073047.1"><vh>HtmlTextElement</vh></v>
<v t="ekr.20041214073047.2"><vh>HtmlSpaceElement</vh></v>
<v t="ekr.20041214073047.3"><vh>HtmlMarkupElement</vh></v>
<v t="ekr.20041214073047.4"><vh>HtmlCell</vh></v>
<v t="ekr.20041214073047.5"><vh>HtmlTable</vh></v>
<v t="ekr.20041214073047.6"><vh>HtmlRef</vh></v>
<v t="ekr.20041214073047.7"><vh>HtmlLi</vh></v>
<v t="ekr.20041214073047.8"><vh>HtmlListStart</vh></v>
<v t="ekr.20041214073047.9"><vh>HtmlImage</vh></v>
<v t="ekr.20041214073047.10"><vh>HtmlInput</vh></v>
<v t="ekr.20041214073047.11"><vh>HtmlForm</vh></v>
<v t="ekr.20041214073047.12"><vh>HtmlHr</vh></v>
<v t="ekr.20041214073047.13"><vh>HtmlAnchor</vh></v>
<v t="ekr.20041214073047.14"><vh>HtmlScript</vh></v>
<v t="ekr.20041214073047.15"><vh>HtmlBlock</vh></v>
<v t="ekr.20041214073047.16"><vh>HtmlStyleStack</vh></v>
<v t="ekr.20041214073047.17"><vh>HtmlMargin</vh></v>
<v t="ekr.20041214073047.18"><vh>HtmlLayoutContext</vh></v>
<v t="ekr.20041214073047.19"><vh>HtmlIndex</vh></v>
<v t="ekr.20041214073047.20"><vh>HtmlWidget</vh></v>
</v>
<v t="ekr.20041214071955.13"><vh>src/htmlcmd.c</vh>
<v t="ekr.20041214071955.15"><vh>HtmlResolveCmd</vh></v>
<v t="ekr.20041214071955.16"><vh>HtmlCgetCmd</vh></v>
<v t="ekr.20041214071955.17"><vh>HtmlClearCmd</vh></v>
<v t="ekr.20041214071955.18"><vh>HtmlConfigCmd</vh></v>
<v t="ekr.20041214071955.19"><vh>HtmlHrefCmd</vh></v>
<v t="ekr.20041214071955.20"><vh>HtmlNamesCmd</vh></v>
<v t="ekr.20041214071955.21"><vh>HtmlParseCmd</vh></v>
<v t="ekr.20041214071955.22"><vh>HtmlXviewCmd</vh></v>
<v t="ekr.20041214071955.23"><vh>HtmlYviewCmd</vh></v>
<v t="ekr.20041214071955.24"><vh>HtmlTokenHandlerCmd</vh></v>
<v t="ekr.20041214071955.25"><vh>HtmlIndexCmd</vh></v>
<v t="ekr.20041214071955.26"><vh>UpdateSelection</vh></v>
<v t="ekr.20041214071955.27"><vh>HtmlUpdateSelection</vh></v>
<v t="ekr.20041214071955.28"><vh>HtmlSelectionSetCmd</vh></v>
<v t="ekr.20041214071955.29"><vh>HtmlSelectionClearCmd</vh></v>
<v t="ekr.20041214071955.30"><vh>HtmlUpdateInsert</vh></v>
<v t="ekr.20041214071955.31"><vh>HtmlInsertCmd</vh></v>
<v t="ekr.20041214071955.32"><vh>HtmlTokenListCmd</vh></v>
<v t="ekr.20041214073236"><vh>debugging...</vh>
<v t="ekr.20041214071955.33"><vh>HtmlDebugDumpCmd</vh></v>
<v t="ekr.20041214071955.34" a="E"><vh>HtmlDebugTestPtCmd</vh></v>
</v>
</v>
<v t="ekr.20041214071955.35"><vh>src/htmldraw.c</vh>
<v t="ekr.20041214071955.37"><vh>AllocBlock</vh></v>
<v t="ekr.20041214071955.38"><vh>FreeBlock</vh></v>
<v t="ekr.20041214071955.39"><vh>UnlinkAndFreeBlock</vh></v>
<v t="ekr.20041214071955.40"><vh>AppendBlock</vh></v>
<v t="ekr.20041214071955.41"><vh>GetLetterIndex</vh></v>
<v t="ekr.20041214071955.42"><vh>GetRomanIndex</vh></v>
<v t="ekr.20041214071955.43"><vh>DrawSelectionBackground</vh></v>
<v t="ekr.20041214071955.44"><vh>HtmlDrawRect</vh></v>
<v t="ekr.20041214071955.45"><vh>HtmlBlockDraw</vh></v>
<v t="ekr.20041214071955.46"><vh>HtmlDrawImage</vh></v>
<v t="ekr.20041214071955.47"><vh>FillOutBlock</vh></v>
<v t="ekr.20041214071955.48"><vh>FindStartOfNextBlock</vh></v>
<v t="ekr.20041214071955.49"><vh>HtmlFormBlocks</vh></v>
</v>
<v t="ekr.20041214071955.50"><vh>src/htmlform.c</vh>
<v t="ekr.20041214071955.51"><vh>&lt;&lt; htmlform #includes &gt;&gt;</vh></v>
<v t="ekr.20041214071955.52"><vh>HtmlUnmapControls</vh></v>
<v t="ekr.20041214071955.53"><vh>HtmlMapControls</vh></v>
<v t="ekr.20041214071955.54"><vh>HtmlDeleteControls</vh></v>
<v t="ekr.20041214071955.55"><vh>InputType</vh></v>
<v t="ekr.20041214071955.56"><vh>MakeWindowName</vh></v>
<v t="ekr.20041214071955.57"><vh>EmptyInput</vh></v>
<v t="ekr.20041214071955.58"><vh>HtmlInputRequestProc</vh></v>
<v t="ekr.20041214071955.59"><vh>HtmlInputLostSlaveProc</vh></v>
<v t="ekr.20041214071955.60"><vh>HtmlInputEventProc</vh></v>
<v t="ekr.20041214071955.61"><vh>SizeAndLink</vh></v>
<v t="ekr.20041214071955.62"><vh>HtmlAppendText</vh></v>
<v t="ekr.20041214071955.63"><vh>AddSelectOptions</vh></v>
<v t="ekr.20041214071955.64"><vh>HtmlControlSize</vh></v>
<v t="ekr.20041214071955.65"><vh>EncodeText</vh></v>
</v>
<v t="ekr.20041214071955.66"><vh>src/htmlimage.c</vh>
<v t="ekr.20041214071955.68"><vh>HtmlGetImageAlignment</vh></v>
<v t="ekr.20041214071955.69"><vh>ImageChangeProc</vh></v>
<v t="ekr.20041214071955.70"><vh>HtmlAppendArglist</vh></v>
<v t="ekr.20041214071955.71"><vh>HtmlGetImage</vh></v>
</v>
<v t="ekr.20041214071955.72"><vh>src/htmlindex.c</vh>
<v t="ekr.20041214071955.73"><vh>&lt;&lt; htmlindex #includes &gt;&gt;</vh></v>
<v t="ekr.20041214071955.74" a="E"><vh>HtmlTokenByIndex</vh></v>
<v t="ekr.20041214071955.75"><vh>HtmlTokenNumber</vh></v>
<v t="ekr.20041214071955.76"><vh>maxIndex</vh></v>
<v t="ekr.20041214071955.77"><vh>FindIndexInBlock</vh></v>
<v t="ekr.20041214071955.78"><vh>HtmlIndexToBlockIndex</vh></v>
<v t="ekr.20041214071955.79"><vh>DecodeBaseIndex</vh></v>
<v t="ekr.20041214071955.80"><vh>HtmlGetIndex</vh></v>
</v>
<v t="ekr.20041214071955.81"><vh>src/htmllayout.c</vh>
<v t="ekr.20041214071955.82"><vh>&lt;&lt; htmllayout #includes &gt;&gt;</vh></v>
<v t="ekr.20041214071955.83"><vh>HtmlPushMargin</vh></v>
<v t="ekr.20041214071955.84"><vh>HtmlPopOneMargin</vh></v>
<v t="ekr.20041214071955.85"><vh>HtmlPopMargin</vh></v>
<v t="ekr.20041214071955.86"><vh>PopExpiredMargins</vh></v>
<v t="ekr.20041214071955.87"><vh>HtmlClearMarginStack</vh></v>
<v t="ekr.20041214071955.88"><vh>GetLine</vh></v>
<v t="ekr.20041214071955.89"><vh>FixAnchors</vh></v>
<v t="ekr.20041214071955.90"><vh>FixLine</vh></v>
<v t="ekr.20041214071955.91"><vh>Paragraph</vh></v>
<v t="ekr.20041214071955.92"><vh>HtmlComputeMargins</vh></v>
<v t="ekr.20041214071955.93"><vh>ClearObstacle</vh></v>
<v t="ekr.20041214071955.94"><vh>DoBreakMarkup</vh></v>
<v t="ekr.20041214071955.95"><vh>InWrapAround</vh></v>
<v t="ekr.20041214071955.96"><vh>HtmlWidenLine</vh></v>
<v t="ekr.20041214071955.97"><vh>HtmlLayoutBlock</vh></v>
<v t="ekr.20041214071955.98"><vh>HtmlLayout</vh></v>
</v>
<v t="ekr.20041214071955.99"><vh>src/htmlparse.c</vh>
<v t="ekr.20041214071955.100"><vh>&lt;&lt; htmlparse #includes &gt;&gt;</vh></v>
<v t="ekr.20041214071955.101"><vh>&lt;&lt; htmlparse declarations &gt;&gt;</vh></v>
<v t="ekr.20041214071955.102"><vh>EscHash</vh></v>
<v t="ekr.20041214071955.103"><vh>EscHashStats</vh></v>
<v t="ekr.20041214071955.104"><vh>EscInit</vh></v>
<v t="ekr.20041214071955.105"><vh>HtmlTranslateEscapes</vh></v>
<v t="ekr.20041214071955.106"><vh>HtmlHash</vh></v>
<v t="ekr.20041214071955.107"><vh>HtmlHashStats</vh></v>
<v t="ekr.20041214071955.108"><vh>HtmlHashInit</vh></v>
<v t="ekr.20041214071955.109"><vh>AppendElement</vh></v>
<v t="ekr.20041214071955.110"><vh>NextColumn</vh></v>
<v t="ekr.20041214071955.111"><vh>ToLower</vh></v>
<v t="ekr.20041214071955.112"><vh>Tokenize</vh></v>
<v t="ekr.20041214071955.113"><vh>HtmlTokenizerAppend</vh></v>
<v t="ekr.20041214071955.114"><vh>HtmlInsertToken</vh></v>
<v t="ekr.20041214071955.115"><vh>HtmlNameToType</vh></v>
<v t="ekr.20041214071955.116"><vh>HtmlTypeToName</vh></v>
<v t="ekr.20041214071955.117"><vh>HtmlTokenName</vh></v>
<v t="ekr.20041214071955.118"><vh>HtmlTclizeList</vh></v>
<v t="ekr.20041214071955.119"><vh>HtmlPrintList</vh></v>
</v>
<v t="ekr.20041214071955.120"><vh>src/htmlsizer.c</vh>
<v t="ekr.20041214071955.121"><vh>&lt;&lt; htmlsizer #includes &gt;&gt;</vh></v>
<v t="ekr.20041214071955.122"><vh>GetCurrentStyle</vh></v>
<v t="ekr.20041214071955.123"><vh>PushStyleStack</vh></v>
<v t="ekr.20041214071955.124"><vh>HtmlPopStyleStack</vh></v>
<v t="ekr.20041214071955.125"><vh>ScaleFont</vh></v>
<v t="ekr.20041214071955.126"><vh>HtmlMarkupArg</vh></v>
<v t="ekr.20041214071955.127"><vh>GetAlignment</vh></v>
<v t="ekr.20041214071955.128"><vh>GetOrderedListType</vh></v>
<v t="ekr.20041214071955.129"><vh>GetUnorderedListType</vh></v>
<v t="ekr.20041214071955.130"><vh>MakeInvisible</vh></v>
<v t="ekr.20041214071955.131"><vh>GetLinkColor</vh></v>
<v t="ekr.20041214071955.132"><vh>HtmlAddStyle</vh></v>
<v t="ekr.20041214071955.133"><vh>HtmlSizer</vh></v>
</v>
<v t="ekr.20041214071955.134"><vh>src/htmltable.c</vh>
<v t="ekr.20041214071955.135"><vh>&lt;&lt; htmltable #includes &gt;&gt;</vh></v>
<v t="ekr.20041214071955.136"><vh>CellSpacing</vh></v>
<v t="ekr.20041214071955.137"><vh>TableDimensions</vh></v>
<v t="ekr.20041214071955.138"><vh>MinMax</vh></v>
<v t="ekr.20041214071955.139"><vh>GetVerticalAlignment</vh></v>
<v t="ekr.20041214071955.140"><vh>HtmlTableLayout</vh></v>
<v t="ekr.20041214071955.141"><vh>HtmlMoveVertically</vh></v>
</v>
<v t="ekr.20041214071955.142"><vh>src/htmltest.c</vh>
<v t="ekr.20041214071955.143"><vh>&lt;&lt; htmltest #includes &gt;&gt;</vh></v>
<v t="ekr.20041214071955.144"><vh>&lt;&lt; htmltest declarations &gt;&gt;</vh></v>
<v t="ekr.20041214071955.145"><vh>HtmlTestPointDump</vh></v>
<v t="ekr.20041214071955.146"><vh>HtmlTPUntested</vh></v>
<v t="ekr.20041214071955.147"><vh>HtmlTPCantHappen</vh></v>
</v>
<v t="ekr.20041214071955.148"><vh>src/htmlurl.c</vh>
<v t="ekr.20041214071955.149"><vh>&lt;&lt; htmlurl #includes &gt;&gt;</vh></v>
<v t="ekr.20041214071955.150"><vh>&lt;&lt; htmlurl declarations &gt;&gt;</vh></v>
<v t="ekr.20041214071955.151"><vh>ComponentLength</vh></v>
<v t="ekr.20041214071955.152"><vh>StrNDup</vh></v>
<v t="ekr.20041214071955.153"><vh>ParseUri</vh></v>
<v t="ekr.20041214071955.154"><vh>FreeUri</vh></v>
<v t="ekr.20041214071955.155"><vh>BuildUri</vh></v>
<v t="ekr.20041214071955.156"><vh>ReplaceStr</vh></v>
<v t="ekr.20041214071955.157"><vh>Trim</vh></v>
<v t="ekr.20041214071955.158"><vh>HtmlCallResolver</vh></v>
<v t="ekr.20041214071955.159"><vh>HtmlResolveUri</vh></v>
</v>
<v t="ekr.20041214071955.160" a="TV"><vh>src/htmlwidget.c</vh>
<v t="ekr.20041214071955.161"><vh>&lt;&lt; htmlwidget #includes &gt;&gt;</vh></v>
<v t="ekr.20041214071955.162"><vh>&lt;&lt; htmlwidget declarations &gt;&gt;</vh></v>
<v t="ekr.20041214071955.163"><vh>HtmlConfigSpec</vh></v>
<v t="ekr.20041214071955.164"><vh>HtmlUsableWidth</vh></v>
<v t="ekr.20041214071955.165"><vh>HtmlUsableHeight</vh></v>
<v t="ekr.20041214071955.166"><vh>HtmlComputeVerticalPosition</vh></v>
<v t="ekr.20041214071955.167"><vh>HtmlComputeHorizontalPosition</vh></v>
<v t="ekr.20041214071955.168"><vh>ClearGcCache</vh></v>
<v t="ekr.20041214071955.169"><vh>HtmlCmdDeletedProc</vh></v>
<v t="ekr.20041214071955.170"><vh>ResetLayoutContext</vh></v>
<v t="ekr.20041214071955.171"><vh>HtmlRedrawCallback</vh></v>
<v t="ekr.20041214071955.172"><vh>HtmlScheduleRedraw</vh></v>
<v t="ekr.20041214071955.173"><vh>HtmlRedrawArea</vh></v>
<v t="ekr.20041214071955.174"><vh>HtmlRedrawBlock</vh></v>
<v t="ekr.20041214071955.175"><vh>HtmlRedrawEverything</vh></v>
<v t="ekr.20041214071955.176"><vh>HtmlRedrawPush</vh></v>
<v t="ekr.20041214071955.177"><vh>HtmlRedrawText</vh></v>
<v t="ekr.20041214071955.178"><vh>HtmlRecomputeGeometry</vh></v>
<v t="ekr.20041214071955.179"><vh>ConfigureHtmlWidget</vh></v>
<v t="ekr.20041214071955.180"><vh>HtmlDeleteElement</vh></v>
<v t="ekr.20041214071955.181"><vh>HtmlClear</vh></v>
<v t="ekr.20041214071955.182"><vh>DestroyHtmlWidget</vh></v>
<v t="ekr.20041214071955.183"><vh>HtmlUnlock</vh></v>
<v t="ekr.20041214071955.184"><vh>HtmlLock</vh></v>
<v t="ekr.20041214071955.185"><vh>HtmlIsDead</vh></v>
<v t="ekr.20041214071955.186"><vh>HtmlFlashCursor</vh></v>
<v t="ekr.20041214071955.187"><vh>HtmlGetGC</vh></v>
<v t="ekr.20041214071955.188"><vh>HtmlGetAnyGC</vh></v>
<v t="ekr.20041214071955.189"><vh>HtmlEventProc</vh></v>
<v t="ekr.20041214071955.190"><vh>HtmlGetFont</vh></v>
<v t="ekr.20041214071955.191"><vh>colorDistance</vh></v>
<v t="ekr.20041214071955.192"><vh>HtmlGetColorByName</vh></v>
<v t="ekr.20041214071955.193"><vh>isDarkColor</vh></v>
<v t="ekr.20041214071955.194"><vh>HtmlGetDarkShadowColor</vh></v>
<v t="ekr.20041214071955.195"><vh>isLightColor</vh></v>
<v t="ekr.20041214071955.196"><vh>HtmlGetLightShadowColor</vh></v>
<v t="ekr.20041214071955.197"><vh>GetColorByValue</vh></v>
<v t="ekr.20041214071955.198"><vh>HtmlGetHref</vh></v>
<v t="ekr.20041214071955.199"><vh>HtmlVerticalScroll</vh></v>
<v t="ekr.20041214071955.200"><vh>HtmlHorizontalScroll</vh></v>
<v t="ekr.20041214071955.201"><vh>HtmlWidgetCommand</vh></v>
<v t="ekr.20041214071955.202"><vh>HtmlCommand</vh></v>
<v t="ekr.20041214071955.203"><vh>Tkhtml_Init</vh></v>
</v>
<v t="ekr.20041214071955.204"><vh>src/htmlwish.c</vh>
<v t="ekr.20041214071955.205"><vh>&lt;&lt; htmlwish #includes &gt;&gt;</vh></v>
<v t="ekr.20041214071955.206"><vh>Et_AppInit</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20041214071955">@tabwidth -4
@language c</t>
<t tx="ekr.20041214071955.1">@language plain

# Copyright (C) 1997-2000 D. Richard Hipp
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
# 
# You should have received a copy of the GNU Library General Public
# License along with this library; if not, write to the
# Free Software Foundation, Inc., 59 Temple Place - Suite 330,
# Boston, MA  02111-1307, USA.
#
# Author contact information:
#   drh@acm.org
#   http://www.hwaci.com/drh/
</t>
<t tx="ekr.20041214071955.2">@language plain

# This file contains raw data used to build the "htmltokens.c" file.
# Each line contains 2 or 3 elements.  The first word on each line is
# the name of some HTML markup.  The second word is the amount of
# space to allocate for the corresponding element.  "0" appears if
# no extra space (beyond HtmlMarkup) is required.  If there is a
# corresponding end-tag, then the third column specifies the size of
# the end markup.
# $Revision: 1.8 $
# Order is not important.  Comments begin with #.  Spacing is ignored.

a               HtmlAnchor                     HtmlRef
address         0                              0
applet          HtmlInput                      0
area            0                              
b               0                              0
base            0                              
basefont        0                              0
bgsound         0                              
big             0                              0
blockquote      0                              0
body            0                              0
br              0                              
caption         0                              0
center          0                              0
cite            0                              0
code            0                              0
comment         0                              0
dd              HtmlRef                        0
dfn             0                              0
dir             HtmlListStart                  HtmlRef
div             0                              0
dl              HtmlListStart                  HtmlRef
dt              HtmlRef                        0
em              0                              0
embed           HtmlInput
font            0                              0
form            HtmlForm                       HtmlRef
frame           0                              0
frameset        0                              0
h1              0                              0
h2              0                              0
h3              0                              0
h4              0                              0
h5              0                              0
h6              0                              0
hr              HtmlHr                              
html            0                              0
i               0                              0
iframe          0
img             HtmlImageMarkup                
input           HtmlInput                      
isindex         0                              
kbd             0                              0
li              HtmlLi                         0
link            0                              
listing         0                              0
map             0                              0
marquee         0                              0
menu            HtmlListStart                  HtmlRef
meta            0                              
nextid          0                              
nobr            0                              0
noframe         0                              0
noscript        0                              0
ol              HtmlListStart                  HtmlRef
option          0                              0
p               0                              0
param           0                              0
plaintext       0                              
pre             0                              0
s               0                              0
samp            0                              0
script          HtmlScript
select          HtmlInput                      HtmlRef
small           0                              0
strike          0                              0
strong          0                              0
style           HtmlScript
sub             0                              0
sup             0                              0
table           HtmlTable                      HtmlRef
td              HtmlCell                       HtmlRef
textarea        HtmlInput                      HtmlRef
th              HtmlCell                       HtmlRef
title           0                              0
tr              HtmlRef                        HtmlRef
tt              0                              0
u               0                              0
ul              HtmlListStart                  HtmlRef
var             0                              0
wbr             0                              
xmp             0                              0
</t>
<t tx="ekr.20041214071955.3">@ignore
/*
** Structures and typedefs used by the HTML widget
** $Revision: 1.28 $
*/

@others

</t>
<t tx="ekr.20041214071955.4">/*
** Debug must be turned on for testing to work.
*/
#define DEBUG 1</t>
<t tx="ekr.20041214071955.5">/*
** Version information for the package mechanism.
*/
#define HTML_PKGNAME "Tkhtml"
#define HTML_PKGVERSION "0.0"

</t>
<t tx="ekr.20041214071955.6">#ifdef DEBUG
#define HtmlAssert(X) \
  if(!(X)){ \
    fprintf(stderr,"Assertion failed on line %d of %s\n",__LINE__,__FILE__); \
  }
#define HtmlCantHappen \
  fprintf(stderr,"Can't happen on line %d of %s\n",__LINE__,__FILE__);
#else
#define HtmlAssert(X)
#define HtmlCantHappen
#endif</t>
<t tx="ekr.20041214071955.7">/*
** The TRACE macro is used to print internal information about the
** HTML layout engine during testing and debugging.  The amount of
** information printed is governed by a global variable named
** HtmlTraceMask.  If bits in the first argument to the TRACE macro
** match any bits in HtmlTraceMask variable, then the trace message
** is printed.
**
** All of this is completely disabled, of course, if the DEBUG macro
** is not defined.
*/
#ifdef DEBUG
# define TRACE_INDENT  printf("%*s",HtmlDepth-3,"")
# define TRACE(Flag, Args) \
    if( (Flag)&amp;HtmlTraceMask ){ \
       TRACE_INDENT; printf Args; fflush(stdout); \
    }
# define TRACE_PUSH(Flag)  if( (Flag)&amp;HtmlTraceMask ){ HtmlDepth+=3; }
# define TRACE_POP(Flag)   if( (Flag)&amp;HtmlTraceMask ){ HtmlDepth-=3; }
#else
# define TRACE_INDENT
# define TRACE(Flag, Args)
# define TRACE_PUSH(Flag)
# define TRACE_POP(Flag)
#endif

/*
** Bitmasks for the HtmlTraceMask global variable
*/
#define HtmlTrace_Table1       0x00000001
#define HtmlTrace_Table2       0x00000002
#define HtmlTrace_Table3       0x00000004
#define HtmlTrace_Table4       0x00000008
#define HtmlTrace_Table5       0x00000010
#define HtmlTrace_Table6       0x00000020
#define HtmlTrace_GetLine      0x00000100
#define HtmlTrace_GetLine2     0x00000200
#define HtmlTrace_FixLine      0x00000400
#define HtmlTrace_BreakMarkup  0x00001000
#define HtmlTrace_Style        0x00002000
#define HtmlTrace_Input1       0x00004000</t>
<t tx="ekr.20041214071955.8">/*
** Macros to allocate and free memory.
*/
#define HtmlAlloc(A)      ((void*)Tcl_Alloc(A))
#define HtmlFree(A)       Tcl_Free((char*)(A))
#define HtmlRealloc(A,B)  ((void*)Tcl_Realloc((A),(B)))

</t>
<t tx="ekr.20041214071955.9">/*
** Various data types.  This code is designed to run on a modern
** cached architecture where the CPU runs a lot faster than the
** memory bus.  Hence we try to pack as much data into as small a space
** as possible so that it is more likely to fit in cache.  The
** extra CPU instruction or two needed to unpack the data is not
** normally an issue since we expect the speed of the memory bus 
** to be the limiting factor.
*/
typedef unsigned char  Html_u8;      /* 8-bit unsigned integer */
typedef short          Html_16;      /* 16-bit signed integer */
typedef unsigned short Html_u16;     /* 16-bit unsigned integer */
typedef int            Html_32;      /* 32-bit signed integer */

</t>
<t tx="ekr.20041214071955.10">/*
** An instance of the following structure is used to record style
** information on each Html element.
*/
struct HtmlStyle {
  unsigned int font    : 6;      /* Font to use for display */
  unsigned int color   : 4;      /* Foreground color */
  signed int subscript : 4;      /* Positive for &lt;sup&gt;, negative for &lt;sub&gt; */
  unsigned int align   : 2;      /* Horizontal alignment */
  unsigned int bgcolor : 4;      /* Background color */
  unsigned int flags   : 12;     /* the STY_ flags below */
}

/*
** We allow 8 different font families:  Normal, Bold, Italic and 
** Bold-Italic in either variable or constant width.
** Within each family there can be up to 7 font sizes from 1
** (the smallest) up to 7 (the largest).  Hence, the widget can use
** a maximum of 56 fonts.  The ".font" field of the style is an integer
** between 0 and 55 which indicates which font to use.
*/
#define N_FONT_FAMILY     8
#define N_FONT_SIZE       7
#define N_FONT            (N_FONT_FAMILY*N_FONT_SIZE)
#define NormalFont(X)     (X)
#define BoldFont(X)       ((X)+N_FONT_SIZE)
#define ItalicFont(X)     ((X)+2*N_FONT_SIZE)
#define CWFont(X)         ((X)+4*N_FONT_SIZE)
#define FontSize(X)       ((X)%N_FONT_SIZE)
#define FontFamily(X)     (((X)/N_FONT_SIZE)*N_FONT_SIZE)
#define FONT_Any           -1
#define FONT_Default      3
#define FontSwitch(Size, Bold, Italic, Cw) \
                          ((Size)+(Bold+(Italic)*2+(Cw)*4)*N_FONT_SIZE)

/*
** Macros for manipulating the fontValid bitmap of an HtmlWidget structure.
*/
#define FontIsValid(H,I)     (((H)-&gt;fontValid[(I)&gt;&gt;3] &amp; (1&lt;&lt;((I)&amp;3)))!=0)
#define FontSetValid(H,I)    ((H)-&gt;fontValid[(I)&gt;&gt;3] |= (1&lt;&lt;((I)&amp;3)))
#define FontClearValid(H,I)  ((H)-&gt;fontValid[(I)&gt;&gt;3] &amp;= ~(1&lt;&lt;((I)&amp;3)))

/*
** Information about available colors.
**
** The widget will use at most N_COLOR colors.  4 of these colors
** are predefined.  The rest are user selectable by options to
** various markups. (Ex:  &lt;font color=red&gt;)
**
** All colors are stored in the apColor[] array of the main widget
** structure.  The ".color" field of the HtmlStyle is an integer
** between 0 and N_COLOR-1 which indicates which of these colors 
** to use.
*/
#define N_COLOR             16      /* Total number of colors */
#define COLOR_Normal         0      /* Index for normal color (black) */
#define COLOR_Unvisited      1      /* Index for unvisited hyperlinks */
#define COLOR_Visited        2      /* Color for visited hyperlinks */
#define COLOR_Selection      3      /* Background color for the selection */
#define COLOR_Background     4      /* Default background color */
#define N_PREDEFINED_COLOR   5      /* Number of predefined colors */

/*
** The "align" field of the style determines how text is justified
** horizontally.  ALIGN_None means that the alignment is not specified.
** (It should probably default to ALIGN_Left in this case.)
*/
#define ALIGN_Left   1
#define ALIGN_Right  2
#define ALIGN_Center 3
#define ALIGN_None   0

/*
** Possible value of the "flags" field of HtmlStyle are shown below.
**
**  STY_Preformatted       If set, the current text occurred within
**                         &lt;pre&gt;..&lt;/pre&gt;
**
**  STY_StrikeThru         Draw a solid line thru the middle of this text.
**
**  STY_Underline          This text should drawn with an underline.
**
**  STY_NoBreak            This text occurs within &lt;nobr&gt;..&lt;/nobr&gt;
**
**  STY_Anchor             This text occurs within &lt;a href=X&gt;..&lt;/a&gt;.
**
**  STY_DT                 This text occurs within &lt;dt&gt;..&lt;/dt&gt;.                 
**
**  STY_Invisible          This text should not appear in the main HTML
**                         window.  (For example, it might be within 
**                         &lt;title&gt;..&lt;/title&gt; or &lt;marquee&gt;..&lt;/marquee&gt;.)
*/
#define STY_Preformatted    0x001
#define STY_StrikeThru      0x002
#define STY_Underline       0x004
#define STY_NoBreak         0x008
#define STY_Anchor          0x010
#define STY_DT              0x020
#define STY_Invisible       0x040
#define STY_FontMask        (STY_StrikeThru|STY_Underline)</t>
<t tx="ekr.20041214071955.11">/*
** The first thing done with input HTML text is to parse it into
** HtmlElements.  All sizing and layout is done using these elements,
** so this is a very important structure.
**
** Elements are designed so that the common ones (Text and Space)
** require as little storage as possible, in order to increase
** the chance of memory cache hits.  (Turns out I didn't do a
** very good job of this.  This widget is a pig for memory.  But
** the speed is good, so I'm not going to change it right now...)
**
** Some elements require more memory than Text and Space (ex: &lt;IMG&gt;).
** An HtmlElement is therefore represented as a union of many other 
** structures all of different sizes.  That way we can have a pointer 
** to a generic element without having to worry about how big that 
** element is.  The ".base.type" field (which is found in all elements) 
** will tell us what type of element we are dealing with.
**
** NOTE:  This trick will only work on compilers that align all elements
** of a union to the lowest memory address in that union.  This is true
** for every C compiler I've ever seen, but isn't guarenteed for ANSI-C.
*/
union HtmlElement {
  HtmlElement *pNext;
  HtmlBaseElement base;
  HtmlTextElement text;
  HtmlSpaceElement space;
  HtmlMarkupElement markup;
  HtmlCell cell;
  HtmlTable table;
  HtmlRef ref;
  HtmlLi li;
  HtmlListStart list;
  HtmlImageMarkup image;
  HtmlInput input;
  HtmlForm form;
  HtmlHr hr;
  HtmlAnchor anchor;
  HtmlScript script;
  HtmlBlock block;
};

</t>
<t tx="ekr.20041214071955.13">@language c
static char const rcsid[] = "@(#) $Id: htmlcmd.c,v 1.18 2000/02/25 02:19:29 drh Exp $";

// Routines to implement the HTML widget commands

#include &lt;tk.h&gt;
#include &lt;stdlib.h&gt;
#include "htmlcmd.h"

@others

</t>
<t tx="ekr.20041214071955.15">@ ** WIDGET resolve ?URI ...? ** ** Call the TCL command specified by the -resolvercommand option ** to resolve the URL.
@c

int HtmlResolveCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv            /* List of all arguments */
){
  return HtmlCallResolver(htmlPtr, argv+2);
}
</t>
<t tx="ekr.20041214071955.16">@ ** WIDGET cget CONFIG-OPTION ** ** Retrieve the value of a configuration option
@c

int HtmlCgetCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv            /* List of all arguments */
){
  TestPoint(0);
  return Tk_ConfigureValue(interp, htmlPtr-&gt;tkwin, HtmlConfigSpec(),
		(char *) htmlPtr, argv[2], 0);
}
</t>
<t tx="ekr.20041214071955.17">@ ** WIDGET clear ** ** Erase all HTML from this widget and clear the screen. This is ** typically done before loading a new document.
@c

int HtmlClearCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv            /* List of all arguments */
){
  HtmlClear(htmlPtr);
  htmlPtr-&gt;flags |= REDRAW_TEXT | VSCROLL | HSCROLL;
  HtmlScheduleRedraw(htmlPtr);
  TestPoint(0);
  return TCL_OK;
}
</t>
<t tx="ekr.20041214071955.18">@ ** WIDGET configure ?OPTIONS? ** ** The standard Tk configure command.
@c

int HtmlConfigCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv            /* List of all arguments */
){
  if (argc == 2) {
     TestPoint(0);
     return Tk_ConfigureInfo(interp, htmlPtr-&gt;tkwin, HtmlConfigSpec(),
        (char *) htmlPtr, (char *) NULL, 0);
  } else if (argc == 3) {
     TestPoint(0);
     return Tk_ConfigureInfo(interp, htmlPtr-&gt;tkwin, HtmlConfigSpec(),
        (char *) htmlPtr, argv[2], 0);
  } else {
     TestPoint(0);
     return ConfigureHtmlWidget(interp, htmlPtr, argc-2, argv+2,
                                TK_CONFIG_ARGV_ONLY, 0);
  }
}
</t>
<t tx="ekr.20041214071955.19">@ ** WIDGET href X Y ** ** Returns the URL on the hyperlink that is beneath the position X,Y. ** Returns {} if there is no hyperlink beneath X,Y.
@c

int HtmlHrefCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv            /* List of all arguments */
){
  int x, y;
  char *z;

  if( Tcl_GetInt(interp, argv[2], &amp;x) != TCL_OK 
   || Tcl_GetInt(interp, argv[3], &amp;y) != TCL_OK
  ){
    TestPoint(0);
    return TCL_ERROR;
  }
  z = HtmlGetHref(htmlPtr, x + htmlPtr-&gt;xOffset, y + htmlPtr-&gt;yOffset);
  if( z ){
    HtmlLock(htmlPtr);
    z = HtmlResolveUri(htmlPtr, z);
    if( !HtmlUnlock(htmlPtr) ){
      Tcl_SetResult(interp, z, TCL_DYNAMIC);
    }
  }
  return TCL_OK;
}
</t>
<t tx="ekr.20041214071955.20">@ ** WIDGET names ** ** Returns a list of names associated with &lt;a name=...&gt; tags.
@c

int HtmlNamesCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv            /* List of all arguments */
){
  HtmlElement *p;
  char *z;
  TestPoint(0);
  for(p=htmlPtr-&gt;pFirst; p; p=p-&gt;pNext){
    if( p-&gt;base.type!=Html_A ) continue;
    z = HtmlMarkupArg(p,"name",0);
    if( z ){
      Tcl_AppendElement(interp,z);
    }else{
      z = HtmlMarkupArg(p,"id",0);
      if( z ){
        Tcl_AppendElement(interp,z);
      }
    }
  }
  return TCL_OK;
}
</t>
<t tx="ekr.20041214071955.21">@ ** WIDGET parse HTML ** ** Appends the given HTML text to the end of any HTML text that may have ** been inserted by prior calls to this command. Then it runs the ** tokenizer, parser and layout engine as far as possible with the ** text that is available. The display is updated appropriately.
@c

int HtmlParseCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv            /* List of all arguments */
){
  HtmlElement *endPtr;
  endPtr = htmlPtr-&gt;pLast;
  HtmlLock(htmlPtr);
  HtmlTokenizerAppend(htmlPtr, argv[2]);
  if( HtmlIsDead(htmlPtr) ){
    return TCL_OK;
  }
  if( endPtr ){
    if( endPtr-&gt;pNext ){
      HtmlAddStyle(htmlPtr, endPtr-&gt;pNext);
    }
  }else if( htmlPtr-&gt;pFirst ){
    htmlPtr-&gt;paraAlignment = ALIGN_None;
    htmlPtr-&gt;rowAlignment = ALIGN_None;
    htmlPtr-&gt;anchorFlags = 0;
    htmlPtr-&gt;inDt = 0;
    htmlPtr-&gt;anchorStart = 0;
    htmlPtr-&gt;formStart = 0;
    htmlPtr-&gt;innerList = 0;
    HtmlAddStyle(htmlPtr, htmlPtr-&gt;pFirst);
    TestPoint(0);
  }
  if( !HtmlUnlock(htmlPtr) ){
    htmlPtr-&gt;flags |= EXTEND_LAYOUT;
    HtmlScheduleRedraw(htmlPtr);
    TestPoint(0);
  }
  return TCL_OK;
}
</t>
<t tx="ekr.20041214071955.22">@ ** WIDGET xview ?SCROLL-OPTIONS...? ** ** Implements horizontal scrolling in the usual Tk way.
@c

int HtmlXviewCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv            /* List of all arguments */
){
  if( argc==2 ){
    HtmlComputeHorizontalPosition(htmlPtr,interp-&gt;result);
    TestPoint(0);
  }else{
    int count;
    double fraction;
    int maxX = htmlPtr-&gt;maxX;
    int w = HtmlUsableWidth(htmlPtr);
    int offset = htmlPtr-&gt;xOffset;
    int type = Tk_GetScrollInfo(interp,argc,argv,&amp;fraction,&amp;count);
    switch( type ){
      case TK_SCROLL_ERROR:
        TestPoint(0);
        return TCL_ERROR;
      case TK_SCROLL_MOVETO:
        offset = fraction * maxX;
        TestPoint(0);
        break;
      case TK_SCROLL_PAGES:
        offset += (count * w * 9)/10;
        TestPoint(0);
        break;
      case TK_SCROLL_UNITS:
        offset += (count * w)/10;
        TestPoint(0);
        break;
    }
    if( offset + w &gt; maxX ){
      offset = maxX - w;
      TestPoint(0);
    }else{
      TestPoint(0);
    }
    if( offset &lt; 0 ){
      offset = 0;
      TestPoint(0);
    }else{
      TestPoint(0);
    }
    HtmlHorizontalScroll(htmlPtr, offset);
  }
  return TCL_OK;
}
</t>
<t tx="ekr.20041214071955.23">@ ** WIDGET yview ?SCROLL-OPTIONS...? ** ** Implements vertical scrolling in the usual Tk way, but with one ** enhancement. If the argument is a single word, the widget looks ** for a &lt;a name=...&gt; tag with that word as the "name" and scrolls ** to the position of that tag.
@c

int HtmlYviewCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv            /* List of all arguments */
){
  if( argc==2 ){
    HtmlComputeVerticalPosition(htmlPtr,interp-&gt;result);
    TestPoint(0);
  }else if( argc==3 ){
    char *z;
    HtmlElement *p;
    for(p=htmlPtr-&gt;pFirst; p; p=p-&gt;pNext){
      if( p-&gt;base.type!=Html_A ) continue;
      z = HtmlMarkupArg(p,"name",0);
      if( z==0 ){
        TestPoint(0);
        continue;
      }
      if( strcmp(z,argv[2])!=0 ){
        TestPoint(0);
        continue;
      }
      HtmlVerticalScroll(htmlPtr, p-&gt;anchor.y);
      TestPoint(0);
      break;
    }
  }else{
    int count;
    double fraction;
    int maxY = htmlPtr-&gt;maxY;
    int h = HtmlUsableHeight(htmlPtr);
    int offset = htmlPtr-&gt;yOffset;
    int type = Tk_GetScrollInfo(interp,argc,argv,&amp;fraction,&amp;count);
    switch( type ){
      case TK_SCROLL_ERROR:
        TestPoint(0);
        return TCL_ERROR;
      case TK_SCROLL_MOVETO:
        offset = fraction * maxY;
        TestPoint(0);
        break;
      case TK_SCROLL_PAGES:
        offset += (count * h * 9)/10;
        TestPoint(0);
        break;
      case TK_SCROLL_UNITS:
        offset += (count * h)/10;
        TestPoint(0);
        break;
    }
    if( offset + h &gt; maxY ){
      offset = maxY - h;
      TestPoint(0);
    }else{
      TestPoint(0);
    }
    if( offset &lt; 0 ){
      offset = 0;
      TestPoint(0);
    }else{
      TestPoint(0);
    }
    HtmlVerticalScroll(htmlPtr, offset);
  }
  return TCL_OK;
}
</t>
<t tx="ekr.20041214071955.24">@ ** WIDGET token handler TAG ?SCRIPT?
@c

int HtmlTokenHandlerCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv            /* List of all arguments */
){
  int type = HtmlNameToType(argv[3]);
  if( type==Html_Unknown ){
    Tcl_AppendResult(interp,"unknown tag: \"", argv[3], "\"", 0);
    return TCL_ERROR;
  }
  if( argc==4 ){
    if( htmlPtr-&gt;zHandler[type]!=0 ){
      interp-&gt;result = htmlPtr-&gt;zHandler[type];
    }
  }else{
    if( htmlPtr-&gt;zHandler[type]!=0 ){
      HtmlFree(htmlPtr-&gt;zHandler[type]);
    }
    htmlPtr-&gt;zHandler[type] = HtmlAlloc( strlen(argv[4]) + 1 );
    if( htmlPtr-&gt;zHandler[type] ){
      strcpy(htmlPtr-&gt;zHandler[type],argv[4]);
    }
  }
  return TCL_OK;
}
</t>
<t tx="ekr.20041214071955.25">@ ** WIDGET index INDEX
@c

int HtmlIndexCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv            /* List of all arguments */
){
  HtmlElement *p;
  int i;

  HtmlLock(htmlPtr);
  if( HtmlGetIndex(htmlPtr, argv[2], &amp;p, &amp;i)!=0 ){
    if( !HtmlUnlock(htmlPtr) ){
      Tcl_AppendResult(interp,"malformed index: \"", argv[2], "\"", 0);
    }
    TestPoint(0);
    return TCL_ERROR;
  }
  if( !HtmlUnlock(htmlPtr) &amp;&amp; p ){
    sprintf(interp-&gt;result, "%d.%d", HtmlTokenNumber(p), i);
    TestPoint(0);
  }else{
    TestPoint(0);
  }
  return TCL_OK;
}
</t>
<t tx="ekr.20041214071955.26">@ The pSelStartBlock and pSelEndBlock values have been changed. ** This routine's job is to loop over all HtmlBlocks and either ** set or clear the HTML_Selected bits in the .base.flags field ** as appropriate. For every HtmlBlock where the bit changes, ** mark that block for redrawing.
@c

static void UpdateSelection(HtmlWidget *htmlPtr){
  int selected = 0;
  HtmlIndex tempIndex;
  HtmlBlock *pTempBlock;
  int temp;
  HtmlBlock *p;

  for(p=htmlPtr-&gt;firstBlock; p; p=p-&gt;pNext){
    if( p==htmlPtr-&gt;pSelStartBlock ){
      selected = 1;
      HtmlRedrawBlock(htmlPtr, p);
      TestPoint(0);
    }else if( !selected &amp;&amp; p==htmlPtr-&gt;pSelEndBlock ){
      selected = 1;
      tempIndex = htmlPtr-&gt;selBegin;
      htmlPtr-&gt;selBegin = htmlPtr-&gt;selEnd;
      htmlPtr-&gt;selEnd = tempIndex;
      pTempBlock = htmlPtr-&gt;pSelStartBlock;
      htmlPtr-&gt;pSelStartBlock = htmlPtr-&gt;pSelEndBlock;
      htmlPtr-&gt;pSelEndBlock = pTempBlock;
      temp = htmlPtr-&gt;selStartIndex;
      htmlPtr-&gt;selStartIndex = htmlPtr-&gt;selEndIndex;
      htmlPtr-&gt;selEndIndex = temp;
      HtmlRedrawBlock(htmlPtr, p);
      TestPoint(0);
    }else{
      TestPoint(0);
    }
    if( p-&gt;base.flags &amp; HTML_Selected ){
      if( !selected ){
        p-&gt;base.flags &amp;= ~HTML_Selected;
        HtmlRedrawBlock(htmlPtr,p);
        TestPoint(0);
      }else{
        TestPoint(0);
      }
    }else{
      if( selected ){
        p-&gt;base.flags |= HTML_Selected;
        HtmlRedrawBlock(htmlPtr,p);
        TestPoint(0);
      }else{
        TestPoint(0);
      }
    }
    if( p==htmlPtr-&gt;pSelEndBlock ){
      selected = 0;
      HtmlRedrawBlock(htmlPtr, p);
      TestPoint(0);
    }else{
      TestPoint(0);
    }
  }
}
</t>
<t tx="ekr.20041214071955.27">@ Given the selection end-points in htmlPtr-&gt;selBegin ** and htmlPtr-&gt;selEnd, recompute pSelBeginBlock and ** pSelEndBlock, then call UpdateSelection to update the ** display. ** ** This routine should be called whenever the selection ** changes or whenever the set of HtmlBlock structures ** change.
@c

void HtmlUpdateSelection(HtmlWidget *htmlPtr, int forceUpdate){
  HtmlBlock *pBlock;
  int index;
  int needUpdate = forceUpdate;
  int temp;

  if( htmlPtr-&gt;selEnd.p==0 ){
    htmlPtr-&gt;selBegin.p = 0;
    TestPoint(0);
  }else{
    TestPoint(0);
  }
  HtmlIndexToBlockIndex(htmlPtr, htmlPtr-&gt;selBegin, &amp;pBlock, &amp;index);
  if( needUpdate || pBlock != htmlPtr-&gt;pSelStartBlock ){
    needUpdate = 1;
    HtmlRedrawBlock(htmlPtr, htmlPtr-&gt;pSelStartBlock);
    htmlPtr-&gt;pSelStartBlock = pBlock;
    htmlPtr-&gt;selStartIndex = index;
    TestPoint(0);
  }else if( index != htmlPtr-&gt;selStartIndex ){
    HtmlRedrawBlock(htmlPtr, pBlock);
    htmlPtr-&gt;selStartIndex = index;
    TestPoint(0);
  }else{
    TestPoint(0);
  }
  if( htmlPtr-&gt;selBegin.p==0 ){
    htmlPtr-&gt;selEnd.p = 0;
    TestPoint(0);
  }else{
    TestPoint(0);
  }
  HtmlIndexToBlockIndex(htmlPtr, htmlPtr-&gt;selEnd, &amp;pBlock, &amp;index);
  if( needUpdate || pBlock != htmlPtr-&gt;pSelEndBlock ){
    needUpdate = 1;
    HtmlRedrawBlock(htmlPtr, htmlPtr-&gt;pSelEndBlock);
    htmlPtr-&gt;pSelEndBlock = pBlock;
    htmlPtr-&gt;selEndIndex = index;
    TestPoint(0);
  }else if( index != htmlPtr-&gt;selEndIndex ){
    HtmlRedrawBlock(htmlPtr, pBlock);
    htmlPtr-&gt;selEndIndex = index;
    TestPoint(0);
  }else{
    TestPoint(0);
  }
  if( htmlPtr-&gt;pSelStartBlock 
  &amp;&amp; htmlPtr-&gt;pSelStartBlock==htmlPtr-&gt;pSelEndBlock
  &amp;&amp; htmlPtr-&gt;selStartIndex &gt; htmlPtr-&gt;selEndIndex
  ){
    temp = htmlPtr-&gt;selStartIndex;
    htmlPtr-&gt;selStartIndex = htmlPtr-&gt;selEndIndex;
    htmlPtr-&gt;selEndIndex = temp;
    TestPoint(0);
  }else{
    TestPoint(0);
  }
  if( needUpdate ){
    UpdateSelection(htmlPtr);
    TestPoint(0);
  }else{
    TestPoint(0);
  }
}
</t>
<t tx="ekr.20041214071955.28">@ ** WIDGET selection set INDEX INDEX
@c

int HtmlSelectionSetCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv           /* List of all arguments */
){
  HtmlIndex selBegin, selEnd;

  HtmlLock(htmlPtr);
  if( HtmlGetIndex(htmlPtr, argv[3], &amp;selBegin.p, &amp;selBegin.i) ){
    if( !HtmlUnlock(htmlPtr) ){
      Tcl_AppendResult(interp,"malformed index: \"", argv[3], "\"", 0);
    }
    TestPoint(0);
    return TCL_ERROR;
  }
  if( HtmlIsDead(htmlPtr) ) return TCL_OK;
  if( HtmlGetIndex(htmlPtr, argv[4], &amp;selEnd.p, &amp;selEnd.i) ){
    if( !HtmlUnlock(htmlPtr) ){
      Tcl_AppendResult(interp,"malformed index: \"", argv[4], "\"", 0);
    }
    TestPoint(0);
    return TCL_ERROR;
  }
  if( HtmlUnlock(htmlPtr) ) return TCL_OK;
  htmlPtr-&gt;selBegin = selBegin;
  htmlPtr-&gt;selEnd = selEnd;
  HtmlUpdateSelection(htmlPtr,0);
  TestPoint(0);
  return TCL_OK;
}
</t>
<t tx="ekr.20041214071955.29">@ ** WIDGET selection clear
@c

int HtmlSelectionClearCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv           /* List of all arguments */
){
  htmlPtr-&gt;pSelStartBlock = 0;
  htmlPtr-&gt;pSelEndBlock = 0;
  htmlPtr-&gt;selBegin.p = 0;
  htmlPtr-&gt;selEnd.p = 0;
  UpdateSelection(htmlPtr);
  TestPoint(0);
  return TCL_OK;
}
</t>
<t tx="ekr.20041214071955.30">@ ** Recompute the position of the insertion cursor based on the ** position in htmlPtr-&gt;ins.
@c

void HtmlUpdateInsert(HtmlWidget *htmlPtr){
  HtmlIndexToBlockIndex(htmlPtr, htmlPtr-&gt;ins, 
                        &amp;htmlPtr-&gt;pInsBlock, &amp;htmlPtr-&gt;insIndex);
  HtmlRedrawBlock(htmlPtr, htmlPtr-&gt;pInsBlock);
  if( htmlPtr-&gt;insTimer==0 ){
    htmlPtr-&gt;insStatus = 0;
    HtmlFlashCursor(htmlPtr);
    TestPoint(0);
  }else{
    TestPoint(0);
  }
}
</t>
<t tx="ekr.20041214071955.31">@ ** WIDGET insert INDEX
@c

int HtmlInsertCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv           /* List of all arguments */
){
  HtmlIndex ins;
  if( argv[2][0]==0 ){
    HtmlRedrawBlock(htmlPtr, htmlPtr-&gt;pInsBlock);
    htmlPtr-&gt;insStatus = 0;
    htmlPtr-&gt;pInsBlock = 0;
    htmlPtr-&gt;ins.p = 0;
    TestPoint(0);
  }else{
    HtmlLock(htmlPtr);
    if( HtmlGetIndex(htmlPtr, argv[2], &amp;ins.p, &amp;ins.i) ){
      if( !HtmlUnlock(htmlPtr) ){
        Tcl_AppendResult(interp,"malformed index: \"", argv[2], "\"", 0);
      }
      TestPoint(0);
      return TCL_ERROR;
    }
    if( HtmlUnlock(htmlPtr) ) return TCL_OK;
    HtmlRedrawBlock(htmlPtr, htmlPtr-&gt;pInsBlock);
    htmlPtr-&gt;ins = ins;
    HtmlUpdateInsert(htmlPtr);
    TestPoint(0);
  }
  return TCL_OK;
}
</t>
<t tx="ekr.20041214071955.32">@ ** WIDGET token list START END
@c

int HtmlTokenListCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv            /* List of all arguments */
){
  HtmlElement *pStart, *pEnd;
  int i;

  if( HtmlGetIndex(htmlPtr, argv[3], &amp;pStart, &amp;i)!=0 ){
    Tcl_AppendResult(interp,"malformed index: \"", argv[3], "\"", 0);
    return TCL_ERROR;
  }
  if( HtmlGetIndex(htmlPtr, argv[4], &amp;pEnd, &amp;i)!=0 ){
    Tcl_AppendResult(interp,"malformed index: \"", argv[4], "\"", 0);
    return TCL_ERROR;
  }
  if( pStart ){
    HtmlTclizeList(interp,pStart,pEnd ? pEnd-&gt;base.pNext : 0);
  }
  return TCL_OK;
}
</t>
<t tx="ekr.20041214071955.33">
/*
** WIDGET debug dump START END
*/
int HtmlDebugDumpCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv            /* List of all arguments */
){
  HtmlElement *pStart, *pEnd;
  int i;

  if( HtmlGetIndex(htmlPtr, argv[3], &amp;pStart, &amp;i)!=0 ){
    Tcl_AppendResult(interp,"malformed index: \"", argv[3], "\"", 0);
    return TCL_ERROR;
  }
  if( HtmlGetIndex(htmlPtr, argv[4], &amp;pEnd, &amp;i)!=0 ){
    Tcl_AppendResult(interp,"malformed index: \"", argv[4], "\"", 0);
    return TCL_ERROR;
  }
  if( pStart ){
    HtmlPrintList(pStart,pEnd ? pEnd-&gt;base.pNext : 0);
  }
  return TCL_OK;
}
</t>
<t tx="ekr.20041214071955.34">// WIDGET debug testpt FILENAME

int HtmlDebugTestPtCmd(
  HtmlWidget *htmlPtr,   /* The HTML widget */
  Tcl_Interp *interp,    /* The interpreter */
  int argc,              /* Number of arguments */
  char **argv            /* List of all arguments */
){
  HtmlTestPointDump(argv[3]);
  return TCL_OK;
}
</t>
<t tx="ekr.20041214071955.35">@ignore
@language c
static char const rcsid[] = "@(#) $Id: htmldraw.c,v 1.24 2000/01/31 13:23:46 drh Exp $";

// Routines used to render HTML onto the screen for the Tk HTML widget.

#include &lt;tk.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include "htmldraw.h"

#ifdef USE_TK_STUBS
# include &lt;tkIntXlibDecls.h&gt;
#endif

#define USE_TK_DRAWCHARS 1

@others
</t>
<t tx="ekr.20041214071955.37">/*
** Allocate a new HtmlBlock structure.
*/
static HtmlBlock *AllocBlock(void){
  HtmlBlock *pNew;

  pNew = HtmlAlloc( sizeof(HtmlBlock) );
  if( pNew ){
    memset(pNew, 0, sizeof(*pNew));
    pNew-&gt;base.type = Html_Block;
  }
  return pNew;
}
</t>
<t tx="ekr.20041214071955.38">@ ** Free an HtmlBlock structure. Assume that it is already unlinked ** from the element list and the block list.
@c

static void FreeBlock(HtmlBlock *pBlock){
  if( pBlock ){
    if( pBlock-&gt;z ){
      HtmlFree(pBlock-&gt;z);
    }
    HtmlFree(pBlock);
  }
}
</t>
<t tx="ekr.20041214071955.39">@ ** Destroy the given Block after first unlinking it from the ** element list. Note that this unlinks the block from the ** element list only -- not from the block list.
@c

static void UnlinkAndFreeBlock(HtmlWidget *htmlPtr, HtmlBlock *pBlock){
  if( pBlock-&gt;base.pNext ){
    pBlock-&gt;base.pNext-&gt;base.pPrev = pBlock-&gt;base.pPrev;
    TestPoint(0);
  }else{
    htmlPtr-&gt;pLast = pBlock-&gt;base.pPrev;
    TestPoint(0);
  }
  if( pBlock-&gt;base.pPrev ){
    pBlock-&gt;base.pPrev-&gt;base.pNext = pBlock-&gt;base.pNext;
    TestPoint(0);
  }else{
    htmlPtr-&gt;pFirst = pBlock-&gt;base.pNext;
    TestPoint(0);
  }
  pBlock-&gt;base.pPrev = pBlock-&gt;base.pNext = 0;
  FreeBlock(pBlock);
}
</t>
<t tx="ekr.20041214071955.40">@ ** Append a block to the block list and insert the block into the ** element list immediately prior to the element given.
@c

static void AppendBlock(
  HtmlWidget *htmlPtr,     /* The HTML widget */
  HtmlElement *pToken,     /* The token that comes after pBlock */
  HtmlBlock *pBlock        /* The block to be appended */
){
  pBlock-&gt;base.pPrev = pToken-&gt;base.pPrev;
  pBlock-&gt;base.pNext = pToken;
  pBlock-&gt;pPrev = htmlPtr-&gt;lastBlock;
  pBlock-&gt;pNext = 0;
  if( htmlPtr-&gt;lastBlock ){
    htmlPtr-&gt;lastBlock-&gt;pNext = pBlock;
    TestPoint(0);
  }else{
    htmlPtr-&gt;firstBlock = pBlock;
    TestPoint(0);
  }
  htmlPtr-&gt;lastBlock = pBlock;
  if( pToken-&gt;base.pPrev ){
    pToken-&gt;base.pPrev-&gt;base.pNext = (HtmlElement*)pBlock;
    TestPoint(0);
  }else{
    htmlPtr-&gt;pFirst = (HtmlElement*)pBlock;
    TestPoint(0);
  }
  pToken-&gt;base.pPrev = (HtmlElement*)pBlock;
}
</t>
<t tx="ekr.20041214071955.41">@ ** Print an ordered list index into the given buffer. Use numbering ** like this: ** **   A B C ... Y Z AA BB CC ... ZZ ** ** Revert to decimal for indices greater than 52.
@c

static void GetLetterIndex(char *zBuf, int index, int isUpper){
  int seed;
  if( index&lt;1 || index&gt;52 ){
    sprintf(zBuf,"%d",index);
    TestPoint(0);
    return;
  }
  if( isUpper ){
    seed = 'A';
    TestPoint(0);
  }else{
    seed = 'a';
    TestPoint(0);
  }
  index--;
  if( index&lt;26 ){
    zBuf[0] = seed + index;
    zBuf[1] = 0;
    TestPoint(0);
  }else{
    index -= 26;
    zBuf[0] = seed + index;
    zBuf[1] = seed + index;
    zBuf[2] = 0;
    TestPoint(0);
  }
  strcat(zBuf,".");
}
</t>
<t tx="ekr.20041214071955.42">@ ** Print an ordered list index into the given buffer. Use roman ** numerals. For indices greater than a few thousand, revert to ** decimal.
@c

static void GetRomanIndex(char *zBuf, int index, int isUpper){
  int i = 0;
  int j;
  static struct {
    int value;
    char *name;
  } values[] = {
    { 1000, "m"  },
    {  999, "im" },
    {  990, "xm" },
    {  900, "cm" },
    {  500, "d"  },
    {  499, "id" },
    {  490, "xd" },
    {  400, "cd" },
    {  100, "c"  },
    {   99, "ic" },
    {   90, "xc" },
    {   50, "l"  },
    {   49, "il" },
    {   40, "xl" },
    {   10, "x"  },
    {    9, "ix" },
    {    5, "v"  },
    {    4, "iv" },
    {    1, "i"  },
  };
  if( index&lt;1 || index&gt;=5000 ){
    sprintf(zBuf,"%d",index);
    TestPoint(0);
    return;
  }
  for(j=0; index&gt;0 &amp;&amp; j&lt;sizeof(values)/sizeof(values[0]); j++){
    int k;
    while( index &gt;= values[j].value ){
      for(k=0; values[j].name[k]; k++){
        zBuf[i++] = values[j].name[k];
        TestPoint(0);
      }
      index -= values[j].value;
      TestPoint(0);
    }
  }
  zBuf[i] = 0;
  if( isUpper ){
    for(i=0; zBuf[i]; i++){
      zBuf[i] += 'A' - 'a';
      TestPoint(0);
    }
  }else{
    TestPoint(0);
  }
  strcat(zBuf,".");
}
</t>
<t tx="ekr.20041214071955.43">@ Draw the selection background for the given block
@c

static void DrawSelectionBackground(
  HtmlWidget *htmlPtr,      /* The HTML widget */
  HtmlBlock *pBlock,        /* The block whose background is drawn */
  Drawable drawable,        /* Draw the background on this drawable */
  int x, int y              /* Virtual coords of top-left of drawable */
){
  int xLeft, xRight;        /* Left and right bounds of box to draw */
  int yTop, yBottom;        /* Top and bottom of box */
  HtmlElement *p = 0;       /* First element of the block */
  Tk_Font font;             /* Font */
  GC gc;                    /* GC for drawing */
  XRectangle xrec;          /* Size of a filled rectangle to be drawn */

  if( pBlock==0 || (pBlock-&gt;base.flags &amp; HTML_Selected)==0 ){
    TestPoint(0);
    return;
  }
  xLeft = pBlock-&gt;left - x;
  if( pBlock==htmlPtr-&gt;pSelStartBlock &amp;&amp; htmlPtr-&gt;selStartIndex&gt;0 ){
    if( htmlPtr-&gt;selStartIndex &gt;= pBlock-&gt;n ){ TestPoint(0); return; }
    p = pBlock-&gt;base.pNext;
    font = HtmlGetFont(htmlPtr, p-&gt;base.style.font);
    if( font==0 ) return;
    if( p-&gt;base.type==Html_Text ){
      xLeft = p-&gt;text.x - x + Tk_TextWidth(font, pBlock-&gt;z, 
                                           htmlPtr-&gt;selStartIndex);
    }
  }
  xRight = pBlock-&gt;right - x;
  if( pBlock==htmlPtr-&gt;pSelEndBlock &amp;&amp; htmlPtr-&gt;selEndIndex&lt;pBlock-&gt;n ){
    if( p==0 ){
      p = pBlock-&gt;base.pNext;
      font = HtmlGetFont(htmlPtr, p-&gt;base.style.font);
      if( font==0 ) return;
    }
    if( p-&gt;base.type==Html_Text ){
      xRight = p-&gt;text.x - x + Tk_TextWidth(font, pBlock-&gt;z,
                                            htmlPtr-&gt;selEndIndex);
    }
  }
  yTop = pBlock-&gt;top - y;
  yBottom = pBlock-&gt;bottom - y;
  gc = HtmlGetGC(htmlPtr, COLOR_Selection, FONT_Any);
  xrec.x = xLeft;
  xrec.y = yTop;
  xrec.width = xRight - xLeft;
  xrec.height = yBottom - yTop;
  XFillRectangles(htmlPtr-&gt;display, drawable, gc, &amp;xrec, 1);
}
</t>
<t tx="ekr.20041214071955.44">@ ** Draw a rectangle. The rectangle will have a 3-D appearance if ** flat==0 and a flat appearance if flat==1. ** ** We don't use Tk_Draw3DRectangle() because it doesn't work well ** when the background color is close to pure white or pure black.
@c

static void HtmlDrawRect(
  HtmlWidget *htmlPtr,              /* The HTML widget */
  Drawable drawable,                /* Draw it here */
  HtmlElement *src,                 /* Element associated with drawing */
  int x, int y, int w, int h,       /* Coordinates of the rectangle */
  int depth,                        /* Width of the relief, or the flat line */
  int relief                        /* The relief.  TK_RELIEF_FLAT omits 3d */
){
  if( depth&gt;0 ){
    int i;
    GC gcLight, gcDark;
    XRectangle xrec[1];
    if( relief!=TK_RELIEF_FLAT ){
      int iLight, iDark;
      iLight = HtmlGetLightShadowColor(htmlPtr, src-&gt;base.style.bgcolor);
      gcLight = HtmlGetGC(htmlPtr, iLight, FONT_Any);
      iDark = HtmlGetDarkShadowColor(htmlPtr, src-&gt;base.style.bgcolor);
      gcDark = HtmlGetGC(htmlPtr, iDark, FONT_Any);
      if( relief==TK_RELIEF_SUNKEN ){
        GC gcTemp = gcLight;
        gcLight = gcDark;
        gcDark = gcTemp;
      }
    }else{
      gcLight = HtmlGetGC(htmlPtr, src-&gt;base.style.color, FONT_Any);
      gcDark = gcLight;
    }
    xrec[0].x = x;
    xrec[0].y = y;
    xrec[0].width = depth;
    xrec[0].height = h;
    XFillRectangles(htmlPtr-&gt;display, drawable, gcLight, xrec, 1);
    xrec[0].x = x+w-depth;
    XFillRectangles(htmlPtr-&gt;display, drawable, gcDark, xrec, 1);
    for(i=0; i&lt;depth &amp;&amp; i&lt;h/2; i++){
      XDrawLine(htmlPtr-&gt;display, drawable, gcLight, x+i, y+i, x+w-i-1, y+i);
      XDrawLine(htmlPtr-&gt;display, drawable, gcDark, x+i, y+h-i-1, 
                 x+w-i-1, y+h-i-1);
    }
  }
  if( h&gt;depth*2 &amp;&amp; w&gt;depth*2 ){
    GC gcBg;
    XRectangle xrec[1];
    gcBg = HtmlGetGC(htmlPtr, src-&gt;base.style.bgcolor, FONT_Any);
    xrec[0].x = x + depth;
    xrec[0].y = y + depth;
    xrec[0].width = w - depth*2;
    xrec[0].height = h - depth*2;
    XFillRectangles(htmlPtr-&gt;display, drawable, gcBg, xrec, 1);
  }
}
</t>
<t tx="ekr.20041214071955.45">@ ** Display a single HtmlBlock. This is where all the drawing ** happens.
@c

void HtmlBlockDraw(
  HtmlWidget *htmlPtr,   /* The main HTML widget */
  HtmlBlock *pBlock,     /* Block which needs to be drawn */
  Drawable drawable,     /* Draw the line on this */
  int drawableLeft,      /* Virtual coordinate of left edge of drawable */
  int drawableTop,       /* Virtual coordinate of top edge of drawable */
  int drawableWidth,     /* Width of the drawable */
  int drawableHeight     /* Height of the drawable */
){
  Tk_Font font;           /* Font to use to render text */
  GC gc;                  /* A graphics context */
  HtmlElement *src;       /* HtmlElement holding style information */
  HtmlElement *pTable;    /* The table (when drawing part of a table) */
  int x, y;               /* Where to draw */

  if( pBlock==0 ){ TestPoint(0); return; }
  src = pBlock-&gt;base.pNext;
  while( src &amp;&amp; (src-&gt;base.flags &amp; HTML_Visible)==0 ){
    src = src-&gt;base.pNext;
    TestPoint(0);
  }
  if( src==0 ){ TestPoint(0); return; }
  if( pBlock-&gt;n&gt;0 ){
    /* We must be dealing with plain old text */
    if( src-&gt;base.type==Html_Text ){
      x = src-&gt;text.x;
      y = src-&gt;text.y;
      TestPoint(0);
    }else{
      CANT_HAPPEN;
      return;
    }
    if( pBlock-&gt;base.flags &amp; HTML_Selected ){
      HtmlLock(htmlPtr);
      DrawSelectionBackground(htmlPtr, pBlock, drawable, 
                              drawableLeft, drawableTop);
      if( HtmlUnlock(htmlPtr) ) return;
    }
    gc = HtmlGetGC(htmlPtr, src-&gt;base.style.color, src-&gt;base.style.font);
    font = HtmlGetFont(htmlPtr, src-&gt;base.style.font);
    if( font==0 ) return;
    Tk_DrawChars(htmlPtr-&gt;display,
                 drawable,
                 gc, font,
                 pBlock-&gt;z, pBlock-&gt;n,
                 x - drawableLeft, y - drawableTop);
    if( src-&gt;base.style.flags &amp; STY_Underline ){
      Tk_UnderlineChars(htmlPtr-&gt;display, drawable, gc, font, pBlock-&gt;z,
                        x - drawableLeft, y-drawableTop, 0, pBlock-&gt;n);
    }
    if( src-&gt;base.style.flags &amp; STY_StrikeThru ){
      XRectangle xrec;
      xrec.x = pBlock-&gt;left - drawableLeft;
      xrec.y = (pBlock-&gt;top + pBlock-&gt;bottom)/2 - drawableTop;
      xrec.width = pBlock-&gt;right - pBlock-&gt;left;
      xrec.height = 1 + (pBlock-&gt;bottom - pBlock-&gt;top &gt; 15);
      XFillRectangles(htmlPtr-&gt;display, drawable, gc, &amp;xrec, 1);
    }
    if( pBlock==htmlPtr-&gt;pInsBlock &amp;&amp; htmlPtr-&gt;insStatus&gt;0 ){
      int x;
      XRectangle xrec;
      if( htmlPtr-&gt;insIndex &lt; pBlock-&gt;n ){
        x = src-&gt;text.x - drawableLeft;
        x += Tk_TextWidth(font, pBlock-&gt;z, htmlPtr-&gt;insIndex);
      }else{
        x = pBlock-&gt;right - drawableLeft;
      }
      if( x&gt;0 ){ TestPoint(0); x--; }
      xrec.x = x;
      xrec.y = pBlock-&gt;top - drawableTop;
      xrec.width =  2;
      xrec.height = pBlock-&gt;bottom - pBlock-&gt;top;
      XFillRectangles(htmlPtr-&gt;display, drawable, gc, &amp;xrec, 1);
    }
  }else{
    /* We are dealing with a single HtmlElement which contains something
    ** other than plain text. */
    int top, btm, cntr;
    int cnt, w;
    char zBuf[30];
    switch( src-&gt;base.type ){
      case Html_LI:
        x = src-&gt;li.x;
        y = src-&gt;li.y;
        cntr = (top+btm)/2;
        switch( src-&gt;li.type ){
          case LI_TYPE_Enum_1:
            sprintf(zBuf,"%d.",src-&gt;li.cnt);
            TestPoint(0);
            break;
          case LI_TYPE_Enum_A:
            GetLetterIndex(zBuf,src-&gt;li.cnt,1);
            TestPoint(0);
            break;
          case LI_TYPE_Enum_a:
            GetLetterIndex(zBuf,src-&gt;li.cnt,0);
            TestPoint(0);
            break;
          case LI_TYPE_Enum_I:
            GetRomanIndex(zBuf,src-&gt;li.cnt,1);
            TestPoint(0);
            break;
          case LI_TYPE_Enum_i:
            GetRomanIndex(zBuf,src-&gt;li.cnt,0);
            TestPoint(0);
            break;
          default:
            zBuf[0] = 0;
            TestPoint(0);
            break;
        }
        gc = HtmlGetGC(htmlPtr, src-&gt;base.style.color, src-&gt;base.style.font);
        switch( src-&gt;li.type ){
          case LI_TYPE_Undefined:
          case LI_TYPE_Bullet1:
            XFillArc(htmlPtr-&gt;display,
                     drawable,
                     gc,
                     x - 7 - drawableLeft, y - 8 - drawableTop, 7, 7,
                     0, 360*64);
            TestPoint(0);
            break;

          case LI_TYPE_Bullet2:
            XDrawArc(htmlPtr-&gt;display,
                     drawable,
                     gc,
                     x - 7 - drawableLeft, y - 8 - drawableTop, 7, 7,
                     0, 360*64);
            TestPoint(0);
            break;

          case LI_TYPE_Bullet3:
            XDrawRectangle(htmlPtr-&gt;display,
                     drawable,
                     gc,
                     x - 7 - drawableLeft, y - 8 - drawableTop, 7, 7);
            TestPoint(0);
            break;
          
          case LI_TYPE_Enum_1:
          case LI_TYPE_Enum_A:
          case LI_TYPE_Enum_a:
          case LI_TYPE_Enum_I:
          case LI_TYPE_Enum_i:
            cnt = strlen(zBuf);
            font = HtmlGetFont(htmlPtr, src-&gt;base.style.font);
            if( font==0 ) return;
            w = Tk_TextWidth(font, zBuf, cnt);
            Tk_DrawChars(htmlPtr-&gt;display,
                 drawable,
                 gc, font,
                 zBuf, cnt, 
                 x - w - drawableLeft, y - drawableTop);
            TestPoint(0);
            break;
        }
        break;
      case Html_HR: {
        int relief = htmlPtr-&gt;ruleRelief;
        switch( relief ){
          case TK_RELIEF_RAISED: 
          case TK_RELIEF_SUNKEN:
            break;
          default:
            relief = TK_RELIEF_FLAT;
            break;
        }
        HtmlDrawRect(htmlPtr, drawable, src,
            src-&gt;hr.x - drawableLeft,
            src-&gt;hr.y - drawableTop,
            src-&gt;hr.w,
            src-&gt;hr.h,
            1, relief);
        break;
      }
      case Html_TABLE: {
        int relief = htmlPtr-&gt;tableRelief;
        switch( relief ){
          case TK_RELIEF_RAISED: 
          case TK_RELIEF_SUNKEN:
            break;
          default:
            relief = TK_RELIEF_FLAT;
            break;
        }
        HtmlDrawRect(htmlPtr, drawable, src,
                           src-&gt;table.x - drawableLeft,
                           src-&gt;table.y - drawableTop,
                           src-&gt;table.w, 
                           src-&gt;table.h,
                           src-&gt;table.borderWidth,
                           relief);
        break;
      }
      case Html_TH:
      case Html_TD: {
        int depth, relief;
        pTable = src-&gt;cell.pTable;
        depth = pTable &amp;&amp; pTable-&gt;table.borderWidth&gt;0;
        switch( htmlPtr-&gt;tableRelief ){
          case TK_RELIEF_RAISED:  relief = TK_RELIEF_SUNKEN; break;
          case TK_RELIEF_SUNKEN:  relief = TK_RELIEF_RAISED; break;
          default:                relief = TK_RELIEF_FLAT;   break;
        }
        HtmlDrawRect(htmlPtr, drawable, src,
                         src-&gt;cell.x - drawableLeft,
                         src-&gt;cell.y - drawableTop,
                         src-&gt;cell.w, 
                         src-&gt;cell.h,
                         depth,
                         relief);
        break;
      }
      case Html_IMG:
        if( src-&gt;image.pImage ){
          HtmlDrawImage(src, drawable, drawableLeft, drawableTop,
                        drawableLeft + drawableWidth,
                        drawableTop + drawableHeight);
        }else if( src-&gt;image.zAlt ){
          gc = HtmlGetGC(htmlPtr, src-&gt;base.style.color, src-&gt;base.style.font);
          font = HtmlGetFont(htmlPtr, src-&gt;base.style.font);
          if( font==0 ) return;
          Tk_DrawChars(htmlPtr-&gt;display,
                 drawable,
                 gc, font,
                 src-&gt;image.zAlt, strlen(src-&gt;image.zAlt),
                 src-&gt;image.x - drawableLeft, 
                 src-&gt;image.y - drawableTop);
          TestPoint(0);
        }    
        break;
      default:
        TestPoint(0);
        break;
    }
  }
}
</t>
<t tx="ekr.20041214071955.46">@ ** Draw all or part of an image.
@c

void HtmlDrawImage(
  HtmlElement *pElem,    /* The &lt;IMG&gt; to be drawn */
  Drawable drawable,     /* Draw it here */
  int drawableLeft,      /* left edge of the drawable */
  int drawableTop,       /* Virtual canvas coordinate for top of drawable */
  int drawableRight,     /* right edge of the drawable */
  int drawableBottom     /* bottom edge of the drawable */
){
  int imageTop;          /* virtual canvas coordinate for top of image */
  int x, y;              /* where to place image on the drawable */
  int imageX, imageY;    /* \__  Subset of image that fits    */
  int imageW, imageH;    /* /    on the drawable              */
                    
  imageTop = pElem-&gt;image.y - pElem-&gt;image.ascent;
  y = imageTop - drawableTop;
  if( imageTop + pElem-&gt;image.h &gt; drawableBottom ){
    imageH = drawableBottom - imageTop;
    TestPoint(0);
  }else{
    imageH = pElem-&gt;image.h;
    TestPoint(0);
  }
  if( y&lt;0 ){
    imageY = -y;
    imageH += y;
    y = 0;
    TestPoint(0);
  }else{
    imageY = 0;
    TestPoint(0);
  }
  x = pElem-&gt;image.x - drawableLeft;
  if( pElem-&gt;image.x + pElem-&gt;image.w &gt; drawableRight ){
    imageW = drawableRight - pElem-&gt;image.x;
    TestPoint(0);
  }else{
    imageW = pElem-&gt;image.w;
    TestPoint(0);
  }
  if( x&lt;0 ){
    imageX = -x;
    imageW += x;
    x = 0;
    TestPoint(0);
  }else{
    imageX = 0;
    TestPoint(0);
  }
  Tk_RedrawImage(pElem-&gt;image.pImage-&gt;image, imageX, imageY, imageW, imageH, 
                 drawable, x, y);
  pElem-&gt;image.redrawNeeded = 0;
}
</t>
<t tx="ekr.20041214071955.47">@ ** Recompute the following fields of the given block structure: ** **  base.count     The number of elements described by this **            block structure. ** **  n         The number of characters of text output **            associated with this block. If the block **            renders something other than text (ex: &lt;IMG&gt;) **            then set n to 0. ** **  z         Pointer to malloced memory containing the **            text associated with this block. NULL if **            n is 0. ** ** Return a pointer to the first HtmlElement not covered by the ** block.
@c

static HtmlElement *FillOutBlock(HtmlWidget *htmlPtr, HtmlBlock *p){
  HtmlElement *pElem;
  int go;
  int n;
  int x, y;
  int i;
  HtmlStyle style;
  int firstSelected;      /* First selected character in this block */
  int lastSelected;       /* Last selected character in this block */
  char zBuf[400];

  /*
  ** Reset n and z
  */
  if( p-&gt;n ){
    p-&gt;n = 0;
  }
  if( p-&gt;z ){
    HtmlFree(p-&gt;z);
  }
  firstSelected = 1000000;
  lastSelected = -1;

  /*
  ** Skip over HtmlElements that aren't directly displayed.
  */
  pElem = p-&gt;base.pNext;
  p-&gt;base.count = 0;
  while( pElem &amp;&amp; (pElem-&gt;base.flags &amp; HTML_Visible)==0 ){
    HtmlElement *pNext = pElem-&gt;pNext;
    if( pElem-&gt;base.type==Html_Block ){
      UnlinkAndFreeBlock(htmlPtr, &amp;pElem-&gt;block);
      TestPoint(0);
    }else{
      p-&gt;base.count++;
      TestPoint(0);
    }
    pElem = pNext;
  }
  if( pElem==0 ){ TestPoint(0); return 0; }

  /*
  ** Handle "special" elements.
  */
  if( pElem-&gt;base.type!=Html_Text ){
    switch( pElem-&gt;base.type ){
      case Html_HR:
        p-&gt;top = pElem-&gt;hr.y - pElem-&gt;hr.h;
        p-&gt;bottom = pElem-&gt;hr.y;
        p-&gt;left = pElem-&gt;hr.x;
        p-&gt;right = pElem-&gt;hr.x + pElem-&gt;hr.w;
        TestPoint(0);
        break;
      case Html_LI:
        p-&gt;top = pElem-&gt;li.y - pElem-&gt;li.ascent;
        p-&gt;bottom = pElem-&gt;li.y + pElem-&gt;li.descent;
        p-&gt;left = pElem-&gt;li.x - 10;
        p-&gt;right = pElem-&gt;li.x + 10;
        TestPoint(0);
        break;
      case Html_TD:
      case Html_TH:
        p-&gt;top = pElem-&gt;cell.y;
        p-&gt;bottom = pElem-&gt;cell.y + pElem-&gt;cell.h;
        p-&gt;left = pElem-&gt;cell.x;
        p-&gt;right = pElem-&gt;cell.x + pElem-&gt;cell.w;
        TestPoint(0);
        break;
      case Html_TABLE:
        p-&gt;top = pElem-&gt;table.y;
        p-&gt;bottom = pElem-&gt;table.y + pElem-&gt;table.h;
        p-&gt;left = pElem-&gt;table.x;
        p-&gt;right = pElem-&gt;table.x + pElem-&gt;table.w;
        TestPoint(0);
        break;
      case Html_IMG:
        p-&gt;top = pElem-&gt;image.y - pElem-&gt;image.ascent;
        p-&gt;bottom = pElem-&gt;image.y + pElem-&gt;image.descent;
        p-&gt;left = pElem-&gt;image.x;
        p-&gt;right = pElem-&gt;image.x + pElem-&gt;image.w;
        TestPoint(0);
        break;
    }
    p-&gt;base.count++;
    TestPoint(0);
    return pElem-&gt;pNext;
  }

  /*
  ** If we get this far, we must be dealing with text.
  */
  n = 0;
  x = pElem-&gt;text.x;
  y = pElem-&gt;text.y;
  p-&gt;top = y - pElem-&gt;text.ascent;
  p-&gt;bottom = y + pElem-&gt;text.descent;
  p-&gt;left = x;
  style = pElem-&gt;base.style;
  go = 1;
  while( pElem ){
    HtmlElement *pNext = pElem-&gt;pNext;
    switch( pElem-&gt;base.type ){
      case Html_Text:
        if( pElem-&gt;base.style.flags &amp; STY_Invisible ){
          TestPoint(0);
          break;
        }
        if( pElem-&gt;text.spaceWidth &lt;=0 ){
          CANT_HAPPEN;
          break;
        }
        if( y != pElem-&gt;text.y 
        ||  style.font != pElem-&gt;base.style.font
        ||  style.color != pElem-&gt;base.style.color
        ||  (style.flags &amp; STY_FontMask) 
              != (pElem-&gt;base.style.flags &amp; STY_FontMask)
        ){
          go = 0;
          TestPoint(0);
        }else{
          int sw = pElem-&gt;text.spaceWidth;
          int nSpace = (pElem-&gt;text.x - x) / sw;
          if( nSpace * sw + x != pElem-&gt;text.x ){
            go = 0;
            TestPoint(0);
          }else if( n + nSpace + pElem-&gt;base.count &gt;= sizeof(zBuf) ){
            go = 0;
            TestPoint(0);
          }else{
            for(i=0; i&lt;nSpace; i++){
              zBuf[n++] = ' ';
              TestPoint(0);
            }
            strcpy(&amp;zBuf[n], pElem-&gt;text.zText);
            n += pElem-&gt;base.count;
            x = pElem-&gt;text.x + pElem-&gt;text.w;
          }
        }
        break;

      case Html_Space:
        if( pElem-&gt;base.style.font != style.font ){
          pElem = pElem-&gt;pNext;
          go = 0;
        }else if( (style.flags &amp; STY_Preformatted)!=0 
                  &amp;&amp; (pElem-&gt;base.flags &amp; HTML_NewLine)!=0 ){
          pElem = pElem-&gt;pNext;
          go = 0;
        }
        break;

      case Html_Block:
        UnlinkAndFreeBlock(htmlPtr,&amp;pElem-&gt;block);
        break;

      case Html_A:
      case Html_EndA:
        go = 0;
        break;

      default:
        if( pElem-&gt;base.flags &amp; HTML_Visible ) go = 0;
        TestPoint(0);
        break;
    }
    if( go==0 ) break;
    p-&gt;base.count++;
    pElem = pNext;
  }
  p-&gt;right = x;

  while( n&gt;0 &amp;&amp; zBuf[n-1]==' ' ){ TestPoint(0); n--; }
  p-&gt;z = HtmlAlloc( n );
  strncpy(p-&gt;z, zBuf, n);
  p-&gt;n = n;
  return pElem;
}
</t>
<t tx="ekr.20041214071955.48">@ ** Scan ahead looking for a place to put a block. Return a pointer ** to the element which should come immediately after the block. ** ** if pCnt!=0, then put the number of elements skipped in *pCnt.
@c

static HtmlElement *FindStartOfNextBlock(
  HtmlWidget *htmlPtr,     /* The HTML widget */
  HtmlElement *p,          /* First candid for the start of a block */
  int *pCnt                /* Write number of elements skipped here */
){
  int cnt = 0;

  while( p &amp;&amp; (p-&gt;base.flags &amp; HTML_Visible)==0 ){
    HtmlElement *pNext = p-&gt;pNext;
    if( p-&gt;base.type==Html_Block ){
      UnlinkAndFreeBlock(htmlPtr, &amp;p-&gt;block);
    }else{
      cnt++;
    }
    p = pNext;
  }
  if( pCnt ){ *pCnt = cnt; }
  return p;
}
</t>
<t tx="ekr.20041214071955.49">@ ** Add additional blocks to the block list in order to cover ** all elements on the element list. ** ** If any old blocks are found on the element list, they must ** be left over from a prior rendering. Unlink and delete them.
@c

void HtmlFormBlocks(HtmlWidget *htmlPtr){
  HtmlElement *pElem;

  if( htmlPtr-&gt;lastBlock ){
    pElem = FillOutBlock(htmlPtr, htmlPtr-&gt;lastBlock);
  }else{
    pElem = htmlPtr-&gt;pFirst;
  }
  while( pElem ){
    int cnt;
    pElem = FindStartOfNextBlock(htmlPtr, pElem, &amp;cnt);
    if( pElem ){
      HtmlBlock *pNew = AllocBlock();
      if( htmlPtr-&gt;lastBlock ){
        htmlPtr-&gt;lastBlock-&gt;base.count += cnt;
      }
      AppendBlock(htmlPtr, pElem, pNew);
      pElem = FillOutBlock(htmlPtr, pNew);
    }
  }
}
</t>
<t tx="ekr.20041214071955.50">@ignore
@language c
static char const rcsid[] = "@(#) $Id: htmlform.c,v 1.22 2000/02/25 13:57:03 drh Exp $";

// Routines used for processing HTML makeup for forms.

#include &lt;tk.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
#include "htmlform.h"

@others
</t>
<t tx="ekr.20041214071955.51"></t>
<t tx="ekr.20041214071955.52">@ ** Unmap any input control that is currently mapped.
@c

void HtmlUnmapControls(HtmlWidget *htmlPtr){
  HtmlElement *p;

  for(p=htmlPtr-&gt;firstInput; p; p=p-&gt;input.pNext){
    if( p-&gt;input.tkwin!=0 &amp;&amp; Tk_IsMapped(p-&gt;input.tkwin) ){
      Tk_UnmapWindow(p-&gt;input.tkwin);
    }
  }
}
</t>
<t tx="ekr.20041214071955.53">@ ** Map any control that should be visible according to the ** current scroll position. At the same time, if any controls that ** should not be visible are mapped, unmap them. After this routine ** finishes, all &lt;INPUT&gt; controls should be in their proper places ** regardless of where they might have been before. ** ** Return the number of controls that are currently visible.
@c

int HtmlMapControls(HtmlWidget *htmlPtr){
  HtmlElement *p;     /* For looping over all controls */
  int x, y, w, h;     /* Part of the virtual canvas that is visible */
  int cnt = 0;        /* Number of visible controls */

  x = htmlPtr-&gt;xOffset;
  y = htmlPtr-&gt;yOffset;
  w = Tk_Width(htmlPtr-&gt;clipwin);
  h = Tk_Height(htmlPtr-&gt;clipwin);
  for(p=htmlPtr-&gt;firstInput; p; p=p-&gt;input.pNext){
    if( p-&gt;input.tkwin==0 ) continue;
    if( p-&gt;input.y &lt; y+h 
     &amp;&amp; p-&gt;input.y + p-&gt;input.h &gt; y
     &amp;&amp; p-&gt;input.x &lt; x+w
     &amp;&amp; p-&gt;input.x + p-&gt;input.w &gt; x
    ){
      /* The control should be visible.  Make is so if it isn't already */
      Tk_MoveResizeWindow(p-&gt;input.tkwin, 
          p-&gt;input.x - x, p-&gt;input.y - y, 
          p-&gt;input.w, p-&gt;input.h);
      if( !Tk_IsMapped(p-&gt;input.tkwin) ){
        Tk_MapWindow(p-&gt;input.tkwin);
      }
      cnt++;
    }else{
      /* This control should not be visible.  Unmap it. */
      if( Tk_IsMapped(p-&gt;input.tkwin) ){
        Tk_UnmapWindow(p-&gt;input.tkwin);
      }
    }
  }
  return cnt;
}
</t>
<t tx="ekr.20041214071955.54">@ ** Delete all input controls. This happens when the HTML widget ** is cleared. ** ** When the TCL "exit" command is invoked, the order of operations ** here is very touchy.
@c

void HtmlDeleteControls(HtmlWidget *htmlPtr){
  HtmlElement *p;        /* For looping over all controls */
  Tcl_Interp *interp;    /* The interpreter */
  
  interp = htmlPtr-&gt;interp;
  p = htmlPtr-&gt;firstInput;
  htmlPtr-&gt;firstInput = 0;
  htmlPtr-&gt;lastInput = 0;
  htmlPtr-&gt;nInput = 0;
  if( p==0 || htmlPtr-&gt;tkwin==0 ) return;
  HtmlLock(htmlPtr);
  for(; p; p=p-&gt;input.pNext){
    if( p-&gt;input.pForm &amp;&amp; p-&gt;input.pForm-&gt;form.id&gt;0 
         &amp;&amp; htmlPtr-&gt;zFormCommand &amp;&amp; htmlPtr-&gt;zFormCommand[0]
         &amp;&amp; !Tcl_InterpDeleted(interp) &amp;&amp; htmlPtr-&gt;clipwin ){
      Tcl_DString cmd;
      int result;
      char zBuf[60];
      Tcl_DStringInit(&amp;cmd);
      Tcl_DStringAppend(&amp;cmd, htmlPtr-&gt;zFormCommand, -1);
      sprintf(zBuf," %d flush", p-&gt;input.pForm-&gt;form.id);
      Tcl_DStringAppend(&amp;cmd, zBuf, -1);
      result = Tcl_GlobalEval(htmlPtr-&gt;interp, Tcl_DStringValue(&amp;cmd));
      Tcl_DStringFree(&amp;cmd);
      if( !Tcl_InterpDeleted(interp) ){
        if( result != TCL_OK ){
          Tcl_AddErrorInfo(htmlPtr-&gt;interp,
             "\n    (-formcommand flush callback executed by html widget)");
          Tcl_BackgroundError(htmlPtr-&gt;interp);
          TestPoint(0);
        }
        Tcl_ResetResult(htmlPtr-&gt;interp);
      }
      p-&gt;input.pForm-&gt;form.id = 0;
    }
    if( p-&gt;input.tkwin ){
      if( htmlPtr-&gt;clipwin!=0 ) Tk_DestroyWindow(p-&gt;input.tkwin);
      p-&gt;input.tkwin = 0;
    }
    p-&gt;input.sized = 0;
  }
  HtmlUnlock(htmlPtr);
}
</t>
<t tx="ekr.20041214071955.55">@ ** Return an appropriate type value for the given &lt;INPUT&gt; markup.
@c

static int InputType(HtmlElement *p){
  int type = INPUT_TYPE_Unknown;
  char *z;
  int i;
  static struct {
    char *zName;
    int type;
  } types[] = {
    { "checkbox",  INPUT_TYPE_Checkbox },
    { "file",      INPUT_TYPE_File     },
    { "hidden",    INPUT_TYPE_Hidden   },
    { "image",     INPUT_TYPE_Image    },
    { "password",  INPUT_TYPE_Password },
    { "radio",     INPUT_TYPE_Radio    },
    { "reset",     INPUT_TYPE_Reset    },
    { "submit",    INPUT_TYPE_Submit   },
    { "text",      INPUT_TYPE_Text     },
  };

  switch( p-&gt;base.type ){
    case Html_INPUT:
      z = HtmlMarkupArg(p, "type", "text");
      if( z==0 ){ TestPoint(0); break; }
      for(i=0; i&lt;sizeof(types)/sizeof(types[0]); i++){
        if( stricmp(types[i].zName,z)==0 ){
          type = types[i].type;
          TestPoint(0);
          break;
        }
        TestPoint(0);
      }
      break;
    case Html_SELECT:
      type = INPUT_TYPE_Select;
      TestPoint(0);
      break;
    case Html_TEXTAREA:
      type = INPUT_TYPE_TextArea;
      TestPoint(0);
      break;
    case Html_APPLET:
    case Html_IFRAME:
    case Html_EMBED:
      type = INPUT_TYPE_Applet;
      TestPoint(0);
      break;
    default:
      CANT_HAPPEN;
      break;
  }
  return type;
}
</t>
<t tx="ekr.20041214071955.56">@ ** Create the window name for a child widget. Space to hold the name ** is obtained from HtmlAlloc() and must be freed by the calling function.
@c

static char *MakeWindowName(
  HtmlWidget *htmlPtr,        /* The HTML widget */
  HtmlElement *pElem          /* The input that needs a child widget */
){
  int n;
  char *zBuf;

  n = strlen(Tk_PathName(htmlPtr-&gt;clipwin));
  zBuf = HtmlAlloc( n + 20 );
  sprintf(zBuf,"%s.x%d",Tk_PathName(htmlPtr-&gt;clipwin), pElem-&gt;input.cnt);
  return zBuf;
}
</t>
<t tx="ekr.20041214071955.57">@ ** A Input element is the input. Mark this element as being ** empty. It has no widget and doesn't appear on the screen. ** ** This is called for HIDDEN inputs or when the -formcommand ** callback doesn't create the widget.
@c

static void EmptyInput(HtmlElement *pElem){
  pElem-&gt;input.tkwin = 0;
  pElem-&gt;input.w = 0;
  pElem-&gt;input.h = 0;
  pElem-&gt;base.flags &amp;= !HTML_Visible;
  pElem-&gt;base.style.flags |= STY_Invisible;
  pElem-&gt;input.sized = 1;
}
</t>
<t tx="ekr.20041214071955.58">@ ** This routine is called when one of the child windows for a form ** wants to change its size.
@c

static void HtmlInputRequestProc(ClientData clientData, Tk_Window tkwin){
  HtmlElement *pElem = (HtmlElement*)clientData;
  if( pElem-&gt;base.type!=Html_INPUT ){ CANT_HAPPEN; return; }
  if( pElem-&gt;input.tkwin!=tkwin ){ CANT_HAPPEN; return; }
  pElem-&gt;input.w = Tk_ReqWidth(tkwin);
  pElem-&gt;input.h = Tk_ReqHeight(tkwin);
  if( pElem-&gt;input.htmlPtr &amp;&amp; pElem-&gt;input.htmlPtr-&gt;tkwin!=0 ){
    pElem-&gt;input.htmlPtr-&gt;flags |= RELAYOUT;
    HtmlScheduleRedraw(pElem-&gt;input.htmlPtr); 
  }
}
</t>
<t tx="ekr.20041214071955.59">@ ** This routine is called when another entity takes over geometry ** management for a widget corresponding to an input element.
@c

static void HtmlInputLostSlaveProc(ClientData clientData, Tk_Window tkwin){
  HtmlElement *pElem = (HtmlElement*)clientData;
  if( pElem-&gt;base.type!=Html_INPUT ){ CANT_HAPPEN; return; }
  if( pElem-&gt;input.tkwin!=tkwin ){ CANT_HAPPEN; return; }
  EmptyInput(pElem);
  if( pElem-&gt;input.htmlPtr &amp;&amp; pElem-&gt;input.htmlPtr-&gt;tkwin!=0 ){
    pElem-&gt;input.htmlPtr-&gt;flags |= RELAYOUT;
    HtmlScheduleRedraw(pElem-&gt;input.htmlPtr); 
  }
}
</t>
<t tx="ekr.20041214071955.60">@ ** This routine catches DestroyNotify events on a INPUT window so ** that we will know the window is been deleted.
@c

static void HtmlInputEventProc(ClientData clientData, XEvent *eventPtr){
  HtmlElement *pElem = (HtmlElement*)clientData;
  /* if( pElem-&gt;base.type!=Html_INPUT ){ CANT_HAPPEN; return; } */
  if( eventPtr-&gt;type==DestroyNotify ){
    EmptyInput(pElem);
    if( pElem-&gt;input.htmlPtr &amp;&amp; pElem-&gt;input.htmlPtr-&gt;tkwin!=0 ){
      pElem-&gt;input.htmlPtr-&gt;flags |= RELAYOUT;
      HtmlScheduleRedraw(pElem-&gt;input.htmlPtr); 
    }
  }
}
</t>
<t tx="ekr.20041214071955.61">@ ** The geometry manager for the HTML widget
@c

static Tk_GeomMgr htmlGeomType = {
  "html",                  /* Name */
  HtmlInputRequestProc,    /* Called when widget changes size */
  HtmlInputLostSlaveProc,  /* Called when someone else takes over management */
};

/*
** zWin is the name of a child widget that is used to implement an
** input element.  Query Tk for information about this widget (such
** as its size) and put that information in the pElem structure
** that represents the input.
*/
static void SizeAndLink(HtmlWidget *htmlPtr, char *zWin, HtmlElement *pElem){
  pElem-&gt;input.tkwin = Tk_NameToWindow(htmlPtr-&gt;interp, zWin, htmlPtr-&gt;clipwin);
  if( pElem-&gt;input.tkwin==0 ){
    Tcl_ResetResult(htmlPtr-&gt;interp);
    EmptyInput(pElem);
  }else if( pElem-&gt;input.type==INPUT_TYPE_Hidden ){
    pElem-&gt;input.w = 0;
    pElem-&gt;input.h = 0;
    pElem-&gt;base.flags &amp;= !HTML_Visible;
    pElem-&gt;base.style.flags |= STY_Invisible;
  }else{
    pElem-&gt;input.w = Tk_ReqWidth(pElem-&gt;input.tkwin);
    pElem-&gt;input.h = Tk_ReqHeight(pElem-&gt;input.tkwin);
    pElem-&gt;base.flags |= HTML_Visible;
    pElem-&gt;input.htmlPtr = htmlPtr;
    Tk_ManageGeometry(pElem-&gt;input.tkwin, &amp;htmlGeomType, pElem);
    Tk_CreateEventHandler(pElem-&gt;input.tkwin, StructureNotifyMask,
       HtmlInputEventProc, pElem);
  }
  pElem-&gt;input.pNext = 0;
  if( htmlPtr-&gt;firstInput==0 ){
    htmlPtr-&gt;firstInput = pElem;
  }else{
    htmlPtr-&gt;lastInput-&gt;input.pNext = pElem;
  }
  htmlPtr-&gt;lastInput = pElem;
  pElem-&gt;input.sized = 1;
}
</t>
<t tx="ekr.20041214071955.62">@ Append all text and space tokens between pStart and pEnd to ** the given Tcl_DString.
@c

static void HtmlAppendText(
  Tcl_DString *str,         /* Append the text here */
  HtmlElement *pFirst,      /* The first token */
  HtmlElement *pEnd         /* The last token */
){
  while( pFirst &amp;&amp; pFirst!=pEnd ){
    switch( pFirst-&gt;base.type ){
      case Html_Text: {
        Tcl_DStringAppend(str, pFirst-&gt;text.zText, -1);
        break;
      }
      case Html_Space: {
        if( pFirst-&gt;base.flags &amp; HTML_NewLine ){
          Tcl_DStringAppend(str, "\n", 1);
        }else{
          int cnt;
          static char zSpaces[] = "                             ";
          cnt = pFirst-&gt;base.count;
          while( cnt&gt;sizeof(zSpaces)-1 ){
            Tcl_DStringAppend(str, zSpaces, sizeof(zSpaces)-1);
            cnt -= sizeof(zSpaces)-1;
          }
          if( cnt&gt;0 ){
            Tcl_DStringAppend(str, zSpaces, cnt);
          }
        }
        break;
      }
      default:
        /* Do nothing */
        break;
    }
    pFirst = pFirst-&gt;pNext;
  }
}
</t>
<t tx="ekr.20041214071955.63">@ ** The "p" argument points to a &lt;select&gt;. This routine scans all ** subsequent elements (up to the next &lt;/select&gt;) looking for ** &lt;option&gt; tags. For each option tag, it appends three elements ** to the "str" DString: ** **   *    1 or 0 to indicated whether or not the element is **       selected. ** **   *    The value returned if this element is selected. ** **   *    The text displayed for this element.
@c

static void AddSelectOptions(
  Tcl_DString *str,      /* Add text here */
  HtmlElement *p,        /* The &lt;SELECT&gt; markup */
  HtmlElement *pEnd      /* The &lt;/SELECT&gt; markup */
){
  while( p &amp;&amp; p!=pEnd &amp;&amp; p-&gt;base.type!=Html_EndSELECT ){
    if( p-&gt;base.type==Html_OPTION ){
      char *zValue;
      Tcl_DStringStartSublist(str);
      if( HtmlMarkupArg(p, "selected", 0)==0 ){
        Tcl_DStringAppend(str, "0 ", 2);
      }else{
        Tcl_DStringAppend(str, "1 ", 2);
      }
      zValue = HtmlMarkupArg(p, "value", "");
      Tcl_DStringAppendElement(str, zValue);
      Tcl_DStringStartSublist(str);
      p = p-&gt;pNext;
      while( p &amp;&amp; p!=pEnd &amp;&amp; p-&gt;base.type!=Html_EndOPTION 
        &amp;&amp; p-&gt;base.type!=Html_OPTION &amp;&amp; p-&gt;base.type!=Html_EndSELECT ){
        if( p-&gt;base.type==Html_Text ){
          Tcl_DStringAppend(str, p-&gt;text.zText, -1);
        }else if( p-&gt;base.type==Html_Space ){
          Tcl_DStringAppend(str, " ", 1);
        }
        p = p-&gt;pNext;
      }
      Tcl_DStringEndSublist(str);
      Tcl_DStringEndSublist(str);
    }else{
      p = p-&gt;pNext;
    }
  }
}
</t>
<t tx="ekr.20041214071955.64">@ ** This routine implements the Sizer() function for &lt;INPUT&gt;, ** &lt;SELECT&gt; and &lt;TEXTAREA&gt; markup. ** ** A side effect of sizing these markups is that widgets are ** created to represent the corresponding input controls. ** ** The function normally returns 0. But if it is dealing with ** a &lt;SELECT&gt; or &lt;TEXTAREA&gt; that is incomplete, 1 is returned. ** In that case, the sizer will be called again at some point in ** the future when more information is available.
@c

int HtmlControlSize(HtmlWidget *htmlPtr, HtmlElement *pElem){
  char *zWin;            /* Name of child widget that implements this input */
  int incomplete = 0;    /* True if data is incomplete */
  Tcl_DString cmd;       /* The complete -formcommand callback */
 
  if( pElem-&gt;input.sized ) return 0;
  pElem-&gt;input.type = InputType(pElem);
  switch( pElem-&gt;input.type ){
    case INPUT_TYPE_Checkbox:
    case INPUT_TYPE_Hidden:
    case INPUT_TYPE_Image:
    case INPUT_TYPE_Radio:
    case INPUT_TYPE_Reset:
    case INPUT_TYPE_Submit:
    case INPUT_TYPE_Text:
    case INPUT_TYPE_Password:
    case INPUT_TYPE_File: {
      int result;
      char zToken[50];

      if( pElem-&gt;input.pForm==0 || htmlPtr-&gt;zFormCommand==0 
           || htmlPtr-&gt;zFormCommand[0]==0 ){
        EmptyInput(pElem);
        break;
      }
      Tcl_DStringInit(&amp;cmd);
      Tcl_DStringAppend(&amp;cmd, htmlPtr-&gt;zFormCommand, -1);
      sprintf(zToken," %d input ",pElem-&gt;input.pForm-&gt;form.id);
      Tcl_DStringAppend(&amp;cmd, zToken, -1);
      pElem-&gt;input.cnt = ++htmlPtr-&gt;nInput;
      zWin = MakeWindowName(htmlPtr, pElem);
      Tcl_DStringAppend(&amp;cmd, zWin, -1);
      Tcl_DStringStartSublist(&amp;cmd);
      HtmlAppendArglist(&amp;cmd, pElem);
      Tcl_DStringEndSublist(&amp;cmd);
      HtmlLock(htmlPtr);
      result = Tcl_GlobalEval(htmlPtr-&gt;interp, Tcl_DStringValue(&amp;cmd));
      Tcl_DStringFree(&amp;cmd);
      if( !HtmlUnlock(htmlPtr) ){
        SizeAndLink(htmlPtr, zWin, pElem);
      }
      HtmlFree(zWin);
      break;
    }
    case INPUT_TYPE_Select: {
      int result;
      char zToken[50];

      if( pElem-&gt;input.pForm==0 || htmlPtr-&gt;zFormCommand==0 
           || htmlPtr-&gt;zFormCommand[0]==0 ){
        EmptyInput(pElem);
        break;
      }
      Tcl_DStringInit(&amp;cmd);
      Tcl_DStringAppend(&amp;cmd, htmlPtr-&gt;zFormCommand, -1);
      sprintf(zToken," %d select ",pElem-&gt;input.pForm-&gt;form.id);
      Tcl_DStringAppend(&amp;cmd, zToken, -1);
      pElem-&gt;input.cnt = ++htmlPtr-&gt;nInput;
      zWin = MakeWindowName(htmlPtr, pElem);
      Tcl_DStringAppend(&amp;cmd, zWin, -1);
      Tcl_DStringStartSublist(&amp;cmd);
      HtmlAppendArglist(&amp;cmd, pElem);
      Tcl_DStringEndSublist(&amp;cmd);
      Tcl_DStringStartSublist(&amp;cmd);
      AddSelectOptions(&amp;cmd, pElem, pElem-&gt;input.pEnd);
      Tcl_DStringEndSublist(&amp;cmd);
      HtmlLock(htmlPtr);
      result = Tcl_GlobalEval(htmlPtr-&gt;interp, Tcl_DStringValue(&amp;cmd));
      Tcl_DStringFree(&amp;cmd);
      if( !HtmlUnlock(htmlPtr) ){
        SizeAndLink(htmlPtr, zWin, pElem);
      }
      HtmlFree(zWin);
      break;
    }
    case INPUT_TYPE_TextArea: {
      int result;
      char zToken[50];

      if( pElem-&gt;input.pForm==0 || htmlPtr-&gt;zFormCommand==0 
           || htmlPtr-&gt;zFormCommand[0]==0 ){
        EmptyInput(pElem);
        break;
      }
      Tcl_DStringInit(&amp;cmd);
      Tcl_DStringAppend(&amp;cmd, htmlPtr-&gt;zFormCommand, -1);
      sprintf(zToken," %d textarea ",pElem-&gt;input.pForm-&gt;form.id);
      Tcl_DStringAppend(&amp;cmd, zToken, -1);
      pElem-&gt;input.cnt = ++htmlPtr-&gt;nInput;
      zWin = MakeWindowName(htmlPtr, pElem);
      Tcl_DStringAppend(&amp;cmd, zWin, -1);
      Tcl_DStringStartSublist(&amp;cmd);
      HtmlAppendArglist(&amp;cmd, pElem);
      Tcl_DStringEndSublist(&amp;cmd);
      Tcl_DStringStartSublist(&amp;cmd);
      HtmlAppendText(&amp;cmd, pElem, pElem-&gt;input.pEnd);
      Tcl_DStringEndSublist(&amp;cmd);
      HtmlLock(htmlPtr);
      result = Tcl_GlobalEval(htmlPtr-&gt;interp, Tcl_DStringValue(&amp;cmd));
      Tcl_DStringFree(&amp;cmd);
      if( !HtmlUnlock(htmlPtr) ){
        SizeAndLink(htmlPtr, zWin, pElem);
      }
      HtmlFree(zWin);
      break;
    }
    case INPUT_TYPE_Applet: {
      int result;

      if( htmlPtr-&gt;zAppletCommand==0 || htmlPtr-&gt;zAppletCommand[0]==0 ){
        EmptyInput(pElem);
        break;
      }
      Tcl_DStringInit(&amp;cmd);
      Tcl_DStringAppend(&amp;cmd, htmlPtr-&gt;zAppletCommand, -1);
      Tcl_DStringAppend(&amp;cmd, " ", 1);
      pElem-&gt;input.cnt = ++htmlPtr-&gt;nInput;
      zWin = MakeWindowName(htmlPtr, pElem);
      Tcl_DStringAppend(&amp;cmd, zWin, -1);
      Tcl_DStringStartSublist(&amp;cmd);
      HtmlAppendArglist(&amp;cmd, pElem);
      Tcl_DStringEndSublist(&amp;cmd);
      HtmlLock(htmlPtr);
      result = Tcl_GlobalEval(htmlPtr-&gt;interp, Tcl_DStringValue(&amp;cmd));
      Tcl_DStringFree(&amp;cmd);
      if( !HtmlUnlock(htmlPtr) ){
        SizeAndLink(htmlPtr, zWin, pElem);
      }
      HtmlFree(zWin);
      break;
    }
    default: {
      CANT_HAPPEN;
      pElem-&gt;base.flags &amp;= ~HTML_Visible;
      pElem-&gt;base.style.flags |= STY_Invisible;
      pElem-&gt;input.tkwin = 0;
      break;
    }
  }
  return incomplete;
}
</t>
<t tx="ekr.20041214071955.65">
#if 0
/*
** The following array determines which characters can be put directly
** in a query string and which must be escaped.
*/
static char needEscape[] = {
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
   1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,
   1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1,
};
#define NeedToEscape(C) ((C)&gt;0 &amp;&amp; (C)&lt;127 &amp;&amp; needEscape[(int)(C)])

/*
** Append to the given DString, an encoded version of the given
** text.
*/
static void EncodeText(Tcl_DString *str, char *z){
  int i;
  while( *z ){
    for(i=0; z[i] &amp;&amp; !NeedToEscape(z[i]); i++){ TestPoint(0); }
    if( i&gt;0 ){ TestPoint(0); Tcl_DStringAppend(str, z, i); }
    z += i;
    while( *z &amp;&amp; NeedToEscape(*z) ){
      if( *z==' ' ){
        Tcl_DStringAppend(str,"+",1);
        TestPoint(0);
      }else if( *z=='\n' ){
        Tcl_DStringAppend(str, "%0D%0A", 6);
        TestPoint(0);
      }else if( *z=='\r' ){
        /* Ignore it... */
        TestPoint(0);
      }else{
        char zBuf[5];
        sprintf(zBuf,"%%%02X",0xff &amp; *z);
        Tcl_DStringAppend(str, zBuf, 3);
        TestPoint(0);
      }
      z++;
    }
  }
}

#endif
</t>
<t tx="ekr.20041214071955.66">@ignore
@language c
static char const rcsid[] = "@(#) $Id: htmlimage.c,v 1.12 2000/02/25 13:57:03 drh Exp $";
/* Routines used for processing &lt;IMG&gt; markup */

#include &lt;tk.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include "htmlimage.h"

@others
</t>
<t tx="ekr.20041214071955.68">// Find the alignment for an image

int HtmlGetImageAlignment(HtmlElement *p){
  char *z;
  int i;
  int result;

  static struct {
     char *zName;
     int iValue;
  } aligns[] = {
    { "bottom",     IMAGE_ALIGN_Bottom    },
    { "baseline",   IMAGE_ALIGN_Bottom    },
    { "middle",     IMAGE_ALIGN_Middle    },
    { "top",        IMAGE_ALIGN_Top       },
    { "absbottom",  IMAGE_ALIGN_AbsBottom },
    { "absmiddle",  IMAGE_ALIGN_AbsMiddle },
    { "texttop",    IMAGE_ALIGN_TextTop   },
    { "left",       IMAGE_ALIGN_Left      },
    { "right",      IMAGE_ALIGN_Right     },
  };

  z = HtmlMarkupArg(p, "align", 0);
  result = IMAGE_ALIGN_Bottom;
  if( z ){
    for(i=0; i&lt;sizeof(aligns)/sizeof(aligns[0]); i++){
      if( stricmp(aligns[i].zName,z)==0 ){
        result = aligns[i].iValue;
        TestPoint(0);
        break;
      }else{
        TestPoint(0);
      }
    }
  }else{
    TestPoint(0);
  }
  return result;
}
</t>
<t tx="ekr.20041214071955.69">@ ** This routine is called when an image changes. If the size of the ** images changes, then we need to completely redo the layout. If ** only the appearance changes, then this works like an expose event.
@c

static void ImageChangeProc(
  ClientData clientData,    /* Pointer to an HtmlImage structure */
  int x,                    /* Left edge of region that changed */
  int y,                    /* Top edge of region that changed */
  int w,                    /* Width of region that changes.  Maybe 0 */
  int h,                    /* Height of region that changed.  Maybe 0 */
  int newWidth,             /* New width of the image */
  int newHeight             /* New height of the image */
){
  HtmlImage *pImage;
  HtmlWidget *htmlPtr;
  HtmlElement *pElem;

  pImage = (HtmlImage*)clientData;
  htmlPtr = pImage-&gt;htmlPtr;
  if( pImage-&gt;w!=newWidth || pImage-&gt;h!=newHeight ){
    /* We have to completely redo the layout after adjusting the size
    ** of the images */
    for(pElem = pImage-&gt;pList; pElem; pElem = pElem-&gt;image.pNext){
      pElem-&gt;image.w = newWidth;
      pElem-&gt;image.h = newHeight;
      TestPoint(0);
    }
    htmlPtr-&gt;flags |= RELAYOUT;
    pImage-&gt;w = newWidth;
    pImage-&gt;h = newHeight;
    HtmlRedrawEverything(htmlPtr);
  }else{
    for(pElem = pImage-&gt;pList; pElem; pElem = pElem-&gt;image.pNext){
      pElem-&gt;image.redrawNeeded = 1;
    }
    htmlPtr-&gt;flags |= REDRAW_IMAGES;
    HtmlScheduleRedraw(htmlPtr);
  }
}
</t>
<t tx="ekr.20041214071955.70">@ ** Append all the arguments of the given markup to the given ** DString. ** ** Example: If the markup is &lt;IMG SRC=image.gif ALT="hello!"&gt; ** then the following text is appended to the DString: ** **    "src image.gif alt hello!" ** ** Notice how all attribute names are converted to lower case. ** This conversion happens in the parser.
@c

void HtmlAppendArglist(Tcl_DString *str, HtmlElement *pElem){
  int i;
  for(i=0; i+1&lt;pElem-&gt;base.count; i+=2){
    char *z = pElem-&gt;markup.argv[i+1];
    Tcl_DStringAppendElement(str, pElem-&gt;markup.argv[i]);
    Tcl_DStringAppendElement(str, z);
  }
}
</t>
<t tx="ekr.20041214071955.71">@ ** Given an &lt;IMG&gt; markup, find or create an appropriate HtmlImage ** structure and return a pointer to that structure. NULL might ** be returned. ** ** This routine may invoke a callback procedure which could delete ** the HTML widget. Use HtmlLock() if necessary to preserve the ** widget structure.
@c

HtmlImage *HtmlGetImage(HtmlWidget *htmlPtr, HtmlElement *p){
  char *zWidth;
  char *zHeight;
  char *zSrc;
  char *zImageName;
  HtmlImage *pImage;
  int result;
  Tcl_DString cmd;
  int lenSrc, lenW, lenH;   /* Lengths of various strings */

  if( p-&gt;base.type!=Html_IMG ){ CANT_HAPPEN; return 0; }
  if( htmlPtr-&gt;zGetImage==0 || htmlPtr-&gt;zGetImage[0]==0 ){
    TestPoint(0);
    return 0;
  }
  zSrc = HtmlMarkupArg(p, "src", 0);
  if( zSrc==0 ){
    return 0;
  }
  HtmlLock(htmlPtr);
  zSrc = HtmlResolveUri(htmlPtr, zSrc);
  if( HtmlUnlock(htmlPtr) || zSrc==0 ) return 0;
  zWidth = HtmlMarkupArg(p, "width", "");
  zHeight = HtmlMarkupArg(p, "height", "");
  for(pImage=htmlPtr-&gt;imageList; pImage; pImage=pImage-&gt;pNext){
    if( strcmp(pImage-&gt;zUrl,zSrc)==0 
    &amp;&amp;  strcmp(pImage-&gt;zWidth, zWidth)==0
    &amp;&amp;  strcmp(pImage-&gt;zHeight, zHeight)==0 ){
      HtmlFree(zSrc);
      return pImage;
    }
  }
  Tcl_DStringInit(&amp;cmd);
  Tcl_DStringAppend(&amp;cmd, htmlPtr-&gt;zGetImage, -1);
  Tcl_DStringAppendElement(&amp;cmd,zSrc);
  Tcl_DStringAppendElement(&amp;cmd,zWidth);
  Tcl_DStringAppendElement(&amp;cmd,zHeight);
  Tcl_DStringStartSublist(&amp;cmd);
  HtmlAppendArglist(&amp;cmd, p);
  Tcl_DStringEndSublist(&amp;cmd);
  HtmlLock(htmlPtr);
  result = Tcl_GlobalEval(htmlPtr-&gt;interp, Tcl_DStringValue(&amp;cmd));
  Tcl_DStringFree(&amp;cmd);
  if( HtmlUnlock(htmlPtr) ){
    HtmlFree(zSrc);
  }
  zImageName = htmlPtr-&gt;interp-&gt;result;
  lenSrc = strlen(zSrc);
  lenW = strlen(zWidth);
  lenH = strlen(zHeight);
  pImage = HtmlAlloc( sizeof(HtmlImage) + lenSrc + lenW + lenH + 3 );
  memset(pImage,0,sizeof(HtmlImage));
  pImage-&gt;htmlPtr = htmlPtr;
  pImage-&gt;zUrl = (char*)&amp;pImage[1];
  strcpy(pImage-&gt;zUrl,zSrc);
  HtmlFree(zSrc);
  pImage-&gt;zWidth = &amp;pImage-&gt;zUrl[lenSrc+1];
  strcpy(pImage-&gt;zWidth, zWidth);
  pImage-&gt;zHeight = &amp;pImage-&gt;zWidth[lenW+1];
  strcpy(pImage-&gt;zHeight, zHeight);
  pImage-&gt;w = 0;
  pImage-&gt;h = 0;
  if( result==TCL_OK ){
    pImage-&gt;image = Tk_GetImage(htmlPtr-&gt;interp, htmlPtr-&gt;clipwin,
                                zImageName, ImageChangeProc, pImage);
    TestPoint(0);
  }else{
    Tcl_AddErrorInfo(htmlPtr-&gt;interp,
      "\n    (\"-imagecommand\" command executed by html widget)");
    Tcl_BackgroundError(htmlPtr-&gt;interp);
    pImage-&gt;image = 0;
    TestPoint(0);
  }
  if( pImage-&gt;image==0 ){
    HtmlFree((char*)pImage);
    TestPoint(0);
    return 0;
  }
  pImage-&gt;pNext = htmlPtr-&gt;imageList;
  htmlPtr-&gt;imageList = pImage;
  TestPoint(0);
  Tcl_ResetResult(htmlPtr-&gt;interp);
  return pImage;
}
</t>
<t tx="ekr.20041214071955.72">@ignore
@language c
static char const rcsid[] = "@(#) $Id: htmlindex.c,v 1.7 2000/01/31 13:23:46 drh Exp $";
/* Routines that deal with indexes */
&lt;&lt; htmlindex #includes &gt;&gt;
@others
</t>
<t tx="ekr.20041214071955.73">#include &lt;ctype.h&gt;
#include &lt;tk.h&gt;
#include "htmlindex.h"
</t>
<t tx="ekr.20041214071955.74">@ Return a pointer to the Nth HtmlElement in the list. If there is no Nth element, return 0 if flag==0 and return either the first or last element (whichever is closest) if flag!=0
@c

HtmlElement *HtmlTokenByIndex(HtmlWidget *htmlPtr, int N, int flag){
  HtmlElement *p;
  int n;

  if( N &gt; htmlPtr-&gt;nToken/2 ){
    /* Start at the end and work back toward the beginning */
    for(p=htmlPtr-&gt;pLast, n=htmlPtr-&gt;nToken; p; p=p-&gt;base.pPrev){
      if( p-&gt;base.type!=Html_Block ){
        if( n==N ){ TestPoint(0); break; }
        n--;
        TestPoint(0);
      }else{
        TestPoint(0);
      }
    }
  }else{
    /* Start at the beginning and work forward */
    for(p=htmlPtr-&gt;pFirst; p; p = p-&gt;base.pNext){
      if( p-&gt;base.type!=Html_Block ){
        N--;
        if( N&lt;=0 ){ TestPoint(0); break; }
      }else{
        TestPoint(0);
      }
    }
  }
  return p;
}
</t>
<t tx="ekr.20041214071955.75">// Return the token number for the given HtmlElement

int HtmlTokenNumber(HtmlElement *p){
  int n = 0;

  while( p ){
    if( p-&gt;base.type!=Html_Block ){ 
      TestPoint(0); 
      n++;
    }else{
      TestPoint(0);
    }
    p = p-&gt;base.pPrev;
  }
  return n;
}
</t>
<t tx="ekr.20041214071955.76">@ ** Find the maximum index for the given token
@c

static void maxIndex(HtmlElement *p, int *pIndex){
  if( p==0 ){
    *pIndex = 0;
    TestPoint(0);
  }else{
    switch( p-&gt;base.type ){
      case Html_Text:
        *pIndex = p-&gt;base.count-1;
        TestPoint(0);
        break;
      case Html_Space:
        if( p-&gt;base.style.flags &amp; STY_Preformatted ){
          *pIndex = p-&gt;base.count-1;
          TestPoint(0);
        }else{
          *pIndex = 0;
          TestPoint(0);
        }
        break;
      default:
        *pIndex = 0;
        TestPoint(0);
        break;
    }
  }
}
</t>
<t tx="ekr.20041214071955.77">@ ** Given a Block and an x coordinate, find the Index of the character ** that is closest to the given x coordinate. ** ** The x-coordinate might specify a point to the left of the block, ** in which case the procedure returns the first token and a character ** index of 0. Or the x-coordinate might specify a point to the right ** of the block, in which case the last token is returned with an index ** equal to its last character.
@c

static void FindIndexInBlock(
  HtmlWidget *htmlPtr,       /* The widget */
  HtmlBlock *pBlock,         /* The block */
  int x,                     /* The x coordinate */
  HtmlElement **ppToken,     /* Write the closest token here */
  int *pIndex                /* Write the charater index in ppToken here */
){
  HtmlElement *p;
  Tk_Font font;
  int len;
  int n;

  p = pBlock-&gt;base.pNext;
  HtmlLock(htmlPtr);
  font = HtmlGetFont(htmlPtr, p-&gt;base.style.font);
  if( HtmlUnlock(htmlPtr) ){
    *ppToken = p;
    *pIndex = 0;
    return;
  }
  if( x &lt;= pBlock-&gt;left ){
    *ppToken = p;
    *pIndex = 0;
    TestPoint(0);
    return;
  }else if( x&gt;= pBlock-&gt;right ){
    *ppToken = p;
    *pIndex = 0;
    while( p &amp;&amp; p-&gt;base.type!=Html_Block ){
      *ppToken = p;
      p = p-&gt;base.pNext;
      TestPoint(0);
    }
    p = *ppToken;
    if( p &amp;&amp; p-&gt;base.type==Html_Text ){
      *pIndex = p-&gt;base.count - 1;
      TestPoint(0);
    }else{
      TestPoint(0);
    }
    return;
  }
  if( pBlock-&gt;n==0 ){
    *ppToken = p;
    *pIndex = 0;
    TestPoint(0);
  }else{
    TestPoint(0);
  }
  n = Tk_MeasureChars(font, pBlock-&gt;z, pBlock-&gt;n, x - pBlock-&gt;left, 0, &amp;len);
  *pIndex = 0;
  *ppToken = 0;
  while( p &amp;&amp; n&gt;=0 ){
    switch( p-&gt;base.type ){
      case Html_Text:
        if( n&lt;p-&gt;base.count ){
          *pIndex = n;
          TestPoint(0);
        }else{
          *pIndex = p-&gt;base.count - 1;
          TestPoint(0);
        }
        *ppToken = p;
        n -= p-&gt;base.count;
        break;
      case Html_Space:
        if( p-&gt;base.style.flags &amp; STY_Preformatted ){
          if( n&lt;p-&gt;base.count ){
            *pIndex = n;
            TestPoint(0);
          }else{
            *pIndex = p-&gt;base.count - 1;
            TestPoint(0);
          }
          *ppToken = p;
          n -= p-&gt;base.count;
        }else{
          *pIndex = 0;
          *ppToken = p;
          n--;
          TestPoint(0);
        }
        break;
      default:
        TestPoint(0);
        break;
    }
    if( p ){
      p = p-&gt;base.pNext;
      TestPoint(0);
    }else{
      TestPoint(0);
    }
  }
}
</t>
<t tx="ekr.20041214071955.78">@ ** Convert an Element-based index into a Block-based index. ** ** In other words, given a pointer to an element and an index ** of a particular character within that element, compute a ** pointer to the HtmlBlock used to display that character and ** the index in the HtmlBlock of the character.
@c

void HtmlIndexToBlockIndex(
  HtmlWidget *htmlPtr,        /* The widget */
  HtmlIndex sIndex,           /* The index to be translated */
  HtmlBlock **ppBlock,        /* Write the corresponding block here */
  int *piIndex                /* Write the block index here */
){
  int n = sIndex.i;
  HtmlElement *p;

  if( sIndex.p==0 ){
    *ppBlock = 0;
    *piIndex = 0;
    TestPoint(0);
    return;
  }
  p = sIndex.p-&gt;base.pPrev;
  while( p &amp;&amp; p-&gt;base.type!=Html_Block ){
    switch( p-&gt;base.type ){
      case Html_Text:
        n += p-&gt;base.count;
        TestPoint(0);
        break;
      case Html_Space:
        if( p-&gt;base.style.flags &amp; STY_Preformatted ){
          n += p-&gt;base.count;
          TestPoint(0);
        }else{
          n++;
          TestPoint(0);
        }
        break;
      default:
        TestPoint(0);
        break;
    }
    p = p-&gt;base.pPrev;
  }
  if( p ){
    *ppBlock = &amp;p-&gt;block;
    *piIndex = n;
    TestPoint(0);
    return;
  }
  for(p=sIndex.p; p &amp;&amp; p-&gt;base.type!=Html_Block; p=p-&gt;base.pNext){
    TestPoint(0);
  }
  *ppBlock = &amp;p-&gt;block;
  *piIndex = 0;
}
</t>
<t tx="ekr.20041214071955.79">@ ** Given a base index name (without any modifiers) return a pointer ** to the token described, and the character within that token. ** ** Valid input forms include: ** **    N.M     Token number N (with numbering starting at 1) and **          character number M (with numbering starting at 0). ** **    end     The end of all text ** **    N.last    Last character of token number N. ** **    sel.first  First character of the selection. ** **    sel.last   Last character of the selection. ** **    ins     The character holding the insertion cursor. ** **    @X,Y     The character a location X,Y of the clipping window. ** ** Zero is returned if we are successful and non-zero if there is ** any kind of error. ** ** If the given token doesn't exist (for example if there are only 10 ** tokens and 11.5 is requested) then *ppToken is left pointing to NULL. ** But the function still returns 0 for success.
@c

static int DecodeBaseIndex(
  HtmlWidget *htmlPtr,     /* The HTML widget we are dealing with */
  const char *zBase,       /* The base index string */
  HtmlElement **ppToken,   /* Write the pointer to the token here */
  int *pIndex              /* Write the character offset here */
){
  int x, y;
  int n;
  int i;
  HtmlElement *p;
  HtmlBlock *pBlock;
  HtmlBlock *pNearby;
  int dist = 1000000;
  int rc = 0;

  while( isspace(*zBase) ){ TestPoint(0); zBase++; }
  switch( *zBase ){
    case '1': case '2': case '3': case '4': case '5':
    case '6': case '7': case '8': case '9':
      n = sscanf(zBase,"%d.%d",&amp;x,&amp;y);
      if( n&gt;0 ){
        p = *ppToken = HtmlTokenByIndex(htmlPtr, x, 0);
        TestPoint(0);
      }else{
        TestPoint(0);
      }
      if( n==2 ){
        *pIndex = y;
        TestPoint(0);
      }else{
        for(i=1; isdigit(zBase[i]); i++){ TestPoint(0); }
        if( zBase[i]==0 ){
          *pIndex = 0;
          TestPoint(0);
        }else if( strcmp(&amp;zBase[i],".last")==0 ){
          maxIndex(p,pIndex);
          TestPoint(0);
        }else{
          rc = 1;
          TestPoint(0);
        }
      }
      break;
    case 'e':
      if( strcmp(zBase,"end")==0 ){
        p = *ppToken = htmlPtr-&gt;pLast;
        maxIndex(p,pIndex);
        TestPoint(0);
      }else{
        rc = 1;
        TestPoint(0);
      }
      break;
    case 's':
      if( strcmp(zBase,"sel.first")==0 ){
        *ppToken = htmlPtr-&gt;selBegin.p;
        *pIndex = htmlPtr-&gt;selBegin.i;
        TestPoint(0);
      }else if( strcmp(zBase,"sel.last")==0 ){
        *ppToken = htmlPtr-&gt;selEnd.p;
        *pIndex = htmlPtr-&gt;selEnd.i;
        TestPoint(0);
      }else{
        rc = 1;
        TestPoint(0);
      }
      break;
    case 'i':
      if( strcmp(zBase,"insert")==0 ){
        *ppToken = htmlPtr-&gt;ins.p;
        *pIndex = htmlPtr-&gt;ins.i;
        TestPoint(0);
      }else{
        rc = 1;
        TestPoint(0);
      }
      break;
    case '@':
      n = sscanf(zBase,"@%d,%d",&amp;x,&amp;y);
      if( n!=2 ){
        rc = 1;
        TestPoint(0);
        break;
      }
      x += htmlPtr-&gt;xOffset;
      y += htmlPtr-&gt;yOffset;
      pNearby = 0;
      *ppToken = htmlPtr-&gt;pLast;
      *pIndex = 0;
      for(pBlock=htmlPtr-&gt;firstBlock; pBlock; pBlock=pBlock-&gt;pNext){
        int dotest;
        if( pBlock-&gt;n==0 ){
          switch( pBlock-&gt;base.pNext-&gt;base.type ){
            case Html_LI:
            case Html_IMG:
            case Html_INPUT:
            case Html_TEXTAREA:
            case Html_SELECT:
              dotest = 1;
              TestPoint(0);
              break;
            default:
              dotest = 0;
              TestPoint(0);
              break;
          }
        }else{
          dotest = 1;
          TestPoint(0);
        }
        if (dotest){ 
          if( pBlock-&gt;top &lt;= y &amp;&amp; pBlock-&gt;bottom &gt;= y ){
            if( pBlock-&gt;left &gt; x ){
              if( pBlock-&gt;left - x &lt; dist ){
                dist = pBlock-&gt;left - x;
                pNearby = pBlock;
                TestPoint(0);
              }else{
                TestPoint(0);
              }
            }else if( pBlock-&gt;right &lt; x ){
              if( x - pBlock-&gt;right &lt; dist ){
                dist = x - pBlock-&gt;right;
                pNearby = pBlock;
                TestPoint(0);
              }else{
                TestPoint(0);
              }
            }else{
              HtmlLock(htmlPtr);
              FindIndexInBlock(htmlPtr, pBlock, x, ppToken, pIndex);
              if( HtmlUnlock(htmlPtr) ) return 1;
              TestPoint(0);
              break;
            }
          }else{
            int distY;
            int distX;

            if( pBlock-&gt;bottom &lt; y ){
              distY = y - pBlock-&gt;bottom;
              TestPoint(0);
            }else{
              distY = pBlock-&gt;top - y;
              TestPoint(0);
            }
            if( pBlock-&gt;left &gt; x ){
              distX = pBlock-&gt;left - x;
              TestPoint(0);
            }else if( pBlock-&gt;right &lt; x ){
              distX = x - pBlock-&gt;right;
              TestPoint(0);
            }else{
              distX = 0;
              TestPoint(0);
            }
            if( distX + 4*distY &lt; dist ){
              dist = distX + 4*distY;
              pNearby = pBlock;
              TestPoint(0);
            }else{
              TestPoint(0);
            }
          }
        }
      }
      if( pBlock==0 ){
        if( pNearby ){
          HtmlLock(htmlPtr);
          FindIndexInBlock(htmlPtr, pNearby, x, ppToken, pIndex);
          if( HtmlUnlock(htmlPtr) ) return 1;
          TestPoint(0);
        }else{
          TestPoint(0);
        }
      }else{
        TestPoint(0);
      }
      break;
    default:
      rc = 1;
      TestPoint(0);
      break;
  }
  return rc;
}
</t>
<t tx="ekr.20041214071955.80">@ ** This routine decodes a complete index specification. A complete ** index consists of the base specification followed by modifiers.
@c

int HtmlGetIndex(
  HtmlWidget *htmlPtr,     /* The widget */
  char *zIndex,            /* Complete text of the index spec */
  HtmlElement **ppToken,   /* Write the pointer to the token here */
  int *pIndex              /* Write the character offset here */
){
  TestPoint(0);
  return DecodeBaseIndex(htmlPtr, zIndex, ppToken, pIndex);
}
</t>
<t tx="ekr.20041214071955.81">@ignore
@language c
static char const rcsid[] = "@(#) $Id: htmllayout.c,v 1.27 2000/01/31 13:23:46 drh Exp $";
/* This file contains the code used to position elements of the */
&lt;&lt; htmllayout #includes &gt;&gt;
@others
</t>
<t tx="ekr.20041214071955.82">#include &lt;tk.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "htmllayout.h"
</t>
<t tx="ekr.20041214071955.83">@ ** Push a new margin onto the given margin stack. ** ** If the "bottom" parameter is non-negative, then this margin will ** automatically expire for all text that is placed below the y-coordinate ** given by "bottom". This feature is used for &lt;IMG ALIGN=left&gt; ** and &lt;IMG ALIGN=right&gt; kinds of markup. It allows text to flow around ** an image. ** ** If "bottom" is negative, then the margin stays in force until ** it is explicitly canceled by a call to HtmlPopMargin().
@c

void HtmlPushMargin(
  HtmlMargin **ppMargin,  /* The margin stack onto which to push */
  int indent,             /* The indentation for the new margin */
  int bottom,             /* The margin expires at this Y coordinate */
  int tag                 /* Markup that will cancel this margin */
){
  HtmlMargin *pNew = HtmlAlloc( sizeof(HtmlMargin) );
  pNew-&gt;pNext = *ppMargin;
  if( pNew-&gt;pNext ){
    pNew-&gt;indent = indent + pNew-&gt;pNext-&gt;indent;
    TestPoint(0);
  }else{
    pNew-&gt;indent = indent;
    TestPoint(0);
  }
  pNew-&gt;bottom = bottom;
  pNew-&gt;tag = tag;
  *ppMargin = pNew;
}
</t>
<t tx="ekr.20041214071955.84">@ ** Pop one margin off of the given margin stack.
@c

static void HtmlPopOneMargin(HtmlMargin **ppMargin){
  if( *ppMargin ){
    HtmlMargin *pOld = *ppMargin;
    *ppMargin = pOld-&gt;pNext;
    HtmlFree(pOld);
  }
}
</t>
<t tx="ekr.20041214071955.85">@ ** Pop as many margins as necessary until the margin that was ** created with "tag" is popped off. Update the layout context ** to move past obsticles, if necessary. ** ** If there are some margins on the stack that contain non-negative ** bottom fields, that means there are some obsticles that we have ** not yet cleared. If these margins get popped off the stack, ** then we have to be careful to advance the pLC-&gt;bottom value so ** that the next line of text will clear the obsticle.
@c

static void HtmlPopMargin(
  HtmlMargin **ppMargin,      /* The margin stack to be popped */
  int tag,                    /* The tag we want to pop */
  HtmlLayoutContext *pLC      /* Update this layout context */
){
  int bottom = -1;
  int oldTag;
  HtmlMargin *pM;

  for(pM=*ppMargin; pM &amp;&amp; pM-&gt;tag!=tag; pM=pM-&gt;pNext){}
  if( pM==0 ){
    /* No matching margin is found.  Do nothing. */
    return;
  }
  while( (pM=*ppMargin)!=0 ){
    if( pM-&gt;bottom&gt;bottom ){
      bottom = pM-&gt;bottom;
    }
    oldTag = pM-&gt;tag;
    HtmlPopOneMargin(ppMargin);
    if( oldTag==tag ) break;
  }
  if( pLC &amp;&amp; pLC-&gt;bottom&lt;bottom ){
    pLC-&gt;headRoom += bottom - pLC-&gt;bottom;
    pLC-&gt;bottom = bottom;
  }
}
</t>
<t tx="ekr.20041214071955.86">@ ** Pop all expired margins from the stack.  ** ** An expired margin is one with a non-negative bottom parameter ** that is less than the value "y". "y" is the Y-coordinate of ** the top edge the next line of text to by positioned. What this ** function does is check to see if we have cleared any obsticles ** (an obsticle is an &lt;IMG ALIGN=left&gt; or &lt;IMG ALIGN=right&gt;) and ** expands the margins if we have.
@c

static void PopExpiredMargins(HtmlMargin **ppMarginStack, int y){
  while( *ppMarginStack &amp;&amp; (**ppMarginStack).bottom&gt;=0 &amp;&amp;
       (**ppMarginStack).bottom &lt;= y ){
    HtmlPopOneMargin(ppMarginStack);
  }
}
</t>
<t tx="ekr.20041214071955.87">@ ** Clear a margin stack to reclaim memory. This routine just blindly ** pops everything off the stack. Typically used when the screen is ** cleared or the widget is deleted, etc.
@c

void HtmlClearMarginStack(HtmlMargin **ppMargin){
  while( *ppMargin ){
    HtmlPopOneMargin(ppMargin);
  }
}
</t>
<t tx="ekr.20041214071955.88">@ ** This routine gathers as many tokens as will fit on one line. ** ** The candidate tokens begin with pStart and go thru the end of ** the list or to pEnd, whichever comes first. The first token ** at the start of the next line is returned. NULL is returned if ** we exhaust data. ** ** "width" is the maximum allowed width of the line. The actual ** width is returned in *actualWidth. The actual width does not ** include any trailing spaces. Sometimes the actual width will ** be greater than the maximum width. This will happen, for example, ** for text enclosed in &lt;pre&gt;..&lt;/pre&gt; that has lines longer than ** the width of the page. ** ** If the list begins with text, at least one token is returned, ** even if that one token is longer than the allowed line length. ** But if the list begins with some kind of break markup (possibly ** preceded by white space) then the returned list may be empty. ** ** The "x" coordinates of all elements are set assuming that the line ** begins at 0. The calling routine should adjust these coordinates ** to position the line horizontally. (The FixLine() procedure does ** this.) Note that the "x" coordinate of &lt;li&gt; elements will be negative. ** Text within &lt;dt&gt;..&lt;/dt&gt; might also have a negative "x" coordinate. ** But in no case will the x coordinate every be less than "minX".
@c

static HtmlElement *GetLine(
  HtmlLayoutContext *pLC,      /* The complete layout context.  */
  HtmlElement *pStart,         /* First token on new line */
  HtmlElement *pEnd,           /* End of line.  Might be NULL */
  int width,                   /* How much space is on this line */
  int minX,                    /* The minimum value of the X coordinate */
  int *actualWidth             /* Return space actually required */
){
  int x;                       /* Current X coordinate */
  int spaceWanted = 0;         /* Add this much space before next token */
  HtmlElement *p;              /* For looping over tokens */
  HtmlElement *lastBreak = 0;  /* Last line-break opportunity */
  int isEmpty = 1;             /* True if link contains nothing */
  int origin;                  /* Initial value of "x" */
  
  *actualWidth = 0;
  p = pStart;
  while( p &amp;&amp; p!=pEnd &amp;&amp; (p-&gt;base.style.flags &amp; STY_Invisible)!=0 ){
    p = p-&gt;pNext;
  }
  if( p &amp;&amp; p-&gt;base.style.flags &amp; STY_DT ){
    origin = -HTML_INDENT;
  }else{
    origin = 0;
  }
  x = origin;
  if( x&lt;minX ){ x = minX; }
  if( p &amp;&amp; p!=pEnd &amp;&amp; p-&gt;base.type==Html_LI ){
    p-&gt;li.x = x - HTML_INDENT/3;
    if( p-&gt;li.x - (HTML_INDENT*2)/3&lt;minX ){
      x += minX - p-&gt;li.x + (HTML_INDENT*2)/3;
      p-&gt;li.x = minX + (HTML_INDENT*2)/3;
    }
    isEmpty = 0;
    *actualWidth = 1;
    p = p-&gt;pNext;
    while( p &amp;&amp; (p-&gt;base.type==Html_Space || p-&gt;base.type==Html_P) ){
      p = p-&gt;pNext;
    }
  }
  for(; p &amp;&amp; p!=pEnd; p=p-&gt;pNext){
    if( p-&gt;base.style.flags &amp; STY_Invisible ){
      continue;
    }
    switch( p-&gt;base.type ){
      case Html_Text:
        p-&gt;text.x = x + spaceWanted;
        if( (p-&gt;base.style.flags &amp; STY_Preformatted) == 0 ){
          if( lastBreak &amp;&amp; x + spaceWanted + p-&gt;text.w &gt; width ){
            TestPoint(0);
            return lastBreak;
          }
        }
        TRACE(HtmlTrace_GetLine2, ("Place token %s at x=%d w=%d\n",
           HtmlTokenName(p), p-&gt;text.x, p-&gt;text.w));
        x += p-&gt;text.w + spaceWanted;
        isEmpty = 0;
        spaceWanted = 0;
        break;

      case Html_Space:
        if( p-&gt;base.style.flags &amp; STY_Preformatted ){
          if( p-&gt;base.flags &amp; HTML_NewLine ){
            *actualWidth = x&lt;=0 ? 1 : x;
            TestPoint(0);
            return p-&gt;pNext;
          }
          x += p-&gt;space.w * p-&gt;base.count;
          TestPoint(0);
        }else{
          int w;
          if( (p-&gt;base.style.flags &amp; STY_NoBreak)==0 ){
            lastBreak = p-&gt;pNext;
            *actualWidth = x&lt;=0 &amp;&amp; !isEmpty ? 1 : x;
          }
          w = p-&gt;space.w;
          if( spaceWanted &lt; w &amp;&amp; x&gt;origin ){
            spaceWanted = w;
          }
        }
        break;

      case Html_IMG:
        switch( p-&gt;image.align ){
          case IMAGE_ALIGN_Left:
          case IMAGE_ALIGN_Right:
            *actualWidth = x&lt;=0 &amp;&amp; !isEmpty ? 1 : x;
            return p;
          default:
            break;
        }
        p-&gt;image.x = x + spaceWanted;
        if( (p-&gt;base.style.flags &amp; STY_Preformatted) == 0 ){
          if( lastBreak &amp;&amp; x + spaceWanted + p-&gt;image.w &gt; width ){
            TestPoint(0);
            return lastBreak;
          }
        }
        TRACE(HtmlTrace_GetLine2, ("Place in-line image %s at x=%d w=%d\n",
           HtmlTokenName(p), p-&gt;image.x, p-&gt;image.w));
        x += p-&gt;image.w + spaceWanted;
        if( (p-&gt;base.style.flags &amp; STY_NoBreak)==0 ){
          lastBreak = p-&gt;pNext;
          *actualWidth = x&lt;=0 &amp;&amp; !isEmpty ? 1 : x;
        }
        spaceWanted = 0;
        isEmpty = 0;
        break;

      case Html_APPLET:
      case Html_EMBED:
      case Html_INPUT:
      case Html_SELECT:
      case Html_TEXTAREA:
        p-&gt;input.x = x + spaceWanted + p-&gt;input.padLeft;
        if( (p-&gt;base.style.flags &amp; STY_Preformatted) == 0 ){
          if( lastBreak &amp;&amp; x + spaceWanted + p-&gt;input.w &gt; width ){
            TestPoint(0);
            return lastBreak;
          }
        }
        TRACE(HtmlTrace_GetLine2, ("Place token %s at x=%d w=%d\n",
           HtmlTokenName(p), p-&gt;input.x, p-&gt;input.w));
        x = p-&gt;input.x + p-&gt;input.w;
        if( (p-&gt;base.style.flags &amp; STY_NoBreak)==0 ){
          lastBreak = p-&gt;pNext;
          *actualWidth = x&lt;=0 &amp;&amp; !isEmpty ? 1 : x;
        }
        spaceWanted = 0;
        isEmpty = 0;
        break;

      case Html_EndTEXTAREA:
        if( p-&gt;ref.pOther ){
          /* HtmlResetTextarea(pLC-&gt;htmlPtr, p-&gt;ref.pOther); */
        }
        break;

      case Html_DD:
        if( p-&gt;ref.pOther==0 ) break;
        if( p-&gt;ref.pOther-&gt;list.compact==0 || x + spaceWanted &gt;= 0 ){
          *actualWidth = x&lt;=0 &amp;&amp; !isEmpty ? 1 : x;
          return p;
        }
        x = 0;
        spaceWanted = 0;
        break;

      case Html_WBR:
        *actualWidth = x&lt;=0 &amp;&amp; !isEmpty ? 1 : x;
        if( x + spaceWanted &gt;= width ){
          return p-&gt;pNext;
        }else{
          lastBreak = p-&gt;pNext;
        }
        break;

      case Html_ADDRESS:
      case Html_EndADDRESS:
      case Html_BLOCKQUOTE:
      case Html_EndBLOCKQUOTE:
      case Html_BODY:
      case Html_EndBODY:
      case Html_BR:
      case Html_CAPTION:
      case Html_EndCAPTION:
      case Html_CENTER:
      case Html_EndCENTER:
      case Html_EndDD:
      case Html_DIV:
      case Html_EndDIV:
      case Html_DL:
      case Html_EndDL:
      case Html_DT:
      case Html_H1:
      case Html_EndH1:
      case Html_H2:
      case Html_EndH2:
      case Html_H3:
      case Html_EndH3:
      case Html_H4:
      case Html_EndH4:
      case Html_H5:
      case Html_EndH5:
      case Html_H6:
      case Html_EndH6:
      case Html_EndHTML:
      case Html_HR:
      case Html_LI:
      case Html_LISTING:
      case Html_EndLISTING:
      case Html_MENU:
      case Html_EndMENU:
      case Html_OL:
      case Html_EndOL:
      case Html_P:
      case Html_EndP:
      case Html_PRE:
      case Html_EndPRE:
      case Html_TABLE:
      case Html_EndTABLE:
      case Html_TD:
      case Html_EndTD:
      case Html_TH:
      case Html_EndTH:
      case Html_TR:
      case Html_EndTR:
      case Html_UL:
      case Html_EndUL:
        *actualWidth = x&lt;=0 &amp;&amp; !isEmpty ? 1 : x;
        return p;

      default:
        break;
    }
  }
  *actualWidth = x&lt;=0 &amp;&amp; !isEmpty ? 1 : x;
  return p;
}
</t>
<t tx="ekr.20041214071955.89">@ ** Set the y coordinate for every anchor in the given list
@c

static void FixAnchors(HtmlElement *p, HtmlElement *pEnd, int y){
  while( p &amp;&amp; p!=pEnd ){
    if( p-&gt;base.type==Html_A ){
      p-&gt;anchor.y = y;
    }
    p = p-&gt;pNext;
  }
}
</t>
<t tx="ekr.20041214071955.90">@ ** This routine computes the X and Y coordinates for all elements of ** a line that has been gathered using GetLine() above.  It also figures ** the ascent and descent for in-line images. ** ** The value returned is the Y coordinate of the bottom edge of the ** new line. The X coordinates are computed by adding the left margin ** plus any extra space needed for centering or right-justification.
@c

static int FixLine(
  HtmlElement *pStart,   /* Start of tokens for this line */
  HtmlElement *pEnd,     /* First token past end of this line.  Maybe NULL */
  int bottom,            /* Put the top of this line here */
  int width,             /* This is the space available to the line */
  int actualWidth,       /* This is the actual width needed by the line */
  int leftMargin,        /* The current left margin */
  int *maxX              /* Write maximum X coordinate of ink here */
){
  int dx;                /* Amount by which to increase all X coordinates */
  int maxAscent;         /* Maximum height above baseline */
  int maxTextAscent;     /* Maximum height above baseline for text */
  int maxDescent;        /* Maximum depth below baseline */
  int ascent, descent;   /* Computed ascent and descent for one element */
  HtmlElement *p;        /* For looping */
  int y;                 /* Y coordinate of the baseline */
  int dy2center;         /* Distance from baseline to text font center */
  int max = 0; 

  if( actualWidth&gt;0 ){
    for(p=pStart; p &amp;&amp; p!=pEnd &amp;&amp; p-&gt;base.type!=Html_Text; p=p-&gt;pNext){}
    if( p==pEnd || p==0 ) p = pStart;
    if( p-&gt;base.style.align == ALIGN_Center ){
      dx = leftMargin + (width - actualWidth)/2;
    }else if( p-&gt;base.style.align == ALIGN_Right ){
      dx = leftMargin + (width - actualWidth);
    }else{
      dx = leftMargin;
    }
    if( dx&lt;0 ) dx = 0;
    maxAscent = maxTextAscent = 0;
    for(p=pStart; p &amp;&amp; p!=pEnd; p=p-&gt;pNext){
      int ss;
      if( p-&gt;base.style.flags &amp; STY_Invisible ){
        continue;
      }
      switch( p-&gt;base.type ){
        case Html_Text:
          p-&gt;text.x += dx;
          max = p-&gt;text.x + p-&gt;text.w;
          ss = p-&gt;base.style.subscript;
          if( ss &gt; 0 ){
            int ascent = p-&gt;text.ascent;
            int delta = (ascent + p-&gt;text.descent)*ss/2;
            ascent += delta;
            p-&gt;text.y = -delta;
            if( ascent &gt; maxAscent ){ TestPoint(0); maxAscent = ascent; }
            if( ascent &gt; maxTextAscent ){ TestPoint(0); maxTextAscent = ascent;}
          }else if( ss &lt; 0 ){
            int descent = p-&gt;text.descent;
            int delta = (descent + p-&gt;text.ascent)*(-ss)/2;
            descent += delta;
            p-&gt;text.y = delta;
          }else{
            p-&gt;text.y = 0;
            if( p-&gt;text.ascent &gt; maxAscent ){ 
              maxAscent = p-&gt;text.ascent;
            }
            if( p-&gt;text.ascent &gt; maxTextAscent ){
              maxTextAscent = p-&gt;text.ascent;
            }
          }
          break;
        case Html_Space:
          if( p-&gt;space.ascent &gt; maxAscent ){ 
            maxAscent = p-&gt;space.ascent;
          }
          break;
        case Html_LI:
          p-&gt;li.x += dx;
          if( p-&gt;li.x &gt; max ){
            max = p-&gt;li.x; 
          }
          break;
        case Html_IMG:
          p-&gt;image.x += dx;
          max = p-&gt;image.x + p-&gt;image.w;
          switch( p-&gt;image.align ){
            case IMAGE_ALIGN_Middle:
              p-&gt;image.descent = p-&gt;image.h/2;
              p-&gt;image.ascent = p-&gt;image.h - p-&gt;image.descent;
              if( p-&gt;image.ascent &gt; maxAscent ){
                maxAscent = p-&gt;image.ascent;
              }
              break;
            case IMAGE_ALIGN_AbsMiddle:
              dy2center = (p-&gt;image.textDescent - p-&gt;image.textAscent)/2;
              p-&gt;image.descent = p-&gt;image.h/2 + dy2center;
              p-&gt;image.ascent = p-&gt;image.h - p-&gt;image.descent;
              if( p-&gt;image.ascent &gt; maxAscent ){
                maxAscent = p-&gt;image.ascent;
              }
              break;
            case IMAGE_ALIGN_Bottom:
              p-&gt;image.descent = 0;
              p-&gt;image.ascent = p-&gt;image.h;
              if( p-&gt;image.ascent &gt; maxAscent ){
                maxAscent = p-&gt;image.ascent;
              }
              break;
            case IMAGE_ALIGN_AbsBottom:
              p-&gt;image.descent = p-&gt;image.textDescent;
              p-&gt;image.ascent = p-&gt;image.h - p-&gt;image.descent;
              if( p-&gt;image.ascent &gt; maxAscent ){
                maxAscent = p-&gt;image.ascent;
              }
              break;
            default:
              TestPoint(0);
              break;
          }
          break;
        case Html_TEXTAREA:
        case Html_INPUT:
        case Html_SELECT:
        case Html_EMBED:
        case Html_APPLET:
          p-&gt;input.x += dx;
          max = p-&gt;input.x + p-&gt;input.w;
          dy2center = (p-&gt;input.textDescent - p-&gt;input.textAscent)/2;
          p-&gt;input.y = dy2center - p-&gt;input.h/2;
          ascent = -p-&gt;input.y;
          if( ascent &gt; maxAscent ){
            maxAscent = ascent;
          }
          break;
        default:
          /* Shouldn't happen */
          break;
      }
    }
    *maxX = max;
    y = maxAscent + bottom;
    maxDescent = 0;
    for(p=pStart; p &amp;&amp; p!=pEnd; p=p-&gt;pNext){
      if( p-&gt;base.style.flags &amp; STY_Invisible ){
        TestPoint(0);
        continue;
      }
      switch( p-&gt;base.type ){
        case Html_Text:
          p-&gt;text.y += y;
          if( p-&gt;text.descent &gt; maxDescent ){
            maxDescent = p-&gt;text.descent;
          }
          break;
        case Html_LI:
          p-&gt;li.y = y;
          if( p-&gt;li.descent &gt; maxDescent ){
            maxDescent = p-&gt;li.descent;
          }
          break;
        case Html_IMG:
          p-&gt;image.y = y;
          switch( p-&gt;image.align ){
            case IMAGE_ALIGN_Top:
              p-&gt;image.ascent = maxAscent;
              p-&gt;image.descent = p-&gt;image.h - maxAscent;
              TestPoint(0);
              break;
            case IMAGE_ALIGN_TextTop:
              p-&gt;image.ascent = maxTextAscent;
              p-&gt;image.descent = p-&gt;image.h - maxTextAscent;
              TestPoint(0);
              break;
            default:
              TestPoint(0);
              break;
          }
          if( p-&gt;image.descent &gt; maxDescent ){
            maxDescent = p-&gt;image.descent;
          }
          break;
        case Html_INPUT:
        case Html_SELECT:
        case Html_TEXTAREA:
        case Html_APPLET:
        case Html_EMBED:
          descent = p-&gt;input.y + p-&gt;input.h;
          p-&gt;input.y += y;
          if( descent &gt; maxDescent ){
            maxDescent = descent;
          }
          break;
        default:
          /* Shouldn't happen */
          break;
      }
    }
    TRACE(HtmlTrace_FixLine, 
       ("Setting baseline to %d. bottom=%d ascent=%d descent=%d dx=%d\n",
       y, bottom, maxAscent, maxDescent, dx));
  }else{
    maxDescent = 0;
    y = bottom;
  }
  return y + maxDescent;
}
</t>
<t tx="ekr.20041214071955.91">@ ** Increase the headroom to create a paragraph break at the current token
@c

static void Paragraph(
  HtmlLayoutContext *pLC,
  HtmlElement *p
){
  int headroom;

  if( p==0 ){ TestPoint(0); return; }
  if( p-&gt;base.type==Html_Text ){
    headroom = p-&gt;text.ascent + p-&gt;text.descent;
    TestPoint(0);
  }else if( p-&gt;pNext &amp;&amp; p-&gt;pNext-&gt;base.type==Html_Text ){
    headroom = p-&gt;pNext-&gt;text.ascent + p-&gt;pNext-&gt;text.descent;
    TestPoint(0);
  }else{
    Tk_FontMetrics fontMetrics;
    Tk_Font font;
    font = HtmlGetFont(pLC-&gt;htmlPtr, p-&gt;base.style.font);
    if( font==0 ) return;   
    Tk_GetFontMetrics(font, &amp;fontMetrics);
    headroom = fontMetrics.descent + fontMetrics.ascent;
    TestPoint(0);
  }
  if( pLC-&gt;headRoom &lt; headroom &amp;&amp; pLC-&gt;bottom &gt; pLC-&gt;top ){
    pLC-&gt;headRoom = headroom;
  }
}
</t>
<t tx="ekr.20041214071955.92">@ ** Compute the current margins for layout. Three values are returned: ** **  *pY    The top edge of the area in which we can put ink. This **       takes into account any requested headroom. ** **  *pX    The left edge of the inkable area. The takes into account **       any margin requests active at vertical position specified **       in pLC-&gt;bottom. ** **  *pW    The width of the inkable area. This takes into account **       an margin requests that are active at the vertical position **       pLC-&gt;bottom. **
@c

void HtmlComputeMargins(
  HtmlLayoutContext *pLC,    /* The current layout context */
  int *pX,                   /* Put the left edge here */
  int *pY,                   /* Put the top edge here */
  int *pW                    /* Put the width here */
){
  int x, y, w;

  y = pLC-&gt;bottom + pLC-&gt;headRoom;
  PopExpiredMargins(&amp;pLC-&gt;leftMargin, pLC-&gt;bottom);
  PopExpiredMargins(&amp;pLC-&gt;rightMargin, pLC-&gt;bottom);
  w = pLC-&gt;pageWidth - pLC-&gt;right;
  if( pLC-&gt;leftMargin ){
    x = pLC-&gt;leftMargin-&gt;indent + pLC-&gt;left;
    TestPoint(0);
  }else{
    x = pLC-&gt;left;
    TestPoint(0);
  }
  w -= x;
  if( pLC-&gt;rightMargin ){
    w -= pLC-&gt;rightMargin-&gt;indent;
    TestPoint(0);
  }else{
    TestPoint(0);
  }
  *pX = x;
  *pY = y;
  *pW = w;
}
</t>
<t tx="ekr.20041214071955.93">@ ** Clear a wrap-around obstacle. The second option determines the ** precise behavior. ** **  CLEAR_Left    Clear all obstacles on the left. ** **  CLEAR_Right    Clear all obstacles on the right. ** **  CLEAR_Both    Clear all obstacles on both sides. ** **  CLEAR_First    Clear only the first obsticle on either side.
@c

#define CLEAR_Left  0
#define CLEAR_Right 1
#define CLEAR_Both  2
#define CLEAR_First 3
static void ClearObstacle(HtmlLayoutContext *pLC, int mode){
  int newBottom = pLC-&gt;bottom;

  PopExpiredMargins(&amp;pLC-&gt;leftMargin, pLC-&gt;bottom);
  PopExpiredMargins(&amp;pLC-&gt;rightMargin, pLC-&gt;bottom);
  switch( mode ){
    case CLEAR_Both:
      ClearObstacle(pLC,CLEAR_Left);
      ClearObstacle(pLC,CLEAR_Right);
      TestPoint(0);
      break;

    case CLEAR_Left:
      while( pLC-&gt;leftMargin &amp;&amp; pLC-&gt;leftMargin-&gt;bottom&gt;=0 ){
        newBottom = pLC-&gt;leftMargin-&gt;bottom;
        HtmlPopOneMargin(&amp;pLC-&gt;leftMargin);
        TestPoint(0);
      }
      if( newBottom &gt; pLC-&gt;bottom + pLC-&gt;headRoom ){
        pLC-&gt;headRoom = 0;
        TestPoint(0);
      }else{
        pLC-&gt;headRoom = newBottom - pLC-&gt;bottom;
        TestPoint(0);
      }
      pLC-&gt;bottom = newBottom;
      PopExpiredMargins(&amp;pLC-&gt;rightMargin, pLC-&gt;bottom);
      break;

    case CLEAR_Right:
      while( pLC-&gt;rightMargin &amp;&amp; pLC-&gt;rightMargin-&gt;bottom&gt;=0 ){
        newBottom = pLC-&gt;rightMargin-&gt;bottom;
        HtmlPopOneMargin(&amp;pLC-&gt;rightMargin);
        TestPoint(0);
      }
      if( newBottom &gt; pLC-&gt;bottom + pLC-&gt;headRoom ){
        pLC-&gt;headRoom = 0;
        TestPoint(0);
      }else{
        pLC-&gt;headRoom = newBottom - pLC-&gt;bottom;
        TestPoint(0);
      }
      pLC-&gt;bottom = newBottom;
      PopExpiredMargins(&amp;pLC-&gt;leftMargin, pLC-&gt;bottom);
      break;

    case CLEAR_First:
      if( pLC-&gt;leftMargin &amp;&amp; pLC-&gt;leftMargin-&gt;bottom&gt;=0 ){
        if( pLC-&gt;rightMargin 
         &amp;&amp; pLC-&gt;rightMargin-&gt;bottom &lt; pLC-&gt;leftMargin-&gt;bottom
        ){
          newBottom = pLC-&gt;rightMargin-&gt;bottom;
          HtmlPopOneMargin(&amp;pLC-&gt;rightMargin);
          TestPoint(0);
        }else{
          newBottom = pLC-&gt;leftMargin-&gt;bottom;
          HtmlPopOneMargin(&amp;pLC-&gt;leftMargin);
          TestPoint(0);
        }
      }else if( pLC-&gt;rightMargin &amp;&amp; pLC-&gt;rightMargin-&gt;bottom&gt;=0 ){
        newBottom = pLC-&gt;rightMargin-&gt;bottom;
        HtmlPopOneMargin(&amp;pLC-&gt;rightMargin);
        TestPoint(0);
      }else{
        TestPoint(0);
      }
      if( newBottom &gt; pLC-&gt;bottom + pLC-&gt;headRoom ){
        pLC-&gt;headRoom = 0;
        TestPoint(0);
      }else{
        pLC-&gt;headRoom = newBottom - pLC-&gt;bottom;
        TestPoint(0);
      }
      pLC-&gt;bottom = newBottom;
      break;
  }
}
</t>
<t tx="ekr.20041214071955.94">@ ** Break markup is any kind of markup that might force a line-break. This ** routine handles a single element of break markup and returns a pointer ** to the first element past that markup. If p doesn't point to break ** markup, then p is returned. If p is an incomplete table (a &lt;TABLE&gt; ** that lacks a &lt;/TABLE&gt;), then NULL is returned.
@c

static HtmlElement *DoBreakMarkup(
  HtmlLayoutContext *pLC,
  HtmlElement *p
){
  HtmlElement *pNext = p-&gt;pNext;
  char *z;
  int x, y, w;

  switch( p-&gt;base.type ){
    case Html_A:
      p-&gt;anchor.y = pLC-&gt;bottom;
      TestPoint(0);
      break;

    case Html_BLOCKQUOTE:
      HtmlPushMargin(&amp;pLC-&gt;leftMargin, HTML_INDENT, -1, Html_EndBLOCKQUOTE);
      HtmlPushMargin(&amp;pLC-&gt;rightMargin, HTML_INDENT, -1, Html_EndBLOCKQUOTE);
      Paragraph(pLC, p);
      TestPoint(0);
      break;
    case Html_EndBLOCKQUOTE:
      HtmlPopMargin(&amp;pLC-&gt;leftMargin, Html_EndBLOCKQUOTE, pLC);
      HtmlPopMargin(&amp;pLC-&gt;rightMargin, Html_EndBLOCKQUOTE, pLC);
      Paragraph(pLC, p);
      TestPoint(0);
      break;

    case Html_IMG:
      switch( p-&gt;image.align ){
        case IMAGE_ALIGN_Left:
          HtmlComputeMargins(pLC, &amp;x, &amp;y, &amp;w);
          p-&gt;image.x = x;
          p-&gt;image.y = y;
          p-&gt;image.ascent = 0;
          p-&gt;image.descent = p-&gt;image.h;
          HtmlPushMargin(&amp;pLC-&gt;leftMargin, p-&gt;image.w + 2, y + p-&gt;image.h, 0);
          SETMAX( pLC-&gt;maxY, y + p-&gt;image.h );
          SETMAX( pLC-&gt;maxX, x + p-&gt;image.w );
          break;
        case IMAGE_ALIGN_Right:
          HtmlComputeMargins(pLC, &amp;x, &amp;y, &amp;w);
          p-&gt;image.x = x + w - p-&gt;image.w;
          p-&gt;image.y = y;
          p-&gt;image.ascent = 0;
          p-&gt;image.descent = p-&gt;image.h;
          HtmlPushMargin(&amp;pLC-&gt;rightMargin, p-&gt;image.w + 2, y + p-&gt;image.h, 0);
          SETMAX( pLC-&gt;maxY, y + p-&gt;image.h );
          SETMAX( pLC-&gt;maxX, x + p-&gt;image.w );
          break;
        default:
          TestPoint(0);
          pNext = p;
          break;
      }
      break;

    
    case Html_PRE:
      /* Skip space tokens thru the next newline. */
      while( pNext-&gt;base.type==Html_Space ){
        HtmlElement *pThis = pNext;
        pNext = pNext-&gt;pNext;
        if( pThis-&gt;base.flags &amp; HTML_NewLine ){ TestPoint(0); break; }
      }
      Paragraph(pLC,p);
      break;

    case Html_UL:
    case Html_MENU:
    case Html_DIR:
    case Html_OL:
      if( p-&gt;list.compact==0 ){
        Paragraph(pLC,p);
      }
      HtmlPushMargin(&amp;pLC-&gt;leftMargin, HTML_INDENT, -1, p-&gt;base.type+1);
      break;

    case Html_EndOL:
    case Html_EndUL:
    case Html_EndMENU:
    case Html_EndDIR:
      if( p-&gt;ref.pOther ){
        HtmlPopMargin(&amp;pLC-&gt;leftMargin, p-&gt;base.type, pLC);
        if( !p-&gt;ref.pOther-&gt;list.compact ){
          Paragraph(pLC,p);
        }
      }
      break;

    case Html_DL:
      Paragraph(pLC,p);
      HtmlPushMargin(&amp;pLC-&gt;leftMargin, HTML_INDENT, -1, Html_EndDL);
      TestPoint(0);
      break;

    case Html_EndDL:
      HtmlPopMargin(&amp;pLC-&gt;leftMargin, Html_EndDL, pLC);
      Paragraph(pLC,p);
      TestPoint(0);
      break;

    case Html_HR: {
      int zl, wd;

      p-&gt;hr.is3D = HtmlMarkupArg(p, "noshade", 0)==0;
      z = HtmlMarkupArg(p, "size", 0);
      if( z ){
        p-&gt;hr.h = atoi(z);
      }else{
        p-&gt;hr.h = 0;
      }
      if( p-&gt;hr.h&lt;1 ){
        int relief = pLC-&gt;htmlPtr-&gt;ruleRelief;
        if( p-&gt;hr.is3D 
        &amp;&amp; (relief==TK_RELIEF_SUNKEN || relief==TK_RELIEF_RAISED) ){
          p-&gt;hr.h = 3;
        }else{
          p-&gt;hr.h = 2;
        }
      }
      HtmlComputeMargins(pLC, &amp;x, &amp;y, &amp;w);
      p-&gt;hr.y = y;
      y += p-&gt;hr.h + 1;
      p-&gt;hr.x = x;
      z = HtmlMarkupArg(p, "width", "100%");
      zl = strlen(z);
      if( zl&gt;0 &amp;&amp; z[zl-1]=='%' ){
        wd = (atoi(z)*w)/100;
      }else{
        wd = atoi(z);
      }
      if( wd&gt;w ) wd = w;
      p-&gt;hr.w = wd;
      switch( p-&gt;base.style.align ){
        case ALIGN_Center:
        case ALIGN_None:
          p-&gt;hr.x += (w - wd)/2;
          TestPoint(0);
          break;
        case ALIGN_Right:
          p-&gt;hr.x += (w - wd);
          TestPoint(0);
          break;
        default:
          TestPoint(0);
          break;
      }
      SETMAX( pLC-&gt;maxY, y);
      SETMAX( pLC-&gt;maxX, wd + p-&gt;hr.x );
      pLC-&gt;bottom = y;
      pLC-&gt;headRoom = 0;
      break;
    }

    case Html_ADDRESS:
    case Html_EndADDRESS:
    case Html_CENTER:
    case Html_EndCENTER:
    case Html_DIV:
    case Html_EndDIV:
    case Html_H1:
    case Html_EndH1:
    case Html_H2:
    case Html_EndH2:
    case Html_H3:
    case Html_EndH3:
    case Html_H4:
    case Html_EndH4:
    case Html_H5:
    case Html_EndH5:
    case Html_H6:
    case Html_EndH6:
    case Html_P:
    case Html_EndP:
    case Html_EndPRE:
      Paragraph(pLC, p);
      TestPoint(0);
      break;

    case Html_TABLE:
      pNext = HtmlTableLayout(pLC, p);
      TestPoint(0);
      break;

    case Html_BR:
      z = HtmlMarkupArg(p, "clear",0);
      if( z ){
        if( stricmp(z,"left")==0 ){
          ClearObstacle(pLC, CLEAR_Left);
          TestPoint(0);
        }else if( stricmp(z,"right")==0 ){
          ClearObstacle(pLC, CLEAR_Right);
          TestPoint(0);
        }else{
          ClearObstacle(pLC, CLEAR_Both);
          TestPoint(0);
        }
      }else{
        TestPoint(0);
      }
      break;

    /* All of the following tags need to be handed to the GetLine() routine */
    case Html_Text:
    case Html_Space:
    case Html_LI:
    case Html_INPUT:
    case Html_SELECT:
    case Html_TEXTAREA:
    case Html_APPLET:
    case Html_EMBED:
      pNext = p;
      TestPoint(0);
      break;

    default:
      TestPoint(0);
      break;
  }
  return pNext;
}
</t>
<t tx="ekr.20041214071955.95">@ ** Return TRUE (non-zero) if we are currently wrapping text around ** one or more images.
@c

static int InWrapAround(HtmlLayoutContext *pLC){
  if( pLC-&gt;leftMargin &amp;&amp; pLC-&gt;leftMargin-&gt;bottom &gt;= 0 ){
    TestPoint(0);
    return 1;
  }
  if( pLC-&gt;rightMargin &amp;&amp; pLC-&gt;rightMargin-&gt;bottom &gt;= 0 ){
    TestPoint(0);
    return 1;
  }
  TestPoint(0);
  return 0;
}
</t>
<t tx="ekr.20041214071955.96">@ ** Move past obsticles until a linewidth of reqWidth is obtained, ** or until all obsticles are cleared.
@c

void HtmlWidenLine(
  HtmlLayoutContext *pLC,     /* The layout context */
  int reqWidth,               /* Requested line width */
  int *pX, int *pY, int *pW   /* The margins.  See HtmllComputeMargins() */
){
  HtmlComputeMargins(pLC, pX, pY, pW);
  if( *pW&lt;reqWidth &amp;&amp; InWrapAround(pLC) ){
    ClearObstacle(pLC, CLEAR_First);
    HtmlComputeMargins(pLC, pX, pY, pW);
  }
}
</t>
<t tx="ekr.20041214071955.97">
#ifdef TABLE_TRIM_BLANK
int HtmlLineWasBlank = 0;
#endif /* TABLE_TRIM_BLANK */

/*
** Do as much layout as possible on the block of text defined by
** the HtmlLayoutContext.
*/
void HtmlLayoutBlock(HtmlLayoutContext *pLC){
  HtmlElement *p, *pNext;

  for(p=pLC-&gt;pStart; p &amp;&amp; p!=pLC-&gt;pEnd; p=pNext){
    int lineWidth;
    int actualWidth;
    int y = 0;
    int leftMargin;
    int maxX = 0;

    /* Do as much break markup as we can. */
    while( p &amp;&amp; p!=pLC-&gt;pEnd ){
      HtmlLock(pLC-&gt;htmlPtr);
      pNext = DoBreakMarkup(pLC, p);
      if( HtmlUnlock(pLC-&gt;htmlPtr) ) return;
      if( pNext==p ){ TestPoint(0); break; }
      if( pNext ){
        TRACE(HtmlTrace_BreakMarkup,
           ("Processed token %s as break markup\n", HtmlTokenName(p)));
        pLC-&gt;pStart = p;
      }
      p = pNext;
      TestPoint(0);
    }
    if( p==0 || p==pLC-&gt;pEnd ){ TestPoint(0); break; }

#ifdef TABLE_TRIM_BLANK
    HtmlLineWasBlank = 0;
#endif /* TABLE_TRIM_BLANK */

    /* We might try several times to layout a single line... */   
    while( 1 ){

      /* Compute margins */
      HtmlComputeMargins(pLC, &amp;leftMargin, &amp;y, &amp;lineWidth);

      /* Layout a single line of text */
      pNext = GetLine(pLC, p, pLC-&gt;pEnd, lineWidth, pLC-&gt;left-leftMargin,
                      &amp;actualWidth);
      TRACE(HtmlTrace_GetLine,
         ("GetLine page=%d left=%d right=%d available=%d used=%d\n",
         pLC-&gt;pageWidth, pLC-&gt;left, pLC-&gt;right, lineWidth, actualWidth));
      FixAnchors(p,pNext,pLC-&gt;bottom);

      /* Move down and repeat the layout if we exceeded the available
      ** line length and it is possible to increase the line length by
      ** moving past some obsticle.
      */
      if( actualWidth &gt; lineWidth &amp;&amp; InWrapAround(pLC) ){
        ClearObstacle(pLC, CLEAR_First);
        TestPoint(0);
        continue;
      }

      /* Lock the line into place and exit the loop */
      y = FixLine(p, pNext, y, lineWidth, actualWidth, leftMargin, &amp;maxX);
      TestPoint(0);
      break;
    }

#ifdef TABLE_TRIM_BLANK
	/*
	 * I noticed that a newline following break markup would result
	 * in a blank line being drawn. So if an "empty" line was found
	 * I subtract any whitespace caused by break markup.
	 */
	if (actualWidth &lt;= 0)
	{
		HtmlLineWasBlank = 1;
	}
#endif /* TABLE_TRIM_BLANK */

    /* If a line was completed, advance to the next line */
    if( pNext &amp;&amp; actualWidth&gt;0 &amp;&amp; y &gt; pLC-&gt;bottom ){
      pLC-&gt;bottom = y;
      pLC-&gt;headRoom = 0;
      pLC-&gt;pStart = pNext;
    }
    if( y &gt; pLC-&gt;maxY ){
      pLC-&gt;maxY = y;
    }
    if( maxX &gt; pLC-&gt;maxX ){
      pLC-&gt;maxX = maxX;
    }
  }
}
</t>
<t tx="ekr.20041214071955.98">@ ** Advance the layout as far as possible
@c

void HtmlLayout(HtmlWidget *htmlPtr){
  HtmlLayoutContext *pLC;
  int btm;

  if( htmlPtr-&gt;pFirst==0 ) return;
  HtmlLock(htmlPtr);
  HtmlSizer(htmlPtr);
  if( HtmlUnlock(htmlPtr) ) return;
  pLC = &amp;htmlPtr-&gt;layoutContext;
  pLC-&gt;htmlPtr = htmlPtr;
  pLC-&gt;pageWidth = htmlPtr-&gt;realWidth - 2*(htmlPtr-&gt;inset + htmlPtr-&gt;padx);
  pLC-&gt;left = 0;
  pLC-&gt;right = 0;
  pLC-&gt;pStart = htmlPtr-&gt;nextPlaced;
  if( pLC-&gt;pStart==0 ){
    pLC-&gt;pStart = htmlPtr-&gt;pFirst;
  }
  if( pLC-&gt;pStart ){
    pLC-&gt;maxX = htmlPtr-&gt;maxX;
    pLC-&gt;maxY = htmlPtr-&gt;maxY;
    btm = pLC-&gt;bottom;
    HtmlLock(htmlPtr);
    HtmlLayoutBlock(pLC);
    if( HtmlUnlock(htmlPtr) ) return;
    htmlPtr-&gt;maxX = pLC-&gt;maxX;
    htmlPtr-&gt;maxY = pLC-&gt;maxY;
    htmlPtr-&gt;nextPlaced = pLC-&gt;pStart;
    htmlPtr-&gt;flags |= HSCROLL | VSCROLL;
    HtmlRedrawText(htmlPtr, btm);
  }
}
</t>
<t tx="ekr.20041214071955.99">@ignore
@language c
static char const rcsid[] = "@(#) $Id: htmlparse.c,v 1.21 2000/02/01 12:34:22 drh Exp $";
/* A tokenizer that converts raw HTML into a linked list of HTML elements. */
&lt;&lt; htmlparse #includes &gt;&gt;
&lt;&lt; htmlparse declarations &gt;&gt;
@others
#endif
</t>
<t tx="ekr.20041214071955.100">#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;tk.h&gt;
#include "htmlparse.h"
</t>
<t tx="ekr.20041214071955.101">
/****************** Begin Escape Sequence Translator *************/
/*
** The next section of code implements routines used to translate
** the '&amp;' escape sequences of SGML to individual characters.
** Examples:
**
**         &amp;amp;          &amp;
**         &amp;lt;           &lt;
**         &amp;gt;           &gt;
**         &amp;nbsp;         nonbreakable space
*/

/* Each escape sequence is recorded as an instance of the following
** structure
*/
struct sgEsc {
  char *zName;            /* The name of this escape sequence.  ex:  "amp" */
  char  value[8];         /* The value for this sequence.       ex:  "&amp;" */
  struct sgEsc *pNext;    /* Next sequence with the same hash on zName */
};

/* The following is a table of all escape sequences.  Add new sequences
** by adding entries to this table.
*/
static struct sgEsc esc_sequences[] = {
  { "quot",      "\"",    0 },
  { "amp",       "&amp;",     0 },
  { "lt",        "&lt;",     0 },
  { "gt",        "&gt;",     0 },
  { "nbsp",      " ",     0 },
  { "iexcl",     "\241",  0 },
  { "cent",      "\242",  0 },
  { "pound",     "\243",  0 },
  { "curren",    "\244",  0 },
  { "yen",       "\245",  0 },
  { "brvbar",    "\246",  0 },
  { "sect",      "\247",  0 },
  { "uml",       "\250",  0 },
  { "copy",      "\251",  0 },
  { "ordf",      "\252",  0 },
  { "laquo",     "\253",  0 },
  { "not",       "\254",  0 },
  { "shy",       "\255",  0 },
  { "reg",       "\256",  0 },
  { "macr",      "\257",  0 },
  { "deg",       "\260",  0 },
  { "plusmn",    "\261",  0 },
  { "sup2",      "\262",  0 },
  { "sup3",      "\263",  0 },
  { "acute",     "\264",  0 },
  { "micro",     "\265",  0 },
  { "para",      "\266",  0 },
  { "middot",    "\267",  0 },
  { "cedil",     "\270",  0 },
  { "sup1",      "\271",  0 },
  { "ordm",      "\272",  0 },
  { "raquo",     "\273",  0 },
  { "frac14",    "\274",  0 },
  { "frac12",    "\275",  0 },
  { "frac34",    "\276",  0 },
  { "iquest",    "\277",  0 },
  { "Agrave",    "\300",  0 },
  { "Aacute",    "\301",  0 },
  { "Acirc",     "\302",  0 },
  { "Atilde",    "\303",  0 },
  { "Auml",      "\304",  0 },
  { "Aring",     "\305",  0 },
  { "AElig",     "\306",  0 },
  { "Ccedil",    "\307",  0 },
  { "Egrave",    "\310",  0 },
  { "Eacute",    "\311",  0 },
  { "Ecirc",     "\312",  0 },
  { "Euml",      "\313",  0 },
  { "Igrave",    "\314",  0 },
  { "Iacute",    "\315",  0 },
  { "Icirc",     "\316",  0 },
  { "Iuml",      "\317",  0 },
  { "ETH",       "\320",  0 },
  { "Ntilde",    "\321",  0 },
  { "Ograve",    "\322",  0 },
  { "Oacute",    "\323",  0 },
  { "Ocirc",     "\324",  0 },
  { "Otilde",    "\325",  0 },
  { "Ouml",      "\326",  0 },
  { "times",     "\327",  0 },
  { "Oslash",    "\330",  0 },
  { "Ugrave",    "\331",  0 },
  { "Uacute",    "\332",  0 },
  { "Ucirc",     "\333",  0 },
  { "Uuml",      "\334",  0 },
  { "Yacute",    "\335",  0 },
  { "THORN",     "\336",  0 },
  { "szlig",     "\337",  0 },
  { "agrave",    "\340",  0 },
  { "aacute",    "\341",  0 },
  { "acirc",     "\342",  0 },
  { "atilde",    "\343",  0 },
  { "auml",      "\344",  0 },
  { "aring",     "\345",  0 },
  { "aelig",     "\346",  0 },
  { "ccedil",    "\347",  0 },
  { "egrave",    "\350",  0 },
  { "eacute",    "\351",  0 },
  { "ecirc",     "\352",  0 },
  { "euml",      "\353",  0 },
  { "igrave",    "\354",  0 },
  { "iacute",    "\355",  0 },
  { "icirc",     "\356",  0 },
  { "iuml",      "\357",  0 },
  { "eth",       "\360",  0 },
  { "ntilde",    "\361",  0 },
  { "ograve",    "\362",  0 },
  { "oacute",    "\363",  0 },
  { "ocirc",     "\364",  0 },
  { "otilde",    "\365",  0 },
  { "ouml",      "\366",  0 },
  { "divide",    "\367",  0 },
  { "oslash",    "\370",  0 },
  { "ugrave",    "\371",  0 },
  { "uacute",    "\372",  0 },
  { "ucirc",     "\373",  0 },
  { "uuml",      "\374",  0 },
  { "yacute",    "\375",  0 },
  { "thorn",     "\376",  0 },
  { "yuml",      "\377",  0 },
};

/* The size of the handler hash table.  For best results this should
** be a prime number which is about the same size as the number of
** escape sequences known to the system. */
#define ESC_HASH_SIZE (sizeof(esc_sequences)/sizeof(esc_sequences[0])+7)

/* The hash table 
**
** If the name of an escape sequences hashes to the value H, then
** apEscHash[H] will point to a linked list of Esc structures, one of
** which will be the Esc structure for that escape sequence.
*/
static struct sgEsc *apEscHash[ESC_HASH_SIZE];
</t>
<t tx="ekr.20041214071955.102">@ Hash a escape sequence name. The value returned is an integer ** between 0 and ESC_HASH_SIZE-1, inclusive.
@c

static int EscHash(const char *zName){
  int h = 0;      /* The hash value to be returned */
  char c;         /* The next character in the name being hashed */

  while( (c=*zName)!=0 ){
    h = h&lt;&lt;5 ^ h ^ c;
    zName++;
    TestPoint(0);
  }
  if( h&lt;0 ){
    h = -h;
    TestPoint(0);
  }else{
    TestPoint(0);
  }
  return h % ESC_HASH_SIZE;
}
</t>
<t tx="ekr.20041214071955.103">
#ifdef TEST
/* 
** Compute the longest and average collision chain length for the
** escape sequence hash table
*/
static void EscHashStats(void){
  int i;
  int sum = 0;
  int max = 0;
  int cnt;
  int notempty = 0;
  struct sgEsc *p;

  for(i=0; i&lt;sizeof(esc_sequences)/sizeof(esc_sequences[0]); i++){
    cnt = 0; 
    p = apEscHash[i];
    if( p ) notempty++;
    while( p ){
      cnt++;
      p = p-&gt;pNext;
    }
    sum += cnt;
    if( cnt&gt;max ) max = cnt;
  }
  printf("Longest chain=%d  avg=%g  slots=%d  empty=%d (%g%%)\n",
     max,(double)sum/(double)notempty, i, i-notempty, 
     100.0*(i-notempty)/(double)i);
}
</t>
<t tx="ekr.20041214071955.104">#endif

/* Initialize the escape sequence hash table
*/
static void EscInit(void){
  int i;  /* For looping thru the list of escape sequences */
  int h;  /* The hash on a sequence */

  for(i=0; i&lt;sizeof(esc_sequences)/sizeof(esc_sequences[i]); i++){
/* #ifdef TCL_UTF_MAX */
#if 0
    {
      int c = esc_sequences[i].value[0];
      Tcl_UniCharToUtf(c, esc_sequences[i].value);
    }
#endif
    h = EscHash(esc_sequences[i].zName);
    esc_sequences[i].pNext = apEscHash[h];
    apEscHash[h] = &amp;esc_sequences[i];
    TestPoint(0);
  }
#ifdef TEST
  EscHashStats();
#endif
}
</t>
<t tx="ekr.20041214071955.105">@ ** This table translates the non-standard microsoft characters between ** 0x80 and 0x9f into plain ASCII so that the characters will be visible ** on Unix systems. Care is taken to translate the characters ** into values less than 0x80, to avoid UTF-8 problems.
@c

#ifndef __WIN32__
static char acMsChar[] = {
  /* 0x80 */ 'C',
  /* 0x81 */ ' ',
  /* 0x82 */ ',',
  /* 0x83 */ 'f',
  /* 0x84 */ '"',
  /* 0x85 */ '.',
  /* 0x86 */ '*',
  /* 0x87 */ '*',
  /* 0x88 */ '^',
  /* 0x89 */ '%',
  /* 0x8a */ 'S',
  /* 0x8b */ '&lt;',
  /* 0x8c */ 'O',
  /* 0x8d */ ' ',
  /* 0x8e */ 'Z',
  /* 0x8f */ ' ',
  /* 0x90 */ ' ',
  /* 0x91 */ '\'',
  /* 0x92 */ '\'',
  /* 0x93 */ '"',
  /* 0x94 */ '"',
  /* 0x95 */ '*',
  /* 0x96 */ '-',
  /* 0x97 */ '-',
  /* 0x98 */ '~',
  /* 0x99 */ '@',
  /* 0x9a */ 's',
  /* 0x9b */ '&gt;',
  /* 0x9c */ 'o',
  /* 0x9d */ ' ',
  /* 0x9e */ 'z',
  /* 0x9f */ 'Y',
};
#endif

/* Translate escape sequences in the string "z".  "z" is overwritten
** with the translated sequence.
**
** Unrecognized escape sequences are unaltered.
**
** Example:
**
**      input =    "AT&amp;amp;T &amp;gt MCI"
**      output =   "AT&amp;T &gt; MCI"
*/
LOCAL void HtmlTranslateEscapes(char *z){
  int from;   /* Read characters from this position in z[] */
  int to;     /* Write characters into this position in z[] */
  int h;      /* A hash on the escape sequence */
  struct sgEsc *p;   /* For looping down the escape sequence collision chain */
  static int isInit = 0;   /* True after initialization */

  from = to = 0;
  if( !isInit ){
    EscInit();
    isInit = 1;
  }
  while( z[from] ){
    if( z[from]=='&amp;' ){
      if( z[from+1]=='#' ){
        int i = from + 2;
        int v = 0;
        while( isdigit(z[i]) ){
          v = v*10 + z[i] - '0';
          i++;
        }
        if( z[i]==';' ){ i++; }

        /* On Unix systems, translate the non-standard microsoft
        ** characters in the range of 0x80 to 0x9f into something
        ** we can see.
        */
#ifndef __WIN32__
        if( v&gt;=0x80 &amp;&amp; v&lt;0xa0 ){
          v = acMsChar[v&amp;0x1f];
        }
#endif
        /* Put the character in the output stream in place of
        ** the "&amp;#000;".  How we do this depends on whether or
        ** not we are using UTF-8.
        */
#ifdef TCL_UTF_MAX
        {
          int j, n;
          char value[8];
          n = Tcl_UniCharToUtf(v,value);
          for(j=0; j&lt;n; j++){
            z[to++] = value[j];
          }
        }
#else
        z[to++] = v;
#endif
        from = i;
      }else{
        int i = from+1;
        int c;
        while( z[i] &amp;&amp; isalnum(z[i]) ){ TestPoint(0); i++; }
        c = z[i];
        z[i] = 0;
        h = EscHash(&amp;z[from+1]);
        p = apEscHash[h];
        while( p &amp;&amp; strcmp(p-&gt;zName,&amp;z[from+1])!=0 ){ 
          p = p-&gt;pNext; 
        }
        z[i] = c;
        if( p ){
          int j;
          for(j=0; p-&gt;value[j]; j++){
            z[to++] = p-&gt;value[j];
          }
          from = i;
          if( c==';' ){
            from++;
          }
        }else{
          z[to++] = z[from++];
        }
      }

    /* On UNIX systems, look for the non-standard microsoft characters 
    ** between 0x80 and 0x9f and translate them into printable ASCII
    ** codes.  Separate algorithms are required to do this for plain
    ** ascii and for utf-8.
    */
#ifndef __WIN32__
#ifdef TCL_UTF_MAX
    }else if( (z[from]&amp;0x80)!=0 ){
      Tcl_UniChar c;
      int n;
      n = Tcl_UtfToUniChar(&amp;z[from], &amp;c);
      if( c&gt;=0x80 &amp;&amp; c&lt;0xa0 ){
        z[to++] = acMsChar[c &amp; 0x1f];
        from += n;
      }else{
        while( n-- ) z[to++] = z[from++];
      }
#else /* if !defined(TCL_UTF_MAX) */
    }else if( ((unsigned char)z[from])&gt;=0x80 &amp;&amp; ((unsigned char)z[from])&lt;0xa0 ){
      z[to++] = acMsChar[z[from++]&amp;0x1f];
#endif /* TCL_UTF_MAX */
#endif /* __WIN32__ */
    }else{
      z[to++] = z[from++];
      TestPoint(0);
    }
  }
  z[to] = 0;
}
</t>
<t tx="ekr.20041214071955.106">@ ****************** End Escape Sequence Translator **************
****************** Begin HTML tokenizer code ******************
** The following variable becomes TRUE when the markup hash table ** (stored in HtmlMarkupMap[]) is initialized.
@c

static int isInit = 0;

/* The hash table for HTML markup names.
**
** If an HTML markup name hashes to H, then apMap[H] will point to
** a linked list of sgMap structure, one of which will describe the
** the particular markup (if it exists.)
*/
static HtmlTokenMap *apMap[HTML_MARKUP_HASH_SIZE];

/* Hash a markup name
**
** HTML markup is case insensitive, so this function will give the
** same hash regardless of the case of the markup name.
**
** The value returned is an integer between 0 and HTML_MARKUP_HASH_SIZE-1,
** inclusive.
*/
static int HtmlHash(const char *zName){
  int h = 0;
  char c;
  while( (c=*zName)!=0 ){
    if( isupper(c) ){
      c = tolower(c);
    }
    h = h&lt;&lt;5 ^ h ^ c;
    zName++;
  }
  if( h&lt;0 ){
    h = -h;
  }
  return h % HTML_MARKUP_HASH_SIZE;
}
</t>
<t tx="ekr.20041214071955.107">
#ifdef TEST
/* 
** Compute the longest and average collision chain length for the
** markup hash table
*/
static void HtmlHashStats(void){
  int i;
  int sum = 0;
  int max = 0;
  int cnt;
  int notempty = 0;
  struct sgMap *p;

  for(i=0; i&lt;HTML_MARKUP_COUNT; i++){
    cnt = 0; 
    p = apMap[i];
    if( p ) notempty++;
    while( p ){
      cnt++;
      p = p-&gt;pCollide;
    }
    sum += cnt;
    if( cnt&gt;max ) max = cnt;
    
  }
  printf("longest chain=%d  avg=%g  slots=%d  empty=%d (%g%%)\n",
    max, (double)sum/(double)notempty, i, i-notempty,
    100.0*(i-notempty)/(double)i);
}
</t>
<t tx="ekr.20041214071955.108">#endif

/* Initialize the escape sequence hash table
*/
static void HtmlHashInit(void){
  int i;  /* For looping thru the list of markup names */
  int h;  /* The hash on a markup name */

  for(i=0; i&lt;HTML_MARKUP_COUNT; i++){
    h = HtmlHash(HtmlMarkupMap[i].zName);
    HtmlMarkupMap[i].pCollide = apMap[h];
    apMap[h] = &amp;HtmlMarkupMap[i];
  }
#ifdef TEST
  HtmlHashStats();
#endif
}
</t>
<t tx="ekr.20041214071955.109">@ ** Append the given HtmlElement to the tokenizers list of elements
@c

static void AppendElement(HtmlWidget *p, HtmlElement *pElem){
  pElem-&gt;base.pNext = 0;
  pElem-&gt;base.pPrev = p-&gt;pLast;
  if( p-&gt;pFirst==0 ){
    p-&gt;pFirst = pElem;
  }else{
    p-&gt;pLast-&gt;base.pNext = pElem;
  }
  p-&gt;pLast = pElem;
  p-&gt;nToken++;
}
</t>
<t tx="ekr.20041214071955.110">@ ** Compute the new column index following the given character.
@c

static int NextColumn(int iCol, char c){
  switch( c ){
    case '\n': return 0;
    case '\t': return (iCol | 7) + 1;
    default:   return iCol+1;
  }
  /* NOT REACHED */
}
</t>
<t tx="ekr.20041214071955.111">@ ** Convert a string to all lower-case letters.
@c

static void ToLower(char *z){
  while( *z ){
    if( isupper(*z) ) *z = tolower(*z);
    z++;
  }
}
</t>
<t tx="ekr.20041214071955.112">@ Process as much of the input HTML as possible. Construct new ** HtmlElement structures and appended them to the list. Return ** the number of characters actually processed. ** ** This routine may invoke a callback procedure which could delete ** the HTML widget. ** ** This routine is not reentrant for the same HTML widget. To ** prevent reentrancy (during a callback), the p-&gt;iCol field is ** set to a negative number. This is a flag to future invocations ** not to reentry this routine. The p-&gt;iCol field is restored ** before exiting, of course.
@c

static int Tokenize(
  HtmlWidget *p        /* The HTML widget doing the parsing */
){
  char *z;             /* The input HTML text */
  int c;               /* The next character of input */
  int n;               /* Number of characters processed so far */
  int iCol;            /* Column of input */
  int i, j;            /* Loop counters */
  int h;               /* Result from HtmlHash() */
  int nByte;           /* Space allocated for a single HtmlElement */
  HtmlElement *pElem;  /* A new HTML element */
  int selfClose;       /* True for content free elements.  Ex:  &lt;br/&gt; */
  int argc;            /* The number of arguments on a markup */
  HtmlTokenMap *pMap;  /* For searching the markup name hash table */
  char *zBuf;          /* For handing out buffer space */
# define mxARG 200     /* Maximum number of parameters in a single markup */
  char *argv[mxARG];   /* Pointers to each markup argument. */
  int arglen[mxARG];   /* Length of each markup argument */

  iCol = p-&gt;iCol;
  n = p-&gt;nComplete;
  z = p-&gt;zText;
  if( iCol&lt;0 ){ TestPoint(0); return n; }   /* Prevents recursion */
  p-&gt;iCol = -1;
  while( (c=z[n])!=0 ){
    if( p-&gt;pScript ){
      /* We are in the middle of &lt;SCRIPT&gt;...&lt;/SCRIPT&gt;.  Just look for
      ** the &lt;/SCRIPT&gt; markup.  (later:)  Treat &lt;STYLE&gt;...&lt;/STYLE&gt; the
      ** same way. */
      HtmlScript *pScript = p-&gt;pScript;
      char *zEnd;
      int nEnd;
      if( pScript-&gt;markup.base.type==Html_SCRIPT ){
        zEnd = "&lt;/script&gt;";
        nEnd = 9;
      }else{
        zEnd = "&lt;/style&gt;";
        nEnd = 8;
      }
      if( pScript-&gt;zScript==0 ){
        pScript-&gt;zScript = &amp;z[n];
        pScript-&gt;nScript = 0;
      }
      for(i=n+pScript-&gt;nScript; z[i]; i++){
        if( z[i]=='&lt;' &amp;&amp; z[i+1]=='/' &amp;&amp; strnicmp(&amp;z[i],zEnd,nEnd)==0 ){
          pScript-&gt;nScript = i - n;
          p-&gt;pScript = 0;
          n = i+nEnd;
          break;
        }
      }
      if( p-&gt;pScript ){
        pScript-&gt;nScript = i - n;
      }
      continue;
    }else if( isspace(c) ){
      /* White space */
      for(i=0; (c=z[n+i])!=0 &amp;&amp; isspace(c) &amp;&amp; c!='\n' &amp;&amp; c!='\r'; i++){}
      if( c=='\r' &amp;&amp; z[n+i+1]=='\n' ){ i++; }
      pElem = HtmlAlloc( sizeof(HtmlSpaceElement) );
      if( pElem==0 ){ goto incomplete; }
      pElem-&gt;base.type = Html_Space;
      if( c=='\n' || c=='\r' ){
        pElem-&gt;base.flags = HTML_NewLine;
        pElem-&gt;base.count = 1;
        i++;
        iCol = 0;
        TestPoint(0);
      }else{
        int iColStart = iCol;
        pElem-&gt;base.flags = 0;
        for(j=0; j&lt;i; j++){
          iCol = NextColumn(iCol, z[n+j]);
          TestPoint(0);
        }
        pElem-&gt;base.count = iCol - iColStart;
      }
      AppendElement(p,pElem);
      n += i;
    }else if( c!='&lt;' || p-&gt;iPlaintext!=0 || 
      (!isalpha(z[n+1]) &amp;&amp; z[n+1]!='/' &amp;&amp; z[n+1]!='!' &amp;&amp; z[n+1]!='?') ){
      /* Ordinary text */
      for(i=1; (c=z[n+i])!=0 &amp;&amp; !isspace(c) &amp;&amp; c!='&lt;'; i++){}
      if( c==0 ){ TestPoint(0); goto incomplete; }
      if( p-&gt;iPlaintext!=0 &amp;&amp; z[n]=='&lt;' ){
        switch( p-&gt;iPlaintext ){
          case Html_LISTING:
            if( i&gt;=10 &amp;&amp; strnicmp(&amp;z[n],"&lt;/listing&gt;",10)==0 ){
              p-&gt;iPlaintext = 0;
              goto doMarkup;
            }
            break;
          case Html_XMP:
            if( i&gt;=6 &amp;&amp; strnicmp(&amp;z[n],"&lt;/xmp&gt;",6)==0 ){
              p-&gt;iPlaintext = 0;
              goto doMarkup;
            }
            break;
          case Html_TEXTAREA:
            if( i&gt;=11 &amp;&amp; strnicmp(&amp;z[n],"&lt;/textarea&gt;",11)==0 ){
              p-&gt;iPlaintext = 0;
              goto doMarkup;
            }
            break;
          default:
            break;
        }
      }
      nByte = sizeof(HtmlTextElement) + i;
      pElem = HtmlAlloc( nByte );
      if( pElem==0 ){ goto incomplete; }
      memset(pElem,0,nByte);
      pElem-&gt;base.type = Html_Text;
      sprintf(pElem-&gt;text.zText,"%.*s",i,&amp;z[n]);
      AppendElement(p,pElem);
      if( p-&gt;iPlaintext==0 || p-&gt;iPlaintext==Html_TEXTAREA ){
        HtmlTranslateEscapes(pElem-&gt;text.zText);
      }
      pElem-&gt;base.count = strlen(pElem-&gt;text.zText);
      n += i;
      iCol += i;
    }else if( strncmp(&amp;z[n],"&lt;!--",4)==0 ){
      /* An HTML comment.  Just skip it. */
      for(i=4; z[n+i]; i++){
        if( z[n+i]=='-' &amp;&amp; strncmp(&amp;z[n+i],"--&gt;",3)==0 ){ break; }
      }
      if( z[n+i]==0 ){ TestPoint(0); goto incomplete; }
      for(j=0; j&lt;i+3; j++){
        iCol = NextColumn(iCol, z[n+j]);
      }
      n += i + 3;
    }else{
      /* Markup.
      **
      ** First get the name of the markup
      */
doMarkup:
      argc = 1;
      argv[0] = &amp;z[n+1];
      for(i=1; (c=z[n+i])!=0 &amp;&amp; !isspace(c) &amp;&amp; c!='&gt;' &amp;&amp; (i&lt;2 || c!='/'); i++){}
      arglen[0] = i - 1;
      if( c==0 ){ goto incomplete; }

      /*
      ** Now parse up the arguments
      */
      while( isspace(z[n+i]) ){ i++; }
      while( (c=z[n+i])!=0 &amp;&amp; c!='&gt;' &amp;&amp; (c!='/' || z[n+i+1]!='&gt;') ){
        if( argc&gt;mxARG-3 ){
          argc = mxARG-3;
        }
        argv[argc] = &amp;z[n+i];
        j = 0;
        while( (c=z[n+i+j])!=0 &amp;&amp; !isspace(c) &amp;&amp; c!='&gt;' 
               &amp;&amp; c!='=' &amp;&amp; (c!='/' || z[n+i+j+1]!='&gt;') ){
          j++;
        }
        arglen[argc] = j;
        if( c==0 ){  goto incomplete; }
        i += j;
        while( isspace(c) ){
          i++;
          c = z[n+i];
        }
        if( c==0 ){ goto incomplete; }
        argc++;
        if( c!='=' ){
          argv[argc] = "";
          arglen[argc] = 0;
          argc++;
          continue;
        }
        i++;
        c = z[n+i];
        while( isspace(c) ){
          i++;
          c = z[n+i];
        }
        if( c==0 ){ goto incomplete; }
        if( c=='\'' || c=='"' ){
          int cQuote = c;
          i++;
          argv[argc] = &amp;z[n+i];
          for(j=0; (c=z[n+i+j])!=0 &amp;&amp; c!=cQuote; j++){}
          if( c==0 ){ goto incomplete; }
          arglen[argc] = j;
          i += j+1;
          TestPoint(0);
        }else{
          argv[argc] = &amp;z[n+i];
          for(j=0; (c=z[n+i+j])!=0 &amp;&amp; !isspace(c) &amp;&amp; c!='&gt;'; j++){}
          if( c==0 ){ goto incomplete; }
          arglen[argc] = j;
          i += j;
        }
        argc++;
        while( isspace(z[n+i]) ){ i++; }
      }
      if( c=='/' ){
        i++;
        c = z[n+i];
        selfClose = 1;
      }else{
        selfClose = 0;
      }
      if( c==0 ){ goto incomplete; }
      for(j=0; j&lt;i+1; j++){
        iCol = NextColumn(iCol, z[n+j]);
      }
      n += i + 1;

      /* Lookup the markup name in the hash table 
      */
      if( !isInit ){
        HtmlHashInit();
        isInit = 1;
      }
      c = argv[0][arglen[0]];
      argv[0][arglen[0]] = 0;
      h = HtmlHash(argv[0]);
      for(pMap = apMap[h]; pMap; pMap=pMap-&gt;pCollide){
        if( stricmp(pMap-&gt;zName,argv[0])==0 ){ break; }
        TestPoint(0);
      }
      argv[0][arglen[0]] = c;
      if( pMap==0 ){ continue; }  /* Ignore unknown markup */

makeMarkupEntry:
      /* Construct a HtmlMarkup entry for this markup.
      */ 
      if( pMap-&gt;extra ){
        nByte = pMap-&gt;extra;
      }else if( argc==1 ){
        nByte = sizeof(HtmlBaseElement);
      }else{
        nByte = sizeof(HtmlMarkupElement);
      }
      if( argc&gt;1 ){
        nByte += sizeof(char*) * argc;
        for(j=1; j&lt;argc; j++){
          nByte += arglen[j] + 1;
        }
      }
      pElem = HtmlAlloc( nByte );
      if( pElem==0 ){ goto incomplete; }
      memset(pElem,0,nByte);
      pElem-&gt;base.type = pMap-&gt;type;
      pElem-&gt;base.count = argc - 1;
      if( argc&gt;1 ){
        if( pMap-&gt;extra ){
          pElem-&gt;markup.argv = (char**)&amp;((char*)pElem)[pMap-&gt;extra];
        }else{
          pElem-&gt;markup.argv = (char**)&amp;((HtmlMarkupElement*)pElem)[1];
        }
        zBuf = (char*)&amp;pElem-&gt;markup.argv[argc];
        for(j=1; j&lt;argc; j++){
          pElem-&gt;markup.argv[j-1] = zBuf;
          zBuf += arglen[j] + 1;
          sprintf(pElem-&gt;markup.argv[j-1],"%.*s",arglen[j],argv[j]);
          HtmlTranslateEscapes(pElem-&gt;markup.argv[j-1]);
          if( (j&amp;1)==1 ){
            ToLower(pElem-&gt;markup.argv[j-1]);
          }
        }
        pElem-&gt;markup.argv[argc-1] = 0;
      }

      /* The new markup has now be constructed in pElem.  But before
      ** appending to the list, check to see if there is a special
      ** handler for this markup type.
      */
      if( p-&gt;zHandler[pMap-&gt;type] ){
        Tcl_DString str;
        Tcl_DStringInit(&amp;str);
        Tcl_DStringAppend(&amp;str, p-&gt;zHandler[pMap-&gt;type], -1);
        Tcl_DStringAppendElement(&amp;str, pMap-&gt;zName);
        Tcl_DStringStartSublist(&amp;str);
        for(j=0; j&lt;argc-1; j++){
          Tcl_DStringAppendElement(&amp;str, pElem-&gt;markup.argv[j]);
        }
        Tcl_DStringEndSublist(&amp;str);
        HtmlFree(pElem);
        HtmlLock(p);
        Tcl_GlobalEval(p-&gt;interp, Tcl_DStringValue(&amp;str));
        Tcl_DStringFree(&amp;str);
        if( HtmlUnlock(p) ){ return 0; }

        /* Tricky, tricky.  The callback might have caused the p-&gt;zText
        ** pointer to change, so renew our copy of that pointer.  The
        ** callback might also have cleared or destroyed the widget.
        ** If so, abort this routine.
        */
        z = p-&gt;zText;
        if( z==0 || p-&gt;tkwin==0 ){
          n = 0;
          iCol = 0;
          goto incomplete;
        }
        continue;
      }

      /* No special handler for this markup.  Just append it to the
      ** list of all tokens.
      */
      AppendElement(p,pElem);
      switch( pMap-&gt;type ){
        case Html_PLAINTEXT:
        case Html_LISTING:
        case Html_XMP:
        case Html_TEXTAREA:
          p-&gt;iPlaintext = pMap-&gt;type;
          break;
        case Html_STYLE:
        case Html_SCRIPT:
          p-&gt;pScript = (HtmlScript*)pElem;
          break;
        default:
          break;
      }

      /* If this is self-closing markup (ex: &lt;br/&gt; or &lt;img/&gt;) then
      ** synthesize a closing token.
      */
      if( selfClose &amp;&amp; argv[0][0]!='/' 
      &amp;&amp; strcmp(&amp;pMap[1].zName[1],pMap-&gt;zName)==0 ){
        selfClose = 0;
        pMap++;
        argc = 1;
        goto makeMarkupEntry;
      }
    }
  }
incomplete:
  p-&gt;iCol = iCol;
  return n;
}
</t>
<t tx="ekr.20041214071955.113">@ ************************* End HTML Tokenizer Code **************************
** Append text to the tokenizer engine. ** ** This routine (actually the Tokenize() subroutine that is called ** by this routine) may invoke a callback procedure which could delete ** the HTML widget.
@c

void HtmlTokenizerAppend(HtmlWidget *htmlPtr, const char *zText){
  int len = strlen(zText);
  if( htmlPtr-&gt;nText==0 ){
    htmlPtr-&gt;nAlloc = len + 100;
    htmlPtr-&gt;zText = HtmlAlloc( htmlPtr-&gt;nAlloc );
    TestPoint(0);
  }else if( htmlPtr-&gt;nText + len &gt;= htmlPtr-&gt;nAlloc ){
    htmlPtr-&gt;nAlloc += len + 100;
    htmlPtr-&gt;zText = HtmlRealloc( htmlPtr-&gt;zText, htmlPtr-&gt;nAlloc );
    TestPoint(0);
  }
  if( htmlPtr-&gt;zText==0 ){
    htmlPtr-&gt;nText = 0;
    UNTESTED;
    return;
  }
  strcpy(&amp;htmlPtr-&gt;zText[htmlPtr-&gt;nText], zText);
  htmlPtr-&gt;nText += len;
  htmlPtr-&gt;nComplete = Tokenize(htmlPtr);
}
</t>
<t tx="ekr.20041214071955.114">@ ** This routine takes a text representation of a token, converts ** it into an HtmlElement structure and inserts it immediately ** prior to pToken. If pToken==0, then the newly created HtmlElement ** is appended. ** ** This routine does nothing to resize, restyle, relayout or redisplay ** the HTML. That is the calling routines responsibility. ** ** Return 0 if successful. Return non-zero if zType is not a known ** markup name.
@c

int HtmlInsertToken(
  HtmlWidget *htmlPtr,     /* The widget into which the token is inserted */
  HtmlElement *pToken,     /* Insert before this.  Append if pToken==0 */
  char *zType,             /* Type of markup.  Ex: "/a" or "table" */
  char *zArgs              /* List of arguments */
){
  HtmlTokenMap *pMap;     /* For searching the markup name hash table */
  int h;                   /* The hash on zType */
  HtmlElement *pElem;      /* The new element */
  int nByte;               /* How many bytes to allocate */
  int i;                   /* Loop counter */

  if( !isInit ){
    HtmlHashInit();
    isInit = 1;
    TestPoint(0);
  }else{
    TestPoint(0);
  }
  h = HtmlHash(zType);
  for(pMap = apMap[h]; pMap; pMap=pMap-&gt;pCollide){
    if( stricmp(pMap-&gt;zName,zType)==0 ){ TestPoint(0); break; }
    TestPoint(0);
  }
  if( pMap==0 ){ TestPoint(0); return 1; }

  if( zArgs==0 || *zArgs==0 ){
    /* Special case of no arguments.  This is a lot easier... */
    nByte = pMap-&gt;extra ? pMap-&gt;extra : sizeof(HtmlBaseElement);
    nByte += strlen(zType);
    pElem = HtmlAlloc( nByte );
    if( pElem==0 ){ TestPoint(0); return 1; }
    memset(pElem,0,nByte);
    pElem-&gt;base.type = pMap-&gt;type;
    TestPoint(0);
  }else{
    /* The general case.  There are arguments that need to be parsed
    ** up.  This is slower, but we gotta do it.
    */
    int argc;
    char **argv;
    char *zBuf;

    if( Tcl_SplitList(htmlPtr-&gt;interp, zArgs, &amp;argc, &amp;argv)!=TCL_OK ){
      TestPoint(0);
      return 1;
    }
    if( pMap-&gt;extra ){
      nByte = pMap-&gt;extra;
      TestPoint(0);
    }else{
      nByte = sizeof(HtmlMarkupElement);
      TestPoint(0);
    }
    nByte += sizeof(char*)*(argc+1) + strlen(zArgs) + argc + 2;
    pElem = HtmlAlloc( nByte );
    if( pElem==0 ){
      HtmlFree(argv);
      TestPoint(0);
      return 1;
    }
    memset(pElem,0,nByte);
    pElem-&gt;base.type = pMap-&gt;type;
    pElem-&gt;base.count = argc;
    if( pMap-&gt;extra ){
      pElem-&gt;markup.argv = (char**)&amp;((char*)pElem)[pMap-&gt;extra];
      TestPoint(0);
    }else{
      pElem-&gt;markup.argv = (char**)&amp;((HtmlMarkupElement*)pElem)[1];
      TestPoint(0);
    }
    zBuf = (char*)&amp;pElem-&gt;markup.argv[argc];
    for(i=1; i&lt;argc; i++){
      pElem-&gt;markup.argv[i-1] = zBuf;
      zBuf += strlen(argv[i]) + 1;
      strcpy(pElem-&gt;markup.argv[i-1],argv[i]);
      TestPoint(0);
    }
    pElem-&gt;markup.argv[argc-1] = 0;
    HtmlFree(argv);
    TestPoint(0);
  }
  if( pToken ){
    pElem-&gt;base.pNext = pToken;
    pElem-&gt;base.pPrev = pToken-&gt;base.pPrev;
    if( pToken-&gt;base.pPrev ){
      pToken-&gt;base.pPrev-&gt;pNext = pElem;
      TestPoint(0);
    }else{
      htmlPtr-&gt;pFirst = pElem;
      TestPoint(0);
    }
    pToken-&gt;base.pPrev = pElem;
    htmlPtr-&gt;nToken++;
  }else{
    AppendElement(htmlPtr,pElem);
    TestPoint(0);
  }
  return 0;
}
</t>
<t tx="ekr.20041214071955.115">@ ** Convert a markup name into a type integer
@c

int HtmlNameToType(char *zType){
  HtmlTokenMap *pMap;     /* For searching the markup name hash table */
  int h;                   /* The hash on zType */

  if( !isInit ){
    HtmlHashInit();
    isInit = 1;
    TestPoint(0);
  }else{
    TestPoint(0);
  }
  h = HtmlHash(zType);
  for(pMap = apMap[h]; pMap; pMap=pMap-&gt;pCollide){
    if( stricmp(pMap-&gt;zName,zType)==0 ){ TestPoint(0); break; }
    TestPoint(0);
  }
  return pMap ? pMap-&gt;type : Html_Unknown;
}
</t>
<t tx="ekr.20041214071955.116">@ ** Convert a type into a symbolic name
@c

const char *HtmlTypeToName(int type){
  if( type&gt;=Html_A &amp;&amp; type&lt;=Html_EndXMP ){
    HtmlTokenMap *pMap = apMap[type - Html_A];
    TestPoint(0);
    return pMap-&gt;zName;
  }else{
    TestPoint(0);
    return "???";
  }
}
</t>
<t tx="ekr.20041214071955.117">@ ** For debugging purposes, print information about a token
@c

char *HtmlTokenName(HtmlElement *p){
#ifdef DEBUG
  static char zBuf[200];
  int j;
  char *zName;

  if( p==0 ) return "NULL";
  switch( p-&gt;base.type ){
  case Html_Text:
    sprintf(zBuf,"\"%.*s\"",p-&gt;base.count,p-&gt;text.zText);
    break;
  case Html_Space:
    if( p-&gt;base.flags &amp; HTML_NewLine ){
      sprintf(zBuf,"\"\\n\"");
    }else{
      sprintf(zBuf,"\" \"");
    }
    break;
  case Html_Block:
    if( p-&gt;block.n&gt;0 ){
      int n = p-&gt;block.n;
      if( n&gt;150 ) n = 150;
      sprintf(zBuf,"&lt;Block z=\"%.*s\"&gt;", n, p-&gt;block.z);
    }else{
      sprintf(zBuf,"&lt;Block&gt;");
    }
    break;
  default:
    if( p-&gt;base.type &gt;= HtmlMarkupMap[0].type 
    &amp;&amp; p-&gt;base.type &lt;= HtmlMarkupMap[HTML_MARKUP_COUNT-1].type ){
      zName = HtmlMarkupMap[p-&gt;base.type - HtmlMarkupMap[0].type].zName;
    }else{
      zName = "Unknown";
    }
    sprintf(zBuf,"&lt;%s",zName);
    for(j=1; j&lt;p-&gt;base.count; j += 2){
      sprintf(&amp;zBuf[strlen(zBuf)]," %s=%s",
              p-&gt;markup.argv[j-1],p-&gt;markup.argv[j]);
    }
    strcat(zBuf,"&gt;");
    break;
  }
  return zBuf;
#else
  return 0;
#endif
}
</t>
<t tx="ekr.20041214071955.118">@ ** Return all tokens between the two elements as a Tcl list.
@c

void HtmlTclizeList(Tcl_Interp *interp, HtmlElement *p, HtmlElement *pEnd){
  Tcl_DString str;
  int i;
  char *zName;
  char zLine[100];

  Tcl_DStringInit(&amp;str);
  while( p &amp;&amp; p!=pEnd ){
    switch( p-&gt;base.type ){
      case Html_Block:
        break;
      case Html_Text:
        Tcl_DStringStartSublist(&amp;str);
        Tcl_DStringAppendElement(&amp;str,"Text");
        Tcl_DStringAppendElement(&amp;str, p-&gt;text.zText);
        Tcl_DStringEndSublist(&amp;str);
        break;
      case Html_Space:
        sprintf(zLine,"Space %d %d",
          p-&gt;base.count, (p-&gt;base.flags &amp; HTML_NewLine)!=0);
        Tcl_DStringAppendElement(&amp;str,zLine);
        break;
      case Html_Unknown:
        Tcl_DStringAppendElement(&amp;str,"Unknown");
        break;
      default:
        Tcl_DStringStartSublist(&amp;str);
        Tcl_DStringAppendElement(&amp;str,"Markup");
        if( p-&gt;base.type &gt;= HtmlMarkupMap[0].type 
         &amp;&amp; p-&gt;base.type &lt;= HtmlMarkupMap[HTML_MARKUP_COUNT-1].type ){
          zName = HtmlMarkupMap[p-&gt;base.type - HtmlMarkupMap[0].type].zName;
        }else{
          zName = "Unknown";
        }
        Tcl_DStringAppendElement(&amp;str, zName);
        for(i=0; i&lt;p-&gt;base.count; i++){
          Tcl_DStringAppendElement(&amp;str, p-&gt;markup.argv[i]);
        }
        Tcl_DStringEndSublist(&amp;str);
        break;
    }
    p = p-&gt;pNext;
  }
  Tcl_DStringResult(interp, &amp;str);
}
</t>
<t tx="ekr.20041214071955.119">@ ** Print a list of tokens
@c

#ifdef DEBUG
void HtmlPrintList(HtmlElement *p, HtmlElement *pEnd){
  while( p &amp;&amp; p!=pEnd ){
    if( p-&gt;base.type==Html_Block ){
      char *z = p-&gt;block.z;
      int n = p-&gt;block.n;
      if( n==0 || z==0 ){
        n = 1;
        z = "";
      }
      printf("Block 0x%08x flags=%02x cnt=%d x=%d..%d y=%d..%d z=\"%.*s\"\n",
        (int)p, p-&gt;base.flags, p-&gt;base.count, p-&gt;block.left, p-&gt;block.right,
        p-&gt;block.top, p-&gt;block.bottom, n, z);
    }else{
      printf("Token 0x%08x font=%2d color=%2d align=%d flags=0x%04x name=%s\n",
        (int)p, p-&gt;base.style.font, p-&gt;base.style.color,
        p-&gt;base.style.align, p-&gt;base.style.flags, HtmlTokenName(p));
    }
    p = p-&gt;pNext;
  }
}
</t>
<t tx="ekr.20041214071955.120">@ignore
@language c
static char const rcsid[] = "@(#) $Id: htmlsizer.c,v 1.34 2000/02/25 13:57:03 drh Exp $";
/* Routines used to compute the style and size of individual elements. */
&lt;&lt; htmlsizer #includes &gt;&gt;
@others
</t>
<t tx="ekr.20041214071955.121">#include &lt;tk.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include "htmlsizer.h"
</t>
<t tx="ekr.20041214071955.122">@ ** Get the current rendering style. In other words, get the style ** that is currently on the top of the style stack.
@c

static HtmlStyle GetCurrentStyle(HtmlWidget *htmlPtr){
  HtmlStyle style;
  if( htmlPtr-&gt;styleStack ){
    style = htmlPtr-&gt;styleStack-&gt;style;
  }else{
    style.font = NormalFont(2);
    style.color = COLOR_Normal;
    style.bgcolor = COLOR_Background;
    style.subscript = 0;
    style.align = ALIGN_Left;
    style.flags = 0;
  }
  return style;
}
</t>
<t tx="ekr.20041214071955.123">@ ** Push a new rendering style onto the stack.
@c

static void PushStyleStack(
  HtmlWidget *htmlPtr,   /* Widget on which to push the style */
  int tag,               /* Tag for this style.  Normally the end-tag such
                         ** as &lt;/h3&gt; or &lt;/em&gt;. */
  HtmlStyle style        /* The style to push */
){
  HtmlStyleStack *p;

  p = HtmlAlloc(sizeof(*p));
  p-&gt;pNext = htmlPtr-&gt;styleStack;
  p-&gt;type = tag;
  p-&gt;style = style;
  htmlPtr-&gt;styleStack = p;
}
</t>
<t tx="ekr.20041214071955.124">@ ** Pop a rendering style off of the stack. ** ** The top-most style on the stack should have a tag equal to "tag". ** If not, then we have an HTML coding error. Perhaps something ** like this: "Some text &lt;em&gt;Enphasized&lt;/i&gt; more text". It is an ** interesting problem to figure out how to respond sanely to this ** kind of error. Our solution it to keep popping the stack until ** we find the correct tag, or until the stack is empty.
@c

HtmlStyle HtmlPopStyleStack(HtmlWidget *htmlPtr, int tag){
  int type;
  HtmlStyleStack *p;
  static Html_u8 priority[Html_TypeCount+1];

  if( priority[Html_TABLE]==0 ){
    int i;
    for(i=0; i&lt;=Html_TypeCount; i++) priority[i] = 1;
    priority[Html_TD] = 2;
    priority[Html_EndTD] = 2;
    priority[Html_TH] = 2;
    priority[Html_EndTH] = 2;
    priority[Html_TR] = 3;
    priority[Html_EndTR] = 3;
    priority[Html_TABLE] = 4;
    priority[Html_EndTABLE] = 4;
  }
  if( tag&lt;=0 || tag&gt;Html_TypeCount ){
    CANT_HAPPEN;
    return GetCurrentStyle(htmlPtr);
  }
  while( (p=htmlPtr-&gt;styleStack)!=0 ){
    type = p-&gt;type;
    if( type&lt;=0 || type&gt;Html_TypeCount ){
      CANT_HAPPEN;
      return GetCurrentStyle(htmlPtr);
    }
    if( type!=tag &amp;&amp; priority[type]&gt;priority[tag] ){
      return GetCurrentStyle(htmlPtr);
    }
    htmlPtr-&gt;styleStack = p-&gt;pNext;
    HtmlFree(p);
    if( type==tag ){ break; }
  }
  return GetCurrentStyle(htmlPtr);
}
</t>
<t tx="ekr.20041214071955.125">@ ** Change the font size on the given style by the delta-amount given
@c

static void ScaleFont(HtmlStyle *pStyle, int delta){
  int size = FontSize(pStyle-&gt;font) + delta;
  if( size&lt;0 ){
    delta -= size;
  }else if( size&gt;6 ){
    delta -= size-6;
  }
  pStyle-&gt;font += delta;
}
</t>
<t tx="ekr.20041214071955.126">@ ** Lookup an argument in the given markup with the name given. ** Return a pointer to its value, or the given default ** value if it doesn't appear.
@c

char *HtmlMarkupArg(HtmlElement *p, const char *tag, char *zDefault){
  int i;
  if( !HtmlIsMarkup(p) ){ TestPoint(0); return 0; }
  for(i=0; i&lt;p-&gt;base.count; i+=2){
    if( strcmp(p-&gt;markup.argv[i],tag)==0 ){
      return  p-&gt;markup.argv[i+1];
    }
  }
  return zDefault;
}
</t>
<t tx="ekr.20041214071955.127">@ ** Return an alignment or justification flag associated with the ** given markup. The given default value is returned if no alignment is ** specified.
@c

static int GetAlignment(HtmlElement *p, int dflt){
  char *z = HtmlMarkupArg(p,"align",0);
  int rc = dflt;
  if( z ){
    if( stricmp(z,"left")==0 ){
      rc = ALIGN_Left;
    }else if( stricmp(z,"right")==0 ){
      rc = ALIGN_Right;
    }else if( stricmp(z,"center")==0 ){
      rc = ALIGN_Center;
    }
  }
  return rc;
}
</t>
<t tx="ekr.20041214071955.128">@ ** The "type" argument to the given element might describe the type ** for an ordered list. Return the corresponding LI_TYPE_* entry ** if this is the case, or the default value if it isn't.
@c

static int GetOrderedListType(HtmlElement *p, int dflt){
  char *z;

  z = HtmlMarkupArg(p,"type",0);
  if( z ){
    switch( *z ){
      case 'A':  TestPoint(0); dflt = LI_TYPE_Enum_A; break;
      case 'a':  TestPoint(0); dflt = LI_TYPE_Enum_a; break;
      case '1':  TestPoint(0); dflt = LI_TYPE_Enum_1; break;
      case 'I':  TestPoint(0); dflt = LI_TYPE_Enum_I; break;
      case 'i':  TestPoint(0); dflt = LI_TYPE_Enum_i; break;
      default:   TestPoint(0); break;
    }
  }else{
    TestPoint(0);
  }
  return dflt;
}
</t>
<t tx="ekr.20041214071955.129">@ ** The "type" argument to the given element might describe a type ** for an unordered list. Return the corresponding LI_TYPE entry ** if this is the case, or the default value if it isn't.
@c

static int GetUnorderedListType(HtmlElement *p, int dflt){
  char *z;

  z = HtmlMarkupArg(p,"type",0);
  if( z ){
    if( stricmp(z,"disc")==0 ){
      dflt = LI_TYPE_Bullet1;
    }else if( stricmp(z,"circle")==0 ){
      dflt = LI_TYPE_Bullet2;
    }else if( stricmp(z,"square")==0 ){
      dflt = LI_TYPE_Bullet3;
    }
  }
  return dflt;
}
</t>
<t tx="ekr.20041214071955.130">@ ** Add the STY_Invisible style to every token between pFirst and pLast.
@c

static void MakeInvisible(HtmlElement *pFirst, HtmlElement *pLast){
  if( pFirst==0 ) return;
  pFirst = pFirst-&gt;pNext;
  while( pFirst &amp;&amp; pFirst!=pLast ){
    pFirst-&gt;base.style.flags |= STY_Invisible;
    pFirst=pFirst-&gt;pNext;
  }
}
</t>
<t tx="ekr.20041214071955.131">@ ** For the markup &lt;a href=XXX&gt;, find out if the URL has been visited ** before or not. Return COLOR_Visited or COLOR_Unvisited, as ** appropriate. ** ** This routine may invoke a callback procedure which could delete ** the HTML widget. The calling function should call HtmlLock() ** if it needs the widget structure to be preserved.
@c

static int GetLinkColor(HtmlWidget *htmlPtr, char *zURL){
  char *zCmd;
  int result;
  int isVisited;

  if( htmlPtr-&gt;tkwin==0 ){
    TestPoint(0);
    return COLOR_Normal;
  }
  if( htmlPtr-&gt;zIsVisited==0 || htmlPtr-&gt;zIsVisited[0]==0 ){
    TestPoint(0);
    return COLOR_Unvisited;
  }
  zCmd = HtmlAlloc( strlen(htmlPtr-&gt;zIsVisited) + strlen(zURL) + 10 );
  if( zCmd==0 ){
    TestPoint(0);
    return COLOR_Unvisited;
  }
  sprintf(zCmd,"%s {%s}",htmlPtr-&gt;zIsVisited, zURL);
  HtmlLock(htmlPtr);
  result = Tcl_GlobalEval(htmlPtr-&gt;interp,zCmd);
  HtmlFree(zCmd);
  if( HtmlUnlock(htmlPtr) ){
    return COLOR_Unvisited;
  }
  if( result!=TCL_OK ){
    TestPoint(0);
    goto errorOut;
  }
  result = Tcl_GetBoolean(htmlPtr-&gt;interp, htmlPtr-&gt;interp-&gt;result, &amp;isVisited);
  if( result!=TCL_OK ){
    TestPoint(0);
    goto errorOut;
  }
  TestPoint(0);
  return isVisited ? COLOR_Visited : COLOR_Unvisited;

  errorOut:
  Tcl_AddErrorInfo(htmlPtr-&gt;interp,
    "\n    (\"-isvisitedcommand\" command executed by html widget)");
  Tcl_BackgroundError(htmlPtr-&gt;interp);
  TestPoint(0);
  return COLOR_Unvisited;
}
</t>
<t tx="ekr.20041214071955.132">@ ** This routine adds information to the input texts that doesn't change ** when the display is resized or when new fonts are selected, etc. ** Mostly this means adding style attributes. But other constant ** information (such as numbering on &lt;li&gt; and images used for &lt;IMG&gt;) ** is also obtained. The key is that this routine is only called ** once, where the sizer and layout routines can be called many times. ** ** This routine is called whenever the list of elements grows. The ** style stack is stored as part of the HTML widget so that we can ** always continue where we left off the last time. ** ** In addition to adding style, this routine will invoke callbacks ** needed to acquire information about a markup. The htmlPtr-&gt;zIsVisitied ** callback is called for each &lt;a&gt; and the htmlPtr-&gt;zGetImage is called ** for each &lt;IMG&gt; or for each &lt;LI&gt; that has a SRC= field. ** ** This routine may invoke a callback procedure which could delete ** the HTML widget. ** ** When a markup is inserted or deleted from the token list, the ** style routine must be completely rerun from the beginning. So ** what we said above, that this routine is only run once, is not ** strictly true.
@c

void HtmlAddStyle(HtmlWidget *htmlPtr, HtmlElement *p){
  HtmlStyle style;          /* Current style */
  int size;                 /* A new font size */
  int i;                    /* Loop counter */
  int paraAlign;            /* Current paragraph alignment */
  int rowAlign;             /* Current table row alignment */
  int anchorFlags;          /* Flags associated with &lt;a&gt; tag */
  int inDt;                 /* True if within &lt;dt&gt;..&lt;/dt&gt; */
  HtmlStyle nextStyle;      /* Style for next token if useNextStyle==1 */
  int useNextStyle = 0;     /* True if nextStyle is valid */
  char *z;                  /* A tag parameter's value */

  /* The size of header fonts relative to the current font size */
  static int header_sizes[] = {+2, +1, 1, 1, -1, -1};

  /* Don't allow recursion */
  if( htmlPtr-&gt;flags &amp; STYLER_RUNNING ){ TestPoint(0); return; }
  htmlPtr-&gt;flags |= STYLER_RUNNING;

  /* Load the style state out of the htmlPtr structure and into local
  ** variables.  This is purely a matter of convenience... */
  style = GetCurrentStyle(htmlPtr);
  paraAlign = htmlPtr-&gt;paraAlignment;
  rowAlign = htmlPtr-&gt;rowAlignment;
  anchorFlags = htmlPtr-&gt;anchorFlags;
  inDt = htmlPtr-&gt;inDt;

  /* Loop over tokens */
  while( p ){
    switch( p-&gt;base.type ){
      case Html_A:
        if( htmlPtr-&gt;anchorStart ){
          style = HtmlPopStyleStack(htmlPtr, Html_EndA);
          htmlPtr-&gt;anchorStart = 0;
          anchorFlags = 0;
        }
        z = HtmlMarkupArg(p,"href",0);
        if( z ){
          HtmlLock(htmlPtr);
          style.color = GetLinkColor(htmlPtr, z);
          if( htmlPtr-&gt;underlineLinks ){
            style.flags |= STY_Underline;
          }
          if( HtmlUnlock(htmlPtr) ) return;
          anchorFlags |= STY_Anchor;
          PushStyleStack(htmlPtr, Html_EndA, style);
          htmlPtr-&gt;anchorStart = p;
        }
        break;
      case Html_EndA:
        if( htmlPtr-&gt;anchorStart ){
          p-&gt;ref.pOther = htmlPtr-&gt;anchorStart;
          style = HtmlPopStyleStack(htmlPtr, Html_EndA);
          htmlPtr-&gt;anchorStart = 0;
          anchorFlags = 0;
        }
        break;
      case Html_ADDRESS:
      case Html_EndADDRESS:
      case Html_BLOCKQUOTE:
      case Html_EndBLOCKQUOTE:
        paraAlign = ALIGN_None;
        TestPoint(0);
        break;
      case Html_APPLET:
        if( htmlPtr-&gt;zAppletCommand &amp;&amp; *htmlPtr-&gt;zAppletCommand ){
          nextStyle = style;
          nextStyle.flags |= STY_Invisible;
          PushStyleStack(htmlPtr, Html_EndAPPLET, nextStyle);
          useNextStyle = 1;
        }else{
          PushStyleStack(htmlPtr, Html_EndAPPLET, style);
        }
        TestPoint(0);
        break;
      case Html_B:
        style.font = BoldFont( FontSize(style.font) );
        PushStyleStack(htmlPtr, Html_EndB, style);
        TestPoint(0);
        break;
      case Html_EndAPPLET:
      case Html_EndB:
      case Html_EndBIG:
      case Html_EndCENTER:
      case Html_EndCITE:
      case Html_EndCODE:
      case Html_EndCOMMENT:
      case Html_EndEM:
      case Html_EndFONT:
      case Html_EndI:
      case Html_EndKBD:
      case Html_EndMARQUEE:
      case Html_EndNOBR:
      case Html_EndNOFRAME:
      case Html_EndNOSCRIPT:
      case Html_EndS:
      case Html_EndSAMP:
      case Html_EndSMALL:
      case Html_EndSTRIKE:
      case Html_EndSTRONG:
      case Html_EndSUB:
      case Html_EndSUP:
      case Html_EndTITLE:
      case Html_EndTT:
      case Html_EndU:
      case Html_EndVAR:
        style = HtmlPopStyleStack(htmlPtr, p-&gt;base.type);
        TestPoint(0);
        break;
      case Html_BASE:
        z = HtmlMarkupArg(p,"href",0);
        if( z ){
          HtmlLock(htmlPtr);
          z = HtmlResolveUri(htmlPtr, z);
          if( HtmlUnlock(htmlPtr) ) return;
          if( z!=0 ){
            if( htmlPtr-&gt;zBaseHref ){
              HtmlFree(htmlPtr-&gt;zBaseHref);
            }
            htmlPtr-&gt;zBaseHref = z;
          }
        }
        break;
      case Html_EndDIV:
        paraAlign = ALIGN_None;
        style = HtmlPopStyleStack(htmlPtr, p-&gt;base.type);
        TestPoint(0);
        break;
      case Html_EndBASEFONT:
        style = HtmlPopStyleStack(htmlPtr, Html_EndBASEFONT);
        style.font = FontFamily(style.font) + 2;
        TestPoint(0);
        break;
      case Html_BIG:
        ScaleFont(&amp;style,1);
        PushStyleStack(htmlPtr, Html_EndBIG, style);
        TestPoint(0);
        break;
      case Html_CAPTION:
        paraAlign = GetAlignment(p, paraAlign);
        TestPoint(0);
        break;
      case Html_EndCAPTION:
        paraAlign = ALIGN_None;
        TestPoint(0);
        break;
      case Html_CENTER:
        paraAlign = ALIGN_None;
        style.align = ALIGN_Center;
        PushStyleStack(htmlPtr, Html_EndCENTER, style);
        TestPoint(0);
        break;
      case Html_CITE:
        PushStyleStack(htmlPtr, Html_EndCITE, style);
        TestPoint(0);
        break;
      case Html_CODE:
        style.font = CWFont( FontSize(style.font) );
        PushStyleStack(htmlPtr, Html_EndCODE, style);
        TestPoint(0);
        break;
      case Html_COMMENT:
        style.flags |= STY_Invisible;
        PushStyleStack(htmlPtr, Html_EndCOMMENT, style);
        TestPoint(0);
        break;
      case Html_DD:
        if( htmlPtr-&gt;innerList &amp;&amp; htmlPtr-&gt;innerList-&gt;base.type==Html_DL ){
          p-&gt;ref.pOther = htmlPtr-&gt;innerList;
          TestPoint(0);
        }else{
          p-&gt;ref.pOther = 0;
          TestPoint(0);
        }
        inDt = 0;
        break;
      case Html_DIR:
      case Html_MENU:
      case Html_UL:
        p-&gt;list.pPrev = htmlPtr-&gt;innerList;
        p-&gt;list.cnt = 0;
        htmlPtr-&gt;innerList = p;
        if( p-&gt;list.pPrev==0 ){
          p-&gt;list.type = LI_TYPE_Bullet1;
          p-&gt;list.compact = HtmlMarkupArg(p,"compact",0)!=0;
          TestPoint(0);
        }else if( p-&gt;list.pPrev-&gt;list.pPrev==0 ){
          p-&gt;list.type = LI_TYPE_Bullet2;
          p-&gt;list.compact = 1;
          TestPoint(0);
        }else{
          p-&gt;list.type = LI_TYPE_Bullet3;
          p-&gt;list.compact = 1;
          TestPoint(0);
        }
        p-&gt;list.type = GetUnorderedListType(p,p-&gt;list.type);
        break;
      case Html_EndDL:
        inDt = 0;
        TestPoint(0);
        /* Fall thru into the next case */
      case Html_EndDIR:
      case Html_EndMENU:
      case Html_EndOL:
      case Html_EndUL:
        p-&gt;ref.pOther = htmlPtr-&gt;innerList;
        if( htmlPtr-&gt;innerList ){
          htmlPtr-&gt;innerList = htmlPtr-&gt;innerList-&gt;list.pPrev;
          TestPoint(0);
        }else{
          TestPoint(0);
        }
        break;
      case Html_DIV:
        paraAlign = ALIGN_None;
        style.align = GetAlignment(p, style.align);
        PushStyleStack(htmlPtr, Html_EndDIV, style);
        TestPoint(0);
        break;
      case Html_DT:
        if( htmlPtr-&gt;innerList &amp;&amp; htmlPtr-&gt;innerList-&gt;base.type==Html_DL ){
          p-&gt;ref.pOther = htmlPtr-&gt;innerList;
          TestPoint(0);
        }else{
          p-&gt;ref.pOther = 0;
          TestPoint(0);
        }
        inDt = STY_DT;
        break;
      case Html_EndDD:
      case Html_EndDT:
        inDt = 0;
        TestPoint(0);
        break;
      case Html_DL:
        p-&gt;list.pPrev = htmlPtr-&gt;innerList;
        p-&gt;list.cnt = 0;
        htmlPtr-&gt;innerList = p;
        p-&gt;list.compact = HtmlMarkupArg(p,"compact",0)!=0;
        inDt = 0;
        TestPoint(0);
        break; 
      case Html_EM:
        style.font = ItalicFont( FontSize(style.font) );
        PushStyleStack(htmlPtr, Html_EndEM, style);
        TestPoint(0);
        break;
      case Html_EMBED:
        break;
      case Html_BASEFONT:
      case Html_FONT:
        z = HtmlMarkupArg(p,"size",0);
        if( z ){
          if( *z=='-' ){
            size = FontSize(style.font) - atoi(&amp;z[1]);
          }else if( *z=='+' ){
            size = FontSize(style.font) + atoi(&amp;z[1]);
          }else{
            size = atoi(z);
          }
          if( size &lt;= 0 ){ 
            size = 1;
          }
          if( size &gt;= N_FONT_SIZE ){
            size = N_FONT_SIZE - 1;
          }
          style.font = FontFamily(style.font) + size - 1;
        }
        z = HtmlMarkupArg(p,"color",0);
        if( z ){
          style.color = HtmlGetColorByName(htmlPtr, z);
        }
        PushStyleStack(htmlPtr, 
            p-&gt;base.type==Html_FONT ? Html_EndFONT : Html_EndBASEFONT, style);
        break;
      case Html_FORM: {
        char *zUrl;
        char *zMethod;
        Tcl_DString cmd;      /* -formcommand callback */
        int result;
        char zToken[50];

        htmlPtr-&gt;formStart = 0;
        p-&gt;form.id = 0;
        if( htmlPtr-&gt;zFormCommand==0 || htmlPtr-&gt;zFormCommand[0]==0 ){
          TestPoint(0);
          break;
        }
        zUrl = HtmlMarkupArg(p,"action",0);
        if( zUrl==0 ){
          TestPoint(0);
          break;
        }
        HtmlLock(htmlPtr);
        zUrl = HtmlResolveUri(htmlPtr, zUrl);
        if( HtmlUnlock(htmlPtr) ) return;
        if( zUrl==0 ) break;
        zMethod = HtmlMarkupArg(p,"method","GET");
        sprintf(zToken," %d form ", ++htmlPtr-&gt;nForm);
        Tcl_DStringInit(&amp;cmd);
        Tcl_DStringAppend(&amp;cmd, htmlPtr-&gt;zFormCommand, -1);
        Tcl_DStringAppend(&amp;cmd, zToken, -1);
        Tcl_DStringAppendElement(&amp;cmd, zUrl);
        HtmlFree(zUrl);
        Tcl_DStringAppendElement(&amp;cmd, zMethod);
        Tcl_DStringStartSublist(&amp;cmd);
        HtmlAppendArglist(&amp;cmd, p);
        Tcl_DStringEndSublist(&amp;cmd);
        HtmlLock(htmlPtr);
        result = Tcl_GlobalEval(htmlPtr-&gt;interp, Tcl_DStringValue(&amp;cmd));
        Tcl_DStringFree(&amp;cmd);
        if( HtmlUnlock(htmlPtr) ) return;
        if( result==TCL_OK ){
          htmlPtr-&gt;formStart = p;
          p-&gt;form.id = htmlPtr-&gt;nForm;
        }
        Tcl_ResetResult(htmlPtr-&gt;interp);
        break;
      }
      case Html_EndFORM:
        p-&gt;ref.pOther = htmlPtr-&gt;formStart;
        htmlPtr-&gt;formStart = 0;
        TestPoint(0);
        break;
      case Html_H1:
      case Html_H2:
      case Html_H3:
      case Html_H4:
      case Html_H5:
      case Html_H6:
        paraAlign = ALIGN_None;
        i = (p-&gt;base.type - Html_H1)/2 + 1;
        if( i&gt;=1 &amp;&amp; i&lt;=6 ){
          ScaleFont(&amp;style,header_sizes[i-1]);
        }
        style.font = BoldFont( FontSize(style.font) );
        style.align = GetAlignment(p, style.align);
        PushStyleStack(htmlPtr, Html_EndH1, style);
        break;
      case Html_EndH1:
      case Html_EndH2:
      case Html_EndH3:
      case Html_EndH4:
      case Html_EndH5:
      case Html_EndH6:
        paraAlign = ALIGN_None;
        style = HtmlPopStyleStack(htmlPtr, Html_EndH1);
        TestPoint(0);
        break;
      case Html_HR:
        nextStyle = style;
        style.align = GetAlignment(p, ALIGN_None);
        useNextStyle = 1;
        break;
      case Html_I:
        style.font = ItalicFont( FontSize(style.font) );
        PushStyleStack(htmlPtr, Html_EndI, style);
        TestPoint(0);
        break;
      case Html_IMG:
        HtmlLock(htmlPtr);
        p-&gt;image.pImage = HtmlGetImage(htmlPtr, p);
        if( HtmlUnlock(htmlPtr) ) return;
        TestPoint(0);
        break;
      case Html_INPUT:
        p-&gt;input.pForm = htmlPtr-&gt;formStart;
        TestPoint(0);
        break;
      case Html_KBD:
        style.font = CWFont( FontSize(style.font) );
        PushStyleStack(htmlPtr, Html_EndKBD, style);
        TestPoint(0);
        break;
      case Html_LI:
        if( htmlPtr-&gt;innerList ){
          p-&gt;li.type = htmlPtr-&gt;innerList-&gt;list.type;
          if( htmlPtr-&gt;innerList-&gt;base.type==Html_OL ){
            z = HtmlMarkupArg(p, "value", 0);
            if( z ){
              int n = atoi(z);
              if( n&gt;0 ){
                p-&gt;li.cnt = n;
                htmlPtr-&gt;innerList-&gt;list.cnt = n+1;
                TestPoint(0);
              }else{
                TestPoint(0);
              }
            }else{
              p-&gt;li.cnt = htmlPtr-&gt;innerList-&gt;list.cnt++;
              TestPoint(0);
            }
            p-&gt;li.type = GetOrderedListType(p,p-&gt;li.type);
          }else{
            p-&gt;li.type = GetUnorderedListType(p,p-&gt;li.type);
            TestPoint(0);
          }
        }else{
          p-&gt;base.flags &amp;= ~HTML_Visible;
          TestPoint(0);
        }
        break;
      case Html_MARQUEE:
        style.flags |= STY_Invisible;
        PushStyleStack(htmlPtr, Html_EndMARQUEE, style);
        TestPoint(0);
        break;
      case Html_NOBR:
        style.flags |= STY_NoBreak;
        PushStyleStack(htmlPtr, Html_EndNOBR, style);
        TestPoint(0);
        break;
      case Html_NOFRAME:
        if( htmlPtr-&gt;zFrameCommand &amp;&amp; *htmlPtr-&gt;zFrameCommand ){
          nextStyle = style;
          nextStyle.flags |= STY_Invisible;
          PushStyleStack(htmlPtr, Html_EndNOFRAME, nextStyle);
          useNextStyle = 1;
        }else{
          PushStyleStack(htmlPtr, Html_EndNOFRAME, style);
        }
        TestPoint(0);
        break;
      case Html_NOSCRIPT:
        if( htmlPtr-&gt;zScriptCommand &amp;&amp; *htmlPtr-&gt;zScriptCommand ){
          nextStyle = style;
          nextStyle.flags |= STY_Invisible;
          PushStyleStack(htmlPtr, Html_EndNOSCRIPT, nextStyle);
          useNextStyle = 1;
        }else{
          PushStyleStack(htmlPtr, Html_EndNOSCRIPT, style);
        }
        TestPoint(0);
        break;
      case Html_OL:
        p-&gt;list.pPrev = htmlPtr-&gt;innerList;
        p-&gt;list.type = GetOrderedListType(p,LI_TYPE_Enum_1);
        p-&gt;list.cnt = 1;
        z = HtmlMarkupArg(p,"start",0);
        if( z ){
          int n = atoi(z);
          if( n&gt;0 ){
            p-&gt;list.cnt = n;
            TestPoint(0);
          }else{
            TestPoint(0);
          }
        }else{
          TestPoint(0);
        }
        p-&gt;list.compact = htmlPtr-&gt;innerList!=0 || 
                          HtmlMarkupArg(p,"compact",0)!=0;
        htmlPtr-&gt;innerList = p;
        break;
      case Html_P:
        paraAlign = GetAlignment(p, ALIGN_None);
        TestPoint(0);
        break;
      case Html_EndP:
        paraAlign = ALIGN_None;
        TestPoint(0);
        break;
      case Html_PRE:
      case Html_LISTING:
      case Html_XMP:
      case Html_PLAINTEXT:
        paraAlign = ALIGN_None;
        style.font = CWFont( FontSize(style.font) );
        style.flags |= STY_Preformatted;
        PushStyleStack(htmlPtr, Html_EndPRE, style);
        TestPoint(0);
        break;
      case Html_EndPRE:
      case Html_EndLISTING:
      case Html_EndXMP:
        style = HtmlPopStyleStack(htmlPtr, Html_EndPRE);
        TestPoint(0);
        break;
      case Html_S:
        style.flags |= STY_StrikeThru;
        PushStyleStack(htmlPtr, Html_EndS, style);
        TestPoint(0);
        break;
      case Html_SCRIPT:
        if( htmlPtr-&gt;zScriptCommand &amp;&amp; *htmlPtr-&gt;zScriptCommand ){
          Tcl_DString cmd;
          int result;
          Tcl_DStringInit(&amp;cmd);
          Tcl_DStringAppend(&amp;cmd, htmlPtr-&gt;zScriptCommand, -1);
          Tcl_DStringStartSublist(&amp;cmd);
          HtmlAppendArglist(&amp;cmd, p);
          Tcl_DStringEndSublist(&amp;cmd);
          Tcl_DStringStartSublist(&amp;cmd);
          Tcl_DStringAppend(&amp;cmd, p-&gt;script.zScript, p-&gt;script.nScript);
          Tcl_DStringEndSublist(&amp;cmd);
          HtmlLock(htmlPtr);
          result = Tcl_GlobalEval(htmlPtr-&gt;interp, Tcl_DStringValue(&amp;cmd));
          Tcl_DStringFree(&amp;cmd);
          if( HtmlUnlock(htmlPtr) ) return;
          Tcl_ResetResult(htmlPtr-&gt;interp);
        }
        nextStyle = style;
        style.flags |= STY_Invisible;
        useNextStyle = 1;
        break;
      case Html_SELECT:
        p-&gt;input.pForm = htmlPtr-&gt;formStart;
        nextStyle.flags |= STY_Invisible;
        useNextStyle = 1;
        PushStyleStack(htmlPtr, Html_EndSELECT, style);
        htmlPtr-&gt;formElemStart = p;
        break;
      case Html_EndSELECT:
        style = HtmlPopStyleStack(htmlPtr, Html_EndSELECT);
        if( htmlPtr-&gt;formElemStart
        &amp;&amp; htmlPtr-&gt;formElemStart-&gt;base.type==Html_SELECT ){
          p-&gt;ref.pOther = htmlPtr-&gt;formElemStart;
          MakeInvisible(p-&gt;ref.pOther, p);
        }else{
          p-&gt;ref.pOther = 0;
        }
        htmlPtr-&gt;formElemStart = 0;
        break;
      case Html_STRIKE:
        style.flags |= STY_StrikeThru;
        PushStyleStack(htmlPtr, Html_EndSTRIKE, style);
        TestPoint(0);
        break;
      case Html_STYLE:
        /* Ignore style sheets */
        break;
      case Html_SAMP:
        style.font = CWFont( FontSize(style.font) );
        PushStyleStack(htmlPtr, Html_EndSAMP, style);
        TestPoint(0);
        break;
      case Html_SMALL:
        ScaleFont(&amp;style,-1);
        PushStyleStack(htmlPtr, Html_EndSMALL, style);
        TestPoint(0);
        break;
      case Html_STRONG:
        style.font = BoldFont( FontSize(style.font) );
        PushStyleStack(htmlPtr, Html_EndSTRONG, style);
        TestPoint(0);
        break;
      case Html_SUB:
        ScaleFont(&amp;style,-1);
        if( style.subscript &gt; -6 ){
          style.subscript--;
          TestPoint(0);
        }else{
          TestPoint(0);
        }
        PushStyleStack(htmlPtr, Html_EndSUB, style);
        break;
      case Html_SUP:
        ScaleFont(&amp;style,-1);
        if( style.subscript &lt; 6 ){
          style.subscript++;
          TestPoint(0);
        }else{
          TestPoint(0);
        }
        PushStyleStack(htmlPtr, Html_EndSUP, style);
        break;
      case Html_TABLE:
        paraAlign = ALIGN_None;
        nextStyle = style;
        nextStyle.align = ALIGN_Left;
        z = HtmlMarkupArg(p, "bgcolor", 0);
        if( z ){
          nextStyle.bgcolor = HtmlGetColorByName(htmlPtr, z);
          style.bgcolor = nextStyle.bgcolor;
/*        }else{
          nextStyle.bgcolor = COLOR_Background; */
        }
        PushStyleStack(htmlPtr, Html_EndTABLE, nextStyle);
        useNextStyle = 1;
        htmlPtr-&gt;inTd = 0;
        htmlPtr-&gt;inTr = 0;
        TestPoint(0);
        break;
      case Html_EndTABLE:
        paraAlign = ALIGN_None;
        if( htmlPtr-&gt;inTd ){
          style = HtmlPopStyleStack(htmlPtr, Html_EndTD);
          htmlPtr-&gt;inTd = 0;
        }
        if( htmlPtr-&gt;inTr ){
          style = HtmlPopStyleStack(htmlPtr, Html_EndTR);
          htmlPtr-&gt;inTr = 0;
        }
        style = HtmlPopStyleStack(htmlPtr, p-&gt;base.type);
        TestPoint(0);
        break;
      case Html_TD:
        if( htmlPtr-&gt;inTd ){
          style = HtmlPopStyleStack(htmlPtr, Html_EndTD);
        }
        htmlPtr-&gt;inTd = 1;
        paraAlign = GetAlignment(p, rowAlign);
        if( (z = HtmlMarkupArg(p, "bgcolor", 0))!=0 ){
          style.bgcolor = HtmlGetColorByName(htmlPtr, z);
        }
        PushStyleStack(htmlPtr, Html_EndTD, style);
        TestPoint(0);
        break;
      case Html_TEXTAREA:
        p-&gt;input.pForm = htmlPtr-&gt;formStart;
        nextStyle = style;
        nextStyle.flags |= STY_Invisible;
        PushStyleStack(htmlPtr, Html_EndTEXTAREA, nextStyle);
        htmlPtr-&gt;formElemStart = p;
        useNextStyle = 1;
        TestPoint(0);
        break;
      case Html_EndTEXTAREA:
        style = HtmlPopStyleStack(htmlPtr, Html_EndTEXTAREA);
        if( htmlPtr-&gt;formElemStart
        &amp;&amp; htmlPtr-&gt;formElemStart-&gt;base.type==Html_TEXTAREA ){
          p-&gt;ref.pOther = htmlPtr-&gt;formElemStart;
        }else{
          p-&gt;ref.pOther = 0;
        }
        htmlPtr-&gt;formElemStart = 0;
        break;
      case Html_TH:
        /* paraAlign = GetAlignment(p, rowAlign); */
        if( htmlPtr-&gt;inTd ){
          style = HtmlPopStyleStack(htmlPtr, Html_EndTD);
        }
        paraAlign = GetAlignment(p, ALIGN_Center);
        style.font = BoldFont( FontSize(style.font) );
        if( (z = HtmlMarkupArg(p, "bgcolor", 0))!=0 ){
          style.bgcolor = HtmlGetColorByName(htmlPtr, z);
        }
        PushStyleStack(htmlPtr, Html_EndTD, style);
        htmlPtr-&gt;inTd = 1;
        TestPoint(0);
        break;
      case Html_TR:
        if( htmlPtr-&gt;inTd ){
          style = HtmlPopStyleStack(htmlPtr, Html_EndTD);
          htmlPtr-&gt;inTd = 0;
        }
        if( htmlPtr-&gt;inTr ){
          style = HtmlPopStyleStack(htmlPtr, Html_EndTR);
        }
        rowAlign = GetAlignment(p, ALIGN_None);
        if( (z = HtmlMarkupArg(p, "bgcolor", 0))!=0 ){
          style.bgcolor = HtmlGetColorByName(htmlPtr, z);
        }
        PushStyleStack(htmlPtr, Html_EndTR, style);
        htmlPtr-&gt;inTr = 1;
        TestPoint(0);
        break;
      case Html_EndTR:
        if( htmlPtr-&gt;inTd ){
          style = HtmlPopStyleStack(htmlPtr, Html_EndTD);
          htmlPtr-&gt;inTd = 0;
        }
        style = HtmlPopStyleStack(htmlPtr, Html_EndTR);
        htmlPtr-&gt;inTr = 0;
        paraAlign = ALIGN_None;
        rowAlign = ALIGN_None;
        TestPoint(0);
        break;
      case Html_EndTD:
      case Html_EndTH:
        style = HtmlPopStyleStack(htmlPtr, Html_EndTD);
        htmlPtr-&gt;inTd = 0;
        paraAlign = ALIGN_None;
        rowAlign = ALIGN_None;
        TestPoint(0);
        break;
      case Html_TITLE:
        style.flags |= STY_Invisible;
        PushStyleStack(htmlPtr, Html_EndTITLE, style);
        TestPoint(0);
        break;
      case Html_TT:
        style.font = CWFont( FontSize(style.font) );
        PushStyleStack(htmlPtr, Html_EndTT, style);
        TestPoint(0);
        break;
      case Html_U:
        style.flags |= STY_Underline;
        PushStyleStack(htmlPtr, Html_EndU, style);
        break;
      case Html_VAR:
        style.font = ItalicFont( FontSize(style.font) );
        PushStyleStack(htmlPtr, Html_EndVAR, style);
        TestPoint(0);
        break;
      default:
        TestPoint(0);
        break;
    }
    p-&gt;base.style = style;
    p-&gt;base.style.flags |= anchorFlags | inDt;
    if( paraAlign!=ALIGN_None ){
      p-&gt;base.style.align = paraAlign;
    }
    if( useNextStyle ){
      style = nextStyle;
      useNextStyle = 0;
    }
    TRACE(HtmlTrace_Style,
      ("Style of 0x%08x font=%02d color=%02d bg=%02d "
       "align=%d flags=0x%04x token=%s\n",
      (int)p, p-&gt;base.style.font, p-&gt;base.style.color, p-&gt;base.style.bgcolor,
      p-&gt;base.style.align, p-&gt;base.style.flags, HtmlTokenName(p)));
    p = p-&gt;pNext;
  }

  /* Copy state information back into the htmlPtr structure for
  ** safe keeping. */
  htmlPtr-&gt;paraAlignment = paraAlign;
  htmlPtr-&gt;rowAlignment = rowAlign;
  htmlPtr-&gt;anchorFlags = anchorFlags;
  htmlPtr-&gt;inDt = inDt;
  htmlPtr-&gt;flags &amp;= ~STYLER_RUNNING;
}
</t>
<t tx="ekr.20041214071955.133">@ ** Compute the size of all elements in the widget. Assume that a ** style has already been assigned to all elements. ** ** Some of the elements might have already been sized. Refer to the ** htmlPtr-&gt;lastSized and only compute sizes for elements that follow ** this one. If htmlPtr-&gt;lastSized==0, then size everything. ** ** This routine only computes the sizes of individual elements. The ** size of aggregate elements (like tables) are computed separately. ** ** The HTML_Visible flag is also set on every element that results ** in ink on the page. ** ** This routine may invoke a callback procedure which could delete ** the HTML widget.
@c

void HtmlSizer(HtmlWidget *htmlPtr){
  HtmlElement *p;
  int iFont = -1;
  Tk_Font font;
  int spaceWidth = 0;
  Tk_FontMetrics fontMetrics;
  char *z;
  int stop = 0;

  if( htmlPtr-&gt;pFirst==0 ){ TestPoint(0); return; }
  if( htmlPtr-&gt;lastSized==0 ){
    p = htmlPtr-&gt;pFirst;
    TestPoint(0);
  }else{
    p = htmlPtr-&gt;lastSized-&gt;pNext;
    TestPoint(0);
  }
  for(; !stop &amp;&amp; p; p=p-&gt;pNext){
    if( p-&gt;base.style.flags &amp; STY_Invisible ){
      p-&gt;base.flags &amp;= ~HTML_Visible;
      TestPoint(0);
      continue;
    }
    if( iFont != p-&gt;base.style.font ){
      iFont = p-&gt;base.style.font;
      HtmlLock(htmlPtr);
      font = HtmlGetFont(htmlPtr, iFont);
      if( HtmlUnlock(htmlPtr) ) break;
      Tk_GetFontMetrics(font, &amp;fontMetrics);
      spaceWidth = 0;
    }
    switch( p-&gt;base.type ){
      case Html_Text:
        p-&gt;text.w = Tk_TextWidth(font, p-&gt;text.zText, p-&gt;base.count);
        p-&gt;base.flags |= HTML_Visible;
        p-&gt;text.descent = fontMetrics.descent;
        p-&gt;text.ascent = fontMetrics.ascent;
        if( spaceWidth==0 ){
          spaceWidth = Tk_TextWidth(font, " ", 1);
          TestPoint(0);
        }else{
          TestPoint(0);
        }
        p-&gt;text.spaceWidth = spaceWidth;
        break;
      case Html_Space:
        if( spaceWidth==0 ){
          spaceWidth = Tk_TextWidth(font, " ", 1);
        }
        p-&gt;space.w = spaceWidth;
        p-&gt;space.descent = fontMetrics.descent;
        p-&gt;space.ascent = fontMetrics.ascent;
        p-&gt;base.flags &amp;= ~HTML_Visible;
        break;
      case Html_TD:
      case Html_TH:
        z = HtmlMarkupArg(p, "rowspan","1");
        p-&gt;cell.rowspan = atoi(z);
        z = HtmlMarkupArg(p, "colspan","1");
        p-&gt;cell.colspan = atoi(z);
        p-&gt;base.flags |= HTML_Visible;
        TestPoint(0);
        break;
      case Html_LI:
        p-&gt;li.descent = fontMetrics.descent;
        p-&gt;li.ascent = fontMetrics.ascent;
        p-&gt;base.flags |= HTML_Visible;
        TestPoint(0);
        break;
      case Html_IMG:
        p-&gt;base.flags |= HTML_Visible;
        p-&gt;image.redrawNeeded = 0;
        p-&gt;image.textAscent = fontMetrics.ascent;
        p-&gt;image.textDescent = fontMetrics.descent;
        p-&gt;image.align = HtmlGetImageAlignment(p);
        if( p-&gt;image.pImage==0 ){
          p-&gt;image.ascent = fontMetrics.ascent;
          p-&gt;image.descent = fontMetrics.descent;
          p-&gt;image.zAlt = HtmlMarkupArg(p, "alt", "&lt;image&gt;");
          p-&gt;image.w = Tk_TextWidth(font, p-&gt;image.zAlt, strlen(p-&gt;image.zAlt));
        }else{
          int w, h;
          p-&gt;image.pNext = p-&gt;image.pImage-&gt;pList;
          p-&gt;image.pImage-&gt;pList = p;
          Tk_SizeOfImage(p-&gt;image.pImage-&gt;image, &amp;w, &amp;h);
          p-&gt;image.h = h;
          p-&gt;image.w = w;
          p-&gt;image.ascent = h/2;
          p-&gt;image.descent = h - p-&gt;image.ascent;
        }
        if( (z = HtmlMarkupArg(p, "width", 0))!=0 ){
          int w = atoi(z);
          if( w&gt;0 ) p-&gt;image.w = w;
        }
        if( (z = HtmlMarkupArg(p, "height", 0))!=0 ){
          int h = atoi(z);
          if( h&gt;0 ) p-&gt;image.h = h;
        }
        break;
      case Html_HR:
      case Html_TABLE:
        p-&gt;base.flags |= HTML_Visible;
        TestPoint(0);
        break;
      case Html_APPLET:
      case Html_EMBED:
      case Html_INPUT:
        p-&gt;input.textAscent = fontMetrics.ascent;
        p-&gt;input.textDescent = fontMetrics.descent;
        stop = HtmlControlSize(htmlPtr, p);
        break;
      case Html_SELECT:
      case Html_TEXTAREA:
        p-&gt;input.textAscent = fontMetrics.ascent;
        p-&gt;input.textDescent = fontMetrics.descent;
        break;
      case Html_EndSELECT:
      case Html_EndTEXTAREA:
        if( p-&gt;ref.pOther ){
          p-&gt;ref.pOther-&gt;input.pEnd = p;
          stop = HtmlControlSize(htmlPtr, p-&gt;ref.pOther);
        }
        break;
      default:
        p-&gt;base.flags &amp;= ~HTML_Visible;
        break;
    }
  }
  if( p ){
    htmlPtr-&gt;lastSized = p;
  }else{
    htmlPtr-&gt;lastSized = htmlPtr-&gt;pLast;
  }
}
</t>
<t tx="ekr.20041214071955.134">@ignore
@language c
static char const rcsid[] = "@(#) $Id: htmltable.c,v 1.37 2000/06/20 22:48:38 drh Exp $";
/* Routines for doing layout of HTML tables */
&lt;&lt; htmltable #includes &gt;&gt;
@others
</t>
<t tx="ekr.20041214071955.135">#include &lt;tk.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;math.h&gt;
#include "htmltable.h"
</t>
<t tx="ekr.20041214071955.136">@ ** Default values for various table style parameters
@c

#define DFLT_BORDER             0
#define DFLT_CELLSPACING_3D     5
#define DFLT_CELLSPACING_FLAT   0
#define DFLT_CELLPADDING        2
#define DFLT_HSPACE             0
#define DFLT_VSPACE             0

#if INTERFACE
/*
** Set parameter A to the maximum of A and B.
*/
#define SETMAX(A,B)  if( (A)&lt;(B) ){ (A) = (B); }
#define MAX(A,B)     ((A)&lt;(B)?(B):(A))
#endif

/*
** Return the appropriate cell spacing for the given table.
*/
static int CellSpacing(HtmlWidget *htmlPtr, HtmlElement *pTable){
  char *z;
  int relief;
  int cellSpacing;

  z = HtmlMarkupArg(pTable, "cellspacing", 0);
  if( z==0 ){
     relief = htmlPtr-&gt;tableRelief;
     if( relief==TK_RELIEF_RAISED || relief==TK_RELIEF_SUNKEN ){
       cellSpacing = DFLT_CELLSPACING_3D;
     }else{
       cellSpacing = DFLT_CELLSPACING_FLAT;
     }
  }else{
    cellSpacing = atoi(z);
  }
  return cellSpacing;
}
</t>
<t tx="ekr.20041214071955.137">@ Forward declaration
@c

static HtmlElement *MinMax(HtmlWidget*, HtmlElement *, int *, int *, int);

/* pStart points to a &lt;table&gt;.  Compute the number of columns, the
** minimum and maximum size for each column and the overall minimum
** and maximum size for this table and store these value in the
** pStart structure.  Return a pointer to the &lt;/table&gt; element, 
** or to NULL if there is no &lt;/table&gt;.
**
** The min and max size for column N (where the leftmost column has
** N==1) is pStart-&gt;minW[1] and pStart-&gt;maxW[1].  The pStart-&gt;minW[0]
** and pStart-&gt;maxW[0] entries contain the minimum and maximum widths
** of the whole table, including any cell padding, cell spacing,
** border width and "hspace".  The values of pStart-&gt;minW[I] for I&gt;=1
** do not contain any cell padding, cell spacing or border width.
** Only pStart-&gt;minW[0] contains these extra spaces.
**
** The back references from &lt;/table&gt;, &lt;/tr&gt;, &lt;/td&gt; and &lt;/th&gt; back to
** the &lt;table&gt; markup are also filled in.  And for each &lt;td&gt; and &lt;th&gt;
** markup, the pTable and pEnd fields are set to their proper values.
*/
static HtmlElement *TableDimensions(
  HtmlWidget *htmlPtr,               /* The HTML widget */
  HtmlElement *pStart,               /* The &lt;table&gt; markup */
  int lineWidth                      /* Total widget available to the table */
){
  HtmlElement *p;                    /* Element being processed */
  HtmlElement *pNext;                /* Next element to process */
  int iCol = 0;                      /* Current column number.  1..N */
  int iRow = 0;                      /* Current row number */
  int inRow = 0;                     /* True if in between &lt;TR&gt; and &lt;/TR&gt; */
  int i, j;                          /* Loop counters */
  int n;                             /* Number of columns */
  int minW, maxW, requestedW;        /* min, max, requested width for a cell */
  int noWrap;                        /* true for NOWRAP cells */
  int colspan;                       /* Column span for the current cell */
  int rowspan;                       /* Row span for the current cell */
  char *z;                           /* Value of a &lt;table&gt; parameter */
  int cellSpacing;                   /* Value of CELLSPACING parameter */
  int cellPadding;                   /* Value of CELLPADDING parameter */
  int tbw;                           /* Width of border around whole table */
  int cbw;                           /* Width of border around one cell */
  int hspace;                        /* Value of HSPACE parameter */
  int separation;                    /* Space between columns */
  int margin;                        /* Space between left margin and 1st col */
  int availWidth;                    /* Part of lineWidth still available */
  int maxTableWidth;                 /* Amount of lineWidth available to table*/
  int fromAbove[HTML_MAX_COLUMNS+1]; /* Cell above extends thru this row */
  int min0span[HTML_MAX_COLUMNS+1];  /* Min for colspan=0 cells */
  int max0span[HTML_MAX_COLUMNS+1];  /* Max for colspan=0 cells */
  int reqW[HTML_MAX_COLUMNS+1];      /* Requested width for each column */

  /* colMin[A][B] is the absolute minimum width of all columns between
  ** A+1 and B+1.  colMin[B][A] is the requested width of columns between
  ** A+1 and B+1.  This information is used to add in the constraints imposed
  ** by &lt;TD COLSPAN=N&gt; markup where N&gt;=2.
  */
  int colMin[HTML_MAX_COLUMNS+1][HTML_MAX_COLUMNS+1];
# define ColMin(A,B) colMin[(A)-1][(B)-1]
# define ColReq(A,B) colMin[(B)-1][(A)-1]
  
  if( pStart==0 || pStart-&gt;base.type!=Html_TABLE ){ 
    TestPoint(0); 
    return pStart;
  }
  TRACE_PUSH(HtmlTrace_Table1);
  TRACE(HtmlTrace_Table1, ("Starting TableDimensions..\n"));
  pStart-&gt;table.nCol = 0;
  pStart-&gt;table.nRow = 0;
  z = HtmlMarkupArg(pStart, "border", 0);
  if( z &amp;&amp; *z==0 ) z = "2";
  tbw = pStart-&gt;table.borderWidth = z ? atoi(z) : DFLT_BORDER;
  cbw = tbw&gt;0;
  z = HtmlMarkupArg(pStart, "cellpadding", 0);
  cellPadding = z ? atoi(z) : DFLT_CELLPADDING;
  cellSpacing = CellSpacing(htmlPtr, pStart);
#ifdef DEBUG
  /* The HtmlTrace_Table4 flag causes tables to be draw with borders
  ** of 2, cellPadding of 5 and cell spacing of 2.  This makes the
  ** table clearly visible.  Useful for debugging. */
  if( HtmlTraceMask &amp; HtmlTrace_Table4 ){
    tbw = pStart-&gt;table.borderWidth = 2;
    cbw = 1;
    cellPadding = 5;
    cellSpacing = 2;
    pStart-&gt;base.style.bgcolor = COLOR_Background;
  }
#endif
  separation = cellSpacing + 2*(cellPadding + cbw);
  margin = tbw + cellSpacing + cbw + cellPadding;
  z = HtmlMarkupArg(pStart, "hspace", 0);
  hspace = z ? atoi(z) : DFLT_HSPACE;

  for(p=pStart-&gt;pNext; p &amp;&amp; p-&gt;base.type!=Html_EndTABLE; p=pNext){
    pNext = p-&gt;pNext;
    switch( p-&gt;base.type ){
      case Html_EndTD:
      case Html_EndTH:
      case Html_EndTABLE:
        p-&gt;ref.pOther = pStart;
        TestPoint(0);
        break;
      case Html_EndTR:
        p-&gt;ref.pOther = pStart;
        inRow = 0;
        TestPoint(0);
        break;
      case Html_TR:
        p-&gt;ref.pOther = pStart;
        iRow++;
        pStart-&gt;table.nRow++;
        iCol = 0;
        inRow = 1;
        maxTableWidth = availWidth = lineWidth - 2*margin;
        TestPoint(0);
        break;
      case Html_CAPTION:
        while( p &amp;&amp; p-&gt;base.type!=Html_EndTABLE 
               &amp;&amp; p-&gt;base.type!=Html_EndCAPTION ){
          p = p-&gt;pNext;
          TestPoint(0);
        }
        break;
      case Html_TD:
      case Html_TH:
        if( !inRow ){
          /* If the &lt;TR&gt; markup is omitted, insert it. */
          HtmlElement *pNew = HtmlAlloc( sizeof(HtmlRef) );
          if( pNew==0 ) break;
          memset(pNew, 0, sizeof(HtmlRef));
          pNew-&gt;base = p-&gt;base;
          pNew-&gt;base.pNext = p;
          pNew-&gt;base.type = Html_TR;
          pNew-&gt;base.count = 0;
          p-&gt;base.pPrev-&gt;base.pNext = pNew;
          p-&gt;base.pPrev = pNew;
          pNext = pNew;
          break;
        }
        do{
          iCol++;
        }while( iCol &lt;= pStart-&gt;table.nCol &amp;&amp; fromAbove[iCol] &gt; iRow );
        p-&gt;cell.pTable = pStart;
        colspan = p-&gt;cell.colspan;
        if( colspan==0 ){
          colspan = 1;
        }
        if( iCol + colspan - 1 &gt; pStart-&gt;table.nCol ){
          int nCol = iCol + colspan - 1;
          if( nCol &gt; HTML_MAX_COLUMNS ){
            nCol = HTML_MAX_COLUMNS;
          }
          for(i=pStart-&gt;table.nCol+1; i&lt;=nCol; i++){
            fromAbove[i] = 0;
            pStart-&gt;table.minW[i] = 0;
            pStart-&gt;table.maxW[i] = 0;
            min0span[i] = 0;
            max0span[i] = 0;
            reqW[i] = 0;
            for(j=1; j&lt;i; j++){
              ColMin(j,i) = 0;
              ColReq(j,i) = 0;
            }
          }
          pStart-&gt;table.nCol = nCol;
        }
        noWrap = HtmlMarkupArg(p, "nowrap", 0)!=0;
        pNext = MinMax(htmlPtr, p, &amp;minW, &amp;maxW, availWidth);
        p-&gt;cell.pEnd = pNext;
        if( (z = HtmlMarkupArg(p, "width", 0))!=0 ){
          for(i=0; isdigit(z[i]); i++){}
          if( strcmp(z,"*")==0 ){
            requestedW = availWidth;
          }else if( z[i]==0 ){
            requestedW = atoi(z);
          }else if( z[i]=='%' ){
            /* requestedW = (atoi(z)*availWidth + 99)/100; */
            requestedW = (atoi(z)*maxTableWidth + 99)/100;
          }
        }else{
          requestedW = 0;
        }
        TRACE(HtmlTrace_Table1,
          ("Row %d Column %d: min=%d max=%d req=%d stop at %s\n",
            iRow,iCol,minW,maxW,requestedW, HtmlTokenName(p-&gt;cell.pEnd)));
        if( noWrap ){
          minW = maxW;
        }
        if( iCol + p-&gt;cell.colspan &lt;= HTML_MAX_COLUMNS ){
          int min = 0;
          if( p-&gt;cell.colspan==0 ){
            SETMAX( min0span[iCol], minW );
            SETMAX( max0span[iCol], maxW );
            min = min0span[iCol] + separation;
          }else if( colspan==1 ){
            SETMAX( pStart-&gt;table.minW[iCol], minW );
            SETMAX( pStart-&gt;table.maxW[iCol], maxW );
            SETMAX( reqW[iCol], requestedW );     
            min = pStart-&gt;table.minW[iCol] + separation;
          }else{
            int n = p-&gt;cell.colspan;
            SETMAX( ColMin(iCol,iCol+n-1), minW);
            SETMAX( ColReq(iCol,iCol+n-1), requestedW);
            min = minW + separation;
#if 0
            maxW = (maxW + (n - 1)*(1-separation))/n;
            for(i=iCol; i&lt;iCol + n &amp;&amp; i&lt;HTML_MAX_COLUMNS; i++){
              SETMAX( pStart-&gt;table.maxW[i], maxW );
            }
#endif
          }
          availWidth -= min;
        }
        rowspan = p-&gt;cell.rowspan;
        if( rowspan==0 ){
          rowspan = LARGE_NUMBER;
        }
        if( rowspan&gt;1 ){
          for(i=iCol; i&lt;iCol + p-&gt;cell.colspan &amp;&amp; i&lt;HTML_MAX_COLUMNS; i++){
            fromAbove[i] = iRow + rowspan;
          }
        }
        if( p-&gt;cell.colspan &gt; 1 ){
          iCol += p-&gt;cell.colspan - 1;
        }else if( p-&gt;cell.colspan==0 ){
          iCol = HTML_MAX_COLUMNS + 1;
        }
        break;
    }
  }

#ifdef DEBUG
  if( HtmlTraceMask &amp; HtmlTrace_Table6 ){
    char *zSpace = "";
    TRACE_INDENT;
    for(i=1; i&lt;=pStart-&gt;table.nCol; i++){
      printf("%s%d:%d..%d",zSpace,i,
         pStart-&gt;table.minW[i],pStart-&gt;table.maxW[i]);
      if( reqW[i]&gt;0 ){
        printf("(w=%d)",reqW[i]);
      }
      zSpace = "  ";
    }
    printf("\n");
    for(i=1; i&lt;pStart-&gt;table.nCol; i++){
      for(j=i+1; j&lt;=pStart-&gt;table.nCol; j++){
        if( ColMin(i,j)&gt;0 ){
          TRACE_INDENT;
          printf("ColMin(%d,%d) = %d\n", i, j, ColMin(i,j));
        }
        if( ColReq(i,j)&gt;0 ){
          TRACE_INDENT;
          printf("ColReq(%d,%d) = %d\n", i, j, ColReq(i,j));
        }
      } 
    }
  }
#endif

  /* Compute the min and max width of each column
  */
  for(i=1; i&lt;=pStart-&gt;table.nCol; i++){
    int sumMin, sumReq, sumMax;

    /* Reduce the max[] field to N for columns that have "width=N" */
    if( reqW[i]&gt;0 ){
      pStart-&gt;table.maxW[i] = MAX(pStart-&gt;table.minW[i],reqW[i]);
    }

    /* Expand the width of columns marked with "colspan=0". 
    */
    if( min0span[i]&gt;0 || max0span[i]&gt;0 ){
      int n = pStart-&gt;table.nCol - i + 1;
      minW = (min0span[i] + (n - 1)*(1-separation))/n;
      maxW = (max0span[i] + (n - 1)*(1-separation))/n;
      for(j=i; j&lt;=pStart-&gt;table.nCol; j++){
        SETMAX( pStart-&gt;table.minW[j], minW );
        SETMAX( pStart-&gt;table.maxW[j], maxW );
      }
    }

    /* Expand the minW[] of columns to accomodate "colspan=N" constraints.
    ** The minW[] is expanded up to the maxW[] first.  Then all the maxW[]s
    ** are expanded in proportion to their sizes.  The same thing occurs
    ** for reqW[]s.
    */
    sumReq = reqW[i];
    sumMin = pStart-&gt;table.minW[i];
    sumMax = pStart-&gt;table.maxW[i];
    for(j=i-1; j&gt;=1; j--){
      int cmin, creq;
      sumMin += pStart-&gt;table.minW[j];
      sumMax += pStart-&gt;table.maxW[j];
      sumReq += reqW[i];
      cmin = ColMin(j,i);
      if( cmin&gt;sumMin ){
        int k;
        double scale;
        int *tminW = pStart-&gt;table.minW;
        int *tmaxW = pStart-&gt;table.maxW;
        if( sumMin&lt;sumMax ){
          scale = (double)(cmin - sumMin)/(double)(sumMax - sumMin);
          for(k=j; k&lt;=i; k++){
            sumMin -= tminW[k];
            tminW[k] = (tmaxW[k] - tminW[k])*scale + tminW[k];
            sumMin += tminW[k];
          }
        }else if( sumMin&gt;0 ){
          scale = (double)cmin/(double)sumMin;
          for(k=j; k&lt;=i; k++){
            sumMin -= tminW[k];
            tminW[k] = tmaxW[k] = tminW[k]*scale;
            sumMin += tminW[k];
          }
        }else{
          int unit = cmin/(i-j+1);
          for(k=j; k&lt;=i; k++){
            tminW[k] = tmaxW[k] = unit;
            sumMin += tminW[k];
          }
        }
      }
      creq = ColReq(j,i);
      if( creq&gt;sumReq ){
        int k;
        double scale;
        int *tmaxW = pStart-&gt;table.maxW;
        if( sumReq&lt;sumMax ){
          scale = (double)(creq - sumReq)/(double)(sumMax - sumReq);
          for(k=j; k&lt;=i; k++){
            sumReq -= reqW[k];
            reqW[k] = (tmaxW[k] - reqW[k])*scale + reqW[k];
            sumReq += reqW[k];
          }
        }else if( sumReq&gt;0 ){
          scale = (double)creq/(double)sumReq;
          for(k=j; k&lt;=i; k++){
            sumReq -= reqW[k];
            reqW[k] = reqW[k]*scale;
            sumReq += reqW[k];
          }
        }else{
          int unit = creq/(i-j+1);
          for(k=j; k&lt;=i; k++){
            reqW[k] = unit;
            sumReq += reqW[k];
          }
        }
      }
    }
  }

#ifdef DEBUG
  if( HtmlTraceMask &amp; HtmlTrace_Table6 ){
    char *zSpace = "";
    TRACE_INDENT;
    for(i=1; i&lt;=pStart-&gt;table.nCol; i++){
      printf("%s%d:%d..%d",zSpace,i,
         pStart-&gt;table.minW[i],pStart-&gt;table.maxW[i]);
      if( reqW[i]&gt;0 ){
        printf("(w=%d)",reqW[i]);
      }
      zSpace = "  ";
    }
    printf("\n");
  }
#endif

  /* Compute the min and max width of the whole table
  */
  n = pStart-&gt;table.nCol;
  requestedW = tbw*2 + (n+1)*cellSpacing + n*2*(cellPadding + cbw);
  pStart-&gt;table.minW[0] = requestedW;
  pStart-&gt;table.maxW[0] = requestedW;
  for(i=1; i&lt;=pStart-&gt;table.nCol; i++){
    pStart-&gt;table.minW[0] += pStart-&gt;table.minW[i];
    pStart-&gt;table.maxW[0] += pStart-&gt;table.maxW[i];
    requestedW += MAX(reqW[i], pStart-&gt;table.minW[i]);
  }

  /* Figure out how wide to draw the table */
  z = HtmlMarkupArg(pStart, "width", 0);
  if( z ){
    int len = strlen(z);
    int totalWidth;
    if( len&gt;0 &amp;&amp; z[len-1]=='%' ){
      totalWidth = (atoi(z) * lineWidth)/100;
    }else{
      totalWidth = atoi(z);
    }
    SETMAX( requestedW, totalWidth );
  }
  if( lineWidth &amp;&amp; (requestedW &gt; lineWidth) ){
    TRACE(HtmlTrace_Table5,("RequestedW reduced to lineWidth: %d -&gt; %d\n", 
       requestedW, lineWidth));
    requestedW = lineWidth;
  }
  if( requestedW &gt; pStart-&gt;table.minW[0] ){
    float scale;
    int *tminW = pStart-&gt;table.minW;
    int *tmaxW = pStart-&gt;table.maxW;
    TRACE(HtmlTrace_Table5,
        ("Expanding table minW from %d to %d.  (reqW=%d width=%s)\n",
          tminW[0], requestedW, requestedW, z));
    if( tmaxW[0] &gt; tminW[0] ){
      scale = (double)(requestedW - tminW[0]) / (double)(tmaxW[0] - tminW[0]);
      for(i=1; i&lt;=pStart-&gt;table.nCol; i++){
        tminW[i] += (tmaxW[i] - tminW[i]) * scale;
        SETMAX(tmaxW[i], tminW[i]);
      }
    }else if( tminW[0]&gt;0 ){
      scale = requestedW/(double)tminW[0];
      for(i=1; i&lt;=pStart-&gt;table.nCol; i++){
        tminW[i] *= scale;
        tmaxW[i] *= scale;
      }
    }else if( pStart-&gt;table.nCol&gt;0 ){
      int unit = (requestedW - margin)/pStart-&gt;table.nCol - separation;
      if( unit&lt;0 ) unit = 0;
      for(i=1; i&lt;=pStart-&gt;table.nCol; i++){
        tminW[i] = tmaxW[i] = unit;
      }
    }else{
      tminW[0] = tmaxW[0] = requestedW;
    }
    pStart-&gt;table.minW[0] = requestedW;
    SETMAX( pStart-&gt;table.maxW[0], requestedW );
  }

#ifdef DEBUG
  if( HtmlTraceMask &amp; HtmlTrace_Table5 ){
    TRACE_INDENT;
    printf("Start with %s and ", HtmlTokenName(pStart));
    printf("end with %s\n", HtmlTokenName(p));
    TRACE_INDENT;
    printf("nCol=%d minWidth=%d maxWidth=%d\n",
      pStart-&gt;table.nCol, pStart-&gt;table.minW[0], pStart-&gt;table.maxW[0]);
    for(i=1; i&lt;=pStart-&gt;table.nCol; i++){
      TRACE_INDENT;
      printf("Column %d minWidth=%d maxWidth=%d\n",
         i, pStart-&gt;table.minW[i], pStart-&gt;table.maxW[i]);
    }
  }
#endif

  TRACE(HtmlTrace_Table1,
     ("Result of TableDimensions: min=%d max=%d nCol=%d\n",
     pStart-&gt;table.minW[0], pStart-&gt;table.maxW[0], pStart-&gt;table.nCol));
  TRACE_POP(HtmlTrace_Table1);
  return p;
}
</t>
<t tx="ekr.20041214071955.138">@ ** Given a list of elements, compute the minimum and maximum width needed ** to render the list. Stop the search at the first element seen that is ** in the following set: ** **    &lt;tr&gt; &lt;td&gt; &lt;th&gt; &lt;/tr&gt; &lt;/td&gt; &lt;/th&gt; &lt;/table&gt; ** ** Return a pointer to the element that stopped the search, or to NULL ** if we ran out of data. ** ** Sometimes the value returned for both min and max will be larger than ** the true minimum and maximum. This is rare, and only occurs if the ** element string contains figures with flow-around text.
@c

static HtmlElement *MinMax(
  HtmlWidget *htmlPtr,     /* The Html widget */
  HtmlElement *p,          /* Start the search here */
  int *pMin,               /* Return the minimum width here */
  int *pMax,               /* Return the maximum width here */
  int lineWidth            /* Total width available */
){
  int min = 0;             /* Minimum width so far */
  int max = 0;             /* Maximum width so far */
  int indent = 0;          /* Amount of indentation (minimum) */
  int obstacle = 0;        /* Possible obstacles in the margin */
  int x1 = 0;              /* Length of current line assuming maximum length */
  int x2 = 0;              /* Length of current line assuming minimum length */
  int go = 1;              /* Change to 0 to stop the loop */
  HtmlElement *pNext;      /* Next element in the list */

  for(p=p-&gt;pNext; go &amp;&amp; p; p = pNext){
    pNext = p-&gt;pNext;
    switch( p-&gt;base.type ){
      case Html_Text:
        x1 += p-&gt;text.w;
        x2 += p-&gt;text.w;
        if( p-&gt;base.style.flags &amp; STY_Preformatted ){
          SETMAX( min, x1 );
          SETMAX( max, x1 );
        }else{
          SETMAX( min, x2 );
          SETMAX( max, x1 );
        }
        break;
      case Html_Space:
        if( p-&gt;base.style.flags &amp; STY_Preformatted ){
          if( p-&gt;base.flags &amp; HTML_NewLine ){
            x1 = x2 = indent;
          }else{
            x1 += p-&gt;space.w * p-&gt;base.count;
            x2 += p-&gt;space.w * p-&gt;base.count;
          }
        }else if( p-&gt;base.style.flags &amp; STY_NoBreak ){
          if( x1&gt;indent ){ x1 += p-&gt;space.w; TestPoint(0);}
          if( x2&gt;indent ){ x2 += p-&gt;space.w; TestPoint(0);}
        }else{
          if( x1&gt;indent ){ x1 += p-&gt;space.w; TestPoint(0);}
          x2 = indent;
        }
        break;
      case Html_IMG:
        switch( p-&gt;image.align ){
          case IMAGE_ALIGN_Left:
          case IMAGE_ALIGN_Right:
            obstacle += p-&gt;image.w;
            x1 = obstacle + indent;
            x2 = indent;
            SETMAX( min, x2 );
            SETMAX( min, p-&gt;image.w );
            SETMAX( max, x1 );
            break;
          default:
            x1 += p-&gt;image.w;
            x2 += p-&gt;image.w;
            if( p-&gt;base.style.flags &amp; STY_Preformatted ){
              SETMAX( min, x1 );
              SETMAX( max, x1 );
            }else{
              SETMAX( min, x2 );
              SETMAX( max, x1 );
            }
            break;
        }
        break;
      case Html_TABLE:
        /* pNext = TableDimensions(htmlPtr, p, lineWidth-indent); */
        pNext = TableDimensions(htmlPtr, p, 0);
        x1 = p-&gt;table.maxW[0] + indent + obstacle;
        x2 = p-&gt;table.minW[0] + indent;
        SETMAX( max, x1 );
        SETMAX( min, x2 );	
        x1 = indent + obstacle;
        x2 = indent;
        if( pNext &amp;&amp; pNext-&gt;base.type==Html_EndTABLE ){
          pNext = pNext-&gt;pNext;
        }
        break;
      case Html_UL:
      case Html_OL:
        indent += HTML_INDENT;
        x1 = indent + obstacle;
        x2 = indent;
        break;
      case Html_EndUL:
      case Html_EndOL:
        indent -= HTML_INDENT;
        if( indent &lt; 0 ){ indent = 0; }
        x1 = indent + obstacle;
        x2 = indent;
        break;
      case Html_BLOCKQUOTE:
        indent += 2*HTML_INDENT;
        x1 = indent + obstacle;
        x2 = indent;
        break;
      case Html_EndBLOCKQUOTE:
        indent -= 2*HTML_INDENT;
        if( indent &lt; 0 ){ indent = 0; }
        x1 = indent + obstacle;
        x2 = indent;
        break;
      case Html_APPLET:
      case Html_INPUT:
      case Html_SELECT:
      case Html_EMBED:
      case Html_TEXTAREA:
        x1 += p-&gt;input.w + p-&gt;input.padLeft;
        if( p-&gt;base.style.flags &amp; STY_Preformatted ){
          SETMAX( min, x1 );
          SETMAX( max, x1 );
          x2 += p-&gt;input.w + p-&gt;input.padLeft;
        }else{
          SETMAX( min, indent + p-&gt;input.w );
          SETMAX( max, x1 );
          x2 = indent;
        }
        break;
      case Html_BR:
      case Html_P:
      case Html_EndP:
      case Html_DIV:
      case Html_EndDIV:
      case Html_H1:
      case Html_EndH1:
      case Html_H2:
      case Html_EndH2:
      case Html_H3:
      case Html_EndH3:
      case Html_H4:
      case Html_EndH4:
      case Html_H5:
      case Html_H6:
        x1 = indent + obstacle;
        x2 = indent;
        break;
      case Html_EndTD:
      case Html_EndTH:
      case Html_CAPTION:
      case Html_EndTABLE:
      case Html_TD:
      case Html_TR:
      case Html_TH:
      case Html_EndTR:
        go = 0;
        break;
      default:
        break;
    }
    if( !go ){ break; }
  }
  *pMin = min;
  *pMax = max;
  return p;
}
</t>
<t tx="ekr.20041214071955.139">@ Vertical alignments:
@c

#define VAlign_Unknown    0
#define VAlign_Top        1
#define VAlign_Bottom     2
#define VAlign_Center     3
#define VAlign_Baseline   4

/*
** Return the vertical alignment specified by the given element.
*/
static int GetVerticalAlignment(HtmlElement *p, int dflt){
  char *z;
  int rc;
  if( p==0 ) return dflt;
  z = HtmlMarkupArg(p, "valign", 0);
  if( z==0 ){
    rc = dflt;
    TestPoint(0);
  }else if( stricmp(z,"top")==0 ){
    rc = VAlign_Top;
    TestPoint(0);
  }else if( stricmp(z,"bottom")==0 ){
    rc = VAlign_Bottom;
    TestPoint(0);
  }else if( stricmp(z,"center")==0 ){
    rc = VAlign_Center;
    TestPoint(0);
  }else if( stricmp(z,"baseline")==0 ){
    rc = VAlign_Baseline;
    TestPoint(0);
  }else{
    rc = dflt;
    TestPoint(0);
  }
  return rc;
}
</t>
<t tx="ekr.20041214071955.140">@ Do all layout for a single table. Return the &lt;/table&gt; element or ** NULL if the table is unterminated.
@c

HtmlElement *HtmlTableLayout(
  HtmlLayoutContext *pLC,      /* The layout context */
  HtmlElement *pTable          /* The &lt;table&gt; element */
){
  HtmlElement *pEnd;      /* The &lt;/table&gt; element */
  HtmlElement *p;         /* For looping thru elements of the table */
  HtmlElement *pNext;     /* Next element in the loop */
  HtmlElement *pCaption;  /* Start of the caption text.  The &lt;caption&gt; */
  HtmlElement *pEndCaption; /* End of the caption.  The &lt;/caption&gt; */
  int width;              /* Width of the table as drawn */
  int cellSpacing;        /* Value of cellspacing= parameter to &lt;table&gt; */
  int cellPadding;        /* Value of cellpadding= parameter to &lt;table&gt; */
  int tbw;                /* Width of the 3D border around the whole table */
  int cbw;                /* Width of the 3D border around a cell */
  int pad;                /* cellPadding + borderwidth */
  char *z;                /* A string */
  int leftMargin;         /* The left edge of space available for drawing */
  int lineWidth;          /* Total horizontal space available for drawing */
  int separation;         /* Distance between content of columns (or rows) */
  int i;                  /* Loop counter */
  int n;                  /* Number of columns */
  int btm;                /* Bottom edge of previous row */
  int iRow;               /* Current row number */
  int iCol;               /* Current column number */
  int colspan;            /* Number of columns spanned by current cell */
  int vspace;             /* Value of the vspace= parameter to &lt;table&gt; */
  int hspace;             /* Value of the hspace= parameter to &lt;table&gt; */
  int rowBottom;          /* Bottom edge of content in the current row */
  int defaultVAlign;      /* Default vertical alignment for the current row */
  char *zAlign;           /* Value of the ALIGN= attribute of the &lt;TABLE&gt; */
#define N HTML_MAX_COLUMNS+1
  int y[N];               /* Top edge of each cell's content */
  int x[N];               /* Left edge of each cell's content */
  int w[N];               /* Width of each cell's content */
  int ymax[N];            /* Bottom edge of cell's content if valign=top */
  HtmlElement *apElem[N]; /* The &lt;td&gt; or &lt;th&gt; for each cell in a row */
  int firstRow[N];        /* First row on which a cell appears */
  int lastRow[N];         /* Row to which each cell span's */
  int valign[N];          /* Vertical alignment for each cell */
  HtmlLayoutContext savedContext;  /* Saved copy of the original pLC */
  HtmlLayoutContext cellContext;   /* Used to render a single cell */
#ifdef TABLE_TRIM_BLANK
	extern int HtmlLineWasBlank;
#endif /* TABLE_TRIM_BLANK */

  if( pTable==0 || pTable-&gt;base.type!=Html_TABLE ){ 
    TestPoint(0);
    return pTable;
  }
  TRACE_PUSH(HtmlTrace_Table2);
  TRACE(HtmlTrace_Table2, ("Starting TableLayout() at %s\n", 
                          HtmlTokenName(pTable)));

  /* Figure how much horizontal space is available for rendering 
  ** this table.  Store the answer in lineWidth.  leftMargin is
  ** the left-most X coordinate of the table.  btm stores the top-most
  ** Y coordinate.
  */
  HtmlComputeMargins(pLC, &amp;leftMargin, &amp;btm, &amp;lineWidth);
  TRACE(HtmlTrace_Table2, ("...btm=%d left=%d width=%d\n",
                           btm, leftMargin, lineWidth));

  /* figure out how much space the table wants for each column,
  ** and in total.. */
  pEnd = TableDimensions(pLC-&gt;htmlPtr, pTable, lineWidth);

  /* If we don't have enough horizontal space to accomodate the minimum table
  ** width, then try to move down past some obstruction (such as an
  ** &lt;IMG ALIGN=LEFT&gt;) to give us more room.
  */
  if( lineWidth &lt; pTable-&gt;table.minW[0] ){
    HtmlWidenLine(pLC, pTable-&gt;table.minW[0], &amp;leftMargin, &amp;btm, &amp;lineWidth);
    TRACE(HtmlTrace_Table2, ("Widen to btm=%d left=%d width=%d\n", 
                             btm, leftMargin, lineWidth));
  }
  savedContext = *pLC;
  
  /* Figure out how wide to draw the table 
  */
  if( lineWidth &lt; pTable-&gt;table.minW[0] ){
    width = pTable-&gt;table.minW[0];
  }else if( lineWidth &lt;= pTable-&gt;table.maxW[0] ){
    width = lineWidth;
  }else{
    width = pTable-&gt;table.maxW[0];
  }


  /* Compute the width and left edge position of every column in
  ** the table */
  z = HtmlMarkupArg(pTable, "cellpadding", 0);
  cellPadding = z ? atoi(z) : DFLT_CELLPADDING;
  cellSpacing = CellSpacing(pLC-&gt;htmlPtr, pTable);
  z = HtmlMarkupArg(pTable, "vspace", 0);
  vspace = z ? atoi(z) : DFLT_VSPACE;
  z = HtmlMarkupArg(pTable, "hspace", 0);
  hspace = z ? atoi(z) : DFLT_HSPACE;
#ifdef DEBUG
  if( HtmlTraceMask &amp; HtmlTrace_Table4 ){
    cellPadding = 5;
    cellSpacing = 2;
    if( vspace&lt;2 ) vspace = 2;
    if( hspace&lt;2 ) hspace = 2;
  }
#endif
  tbw = pTable-&gt;table.borderWidth;
  cbw = (tbw&gt;0);
  pad = cellPadding + cbw;
  separation = cellSpacing + 2*pad;
  x[1] = leftMargin + tbw + cellSpacing + pad;
  n = pTable-&gt;table.nCol;
  if( n&lt;=0 || pTable-&gt;table.maxW[0]&lt;=0 ){
    /* Abort if the table has no columns at all or if the total width
    ** of the table is zero or less. */
    return pEnd;
  }
  zAlign = HtmlMarkupArg(pTable, "align", "");
  if( width &lt; lineWidth ){
    int align = pTable-&gt;base.style.align;
    if( align==ALIGN_Right || stricmp(zAlign,"right")==0 ){
      x[1] += lineWidth - width;
    }else if( align==ALIGN_Center &amp;&amp; stricmp(zAlign,"left")!=0 ){
      x[1] += (lineWidth - width)/2;
    }
  }
  if( width==pTable-&gt;table.maxW[0] ){
    w[1] = pTable-&gt;table.maxW[1];
    for(i=2; i&lt;=n; i++){
      w[i] = pTable-&gt;table.maxW[i];
      x[i] = x[i-1] + w[i-1] + separation;
      TestPoint(0);
    }
  }else if( width &gt; pTable-&gt;table.maxW[0] ){
    int *tmaxW = pTable-&gt;table.maxW;
    double scale = ((double)width)/ (double)tmaxW[0];
    w[1] = tmaxW[1] * scale;
    for(i=2; i&lt;=n; i++){
      w[i] = tmaxW[i] * scale;
      x[i] = x[i-1] + w[i-1] + separation;
      TestPoint(0);
    }
  }else if( width &gt; pTable-&gt;table.minW[0] ){
    float scale;
    int *tminW = pTable-&gt;table.minW;
    int *tmaxW = pTable-&gt;table.maxW;
    scale = (double)(width - tminW[0]) / (double)(tmaxW[0] - tminW[0]);
    w[1] = tminW[1] + (tmaxW[1] - tminW[1]) * scale;
    for(i=2; i&lt;=n; i++){
      w[i] = tminW[i] + (tmaxW[i] - tminW[i]) * scale;
      x[i] = x[i-1] + w[i-1] + separation;
      TestPoint(0);
    }
  }else{
    w[1] = pTable-&gt;table.minW[1];
    for(i=2; i&lt;=n; i++){
      w[i] = pTable-&gt;table.minW[i];
      x[i] = x[i-1] + w[i-1] + separation;
      TestPoint(0);
    }
  }
  w[n] = width - ((x[n] - x[1]) + 2*(tbw + pad + cellSpacing));

  /* Add notation to the pTable structure so that we will know where
  ** to draw the outer box around the outside of the table.
  */
  btm += vspace;
  pTable-&gt;table.y = btm;
  pTable-&gt;table.x = x[1] - (tbw + cellSpacing + pad);
  pTable-&gt;table.w = width;
  SETMAX(pLC-&gt;maxX, pTable-&gt;table.x + pTable-&gt;table.w);
  btm += tbw + cellSpacing;

  /* Begin rendering rows of the table */
  for(i=1; i&lt;=n; i++){
    firstRow[i] = 0;
    lastRow[i] = 0;
    apElem[i] = 0;
  }
  p = pTable-&gt;pNext;
  rowBottom = btm;
  for(iRow=1; iRow&lt;=pTable-&gt;table.nRow; iRow++){
    TRACE(HtmlTrace_Table2, ("Row %d: btm=%d\n",iRow,btm));
    /* Find the start of the next row.  Keep an eye out for the caption
    ** while we search */
    while( p &amp;&amp; p-&gt;base.type!=Html_TR ){ 
      if( p-&gt;base.type==Html_CAPTION ){
        pCaption = p;
        while( p &amp;&amp; p!=pEnd &amp;&amp; p-&gt;base.type!=Html_EndCAPTION ){
          p = p-&gt;pNext;
        }
        pEndCaption = p;
      }
      TRACE(HtmlTrace_Table3, ("Skipping token %s\n", HtmlTokenName(p)));
      p = p-&gt;pNext; 
    }
    if( p==0 ){ TestPoint(0); break; }

    /* Record default vertical alignment flag for this row */
    defaultVAlign = GetVerticalAlignment(p, VAlign_Center);

    /* Find every new cell on this row */
    for(iCol=1; iCol&lt;=pTable-&gt;table.nCol &amp;&amp; iCol&lt;HTML_MAX_COLUMNS; iCol++){
      if( lastRow[iCol]&lt;iRow ) ymax[iCol] = 0;
    }
    iCol = 0;
    for(p=p-&gt;pNext; p &amp;&amp; p-&gt;base.type!=Html_TR &amp;&amp; p!=pEnd; p=pNext){
      pNext = p-&gt;pNext;
      TRACE(HtmlTrace_Table3, ("Processing token %s\n", HtmlTokenName(p)));
      switch( p-&gt;base.type ){
        case Html_TD:
        case Html_TH:
          /* Find the column number for this cell.  Be careful to skip
          ** columns which extend down to this row from prior rows */
          do{
            iCol++;
          }while( iCol &lt;= HTML_MAX_COLUMNS &amp;&amp; lastRow[iCol] &gt;= iRow );
          TRACE(HtmlTrace_Table2,
            ("Column %d: x=%d w=%d\n",iCol,x[iCol],w[iCol]));
          /* Process the new cell.  (Cells beyond the maximum number of
          ** cells are simply ignored.) */
          if( iCol &lt;= HTML_MAX_COLUMNS ){
            apElem[iCol] = p;
            pNext = p-&gt;cell.pEnd;
            if( p-&gt;cell.rowspan==0 ){
              lastRow[iCol] = pTable-&gt;table.nRow;
            }else{
              lastRow[iCol] = iRow + p-&gt;cell.rowspan - 1;
            }
            firstRow[iCol] = iRow;

            /* Set vertical alignment flag for this cell */
            valign[iCol] = GetVerticalAlignment(p, defaultVAlign);

            /* Render cell contents and record the height */
            y[iCol] = btm + pad;
            cellContext.htmlPtr = pLC-&gt;htmlPtr;
            cellContext.pStart = p-&gt;pNext;
            cellContext.pEnd = pNext;
            cellContext.headRoom = 0;
            cellContext.top = y[iCol];
            cellContext.bottom = y[iCol];
            cellContext.left = x[iCol];
            cellContext.right = 0;
            cellContext.pageWidth = x[iCol]+w[iCol];
            colspan = p-&gt;cell.colspan;
            if( colspan==0 ){
              for(i=iCol+1; i&lt;=pTable-&gt;table.nCol; i++){
                cellContext.pageWidth += w[i] + separation;
                lastRow[i] = lastRow[iCol];
              }
            }else if( colspan&gt;1 ){
              for(i=iCol+1; i&lt;iCol+colspan; i++){
                cellContext.pageWidth += w[i] + separation;
                lastRow[i] = lastRow[iCol];
              }
            }
            cellContext.maxX = 0;
            cellContext.maxY = 0;
            cellContext.leftMargin = 0;
            cellContext.rightMargin = 0;
            HtmlLock(cellContext.htmlPtr);
            HtmlLayoutBlock(&amp;cellContext);
            if( HtmlUnlock(cellContext.htmlPtr) ) return 0;
#ifdef TABLE_TRIM_BLANK
			/*
			 * Cancel any trailing vertical whitespace caused
			 * by break markup
			 */
			if (HtmlLineWasBlank)
				cellContext.maxY -= cellContext.headRoom;
#endif /* TABLE_TRIM_BLANK */
            ymax[iCol] = cellContext.maxY;
            SETMAX(ymax[iCol], y[iCol]);
            HtmlClearMarginStack(&amp;cellContext.leftMargin);
            HtmlClearMarginStack(&amp;cellContext.rightMargin);

            /* Set coordinates of the cell border */
            p-&gt;cell.x = x[iCol] - pad;
            p-&gt;cell.y = btm;
            p-&gt;cell.w = cellContext.pageWidth + 2*pad - x[iCol];
            TRACE(HtmlTrace_Table2,
              ("Column %d top=%d bottom=%d h=%d left=%d w=%d\n",
              iCol, y[iCol], ymax[iCol], ymax[iCol]-y[iCol], 
              p-&gt;cell.x, p-&gt;cell.w));

            /* Advance the column counter for cells spaning multiple columns */
            if( colspan &gt; 1 ){
              iCol += colspan - 1;
            }else if( colspan==0 ){
              iCol = HTML_MAX_COLUMNS + 1;
            }
          }
          break;

        case Html_CAPTION:
          /* Gotta remember where the caption is so we can render it
          ** at the end */
          pCaption = p;
          while( pNext &amp;&amp; pNext!=pEnd &amp;&amp; pNext-&gt;base.type!=Html_EndCAPTION ){
            pNext = pNext-&gt;pNext;
          }
          pEndCaption = pNext;
          break;
      }
    }

    /* Figure out how high to make this row. */
    for(iCol=1; iCol&lt;=pTable-&gt;table.nCol; iCol++){
      if( lastRow[iCol] == iRow || iRow==pTable-&gt;table.nRow ){
        SETMAX( rowBottom, ymax[iCol] );
      }
    }
    TRACE(HtmlTrace_Table2, ("Total row height: %d..%d -&gt; %d\n",
                             btm,rowBottom,rowBottom-btm));

    /* Position every cell whose bottom edge ends on this row */
    for(iCol=1; iCol&lt;=pTable-&gt;table.nCol; iCol++){
      int dy;    /* Extra space at top of cell used for vertical alignment */

      /* Skip any unused cells or cells that extend down thru 
      ** subsequent rows */
      if( apElem[iCol]==0 
      || (iRow!=pTable-&gt;table.nRow &amp;&amp; lastRow[iCol]&gt;iRow) ){  continue; }

      /* Align the contents of the cell vertically. */
      switch( valign[iCol] ){
        case VAlign_Unknown:
        case VAlign_Center:
          dy = (rowBottom - ymax[iCol])/2;
          break;
        case VAlign_Top:
        case VAlign_Baseline:
          dy = 0;
          break;
        case VAlign_Bottom:
          dy = rowBottom - ymax[iCol];
          break;
      }
      if( dy ){
        HtmlElement *pLast = apElem[iCol]-&gt;cell.pEnd;
        TRACE(HtmlTrace_Table3, ("Delta column %d by %d\n",iCol,dy));
        HtmlMoveVertically(apElem[iCol]-&gt;pNext, pLast, dy);
      }

      /* Record the height of the cell so that the border can be drawn */
      apElem[iCol]-&gt;cell.h = rowBottom + pad - apElem[iCol]-&gt;cell.y;
      apElem[iCol] = 0;
    }

    /* Update btm to the height of the row we just finished setting */
    btm = rowBottom + pad + cellSpacing;
  }

  btm += tbw;
  pTable-&gt;table.h = btm - pTable-&gt;table.y;
  SETMAX( pLC-&gt;maxY, btm );
  pLC-&gt;bottom = btm + vspace;

  /* Render the caption, if there is one */
  if( pCaption ){
  }

  /* Whenever we do any table layout, we need to recompute all the 
  ** HtmlBlocks.  The following statement forces this. */
  pLC-&gt;htmlPtr-&gt;firstBlock = pLC-&gt;htmlPtr-&gt;lastBlock = 0;

  /* Adjust the context for text that wraps around the table, if
  ** requested by an ALIGN=RIGHT or ALIGN=LEFT attribute.
  */
  if( stricmp(zAlign,"left")==0 ){
    savedContext.maxX = pLC-&gt;maxX;
    savedContext.maxY = pLC-&gt;maxY;
    *pLC = savedContext;
    HtmlPushMargin(&amp;pLC-&gt;leftMargin, pTable-&gt;table.w + 2, 
        pTable-&gt;table.y + pTable-&gt;table.h + 2, 0);
  }else if( stricmp(zAlign,"right")==0 ){
    savedContext.maxX = pLC-&gt;maxX;
    savedContext.maxY = pLC-&gt;maxY;
    *pLC = savedContext;
    HtmlPushMargin(&amp;pLC-&gt;rightMargin, pTable-&gt;table.w + 2, 
        pTable-&gt;table.y + pTable-&gt;table.h + 2, 0);
  }

  /* All done */
  TRACE(HtmlTrace_Table2, (
     "Done with TableLayout().  x=%d y=%d w=%d h=%d Return %s\n",
     pTable-&gt;table.x, pTable-&gt;table.y, pTable-&gt;table.w, pTable-&gt;table.h,
     HtmlTokenName(pEnd)));
  TRACE_POP(HtmlTrace_Table2);
  return pEnd;
}
</t>
<t tx="ekr.20041214071955.141">@ ** Move all elements in the given list vertically by the amount dy
@c

void HtmlMoveVertically(
  HtmlElement *p,         /* First element to move */
  HtmlElement *pLast,     /* Last element.  Do move this one */
  int dy                  /* Amount by which to move */
){
  if( dy==0 ){ TestPoint(0); return; }
  while( p &amp;&amp; p!=pLast ){
    switch( p-&gt;base.type ){
      case Html_A:
        p-&gt;anchor.y += dy;
        break;
      case Html_Text:
        p-&gt;text.y += dy;
        break;
      case Html_LI:
        p-&gt;li.y += dy;
        break;
      case Html_TD:
      case Html_TH:
        p-&gt;cell.y += dy;
        break;
      case Html_TABLE:
        p-&gt;table.y += dy;
        break;
      case Html_IMG:
        p-&gt;image.y += dy;
        break;
      case Html_INPUT:
      case Html_SELECT:
      case Html_APPLET:
      case Html_EMBED:
      case Html_TEXTAREA:
        p-&gt;input.y += dy;
        break;
      default:
        break;
    }
    p = p-&gt;pNext;
  }
}
</t>
<t tx="ekr.20041214071955.142">@ignore
@language c
static char const rcsid[] = "@(#) $Id: htmltest.c,v 1.9 2000/01/31 13:23:47 drh Exp $";
/* This file contains the TestPoint routines used for profiling and coverage analysis of the code.
*/

/*
** A macro named "TestPoint" is defined which increments a counter
** whenever it is encountered.  This is very efficient, and should
** not impact performance of the system.  For delivery, the macro
** can be nulled out by recompiling without the COVERAGE_TEST macro 
** defined.
**
** See also the "renumber.c" program which can be used
** to assign unique numbers to all of the TestPoint(0) macros.
*/

&lt;&lt; htmltest #includes &gt;&gt;
&lt;&lt; htmltest declarations &gt;&gt;

@others
</t>
<t tx="ekr.20041214071955.143">#include "tcl.h"
#include "htmltest.h"
</t>
<t tx="ekr.20041214071955.144">
#if INTERFACE

#if defined(COVERAGE_TEST)
# define TestPoint(X)      {extern int HtmlTPArray[]; HtmlTPArray[X]++;}
# define UNTESTED          HtmlTPUntested(__FILE__,__LINE__)
# define CANT_HAPPEN       HtmlTPCantHappen(__FILE__,__LINE__)
# define HtmlVerifyLock(H) if((H)-&gt;locked==0)HtmlTPCantHappen(__FILE__,__LINE__)
#else
# define TestPoint(X)
# define UNTESTED
# define CANT_HAPPEN
# define HtmlVerifyLock(H)
#endif

#endif /* INTERFACE */

/*
** The following global array keeps track of the number of visits to
** each testpoint.  The size of the array must be set manually to the
** be at least one greater than the largest TestPoint number.
*/
#if defined(COVERAGE_TEST)
int HtmlTPArray[2000];
#endif

/* Needed by the EslTestPointDump routine
*/
#include &lt;stdio.h&gt;

/*
** Recursion depth
*/
#if defined(DEBUG)
int HtmlDepth = 0;
</t>
<t tx="ekr.20041214071955.145">#endif
#if INTERFACE
#if defined(DEBUG)
#define HtmlPush HtmlDepth+=2
#define HtmlPop  HtmlDepth-=2
#else
#define HtmlPush
#define HtmlPop
#endif
#endif

/* This function is called to print the values of all elements of the
** TP_Array to the given file.  Values are printed in decimal, one per line.
*/
void HtmlTestPointDump(char *filename){
#if defined(COVERAGE_TEST)
  FILE *fp;

  fp = fopen(filename,"a");
  if( fp ){
    int i;
    for(i=0; i&lt;sizeof(HtmlTPArray)/sizeof(HtmlTPArray[0]); i++){
      if( HtmlTPArray[i]&gt;0 ){
        fprintf(fp,"%d %d\n",i,HtmlTPArray[i]);
      }
    }
  }
  fclose(fp);
#endif
}
</t>
<t tx="ekr.20041214071955.146">@ This function reports an error to stderr when code that is marked ** UNTESTED gets executed.
@c

void HtmlTPUntested(const char *zFile, int line){
#ifndef USE_TCL_STUBS
  fprintf(stderr,"Untested HTML Widget code executed in file %s line %d\n",
          zFile,line);
#endif
}
</t>
<t tx="ekr.20041214071955.147">@ This function reports an error to stderr when safety code that should ** never execute is called.
@c

void HtmlTPCantHappen(const char *zFile, int line){
#ifndef USE_TCL_STUBS
  fprintf(stderr,"Unplanned behavior in the HTML Widget in file %s line %d\n",
          zFile,line);
#endif
}
</t>
<t tx="ekr.20041214071955.148">@ignore
@language c
static char const rcsid[] = "@(#) $Id: htmlurl.c,v 1.18 2000/02/06 23:17:25 drh Exp $";
/* Routines for processing URLs. */
&lt;&lt; htmlurl #includes &gt;&gt;
&lt;&lt; htmlurl declarations &gt;&gt;
@others
</t>
<t tx="ekr.20041214071955.149">#include &lt;tk.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include "htmlurl.h"
</t>
<t tx="ekr.20041214071955.150">
#if LOCAL_INTERFACE
/*
** A parsed URI is held in an instance of the following structure.
** Each component is recorded in memory obtained from HtmlAlloc().
**
** The examples are from the URI 
**
**    http://192.168.1.1:8080/cgi-bin/printenv?name=xyzzy&amp;addr=none#frag
*/
struct HtmlUri {
  char *zScheme;             /* Ex: "http" */
  char *zAuthority;          /* Ex: "192.168.1.1:8080" */
  char *zPath;               /* Ex: "cgi-bin/printenv" */
  char *zQuery;              /* Ex: "name=xyzzy&amp;addr=none" */
  char *zFragment;           /* Ex: "frag" */
};
</t>
<t tx="ekr.20041214071955.151">#endif

/*
** Return the length of the next component of the URL in z[] given
** that the component starts at z[0].  The initial sequence of the
** component must be zInit[].  The component is terminated by any
** character in zTerm[].  The length returned is 0 if the component
** doesn't exist.  The length includes the zInit[] string, but not
** the termination character.
**
**        Component        zInit      zTerm
**        ----------       -------    -------
**        scheme           ""         ":/?#"
**        authority        "//"       "/?#"
**        path             "/"        "?#"
**        query            "?"        "#"
**        fragment         "#"        ""
*/
static int ComponentLength(const char *z, const char *zInit, const char *zTerm){
  int i, n;
  for(n=0; zInit[n]; n++){
    if( zInit[n]!=z[n] ) return 0;
  }
  while( z[n] ){
    for(i=0; zTerm[i]; i++){
      if( z[n]==zTerm[i] ) return n;
    }
    n++;
  }
  return n;
}
</t>
<t tx="ekr.20041214071955.152">@ ** Duplicate a string of length n.
@c

static char *StrNDup(const char *z, int n){
  char *zResult;
  if( n&lt;=0 ){
    n = strlen(z);
  }
  zResult = HtmlAlloc( n + 1 );
  if( zResult ){
    memcpy(zResult, z, n);
    zResult[n] = 0;
    TestPoint(0);
  }
  return zResult;
}
</t>
<t tx="ekr.20041214071955.153">@ ** Parse a text URI into an HtmlUri structure.
@c

static HtmlUri *ParseUri(const char *zUri){
  HtmlUri *p;
  int n;

  p = HtmlAlloc( sizeof(*p) );
  if( p==0 ) return 0;
  memset(p, 0, sizeof(*p));
  if( zUri==0 || zUri[0]==0 ) return p;
  while( isspace(zUri[0]) ){ zUri++; }
  n = ComponentLength(zUri, "", ":/?# ");
  if( n&gt;0 &amp;&amp; zUri[n]==':' ){
    p-&gt;zScheme = StrNDup(zUri, n);
    zUri += n+1;
  }
  n = ComponentLength(zUri, "//", "/?# ");
  if( n&gt;0 ){
    p-&gt;zAuthority = StrNDup(&amp;zUri[2], n-2);
    zUri += n;
  }
  n = ComponentLength(zUri, "", "?# ");
  if( n&gt;0 ){
    p-&gt;zPath = StrNDup(zUri, n);
    zUri += n;
  }
  n = ComponentLength(zUri, "?", "# ");
  if( n&gt;0 ){
    p-&gt;zQuery = StrNDup(&amp;zUri[1], n-1);
    zUri += n;
  }
  n = ComponentLength(zUri, "#", " ");
  if( n&gt;0 ){
    p-&gt;zFragment = StrNDup(&amp;zUri[1], n-1);
  }
  return p;
}
</t>
<t tx="ekr.20041214071955.154">@ ** Delete an HtmlUri structure.
@c

static void FreeUri(HtmlUri *p){
  if( p==0 ) return;
  if( p-&gt;zScheme )    HtmlFree(p-&gt;zScheme);
  if( p-&gt;zAuthority ) HtmlFree(p-&gt;zAuthority);
  if( p-&gt;zPath )      HtmlFree(p-&gt;zPath);
  if( p-&gt;zQuery )     HtmlFree(p-&gt;zQuery);
  if( p-&gt;zFragment )  HtmlFree(p-&gt;zFragment);
  HtmlFree(p);
}
</t>
<t tx="ekr.20041214071955.155">@ ** Create a string to hold the given URI. Memory to hold the string ** is obtained from HtmlAlloc() and must be freed by the calling ** function.
@c

static char *BuildUri(HtmlUri *p){
  int n = 1;
  char *z;
  if( p-&gt;zScheme )    n += strlen(p-&gt;zScheme)+1;
  if( p-&gt;zAuthority ) n += strlen(p-&gt;zAuthority)+2;
  if( p-&gt;zPath )      n += strlen(p-&gt;zPath)+1;
  if( p-&gt;zQuery )     n += strlen(p-&gt;zQuery)+1;
  if( p-&gt;zFragment )  n += strlen(p-&gt;zFragment)+1;
  z = HtmlAlloc( n );
  if( z==0 ) return 0;
  n = 0;
  if( p-&gt;zScheme ){
    sprintf(z, "%s:", p-&gt;zScheme);
    n = strlen(z);
  }
  if( p-&gt;zAuthority ){
    sprintf(&amp;z[n], "//%s", p-&gt;zAuthority);
    n += strlen(&amp;z[n]);
  }
  if( p-&gt;zPath ){
    sprintf(&amp;z[n], "%s", p-&gt;zPath);
    n += strlen(&amp;z[n]);
  }
  if( p-&gt;zQuery ){
    sprintf(&amp;z[n], "?%s", p-&gt;zQuery);
    n += strlen(&amp;z[n]);
  }
  if( p-&gt;zFragment ){
    sprintf(&amp;z[n], "#%s", p-&gt;zFragment);
  }else{
    z[n] = 0;
  }
  return z;
}
</t>
<t tx="ekr.20041214071955.156">@ ** Replace the string in *pzDest with the string in zSrc
@c

static void ReplaceStr(char **pzDest, const char *zSrc){
  if( *pzDest!=0 ) HtmlFree(*pzDest);
  if( zSrc==0 ){
    *pzDest = 0;
  }else{
    *pzDest = StrNDup(zSrc, -1);
  }
}
</t>
<t tx="ekr.20041214071955.157">@ ** Remove leading and trailing spaces from the given string. Return ** a new string obtained from HtmlAlloc().
@c

static char *Trim(char *z){
  int i;
  char *zNew;
  while( isspace(*z) ) z++;
  i = strlen(z);
  zNew = HtmlAlloc( i+1 );
  if( zNew==0 ) return 0;
  strcpy(zNew, z);
  if( i&gt;0 &amp;&amp; isspace(zNew[i-1]) ){
    i--;
    zNew[i] = 0;
  }
  return zNew;
}
</t>
<t tx="ekr.20041214071955.158">@ ** The input azSeries[] is a sequence of URIs. This command must ** resolve them all and put the result in the interp-&gt;result field ** of the interpreter associated with the HTML widget. Return ** TCL_OK on success and TCL_ERROR if there is a failure. ** ** This function can cause the HTML widget to be deleted or changed ** arbitrarily.
@c

int HtmlCallResolver(
  HtmlWidget *htmlPtr,      /* The widget that is doing the resolving. */
  char **azSeries           /* A list of URIs.  NULL terminated */
){
  int rc = TCL_OK;          /* Return value of this function. */
  char *z;

  HtmlVerifyLock(htmlPtr);
  if( htmlPtr-&gt;zResolverCommand &amp;&amp; htmlPtr-&gt;zResolverCommand[0] ){
    /*
    ** Append the current base URI then the azSeries arguments to the
    ** TCL command specified by the -resolvercommand optoin, then execute
    ** the result.
    **
    ** The -resolvercommand could do nasty things, such as delete
    ** the HTML widget out from under us.  Be prepared for the worst.
    */
    Tcl_DString cmd;
    Tcl_DStringInit(&amp;cmd);
    Tcl_DStringAppend(&amp;cmd, htmlPtr-&gt;zResolverCommand, -1);
    if( htmlPtr-&gt;zBaseHref &amp;&amp; htmlPtr-&gt;zBaseHref[0] ){
      z = Trim(htmlPtr-&gt;zBaseHref);
    }else if( htmlPtr-&gt;zBase &amp;&amp; htmlPtr-&gt;zBase[0] ){
      z = Trim(htmlPtr-&gt;zBase);
    }
    if( z ){
      Tcl_DStringAppendElement(&amp;cmd, z);
      HtmlFree(z);
    }
    while( azSeries[0] ){
      z = Trim(azSeries[0]);
      if( z ){
        Tcl_DStringAppendElement(&amp;cmd, z);
        HtmlFree(z);
      }
      azSeries++;
    }
    HtmlLock(htmlPtr);
    rc = Tcl_GlobalEval(htmlPtr-&gt;interp, Tcl_DStringValue(&amp;cmd));
    Tcl_DStringFree(&amp;cmd);
    if( HtmlUnlock(htmlPtr) ) return TCL_ERROR;
    if( rc!=TCL_OK ){
      Tcl_AddErrorInfo(htmlPtr-&gt;interp,
         "\n    (-resolvercommand executed by HTML widget)");
    }
  }else{
    /*
    ** No -resolvercommand has been specified.  Do the default
    ** resolver algorithm specified in section 5.2 of RFC 2396.
    */
    HtmlUri *base, *term;
    if( htmlPtr-&gt;zBaseHref &amp;&amp; htmlPtr-&gt;zBaseHref[0] ){
      base = ParseUri(htmlPtr-&gt;zBaseHref);
    }else{
      base = ParseUri(htmlPtr-&gt;zBase);
    }
    while( azSeries[0] ){
      term = ParseUri(azSeries[0]);
      azSeries++;
      if( term-&gt;zScheme==0 &amp;&amp; term-&gt;zAuthority==0 &amp;&amp; term-&gt;zPath==0
          &amp;&amp; term-&gt;zQuery==0 &amp;&amp; term-&gt;zFragment ){
        ReplaceStr(&amp;base-&gt;zFragment, term-&gt;zFragment);
      }else if( term-&gt;zScheme ){
        HtmlUri temp;
        temp = *term;
        *term = *base;
        *base = temp;
      }else if( term-&gt;zAuthority ){
        ReplaceStr(&amp;base-&gt;zAuthority, term-&gt;zAuthority);
        ReplaceStr(&amp;base-&gt;zPath, term-&gt;zPath);
        ReplaceStr(&amp;base-&gt;zQuery, term-&gt;zQuery);
        ReplaceStr(&amp;base-&gt;zFragment, term-&gt;zFragment);
      }else if( term-&gt;zPath &amp;&amp; (term-&gt;zPath[0]=='/' || base-&gt;zPath==0) ){
        ReplaceStr(&amp;base-&gt;zPath, term-&gt;zPath);
        ReplaceStr(&amp;base-&gt;zQuery, term-&gt;zQuery);
        ReplaceStr(&amp;base-&gt;zFragment, term-&gt;zFragment);
      }else if( term-&gt;zPath &amp;&amp; base-&gt;zPath ){
        char *zBuf;
        int i, j;
        zBuf = HtmlAlloc( strlen(base-&gt;zPath) + strlen(term-&gt;zPath) + 2 );
        if( zBuf ){
          sprintf(zBuf,"%s", base-&gt;zPath);
          for(i=strlen(zBuf)-1; i&gt;=0 &amp;&amp; zBuf[i]!='/'; i--){ zBuf[i] = 0; }
          strcat(zBuf, term-&gt;zPath);
          for(i=0; zBuf[i]; i++){
            if( zBuf[i]=='/' &amp;&amp; zBuf[i+1]=='.' &amp;&amp; zBuf[i+2]=='/' ){
              strcpy(&amp;zBuf[i+1], &amp;zBuf[i+3]);
              i--;
              continue;
            }
            if( zBuf[i]=='/' &amp;&amp; zBuf[i+1]=='.' &amp;&amp; zBuf[i+2]==0 ){
              zBuf[i+1] = 0;
              continue;
            }
            if( i&gt;0 &amp;&amp; zBuf[i]=='/' &amp;&amp; zBuf[i+1]=='.' &amp;&amp; zBuf[i+2]=='.'
                   &amp;&amp; (zBuf[i+3]=='/' || zBuf[i+3]==0) ){
              for(j=i-1; j&gt;=0 &amp;&amp; zBuf[j]!='/'; j--){}
              if( zBuf[i+3] ){
                strcpy(&amp;zBuf[j+1], &amp;zBuf[i+4]);
              }else{
                zBuf[j+1] = 0;
              }
              i = j-1;
              if( i&lt;-1 ) i = -1;
              continue;
            }
          }
          HtmlFree(base-&gt;zPath);
          base-&gt;zPath = zBuf;
        }
        ReplaceStr(&amp;base-&gt;zQuery, term-&gt;zQuery);
        ReplaceStr(&amp;base-&gt;zFragment, term-&gt;zFragment);
     }
      FreeUri(term);
    }
    Tcl_SetResult(htmlPtr-&gt;interp, BuildUri(base), TCL_DYNAMIC);
    FreeUri(base);
  }
  return rc;
}
</t>
<t tx="ekr.20041214071955.159">@ ** This is a convenient wrapper routine for HtmlCallResolver. ** It makes a copy of the result into memory obtained from HtmlAlloc() ** and invokes Tcl_ResetResult().
@c

char *HtmlResolveUri(HtmlWidget *htmlPtr, char *zUri){
  char *azSeq[2];
  char *zSrc;
  int result;

  if( zUri==0 || *zUri==0 ) return 0;
  azSeq[0] = zUri;
  azSeq[1] = 0;
  HtmlLock(htmlPtr);
  result = HtmlCallResolver(htmlPtr, azSeq);
  if( HtmlUnlock(htmlPtr) ) return 0;
  if( result==TCL_OK ){
    zSrc = HtmlAlloc( strlen(htmlPtr-&gt;interp-&gt;result) + 1 );
    if( zSrc ) strcpy(zSrc, htmlPtr-&gt;interp-&gt;result);
  }else{
    zSrc = 0;
  }
  Tcl_ResetResult(htmlPtr-&gt;interp);
  return zSrc;
}
</t>
<t tx="ekr.20041214071955.160">@ignore
@language c
static char const rcsid[] = "@(#) $Id: htmlwidget.c,v 1.43 2000/02/25 13:57:03 drh Exp $";
/* The main routine for the HTML widget for Tcl/Tk */
&lt;&lt; htmlwidget #includes &gt;&gt;
&lt;&lt; htmlwidget declarations &gt;&gt;
@others
</t>
<t tx="ekr.20041214071955.161">#include &lt;tk.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "htmlwidget.h"
</t>
<t tx="ekr.20041214071955.162">#ifdef USE_TK_STUBS
# include &lt;tkIntXlibDecls.h&gt;
#endif

/*
** This global variable is used for tracing the operation of
** the Html formatter.
*/
int HtmlTraceMask = 0;

#ifdef __WIN32__
# define DEF_FRAME_BG_COLOR        "SystemButtonFace"
# define DEF_FRAME_BG_MONO         "White"
# define DEF_FRAME_CURSOR          ""
# define DEF_BUTTON_FG             "SystemButtonText"
# define DEF_BUTTON_HIGHLIGHT_BG   "SystemButtonFace"
# define DEF_BUTTON_HIGHLIGHT      "SystemWindowFrame"
#else
# define DEF_FRAME_BG_COLOR        "#d9d9d9"
# define DEF_FRAME_BG_MONO         "White"
# define DEF_FRAME_CURSOR          ""
# define DEF_BUTTON_FG             "Black"
# define DEF_BUTTON_HIGHLIGHT_BG   "#d9d9d9"
# define DEF_BUTTON_HIGHLIGHT      "Black"
#endif

/*
** Information used for argv parsing.
*/
static Tk_ConfigSpec configSpecs[] = {
    {TK_CONFIG_STRING, "-appletcommand", "appletCommand", "HtmlCallback",
        DEF_HTML_CALLBACK, Tk_Offset(HtmlWidget, zAppletCommand), 0},
    {TK_CONFIG_BORDER, "-background", "background", "Background",
	DEF_HTML_BG_COLOR, Tk_Offset(HtmlWidget, border),
	TK_CONFIG_COLOR_ONLY},
    {TK_CONFIG_BORDER, "-background", "background", "Background",
	DEF_HTML_BG_MONO, Tk_Offset(HtmlWidget, border),
	TK_CONFIG_MONO_ONLY},
    {TK_CONFIG_STRING, "-base", "base", "Base",
        "", Tk_Offset(HtmlWidget, zBase), 0},
    {TK_CONFIG_SYNONYM, "-bd", "borderWidth", (char *) NULL,
	(char *) NULL, 0, 0},
    {TK_CONFIG_SYNONYM, "-bg", "background", (char *) NULL,
	(char *) NULL, 0, 0},
    {TK_CONFIG_PIXELS, "-borderwidth", "borderWidth", "BorderWidth",
	DEF_HTML_BORDER_WIDTH, Tk_Offset(HtmlWidget, borderWidth), 0},
    {TK_CONFIG_ACTIVE_CURSOR, "-cursor", "cursor", "Cursor",
	DEF_HTML_CURSOR, Tk_Offset(HtmlWidget, cursor), TK_CONFIG_NULL_OK},
    {TK_CONFIG_BOOLEAN, "-exportselection", "exportSelection","ExportSelection",
        DEF_HTML_EXPORT_SEL, Tk_Offset(HtmlWidget, exportSelection), 0},
    {TK_CONFIG_SYNONYM, "-fg", "foreground", (char *) NULL,
	(char *) NULL, 0, 0},
    {TK_CONFIG_STRING, "-fontcommand", "fontCommand", "FontCommand",
        DEF_HTML_CALLBACK, Tk_Offset(HtmlWidget, zFontCommand), 0},
    {TK_CONFIG_COLOR, "-foreground", "foreground", "Foreground",
	DEF_HTML_FG, Tk_Offset(HtmlWidget, fgColor), 0},
    {TK_CONFIG_STRING, "-formcommand", "formlCommand", "HtmlCallback",
        DEF_HTML_CALLBACK, Tk_Offset(HtmlWidget, zFormCommand), 0},
    {TK_CONFIG_STRING, "-framecommand", "frameCommand", "HtmlCallback",
        DEF_HTML_CALLBACK, Tk_Offset(HtmlWidget, zFrameCommand), 0},
    {TK_CONFIG_PIXELS, "-height", "height", "Hidth",
	DEF_HTML_HEIGHT, Tk_Offset(HtmlWidget, height), 0},
    {TK_CONFIG_COLOR, "-highlightbackground", "highlightBackground",
	"HighlightBackground", DEF_HTML_HIGHLIGHT_BG,
	Tk_Offset(HtmlWidget, highlightBgColorPtr), 0},
    {TK_CONFIG_COLOR, "-highlightcolor", "highlightColor", "HighlightColor",
	DEF_HTML_HIGHLIGHT, Tk_Offset(HtmlWidget, highlightColorPtr), 0},
    {TK_CONFIG_PIXELS, "-highlightthickness", "highlightThickness",
	"HighlightThickness",
	DEF_HTML_HIGHLIGHT_WIDTH, Tk_Offset(HtmlWidget, highlightWidth), 0},
    {TK_CONFIG_STRING, "-hyperlinkcommand", "hyperlinkCommand", "HtmlCallback",
        DEF_HTML_CALLBACK, Tk_Offset(HtmlWidget, zHyperlinkCommand), 0},
    {TK_CONFIG_STRING, "-imagecommand", "imageCommand", "HtmlCallback",
        DEF_HTML_CALLBACK, Tk_Offset(HtmlWidget, zGetImage), 0},
    {TK_CONFIG_INT, "-insertofftime", "insertOffTime", "OffTime",
        DEF_HTML_INSERT_OFF_TIME, Tk_Offset(HtmlWidget, insOffTime), 0},
    {TK_CONFIG_INT, "-insertontime", "insertOnTime", "OnTime",
        DEF_HTML_INSERT_ON_TIME, Tk_Offset(HtmlWidget, insOnTime), 0},
    {TK_CONFIG_STRING, "-isvisitedcommand", "isVisitedCommand", "HtmlCallback",
        DEF_HTML_CALLBACK, Tk_Offset(HtmlWidget, zIsVisited), 0},
    {TK_CONFIG_PIXELS, "-padx", "padX", "Pad",
	DEF_HTML_PADX, Tk_Offset(HtmlWidget, padx), 0},
    {TK_CONFIG_PIXELS, "-pady", "padY", "Pad",
	DEF_HTML_PADY, Tk_Offset(HtmlWidget, pady), 0},
    {TK_CONFIG_RELIEF, "-relief", "relief", "Relief",
	DEF_HTML_RELIEF, Tk_Offset(HtmlWidget, relief), 0},
    {TK_CONFIG_STRING, "-resolvercommand", "resolverCommand", "HtmlCallback",
        DEF_HTML_CALLBACK, Tk_Offset(HtmlWidget, zResolverCommand), 0},
    {TK_CONFIG_RELIEF, "-rulerelief", "ruleRelief","RuleRelief",
        "sunken", Tk_Offset(HtmlWidget, ruleRelief), 0},
    {TK_CONFIG_STRING, "-scriptcommand", "scriptCommand", "HtmlCallback",
        "", Tk_Offset(HtmlWidget, zScriptCommand), 0},
    {TK_CONFIG_COLOR, "-selectioncolor", "background", "Background",
	DEF_HTML_SELECTION_COLOR, Tk_Offset(HtmlWidget, selectionColor), 0},
    {TK_CONFIG_RELIEF, "-tablerelief", "tableRelief","TableRelief",
        "raised", Tk_Offset(HtmlWidget, tableRelief), 0},
    {TK_CONFIG_STRING, "-takefocus", "takeFocus", "TakeFocus",
	DEF_HTML_TAKE_FOCUS, Tk_Offset(HtmlWidget, takeFocus),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_COLOR, "-unvisitedcolor", "foreground", "Foreground",
	DEF_HTML_UNVISITED, Tk_Offset(HtmlWidget, newLinkColor), 0},
    {TK_CONFIG_BOOLEAN, "-underlinehyperlinks", "underlineHyperlinks",
        "UnderlineHyperlinks", "1", Tk_Offset(HtmlWidget, underlineLinks), 0},
    {TK_CONFIG_COLOR, "-visitedcolor", "foreground", "Foreground",
	DEF_HTML_VISITED, Tk_Offset(HtmlWidget, oldLinkColor), 0},
    {TK_CONFIG_PIXELS, "-width", "width", "Width",
	DEF_HTML_WIDTH, Tk_Offset(HtmlWidget, width), 0},
    {TK_CONFIG_STRING, "-xscrollcommand", "xScrollCommand", "ScrollCommand",
	DEF_HTML_SCROLL_COMMAND, Tk_Offset(HtmlWidget, xScrollCmd),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_STRING, "-yscrollcommand", "yScrollCommand", "ScrollCommand",
	DEF_HTML_SCROLL_COMMAND, Tk_Offset(HtmlWidget, yScrollCmd),
	TK_CONFIG_NULL_OK},
    {TK_CONFIG_END, (char *) NULL, (char *) NULL, (char *) NULL,
	(char *) NULL, 0, 0}
};
</t>
<t tx="ekr.20041214071955.163">@ ** Get a copy of the config specs.
@c

Tk_ConfigSpec *HtmlConfigSpec(void){
  return configSpecs;
}
</t>
<t tx="ekr.20041214071955.164">@ ** Find the width of the usable drawing area in pixels. If the window isn't ** mapped, use the size requested by the user. ** ** The usable drawing area is the area available for displaying rendered ** HTML. The usable drawing area does not include the 3D border or the ** padx and pady boundry within the 3D border. The usable drawing area ** is the size of the clipping window.
@c

int HtmlUsableWidth(HtmlWidget *htmlPtr){
  int w;
  Tk_Window tkwin = htmlPtr-&gt;tkwin;
  if( tkwin &amp;&amp; Tk_IsMapped(tkwin) ){
    w = Tk_Width(tkwin) - 2*(htmlPtr-&gt;padx + htmlPtr-&gt;inset);
    TestPoint(0);
  }else{
    w = htmlPtr-&gt;width;
    TestPoint(0);
  }
  return w;
}
</t>
<t tx="ekr.20041214071955.165">@ ** Find the height of the usable drawing area in pixels. If the window isn't ** mapped, use the size requested by the user. ** ** The usable drawing area is the area available for displaying rendered ** HTML. The usable drawing area does not include the 3D border or the ** padx and pady boundry within the 3D border. The usable drawing area ** is the size of the clipping window.
@c

int HtmlUsableHeight(HtmlWidget *htmlPtr){
  int h;
  Tk_Window tkwin = htmlPtr-&gt;tkwin;
  if( tkwin &amp;&amp; Tk_IsMapped(tkwin) ){
    h = Tk_Height(tkwin) - 2*(htmlPtr-&gt;pady + htmlPtr-&gt;inset);
    TestPoint(0);
  }else{
    h = htmlPtr-&gt;height;
    TestPoint(0);
  }
  return h;
}
</t>
<t tx="ekr.20041214071955.166">@ ** Compute a pair of floating point numbers that describe the current ** vertical scroll position. The first number is the fraction of ** the document that is off the top of the visible region and the second ** number is the fraction that is beyond the end of the visible region.
@c

void HtmlComputeVerticalPosition(
  HtmlWidget *htmlPtr,
  char *buf               /* Write the two floating point values here */
){
  int actual;              /* Size of the viewing area */
  double frac1, frac2;

  actual = HtmlUsableHeight(htmlPtr);
  if( htmlPtr-&gt;maxY &lt;= 0 ){
    frac1 = 0.0;
    frac2 = 1.0;
    TestPoint(0);
  }else{
    frac1 = (double)htmlPtr-&gt;yOffset/(double)htmlPtr-&gt;maxY;
    if( frac1 &gt; 1.0 ){
      frac1 = 1.0;
      TestPoint(0);
    }else if( frac1 &lt; 0.0 ){
      frac1 = 0.0;
      TestPoint(0);
    }
    frac2 = (double)(htmlPtr-&gt;yOffset+actual)/(double)htmlPtr-&gt;maxY;
    if( frac2 &gt; 1.0 ){
      frac2 = 1.0;
      TestPoint(0);
    }else if( frac2 &lt; 0.0 ){
      frac2 = 0.0;
      TestPoint(0);
    }
  }
  sprintf(buf,"%g %g",frac1, frac2);
}
</t>
<t tx="ekr.20041214071955.167">@ ** Do the same thing for the horizontal direction
@c

void HtmlComputeHorizontalPosition(
  HtmlWidget *htmlPtr,
  char *buf               /* Write the two floating point values here */
){
  int actual;             /* Size of the viewing area */
  double frac1, frac2;

  actual = HtmlUsableWidth(htmlPtr);
  if( htmlPtr-&gt;maxX &lt;= 0 ){
    frac1 = 0.0;
    frac2 = 1.0;
    TestPoint(0);
  }else{
    frac1 = (double)htmlPtr-&gt;xOffset/(double)htmlPtr-&gt;maxX;
    if( frac1 &gt; 1.0 ){
      frac1 = 1.0;
      TestPoint(0);
    }else if( frac1 &lt; 0.0 ){
      frac1 = 0.0;
      TestPoint(0);
    }
    frac2 = (double)(htmlPtr-&gt;xOffset+actual)/(double)htmlPtr-&gt;maxX;
    if( frac2 &gt; 1.0 ){
      frac2 = 1.0;
      TestPoint(0);
    }else if( frac2 &lt; 0.0 ){
      frac2 = 0.0;
      TestPoint(0);
    }
  }
  sprintf(buf,"%g %g",frac1, frac2);
}
</t>
<t tx="ekr.20041214071955.168">@ ** Clear the cache of GCs
@c

static void ClearGcCache(HtmlWidget *htmlPtr){
  int i;
  for(i=0; i&lt;N_CACHE_GC; i++){
    if( htmlPtr-&gt;aGcCache[i].index ){
      Tk_FreeGC(htmlPtr-&gt;display, htmlPtr-&gt;aGcCache[i].gc);
      htmlPtr-&gt;aGcCache[i].index = 0;
      TestPoint(0);
    }else{
      TestPoint(0);
    }
  }
}
</t>
<t tx="ekr.20041214071955.169">@ ** This routine is called when the widget command is deleted. If the ** widget isn't already in the process of being destroyed, this command ** starts that process rolling. ** ** This routine can be called in two ways.  ** **  (1) The window is destroyed, which causes the command to be deleted. **    In this case, we don't have to do anything. ** **  (2) The command only is deleted (ex: "rename .html {}"). In that **    case we need to destroy the window.
@c

static void HtmlCmdDeletedProc(ClientData clientData){
  HtmlWidget *htmlPtr = (HtmlWidget*) clientData;
  if (htmlPtr != NULL &amp;&amp; htmlPtr-&gt;tkwin!=NULL ) {
    Tk_Window tkwin = htmlPtr-&gt;tkwin;
    htmlPtr-&gt;tkwin = NULL;
    Tk_DestroyWindow(tkwin);
  }
}
</t>
<t tx="ekr.20041214071955.170">@ ** Reset the main layout context in the main widget. This happens ** before we redo the layout, or just before deleting the widget.
@c

static void ResetLayoutContext(HtmlWidget *htmlPtr){
  htmlPtr-&gt;layoutContext.headRoom = 0;
  htmlPtr-&gt;layoutContext.top = 0;
  htmlPtr-&gt;layoutContext.bottom = 0;
  HtmlClearMarginStack(&amp;htmlPtr-&gt;layoutContext.leftMargin);
  HtmlClearMarginStack(&amp;htmlPtr-&gt;layoutContext.rightMargin);
}
</t>
<t tx="ekr.20041214071955.171">@ ** This routine is invoked in order to redraw all or part of the HTML ** widget. This might happen because the display has changed, or in ** response to an expose event. In all cases, though, this routine ** is called by an idle callback.
@c

static void HtmlRedrawCallback(ClientData clientData){
  HtmlWidget *htmlPtr = (HtmlWidget*)clientData;
  Tk_Window tkwin = htmlPtr-&gt;tkwin;
  Tk_Window clipwin = htmlPtr-&gt;clipwin;
  Pixmap pixmap;           /* The buffer on which to render HTML */
  int x, y, w, h;          /* Virtual canvas coordinates of area to draw */
  int hw;                  /* highlight thickness */
  int insetX, insetY;      /* Total highlight thickness, border width and 
                           ** padx/y */
  int clipwinH, clipwinW;  /* Width and height of the clipping window */
  HtmlBlock *pBlock;       /* For looping over blocks to be drawn */
  int redoSelection = 0;   /* True to recompute the selection */
  
  /* 
  ** Don't bother doing anything if the widget is in the process of
  ** being destroyed.
  */
  if( tkwin==0 ){
    goto redrawExit;
  }

  /*
  ** Recompute the layout, if necessary or requested.
  **
  ** Calling HtmlLayout() is tricky because HtmlLayout() may invoke one
  ** or more callbacks (thru the "-imagecommand" callback, for instance)
  ** and these callbacks could, in theory, do nasty things like delete 
  ** or unmap this widget.  So we have to take precautions:
  **
  **   *  Don't remove the REDRAW_PENDING flag until after HtmlLayout()
  **      has been called, to prevent a recursive call to HtmlRedrawCallback().
  **
  **   *  Call HtmlLock() on the htmlPtr structure to prevent it from
  **      being deleted out from under us.
  **
  */
  if( (htmlPtr-&gt;flags &amp; RESIZE_ELEMENTS)!=0 
  &amp;&amp; (htmlPtr-&gt;flags &amp; STYLER_RUNNING)==0 ){
    HtmlImage *pImage;
    for(pImage=htmlPtr-&gt;imageList; pImage; pImage=pImage-&gt;pNext){
      pImage-&gt;pList = 0;
    }
    htmlPtr-&gt;lastSized = 0;
    htmlPtr-&gt;flags &amp;= ~RESIZE_ELEMENTS;
    htmlPtr-&gt;flags |= RELAYOUT;
  }

  /* We used to make a distinction between RELAYOUT and EXTEND_LAYOUT.
  ** RELAYOUT would be used when the widget was resized, but the
  ** less compute-intensive EXTEND_LAYOUT would be used when new
  ** text was appended.
  **
  ** Unfortunately, EXTEND_LAYOUT has some problem that arise when
  ** tables are used.  The quick fix is to make an EXTEND_LAYOUT do
  ** a complete RELAYOUT.  Someday, we need to fix EXTEND_LAYOUT so
  ** that it works right...
  */
  if( (htmlPtr-&gt;flags &amp; (RELAYOUT|EXTEND_LAYOUT))!=0 
  &amp;&amp; (htmlPtr-&gt;flags &amp; STYLER_RUNNING)==0 ){
    htmlPtr-&gt;nextPlaced = 0;
    htmlPtr-&gt;nInput = 0;
    htmlPtr-&gt;varId = 0;
    htmlPtr-&gt;maxX = 0;
    htmlPtr-&gt;maxY = 0;
    ResetLayoutContext(htmlPtr);
    htmlPtr-&gt;firstBlock = 0;
    htmlPtr-&gt;lastBlock = 0;
    redoSelection = 1;
    htmlPtr-&gt;flags &amp;= ~RELAYOUT;
    htmlPtr-&gt;flags |= HSCROLL | VSCROLL | REDRAW_TEXT | EXTEND_LAYOUT;
  }
  if( (htmlPtr-&gt;flags &amp; EXTEND_LAYOUT) &amp;&amp; htmlPtr-&gt;pFirst!=0 ){
    HtmlLock(htmlPtr);
    HtmlLayout(htmlPtr);
    if( HtmlUnlock(htmlPtr) ) goto redrawExit;
    tkwin = htmlPtr-&gt;tkwin;
    htmlPtr-&gt;flags &amp;= ~EXTEND_LAYOUT;
    HtmlFormBlocks(htmlPtr);
    HtmlMapControls(htmlPtr);
    if( redoSelection &amp;&amp; htmlPtr-&gt;selBegin.p &amp;&amp; htmlPtr-&gt;selEnd.p ){
      HtmlUpdateSelection(htmlPtr,1);
      HtmlUpdateInsert(htmlPtr);
    }
  }
  htmlPtr-&gt;flags &amp;= ~REDRAW_PENDING;

  /* No need to do any actual drawing if we aren't mapped
  */
  if( !Tk_IsMapped(tkwin) ){
    goto redrawExit;
  }

  /* Redraw the scrollbars.  Take care here, since the scrollbar
  ** update command could (in theory) delete the html widget, or
  ** even the whole interpreter.  Preserve critical data structures,
  ** and check to see if we are still alive before continuing.
  */
  if( (htmlPtr-&gt;flags &amp; (HSCROLL|VSCROLL)) != 0 ){
    Tcl_Interp *interp = htmlPtr-&gt;interp;
    int result;
    char buf[200];

    if( (htmlPtr-&gt;flags &amp; HSCROLL)!=0 ){
      if( htmlPtr-&gt;xScrollCmd &amp;&amp; htmlPtr-&gt;xScrollCmd[0] ){
        HtmlComputeHorizontalPosition(htmlPtr,buf);
        HtmlLock(htmlPtr);
        result = Tcl_VarEval(interp, htmlPtr-&gt;xScrollCmd, " ", buf, 0);
        if( HtmlUnlock(htmlPtr) ) goto redrawExit;
        if (result != TCL_OK) {
          Tcl_AddErrorInfo(interp,
             "\n    (horizontal scrolling command executed by html widget)");
          Tcl_BackgroundError(interp);
          TestPoint(0);
        }
      }
      htmlPtr-&gt;flags &amp;= ~HSCROLL;
    }
    if( (htmlPtr-&gt;flags &amp; VSCROLL)!=0 &amp;&amp; tkwin &amp;&amp; Tk_IsMapped(tkwin) ){
      if( htmlPtr-&gt;yScrollCmd &amp;&amp; htmlPtr-&gt;yScrollCmd[0] ){
        Tcl_Interp *interp = htmlPtr-&gt;interp;
        int result;
        char buf[200];
        HtmlComputeVerticalPosition(htmlPtr,buf);
        HtmlLock(htmlPtr);
        result = Tcl_VarEval(interp, htmlPtr-&gt;yScrollCmd, " ", buf, 0);
        if( HtmlUnlock(htmlPtr) ) goto redrawExit;
        if (result != TCL_OK) {
          Tcl_AddErrorInfo(interp,
             "\n    (horizontal scrolling command executed by html widget)");
          Tcl_BackgroundError(interp);
          TestPoint(0);
        }
      }
      htmlPtr-&gt;flags &amp;= ~VSCROLL;
    }
    tkwin = htmlPtr-&gt;tkwin;
    if( tkwin==0 || !Tk_IsMapped(tkwin) ){ goto redrawExit; }
    if( htmlPtr-&gt;flags &amp; REDRAW_PENDING ){ return; }
    clipwin = htmlPtr-&gt;clipwin;
    if( clipwin==0 ){ TestPoint(0); goto redrawExit; }
  }

  /* Redraw the focus highlight, if requested */
  hw = htmlPtr-&gt;highlightWidth;
  if( htmlPtr-&gt;flags &amp; REDRAW_FOCUS ){
    if( hw&gt;0 ){
      GC gc;
      Tk_Window tkwin = htmlPtr-&gt;tkwin;

      if( htmlPtr-&gt;flags &amp; GOT_FOCUS ){
        gc = Tk_GCForColor(htmlPtr-&gt;highlightColorPtr, Tk_WindowId(tkwin));
        TestPoint(0);
      }else{
        gc = Tk_GCForColor(htmlPtr-&gt;highlightBgColorPtr, Tk_WindowId(tkwin));
        TestPoint(0);
      }
      Tk_DrawFocusHighlight(tkwin, gc, hw, Tk_WindowId(tkwin));
    }
    htmlPtr-&gt;flags &amp;= ~REDRAW_FOCUS;
  }

  /* Draw the borders around the parameter of the window.  This is
  ** drawn directly -- it is not double buffered.
  */
  if( htmlPtr-&gt;flags &amp; REDRAW_BORDER ){
    htmlPtr-&gt;flags &amp;= ~REDRAW_BORDER;
    Tk_Fill3DRectangle(tkwin, Tk_WindowId(tkwin), htmlPtr-&gt;border,
          hw,                        /* x */
          hw,                        /* y */
          Tk_Width(tkwin) - 2*hw,    /* width */
          Tk_Height(tkwin) - 2*hw,   /* height */
          htmlPtr-&gt;borderWidth, htmlPtr-&gt;relief);
  }

  /*
  ** If the styler is in a callback, unmap the clipping window and
  ** abort further processing.
  */
  if( htmlPtr-&gt;flags &amp; STYLER_RUNNING ){
    if( Tk_IsMapped(clipwin) ){
      Tk_UnmapWindow(clipwin);
    }
    goto earlyOut;
  }

  /*
  ** If we don't have a clipping window, then something is seriously
  ** wrong.  We might as well give up.
  */
  if( clipwin==NULL ){ TestPoint(0); goto earlyOut; }

  /* Resize, reposition and map the clipping window, if necessary */
  insetX = htmlPtr-&gt;padx + htmlPtr-&gt;inset;
  insetY = htmlPtr-&gt;pady + htmlPtr-&gt;inset;
  if( htmlPtr-&gt;flags &amp; RESIZE_CLIPWIN ){
    int h, w;
    Tk_MoveResizeWindow(clipwin, insetX, insetY, 
       htmlPtr-&gt;realWidth - 2*insetX,
       htmlPtr-&gt;realHeight - 2*insetY);
    if( !Tk_IsMapped(clipwin) ){
      Tk_MapWindow(clipwin);
    }
    h = htmlPtr-&gt;realHeight - 2*insetY;
    if( htmlPtr-&gt;yOffset + h &gt; htmlPtr-&gt;maxY ){
      htmlPtr-&gt;yOffset = htmlPtr-&gt;maxY - h;
    }
    if( htmlPtr-&gt;yOffset &lt; 0 ){
      htmlPtr-&gt;yOffset = 0;
    }
    w = htmlPtr-&gt;realWidth - 2*insetX;
    if( htmlPtr-&gt;xOffset + h &gt; htmlPtr-&gt;maxX ){
      htmlPtr-&gt;xOffset = htmlPtr-&gt;maxX - w;
    }
    if( htmlPtr-&gt;xOffset &lt; 0 ){
      htmlPtr-&gt;xOffset = 0;
    }
    htmlPtr-&gt;flags &amp;= ~RESIZE_CLIPWIN;
  }
  HtmlMapControls(htmlPtr);

  /*
  ** Compute the virtual canvas coordinates corresponding to the
  ** dirty region of the clipping window.
  */
  clipwinW = Tk_Width(clipwin);
  clipwinH = Tk_Height(clipwin);
  if( htmlPtr-&gt;flags &amp; REDRAW_TEXT ){
    w = clipwinW;
    h = clipwinH;
    x = htmlPtr-&gt;xOffset;
    y = htmlPtr-&gt;yOffset;
    htmlPtr-&gt;dirtyLeft = 0;
    htmlPtr-&gt;dirtyTop = 0;
    htmlPtr-&gt;flags &amp;= ~REDRAW_TEXT;
  }else{
    if( htmlPtr-&gt;dirtyLeft &lt; 0 ){
      htmlPtr-&gt;dirtyLeft = 0;
      TestPoint(0);
    }
    if( htmlPtr-&gt;dirtyRight &gt; clipwinW  ){
      htmlPtr-&gt;dirtyRight = clipwinW;
      TestPoint(0);
    }
    if( htmlPtr-&gt;dirtyTop &lt; 0 ){
      htmlPtr-&gt;dirtyTop = 0;
      TestPoint(0);
    }
    if( htmlPtr-&gt;dirtyBottom &gt; clipwinH ){
      htmlPtr-&gt;dirtyBottom = clipwinH;
      TestPoint(0);
    }
    w = htmlPtr-&gt;dirtyRight - htmlPtr-&gt;dirtyLeft;
    h = htmlPtr-&gt;dirtyBottom - htmlPtr-&gt;dirtyTop;
    x = htmlPtr-&gt;xOffset + htmlPtr-&gt;dirtyLeft;
    y = htmlPtr-&gt;yOffset + htmlPtr-&gt;dirtyTop;
  }

  /* Skip the rest of the drawing process if the area to be refreshed is
  ** less than zero */
  if( w&gt;0 &amp;&amp; h&gt;0 ){
    Display *display = htmlPtr-&gt;display;
    int dead;
    GC gcBg;
    XRectangle xrec;
    /* printf("Redraw %dx%d at %d,%d\n", w, h, x, y); */

    /* Allocate and clear a pixmap upon which to draw */
    gcBg = HtmlGetGC(htmlPtr, COLOR_Background, FONT_Any);
    pixmap = Tk_GetPixmap(display, Tk_WindowId(clipwin),w,h,Tk_Depth(clipwin));
    xrec.x = 0;
    xrec.y = 0;
    xrec.width = w;
    xrec.height = h;
    XFillRectangles(display, pixmap, gcBg, &amp;xrec, 1);
                       
    /* Render all visible HTML onto the pixmap */
    HtmlLock(htmlPtr);
    for(pBlock=htmlPtr-&gt;firstBlock; pBlock; pBlock=pBlock-&gt;pNext){
      if( pBlock-&gt;top &lt;= y+h &amp;&amp; pBlock-&gt;bottom &gt;= y 
      &amp;&amp; pBlock-&gt;left &lt;= x+w &amp;&amp; pBlock-&gt;right &gt;= x ){
        HtmlBlockDraw(htmlPtr,pBlock,pixmap,x,y,w,h);
        if( htmlPtr-&gt;tkwin==0 ) break;
      }
    }
    dead = HtmlUnlock(htmlPtr);
     
    /* Finally, copy the pixmap onto the window and delete the pixmap */
    if( !dead ){
      XCopyArea(display, pixmap, Tk_WindowId(clipwin),
                gcBg, 0, 0, w, h, htmlPtr-&gt;dirtyLeft, htmlPtr-&gt;dirtyTop);
    }
    Tk_FreePixmap(display, pixmap);
    if( dead ) goto redrawExit;
    /* XFlush(display); */
  }

  /* Redraw images, if requested */
  if( htmlPtr-&gt;flags &amp; REDRAW_IMAGES ){
    HtmlImage *pImage;
    HtmlElement *pElem;
    int top, bottom, left, right;     /* Coordinates of the clipping window */
    int imageTop;                     /* Top edge of image */

    top = htmlPtr-&gt;yOffset;
    bottom = top + HtmlUsableHeight(htmlPtr);
    left = htmlPtr-&gt;xOffset;
    right = left + HtmlUsableWidth(htmlPtr);
    for(pImage = htmlPtr-&gt;imageList; pImage; pImage=pImage-&gt;pNext){
      for(pElem = pImage-&gt;pList; pElem; pElem=pElem-&gt;image.pNext){
        if( pElem-&gt;image.redrawNeeded==0 ) continue;
        imageTop = pElem-&gt;image.y - pElem-&gt;image.ascent;
        if( imageTop &gt; bottom
         || imageTop + pElem-&gt;image.h &lt; top
         || pElem-&gt;image.x &gt; right
         || pElem-&gt;image.x + pElem-&gt;image.w &lt; left ){ 
            TestPoint(0); 
            continue; 
        }
        HtmlDrawImage(pElem, Tk_WindowId(htmlPtr-&gt;clipwin),
                      left, top, right, bottom);
      }
    }
    htmlPtr-&gt;flags &amp;= ~REDRAW_IMAGES;
  }

  /* Set the dirty region to the empty set. */
  earlyOut:
  htmlPtr-&gt;dirtyTop = LARGE_NUMBER;
  htmlPtr-&gt;dirtyLeft = LARGE_NUMBER;
  htmlPtr-&gt;dirtyBottom = 0;
  htmlPtr-&gt;dirtyRight = 0;
  redrawExit:
  return;
}
</t>
<t tx="ekr.20041214071955.172">@ ** Make sure that a call to the HtmlRedrawCallback() routine has been ** queued.
@c

void HtmlScheduleRedraw(HtmlWidget *htmlPtr){
  if( (htmlPtr-&gt;flags &amp; REDRAW_PENDING)==0
    &amp;&amp; htmlPtr-&gt;tkwin!=0 
    &amp;&amp; Tk_IsMapped(htmlPtr-&gt;tkwin)
  ){
    Tcl_DoWhenIdle(HtmlRedrawCallback, (ClientData)htmlPtr);
    htmlPtr-&gt;flags |= REDRAW_PENDING;
  }
}
</t>
<t tx="ekr.20041214071955.173">@ ** If any part of the screen needs to be redrawn, Then call this routine ** with the values of a box (in window coordinates) that needs to be ** redrawn. This routine will make sure an idle callback is scheduled ** to do the redraw. ** ** The box coordinates are relative to the clipping window (clipwin), ** not the main window (tkwin).
@c

void HtmlRedrawArea(
  HtmlWidget *htmlPtr,      /* The widget to be redrawn */
  int left, int top,        /* Top left corner of area to redraw */
  int right, int bottom     /* bottom right corner of area to redraw */
){
  if( bottom &lt; 0 ){ TestPoint(0); return; }
  if( top &gt; htmlPtr-&gt;realHeight ){ TestPoint(0); return; }
  if( right &lt; 0 ){ TestPoint(0); return; }
  if( left &gt; htmlPtr-&gt;realWidth ){ TestPoint(0); return; }
  if( htmlPtr-&gt;dirtyTop &gt; top ){ htmlPtr-&gt;dirtyTop = top; TestPoint(0);}
  if( htmlPtr-&gt;dirtyLeft &gt; left ){ htmlPtr-&gt;dirtyLeft = left; TestPoint(0);}
  if( htmlPtr-&gt;dirtyBottom &lt; bottom ){ 
    htmlPtr-&gt;dirtyBottom = bottom;
    TestPoint(0);
  }
  if( htmlPtr-&gt;dirtyRight &lt; right ){ htmlPtr-&gt;dirtyRight = right; TestPoint(0);}
  HtmlScheduleRedraw(htmlPtr);
  TestPoint(0);
}
</t>
<t tx="ekr.20041214071955.174">@ Redraw the HtmlBlock given.
@c

void HtmlRedrawBlock(HtmlWidget *htmlPtr, HtmlBlock *p){
  if( p ){
    HtmlRedrawArea(htmlPtr,
      p-&gt;left - htmlPtr-&gt;xOffset,
      p-&gt;top - htmlPtr-&gt;yOffset,
      p-&gt;right - htmlPtr-&gt;xOffset + 1,
      p-&gt;bottom - htmlPtr-&gt;yOffset
    );
    TestPoint(0);
  }else{
    TestPoint(0);
  }
}
</t>
<t tx="ekr.20041214071955.175">@ ** Call this routine to force the entire widget to be redrawn.
@c

void HtmlRedrawEverything(HtmlWidget *htmlPtr){
  htmlPtr-&gt;flags |= REDRAW_FOCUS | REDRAW_TEXT | REDRAW_BORDER;
  HtmlScheduleRedraw(htmlPtr);
  TestPoint(0);
}
</t>
<t tx="ekr.20041214071955.176">@ ** Do the redrawing right now. Don't wait.
@c

#if 0  /* NOT_USED */
static void HtmlRedrawPush(HtmlWidget *htmlPtr){
  if( htmlPtr-&gt;flags &amp; REDRAW_PENDING ){
    Tcl_CancelIdleCall(HtmlRedrawCallback, (ClientData)htmlPtr);
    TestPoint(0);
  }else{
    TestPoint(0);
  }
  HtmlRedrawCallback( (ClientData)htmlPtr );
}
</t>
<t tx="ekr.20041214071955.177">#endif

/*
** Call this routine to cause all of the rendered HTML at the
** virtual canvas coordinate of Y and beyond to be redrawn.
*/
void HtmlRedrawText(HtmlWidget *htmlPtr, int y){
  int yOffset;        /* Top-most visible canvas coordinate */
  int clipHeight;     /* Height of the clipping window */
  
  yOffset = htmlPtr-&gt;yOffset;
  clipHeight = HtmlUsableHeight(htmlPtr);
  y -= yOffset;
  if( y &lt; clipHeight ){
    HtmlRedrawArea(htmlPtr, 0, y, LARGE_NUMBER, clipHeight);
    TestPoint(0);
  }else{
    TestPoint(0);
  }
}
</t>
<t tx="ekr.20041214071955.178">@ ** Recalculate the preferred size of the html widget and pass this ** along to the geometry manager.
@c

static void HtmlRecomputeGeometry(HtmlWidget *htmlPtr){
  int w, h;      /* Total width and height of the widget */

  htmlPtr-&gt;inset = htmlPtr-&gt;highlightWidth + htmlPtr-&gt;borderWidth;
  w = htmlPtr-&gt;width + 2*(htmlPtr-&gt;padx + htmlPtr-&gt;inset);
  h = htmlPtr-&gt;height + 2*(htmlPtr-&gt;pady + htmlPtr-&gt;inset);
  Tk_GeometryRequest(htmlPtr-&gt;tkwin, w, h);
  Tk_SetInternalBorder(htmlPtr-&gt;tkwin, htmlPtr-&gt;inset);
  TestPoint(0);
}
</t>
<t tx="ekr.20041214071955.179">@ ** This routine is called in order to process a "configure" subcommand ** on the given html widget.
@c

int ConfigureHtmlWidget(
  Tcl_Interp *interp,      /* Write error message to this interpreter */
  HtmlWidget *htmlPtr,     /* The Html widget to be configured */
  int argc,                /* Number of configuration arguments */
  char **argv,             /* Text of configuration arguments */
  int flags,               /* Configuration flags */
  int realign              /* Always do a redraw if set */
){
  int rc;
  int i;
  int redraw = realign;    /* True if a redraw is required. */

  /* Scan thru the configuration options to see if we need to redraw
  ** the widget.
  */
  for(i=0; redraw==0 &amp;&amp; i&lt;argc; i+=2){
    int c;
    int n;
    if( argv[i][0]!='-' ){
      redraw = 1;
      break;
    }
    c = argv[i][1];
    n = strlen(argv[i]);
    if( c=='c' &amp;&amp; n&gt;4 &amp;&amp; strncmp(argv[i],"-cursor",n)==0 ){
      /* do nothing */
    }else
    /* The default case */
    {
      redraw = 1;
    }
  }
  rc = Tk_ConfigureWidget(interp, htmlPtr-&gt;tkwin, configSpecs, argc, argv,
                         (char *) htmlPtr, flags);
  if( rc!=TCL_OK || redraw==0 ){ TestPoint(0); return rc; }
  memset(htmlPtr-&gt;fontValid, 0, sizeof(htmlPtr-&gt;fontValid));
  htmlPtr-&gt;apColor[COLOR_Normal] = htmlPtr-&gt;fgColor;
  htmlPtr-&gt;apColor[COLOR_Visited] = htmlPtr-&gt;oldLinkColor;
  htmlPtr-&gt;apColor[COLOR_Unvisited] = htmlPtr-&gt;newLinkColor;
  htmlPtr-&gt;apColor[COLOR_Selection] = htmlPtr-&gt;selectionColor;
  htmlPtr-&gt;apColor[COLOR_Background] = Tk_3DBorderColor(htmlPtr-&gt;border);
  Tk_SetBackgroundFromBorder(htmlPtr-&gt;tkwin, htmlPtr-&gt;border);
  if( htmlPtr-&gt;highlightWidth &lt; 0 ){ htmlPtr-&gt;highlightWidth = 0; TestPoint(0);}
  if (htmlPtr-&gt;padx &lt; 0) { htmlPtr-&gt;padx = 0; TestPoint(0);}
  if (htmlPtr-&gt;pady &lt; 0) { htmlPtr-&gt;pady = 0; TestPoint(0);}
  if (htmlPtr-&gt;width &lt; 100) { htmlPtr-&gt;width = 100; TestPoint(0);}
  if (htmlPtr-&gt;height &lt; 100) { htmlPtr-&gt;height = 100; TestPoint(0);}
  if (htmlPtr-&gt;borderWidth &lt; 0) {htmlPtr-&gt;borderWidth = 0; TestPoint(0);}
  htmlPtr-&gt;flags |= RESIZE_ELEMENTS | RELAYOUT | REDRAW_BORDER | RESIZE_CLIPWIN;
  HtmlRecomputeGeometry(htmlPtr);
  HtmlRedrawEverything(htmlPtr);
  ClearGcCache(htmlPtr);
  return rc;
}
</t>
<t tx="ekr.20041214071955.180">@ ** Delete a single HtmlElement
@c

void HtmlDeleteElement(HtmlElement *p){
  switch( p-&gt;base.type ){
    case Html_Block:
      if( p-&gt;block.z ){
        HtmlFree(p-&gt;block.z);
      }
      break;
    default:
      break;
  }
  HtmlFree(p);
}
</t>
<t tx="ekr.20041214071955.181">@ ** Erase all data from the HTML widget. Bring it back to an ** empty screen. ** ** This happens (for example) when the "clear" method is invoked ** on the widget, or just before the widget is deleted.
@c

void HtmlClear(HtmlWidget *htmlPtr){
  int i;
  HtmlElement *p, *pNext;

  HtmlDeleteControls(htmlPtr);
  for(p=htmlPtr-&gt;pFirst; p; p=pNext){
    pNext = p-&gt;pNext;
    HtmlDeleteElement(p);
  }
  htmlPtr-&gt;pFirst = 0;
  htmlPtr-&gt;pLast = 0;
  htmlPtr-&gt;nToken = 0;
  if( htmlPtr-&gt;zText ){
    HtmlFree(htmlPtr-&gt;zText);
  }
  htmlPtr-&gt;zText = 0;
  htmlPtr-&gt;nText = 0;
  htmlPtr-&gt;nAlloc = 0;
  htmlPtr-&gt;nComplete = 0;
  htmlPtr-&gt;iPlaintext = 0;
  for(i=N_PREDEFINED_COLOR; i&lt;N_COLOR; i++){
    if( htmlPtr-&gt;apColor[i] != 0 ){
      Tk_FreeColor(htmlPtr-&gt;apColor[i]);
      htmlPtr-&gt;apColor[i] = 0;
    }
  }
  for(i=0; i&lt;N_COLOR; i++){
    htmlPtr-&gt;iDark[i] = 0;
    htmlPtr-&gt;iLight[i] = 0;
  }
  htmlPtr-&gt;colorUsed = 0;
  while( htmlPtr-&gt;imageList ){
    HtmlImage *p = htmlPtr-&gt;imageList;
    htmlPtr-&gt;imageList = p-&gt;pNext;
    Tk_FreeImage(p-&gt;image);
    HtmlFree(p);
    TestPoint(0);
  }
  while( htmlPtr-&gt;styleStack ){
    HtmlStyleStack *p = htmlPtr-&gt;styleStack;
    htmlPtr-&gt;styleStack = p-&gt;pNext;
    HtmlFree(p);
  }
  ClearGcCache(htmlPtr);
  ResetLayoutContext(htmlPtr);
  if( htmlPtr-&gt;zBaseHref ){
    HtmlFree(htmlPtr-&gt;zBaseHref);
    htmlPtr-&gt;zBaseHref = 0;
  }
  htmlPtr-&gt;lastSized = 0;
  htmlPtr-&gt;nextPlaced = 0;
  htmlPtr-&gt;firstBlock = 0;
  htmlPtr-&gt;lastBlock = 0;
  htmlPtr-&gt;nInput = 0;
  htmlPtr-&gt;nForm = 0;
  htmlPtr-&gt;varId = 0;
  htmlPtr-&gt;paraAlignment = ALIGN_None;
  htmlPtr-&gt;rowAlignment = ALIGN_None;
  htmlPtr-&gt;anchorFlags = 0;
  htmlPtr-&gt;inDt = 0;
  htmlPtr-&gt;anchorStart = 0;
  htmlPtr-&gt;formStart = 0;
  htmlPtr-&gt;innerList = 0;
  htmlPtr-&gt;maxX = 0;
  htmlPtr-&gt;maxY = 0;
  htmlPtr-&gt;xOffset = 0;
  htmlPtr-&gt;yOffset = 0;
  htmlPtr-&gt;pInsBlock = 0;
  htmlPtr-&gt;ins.p = 0;
  htmlPtr-&gt;selBegin.p = 0;
  htmlPtr-&gt;selEnd.p = 0;
  htmlPtr-&gt;pSelStartBlock = 0;
  htmlPtr-&gt;pSelEndBlock = 0;
}
</t>
<t tx="ekr.20041214071955.182">@ ** This routine attempts to delete the widget structure. But it won't ** do it if the widget structure is locked. If the widget structure is ** locked, then when HtmlUnlock() is called and the lock count reaches ** zero, this routine will be called to finish the job.
@c

static void DestroyHtmlWidget(HtmlWidget *htmlPtr){
  int i;

  if( htmlPtr-&gt;locked&gt;0 ) return;
  Tcl_DeleteCommand(htmlPtr-&gt;interp, htmlPtr-&gt;zCmdName);
  Tcl_DeleteCommand(htmlPtr-&gt;interp, htmlPtr-&gt;zClipwin);
  HtmlClear(htmlPtr);
  Tk_FreeOptions(configSpecs, (char*) htmlPtr, htmlPtr-&gt;display, 0);
  for(i=0; i&lt;N_FONT; i++){
    if( htmlPtr-&gt;aFont[i] != 0 ){
      Tk_FreeFont(htmlPtr-&gt;aFont[i]);
      htmlPtr-&gt;aFont[i] = 0;
    }
  }
  for(i=0; i&lt;Html_TypeCount; i++){
    if( htmlPtr-&gt;zHandler[i] ){
      HtmlFree(htmlPtr-&gt;zHandler[i]);
      htmlPtr-&gt;zHandler[i] = 0;
    }
  }
  if( htmlPtr-&gt;insTimer ){
    Tcl_DeleteTimerHandler(htmlPtr-&gt;insTimer);
    htmlPtr-&gt;insTimer = 0;
  }
  HtmlFree(htmlPtr-&gt;zClipwin);
  HtmlFree(htmlPtr);
}
</t>
<t tx="ekr.20041214071955.183">@ ** Remove a lock from the HTML widget. If the widget has been ** deleted, then delete the widget structure. Return 1 if the ** widget has been deleted. Return 0 if it still exists. ** ** Normal Tk code (that is to say, code in the Tk core) uses ** Tcl_Preserve() and Tcl_Release() to accomplish what this ** function does. But preserving and releasing are much more ** common in this code than in regular widgets, so this routine ** was invented to do the same thing easier and faster.
@c

int HtmlUnlock(HtmlWidget *htmlPtr){
  htmlPtr-&gt;locked--;
  if( htmlPtr-&gt;tkwin==0 &amp;&amp; htmlPtr-&gt;locked&lt;=0 ){
    Tcl_Interp *interp = htmlPtr-&gt;interp;
    Tcl_Preserve(interp);
    DestroyHtmlWidget(htmlPtr);
    Tcl_Release(interp);
    return 1;
  }
  return htmlPtr-&gt;tkwin==0;
}
</t>
<t tx="ekr.20041214071955.184">@ ** Lock the HTML widget. This prevents the widget structure from ** being deleted even if the widget itself is destroyed. There must ** be a call to HtmlUnlock() to release the structure.
@c

void HtmlLock(HtmlWidget *htmlPtr){
  htmlPtr-&gt;locked++;
}
</t>
<t tx="ekr.20041214071955.185">@ ** This routine checks to see if an HTML widget has been ** destroyed. It is always called after calling HtmlLock(). ** ** If the widget has been destroyed, then the structure ** is unlocked and the function returns 1. If the widget ** has not been destroyed, then the structure is not unlocked ** and the routine returns 0. ** ** This routine is intended for use in code like the following: ** **   HtmlLock(htmlPtr); **   // Do something that might destroy the widget **   if( HtmlIsDead(htmlPtr) ) return; **   // Do something that might destroy the widget **   if( HtmlIsDead(htmlPtr) ) return; **   // Do something that might destroy the widget **   if( HtmlUnlock(htmlPtr) ) return;
@c

int HtmlIsDead(HtmlWidget *htmlPtr){
  if( htmlPtr-&gt;tkwin==0 ){
    HtmlUnlock(htmlPtr);
    return 1;
  }
  return 0;
}
</t>
<t tx="ekr.20041214071955.186">@ ** Flash the insertion cursor.
@c

void HtmlFlashCursor(ClientData clientData){
  HtmlWidget *htmlPtr = (HtmlWidget*)clientData;
  if( htmlPtr-&gt;pInsBlock==0 || htmlPtr-&gt;insOnTime&lt;=0
      || htmlPtr-&gt;insOffTime&lt;=0 ){
    htmlPtr-&gt;insTimer = 0;
    TestPoint(0);
    return;
  }
  HtmlRedrawBlock(htmlPtr, htmlPtr-&gt;pInsBlock);
  if( (htmlPtr-&gt;flags &amp; GOT_FOCUS)==0 ){
    htmlPtr-&gt;insStatus = 0;
    htmlPtr-&gt;insTimer = 0;
    TestPoint(0);
  }else if( htmlPtr-&gt;insStatus ){
    htmlPtr-&gt;insTimer = Tcl_CreateTimerHandler(htmlPtr-&gt;insOffTime,
                                               HtmlFlashCursor, clientData);
    htmlPtr-&gt;insStatus = 0;
    TestPoint(0);
  }else{
    htmlPtr-&gt;insTimer = Tcl_CreateTimerHandler(htmlPtr-&gt;insOnTime,
                                               HtmlFlashCursor, clientData);
    htmlPtr-&gt;insStatus = 1;
    TestPoint(0);
  }
}
</t>
<t tx="ekr.20041214071955.187">@ ** Return a GC from the cache. As many as N_CACHE_GCs are kept valid ** at any one time. They are replaced using an LRU algorithm. ** ** A value of FONT_Any (-1) for the font means "don't care".
@c

GC HtmlGetGC(HtmlWidget *htmlPtr, int color, int font){
  int i, j;
  GcCache *p = htmlPtr-&gt;aGcCache;
  XGCValues gcValues;
  int mask;
  Tk_Font tkfont;

  /* 
  ** Check for an existing GC.
  */
  if( color &lt; 0 || color &gt;= N_COLOR ){ color = 0; TestPoint(0); }
  if( font &lt; FONT_Any || font &gt;= N_FONT ){ font = FONT_Default; TestPoint(0); }
  for(i=0; i&lt;N_CACHE_GC; i++, p++){
    if( p-&gt;index==0 ){ TestPoint(0); continue; }
    if( (font&lt;0 || p-&gt;font==font) &amp;&amp; p-&gt;color==color ){
      if( p-&gt;index&gt;1 ){
        for(j=0; j&lt;N_CACHE_GC; j++){
          if( htmlPtr-&gt;aGcCache[j].index 
          &amp;&amp; htmlPtr-&gt;aGcCache[j].index &lt; p-&gt;index ){
            htmlPtr-&gt;aGcCache[j].index++;
          }
        }
        p-&gt;index = 1;
      }
      return htmlPtr-&gt;aGcCache[i].gc;
    }
  }

  /*
  ** No GC matches.  Find a place to allocate a new GC.
  */
  p = htmlPtr-&gt;aGcCache;
  for(i=0; i&lt;N_CACHE_GC; i++, p++){
    if( p-&gt;index==0 || p-&gt;index==N_CACHE_GC ){ TestPoint(0); break; }
  }
  if( p-&gt;index ){
    Tk_FreeGC(htmlPtr-&gt;display, p-&gt;gc);
  }
  gcValues.foreground = htmlPtr-&gt;apColor[color]-&gt;pixel;
  gcValues.graphics_exposures = True;
  mask = GCForeground | GCGraphicsExposures;
  if( font&lt;0 ){ font = FONT_Default; TestPoint(0); }
  tkfont = HtmlGetFont(htmlPtr, font);
  if( tkfont ){
    gcValues.font = Tk_FontId(tkfont);
    mask |= GCFont;
  }
  p-&gt;gc = Tk_GetGC(htmlPtr-&gt;tkwin, mask, &amp;gcValues);
  if( p-&gt;index==0 ){ p-&gt;index = N_CACHE_GC + 1; TestPoint(0); }
  for(j=0; j&lt;N_CACHE_GC; j++){
    if( htmlPtr-&gt;aGcCache[j].index &amp;&amp; htmlPtr-&gt;aGcCache[j].index &lt; p-&gt;index ){
      htmlPtr-&gt;aGcCache[j].index++;
    }
  }
  p-&gt;index = 1;
  p-&gt;font = font;
  p-&gt;color = color;
  return p-&gt;gc;
}
</t>
<t tx="ekr.20041214071955.188">@ ** Retrieve any valid GC. The font and color don't matter since the ** GC will only be used for copying.
@c

GC HtmlGetAnyGC(HtmlWidget *htmlPtr){
  int i;
  GcCache *p = htmlPtr-&gt;aGcCache;

  for(i=0; i&lt;N_CACHE_GC; i++, p++){
    if( p-&gt;index ){ TestPoint(0); return p-&gt;gc; }
  }
  TestPoint(0);
  return HtmlGetGC(htmlPtr, COLOR_Normal, FONT_Default);
}
</t>
<t tx="ekr.20041214071955.189">@ ** All window events (for both tkwin and clipwin) are ** sent to this routine.
@c

static void HtmlEventProc(ClientData clientData, XEvent *eventPtr){
  HtmlWidget *htmlPtr = (HtmlWidget*) clientData;
  int redraw_needed = 0;
  XConfigureRequestEvent *p;

  switch( eventPtr-&gt;type ){
    case GraphicsExpose:
    case Expose:
      if( htmlPtr-&gt;tkwin==0 ){
        /* The widget is being deleted.  Do nothing */
        TestPoint(0);
      }else if( eventPtr-&gt;xexpose.window!=Tk_WindowId(htmlPtr-&gt;tkwin) ){
        /* Exposure in the clipping window */
        HtmlRedrawArea(htmlPtr, eventPtr-&gt;xexpose.x - 1, 
                   eventPtr-&gt;xexpose.y - 1,
                   eventPtr-&gt;xexpose.x + eventPtr-&gt;xexpose.width + 1,
                   eventPtr-&gt;xexpose.y + eventPtr-&gt;xexpose.height + 1);
        TestPoint(0);
      }else{
        /* Exposure in the main window */
        htmlPtr-&gt;flags |= REDRAW_BORDER;
        HtmlScheduleRedraw(htmlPtr);
        TestPoint(0);
      }
      break;
    case DestroyNotify:
      if( (htmlPtr-&gt;flags &amp; REDRAW_PENDING) ){
        Tcl_CancelIdleCall(HtmlRedrawCallback, (ClientData)htmlPtr);
        htmlPtr-&gt;flags &amp;= ~REDRAW_PENDING;
      }
      if( htmlPtr-&gt;tkwin != 0 ){
        if( eventPtr-&gt;xany.window!=Tk_WindowId(htmlPtr-&gt;tkwin) ){
          Tk_DestroyWindow(htmlPtr-&gt;tkwin);
          htmlPtr-&gt;clipwin = 0;
          break;
        }
        htmlPtr-&gt;tkwin = 0;
        Tcl_DeleteCommand(htmlPtr-&gt;interp, htmlPtr-&gt;zCmdName);
        Tcl_DeleteCommand(htmlPtr-&gt;interp, htmlPtr-&gt;zClipwin);
      }
      HtmlUnlock(htmlPtr);
      break;
    case ConfigureNotify:
      if( htmlPtr-&gt;tkwin!=0
       &amp;&amp; eventPtr-&gt;xconfigure.window==Tk_WindowId(htmlPtr-&gt;tkwin) 
      ){
        p = (XConfigureRequestEvent*)eventPtr;
        if( p-&gt;width != htmlPtr-&gt;realWidth ){
          redraw_needed = 1;
          htmlPtr-&gt;realWidth = p-&gt;width;
          TestPoint(0);
        }else{
          TestPoint(0);
        }
        if( p-&gt;height != htmlPtr-&gt;realHeight ){
          redraw_needed = 1;
          htmlPtr-&gt;realHeight = p-&gt;height;
          TestPoint(0);
        }else{
          TestPoint(0);
        }
        if( redraw_needed ){
          htmlPtr-&gt;flags |= RELAYOUT | VSCROLL | HSCROLL | RESIZE_CLIPWIN;
          HtmlRedrawEverything(htmlPtr);
          TestPoint(0);
        }else{
          TestPoint(0);
        }
      }
      break;
    case FocusIn:
      if( htmlPtr-&gt;tkwin!=0
       &amp;&amp; eventPtr-&gt;xfocus.window==Tk_WindowId(htmlPtr-&gt;tkwin)
       &amp;&amp; eventPtr-&gt;xfocus.detail != NotifyInferior
      ){
        htmlPtr-&gt;flags |= GOT_FOCUS | REDRAW_FOCUS;
        HtmlScheduleRedraw(htmlPtr);
        HtmlUpdateInsert(htmlPtr);
        TestPoint(0);
      }else{
        TestPoint(0);
      }
      break;
    case FocusOut:
      if( htmlPtr-&gt;tkwin!=0
       &amp;&amp; eventPtr-&gt;xfocus.window==Tk_WindowId(htmlPtr-&gt;tkwin)
       &amp;&amp; eventPtr-&gt;xfocus.detail != NotifyInferior
      ){
        htmlPtr-&gt;flags &amp;= ~GOT_FOCUS;
        htmlPtr-&gt;flags |= REDRAW_FOCUS;
        HtmlScheduleRedraw(htmlPtr);
        TestPoint(0);
      }else{
        TestPoint(0);
      }
      break;
  }
}
</t>
<t tx="ekr.20041214071955.190">@ ** The rendering and layout routines should call this routine in order to get ** a font structure. The iFont parameter specifies which of the N_FONT ** fonts should be obtained. The font is allocated if necessary. ** ** Because the -fontcommand callback can be invoked, this function can ** (in theory) cause the HTML widget to be changed arbitrarily or even ** deleted. Callers of this function much be prepared to be called ** recursively and/or to have the HTML widget deleted out from under ** them. This routine will return NULL if the HTML widget is deleted.
@c

Tk_Font HtmlGetFont(
  HtmlWidget *htmlPtr,        /* The HTML widget to which the font applies */
  int iFont                   /* Which font to obtain */
){
  Tk_Font toFree = 0;

  if( iFont&lt;0 ){ iFont = 0; TestPoint(0); }
  if( iFont&gt;=N_FONT ){ iFont = N_FONT - 1; CANT_HAPPEN; }

  /*
  ** If the font has previously been allocated, but the "fontValid" bitmap
  ** shows it is no longer valid, then mark it for freeing later.  We use
  ** a policy of allocate-before-free because Tk's font cache operates
  ** much more efficiently that way.
  */
  if( !FontIsValid(htmlPtr, iFont) &amp;&amp; htmlPtr-&gt;aFont[iFont]!=0 ){
    toFree = htmlPtr-&gt;aFont[iFont];
    htmlPtr-&gt;aFont[iFont] = 0;
    TestPoint(0);
  }

  /*
  ** If we need to allocate a font, first construct the font name then
  ** allocate it.
  */
  if( htmlPtr-&gt;aFont[iFont]==0 ){
    char name[200];     /* Name of the font */

    name[0] = 0;

    /* Run the -fontcommand if it is specified 
    */
    if( htmlPtr-&gt;zFontCommand &amp;&amp; htmlPtr-&gt;zFontCommand[0] ){
      int iFam;           /* The font family index.  Value between 0 and 7 */
      Tcl_DString str;    /* The command we'll execute to get the font name */
      char *zSep = "";    /* Separator between font attributes */
      int rc;             /* Return code from the font command */
      char zBuf[100];     /* Temporary buffer */

      Tcl_DStringInit(&amp;str);
      Tcl_DStringAppend(&amp;str, htmlPtr-&gt;zFontCommand, -1);
      sprintf(zBuf, " %d {", FontSize(iFont)+1);
      Tcl_DStringAppend(&amp;str,zBuf, -1);
      iFam = iFont / N_FONT_SIZE ;
      if( iFam &amp; 1 ){
        Tcl_DStringAppend(&amp;str,"bold",-1);
        zSep = " ";
      }
      if( iFam &amp; 2 ){
        Tcl_DStringAppend(&amp;str,zSep,-1);
        Tcl_DStringAppend(&amp;str,"italic",-1);
        zSep = " ";
      }
      if( iFam &amp; 4 ){
        Tcl_DStringAppend(&amp;str,zSep,-1);
        Tcl_DStringAppend(&amp;str,"fixed",-1);
      }
      Tcl_DStringAppend(&amp;str,"}",-1);
      HtmlLock(htmlPtr);
      rc = Tcl_GlobalEval(htmlPtr-&gt;interp, Tcl_DStringValue(&amp;str));
      Tcl_DStringFree(&amp;str);
      if( HtmlUnlock(htmlPtr) ){
        return NULL;
      }
      if( rc!=TCL_OK ){
        Tcl_AddErrorInfo(htmlPtr-&gt;interp, 
              "\n    (-fontcommand callback of HTML widget)");
        Tcl_BackgroundError(htmlPtr-&gt;interp);
      }else{
        sprintf(name,"%.100s", htmlPtr-&gt;interp-&gt;result);
      }
      Tcl_ResetResult(htmlPtr-&gt;interp);
    }

    /*
    ** If the -fontcommand failed or returned an empty string, or if
    ** there is no -fontcommand, then get the default font name.
    */
    if( name[0]==0 ){
      char *familyStr = "";
      int iFamily;
      int iSize;
      int size;

      iFamily = iFont / N_FONT_SIZE;
      iSize = iFont % N_FONT_SIZE + 1;
      switch( iFamily ){
        case 0:  familyStr = "helvetica -%d";             break;
        case 1:  familyStr = "helvetica -%d bold";        break;
        case 2:  familyStr = "helvetica -%d italic";      break;
        case 3:  familyStr = "helvetica -%d bold italic"; break;
        case 4:  familyStr = "courier -%d";               break;
        case 5:  familyStr = "courier -%d bold";          break;
        case 6:  familyStr = "courier -%d italic";        break;
        case 7:  familyStr = "courier -%d bold italic";   break;
        default: familyStr = "helvetica -14";             CANT_HAPPEN;
      }
      switch( iSize ){
        case 1:  size = 8;   break;
        case 2:  size = 10;  break;
        case 3:  size = 12;  break;
        case 4:  size = 14;  break;
        case 5:  size = 16;  break;
        case 6:  size = 18;  break;
        case 7:  size = 24;  break;
        default: size = 14;  CANT_HAPPEN;
      }
      sprintf(name, familyStr, size);
    }

    /* Get the named font
    */
    htmlPtr-&gt;aFont[iFont] = Tk_GetFont(htmlPtr-&gt;interp, htmlPtr-&gt;tkwin, name);
    if( htmlPtr-&gt;aFont[iFont]==0 ){
      Tcl_AddErrorInfo(htmlPtr-&gt;interp, 
              "\n    (trying to create a font named \"");
      Tcl_AddErrorInfo(htmlPtr-&gt;interp, name);
      Tcl_AddErrorInfo(htmlPtr-&gt;interp, "\" in the HTML widget)");
      Tcl_BackgroundError(htmlPtr-&gt;interp);
      htmlPtr-&gt;aFont[iFont] = 
       Tk_GetFont(htmlPtr-&gt;interp, htmlPtr-&gt;tkwin, "fixed");
    }
    if( htmlPtr-&gt;aFont[iFont]==0 ){
      Tcl_AddErrorInfo(htmlPtr-&gt;interp,
              "\n    (trying to create font \"fixed\" in the HTML widget)");
      Tcl_BackgroundError(htmlPtr-&gt;interp);
      htmlPtr-&gt;aFont[iFont] = 
       Tk_GetFont(htmlPtr-&gt;interp, htmlPtr-&gt;tkwin, "helvetica -12");
    }
    FontSetValid(htmlPtr, iFont);
    TestPoint(0);
  }

  /*
  ** Free the expired font, if any.
  */
  if( toFree!=0 ){
    Tk_FreeFont(toFree);
  }
  return htmlPtr-&gt;aFont[iFont];
}
</t>
<t tx="ekr.20041214071955.191">@ ** Compute the squared distance between two colors
@c

static float colorDistance(XColor *pA, XColor *pB){
  float x, y, z;

  x = 0.30 * (pA-&gt;red - pB-&gt;red);
  y = 0.61 * (pA-&gt;green - pB-&gt;green);
  z = 0.11 * (pA-&gt;blue - pB-&gt;blue);
  TestPoint(0);
  return x*x + y*y + z*z;
}
</t>
<t tx="ekr.20041214071955.192">@ ** This routine returns an index between 0 and N_COLOR-1 which indicates ** which XColor structure in the apColor[] array of htmlPtr should be ** used to describe the color specified by the given name.
@c

int HtmlGetColorByName(HtmlWidget *htmlPtr, char *zColor){
  XColor *pNew;
  int iColor;
  Tk_Uid name;
  int i, n;
  char zAltColor[16];

  /* Netscape accepts color names that are just HEX values, without
  ** the # up front.  This isn't valid HTML, but we support it for
  ** compatibility.
  */
  n = strlen(zColor);
  if( n==6 || n==3 || n==9 || n==12 ){
    for(i=0; i&lt;n; i++){
      if( !isxdigit(zColor[i]) ) break;
    }
    if( i==n ){
      sprintf(zAltColor,"#%s",zColor);
    }else{
      strcpy(zAltColor, zColor);
    }
    name = Tk_GetUid(zAltColor);
  }else{
    name = Tk_GetUid(zColor);
  }
  pNew = Tk_GetColor(htmlPtr-&gt;interp, htmlPtr-&gt;clipwin, name);
  if( pNew==0 ){
    return 0;      /* Color 0 is always the default */
  }

  iColor = GetColorByValue(htmlPtr, pNew);
  Tk_FreeColor(pNew);
  return iColor;
}
</t>
<t tx="ekr.20041214071955.193">@ ** Macros used in the computation of appropriate shadow colors.
@c

#define MAX_COLOR 65535
#define MAX(A,B)     ((A)&lt;(B)?(B):(A))
#define MIN(A,B)     ((A)&lt;(B)?(A):(B))

/*
** Check to see if the given color is too dark to be easily distinguished
** from black.
*/
static int isDarkColor(XColor *p){
  float x, y, z;

  x = 0.50 * p-&gt;red;
  y = 1.00 * p-&gt;green;
  z = 0.28 * p-&gt;blue;
  return (x*x + y*y + z*z)&lt;0.05*MAX_COLOR*MAX_COLOR;
}
</t>
<t tx="ekr.20041214071955.194">@ ** Given that the background color is iBgColor, figure out an ** appropriate color for the dark part of a 3D shadow.
@c

int HtmlGetDarkShadowColor(HtmlWidget *htmlPtr, int iBgColor){
  if( htmlPtr-&gt;iDark[iBgColor]==0 ){
    XColor *pRef, val;
    pRef = htmlPtr-&gt;apColor[iBgColor];
    if( isDarkColor(pRef) ){
      int t1, t2;
      t1 = MIN(MAX_COLOR,pRef-&gt;red*1.2);
      t2 = (pRef-&gt;red*3 + MAX_COLOR)/4;
      val.red = MAX(t1,t2);
      t1 = MIN(MAX_COLOR,pRef-&gt;green*1.2);
      t2 = (pRef-&gt;green*3 + MAX_COLOR)/4;
      val.green = MAX(t1,t2);
      t1 = MIN(MAX_COLOR,pRef-&gt;blue*1.2);
      t2 = (pRef-&gt;blue*3 + MAX_COLOR)/4;
      val.blue = MAX(t1,t2);
    }else{
      val.red = pRef-&gt;red*0.6;
      val.green = pRef-&gt;green*0.6;
      val.blue = pRef-&gt;blue*0.6;
    }
    htmlPtr-&gt;iDark[iBgColor] = GetColorByValue(htmlPtr, &amp;val) + 1;
  }
  return htmlPtr-&gt;iDark[iBgColor] - 1;
}
</t>
<t tx="ekr.20041214071955.195">@ ** Check to see if the given color is too light to be easily distinguished ** from white.
@c

static int isLightColor(XColor *p){
  return p-&gt;green&gt;=0.85*MAX_COLOR;
}
</t>
<t tx="ekr.20041214071955.196">@ ** Given that the background color is iBgColor, figure out an ** appropriate color for the bright part of the 3D shadow.
@c

int HtmlGetLightShadowColor(HtmlWidget *htmlPtr, int iBgColor){
  if( htmlPtr-&gt;iLight[iBgColor]==0 ){
    XColor *pRef, val;
    pRef = htmlPtr-&gt;apColor[iBgColor];
    if( isLightColor(pRef) ){
      val.red = pRef-&gt;red*0.9;
      val.green = pRef-&gt;green*0.9;
      val.blue = pRef-&gt;blue*0.9;
    }else{
      int t1, t2;
      t1 = MIN(MAX_COLOR,pRef-&gt;green*1.4);
      t2 = (pRef-&gt;green + MAX_COLOR)/2;
      val.green = MAX(t1,t2);
      t1 = MIN(MAX_COLOR,pRef-&gt;red*1.4);
      t2 = (pRef-&gt;red + MAX_COLOR)/2;
      val.red = MAX(t1,t2);
      t1 = MIN(MAX_COLOR,pRef-&gt;blue*1.4);
      t2 = (pRef-&gt;blue + MAX_COLOR)/2;
      val.blue = MAX(t1,t2);
    }
    htmlPtr-&gt;iLight[iBgColor] = GetColorByValue(htmlPtr, &amp;val) + 1;
  }
  return htmlPtr-&gt;iLight[iBgColor] - 1;
}
</t>
<t tx="ekr.20041214071955.197">@ ** Find a color integer for the color whose color components ** are given by pRef.
@c

LOCAL int GetColorByValue(HtmlWidget *htmlPtr, XColor *pRef){
  int i;
  float dist;
  float closestDist;
  int closest;
  int r, g, b;
# define COLOR_MASK  0xf800

  /* Search for an exact match */
  r = pRef-&gt;red &amp;= COLOR_MASK;
  g = pRef-&gt;green &amp;= COLOR_MASK;
  b = pRef-&gt;blue &amp;= COLOR_MASK;
  for(i=0; i&lt;N_COLOR; i++){
    XColor *p = htmlPtr-&gt;apColor[i];
    if( p &amp;&amp; (p-&gt;red &amp; COLOR_MASK)==r &amp;&amp; (p-&gt;green &amp; COLOR_MASK)==g 
    &amp;&amp; (p-&gt;blue &amp; COLOR_MASK)==b ){
      htmlPtr-&gt;colorUsed |= (1&lt;&lt;i);
      return i;
    }
  }

  /* No exact matches.  Look for a completely unused slot */
  for(i=N_PREDEFINED_COLOR; i&lt;N_COLOR; i++){
    if( htmlPtr-&gt;apColor[i]==0 ){
      htmlPtr-&gt;apColor[i] = Tk_GetColorByValue(htmlPtr-&gt;clipwin, pRef);
      htmlPtr-&gt;colorUsed |= (1&lt;&lt;i);
      return i;
    }
  }

  /* No empty slots.  Look for a slot that contains a color that
  ** isn't currently in use. */
  for(i=N_PREDEFINED_COLOR; i&lt;N_COLOR; i++){
    if( ((htmlPtr-&gt;colorUsed &gt;&gt; i) &amp; 1) == 0 ){
      Tk_FreeColor(htmlPtr-&gt;apColor[i]);
      htmlPtr-&gt;apColor[i] = Tk_GetColorByValue(htmlPtr-&gt;clipwin, pRef);
      htmlPtr-&gt;colorUsed |= (1&lt;&lt;i);
      return i;
    }
  }

  /* Ok, find the existing color that is closest to the color requested
  ** and use it. */
  closest = 0;
  closestDist = colorDistance(pRef, htmlPtr-&gt;apColor[0]);
  for(i=1; i&lt;N_COLOR; i++){
    dist = colorDistance(pRef, htmlPtr-&gt;apColor[i]);
    if( dist &lt; closestDist ){
      closestDist = dist;
      closest = i;
    }
  }
  return i;
}
</t>
<t tx="ekr.20041214071955.198">@ ** This routine searchs for a hyperlink beneath the coordinates x,y ** and returns a pointer to the HREF for that hyperlink. The text ** is held one of the markup.argv[] fields of the &lt;a&gt; markup.
@c

char *HtmlGetHref(HtmlWidget *htmlPtr, int x, int y){
  HtmlBlock *pBlock;
  HtmlElement *pElem;

  for(pBlock=htmlPtr-&gt;firstBlock; pBlock; pBlock=pBlock-&gt;pNext){
    if( pBlock-&gt;top &gt; y || pBlock-&gt;bottom &lt; y
     || pBlock-&gt;left &gt; x || pBlock-&gt;right &lt; x
    ){
      TestPoint(0);
      continue;
    }
    pElem = pBlock-&gt;base.pNext;
    if( (pElem-&gt;base.style.flags &amp; STY_Anchor)==0 ){ TestPoint(0); continue; }
    switch( pElem-&gt;base.type ){
      case Html_Text:
      case Html_Space:
      case Html_IMG:
        while( pElem &amp;&amp; pElem-&gt;base.type!=Html_A ){
          pElem = pElem-&gt;base.pPrev;
        }
        if( pElem==0 || pElem-&gt;base.type!=Html_A ){ break; }
        return HtmlMarkupArg(pElem,"href", 0);
      default:
        break;
    }
  }
  TestPoint(0);
  return 0;
}
</t>
<t tx="ekr.20041214071955.199">@ ** Change the "yOffset" field from its current value to the value given. ** This has the effect of scrolling the widget vertically.
@c

void HtmlVerticalScroll(HtmlWidget *htmlPtr, int yOffset){
  int inset;  /* The 3D border plus the pady */
  int h;      /* Height of the clipping window */
  int diff;   /* Difference between old and new offset */
  GC gc;      /* Graphics context used for copying */
  int w;      /* Width of text area */

  if( yOffset==htmlPtr-&gt;yOffset ){ TestPoint(0); return; }
  inset = htmlPtr-&gt;pady + htmlPtr-&gt;inset;
  h = htmlPtr-&gt;realHeight - 2*inset;
  if( (htmlPtr-&gt;flags &amp; REDRAW_TEXT)!=0
   || (htmlPtr-&gt;dirtyTop &lt; h &amp;&amp; htmlPtr-&gt;dirtyBottom &gt; 0)
   || htmlPtr-&gt;yOffset &gt; yOffset + (h - 30)
   || htmlPtr-&gt;yOffset &lt; yOffset - (h - 30)
  ){
    htmlPtr-&gt;yOffset = yOffset;
    htmlPtr-&gt;flags |= VSCROLL | REDRAW_TEXT;
    HtmlScheduleRedraw(htmlPtr);
    TestPoint(0);
    return;
  }
  diff = htmlPtr-&gt;yOffset - yOffset;
  gc = HtmlGetAnyGC(htmlPtr);
  w = htmlPtr-&gt;realWidth - 2*(htmlPtr-&gt;inset + htmlPtr-&gt;padx);
  htmlPtr-&gt;flags |= VSCROLL;
  htmlPtr-&gt;yOffset = yOffset;
  if( diff &lt; 0 ){
    XCopyArea(htmlPtr-&gt;display, 
            Tk_WindowId(htmlPtr-&gt;clipwin),    /* source */
            Tk_WindowId(htmlPtr-&gt;clipwin),    /* destination */
            gc, 
            0, -diff,                         /* source X, Y */
            w, h + diff,                      /* Width and height */
            0, 0);                            /* Destination X, Y */
    HtmlRedrawArea(htmlPtr, 0, h + diff, w, h);
    TestPoint(0);
  }else{
    XCopyArea(htmlPtr-&gt;display, 
            Tk_WindowId(htmlPtr-&gt;clipwin),    /* source */
            Tk_WindowId(htmlPtr-&gt;clipwin),    /* destination */
            gc, 
            0, 0,                             /* source X, Y */
            w, h - diff,                      /* Width and height */
            0, diff);                         /* Destination X, Y */
    HtmlRedrawArea(htmlPtr, 0, 0, w, diff);
    TestPoint(0);
  }
  /* HtmlMapControls(htmlPtr);*/
}
</t>
<t tx="ekr.20041214071955.200">@ ** Change the "xOffset" field from its current value to the value given. ** This has the effect of scrolling the widget horizontally.
@c

void HtmlHorizontalScroll(HtmlWidget *htmlPtr, int xOffset){
  if( xOffset==htmlPtr-&gt;xOffset ){ TestPoint(0); return; }
  htmlPtr-&gt;xOffset = xOffset;
  HtmlMapControls(htmlPtr);
  htmlPtr-&gt;flags |= HSCROLL | REDRAW_TEXT;
  HtmlScheduleRedraw(htmlPtr);
  TestPoint(0);
}
</t>
<t tx="ekr.20041214071955.201">@ ** The following array defines all possible widget command. The main ** widget command function just parses up the command line, then vectors ** control to one of the command service routines defined in the ** following array:
@c

static struct HtmlSubcommand {
  char *zCmd1;           /* First-level subcommand.  Required */
  char *zCmd2;           /* Second-level subcommand.  May be NULL */
  int minArgc;           /* Minimum number of arguments */
  int maxArgc;           /* Maximum number of arguments */
  char *zHelp;           /* Help string if wrong number of arguments */
  int (*xFunc)(HtmlWidget*,Tcl_Interp*,int,char**);  /* Cmd service routine */
} aSubcommand[] = {
  { "cget",      0,         3, 3, "CONFIG-OPTION",       HtmlCgetCmd },
  { "clear",     0,         2, 2, 0,                     HtmlClearCmd },
  { "configure", 0,         2, 0, "?ARGS...?",           HtmlConfigCmd },
  { "href",      0,         4, 4, "X Y",                 HtmlHrefCmd },
  { "index",     0,         3, 3, "INDEX",               HtmlIndexCmd },
  { "insert",    0,         3, 3, "INDEX",               HtmlInsertCmd },
  { "names",     0,         2, 2, 0,                     HtmlNamesCmd },
  { "parse",     0,         3, 3, "HTML-TEXT",           HtmlParseCmd },
  { "resolve",   0,         2, 0, "?URI ...?",           HtmlResolveCmd },
  { "selection", "clear",   3, 3, 0,                     HtmlSelectionClearCmd},
  { 0,           "set",     5, 5, "START END",           HtmlSelectionSetCmd },
  { "text",      "ascii",   5, 5, "START END",           0 },
  { 0,           "delete",  5, 5, "START END",           0 },
  { 0,           "html",    5, 5, "START END",           0 },
  { 0,           "insert",  5, 5, "INDEX TEXT",          0 },
  { "token",     "append",  5, 5, "TAG ARGUMENTS",       0 },
  { 0,           "delete",  4, 5, "INDEX ?INDEX?",       0 },
  { 0,           "find",    4, 6, "TAG ?before|after INDEX?", 0 },
  { 0,           "get",     4, 5, "INDEX ?INDEX?",       0 },
  { 0,           "handler", 4, 5, "TAG ?SCRIPT?",        HtmlTokenHandlerCmd },
  { 0,           "insert",  6, 6, "INDEX TAG ARGUMENTS", 0 },
  { 0,           "list",    5, 5, "START END",           HtmlTokenListCmd },
  { "xview",     0,         2, 5, "OPTIONS...",          HtmlXviewCmd },
  { "yview",     0,         2, 5, "OPTIONS...",          HtmlYviewCmd },
#ifdef DEBUG
  { "debug",     "dump",    5, 5, "START END",           HtmlDebugDumpCmd },
  { 0,           "testpt",  4, 4, "FILENAME",            HtmlDebugTestPtCmd },
#endif
};
#define nSubcommand (sizeof(aSubcommand)/sizeof(aSubcommand[0]))

/*
** This routine implements the command used by individual HTML widgets.
*/
static int HtmlWidgetCommand(
  ClientData clientData,	/* The HTML widget data structure */
  Tcl_Interp *interp,		/* Current interpreter. */
  int argc,			/* Number of arguments. */
  char **argv			/* Argument strings. */
){
  HtmlWidget *htmlPtr = (HtmlWidget*) clientData;
  size_t length;
  int c;
  int i;
  struct HtmlSubcommand *pCmd;

  if (argc &lt; 2) {
    Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
        " option ?arg arg ...?\"", 0);
    TestPoint(0);
    return TCL_ERROR;
  }
  c = argv[1][0];
  length = strlen(argv[1]);
  for(i=0, pCmd=aSubcommand; i&lt;nSubcommand; i++, pCmd++){
    if( pCmd-&gt;zCmd1==0 || c!=pCmd-&gt;zCmd1[0] 
    || strncmp(pCmd-&gt;zCmd1,argv[1],length)!=0 ){
      TestPoint(0);
      continue;
    }
    if( pCmd-&gt;zCmd2 ){
      int length2;
      int j;
      if( argc&lt;3 ){
        Tcl_AppendResult(interp, "wrong # args: should be \"",
          argv[0], " ", pCmd-&gt;zCmd1, " SUBCOMMAND ?OPTIONS...?", 0);
        TestPoint(0);
        return TCL_ERROR;
      }
      length2 = strlen(argv[2]);
      for(j=i; j&lt;nSubcommand &amp;&amp; (j==i || pCmd-&gt;zCmd1==0); j++, pCmd++){
        if( strncmp(pCmd-&gt;zCmd2,argv[2],length2)==0 ){
          TestPoint(0);
          break;
        }
      }
      if( j&gt;=nSubcommand || (j!=i &amp;&amp; aSubcommand[j].zCmd1!=0) ){
        Tcl_AppendResult(interp,"unknown subcommand \"", argv[2],
          "\" -- should be one of:", 0);
        for(j=i; j&lt;nSubcommand &amp;&amp; (j==i || aSubcommand[j].zCmd1==0); j++){
          Tcl_AppendResult(interp, " ", aSubcommand[j].zCmd2, 0);
          TestPoint(0);
        }
        return TCL_ERROR;
      }
    }
    if( argc&lt;pCmd-&gt;minArgc || (argc&gt;pCmd-&gt;maxArgc &amp;&amp; pCmd-&gt;maxArgc&gt;0) ){
      Tcl_AppendResult(interp,"wrong # args: should be \"", argv[0],
         " ", pCmd-&gt;zCmd1, 0);
      if( pCmd-&gt;zCmd2 ){
        Tcl_AppendResult(interp, " ", pCmd-&gt;zCmd2, 0);
        TestPoint(0);
      }
      if( pCmd-&gt;zHelp ){
        Tcl_AppendResult(interp, " ", pCmd-&gt;zHelp, 0);
        TestPoint(0);
      }
      Tcl_AppendResult(interp, "\"", 0);
      TestPoint(0);
      return TCL_ERROR;
    }
    if( pCmd-&gt;xFunc==0 ){
      Tcl_AppendResult(interp,"command not yet implemented", 0);
      TestPoint(0);
      return TCL_ERROR;
    }
    TestPoint(0);
    return (*pCmd-&gt;xFunc)(htmlPtr, interp, argc, argv);
  }
  Tcl_AppendResult(interp,"unknown command \"", argv[1], "\" -- should be "
    "one of:", 0);
  for(i=0; i&lt;nSubcommand; i++){
    if( aSubcommand[i].zCmd1==0 || aSubcommand[i].zCmd1[0]=='_' ){ 
      TestPoint(0); 
      continue;
    }
    Tcl_AppendResult(interp, " ", aSubcommand[i].zCmd1, 0);
    TestPoint(0);
  }
  TestPoint(0);
  return TCL_ERROR;
}
</t>
<t tx="ekr.20041214071955.202">@ ** The following routine implements the Tcl "html" command. This command ** is used to create new HTML widgets only. After the widget has been ** created, it is manipulated using the widget command defined above.
@c

static int HtmlCommand(
  ClientData clientData,	/* Main window */
  Tcl_Interp *interp,		/* Current interpreter. */
  int argc,			/* Number of arguments. */
  char **argv			/* Argument strings. */
){
  int n, c;
  char *z;

  if (argc &lt; 2) {
    Tcl_AppendResult(interp, "wrong # args: should be \"",
         argv[0], " pathName ?options?\"", (char *) NULL);
    return TCL_ERROR;
  }
  z = argv[1];
  n = strlen(z);
  c = z[0];

  /* If the first argument begins with ".", then it must be the
  ** name of a new window the user wants to create.
  */
  if( argv[1][0]=='.' ){
    HtmlWidget *htmlPtr;
    Tk_Window new;
    Tk_Window clipwin;
    char *zClipwin;
    Tk_Window tkwin = (Tk_Window)clientData;
    static int varId = 1;        /* Used to construct unique names */

    new = Tk_CreateWindowFromPath(interp, tkwin, argv[1], (char *) NULL);
    if (new == NULL) {
       return TCL_ERROR;
    }
    zClipwin = HtmlAlloc( strlen(argv[1]) + 3 );
    if( zClipwin==0 ){
      Tk_DestroyWindow(new);
      return TCL_ERROR;
    }
    sprintf(zClipwin,"%s.x",argv[1]);
    clipwin = Tk_CreateWindowFromPath(interp, new, zClipwin, 0);
    if( clipwin==0 ){
      Tk_DestroyWindow(new);
      HtmlFree(zClipwin);
      return TCL_ERROR;
    }

    htmlPtr = HtmlAlloc(sizeof(HtmlWidget) + strlen(argv[1]) + 1);
    memset(htmlPtr, 0, sizeof(HtmlWidget));
    htmlPtr-&gt;tkwin = new;
    htmlPtr-&gt;clipwin = clipwin;
    htmlPtr-&gt;zClipwin = zClipwin;
    htmlPtr-&gt;display = Tk_Display(new);
    htmlPtr-&gt;interp = interp;
    htmlPtr-&gt;zCmdName = (char*)&amp;htmlPtr[1];
    strcpy(htmlPtr-&gt;zCmdName, argv[1]);
    htmlPtr-&gt;relief = TK_RELIEF_FLAT;
    htmlPtr-&gt;dirtyLeft = LARGE_NUMBER;
    htmlPtr-&gt;dirtyTop = LARGE_NUMBER;
    htmlPtr-&gt;flags = RESIZE_CLIPWIN;
    htmlPtr-&gt;varId = varId++;
    Tcl_CreateCommand(interp, htmlPtr-&gt;zCmdName,
      HtmlWidgetCommand, (ClientData)htmlPtr, HtmlCmdDeletedProc);
    Tcl_CreateCommand(interp, htmlPtr-&gt;zClipwin,
      HtmlWidgetCommand, (ClientData)htmlPtr, HtmlCmdDeletedProc);
    
    Tk_SetClass(new,"Html");
    Tk_SetClass(clipwin,"HtmlClip");
    Tk_CreateEventHandler(htmlPtr-&gt;tkwin,
         ExposureMask|StructureNotifyMask|FocusChangeMask,
         HtmlEventProc, (ClientData) htmlPtr);
    Tk_CreateEventHandler(htmlPtr-&gt;clipwin,
         ExposureMask|StructureNotifyMask,
         HtmlEventProc, (ClientData) htmlPtr);
    if (ConfigureHtmlWidget(interp, htmlPtr, argc-2, argv+2, 0, 1) != TCL_OK) {
       goto error;
    }
    interp-&gt;result = Tk_PathName(htmlPtr-&gt;tkwin);
    return TCL_OK;

    error:
    Tk_DestroyWindow(htmlPtr-&gt;tkwin);
    return TCL_ERROR;
  }

  /*    html reformat  $from  $to  $text
  **
  ** Convert the format of text.
  */
  if( c=='r' &amp;&amp; strncmp(z,"reformat",n)==0 ){
    if( argc!=5 ){
      Tcl_AppendResult(interp, "wrong # args: should be \"",
           argv[0], " reformat FROM TO TEXT", (char *) NULL);
      return TCL_ERROR;
    }
    Tcl_AppendResult(interp, "not yet implemented", 0);
    return TCL_ERROR;
  }else


  /*    html urljoin  $scheme $authority $path $query $fragment
  **
  ** Merge together the parts of a URL into a single value URL.
  */
  if( c=='u' &amp;&amp; strncmp(z,"urljoin",n)==0 ){
    if( argc!=7 ){
      Tcl_AppendResult(interp, "wrong # args: should be \"",
           argv[0], " url join SCHEME AUTHORITY PATH QUERY FRAGMENT\"", 0);
      return TCL_ERROR;
    }
    Tcl_AppendResult(interp, "not yet implemented", 0);
    return TCL_ERROR;
  }else


  /*    html urlsplit $url
  **
  ** Split a URL into a list of its parts.
  */
  if( c=='u' &amp;&amp; strncmp(z,"urlsplit",n)==0 ){
    if( argc!=3 ){
      Tcl_AppendResult(interp, "wrong # args: should be \"",
           argv[0], " url split URL\"", 0);
      return TCL_ERROR;
    }
    Tcl_AppendResult(interp, "not yet implemented", 0);
    return TCL_ERROR;
  }else

  /* No match.  Report an error.
  */
  {
    Tcl_AppendResult(interp, "unknown command \"", z, "\": should be "
      "a window name or one of: "
      "reformat urljoin urlsplit", 0);
    return TCL_ERROR;
  }
  return TCL_OK;   
}
</t>
<t tx="ekr.20041214071955.203">@ ** The following mess is used to define DLL_EXPORT. DLL_EXPORT is ** blank except when we are building a Windows95/NT DLL from this ** library. Some special trickery is necessary to make this wall ** work together with makeheaders.
@c

#if INTERFACE
#define DLL_EXPORT
#endif
#if defined(USE_TCL_STUBS) &amp;&amp; defined(__WIN32__)
# undef DLL_EXPORT
# define DLL_EXPORT __declspec(dllexport)
#endif

/*
** This routine is used to register the "html" command with the
** Tcl interpreter.  This is the only routine in this file with
** external linkage.
*/
DLL_EXPORT int Tkhtml_Init(Tcl_Interp *interp){
#ifdef USE_TCL_STUBS
  if( Tcl_InitStubs(interp,"8.0",0)==0 ){
    return TCL_ERROR;
  }
  if( Tk_InitStubs(interp,"8.0",0)==0 ){
    return TCL_ERROR;
  }
#endif
  Tcl_CreateCommand(interp,"html", HtmlCommand, 
      Tk_MainWindow(interp), 0);
  /* Tcl_GlobalEval(interp,HtmlLib); */
#ifdef DEBUG
  Tcl_LinkVar(interp, "HtmlTraceMask", (char*)&amp;HtmlTraceMask, TCL_LINK_INT);
#endif
  Tcl_PkgProvide(interp, HTML_PKGNAME, HTML_PKGVERSION);
  return TCL_OK;
}
</t>
<t tx="ekr.20041214071955.204">@language c
static char const rcsid[] = "@(#) $Id: htmlwish.c,v 1.4 2000/01/17 13:55:11 drh Exp $";
/* Make a "wish" that includes the html widget. */
&lt;&lt; htmlwish #includes &gt;&gt;
@others
</t>
<t tx="ekr.20041214071955.205">#include "appinit.h"
</t>
<t tx="ekr.20041214071955.206">int Et_AppInit(Tcl_Interp *interp){
  extern int Tkhtml_Init(Tcl_Interp*);
  Tkhtml_Init(interp);
  return TCL_OK;
}
</t>
<t tx="ekr.20041214073047">// Every element contains at least this much information:

struct HtmlBaseElement {
  HtmlElement *pNext;         /* Next input token in a list of them all */
  HtmlElement *pPrev;         /* Previous token in a list of them all */
  HtmlStyle style;            /* The rendering style for this token */
  Html_u8 type;               /* The token type. */
  Html_u8 flags;              /* The HTML_ flags below */
  Html_16 count;              /* Various uses, depending on "type" */
};

// Bitmasks for the "flags" field of the HtmlBaseElement

#define HTML_Visible   0x01     /* This element produces "ink" */
#define HTML_NewLine   0x02     /* type==Html_Space and ends with newline */
#define HTML_Selected  0x04     /* Some or all of this Html_Block is selected */
                                /* Used by Html_Block elements only. */</t>
<t tx="ekr.20041214073047.1">/*
** Each text element holds additional information as show here.  Notice
** that extra space is allocated so that zText[] will be large enough
** to hold the complete text of the element.  X and y coordinates are
** relative to the virtual canvas.  The y coordinate refers to the
** baseline.
*/
struct HtmlTextElement {
  HtmlBaseElement base;       /* All the base information */
  Html_32 y;                  /* y coordinate where text should be rendered */
  Html_16 x;                  /* x coordinate where text should be rendered */
  Html_16 w;                  /* width of this token in pixels */
  Html_u8 ascent;             /* height above the baseline */
  Html_u8 descent;            /* depth below the baseline */
  Html_u8 spaceWidth;         /* Width of one space in the current font */
  char zText[1];              /* Text for this element.  Null terminated */
};
</t>
<t tx="ekr.20041214073047.2">// Each space element is represented like this:

struct HtmlSpaceElement {
  HtmlBaseElement base;       /* All the base information */
  Html_16 w;                  /* Width of a single space in current font */
  Html_u8 ascent;             /* height above the baseline */
  Html_u8 descent;            /* depth below the baseline */
};

</t>
<t tx="ekr.20041214073047.3">/*
** Most markup uses this structure.  Some markup extends this structure
** with additional information, but most use it as a base, at the very
** least. 
**
** If the markup doesn't have arguments (the "count" field of
** HtmlBaseElement is 0) then the extra "argv" field of this structure
** is not allocated and should not be used.
*/
struct HtmlMarkupElement {
  HtmlBaseElement base;
  char **argv;
};

</t>
<t tx="ekr.20041214073047.4">/* Each &lt;td&gt; or &lt;th&gt; markup is represented by an instance of the 
** following structure.
**
** Drawing for a cell is a sunken 3D border with the border width given
** by the borderWidth field in the associated &lt;table&gt; structure.
*/
struct HtmlCell {
  HtmlMarkupElement markup;
  Html_16 rowspan;          /* Number of rows spanned by this cell */
  Html_16 colspan;          /* Number of columns spanned by this cell */
  Html_16 x;                /* X coordinate of left edge of border */
  Html_16 w;                /* Width of the border */
  Html_32 y;                /* Y coordinate of top of border indentation */
  Html_32 h;                /* Height of the border */
  HtmlElement *pTable;      /* Pointer back to the &lt;table&gt; */
  HtmlElement *pEnd;        /* Element that ends this cell */
};</t>
<t tx="ekr.20041214073047.5">/*
** The maximum number of columns allowed in a table.  Any columns beyond
** this number are ignored.
*/
#define HTML_MAX_COLUMNS 40

/*
** This structure is used for each &lt;table&gt; element.
**
** In the minW[] and maxW[] arrays, the [0] element is the overall
** minimum and maximum width, including cell padding, spacing and 
** the "hspace".  All other elements are the minimum and maximum 
** width for the contents of individual cells without any spacing or
** padding.
*/
struct HtmlTable {
  HtmlMarkupElement markup;
  Html_u8 borderWidth;           /* Width of the border */
  Html_u8 nCol;                  /* Number of columns */
  Html_u16 nRow;                 /* Number of rows */
  Html_32 y;                     /* top edge of table border */
  Html_32 h;                     /* height of the table border */
  Html_16 x;                     /* left edge of table border */
  Html_16 w;                     /* width of the table border */
  int minW[HTML_MAX_COLUMNS+1];  /* minimum width of each column */
  int maxW[HTML_MAX_COLUMNS+1];  /* maximum width of each column */
};
</t>
<t tx="ekr.20041214073047.6">/* This structure is used for &lt;/table&gt;, &lt;/td&gt;, &lt;tr&gt;, &lt;/tr&gt; 
** and &lt;/th&gt; elements.  It points back to the &lt;table&gt; element 
** that began the table.  It is also used by &lt;/a&gt; to point back
** to the original &lt;a&gt;.  I'll probably think of other uses before
** all is said and done...
*/
struct HtmlRef {
  HtmlMarkupElement markup;
  HtmlElement *pOther;         /* Pointer to some other Html element */
};

</t>
<t tx="ekr.20041214073047.7">/*
** An instance of the following structure is used to represent
** each &lt;LI&gt; markup.
*/
struct HtmlLi {
  HtmlMarkupElement markup;
  Html_u8 type;     /* What type of list is this? */
  Html_u8 ascent;   /* height above the baseline */
  Html_u8 descent;  /* depth below the baseline */
  Html_16 cnt;      /* Value for this element (if inside &lt;OL&gt;) */
  Html_16 x;        /* X coordinate of the bullet */
  Html_32 y;        /* Y coordinate of the bullet */
};

/*
** The .type field of an HtmlLi or HtmlListStart structure can take on 
** any of the following values to indicate what type of bullet to draw.
** The value in HtmlLi will take precedence over the value in HtmlListStart
** if the two values differ.
*/
#define LI_TYPE_Undefined 0     /* If in HtmlLi, use the HtmlListStart value */
#define LI_TYPE_Bullet1   1     /* A solid circle */
#define LI_TYPE_Bullet2   2     /* A hollow circle */
#define LI_TYPE_Bullet3   3     /* A hollow square */
#define LI_TYPE_Enum_1    4     /* Arabic numbers */
#define LI_TYPE_Enum_A    5     /* A, B, C, ... */
#define LI_TYPE_Enum_a    6     /* a, b, c, ... */
#define LI_TYPE_Enum_I    7     /* Capitalized roman numerals */
#define LI_TYPE_Enum_i    8     /* Lower-case roman numerals */
</t>
<t tx="ekr.20041214073047.8">/*
** An instance of this structure is used for &lt;UL&gt; or &lt;OL&gt;
** markup.
*/
struct HtmlListStart {
  HtmlMarkupElement markup;
  Html_u8 type;            /* One of the LI_TYPE_ defines above */
  Html_u8 compact;         /* True if the COMPACT flag is present */
  Html_u16 cnt;            /* Next value for &lt;OL&gt; */
  Html_u16 width;          /* How much space to allow for indentation */
  HtmlElement *pPrev;      /* Next higher level list, or NULL */
};

</t>
<t tx="ekr.20041214073047.9">/*
** Information about each image on the HTML widget is held in an
** instance of the following structure.  A pointer to this structure
** is the clientData for the image change callback.  All image structures
** are held on a list attached to the main widget structure.
**
** This structure is NOT an element.  The &lt;IMG&gt; element is represented
** by an HtmlImageMarkup structure below.  There is one HtmlImageMarkup
** for each &lt;IMG&gt; in the source HTML.  There is one of these structures
** for each unique image loaded.  (If two &lt;IMG&gt; specify the same image,
** there are still two HtmlImageMarkup structures but only one
** HtmlImage structure that is shared between them.)
*/
struct HtmlImage {
  HtmlWidget *htmlPtr;     /* The owner of this image */
  Tk_Image image;          /* The Tk image token */
  Html_32 w;               /* Requested width of this image (0 if none) */
  Html_32 h;               /* Requested height of this image (0 if none) */
  char *zUrl;              /* The URL for this image. */
  char *zWidth, *zHeight;  /* Width and height in the &lt;img&gt; markup. */
  HtmlImage *pNext;        /* Next image on the list */
  HtmlElement *pList;      /* List of all &lt;IMG&gt; markups that use this 
                           ** same image */
};

/* Each &lt;img&gt; markup is represented by an instance of the 
** following structure.
**
** If pImage==0, then we use the alternative text in zAlt.
*/
struct HtmlImageMarkup {
  HtmlMarkupElement markup;
  Html_u8 align;          /* Alignment.  See IMAGE_ALIGN_ defines below */
  Html_u8 textAscent;     /* Ascent of text font in force at the &lt;IMG&gt; */
  Html_u8 textDescent;    /* Descent of text font in force at the &lt;IMG&gt; */
  Html_u8 redrawNeeded;   /* Need to redraw this image because the image
                          ** content changed. */
  Html_16 h;              /* Actual height of the image */
  Html_16 w;              /* Actual width of the image */
  Html_16 ascent;         /* How far image extends above "y" */
  Html_16 descent;        /* How far image extends below "y" */
  Html_16 x;              /* X coordinate of left edge of the image */
  Html_32 y;              /* Y coordinate of image baseline */
  char *zAlt;             /* Alternative text */
  HtmlImage *pImage;      /* Corresponding HtmlImage structure */
  HtmlElement *pNext;     /* Next markup using the same HtmlImage structure */
};

/*
** Allowed alignments for images.  These represent the allowed arguments
** to the "align=" field of the &lt;IMG&gt; markup.
*/
#define IMAGE_ALIGN_Bottom        0
#define IMAGE_ALIGN_Middle        1
#define IMAGE_ALIGN_Top           2
#define IMAGE_ALIGN_TextTop       3
#define IMAGE_ALIGN_AbsMiddle     4
#define IMAGE_ALIGN_AbsBottom     5
#define IMAGE_ALIGN_Left          6
#define IMAGE_ALIGN_Right         7
</t>
<t tx="ekr.20041214073047.10">/*
** All kinds of form markup, including &lt;INPUT&gt;, &lt;TEXTAREA&gt; and &lt;SELECT&gt;
** are represented by instances of the following structure.
**
** (later...)  We also use this for the &lt;APPLET&gt; markup.  That way,
** the window we create for an &lt;APPLET&gt; responds to the HtmlMapControls()
** and HtmlUnmapControls() function calls.  For an &lt;APPLET&gt;, the
** pForm field is NULL.  (Later still...) &lt;EMBED&gt; works just like
** &lt;APPLET&gt; so it uses this structure too.
*/
struct HtmlInput {
  HtmlMarkupElement markup;
  HtmlElement *pForm;      /* The &lt;FORM&gt; to which this belongs */
  HtmlElement *pNext;      /* Next element in a list of all input elements */
  Tk_Window tkwin;         /* The window that implements this control */
  HtmlWidget *htmlPtr;     /* The whole widget.  Needed by geometry callbacks */
  HtmlElement *pEnd;       /* End tag for &lt;TEXTAREA&gt;, etc. */
  Html_32  y;              /* Baseline for this input element */
  Html_u16 x;              /* Left edge */
  Html_u16 w, h;           /* Width and height of this control */
  Html_u8 padLeft;         /* Extra padding on left side of the control */
  Html_u8 align;           /* One of the IMAGE_ALIGN_xxx  types */
  Html_u8 textAscent;      /* Ascent for the current font */
  Html_u8 textDescent;     /* descent for the current font */
  Html_u8 type;            /* What type of input is this? */
  Html_u8 sized;           /* True if this input has been sized already */
  Html_u16 cnt;            /* Used to derive widget name. 0 if no widget */
};

/*
** An input control can be one of the following types.  See the
** comment about &lt;APPLET&gt; on the HtmlInput structure insight into
** INPUT_TYPE_Applet.
*/
#define INPUT_TYPE_Unknown      0
#define INPUT_TYPE_Checkbox     1
#define INPUT_TYPE_File         2
#define INPUT_TYPE_Hidden       3
#define INPUT_TYPE_Image        4
#define INPUT_TYPE_Password     5
#define INPUT_TYPE_Radio        6
#define INPUT_TYPE_Reset        7
#define INPUT_TYPE_Select       8
#define INPUT_TYPE_Submit       9
#define INPUT_TYPE_Text        10
#define INPUT_TYPE_TextArea    11
#define INPUT_TYPE_Applet      12


</t>
<t tx="ekr.20041214073047.11">/*
** There can be multiple &lt;FORM&gt; entries on a single HTML page.
** Each one must be given a unique number for identification purposes,
** and so we can generate unique state variable names for radiobuttons,
** checkbuttons, and entry boxes.
*/
struct HtmlForm {
  HtmlMarkupElement markup;
  Html_u16 id;             /* Unique number assigned to this form */
};

</t>
<t tx="ekr.20041214073047.12">/*
** Information used by a &lt;HR&gt; markup
*/
struct HtmlHr {
  HtmlMarkupElement markup;
  Html_32  y;              /* Baseline for this input element */
  Html_u16 x;              /* Left edge */
  Html_u16 w, h;           /* Width and height of this control */
  Html_u8 is3D;            /* Is it drawn 3D? */
};
</t>
<t tx="ekr.20041214073047.13">/*
** Information used by a &lt;A&gt; markup
*/
struct HtmlAnchor {
  HtmlMarkupElement markup;
  Html_32  y;              /* Top edge for this element */
};

</t>
<t tx="ekr.20041214073047.14">/*
** Information about the &lt;SCRIPT&gt; markup.  The parser treats &lt;SCRIPT&gt;
** specially.  All text between &lt;SCRIPT&gt; and &lt;/SCRIPT&gt; is captured and
** is pointed to by the zScript field of this structure.
**
** Note that zScript is not null-terminated.   Instead, zScript just
** points to a spot in the zText field of the HtmlWidget structure.
** The nScript field determines how long the script is.
*/
struct HtmlScript {
  HtmlMarkupElement markup;
  char *zScript;           /* Complete text of this script */
  int nScript;             /* Number of characters of text */
}

</t>
<t tx="ekr.20041214073047.15">/*
** A block is a single unit of display information.  This can be
** one or more text elements, or the border of table, or an
** image, etc.
**
** Blocks are used to improve display speed and to improve the
** speed of linear searchs through the token list.  A single
** block will typically contain enough information to display
** a dozen or more Text and Space elements all with a single
** call to Tk_DrawChars().  The blocks are linked together on
** their own list, so we can search them much faster then elements
** (since there are fewer of them.)
**
** Of course, you can construct pathological HTML that has as
** many Blocks as it has normal tokens.  But you haven't lost
** anything.  Using blocks just speeds things up in the common
** case.
**
** Much of the information needed for display is held in the
** original HtmlElement structures.  "base.pNext" points to the first
** structure in the list which can be used to find the "style"
** "x" and "y".
**
** If n==0, then "base.pNext" might point to a special HtmlElement that
** defines some other kind of drawing, like &lt;LI&gt; or &lt;IMG&gt; or &lt;INPUT&gt;.
*/
struct HtmlBlock {
  HtmlBaseElement base;      /* Superclass.  Must be first */
  char *z;                   /* Space to hold text when n&gt;0 */
  int top, bottom;           /* Extremes of y coordinates */
  Html_u16 left, right;      /* Left and right boundry of this object */
  Html_u16 n;                /* Number of characters in z[] */
  HtmlBlock *pPrev, *pNext;  /* Linked list of all Blocks */
};

/*
** Linux doesn't have a stricmp() function.
*/
#ifndef HAVE_STRICMP
# define stricmp strcasecmp
# define strnicmp strncasecmp
#endif

</t>
<t tx="ekr.20041214073047.16">/*
** A stack of these structures is used to keep track of nested font and
** style changes.  This allows us to easily revert to the previous style
** when we encounter and end-tag like &lt;/em&gt; or &lt;/h3&gt;.
**
** This stack is used to keep track of the current style while walking
** the list of elements.  After all elements have been assigned a style,
** the information in this stack is no longer used.
*/
struct HtmlStyleStack {
  HtmlStyleStack *pNext;   /* Next style on the stack */
  int type;                /* A markup that ends this style. Ex: Html_EndEM */
  HtmlStyle style;         /* The currently active style. */
}


</t>
<t tx="ekr.20041214073047.17">/*
** A stack of the following structures is used to remember the
** left and right margins within a layout context.
*/
struct HtmlMargin {
  int indent;          /* Size of the current margin */
  int bottom;          /* Y value at which this margin expires */
  int tag;             /* Markup that will cancel this margin */
  HtmlMargin *pNext;   /* Previous margin */
};

/*
** How much space (in pixels) used for a single level of indentation due
** to a &lt;UL&gt; or &lt;DL&gt; or &lt;BLOCKQUOTE&gt;, etc.
*/
#define HTML_INDENT 36

</t>
<t tx="ekr.20041214073047.18">/*
** A layout context holds all state information used by the layout
** engine.
*/
struct HtmlLayoutContext {
  HtmlWidget *htmlPtr;          /* The html widget undergoing layout */
  HtmlElement *pStart;          /* Start of elements to layout */
  HtmlElement *pEnd;            /* Stop when reaching this element */
  int headRoom;                 /* Extra space wanted above this line */
  int top;                      /* Absolute top of drawing area */
  int bottom;                   /* Bottom of previous line */
  int left, right;              /* Left and right extremes of drawing area */
  int pageWidth;                /* Width of the layout field, including
                                ** the margins */
  int maxX, maxY;               /* Maximum X and Y values of paint */
  HtmlMargin *leftMargin;       /* Stack of left margins */
  HtmlMargin *rightMargin;      /* Stack of right margins */
};

/*
** With 28 different fonts and 16 colors, we could in principle have
** as many as 448 different GCs.  But in practice, a single page of
** HTML will typically have much less than this.  So we won't try to
** keep all GCs on hand.  Instead, We'll keep around the most recently
** used GCs and allocate new ones as necessary.
**
** The following structure is used to build a cache of GCs in the
** main widget structure.
*/
#define N_CACHE_GC 16
struct GcCache {
  GC gc;                /* The graphics context */
  Html_u8 font;         /* Font used for this context */
  Html_u8 color;        /* Color used for this context */
  Html_u8 index;        /* Index used for LRU replacement */
};

</t>
<t tx="ekr.20041214073047.19">/*
** An HtmlIndex is a reference to a particular character within a
** particular Text or Space token.  
*/
struct HtmlIndex {
  HtmlElement *p;      /* The token containing the character */
  int i;               /* Index of the character */
};

</t>
<t tx="ekr.20041214073047.20">/*
** A single instance of the following structure (together with various
** other structures to which this structure points) contains complete 
** state information for a single HTML widget.  The clientData for
** the widget command is a pointer to this structure.
**
** The HTML widget is really a mega-widget.  It consists of two nested
** windows.  The outer window (tkwin) contains the focus highlight border,
** the 3D border and the padding between the border and the text.  All
** text that results from the HTML is drawn into the clipping window
** (clipwin).  The clipping window is a child of the main
** window and has the name "x".  We have to use a clipping window so
** that subwindows required by &lt;FORM&gt; will be clipped properly and won't
** overlap with the borders.
**
** Two primary coordinate systems are used in this widget.
**
**   Window coordinates      In this system, (0,0) is the upper left-hand
**                           corner of the clipping window.  This coordinates
**                           apply only to objects which is visible on screen.
**
**   Virtual canvas          The virtual canvas is an imaginary canvas holding
**                           the entire document.  Typically, part of the
**                           virtual canvas will show thru the clipping 
**                           window to become visible.  The mapping from
**                           window to virtual canvas coordinates is
**                           governed by the "xOffset" and "yOffset" fields
**                           of the widget structure.
**
** 
*/
struct HtmlWidget {
  Tk_Window tkwin;              /* The main window for this widget */
  Tk_Window clipwin;            /* The clipping window in which all text is
                                ** rendered. */
  char *zClipwin;               /* Name of the clipping window. */
  Display *display;             /* The X11 Server that contains tkwin */
  Tcl_Interp *interp;           /* The interpreter in which the widget lives */
  char *zCmdName;               /* Name of the command */
  HtmlElement *pFirst;          /* First HTML token on a list of them all */
  HtmlElement *pLast;           /* Last HTML token on the list */
  int nToken;                   /* Number of HTML tokens on the list.
                                 * Html_Block tokens don't count. */
  HtmlElement *lastSized;       /* Last HTML element that has been sized */
  HtmlElement *nextPlaced;      /* Next HTML element that needs to be 
                                 * positioned on canvas. */
  HtmlBlock *firstBlock;        /* List of all HtmlBlock tokens */
  HtmlBlock *lastBlock;         /* Last HtmlBlock in the list */
  HtmlElement *firstInput;      /* First &lt;INPUT&gt; element */
  HtmlElement *lastInput;       /* Last &lt;INPUT&gt; element */
  int nInput;                   /* The number of &lt;INPUT&gt; elements */
  int nForm;                    /* The number of &lt;FORM&gt; elements */
  int varId;                    /* Used to construct a unique name for a
                                ** global array used by &lt;INPUT&gt; elements */

  /*
   * Information about the selected region of text
   */
  HtmlIndex selBegin;           /* Start of the selection */
  HtmlIndex selEnd;             /* End of the selection */
  HtmlBlock *pSelStartBlock;    /* Block in which selection starts */
  Html_16 selStartIndex;        /* Index in pSelStartBlock of first selected
                                 * character */
  Html_16 selEndIndex;          /* Index of last selecte char in pSelEndBlock */
  HtmlBlock *pSelEndBlock;      /* Block in which selection ends */

  /*
   * Information about the insertion cursor 
   */
  int insOnTime;                /* How long the cursor states one (millisec) */
  int insOffTime;               /* How long it is off (milliseconds) */
  int insStatus;                /* Is it visible? */
  Tcl_TimerToken insTimer;      /* Timer used to flash the insertion cursor */
  HtmlIndex ins;                /* The insertion cursor position */
  HtmlBlock *pInsBlock;         /* The HtmlBlock containing the cursor */
  int insIndex;                 /* Index in pInsBlock of the cursor */

  /*
   * The following fields hold state information used by
   * the tokenizer.
   */
  char *zText;                  /* Complete text of the unparsed HTML */
  int nText;                    /* Number of characters in zText */
  int nAlloc;                   /* Space allocated for zText */
  int nComplete;                /* How much of zText has actually been
                                 * converted into tokens */
  int iCol;                     /* The column in which zText[nComplete]
                                 * occurs.  Used to resolve tabs in input */
  int iPlaintext;               /* If not zero, this is the token type that
                                 * caused us to go into plaintext mode.  One
                                 * of Html_PLAINTEXT, Html_LISTING or
                                 * Html_XMP */
  HtmlScript *pScript;            /* &lt;SCRIPT&gt; currently being parsed */
  char *zHandler[Html_TypeCount]; /* If not NULL, this is a TCL routine that
                                 * is used to process tokens of the given 
                                 * type */
  /*
   * These fields hold state information used by the HtmlAddStyle routine.
   * We have to store this state information here since HtmlAddStyle
   * operates incrementally.  This information must be carried from
   * one incremental execution to the next.
   */
  HtmlStyleStack *styleStack;   /* The style stack */
  int paraAlignment;            /* Justification associated with &lt;p&gt; */
  int rowAlignment;             /* Justification associated with &lt;tr&gt; */
  int anchorFlags;              /* Style flags associated with &lt;A&gt;...&lt;/A&gt; */
  int inDt;                     /* Style flags associated with &lt;DT&gt;...&lt;/DT&gt; */
  int inTr;                     /* True if within &lt;tr&gt;..&lt;/tr&gt; */
  int inTd;                     /* True if within &lt;td&gt;..&lt;/td&gt; or &lt;th&gt;..&lt;/th&gt; */
  HtmlElement *anchorStart;     /* Most recent &lt;a href=...&gt; */
  HtmlElement *formStart;       /* Most recent &lt;form&gt; */
  HtmlElement *formElemStart;   /* Most recent &lt;textarea&gt; or &lt;select&gt; */
  HtmlElement *innerList;       /* The inner most &lt;OL&gt; or &lt;UL&gt; */

  /*
   * These fields are used to hold the state of the layout engine.
   * Because the layout is incremental, this state must be held for
   * the life of the widget.
   */
  HtmlLayoutContext layoutContext;

  /*
   * Information used when displaying the widget:
   */
  Tk_3DBorder border;		/* Background color */
  int borderWidth;		/* Width of the border. */
  int relief;			/* 3-D effect: TK_RELIEF_RAISED, etc. */
  int highlightWidth;		/* Width in pixels of highlight to draw
				 * around widget when it has the focus.
				 * &lt;= 0 means don't draw a highlight. */
  XColor *highlightBgColorPtr;  /* Color for drawing traversal highlight
				 * area when highlight is off. */
  XColor *highlightColorPtr;	/* Color for drawing traversal highlight. */
  int inset;			/* Total width of highlight and 3-D border */
  Tk_Font aFont[N_FONT];	/* Information about all screen fonts */
  char fontValid[(N_FONT+7)/8]; /* If bit N%8 of work N/8 of this field is 0
                                 * if aFont[N] needs to be reallocated before
                                 * being used. */
  XColor *apColor[N_COLOR];     /* Information about all colors */
  int colorUsed;                /* bit N is 1 if color N is in use.  Only
                                ** applies to colors that aren't predefined */
  int iDark[N_COLOR];           /* Dark 3D shadow of color K is iDark[K] */
  int iLight[N_COLOR];          /* Light 3D shadow of color K is iLight[K] */
  XColor *fgColor;              /* Color of normal text. apColor[0] */
  XColor *newLinkColor;         /* Color of unvisitied links. apColor[1] */
  XColor *oldLinkColor;         /* Color of visitied links. apColor[2] */
  XColor *selectionColor;       /* Background color for selections */
  GcCache aGcCache[N_CACHE_GC]; /* A cache of GCs for general use */
  int lastGC;                   /* Index of recently used GC */
  HtmlImage *imageList;         /* A list of all images */
  int width, height;		/* User-requested size of the usable drawing
                                 * area, in pixels.   Borders and padding
                                 * make the actual window a little larger */
  int realWidth, realHeight;    /* The actual physical size of tkwin as
                                 * reported in the most recent ConfigureNotify
                                 * event. */
  int padx, pady;               /* Separation between the edge of the window
                                 * and rendered HTML.  */
  int underlineLinks;           /* TRUE if we should underline hyperlinks */

  /* Information about the selection
  */
  int exportSelection;          /* True if the selection is automatically
                                 * exported to the clipboard */

  /* Callback commands.  The HTML parser will invoke callbacks from time
  ** to time to find out information it needs to complete formatting of
  ** the document.  The following fields define the callback commands.
  */
  char *zIsVisited;             /* Command to tell if a hyperlink has already
                                ** been visited */
  char *zGetImage;              /* Command to get an image from a URL */
  char *zFrameCommand;          /* Command for handling &lt;frameset&gt; markup */
  char *zAppletCommand;         /* Command to process applets */
  char *zResolverCommand;       /* Command to resolve URIs */
  char *zFormCommand;           /* When user presses Submit */
  char *zHyperlinkCommand;      /* Invoked when a hyperlink is clicked */
  char *zFontCommand;           /* Invoked to find font names */
  char *zScriptCommand;         /* Invoked for each &lt;SCRIPT&gt; markup */

   /*
    * Miscellaneous information:
    */
  int tableRelief;              /* 3d effects on &lt;TABLE&gt; */
  int ruleRelief;               /* 3d effects on &lt;HR&gt; */
  char *zBase;                  /* The base URI */
  char *zBaseHref;              /* zBase as modified by &lt;BASE HREF=..&gt; markup */
  Tk_Cursor cursor;		/* Current cursor for window, or None. */
  char *takeFocus;		/* Value of -takefocus option;  not used in
				 * the C code, but used by keyboard traversal
				 * scripts.  Malloc'ed, but may be NULL. */
  char *yScrollCmd;		/* Command prefix for communicating with
				 * vertical scrollbar.  NULL means no command
				 * to issue.  Malloc'ed. */
  char *xScrollCmd;		/* Command prefix for communicating with
				 * horizontal scrollbar.  NULL means no command
				 * to issue.  Malloc'ed. */
  int xOffset, yOffset;         /* Current scroll position.  These form the
                                 * coordinate in the virtual canvas that
                                 * corresponds to (0,0) on the physical screen
                                 * in window tkwin */
  int maxX, maxY;               /* Maximum extent of any "paint" that appears
                                 * on the virtual canvas.  Used to compute 
                                 * scrollbar positions. */
  int dirtyLeft, dirtyTop;      /* Top left corner of region to redraw.  These
                                 * are physical screen coordinates relative to
                                 * clipwin, not tkwin. */
  int dirtyRight, dirtyBottom;  /* Bottom right corner of region to redraw */
  int locked;                   /* Number of locks on this structure. Don't
                                ** delete until it reaches zero. */
  int flags;			/* Various flags;  see below for
				 * definitions. */
}

/*
 * Flag bits "flags" field of the Html widget:
 *
 * REDRAW_PENDING         A DoWhenIdle handler has already been queued to 
 *                        call HtmlRedrawCallback() function.
 *
 * GOT_FOCUS              This widget currently has input focus.
 *
 * HSCROLL                Horizontal scrollbar position needs to be
 *                        recomputed.
 *
 * VSCROLL                Vertical scrollbar position needs to be
 *                        recomputed.
 *
 * RELAYOUT               We need to reposition every element on the 
 *                        virtual canvas.  (This happens, for example,
 *                        when the size of the widget changes and we
 *                        need to recompute the line breaks.)
 *
 * RESIZE_ELEMENTS        We need to recompute the size of every element.
 *                        This happens, for example, when the fonts
 *                        change.
 *
 * REDRAW_FOCUS           We need to repaint the focus highlight border.
 *
 * REDRAW_TEXT            Everything in the clipping window needs to be redrawn.
 *
 * REDRAW_BORDER          Everything outside the clipping window needs
 *                        to be redrawn.
 *
 * RESIZE_CLIPWIN         The size and position of the clipping window 
 *                        needs to be adjusted using Tk_MoveResizeWindow().
 *
 * STYLER_RUNNING         There is a call to HtmlAddStyle() in process.
 *                        Used to prevent a recursive call to HtmlAddStyle().
 *
 * INSERT_FLASHING        True if there is a timer callback pending that will
 *                        toggle the state of the insertion cursor.
 *
 * REDRAW_IMAGES          One or more HtmlImageMarkup structures have
 *                        their redrawNeeded flag set.
 */

#define REDRAW_PENDING	     0x000001
#define GOT_FOCUS            0x000002
#define HSCROLL              0x000004
#define VSCROLL              0x000008
#define RELAYOUT             0x000010
#define RESIZE_ELEMENTS      0x000020
#define REDRAW_FOCUS         0x000040
#define REDRAW_TEXT          0x000080
#define REDRAW_BORDER        0x000100
#define EXTEND_LAYOUT        0x000200
#define RESIZE_CLIPWIN       0x000400
#define STYLER_RUNNING       0x000800
#define INSERT_FLASHING      0x001000
#define REDRAW_IMAGES        0x002000

/*
** Macros to set, clear or test bits of the "flags" field.
*/
#define HtmlHasFlag(A,F)      (((A)-&gt;flags&amp;(F))==(F))
#define HtmlHasAnyFlag(A,F)   (((A)-&gt;flags&amp;(F))!=0)
#define HtmlSetFlag(A,F)      ((A)-&gt;flags|=(F))
#define HtmlClearFlag(A,F)    ((A)-&gt;flags&amp;=~(F))

/*
** No coordinate is every as big as this number
*/
#define LARGE_NUMBER 100000000

/*
** Default values for configuration options
*/
#define DEF_HTML_BG_COLOR             DEF_FRAME_BG_COLOR
#define DEF_HTML_BG_MONO              DEF_FRAME_BG_MONO
#define DEF_HTML_BORDER_WIDTH         "2"
#define DEF_HTML_CALLBACK             ""
#define DEF_HTML_CURSOR               DEF_FRAME_CURSOR
#define DEF_HTML_EXPORT_SEL           "yes"
#define DEF_HTML_FG                   DEF_BUTTON_FG
#define DEF_HTML_HEIGHT               "400"
#define DEF_HTML_HIGHLIGHT_BG         DEF_BUTTON_HIGHLIGHT_BG
#define DEF_HTML_HIGHLIGHT            DEF_BUTTON_HIGHLIGHT
#define DEF_HTML_HIGHLIGHT_WIDTH      "0"
#define DEF_HTML_INSERT_OFF_TIME      "300"
#define DEF_HTML_INSERT_ON_TIME       "600"
#define DEF_HTML_PADX                 "5"
#define DEF_HTML_PADY                 "5"
#define DEF_HTML_RELIEF               "raised"
#define DEF_HTML_SCROLL_COMMAND       ""
#define DEF_HTML_SELECTION_COLOR      "skyblue"
#define DEF_HTML_TAKE_FOCUS           "0"
#define DEF_HTML_UNVISITED            "blue1"
#define DEF_HTML_VISITED              "blue3"
#define DEF_HTML_WIDTH                "600"

#ifdef NAVIGATOR_TABLES

    #define DEF_HTML_TABLE_BORDER             "0"
    #define DEF_HTML_TABLE_CELLPADDING        "2"
    #define DEF_HTML_TABLE_CELLSPACING        "5"
    #define DEF_HTML_TABLE_BORDER_LIGHT_COLOR "gray80"
    #define DEF_HTML_TABLE_BORDER_DARK_COLOR  "gray40"

#endif /* NAVIGATOR_TABLES */</t>
<t tx="ekr.20041214073236">#ifdef DEBUG

@others

#endif</t>
</tnodes>
</leo_file>
