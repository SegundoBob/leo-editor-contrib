<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20181108111559.1"><vh>pscript study outline</vh></v>
<v t="ekr.20181108111640.313"><vh>@@clean __init__.py</vh>
<v t="ekr.20181108111640.314"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
</v>
<v t="ekr.20181108111640.2"><vh>@@clean base.py</vh>
<v t="ekr.20181108111640.4"><vh>class BasicParser(Parser2)</vh></v>
<v t="ekr.20181108111640.5"><vh>class Parser(Parser3)</vh></v>
<v t="ekr.20181108111640.6"><vh>this_is_js</vh></v>
</v>
<v t="ekr.20181108111640.7"><vh>@@clean commonast.py</vh>
<v t="ekr.20181108111640.9"><vh>parse</vh></v>
<v t="ekr.20181108111640.10"><vh>class Node(object)</vh>
<v t="ekr.20181108111640.11"><vh>class OPS</vh></v>
<v t="ekr.20181108111640.12"><vh>class COMP</vh></v>
<v t="ekr.20181108111640.13"><vh>__init__</vh></v>
<v t="ekr.20181108111640.14"><vh>tojson</vh></v>
<v t="ekr.20181108111640.15"><vh>fromjson</vh></v>
<v t="ekr.20181108111640.16"><vh>_fromdict</vh></v>
<v t="ekr.20181108111640.17"><vh>_todict</vh></v>
<v t="ekr.20181108111640.18"><vh>__eq__</vh></v>
<v t="ekr.20181108111640.19"><vh>__repr__</vh></v>
<v t="ekr.20181108111640.20"><vh>__str__</vh></v>
</v>
<v t="ekr.20181108111640.21"><vh>class Comment(Node)</vh></v>
<v t="ekr.20181108111640.22"><vh>class Module(Node)</vh></v>
<v t="ekr.20181108111640.23"><vh>class Num(Node)</vh></v>
<v t="ekr.20181108111640.24"><vh>class Str(Node)</vh></v>
<v t="ekr.20181108111640.25"><vh>class FormattedValue(Node)</vh></v>
<v t="ekr.20181108111640.26"><vh>class JoinedStr(Node)</vh></v>
<v t="ekr.20181108111640.27"><vh>class Bytes(Node)</vh></v>
<v t="ekr.20181108111640.28"><vh>class List(Node)</vh></v>
<v t="ekr.20181108111640.29"><vh>class Tuple(Node)</vh></v>
<v t="ekr.20181108111640.30"><vh>class Set(Node)</vh></v>
<v t="ekr.20181108111640.31"><vh>class Dict(Node)</vh></v>
<v t="ekr.20181108111640.32"><vh>class Ellipsis(Node)</vh></v>
<v t="ekr.20181108111640.33"><vh>class NameConstant(Node)</vh></v>
<v t="ekr.20181108111640.34"><vh>class Name(Node)</vh></v>
<v t="ekr.20181108111640.35"><vh>class Starred(Node)</vh></v>
<v t="ekr.20181108111640.36"><vh>class Attribute(Node)</vh></v>
<v t="ekr.20181108111640.37"><vh>class Subscript(Node)</vh></v>
<v t="ekr.20181108111640.38"><vh>class Index(Node)</vh></v>
<v t="ekr.20181108111640.39"><vh>class Slice(Node)</vh></v>
<v t="ekr.20181108111640.40"><vh>class ExtSlice(Node)</vh></v>
<v t="ekr.20181108111640.41"><vh>class Expr(Node)</vh></v>
<v t="ekr.20181108111640.42"><vh>class UnaryOp(Node)</vh></v>
<v t="ekr.20181108111640.43"><vh>class BinOp(Node)</vh></v>
<v t="ekr.20181108111640.44"><vh>class BoolOp(Node)</vh></v>
<v t="ekr.20181108111640.45"><vh>class Compare(Node)</vh></v>
<v t="ekr.20181108111640.46"><vh>class Call(Node)</vh></v>
<v t="ekr.20181108111640.47"><vh>class Keyword(Node)</vh></v>
<v t="ekr.20181108111640.48"><vh>class IfExp(Node)</vh></v>
<v t="ekr.20181108111640.49"><vh>class ListComp(Node)</vh></v>
<v t="ekr.20181108111640.50"><vh>class SetComp(Node)</vh></v>
<v t="ekr.20181108111640.51"><vh>class GeneratorExp(Node)</vh></v>
<v t="ekr.20181108111640.52"><vh>class DictComp(Node)</vh></v>
<v t="ekr.20181108111640.53"><vh>class Comprehension(Node)</vh></v>
<v t="ekr.20181108111640.54"><vh>class Assign(Node)</vh></v>
<v t="ekr.20181108111640.55"><vh>class AugAssign(Node)</vh></v>
<v t="ekr.20181108111640.56"><vh>class Raise(Node)</vh></v>
<v t="ekr.20181108111640.57"><vh>class Assert(Node)</vh></v>
<v t="ekr.20181108111640.58"><vh>class Delete(Node)</vh></v>
<v t="ekr.20181108111640.59"><vh>class Pass(Node)</vh></v>
<v t="ekr.20181108111640.60"><vh>class Import(Node)</vh></v>
<v t="ekr.20181108111640.61"><vh>class If(Node)</vh></v>
<v t="ekr.20181108111640.62"><vh>class For(Node)</vh></v>
<v t="ekr.20181108111640.63"><vh>class While(Node)</vh></v>
<v t="ekr.20181108111640.64"><vh>class Break(Node)</vh></v>
<v t="ekr.20181108111640.65"><vh>class Continue(Node)</vh></v>
<v t="ekr.20181108111640.66"><vh>class Try(Node)</vh></v>
<v t="ekr.20181108111640.67"><vh>class ExceptHandler(Node)</vh></v>
<v t="ekr.20181108111640.68"><vh>class With(Node)</vh></v>
<v t="ekr.20181108111640.69"><vh>class WithItem(Node)</vh></v>
<v t="ekr.20181108111640.70"><vh>class FunctionDef(Node)</vh></v>
<v t="ekr.20181108111640.71"><vh>class Lambda(Node)</vh></v>
<v t="ekr.20181108111640.72"><vh>class AsyncFunctionDef(Node)</vh></v>
<v t="ekr.20181108111640.73"><vh>class Arg(Node)</vh></v>
<v t="ekr.20181108111640.74"><vh>class Return(Node)</vh></v>
<v t="ekr.20181108111640.75"><vh>class Yield(Node)</vh></v>
<v t="ekr.20181108111640.76"><vh>class YieldFrom(Node)</vh></v>
<v t="ekr.20181108111640.77"><vh>class Await(Node)</vh></v>
<v t="ekr.20181108111640.78"><vh>class Global(Node)</vh></v>
<v t="ekr.20181108111640.79"><vh>class Nonlocal(Node)</vh></v>
<v t="ekr.20181108111640.80"><vh>class ClassDef(Node)</vh></v>
<v t="ekr.20181108111640.81"><vh>class NativeAstConverter</vh>
<v t="ekr.20181108111640.82"><vh>NativeAstConverter.__init__</vh></v>
<v t="ekr.20181108111640.83"><vh>NativeAstConverter._add_comments</vh></v>
<v t="ekr.20181108111640.84"><vh>NativeAstConverter.convert</vh></v>
<v t="ekr.20181108111640.85"><vh>NativeAstConverter._convert</vh></v>
<v t="ekr.20181108111640.86"><vh>NativeAstConverter._convert_Module</vh></v>
<v t="ekr.20181108111640.87"><vh>NativeAstConverter._convert_Num</vh></v>
<v t="ekr.20181108111640.88"><vh>NativeAstConverter._convert_Str</vh></v>
<v t="ekr.20181108111640.89"><vh>NativeAstConverter._convert_JoinedStr</vh></v>
<v t="ekr.20181108111640.90"><vh>NativeAstConverter._convert_FormattedValue</vh></v>
<v t="ekr.20181108111640.91"><vh>NativeAstConverter._convert_Bytes</vh></v>
<v t="ekr.20181108111640.92"><vh>NativeAstConverter._convert_List</vh></v>
<v t="ekr.20181108111640.93"><vh>NativeAstConverter._convert_Tuple</vh></v>
<v t="ekr.20181108111640.94"><vh>NativeAstConverter._convert_Set</vh></v>
<v t="ekr.20181108111640.95"><vh>NativeAstConverter._convert_Dict</vh></v>
<v t="ekr.20181108111640.96"><vh>NativeAstConverter._convert_Ellipsis</vh></v>
<v t="ekr.20181108111640.97"><vh>NativeAstConverter._convert_NameConstant</vh></v>
<v t="ekr.20181108111640.98"><vh>NativeAstConverter._convert_Name</vh></v>
<v t="ekr.20181108111640.99"><vh>NativeAstConverter._convert_Starred</vh></v>
<v t="ekr.20181108111640.100"><vh>NativeAstConverter._convert_Attribute</vh></v>
<v t="ekr.20181108111640.101"><vh>NativeAstConverter._convert_Subscript</vh></v>
<v t="ekr.20181108111640.102"><vh>NativeAstConverter._convert_Index</vh></v>
<v t="ekr.20181108111640.103"><vh>NativeAstConverter._convert_Slice</vh></v>
<v t="ekr.20181108111640.104"><vh>NativeAstConverter._convert_ExtSlice</vh></v>
<v t="ekr.20181108111640.105"><vh>NativeAstConverter._convert_Expr</vh></v>
<v t="ekr.20181108111640.106"><vh>NativeAstConverter._convert_UnaryOp</vh></v>
<v t="ekr.20181108111640.107"><vh>NativeAstConverter._convert_BinOp</vh></v>
<v t="ekr.20181108111640.108"><vh>NativeAstConverter._convert_BoolOp</vh></v>
<v t="ekr.20181108111640.109"><vh>NativeAstConverter._convert_Compare</vh></v>
<v t="ekr.20181108111640.110"><vh>NativeAstConverter._convert_Call</vh></v>
<v t="ekr.20181108111640.111"><vh>NativeAstConverter._convert_keyword</vh></v>
<v t="ekr.20181108111640.112"><vh>NativeAstConverter._convert_IfExp</vh></v>
<v t="ekr.20181108111640.113"><vh>NativeAstConverter._convert_ListComp</vh></v>
<v t="ekr.20181108111640.114"><vh>NativeAstConverter._convert_SetComp</vh></v>
<v t="ekr.20181108111640.115"><vh>NativeAstConverter._convert_GeneratorExp</vh></v>
<v t="ekr.20181108111640.116"><vh>NativeAstConverter._convert_DictComp</vh></v>
<v t="ekr.20181108111640.117"><vh>NativeAstConverter._convert_comprehension</vh></v>
<v t="ekr.20181108111640.118"><vh>NativeAstConverter._convert_Assign</vh></v>
<v t="ekr.20181108111640.119"><vh>NativeAstConverter._convert_AugAssign</vh></v>
<v t="ekr.20181108111640.120"><vh>NativeAstConverter._convert_Print</vh></v>
<v t="ekr.20181108111640.121"><vh>NativeAstConverter._convert_Exec</vh></v>
<v t="ekr.20181108111640.122"><vh>NativeAstConverter._convert_Repr</vh></v>
<v t="ekr.20181108111640.123"><vh>NativeAstConverter._convert_Raise</vh></v>
<v t="ekr.20181108111640.124"><vh>NativeAstConverter._convert_Assert</vh></v>
<v t="ekr.20181108111640.125"><vh>NativeAstConverter._convert_Delete</vh></v>
<v t="ekr.20181108111640.126"><vh>NativeAstConverter._convert_Pass</vh></v>
<v t="ekr.20181108111640.127"><vh>NativeAstConverter._convert_Import</vh></v>
<v t="ekr.20181108111640.128"><vh>NativeAstConverter._convert_ImportFrom</vh></v>
<v t="ekr.20181108111640.129"><vh>NativeAstConverter._convert_If</vh></v>
<v t="ekr.20181108111640.130"><vh>NativeAstConverter._convert_For</vh></v>
<v t="ekr.20181108111640.131"><vh>NativeAstConverter._convert_While</vh></v>
<v t="ekr.20181108111640.132"><vh>NativeAstConverter._convert_Break</vh></v>
<v t="ekr.20181108111640.133"><vh>NativeAstConverter._convert_Continue</vh></v>
<v t="ekr.20181108111640.134"><vh>NativeAstConverter._convert_Try</vh></v>
<v t="ekr.20181108111640.135"><vh>NativeAstConverter._convert_TryFinally</vh></v>
<v t="ekr.20181108111640.136"><vh>NativeAstConverter._convert_TryExcept</vh></v>
<v t="ekr.20181108111640.137"><vh>NativeAstConverter._convert_ExceptHandler</vh></v>
<v t="ekr.20181108111640.138"><vh>NativeAstConverter._convert_With</vh></v>
<v t="ekr.20181108111640.139"><vh>NativeAstConverter._convert_withitem</vh></v>
<v t="ekr.20181108111640.140"><vh>NativeAstConverter._convert_functiondefs</vh></v>
<v t="ekr.20181108111640.141"><vh>NativeAstConverter._convert_FunctionDef</vh></v>
<v t="ekr.20181108111640.142"><vh>NativeAstConverter._convert_Lambda</vh></v>
<v t="ekr.20181108111640.143"><vh>NativeAstConverter._convert_AsyncFunctionDef</vh></v>
<v t="ekr.20181108111640.144"><vh>NativeAstConverter._convert_arg</vh></v>
<v t="ekr.20181108111640.145"><vh>NativeAstConverter._convert_Return</vh></v>
<v t="ekr.20181108111640.146"><vh>NativeAstConverter._convert_Yield</vh></v>
<v t="ekr.20181108111640.147"><vh>NativeAstConverter._convert_YieldFrom</vh></v>
<v t="ekr.20181108111640.148"><vh>NativeAstConverter._convert_Await</vh></v>
<v t="ekr.20181108111640.149"><vh>NativeAstConverter._convert_Global</vh></v>
<v t="ekr.20181108111640.150"><vh>NativeAstConverter._convert_Nonlocal</vh></v>
<v t="ekr.20181108111640.151"><vh>NativeAstConverter._convert_ClassDef</vh></v>
</v>
</v>
<v t="ekr.20181108111640.152"><vh>@@clean functions.py</vh>
<v t="ekr.20181108111640.154"><vh>class JSString(str)</vh></v>
<v t="ekr.20181108111640.155"><vh>py2js</vh>
<v t="ekr.20181108210630.1"><vh>&lt;&lt; py2js docstring &gt;&gt;</vh></v>
</v>
<v t="ekr.20181108111640.156"><vh>js_rename</vh></v>
<v t="ekr.20181108111640.157"><vh>get_node_exe</vh></v>
<v t="ekr.20181108111640.158"><vh>evaljs</vh></v>
<v t="ekr.20181108111640.159"><vh>evalpy</vh></v>
<v t="ekr.20181108111640.160"><vh>script2js</vh></v>
</v>
<v t="ekr.20181108111640.161"><vh>@@clean modules.py</vh>
<v t="ekr.20181108111640.162"><vh>&lt;&lt; code snippets &gt;&gt;</vh></v>
<v t="ekr.20181108111640.163"><vh>isidentifier</vh></v>
<v t="ekr.20181108111640.164"><vh>create_js_module</vh></v>
</v>
<v t="ekr.20181108111640.165"><vh>@@clean parser0.py</vh>
<v t="ekr.20181108111640.167"><vh>class JSError(Exception)</vh></v>
<v t="ekr.20181108111640.168"><vh>unify</vh></v>
<v t="ekr.20181108111640.169"><vh>class NameSpace(dict)</vh>
<v t="ekr.20181108111640.170"><vh>NameSpace.set_nonlocal</vh></v>
<v t="ekr.20181108111640.171"><vh>NameSpace.set_global</vh></v>
<v t="ekr.20181108111640.172"><vh>NameSpace.use</vh></v>
<v t="ekr.20181108111640.173"><vh>NameSpace.add</vh></v>
<v t="ekr.20181108111640.174"><vh>NameSpace.discard</vh></v>
<v t="ekr.20181108111640.175"><vh>NameSpace.leak_stack</vh></v>
<v t="ekr.20181108111640.176"><vh>NameSpace.is_known</vh></v>
<v t="ekr.20181108111640.177"><vh>NameSpace.get_defined</vh></v>
<v t="ekr.20181108111640.178"><vh>NameSpace.get_globals</vh></v>
<v t="ekr.20181108111640.179"><vh>NameSpace.get_undefined</vh></v>
</v>
<v t="ekr.20181108111640.180"><vh>class Parser0</vh>
<v t="ekr.20181108111640.181"><vh>Parser0.__init__</vh></v>
<v t="ekr.20181108111640.182"><vh>Parser0.dump</vh></v>
<v t="ekr.20181108111640.183"><vh>Parser0._better_js_error</vh></v>
<v t="ekr.20181108111640.184"><vh>Parser0.push_stack</vh></v>
<v t="ekr.20181108111640.185"><vh>Parser0.pop_stack</vh></v>
<v t="ekr.20181108111640.186"><vh>Parser0.get_declarations</vh></v>
<v t="ekr.20181108111640.187"><vh>Parser0.with_prefix</vh></v>
<v t="ekr.20181108111640.188"><vh>Parser0.vars</vh></v>
<v t="ekr.20181108111640.189"><vh>Parser0.lf</vh></v>
<v t="ekr.20181108111640.190"><vh>Parser0.dummy</vh></v>
<v t="ekr.20181108111640.191"><vh>Parser0._handle_std_deps</vh></v>
<v t="ekr.20181108111640.192"><vh>Parser0.use_std_function</vh></v>
<v t="ekr.20181108111640.193"><vh>Parser0.use_std_method</vh></v>
<v t="ekr.20181108111640.194"><vh>Parser0.pop_docstring</vh></v>
<v t="ekr.20181108111640.195"><vh>Parser0.parse</vh></v>
</v>
</v>
<v t="ekr.20181108111640.196"><vh>@@clean parser1.py</vh>
<v t="ekr.20181108111640.197"><vh>&lt;&lt; parser1 docstring &gt;&gt;</vh></v>
<v t="ekr.20181108211821.1"><vh>&lt;&lt; parser1 data &gt;&gt;</vh></v>
<v t="ekr.20181108111640.198"><vh>class Parser1(Parser0)</vh>
<v t="ekr.20181108111640.199"><vh>Parser1.parse_Num</vh></v>
<v t="ekr.20181108111640.200"><vh>Parser1.parse_Str</vh></v>
<v t="ekr.20181108111640.201"><vh>Parser1.parse_JoinedStr</vh></v>
<v t="ekr.20181108111640.202"><vh>Parser1.parse_FormattedValue</vh></v>
<v t="ekr.20181108111640.203"><vh>Parser1._parse_FormattedValue_fmt</vh></v>
<v t="ekr.20181108111640.204"><vh>Parser1.parse_Bytes</vh></v>
<v t="ekr.20181108111640.205"><vh>Parser1.parse_NameConstant</vh></v>
<v t="ekr.20181108111640.206"><vh>Parser1.parse_List</vh></v>
<v t="ekr.20181108111640.207"><vh>Parser1.parse_Tuple</vh></v>
<v t="ekr.20181108111640.208"><vh>Parser1.parse_Dict</vh></v>
<v t="ekr.20181108111640.209"><vh>Parser1.parse_Set</vh></v>
<v t="ekr.20181108111640.210"><vh>Parser1.push_scope_prefix</vh></v>
<v t="ekr.20181108111640.211"><vh>Parser1.pop_scope_prefix</vh></v>
<v t="ekr.20181108111640.212"><vh>Parser1.parse_Name</vh></v>
<v t="ekr.20181108111640.213"><vh>Parser1.parse_Starred</vh></v>
<v t="ekr.20181108111640.214"><vh>Parser1.parse_Expr</vh></v>
<v t="ekr.20181108111640.215"><vh>Parser1.parse_UnaryOp</vh></v>
<v t="ekr.20181108111640.216"><vh>Parser1.parse_BinOp</vh></v>
<v t="ekr.20181108111640.217"><vh>Parser1._format_string</vh></v>
<v t="ekr.20181108111640.218"><vh>Parser1._wrap_truthy</vh></v>
<v t="ekr.20181108111640.219"><vh>Parser1.parse_BoolOp</vh></v>
<v t="ekr.20181108111640.220"><vh>Parser1.parse_Compare</vh></v>
<v t="ekr.20181108111640.221"><vh>Parser1.parse_Call</vh></v>
<v t="ekr.20181108111640.222"><vh>Parser1._get_args</vh></v>
<v t="ekr.20181108111640.223"><vh>Parser1._get_positional_args</vh></v>
<v t="ekr.20181108111640.224"><vh>Parser1._get_keyword_args</vh></v>
<v t="ekr.20181108111640.225"><vh>Parser1.parse_Attribute</vh></v>
<v t="ekr.20181108111640.226"><vh>Parser1.parse_Assign</vh></v>
<v t="ekr.20181108111640.227"><vh>Parser1.parse_AugAssign</vh></v>
<v t="ekr.20181108111640.228"><vh>Parser1.parse_Delete</vh></v>
<v t="ekr.20181108111640.229"><vh>Parser1.parse_Pass</vh></v>
<v t="ekr.20181108111640.230"><vh>Parser1.parse_Subscript</vh></v>
<v t="ekr.20181108111640.231"><vh>Parser1.parse_Index</vh></v>
<v t="ekr.20181108111640.232"><vh>Parser1.parse_Slice</vh></v>
<v t="ekr.20181108111640.233"><vh>Parser1.parse_ExtSlice</vh></v>
<v t="ekr.20181108111640.234"><vh>Parser1.parse_Import</vh></v>
<v t="ekr.20181108111640.235"><vh>Parser1.parse_Module</vh></v>
</v>
</v>
<v t="ekr.20181108111640.236"><vh>@@clean parser2.py</vh>
<v t="ekr.20181108111640.237"><vh>&lt;&lt; parser2 docstring &gt;&gt;</vh></v>
<v t="ekr.20181108212134.1"><vh>&lt;&lt; parser2 data &gt;&gt;</vh></v>
<v t="ekr.20181108111640.238"><vh>class Parser2(Parser1)</vh>
<v t="ekr.20181108111640.239"><vh>Parser2.parse_Raise</vh></v>
<v t="ekr.20181108111640.240"><vh>Parser2.parse_Assert</vh></v>
<v t="ekr.20181108111640.241"><vh>Parser2.parse_Try</vh></v>
<v t="ekr.20181108111640.242"><vh>Parser2.parse_ExceptHandler</vh></v>
<v t="ekr.20181108111640.243"><vh>Parser2.parse_With</vh></v>
<v t="ekr.20181108111640.244"><vh>Parser2.parse_IfExp</vh></v>
<v t="ekr.20181108111640.245"><vh>Parser2.parse_If</vh></v>
<v t="ekr.20181108111640.246"><vh>Parser2.parse_For</vh></v>
<v t="ekr.20181108111640.247"><vh>Parser2._make_iterable</vh></v>
<v t="ekr.20181108111640.248"><vh>Parser2.parse_While</vh></v>
<v t="ekr.20181108111640.249"><vh>Parser2.parse_Break</vh></v>
<v t="ekr.20181108111640.250"><vh>Parser2.parse_Continue</vh></v>
<v t="ekr.20181108111640.251"><vh>Parser2.parse_ListComp_funtionless</vh></v>
<v t="ekr.20181108111640.252"><vh>Parser2.parse_ListComp</vh></v>
<v t="ekr.20181108111640.253"><vh>Parser2._iterator_assign</vh></v>
<v t="ekr.20181108111640.254"><vh>Parser2.parse_FunctionDef</vh></v>
<v t="ekr.20181108111640.255"><vh>Parser2.parse_Lambda</vh></v>
<v t="ekr.20181108111640.256"><vh>Parser2.parse_AsyncFunctionDef</vh></v>
<v t="ekr.20181108111640.257"><vh>Parser2.parse_Return</vh></v>
<v t="ekr.20181108111640.258"><vh>Parser2.parse_ClassDef</vh></v>
<v t="ekr.20181108111640.259"><vh>Parser2.function_super</vh></v>
<v t="ekr.20181108111640.260"><vh>Parser2.parse_Await</vh></v>
<v t="ekr.20181108111640.261"><vh>Parser2.parse_Global</vh></v>
<v t="ekr.20181108111640.262"><vh>Parser2.parse_Nonlocal</vh></v>
</v>
<v t="ekr.20181108111640.263"><vh>get_class_definition</vh></v>
</v>
<v t="ekr.20181108111640.264"><vh>@@clean parser3.py</vh>
<v t="ekr.20181108111640.265"><vh>&lt;&lt; parser3 docstring &gt;&gt;</vh></v>
<v t="ekr.20181108111640.266"><vh>class Parser3(Parser2)</vh>
<v t="ekr.20181108111640.267"><vh>Parser3.function_this_is_js</vh></v>
<v t="ekr.20181108111640.268"><vh>Parser3.function_RawJS</vh></v>
<v t="ekr.20181108111640.269"><vh>Parser3.function_isinstance</vh></v>
<v t="ekr.20181108111640.270"><vh>Parser3.function_issubclass</vh></v>
<v t="ekr.20181108111640.271"><vh>Parser3.function_print</vh></v>
<v t="ekr.20181108111640.272"><vh>Parser3.function_len</vh></v>
<v t="ekr.20181108111640.273"><vh>Parser3.function_max</vh></v>
<v t="ekr.20181108111640.274"><vh>Parser3.function_min</vh></v>
<v t="ekr.20181108111640.275"><vh>Parser3.function_callable</vh></v>
<v t="ekr.20181108111640.276"><vh>Parser3.function_chr</vh></v>
<v t="ekr.20181108111640.277"><vh>Parser3.function_ord</vh></v>
<v t="ekr.20181108111640.278"><vh>Parser3.function_dict</vh></v>
<v t="ekr.20181108111640.279"><vh>Parser3.function_list</vh></v>
<v t="ekr.20181108111640.280"><vh>Parser3.function_tuple</vh></v>
<v t="ekr.20181108111640.281"><vh>Parser3.function_range</vh></v>
<v t="ekr.20181108111640.282"><vh>Parser3.function_sorted</vh></v>
<v t="ekr.20181108111640.283"><vh>Parser3.method_sort</vh></v>
<v t="ekr.20181108111640.284"><vh>Parser3.method_format</vh></v>
</v>
<v t="ekr.20181108111640.285"><vh>make_function</vh></v>
<v t="ekr.20181108111640.286"><vh>make_method</vh></v>
</v>
<v t="ekr.20181108111640.287"><vh>@@clean stdlib.py</vh>
<v t="ekr.20181108111640.289"><vh>get_std_info</vh></v>
<v t="ekr.20181108111640.290"><vh>_update_deps</vh></v>
<v t="ekr.20181108111640.291"><vh>get_partial_std_lib</vh></v>
<v t="ekr.20181108111640.292"><vh>get_full_std_lib</vh></v>
<v t="ekr.20181108111640.293"><vh>get_all_std_names</vh></v>
<v t="ekr.20181108212755.1"><vh>&lt;&lt; define FUNCTIONS &gt;&gt;</vh></v>
<v t="ekr.20181108212823.1"><vh>&lt;&lt; define METHODS &gt;&gt;</vh></v>
</v>
<v t="ekr.20181108111640.294"><vh>@@clean stubs.py</vh>
<v t="ekr.20181108111640.296"><vh>class RawJS</vh>
<v t="ekr.20181108111640.297"><vh>RawJS.__init__</vh></v>
<v t="ekr.20181108111640.298"><vh>RawJS.__repr__</vh></v>
<v t="ekr.20181108111640.299"><vh>RawJS.__str__</vh></v>
<v t="ekr.20181108111640.300"><vh>RawJS._str2lines</vh></v>
<v t="ekr.20181108111640.301"><vh>RawJS.get_defined_name</vh></v>
<v t="ekr.20181108111640.302"><vh>RawJS.get_code</vh></v>
</v>
<v t="ekr.20181108111640.303"><vh>class JSConstant</vh>
<v t="ekr.20181108111640.304"><vh>JSConstant.__init__</vh></v>
<v t="ekr.20181108111640.305"><vh>JSConstant.__repr__</vh></v>
</v>
<v t="ekr.20181108111640.306"><vh>class Stubs</vh></v>
</v>
<v t="ekr.20181108111640.308"><vh>@@clean testing.py</vh>
<v t="ekr.20181108111640.309"><vh>&lt;&lt; testing data &gt;&gt;</vh></v>
<v t="ekr.20181108111640.310"><vh>run_tests_if_main</vh></v>
<v t="ekr.20181108111640.311"><vh>_enable_faulthandler</vh></v>
<v t="ekr.20181108111640.312"><vh>_clear_our_modules</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20181108111559.1"># Note: this code has not been tested with perfect import.</t>
<t tx="ekr.20181108111640.10">class Node(object):
    """ Abstract base class for all Nodes.
    """
    
    __slots__ = ['lineno', 'col_offset']
    
    @others
try:
    Node.OPS.__doc__ += ', '.join([x for x in sorted(Node.OPS.__dict__)
                                   if not x.startswith('_')])
    Node.COMP.__doc__ += ', '.join([x for x in sorted(Node.COMP.__dict__)
                                    if not x.startswith('_')])
except AttributeError:  # pragma: no cover
    pass  # Py &lt; 3.3


## -- (start marker for doc generator)

## General

</t>
<t tx="ekr.20181108111640.100">def _convert_Attribute(self, n):
    return Attribute(self._convert(n.value), n.attr)

</t>
<t tx="ekr.20181108111640.101">def _convert_Subscript(self, n):
    return Subscript(self._convert(n.value), self._convert(n.slice))

</t>
<t tx="ekr.20181108111640.102">def _convert_Index(self, n):
    return Index(self._convert(n.value))

</t>
<t tx="ekr.20181108111640.103">def _convert_Slice(self, n):
    c = self._convert
    step = c(n.step)
    if pyversion &lt; (3, ) and isinstance(step, NameConstant) and step.value is None:
        if not self._lines[n.step.lineno-1][n.step.col_offset:].startswith('None'):
            step = None  # silly Python 2 turns a[::] into a[::None]
    return Slice(c(n.lower), c(n.upper), step)

</t>
<t tx="ekr.20181108111640.104">def _convert_ExtSlice(self, n):
    c = self._convert
    return ExtSlice([c(x) for x in n.dims])

## Expressions

</t>
<t tx="ekr.20181108111640.105">def _convert_Expr(self, n):
    return Expr(self._convert(n.value))

</t>
<t tx="ekr.20181108111640.106">def _convert_UnaryOp(self, n):
    op = n.op.__class__.__name__
    return UnaryOp(op, self._convert(n.operand))

</t>
<t tx="ekr.20181108111640.107">def _convert_BinOp(self, n):
    op = n.op.__class__.__name__
    return BinOp(op, self._convert(n.left), self._convert(n.right))

</t>
<t tx="ekr.20181108111640.108">def _convert_BoolOp(self, n):
    c = self._convert
    op = n.op.__class__.__name__
    return BoolOp(op, [c(x) for x in n.values])  # list of value_nodes

</t>
<t tx="ekr.20181108111640.109">def _convert_Compare(self, n):
    c = self._convert
    # Get compares and ops
    comps = [c(x) for x in ([n.left] + n.comparators)]
    ops = [op.__class__.__name__ for op in n.ops]
    assert len(ops) == (len(comps) - 1)
    # Create our comparison operators
    compares = []
    for i in range(len(ops)):
        co = Compare(ops[i], comps[i], comps[i+1])
        compares.append(co)
    # Return single or wrapped in an AND
    assert compares
    if len(compares) == 1:
        return compares[0]
    else:
        return BoolOp(Node.OPS.And, compares)

</t>
<t tx="ekr.20181108111640.11">class OPS:
    """ Operator enums: """
    # Unary
    UAdd = 'UAdd'
    USub = 'USub'
    Not = 'Not'
    Invert = 'Invert'
    # Binary
    Add = 'Add'
    Sub = 'Sub'
    Mult = 'Mult'
    Div = 'Div'
    FloorDiv = 'FloorDiv'
    Mod = 'Mod'
    Pow = 'Pow'
    LShift = 'LShift'
    RShift = 'RShift'
    BitOr = 'BitOr'
    BitXor = 'BitXor'
    BitAnd = 'BitAnd'
    # Boolean
    And = 'And'
    Or = 'Or'

</t>
<t tx="ekr.20181108111640.110">def _convert_Call(self, n):
    c = self._convert
    arg_nodes = [c(a) for a in n.args]
    kwarg_nodes = [c(a) for a in n.keywords]
    
    if pyversion &lt; (3, 5):
        if n.starargs:
            arg_nodes.append(Starred(c(n.starargs)))
        if n.kwargs:
            kwarg_nodes.append(Keyword(None, c(n.kwargs)))
    
    return Call(c(n.func), arg_nodes, kwarg_nodes)

</t>
<t tx="ekr.20181108111640.111">def _convert_keyword(self, n):
    return Keyword(n.arg, self._convert(n.value or None))

</t>
<t tx="ekr.20181108111640.112">def _convert_IfExp(self, n):
    c = self._convert
    return IfExp(c(n.test), c(n.body), c(n.orelse))

</t>
<t tx="ekr.20181108111640.113">def _convert_ListComp(self, n):
    c = self._convert
    return ListComp(c(n.elt), [c(x) for x in n.generators])

</t>
<t tx="ekr.20181108111640.114">def _convert_SetComp(self, n):
    c = self._convert
    return SetComp(c(n.elt), [c(x) for x in n.generators])

</t>
<t tx="ekr.20181108111640.115">def _convert_GeneratorExp(self, n):
    c = self._convert
    return GeneratorExp(c(n.elt), [c(x) for x in n.generators])

</t>
<t tx="ekr.20181108111640.116">def _convert_DictComp(self, n):
    c = self._convert
    return DictComp(c(n.key), c(n.value), [c(x) for x in n.generators])

</t>
<t tx="ekr.20181108111640.117">def _convert_comprehension(self, n):
    c = self._convert
    return Comprehension(c(n.target), c(n.iter), [c(x) for x in n.ifs])

## Statements

</t>
<t tx="ekr.20181108111640.118">def _convert_Assign(self, n):
    c = self._convert
    return Assign([c(x) for x in n.targets], c(n.value))

</t>
<t tx="ekr.20181108111640.119">def _convert_AugAssign(self, n):
    op = n.op.__class__.__name__
    return AugAssign(self._convert(n.target), op, self._convert(n.value))

</t>
<t tx="ekr.20181108111640.12">class COMP:
    """ Comparison enums: """
    Eq = 'Eq'
    NotEq = 'NotEq'
    Lt = 'Lt'
    LtE = 'LtE'
    Gt = 'Gt'
    GtE = 'GtE'
    Is = 'Is'
    IsNot = 'IsNot'
    In = 'In'
    NotIn = 'NotIn'

</t>
<t tx="ekr.20181108111640.120">def _convert_Print(self, n):  # pragma: no cover - Python 2.x compat
    c = self._convert
    if len(n.values) == 1 and isinstance(n.values[0], ast.Tuple):
        arg_nodes = [c(x) for x in n.values[0].elts]
    else:
        arg_nodes = [c(x) for x in n.values]
    kwarg_nodes = []
    if n.dest is not None:
        kwarg_nodes.append(Keyword('dest', c(n.dest)))
    if not n.nl:
        kwarg_nodes.append(Keyword('end', Str('')))
    return Expr(Call(Name('print'), arg_nodes, kwarg_nodes))

</t>
<t tx="ekr.20181108111640.121">def _convert_Exec(self, n):  # pragma: no cover - Python 2.x compat
    c = self._convert
    arg_nodes = [c(n.body)]
    arg_nodes.append(c(n.globals) or NameConstant(None))
    arg_nodes.append(c(n.locals) or NameConstant(None))
    return Expr(Call(Name('exec'), arg_nodes, []))

</t>
<t tx="ekr.20181108111640.122">def _convert_Repr(self, n):  # pragma: no cover - Python 2.x compat
    c = self._convert
    return Call(Name('repr'), [c(n.value)], [])

</t>
<t tx="ekr.20181108111640.123">def _convert_Raise(self, n):
    if pyversion &lt; (3, ):
        if n.inst or n.tback:
            raise RuntimeError('Commonast does not support old raise syntax')
        return Raise(self._convert(n.type), None)
    return Raise(self._convert(n.exc), self._convert(n.cause))

</t>
<t tx="ekr.20181108111640.124">def _convert_Assert(self, n):
    return Assert(self._convert(n.test), self._convert(n.msg))

</t>
<t tx="ekr.20181108111640.125">def _convert_Delete(self, n):
    c = self._convert
    return Delete([c(x) for x in n.targets])

</t>
<t tx="ekr.20181108111640.126">def _convert_Pass(self, n):
    return Pass()

</t>
<t tx="ekr.20181108111640.127">def _convert_Import(self, n):
    return Import(None, [(x.name, x.asname) for x in n.names], 0)

</t>
<t tx="ekr.20181108111640.128">def _convert_ImportFrom(self, n):
    names = [(x.name, x.asname) for x in n.names]
    return Import(n.module, names, n.level)

## Control flow

</t>
<t tx="ekr.20181108111640.129">def _convert_If(self, n):
    c = self._convert
    node = If(c(n.test), [], [])
    self._stack.append((node.body_nodes, n.body))
    self._stack.append((node.else_nodes, n.orelse))
    return node

</t>
<t tx="ekr.20181108111640.13">def __init__(self, *args):
    names = self.__slots__
    # Checks
    assert len(args) == len(names)  # check this always
    if docheck:
        assert not hasattr(self, '__dict__'), 'Nodes must have __slots__'
        assert self.__class__ is not Node, 'Node is an abstract class'
        for name, val in zip(names, args):
            assert not isinstance(val, ast.AST)
            if name == 'name':
                assert isinstance(val, (basestring, NoneType)), 'name not a string'
            elif name == 'op':
                assert val in Node.OPS.__dict__ or val in Node.COMP.__dict__
            elif name.endswith('_node'):
                assert isinstance(val, (Node, NoneType)), '%r is not a Node' % name
            elif name.endswith('_nodes'):
                islistofnodes = (isinstance(val, list) and 
                                 all(isinstance(n, Node) for n in val))
                assert islistofnodes, '%r is not a list of nodes' % name
            else:
                assert not isinstance(val, Node), '%r should not be a Node' % name
                assert not (isinstance(val, list) and 
                            all(isinstance(n, Node) for n in val))
    # Assign
    for name, val in zip(names, args):
        setattr(self, name, val)

</t>
<t tx="ekr.20181108111640.130">def _convert_For(self, n):
    c = self._convert
    node = For(c(n.target), c(n.iter), [], [])
    self._stack.append((node.body_nodes, n.body))
    self._stack.append((node.else_nodes, n.orelse))
    return node

</t>
<t tx="ekr.20181108111640.131">def _convert_While(self, n):
    c = self._convert
    node = While(c(n.test), [], [])
    self._stack.append((node.body_nodes, n.body))
    self._stack.append((node.else_nodes, n.orelse))
    return node

</t>
<t tx="ekr.20181108111640.132">def _convert_Break(self, n):
    return Break()

</t>
<t tx="ekr.20181108111640.133">def _convert_Continue(self, n):
    return Continue()

</t>
<t tx="ekr.20181108111640.134">def _convert_Try(self, n):
    c = self._convert
    node = Try([], [c(x) for x in n.handlers], [], [])
    self._stack.append((node.body_nodes, n.body))
    self._stack.append((node.else_nodes, n.orelse))
    self._stack.append((node.finally_nodes, n.finalbody))
    return node

</t>
<t tx="ekr.20181108111640.135">def _convert_TryFinally(self, n):  # pragma: no cover - Py &lt;= 3.2
    c = self._convert
    if (len(n.body) == 1) and n.body[0].__class__.__name__ == 'TryExcept':
        # un-nesting for try-except-finally
        n2 = n.body[0]
        node = Try([], [c(x) for x in n2.handlers], [], [])
        self._stack.append((node.body_nodes, n2.body))
        self._stack.append((node.else_nodes, n2.orelse))
        self._stack.append((node.finally_nodes, n.finalbody))
    else:
        node = Try([], [], [], [])
        self._stack.append((node.body_nodes, n.body))
        self._stack.append((node.finally_nodes, n.finalbody))
    return node

</t>
<t tx="ekr.20181108111640.136">def _convert_TryExcept(self, n):  # pragma: no cover - Py &lt;= 3.2
    c = self._convert
    node = Try([], [c(x) for x in n.handlers], [], [])
    self._stack.append((node.body_nodes, n.body))
    self._stack.append((node.else_nodes, n.orelse))
    return node

</t>
<t tx="ekr.20181108111640.137">def _convert_ExceptHandler(self, n):
    c = self._convert
    name = n.name.id if isinstance(n.name, ast.Name) else n.name
    node = ExceptHandler(c(n.type), name, [])
    self._stack.append((node.body_nodes, n.body))
    return node

</t>
<t tx="ekr.20181108111640.138">def _convert_With(self, n):
    c = self._convert
    if hasattr(n, 'items'):
        node = With([c(x) for x in n.items], [])
    else:  # pragma: no cover - Py &lt; 3.3
        items = [WithItem(c(n.context_expr), c(n.optional_vars))]
        while (len(n.body) == 1) and isinstance(n.body[0], n.__class__):
            n = n.body[0]
            items.append(WithItem(c(n.context_expr), c(n.optional_vars)))
        node = With(items, [])
    self._stack.append((node.body_nodes, n.body))
    return node

</t>
<t tx="ekr.20181108111640.139">def _convert_withitem(self, n):
    return WithItem(self._convert(n.context_expr), self._convert(n.optional_vars))

## Function and class definitions

</t>
<t tx="ekr.20181108111640.14">def tojson(self, indent=2):
    """ Return a string with the JSON representatiom of this AST.
    Set indent to None for a more compact representation.
    """
    return json.dumps(self._todict(), indent=indent, sort_keys=True)

</t>
<t tx="ekr.20181108111640.140">def _convert_functiondefs(self, n, cls):
    c = self._convert
    args = n.args
    # Parse arg_nodes and kwarg_nodes
    arg_nodes = [c(x) for x in args.args]
    for i, default in enumerate(reversed(args.defaults)):
        arg_node = arg_nodes[-1-i]
        if isinstance(arg_node, Tuple):
            raise RuntimeError('Tuple arguments in function def not supported.')
        arg_node.value_node = c(default)
    if pyversion &lt; (3, ):
        kwarg_nodes = []
    else:
        kwarg_nodes = [c(x) for x in args.kwonlyargs]
        for i, default in enumerate(reversed(args.kw_defaults)):
            kwarg_nodes[-1-i].value_node = c(default) 
    # Parse args_node and kwargs_node
    if pyversion &lt; (3, ):
        args_node = Arg(args.vararg, None, None) if args.vararg else None
        kwargs_node = Arg(args.kwarg, None, None) if args.kwarg else None
    elif pyversion &lt; (3, 4):
        args_node = kwargs_node = None
        if args.vararg:
            args_node = Arg(args.vararg, None, c(args.varargannotation))
        if args.kwarg: 
            kwargs_node = Arg(args.kwarg, None, c(args.kwargannotation))
    else:
        args_node = c(args.vararg)
        kwargs_node = c(args.kwarg)
    
    returns = None if pyversion &lt; (3, ) else c(n.returns)
    Cls = cls  # noqa
    node = Cls(n.name, [c(x) for x in n.decorator_list], returns,
               arg_nodes, kwarg_nodes, args_node, kwargs_node, [])
    if docheck:
        assert isinstance(node.args_node, (NoneType, Arg))
        assert isinstance(node.kwargs_node, (NoneType, Arg))
        for x in node.arg_nodes + node.kwarg_nodes:
            assert isinstance(x, Arg)
    
    self._stack.append((node.body_nodes, n.body))
    return node

</t>
<t tx="ekr.20181108111640.141">def _convert_FunctionDef(self, n):
    return self._convert_functiondefs(n, FunctionDef)

</t>
<t tx="ekr.20181108111640.142">def _convert_Lambda(self, n):
    c = self._convert
    args = n.args
    arg_nodes = [c(x) for x in args.args]
    for i, default in enumerate(reversed(args.defaults)):
        arg_nodes[-1-i].value_node = c(default)
    if pyversion &lt; (3, ):
        kwarg_nodes = []
    else:
        kwarg_nodes = [c(x) for x in args.kwonlyargs]
        for i, default in enumerate(reversed(args.kw_defaults)):
            kwarg_nodes[-1-i].value_node = c(default)
    
    return Lambda(arg_nodes, kwarg_nodes,
                  c(args.vararg), c(args.kwarg), c(n.body))

</t>
<t tx="ekr.20181108111640.143">def _convert_AsyncFunctionDef(self, n):
    return self._convert_functiondefs(n, AsyncFunctionDef)

</t>
<t tx="ekr.20181108111640.144">def _convert_arg(self, n):
    # Value is initially None
    return Arg(n.arg or None, None, self._convert(n.annotation))

</t>
<t tx="ekr.20181108111640.145">def _convert_Return(self, n):
    return Return(self._convert(n.value))

</t>
<t tx="ekr.20181108111640.146">def _convert_Yield(self, n):
    return Yield(self._convert(n.value))

</t>
<t tx="ekr.20181108111640.147">def _convert_YieldFrom(self, n):
    return YieldFrom(self._convert(n.value))

</t>
<t tx="ekr.20181108111640.148">def _convert_Await(self, n):
    return Await(self._convert(n.value))

</t>
<t tx="ekr.20181108111640.149">def _convert_Global(self, n):
    return Global(n.names)

</t>
<t tx="ekr.20181108111640.15">@classmethod
def fromjson(cls, text):
    """ Classmethod to create an AST tree from JSON.
    """
    return Node._fromdict(json.loads(text))
    
</t>
<t tx="ekr.20181108111640.150">def _convert_Nonlocal(self, n):
    return Nonlocal(n.names)

</t>
<t tx="ekr.20181108111640.151">def _convert_ClassDef(self, n):
    c = self._convert
    arg_nodes = [c(a) for a in n.bases]
    kwarg_nodes = [] if pyversion &lt; (3, ) else [c(a) for a in n.keywords]
    
    if getattr(n, 'starargs', None):
        arg_nodes.append(Starred(self._convert(n.starargs)))
    if getattr(n, 'kwargs', None):
        kwarg_nodes.append(Keyword(None, self._convert(n.kwargs)))
    
    node = ClassDef(n.name, [c(a) for a in n.decorator_list],
                    arg_nodes, kwarg_nodes, [])
    
    self._stack.append((node.body_nodes, n.body))
    return node
</t>
<t tx="ekr.20181108111640.152">import re
import os
import sys
import types
import inspect
import hashlib
import tempfile
import subprocess

from . import Parser
from .stdlib import get_full_std_lib  # noqa
from .modules import create_js_module

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181108111640.154">class JSString(str):
    """ A subclass of string, so we can add attributes to JS string objects.
    """
    pass


</t>
<t tx="ekr.20181108111640.155">def py2js(ob=None, new_name=None, **parser_options):
    &lt;&lt; py2js docstring &gt;&gt;
    
    def py2js_(ob):
        if isinstance(ob, str):
            thetype = 'str'
            pycode = ob
            filename = None
            linenr = 0
        elif isinstance(ob, types.ModuleType) and hasattr(ob, '__file__'):
            thetype = 'str'
            filename = inspect.getsourcefile(ob)
            linenr = 0
            pycode = open(filename, 'rb').read().decode()
            if pycode.startswith('# -*- coding:'):
                pycode = '\n' + pycode.split('\n', 1)[-1]
        elif isinstance(ob, (type, types.FunctionType, types.MethodType)):
            thetype = 'class' if isinstance(ob, type) else 'def'
            # Get code
            try:
                filename = inspect.getsourcefile(ob)
                lines, linenr = inspect.getsourcelines(ob)
            except Exception as err:
                raise ValueError('Could not get source code for object %r: %s' %
                                 (ob, err))
            if getattr(ob, '__name__', '') in ('', '&lt;lambda&gt;'):
                raise ValueError('py2js() got anonymous function from '
                                 '"%s", line %i, %r.' % (filename, linenr, ob))
            # Normalize indentation, based on first line
            indent = len(lines[0]) - len(lines[0].lstrip())
            for i in range(len(lines)):
                line = lines[i]
                line_indent = len(line) - len(line.lstrip())
                if line_indent &lt; indent and line.strip():
                    assert line.lstrip().startswith('#')  # only possible for comments
                    lines[i] = indent * ' ' + line.lstrip()
                else:
                    lines[i] = line[indent:]
            # Skip any decorators
            while not lines[0].lstrip().startswith((thetype, 'async ' + thetype)):
                lines.pop(0)
            # join lines and rename
            pycode = ''.join(lines)
        else:
            raise ValueError('py2js() only accepts non-builtin modules, '
                             'classes and functions.')
        
        # Get hash, in case we ever want to cache JS accross sessions
        h = hashlib.sha256('pscript version 1'.encode())
        h.update(pycode.encode())
        hash = h.digest()
        
        # Get JS code
        if filename:
            p = Parser(pycode, (filename, linenr), **parser_options)
        else:
            p = Parser(pycode, **parser_options)
        jscode = p.dump()
        if new_name:
            if thetype not in ('class', 'def'):
                raise TypeError('py2js() can only rename functions and classes.')
            jscode = js_rename(jscode, ob.__name__, new_name)
        
        # Collect undefined variables
        # vars_unknown = [name for name, s in p.vars.get_undefined()]
        vars_unknown = set()
        for name, usages in p.vars.get_undefined():
            for usage in usages:
                vars_unknown.add(usage)
        
        # todo: now that we have so much info in the meta, maybe we should
        # use use py2js everywhere where we now use Parser and move its docs here.
        
        # Wrap in JSString
        jscode = JSString(jscode)
        jscode.meta = {}
        jscode.meta['filename'] = filename
        jscode.meta['linenr'] = linenr
        jscode.meta['pycode'] = pycode
        jscode.meta['pyhash'] = hash
        jscode.meta['std_functions'] = p._std_functions
        jscode.meta['std_methods'] = p._std_methods
        jscode.meta['vars_defined'] = p.vars.get_defined()
        jscode.meta['vars_global'] = p.vars.get_globals()
        jscode.meta['vars_unknown'] = vars_unknown
        return jscode
    
    if ob is None:
        return py2js_  # uses as a decorator with some options set
    return py2js_(ob)

</t>
<t tx="ekr.20181108111640.156">re_sub1 = re.compile(r'this\.__(\w*?[a-zA-Z0-9](?!__)\W)', re.UNICODE)

def js_rename(jscode, cur_name, new_name):
    """ Rename a function or class in a JavaScript code string.
    
    The new name can be prefixed (i.e. have dots in it). Functions can be
    converted to methods by prefixing with a name that starts with a capital
    letter (and probably ".prototype"). Double-underscore-mangling
    is taken into account.
    
    Parameters:
        jscode (str): the JavaScript source code
        cur_name (str): the current name (must be an identifier, e.g. no dots).
        new_name (str): the name to replace the current name with
    
    Returns:
        str: the modified JavaScript source code
    """
    assert cur_name and '.' not in cur_name
    
    isclass = cur_name[0].lower() != cur_name[0]
    if isclass:
        # cur_cls_name = cur_name
        new_cls_name = new_name.split('.')[-1]
    else:
        new_cls_name = ''
        parts = new_name.split('.')
        prefix = '.'.join(parts[:-1])
        if prefix:
            maybe_cls = parts[-3] if parts[-2] == 'prototype' else parts[-2]
            maybe_cls = maybe_cls.strip('$')  # allow special names
            if maybe_cls[0].lower() != maybe_cls[0]:
                new_cls_name = maybe_cls
    
    cur_name_short = cur_name.split('.')[-1]
    new_name_short = new_name.split('.')[-1]
    if isclass:
        # If this is about a class ...
        jscode = jscode.replace('.__name__ = "%s"' % cur_name_short, 
                                '.__name__ = "%s"' % new_name_short)
        jscode = jscode.replace('._%s__' % cur_name_short,
                                '._%s__' % new_name_short)
        jscode = jscode.replace('%s.prototype' % cur_name, 
                                '%s.prototype' % new_name)
    else:
        # If this is about a function / method
        jscode = jscode.replace('function flx_%s' % cur_name_short,
                                'function flx_%s' % new_name_short, 1)
        if new_cls_name:  # use regexp to match double-underscore but no magics!
            jscode = re_sub1.sub('this._%s__\\1' % new_cls_name, jscode)
            #jscode = jscode.replace('this.__', 'this._%s__' % new_cls_name)
    
    # Always do this
    jscode = jscode.replace('%s = function' % cur_name, 
                            '%s = function' % new_name, 1)
    jscode = jscode.replace('%s = async function' % cur_name, 
                            '%s = async function' % new_name, 1)
    if '.' in new_name:
        jscode = jscode.replace('var %s;\n' % cur_name, '', 1)
    else:
        jscode = jscode.replace('var %s;\n' % cur_name, 
                                'var %s;\n' % new_name, 1)
    
    if 'this._Component__properties__' in jscode:
        1/0
        
    return jscode
</t>
<t tx="ekr.20181108111640.157">NODE_EXE = None

def get_node_exe():
    """ Small utility that provides the node exe. The first time this
    is called both 'nodejs' and 'node' are tried. To override the
    executable path, set the ``PSCRIPT_NODE_EXE`` environment variable.
    """
    # This makes things work on Ubuntu's nodejs as well as other node
    # implementations, and allows users to set the node exe if necessary
    global NODE_EXE
    NODE_EXE = os.getenv('PSCRIPT_NODE_EXE', os.getenv('FLEXX_NODE_EXE')) or NODE_EXE
    if NODE_EXE is None:
        NODE_EXE = 'nodejs'
        try:
            subprocess.check_output([NODE_EXE, '-v'])
        except Exception:  # pragma: no cover
            NODE_EXE = 'node'
    return NODE_EXE

</t>
<t tx="ekr.20181108111640.158">_eval_count = 0

def evaljs(jscode, whitespace=True, print_result=True, extra_nodejs_args=None):
    """ Evaluate JavaScript code in Node.js.
    
    Parameters:
        jscode (str): the JavaScript code to evaluate.
        whitespace (bool): if whitespace is False, the whitespace
            is removed from the result. Default True.
        print_result (bool): whether to print the result of the evaluation.
            Default True. If False, larger pieces of code can be evaluated
            because we can use file-mode.
        extra_nodejs_args (list): Extra command line args to pass to nodejs.
    
    Returns:
        str: the last result as a string.
    """
    global _eval_count
    
    # Init command
    cmd = [get_node_exe()]
    if extra_nodejs_args:
        cmd.extend(extra_nodejs_args)
    
    # Prepare command
    if len(jscode) &gt; 2**14:
        if print_result:
            # Strictly speaking, this is a limitation of Windows, but come-on!
            raise RuntimeError('evaljs() wont send more than 16 kB of code '
                               'over the command line, but cannot use a file '
                               'unless print_result is False.')
        _eval_count += 1
        fname = 'pscript_%i_%i.js' % (os.getpid(), _eval_count)
        filename = os.path.join(tempfile.gettempdir(), fname)
        with open(filename, 'wb') as f:
            f.write(jscode.encode())
        cmd += ['--use_strict', filename]
    else:
        filename = None
        p_or_e = ['-p', '-e'] if print_result else ['-e']
        cmd += ['--use_strict'] + p_or_e + [jscode]
        if sys.version_info[0] &lt; 3:
            cmd = [c.encode('raw_unicode_escape') for c in cmd]
    
    # Call node
    try:
        res = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
    except Exception as err:
        if hasattr(err, 'output'):
            err = err.output.decode()
        else:
            err = str(err)
        err = err[:400] + '...' if len(err) &gt; 400 else err
        raise RuntimeError(err)
    finally:
        if filename is not None:
            try:
                os.remove(filename)
            except Exception:
                pass
    
    # Process result
    res = res.decode().rstrip()
    if print_result and res.endswith('undefined'):
        res = res[:-9].rstrip()
    if not whitespace:
        res = res.replace('\n', '').replace('\t', '').replace(' ', '')
    return res


</t>
<t tx="ekr.20181108111640.159">def evalpy(pycode, whitespace=True):
    """ Evaluate PScript code in Node.js (after translating to JS).
    
    Parameters:
        pycode (str): the PScript code to evaluate.
        whitespace (bool): if whitespace is False, the whitespace is
            removed from the result. Default True.
    
    Returns:
        str: the last result as a string.
    """
    # delibirate numpy doc style to see if napoleon handles it the same
    return evaljs(py2js(pycode), whitespace)


</t>
<t tx="ekr.20181108111640.16">@classmethod
def _fromdict(cls, d):
    assert '_type' in d
    Cls = globals()[d['_type']]
    
    args = []
    for name in Cls.__slots__:
        val = d[name]
        if val is None:
            pass
        elif name.endswith('_node'):
            val = Node._fromdict(val)
        elif name.endswith('_nodes'):
            val = [Node._fromdict(x) for x in val]
        elif isinstance(val, basestring):
            if val.startswith('BYTES:'):
                val = decodebytes(val[6:].encode('utf-8'))
            elif val.startswith('COMPLEX:'):
                val = complex(val[8:])
            elif pyversion &lt; (3, ):
                val = unicode(val)  # noqa
        args.append(val)
    return Cls(*args)

</t>
<t tx="ekr.20181108111640.160">def script2js(filename, namespace=None, target=None, module_type='umd',
              **parser_options):
    """ Export a .py file to a .js file.
    
    Parameters:
      filename (str): the filename of the .py file to transpile.
      namespace (str): the namespace for this module. (optional)
      target (str): the filename of the resulting .js file. If not given
        or None, will use the ``filename``, but with a ``.js`` extension.
      module_type (str): the type of module to produce (if namespace is given),
        can be 'hidden', 'simple', 'amd', 'umd', default 'umd'.
      parser_options: additional options for the parser. See Parser class
        for details.
    """
    # Import
    assert filename.endswith('.py')
    pycode = open(filename, 'rb').read().decode()
    # Convert
    parser = Parser(pycode, filename, **parser_options)
    jscode = '/* Do not edit, autogenerated by pscript */\n\n' + parser.dump()
    # Wrap in module
    if namespace:
        exports = [name for name in parser.vars.get_defined()
                   if not name.startswith('_')]
        jscode = create_js_module(namespace, jscode, [], exports, module_type)
    # Export
    if target is None:
        dirname, fname = os.path.split(filename)
        filename2 = os.path.join(dirname, fname[:-3] + '.js')
    else:
        filename2 = target
    with open(filename2, 'wb') as f:
        f.write(jscode.encode())
</t>
<t tx="ekr.20181108111640.161">"""
Functionality for creating JS modules of various formats, including AMD and UMD.
"""

import re

&lt;&lt; code snippets &gt;&gt;
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181108111640.162"># Immediately Invoked Function Expression (IIFE)
HIDDEN = """
(function () {

"use strict";

{code}

})();
""".lstrip()


SIMPLE = """
(function (root, factory) {
    root.{save_name} = factory();
}(this, function () {

"use strict";

{code}

return {exports};
}));
""".lstrip()


AMD = """
define("{name}", [{dep_strings}], function ({dep_names}) {

"use strict";

{code}

return {exports};
});
""".lstrip()

AMD_FLEXX = "flexx." + AMD


# https://github.com/umdjs/umd/blob/master/returnExports.js
UMD = """
(function (root, factory) {
    if (typeof define === 'function' &amp;&amp; define.amd) {
        // AMD. Register as an anonymous module.
        define("{name}", [{dep_strings}], factory);
    } else if (typeof exports !== 'undefined') {
        // Node or CommonJS
        module.exports = factory({dep_requires});
        if (typeof window === 'undefined') {
            root.{save_name} = module.exports;  // also create global module in Node
        }
    } else {
        // Browser globals (root is window)
        root.{save_name} = factory({dep_fullnames});
    }
}(this, function ({dep_names}) {

"use strict";

{code}

return {exports};
})); 
""".lstrip()


</t>
<t tx="ekr.20181108111640.163">def isidentifier(s):
    # http://stackoverflow.com/questions/2544972/
    if not isinstance(s, str):
        return False
    return re.match(r'^\w+$', s, re.UNICODE) and re.match(r'^[0-9]', s) is None


</t>
<t tx="ekr.20181108111640.164">def create_js_module(name, code, imports, exports, type='umd'):
    """ Wrap the given code in an AMD module.
    
    Note that "use strict" is added to the top of the module body. PScript
    does not deal with license strings; the caller should do that.
    
    Parameters:
        name (str): the name of the module.
        code (str): the JS code to wrap.
        imports (list): the imports for this module, as string names of the
            dependencies. Optionally, 'as' can  be used to make a dependency
            available under a specific name (e.g. 'foo.js as foo').
        exports (str, list): the result of this module (i.e. what other modules
            get when they import this module. Can be a JS expression or a list
            of names to export.
        type (str): the type of module to export, valid values are
            'hidden', 'simple' (save module on root), 'amd' , 'amd-flexx' and
            'umd' (case insensitive). Default 'umd'.
    """
    
    # Check input args
    if not isinstance(name, str) or not name:
        raise ValueError('create_module() name arg must be a (nonempty) string.')
    if not isinstance(code, str):
        raise ValueError('create_module() code arg must be a string.')
    if not isinstance(imports, (tuple, list)):
        raise ValueError('create_module() imports arg must be a string.')
    if not isinstance(exports, (str, tuple, list)):
        raise ValueError('create_module() exports arg must be a string or list.')
    
    # Process imports
    deps, dep_names = [], []
    for imp in imports:
        if not isinstance(imp, str):
            raise ValueError('Elements in create_module() imports must be str.')
        if ' as ' in imp:
            dep, dep_name = imp.split(' as ', 1)
        else:
            dep = dep_name = imp
        if '.' in dep_name:
            raise ValueError('Import %r has dots, have you used "as"?' % dep_name)
        deps.append(dep)
        dep_names.append(dep_name)
    
    # Process exports
    if isinstance(exports, str):
        return_val = exports
    else:  # list
        for exp in exports:
            if not isinstance(exp, str):
                raise ValueError('Elements in create_module() exports must be str.')
        return_val = ', '.join(['%s: %s' % (exp, exp) for exp in exports])
        return_val = '{' + return_val + '}'
    
    # Process type -&gt; select template
    types = {'hidden': HIDDEN, 'simple': SIMPLE,
             'amd': AMD, 'umd': UMD, 'amd-flexx': AMD_FLEXX}
    if not isinstance(type, str):
        raise ValueError('create_js_module() type must be str.')
    if type.lower() not in types:
        raise ValueError('create_js_module() got invalid type %r' % type)
    template = types[type.lower()]
    
    # Derived information needed to populate the module templates
    save_name = lambda n: n.split('/')[-1].split('.')[0].replace('-', '_')
    dep_strings = ['"%s"' % dep for dep in deps]
    dep_fullnames = ['root.' + save_name(dep) for dep in deps]
    dep_requires = ['require("%s")' % dep for dep in deps]
    
    # Fill in the template
    for key, val in [('{name}', name),
                     ('{save_name}', save_name(name)),
                     ('{exports}', return_val),
                     ('{dep_names}', ', '.join(dep_names)),
                     ('{dep_strings}', ', '.join(dep_strings)),
                     ('{dep_fullnames}', ', '.join(dep_fullnames)),
                     ('{dep_requires}', ', '.join(dep_requires)),
                     ('{code}', code),  # last!
                    ]:
        template = template.replace(key, val)
    
    return template
</t>
<t tx="ekr.20181108111640.165"># -*- coding: utf-8
"""
Parts of this code (and in the other modules that define the parser
class) are inspired by / taken from the py2js project.

Useful links:
 * https://greentreesnakes.readthedocs.org/en/latest/nodes.html
 * https://github.com/qsnake/py2js/blob/master/py2js/__init__.py

Main limiting features for browsers (not sure if this is 100% complete):
* Object.keys supported from IE 9 - we use it in method_keys()

"""

import re
import sys
import json

from . import commonast as ast
from . import stdlib, logger

reprs = json.dumps  # Save string representation without the u in u'xx'.

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181108111640.167">class JSError(Exception):
    """ Exception raised when unable to convert Python to JS.
    """
    pass


</t>
<t tx="ekr.20181108111640.168">def unify(x):
    """ Turn string or list of strings parts into string. Braces are
    placed around it if its not alphanumerical
    """
    # Note that r'[\.\w]' matches anyting in 'ab_01.äé'
    
    if isinstance(x, (tuple, list)):
        x = ''.join(x)
    
    if x[0] in '\'"' and x[0] == x[-1] and x.count(x[0]) == 2:
        return x  # string
    elif re.match(r'^[\.\w]*$', x, re.UNICODE):
        return x  # words consisting of normal chars, numbers and dots
    elif re.match(r'^[\.\w]*\(.*\)$', x, re.UNICODE) and x.count(')') == 1:
        return x  # function calls (e.g. 'super()' or 'foo.bar(...)')
    elif re.match(r'^[\.\w]*\[.*\]$', x, re.UNICODE) and x.count(']') == 1:
        return x  # indexing
    elif re.match(r'^\{.*\}$', x, re.UNICODE) and x.count('}') == 1:
        return x  # dicts
    else:
        return '(%s)' % x


</t>
<t tx="ekr.20181108111640.169">class NameSpace(dict):
    """ Representation of the namespace in a certain scope. It looks a bit like
    a set, but makes a distinction between used/defined and local/nonlocal.
    
    The value of an item in this dict can be:
    * 1: variable defined in this scope.
    * 2: nonlocal variable (set nonlocal in this scope).
    * 3: global variable (set global in this scope).
    * 4: global variable (set in a subscope).
    * set: variable used here (or in a subscope) but not defined here.
    """
    
    @others
</t>
<t tx="ekr.20181108111640.17">def _todict(self):
    """ Get a dict representing this AST. This is the basis for
    creating JSON, but can be used to compare AST trees as well.
    """
    d = {}
    d['_type'] = self.__class__.__name__
    for name in self.__slots__:
        val = getattr(self, name)
        if val is None:
            pass
        elif name.endswith('_node'):
            val = val._todict()
        elif name.endswith('_nodes'):
            val = [x._todict() for x in val]
        elif isinstance(self, Bytes) and isinstance(val, bytes):
            val = 'BYTES:' + encodebytes(val).decode('utf-8').rstrip()
        elif isinstance(self, Num) and isinstance(val, complex):
            val = 'COMPLEX:' + repr(val)
        d[name] = val
    return d

</t>
<t tx="ekr.20181108111640.170">def set_nonlocal(self, key):
    """ Explicitly declare a name as nonlocal """
    self[key] = 2  # also if already exists

</t>
<t tx="ekr.20181108111640.171">def set_global(self, key):
    """ Explicitly declare a name as global """
    self[key] = 3  # also if already exists
    # becomes 4 in parent scope

</t>
<t tx="ekr.20181108111640.172">def use(self, key, how):
    """ Declare a name as used and how (the full name.foo.bar). The name
    may be defined in higher level, or it will end up in vars_unknown.
    """
    hows = self.setdefault(key, set())
    if isinstance(hows, set):
        hows.add(how)

</t>
<t tx="ekr.20181108111640.173">def add(self, key):
    """ Declare a name as defined in this namespace """
    # If value is 4, the name is used as a global in a subscope. At this
    # point, we do not know whether this is the toplevel scope (also
    # because py2js() is often used to transpile snippets which are later
    # combined), so we assume that the user know what (s)he is doing.
    curval = self.get(key, 0)
    if curval not in (2, 3):  # dont overwrite nonlocal or global
        self[key] = 1

</t>
<t tx="ekr.20181108111640.174">def discard(self, key):
    """ Discard name from this namespace """
    self.pop(key, None)

</t>
<t tx="ekr.20181108111640.175">def leak_stack(self, sub):
    """ Leak a child namespace into the current one. Undefined variables
    and nonlocals are moved upwards.
    """
    for name in sub.get_globals():
        sub.discard(name)
        if name not in self:
            self[name] = 4
        # elif self[name] not in (3, 4):  ... dont know whether outer scope
        #     raise JSError('Cannot use non-global that is global in subscope.')
    for name, hows in sub.get_undefined():
        sub.discard(name)
        for how in hows:
            self.use(name, how)

</t>
<t tx="ekr.20181108111640.176">def is_known(self, name):
    """ Get whether the given name is defined or declared global/nonlocal
    in this scope.
    """
    return self.get(name, 0) in (1, 2, 3)
    
</t>
<t tx="ekr.20181108111640.177">def get_defined(self):
    """ Get list of variable names that the current scope defines.
    """
    return set([name for name, val in self.items() if val == 1])

</t>
<t tx="ekr.20181108111640.178">def get_globals(self):
    """ Get list of variable names that are declared global in the
    current scope or its subscopes.
    """
    return set([name for name, val in self.items() if val in (3, 4)])

</t>
<t tx="ekr.20181108111640.179">def get_undefined(self):
    """ Get (name, set) tuples for variables that are used, but not
    defined. The set contains the ways in which the variable is used
    (e.g. name.foo.bar).
    """
    return [(name, val) for name, val in self.items() if isinstance(val, set)]


</t>
<t tx="ekr.20181108111640.18">def __eq__(self, other):
    if not isinstance(other, Node):
        raise ValueError('Can only compare nodes to other nodes.')
    return self._todict() == other._todict()

</t>
<t tx="ekr.20181108111640.180">class Parser0:
    """ The Base parser class. Implements the basic mechanism to allow
    parsing to work, but does not implement any parsing on its own.
    
    For details see the Parser class.
    """
    
    # Developer notes:
    # The parse_x() functions are called by parse() with the node of
    # type x. They should return a string or a list of strings. parse()
    # always returns a list of strings.
    
    NAME_MAP = {
        'True'  : 'true',
        'False' : 'false',
        'None'  : 'null',
        'unicode': 'str',  # legacy Py compat
        'unichr': 'chr',
        'xrange': 'range',
        'self': 'this',
    }
    
    ATTRIBUTE_MAP = {
        '__class__': 'Object.getPrototypeOf({})',
    }
    
    BINARY_OP = {
        'Add'    : '+',
        'Sub'    : '-',
        'Mult'   : '*',
        'Div'    : '/',
        'Mod'    : '%',
        'LShift' : '&lt;&lt;',
        'RShift' : '&gt;&gt;',
        'BitOr'  : '|',
        'BitXor' : '^',
        'BitAnd' : '&amp;',
    }
    
    UNARY_OP = {
        'Invert' : '~',
        'Not'    : '!',
        'UAdd'   : '+',
        'USub'   : '-',
    }
    
    BOOL_OP = {
        'And'    : '&amp;&amp;',
        'Or'     : '||',
    }
    
    COMP_OP = {
        'Eq'    : "==",
        'NotEq' : "!=",
        'Lt'    : "&lt;",
        'LtE'   : "&lt;=",
        'Gt'    : "&gt;",
        'GtE'   : "&gt;=",
        'Is'    : "===",
        'IsNot' : "!==",
    }
    
    @others
</t>
<t tx="ekr.20181108111640.181">def __init__(self, code, pysource=None, indent=0, docstrings=True,
             inline_stdlib=True):
    self._pycode = code  # helpfull during debugging
    self._pysource = None
    if isinstance(pysource, str):
        self._pysource = pysource, 0
    elif isinstance(pysource, tuple):
        self._pysource = str(pysource[0]), int(pysource[1])
    elif pysource is not None:
        logger.warn('Parser ignores pysource; it must be str or (str, int).')
    if sys.version_info[0] == 2:
        fut = 'from __future__ import unicode_literals, print_function\n'
        code = fut + code
    self._root = ast.parse(code)
    if sys.version_info[0] == 2:
        self._root.body_nodes.pop(0)  # remove that import node we added
    self._stack = []
    self._indent = indent
    self._dummy_counter = 0
    self._scope_prefix = []  # stack of name prefixes to simulate local scope
    
    # To keep track of std lib usage
    self._std_functions = set()
    self._std_methods = set()
    
    # To help distinguish classes from functions
    self._seen_func_names = set()
    self._seen_class_names = set()
    
    # Options
    self._docstrings = bool(docstrings)  # whether to inclue docstrings
    
    # Collect function and method handlers
    self._functions, self._methods = {}, {}
    for name in dir(self.__class__):
        if name.startswith('function_op_'):
            pass  # special operator function that we use explicitly
        elif name.startswith('function_'):
            self._functions[name[9:]] = getattr(self, name)
        elif name.startswith('method_'):
            self._methods[name[7:]] = getattr(self, name)
    
    # Prepare
    self.push_stack('module', '')
    
    # Parse
    try:
        self._parts = self.parse(self._root)
    except JSError as err:
        # Give smarter error message
        _, _, tb = sys.exc_info()
        try:
            msg = self._better_js_error(tb)
        except Exception:  # pragma: no cover
            raise(err)
        else:
            err.args = (msg + ':\n' + str(err), )
            raise(err)
    
    # Finish
    ns = self.vars  # do not self.pop_stack() so caller can inspect module vars
    defined_names = ns.get_defined()
    if defined_names:
        self._parts.insert(0, self.get_declarations(ns))
    
    # Add part of the stdlib that was actually used
    if inline_stdlib:
        libcode = stdlib.get_partial_std_lib(self._std_functions,
                                             self._std_methods,
                                             self._indent)
        if libcode:
            self._parts.insert(0, libcode)
    
    # Post-process
    if self._parts:
        self._parts[0] = '    ' * indent + self._parts[0].lstrip()

</t>
<t tx="ekr.20181108111640.182">def dump(self):
    """ Get the JS code as a string.
    """
    return ''.join(self._parts)

</t>
<t tx="ekr.20181108111640.183">def _better_js_error(self, tb):  # pragma: no cover
    """ If we get a JSError, we try to get the corresponding node
    and print the lineno as well as the function etc.
    """
    node = None
    classNode = None
    funcNode = None
    while tb.tb_next:
        tb = tb.tb_next
        node = tb.tb_frame.f_locals.get('node', node)
        classNode = node if isinstance(node, ast.ClassDef) else classNode
        funcNode = node if isinstance(node, ast.FunctionDef) else funcNode
    
    # Get location as accurately as we can
    filename = None
    lineno = getattr(node, 'lineno', -1)
    if self._pysource:
        filename, lineno = self._pysource
        lineno += node.lineno
    
    msg = 'Error processing %s-node' % (node.__class__.__name__)
    if classNode:
        msg += ' in class "%s"' % classNode.name
    if funcNode:
        msg += ' in function "%s"' % funcNode.name
    if filename:
        msg += ' in "%s"' % filename
    if hasattr(node, 'lineno'):
        msg += ', line %i, ' % lineno
    if hasattr(node, 'col_offset'):
        msg += 'col %i' % node.col_offset
    return msg

</t>
<t tx="ekr.20181108111640.184">def push_stack(self, type, name):
    """ New namespace stack. Match a call to this with a call to
    pop_stack() and process the resulting line to declare the used
    variables. type must be 'module', 'class' or 'function'.
    """
    assert type in ('module', 'class', 'function')
    self._stack.append((type, name, NameSpace()))

</t>
<t tx="ekr.20181108111640.185">def pop_stack(self):
    """ Pop the current stack and return the namespace.
    """
    # Pop
    nstype, nsname, ns = self._stack.pop(-1)
    self.vars.leak_stack(ns)
    return ns

</t>
<t tx="ekr.20181108111640.186">def get_declarations(self, ns):
    """ Get string with variable (and builtin-function) declarations.
    """
    if not ns:
        return ''
    code = []
    loose_vars = []
    for name, value in sorted(ns.items()):
        if value == 1:
            loose_vars.append(name)
        # else: pass global/nonlocal or expected to be defined in outer scope
    if loose_vars:
        code.insert(0, self.lf('var %s;' % ', '.join(loose_vars)))
    return ''.join(code)

</t>
<t tx="ekr.20181108111640.187">def with_prefix(self, name, new=False):
    """ Add class prefix to a variable name if necessary.
    """
    nstype, nsname, ns = self._stack[-1]
    if nstype == 'class':
        if name.startswith('__') and not name.endswith('__'):
            name = '_' + nsname + name  # Double underscore name mangling
        return nsname + '.prototype.' + name
    else:
        return name

</t>
<t tx="ekr.20181108111640.188">@property
def vars(self):
    """ NameSpace instance for the current stack. """
    return self._stack[-1][2]

</t>
<t tx="ekr.20181108111640.189">def lf(self, code=''):
    """ Line feed - create a new line with the correct indentation.
    """
    return '\n' + self._indent * '    ' + code

</t>
<t tx="ekr.20181108111640.19">def __repr__(self):
    names = ', '.join([repr(x) for x in self.__slots__])
    return '&lt;%s with %s at 0x%x&gt;' % (self.__class__.__name__, names, id(self))

</t>
<t tx="ekr.20181108111640.190">def dummy(self, name=''):
    """ Get a unique name. The name is added to vars.
    """
    self._dummy_counter += 1
    name = 'stub%i_%s' % (self._dummy_counter, name)
    self.vars.add(name)
    return name

</t>
<t tx="ekr.20181108111640.191">def _handle_std_deps(self, code):
    nargs, function_deps, method_deps = stdlib.get_std_info(code)
    for dep in function_deps:
        self.use_std_function(dep, [])
    for dep in method_deps:
        self.use_std_method('x', dep, [])

</t>
<t tx="ekr.20181108111640.192">def use_std_function(self, name, arg_nodes):
    """ Use a function from the PScript standard library.
    """
    self._handle_std_deps(stdlib.FUNCTIONS[name])
    self._std_functions.add(name)
    mangled_name = stdlib.FUNCTION_PREFIX + name
    args = [(a if isinstance(a, str) else unify(self.parse(a)))
            for a in arg_nodes]
    return '%s(%s)' % (mangled_name, ', '.join(args))

</t>
<t tx="ekr.20181108111640.193">def use_std_method(self, base, name, arg_nodes):
    """ Use a method from the PScript standard library.
    """
    self._handle_std_deps(stdlib.METHODS[name])
    self._std_methods.add(name)
    mangled_name = stdlib.METHOD_PREFIX + name
    args = [(a if isinstance(a, str) else unify(self.parse(a)))
            for a in arg_nodes]
    #return '%s.%s(%s)' % (base, mangled_name, ', '.join(args)) 
    args.insert(0, base)
    return '%s.call(%s)' % (mangled_name, ', '.join(args)) 

</t>
<t tx="ekr.20181108111640.194">def pop_docstring(self, node):
    """ If a docstring is present, in the body of the given node,
    remove that string node and return it as a string, corrected
    for indentation and stripped. If no docstring is present return
    empty string.
    """
    docstring = ''
    if (node.body_nodes and isinstance(node.body_nodes[0], ast.Expr) and
                            isinstance(node.body_nodes[0].value_node, ast.Str)):
        docstring = node.body_nodes.pop(0).value_node.value.strip()
        lines = docstring.splitlines()
        getindent = lambda x: len(x) - len(x.strip())
        indent = min([getindent(x) for x in lines[1:]]) if (len(lines) &gt; 1) else 0
        if lines:
            lines[0] = ' ' * indent + lines[0]
            lines = [line[indent:] for line in lines]
        docstring = '\n'.join(lines)
    return docstring

</t>
<t tx="ekr.20181108111640.195">def parse(self, node):
    """ Parse a node. Check node type and dispatch to one of the
    specific parse functions. Raises error if we cannot parse this
    type of node.
    
    Returns a list of strings.
    """
    nodeType = node.__class__.__name__
    parse_func = getattr(self, 'parse_' + nodeType, None)
    if parse_func:
        res = parse_func(node)
        # Return as list also if a tuple or string was returned
        assert res is not None
        if isinstance(res, tuple):
            res = list(res)
        if not isinstance(res, list):
            res = [res]
        return res
    else:
        raise JSError('Cannot parse %s-nodes yet' % nodeType)
</t>
<t tx="ekr.20181108111640.196">&lt;&lt; parser1 docstring &gt;&gt;
import re

from . import commonast as ast
from . import stdlib
from .parser0 import Parser0, JSError, unify, reprs  # noqa

&lt;&lt; parser1 data &gt;&gt;

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181108111640.197">@language rest

"""

The basics
----------

Most types just work, common Python names are converted to their JavaScript
equivalents.

.. pscript_example::
    
    # Simple operations
    3 + 4 -1
    3 * 7 / 9
    5**2
    pow(5, 2)
    7 // 2
    
    # Basic types
    [True, False, None]
    
    # Lists and dicts
    foo = [1, 2, 3]
    bar = {'a': 1, 'b': 2}


Slicing and subscriping
-----------------------

.. pscript_example::

    # Slicing lists
    foo = [1, 2, 3, 4, 5]
    foo[2:]
    foo[2:-2]
    
    # Slicing strings
    bar = 'abcdefghij'
    bar[2:]
    bar[2:-2]
    
    # Subscripting
    foo = {'bar': 3}
    foo['bar']
    foo.bar  # Works in JS, but not in Python


String formatting
-----------------

String formatting is supported in various forms.

.. pscript_example::
    
    # Old school
    "value: %g" % val
    "%s: %0.2f" % (name, val)
    
    # Modern
    "value: {:g}".format(val)
    "{}: {:3.2f}".format(name, val)
    
    # F-strings (python 3.6+)
    #f"value: {val:g}"
    #f"{name}: {val:3.2f}"
    
    # This also works
    t = "value: {:g}"
    t.format(val)
    
    # But this does not (because PScript cannot know whether t is str or float)
    t = "value: %g"
    t % val

Kinds of formatting that is supported:

* Float, exponential en "general" number formatting.
* Specifying precision for numbers.
* Padding of number with "+" or " ".
* Repr-formatting.

At the moment, PScript does not support advanced features such as string
padding.


Assignments
-----------

Declaration of variables is handled automatically. Also support for
tuple packing and unpacking (a.k.a. destructuring assignment).

.. pscript_example::
    
    # Declare foo
    foo = 3
    
    # But not here
    bar.foo = 3
    
    # Pack items in an array
    a = 1, 2, 3
    
    # And unpack them
    a1, a2, a3 = a
    
    # Deleting variables
    del bar.foo
    
    # Functions starting with a capital letter
    # are assumed constructors
    foo = Foo()


Comparisons
-----------

.. pscript_example::
    
    # Identity
    foo is bar
    
    # Equality 
    foo == bar
    
    # But comparisons are deep (unlike JS)
    (2, 3, 4) == (2, 3, 4)
    (2, 3) in [(1,2), (2,3), (3,4)]

    # Test for null
    foo is None
    
    # Test for JS undefined
    foo is undefined
    
    # Testing for containment
    "foo" in "this has foo in it"
    3 in [0, 1, 2, 3, 4]


Truthy and Falsy
----------------

In JavaScript, an empty array and an empty dict are interpreted as
truthy. PScript fixes this, so that you can do ``if an_array:`` as
usual.

.. pscript_example::

    # These evaluate to False:
    0
    NaN
    ""  # empty string
    None  # JS null
    undefined
    []
    {}
    
    # This still works
    a = []
    a = a or [1]  # a is now [1]


Function calls
--------------

As in Python, the default return value of a function is ``None`` (i.e.
``null`` in JS).

.. pscript_example::
    
    # Business as usual
    foo(a, b)
    
    # Support for star args (but not **kwargs)
    foo(*a)

Imports
-------

Imports are not supported syntax in PScript. Imports "from pscript"
and "from __future__" are ignored to help writing hybrid Python/JS
modules.

PScript does provide functionality to package code in JS modules,
but these follow the ``require`` pattern.

"""
</t>
<t tx="ekr.20181108111640.198">class Parser1(Parser0):
    """ Parser that add basic functionality like assignments,
    operations, function calls, and indexing.
    """
    
    ## Literals
    
    @others
</t>
<t tx="ekr.20181108111640.199">def parse_Num(self, node):
    return repr(node.value)

</t>
<t tx="ekr.20181108111640.2">from .parser2 import Parser2
from .parser3 import Parser3

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181108111640.20">def __str__(self):
    return self.tojson()


</t>
<t tx="ekr.20181108111640.200">def parse_Str(self, node):
    return reprs(node.value)

</t>
<t tx="ekr.20181108111640.201">def parse_JoinedStr(self, node):
    parts, value_nodes = [], []
    for n in node.value_nodes:
        if isinstance(n, ast.Str):
            parts.append(n.value)
        else:
            assert isinstance(n, ast.FormattedValue)
            parts.append('{' + self._parse_FormattedValue_fmt(n) + '}')
            value_nodes.append(n.value_node)
    thestring = reprs(''.join(parts))
    return self.use_std_method(thestring, 'format', value_nodes)

</t>
<t tx="ekr.20181108111640.202">def parse_FormattedValue(self, node):  # can als be present standalone
    thestring = "{" + self._parse_FormattedValue_fmt(node) + "}"
    return self.use_std_method(thestring, 'format', [node.value_node])

</t>
<t tx="ekr.20181108111640.203">def _parse_FormattedValue_fmt(self, node):
    """ Return fmt for a FormattedValue node.
    """
    fmt = ''
    if node.conversion:
        fmt += '!' + node.conversion
    if node.format_node and len(node.format_node.value_nodes) &gt; 0:
        if len(node.format_node.value_nodes) &gt; 1:
            raise JSError('String formatting only supports singleton format spec.')
        spec_node = node.format_node.value_nodes[0]
        if not isinstance(spec_node, ast.Str):
            raise JSError('String formatting only supports string format spec.')
        fmt += ':' + spec_node.value
    return fmt

</t>
<t tx="ekr.20181108111640.204">def parse_Bytes(self, node):
    raise JSError('No Bytes in JS')

</t>
<t tx="ekr.20181108111640.205">def parse_NameConstant(self, node):
    M = {True: 'true', False: 'false', None: 'null'}
    return M[node.value]

</t>
<t tx="ekr.20181108111640.206">def parse_List(self, node):
    code = ['[']
    for child in node.element_nodes:
        code += self.parse(child)
        code.append(', ')
    if node.element_nodes:
        code.pop(-1)  # skip last comma
    code.append(']')
    return code

</t>
<t tx="ekr.20181108111640.207">def parse_Tuple(self, node):
    return self.parse_List(node)  # tuple = ~ list in JS

</t>
<t tx="ekr.20181108111640.208">def parse_Dict(self, node):
    # Oh JS; without the outer braces, it would only be an Object if used
    # in an assignment ...
    use_make_dict_func = False
    code = ['({']
    for key, val in zip(node.key_nodes, node.value_nodes):
        if isinstance(key, (ast.Num, ast.NameConstant)):
            code += self.parse(key)
        elif (isinstance(key, ast.Str) and isidentifier1.match(key.value) and
                                           key.value[0] not in '0123456789'):
            code += key.value
        else:
            use_make_dict_func = True
            break
        code.append(': ')
        code += self.parse(val)
        code.append(', ')
    if node.key_nodes:
        code.pop(-1)  # skip last comma
    code.append('})')
    
    # Do we need to use the fallback?
    if use_make_dict_func:
        func_args = []
        for key, val in zip(node.key_nodes, node.value_nodes):
            func_args += [unify(self.parse(key)), unify(self.parse(val))]
        self.use_std_function('create_dict', [])
        return stdlib.FUNCTION_PREFIX + 'create_dict(' + ', '.join(func_args) + ')'
    return code

</t>
<t tx="ekr.20181108111640.209">def parse_Set(self, node):
    raise JSError('No Set in JS')

## Variables

</t>
<t tx="ekr.20181108111640.21">class Comment(Node):
    """
    Attributes:
        value: the comment string.
    """
    __slots__ = 'value',

</t>
<t tx="ekr.20181108111640.210">def push_scope_prefix(self, prefix):
    # To avoid name clashes e.g. in comprehensions, which have their own
    # scope in Python, but we want to apply these as a for loop in JS
    # where possible.
    assert prefix
    self._scope_prefix.append(prefix)

</t>
<t tx="ekr.20181108111640.211">def pop_scope_prefix(self):
    self._scope_prefix.pop(-1)

</t>
<t tx="ekr.20181108111640.212">def parse_Name(self, node, fullname=None):
    # node.ctx can be Load, Store, Del -&gt; can be of use somewhere?
    name = node.name
    if name in reserved_names:
        raise JSError('Cannot use reserved name %s as a variable name!' % name)
    if self.vars.is_known(name):
        return self.with_prefix(name)
    if self._scope_prefix:
        for stackitem in reversed(self._stack):
            scope = stackitem[2]
            for prefix in reversed(self._scope_prefix):
                prefixed_name = prefix + name
                if prefixed_name in scope:
                    return prefixed_name
    if name in self.NAME_MAP:
        return self.NAME_MAP[name]
    # Else ...
    if not (name in self._functions or name in ('undefined', 'window')):
        # mark as used (not defined)
        used_name = (name + '.' + fullname) if fullname else name
        self.vars.use(name, used_name)
    return name

</t>
<t tx="ekr.20181108111640.213">def parse_Starred(self, node):
    # they're present in Call arguments, but we parse them there.
    raise JSError('Starred args are not supported.')

## Expressions

</t>
<t tx="ekr.20181108111640.214">def parse_Expr(self, node):
    # Expression (not stored in a variable)
    code = [self.lf()]
    code += self.parse(node.value_node)
    code.append(';')
    return code

</t>
<t tx="ekr.20181108111640.215">def parse_UnaryOp(self, node):
    if node.op == node.OPS.Not:
        return '!', self._wrap_truthy(node.right_node)
    else:
        op = self.UNARY_OP[node.op]
        right = unify(self.parse(node.right_node))
        return op, right

</t>
<t tx="ekr.20181108111640.216">def parse_BinOp(self, node):
    if node.op == node.OPS.Mod and isinstance(node.left_node, ast.Str):
        # Modulo on a string is string formatting in Python
        return self._format_string(node)
    
    left = unify(self.parse(node.left_node))
    right = unify(self.parse(node.right_node))
    
    if node.op == node.OPS.Add:
        C = ast.Num, ast.Str
        if not (isinstance(node.left_node, C) or
                isinstance(node.right_node, C) or
                (isinstance(node.left_node, ast.BinOp) and
                    node.left_node.op == node.OPS.Add and "op_add" not in left) or
                (isinstance(node.right_node, ast.BinOp) and
                    node.right_node.op == node.OPS.Add and "op_add" not in right)):
            return self.use_std_function('op_add', [left, right])
    elif node.op == node.OPS.Mult:
        C = ast.Num
        if not (isinstance(node.left_node, C) and isinstance(node.right_node, C)):
            return self.use_std_function('op_mult', [left, right])
    elif node.op == node.OPS.Pow:
        return ["Math.pow(", left, ", ", right, ")"]
    elif node.op == node.OPS.FloorDiv:
        return ["Math.floor(", left, "/", right, ")"]
    
    op = ' %s ' % self.BINARY_OP[node.op]
    return [left, op, right]

</t>
<t tx="ekr.20181108111640.217">def _format_string(self, node):
    # Get value_nodes
    if isinstance(node.right_node, (ast.Tuple, ast.List)):
        value_nodes = node.right_node.element_nodes
    else:
        value_nodes = [node.right_node]
    
    # Is the left side a string? If not, exit early
    # This works, but we cannot know whether the left was a string or number :P
    # if not isinstance(node.left_node, ast.Str):
    #     thestring = unify(self.parse(node.left_node))
    #     thestring += ".replace(/%([0-9\.\+\-\#]*[srdeEfgGioxXc])/g, '{:$1}')"
    #     return self.use_std_method(thestring, 'format', value_nodes) 
    
    assert isinstance(node.left_node, ast.Str)
    left = ''.join(self.parse(node.left_node))
    sep, left = left[0], left[1:-1]
    
    # Get matches
    matches = list(re.finditer(r'%[0-9\.\+\-\#]*[srdeEfgGioxXc]', left))
    if len(matches) != len(value_nodes):
        raise JSError('In string formatting, number of placeholders '
                        'does not match number of replacements')
    # Format
    parts = []
    start = 0
    for m in matches:
        fmt = m.group(0)
        fmt = {'%r': '!r', '%s': ''}.get(fmt, ':' + fmt[1:])
        # Add the part in front of the match (and after prev match)
        parts.append(left[start:m.start()])
        parts.append("{%s}" % fmt)
        start = m.end()
    parts.append(left[start:])
    thestring = sep + ''.join(parts) + sep
    return self.use_std_method(thestring, 'format', value_nodes)

</t>
<t tx="ekr.20181108111640.218">def _wrap_truthy(self, node):
    """ Wraps an operation in a truthy call, unless its not necessary. """
    eq_name = stdlib.FUNCTION_PREFIX + 'op_equals'
    test = ''.join(self.parse(node))
    if (False or test.endswith('.length') or test.startswith('!') or
                 test.isnumeric() or test == 'true' or test == 'false' or
                 test.count('==') or test.count('&gt;') or test.count('&lt;') or
                 test.count(eq_name) or
                 test == '"this_is_js()"' or test.startswith('Array.isArray(') or
                 (test.startswith(returning_bool) and '||' not in test)):
        return unify(test)
    else:
        return self.use_std_function('truthy', [test])

</t>
<t tx="ekr.20181108111640.219">def parse_BoolOp(self, node):
    op = ' %s ' % self.BOOL_OP[node.op]
    if node.op.lower() == 'or':  # allow foo = bar or []
        values = [unify(self._wrap_truthy(val)) for val in node.value_nodes[:-1]]
        values += [unify(self.parse(node.value_nodes[-1]))]
    else:
        values = [unify(self._wrap_truthy(val)) for val in node.value_nodes]
    return op.join(values)

</t>
<t tx="ekr.20181108111640.22">class Module(Node):
    """ Each code that an AST is created for gets wrapped in a Module node.
    
    Attributes:
        body_nodes: a list of nodes.
    """
    __slots__ = 'body_nodes',

## Literals

</t>
<t tx="ekr.20181108111640.220">def parse_Compare(self, node):
    
    left = unify(self.parse(node.left_node))
    right = unify(self.parse(node.right_node))
    
    if node.op in (node.COMP.Eq, node.COMP.NotEq) and not left.endswith('.length'):
        code = self.use_std_function('op_equals', [left, right])
        if node.op == node.COMP.NotEq:
            code = '!' + code
        return code
    elif node.op in (node.COMP.In, node.COMP.NotIn):
        self.use_std_function('op_equals', [])  # trigger use of equals
        code = self.use_std_function('op_contains', [left, right])
        if node.op == node.COMP.NotIn:
            code = '!' + code
        return code
    else:
        op = self.COMP_OP[node.op]
        return "%s %s %s" % (left, op, right)

</t>
<t tx="ekr.20181108111640.221">def parse_Call(self, node):
    
    # Get full function name and method name if it exists
    
    if isinstance(node.func_node, ast.Attribute):
        # We dont want to parse twice, because it may add to the vars_unknown
        method_name = node.func_node.attr
        nameparts = self.parse(node.func_node)
        full_name = unify(nameparts)
        nameparts[-1] = nameparts[-1].rsplit('.', 1)[0]
        base_name = unify(nameparts)
    elif isinstance(node.func_node, ast.Subscript):
        base_name = unify(self.parse(node.func_node.value_node))
        full_name = unify(self.parse(node.func_node))
        method_name = ''
    else:  # ast.Name
        method_name = ''
        base_name = ''
        full_name = unify(self.parse(node.func_node))
    
    # Handle special functions and methods
    res = None
    if method_name in self._methods:
        res = self._methods[method_name](node, base_name)
    elif full_name in self._functions:
        res = self._functions[full_name](node)
    if res is not None:
        return res
    
    # Handle normally
    if base_name.endswith('._base_class') or base_name == 'super()':
        # super() was used, use "call" to pass "this"
        return [full_name] + self._get_args(node, 'this', True)
    else:
        code = [full_name] + self._get_args(node, base_name)
        # Insert "new" if this looks like a class
        if base_name == 'this':
            pass
        elif method_name:
            if method_name[0].lower() != method_name[0]:
                code.insert(0, 'new ')
        else:
            fn = full_name
            if fn in self._seen_func_names and fn not in self._seen_class_names:
                pass
            elif fn not in self._seen_func_names and fn in self._seen_class_names:
                code.insert(0, 'new ')
            elif full_name[0].lower() != full_name[0]:
                code.insert(0, 'new ')
        return code

</t>
<t tx="ekr.20181108111640.222">def _get_args(self, node, base_name, use_call_or_apply=False):
    """ Get arguments for function call. Does checking for keywords and
    handles starargs. The first element in the returned list is either
    "(" or ".apply(".
    """
    
    # Can produce:
    # normal:               foo(.., ..)
    # use_call_or_apply:    foo.call(base_name, .., ..)
    # use_starargs:         foo.apply(base_name, vararg_name)
    #           or:         foo.apply(base_name, [].concat([.., ..], vararg_name)
    # has_kwargs:           foo({__args: [], __kwargs: {} })
    #         or:           foo.apply(base_name, ({__args: [], __kwargs: {} })
    
    base_name = base_name or 'null'
    
    # Get arguments
    args_simple, args_array = self._get_positional_args(node)
    kwargs = self._get_keyword_args(node)
    
    if kwargs is not None:
        # Keyword arguments need a whole special treatment
        if use_call_or_apply:
            start = ['.call(', base_name, ', '] 
        else:
            start = ['(']
        return start + ['{', 'flx_args: ', args_array,
                           ', flx_kwargs: ', kwargs, '})']
    elif args_simple is None:
        # Need to use apply
        return [".apply(", base_name, ', ', args_array, ")"]
    elif use_call_or_apply:
        # Need to use call (arg_simple can be empty string)
        if args_simple:
            return [".call(", base_name, ', ', args_simple, ")"]
        else:
            return [".call(", base_name, ")"]
    else: 
        # Normal function call
        return ["(", args_simple, ")"]

</t>
<t tx="ekr.20181108111640.223">def _get_positional_args(self, node):
    """ Returns:
    * a string args_simple, which represents the positional args in comma
      separated form. Can be None if the args cannot be represented that
      way. Note that it can be empty string.
    * a string args_array representing the array with positional arguments.
    """
    
    # Generate list of arg lists (has normal positional args and starargs)
    # Note that there can be multiple starargs and these can alternate.
    argswithcommas = []
    arglists = [argswithcommas]
    for arg in node.arg_nodes:
        if isinstance(arg, ast.Starred):
            starname = ''.join(self.parse(arg.value_node))
            arglists.append(starname)
            argswithcommas = []
            arglists.append(argswithcommas)
        else:
            argswithcommas.extend(self.parse(arg))
            argswithcommas.append(', ')
    
    # Clear empty lists and trailing commas
    for i in reversed(range(len(arglists))):
        arglist = arglists[i]
        if not arglist:
            arglists.pop(i)
        elif arglist[-1] == ', ':
            arglist.pop(-1)
    
    # Generate code for positional arguments
    if len(arglists) == 0:
        return '', '[]'
    elif len(arglists) == 1 and isinstance(arglists[0], list):
        args_simple = ''.join(argswithcommas)
        return args_simple, '[' + args_simple + ']'
    elif len(arglists) == 1:
        assert isinstance(arglists[0], str)
        return None, arglists[0]
    else:
        code = ['[].concat(']
        for arglist in arglists:
            if isinstance(arglist, list):
                code += ['[']
                code += arglist
                code += [']']
            else:
                code += [arglist]
            code += [', ']
        code.pop(-1)
        code += ')'
        return None, ''.join(code)

</t>
<t tx="ekr.20181108111640.224">def _get_keyword_args(self, node):
    """ Get a string that represents the dictionary of keyword arguments,
    or None if there are no keyword arguments (normal nor double-star).
    """
    
    # Collect elements that will make up the total kwarg dict
    kwargs = []
    for kwnode in node.kwarg_nodes:
        if not kwnode.name:  # **xx
            kwargs.append(unify(self.parse(kwnode.value_node)))
        else:  # foo=xx
            if not (kwargs and isinstance(kwargs[-1], list)):
                kwargs.append([])
            kwargs[-1].append('%s: %s' % (kwnode.name,
                                          unify(self.parse(kwnode.value_node))))
    
    # Resolve sequneces of loose kwargs
    for i in range(len(kwargs)):
        if isinstance(kwargs[i], list):
            kwargs[i] = '{' + ', '.join(kwargs[i]) + '}'
    
    # Compose, easy if singleton, otherwise we need to merge
    if len(kwargs) == 0:
        return None
    elif len(kwargs) == 1:
        return kwargs[0]
    else:
        # register use of merge_dicts(), but we build the string ourselves
        self.use_std_function('merge_dicts', [])
        return stdlib.FUNCTION_PREFIX + 'merge_dicts(' + ', '.join(kwargs) + ')'

</t>
<t tx="ekr.20181108111640.225">def parse_Attribute(self, node, fullname=None):
    fullname = node.attr + '.' + fullname if fullname else node.attr
    if isinstance(node.value_node, ast.Name):
        base_name = self.parse_Name(node.value_node, fullname)
    elif isinstance(node.value_node, ast.Attribute):
        base_name = self.parse_Attribute(node.value_node, fullname)
    else:
        base_name = unify(self.parse(node.value_node))
    attr = node.attr
    # Double underscore name mangling
    if attr.startswith('__') and not attr.endswith('__') and base_name == 'this':
        for i in range(len(self._stack)-1, -1, -1):
            if self._stack[i][0] == 'class':
                classname = self._stack[i][1]
                attr = '_' + classname + attr
                break
    if attr in self.ATTRIBUTE_MAP:
        return self.ATTRIBUTE_MAP[attr].replace('{}', base_name)
    else:
        return "%s.%s" % (base_name, attr)

## Statements

</t>
<t tx="ekr.20181108111640.226">def parse_Assign(self, node):
    """ Variable assignment. """
    code = [self.lf()]
    
    # Parse targets
    tuple = []
    for target in node.target_nodes:
        var = ''.join(self.parse(target))
        if isinstance(target, ast.Name):
            if '.' in var:
                code.append(var)
            else:
                self.vars.add(var)
                code.append(self.with_prefix(var))
        elif isinstance(target, ast.Attribute):
            code.append(var)
        elif isinstance(target, ast.Subscript):
            code.append(var)
        elif isinstance(target, (ast.Tuple, ast.List)):
            dummy = self.dummy()
            code.append(dummy)
            tuple = target.element_nodes
        else:
            raise JSError("Unsupported assignment type")
        code.append(' = ')
    
    # Parse right side
    if isinstance(node.value_node, ast.ListComp) and len(node.target_nodes) == 1:
        result_name = self.dummy()
        code.append(result_name + ';')
        lc_code = self.parse_ListComp_funtionless(node.value_node, result_name)
        code = [self.lf(), result_name + ' = [];'] + lc_code + code
    else:
        code += self.parse(node.value_node)
        code.append(';')
    
    # Handle tuple unpacking
    if tuple:
        code.append(self.lf())
        for i, x in enumerate(tuple):
            var = unify(self.parse(x))
            if isinstance(x, ast.Name):  # but not when attr or index
                self.vars.add(var)
            code.append('%s = %s[%i];' % (var, dummy, i))
    
    return code

</t>
<t tx="ekr.20181108111640.227">def parse_AugAssign(self, node):  # -&gt; x += 1
    target = ''.join(self.parse(node.target_node))
    value = ''.join(self.parse(node.value_node))
    
    nl = self.lf()
    if node.op == node.OPS.Add and not isinstance(node.value_node,
                                                  (ast.Num, ast.Str)):
        return [nl, target, ' = ',
                self.use_std_function('op_add', [target, value]), ';']
    elif node.op == node.OPS.Mult:
        return [nl, target, ' = ',
                self.use_std_function('op_mult', [target, value]), ';']
    elif node.op == node.OPS.Pow:
        return [nl, target, " = Math.pow(", target, ", ", value, ");"]
    elif node.op == node.OPS.FloorDiv:
        return [nl, target, " = Math.floor(", target, "/", value, ");"]
    else:
        op = ' %s= ' % self.BINARY_OP[node.op]
        return [nl, target, op, value, ';']

</t>
<t tx="ekr.20181108111640.228">def parse_Delete(self, node):
    code = []
    for target in node.target_nodes:
        code.append(self.lf('delete '))
        code += self.parse(target)
        code.append(';')
    return code

</t>
<t tx="ekr.20181108111640.229">def parse_Pass(self, node):
    return []

## Subscripting

</t>
<t tx="ekr.20181108111640.23">class Num(Node):
    """
    Attributes:
        value: the number as a native Python object (int, float, or complex).
    """
    __slots__ = 'value',

</t>
<t tx="ekr.20181108111640.230">def parse_Subscript(self, node):
    
    value_list = self.parse(node.value_node)
    slice_list = self.parse(node.slice_node)
    
    code = []
    code += value_list
    
    if isinstance(node.slice_node, ast.Index):
        code.append('[')
        if slice_list[0].startswith('-'):
            code.append(unify(value_list) + '.length ')
        code += slice_list
        code.append(']')
    else:  # ast.Slice
        code.append('.slice(')
        code += slice_list
        code.append(')')
    return code

</t>
<t tx="ekr.20181108111640.231">def parse_Index(self, node):
    return self.parse(node.value_node)

</t>
<t tx="ekr.20181108111640.232">def parse_Slice(self, node):
    code = []
    if node.step_node:
        raise JSError('Slicing with step not supported.')
    if node.lower_node:
        code += self.parse(node.lower_node)
    else:
        code.append('0')
    if node.upper_node:
        code.append(',')
        code += self.parse(node.upper_node)
    return code

</t>
<t tx="ekr.20181108111640.233">def parse_ExtSlice(self, node):
    raise JSError('Multidimensional slicing not supported in JS')

## Imports 

</t>
<t tx="ekr.20181108111640.234">def parse_Import(self, node):
    
    if node.root and 'pscript' in node.root:
        # User is probably importing names from here to allow
        # writing the JS code and command to parse it in one module.
        # Ignore this import.
        return []
    if node.root and node.root == '__future__':
        return []  # stuff to help the parser
    if node.root is 'time':
        return []  # PScript natively supports time() and perf_counter()
    raise JSError('PScript does not support imports.')

</t>
<t tx="ekr.20181108111640.235">def parse_Module(self, node):
    # Module level. Every piece of code has a module as the root.
    # Just pass body.
    
    # Get docstring, but only if in module mode 
    # module_mode = self._stack[0][1] # top stack has a name -&gt; works no more
    module_mode = self._pysource and self._pysource[1] == 0  # line nr offset
    docstring = ''
    if self._docstrings and module_mode:
        docstring = self.pop_docstring(node)
    
    code = []
    if docstring:
        for line in docstring.splitlines():
            code.append(self.lf('// ' + line))
        code.append('\n')
    for child in node.body_nodes:
        code += self.parse(child)
    return code
</t>
<t tx="ekr.20181108111640.236">&lt;&lt; parser2 docstring &gt;&gt;

from . import commonast as ast
from . import stdlib
from . import logger
from .parser1 import Parser1, JSError, unify, reprs  # noqa

&lt;&lt; parser2 data &gt;&gt;

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181108111640.237">@language rest

"""

If statements
-------------


.. pscript_example::

    if val &gt; 7:
        result = 42
    elif val &gt; 1:
        result = 1
    else:
        result = 0
    
    # One-line if
    result = 42 if truth else 0
    
    
Looping
-------

There is support for while loops and for-loops in several forms.
Both support ``continue``, ``break`` and the ``else`` clause.

While loops map well to JS

.. pscript_example::

    val = 0
    while val &lt; 10:
        val += 1

Explicit iterating over arrays (and strings):

.. pscript_example::

    # Using range() yields true for-loops
    for i in range(10):
        print(i)
    
    for i in range(100, 10, -2):
        print(i)
    
    # One way to iterate over an array
    for i in range(len(arr)):
        print(arr[i])
    
    # But this is equally valid (and fast)
    for element in arr:
        print(element)


Iterations over dicts:

.. pscript_example::

    # Plain iteration over a dict has a minor overhead
    for key in d:
        print(key)
    
    # Which is why we recommend using keys(), values(), or items()
    for key in d.keys():
        print(key)
    
    for val in d.values():
        print(val)
    
    for key, val in d.items():
        print(key, val, sep=': ')


We can iterate over anything:

.. pscript_example::

    # Strings
    for char in "foo bar":
        print(c)
    
    # More complex data structes
    for i, j in [[1, 2], [3, 4]]:
        print(i+j)

Builtin functions intended for iterations are supported too: 
enumerate, zip, reversed, sorted, filter, map.

.. pscript_example::

    for i, x in enumerate(foo):
        pass
    
    for a, b in zip(foo, bar):
        pass
    
    for x in reversed(sorted(foo)):
        pass
    
    for x in map(lambda x: x+1, foo):
        pass
    
    for x in filter(lambda x: x&gt;0, foo):
        pass


Comprehensions
--------------

.. pscript_example::
    
    # List comprehensions just work
    x = [i*2 for i in some_array if i&gt;0]
    y = [i*j for i in a for j in b]


Defining functions
------------------

.. pscript_example::

    def display(val):
        print(val)
    
    # Support for *args
    def foo(x, *values):
        bar(x+1, *values)
    
    # To write the function in raw JS, use the RawJS call
    def bar(a, b):
        RawJS('''
        var c = 4;
        return a + b + c;
        ''')
    
    # Lambda expressions
    foo = lambda x: x**2


PScript also supports async functions and await syntax. (These map to
``async`` and ``await`` in JS, which work in about every browser except IE.):

.. pscript_example::

    async def getresult(uri):
        response = await window.fetch(uri)
        return await response.text()


Defining classes
----------------

Classes are translated to the JavaScript prototypal class paragigm,
which means that they should play well with other JS libraries and e.g.
`instanceof`. Inheritance is supported, but not multiple inheritance.
Further, `super()` works just as in Python 3.

.. pscript_example::
    
    class Foo:
        a_class_attribute = 4
        def __init__(self):
            self.x = 3
    
    class Bar(Foo):
        def __init__(self):
            super.__init__()
            self.x += 1
        def add1(self):
            self.x += 1
    
    # Methods are bound functions, like in Python
    b = Bar()
    setTimeout(b.add1, 1000)
    
    # Functions defined in methods (and that do not start with self or this)
    # have ``this`` bound the the same object.
    class Spam(Bar):
        def add_later(self):
            setTimeout(lambda ev: self.add1(), 1000)


Exceptions
----------

Raised exceptions are translated to a JavaScript Error objects, for
which the ``name`` attribute is set to the type of the exception being
raised. When catching exceptions the name attribute is checked (if its
an Error object. You can raise strings or any other kind of object, but
you can only catch Error objects.

.. pscript_example::
    
    # Throwing/raising exceptions
    raise SomeError('asd')
    raise AnotherError()
    raise "In JS you can throw anything"
    raise 4
    
    # Assertions work too
    assert foo == 3
    assert bar == 4, "bar should be 4"
    
    # Catching exceptions
    try:
        raise IndexError('blabla')
    except IndexError as err:
        print(err)
    except Exception:
       print('something went wrong')

Globals and nonlocal
--------------------

.. pscript_example::
    
    a = 3
    def foo():
        global a
        a = 4
    foo()
    # a is now 4

"""
</t>
<t tx="ekr.20181108111640.238">class Parser2(Parser1):
    """ Parser that adds control flow, functions, classes, and exceptions.
    """
    
    ## Exceptions
    
    @others
</t>
<t tx="ekr.20181108111640.239">def parse_Raise(self, node):
    # We raise the exception as an Error object
    
    if node.exc_node is None:
        raise JSError('When raising, provide an error object.')
    if node.cause_node is not None:
        raise JSError('When raising, "cause" is not supported.')
    err_node = node.exc_node
    
    # Get cls and msg
    err_cls, err_msg = None, "''"
    if isinstance(err_node, ast.Name):
        if err_node.name[0].islower():  # raise an (error) object
            return [self.lf("throw " + err_node.name + ';')]
        err_cls = err_node.name
    elif isinstance(err_node, ast.Call):
        err_cls = err_node.func_node.name
        err_msg = ''.join([unify(self.parse(arg)) for arg in err_node.arg_nodes])
    else:
        err_msg = ''.join(self.parse(err_node))
    
    err_name = 'err_%i' % self._indent
    self.vars.add(err_name)
    
    # Build code to throw
    if err_cls:
        code = self.use_std_function('op_error', 
                                     ["'%s'" % err_cls, err_msg or '""'])
    else:
        code = err_msg
    return [self.lf('throw ' + code + ';')]

</t>
<t tx="ekr.20181108111640.24">class Str(Node):
    """
    Attributes:
        value: the native Python str object.
    """
    __slots__ = 'value',

</t>
<t tx="ekr.20181108111640.240">def parse_Assert(self, node):
    
    test = ''.join(self.parse(node.test_node))
    msg = test
    if node.msg_node:
        msg = ''.join(self.parse(node.msg_node))
    
    code = []
    code.append(self.lf('if (!('))
    code += test
    code.append(')) { throw ')
    code.append(self.use_std_function('op_error', ["'AssertionError'", reprs(msg)]))
    code.append(";}")
    return code

</t>
<t tx="ekr.20181108111640.241">def parse_Try(self, node):
    if node.else_nodes:
        raise JSError('No support for try-else clause.')
    
    code = []
    
    # Try
    if True:
        code.append(self.lf('try {'))
        self._indent += 1
        for n in node.body_nodes:
            code += self.parse(n)
        self._indent -= 1
        code.append(self.lf('}'))
    
    # Except
    if node.handler_nodes:
        self._indent += 1
        err_name = 'err_%i' % self._indent
        code.append(' catch(%s) {' % err_name)
        subcode = []
        for i, handler in enumerate(node.handler_nodes):
            if i == 0:
                code.append(self.lf(''))
            else:
                code.append(' else ')
            subcode = self.parse(handler)
            code += subcode
        
        # Rethrow?
        if subcode and subcode[0].startswith('if'):
            code.append(' else { throw %s; }' % err_name)
        
        self._indent -= 1
        code.append(self.lf('}'))  # end catch
    
    # Finally
    if node.finally_nodes:
        code.append(' finally {')
        self._indent += 1
        for n in node.finally_nodes:
            code += self.parse(n)
        self._indent -= 1
        code.append(self.lf('}'))  # end finally
    
    return code
    
</t>
<t tx="ekr.20181108111640.242">def parse_ExceptHandler(self, node):
    err_name = 'err_%i' % self._indent
    
    # Setup the catch
    code = []
    err_type = unify(self.parse(node.type_node)) if node.type_node else ''
    self.vars.discard(err_type)
    if err_type and err_type != 'Exception':
        code.append('if (%s instanceof Error &amp;&amp; %s.name === "%s") {' %
                    (err_name, err_name, err_type))
    else:
        code.append('{')
    self._indent += 1
    if node.name:
        code.append(self.lf('%s = %s;' % (node.name, err_name)))
        self.vars.add(node.name)
    
    # Insert the body
    for n in node.body_nodes:
        code += self.parse(n)
    self._indent -= 1
    
    code.append(self.lf('}'))
    return code

</t>
<t tx="ekr.20181108111640.243">def parse_With(self, node):
    code = []
    
    if len(node.item_nodes) != 1:
        raise JSError('With statement only supported for singleton contexts.')
    with_item = node.item_nodes[0]
    context_name = unify(self.parse(with_item.expr_node))
    
    # Store context expression in a variable?
    if '(' in context_name or '[' in context_name:
        ctx = self.dummy('context')
        code.append(self.lf(ctx + ' = ' + context_name + ';'))
        context_name = ctx
    
    err_name1 = 'err_%i' % self._indent
    err_name2 = self.dummy('err')
    
    # Enter
    # for with_item in node.item_nodes: ...
    if with_item.as_node is None:
        code.append(self.lf(''))
    elif isinstance(with_item.as_node, ast.Name):
        self.vars.add(with_item.as_node.name)
        code.append(self.lf(with_item.as_node.name + ' = '))
    elif isinstance(with_item.as_node, ast.Attribute):
        code += [self.lf()] + self.parse(with_item.as_node) + [' = ']
    else:
        raise JSError('The as-node in a with-statement must be a name or attr.')
    code += [context_name, '.__enter__();']
    
    # Try
    code.append(self.lf('try {'))
    self._indent += 1
    for n in node.body_nodes:
        code += self.parse(n)
    self._indent -= 1
    code.append(self.lf('}'))
    
    # Exit
    code.append(' catch(%s)  { %s=%s; }' % (err_name1, err_name2, err_name1))
    code.append(self.lf() + 'if (%s) { '
                'if (!%s.__exit__(%s.name || "error", %s, null)) '
                '{ throw %s; }' %
                (err_name2, context_name, err_name2, err_name2, err_name2))
    code.append(self.lf() + '} else { %s.__exit__(null, null, null); }' % 
                context_name)
    return code

# def parse_Withitem(self, node) -&gt; handled in parse_With

## Control flow

</t>
<t tx="ekr.20181108111640.244">def parse_IfExp(self, node):
    # in "a if b else c"
    a = self.parse(node.body_node)
    b = self._wrap_truthy(node.test_node)
    c = self.parse(node.else_node)
    
    code = []
    code.append('(')
    code += b
    code.append(')? (')
    code += a
    code.append(') : (')
    code += c
    code.append(')')
    return code

</t>
<t tx="ekr.20181108111640.245">def parse_If(self, node):
    if (True and isinstance(node.test_node, ast.Compare) and
                 isinstance(node.test_node.left_node, ast.Name) and
                 node.test_node.left_node.name == '__name__'):
        # Ignore ``__name__ == '__main__'``, since it may be
        # used inside a PScript file for the compiling.
        return []
    
    # Shortcut for this_is_js() cases, discarting the else to reduce code
    if (True and isinstance(node.test_node, ast.Call) and
                 isinstance(node.test_node.func_node, ast.Name) and
                 node.test_node.func_node.name == 'this_is_js'):
        code = [self.lf('if ('), 'true', ') ', '{ /* if this_is_js() */']
        self._indent += 1
        for stmt in node.body_nodes:
            code += self.parse(stmt)
        self._indent -= 1
        code.append(self.lf('}'))
        return code
    
    # Disable body if "not this_is_js()"
    if (True and isinstance(node.test_node, ast.UnaryOp) and
                 node.test_node.op == 'Not' and
                 isinstance(node.test_node.right_node, ast.Call) and
                 isinstance(node.test_node.right_node.func_node, ast.Name) and
                 node.test_node.right_node.func_node.name == 'this_is_js'):
        node.body_nodes = []
    
    code = [self.lf('if (')]  # first part (popped in elif parsing)
    code.append(self._wrap_truthy(node.test_node))
    code.append(') {')
    self._indent += 1
    for stmt in node.body_nodes:
        code += self.parse(stmt)
    self._indent -= 1
    if node.else_nodes:
        if len(node.else_nodes) == 1 and isinstance(node.else_nodes[0], ast.If):
            code.append(self.lf("} else if ("))
            code += self.parse(node.else_nodes[0])[1:-1]  # skip first and last
        else:
            code.append(self.lf("} else {"))
            self._indent += 1
            for stmt in node.else_nodes:
                code += self.parse(stmt)
            self._indent -= 1
    code.append(self.lf("}"))  # last part (popped in elif parsing)
    return code

</t>
<t tx="ekr.20181108111640.246">def parse_For(self, node):
    # Note that enumerate, reversed, sorted, filter, map are handled in parser3
    
    METHODS = 'keys', 'values', 'items'
    
    iter = None  # what to iterate over
    sure_is_dict = False  # flag to indicate that we're sure iter is a dict
    sure_is_range = False  # dito for range
    
    # First see if this for-loop is something that we support directly
    if isinstance(node.iter_node, ast.Call):
        f = node.iter_node.func_node
        if (isinstance(f, ast.Attribute) and
                not node.iter_node.arg_nodes and f.attr in METHODS):
            sure_is_dict = f.attr
            iter = ''.join(self.parse(f.value_node))
        elif isinstance(f, ast.Name) and f.name in ('xrange', 'range'):
            sure_is_range = [''.join(self.parse(arg)) for arg in 
                             node.iter_node.arg_nodes]
            iter = 'range'  # stub to prevent the parsing of iter_node below
    
    # Otherwise we parse the iter
    if iter is None:
        iter = ''.join(self.parse(node.iter_node))
    
    # Get target
    if isinstance(node.target_node, ast.Name):
        target = [node.target_node.name]
        if sure_is_dict == 'values':
            target.append(target[0])
        elif sure_is_dict == 'items':
            raise JSError('Iteration over a dict with .items() '
                          'needs two iterators.')
    elif isinstance(node.target_node, ast.Tuple):
        target = [''.join(self.parse(t)) for t in node.target_node.element_nodes]
        if sure_is_dict:
            if not (sure_is_dict == 'items' and len(target) == 2):
                raise JSError('Iteration over a dict needs one iterator, '
                              'or 2 when using .items()')
        elif sure_is_range:
            raise JSError('Iterarion via range() needs one iterator.')
    else:
        raise JSError('Invalid iterator in for-loop')
    
    # Collect body and else-body
    for_body = []
    for_else = []
    self._indent += 1
    for n in node.body_nodes:
        for_body += self.parse(n)
    for n in node.else_nodes:
        for_else += self.parse(n)
    self._indent -= 1
    
    # Init code
    code = []
    
    # Prepare variable to detect else
    if node.else_nodes:
        else_dummy = self.dummy('els')
        code.append(self.lf('%s = true;' % else_dummy))
    
    # Declare iteration variables if necessary
    for t in target:
        self.vars.add(t)
    
    if sure_is_range:  # Explicit iteration
        # Get range args
        nums = sure_is_range  # The range() arguments
        assert len(nums) in (1, 2, 3)
        if len(nums) == 1:
            start, end, step = '0', nums[0], '1'
        elif len(nums) == 2:
            start, end, step = nums[0], nums[1], '1'
        elif len(nums) == 3:
            start, end, step = nums[0], nums[1], nums[2]
        # Build for-loop in JS
        t = 'for ({i} = {start}; {i} &lt; {end}; {i} += {step})'
        if step.lstrip('+-').isdecimal() and float(step) &lt; 0:
            t = t.replace('&lt;', '&gt;')
        assert len(target) == 1
        t = t.format(i=target[0], start=start, end=end, step=step) + ' {'
        code.append(self.lf(t))
        self._indent += 1
    
    elif sure_is_dict:  # Enumeration over an object (i.e. a dict)
        # Create dummy vars
        d_seq = self.dummy('seq')
        code.append(self.lf('%s = %s;' % (d_seq, iter)))
        # The loop
        code += self.lf(), 'for (', target[0], ' in ', d_seq, ') {'
        self._indent += 1
        code.append(self.lf('if (!%s.hasOwnProperty(%s)){ continue; }' %
                            (d_seq, target[0])))
        # Set second/alt iteration variable
        if len(target) &gt; 1:
            code.append(self.lf('%s = %s[%s];' % (target[1], d_seq, target[0])))
    
    else:  # Enumeration
        
        # We cannot know whether the thing to iterate over is an
        # array or a dict. We use a for-iterarion (otherwise we
        # cannot be sure of the element order for arrays). Before
        # running the loop, we test whether its an array. If its
        # not, we replace the sequence with the keys of that
        # sequence. Peformance for arrays should be good. For
        # objects probably slightly less.
        
        # Create dummy vars
        d_seq = self.dummy('seq')
        d_iter = self.dummy('itr')
        d_target = target[0] if (len(target) == 1) else self.dummy('tgt')
        
        # Ensure our iterable is indeed iterable
        code.append(self._make_iterable(iter, d_seq))
        
        # The loop
        code.append(self.lf('for (%s = 0; %s &lt; %s.length; %s += 1) {' %
                            (d_iter, d_iter, d_seq, d_iter)))
        self._indent += 1
        code.append(self.lf('%s = %s[%s];' % (d_target, d_seq, d_iter)))
        if len(target) &gt; 1:
            code.append(self.lf(self._iterator_assign(d_target, *target)))
    
    # The body of the loop
    code += for_body
    self._indent -= 1
    code.append(self.lf('}'))
    
    # Handle else
    if node.else_nodes:
        code.append(' if (%s) {' % else_dummy)
        code += for_else
        code.append(self.lf("}"))
        # Update all breaks to set the dummy. We overwrite the
        # "break;" so it will not be detected by a parent loop
        ii = [i for i, part in enumerate(code) if part=='break;']
        for i in ii:
            code[i] = '%s = false; break;' % else_dummy
    
    return code

</t>
<t tx="ekr.20181108111640.247">def _make_iterable(self, name1, name2, newlines=True):
    code = []
    lf = self.lf
    if not newlines:  # pragma: no cover
        lf = lambda x: x
    
    if name1 != name2:
        code.append(lf('%s = %s;' % (name2, name1)))
    code.append(lf('if ((typeof %s === "object") &amp;&amp; '
                   '(!Array.isArray(%s))) {' % (name2, name2)))
    code.append(' %s = Object.keys(%s);' % (name2, name2))
    code.append('}')
    return ''.join(code)

</t>
<t tx="ekr.20181108111640.248">def parse_While(self, node):
    
    test = ''.join(self.parse(node.test_node))
    
    # Collect body and else-body
    for_body = []
    for_else = []
    self._indent += 1
    for n in node.body_nodes:
        for_body += self.parse(n)
    for n in node.else_nodes:
        for_else += self.parse(n)
    self._indent -= 1
    
    # Init code
    code = []
    
    # Prepare variable to detect else
    if node.else_nodes:
        else_dummy = self.dummy('els')
        code.append(self.lf('%s = true;' % else_dummy))
    
    # The loop itself
    code.append(self.lf("while (%s) {" % test))
    self._indent += 1
    code += for_body
    self._indent -= 1
    code.append(self.lf('}'))
    
    # Handle else
    if node.else_nodes:
        code.append(' if (%s) {' % else_dummy)
        code += for_else
        code.append(self.lf("}"))
        # Update all breaks to set the dummy. We overwrite the
        # "break;" so it will not be detected by a parent loop
        ii = [i for i, part in enumerate(code) if part=='break;']
        for i in ii:
            code[i] = '%s = false; break;' % else_dummy
    
    return code

</t>
<t tx="ekr.20181108111640.249">def parse_Break(self, node):
    # Note that in parse_For, we detect breaks and modify them to
    # deal with the for-else clause
    return [self.lf(), 'break;']

</t>
<t tx="ekr.20181108111640.25">class FormattedValue(Node):
    """ Node representing a single formatting field in an f-string. If the
    string contains a single formatting field and nothing else the node can be
    isolated, otherwise it appears in JoinedStr.
    
    Attributes:
        value_node: an expression (can be anything).
        conversion: a string, '' means no formatting, 's' means !s string
            formatting, 'r' means !r repr formatting, 'a' means !a ascii
            formatting.
        format_node:  a JoinedStr node reprensenting the formatting, or None
            if no format was specified. Both conversion and format_node can be
            set at the same time.
    """
    __slots__ = 'value_node', 'conversion', 'format_node'

</t>
<t tx="ekr.20181108111640.250">def parse_Continue(self, node):
    return self.lf('continue;')

## Comprehensions

</t>
<t tx="ekr.20181108111640.251">def parse_ListComp_funtionless(self, node, result_name):
    
    prefix = result_name
    self.push_scope_prefix(prefix)
    code = []
    
    for iter, comprehension in enumerate(node.comp_nodes):
        cc = []
        # Get target (can be multiple vars)
        if isinstance(comprehension.target_node, ast.Tuple):
            target = [namenode.name for namenode in
                      comprehension.target_node.element_nodes]
        else:
            target = [comprehension.target_node.name]
        for i in range(len(target)):
            if not self.vars.is_known(target[i]):
                target[i] = prefix + target[i]
                self.vars.add(target[i])
        self.vars.add(prefix + 'i%i' % iter)
        self.vars.add(prefix + 'iter%i' % iter)
        
        # comprehension(target_node, iter_node, if_nodes)
        cc.append('iter# = %s;' % ''.join(self.parse(comprehension.iter_node)))
        cc.append('if ((typeof iter# === "object") &amp;&amp; '
                '(!Array.isArray(iter#))) {iter# = Object.keys(iter#);}')
        cc.append('for (i#=0; i#&lt;iter#.length; i#++) {')
        cc.append(self._iterator_assign('iter#[i#]', *target))
        # Ifs
        if comprehension.if_nodes:
            cc.append('if (!(')
            for iff in comprehension.if_nodes:
                cc += unify(self.parse(iff))
                cc.append('&amp;&amp;')
            cc.pop(-1)  # pop '&amp;&amp;'
            cc.append(')) {continue;}')
        # Insert code for this comprehension loop
        code.append(''.join(cc).replace('i#', prefix + 'i%i' % iter).replace(
                                        'iter#', prefix + 'iter%i' % iter))
    
    # Push result
    elt = ''.join(self.parse(node.element_node))
    code.append('{%s.push(%s);}' % (result_name, elt))
    for comprehension in node.comp_nodes:
        code.append('}')  # end for
    
    self.pop_scope_prefix()
    return code

</t>
<t tx="ekr.20181108111640.252">def parse_ListComp(self, node):
    
    self.push_stack('function', 'listcomp')
    elt = ''.join(self.parse(node.element_node))
    code = ['(function list_comprehension (iter0) {', 'var res = [];']
    vars = []
    
    for iter, comprehension in enumerate(node.comp_nodes):
        cc = []
        # Get target (can be multiple vars)
        if isinstance(comprehension.target_node, ast.Tuple):
            target = [''.join(self.parse(t)) for t in 
                      comprehension.target_node.element_nodes]
        else:
            target = [''.join(self.parse(comprehension.target_node))]
        for t in target:
            vars.append(t)
        vars.append('i%i' % iter)
        
        # comprehension(target_node, iter_node, if_nodes)
        if iter &gt; 0:  # first one is passed to function as an arg
            cc.append('iter# = %s;' % ''.join(self.parse(comprehension.iter_node)))
            vars.append('iter%i' % iter)
        cc.append('if ((typeof iter# === "object") &amp;&amp; '
                '(!Array.isArray(iter#))) {iter# = Object.keys(iter#);}')
        cc.append('for (i#=0; i#&lt;iter#.length; i#++) {')
        cc.append(self._iterator_assign('iter#[i#]', *target))
        # Ifs
        if comprehension.if_nodes:
            cc.append('if (!(')
            for iff in comprehension.if_nodes:
                cc += unify(self.parse(iff))
                cc.append('&amp;&amp;')
            cc.pop(-1)  # pop '&amp;&amp;'
            cc.append(')) {continue;}')
        # Insert code for this comprehension loop
        code.append(''.join(cc).replace('i#', 'i%i' % iter).replace(
                                        'iter#', 'iter%i' % iter))
    # Push result
    code.append('{res.push(%s);}' % elt)
    for comprehension in node.comp_nodes:
        code.append('}')  # end for
    # Finalize
    code.append('return res;})')  # end function
    iter0 = ''.join(self.parse(node.comp_nodes[0].iter_node))
    code.append('.call(this, ' + iter0 + ')')  # call funct with iter as 1st arg
    code.insert(2, 'var %s;' % ', '.join(vars))
    # Clean vars
    for var in vars:
        self.vars.add(var)
    self.pop_stack()
    return code
    
    # todo: apply the apply(this) trick everywhere where we use a function

# SetComp
# GeneratorExp
# DictComp
# comprehension

</t>
<t tx="ekr.20181108111640.253">def _iterator_assign(self, val, *names):
    if len(names) == 1:
        return '%s = %s;' % (names[0], val)
    else:
        code = []
        for i, name in enumerate(names):
            code.append('%s = %s[%i];' % (name, val, i))
        return ' '.join(code)

## Functions and class definitions

</t>
<t tx="ekr.20181108111640.254">def parse_FunctionDef(self, node, lambda_=False, asyn=False):
    # Common code for the FunctionDef and Lambda nodes.
    
    has_self = node.arg_nodes and node.arg_nodes[0].name in ('self', 'this')
    
    # Bind if this function is inside a function, and does not have self
    binder = ''  # code to add to the end
    if len(self._stack) &gt;= 1 and self._stack[-1][0] == 'function':
        if not has_self:
            binder = ').bind(this)'
    
    # Init function definition
    # Non-anonymouse functions get a name so that they are debugged more
    # easily and resolve to the correct event labels in flexx.event. However,
    # we cannot use the exact name, since we don't want to actually *use* it.
    # Classes give their methods a __name__, so no need to name these.
    code = []
    func_name = ''
    if not lambda_:
        if not has_self:
            func_name = 'flx_' + node.name
        prefixed = self.with_prefix(node.name)
        if prefixed == node.name:  # normal function vs method
            self.vars.add(node.name)
            self._seen_func_names.add(node.name)
        code.append(self.lf('%s = ' % prefixed))
    code.append('%s%sfunction %s%s(' % ('(' if binder else '',
                                      'async ' if asyn else '',
                                      func_name,
                                      ' ' if func_name else ''))
    
    # Collect args
    argnames = []
    for arg in node.arg_nodes:  # ast.Arg nodes
        name = self.NAME_MAP.get(arg.name, arg.name)
        if name != 'this':
            argnames.append(name)
            # Add code and comma
            code.append(name)
            code.append(', ')
    if argnames:
        code.pop(-1)  # pop last comma
    
    # Check
    if (not lambda_) and node.decorator_nodes:
        if not (len(node.decorator_nodes) == 1 and
                isinstance(node.decorator_nodes[0], ast.Name) and
                node.decorator_nodes[0].name == 'staticmethod'):
            raise JSError('No support for function decorators')
    
    # Prepare for content
    code.append(') {')
    pre_code, code = code, []
    self._indent += 1
    self.push_stack('function', '' if lambda_ else node.name)
    
    # Add argnames to known vars
    for name in argnames:
        self.vars.add(name)
    
    # Prepare code for varargs
    vararg_code1 = vararg_code2 = ''
    if node.args_node:
        name = node.args_node.name  # always an ast.Arg
        self.vars.add(name)
        if not argnames:
            # Make available under *arg name
            #code.append(self.lf('%s = arguments;' % name))
            vararg_code1 = '%s = Array.prototype.slice.call(arguments);' % name
            vararg_code2 = '%s = arguments[0].flx_args;' % name
        else:
            # Slice it
            x = name, len(argnames)
            vararg_code1 = '%s = Array.prototype.slice.call(arguments, %i);' % x
            vararg_code2 = '%s = arguments[0].flx_args.slice(%i);' % x
    
    # Handle keyword arguments and kwargs
    kw_argnames = set()  # variables that come from keyword args, or helper vars
    if node.kwarg_nodes or node.kwargs_node:
        # Collect names and default values
        names, values = [], []
        for arg in node.kwarg_nodes:
            self.vars.add(arg.name)
            kw_argnames.add(arg.name)
            names.append("'%s'" % arg.name)
            values.append(''.join(self.parse(arg.value_node)))
        # Turn into string representation
        names = '[' + ', '.join(names) + ']'
        values = '[' + ', '.join(values) + ']'
        # Write code to prepare for kwargs
        if node.kwargs_node:
            code.append(self.lf('%s = {};' % node.kwargs_node.name))
        if node.kwarg_nodes:
            values_var = self.dummy('kw_values')
            kw_argnames.add(values_var)
            code += [self.lf(values_var), ' = ', values, ';']
        else:
            values_var = values
        # Enter if to actually parse kwargs
        code.append(self.lf(
            "if (arguments.length == 1 &amp;&amp; typeof arguments[0] == 'object' &amp;&amp; "
            "Object.keys(arguments[0]).toString() == 'flx_args,flx_kwargs') {"))
        self._indent += 1
        # Call function to parse args
        code += [self.lf()]
        if node.kwargs_node:
            kw_argnames.add(node.kwargs_node.name)
            self.vars.add(node.kwargs_node.name)
            code += [node.kwargs_node.name, ' = ']
        self.use_std_function('op_parse_kwargs', [])
        code += [stdlib.FUNCTION_PREFIX + 'op_parse_kwargs(',
                 names, ', ', values_var, ', arguments[0].flx_kwargs']
        if not node.kwargs_node:
            code.append(", '%s'" % func_name or 'anonymous')
        code.append(');')
        # Apply values of positional args
        # inside if, because standard arguments are invalid
        args_var = 'arguments[0].flx_args'
        if len(argnames) &gt; 1:
            args_var = self.dummy('args')
            code.append(self.lf('%s = arguments[0].flx_args;' % args_var))
        for i, name in enumerate(argnames):
            code.append(self.lf('%s = %s[%i];' % (name, args_var, i)))
        # End if
        if vararg_code2:
            code.append(self.lf(vararg_code2))
        self._indent -= 1
        code.append(self.lf('}'))
        if vararg_code1:
            code += [' else {', vararg_code1, '}']
        # Apply values of keyword-only args
        # outside if, because these need to be assigned always
        # Note that we cannot use destructuring assignment because not all
        # browsers support it (meh IE and Safari!)
        for i, arg in enumerate(node.kwarg_nodes):
            code.append(self.lf('%s = %s[%i];' % (arg.name, values_var, i)))
    else:
        if vararg_code1:
            code.append(self.lf(vararg_code1))
    
    # Apply defaults of positional arguments
    for arg in node.arg_nodes:
        if arg.value_node is not None:
            name = arg.name
            d = ''.join(self.parse(arg.value_node))
            x = '%s = (%s === undefined) ? %s: %s;' % (name, name, d, name)
            code.append(self.lf(x))
    
    # Apply content
    if lambda_:
        code.append('return ')
        code += self.parse(node.body_node)
        code.append(';')
    else:
        docstring = self.pop_docstring(node)
        if docstring and not node.body_nodes:
            # Raw JS - but deprecated
            logger.warn(RAW_DOC_WARNING % node.name)
            for line in docstring.splitlines():
                code.append(self.lf(line))
        else:
            # Normal function
            if self._docstrings:
                for line in docstring.splitlines():
                    code.append(self.lf('// ' + line))
            for child in node.body_nodes:
                code += self.parse(child)
    
    # Wrap up
    if lambda_:
        code.append('}%s' % binder)
        # ns should only consist only of arg names (or helpers)
        for name in argnames:
            self.vars.discard(name)
        if node.args_node:
            self.vars.discard(node.args_node.name)
        ns = self.pop_stack()
        assert set(ns) == kw_argnames
        pre_code.append(self.get_declarations(ns))
    else:
        if not (code and code[-1].strip().startswith('return ')):
            code.append(self.lf('return null;'))
        # Declare vars, but exclude our argnames
        for name in argnames:
            self.vars.discard(name)
        ns = self.pop_stack()
        pre_code.append(self.get_declarations(ns))
    
    self._indent -= 1
    if not lambda_:
        code.append(self.lf('}%s;\n' % binder))
    return pre_code + code

</t>
<t tx="ekr.20181108111640.255">def parse_Lambda(self, node):
    return self.parse_FunctionDef(node, True)

</t>
<t tx="ekr.20181108111640.256">def parse_AsyncFunctionDef(self, node):
    return self.parse_FunctionDef(node, False, True)

</t>
<t tx="ekr.20181108111640.257">def parse_Return(self, node):
    if node.value_node is not None:
        return self.lf('return %s;' % ''.join(self.parse(node.value_node)))
    else:
        return self.lf("return null;")

</t>
<t tx="ekr.20181108111640.258">def parse_ClassDef(self, node):
    
    # Checks
    if len(node.arg_nodes) &gt; 1:
        raise JSError('Multiple inheritance not (yet) supported.')
    if node.kwarg_nodes:
        raise JSError('Metaclasses not supported.')
    if node.decorator_nodes:
        raise JSError('Class decorators not supported.')
    
    # Get base class (not the constructor)
    base_class = 'Object'
    if node.arg_nodes:
        base_class = ''.join(self.parse(node.arg_nodes[0]))
    if not base_class.replace('.', '_').isalnum():
        raise JSError('Base classes must be simple names')
    elif base_class.lower() == 'object':  # maybe Python "object"
        base_class = 'Object'
    else:
        base_class = base_class + '.prototype'
    
    # Define function that acts as class constructor
    code = []
    docstring = self.pop_docstring(node) 
    docstring = docstring if self._docstrings else ''
    for line in get_class_definition(node.name, base_class, docstring):
        code.append(self.lf(line))
    self.use_std_function('op_instantiate', [])
    
    # Body ...
    self.vars.add(node.name)
    self._seen_class_names.add(node.name)
    self.push_stack('class', node.name)
    for sub in node.body_nodes:
        code += self.parse(sub)
    code.append('\n')
    self.pop_stack()
    # no need to declare variables, because they're prefixed
    
    return code

</t>
<t tx="ekr.20181108111640.259">def function_super(self, node):
    # allow using super() in methods
    # Note that in parse_Call() we ensure that a call using super
    # uses .call(this, ...) so that the instance is handled ok.
    
    if node.arg_nodes:
        #raise JSError('super() accepts 0 or 1 arguments.')
        pass  # In Python 2, arg nodes are provided, and we ignore them
    if len(self._stack) &lt; 3:  # module, class, function
        #raise JSError('can only use super() inside a method.')
        # We just provide "super()" and hope that the user will
        # replace the code (as we do in the Model class).
        return 'super()'
    
    # Find the class of this function. Using this._base_class would work
    # in simple situations, but not when there's two levels of super().
    nstype1, nsname1, _ = self._stack[-1]
    nstype2, nsname2, _ = self._stack[-2]
    if not (nstype1 == 'function' and nstype2 == 'class'):
        raise JSError('can only use super() inside a method.')
    
    base_class = nsname2
    return '%s.prototype._base_class' % base_class

#def parse_Yield
#def parse_YieldFrom

</t>
<t tx="ekr.20181108111640.26">class JoinedStr(Node):
    """ An f-string, comprising a series of FormattedValue and Str nodes.
    
    Attributes:
        value_nodes: list of Str and FormattedValue nodes.
    """
    __slots__ = 'value_nodes',

</t>
<t tx="ekr.20181108111640.260">def parse_Await(self, node):
    return 'await %s' % ''.join(self.parse(node.value_node))

</t>
<t tx="ekr.20181108111640.261">def parse_Global(self, node):
    for name in node.names:
        self.vars.set_global(name)
    return '' 

</t>
<t tx="ekr.20181108111640.262">def parse_Nonlocal(self, node):
    for name in node.names:
        self.vars.set_nonlocal(name)
    return '' 


</t>
<t tx="ekr.20181108111640.263">def get_class_definition(name, base='Object', docstring=''):
    """ Get a list of lines that defines a class in JS.
    Used in the parser as well as by flexx.app.Component.
    """
    code = []
    
    code.append('%s = function () {' % name)
    for line in docstring.splitlines():
        code.append('    // ' + line)
    code.append('    %sop_instantiate(this, arguments);' % stdlib.FUNCTION_PREFIX)
    code.append('}')
    
    if base != 'Object':
        code.append('%s.prototype = Object.create(%s);' % (name, base))
    code.append('%s.prototype._base_class = %s;' % (name, base))
    code.append('%s.prototype.__name__ = %s;' % (name, reprs(name.split('.')[-1])))
    
    code.append('')
    return code
</t>
<t tx="ekr.20181108111640.264">&lt;&lt; parser3 docstring &gt;&gt;

from . import commonast as ast
from . import stdlib
from .parser2 import Parser2, JSError, unify  # noqa
from .stubs import RawJS

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181108111640.265">@language rest
@wrap

"""

Python Builtins
---------------

Most builtin functions (that make sense in JS) are automatically
translated to JavaScript: isinstance, issubclass, callable, hasattr,
getattr, setattr, delattr, print, len, max, min, chr, ord, dict, list,
tuple, range, pow, sum, round, int, float, str, bool, abs, divmod, all,
any, enumerate, zip, reversed, sorted, filter, map.

Further all methods for list, dict and str are implemented (except str
methods: encode, decode, format_map, isprintable, maketrans).

.. pscript_example::

    # "self" is replaced with "this"
    self.foo
    
    # Printing just works
    print('some test')
    print(a, b, c, sep='-')
    
    # Getting the length of a string or array
    len(foo)
    
    # Rounding and abs
    round(foo)  # round to nearest integer
    int(foo)  # round towards 0 as in Python
    abs(foo)
    
    # min and max
    min(foo)
    min(a, b, c)
    max(foo)
    max(a, b, c)
    
    # divmod
    a, b = divmod(100, 7)  # -&gt; 14, 2
    
    # Aggregation
    sum(foo)
    all(foo)
    any(foo)
    
    # Turning things into numbers, bools and strings
    str(s)
    float(x)
    bool(y)
    int(z)  # this rounds towards zero like in Python
    chr(65)  # -&gt; 'A'
    ord('A')  # -&gt; 65
    
    # Turning things into lists and dicts
    dict([['foo', 1], ['bar', 2]])  # -&gt; {'foo': 1, 'bar': 2}
    list('abc')  # -&gt; ['a', 'b', 'c']
    dict(other_dict)  # make a copy
    list(other_list)  # make copy


The isinstance function (and friends)
-------------------------------------

The ``isinstance()`` function works for all JS primitive types, but also
for user-defined classes.

.. pscript_example::

    # Basic types
    isinstance(3, float)  # in JS there are no ints
    isinstance('', str)
    isinstance([], list)
    isinstance({}, dict)
    isinstance(foo, types.FunctionType)
    
    # Can also use JS strings
    isinstance(3, 'number')
    isinstance('', 'string')
    isinstance([], 'array')
    isinstance({}, 'object')
    isinstance(foo, 'function')
    
    # You can use it on your own types too ...
    isinstance(x, MyClass)
    isinstance(x, 'MyClass')  # equivalent
    isinstance(x, 'Object')  # also yields true (subclass of Object)
    
    # issubclass works too
    issubclass(Foo, Bar)
    
    # As well as callable
    callable(foo)


hasattr, getattr, setattr and delattr
-------------------------------------

.. pscript_example::
    
    a = {'foo': 1, 'bar': 2}
    
    hasattr(a, 'foo')  # -&gt; True
    hasattr(a, 'fooo')  # -&gt; False
    hasattr(null, 'foo')  # -&gt; False
    
    getattr(a, 'foo')  # -&gt; 1
    getattr(a, 'fooo')  # -&gt; raise AttributeError
    getattr(a, 'fooo', 3)  # -&gt; 3
    getattr(null, 'foo', 3)  # -&gt; 3
    
    setattr(a, 'foo', 2)
    
    delattr(a, 'foo')


Creating sequences
------------------

.. pscript_example::
    
    range(10)
    range(2, 10, 2)
    range(100, 0, -1)
    
    reversed(foo)
    sorted(foo)
    enumerate(foo)
    zip(foo, bar)
    
    filter(func, foo)
    map(func, foo)


List methods
------------

.. pscript_example::

    # Call a.append() if it exists, otherwise a.push()
    a.append(x)
    
    # Similar for remove()
    a.remove(x)


Dict methods
------------

.. pscript_example::
    
    a = {'foo': 3}
    a['foo']
    a.get('foo', 0)
    a.get('foo')
    a.keys()


Str methods
-----------

.. pscript_example::

    "foobar".startswith('foo')
    "foobar".replace('foo', 'bar')
    "foobar".upper()


Using JS specific functionality
-------------------------------

When writing PScript inside Python modules, we recommend that where
specific JavaScript functionality is used, that the references are
prefixed with ``window.`` Where ``window`` represents the global JS 
namespace. All global JavaScript objects, functions, and variables
automatically become members of the ``window`` object. This helps
make it clear that the functionality is specific to JS, and also
helps static code analysis tools like flake8.

.. pscript_example::
    
    from pscript import window  # this is a stub
    def foo(a):
        return window.Math.cos(a)

Aside from ``window``, ``pscript`` also provides ``undefined``,
``Inifinity``, and ``NaN``.

"""
</t>
<t tx="ekr.20181108111640.266"># This class has several `function_foo()` and `method_bar()` methods
# to implement corresponding functionality. Most of these are
# auto-generated from the stdlib. However, some methods need explicit
# implementation, e.g. to parse keyword arguments, or are inlined rather
# than implemented via the stlib.
#
# Note that when the number of arguments does not match, almost all
# functions raise a compile-time error. The methods, however, will
# bypass the stdlib in this case, because it is assumed that the user
# intended to call a special method on the object.

class Parser3(Parser2):
    """ Parser to transcompile Python to JS, allowing more Pythonic
    code, like ``self``, ``print()``, ``len()``, list methods, etc.
    """
    
    @others
</t>
<t tx="ekr.20181108111640.267">def function_this_is_js(self, node):
    # Note that we handle this_is_js() shortcuts in the if-statement
    # directly. This replacement with a string is when this_is_js()
    # is used outside an if statement.
    if len(node.arg_nodes) != 0:
        raise JSError('this_is_js() expects zero arguments.')
    return ('"this_is_js()"')

</t>
<t tx="ekr.20181108111640.268">def function_RawJS(self, node):
    if len(node.arg_nodes) == 1:
        if not isinstance(node.arg_nodes[0], ast.Str):
            raise JSError('RawJS needs a verbatim string (use multiple '
                          'args to bypass PScript\'s RawJS).')
        lines = RawJS._str2lines(node.arg_nodes[0].value.strip())
        nl = '\n' + (self._indent * 4) * ' '
        return nl.join(lines)
    else:
        return None  # maybe RawJS is a thing

## Python builtin functions


</t>
<t tx="ekr.20181108111640.269">def function_isinstance(self, node):
    if len(node.arg_nodes) != 2:
        raise JSError('isinstance() expects two arguments.')
    
    ob = unify(self.parse(node.arg_nodes[0]))
    cls = unify(self.parse(node.arg_nodes[1]))
    if cls[0] in '"\'':
        cls = cls[1:-1]  # remove quotes
    
    BASIC_TYPES = ('number', 'boolean', 'string', 'function', 'array',
                   'object', 'null', 'undefined')
    
    MAP = {'[int, float]': 'number', '[float, int]': 'number', 'float': 'number',
           'str': 'string', 'basestring': 'string', 'string_types': 'string',
           'bool': 'boolean',
           'FunctionType': 'function', 'types.FunctionType': 'function',
           'list': 'array', 'tuple': 'array',
           '[list, tuple]': 'array', '[tuple, list]': 'array',
           'dict': 'object',
    }
    
    cmp = MAP.get(cls, cls)
    
    if cmp == 'array':
        return ['Array.isArray(', ob, ')']
    elif cmp.lower() in BASIC_TYPES:
        # Basic type, use Object.prototype.toString
        return ["Object.prototype.toString.call(", ob ,
                ").slice(8,-1).toLowerCase() === '%s'" % cmp.lower()]
        # In http://stackoverflow.com/questions/11108877 the following is
        # proposed, which might be better in theory, but is &gt; 50% slower
        return ["({}).toString.call(",
                ob,
                r").match(/\s([a-zA-Z]+)/)[1].toLowerCase() === ",
                "'%s'" % cmp.lower()
                ]
    else:
        # User defined type, use instanceof
        # http://tobyho.com/2011/01/28/checking-types-in-javascript/
        cmp = unify(cls)
        if cmp[0] == '(':
            raise JSError('isinstance() can only compare to simple types')
        return ob, " instanceof ", cmp

</t>
<t tx="ekr.20181108111640.27">class Bytes(Node):
    """
    Attributes:
        value: the native Python bytes object.
    """
    __slots__ = 'value',

</t>
<t tx="ekr.20181108111640.270">def function_issubclass(self, node):
    # issubclass only needs to work on custom classes
    if len(node.arg_nodes) != 2:
        raise JSError('issubclass() expects two arguments.')
    
    cls1 = unify(self.parse(node.arg_nodes[0]))
    cls2 = unify(self.parse(node.arg_nodes[1]))
    if cls2 == 'object':
        cls2 = 'Object'
    return '(%s.prototype instanceof %s)' % (cls1, cls2)

</t>
<t tx="ekr.20181108111640.271">def function_print(self, node):
    # Process keywords
    sep, end = '" "', ''
    for kw in node.kwarg_nodes:
        if kw.name == 'sep':
            sep = ''.join(self.parse(kw.value_node))
        elif kw.name == 'end':
            end = ''.join(self.parse(kw.value_node))
        elif kw.name in ('file', 'flush'):
            raise JSError('print() file and flush args not supported')
        else:
            raise JSError('Invalid argument for print(): %r' % kw.name)
    
    # Combine args
    args = [unify(self.parse(arg)) for arg in node.arg_nodes]
    end = (" + %s" % end) if (args and end and end != '\n') else ''
    combiner = ' + %s + ' % sep
    args_concat = combiner.join(args) or '""'
    return 'console.log(' + args_concat + end + ')'

</t>
<t tx="ekr.20181108111640.272">def function_len(self, node):
    if len(node.arg_nodes) == 1:
        return unify(self.parse(node.arg_nodes[0])), '.length'
    else:
        return None  # don't apply this feature

</t>
<t tx="ekr.20181108111640.273">def function_max(self, node):
    if len(node.arg_nodes) == 0:
        raise JSError('max() needs at least one argument')
    elif len(node.arg_nodes) == 1:
        arg = ''.join(self.parse(node.arg_nodes[0]))
        return 'Math.max.apply(null, ', arg, ')'
    else:
        args = ', '.join([unify(self.parse(arg)) for arg in node.arg_nodes])
        return 'Math.max(', args, ')'

</t>
<t tx="ekr.20181108111640.274">def function_min(self, node):
    if len(node.arg_nodes) == 0:
        raise JSError('min() needs at least one argument')
    elif len(node.arg_nodes) == 1:
        arg = ''.join(self.parse(node.arg_nodes[0]))
        return 'Math.min.apply(null, ', arg, ')'
    else:
        args = ', '.join([unify(self.parse(arg)) for arg in node.arg_nodes])
        return 'Math.min(', args, ')'

</t>
<t tx="ekr.20181108111640.275">def function_callable(self, node):
    if len(node.arg_nodes) == 1:
        arg = unify(self.parse(node.arg_nodes[0]))
        return '(typeof %s === "function")' % arg
    else:
        raise JSError('callable() needs at least one argument')

</t>
<t tx="ekr.20181108111640.276">def function_chr(self, node):
    if len(node.arg_nodes) == 1:
        arg = ''.join(self.parse(node.arg_nodes[0]))
        return 'String.fromCharCode(%s)' % arg
    else:
        raise JSError('chr() needs at least one argument')

</t>
<t tx="ekr.20181108111640.277">def function_ord(self, node):
    if len(node.arg_nodes) == 1:
        arg = ''.join(self.parse(node.arg_nodes[0]))
        return '%s.charCodeAt(0)' % arg
    else:
        raise JSError('ord() needs at least one argument')

</t>
<t tx="ekr.20181108111640.278">def function_dict(self, node):
    if len(node.arg_nodes) == 0:
        kwargs = ['%s:%s' % (arg.name, unify(self.parse(arg.value_node)))
                  for arg in node.kwarg_nodes]
        return '{%s}' % ', '.join(kwargs)
    if len(node.arg_nodes) == 1:
        return self.use_std_function('dict', node.arg_nodes)
    else:
        raise JSError('dict() needs at least one argument')

</t>
<t tx="ekr.20181108111640.279">def function_list(self, node):
    if len(node.arg_nodes) == 0:
        return '[]'
    if len(node.arg_nodes) == 1:
        return self.use_std_function('list', node.arg_nodes)
    else:
        raise JSError('list() needs at least one argument')

</t>
<t tx="ekr.20181108111640.28">class List(Node):
    """
    Attributes:
        element_nodes: the items in the list.
    """
    __slots__ = 'element_nodes',

</t>
<t tx="ekr.20181108111640.280">def function_tuple(self, node):
    return self.function_list(node)

</t>
<t tx="ekr.20181108111640.281">def function_range(self, node):
    if len(node.arg_nodes) == 1:
        args = ast.Num(0), node.arg_nodes[0], ast.Num(1)
        return self.use_std_function('range', args)
    elif len(node.arg_nodes) == 2:
        args = node.arg_nodes[0], node.arg_nodes[1], ast.Num(1)
        return self.use_std_function('range', args)
    elif len(node.arg_nodes) == 3:
        return self.use_std_function('range', node.arg_nodes)
    else:
        raise JSError('range() needs 1, 2 or 3 arguments')

</t>
<t tx="ekr.20181108111640.282">def function_sorted(self, node):
    if len(node.arg_nodes) == 1:
        key, reverse = ast.Name('undefined'), ast.NameConstant(False)
        for kw in node.kwarg_nodes:
            if kw.name == 'key':
                key = kw.value_node
            elif kw.name == 'reverse':
                reverse = kw.value_node
            else:
                raise JSError('Invalid keyword argument for sorted: %r' % kw.name)
        return self.use_std_function('sorted', [node.arg_nodes[0], key, reverse])
    else:
        raise JSError('sorted() needs one argument')

## Methods of list/dict/str

</t>
<t tx="ekr.20181108111640.283">def method_sort(self, node, base):
    if len(node.arg_nodes) == 0:  # sorts args are keyword-only
        key, reverse = ast.Name('undefined'), ast.NameConstant(False)
        for kw in node.kwarg_nodes:
            if kw.name == 'key':
                key = kw.value_node
            elif kw.name == 'reverse':
                reverse = kw.value_node
            else:
                raise JSError('Invalid keyword argument for sort: %r' % kw.name)
        return self.use_std_method(base, 'sort', [key, reverse])

</t>
<t tx="ekr.20181108111640.284">def method_format(self, node, base):
    if node.kwarg_nodes:
        raise JSError('Method format() does not support keyword args.')
    return self.use_std_method(base, 'format', node.arg_nodes)


\\-4.# Add functions and methods to the class, using the stdib functions ...

</t>
<t tx="ekr.20181108111640.285">def make_function(name, nargs, function_deps, method_deps):
    def function_X(self, node):
        if node.kwarg_nodes:
            raise JSError('Function %s does not support keyword args.' % name)
        if len(node.arg_nodes) not in nargs:
            raise JSError('Function %s needs #args in %r.' % (name, nargs))
        for dep in function_deps:
            self.use_std_function(dep, [])
        for dep in method_deps:
            self.use_std_method('x', dep, [])
        return self.use_std_function(name, node.arg_nodes)
    return function_X

</t>
<t tx="ekr.20181108111640.286">def make_method(name, nargs, function_deps, method_deps):
    def method_X(self, node, base):
        if node.kwarg_nodes:
            raise JSError('Method %s does not support keyword args.' % name)
        if len(node.arg_nodes) not in nargs:
            return None  # call as-is, don't use our variant
        for dep in function_deps:
            self.use_std_function(dep, [])
        for dep in method_deps:
            self.use_std_method('x', dep, [])
        return self.use_std_method(base, name, node.arg_nodes)
    return method_X

for name, code in stdlib.METHODS.items():
    nargs, function_deps, method_deps = stdlib.get_std_info(code)
    if nargs and not hasattr(Parser3, 'method_' + name):
        m = make_method(name, tuple(nargs), function_deps, method_deps)
        setattr(Parser3, 'method_' + name, m)

for name, code in stdlib.FUNCTIONS.items():
    nargs, function_deps, method_deps = stdlib.get_std_info(code)
    if nargs and not hasattr(Parser3, 'function_' + name):
        m = make_function(name, tuple(nargs), function_deps, method_deps)
        setattr(Parser3, 'function_' + name, m)
</t>
<t tx="ekr.20181108111640.287">"""
PScript standard functions.

Functions are declared as ... functions. Methods are written as methods
(using this), but declared as functions, and then "apply()-ed" to the
instance of interest. Declaring methods on Object is a bad idea (breaks
Bokeh, jquery).

"""

import re

# Functions not covered by this lib:
# isinstance, issubclass, print, len, max, min, callable, chr, ord

FUNCTIONS = {}
METHODS = {}
FUNCTION_PREFIX = '_pyfunc_'
METHOD_PREFIX = '_pymeth_'

@others

&lt;&lt; define FUNCTIONS &gt;&gt;
&lt;&lt; define METHODS &gt;&gt;

for key in METHODS:
    METHODS[key] = re.subn(r'METHOD_PREFIX(.+?)\(',
                           r'METHOD_PREFIX\1.call(', METHODS[key])[0]
    METHODS[key] = METHODS[key].replace(
        'KEY', key).replace(
        'FUNCTION_PREFIX', FUNCTION_PREFIX).replace(
        'METHOD_PREFIX', METHOD_PREFIX).replace(
        ', )', ')')
    
for key in FUNCTIONS:
    FUNCTIONS[key] = re.subn(r'METHOD_PREFIX(.+?)\(',
                             r'METHOD_PREFIX\1.call(', FUNCTIONS[key])[0]
    FUNCTIONS[key] = FUNCTIONS[key].replace(
        'KEY', key).replace(
        'FUNCTION_PREFIX', FUNCTION_PREFIX).replace(
        'METHOD_PREFIX', METHOD_PREFIX)

@language python
@tabwidth -4
</t>
<t tx="ekr.20181108111640.289">def get_std_info(code):
    """ Given the JS code for a std function or method, determine the
    number of arguments, function_deps and method_deps.
    """
    _, _, nargs = code.splitlines()[0].partition('nargs:')
    nargs = [int(i.strip()) for i in nargs.strip().replace(',', ' ').split(' ') if i]
    # Collect dependencies on other funcs/methods
    sep = FUNCTION_PREFIX
    function_deps = [part.split('(')[0].strip() for part in code.split(sep)[1:]]
    sep = METHOD_PREFIX
    method_deps = [part.split('.')[0].strip() for part in code.split(sep)[1:]]
    # Reduce and sort
    function_deps = sorted(set(function_deps))
    method_deps = sorted(set(method_deps))
    # Filter
    function_deps = [dep for dep in function_deps if dep not in method_deps]
    function_deps = set([dep for dep in function_deps if dep in FUNCTIONS])
    method_deps = set([dep for dep in method_deps if dep in METHODS])
    # Recurse
    for dep in list(function_deps):
        _update_deps(FUNCTIONS[dep], function_deps, method_deps)
    for dep in list(method_deps):
        _update_deps(METHODS[dep], function_deps, method_deps)
    
    return nargs, sorted(function_deps), sorted(method_deps)

</t>
<t tx="ekr.20181108111640.29">class Tuple(Node):
    """
    Attributes:
        element_nodes: the items in the tuple.
    """
    __slots__ = 'element_nodes',

</t>
<t tx="ekr.20181108111640.290">def _update_deps(code, function_deps, method_deps):
    """ Given the code of a dependency, recursively resolve additional dependencies.
    """
    # Collect deps
    sep = FUNCTION_PREFIX
    new_function_deps = [part.split('(')[0].strip() for part in code.split(sep)[1:]]
    sep = METHOD_PREFIX
    new_method_deps = [part.split('.')[0].strip() for part in code.split(sep)[1:]]
    # Update
    new_function_deps = set(new_function_deps).difference(function_deps)
    new_method_deps = set(new_method_deps).difference(method_deps)
    function_deps.update(new_function_deps)
    method_deps.update(new_method_deps)
    # Recurse
    for dep in new_function_deps:
        _update_deps(FUNCTIONS[dep], function_deps, method_deps)
    for dep in new_method_deps:
        _update_deps(METHODS[dep], function_deps, method_deps)
    return function_deps, method_deps


</t>
<t tx="ekr.20181108111640.291">def get_partial_std_lib(func_names, method_names, indent=0,
                        func_prefix=None, method_prefix=None):
    """ Get the code for the PScript standard library consisting of
    the given function and method names. The given indent specifies how
    many sets of 4 spaces to prepend.
    """
    func_prefix = 'var ' + FUNCTION_PREFIX if (func_prefix is None) else func_prefix
    method_prefix = 'var ' + METHOD_PREFIX if (method_prefix is None) else method_prefix
    lines = []
    for name in sorted(func_names):
        code = FUNCTIONS[name].strip()
        if '\n' not in code:
            code = code.rsplit('//', 1)[0].rstrip()  # strip comment from one-liners
        lines.append('%s%s = %s;' % (func_prefix, name, code))
    for name in sorted(method_names):
        code = METHODS[name].strip()
        # lines.append('Object.prototype.%s%s = %s;' % (METHOD_PREFIX, name, code))
        lines.append('%s%s = %s;' % (method_prefix, name, code))
    code = '\n'.join(lines)
    if indent:
        lines = ['    '*indent + line for line in code.splitlines()]
        code = '\n'.join(lines)
    return code


</t>
<t tx="ekr.20181108111640.292">def get_full_std_lib(indent=0):
    """ Get the code for the full PScript standard library.
    
    The given indent specifies how many sets of 4 spaces to prepend.
    If the full stdlib is made available in JavaScript, multiple
    snippets of code can be transpiled without inlined stdlib parts by
    using ``py2js(..., inline_stdlib=False)``.
    """
    return get_partial_std_lib(FUNCTIONS.keys(), METHODS.keys(), indent)


# todo: now that we have modules, we can have shorter/no prefixes, right?
# -&gt; though maybe we use them for string replacement somewhere?
</t>
<t tx="ekr.20181108111640.293">def get_all_std_names():
    """ Get list if function names and methods names in std lib.
    """
    return ([FUNCTION_PREFIX + f for f in FUNCTIONS],
            [METHOD_PREFIX + f for f in METHODS])


</t>
<t tx="ekr.20181108111640.294">"""
Module that can dynamically generate stubs.
"""

import sys

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181108111640.296">class RawJS:
    """ An object to wrap verbatim code to be included in the generated
    JavaScript. This serves a number of purposes:
    
    * Using code in PScript that is not valid Python syntax, like regular
      expressions or the jQuery object ``$``.
    * Write high performance code that avoids Pythonic features like operator
      overloading.
    * In Flexx's module system it can be used to create a stub variable in
      Python that *does* have a value in JS. This value can imported in other
      modules, leading to a shared value also in JS.
    
    PScript does not verify the syntax of the code, so write carefully!
    To allow the features in the 3d point, this object has a magic touch:
    the ``__module__`` attribute of an instance refers to the module in which it
    was instantiated, and if it's a global, its defining name can be obtained.
    
    Example:
    
    .. code-block:: py
        
        # Syntax not usable in Py
        myre = RawJS('/ab+c/')
        
        # Code that should only execute on JS
        foo = RawJS('require("some.module")')
        
        # Performance
        def bar(n):
            res = []
            RawJS('''
                for (var i=0; i&lt;n; i++) {
                    if (is_ok_num(i)) {
                        res.push(i);
                    }
                }
            ''')
    
    """
    
    @others
</t>
<t tx="ekr.20181108111640.297">def __init__(self, code, _resolve_defining_module=True):
    if not isinstance(code, str):
        raise TypeError('RawJS requires str input.')
    self._lines = self._str2lines(code)
    
    # Get the globals of the module in which this instance is defined, so
    # that we can set __module__ and later obtain the name by which this 
    # instance is known in that module. We use a trick here to get access
    # to the stack frame while avoiding sys._getframe().
    try:
        raise Exception()
    except Exception as err:
        tb = getattr(err, '__traceback__', None)
        if tb is None:  # Legacy Python 2.x
            import sys
            _, _, tb = sys.exc_info()
        self._globals = tb.tb_frame.f_back.f_globals
        del tb
    self.__module__ = self._globals['__name__']
    self._real_name = None

</t>
<t tx="ekr.20181108111640.298">def __repr__(self):
    if len(self._lines) == 1 and len(self._lines[0]) &lt; 60:
        return '&lt;%s "%s"&gt;' % (self.__class__.__name__, self.get_code(0))
    else:
        return '&lt;%s with %i lines&gt;' % (self.__class__.__name__, len(self._lines))

</t>
<t tx="ekr.20181108111640.299">def __str__(self):
    return self.get_code(0)

</t>
<t tx="ekr.20181108111640.30">class Set(Node):
    """
    Attributes:
        element_nodes: the items in the set.
    """
    __slots__ = 'element_nodes',

</t>
<t tx="ekr.20181108111640.300">@classmethod
def _str2lines(cls, text):
    """ Classmethod to split a text in lines, dedenting each line.
    The first line's indentation will assume the minimal
    indentation.
    """
    lines = text.replace('\r', '').split('\n')
    lines[0] = lines[0].strip()  # firts line is always detented
    if len(lines) &gt; 1:
        # Get minimal indentation
        min_indent = 99999
        for line in lines[1:]:
            if line.strip():  # don't count empty lines
                min_indent = min(min_indent, len(line) - len(line.lstrip()))
        # Remove indentation
        for i in range(1, len(lines)):
            lines[i] = lines[i][min_indent:].rstrip()
    # Remove empty line only at beginning
    if not lines[0]:
        lines.pop(0)
    return lines

</t>
<t tx="ekr.20181108111640.301">def get_defined_name(self, suggestion=None):
    """ Get the name by which this object is known in the module in which
    it is defined. Only works if it is a global. Returns '' otherwise.
    If a suggestion is given and it is the correct name, this function
    performs faster. The resulting name is cached internally.
    """
    if self._real_name is None:
        self._real_name = ''  # could be defined not in the globals
        if suggestion and self._globals.get(suggestion, None) is self:
            self._real_name = suggestion
        else:
            for name, val in self._globals.items():
                if val is self:
                    self._real_name = name
                    break
    return self._real_name

</t>
<t tx="ekr.20181108111640.302">def get_code(self, indent=0):
    """ Get the code with the given indentation.
    """
    indent = indent * ' '
    return '\n'.join([indent + line for line in self._lines])


</t>
<t tx="ekr.20181108111640.303">class JSConstant:
    """ Class to represent variables that are used in JS, and are considered
    global or otherwise available in a way that Python cannot know.
    """
    
    @others
</t>
<t tx="ekr.20181108111640.304">def __init__(self, name='jsconstant'):
    self._name = name

</t>
<t tx="ekr.20181108111640.305">def __repr__(self):  # pragma: no cover
    return '&lt;%s %s&gt;' % (self.__class__.__name__, self._name)


</t>
<t tx="ekr.20181108111640.306">class Stubs:
    
    __name__ = __name__
    __file__ = __file__
    JSConstant = JSConstant
    RawJS = RawJS
    
    def __getattr__(self, name):
        if name in ('JSConstant', 'RawJS'):
            return getattr(self, name)
        else:
            return self.JSConstant(name)
    
# Seems hacky, but is supported: http://stackoverflow.com/a/7668273/2271927
sys.modules[__name__] = Stubs()
</t>
<t tx="ekr.20181108111640.308"># -*- coding: utf-8 -*-
# Copyright (c) 2016, Almar Klein
# Distributed under the (new) BSD License.

"""
Functionality used for testing, based on pytest. This module is designed
to just work, without modification, in most projects.

Write your tests like this:

    from yourproject.xxx.testing import run_tests_if_main, raises, skipif
    ...
    run_tests_if_main()

Then you can run the test file as a script, which will run all tests
and report coverage. Magic!
"""

from __future__ import absolute_import, print_function, division

import os
import sys
import inspect

import pytest

&lt;&lt; testing data &gt;&gt;
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181108111640.309">PACKAGE_NAME = __name__.split('.')[0]

# Get project root dir
THIS_DIR = os.path.abspath(os.path.dirname(__file__))
ROOT_DIR = THIS_DIR
for i in range(9):
    ROOT_DIR = os.path.dirname(ROOT_DIR)
    if os.path.basename(ROOT_DIR) == PACKAGE_NAME:
        ROOT_DIR = os.path.dirname(ROOT_DIR)
        break
else:
    print('testing.py could not find project root dir, '
          'using testing.py directory instead.')
    ROOT_DIR = THIS_DIR


# Inject some function names so they can be obtained with one import
raises = pytest.raises
skipif = pytest.mark.skipif
skip = pytest.skip

</t>
<t tx="ekr.20181108111640.31">class Dict(Node):
    """
    Attributes:
        key_nodes: the keys of the dict.
        value_nodes: the corresponding values.
    """
    __slots__ = 'key_nodes', 'value_nodes'

</t>
<t tx="ekr.20181108111640.310">def run_tests_if_main(show_coverage=False):
    """ Run tests in a given file if it is run as a script
    
    Coverage is reported for running this single test. Set show_coverage to
    launch the report in the web browser.
    """
    local_vars = inspect.currentframe().f_back.f_locals
    if not local_vars.get('__name__', '') == '__main__':
        return
    # we are in a "__main__"
    os.chdir(ROOT_DIR)
    fname = str(local_vars['__file__'])
    _clear_our_modules()
    _enable_faulthandler()
    pytest.main(['-v', '-x', '--color=yes', '--cov', PACKAGE_NAME,
                 '--cov-config', '.coveragerc', '--cov-report', 'html', fname])
    if show_coverage:
        import webbrowser
        fname = os.path.join(ROOT_DIR, 'htmlcov', 'index.html')
        webbrowser.open_new_tab(fname)


</t>
<t tx="ekr.20181108111640.311">def _enable_faulthandler():
    """ Enable faulthandler (if we can), so that we get tracebacks
    on segfaults.
    """
    try:
        import faulthandler
        faulthandler.enable()
        print('Faulthandler enabled')
    except Exception:
        print('Could not enable faulthandler')


</t>
<t tx="ekr.20181108111640.312">def _clear_our_modules():
    """ Remove ourselves from sys.modules to force an import.
    """
    for key in list(sys.modules.keys()):
        if key.startswith(PACKAGE_NAME) and 'testing' not in key:
            del sys.modules[key]
</t>
<t tx="ekr.20181108111640.313">&lt;&lt; docstring &gt;&gt;
__version__ = '0.6.2'

import sys
import logging

logger = logging.getLogger(__name__)

# Assert compatibility and redirect to legacy version on Python 2.7
ok = True

if sys.version_info[0] == 2:  # pragma: no cover
    if sys.version_info &lt; (2, 7):
        raise RuntimeError('PScript needs at least Python 2.7')
    if type(b'') == type(''):  # noqa - will be str and unicode after conversion
        sys.modules[__name__] = __import__(__name__ + '_legacy')
        ok = False

# NOTE: The code for the parser is quite long, especially if you want
# to document it well. Therefore it is split in multiple modules, which
# are simply numbered 0, 1, 2, etc. Here in the __init__, we define
# which parser is *the* parser. This gives us the freedom to split the
# parser in smaller pieces if we want.
#
# In the docstring of every parser module we maintain a brief user-guide
# demonstrating the features defined in that module. In the docs these
# docstrings are combined into one complete guide.

# flake8: noqa

if ok:
        
    from .parser0 import Parser0, JSError
    from .parser1 import Parser1
    from .parser2 import Parser2
    from .parser3 import Parser3
    from .base import *
    
    from .functions import py2js, evaljs, evalpy, JSString
    from .functions import script2js, js_rename, create_js_module
    from .stdlib import get_full_std_lib, get_all_std_names
    from .stubs import RawJS, JSConstant, window, undefined


del logging, sys, ok
@language python
@tabwidth -4
</t>
<t tx="ekr.20181108111640.314">@language rest
@wrap
"""
The pscript module provides functionality for transpiling Python code
to JavaScript.

Quick intro
-----------

This is a brief intro for using PScript. For more details see the
sections below.

PScript is a tool to write JavaScript using (a subset) of the Python
language. All relevant builtins, and the methods of list, dict and str
are supported. Not supported are set, slicing with steps, ``yield`` and
imports. Other than that, most Python code should work as expected ...
mostly, see caveats below. If you try hard enough the JavaScript may
shine through. As a rule of thumb, the code should behave as expected
when correct, but error reporting may not be very Pythonic.

The most important functions you need to know about are
:func:`py2js &lt;pscript.py2js&gt;` and 
:func:`evalpy &lt;pscript.evalpy&gt;`.
In principal you do not need knowledge of JavaScript to write PScript
code, though it does help in corner cases.


Goals
-----

There is an increase in Python projects that target web technology to
handle visualization and user interaction.
PScript grew out of a desire to allow writing JavaScript callbacks in
Python, to allow user-defined interaction to be flexible, fast, and
stand-alone.

This resulted in the following two main goals: 

* To make writing JavaScript easier and less frustrating, by letting
  people write it with the Python syntax and builtins, and fixing some
  of JavaScripts quirks.
* To allow JavaScript snippets to be defined naturally inside a Python
  program.

Code produced by PScript works standalone. Any (PScript-compatible)
Python snippet can be converted to JS; you don't need another JS library
to run it.

PScript can also be used to develop standalone JavaScript (AMD) modules.


PScript is just JavaScript
--------------------------

The purpose of projects like Skulpt or PyJS is to enable full Python
support in the browser. This approach will always be plagued by a
fundamental limitation: libraries that are not pure Python (like numpy)
will not work.

PScript takes a more modest approach; it is a tool that allows one to
write JavaScript with a Python syntax. PScript is just JavaScript.

This means that depending on what you want to achieve, you may still need
to know a thing or two about how JavaScript works. Further, not all Python
code can be converted (e.g. import is not supported), and
lists and dicts are really just JavaScript arrays and objects, respectively.


Pythonic
--------

PScript makes writing JS more "Pythonic". Apart from allowing Python syntax
for loops, classes, etc, all relevant Python builtins are supported,
as well as the methods of list, dict and str. E.g. you can use
``print()``, ``range()``, ``L.append()``, ``D.update()``, etc.

The empty list and dict evaluate to false (whereas in JS it's
true), and ``isinstance()`` just works (whereas JS' ``typeof`` is
broken). 

Deep comparisons are supported (e.g. for ``==`` and ``in``), so you can
compare two lists or dicts, or even a structure of nested
lists/dicts. Lists can be combined with the plus operator, and lists
and strings can be repeated with the multiply (star) operator. Class
methods are bound functions.

.. _pscript-caveats:

Caveats
-------

PScript fixes some of JS's quirks, but it's still just JavaScript.
Here's a list of things to keep an eye out for. This list is likely
incomplete. We recommend familiarizing yourself with JavaScript if you
plan to make heavy use of PScript.

* JavasScript has a concept of ``null`` (i.e. ``None``), as well as
  ``undefined``. Sometimes you may want to use ``if x is None or x is
  undefined: ...``.
* Accessing an attribute that does not exist will not raise an
  AttributeError but yield ``undefined``. Though this may change.
* Keys in a dictionary are implicitly converted to strings.
* Magic functions on classes (e.g. for operator overloading) do not work.
* Calling an object that starts with a capital letter is assumed to be
  a class instantiation (using ``new``): PScript classes *must* start
  with a capital letter, and any other callables must not.
* A function can accept keyword arguments if it has a ``**kwargs`` parameter
  or named arguments after ``*args``. Passing keywords to a function that does
  not handle keyword arguments might result in confusing errors.
* Divide by zero results in `inf` instead of raising ZeroDivisionError.


PScript is valid Python
------------------------

Other than e.g. RapydScript, PScript is valid Python. This allows
creating modules that are a mix of real Python and PScript. You can easily
write code that runs correctly both as Python and PScript, and
:func:`raw JavaScript &lt;pscript.RawJS&gt;` can
be included where needed (e.g. for performance).

PScript's compiler is written in Python. Perhaps PScript can
at some point compile itself, so that it becomes possible to define
PScript inside HTML documents.

There are things you can do, which you cannot do in Python:


Performance
-----------

Because PScript produces relatively bare JavaScript, it is pretty fast.
Faster than CPython, and significantly faster than e.g. Brython.
Check out ``examples/app/benchmark.py``.

Nevertheless, the overhead to realize the more Pythonic behavior can
have a negative impact on performance in tight loops (in comparison to
writing the JS by hand). The recommended approach is to write
performance critical code in pure JavaScript
(using :func:`RawJS &lt;pscript.RawJS&gt;`) if necessary. 

.. _pscript-support:

Support
-------

This is an overview of the language features that PScript
supports/lacks. 

Not currently supported:

* import (maybe we should translate an import to ``require()``?)
* the ``set`` class (JS has no set, but we could create one?)
* slicing with steps (JS does not support this)
* Generators, i.e. ``yield`` (not widely supported in JS)

Supported basics:

* numbers, strings, lists, dicts (the latter become JS arrays and objects)
* operations: binary, unary, boolean, power, integer division, ``in`` operator
* comparisons (``==`` -&gt; ``==``, ``is`` -&gt; ``===``)
* tuple packing and unpacking
* basic string formatting
* slicing with start end end (though not with step)
* if-statements and single-line if-expressions
* while-loops and for-loops supporting continue, break, and else-clauses
* for-loops using ``range()``
* for-loop over arrays
* for-loop over dict/object using ``.keys()``, ``.values()`` and ``.items()``
* function calls can have ``*args``
* function defs can have default arguments and ``*args``
* function calls/defs can use keyword arguments and ``**kwargs``, but
  use with care (see caveats).
* lambda expressions
* list comprehensions
* classes, with (single) inheritance, and the use of ``super()``
* raising and catching exceptions, assertions
* creation of "modules"
* globals / nonlocal
* The ``with`` statement (no equivalent in JS)
* double underscore name mangling

Supported Python conveniences:

* use of ``self`` is translated to ``this``
* ``print()`` becomes ``console.log()`` (also supports ``sep`` and ``end``)
* ``isinstance()`` Just Works (for primitive types as well as
  user-defined classes)
* an empty list or dict evaluates to False as in Python.
* all Python builtin functions that make sense in JS are supported:
  isinstance, issubclass, callable, hasattr, getattr, setattr, delattr,
  print, len, max, min, chr, ord, dict, list, tuple, range, pow, sum,
  round, int, float, str, bool, abs, divmod, all, any, enumerate, zip,
  reversed, sorted, filter, map.
* all methods of list, dict and str are supported (except a few string
  methods: encode, format_map, isprintable, maketrans).
* the default return value of a function is ``None``/``null`` instead
  of ``undefined``.
* list concatenation using the plus operator, and list/str repeating
  using the star operator.
* deep comparisons.
* class methods are bound functions (i.e. ``this`` is fixed to the
  instance).
* functions that are defined in another function (a.k.a closures) that do not
  have self/this as a first argument, are bound the the same instance as the
  function in which it is defined.


Other functionality
-------------------

The PScript package provides a few other "utilities" to deal with JS code,
such as renaming function/class definitions, and creating JS modules
(AMD, UMD, etc.).

"""

</t>
<t tx="ekr.20181108111640.32">class Ellipsis(Node):
    """ Represents the ``...`` syntax for the Ellipsis singleton.
    """
    __slots__ = ()

</t>
<t tx="ekr.20181108111640.33">class NameConstant(Node):
    """
    Attributes:
        value: the corresponding native Python object like True, False or None.
    """
    __slots__ = 'value',

## Variables, attributes, indexing and slicing

</t>
<t tx="ekr.20181108111640.34">class Name(Node):
    """
    Attributes:
        name: the string name of this variable.
    """
    __slots__ = 'name',

</t>
<t tx="ekr.20181108111640.35">class Starred(Node):
    """ A starred variable name, e.g. ``*foo``. Note that this isn't
    used to define a function with ``*args`` - FunctionDef nodes have
    special fields for that.
    
    Attributes:
        value_node: the value that is starred, typically a Name node.
    """
    __slots__ = 'value_node',

</t>
<t tx="ekr.20181108111640.36">class Attribute(Node):
    """ Attribute access, e.g. ``foo.bar``.
    
    Attributes:
        value_node: The node to get/set an attribute of. Typically a Name node.
        attr: a string with the name of the attribute.
    """
    __slots__ = 'value_node', 'attr'

</t>
<t tx="ekr.20181108111640.37">class Subscript(Node):
    """ Subscript access, e.g. ``foo[3]``.
    
    Attributes:
        value_node: The node to get/set a subscript of. Typically a Name node.
        slice_node: An Index, Slice or ExtSlice node.
    """
    __slots__ = 'value_node', 'slice_node'

</t>
<t tx="ekr.20181108111640.38">class Index(Node):
    """
    Attributes:
        value_node: Single index.
    """
    __slots__ = 'value_node',

</t>
<t tx="ekr.20181108111640.39">class Slice(Node):
    """
    Attributes:
        lower_node: start slice.
        upper_node: end slice.
        step_node: slice step.
    """
    __slots__ = 'lower_node', 'upper_node', 'step_node'

</t>
<t tx="ekr.20181108111640.4">class BasicParser(Parser2):
    """ A parser without the Pythonic features for converting builtin
    functions and common methods.
    """
    pass


</t>
<t tx="ekr.20181108111640.40">class ExtSlice(Node):
    """
    Attributes:
        dim_nodes: list of Index and Slice nodes (of for each dimension).
    """
    __slots__ = 'dim_nodes',

## Expressions

</t>
<t tx="ekr.20181108111640.41">class Expr(Node):
    """ When an expression, such as a function call, appears as a
    statement by itself (an expression statement), with its return value
    not used or stored, it is wrapped in this container.
    
    Attributes:
        value_node: holds one of the other nodes in this section, or a
            literal, a Name, a Lambda, or a Yield or YieldFrom node.
    """
    __slots__ = 'value_node',

</t>
<t tx="ekr.20181108111640.42">class UnaryOp(Node):
    """ A unary operation (e.g. ``-x``, ``not x``).
    
    Attributes:
        op: the operator (an enum from ``Node.OPS``).
        right_node: the operand at the right of the operator.
    """
    __slots__ = 'op', 'right_node'

</t>
<t tx="ekr.20181108111640.43">class BinOp(Node):
    """ A binary operation (e.g. ``a / b``, ``a + b``).
    
    Attributes:
        op: the operator (an enum from ``Node.OPS``).
        left_node: the node to the left of the operator.
        right_node: the node to the right of the operator.
    """
    __slots__ = 'op', 'left_node', 'right_node'

</t>
<t tx="ekr.20181108111640.44">class BoolOp(Node):
    """ A boolean operator (``and``, ``or``, but not ``not``).
    
    Attributes:
        op: the operator (an enum from ``Node.OPS``).
        value_nodes: a list of nodes. ``a``, ``b`` and ``c`` in 
            ``a or b or c``.
    """
    __slots__ = 'op', 'value_nodes'

</t>
<t tx="ekr.20181108111640.45">class Compare(Node):
    """ A comparison of two or more values. 
    
    Attributes:
        op: the comparison operator (an enum from ``Node.COMP``).
        left_node: the node to the left of the operator.
        right_node: the node to the right of the operator.
    """
    __slots__ = 'op', 'left_node', 'right_node'

</t>
<t tx="ekr.20181108111640.46">class Call(Node):
    """ A function call.
    
    Attributes:
        func_node: Name, Attribute or SubScript node that represents
            the function.
        arg_nodes: list of nodes representing positional arguments.
        kwarg_nodes: list of Keyword nodes representing keyword arguments.
    
    Note that an argument ``*x`` would be specified as a Starred node
    in arg_nodes, and ``**y`` as a Keyword node with a name being ``None``.
    """
    __slots__ = ('func_node', 'arg_nodes', 'kwarg_nodes')

</t>
<t tx="ekr.20181108111640.47">class Keyword(Node):
    """ Keyword argument used in a Call.
    
    Attributes:
        name: the (string) name of the argument. Is None for ``**kwargs``.
        value_node: the value of the arg. 
    """
    __slots__ = ('name', 'value_node')

</t>
<t tx="ekr.20181108111640.48">class IfExp(Node):
    """ An expression such as ``a if b else c``.
    
    Attributes:
        test_node: the ``b`` in the above.
        body_node: the ``a`` in the above.
        else_node: the ``c`` in the above.
    """
    __slots__ = 'test_node', 'body_node', 'else_node'

</t>
<t tx="ekr.20181108111640.49">class ListComp(Node):
    """ List comprehension.
    
    Attributes:
        element_node: the part being evaluated for each item.
        comp_nodes: a list of Comprehension nodes.
    """
    __slots__ = 'element_node', 'comp_nodes'

</t>
<t tx="ekr.20181108111640.5">class Parser(Parser3):
    """ Parser to convert Python to JavaScript.
    
    Instantiate this class with the Python code. Retrieve the JS code
    using the dump() method.
    
    In a subclass, you can implement methods called "function_x" or
    "method_x", which will then be called during parsing when a
    function/method with name "x" is encountered. Several methods and
    functions are already implemented in this way.
    
    While working on ast parsing, this resource is very helpful:
    https://greentreesnakes.readthedocs.org
    
    Parameters:
        code (str): the Python source code.
        pysource (tuple): the filename and line number that contain the source.
        indent (int): the base indentation level (default 0). One
            indentation level means 4 spaces.
        docstrings (bool): whether docstrings are included in JS
            (default True).
        inline_stdlib (bool): whether the used stdlib functions are inlined
            (default True). Set to False if the stdlib is already loaded.
    """
    pass


# Create stubs that mean something
Infinity = float('inf')
NaN = float('nan')

</t>
<t tx="ekr.20181108111640.50">class SetComp(Node):
    """ Set comprehension. See ListComp.
    """
    __slots__ = 'element_node', 'comp_nodes'

</t>
<t tx="ekr.20181108111640.51">class GeneratorExp(Node):
    """ Generor expression. See ListComp.
    """
    __slots__ = 'element_node', 'comp_nodes'

</t>
<t tx="ekr.20181108111640.52">class DictComp(Node):
    """ Dict comprehension.
    
    Attributes:
        key_node: the key of the item being evaluated.
        value_node: the value of the item being evaluated.
        comp_nodes: a list of Comprehension nodes.
    """
    __slots__ = 'key_node', 'value_node', 'comp_nodes'

</t>
<t tx="ekr.20181108111640.53">class Comprehension(Node):
    """ Represents a single for-clause in a comprehension.
    
    Attributes:
        target_node: reference to use for each element, typically a
            Name or Tuple node.
        iter_node: the object to iterate over.
        if_nodes: a list of test expressions.
    """
    __slots__ = 'target_node', 'iter_node', 'if_nodes'


## Statements

</t>
<t tx="ekr.20181108111640.54">class Assign(Node):
    """ Assignment of a value to a variable.
    
    Attributes:
        target_nodes: variables to assign to, Name or SubScript.
        value_node: the object to assign.
    """
    __slots__ = 'target_nodes', 'value_node'

</t>
<t tx="ekr.20181108111640.55">class AugAssign(Node):
    """ Augmented assignment, such as ``a += 1``.
    
    Attributes:
        target_node: variable to assign to, Name or SubScript.
        op: operator enum (e.g. ``Node.OPS.Add``)
        value_node: the object to assign.
    """ 
    __slots__ = 'target_node', 'op', 'value_node'


</t>
<t tx="ekr.20181108111640.56">class Raise(Node):
    """ Raising an exception.
    
    Attributes:
        exc_node: the exception object to be raised, normally a Call
            or Name, or None for a standalone raise.
        cause_node: the optional part for y in raise x from y.
    """
    __slots__ = 'exc_node', 'cause_node'

</t>
<t tx="ekr.20181108111640.57">class Assert(Node):
    """ An assertion.
    
    Attributes:
        test_node: the condition to test.
        msg_node: the failure message (commonly a Str node)
    """
    __slots__ = 'test_node', 'msg_node'

</t>
<t tx="ekr.20181108111640.58">class Delete(Node):
    """ A del statement.
    
    Attributes:
        target_nodes: the variables to delete, such as Name, Attribute
            or Subscript nodes.
    """
    __slots__ = 'target_nodes',

</t>
<t tx="ekr.20181108111640.59">class Pass(Node):
    """ Do nothing.
    """
    __slots__ = ()

</t>
<t tx="ekr.20181108111640.6">def this_is_js():
    """ Function available in both JS and Py that returns whether the code is running
    on Python or JavaScript.
    """
    return False
</t>
<t tx="ekr.20181108111640.60">class Import(Node):
    """ An import statement.
    
    Attributes:
        root: the name of the module to import from. None if this is
            not a from-import.
        names: list of (name, alias) tuples, where alias can be None.
        level: an integer indicating depth of import. Zero means
            absolute import.
    """
    __slots__ = 'root', 'names', 'level'

## Control flow

</t>
<t tx="ekr.20181108111640.61">class If(Node):
    """ An if-statement.
    
    Note that elif clauses don't have a special representation in the
    AST, but rather appear as extra If nodes within the else section
    of the previous one.
    
    Attributes:
        test_node: the test, e.g. a Compare node.
        body_nodes: the body of the if-statement.
        else_nodes: the body of the else-clause of the if-statement.
    """
    __slots__ = 'test_node', 'body_nodes', 'else_nodes'

</t>
<t tx="ekr.20181108111640.62">class For(Node):
    """ A for-loop.
    
    Attributes:
        target_node: the variable(s) the loop assigns to.
        iter_node: the object to iterate over.
        body_nodes: the body of the for-loop.
        else_nodes: the body of the else-clause of the for-loop.
    """
    __slots__ = 'target_node', 'iter_node', 'body_nodes', 'else_nodes'

</t>
<t tx="ekr.20181108111640.63">class While(Node):
    """ A while-loop.
    
    Attributes:
        test_node: the test to perform on each iteration.
        body_nodes: the body of the for-loop.
        else_nodes: the body of the else-clause of the for-loop.
    """
    __slots__ = 'test_node', 'body_nodes', 'else_nodes'

</t>
<t tx="ekr.20181108111640.64">class Break(Node):
    """ Break from a loop.
    """
    __slots__ = ()

</t>
<t tx="ekr.20181108111640.65">class Continue(Node):
    """ Continue with next iteration of a loop.
    """
    __slots__ = ()

</t>
<t tx="ekr.20181108111640.66">class Try(Node):
    """ Try-block.
    
    Attributes:
        body_nodes: the body of the try-block (i.e. the code to try).
        handler_nodes: a list of ExceptHandler instances.
        else_nodes: the body of the else-clause of the try-block.
        finally_nodes: the body of the finally-clause of the try-block.
    """
    __slots__ = 'body_nodes', 'handler_nodes', 'else_nodes', 'finally_nodes'

</t>
<t tx="ekr.20181108111640.67">class ExceptHandler(Node):
    """ Single except-clause.
    
    Attributes:
        type_node: the type of exception to catch. Often a Name node
            or None to catch all.
        name: the string name of the exception object in case of ``as err``.
            None otherwise.
        body_nodes: the body of the except-clause.
    """
    __slots__ = 'type_node', 'name', 'body_nodes'

</t>
<t tx="ekr.20181108111640.68">class With(Node):
    """ A with-block (i.e. a context manager).
    
    Attributes:
        item_nodes: a list of WithItem nodes (i.e. context managers).
        body_nodes: the body of the with-block.
    """
    __slots__ = 'item_nodes', 'body_nodes'

</t>
<t tx="ekr.20181108111640.69">class WithItem(Node):
    """ A single context manager in a with block.
    
    Attributes:
        expr_node: the expression for the context manager.
        as_node: a Name, Tuple or List node representing the ``as foo`` part.
    """
    __slots__ = 'expr_node', 'as_node'

## Function and class definitions

</t>
<t tx="ekr.20181108111640.7">"""
Module that defines a common AST description, independent from Python
version and implementation. Also provides a function ``parse()`` to
generate this common AST by using the builtin ast module and converting
the result. Supports CPython 2.7, CPython 3.2+, Pypy.

https://github.com/almarklein/commonast
"""

# Notes:
# Python 3.6 introduced ast.Constant, which seems to be added so that 3d
# party code can use it, but ast.parse does not produce it afaik.

from __future__ import print_function, absolute_import

import sys
import ast
import json
from base64 import encodestring as encodebytes, decodestring as decodebytes

pyversion = sys.version_info
NoneType = None.__class__

if pyversion &gt;= (3, ):
    basestring = str  # noqa


# do some extra asserts when running tests, but not always, for speed
docheck = 'pytest' in sys.modules

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181108111640.70">class FunctionDef(Node):
    """ A function definition.
    
    Attributes:
        name: the (string) name of the function.
        decorator_nodes: the list of decorators to be applied, stored
            outermost first (i.e. the first in the list will be applied
            last).
        annotation_node: the return annotation (Python 3 only).
        arg_nodes: list of Args nodes representing positional arguments.
            These *may* have a default value.
        kwarg_nodes: list of Arg nodes representing keyword-only arguments.
        args_node: an Arg node representing ``*args``.
        kwargs_node: an Arg node representing ``**kwargs``.
        body_nodes: the body of the function.
    """
    __slots__ = ('name', 'decorator_nodes', 'annotation_node',
                 'arg_nodes', 'kwarg_nodes', 'args_node', 'kwargs_node', 
                 'body_nodes')

</t>
<t tx="ekr.20181108111640.71">class Lambda(Node):
    """ Anonymous function definition.
    
    Attributes:
        arg_nodes: list of Args nodes representing positional arguments.
        kwarg_nodes: list of Arg nodes representing keyword-only arguments.
        args_node: an Arg node representing ``*args``.
        kwargs_node: an Arg node representing ``**kwargs``.
        body_node: the body of the function (a single node).
    """
    __slots__ = ('arg_nodes', 'kwarg_nodes', 'args_node', 'kwargs_node', 
                 'body_node')

</t>
<t tx="ekr.20181108111640.72">class AsyncFunctionDef(Node):
    """ Asynchronous function definition.
    
    Same as FunctionDef, but async.
    """
    __slots__ = ('name', 'decorator_nodes', 'annotation_node',
                 'arg_nodes', 'kwarg_nodes', 'args_node', 'kwargs_node', 
                 'body_nodes')

</t>
<t tx="ekr.20181108111640.73">class Arg(Node):
    """ Function argument for a FunctionDef.
    
    Attributes:
        name: the (string) name of the argument.
        value_node: the default value of this argument. Can be None.
        annotation_node: the annotation for this argument (Python3 only).
    """
    
    __slots__ = ('name', 'value_node', 'annotation_node')

</t>
<t tx="ekr.20181108111640.74">class Return(Node):
    """
    Attributes:
        value_node: the value to return.
    """
    __slots__ = 'value_node',

</t>
<t tx="ekr.20181108111640.75">class Yield(Node):
    """
    Attributes:
        value_node: the value to yield.
    """
    __slots__ = 'value_node',

</t>
<t tx="ekr.20181108111640.76">class YieldFrom(Node):
    """
    Attributes:
        value_node: the value to yield.
    """
    __slots__ = 'value_node',

</t>
<t tx="ekr.20181108111640.77">class Await(Node):
    """
    Attributes:
        value_node: the value to return.
    """
    __slots__ = 'value_node',

</t>
<t tx="ekr.20181108111640.78">class Global(Node):
    """
    Attributes:
        names: a list of string names to declare global.
    """
    __slots__ = 'names',

</t>
<t tx="ekr.20181108111640.79">class Nonlocal(Node):
    """
    Attributes:
        names: a list of string names to declare nonlocal.
    """
    __slots__ = 'names',

</t>
<t tx="ekr.20181108111640.80">class ClassDef(Node):
    """ A class definition.
    
    Attributes:
        name: a string for the class name.
        decorator_nodes: the list of decorators to be applied, as in FunctionDef.
        arg_nodes: list of nodes representing base classes.
        kwarg_nodes: list of Keyword nodes representing keyword-only arguments.
        body_nodes: the body of the class.
    
    Note that arg_nodes and kwarg_nodes are similar to those in the
    Call node. An argument ``*x`` would be specified as a Starred node
    in arg_nodes, and ``**y`` as a Keyword node with a name being
    ``None``. For more information on keyword arguments see
    https://www.python.org/dev/peps/pep-3115/.
    """
    __slots__ = ('name', 'decorator_nodes', 'arg_nodes', 'kwarg_nodes', 'body_nodes')

## -- (end marker for doc generator)


</t>
<t tx="ekr.20181108111640.81">class NativeAstConverter:
    """ Convert ast produced by Python's ast module to common ast.
    """
    
    @others
</t>
<t tx="ekr.20181108111640.82">def __init__(self, code):
    self._root = ast.parse(code)
    self._lines =code.splitlines()
    self._stack = []  # contains tuple elements: (list_obj, native_nodes)

</t>
<t tx="ekr.20181108111640.83">def _add_comments(self, container, lineno):
    """ Add comment nodes from the last point until the given line number.
    """
    linenr1 = self._comment_pointer
    linenr2 = lineno
    self._comment_pointer = linenr2 + 1  # store for next time
    
    for i in range(linenr1, linenr2):
        line = self._lines[i-1]  # lineno's start from 1
        if line.lstrip().startswith('#'):
            before, _, comment = line.partition('#')
            node = Comment(comment)
            node.lineno = i
            node.col_offset = len(before)
            container.append(node)

</t>
<t tx="ekr.20181108111640.84">def convert(self, comments=False):
    assert not self._stack
    self._comment_pointer = 1
    
    result = self._convert(self._root)
    
    while self._stack:
        container, native_nodes = self._stack.pop(0)
        for native_node in native_nodes:
            node = self._convert(native_node)
            if comments:
                self._add_comments(container, node.lineno)
            container.append(node)
    
    return result

</t>
<t tx="ekr.20181108111640.85">def _convert(self, n):
    
    # n is the native node produced by the ast module
    if n is None:
        return None  # but some node attributes can be None
    assert isinstance(n, ast.AST)
    
    # Get converter function
    type = n.__class__.__name__
    try:
        converter = getattr(self, '_convert_' + type)
    except AttributeError:  # pragma: no cover
        raise RuntimeError('Cannot convert %s nodes.' % type)
    # Convert node
    val = converter(n)
    assert isinstance(val, Node)
    # Set its position
    val.lineno = getattr(n, 'lineno', 1)
    val.col_offset = getattr(n, 'col_offset', 0)
    return val

</t>
<t tx="ekr.20181108111640.86">def _convert_Module(self, n):
    node = Module([])
    # Add back the "docstring" that Python removed; this may actually be
    # a code snippet and not a module.
    self._stack.append((node.body_nodes, n.body))
    return node

## Literals

</t>
<t tx="ekr.20181108111640.87">def _convert_Num(self, n):
    if pyversion &lt; (3, ) and str(n.n).startswith('-'):
        # -4 is a unary sub on 4, dont forget complex numbers
        return UnaryOp(Node.OPS.USub, Num(-n.n))
    return Num(n.n)

</t>
<t tx="ekr.20181108111640.88">def _convert_Str(self, n):
    # We check the string prefix here. We only really need it in Python 2,
    # because u is not needed in py3, and b and r are resolved by the lexer,
    # and f as well (resulting in  JoinedStr or  FormattedValue).
    # Note that the col_offset of the node seems 1 off when the string is
    # a key in a dict :/ (PScript issue #15)
    if pyversion &lt; (3, ):
        line = self._lines[n.lineno-1]
        i = n.col_offset
        i = i - 1 if (i &gt; 0 and line[i-1] in 'rufb"\'') else i
        pre = ''
        if line[i] not in '"\'':
            pre += line[i]
            if line[i + 1] not in '"\'':
                pre += line[i + 1]
        if 'b' in pre:
            return Bytes(n.s)
    return Str(n.s)

</t>
<t tx="ekr.20181108111640.89">def _convert_JoinedStr(self, n):
    c = self._convert
    return JoinedStr([c(x) for x in n.values])

</t>
<t tx="ekr.20181108111640.9">def parse(code, comments=False):
    """ Parse Python code to produce a common AST tree.
    
    Parameters:
        code (str): the Python code to parse
        comments (bool): if True, will include Comment nodes. Default False.
    """
    converter = NativeAstConverter(code)
    return converter.convert(comments)


</t>
<t tx="ekr.20181108111640.90">def _convert_FormattedValue(self, n):
    conversion = '' if n.conversion &lt; 0 else chr(n.conversion)
    return FormattedValue(self._convert(n.value), conversion,
                          self._convert(n.format_spec))

</t>
<t tx="ekr.20181108111640.91">def _convert_Bytes(self, n):
    return Bytes(n.s)

</t>
<t tx="ekr.20181108111640.92">def _convert_List(self, n):
    c = self._convert
    return List([c(x) for x in n.elts])

</t>
<t tx="ekr.20181108111640.93">def _convert_Tuple(self, n):
    c = self._convert
    return Tuple([c(x) for x in n.elts])

</t>
<t tx="ekr.20181108111640.94">def _convert_Set(self, n):
    c = self._convert
    return Set([c(x) for x in n.elts])

</t>
<t tx="ekr.20181108111640.95">def _convert_Dict(self, n):
    c = self._convert
    return Dict([c(x) for x in n.keys], [c(x) for x in n.values])

</t>
<t tx="ekr.20181108111640.96">def _convert_Ellipsis(self, n):
    if pyversion &lt; (3, ):
        return Index(Ellipsis())  # Ellipses must be wrapped in an index
    return Ellipsis()

</t>
<t tx="ekr.20181108111640.97">def _convert_NameConstant(self, n):
    return NameConstant(n.value)

## Variables, attributes, indexing and slicing

</t>
<t tx="ekr.20181108111640.98">def _convert_Name(self, n):
    if pyversion &lt; (3, 4):  # pragma: no cover
        M = {'None': None, 'False': False, 'True': True}
        if n.id in M:
            return NameConstant(M[n.id])  # Python &lt; 3.4
    if pyversion &lt; (3, ) and isinstance(n.ctx , ast.Param):
        return Arg(n.id, None, None)
    return Name(n.id)

</t>
<t tx="ekr.20181108111640.99">def _convert_Starred(self, n):
    return Starred(self._convert(n.value))

</t>
<t tx="ekr.20181108210630.1">""" Convert Python to JavaScript.

Parameters:
    ob (str, module, function, class): The code, function or class
        to transpile.
    new_name (str, optional): If given, renames the function or class. This
        can be used to simply change the name and/or add a prefix. It can
        also be used to turn functions into methods using
        "MyClass.prototype.foo". Double-underscore name mangling is taken
        into account in the process.
    parser_options: Additional options, see
        :class:`Parser class &lt;pscript.Parser&gt;` for details.

Returns:
    str: The JavaScript code as a str object that
    has a ``meta`` attribute with the following fields:
    
    * filename (str): the name of the file that defines the object.
    * linenr (int): the starting linenr for the object definition.
    * pycode (str): the Python code used to generate the JS.
    * pyhash (str): a hash of the Python code.
    * vars_defined (set): names defined in the toplevel namespace.
    * vars_unknown (set): names used in the code but not defined in it.
      This includes namespaces, e.g. "foo.some_function".
    * vars_global (set): names explicitly declared global.
    * std_functions (set): stdlib functions used in this code.
    * std_method (set): stdlib methods used in this code.

Notes:
    The Python source code for a class is acquired by name.
    Therefore one should avoid decorating classes in modules where
    multiple classes with the same name are defined. This is a
    consequence of classes not having a corresponding code object (in
    contrast to functions).

"""</t>
<t tx="ekr.20181108211821.1"># Define builtin stuff for which we know that it returns a bool or int
_bool_funcs = 'hasattr', 'all', 'any', 'op_contains', 'op_equals', 'truthy'
_bool_meths = ('count', 'isalnum', 'isalpha', 'isidentifier', 'islower',
               'isnumeric', 'isdigit', 'isdecimal', 'isspace', 'istitle',
               'isupper', 'startswith')
returning_bool = tuple([stdlib.FUNCTION_PREFIX + x + '(' for x in _bool_funcs] +
                       [stdlib.METHOD_PREFIX + x + '.' for x in _bool_meths])


# precompile regexp to help determine whether a string is an identifier
isidentifier1 = re.compile(r'^\w+$', re.UNICODE)

reserved_names = (
    'abstract', 'instanceof', 'boolean', 'enum', 'switch', 'export',
    'interface', 'synchronized', 'extends', 'let', 'case', 'throw',
    'catch', 'final', 'native', 'throws', 'new', 'transient',
    'const', 'package', 'function', 'private', 'typeof', 'debugger', 'goto',
    'protected', 'var', 'default', 'public', 'void', 'delete', 'implements',
    'volatile', 'do', 'static',
    # Commented, because are disallowed in Python too.
    # 'else', 'break', 'finally', 'class', 'for', 'try', 'continue', 'if',
    # 'return', 'import', 'while', 'in', 'with',
    # Commented for pragmatic reasons
    # 'super', 'float', 'this', 'int', 'byte', 'long', 'char', 'short',
    # 'double', 'null', 'true', 'false',
    )
</t>
<t tx="ekr.20181108212134.1">RAW_DOC_WARNING = ('Function %s only has a docstring, which used to be '
                   'intepreted as raw JS. Wrap a call to RawJS(...) around the '
                   'docstring, or add "pass" to the function body to prevent '
                   'this behavior.')

JS_RESERVED_WORDS = set()


# https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar
RESERVED = {'true', 'false', 'null',
            # Reserved keywords as of ECMAScript 6
            'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger',
            'default', 'delete', 'do', 'else', 'export', 'extends', 'finally',
            'for', 'function', 'if', 'import', 'in', 'instanceof', 'new',
            'return', 'super', 'switch', 'this', 'throw', 'try', 'typeof',
            'var', 'void', 'while', 'with', 'yield',
            # Future reserved keywords
            'implements', 'interface', 'let', 'package', 'private',
            'protected', 'public', 'static', 'enum',
            'await',  # only in module code
            }</t>
<t tx="ekr.20181108212755.1">## ----- Functions

## Special functions: not really in builtins, but important enough to support

FUNCTIONS['perf_counter'] = """function() { // nargs: 0
    if (typeof(process) === "undefined"){return performance.now()*1e-3;}
    else {var t = process.hrtime(); return t[0] + t[1]*1e-9;}
}"""  # Work in nodejs and browser

FUNCTIONS['time'] = """function () {return Date.now() / 1000;} // nargs: 0"""

## Hardcore functions

FUNCTIONS['op_instantiate'] = """function (ob, args) { // nargs: 2
    if ((typeof ob === "undefined") ||
            (typeof window !== "undefined" &amp;&amp; window === ob) ||
            (typeof global !== "undefined" &amp;&amp; global === ob))
            {throw "Class constructor is called as a function.";}
    for (var name in ob) {
        if (Object[name] === undefined &amp;&amp;
            typeof ob[name] === 'function' &amp;&amp; !ob[name].nobind) {
            ob[name] = ob[name].bind(ob);
            ob[name].__name__ = name;
        }
    }
    if (ob.__init__) {
        ob.__init__.apply(ob, args);
    }
}"""

FUNCTIONS['create_dict'] = """function () {
    var d = {};
    for (var i=0; i&lt;arguments.length; i+=2) { d[arguments[i]] = arguments[i+1]; }
    return d;
}"""

FUNCTIONS['merge_dicts'] = """function () {
    var res = {};
    for (var i=0; i&lt;arguments.length; i++) {
        var d = arguments[i];
        var key, keys = Object.keys(d);
        for (var j=0; j&lt;keys.length; j++) { key = keys[j]; res[key] = d[key]; }
    }
    return res;
}"""

# args is a list of (name, default) tuples, and is overwritten with names from kwargs
FUNCTIONS['op_parse_kwargs'] = """
function (arg_names, arg_values, kwargs, strict) { // nargs: 3
    for (var i=0; i&lt;arg_values.length; i++) {
        var name = arg_names[i];
        if (kwargs[name] !== undefined) {
            arg_values[i] = kwargs[name];
            delete kwargs[name];
        }
    }
    if (strict &amp;&amp; Object.keys(kwargs).length &gt; 0) {
        throw FUNCTION_PREFIXop_error('TypeError',
            'Function ' + strict + ' does not accept **kwargs.');
    }
    return kwargs;
}""".lstrip()


FUNCTIONS['op_error'] = """function (etype, msg) { // nargs: 2
    var e = new Error(etype + ': ' + msg);
    e.name = etype
    return e;
}"""

FUNCTIONS['hasattr'] = """function (ob, name) { // nargs: 2
    return (ob !== undefined) &amp;&amp; (ob !== null) &amp;&amp; (ob[name] !== undefined);
}"""

FUNCTIONS['getattr'] = """function (ob, name, deflt) { // nargs: 2 3
    var has_attr = ob !== undefined &amp;&amp; ob !== null &amp;&amp; ob[name] !== undefined;
    if (has_attr) {return ob[name];}
    else if (arguments.length == 3) {return deflt;}
    else {var e = Error(name); e.name='AttributeError'; throw e;}
}"""

FUNCTIONS['setattr'] = """function (ob, name, value) {  // nargs: 3
    ob[name] = value;
}"""

FUNCTIONS['delattr'] = """function (ob, name) {  // nargs: 2
    delete ob[name];
}"""

FUNCTIONS['dict'] = """function (x) {
    var t, i, keys, r={};
    if (Array.isArray(x)) {
        for (i=0; i&lt;x.length; i++) {
            t=x[i]; r[t[0]] = t[1];
        }
    } else {
        keys = Object.keys(x);
        for (i=0; i&lt;keys.length; i++) {
            t=keys[i]; r[t] = x[t];
        }
    }
    return r;
}"""

FUNCTIONS['list'] = """function (x) {
    var r=[];
    if (typeof x==="object" &amp;&amp; !Array.isArray(x)) {x = Object.keys(x)}
    for (var i=0; i&lt;x.length; i++) {
        r.push(x[i]);
    }
    return r;
}"""

FUNCTIONS['range'] = """function (start, end, step) {
    var i, res = [];
    var val = start;
    var n = (end - start) / step;
    for (i=0; i&lt;n; i++) {
        res.push(val);
        val += step;
    }
    return res;
}"""

FUNCTIONS['format'] = """function (v, fmt) {  // nargs: 2
    fmt = fmt.toLowerCase();
    var s = String(v);
    if (fmt.indexOf('!r') &gt;= 0) {
        try { s = JSON.stringify(v); } catch (e) { s = undefined; }
        if (typeof s === 'undefined') { s = v._IS_COMPONENT ? v.id : String(v); }
    }
    var fmt_type = '';
    if (fmt.slice(-1) == 'i' || fmt.slice(-1) == 'f' ||
        fmt.slice(-1) == 'e' || fmt.slice(-1) == 'g') {
            fmt_type = fmt[fmt.length-1]; fmt = fmt.slice(0, fmt.length-1);
    }
    var i0 = fmt.indexOf(':');
    var i1 = fmt.indexOf('.');
    var spec1 = '', spec2 = '';  // before and after dot
    if (i0 &gt;= 0) {
        if (i1 &gt; i0) { spec1 = fmt.slice(i0+1, i1); spec2 = fmt.slice(i1+1); }
        else { spec1 = fmt.slice(i0+1); }
    }
    // Format numbers
    if (fmt_type == '') {
    } else if (fmt_type == 'i') { // integer formatting, for %i
        s = parseInt(v).toFixed(0);
    } else if (fmt_type == 'f') {  // float formatting
        v = parseFloat(v);
        var decimals = spec2 ? Number(spec2) : 6;
        s = v.toFixed(decimals);
    } else if (fmt_type == 'e') {  // exp formatting
        v = parseFloat(v);
        var precision = (spec2 ? Number(spec2) : 6) || 1;
        s = v.toExponential(precision);
    } else if (fmt_type == 'g') {  // "general" formatting
        v = parseFloat(v);
        var precision = (spec2 ? Number(spec2) : 6) || 1;
        // Exp or decimal?
        s = v.toExponential(precision-1);
        var s1 = s.slice(0, s.indexOf('e')), s2 = s.slice(s.indexOf('e'));
        if (s2.length == 3) { s2 = 'e' + s2[1] + '0' + s2[2]; }
        var exp = Number(s2.slice(1));
        if (exp &gt;= -4 &amp;&amp; exp &lt; precision) { s1=v.toPrecision(precision); s2=''; }
        // Skip trailing zeros and dot
        var j = s1.length-1;
        while (j&gt;0 &amp;&amp; s1[j] == '0') { j-=1; }
        s1 = s1.slice(0, j+1);
        if (s1.slice(-1) == '.') { s1 = s1.slice(0, s1.length-1); }
        s = s1 + s2;
    }
    // prefix/padding
    var prefix = '';
    if (spec1) {
        if (spec1[0] == '+' &amp;&amp; v &gt; 0) { prefix = '+'; spec1 = spec1.slice(1); }
        else if (spec1[0] == ' ' &amp;&amp; v &gt; 0) { prefix = ' '; spec1 = spec1.slice(1); }
    }
    if (spec1 &amp;&amp; spec1[0] == '0') {
        var padding = Number(spec1.slice(1)) - (s.length + prefix.length);
        s = '0'.repeat(Math.max(0, padding)) + s;
    }
    return prefix + s;
}"""

## Normal functions

FUNCTIONS['pow'] = 'Math.pow // nargs: 2'

FUNCTIONS['sum'] = """function (x) {  // nargs: 1
    return x.reduce(function(a, b) {return a + b;});
}"""

FUNCTIONS['round'] = 'Math.round // nargs: 1'

FUNCTIONS['int'] = """function (x, base) { // nargs: 1 2
    if(base !== undefined) return parseInt(x, base);
    return x&lt;0 ? Math.ceil(x): Math.floor(x);
}"""

FUNCTIONS['float'] = 'Number // nargs: 1'

FUNCTIONS['str'] = 'String // nargs: 0 1'

# Note use of "_IS_COMPONENT" to check for flexx.app component classes.
FUNCTIONS['repr'] = """function (x) { // nargs: 1
    var res; try { res = JSON.stringify(x); } catch (e) { res = undefined; }
    if (typeof res === 'undefined') { res = x._IS_COMPONENT ? x.id : String(x); }
    return res;
}"""

FUNCTIONS['bool'] = """function (x) { // nargs: 1
    return Boolean(FUNCTION_PREFIXtruthy(x));
}"""

FUNCTIONS['abs'] = 'Math.abs // nargs: 1'

FUNCTIONS['divmod'] = """function (x, y) { // nargs: 2
    var m = x % y; return [(x-m)/y, m];
}"""

FUNCTIONS['all'] = """function (x) { // nargs: 1
    for (var i=0; i&lt;x.length; i++) {
        if (!FUNCTION_PREFIXtruthy(x[i])){return false;}
    } return true;
}"""

FUNCTIONS['any'] = """function (x) { // nargs: 1
    for (var i=0; i&lt;x.length; i++) {
        if (FUNCTION_PREFIXtruthy(x[i])){return true;}
    } return false;
}"""

FUNCTIONS['enumerate'] = """function (iter) { // nargs: 1
    var i, res=[];
    if ((typeof iter==="object") &amp;&amp; (!Array.isArray(iter))) {iter = Object.keys(iter);}
    for (i=0; i&lt;iter.length; i++) {res.push([i, iter[i]]);}
    return res;
}"""
        
FUNCTIONS['zip'] = """function () { // nargs: 2 3 4 5 6 7 8 9
    var i, j, tup, arg, args = [], res = [], len = 1e20;
    for (i=0; i&lt;arguments.length; i++) {
        arg = arguments[i];
        if ((typeof arg==="object") &amp;&amp; (!Array.isArray(arg))) {arg = Object.keys(arg);}
        args.push(arg);
        len = Math.min(len, arg.length);
    }
    for (j=0; j&lt;len; j++) {
        tup = []
        for (i=0; i&lt;args.length; i++) {tup.push(args[i][j]);}
        res.push(tup);
    }
    return res;
}"""

FUNCTIONS['reversed'] = """function (iter) { // nargs: 1
    if ((typeof iter==="object") &amp;&amp; (!Array.isArray(iter))) {iter = Object.keys(iter);}
    return iter.slice().reverse();
}"""

FUNCTIONS['sorted'] = """function (iter, key, reverse) { // nargs: 1 2 3
    if ((typeof iter==="object") &amp;&amp; (!Array.isArray(iter))) {iter = Object.keys(iter);}
    var comp = function (a, b) {a = key(a); b = key(b);
        if (a&lt;b) {return -1;} if (a&gt;b) {return 1;} return 0;};
    comp = Boolean(key) ? comp : undefined; 
    iter = iter.slice().sort(comp);
    if (reverse) iter.reverse();
    return iter;
}"""

FUNCTIONS['filter'] = """function (func, iter) { // nargs: 2
    if (typeof func === "undefined" || func === null) {func = function(x) {return x;}}
    if ((typeof iter==="object") &amp;&amp; (!Array.isArray(iter))) {iter = Object.keys(iter);}
    return iter.filter(func);
}"""

FUNCTIONS['map'] = """function (func, iter) { // nargs: 2
    if (typeof func === "undefined" || func === null) {func = function(x) {return x;}}
    if ((typeof iter==="object") &amp;&amp; (!Array.isArray(iter))) {iter = Object.keys(iter);}
    return iter.map(func);
}"""

## Other / Helper functions

FUNCTIONS['truthy'] = """function (v) {
    if (v === null || typeof v !== "object") {return v;}
    else if (v.length !== undefined) {return v.length ? v : false;}
    else if (v.byteLength !== undefined) {return v.byteLength ? v : false;}
    else if (v.constructor !== Object) {return true;}
    else {return Object.getOwnPropertyNames(v).length ? v : false;}
}"""

FUNCTIONS['op_equals'] = """function op_equals (a, b) { // nargs: 2
    if (a == null || b == null) {
    } else if (Array.isArray(a) &amp;&amp; Array.isArray(b)) {
        var i = 0, iseq = a.length == b.length;
        while (iseq &amp;&amp; i &lt; a.length) {iseq = op_equals(a[i], b[i]); i+=1;}
        return iseq;
    } else if (a.constructor === Object &amp;&amp; b.constructor === Object) {
        var akeys = Object.keys(a), bkeys = Object.keys(b);
        akeys.sort(); bkeys.sort();
        var i=0, k, iseq = op_equals(akeys, bkeys);
        while (iseq &amp;&amp; i &lt; akeys.length)
            {k=akeys[i]; iseq = op_equals(a[k], b[k]); i+=1;}
        return iseq;
    } return a == b;
}"""

FUNCTIONS['op_contains'] = """function op_contains (a, b) { // nargs: 2
    if (b == null) {
    } else if (Array.isArray(b)) {
        for (var i=0; i&lt;b.length; i++) {if (FUNCTION_PREFIXop_equals(a, b[i]))
                                           return true;}
        return false;
    } else if (b.constructor === Object) {
        for (var k in b) {if (a == k) return true;}
        return false;
    } else if (b.constructor == String) {
        return b.indexOf(a) &gt;= 0;
    } var e = Error('Not a container: ' + b); e.name='TypeError'; throw e;
}"""

FUNCTIONS['op_add'] = """function (a, b) { // nargs: 2
    if (Array.isArray(a) &amp;&amp; Array.isArray(b)) {
        return a.concat(b);
    } return a + b;
}"""

FUNCTIONS['op_mult'] = """function (a, b) { // nargs: 2
    if ((typeof a === 'number') + (typeof b === 'number') === 1) {
        if (a.constructor === String) return METHOD_PREFIXrepeat(a, b);
        if (b.constructor === String) return METHOD_PREFIXrepeat(b, a);
        if (Array.isArray(b)) {var t=a; a=b; b=t;}
        if (Array.isArray(a)) {
            var res = []; for (var i=0; i&lt;b; i++) res = res.concat(a);
            return res;
        }
    } return a * b;
}"""


</t>
<t tx="ekr.20181108212823.1">## ----- Methods

## List only

METHODS['append'] = """function (x) { // nargs: 1
    if (!Array.isArray(this)) return this.KEY.apply(this, arguments);
    this.push(x);
}"""

METHODS['extend'] = """function (x) { // nargs: 1
    if (!Array.isArray(this)) return this.KEY.apply(this, arguments);
    this.push.apply(this, x);   
}"""

METHODS['insert'] = """function (i, x) { // nargs: 2
    if (!Array.isArray(this)) return this.KEY.apply(this, arguments);
    i = (i &lt; 0) ? this.length + i : i;
    this.splice(i, 0, x);
}"""

METHODS['remove'] = """function (x) { // nargs: 1
    if (!Array.isArray(this)) return this.KEY.apply(this, arguments);
    for (var i=0; i&lt;this.length; i++) {
        if (FUNCTION_PREFIXop_equals(this[i], x)) {this.splice(i, 1); return;}
    }
    var e = Error(x); e.name='ValueError'; throw e;
}"""

METHODS['reverse'] = """function () { // nargs: 0
    this.reverse();
}"""

METHODS['sort'] = """function (key, reverse) { // nargs: 0 1 2
    if (!Array.isArray(this)) return this.KEY.apply(this, arguments);
    var comp = function (a, b) {a = key(a); b = key(b);
        if (a&lt;b) {return -1;} if (a&gt;b) {return 1;} return 0;};
    comp = Boolean(key) ? comp : undefined; 
    this.sort(comp);
    if (reverse) this.reverse();
}"""

## List and dict

METHODS['clear'] = """function () { // nargs: 0
    if (Array.isArray(this)) {
        this.splice(0, this.length);
    } else if (this.constructor === Object) {
        var keys = Object.keys(this);
        for (var i=0; i&lt;keys.length; i++) delete this[keys[i]];
    } else return this.KEY.apply(this, arguments);
}"""

METHODS['copy'] = """function () { // nargs: 0
    if (Array.isArray(this)) {
        return this.slice(0);
    } else if (this.constructor === Object) {
        var key, keys = Object.keys(this), res = {};
        for (var i=0; i&lt;keys.length; i++) {key = keys[i]; res[key] = this[key];}
        return res;
    } else return this.KEY.apply(this, arguments);
}"""

METHODS['pop'] = """function (i, d) { // nargs: 1 2
    if (Array.isArray(this)) {
        i = (i === undefined) ? -1 : i;
        i = (i &lt; 0) ? (this.length + i) : i;
        var popped = this.splice(i, 1);
        if (popped.length)  return popped[0];
        var e = Error(i); e.name='IndexError'; throw e;
    } else if (this.constructor === Object) {
        var res = this[i]
        if (res !== undefined) {delete this[i]; return res;}
        else if (d !== undefined) return d;
        var e = Error(i); e.name='KeyError'; throw e;
    } else return this.KEY.apply(this, arguments);
}"""

## List and str

# start and stop nor supported for list on Python, but for simplicity, we do
METHODS['count'] = """function (x, start, stop) { // nargs: 1 2 3
    start = (start === undefined) ? 0 : start;
    stop = (stop === undefined) ? this.length : stop;
    start = Math.max(0, ((start &lt; 0) ? this.length + start : start));
    stop = Math.min(this.length, ((stop &lt; 0) ? this.length + stop : stop));
    if (Array.isArray(this)) {
        var count = 0;
        for (var i=0; i&lt;this.length; i++) { 
            if (FUNCTION_PREFIXop_equals(this[i], x)) {count+=1;}
        } return count;
    } else if (this.constructor == String) {
        var count = 0, i = start;
        while (i &gt;= 0 &amp;&amp; i &lt; stop) {
            i = this.indexOf(x, i);
            if (i &lt; 0) break; 
            count += 1;
            i += Math.max(1, x.length);
        } return count;
    } else return this.KEY.apply(this, arguments);
}"""

METHODS['index'] = """function (x, start, stop) { // nargs: 1 2 3
    start = (start === undefined) ? 0 : start;
    stop = (stop === undefined) ? this.length : stop;
    start = Math.max(0, ((start &lt; 0) ? this.length + start : start));
    stop = Math.min(this.length, ((stop &lt; 0) ? this.length + stop : stop));
    if (Array.isArray(this)) {
        for (var i=start; i&lt;stop; i++) {
            if (FUNCTION_PREFIXop_equals(this[i], x)) {return i;} // indexOf cant
        }
    } else if (this.constructor === String) {
        var i = this.slice(start, stop).indexOf(x);
        if (i &gt;= 0) return i + start;
    } else return this.KEY.apply(this, arguments);
    var e = Error(x); e.name='ValueError'; throw e;
}"""

## Dict only

# note: fromkeys is a classmethod, and we dont support it.

METHODS['get'] = """function (key, d) { // nargs: 1 2
    if (this.constructor !== Object) return this.KEY.apply(this, arguments);
    if (this[key] !== undefined) {return this[key];}
    else if (d !== undefined) {return d;}
    else {return null;}
}"""

METHODS['items'] = """function () { // nargs: 0
    if (this.constructor !== Object) return this.KEY.apply(this, arguments);
    var key, keys = Object.keys(this), res = []
    for (var i=0; i&lt;keys.length; i++) {key = keys[i]; res.push([key, this[key]]);}
    return res;
}"""

METHODS['keys'] = """function () { // nargs: 0
    if (typeof this['KEY'] === 'function') return this.KEY.apply(this, arguments);
    return Object.keys(this);
}"""

METHODS['popitem'] = """function () { // nargs: 0
    if (this.constructor !== Object) return this.KEY.apply(this, arguments);
    var keys, key, val;
    keys = Object.keys(this);
    if (keys.length == 0) {var e = Error(); e.name='KeyError'; throw e;}
    key = keys[0]; val = this[key]; delete this[key];
    return [key, val];
}"""

METHODS['setdefault'] = """function (key, d) { // nargs: 1 2
    if (this.constructor !== Object) return this.KEY.apply(this, arguments);
    if (this[key] !== undefined) {return this[key];}
    else if (d !== undefined) { this[key] = d; return d;}
    else {return null;}
}"""

METHODS['update'] = """function (other) { // nargs: 1
    if (this.constructor !== Object) return this.KEY.apply(this, arguments);
    var key, keys = Object.keys(other);
    for (var i=0; i&lt;keys.length; i++) {key = keys[i]; this[key] = other[key];}
    return null;
}"""

METHODS['values'] = """function () { // nargs: 0
    if (this.constructor !== Object) return this.KEY.apply(this, arguments);
    var key, keys = Object.keys(this), res = [];
    for (var i=0; i&lt;keys.length; i++) {key = keys[i]; res.push(this[key]);}
    return res;
}"""

## String only

# ignores: encode, decode, format_map, isprintable, maketrans

# Not a Python method, but a method that we need, and is only ECMA 6
# http://stackoverflow.com/a/5450113/2271927
METHODS['repeat'] = """function(count) { // nargs: 0
    if (this.repeat) return this.repeat(count);
    if (count &lt; 1) return '';
    var result = '', pattern = this.valueOf();
    while (count &gt; 1) {
        if (count &amp; 1) result += pattern;
        count &gt;&gt;= 1, pattern += pattern;
    }
    return result + pattern;
}"""

METHODS['capitalize'] = """function () { // nargs: 0
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    return this.slice(0, 1).toUpperCase() + this.slice(1).toLowerCase();
}"""

METHODS['casefold'] = """function () { // nargs: 0
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    return this.toLowerCase();
}"""

METHODS['center'] = """function (w, fill) { // nargs: 1 2
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    fill = (fill === undefined) ? ' ' : fill;
    var tofill = Math.max(0, w - this.length);
    var left = Math.ceil(tofill / 2);
    var right = tofill - left;
    return METHOD_PREFIXrepeat(fill, left) + this + METHOD_PREFIXrepeat(fill, right);
}"""

METHODS['endswith'] = """function (x) { // nargs: 1
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    return this.lastIndexOf(x) == this.length - x.length;
}"""

METHODS['expandtabs'] = """function (tabsize) { // nargs: 0 1
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    tabsize = (tabsize === undefined) ? 8 : tabsize;
    return this.replace(/\\t/g, METHOD_PREFIXrepeat(' ', tabsize));
}"""

METHODS['find'] = """function (x, start, stop) { // nargs: 1 2 3
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    start = (start === undefined) ? 0 : start;
    stop = (stop === undefined) ? this.length : stop;
    start = Math.max(0, ((start &lt; 0) ? this.length + start : start));
    stop = Math.min(this.length, ((stop &lt; 0) ? this.length + stop : stop));
    var i = this.slice(start, stop).indexOf(x);
    if (i &gt;= 0) return i + start;
    return -1;
}"""

METHODS['format'] = """function () {
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    var parts = [], i = 0, i1, i2;
    var itemnr = -1;
    while (i &lt; this.length) {
        // find opening
        i1 = this.indexOf('{', i);
        if (i1 &lt; 0 || i1 == this.length-1) { break; }
        if (this[i1+1] == '{') {parts.push(this.slice(i, i1+1)); i = i1 + 2; continue;}
        // find closing
        i2 = this.indexOf('}', i1);
        if (i2 &lt; 0) { break; }
        // parse
        itemnr += 1;
        var fmt = this.slice(i1+1, i2);
        var index = fmt.split(':')[0].split('!')[0];
        index = index? Number(index) : itemnr
        var s = FUNCTION_PREFIXformat(arguments[index], fmt);
        parts.push(this.slice(i, i1), s);
        i = i2 + 1;
    }
    parts.push(this.slice(i));
    return parts.join('');
}"""

METHODS['isalnum'] = """function () { // nargs: 0
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    return Boolean(/^[A-Za-z0-9]+$/.test(this));
}"""

METHODS['isalpha'] = """function () { // nargs: 0
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    return Boolean(/^[A-Za-z]+$/.test(this));
}"""

METHODS['isidentifier'] = """function () { // nargs: 0
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    return Boolean(/^[A-Za-z_][A-Za-z0-9_]*$/.test(this));
}"""

METHODS['islower'] = """function () { // nargs: 0
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    var low = this.toLowerCase(), high = this.toUpperCase();
    return low != high &amp;&amp; low == this;
}"""

METHODS['isdecimal'] = """function () { // nargs: 0
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    return Boolean(/^[0-9]+$/.test(this));
}"""

# The thing about isdecimal, isdigit and isnumeric.
# https://stackoverflow.com/a/36800319/2271927
#
# * isdecimal() (Only Decimal Numbers)
# * str.isdigit() (Decimals, Subscripts, Superscripts)
# * isnumeric() (Digits, Vulgar Fractions, Subscripts, Superscripts,
#   Roman Numerals, Currency Numerators)
#
# In other words, isdecimal is the most strict. We used to have
# isnumeric with isdecimal's implementation, so we provide isnumeric
# and isdigit as aliases for now.

METHODS['isnumeric'] = METHODS['isdigit'] = METHODS['isdecimal']

METHODS['isspace'] = """function () { // nargs: 0
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    return Boolean(/^\\s+$/.test(this));
}"""

METHODS['istitle'] = """function () { // nargs: 0
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    var low = this.toLowerCase(), title = METHOD_PREFIXtitle(this);
    return low != title &amp;&amp; title == this;
}"""

METHODS['isupper'] = """function () { // nargs: 0
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    var low = this.toLowerCase(), high = this.toUpperCase();
    return low != high &amp;&amp; high == this;
}"""

METHODS['join'] = """function (x) { // nargs: 1
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    return x.join(this);  // call join on the list instead of the string.   
}"""

METHODS['ljust'] = """function (w, fill) { // nargs: 1 2
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    fill = (fill === undefined) ? ' ' : fill;
    var tofill = Math.max(0, w - this.length);
    return this + METHOD_PREFIXrepeat(fill, tofill);
}"""

METHODS['lower'] = """function () { // nargs: 0
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    return this.toLowerCase();
}"""

METHODS['lstrip'] = """function (chars) { // nargs: 0 1
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    chars = (chars === undefined) ? ' \\t\\r\\n' : chars;
    for (var i=0; i&lt;this.length; i++) {
        if (chars.indexOf(this[i]) &lt; 0) return this.slice(i);
    } return '';
}"""

METHODS['partition'] = """function (sep) { // nargs: 1
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    if (sep === '') {var e = Error('empty sep'); e.name='ValueError'; throw e;}
    var i1 = this.indexOf(sep);
    if (i1 &lt; 0) return [this.slice(0), '', '']
    var i2 = i1 + sep.length;
    return [this.slice(0, i1), this.slice(i1, i2), this.slice(i2)]; 
}"""

METHODS['replace'] = """function (s1, s2, count) {  // nargs: 2 3
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    var i = 0, i2, parts = [];
    count = (count === undefined) ? 1e20 : count;
    while (count &gt; 0) {
        i2 = this.indexOf(s1, i);
        if (i2 &gt;= 0) {
            parts.push(this.slice(i, i2));
            parts.push(s2);
            i = i2 + s1.length;
            count -= 1;
        } else break;
    }
    parts.push(this.slice(i));
    return parts.join('');
}"""

METHODS['rfind'] = """function (x, start, stop) { // nargs: 1 2 3
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    start = (start === undefined) ? 0 : start;
    stop = (stop === undefined) ? this.length : stop;
    start = Math.max(0, ((start &lt; 0) ? this.length + start : start));
    stop = Math.min(this.length, ((stop &lt; 0) ? this.length + stop : stop));
    var i = this.slice(start, stop).lastIndexOf(x);
    if (i &gt;= 0) return i + start;
    return -1;
}"""

METHODS['rindex'] = """function (x, start, stop) {  // nargs: 1 2 3
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    var i = METHOD_PREFIXrfind(this, x, start, stop);
    if (i &gt;= 0) return i;
    var e = Error(x); e.name='ValueError'; throw e;
}"""

METHODS['rjust'] = """function (w, fill) { // nargs: 1 2
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    fill = (fill === undefined) ? ' ' : fill;
    var tofill = Math.max(0, w - this.length);
    return METHOD_PREFIXrepeat(fill, tofill) + this;
}"""

METHODS['rpartition'] = """function (sep) { // nargs: 1
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    if (sep === '') {var e = Error('empty sep'); e.name='ValueError'; throw e;}
    var i1 = this.lastIndexOf(sep);
    if (i1 &lt; 0) return ['', '', this.slice(0)]
    var i2 = i1 + sep.length;
    return [this.slice(0, i1), this.slice(i1, i2), this.slice(i2)]; 
}"""

METHODS['rsplit'] = """function (sep, count) { // nargs: 1 2
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    sep = (sep === undefined) ? /\\s/ : sep;
    count = Math.max(0, (count === undefined) ? 1e20 : count);
    var parts = this.split(sep);
    var limit = Math.max(0, parts.length-count);
    var res = parts.slice(limit);
    if (count &lt; parts.length) res.splice(0, 0, parts.slice(0, limit).join(sep));
    return res;
}"""

METHODS['rstrip'] = """function (chars) { // nargs: 0 1
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    chars = (chars === undefined) ? ' \\t\\r\\n' : chars;
    for (var i=this.length-1; i&gt;=0; i--) {
        if (chars.indexOf(this[i]) &lt; 0) return this.slice(0, i+1);
    } return '';
}"""

METHODS['split'] = """function (sep, count) { // nargs: 0, 1 2
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    if (sep === '') {var e = Error('empty sep'); e.name='ValueError'; throw e;}
    sep = (sep === undefined) ? /\\s/ : sep;
    if (count === undefined) { return this.split(sep); }
    var res = [], i = 0, index1 = 0, index2 = 0;
    while (i &lt; count &amp;&amp; index1 &lt; this.length) {
        index2 = this.indexOf(sep, index1);
        if (index2 &lt; 0) { break; }
        res.push(this.slice(index1, index2));
        index1 = index2 + sep.length || 1;
        i += 1;
    }
    res.push(this.slice(index1));
    return res;
}"""

METHODS['splitlines'] = """function (keepends) { // nargs: 0 1
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    keepends = keepends ? 1 : 0
    var finder = /\\r\\n|\\r|\\n/g;
    var i = 0, i2, isrn, parts = [];
    while (finder.exec(this) !== null) {
        i2 = finder.lastIndex -1;
        isrn = i2 &gt; 0 &amp;&amp; this[i2-1] == '\\r' &amp;&amp; this[i2] == '\\n';
        if (keepends) parts.push(this.slice(i, finder.lastIndex));
        else parts.push(this.slice(i, i2 - isrn));
        i = finder.lastIndex;
    }
    if (i &lt; this.length) parts.push(this.slice(i));
    else if (!parts.length) parts.push('');
    return parts;
}"""

METHODS['startswith'] = """function (x) { // nargs: 1
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    return this.indexOf(x) == 0;
}"""

METHODS['strip'] = """function (chars) { // nargs: 0 1
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    chars = (chars === undefined) ? ' \\t\\r\\n' : chars;
    var i, s1 = this, s2 = '', s3 = '';
    for (i=0; i&lt;s1.length; i++) {
        if (chars.indexOf(s1[i]) &lt; 0) {s2 = s1.slice(i); break;}
    } for (i=s2.length-1; i&gt;=0; i--) {
        if (chars.indexOf(s2[i]) &lt; 0) {s3 = s2.slice(0, i+1); break;}
    } return s3;
}"""

METHODS['swapcase'] = """function () { // nargs: 0
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    var c, res = [];
    for (var i=0; i&lt;this.length; i++) {
        c = this[i];
        if (c.toUpperCase() == c) res.push(c.toLowerCase());
        else res.push(c.toUpperCase());
    } return res.join('');
}"""

METHODS['title'] = """function () { // nargs: 0
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    var i0, res = [], tester = /^[^A-Za-z]?[A-Za-z]$/;
    for (var i=0; i&lt;this.length; i++) {
        i0 = Math.max(0, i-1);
        if (tester.test(this.slice(i0, i+1))) res.push(this[i].toUpperCase());
        else res.push(this[i].toLowerCase());
    } return res.join('');
}"""

METHODS['translate'] = """function (table) { // nargs: 1
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    var c, res = [];
    for (var i=0; i&lt;this.length; i++) {
        c = table[this[i]];
        if (c === undefined) res.push(this[i]);
        else if (c !== null) res.push(c);
    } return res.join('');
}"""

METHODS['upper'] = """function () { // nargs: 0
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    return this.toUpperCase();
}"""

METHODS['zfill'] = """function (width) { // nargs: 1
    if (this.constructor !== String) return this.KEY.apply(this, arguments);
    return METHOD_PREFIXrjust(this, width, '0');
}"""
</t>
</tnodes>
</leo_file>
