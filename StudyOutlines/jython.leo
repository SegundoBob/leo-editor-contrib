<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="4" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="55" left="255" height="837" width="893"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="ekr.20040227065500"><vh>jythonc</vh></v>
<v t="ekr.20040227065500.1"><vh>Recursive import script</vh>
<v t="ekr.20040227065500.2"><vh>importFiles</vh></v>
<v t="ekr.20040227065500.3"><vh>importDir</vh></v>
<v t="ekr.20040227065500.4"><vh>createLastChildOf</vh></v>
</v>
<v t="ekr.20040227065519.624" a="TV"><vh>c:/jython-2.1/tools/jythonc\jast</vh>
<v t="ekr.20040227065519.625"><vh>Modifier.py</vh>
<v t="ekr.20040227065519.626"><vh>&lt;&lt; Modifier declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.627"><vh>Modifier</vh></v>
<v t="ekr.20040227065519.628"><vh>ModifierString</vh></v>
</v>
<v t="ekr.20040227065519.629"><vh>Output.py</vh>
<v t="ekr.20040227065519.630"><vh>&lt;&lt; Output declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.631" a="E"><vh>class SourceFile</vh>
<v t="ekr.20040227065519.632"><vh>__init__</vh></v>
<v t="ekr.20040227065519.633"><vh>dump</vh></v>
<v t="ekr.20040227065519.634"><vh>__repr__</vh></v>
<v t="ekr.20040227065519.635"><vh>writeModifiers</vh></v>
<v t="ekr.20040227065519.636"><vh>write</vh></v>
<v t="ekr.20040227065519.637"><vh>writeln</vh></v>
<v t="ekr.20040227065519.638"><vh>writeList</vh></v>
<v t="ekr.20040227065519.639"><vh>beginBlock</vh></v>
<v t="ekr.20040227065519.640"><vh>endBlock</vh></v>
</v>
</v>
<v t="ekr.20040227065519.641" a="E"><vh>Statement.py</vh>
<v t="ekr.20040227065519.642"><vh>&lt;&lt; Statement declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.643" a="E"><vh>class Statement</vh>
<v t="ekr.20040227065519.644"><vh>__repr__</vh></v>
<v t="ekr.20040227065519.645"><vh>exits</vh></v>
</v>
<v t="ekr.20040227065519.646"><vh>class Class</vh>
<v t="ekr.20040227065519.647"><vh>__init__</vh></v>
<v t="ekr.20040227065519.648"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.649"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040227065519.650"><vh>class Method</vh>
<v t="ekr.20040227065519.651"><vh>__init__</vh></v>
<v t="ekr.20040227065519.652"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.653"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040227065519.654"><vh>class Constructor</vh>
<v t="ekr.20040227065519.655"><vh>__init__</vh></v>
<v t="ekr.20040227065519.656"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.657"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040227065519.658"><vh>class BlankLine</vh>
<v t="ekr.20040227065519.659"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.660"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040227065519.661" a="E"><vh>class Import</vh>
<v t="ekr.20040227065519.662"><vh>__init__</vh></v>
<v t="ekr.20040227065519.663"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.664"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040227065519.665"><vh>class SimpleComment</vh>
<v t="ekr.20040227065519.666"><vh>__init__</vh></v>
<v t="ekr.20040227065519.667"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.668"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040227065519.669"><vh>class Comment</vh>
<v t="ekr.20040227065519.670"><vh>__init__</vh></v>
<v t="ekr.20040227065519.671"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.672"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040227065519.673"><vh>class Declare</vh>
<v t="ekr.20040227065519.674"><vh>__init__</vh></v>
<v t="ekr.20040227065519.675"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.676"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040227065519.677"><vh>class Pass</vh>
<v t="ekr.20040227065519.678"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.679"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040227065519.680"><vh>flatten</vh></v>
<v t="ekr.20040227065519.681"><vh>class FreeBlock</vh>
<v t="ekr.20040227065519.682"><vh>__init__</vh></v>
<v t="ekr.20040227065519.683"><vh>addlocal</vh></v>
<v t="ekr.20040227065519.684"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.685"><vh>exits</vh></v>
<v t="ekr.20040227065519.686"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040227065519.687"><vh>class Block</vh>
<v t="ekr.20040227065519.688"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.689"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040227065519.690"><vh>class TryCatch</vh>
<v t="ekr.20040227065519.691"><vh>__init__</vh></v>
<v t="ekr.20040227065519.692"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.693"><vh>exits</vh></v>
</v>
<v t="ekr.20040227065519.694"><vh>class TryCatches</vh>
<v t="ekr.20040227065519.695"><vh>__init__</vh></v>
<v t="ekr.20040227065519.696"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.697"><vh>exits</vh></v>
</v>
<v t="ekr.20040227065519.698"><vh>class TryFinally</vh>
<v t="ekr.20040227065519.699"><vh>__init__</vh></v>
<v t="ekr.20040227065519.700"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.701"><vh>exits</vh></v>
</v>
<v t="ekr.20040227065519.702"><vh>class If</vh>
<v t="ekr.20040227065519.703"><vh>__init__</vh></v>
<v t="ekr.20040227065519.704"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.705"><vh>exits</vh></v>
</v>
<v t="ekr.20040227065519.706"><vh>class MultiIf</vh>
<v t="ekr.20040227065519.707"><vh>__init__</vh></v>
<v t="ekr.20040227065519.708"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.709"><vh>exits</vh></v>
</v>
<v t="ekr.20040227065519.710"><vh>class While</vh>
<v t="ekr.20040227065519.711"><vh>__init__</vh></v>
<v t="ekr.20040227065519.712"><vh>writeSource</vh></v>
</v>
<v t="ekr.20040227065519.713"><vh>class WhileElse</vh>
<v t="ekr.20040227065519.714"><vh>__init__</vh></v>
<v t="ekr.20040227065519.715"><vh>writeSource</vh></v>
</v>
<v t="ekr.20040227065519.716"><vh>class Switch</vh>
<v t="ekr.20040227065519.717"><vh>__init__</vh></v>
<v t="ekr.20040227065519.718"><vh>writeSource</vh></v>
</v>
<v t="ekr.20040227065519.719"><vh>class Return</vh>
<v t="ekr.20040227065519.720"><vh>__init__</vh></v>
<v t="ekr.20040227065519.721"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.722"><vh>exits</vh></v>
</v>
<v t="ekr.20040227065519.723"><vh>class Throw</vh>
<v t="ekr.20040227065519.724"><vh>__init__</vh></v>
<v t="ekr.20040227065519.725"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.726"><vh>exits</vh></v>
</v>
<v t="ekr.20040227065519.727"><vh>class Break</vh>
<v t="ekr.20040227065519.728"><vh>writeSource</vh></v>
</v>
<v t="ekr.20040227065519.729"><vh>class Continue</vh>
<v t="ekr.20040227065519.730"><vh>writeSource</vh></v>
</v>
<v t="ekr.20040227065519.731"><vh>class Expression</vh>
<v t="ekr.20040227065519.732"><vh>__repr__</vh></v>
<v t="ekr.20040227065519.733"><vh>safeSourceString</vh></v>
<v t="ekr.20040227065519.734"><vh>writeSource</vh></v>
<v t="ekr.20040227065519.735"><vh>_calcargs</vh></v>
<v t="ekr.20040227065519.736"><vh>exits</vh></v>
</v>
<v t="ekr.20040227065519.737"><vh>class UnsafeExpression</vh>
<v t="ekr.20040227065519.738"><vh>safeSourceString</vh></v>
</v>
<v t="ekr.20040227065519.739"><vh>class Cast</vh>
<v t="ekr.20040227065519.740"><vh>__init__</vh></v>
<v t="ekr.20040227065519.741"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.742"><vh>class Set</vh>
<v t="ekr.20040227065519.743"><vh>__init__</vh></v>
<v t="ekr.20040227065519.744"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.745"><vh>class Constant</vh>
<v t="ekr.20040227065519.746"><vh>__init__</vh></v>
<v t="ekr.20040227065519.747"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.748"><vh>class IntegerConstant</vh>
<v t="ekr.20040227065519.749"><vh>&lt;&lt; class IntegerConstant declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040227065519.750"><vh>class FloatConstant</vh>
<v t="ekr.20040227065519.751"><vh>&lt;&lt; class FloatConstant declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040227065519.752"><vh>class CharacterConstant</vh>
<v t="ekr.20040227065519.753"><vh>&lt;&lt; class CharacterConstant declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040227065519.754"><vh>class StringConstant</vh>
<v t="ekr.20040227065519.755"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.756"><vh>class Operation</vh>
<v t="ekr.20040227065519.757"><vh>__init__</vh></v>
<v t="ekr.20040227065519.758"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.759"><vh>class TriTest</vh>
<v t="ekr.20040227065519.760"><vh>__init__</vh></v>
<v t="ekr.20040227065519.761"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.762"><vh>class PostOperation</vh>
<v t="ekr.20040227065519.763"><vh>__init__</vh></v>
<v t="ekr.20040227065519.764"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.765"><vh>class Subscript</vh>
<v t="ekr.20040227065519.766"><vh>__init__</vh></v>
<v t="ekr.20040227065519.767"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.768"><vh>class InvokeLocal</vh>
<v t="ekr.20040227065519.769"><vh>__init__</vh></v>
<v t="ekr.20040227065519.770"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.771"><vh>class Invoke</vh>
<v t="ekr.20040227065519.772"><vh>__init__</vh></v>
<v t="ekr.20040227065519.773"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.774"><vh>class InvokeStatic</vh>
<v t="ekr.20040227065519.775"><vh>__init__</vh></v>
<v t="ekr.20040227065519.776"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.777"><vh>class GetInstanceAttribute</vh>
<v t="ekr.20040227065519.778"><vh>__init__</vh></v>
<v t="ekr.20040227065519.779"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.780"><vh>class GetStaticAttribute</vh>
<v t="ekr.20040227065519.781"><vh>__init__</vh></v>
<v t="ekr.20040227065519.782"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.783"><vh>class SetInstanceAttribute</vh>
<v t="ekr.20040227065519.784"><vh>__init__</vh></v>
<v t="ekr.20040227065519.785"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.786"><vh>class SetStaticAttribute</vh>
<v t="ekr.20040227065519.787"><vh>__init__</vh></v>
<v t="ekr.20040227065519.788"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.789"><vh>class Identifier</vh>
<v t="ekr.20040227065519.790"><vh>__init__</vh></v>
<v t="ekr.20040227065519.791"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.792"><vh>class New</vh>
<v t="ekr.20040227065519.793"><vh>__init__</vh></v>
<v t="ekr.20040227065519.794"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.795"><vh>class FilledArray</vh>
<v t="ekr.20040227065519.796"><vh>__init__</vh></v>
<v t="ekr.20040227065519.797"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.798"><vh>class NewArray</vh>
<v t="ekr.20040227065519.799"><vh>__init__</vh></v>
<v t="ekr.20040227065519.800"><vh>sourceString</vh></v>
</v>
<v t="ekr.20040227065519.801"><vh>class StringArray</vh>
<v t="ekr.20040227065519.802"><vh>__init__</vh></v>
</v>
<v t="ekr.20040227065519.803"><vh>class ClassReference</vh>
<v t="ekr.20040227065519.804"><vh>__init__</vh></v>
<v t="ekr.20040227065519.805"><vh>sourceString</vh></v>
</v>
</v>
<v t="ekr.20040227065519.806"><vh>__init__.py</vh></v>
</v>
<v t="ekr.20040227065519.1"><vh>c:/jython-2.1/tools/jythonc</vh>
<v t="ekr.20040227065519.2"><vh>BaseEvaluator.py</vh>
<v t="ekr.20040227065519.3"><vh>&lt;&lt; BaseEvaluator declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.4"><vh>class BaseEvaluator</vh>
<v t="ekr.20040227065519.5"><vh>__init__</vh></v>
<v t="ekr.20040227065519.6"><vh>parse</vh></v>
<v t="ekr.20040227065519.7"><vh>setline</vh></v>
<v t="ekr.20040227065519.8"><vh>getName</vh></v>
<v t="ekr.20040227065519.9"><vh>visit</vh></v>
<v t="ekr.20040227065519.10"><vh>getAugTmps</vh></v>
<v t="ekr.20040227065519.11"><vh>setAugTmps</vh></v>
<v t="ekr.20040227065519.12"><vh>suite</vh></v>
<v t="ekr.20040227065519.13"><vh>del_stmt</vh></v>
<v t="ekr.20040227065519.14"><vh>delete</vh></v>
<v t="ekr.20040227065519.15"><vh>del_list</vh></v>
<v t="ekr.20040227065519.16"><vh>del_item</vh></v>
<v t="ekr.20040227065519.17"><vh>del_attribute</vh></v>
<v t="ekr.20040227065519.18"><vh>set</vh></v>
<v t="ekr.20040227065519.19"><vh>set_list</vh></v>
<v t="ekr.20040227065519.20"><vh>set_item</vh></v>
<v t="ekr.20040227065519.21"><vh>set_attribute</vh></v>
<v t="ekr.20040227065519.22"><vh>get_item</vh></v>
<v t="ekr.20040227065519.23"><vh>get_attribute</vh></v>
<v t="ekr.20040227065519.24"><vh>makeTemp</vh></v>
<v t="ekr.20040227065519.25"><vh>freeTemp</vh></v>
<v t="ekr.20040227065519.26"><vh>makeFreeDecl</vh></v>
<v t="ekr.20040227065519.27"><vh>expr_stmt</vh></v>
<v t="ekr.20040227065519.28"><vh>binary_op</vh></v>
<v t="ekr.20040227065519.29"><vh>unary_op</vh></v>
<v t="ekr.20040227065519.30"><vh>aug_binary_op</vh></v>
<v t="ekr.20040227065519.31"><vh>compare_op</vh></v>
<v t="ekr.20040227065519.32"><vh>print_line</vh></v>
<v t="ekr.20040227065519.33"><vh>print_continued</vh></v>
<v t="ekr.20040227065519.34"><vh>visitall</vh></v>
<v t="ekr.20040227065519.35"><vh>visitnames</vh></v>
<v t="ekr.20040227065519.36"><vh>invoke</vh></v>
<v t="ekr.20040227065519.37"><vh>call</vh></v>
<v t="ekr.20040227065519.38"><vh>call_extra</vh></v>
<v t="ekr.20040227065519.39"><vh>global_stmt</vh></v>
<v t="ekr.20040227065519.40"><vh>import_stmt</vh></v>
<v t="ekr.20040227065519.41"><vh>importall_stmt</vh></v>
<v t="ekr.20040227065519.42"><vh>importfrom_stmt</vh></v>
<v t="ekr.20040227065519.43"><vh>execstring</vh></v>
<v t="ekr.20040227065519.44"><vh>execfile</vh></v>
</v>
</v>
<v t="ekr.20040227065519.45"><vh>ImportName.py</vh>
<v t="ekr.20040227065519.46"><vh>&lt;&lt; ImportName declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.47"><vh>wrapJava</vh></v>
<v t="ekr.20040227065519.48"><vh>topImport</vh></v>
<v t="ekr.20040227065519.49"><vh>importName</vh></v>
<v t="ekr.20040227065519.50"><vh>findOnPath</vh></v>
<v t="ekr.20040227065519.51"><vh>lookupName</vh></v>
<v t="ekr.20040227065519.52"><vh>class Resource</vh>
<v t="ekr.20040227065519.53"><vh>__init__</vh></v>
<v t="ekr.20040227065519.54"><vh>getDepends</vh></v>
</v>
<v t="ekr.20040227065519.55"><vh>class Namespace</vh>
<v t="ekr.20040227065519.56"><vh>__init__</vh></v>
<v t="ekr.20040227065519.57"><vh>getattr</vh></v>
<v t="ekr.20040227065519.58"><vh>addEvents</vh></v>
<v t="ekr.20040227065519.59"><vh>getDepends</vh></v>
</v>
<v t="ekr.20040227065519.60"><vh>class Package</vh>
<v t="ekr.20040227065519.61"><vh>&lt;&lt; class Package declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.62"><vh>__init__</vh></v>
<v t="ekr.20040227065519.63"><vh>getClasses</vh></v>
</v>
<v t="ekr.20040227065519.64"><vh>class Class</vh>
<v t="ekr.20040227065519.65"><vh>&lt;&lt; class Class declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040227065519.66"><vh>class Module</vh>
<v t="ekr.20040227065519.67"><vh>__init__</vh></v>
<v t="ekr.20040227065519.68"><vh>getattr</vh></v>
<v t="ekr.20040227065519.69"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040227065519.70"><vh>class JavaClass</vh>
<v t="ekr.20040227065519.71"><vh>__init__</vh></v>
<v t="ekr.20040227065519.72"><vh>__repr__</vh></v>
<v t="ekr.20040227065519.73"><vh>findBases</vh></v>
<v t="ekr.20040227065519.74"><vh>findEventProperties</vh></v>
<v t="ekr.20040227065519.75"><vh>addEvents</vh></v>
</v>
</v>
<v t="ekr.20040227065519.76"><vh>JavaCall.py</vh>
<v t="ekr.20040227065519.77"><vh>&lt;&lt; JavaCall declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.78"><vh>call</vh></v>
<v t="ekr.20040227065519.79"><vh>class Signature</vh>
<v t="ekr.20040227065519.80"><vh>__init__</vh></v>
<v t="ekr.20040227065519.81"><vh>handle</vh></v>
<v t="ekr.20040227065519.82"><vh>mkcall</vh></v>
<v t="ekr.20040227065519.83"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040227065519.84"><vh>class JavaFunction</vh>
<v t="ekr.20040227065519.85"><vh>__init__</vh></v>
<v t="ekr.20040227065519.86"><vh>makeSignature</vh></v>
<v t="ekr.20040227065519.87"><vh>__repr__</vh></v>
<v t="ekr.20040227065519.88"><vh>call</vh></v>
<v t="ekr.20040227065519.89"><vh>invoke</vh></v>
</v>
<v t="ekr.20040227065519.90"><vh>class Object</vh>
<v t="ekr.20040227065519.91"><vh>__init__</vh></v>
<v t="ekr.20040227065519.92"><vh>isa</vh></v>
<v t="ekr.20040227065519.93"><vh>asa</vh></v>
</v>
</v>
<v t="ekr.20040227065519.94"><vh>Object.py</vh>
<v t="ekr.20040227065519.95"><vh>&lt;&lt; Object declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.96"><vh>makeAnys</vh></v>
<v t="ekr.20040227065519.97"><vh>PyObjectArray</vh></v>
<v t="ekr.20040227065519.98"><vh>makeStringArray</vh></v>
<v t="ekr.20040227065519.99"><vh>class DelegateMethod</vh>
<v t="ekr.20040227065519.100"><vh>__init__</vh></v>
<v t="ekr.20040227065519.101"><vh>__call__</vh></v>
</v>
<v t="ekr.20040227065519.102"><vh>class Object</vh>
<v t="ekr.20040227065519.103"><vh>__init__</vh></v>
<v t="ekr.20040227065519.104"><vh>asAny</vh></v>
<v t="ekr.20040227065519.105"><vh>makeReference</vh></v>
<v t="ekr.20040227065519.106"><vh>makeStatement</vh></v>
<v t="ekr.20040227065519.107"><vh>mergeWith</vh></v>
<v t="ekr.20040227065519.108"><vh>__repr__</vh></v>
<v t="ekr.20040227065519.109"><vh>__getattr__</vh></v>
</v>
<v t="ekr.20040227065519.110"><vh>class JavaObject</vh>
<v t="ekr.20040227065519.111"><vh>__init__</vh></v>
<v t="ekr.20040227065519.112"><vh>isa</vh></v>
<v t="ekr.20040227065519.113"><vh>asa</vh></v>
<v t="ekr.20040227065519.114"><vh>asAny</vh></v>
<v t="ekr.20040227065519.115"><vh>getStatement</vh></v>
</v>
<v t="ekr.20040227065519.116"><vh>class JavaInteger</vh>
<v t="ekr.20040227065519.117"><vh>__init__</vh></v>
<v t="ekr.20040227065519.118"><vh>asAny</vh></v>
</v>
<v t="ekr.20040227065519.119"><vh>class JavaString</vh>
<v t="ekr.20040227065519.120"><vh>__init__</vh></v>
<v t="ekr.20040227065519.121"><vh>asAny</vh></v>
</v>
<v t="ekr.20040227065519.122"><vh>class PyObject</vh>
<v t="ekr.20040227065519.123"><vh>&lt;&lt; class PyObject declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.124"><vh>getStatement</vh></v>
<v t="ekr.20040227065519.125"><vh>asAny</vh></v>
<v t="ekr.20040227065519.126"><vh>isa</vh></v>
<v t="ekr.20040227065519.127"><vh>asa</vh></v>
<v t="ekr.20040227065519.128"><vh>print_line</vh></v>
<v t="ekr.20040227065519.129"><vh>print_continued</vh></v>
<v t="ekr.20040227065519.130"><vh>print_line_to</vh></v>
<v t="ekr.20040227065519.131"><vh>print_continued_to</vh></v>
<v t="ekr.20040227065519.132"><vh>domethod</vh></v>
<v t="ekr.20040227065519.133"><vh>nonzero</vh></v>
<v t="ekr.20040227065519.134"><vh>unop</vh></v>
<v t="ekr.20040227065519.135"><vh>compop</vh></v>
<v t="ekr.20040227065519.136"><vh>aug_binop</vh></v>
<v t="ekr.20040227065519.137"><vh>igetitem</vh></v>
<v t="ekr.20040227065519.138"><vh>getslice</vh></v>
<v t="ekr.20040227065519.139"><vh>delslice</vh></v>
<v t="ekr.20040227065519.140"><vh>setslice</vh></v>
<v t="ekr.20040227065519.141"><vh>getitem</vh></v>
<v t="ekr.20040227065519.142"><vh>delitem</vh></v>
<v t="ekr.20040227065519.143"><vh>setitem</vh></v>
<v t="ekr.20040227065519.144"><vh>getattr</vh></v>
<v t="ekr.20040227065519.145"><vh>delattr</vh></v>
<v t="ekr.20040227065519.146"><vh>setattr</vh></v>
<v t="ekr.20040227065519.147"><vh>call</vh></v>
<v t="ekr.20040227065519.148"><vh>call_extra</vh></v>
<v t="ekr.20040227065519.149"><vh>invoke</vh></v>
<v t="ekr.20040227065519.150"><vh>doraise</vh></v>
<v t="ekr.20040227065519.151"><vh>mergeWith</vh></v>
<v t="ekr.20040227065519.152"><vh>makeTemp</vh></v>
<v t="ekr.20040227065519.153"><vh>freeTemp</vh></v>
</v>
<v t="ekr.20040227065519.154"><vh>findType</vh></v>
</v>
<v t="ekr.20040227065519.155"><vh>ObjectFactory.py</vh>
<v t="ekr.20040227065519.156"><vh>&lt;&lt; ObjectFactory declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.157"><vh>makeAnys</vh></v>
<v t="ekr.20040227065519.158"><vh>PyObjectArray</vh></v>
<v t="ekr.20040227065519.159"><vh>class ObjectFactory</vh>
<v t="ekr.20040227065519.160"><vh>__init__</vh></v>
<v t="ekr.20040227065519.161"><vh>importName</vh></v>
<v t="ekr.20040227065519.162"><vh>makeFunction</vh></v>
<v t="ekr.20040227065519.163"><vh>makeClass</vh></v>
<v t="ekr.20040227065519.164"><vh>makeList</vh></v>
<v t="ekr.20040227065519.165"><vh>makeTuple</vh></v>
<v t="ekr.20040227065519.166"><vh>makeDictionary</vh></v>
<v t="ekr.20040227065519.167"><vh>makeInteger</vh></v>
<v t="ekr.20040227065519.168"><vh>makeLong</vh></v>
<v t="ekr.20040227065519.169"><vh>makeImaginary</vh></v>
<v t="ekr.20040227065519.170"><vh>makeFloat</vh></v>
<v t="ekr.20040227065519.171"><vh>makeString</vh></v>
<v t="ekr.20040227065519.172"><vh>makeEllipsis</vh></v>
<v t="ekr.20040227065519.173"><vh>makeJavaInteger</vh></v>
<v t="ekr.20040227065519.174"><vh>makeJavaString</vh></v>
<v t="ekr.20040227065519.175"><vh>makeObject</vh></v>
<v t="ekr.20040227065519.176"><vh>makePyObject</vh></v>
<v t="ekr.20040227065519.177"><vh>makeNull</vh></v>
<v t="ekr.20040227065519.178"><vh>makeSlice</vh></v>
<v t="ekr.20040227065519.179"><vh>getCompiler</vh></v>
</v>
<v t="ekr.20040227065519.180"><vh>class FixedObject</vh>
<v t="ekr.20040227065519.181"><vh>&lt;&lt; class FixedObject declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040227065519.182"><vh>class PyConstant</vh>
<v t="ekr.20040227065519.183"><vh>__init__</vh></v>
<v t="ekr.20040227065519.184"><vh>getStatement</vh></v>
</v>
<v t="ekr.20040227065519.185"><vh>class PyFunction</vh>
<v t="ekr.20040227065519.186"><vh>__init__</vh></v>
<v t="ekr.20040227065519.187"><vh>getNew</vh></v>
<v t="ekr.20040227065519.188"><vh>makeCode</vh></v>
</v>
<v t="ekr.20040227065519.189"><vh>class PyClass</vh>
<v t="ekr.20040227065519.190"><vh>__init__</vh></v>
<v t="ekr.20040227065519.191"><vh>getNew</vh></v>
<v t="ekr.20040227065519.192"><vh>_takeSupername</vh></v>
<v t="ekr.20040227065519.193"><vh>isSuperclassJava</vh></v>
<v t="ekr.20040227065519.194"><vh>makeCode</vh></v>
</v>
<v t="ekr.20040227065519.195"><vh>class PyNamespace</vh>
<v t="ekr.20040227065519.196"><vh>__init__</vh></v>
<v t="ekr.20040227065519.197"><vh>getNew</vh></v>
<v t="ekr.20040227065519.198"><vh>getattr</vh></v>
<v t="ekr.20040227065519.199"><vh>invoke</vh></v>
</v>
</v>
<v t="ekr.20040227065519.200"><vh>PathVFS.py</vh>
<v t="ekr.20040227065519.201"><vh>&lt;&lt; PathVFS declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.202"><vh>class JarVFS</vh>
<v t="ekr.20040227065519.203"><vh>__init__</vh></v>
<v t="ekr.20040227065519.204"><vh>open</vh></v>
<v t="ekr.20040227065519.205"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040227065519.206"><vh>class DirVFS</vh>
<v t="ekr.20040227065519.207"><vh>__init__</vh></v>
<v t="ekr.20040227065519.208"><vh>open</vh></v>
<v t="ekr.20040227065519.209"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040227065519.210"><vh>class PathVFS</vh>
<v t="ekr.20040227065519.211"><vh>add_vfs</vh></v>
<v t="ekr.20040227065519.212"><vh>__init__</vh></v>
<v t="ekr.20040227065519.213"><vh>open</vh></v>
</v>
</v>
<v t="ekr.20040227065519.214"><vh>PythonInterpreter.py</vh>
<v t="ekr.20040227065519.215"><vh>&lt;&lt; PythonInterpreter declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.216"><vh>class FlowControlException</vh>
<v t="ekr.20040227065519.217"><vh>&lt;&lt; class FlowControlException declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040227065519.218"><vh>class DoBreak</vh>
<v t="ekr.20040227065519.219"><vh>&lt;&lt; class DoBreak declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040227065519.220"><vh>class DoContinue</vh>
<v t="ekr.20040227065519.221"><vh>&lt;&lt; class DoContinue declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040227065519.222"><vh>class DoReturn</vh>
<v t="ekr.20040227065519.223"><vh>&lt;&lt; class DoReturn declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040227065519.224"><vh>class PythonInterpreter</vh>
<v t="ekr.20040227065519.225"><vh>__init__</vh></v>
<v t="ekr.20040227065519.226"><vh>int_const</vh></v>
<v t="ekr.20040227065519.227"><vh>float_const</vh></v>
<v t="ekr.20040227065519.228"><vh>string_const</vh></v>
<v t="ekr.20040227065519.229"><vh>list_op</vh></v>
<v t="ekr.20040227065519.230"><vh>tuple_op</vh></v>
<v t="ekr.20040227065519.231"><vh>dictionary_op</vh></v>
<v t="ekr.20040227065519.232"><vh>set_name</vh></v>
<v t="ekr.20040227065519.233"><vh>name_const</vh></v>
<v t="ekr.20040227065519.234"><vh>get_module</vh></v>
<v t="ekr.20040227065519.235"><vh>pass_stmt</vh></v>
<v t="ekr.20040227065519.236"><vh>continue_stmt</vh></v>
<v t="ekr.20040227065519.237"><vh>break_stmt</vh></v>
<v t="ekr.20040227065519.238"><vh>return_stmt</vh></v>
<v t="ekr.20040227065519.239"><vh>while_stmt</vh></v>
<v t="ekr.20040227065519.240"><vh>if_stmt</vh></v>
<v t="ekr.20040227065519.241"><vh>for_stmt</vh></v>
</v>
<v t="ekr.20040227065519.242"><vh>class PyObject</vh>
<v t="ekr.20040227065519.243"><vh>print_line</vh></v>
<v t="ekr.20040227065519.244"><vh>print_continued</vh></v>
<v t="ekr.20040227065519.245"><vh>__init__</vh></v>
<v t="ekr.20040227065519.246"><vh>nonzero</vh></v>
<v t="ekr.20040227065519.247"><vh>unop</vh></v>
<v t="ekr.20040227065519.248"><vh>compop</vh></v>
<v t="ekr.20040227065519.249"><vh>getitem</vh></v>
<v t="ekr.20040227065519.250"><vh>setitem</vh></v>
<v t="ekr.20040227065519.251"><vh>getattr</vh></v>
<v t="ekr.20040227065519.252"><vh>setattr</vh></v>
<v t="ekr.20040227065519.253"><vh>call</vh></v>
<v t="ekr.20040227065519.254"><vh>invoke</vh></v>
<v t="ekr.20040227065519.255"><vh>dir</vh></v>
</v>
<v t="ekr.20040227065519.256"><vh>class PyInteger</vh>
<v t="ekr.20040227065519.257"><vh>&lt;&lt; class PyInteger declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040227065519.258"><vh>class PyFloat</vh>
<v t="ekr.20040227065519.259"><vh>&lt;&lt; class PyFloat declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040227065519.260"><vh>class PyString</vh>
<v t="ekr.20040227065519.261"><vh>&lt;&lt; class PyString declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040227065519.262"><vh>makeBuiltins</vh></v>
</v>
<v t="ekr.20040227065519.263"><vh>PythonModule.py</vh>
<v t="ekr.20040227065519.264"><vh>&lt;&lt; PythonModule declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.265"><vh>clean</vh></v>
<v t="ekr.20040227065519.266"><vh>legalJavaName</vh></v>
<v t="ekr.20040227065519.267"><vh>StringArrayOrNull</vh></v>
<v t="ekr.20040227065519.268"><vh>class PythonInner</vh>
<v t="ekr.20040227065519.269"><vh>__init__</vh></v>
<v t="ekr.20040227065519.270"><vh>getConstant</vh></v>
<v t="ekr.20040227065519.271"><vh>getIntegerConstant</vh></v>
<v t="ekr.20040227065519.272"><vh>getLongConstant</vh></v>
<v t="ekr.20040227065519.273"><vh>getImaginaryConstant</vh></v>
<v t="ekr.20040227065519.274"><vh>getFloatConstant</vh></v>
<v t="ekr.20040227065519.275"><vh>getStringConstant</vh></v>
<v t="ekr.20040227065519.276"><vh>getCodeConstant</vh></v>
<v t="ekr.20040227065519.277"><vh>dumpConstants</vh></v>
<v t="ekr.20040227065519.278"><vh>dumpCodes</vh></v>
<v t="ekr.20040227065519.279"><vh>uniquename</vh></v>
<v t="ekr.20040227065519.280"><vh>dumpFuncs</vh></v>
<v t="ekr.20040227065519.281"><vh>getFunctionTable</vh></v>
<v t="ekr.20040227065519.282"><vh>addFunctionCode</vh></v>
<v t="ekr.20040227065519.283"><vh>addMain</vh></v>
<v t="ekr.20040227065519.284"><vh>dumpMain</vh></v>
<v t="ekr.20040227065519.285"><vh>dumpAll</vh></v>
<v t="ekr.20040227065519.286"><vh>makeClass</vh></v>
</v>
<v t="ekr.20040227065519.287"><vh>class PythonModule</vh>
<v t="ekr.20040227065519.288"><vh>getclassname</vh></v>
<v t="ekr.20040227065519.289"><vh>addjavaclass</vh></v>
<v t="ekr.20040227065519.290"><vh>addinnerclass</vh></v>
<v t="ekr.20040227065519.291"><vh>__init__</vh></v>
<v t="ekr.20040227065519.292"><vh>getFrozen</vh></v>
<v t="ekr.20040227065519.293"><vh>addAttribute</vh></v>
<v t="ekr.20040227065519.294"><vh>getIntegerConstant</vh></v>
<v t="ekr.20040227065519.295"><vh>getLongConstant</vh></v>
<v t="ekr.20040227065519.296"><vh>getImaginaryConstant</vh></v>
<v t="ekr.20040227065519.297"><vh>getFloatConstant</vh></v>
<v t="ekr.20040227065519.298"><vh>getStringConstant</vh></v>
<v t="ekr.20040227065519.299"><vh>getCodeConstant</vh></v>
<v t="ekr.20040227065519.300"><vh>addFunctionCode</vh></v>
<v t="ekr.20040227065519.301"><vh>addMain</vh></v>
<v t="ekr.20040227065519.302"><vh>getMainProperties</vh></v>
<v t="ekr.20040227065519.303"><vh>getProxyProperties</vh></v>
<v t="ekr.20040227065519.304"><vh>getPackages</vh></v>
<v t="ekr.20040227065519.305"><vh>dumpDictionary</vh></v>
<v t="ekr.20040227065519.306"><vh>dumpProperties</vh></v>
<v t="ekr.20040227065519.307"><vh>dumpPackages</vh></v>
<v t="ekr.20040227065519.308"><vh>dumpFields</vh></v>
<v t="ekr.20040227065519.309"><vh>dumpInitModule</vh></v>
<v t="ekr.20040227065519.310"><vh>dumpMain</vh></v>
<v t="ekr.20040227065519.311"><vh>dumpInnerClasses</vh></v>
<v t="ekr.20040227065519.312"><vh>dumpAll</vh></v>
<v t="ekr.20040227065519.313"><vh>makeClass</vh></v>
<v t="ekr.20040227065519.314"><vh>makeClassFile</vh></v>
<v t="ekr.20040227065519.315"><vh>dump</vh></v>
</v>
</v>
<v t="ekr.20040227065519.316"><vh>PythonVisitor.py</vh>
<v t="ekr.20040227065519.317"><vh>&lt;&lt; PythonVisitor declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.318"><vh>nodeToList</vh></v>
<v t="ekr.20040227065519.319"><vh>nodeToStrings</vh></v>
<v t="ekr.20040227065519.320"><vh>getDocString</vh></v>
<v t="ekr.20040227065519.321"><vh>class PythonVisitor</vh>
<v t="ekr.20040227065519.322"><vh>__init__</vh></v>
<v t="ekr.20040227065519.323"><vh>getName</vh></v>
<v t="ekr.20040227065519.324"><vh>walk</vh></v>
<v t="ekr.20040227065519.325"><vh>startnode</vh></v>
<v t="ekr.20040227065519.326"><vh>suite</vh></v>
<v t="ekr.20040227065519.327"><vh>exec_stmt</vh></v>
<v t="ekr.20040227065519.328"><vh>assert_stmt</vh></v>
<v t="ekr.20040227065519.329"><vh>pass_stmt</vh></v>
<v t="ekr.20040227065519.330"><vh>break_stmt</vh></v>
<v t="ekr.20040227065519.331"><vh>continue_stmt</vh></v>
<v t="ekr.20040227065519.332"><vh>return_stmt</vh></v>
<v t="ekr.20040227065519.333"><vh>global_stmt</vh></v>
<v t="ekr.20040227065519.334"><vh>raise_stmt</vh></v>
<v t="ekr.20040227065519.335"><vh>Import</vh></v>
<v t="ekr.20040227065519.336"><vh>ImportFrom</vh></v>
<v t="ekr.20040227065519.337"><vh>import_as_name</vh></v>
<v t="ekr.20040227065519.338"><vh>dotted_name</vh></v>
<v t="ekr.20040227065519.339"><vh>print_ext</vh></v>
<v t="ekr.20040227065519.340"><vh>print_stmt</vh></v>
<v t="ekr.20040227065519.341"><vh>if_stmt</vh></v>
<v t="ekr.20040227065519.342"><vh>while_stmt</vh></v>
<v t="ekr.20040227065519.343"><vh>for_stmt</vh></v>
<v t="ekr.20040227065519.344"><vh>expr_stmt</vh></v>
<v t="ekr.20040227065519.345"><vh>del_stmt</vh></v>
<v t="ekr.20040227065519.346"><vh>Name</vh></v>
<v t="ekr.20040227065519.347"><vh>Int</vh></v>
<v t="ekr.20040227065519.348"><vh>Float</vh></v>
<v t="ekr.20040227065519.349"><vh>Complex</vh></v>
<v t="ekr.20040227065519.350"><vh>String</vh></v>
<v t="ekr.20040227065519.351"><vh>Ellipses</vh></v>
<v t="ekr.20040227065519.352"><vh>getSlice</vh></v>
<v t="ekr.20040227065519.353"><vh>Slice</vh></v>
<v t="ekr.20040227065519.354"><vh>makeSeqArgs</vh></v>
<v t="ekr.20040227065519.355"><vh>list</vh></v>
<v t="ekr.20040227065519.356"><vh>list_iter</vh></v>
<v t="ekr.20040227065519.357"><vh>tuple</vh></v>
<v t="ekr.20040227065519.358"><vh>dictionary</vh></v>
<v t="ekr.20040227065519.359"><vh>Dot_Op</vh></v>
<v t="ekr.20040227065519.360"><vh>Index_Op</vh></v>
<v t="ekr.20040227065519.361"><vh>Call_Op</vh></v>
<v t="ekr.20040227065519.362"><vh>binop</vh></v>
<v t="ekr.20040227065519.363"><vh>add_2op</vh></v>
<v t="ekr.20040227065519.364"><vh>sub_2op</vh></v>
<v t="ekr.20040227065519.365"><vh>mul_2op</vh></v>
<v t="ekr.20040227065519.366"><vh>div_2op</vh></v>
<v t="ekr.20040227065519.367"><vh>mod_2op</vh></v>
<v t="ekr.20040227065519.368"><vh>and_2op</vh></v>
<v t="ekr.20040227065519.369"><vh>lshift_2op</vh></v>
<v t="ekr.20040227065519.370"><vh>rshift_2op</vh></v>
<v t="ekr.20040227065519.371"><vh>or_2op</vh></v>
<v t="ekr.20040227065519.372"><vh>xor_2op</vh></v>
<v t="ekr.20040227065519.373"><vh>pow_2op</vh></v>
<v t="ekr.20040227065519.374"><vh>unop</vh></v>
<v t="ekr.20040227065519.375"><vh>abs_1op</vh></v>
<v t="ekr.20040227065519.376"><vh>invert_1op</vh></v>
<v t="ekr.20040227065519.377"><vh>neg_1op</vh></v>
<v t="ekr.20040227065519.378"><vh>abs_1op</vh></v>
<v t="ekr.20040227065519.379"><vh>pos_1op</vh></v>
<v t="ekr.20040227065519.380"><vh>not_1op</vh></v>
<v t="ekr.20040227065519.381"><vh>str_1op</vh></v>
<v t="ekr.20040227065519.382"><vh>aug_binaryop</vh></v>
<v t="ekr.20040227065519.383"><vh>aug_plus</vh></v>
<v t="ekr.20040227065519.384"><vh>aug_minus</vh></v>
<v t="ekr.20040227065519.385"><vh>aug_multiply</vh></v>
<v t="ekr.20040227065519.386"><vh>aug_divide</vh></v>
<v t="ekr.20040227065519.387"><vh>aug_modulo</vh></v>
<v t="ekr.20040227065519.388"><vh>aug_and</vh></v>
<v t="ekr.20040227065519.389"><vh>aug_or</vh></v>
<v t="ekr.20040227065519.390"><vh>aug_xor</vh></v>
<v t="ekr.20040227065519.391"><vh>aug_lshift</vh></v>
<v t="ekr.20040227065519.392"><vh>aug_rshift</vh></v>
<v t="ekr.20040227065519.393"><vh>aug_power</vh></v>
<v t="ekr.20040227065519.394"><vh>getString</vh></v>
<v t="ekr.20040227065519.395"><vh>strjoin</vh></v>
<v t="ekr.20040227065519.396"><vh>comparision</vh></v>
<v t="ekr.20040227065519.397"><vh>and_boolean</vh></v>
<v t="ekr.20040227065519.398"><vh>or_boolean</vh></v>
<v t="ekr.20040227065519.399"><vh>try_stmt</vh></v>
<v t="ekr.20040227065519.400"><vh>funcdef</vh></v>
<v t="ekr.20040227065519.401"><vh>lambdef</vh></v>
<v t="ekr.20040227065519.402"><vh>classdef</vh></v>
</v>
</v>
<v t="ekr.20040227065519.403"><vh>SimpleCompiler.py</vh>
<v t="ekr.20040227065519.404"><vh>&lt;&lt; SimpleCompiler declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.405"><vh>class LocalFrame</vh>
<v t="ekr.20040227065519.406"><vh>__init__</vh></v>
<v t="ekr.20040227065519.407"><vh>setupClosure</vh></v>
<v t="ekr.20040227065519.408"><vh>makeClosure</vh></v>
<v t="ekr.20040227065519.409"><vh>getnames</vh></v>
<v t="ekr.20040227065519.410"><vh>args_count</vh></v>
<v t="ekr.20040227065519.411"><vh>args_arglist</vh></v>
<v t="ekr.20040227065519.412"><vh>args_keyworddict</vh></v>
<v t="ekr.20040227065519.413"><vh>getfreenames</vh></v>
<v t="ekr.20040227065519.414"><vh>getcellnames</vh></v>
<v t="ekr.20040227065519.415"><vh>get_npurecell</vh></v>
<v t="ekr.20040227065519.416"><vh>toCellPrepend</vh></v>
<v t="ekr.20040227065519.417"><vh>gettemps</vh></v>
<v t="ekr.20040227065519.418"><vh>gettemp</vh></v>
<v t="ekr.20040227065519.419"><vh>freetemp</vh></v>
<v t="ekr.20040227065519.420"><vh>get_local_value</vh></v>
<v t="ekr.20040227065519.421"><vh>get_closure_value</vh></v>
<v t="ekr.20040227065519.422"><vh>get_global_value</vh></v>
<v t="ekr.20040227065519.423"><vh>get_name_value</vh></v>
<v t="ekr.20040227065519.424"><vh>set_global_value</vh></v>
<v t="ekr.20040227065519.425"><vh>set_value</vh></v>
<v t="ekr.20040227065519.426"><vh>delCode</vh></v>
<v t="ekr.20040227065519.427"><vh>getReference</vh></v>
<v t="ekr.20040227065519.428"><vh>setCode</vh></v>
<v t="ekr.20040227065519.429"><vh>getglobal</vh></v>
<v t="ekr.20040227065519.430"><vh>getname</vh></v>
<v t="ekr.20040227065519.431"><vh>delname</vh></v>
<v t="ekr.20040227065519.432"><vh>setname</vh></v>
<v t="ekr.20040227065519.433"><vh>getDeclarations</vh></v>
</v>
<v t="ekr.20040227065519.434"><vh>class GlobalFrame</vh>
<v t="ekr.20040227065519.435"><vh>__init__</vh></v>
<v t="ekr.20040227065519.436"><vh>setScope</vh></v>
</v>
<v t="ekr.20040227065519.437"><vh>class ClassFrame</vh>
<v t="ekr.20040227065519.438"><vh>getnames</vh></v>
</v>
<v t="ekr.20040227065519.439"><vh>class FunctionFrame</vh>
<v t="ekr.20040227065519.440"><vh>__init__</vh></v>
</v>
<v t="ekr.20040227065519.441"><vh>class SimpleCompiler</vh>
<v t="ekr.20040227065519.442"><vh>__init__</vh></v>
<v t="ekr.20040227065519.443"><vh>isAlwaysFalse</vh></v>
<v t="ekr.20040227065519.444"><vh>getFutures</vh></v>
<v t="ekr.20040227065519.445"><vh>getFilename</vh></v>
<v t="ekr.20040227065519.446"><vh>error</vh></v>
<v t="ekr.20040227065519.447"><vh>parse</vh></v>
<v t="ekr.20040227065519.448"><vh>makeTemp</vh></v>
<v t="ekr.20040227065519.449"><vh>freeTemp</vh></v>
<v t="ekr.20040227065519.450"><vh>makeFreeDecl</vh></v>
<v t="ekr.20040227065519.451"><vh>int_const</vh></v>
<v t="ekr.20040227065519.452"><vh>long_const</vh></v>
<v t="ekr.20040227065519.453"><vh>complex_const</vh></v>
<v t="ekr.20040227065519.454"><vh>float_const</vh></v>
<v t="ekr.20040227065519.455"><vh>string_const</vh></v>
<v t="ekr.20040227065519.456"><vh>ellipsis_const</vh></v>
<v t="ekr.20040227065519.457"><vh>visitall</vh></v>
<v t="ekr.20040227065519.458"><vh>list_op</vh></v>
<v t="ekr.20040227065519.459"><vh>list_comprehension</vh></v>
<v t="ekr.20040227065519.460"><vh>list_iter</vh></v>
<v t="ekr.20040227065519.461"><vh>tuple_op</vh></v>
<v t="ekr.20040227065519.462"><vh>dictionary_op</vh></v>
<v t="ekr.20040227065519.463"><vh>set_name</vh></v>
<v t="ekr.20040227065519.464"><vh>del_name</vh></v>
<v t="ekr.20040227065519.465"><vh>name_const</vh></v>
<v t="ekr.20040227065519.466"><vh>global_stmt</vh></v>
<v t="ekr.20040227065519.467"><vh>get_module</vh></v>
<v t="ekr.20040227065519.468"><vh>importall_stmt</vh></v>
<v t="ekr.20040227065519.469"><vh>_getnames</vh></v>
<v t="ekr.20040227065519.470"><vh>_loadNames</vh></v>
<v t="ekr.20040227065519.471"><vh>import_stmt</vh></v>
<v t="ekr.20040227065519.472"><vh>getSlice</vh></v>
<v t="ekr.20040227065519.473"><vh>slice_op</vh></v>
<v t="ekr.20040227065519.474"><vh>bool_op</vh></v>
<v t="ekr.20040227065519.475"><vh>and_op</vh></v>
<v t="ekr.20040227065519.476"><vh>or_op</vh></v>
<v t="ekr.20040227065519.477"><vh>do_comp</vh></v>
<v t="ekr.20040227065519.478"><vh>compare_op</vh></v>
<v t="ekr.20040227065519.479"><vh>print_line</vh></v>
<v t="ekr.20040227065519.480"><vh>print_line_to</vh></v>
<v t="ekr.20040227065519.481"><vh>print_continued_to</vh></v>
<v t="ekr.20040227065519.482"><vh>pass_stmt</vh></v>
<v t="ekr.20040227065519.483"><vh>continue_stmt</vh></v>
<v t="ekr.20040227065519.484"><vh>break_stmt</vh></v>
<v t="ekr.20040227065519.485"><vh>exec_stmt</vh></v>
<v t="ekr.20040227065519.486"><vh>assert_stmt</vh></v>
<v t="ekr.20040227065519.487"><vh>return_stmt</vh></v>
<v t="ekr.20040227065519.488"><vh>raise_stmt</vh></v>
<v t="ekr.20040227065519.489"><vh>while_stmt</vh></v>
<v t="ekr.20040227065519.490"><vh>if_stmt</vh></v>
<v t="ekr.20040227065519.491"><vh>tryfinally</vh></v>
<v t="ekr.20040227065519.492"><vh>tryexcept</vh></v>
<v t="ekr.20040227065519.493"><vh>for_stmt</vh></v>
<v t="ekr.20040227065519.494"><vh>funcdef</vh></v>
<v t="ekr.20040227065519.495"><vh>lambdef</vh></v>
<v t="ekr.20040227065519.496"><vh>classdef</vh></v>
<v t="ekr.20040227065519.497"><vh>addModule</vh></v>
<v t="ekr.20040227065519.498"><vh>addSetAttribute</vh></v>
</v>
</v>
<v t="ekr.20040227065519.499" a="M"><vh>compile.py</vh>
<v t="ekr.20040227065519.500"><vh>&lt;&lt; compile declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.501"><vh>getdata</vh></v>
<v t="ekr.20040227065519.502"><vh>getsig</vh></v>
<v t="ekr.20040227065519.503"><vh>insistJavaClass</vh></v>
<v t="ekr.20040227065519.504"><vh>getJavaClass</vh></v>
<v t="ekr.20040227065519.505"><vh>printNames</vh></v>
<v t="ekr.20040227065519.506" a="M"><vh>class Compiler</vh>
<v t="ekr.20040227065519.507"><vh>&lt;&lt; class Compiler declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.508"><vh>__init__</vh></v>
<v t="ekr.20040227065519.509"><vh>write</vh></v>
<v t="ekr.20040227065519.510"><vh>compilefile</vh></v>
<v t="ekr.20040227065519.511"><vh>compile</vh></v>
<v t="ekr.20040227065519.512"><vh>addJavaClass</vh></v>
<v t="ekr.20040227065519.513"><vh>addDependency</vh></v>
<v t="ekr.20040227065519.514"><vh>addDependencies</vh></v>
<v t="ekr.20040227065519.515"><vh>filterpackages</vh></v>
<v t="ekr.20040227065519.516"><vh>makeJavaProxy</vh></v>
<v t="ekr.20040227065519.517"><vh>preprocessModule</vh></v>
<v t="ekr.20040227065519.518"><vh>processModule</vh></v>
<v t="ekr.20040227065519.519"><vh>displayPackages</vh></v>
<v t="ekr.20040227065519.520"><vh>dump</vh></v>
<v t="ekr.20040227065519.521"><vh>java2class</vh></v>
<v t="ekr.20040227065519.522"><vh>makeAdapter</vh></v>
<v t="ekr.20040227065519.523"><vh>trackJavaDependencies</vh></v>
</v>
<v t="ekr.20040227065519.524"><vh>writefile</vh></v>
<v t="ekr.20040227065519.525"><vh>writeclass</vh></v>
<v t="ekr.20040227065519.526"><vh>compile</vh></v>
</v>
<v t="ekr.20040227065519.527"><vh>depend.py</vh>
<v t="ekr.20040227065519.528"><vh>&lt;&lt; depend declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.529"><vh>fix</vh></v>
<v t="ekr.20040227065519.530"><vh>unfix</vh></v>
<v t="ekr.20040227065519.531"><vh>getClass</vh></v>
<v t="ekr.20040227065519.532"><vh>dependencies</vh></v>
<v t="ekr.20040227065519.533"><vh>defaultFilter</vh></v>
<v t="ekr.20040227065519.534"><vh>getFile</vh></v>
<v t="ekr.20040227065519.535"><vh>class PkgEntry</vh>
<v t="ekr.20040227065519.536"><vh>__init__</vh></v>
<v t="ekr.20040227065519.537"><vh>__repr__</vh></v>
<v t="ekr.20040227065519.538"><vh>getInputStream</vh></v>
<v t="ekr.20040227065519.539"><vh>getZipName</vh></v>
</v>
<v t="ekr.20040227065519.540"><vh>class ResourceEntry</vh>
<v t="ekr.20040227065519.541"><vh>__init__</vh></v>
<v t="ekr.20040227065519.542"><vh>__repr__</vh></v>
<v t="ekr.20040227065519.543"><vh>getInputStream</vh></v>
<v t="ekr.20040227065519.544"><vh>getZipName</vh></v>
</v>
<v t="ekr.20040227065519.545"><vh>depends</vh></v>
</v>
<v t="ekr.20040227065519.546"><vh>jar.py</vh>
<v t="ekr.20040227065519.547"><vh>&lt;&lt; jar declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.548"><vh>copy</vh></v>
<v t="ekr.20040227065519.549"><vh>class JavaArchive</vh>
<v t="ekr.20040227065519.550"><vh>__init__</vh></v>
<v t="ekr.20040227065519.551"><vh>addFile</vh></v>
<v t="ekr.20040227065519.552"><vh>addClass</vh></v>
<v t="ekr.20040227065519.553"><vh>addEntry</vh></v>
<v t="ekr.20040227065519.554"><vh>addToManifest</vh></v>
<v t="ekr.20040227065519.555"><vh>dumpManifest</vh></v>
<v t="ekr.20040227065519.556"><vh>dumpFiles</vh></v>
<v t="ekr.20040227065519.557"><vh>dump</vh></v>
<v t="ekr.20040227065519.558"><vh>addPackage</vh></v>
</v>
</v>
<v t="ekr.20040227065519.559"><vh>javac.py</vh>
<v t="ekr.20040227065519.560"><vh>&lt;&lt; javac declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.561"><vh>dumpStream</vh></v>
<v t="ekr.20040227065519.562"><vh>findDefaultJavac</vh></v>
<v t="ekr.20040227065519.563"><vh>getClasspath</vh></v>
<v t="ekr.20040227065519.564"><vh>compile</vh></v>
</v>
<v t="ekr.20040227065519.565"><vh>jythonc.py</vh></v>
<v t="ekr.20040227065519.566"><vh>main.py</vh>
<v t="ekr.20040227065519.567"><vh>&lt;&lt; main declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.568"><vh>usage</vh></v>
<v t="ekr.20040227065519.569"><vh>getOptions</vh></v>
<v t="ekr.20040227065519.570"><vh>addCore</vh></v>
<v t="ekr.20040227065519.571"><vh>addAll</vh></v>
<v t="ekr.20040227065519.572" a="M"><vh>doCompile</vh></v>
<v t="ekr.20040227065519.573"><vh>copyclass</vh></v>
<v t="ekr.20040227065519.574"><vh>writeResults</vh></v>
<v t="ekr.20040227065519.575"><vh>main</vh></v>
</v>
<v t="ekr.20040227065519.576"><vh>proxies.py</vh>
<v t="ekr.20040227065519.577"><vh>&lt;&lt; proxies declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.578"><vh>aget</vh></v>
<v t="ekr.20040227065519.579"><vh>typeName</vh></v>
<v t="ekr.20040227065519.580"><vh>nullReturn</vh></v>
<v t="ekr.20040227065519.581"><vh>makeReturn</vh></v>
<v t="ekr.20040227065519.582"><vh>makeObject</vh></v>
<v t="ekr.20040227065519.583"><vh>filterThrows</vh></v>
<v t="ekr.20040227065519.584"><vh>wrapThrows</vh></v>
<v t="ekr.20040227065519.585"><vh>class JavaProxy</vh>
<v t="ekr.20040227065519.586"><vh>__init__</vh></v>
<v t="ekr.20040227065519.587"><vh>__repr__</vh></v>
<v t="ekr.20040227065519.588"><vh>getSuperproxy</vh></v>
<v t="ekr.20040227065519.589"><vh>getCandSupermethods</vh></v>
<v t="ekr.20040227065519.590"><vh>dumpAll</vh></v>
<v t="ekr.20040227065519.591"><vh>dumpInnerClasses</vh></v>
<v t="ekr.20040227065519.592"><vh>prepMethods</vh></v>
<v t="ekr.20040227065519.593"><vh>dumpMethods</vh></v>
<v t="ekr.20040227065519.594"><vh>dumpConstructors</vh></v>
<v t="ekr.20040227065519.595"><vh>cleanMethods</vh></v>
<v t="ekr.20040227065519.596"><vh>addMethods</vh></v>
<v t="ekr.20040227065519.597"><vh>addConstructors</vh></v>
<v t="ekr.20040227065519.598"><vh>callSuperMethod</vh></v>
<v t="ekr.20040227065519.599"><vh>callMethod</vh></v>
<v t="ekr.20040227065519.600"><vh>callConstructor</vh></v>
<v t="ekr.20040227065519.601"><vh>addPyProxyInterface</vh></v>
<v t="ekr.20040227065519.602"><vh>addClassDictInit</vh></v>
<v t="ekr.20040227065519.603"><vh>makeClass</vh></v>
<v t="ekr.20040227065519.604"><vh>getDescription</vh></v>
</v>
</v>
<v t="ekr.20040227065519.605"><vh>util.py</vh>
<v t="ekr.20040227065519.606"><vh>&lt;&lt; util declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.607"><vh>lookup</vh></v>
<v t="ekr.20040227065519.608"><vh>getzip</vh></v>
<v t="ekr.20040227065519.609"><vh>closezips</vh></v>
<v t="ekr.20040227065519.610"><vh>findClass</vh></v>
<v t="ekr.20040227065519.611"><vh>reportPublicPlainClasses</vh></v>
<v t="ekr.20040227065519.612"><vh>openResource</vh></v>
<v t="ekr.20040227065519.613"><vh>listAllClasses</vh></v>
</v>
<v t="ekr.20040227065519.614"><vh>yapm.py</vh>
<v t="ekr.20040227065519.615"><vh>&lt;&lt; yapm declarations &gt;&gt;</vh></v>
<v t="ekr.20040227065519.616"><vh>class YaPM</vh>
<v t="ekr.20040227065519.617"><vh>__init__</vh></v>
<v t="ekr.20040227065519.618"><vh>findClass</vh></v>
<v t="ekr.20040227065519.619"><vh>findAllPackages</vh></v>
<v t="ekr.20040227065519.620"><vh>filterByName</vh></v>
<v t="ekr.20040227065519.621"><vh>filterByAccess</vh></v>
<v t="ekr.20040227065519.622"><vh>doDir</vh></v>
<v t="ekr.20040227065519.623"><vh>packageExists</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20040227065500"></t>
<t tx="ekr.20040227065500.1"># An example of running this script:

from leoGlobals import *

@others

types = (".py",) #,".c",".html",".txt")

dir = "c:/jython-2.1/tools/jythonc"

importFiles(dir,types,recursive=true)

es("done",color="blue")</t>
<t tx="ekr.20040227065500.2">def importFiles (dir,type=None,kind="@file",recursive=false):
	
	c = top() ; v = c.currentVnode()

	# Check the params.
	if kind != "@file" and kind != "@root":
		es("kind must be @file or @root: " + `kind`)
		return

	if not os_path_exists(dir):
		es("directory does not exist: " + `dir`)
		return
	
	c.beginUpdate()
	root = createLastChildOf(v,"imported files")
	try:
		importDir (dir,type,kind,recursive,root)
		root.contract()
	except:
		es_exception()
	c.endUpdate()
</t>
<t tx="ekr.20040227065500.3">def importDir (dir,types,kind,recursive,root):
	
	c = top() # Get the commander.
	es("dir: " + dir,color="blue")
	
	try:
		files = os.listdir(dir)
		files2 = [] ; dirs =[]
		for f in files:
			path = os_path_join(dir,f)
			if os_path_isfile(path):
				name, ext = os_path_splitext(f)
				if not types or ext in types:
					files2.append(path)
			elif recursive:
				dirs.append(path)
		if len(files2) &gt; 0 or len(dirs) &gt; 0:
			child = createLastChildOf(root,dir)
			c.selectVnode(child)
		if len(files2) &gt; 0:
			c.importCommands.importFilesCommand(files2,kind)
		if len(dirs) &gt; 0:
			dirs.sort()
			for dir in dirs:
				importDir(dir,types,kind,recursive,child)
	except:
		es("exception in importFiles script")
		es_exception()
</t>
<t tx="ekr.20040227065500.4">def createLastChildOf (v,headline):
	
	child = v.insertAsLastChild()
	child.initHeadString(headline)
	return child
</t>
<t tx="ekr.20040227065519.1"></t>
<t tx="ekr.20040227065519.2">@ignore
@language python
&lt;&lt; BaseEvaluator declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040227065519.3"># Copyright (c) Corporation for National Research Initiatives

from PythonVisitor import PythonVisitor, nodeToList
from org.python.parser.PythonGrammarTreeConstants import *
import jast



</t>
<t tx="ekr.20040227065519.4">class BaseEvaluator:
	@others
</t>
<t tx="ekr.20040227065519.5">def __init__(self):
    self.globalnames = {}
    self.augtemps = {}
    self.lineno = -1
    self.visitor = PythonVisitor(self)
    self.imp_accu = None
</t>
<t tx="ekr.20040227065519.6">def parse(self, node):
    try:
        return self.visit(node)
    except:
        print 'Parsing line: %d' % self.lineno
        if hasattr(self, 'data') and self.lineno &gt; 0:
            print self.data.split('\n')[self.lineno-1]
        raise
</t>
<t tx="ekr.20040227065519.7">def setline(self, lineno):
    self.lineno = lineno
</t>
<t tx="ekr.20040227065519.8">def getName(self, name, fast_locals=0):
    return self.visitor.getName(name, fast_locals)
</t>
<t tx="ekr.20040227065519.9">def visit(self, node):
    return node.visit(self.visitor)
</t>
<t tx="ekr.20040227065519.10">def getAugTmps(self, node):
    tmps = self.augtemps[node]
    for var in tmps:
        self.freeTemp(var)
    del self.augtemps[node]
    return tmps
</t>
<t tx="ekr.20040227065519.11">def setAugTmps(self, node, stmts, *vars):
    ret = []
    for var in vars:
        tmp, code = self.makeTemp(var)
        stmts.append(code)
        ret.append(tmp)
    self.augtemps[node] = ret
    return ret
</t>
<t tx="ekr.20040227065519.12">def suite(self, nodes):
    ret = []
    for node in nodes:
        ret.append(self.visit(node))
    return ret
</t>
<t tx="ekr.20040227065519.13">def del_stmt(self, nodes):
    stmts = []
    for node in nodes:
        stmts.append(self.delete(node))
    return stmts
</t>
<t tx="ekr.20040227065519.14">def delete(self, node):
    if node.id == JJTNAME:
        return self.del_name(self.getName(node, self.frame.fast_locals))
    elif node.id == JJTLIST or node.id == JJTTUPLE:
        return self.del_list(nodeToList(node))
    elif node.id == JJTINDEX_OP:
        return self.del_item(node.getChild(0), 
                        node.getChild(1))
    elif node.id == JJTDOT_OP:
        return self.del_attribute(node.getChild(0),
                        self.getName(node.getChild(1)))
    else:
        raise TypeError, 'help, fancy lhs: %s' % node
</t>
<t tx="ekr.20040227065519.15">def del_list(self, seq):
    return self.del_stmt(seq)
</t>
<t tx="ekr.20040227065519.16">def del_item(self, obj, index):
    if index.id == JJTSLICE:
        start, stop, step = self.getSlice(index)
        return self.visit(obj).delslice(start, stop, step)
    return self.visit(obj).delitem(self.visit(index))
</t>
<t tx="ekr.20040227065519.17">def del_attribute(self, obj, name):
    return self.visit(obj).delattr(name)
</t>
<t tx="ekr.20040227065519.18">def set(self, node, value):
    if node.id == JJTNAME:
        return self.set_name(self.getName(node, self.frame.fast_locals),
                             value)
    elif node.id == JJTLIST or node.id == JJTFPLIST or node.id == JJTTUPLE:
        return self.set_list(nodeToList(node), value)
    elif node.id == JJTINDEX_OP:
        return self.set_item(node.getChild(0), 
                        node.getChild(1), value)
    elif node.id == JJTDOT_OP:
        return self.set_attribute(node.getChild(0),
                        self.getName(node.getChild(1)), value)  
    else:
        raise TypeError, 'help, fancy lhs: %s' % node
</t>
<t tx="ekr.20040227065519.19">def set_list(self, seq, value):
    if hasattr(self, 'AUG'):
        raise SyntaxError, "augmented assign to tuple not possible"
    if len(seq) &gt; 0 and seq[-1].id == JJTCOMMA:
        del seq[-1]
    n = len(seq)

    unpacked = jast.InvokeStatic("org.python.core.Py", "unpackSequence",
                                  [value.asAny(), jast.IntegerConstant(n)])
    tmp = self.frame.gettemp('PyObject[]')
    stmts = [ jast.Set(tmp, unpacked) ]
    
    for i in range(n):
        code = jast.Subscript(tmp, i)
        stmts.append(self.set(seq[i], self.factory.makePyObject(code)))
    self.frame.freetemp(tmp)
    return stmts
</t>
<t tx="ekr.20040227065519.20">def set_item(self, obj, index, value):
    if index.id == JJTSLICE:
        if hasattr(self, 'AUG'):
            o, start, stop, step = self.getAugTmps(obj)
        else:
            o = self.visit(obj)
            start, stop, step = self.getSlice(index)
        return o.setslice(start, stop, step, value)

    if hasattr(self, 'AUG'):
        o, idx = self.getAugTmps(obj)
    else:
        o = self.visit(obj)
        idx = self.visit(index)
    return o.setitem(idx, value)
</t>
<t tx="ekr.20040227065519.21">def set_attribute(self, obj, name, value):
    if hasattr(self, 'AUG'):
        o, = self.getAugTmps(obj)
    else:
        o = self.visit(obj)
    return o.setattr(name, value)
</t>
<t tx="ekr.20040227065519.22">def get_item(self, obj, index):
    if index.id == JJTSLICE:
        start, stop, step = self.getSlice(index)
        o = self.visit(obj)

        if hasattr(self, 'AUG'):
            o, start, stop, step = self.setAugTmps(obj, self.AUG, 
                         o, start, stop, step)
        return o.getslice(start, stop, step)

    idx = self.visit(index)
    o = self.visit(obj)

    if hasattr(self, 'AUG'):
        o, idx = self.setAugTmps(obj, self.AUG, o, idx)
    return o.getitem(idx)
</t>
<t tx="ekr.20040227065519.23">def get_attribute(self, obj, name):
    o = self.visit(obj)
    if hasattr(self, 'AUG'):
        o, = self.setAugTmps(obj, self.AUG, o)
    return o.getattr(name)
</t>
<t tx="ekr.20040227065519.24">def makeTemp(self, value):
    return value
</t>
<t tx="ekr.20040227065519.25">def freeTemp(self, tmp): pass
</t>
<t tx="ekr.20040227065519.26">def makeFreeDecl(self,type,value): pass
</t>
<t tx="ekr.20040227065519.27">def expr_stmt(self, lhss, rhs):
    if len(lhss) == 0:
        return self.visit(rhs).makeStatement()
    if len(lhss) == 1:
        return self.set(lhss[0], self.visit(rhs))

    tmp, code = self.makeTemp(self.visit(rhs))
    stmts = [code]
    for lhs in lhss:
        stmts.append(self.set(lhs, tmp))
    self.freeTemp(tmp)
    return stmts
</t>
<t tx="ekr.20040227065519.28">def binary_op(self, name, x, y):
    return self.visit(x).binop(name, self.visit(y))
</t>
<t tx="ekr.20040227065519.29">def unary_op(self, name, x):
    return self.visit(x).unop(name)
</t>
<t tx="ekr.20040227065519.30">def aug_binary_op(self, name, lhs, rhs):
    tmp, code = self.makeTemp(self.visit(rhs))
    stmts = [code]

    self.AUG = stmts
    l = self.visit(lhs)
    result = l.aug_binop(name, tmp)
    stmts.append(self.set(lhs, result))
    del self.AUG
    self.freeTemp(tmp)
    
    return stmts
</t>
<t tx="ekr.20040227065519.31">def compare_op(self, start, compares):
    x = self.visit(start)
    for op, other in compares:
        y = self.visit(other)
        test = x.compop(op, y)
        if not test.nonzero():
            return test
        x = y
    return test
</t>
<t tx="ekr.20040227065519.32">def print_line(self, value=None):
    if value is None:
        print
    else:
        return self.visit(value).print_line()
</t>
<t tx="ekr.20040227065519.33">def print_continued(self, value):
    return self.visit(value).print_continued()
</t>
<t tx="ekr.20040227065519.34">def visitall(self, args):
    ret = []
    for arg in args:
        ret.append(self.visit(arg))
    return ret
</t>
<t tx="ekr.20040227065519.35">def visitnames(self, kws):
    ret = []
    for name, value in kws:
        ret.append( (name, self.visit(value)) )
    return ret
</t>
<t tx="ekr.20040227065519.36">def invoke(self, obj, name, args, kws):
    return self.visit(obj).invoke(name, self.visitall(args),
                                  self.visitnames(kws))
</t>
<t tx="ekr.20040227065519.37">def call(self, callee, args, kws):
    return self.visit(callee).call(self.visitall(args),
                                   self.visitnames(kws))
</t>
<t tx="ekr.20040227065519.38">def call_extra(self, callee, args, kws, starargs, kwargs):
    #print "call_extra", self.visit(callee)
    if starargs:
        starargs = self.visit(starargs.getChild(0))
    if kwargs:
        kwargs = self.visit(kwargs.getChild(0))
    return self.visit(callee).call_extra(self.visitall(args),
                                        self.visitnames(kws),
                                        starargs,
                                        kwargs)
</t>
<t tx="ekr.20040227065519.39">def global_stmt(self, names):
    for name in names:
        self.globalnames[name] = 1
</t>
<t tx="ekr.20040227065519.40">def import_stmt(self, names):
    ret = []
    for name in names:
        ret.append(self.set_name(name[0], self.get_module(name)))
    return ret
</t>
<t tx="ekr.20040227065519.41">def importall_stmt(self, top):
    pass
</t>
<t tx="ekr.20040227065519.42">def importfrom_stmt(self, top, names):                      
    module = self.get_module(top, 0)
    if names == '*':
        return self.importall_stmt(module)
        #print 'import * from', module
        #names = module.dir()

    modnames = []
    asnames = []
    for modname, asname in names:
        if asname is None:
            asname = modname
        asnames.append(asname)
        modnames.append(modname)

    topmodname = jast.StringConstant(".".join(top))
    modnamesArray = jast.FilledArray(
        "String",
        map(lambda x: jast.StringConstant(x), modnames))

    do_import = jast.InvokeStatic("org.python.core.imp", "importFrom",
                                  [topmodname, modnamesArray,
                                   self.frame.frame])

    if not self.imp_accu:
        imp_accu = self.imp_accu = jast.Identifier("imp_accu")
        self.makeFreeDecl("PyObject[]",imp_accu)
    else:
        imp_accu = self.imp_accu
    
    stmts = [jast.Set(imp_accu,do_import)]
    
    for i in range(len(asnames)):
        asname = asnames[i]
        modname = modnames[i]
        code = jast.Subscript(imp_accu,i)
        stmts.append(self.set_name(asname, 
     	module.getattr(modname).makeReference(code)))

    stmts.append(jast.Set(imp_accu,jast.Null))
    
    return stmts       
</t>
<t tx="ekr.20040227065519.43">#external interfaces
def execstring(self, data):
    self.data = data
    from org.python.core import parser
    node = parser.parse(data, 'exec')
    return self.parse(node)
</t>
<t tx="ekr.20040227065519.44">def execfile(self, filename):
    fp = open(filename, 'r')
    data = fp.read()
    fp.close()
    return execstring(data)
</t>
<t tx="ekr.20040227065519.45">@ignore
@language python
&lt;&lt; ImportName declarations &gt;&gt;
@others



if __name__ == '__main__':
    import sys
    print sys.path
    print importName("pawt.colors"), importName("SimpleCompiler"), \
          importName("pawt")
    print importName("os.path")
    print sys.modules
</t>
<t tx="ekr.20040227065519.46"># Copyright (c) Corporation for National Research Initiatives

import sys
import os

from org.python.core import PyModule, PyJavaClass, PyClass, \
     PyJavaPackage, PyBeanEventProperty

from util import lookup



</t>
<t tx="ekr.20040227065519.47">def wrapJava(mod):
    if isinstance(mod, PyModule):
        return Module(mod)
    elif isinstance(mod, PyJavaClass):
        return JavaClass(mod)
    elif isinstance(mod, PyClass):
        return Class(mod)
    elif isinstance(mod, PyJavaPackage):
        return Package(mod)
    else:
        return Namespace(mod)
</t>
<t tx="ekr.20040227065519.48">def topImport(name):
    if not name in sys.builtin_module_names:
        top = findOnPath(name)
        if top is not None:
            return top
    try:
        return wrapJava(__import__(name))
    except ImportError:
        return None
</t>
<t tx="ekr.20040227065519.49">def importName(name):
    if name[0] == "/":
        return Resource(name)
    try:
        names = name.split('.')
        top = topImport(names[0])
        for name in names[1:]:
            top = top.getattr(name)
        return top
    except (ImportError, AttributeError):
        return None
</t>
<t tx="ekr.20040227065519.50">def findOnPath(name, path=sys.path):
    try:
        pyname = name+".py"
        for d in path:
            pyfile = os.path.join(d, pyname)
            if os.path.exists(pyfile):
                return Module(name=name, file=pyfile)
            initfile = os.path.join(os.path.join(d, name), "__init__.py")
            if os.path.exists(initfile):
                return Module(name=name, file=None,
                              path=[os.path.join(d, name)])
    # TBD: this is bogus
    except "fake":
        return None
</t>
<t tx="ekr.20040227065519.51">def lookupName(name):
    return importName(name)
</t>
<t tx="ekr.20040227065519.52">
class Resource:
	@others
</t>
<t tx="ekr.20040227065519.53">def __init__(self, name):
    self.name = name
</t>
<t tx="ekr.20040227065519.54">def getDepends(self):
    return []
</t>
<t tx="ekr.20040227065519.55"> 

class Namespace:
	@others
</t>
<t tx="ekr.20040227065519.56">def __init__(self, mod):
    if hasattr(mod, '__name__'):
        self.name = mod.__name__
    else:
        self.name = "&lt;unknown&gt;"
    self.mod = mod
</t>
<t tx="ekr.20040227065519.57">def getattr(self, name):
    try:
        attr = getattr(self.mod, name)
    except:
        return None
    return wrapJava(attr)
</t>
<t tx="ekr.20040227065519.58">def addEvents(self, attrs, events):
    pass
</t>
<t tx="ekr.20040227065519.59">def getDepends(self):
    if not hasattr(self.mod, '__depends__'):
        return []
    return map(lookupName, self.mod.__depends__)
</t>
<t tx="ekr.20040227065519.60">


from util import reportPublicPlainClasses
class Package(Namespace):
	&lt;&lt; class Package declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040227065519.61">_classes = {}
</t>
<t tx="ekr.20040227065519.62">def __init__(self, mod, *args):
    apply(Namespace.__init__, (self, mod)+args)
    if isinstance(mod, PyJavaPackage):
##            classes = PyJavaPackage._unparsedAll._doget(self.mod)
        classes = reportPublicPlainClasses(self.mod)
        if classes:
            self._classes[self.name] = classes
</t>
<t tx="ekr.20040227065519.63">def getClasses(self):
    return self._classes.get(self.name, None)
</t>
<t tx="ekr.20040227065519.64">


class Class(Namespace):
	&lt;&lt; class Class declarations &gt;&gt;
</t>
<t tx="ekr.20040227065519.65">pass


</t>
<t tx="ekr.20040227065519.66">
class Module(Namespace):
	@others
</t>
<t tx="ekr.20040227065519.67">def __init__(self, mod=None, name=None, file=None, path=None):
    Namespace.__init__(self, mod)
    if file is None and hasattr(mod, '__file__'):
        file = mod.__file__
    if name is not None:
        self.name = name
    self.file = file
    if name is None and hasattr(mod, '__path__'):
        path = mod.__path__
    self.path = path
</t>
<t tx="ekr.20040227065519.68">def getattr(self, name):
    ret = None
    if self.path is not None:
        ret = findOnPath(name, self.path)
    if ret is not None:
        ret.name = self.name+'.'+ret.name
        return ret
    if self.mod is None:
        self.mod = lookup(self.name)
    return Namespace.getattr(self, name)
</t>
<t tx="ekr.20040227065519.69">def __repr__(self):
    return "Module(%s, %s, %s)" % (self.name, self.file, self.path)
</t>
<t tx="ekr.20040227065519.70">

class JavaClass(Namespace):
	@others
</t>
<t tx="ekr.20040227065519.71">def __init__(self, mod):
    Namespace.__init__(self, mod)   
    self.file = None
    self.bases = self.findBases(mod)
    self.eventProperties = self.findEventProperties(mod)
</t>
<t tx="ekr.20040227065519.72">def __repr__(self):
    return "JavaClass(%s)" % (self.name,)
</t>
<t tx="ekr.20040227065519.73">def findBases(self, c):
    bases = []
    for base in c.__bases__:
        bases.append(JavaClass(base))
    return bases
</t>
<t tx="ekr.20040227065519.74">def findEventProperties(self, c):
    eps = {}
    for name, value in c.__dict__.items():
        if isinstance(value, PyBeanEventProperty):
            eps[name] = value.eventClass
    return eps
</t>
<t tx="ekr.20040227065519.75">def addEvents(self, attrs, events, source=None):
    for name, value in self.eventProperties.items():
        if attrs.has_key(name):
            try:
                events[value][source] = 1
            except KeyError:
                d = {source:1}
                events[value] = d
    for base in self.bases:
        base.addEvents(attrs, events, source)
</t>
<t tx="ekr.20040227065519.76">@ignore
@language python
&lt;&lt; JavaCall declarations &gt;&gt;
@others

    one = Object(jast.IntegerConstant(1), [java.lang.Integer.TYPE], 
                 [(org.python.core.PyObject, jast.Identifier("one"))])
    foo = Object(jast.Identifier("foo"), [org.python.core.PyObject],
                 [(java.lang.Integer.TYPE,
                   jast.InvokeStatic("Py", "toint",
                                     [jast.Identifier("foo")]))])

    print f.invoke(foo, [one])
    print f.invoke(foo, [foo])

    print call(org.python.core.Py.py2int, [one])
</t>
<t tx="ekr.20040227065519.77"># Copyright (c) Corporation for National Research Initiatives

import java, org.python.core
import jast



funcs = {}
</t>
<t tx="ekr.20040227065519.78">def call(func, this, args=None):
    if not funcs.has_key(func):
        jf = JavaFunction(func)
        funcs[func] = jf
    else:
        jf = funcs[func]
    if args is None:
        return jf.call(this)
    else:
        return jf.invoke(this, args)
</t>
<t tx="ekr.20040227065519.79">


class Signature:
	@others
</t>
<t tx="ekr.20040227065519.80">def __init__(self, name, inTypes, retType, isStatic=0, isPyArgs=0,
             isConstructor=0):
    self.isPyArgs = isPyArgs
    self.isStatic = isStatic
    self.retType = retType
    self.inTypes = inTypes
    self.name = name
    self.isConstructor = isConstructor
</t>
<t tx="ekr.20040227065519.81">def handle(self, callee, args, isa=1):
##      if self.isPyArgs:
##          pyargs = []
##          for arg in args:
##              pyargs.append(arg.asa(AnyType).getCode())
##          return self.mkcall(callee, [Statement.PyObjectArray(pyargs)] )

    if len(args) != len(self.inTypes):
        return None

    callargs = []
    for i in range(len(args)):
        #print i, args[i]
        if isa:
            callarg = args[i].isa(self.inTypes[i])
        else:
            callarg = args[i].asa(self.inTypes[i])
        if callarg == None:
            return None
        callargs.append(callarg)
    return self.mkcall(callee, callargs)
</t>
<t tx="ekr.20040227065519.82">def mkcall(self, callee, args):
    if self.isConstructor:
        op = jast.New(self.name, args)
    elif self.isStatic:
        op = jast.InvokeStatic(callee, self.name, args)
    else:
        #print callee, self.name, args
        op = jast.Invoke(callee, self.name, args)
    return op, self.retType
</t>
<t tx="ekr.20040227065519.83">def __repr__(self):
    r = []
    for arg in self.inTypes:
        r.append(arg.name)
    COMMASPACE = ', '
    return '(%s)-&gt;%s' % (COMMASPACE.join(r), self.retType.name)
</t>
<t tx="ekr.20040227065519.84">


class JavaFunction:
	@others
</t>
<t tx="ekr.20040227065519.85">def __init__(self, reflectedFunction):
    self.name = reflectedFunction.__name__
    self.isConstructor = isinstance(reflectedFunction,
                                    org.python.core.PyReflectedConstructor)
    sigs = []
    self.callee = None
    for i in range(reflectedFunction.nargs):
        sigs.append(self.makeSignature(reflectedFunction.argslist[i]))
    self.sigs = sigs
    self.function = reflectedFunction
    self.declaringClass = self.function.argslist[0].declaringClass
</t>
<t tx="ekr.20040227065519.86">def makeSignature(self, rargs):
    inTypes = list(rargs.args)
    isPyArgs = rargs.flags == rargs.PyArgsCall
    isStatic = rargs.isStatic
    name = rargs.data.name

    if self.isConstructor:
        outType = rargs.data.declaringClass                 
    else:
        outType = rargs.data.returnType

    if isStatic:
        self.callee = rargs.data.declaringClass.__name__

    return Signature(name, inTypes, outType, isStatic, isPyArgs,
                     self.isConstructor)
</t>
<t tx="ekr.20040227065519.87">def __repr__(self):
    if len(self.sigs) == 1:
        return self.name+repr(self.sigs[0])
    else:
        return self.name+repr(self.sigs)
</t>
<t tx="ekr.20040227065519.88">def call(self, args):
    for isa in [1, 0]:
        for sig in self.sigs:
            ret = sig.handle(self.callee, args, isa=isa)
            if ret is None:
                continue
            return ret
    raise TypeError, repr(args)+' args do not match: '+repr(self)
</t>
<t tx="ekr.20040227065519.89">def invoke(self, this, args):
    this = this.asa(self.declaringClass)
    for isa in [1, 0]:
        for sig in self.sigs:
            ret = sig.handle(this, args, isa=isa)
            if ret is None:
                continue
            return ret
    raise TypeError, repr(args)+' args do not match: '+repr(self)
</t>
<t tx="ekr.20040227065519.90">


if __name__ == '__main__':
    f = JavaFunction(org.python.core.PyObject._add)
    print f

    class Object:
	@others
</t>
<t tx="ekr.20040227065519.91">def __init__(self, code, istypes, astypes):
    self.code = code
    self.istypes = istypes
    self.astypes = astypes
</t>
<t tx="ekr.20040227065519.92">def isa(self, type):
    if type in self.istypes:
        return self.code
</t>
<t tx="ekr.20040227065519.93">def asa(self, type):
    if type in self.istypes:
        return self.code

    for astype, ascode in self.astypes:
        if astype == type:
            return ascode
</t>
<t tx="ekr.20040227065519.94">@ignore
@language python
&lt;&lt; Object declarations &gt;&gt;
@others



Generic = findType(org.python.core.PyObject)
IntType = findType(java.lang.Integer.TYPE)
StringType = findType(java.lang.String)



if __name__ == '__main__':
    foo = Object(jast.Identifier("foo"), Generic)
    one = Object(jast.IntegerConstant(1), IntType)
    hello = Object(jast.StringConstant("hello"), StringType)

    print foo, one, hello
    print foo.binop("add", foo)
    print foo.binop("add", one)
    print foo.binop("add", hello)
    print foo.nonzero()
    print foo.getitem(foo)
    print foo.getitem(one)
    print foo.call([one, hello])
    print foo.call([one, hello, foo])
</t>
<t tx="ekr.20040227065519.95"># Copyright (c) Corporation for National Research Initiatives
import jast
import org, java



</t>
<t tx="ekr.20040227065519.96">def makeAnys(args):
    ret = []
    for arg in args:
        ret.append(arg.asAny())
    return ret
</t>
<t tx="ekr.20040227065519.97">
def PyObjectArray(args):
    aargs = makeAnys(args)
    return Object(
        jast.FilledArray("PyObject", aargs),
        findType(java.lang.Class.forName("[Lorg.python.core.PyObject;")))
</t>
<t tx="ekr.20040227065519.98">def makeStringArray(args):
    return Object(
        jast.StringArray(args),
        findType(java.lang.Class.forName("[Ljava.lang.String;")))
</t>
<t tx="ekr.20040227065519.99">


class DelegateMethod:
	@others
</t>
<t tx="ekr.20040227065519.100">def __init__(self, method, code):
    self.method = method
    self.code = code
</t>
<t tx="ekr.20040227065519.101">def __call__(self, *args):
    return apply(self.method, (self.code, )+args)
</t>
<t tx="ekr.20040227065519.102">

class Object:
	@others
</t>
<t tx="ekr.20040227065519.103">def __init__(self, code, value):
    self.code = code
    self.value = value
</t>
<t tx="ekr.20040227065519.104">def asAny(self):
    return self.asa(org.python.core.PyObject)
</t>
<t tx="ekr.20040227065519.105">def makeReference(self, code):
    return Object(code, self.value)
</t>
<t tx="ekr.20040227065519.106">def makeStatement(self):
    return self.value.getStatement(self.code)
</t>
<t tx="ekr.20040227065519.107">def mergeWith(self, other):
    return Object(jast.Comment("oops"), Generic)
</t>
<t tx="ekr.20040227065519.108">def __repr__(self):
    return "Object(%s, %s)" % (self.code, self.value.__class__.__name__)
</t>
<t tx="ekr.20040227065519.109"># delegate most methods to self.value using DelegateMethod
def __getattr__(self, name):
    return DelegateMethod(getattr(self.value, name), self.code)
</t>
<t tx="ekr.20040227065519.110">

primitives = {java.lang.Integer.TYPE  : 'py2int',
              java.lang.Character.TYPE: 'py2char',
              }

import JavaCall



class JavaObject:
	@others
</t>
<t tx="ekr.20040227065519.111">def __init__(self, javaclass):
    self.javaclass = javaclass
</t>
<t tx="ekr.20040227065519.112">def isa(self, code, type):
    if type.isAssignableFrom(self.javaclass):
        return code
</t>
<t tx="ekr.20040227065519.113">def asa(self, code, type, message=None):
    ret = self.isa(code, type)
    if ret is not None:
        return ret

    if type == org.python.core.PyObject:
        return self.asAny(code)
</t>
<t tx="ekr.20040227065519.114">def asAny(self, code):
    return jast.InvokeStatic('Py', 'java2py', [code])
</t>
<t tx="ekr.20040227065519.115">def getStatement(self, code):
    return code
</t>
<t tx="ekr.20040227065519.116">


class JavaInteger(JavaObject):
	@others
</t>
<t tx="ekr.20040227065519.117">def __init__(self):
    JavaObject.__init__(self, java.lang.Integer.TYPE)
</t>
<t tx="ekr.20040227065519.118">def asAny(self, code):
    return jast.InvokeStatic('Py', 'newInteger', [code])
</t>
<t tx="ekr.20040227065519.119">


class JavaString(JavaObject):
	@others
</t>
<t tx="ekr.20040227065519.120">def __init__(self):
    JavaObject.__init__(self, java.lang.String)
</t>
<t tx="ekr.20040227065519.121">def asAny(self, code):
    return jast.InvokeStatic('Py', 'newString', [code])
</t>
<t tx="ekr.20040227065519.122">


class PyObject:
	&lt;&lt; class PyObject declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040227065519.123">#I hate static fields for dynamic info!
attributes = {}
</t>
<t tx="ekr.20040227065519.124">def getStatement(self, code):
    return code
</t>
<t tx="ekr.20040227065519.125">def asAny(self, code):
    return code
</t>
<t tx="ekr.20040227065519.126">def isa(self, code, type):
    if type == org.python.core.PyObject:
        return code
</t>
<t tx="ekr.20040227065519.127">def asa(self, code, type, message=None):
    ret = self.isa(code, type)
    if ret is not None:
        return ret

    if primitives.has_key(type):
        return jast.InvokeStatic('Py', primitives[type], [code])
    if type == java.lang.Boolean.TYPE:
        return jast.Invoke(code, '__nonzero__', [])

    tname = type.__name__
    tojava = jast.InvokeStatic('Py', 'tojava',
                               [code, jast.GetStaticAttribute(tname,'class')])
    return jast.Cast(tname, tojava)
</t>
<t tx="ekr.20040227065519.128">def print_line(self, code):
    return jast.InvokeStatic("Py", "println", [self.asAny(code)])
</t>
<t tx="ekr.20040227065519.129">def print_continued(self, code):
    return jast.InvokeStatic("Py", "printComma", [self.asAny(code)])
</t>
<t tx="ekr.20040227065519.130">def print_line_to(self, file, code=None):
    if code is None:
        return jast.InvokeStatic("Py", "printlnv", [self.asAny(file)])
    else:
        return jast.InvokeStatic("Py", "println", [self.asAny(file),
                                                   self.asAny(code)])
</t>
<t tx="ekr.20040227065519.131">def print_continued_to(self, file, code):
    return jast.InvokeStatic("Py", "printComma", [self.asAny(file),
                                                  self.asAny(code)])
</t>
<t tx="ekr.20040227065519.132">def domethod(self, code, name, *args):
    meth = getattr(org.python.core.PyObject, name)
    code, type = JavaCall.call(meth, Object(code, self), args)
    return Object(code, findType(type))
</t>
<t tx="ekr.20040227065519.133">def nonzero(self, code):
    return self.domethod(code, "__nonzero__").asa(java.lang.Boolean.TYPE)
</t>
<t tx="ekr.20040227065519.134">def unop(self, code, op):
    return self.domethod(code, '__'+op+'__')
</t>
<t tx="ekr.20040227065519.135">def compop(self, code, op, y):
    return self.domethod(code, "_"+op, y)
</t>
<t tx="ekr.20040227065519.136">binop = compop

def aug_binop(self, code, op, y):
    return self.domethod(code, op, y)
</t>
<t tx="ekr.20040227065519.137">def igetitem(self, code, index):
    return self.domethod(code, "__getitem__",
                         Object(jast.IntegerConstant(index), IntType))
</t>
<t tx="ekr.20040227065519.138">def getslice(self, code, start, stop, step):
    #print start, stop, step
    return self.domethod(code, "__getslice__", start, stop, step)   
</t>
<t tx="ekr.20040227065519.139">def delslice(self, code, start, stop, step):
    return self.domethod(code, "__delslice__",
                         start, stop, step).getStatement()
</t>
<t tx="ekr.20040227065519.140">def setslice(self, code, start, stop, step, value):
    return self.domethod(code, "__setslice__",
                         start, stop, step, value).getStatement()
</t>
<t tx="ekr.20040227065519.141">def getitem(self, code, index):
    return self.domethod(code, "__getitem__", index)
</t>
<t tx="ekr.20040227065519.142">def delitem(self, code, index):
    return self.domethod(code, "__delitem__", index).getStatement()
</t>
<t tx="ekr.20040227065519.143">def setitem(self, code, index, value):
    return self.domethod(code, "__setitem__", index, value).getStatement()
</t>
<t tx="ekr.20040227065519.144">def getattr(self, code, name):
    if not PyObject.attributes.has_key(name):
        PyObject.attributes[name] = None
    name = Object(jast.StringConstant(name), StringType)
    return self.domethod(code, "__getattr__", name)
</t>
<t tx="ekr.20040227065519.145">def delattr(self, code, name):
    name = Object(jast.StringConstant(name), StringType)
    return self.domethod(code, "__delattr__", name).getStatement()
</t>
<t tx="ekr.20040227065519.146">def setattr(self, code, name, value):
    PyObject.attributes[name] = value
    name = Object(jast.StringConstant(name), StringType)
    ret = self.domethod(code, "__setattr__", name, value)
    #print ret      
    return ret.getStatement()
</t>
<t tx="ekr.20040227065519.147">def call(self, code, args, keyargs=None):
    nargs = len(args)
    if keyargs is None or len(keyargs) == 0:
        if nargs == 0:
            return self.domethod(code, "__call__")
        elif nargs == 1:
            return self.domethod(code, "__call__", args[0])
        elif nargs == 2:
            return self.domethod(code, "__call__", args[0], args[1])
        elif nargs == 3:
            return self.domethod(code, "__call__",
                                 args[0], args[1], args[2])
        else:
            return self.domethod(code, "__call__", PyObjectArray(args))
    else:
        keynames = []
        for name, value in keyargs:
            PyObject.attributes[name] = value
            keynames.append(name)
            args.append(value)

        return self.domethod(code, "__call__", PyObjectArray(args),
                             makeStringArray(keynames))
</t>
<t tx="ekr.20040227065519.148">def call_extra(self, code, args, keyargs, starargs, kwargs):
    keynames = []
    for name, value in keyargs:
        PyObject.attributes[name] = value
        keynames.append(name)
        args.append(value)

    if not starargs:
        starargs = Object(jast.Null, self)
    if not kwargs:
        kwargs = Object(jast.Null, self)

    return self.domethod(code, "_callextra",
                         PyObjectArray(args),
                         makeStringArray(keynames),
                         starargs,
                         kwargs)
</t>
<t tx="ekr.20040227065519.149">def invoke(self, code, name, args, keyargs):
    if keyargs:
        return self.getattr(code, name).call(args, keyargs)

    name = Object(jast.StringConstant(name), StringType)
    nargs = len(args)
    if nargs == 0:
        return self.domethod(code, "invoke", name)
    elif nargs == 1:
        return self.domethod(code, "invoke", name, args[0])
    elif nargs == 2:
        return self.domethod(code, "invoke", name, args[0], args[1])
    else:
        return self.domethod(code, "invoke", name, PyObjectArray(args))
</t>
<t tx="ekr.20040227065519.150">def doraise(self, code, exc_value=None, exc_traceback=None):
    args = [code]
    if exc_value is not None:
        args.append(exc_value.asAny())
    if exc_traceback is not None:
        args.append(exc_traceback.asAny())
    return jast.Throw(jast.InvokeStatic("Py", "makeException", args))
</t>
<t tx="ekr.20040227065519.151">def mergeWith(self, other):
    # In simplest world, all types can be merged with each other
    return self
</t>
<t tx="ekr.20040227065519.152">def makeTemp(self, frame):
    return PyObject(jast.Set(frame.gettemp(self.type),
                             self.asAny()), self.parent)
</t>
<t tx="ekr.20040227065519.153">def freeTemp(self, frame):
    frame.freetemp(self.value)
</t>
<t tx="ekr.20040227065519.154">
types = {}
def findType(type):
    if types.has_key(type):
        return types[type]

    if type == java.lang.Integer.TYPE:
        ret = JavaInteger()
    elif type == java.lang.String:
        ret = JavaString()
    elif type == org.python.core.PyObject:
        ret = PyObject()
    elif type == org.python.core.PyString:
        ret = PyObject()
    else:
        ret = JavaObject(type)

    types[type] = ret
    return ret
</t>
<t tx="ekr.20040227065519.155">@ignore
@language python
&lt;&lt; ObjectFactory declarations &gt;&gt;
@others



data = """
x=1+1
#import pawt
#print pawt.test

for i in [1,2,3]:
    print i

def bar(x):
    print x*10
    y = x+2
    print y

bar(42)

class Baz:
    def eggs(self, x, y, z):
        return x, y, z

b = Baz()
print b.eggs(1,2,3)
"""

if __name__ == '__main__':
    mod = SimpleCompiler.BasicModule("foo")
    fact = ObjectFactory()
    pi = SimpleCompiler.SimpleCompiler(mod, fact)
    fact.parent = pi
    code = jast.Block(pi.execstring(data))
    mod.addMain(code, pi)

    print mod.attributes.keys()
    print mod.imports.keys()
    print mod
    mod.dump("c:\\jpython\\tools\\jpythonc2\\test")
</t>
<t tx="ekr.20040227065519.156"># Copyright (c) Corporation for National Research Initiatives
import jast
import org, java
from Object import Object, PyObject, Generic



</t>
<t tx="ekr.20040227065519.157">def makeAnys(args):
    ret = []
    for arg in args:
        ret.append(arg.asAny())
    return ret
</t>
<t tx="ekr.20040227065519.158">
def PyObjectArray(args):
    aargs = makeAnys(args)
    return jast.FilledArray("PyObject", aargs)
</t>
<t tx="ekr.20040227065519.159">
import SimpleCompiler



class ObjectFactory:
	@others
</t>
<t tx="ekr.20040227065519.160">def __init__(self, parent=None):
    self.parent = parent
</t>
<t tx="ekr.20040227065519.161">#makeModule????

def importName(self, name):
    ns = PyNamespace(self.parent, name)
    return Object(ns.getNew(), ns)
</t>
<t tx="ekr.20040227065519.162">def makeFunction(self, name, def_compiler, scope, body, doc=None):
    func = PyFunction(self, name, def_compiler, scope, body, doc)
    return Object(func.getNew(), func)
</t>
<t tx="ekr.20040227065519.163">def makeClass(self, name, bases, def_compiler, scope, body, doc=None):
    cls =  PyClass(self, name, bases, def_compiler, scope, body, doc)
    # Yuck! We can't call getNew() before all modules have been analyzed.
    class DelayGen:
        def __init__(self, cls):
            self.cls = cls
            self.cls.makeCode()
        def sourceString(self):
            return self.cls.getNew().sourceString()
    return Object(DelayGen(cls), cls)
</t>
<t tx="ekr.20040227065519.164">def makeList(self, items):
    code = jast.New("PyList", [PyObjectArray(items)])
    return Object(code, Generic)
</t>
<t tx="ekr.20040227065519.165">def makeTuple(self, items):
    code = jast.New("PyTuple", [PyObjectArray(items)])
    return Object(code, Generic)
</t>
<t tx="ekr.20040227065519.166">def makeDictionary(self, items):
    lst = []
    for key, value in items:
        lst.append(key); lst.append(value)
    code = jast.New("PyDictionary", [PyObjectArray(lst)])
    return Object(code, Generic)
</t>
<t tx="ekr.20040227065519.167">def makeInteger(self, value):
    return Object(self.parent.module.getIntegerConstant(value),
                  PyConstant(value)) 
</t>
<t tx="ekr.20040227065519.168">def makeLong(self, value):
    return Object(self.parent.module.getLongConstant(value),
                  PyConstant(value)) 
</t>
<t tx="ekr.20040227065519.169">def makeImaginary(self, value):
    return Object(self.parent.module.getImaginaryConstant(value),
                  PyConstant(value)) 
</t>
<t tx="ekr.20040227065519.170">def makeFloat(self, value):
    return Object(self.parent.module.getFloatConstant(value),
                  PyConstant(value)) 
</t>
<t tx="ekr.20040227065519.171">def makeString(self, value):
    return Object(self.parent.module.getStringConstant(value),
                  PyConstant(value)) 
</t>
<t tx="ekr.20040227065519.172">def makeEllipsis(self):
    code = jast.GetStaticAttribute("Py", "Ellipsis")
    return Object(code, Generic)
</t>
<t tx="ekr.20040227065519.173">def makeJavaInteger(self, code):
    return Object(code, IntValue)
</t>
<t tx="ekr.20040227065519.174">def makeJavaString(self, code):
    return Object(code, StringValue)
</t>
<t tx="ekr.20040227065519.175">def makeObject(self, code, value):
    return Object(code, value)
</t>
<t tx="ekr.20040227065519.176">def makePyObject(self, code):
    return Object(code, Generic)
</t>
<t tx="ekr.20040227065519.177">def makeNull(self):
    return Object(jast.Null, Generic)
</t>
<t tx="ekr.20040227065519.178">def makeSlice(self, items):
    code = jast.New("PySlice", 
        [items[0].asAny(), items[1].asAny(), items[2].asAny()])
    return Object(code, Generic)
</t>
<t tx="ekr.20040227065519.179">def getCompiler(self, parent_compiler, frameCtr, scope, className):
    return SimpleCompiler.SimpleCompiler(self.parent.module, self,
                                         parent = parent_compiler,
                                         frameCtr = frameCtr,
                                         scope = scope,
                                         options = self.parent.options,
                                         className = className)
</t>
<t tx="ekr.20040227065519.180">

class FixedObject(PyObject):
	&lt;&lt; class FixedObject declarations &gt;&gt;
</t>
<t tx="ekr.20040227065519.181">pass


</t>
<t tx="ekr.20040227065519.182">
class PyConstant(FixedObject):
	@others
</t>
<t tx="ekr.20040227065519.183">def __init__(self, value):
    self.value = value
</t>
<t tx="ekr.20040227065519.184">def getStatement(self, code=None):
    return jast.Comment(str(self.value))
</t>
<t tx="ekr.20040227065519.185">


class PyFunction(FixedObject):
	@others
</t>
<t tx="ekr.20040227065519.186">def __init__(self, factory, name, def_compiler,scope, body, doc=None):
    self.name = name
    self.factory = factory
    self.def_compiler = def_compiler
    self.scope = scope
    self.body = body
    self.doc = doc
</t>
<t tx="ekr.20040227065519.187">def getNew(self):
    globals = jast.GetInstanceAttribute(self.def_compiler.frame.frame,
                                        "f_globals")
    pycode = self.makeCode()
    defaults = [ d.visit(self.def_compiler.visitor) for d in self.scope.ac.defaults ]
    clos = self.def_compiler.frame.makeClosure(self.scope)
    ctrargs = [globals, PyObjectArray(defaults), pycode]
    if clos:
        ctrargs.append(PyObjectArray(clos))
    return jast.New("PyFunction", ctrargs)
</t>
<t tx="ekr.20040227065519.188">def makeCode(self): # now handles a,b style args too
    # Add args to funcframe
    ac = self.scope.ac
    # Parse the body
    comp = self.factory.getCompiler(self.def_compiler,SimpleCompiler.FunctionFrame,self.scope, self.def_compiler.className)
    for argname in ac.names:
        comp.frame.setname(argname, self.factory.makePyObject(None))

    tree = self.body
    if ac.init_code.numChildren &gt; 0:
        ac.init_code.jjtAddChild(tree, ac.init_code.numChildren)
        tree = ac.init_code
    code = jast.Block([comp.parse(tree)])
    # Set up a code object
    self.pycode = self.def_compiler.top_compiler.module.getCodeConstant(
        self.name, code, comp.frame)
    self.frame = comp.frame
    return self.pycode
</t>
<t tx="ekr.20040227065519.189">


class PyClass(FixedObject):
	@others
</t>
<t tx="ekr.20040227065519.190">def __init__(self, factory, name, bases, def_compiler, scope, body, doc=None):
    self.name = name
    self.factory = factory
    self.bases = bases
    self.def_compiler = def_compiler
    self.scope = scope
    self.body = body
    self.doc = doc
</t>
<t tx="ekr.20040227065519.191">def getNew(self):
    args = [jast.StringConstant(self.name),
            PyObjectArray(self.bases), self.pycode,
            jast.Null]

    if self.isSuperclassJava():
        args.append(jast.Identifier("%s.class" % self.proxyname))

    clos = self.def_compiler.frame.makeClosure(self.scope)
    if clos:
        args.append(PyObjectArray(clos))

    return jast.InvokeStatic("Py", "makeClass", args)
</t>
<t tx="ekr.20040227065519.192"># proper logic for retrieving superproxy name
def _takeSupername(self,cls,mod,modname = None):
    if modname is None:
        modname = ""
        if mod.package: modname = mod.package+'.'
        modname += mod.name
    self.javaclasses.extend(cls.javaclasses)
    self.proxyname = self.name
    self.supername = None
    self.issuperproxy = 1
    full_py = modname + '.' + cls.name
    if cls.name != mod.name:
        self.pySupername = self.supername = full_py
    else:
        self.pySupername = full_py
        self.supername = modname
</t>
<t tx="ekr.20040227065519.193">def isSuperclassJava(self):
    if hasattr(self, 'javaclasses'):
        return len(self.javaclasses)

    self.javaclasses = []
    self.proxyname = None
    self.supername = None
    self.pySupername = None
    self.issuperproxy = 0
    import compile
    for base in self.bases:
        if hasattr(base, "javaclass"):
            self.javaclasses.append(base.javaclass)
            self.proxyname = self.name
            self.supername = base.javaclass.__name__
            continue
        base = base.value
        if hasattr(base, "name"):
            jc = compile.getJavaClass(base.name)
            if jc is None:
                idx = base.name.rfind('.')
                if idx &gt; 0:
                    #crude support for innerclasses.
                    name = base.name[:idx] + '$' + base.name[idx+1:]
                    jc = compile.getJavaClass(name)
            if jc is not None:
                self.javaclasses.append(jc)
                self.proxyname = self.name
                if not jc.isInterface():
                    self.supername = jc.__name__
                continue
        if isinstance(base, PyClass):
            if base.isSuperclassJava():
                self._takeSupername(base,base.def_compiler.module)
                continue
        if isinstance(base, PyNamespace):
            names = base.name.split('.')
            if len(names) &gt;= 2:
                modname = '.'.join(names[:-1])
                mod = compile.Compiler.allmodules.get(modname, None)
                if mod:
                    cls = mod.classes.get(names[-1], None)
                    if cls:
                        if cls.value.isSuperclassJava():
                            # pass no modname but just mod,
                            # javapackage should be included
                            self._takeSupername(cls.value,mod)
                            continue

    if len(self.javaclasses) and self.supername == None:
        self.supername = "java.lang.Object"
        self.proxyname = self.name
    return self.supername != None
</t>
<t tx="ekr.20040227065519.194">def makeCode(self):
    comp = self.factory.getCompiler(self.def_compiler,
                                    SimpleCompiler.ClassFrame, self.scope,
                                    self.name)
    code = jast.Block([comp.parse(self.body),
                       jast.Return(jast.Invoke(comp.frame.frame,
                                               "getf_locals", []))])
    self.frame = comp.frame
    self.pycode = self.def_compiler.top_compiler.module.getCodeConstant(
        self.name, code, comp.frame)
    return self.pycode
</t>
<t tx="ekr.20040227065519.195">
class PyNamespace(FixedObject):
	@others
</t>
<t tx="ekr.20040227065519.196">def __init__(self, parent, name):
    self.name = name
    self.parent = parent
    self.parent.addModule(name)
</t>
<t tx="ekr.20040227065519.197">def getNew(self):
    return jast.InvokeStatic("imp", "load",
                             [jast.StringConstant(self.name)])
</t>
<t tx="ekr.20040227065519.198">def getattr(self, code, name):
    newobj = FixedObject.getattr(self, code, name)
    newobj.value = PyNamespace(self.parent, self.name+'.'+name)
    return newobj
</t>
<t tx="ekr.20040227065519.199">#Use the base definition of invoke so that getattr will be properly handled
def invoke(self, code, name, args, keyargs):
    return self.getattr(code, name).call(args, keyargs)
</t>
<t tx="ekr.20040227065519.200">@ignore
@language python
&lt;&lt; PathVFS declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040227065519.201"># Copyright 2000 Samuele Pedroni
import sys

from java import io
from java.util import zip


</t>
<t tx="ekr.20040227065519.202">class JarVFS:
	@others
</t>
<t tx="ekr.20040227065519.203">def __init__(self,fname):
    self.zipfile = zip.ZipFile(fname)
</t>
<t tx="ekr.20040227065519.204">def open(self,id):
    ent = self.zipfile.getEntry(id)
    if ent:
##            print "path-jar-open: %s!%s" % (self.zipfile.name,id) # ?? dbg
        return self.zipfile.getInputStream(ent)
    else:
        return None
</t>
<t tx="ekr.20040227065519.205">def __repr__(self):
    return "&lt;jar-vfs '%s'&gt;" % self.zipfile.name
</t>
<t tx="ekr.20040227065519.206">        
class DirVFS:
	@others
</t>
<t tx="ekr.20040227065519.207">def __init__(self,dir):
    if dir == '':
        self.pfx = None
    else:
        self.pfx = dir
</t>
<t tx="ekr.20040227065519.208">def open(self,id):
    f = io.File(self.pfx, id.replace('/',io.File.separator))
    if f.file:
##            print "path-open:",f # ?? dbg
        return io.BufferedInputStream(io.FileInputStream(f))
    return None
</t>
<t tx="ekr.20040227065519.209">def __repr__(self):
    return "&lt;dir-vfs '%s'&gt;" % self.pfx
</t>
<t tx="ekr.20040227065519.210">
class PathVFS:
	@others
</t>
<t tx="ekr.20040227065519.211">def add_vfs(self,fname):
    if fname == '':
        if not self.once.has_key(''):
            self.once['']=1
            self.vfs.append(DirVFS(''));
        return        
    file=io.File(fname);
    canon = file.canonicalPath
    if not self.once.has_key(canon):
        self.once[canon]=1
        try:
            if file.directory:
                self.vfs.append(DirVFS(fname));
            else:
                if file.exists and (fname.endswith('.jar') or fname.endswith('.zip')):
                    self.vfs.append(JarVFS(fname))
        except:
            pass
</t>
<t tx="ekr.20040227065519.212">def __init__(self,registry):
    self.once = {}
    self.vfs = []
    paths = registry.getProperty("python.packages.paths","java.class.path")
    paths = paths.split(',')
    # opt
    if "sun.boot.class.path" in paths: # ??pending strip boot class paths of other jvms?
        paths.remove("sun.boot.class.path")

    #paths.append("python.packages.fakepath")

    for p in paths:
        e = registry.getProperty(p)
        if e != None:
            path = e.split(io.File.pathSeparator)
            for name in path:
                self.add_vfs(name)

    for name in sys.path:
        self.add_vfs(name)
        
    del self.once
</t>
<t tx="ekr.20040227065519.213">def open(self,id):
    for v in self.vfs:
        stream = v.open(id)
        if stream:
            return stream
    return None
</t>
<t tx="ekr.20040227065519.214">@ignore
@language python
&lt;&lt; PythonInterpreter declarations &gt;&gt;
@others



true = PyObject(1);
false = PyObject(0)



data = """
print 2, 2+2
print 1&lt;2
print 1&lt;2&lt;3
print 3&lt;2
print 1&lt;3&lt;2

print 2*8-9, 6/3
x = 99
print x
y = x+9
print x, y
print 'testing 1, 2, 3'

if 1:
    print 'true'
else:
    print 'false'

i = 0
while i &lt; 5:
    print i
    i = i+1

while i &lt; 10:
    print i
    i = i+1
    if i == 8: break

print len
print [1,2,3]
print len([1,2,3])

import string
print string.join(["a", "b"])

from string import split
print split, split("a b c d e")

"""

pi = PythonInterpreter()
pi.execstring(data)
</t>
<t tx="ekr.20040227065519.215"># Copyright (c) Corporation for National Research Initiatives

import operator
import org
from BaseEvaluator import BaseEvaluator



</t>
<t tx="ekr.20040227065519.216">class FlowControlException(Exception):
	&lt;&lt; class FlowControlException declarations &gt;&gt;
</t>
<t tx="ekr.20040227065519.217">pass

</t>
<t tx="ekr.20040227065519.218">class DoBreak(FlowControlException):
	&lt;&lt; class DoBreak declarations &gt;&gt;
</t>
<t tx="ekr.20040227065519.219">pass

</t>
<t tx="ekr.20040227065519.220">class DoContinue(FlowControlException):
	&lt;&lt; class DoContinue declarations &gt;&gt;
</t>
<t tx="ekr.20040227065519.221">pass

</t>
<t tx="ekr.20040227065519.222">class DoReturn(FlowControlException):
	&lt;&lt; class DoReturn declarations &gt;&gt;
</t>
<t tx="ekr.20040227065519.223">pass


</t>
<t tx="ekr.20040227065519.224">
class PythonInterpreter(BaseEvaluator):
	@others
</t>
<t tx="ekr.20040227065519.225">def __init__(self):
    BaseEvaluator.__init__(self)
    self.locals = {}
    self.globals = {}
    self.builtins = makeBuiltins()
</t>
<t tx="ekr.20040227065519.226">#primitive values
def int_const(self, value):
    return PyInteger(value)
</t>
<t tx="ekr.20040227065519.227">def float_const(self, value):
    return PyFloat(value)
</t>
<t tx="ekr.20040227065519.228">def string_const(self, value):
    return PyString(value)
</t>
<t tx="ekr.20040227065519.229"># builtin types
def list_op(self, values):
    ret = []
    for value in values:
        ret.append(self.visit(value).value)
    return PyObject(ret)
</t>
<t tx="ekr.20040227065519.230">def tuple_op(self, values):
    lst = self.list_op(values)
    return PyObject(tuple(lst.value))
</t>
<t tx="ekr.20040227065519.231">def dictionary_op(self, items):
    dict = {}
    for key, value in items:
        dict[self.visit(key).value] = self.visit(value).value
</t>
<t tx="ekr.20040227065519.232">#namespaces
def set_name(self, name, value):
    if self.globalnames.has_key(name):
        self.globals[name] = value
    else:
        #print 'setlocal', name, value
        self.locals[name] = value
</t>
<t tx="ekr.20040227065519.233">def name_const(self, name):
    #print 'get', self.locals
    if self.locals.has_key(name):
        return self.locals[name]
    elif self.globals.has_key(name):
        return self.globals[name]
    else:
        return self.builtins[name]
</t>
<t tx="ekr.20040227065519.234">def get_module(self, name):
    top = __import__(name[0])
    for part in name[1:]:
        top = getattr(top, part)
    return PyObject(top)
</t>
<t tx="ekr.20040227065519.235">#flow control
def pass_stmt(self):
    pass
</t>
<t tx="ekr.20040227065519.236">def continue_stmt(self):
    raise DoContinue
</t>
<t tx="ekr.20040227065519.237">def break_stmt(self):
    raise DoBreak
</t>
<t tx="ekr.20040227065519.238">def return_stmt(self, value):
    raise DoReturn, self.visit(value)
</t>
<t tx="ekr.20040227065519.239">def while_stmt(self, test, body, else_body=None):
    while self.visit(test).nonzero():
        try:
            self.visit(body)
        except DoBreak:
            break
        except DoContinue:
            continue
    else:
        if else_body is not None:
            self.visit(else_body)
</t>
<t tx="ekr.20040227065519.240">def if_stmt(self, tests, else_body=None):
    for test, body in tests:
        if self.visit(test).nonzero():
            return self.visit(body)
    if else_body != None:
        return self.visit(else_body)
</t>
<t tx="ekr.20040227065519.241">def for_stmt(self, index, sequence, body, else_body=None):
    seq = self.visit(sequence)
    i = 0
    try:
        while 1:
            self.set(index, seq.getitem(PyObject(i)))
            i = i+1
            try:
                self.visit(body)
            except DoBreak:
                break
            except DoContinue:
                continue
    except IndexError:
        if else_body is not None:
            self.visit(else_body)
</t>
<t tx="ekr.20040227065519.242">


class PyObject:
	@others
</t>
<t tx="ekr.20040227065519.243">def print_line(self):
    print self.value
</t>
<t tx="ekr.20040227065519.244">def print_continued(self):
    print self.value,
</t>
<t tx="ekr.20040227065519.245">def __init__(self, value):
    self.value = value
</t>
<t tx="ekr.20040227065519.246">def nonzero(self):
    return not not self.value
</t>
<t tx="ekr.20040227065519.247">def unop(self, op):
    test = getattr(org.python.core.PyObject, '__'+op+'__')(self.value)
    return PyObject(test)
</t>
<t tx="ekr.20040227065519.248">def compop(self, op, y):
    #print 'comp', self.value, op, y.value
    test = getattr(org.python.core.PyObject, '_'+op)(self.value, y.value)
    return PyObject(test)
</t>
<t tx="ekr.20040227065519.249">binop = compop

def getitem(self, index):
    return PyObject(operator.getitem(self.value, index.value))
</t>
<t tx="ekr.20040227065519.250">def setitem(self, index, value):
    operator.setitem(self.value, index.value, value.value)
</t>
<t tx="ekr.20040227065519.251">def getattr(self, name):
    return PyObject(getattr(self.value, name))
</t>
<t tx="ekr.20040227065519.252">def setattr(self, name, value):
    setattr(self.value, name, value.value)
</t>
<t tx="ekr.20040227065519.253">def call(self, args, kws):
    newargs = []
    for arg in args:
        newargs.append(arg.value)
    newkws = {}
    for name, value in kws.items():
        newkws[name] = value.value
    return PyObject(apply(self.value, tuple(newargs), newkws))
</t>
<t tx="ekr.20040227065519.254">def invoke(self, name, args, kws):
    return self.getattr(name).call(args, kws)
</t>
<t tx="ekr.20040227065519.255">def dir(self):
    return dir(self.value)
</t>
<t tx="ekr.20040227065519.256">


class PyInteger(PyObject):
	&lt;&lt; class PyInteger declarations &gt;&gt;
</t>
<t tx="ekr.20040227065519.257">pass

</t>
<t tx="ekr.20040227065519.258">class PyFloat(PyObject):
	&lt;&lt; class PyFloat declarations &gt;&gt;
</t>
<t tx="ekr.20040227065519.259">pass

</t>
<t tx="ekr.20040227065519.260">class PyString(PyObject):
	&lt;&lt; class PyString declarations &gt;&gt;
</t>
<t tx="ekr.20040227065519.261">pass


</t>
<t tx="ekr.20040227065519.262">
def makeBuiltins():
    dict = {}
    import __builtin__
    for name in dir(__builtin__):
        value = getattr(__builtin__, name)
        dict[name] = PyObject(value)
    return dict
</t>
<t tx="ekr.20040227065519.263">@ignore
@language python
&lt;&lt; PythonModule declarations &gt;&gt;
@others


if __name__ == '__main__':
    pm = PythonModule("baz")
    pm.packages = ['java.lang', 'java.awt']
    pm.getIntegerConstant(22)
    pm.getStringConstant("hello world")
    pm.dump("c:\\jpython\\tools\\jpythonc2")
</t>
<t tx="ekr.20040227065519.264"># Copyright (c) Corporation for National Research Initiatives

import os

import jast
import java, org

EMPTYSTRING = ''


from org.python.core.PyTableCode import CO_OPTIMIZED,CO_NESTED


"""
class foo
    class py -- what gets imported by jpython
        holds all py constants
        One of these no matter how many classes
        maybe have static inner classes as well
"""

</t>
<t tx="ekr.20040227065519.265">def clean(node):
    if not hasattr(node, 'exits'):
        print node
    if node.exits():
        return node
    return jast.Block([node,
                       jast.Return(jast.GetStaticAttribute('Py', 'None'))])
</t>
<t tx="ekr.20040227065519.266">
from java.lang.Character import isJavaIdentifierPart
def legalJavaName(name):
    letters = []
    for c in name:
        if isJavaIdentifierPart(c):
            letters.append(c)
    if len(letters) == 0:
        return "x"
    elif len(letters) == len(name):
        return name
    else:
        return EMPTYSTRING.join(letters)
</t>
<t tx="ekr.20040227065519.267">

def StringArrayOrNull(strs):
    if strs:
        return jast.StringArray(strs)
    else:
        return jast.Null
</t>
<t tx="ekr.20040227065519.268">
class PythonInner:
	@others
</t>
<t tx="ekr.20040227065519.269">def __init__(self, parent):
    self.constantValues = {}
    self.constants = []             
    self.codes = []
    self.interfaces = []

    self.funccodes = []
    self.uniquenames = []

    self.modifier = "public static"
    self.parent = parent
    self.filename = parent.filename
    self.name = "_PyInner"

    self.superclass = "Object"
</t>
<t tx="ekr.20040227065519.270">def getConstant(self, value, code, prefix):
    if self.constantValues.has_key( (value,prefix) ):
        return self.constantValues[(value,prefix) ]

    name = prefix+"$"+str(len(self.constants))
    ret = jast.Identifier(name)
    self.constantValues[(value,prefix)] = ret
    self.constants.append( ("PyObject", ret, code) )
    return ret
</t>
<t tx="ekr.20040227065519.271">def getIntegerConstant(self, value):
    code = jast.InvokeStatic("Py", "newInteger",
                             [jast.IntegerConstant(value)])
    return self.getConstant(value, code, "i")
</t>
<t tx="ekr.20040227065519.272">def getLongConstant(self, value):
    code = jast.InvokeStatic("Py", "newLong",
                             [jast.StringConstant(str(value))])
    return self.getConstant(value, code, "l")
</t>
<t tx="ekr.20040227065519.273">def getImaginaryConstant(self, value):
    code = jast.InvokeStatic("Py", "newImaginary",
                             [jast.FloatConstant(value)])
    return self.getConstant(value, code, "j")
</t>
<t tx="ekr.20040227065519.274">def getFloatConstant(self, value):
    code = jast.InvokeStatic("Py", "newFloat", [jast.FloatConstant(value)])
    return self.getConstant(value, code, "f")
</t>
<t tx="ekr.20040227065519.275">def getStringConstant(self, value):
    code = jast.InvokeStatic("Py", "newString",
                             [jast.StringConstant(value)])
    return self.getConstant(value, code, "s")
</t>
<t tx="ekr.20040227065519.276">def getCodeConstant(self, name, code, frame):
    label = "c$%d_%s" % (len(self.codes), legalJavaName(name))
    ret = jast.Identifier(label)
    self.codes.append( (label, name, code, frame) )
    return ret
</t>
<t tx="ekr.20040227065519.277">def dumpConstants(self):
    self.dumpCodes()
    stmts = []
    decls = []
    for type, label, value in self.constants:
        decls.append(jast.Declare("private static "+type, label))
        stmts.append(jast.Set(label, value))

    setconstants = jast.Method("initConstants", "private static",
                               ["void"], jast.Block(stmts))
    decls.append(setconstants)
    return decls
</t>
<t tx="ekr.20040227065519.278">def dumpCodes(self):
    self.constants.append(["PyFunctionTable", self.getFunctionTable(),
                           jast.New(self.name, [])])

    for label, name, code, frame in self.codes:
        code = frame.toCellPrepend(code)

        funcid = self.addFunctionCode(name, code)

        arglist = keyworddict = jast.False
        if frame.args_arglist():
            arglist = jast.True
        if frame.args_keyworddict():
            keyworddict = jast.True

        names = jast.StringArray(frame.getnames())
        cellnames = StringArrayOrNull(frame.getcellnames())
        freenames = StringArrayOrNull(frame.getfreenames())
        npurecell = frame.get_npurecell()

        cargs = [jast.IntegerConstant(frame.args_count()),
                 names,
                 jast.StringConstant(self.filename),
                 jast.StringConstant(name),
                 arglist,
                 keyworddict,
                 self.getFunctionTable(),
                 jast.IntegerConstant(funcid),
                 cellnames,
                 freenames,
                 jast.IntegerConstant(npurecell),
                 jast.IntegerConstant((frame.opt_globals and CO_OPTIMIZED) | (frame.scope.nested_scopes and CO_NESTED))]
        newcode = jast.InvokeStatic("Py", "newCode", cargs)
        self.constants.append(("PyCode", jast.Identifier(label), newcode))
</t>
<t tx="ekr.20040227065519.279">def uniquename(self, name):
    self.uniquenames.append(name)
    return name+"$"+str(len(self.uniquenames))
</t>
<t tx="ekr.20040227065519.280">def dumpFuncs(self):
    meths = []
    cases = []

    args = ["PyObject", ("PyFrame", "frame")]
    access = "private static"

    callargs = [jast.Identifier("frame")]

    for name, funcid, code in self.funccodes:
        funcname = self.uniquename(name)
        meths.append(jast.Method(funcname, access, args, clean(code)))

        body = jast.Return(jast.InvokeStatic(self.name, funcname,
                                             callargs))
        cases.append([jast.IntegerConstant(funcid),
                      jast.FreeBlock([body])])

    defaultCase = jast.FreeBlock([jast.Return(jast.Null)])
    switch = jast.Block([jast.Switch(jast.Identifier('index'), cases,
                                     defaultCase)])

    meths.insert(0, jast.Method("call_function", "public",
                                ["PyObject",
                                 ("int", "index"),
                                 ("PyFrame", "frame")],
                                switch))
    self.superclass = "PyFunctionTable"
    return meths
</t>
<t tx="ekr.20040227065519.281">def getFunctionTable(self):
    return jast.Identifier("funcTable")
</t>
<t tx="ekr.20040227065519.282">def addFunctionCode(self, name, code):
    self.funccodes.append((legalJavaName(name), len(self.funccodes), code))
    return len(self.funccodes)-1
</t>
<t tx="ekr.20040227065519.283">def addMain(self, code, cc):
    self.mainCode = self.getCodeConstant("main", code, cc.frame)
</t>
<t tx="ekr.20040227065519.284">def dumpMain(self):
    if not hasattr(self, 'mainCode'):
        return []
    meths = []

    self.interfaces.append("PyRunnable")
    getmain = jast.Block(
        [jast.If(
            jast.Operation("==", self.mainCode, jast.Null),
            jast.InvokeStatic(self.name, "initConstants", [])),
         jast.Return(self.mainCode)])
    meths.append(jast.Method("getMain", "public", ["PyCode"], getmain))
    return meths
</t>
<t tx="ekr.20040227065519.285">def dumpAll(self):
    return [self.dumpConstants(),
            jast.Blank, self.dumpMain(), self.dumpFuncs()]
</t>
<t tx="ekr.20040227065519.286">def makeClass(self):
    body = jast.Block(self.dumpAll())
    return jast.Class(self.name, self.modifier,
                      self.superclass, self.interfaces, body)
</t>
<t tx="ekr.20040227065519.287">

defaultProxyProps = {
    "python.options.showJavaExceptions": "true",
    "python.modules.builtin": "exceptions:org.python.core.exceptions",
    }

defaultMainProps = {
    "python.modules.builtin": "exceptions:org.python.core.exceptions",
    }



class PythonModule:
	@others
</t>
<t tx="ekr.20040227065519.288">def getclassname(self, name):
    if self.package is not None:
        return self.package + '.' + name
    return name
</t>
<t tx="ekr.20040227065519.289">def addjavaclass(self, name):
    self.javaclasses.append(self.getclassname(name))
</t>
<t tx="ekr.20040227065519.290">def addinnerclass(self, name):
    self.addjavaclass(self.name+'$'+name)
</t>
<t tx="ekr.20040227065519.291">def __init__(self, name, filename="&lt;unknown&gt;", packages = [],
             proxyProperties=defaultProxyProps,
             mainProperties=defaultMainProps, frozen=1):
    package = None
    dot = name.rfind('.')
    if dot != -1:
        package = name[:dot]
        name = name[dot+1:]

    self.name = name
    self.filename = filename
    self.superclass = java.lang.Object
    self.interfaces = []
    self.temps = []

    self.package = package

    self.javamain = 1

    self.attributes = {}
    self.classes = {}
    self.imports = {}

    self.packages = packages                
    self.proxyProperties = proxyProperties
    self.mainProperties = mainProperties
    self.innerClasses = []

    self.modifier = "public"

    self.pyinner = PythonInner(self)

    #if frozen:
    self.innerClasses.append(self.pyinner)

    self.frozen = frozen    
    self.javaproxy = None

    self.javaclasses = []
    self.addjavaclass(self.name)
</t>
<t tx="ekr.20040227065519.292">def getFrozen(self):
    if self.frozen:
        if self.package is None:
            return jast.StringConstant("")
        else:
            return jast.StringConstant(self.package)
    else:
        return jast.Null
</t>
<t tx="ekr.20040227065519.293">def addAttribute(self, name, value):
    self.attributes[name] = value
</t>
<t tx="ekr.20040227065519.294">    #print ' mod add attr', self.name, name, value, self.attributes.keys()

#Delegate constants
def getIntegerConstant(self, value):
    return self.pyinner.getIntegerConstant(value)
</t>
<t tx="ekr.20040227065519.295">def getLongConstant(self, value):
    return self.pyinner.getLongConstant(value)
</t>
<t tx="ekr.20040227065519.296">def getImaginaryConstant(self, value):
    return self.pyinner.getImaginaryConstant(value)
</t>
<t tx="ekr.20040227065519.297">def getFloatConstant(self, value):
    return self.pyinner.getFloatConstant(value)
</t>
<t tx="ekr.20040227065519.298">def getStringConstant(self, value):
    return self.pyinner.getStringConstant(value)
</t>
<t tx="ekr.20040227065519.299">def getCodeConstant(self, name, code, frame):
    return self.pyinner.getCodeConstant(name, code, frame)
</t>
<t tx="ekr.20040227065519.300">def addFunctionCode(self, name, code):
    return self.pyinner.addFunctionCode(name, code)
</t>
<t tx="ekr.20040227065519.301">def addMain(self, code, cc):
    return self.pyinner.addMain(code, cc)
</t>
<t tx="ekr.20040227065519.302">#Properties and packages for registry
def getMainProperties(self,qual=0):
    if qual:
        return jast.GetStaticAttribute(self.name,"jpy$mainProperties")
    else:
        return jast.Identifier("jpy$mainProperties")
</t>
<t tx="ekr.20040227065519.303">def getProxyProperties(self,qual=0):
    if qual:
        return jast.GetStaticAttribute(self.name,"jpy$proxyProperties")
    else:
        return jast.Identifier("jpy$proxyProperties")
</t>
<t tx="ekr.20040227065519.304">def getPackages(self,qual=0):
    if qual:
        return jast.GetStaticAttribute(self.name,"jpy$packages")
    else:
        return jast.Identifier("jpy$packages")
</t>
<t tx="ekr.20040227065519.305">def dumpDictionary(self, dict, field):
    props = []
    for name, value in dict.items():
        props.append(name)
        props.append(value)
    return jast.Declare("static String[]", field, jast.StringArray(props))
</t>
<t tx="ekr.20040227065519.306">def dumpProperties(self):
    return [
        self.dumpDictionary(self.mainProperties,
                               self.getMainProperties()),
        self.dumpDictionary(self.proxyProperties,
                               self.getProxyProperties())
    ]
</t>
<t tx="ekr.20040227065519.307">def dumpPackages(self):
    return self.dumpDictionary(self.packages, self.getPackages())
</t>
<t tx="ekr.20040227065519.308">def dumpFields(self):
    return [self.dumpProperties(), self.dumpPackages()]
</t>
<t tx="ekr.20040227065519.309">def dumpInitModule(self):
    meths = []

    dict = jast.Identifier("dict")
    sargs = [jast.StringConstant("__name__"),
             jast.New("PyString", [jast.StringConstant(self.name)])]
    rargs = [jast.Invoke(jast.New("_PyInner", []), "getMain", []),
             dict, dict]
    code = jast.Block(
        [jast.Invoke(dict, "__setitem__", sargs),
         jast.InvokeStatic("Py", "runCode", rargs)])
    meths.append(jast.Method("moduleDictInit", "public static", 
                             ["void", ("PyObject", "dict")], code))
    return meths
</t>
<t tx="ekr.20040227065519.310">#Define a Java main to run directly
def dumpMain(self):
    meths = []
    if self.javamain:
        code = []
        newargs = jast.Identifier("newargs")
        code.append(jast.Declare("String[]", newargs, 
               jast.NewArray("String", ["args.length+1"])))
        code.append(jast.Set(jast.Identifier("newargs[0]"),  
               jast.StringConstant(self.name)))

        args = [jast.Identifier('args'), 
                jast.IntegerConstant(0),
                jast.Identifier('newargs'), 
                jast.IntegerConstant(1),
                jast.Identifier('args.length')]
        code.append(jast.InvokeStatic("System", "arraycopy", args))

        args = [jast.GetStaticAttribute(self.getclassname(
                       self.name+'.'+self.pyinner.name), "class"),
                jast.Identifier('newargs'), 
                self.getPackages(qual=1), self.getMainProperties(qual=1), 
                self.getFrozen(), jast.StringArray(self.modules.keys())]

        code.append([jast.InvokeStatic("Py", "runMain", args)])
        maincode = jast.Block(code)
        meths.append(jast.Method("main", "public static", 
                                 ["void", ("String[]", "args")], maincode,
                                 ["java.lang.Exception"]))

    return meths
</t>
<t tx="ekr.20040227065519.311">    #args = [jast.StringConstant(self.name), jast.Identifier('dict')]
    #initcode = jast.Block([jast.InvokeStatic("Py", "initRunnable", args)])
    #meths.append(jast.Method("initModule", "public", 
    #       ["void", ("PyObject", "dict")], initcode))

def dumpInnerClasses(self):
    ret = []                
    for inner in self.innerClasses:
        self.addinnerclass(inner.name)
        ret.append(inner.makeClass())
    return ret
</t>
<t tx="ekr.20040227065519.312">def dumpAll(self):
    return [self.dumpFields(),
            jast.Blank, self.dumpInnerClasses(),
            self.dumpInitModule(), self.dumpMain()]
</t>
<t tx="ekr.20040227065519.313">def makeClass(self):
    mycode = self.dumpAll()
    supername = self.superclass.__name__
    if self.javaproxy is not None:
        mycode = [mycode, self.javaproxy.dumpAll()]
        self.superclass = self.javaproxy.superclass
        self.interfaces = self.interfaces+self.javaproxy.interfaces
        supername = self.javaproxy.supername

    body = jast.Block(mycode)
    return jast.Class(self.name, self.modifier, supername,
                      map(lambda i: i.__name__, self.interfaces), body)
</t>
<t tx="ekr.20040227065519.314">def makeClassFile(self):
    header = []
    if self.package is not None:
        header.append(jast.Identifier("package %s" % self.package))
        header.append(jast.Blank)
    header.append(jast.Import("org.python.core.*"))
    header.append(jast.Blank)
    return jast.FreeBlock([header, self.makeClass()])
</t>
<t tx="ekr.20040227065519.315">def dump(self, directory):
    cf = self.makeClassFile()
    sf = jast.Output.SourceFile(self.name)
    if self.package is not None:
        pack = apply(os.path.join, self.package.split('.'))
        directory = os.path.join(directory, pack)
    if not os.path.exists(directory):
        os.makedirs(directory)
    try:
        cf.writeSource(sf)
    except:
        print EMPTYSTRING.join(sf.text)
        raise
    sf.dump(directory)
    return os.path.join(directory, self.name+'.java')
</t>
<t tx="ekr.20040227065519.316">@ignore
@language python
&lt;&lt; PythonVisitor declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040227065519.317"># Copyright (c) Corporation for National Research Initiatives

from org.python.parser import Visitor, SimpleNode
from org.python.parser.PythonGrammarTreeConstants import *
from org.python.parser import SimpleNode

from org.python.compiler import Future


comp_ops = {JJTLESS_CMP         : 'lt',
            JJTEQUAL_CMP        : 'eq',
            JJTGREATER_CMP      : 'gt', 
            JJTGREATER_EQUAL_CMP: 'ge',
            JJTLESS_EQUAL_CMP   : 'le',
            JJTNOTEQUAL_CMP     : 'ne',
            JJTIS_NOT_CMP       : 'isnot',
            JJTIS_CMP           : 'is',
            JJTIN_CMP           : 'in',
            JJTNOT_IN_CMP       : 'notin'
            }



</t>
<t tx="ekr.20040227065519.318">def nodeToList(node, start=0):
    nodes = []
    for i in range(start, node.numChildren):
        nodes.append(node.getChild(i))
    return nodes
</t>
<t tx="ekr.20040227065519.319">def nodeToStrings(node, start=0):
    names = []
    for i in range(start, node.numChildren):
        names.append(node.getChild(i).getInfo())
    return names
</t>
<t tx="ekr.20040227065519.320">
def getDocString(suite):
    if suite.numChildren &gt; 0:
        n = suite.getChild(0)
        if n.id == JJTEXPR_STMT and n.getChild(0).id == JJTSTRING:
            return n.getChild(0).getInfo()
    return None
</t>
<t tx="ekr.20040227065519.321">


class PythonVisitor(Visitor):
	@others
</t>
<t tx="ekr.20040227065519.322">def __init__(self, walker):
    # a SimpleCompiler
    self.walker = walker
</t>
<t tx="ekr.20040227065519.323"># The fast_locals arg is supplied when this method is used for
# names in local scope.
def getName(self, node, fast_locals=0):
    if not node.id == JJTNAME:
        return None
    s = node.getInfo()
    if fast_locals:
        return s
    if s[:2] == '__' and s[-2:] != '__' and self.walker.className:
        s = "_%s%s" % (self.walker.className, s)
    return s
</t>
<t tx="ekr.20040227065519.324">def walk(self, node):
    self.suite(node)
</t>
<t tx="ekr.20040227065519.325">def startnode(self, node):
    self.walker.setline(node.beginLine)
</t>
<t tx="ekr.20040227065519.326">def suite(self, node):
    return self.walker.suite(nodeToList(node))
</t>
<t tx="ekr.20040227065519.327">file_input = suite
single_input = suite
eval_input = suite

def exec_stmt(self, node):
    self.startnode(node)
    code = node.getChild(0).visit(self)
    globs = locs = None
    if node.numChildren &gt; 1:
        globs = node.getChild(1).visit(self)
    if node.numChildren &gt; 2:
        locs = node.getChild(2).visit(self)
    return self.walker.exec_stmt(code, globs, locs)
</t>
<t tx="ekr.20040227065519.328">def assert_stmt(self, node):
    self.startnode(node)
    test = node.getChild(0).visit(self)
    if node.numChildren &gt; 1:
        message = node.getChild(1).visit(self)
    else:
        message = None
    return self.walker.assert_stmt(test, message)
</t>
<t tx="ekr.20040227065519.329">def pass_stmt(self, node):
    self.startnode(node)
    return self.walker.pass_stmt()
</t>
<t tx="ekr.20040227065519.330">def break_stmt(self, node):
    self.startnode(node)    
    return self.walker.break_stmt()
</t>
<t tx="ekr.20040227065519.331">def continue_stmt(self, node):
    self.startnode(node)
    return self.walker.continue_stmt()
</t>
<t tx="ekr.20040227065519.332">def return_stmt(self, node):
    self.startnode(node)
    if node.numChildren == 0:
        return self.walker.return_stmt()
    else:
        return self.walker.return_stmt(node.getChild(0))
</t>
<t tx="ekr.20040227065519.333">def global_stmt(self, node):
    self.startnode(node)
    return self.walker.global_stmt(nodeToStrings(node))
</t>
<t tx="ekr.20040227065519.334">def raise_stmt(self, node):
    self.startnode(node)
    exc_type = exc_value = exc_traceback = None
    n = node.numChildren
    if n &gt; 0:
        exc_type = node.getChild(0).visit(self)
    if n &gt; 1:
        exc_value = node.getChild(1).visit(self)
    if n &gt; 2:
        exc_traceback = node.getChild(2).visit(self)
    return self.walker.raise_stmt(exc_type, exc_value, exc_traceback)
</t>
<t tx="ekr.20040227065519.335">def Import(self, node):
    self.startnode(node)
    names = self.import_as_name(node, 0)
    return self.walker.import_stmt(names)
</t>
<t tx="ekr.20040227065519.336">def ImportFrom(self, node):
    Future.checkFromFuture(node) # future stmt support
    self.startnode(node)
    if node.numChildren &gt; 1:
        names = self.import_as_name(node, 1)
        return self.walker.importfrom_stmt(node.getChild(0).visit(self), 
                                                 names)
    else:
        return self.walker.importfrom_stmt(
            node.getChild(0).visit(self), "*")
</t>
<t tx="ekr.20040227065519.337">def import_as_name(self, node, startnode=0):
    names = []
    for i in range(startnode, node.numChildren):
        n = node.getChild(i)
        if n.id == JJTDOTTED_AS_NAME:
            dotted = n.getChild(0).visit(self)
            asname = n.getChild(1).getInfo()
        elif n.id == JJTIMPORT_AS_NAME:
            dotted = n.getChild(0).getInfo()
            asname = n.getChild(1).getInfo()
        elif n.id == JJTDOTTED_NAME:
            dotted = n.visit(self)
            asname = None
        else:
            dotted = n.getInfo()
            asname = None
        names.append((dotted, asname))
    return names
</t>
<t tx="ekr.20040227065519.338">def dotted_name(self, node):
    return nodeToStrings(node)
</t>
<t tx="ekr.20040227065519.339">def print_ext(self, node):
    # There better be exactly one subnode
    self.startnode(node)
    return node.getChild(0)
</t>
<t tx="ekr.20040227065519.340">def print_stmt(self, node):
    self.startnode(node)
    n = node.numChildren
    rets = []
    printext = 0
    file = None
    start = 0
    nochildren = 0
    # extended print?
    if n &gt; 0 and node.getChild(0).id == JJTPRINT_EXT:
        printext = 1
        file = self.print_ext(node.getChild(0))
        start = 1
        nochildren = 1
    for i in range(start, n-1):
        child = node.getChild(i)
        if printext:
            rets.append(self.walker.print_continued_to(file, child))
        else:
            rets.append(self.walker.print_continued(child))
    if n == nochildren:
        if printext:
            rets.append(self.walker.print_line_to(file))
        else:
            rets.append(self.walker.print_line())
    elif node.getChild(n-1).id != JJTCOMMA:
        child = node.getChild(n-1)
        if printext:
            rets.append(self.walker.print_line_to(file, child))
        else:
            rets.append(self.walker.print_line(child))
    return rets
</t>
<t tx="ekr.20040227065519.341">def if_stmt(self, node):
    self.startnode(node)
    tests = []
    else_body = None
    n = node.numChildren
    for i in range(0,n-1,2):
        tests.append( (node.getChild(i), node.getChild(i+1)) )

    if n % 2 == 1:
        else_body = node.getChild(n-1)

    return self.walker.if_stmt(tests, else_body)
</t>
<t tx="ekr.20040227065519.342">def while_stmt(self, node):
    self.startnode(node)
    test = node.getChild(0)
    suite = node.getChild(1)
    if node.numChildren == 3:
        else_body = node.getChild(2)
    else:
        else_body = None

    return self.walker.while_stmt(test, suite, else_body)
</t>
<t tx="ekr.20040227065519.343">def for_stmt(self, node):
    self.startnode(node)
    index = node.getChild(0)
    sequence = node.getChild(1)
    body = node.getChild(2)
    if node.numChildren == 4:
        else_body = node.getChild(3)
    else:
        else_body = None

    return self.walker.for_stmt(index, sequence, body, else_body)
</t>
<t tx="ekr.20040227065519.344">def expr_stmt(self, node):
    if node.getNumChildren() == 1:
        n = node.getChild(0)
        if n.id &gt;= JJTAUG_PLUS and n.id &lt;= JJTAUG_POWER:
            return self.walker.visit(n)

    self.startnode(node)
    rhs = node.getChild(node.numChildren-1)
    return self.walker.expr_stmt(nodeToList(node)[:-1], rhs)
</t>
<t tx="ekr.20040227065519.345">def del_stmt(self, node):
    self.startnode(node)
    return self.walker.del_stmt(nodeToList(node))
</t>
<t tx="ekr.20040227065519.346">def Name(self, node):
    #self.startnode(node)
    return self.walker.name_const(
            self.getName(node, self.walker.frame.fast_locals))
</t>
<t tx="ekr.20040227065519.347">def Int(self, node):
    #self.startnode(node)
    i = node.getInfo()
    if isinstance(i, type(0)):
        return self.walker.int_const(int(i))
    else:
        return self.walker.long_const(long(i))
</t>
<t tx="ekr.20040227065519.348">def Float(self, node):
    #self.startnode(node)
    return self.walker.float_const(float(node.getInfo()))
</t>
<t tx="ekr.20040227065519.349">def Complex(self, node):
    #self.startnode(node)
    return self.walker.complex_const(float(node.getInfo())) 
</t>
<t tx="ekr.20040227065519.350">def String(self, node):
    #self.startnode(node)
    return self.walker.string_const(node.getInfo())
</t>
<t tx="ekr.20040227065519.351">def Ellipses(self, node):
    return self.walker.ellipsis_const()
</t>
<t tx="ekr.20040227065519.352">def getSlice(self, node):
    s = [None, None, None]
    n = node.numChildren
    index = 0
    for i in range(n):
        child = node.getChild(i)
        if child.id == JJTCOLON:
            index = index+1
        else:
            s[index] = child
    return s
</t>
<t tx="ekr.20040227065519.353">def Slice(self, node):
    #self.startnode(node)
    s = self.getSlice(node)
    return self.walker.slice_op(s[0], s[1], s[2])
</t>
<t tx="ekr.20040227065519.354">def makeSeqArgs(self, node):
    values = nodeToList(node)
    ret = []
    for value in values:
        if value.id == JJTCOMMA:
            continue
        ret.append(value)
    return ret
</t>
<t tx="ekr.20040227065519.355">def list(self, node):
    #self.startnode(node)
    if node.numChildren &gt; 1 and node.getChild(1).id == JJTFOR_STMT:
        return self.walker.list_comprehension(node)
    return self.walker.list_op(self.makeSeqArgs(node))
</t>
<t tx="ekr.20040227065519.356">def list_iter(self, node):
    return self.walker.list_iter(node)
</t>
<t tx="ekr.20040227065519.357">def tuple(self, node):
    #self.startnode(node)
    return self.walker.tuple_op(self.makeSeqArgs(node))
</t>
<t tx="ekr.20040227065519.358">def dictionary(self, node):
    #self.startnode(node)
    items = []
    for i in range(0, node.numChildren, 2):
        items.append( (node.getChild(i), node.getChild(i+1)) )
    return self.walker.dictionary_op(items)
</t>
<t tx="ekr.20040227065519.359">def Dot_Op(self, node):
    #self.startnode(node)   
    obj = node.getChild(0)
    name = self.getName(node.getChild(1))
    return self.walker.get_attribute(obj, name)
</t>
<t tx="ekr.20040227065519.360">def Index_Op(self, node):
    obj = node.getChild(0)
    index = node.getChild(1)
    return self.walker.get_item(obj, index)
</t>
<t tx="ekr.20040227065519.361">def Call_Op(self, node):
    callee = node.getChild(0)

    args = []
    keyargs = []

    kwargs = starargs = None

    if node.numChildren != 1:
        argsNode = node.getChild(1)

        n = argsNode.numChildren
        lastarg = argsNode.getChild(n-1);
        if lastarg.id == JJTEXTRAKEYWORDVALUELIST:
            n = n - 1
            kwargs = lastarg
        if n &gt; 0:
            lastarg = argsNode.getChild(n-1);
            if lastarg.id == JJTEXTRAARGVALUELIST:
                n = n - 1
                starargs = lastarg;

        for i in range(n):
            argNode = argsNode.getChild(i)
            if argNode.id != JJTKEYWORD:
                if len(keyargs) &gt; 0:
                    raise ValueError, \
                          "non-keyword argument following keyword"
                args.append(argNode)
            else:
                keyargs.append((argNode.getChild(0).getInfo(),
                                argNode.getChild(1)))

    # Check for method invocation
    if callee.id == JJTDOT_OP and kwargs is None and starargs is None:
        object = callee.getChild(0)
        name = self.getName(callee.getChild(1))
        return self.walker.invoke(object, name, args, keyargs)
    if kwargs or starargs:
        return self.walker.call_extra(callee, args, 
                                      keyargs, starargs, kwargs)

    return self.walker.call(callee, args, keyargs)
</t>
<t tx="ekr.20040227065519.362">def binop(self, node, name):
    #self.startnode(node)
    return self.walker.binary_op(name, node.getChild(0), node.getChild(1))
</t>
<t tx="ekr.20040227065519.363">def add_2op(self, node): return self.binop(node, 'add')     
</t>
<t tx="ekr.20040227065519.364">def sub_2op(self, node): return self.binop(node, 'sub')     
</t>
<t tx="ekr.20040227065519.365">def mul_2op(self, node): return self.binop(node, 'mul')     
</t>
<t tx="ekr.20040227065519.366">def div_2op(self, node): return self.binop(node, 'div')     
</t>
<t tx="ekr.20040227065519.367">def mod_2op(self, node): return self.binop(node, 'mod')
</t>
<t tx="ekr.20040227065519.368">def and_2op(self, node): return self.binop(node, 'and')
</t>
<t tx="ekr.20040227065519.369">def lshift_2op(self, node): return self.binop(node, 'lshift')
</t>
<t tx="ekr.20040227065519.370">def rshift_2op(self, node): return self.binop(node, 'rshift')
</t>
<t tx="ekr.20040227065519.371">def or_2op(self, node): return self.binop(node, 'or')
</t>
<t tx="ekr.20040227065519.372">def xor_2op(self, node): return self.binop(node, 'xor')
</t>
<t tx="ekr.20040227065519.373">def pow_2op(self, node): return self.binop(node, 'pow')
</t>
<t tx="ekr.20040227065519.374">def unop(self, node, name):
    #self.startnode(node)
    return self.walker.unary_op(name, node.getChild(0))
</t>
<t tx="ekr.20040227065519.375">def abs_1op(self, node): return self.unop(node, 'abs')
</t>
<t tx="ekr.20040227065519.376">def invert_1op(self, node): return self.unop(node, 'invert')
</t>
<t tx="ekr.20040227065519.377">def neg_1op(self, node): return self.unop(node, 'neg')
</t>
<t tx="ekr.20040227065519.378">def abs_1op(self, node): return self.unop(node, 'abs')
</t>
<t tx="ekr.20040227065519.379">def pos_1op(self, node): return self.unop(node, 'pos')
</t>
<t tx="ekr.20040227065519.380">def not_1op(self, node): return self.unop(node, 'not')
</t>
<t tx="ekr.20040227065519.381">def str_1op(self, node): return self.unop(node, 'repr')
</t>
<t tx="ekr.20040227065519.382">def aug_binaryop(self, node, name):
    #self.startnode(node)
    return self.walker.aug_binary_op(name, 
                     node.getChild(0), node.getChild(1))
</t>
<t tx="ekr.20040227065519.383">def aug_plus(self, node): return self.aug_binaryop(node, "__iadd__")
</t>
<t tx="ekr.20040227065519.384">def aug_minus(self, node): return self.aug_binaryop(node, "__isub__")
</t>
<t tx="ekr.20040227065519.385">def aug_multiply(self, node): return self.aug_binaryop(node, "__imul__")
</t>
<t tx="ekr.20040227065519.386">def aug_divide(self, node): return self.aug_binaryop(node, "__idiv__")
</t>
<t tx="ekr.20040227065519.387">def aug_modulo(self, node): return self.aug_binaryop(node, "__imod__")
</t>
<t tx="ekr.20040227065519.388">def aug_and(self, node): return self.aug_binaryop(node, "__iand__")
</t>
<t tx="ekr.20040227065519.389">def aug_or(self, node): return self.aug_binaryop(node, "__ior__")
</t>
<t tx="ekr.20040227065519.390">def aug_xor(self, node): return self.aug_binaryop(node, "__ixor__")
</t>
<t tx="ekr.20040227065519.391">def aug_lshift(self, node): return self.aug_binaryop(node, "__ilshift__")
</t>
<t tx="ekr.20040227065519.392">def aug_rshift(self, node): return self.aug_binaryop(node, "__irshift__")
</t>
<t tx="ekr.20040227065519.393">def aug_power(self, node): return self.aug_binaryop(node, "__ipow__")
</t>
<t tx="ekr.20040227065519.394">def getString(self, node):
    if node.id == JJTSTRING:
        return node.getInfo()
    elif node.id == JJTSTRJOIN:
        return self.getString(node.getChild(0)) + \
               self.getString(node.getChild(1))
    else:
        raise ValueError, 'non string!'
</t>
<t tx="ekr.20040227065519.395">def strjoin(self, node):
    return self.walker.string_const(self.getString(node))
</t>
<t tx="ekr.20040227065519.396">def comparision(self, node):
    #self.startnode(node)
    start = node.getChild(0)
    tests = []
    for i in range(1, node.numChildren, 2):
        op = comp_ops[node.getChild(i).id]
        obj = node.getChild(i+1)
        tests.append( (op, obj) )
    return self.walker.compare_op(start, tests)
</t>
<t tx="ekr.20040227065519.397">def and_boolean(self, node):
    return self.walker.and_op(node.getChild(0), node.getChild(1))
</t>
<t tx="ekr.20040227065519.398">def or_boolean(self, node):
    return self.walker.or_op(node.getChild(0), node.getChild(1))
</t>
<t tx="ekr.20040227065519.399">def try_stmt(self, node):
    self.startnode(node)

    n = node.numChildren
    if n == 2:
        return self.walker.tryfinally(node.getChild(0), node.getChild(1))

    body = node.getChild(0)
    exceptions = []

    for i in range(1, n-1, 2):
        exc = node.getChild(i)
        if exc.numChildren == 0:
            exc = None
        elif exc.numChildren == 1:
            exc = [exc.getChild(0).visit(self)]
        else:
            exc = [exc.getChild(0).visit(self), exc.getChild(1)]
        exceptions.append( (exc, node.getChild(i+1)) )

    if n%2 == 0:
        elseClause = node.getChild(n-1)
    else:
        elseClause = None

    return self.walker.tryexcept(body, exceptions, elseClause)
</t>
<t tx="ekr.20040227065519.400">def funcdef(self, node):
    self.startnode(node)

    funcname = self.getName(node.getChild(0))

    Body = node.getChild(node.numChildren-1)

    doc = getDocString(Body)

    return self.walker.funcdef(funcname, node.scope, Body, doc)
</t>
<t tx="ekr.20040227065519.401">def lambdef(self, node):
    Body = node.getChild(node.numChildren-1)

    retBody = SimpleNode(JJTRETURN_STMT)
    retBody.jjtAddChild(Body, 0)

    return self.walker.lambdef(node.scope, retBody)
</t>
<t tx="ekr.20040227065519.402">def classdef(self, node):
    self.startnode(node)
    name = self.getName(node.getChild(0))

    n = node.numChildren
    suite = node.getChild(n-1)
    doc = getDocString(suite)
    bases = []
    for i in range(1, n-1):
        bases.append(node.getChild(i).visit(self))

    return self.walker.classdef(name, bases, node.scope, suite, doc)
</t>
<t tx="ekr.20040227065519.403">@ignore
@language python
&lt;&lt; SimpleCompiler declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040227065519.404"># Copyright (c) Corporation for National Research Initiatives

from BaseEvaluator import BaseEvaluator
import jast
import ImportName

COMMASPACE = ', '

from org.python.compiler import ScopesCompiler, Future, CompilationContext
from org.python.compiler.ScopeConstants import *

import warnings
from org.python.parser import ParseException


</t>
<t tx="ekr.20040227065519.405">class LocalFrame:
	@others
</t>
<t tx="ekr.20040227065519.406">def __init__(self, compiler, scope=None):
    
    self.frame = jast.Identifier("frame")

    self.compiler = compiler

	self.names = {}

    self.temporaries = {}

    self.scope = scope

    self.fast_locals = 0
    self.opt_globals = 0

</t>
<t tx="ekr.20040227065519.407">def setupClosure(self,nested_scope):
    nested_scope.setup_closure(self.scope)
</t>
<t tx="ekr.20040227065519.408">def makeClosure(self,nested_scope):
    freenames = nested_scope.freevars
    if len(freenames) == 0: return None
    clos = []
    factory = self.compiler.factory
    for free in freenames:
        i = self.scope.tbl.get(free).env_index
        code = jast.Invoke(self.frame, "getclosure", [jast.IntegerConstant(i)])
        clos.append(factory.makePyObject(code))
    return clos
</t>
<t tx="ekr.20040227065519.409">def getnames(self):
    return self.scope.names
</t>
<t tx="ekr.20040227065519.410">def args_count(self):
    if self.scope.ac:
        return len(self.scope.ac.names)
    return 0
</t>
<t tx="ekr.20040227065519.411">def args_arglist(self):
    return self.scope.ac and self.scope.ac.arglist
</t>
<t tx="ekr.20040227065519.412">def args_keyworddict(self):
    return self.scope.ac and self.scope.ac.keywordlist
</t>
<t tx="ekr.20040227065519.413">def getfreenames(self):
    return self.scope.freevars
</t>
<t tx="ekr.20040227065519.414">def getcellnames(self):
    return self.scope.cellvars
</t>
<t tx="ekr.20040227065519.415">def get_npurecell(self):
    return self.scope.jy_npurecell
</t>
<t tx="ekr.20040227065519.416">def toCellPrepend(self,code):
    scope = self.scope
    pre = []
    for parmcell in scope.jy_paramcells:
        syminf = scope.tbl.get(parmcell)
        args = [jast.IntegerConstant(syminf.locals_index),
                jast.IntegerConstant(syminf.env_index)]
        pre.append(jast.Invoke(self.frame, "to_cell", args))
    if not pre: return code
    pre.append(jast.BlankLine())
    return jast.Block(jast.flatten([pre,code]))
</t>
<t tx="ekr.20040227065519.417">def gettemps(self, type):
    try:
        temps = self.temporaries[type]
    except KeyError:
        temps = []
        self.temporaries[type] = temps
    return temps            
</t>
<t tx="ekr.20040227065519.418">def gettemp(self, type):
    temps = self.gettemps(type)

    index = 0
    while index &lt; len(temps):
        if temps[index] is None:
            break
        index = index + 1
    if index == len(temps):
        temps.append(None)

    tname = "t$%d$%s" % (index, type.replace("[]", "__"))
    temp = jast.Identifier(tname)
    temp.type = type
    temps[index] = temp
    #print 'get temp', index, type, temps
    return temp
</t>
<t tx="ekr.20040227065519.419">def freetemp(self, temp):
    parts = temp.name.split('$')
    index = int(parts[1])
    type = temp.type
    temps = self.gettemps(type)

    #print 'free temp', index, type, temps

    if temps[index] is None:
        raise ValueError, 'temp already freed'
    temps[index] = None
</t>
<t tx="ekr.20040227065519.420">def get_local_value(self,name):
    if self.names.has_key(name): return self.names[name]
    return None # ?? better to fail? when?
</t>
<t tx="ekr.20040227065519.421">def get_closure_value(self,name,up=0):
    if not up:
        syminf = self.scope.tbl.get(name)
        if syminf and syminf.flags&amp;CELL: return self.get_local_value(name)
    return self.compiler.parent_compiler.frame.get_closure_value(name)
</t>
<t tx="ekr.20040227065519.422">def get_global_value(self,name):
    return self.compiler.top_compiler.frame.get_local_value(name)
</t>
<t tx="ekr.20040227065519.423">def get_name_value(self,name):
    if self.names.has_key(name): return self.names[name]
    return self.get_global_value(name)
</t>
<t tx="ekr.20040227065519.424">def set_global_value(self,name,value):
    self.compiler.top_compiler.frame.set_value(name,value)
</t>
<t tx="ekr.20040227065519.425">def set_value(self,name,value):
    if self.names.has_key(name):
        self.names[name] = self.names[name].mergeWith(value)
        return
    self.names[name] = value
</t>
<t tx="ekr.20040227065519.426">def delCode(self,method,ref):
    if type(ref) is type(""):
        ref = (jast.StringConstant(ref),)
    else:
        ref = (jast.IntegerConstant(ref),)
    return jast.Invoke(self.frame,method,ref)
</t>
<t tx="ekr.20040227065519.427">def getReference(self,value,method,ref):
    code = self.delCode(method,ref)
    if value: return value.makeReference(code)
    return self.compiler.factory.makePyObject(code)
</t>
<t tx="ekr.20040227065519.428">def setCode(self,method,ref,value):
    if type(ref) is type(""):
        args = (jast.StringConstant(ref),value.asAny())
    else:
        args = (jast.IntegerConstant(ref),value.asAny())
    return jast.Invoke(self.frame,method,args)
</t>
<t tx="ekr.20040227065519.429">def getglobal(self,name):
    return self.getReference(self.get_global_value(name),'getglobal',name)
</t>
<t tx="ekr.20040227065519.430">def getname(self, name):
    syminf = self.scope.tbl.get(name)
    if syminf: 
        flags = syminf.flags
        if not self.scope.nested_scopes: flags &amp;= ~FREE
        if flags&amp;GLOBAL or self.opt_globals and not (flags&amp;(BOUND|CELL|FREE)):
            return self.getglobal(name)
        if self.fast_locals:
            if flags&amp;CELL: return self.getReference(
                self.get_closure_value(name),'getderef',syminf.env_index)
            if flags&amp;BOUND: return self.getReference(
                self.get_local_value(name),'getlocal',syminf.locals_index)
        if flags&amp;FREE and not flags&amp;BOUND: return self.getReference(
            self.get_closure_value(name,up=1),'getderef',syminf.env_index)
    return self.getReference(self.get_name_value(name),'getname',name)
</t>
<t tx="ekr.20040227065519.431">def delname(self, name):
    syminf = self.scope.tbl.get(name)
    if syminf and syminf.flags&amp;GLOBAL: return self.delCode('delglobal',name)
    if not self.fast_locals: return self.delCode('dellocal',name)
    if syminf.flags&amp;CELL: raise NameError,"can not delete variable '%s' referenced in nested scope" % name
    return self.delCode('dellocal',syminf.locals_index)
</t>
<t tx="ekr.20040227065519.432">def setname(self, name, value):
    syminf = self.scope.tbl.get(name)
    if syminf and syminf.flags&amp;GLOBAL:
        self.set_global_value(name,value)
        return self.setCode('setglobal',name,value) 

    self.set_value(name,value)

    if not self.fast_locals: return self.setCode('setlocal',name,value)
    if syminf and syminf.flags&amp;CELL: return self.setCode('setderef',syminf.env_index,value)
    return self.setCode('setlocal',syminf.locals_index,value)
</t>
<t tx="ekr.20040227065519.433">def getDeclarations(self):
    if len(self.temporaries) == 0:
        return []

    decs = [jast.SimpleComment("Temporary Variables")]
    for type, temps in self.temporaries.items():
        names = []
        for index in range(len(temps)):
            names.append("t$%d$%s" % (index, type.replace("[]", "__")))
        ident = "%s %s" % (type, COMMASPACE.join(names))
        decs.append(jast.Identifier(ident))
    decs.append(jast.Blank)
    return decs 
</t>
<t tx="ekr.20040227065519.434">


class GlobalFrame(LocalFrame):
	@others
</t>
<t tx="ekr.20040227065519.435">def __init__(self, compiler):
    LocalFrame.__init__(self, compiler)
</t>
<t tx="ekr.20040227065519.436">def setScope(self,scope): self.scope = scope
</t>
<t tx="ekr.20040227065519.437">
class ClassFrame(LocalFrame):
	@others
</t>
<t tx="ekr.20040227065519.438">def getnames(self):
    return []
</t>
<t tx="ekr.20040227065519.439">
class FunctionFrame(LocalFrame):
	@others
</t>
<t tx="ekr.20040227065519.440">def __init__(self,compiler,scope):
    LocalFrame.__init__(self,compiler,scope=scope)
    self.fast_locals = 1
    self.opt_globals = not scope.exec and not scope.from_import_star
</t>
<t tx="ekr.20040227065519.441">

class SimpleCompiler(BaseEvaluator, CompilationContext):
	@others
</t>
<t tx="ekr.20040227065519.442">def __init__(self, module, factory, parent=None, frameCtr=None, scope=None,
             options=None, className=None):
    BaseEvaluator.__init__(self)

    if parent is None:
        frame = GlobalFrame(self)
        self.parent_compiler = None
        self.top_compiler = self
    else:
        frame = frameCtr(self, scope=scope)
        self.parent_compiler = parent
        self.top_compiler = parent.top_compiler

    self.frame = frame
    self.module = module
    self.nthrowables = 0
    self.factory = factory
    self.options = options
    self.className = className
    self.listComprehensionStack = []

    self.free_decls = []
</t>
<t tx="ekr.20040227065519.443">def isAlwaysFalse(self, name):
    if self.options is None:
        return 0
    return name in self.options.falsenames
</t>
<t tx="ekr.20040227065519.444">def getFutures(self):
    return self._futures
</t>
<t tx="ekr.20040227065519.445">def getFilename(self):
    return self.module.filename
</t>
<t tx="ekr.20040227065519.446">def error(self,msg,err,node):
    if not err:
        try:
            warnings.warn_explicit(msg,SyntaxWarning,self.getFilename(),node.beginLine)
            return
        except Exception,e:
            if not isinstance(e,SyntaxWarning): raise e
    raise ParseException(msg,node)
</t>
<t tx="ekr.20040227065519.447">def parse(self, node):
    if isinstance(self.frame,GlobalFrame):
        futures = self._futures = Future()
        futures.preprocessFutures(node,None)
        ScopesCompiler(self).parse(node)
        self.frame.setScope(node.scope)
    ret = BaseEvaluator.parse(self, node)
    #print 'parse', ret
    decs = self.free_decls + self.frame.getDeclarations()
    if len(decs) != 0:
        return [decs, jast.SimpleComment('Code'), ret]
    else:
        return ret
</t>
<t tx="ekr.20040227065519.448">def makeTemp(self, value):
    tmp = self.frame.gettemp('PyObject')
    setit = jast.Set(tmp, value.asAny())
    return self.factory.makePyObject(tmp), setit
</t>
<t tx="ekr.20040227065519.449">def freeTemp(self, tmp):
    self.frame.freetemp(tmp.asAny())
</t>
<t tx="ekr.20040227065519.450">def makeFreeDecl(self,type,value):
    self.free_decls.append(jast.Declare(type,value))
</t>
<t tx="ekr.20040227065519.451">#primitive values
def int_const(self, value):
    return self.factory.makeInteger(value)
</t>
<t tx="ekr.20040227065519.452">def long_const(self, value):
    return self.factory.makeLong(value)
</t>
<t tx="ekr.20040227065519.453">def complex_const(self, value):
    return self.factory.makeImaginary(value)
</t>
<t tx="ekr.20040227065519.454">def float_const(self, value):
    return self.factory.makeFloat(value)
</t>
<t tx="ekr.20040227065519.455">def string_const(self, value):
    return self.factory.makeString(value)
</t>
<t tx="ekr.20040227065519.456">def ellipsis_const(self):
    return self.factory.makeEllipsis()
</t>
<t tx="ekr.20040227065519.457"># builtin types
def visitall(self, values):
    ret = []
    for value in values:
        ret.append(self.visit(value))       
    return ret
</t>
<t tx="ekr.20040227065519.458">def list_op(self, values):
    return self.factory.makeList(self.visitall(values))
</t>
<t tx="ekr.20040227065519.459">def list_comprehension(self, node):
    # Since this code generated here is placed in its own 
    # java method, we need a new set of temp vrbls.
    oldtmps = self.frame.temporaries
    self.frame.temporaries = {}

    expr = node.getChild(0)
    suite = node.getChild(1)
    lst = self.factory.makeList([])

    lsttmp, lstcode = self.makeTemp(lst)

    append = self.factory.makePyObject(jast.Invoke(lsttmp.asAny(),
                 "__getattr__", [jast.StringConstant("append")]))

    appendtmp, appendcode = self.makeTemp(append)

    self.listComprehensionStack.append((appendtmp, expr))

    stmts = [lstcode, appendcode]
    stmts.append(self.visit(suite))
    stmts.append(jast.Return(lsttmp.asAny()))

    decs = self.frame.getDeclarations()
    if len(decs) != 0:
        stmts.insert(0, decs)

    self.listComprehensionStack.pop(-1)

    idx = self.module.addFunctionCode("__listcomprehension", 
          jast.Block(stmts))

    self.freeTemp(lsttmp)
    self.freeTemp(appendtmp)

    self.frame.temporaries = oldtmps

    return self.factory.makePyObject(
               jast.InvokeLocal("__listcomprehension$%d" % (idx+1), 
                       [jast.Identifier("frame")]))
</t>
<t tx="ekr.20040227065519.460">def list_iter(self, node):
    if node.getNumChildren() == 0:
        append, expr = self.listComprehensionStack[-1]
        return [jast.Invoke(append.asAny(), "__call__",
                                     [self.visit(expr).asAny()])]

    return self.visit(node.getChild(0))
</t>
<t tx="ekr.20040227065519.461">def tuple_op(self, values):
    return self.factory.makeTuple(self.visitall(values))
</t>
<t tx="ekr.20040227065519.462">def dictionary_op(self, items):
    lst = []
    for key, value in items:
        lst.append( (self.visit(key), self.visit(value)) )
    return self.factory.makeDictionary(lst)
</t>
<t tx="ekr.20040227065519.463">#namespaces
def set_name(self, name, value):
    return self.frame.setname(name, value)
</t>
<t tx="ekr.20040227065519.464">def del_name(self, name):
    return self.frame.delname(name)
</t>
<t tx="ekr.20040227065519.465">def name_const(self, name):
    return self.frame.getname(name)
</t>
<t tx="ekr.20040227065519.466">def global_stmt(self, names):
    return jast.SimpleComment('global ' + COMMASPACE.join(names))
</t>
<t tx="ekr.20040227065519.467">def get_module(self, names, topmost=0):
    ret = self.factory.importName(names[0])
    top = ret

    for part in names[1:]:
        ret = ret.getattr(part)
    if topmost:
        return top
    else:
        return ret
</t>
<t tx="ekr.20040227065519.468">def importall_stmt(self, module):
    modname = jast.StringConstant(module.value.name)
    self.addModule(module.value.name, '*')
    #print 'import *', module.value.name
    self._loadNames(self._getnames(module), module)
    return jast.InvokeStatic("org.python.core.imp", "importAll",
                             [modname, self.frame.frame])
</t>
<t tx="ekr.20040227065519.469">def _getnames(self, module):
    #print module.value, module.value.__class__
    mod = ImportName.lookupName(module.value.name)
    if mod:
        return dir(mod.mod)
    return []
</t>
<t tx="ekr.20040227065519.470"># Stolen from imp.loadNames.
def _loadNames(self, names, module):
    for name in names:
        if name == "__all__":
            loadNames(module.getattr(name).value, module)
        elif name[:2] == "__":
            continue;
        else:
            self.set_name(name, module.getattr(name))
</t>
<t tx="ekr.20040227065519.471">def import_stmt(self, names):
    ret = []
    for dotted, asname in names:
        modnameConst = jast.StringConstant(".".join(dotted))
        if asname:
            code = jast.InvokeStatic("org.python.core.imp","importOneAs",
                                     [modnameConst, self.frame.frame])
            code = self.get_module(dotted,0).makeReference(code)
            ret.append(self.set_name(asname,code))
        else:
            code = jast.InvokeStatic("org.python.core.imp","importOne",
                                     [modnameConst, self.frame.frame])
            code = self.get_module(dotted,1).makeReference(code)
        	ret.append(self.set_name(dotted[0],code))
    return ret
</t>
<t tx="ekr.20040227065519.472">def getSlice(self, index):
    indices = self.visitor.getSlice(index)
    ret = []
    for index in indices:
        if index is None:
            ret.append(self.factory.makeNull())
        else:
            ret.append(self.visit(index))
    return ret
</t>
<t tx="ekr.20040227065519.473">def slice_op(self, s0, s1, s2):
    ret = []
    for index in (s0, s1, s2):
        if index is None:
            ret.append(self.factory.makeNull())
        else:
            ret.append(self.visit(index))
    return  self.factory.makeSlice(ret)
</t>
<t tx="ekr.20040227065519.474">def bool_op(self, x, y, swap=0):
    tmp = self.frame.gettemp("PyObject")
    test = jast.Invoke(jast.Set(tmp, self.visit(x).asAny()),
                       "__nonzero__", [])
    yes, no = tmp, self.visit(y).asAny()
    if swap:
        yes, no = no, yes

    op = self.factory.makePyObject(jast.TriTest(test, yes, no))
    self.frame.freetemp(tmp)
    return op
</t>
<t tx="ekr.20040227065519.475">def and_op(self, x, y):
    return self.bool_op(x, y, 1)
</t>
<t tx="ekr.20040227065519.476">def or_op(self, x, y):
    return self.bool_op(x, y, 0)
</t>
<t tx="ekr.20040227065519.477">#flow control
def do_comp(self, x, compares, tmps):
    False = jast.GetStaticAttribute("Py", "Zero")

    op, other = compares[0]
    y = self.visit(other)
    if len(compares) &gt; 1:
        ytmp = self.frame.gettemp("PyObject")
        tmps.append(ytmp)
        gety = self.factory.makePyObject(jast.Set(ytmp, y.asAny()))
    else:
        gety = y

    test = x.compop(op, gety)

    if len(compares) == 1:
        return test.asAny()

    rest = self.do_comp(self.factory.makePyObject(ytmp),
                        compares[1:],
                        tmps)
    return jast.TriTest(test.nonzero(), rest, False)
</t>
<t tx="ekr.20040227065519.478">def compare_op(self, start, compares):
    x = self.visit(start)

    tmps = []
    ret = self.do_comp(x, compares, tmps)
    for tmp in tmps:
        self.frame.freetemp(tmp)
    return self.factory.makePyObject(ret)
</t>
<t tx="ekr.20040227065519.479">def print_line(self, value=None):
    if value is None:
        return jast.InvokeStatic("Py", "println", [])
    else: 
        return self.visit(value).print_line()
</t>
<t tx="ekr.20040227065519.480">def print_line_to(self, file, value=None):
    f = self.visit(file)
    if value is None:
        return f.print_line_to()
    else:
        return f.print_line_to(self.visit(value).asAny())
</t>
<t tx="ekr.20040227065519.481">def print_continued_to(self, file, value):
    f = self.visit(file)
    if value is None:
        return f.print_continued_to()
    else:
        return f.print_continued_to(self.visit(value).asAny())
</t>
<t tx="ekr.20040227065519.482">def pass_stmt(self):
    return jast.SimpleComment("pass")
</t>
<t tx="ekr.20040227065519.483">def continue_stmt(self):
    return jast.Continue()
</t>
<t tx="ekr.20040227065519.484">def break_stmt(self):
    return jast.Break()
</t>
<t tx="ekr.20040227065519.485">def exec_stmt(self, code, globs=None, locs=None):
    if globs is None:
        globCode = jast.Null
    else:
        globCode = globs.asAny()

    if locs is None:
        locCode = jast.Null
    else:
        locCode = locs.asAny()

    return jast.InvokeStatic("Py", "exec",
                             [code.asAny(), globCode, locCode])
</t>
<t tx="ekr.20040227065519.486">def assert_stmt(self, test, message=None):
    if self.isAlwaysFalse("__debug__"):
        return jast.SimpleComment("assert")

    args = [test.asAny()]
    if message is not None:
        args.append(message.asAny())

    return jast.If(self.frame.getglobal("__debug__").nonzero(),
                   jast.InvokeStatic("Py", "assert", args))
</t>
<t tx="ekr.20040227065519.487">def return_stmt(self, value=None):
    if value is None:
        return jast.Return(jast.GetStaticAttribute("Py", "None"))
    else:
        return jast.Return(self.visit(value).asAny())
</t>
<t tx="ekr.20040227065519.488">def raise_stmt(self, exc_type=None, exc_value=None, exc_traceback=None):
    if exc_type is None:
        return jast.Throw(jast.InvokeStatic("Py", "makeException", []))
    return exc_type.doraise(exc_value, exc_traceback)
</t>
<t tx="ekr.20040227065519.489">def while_stmt(self, test, body, else_body=None):
    stest = self.visit(test).nonzero()
    sbody = jast.Block(self.visit(body))
    if else_body is not None:
        else_body = jast.Block(self.visit(else_body))
        wtmp = self.frame.gettemp('boolean')
        ret = jast.WhileElse(stest, sbody, else_body, wtmp)
        self.frame.freetemp(wtmp)
        return ret
    else:
        return jast.While(stest, sbody)
</t>
<t tx="ekr.20040227065519.490">def if_stmt(self, tests, else_body=None):
    jtests = []
    for test, body in tests:
        tname = self.getName(test)
        if tname is not None and self.isAlwaysFalse(tname):
            continue
        test = self.visit(test).nonzero()
        body = jast.Block(self.visit(body))
        jtests.append( (test, body) )

    if else_body is not None:
        else_body = jast.Block(self.visit(else_body))

    if len(jtests) == 0:
        if else_body is None:
            return jast.SimpleComment("if "+tname)
        else:
            return else_body

    if len(jtests) == 1:
        return jast.If(jtests[0][0], jtests[0][1], else_body)
    else:
        return jast.MultiIf(jtests, else_body)
</t>
<t tx="ekr.20040227065519.491">def tryfinally(self, body, finalbody):
    return jast.TryFinally(jast.Block(self.visit(body)),
                           jast.Block(self.visit(finalbody)))
</t>
<t tx="ekr.20040227065519.492">def tryexcept(self, body, exceptions, elseClause=None):
    if elseClause is not None:
        elseBool = self.frame.gettemp("boolean")

    jbody = jast.Block(self.visit(body))
    tests = []
    ifelse = None

    tname = jast.Identifier("x$%d" % self.nthrowables)
    self.nthrowables = self.nthrowables + 1

    exctmp = self.frame.gettemp("PyException")
    setexc = jast.Set(exctmp, jast.InvokeStatic("Py", "setException",
                                                [tname, self.frame.frame]))

    for exc, ebody in exceptions:
        if exc is None:
            ifelse = jast.Block(self.visit(ebody))
            continue

        t = jast.InvokeStatic("Py", "matchException",
                              [exctmp, exc[0].asAny()])
        newbody = []

        if len(exc) == 2:
            exceptionValue = self.factory.makePyObject(
                jast.GetInstanceAttribute(exctmp, "value"))
            #print exc[1], exceptionValue
            newbody.append(self.set(exc[1], exceptionValue))
            #print newbody

        #print self.visit(ebody)
        newbody.append(self.visit(ebody))
        #print newbody
        #print jast.Block(newbody)
        tests.append( (t, jast.Block(newbody)) )

    if ifelse is None:
        ifelse = jast.Throw(exctmp)

    if len(tests) == 0:
        catchBody = ifelse
    else:
        catchBody = jast.MultiIf(tests, ifelse)

    catchBody = [setexc, catchBody]

    if elseClause is not None:
        catchBody = [jast.Set(elseBool, jast.False), catchBody]

    catchBody = jast.Block([catchBody])

    self.frame.freetemp(exctmp)

    ret = jast.TryCatch(jbody, "Throwable", tname, catchBody)

    if elseClause is not None:
        ret = jast.Block([jast.Set(elseBool, jast.True), ret, 
                          jast.If(elseBool,
                                  jast.Block(self.visit(elseClause)))])
        self.frame.freetemp(elseBool)

    return ret
</t>
<t tx="ekr.20040227065519.493">def for_stmt(self, index, sequence, body, else_body=None):
    counter = self.frame.gettemp('int')
    item = self.factory.makePyObject(self.frame.gettemp("PyObject"))
    seq = self.frame.gettemp("PyObject")

    init = []
    init.append( jast.Set(counter, jast.IntegerConstant(0)) )
    init.append( jast.Set(seq, self.visit(sequence).asAny()) )

    counter_inc = jast.PostOperation(counter, '++')

    test = jast.Set(item.asAny(), jast.Invoke(seq, "__finditem__",
                                              [counter_inc]))
    test = jast.Operation('!=', test, jast.Identifier('null'))

    suite = []
    suite.append(self.set(index, item))
    suite.append(self.visit(body))
    suite = jast.Block(suite)

    if else_body is not None:
        else_body = jast.Block(self.visit(else_body))
        wtmp = self.frame.gettemp('boolean')
        ret = [init, jast.WhileElse(test, suite, else_body, wtmp)]
        self.frame.freetemp(wtmp)
        return ret
    else:
        return [init, jast.While(test, suite)]
</t>
<t tx="ekr.20040227065519.494">def funcdef(self, name, scope, body, doc=None):
    self.frame.setupClosure(scope)
    func = self.factory.makeFunction(name, self, scope, body, doc)
    return self.set_name(name, func)
</t>
<t tx="ekr.20040227065519.495">def lambdef(self, scope, body):
    self.frame.setupClosure(scope)
    func = self.factory.makeFunction("&lt;lambda&gt;", self, scope, body)
    return func
</t>
<t tx="ekr.20040227065519.496">def classdef(self, name, bases, scope, body, doc=None):
    self.frame.setupClosure(scope)
    c = self.factory.makeClass(name, bases, self, scope, body, doc)
    self.module.classes[name] = c
    return self.set_name(name, c)
</t>
<t tx="ekr.20040227065519.497">def addModule(self, mod, value=1):
    #print 'add module', mod
    if self.module.imports.has_key(mod) and value == 1:
        return
    self.module.imports[mod] = (value, self.module)
</t>
<t tx="ekr.20040227065519.498">def addSetAttribute(self, obj, name, value):
    #print ' add set attribute', name, value
    self.module.addAttribute(name, value)
</t>
<t tx="ekr.20040227065519.499">@ignore
@language python
&lt;&lt; compile declarations &gt;&gt;
@others

if __name__ == '__main__':
    import sys
    filenames = sys.argv[1:]
    print filenames
    outdir = "."
    files = []
    for filename in filenames:
        outdir = os.path.dirname(filename)
        classname = os.path.splitext(os.path.basename(filename))[0]
        files.append( (filename, classname) )
    files, javaclasses = compile(files, outdir)

    #sys.exit() 

    print 'Building archive...'
    from jar import JavaArchive
    ja = JavaArchive([('org.python.core', []),])
    for jc in javaclasses:
        ja.addClass(outdir, jc)
    outjar = "c:\\jpython\\tools\\jpythonc2\\test\\t.jar"       
    ja.dump(outjar)
</t>
<t tx="ekr.20040227065519.500"># Copyright (c) Corporation for National Research Initiatives

import sys
import os
from types import StringType

from SimpleCompiler import SimpleCompiler
from PythonModule import PythonModule
from ObjectFactory import ObjectFactory
from Object import PyObject

import jast
import ImportName
import javac
import proxies

import java
import org
from java.lang import *



</t>
<t tx="ekr.20040227065519.501">def getdata(filename):
    fp = open(filename, "r")
    data = fp.read()
    fp.close()
    return data
</t>
<t tx="ekr.20040227065519.502">def getsig(doc, pargs, constructor=0):
    SPACE = ' '
    if doc is None:
        return None
    #print doc
    lines = doc.split("\n")
    txt = None
    for line in lines:
        line = line.strip()
        if line.startswith("@sig "):
            txt = line[5:]
            break
    if txt is None:
        return None
    front, back = txt.split("(")
    back = back[:-1].strip()
    front = front.split()
    if constructor:
        ret = jret = None
        mods = SPACE.join(front[:-1])
    else:
        ret = front[-2]
        mods = SPACE.join(front[:-2])
        jret = insistJavaClass(ret)
    arglist = []
    if len(back) &gt; 0:
        for arg in back.split(','):
            c, name = arg.split()
            jc = insistJavaClass(c)
            arglist.append( (jc, name) )
    sigs = []
    for ndefaults in range(0, len(pargs.defaults)+1):
        sigs.append( (mods, jret, arglist[:len(arglist)-ndefaults], []) )
    return sigs
</t>
<t tx="ekr.20040227065519.503">
primitives = {'void'   : Void.TYPE,
              'int'    : Integer.TYPE,
              'byte'   : Byte.TYPE, 
              'short'  : Short.TYPE,
              'long'   : Long.TYPE,
              'float'  : Float.TYPE,
              'double' : Double.TYPE,
              'boolean': Boolean.TYPE,
              'char'   : Character.TYPE,
              }


def insistJavaClass(c):
    jc = getJavaClass(c)
    if jc is None and isinstance(c, StringType):
        jc = getJavaClass("java.lang."+c)
    if jc is None:
        raise ValueError, "can not find class: "+c
    return jc
</t>
<t tx="ekr.20040227065519.504">
primNames = {'void'   : 'V',
             'int'    : 'I',
             'byte'   : 'B', 
             'short'  : 'S',
             'long'   : 'J',
             'float'  : 'F',
             'double' : 'D',
             'boolean': 'Z',
             'char'   : 'C'
             }


##def makeArrayName(c):
##    if c.endswith("[]"):
##        return "["+makeArrayName(c[:-2])
##    else:
##        if primNames.has_key(c):
##            return primNames[c]
##        else:
##            return "L"+c+";"

import util
def getJavaClass(c):
    if isinstance(c, StringType):
        if primitives.has_key(c):
            return primitives[c]
        if c.endswith("[]"):
            # java1.1 allows only this
            el = getJavaClass(c[:-2])
            if el == None:
                return None
            return Class.getClass(reflect.Array.newInstance(el,0))
        try:
            return util.findClass(c) #Class.forName(c)
        except:
            return None
    elif isinstance(c, ImportName.JavaClass):
        return c.mod #Class.forName(c.name)
    elif isinstance(c, Class):
        return c
    else:
        return None
</t>
<t tx="ekr.20040227065519.505">



def printNames(heading, dict):
    items = dict.items()
    if len(items) == 0:
        return

    print       
    print heading

    items1 = []
    for key, value in items:
        if hasattr(key, '__name__'):
            key = key.__name__  
        value = value.keys()
        items1.append( (key, value) )

    items1.sort()
    COMMA = ', '
    for key, value in items1:
        print '  %s used in %s' % (key, COMMA.join(value))
</t>
<t tx="ekr.20040227065519.506">


class Compiler:
	&lt;&lt; class Compiler declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040227065519.507"># TBD: Bad! But this modules dicts must be available from deep in
# ObjectFactory.
allmodules = {}

</t>
<t tx="ekr.20040227065519.508">def __init__(self, javapackage=None, deep = 1, skip=(), 
             include=('org.python.modules', 'org.apache.oro.text.regex'),
             options=None):
    self.javapackage = javapackage
    self.deep = deep
    self.packages = {}
    self.events = {}
    self.depends = {}
    self.modules = {}
    self.javasources = []
    self.files = []
    self.javaclasses = []
    self.javadepends = {}
    self.pypackages = {}
    PyObject.attributes = {}
    self.skip = skip
    self.dependencies = {}
    self.include = include
    self.options = options
</t>
<t tx="ekr.20040227065519.509">def write(self, msg):
    print msg
</t>
<t tx="ekr.20040227065519.510">def compilefile(self, filename, name):
    filename = java.io.File(filename).getCanonicalPath()

    if self.modules.has_key(filename):
        return
    self.write('processing %s' % name)

    self.modules[filename] = 1
    mod = self.compile(getdata(filename), filename, name)
    self.modules[filename] = mod
    Compiler.allmodules[name] = mod
</t>
<t tx="ekr.20040227065519.511">def compile(self, data, filename, name):
    if self.javapackage is not None:
        name = self.javapackage+'.'+name

    data = data + '\n\n'
    
    mod = PythonModule(name, filename, frozen=self.deep)
    fact = ObjectFactory()
    pi = SimpleCompiler(mod, fact, options=self.options)
    fact.parent = pi
    code = pi.execstring(data)
    # __file__ 
    code.insert(0,jast.Invoke(jast.Identifier('frame'),"setglobal",
                              [jast.StringConstant('__file__'),
                               mod.getStringConstant(filename)]))
    code.insert(1,jast.BlankLine())
    code = jast.Block(code)
    mod.addMain(code, pi)
    self.addDependencies(mod)
    return mod
</t>
<t tx="ekr.20040227065519.512">def addJavaClass(self, name, parent):
    #print 'add java class', name

    for package in self.include:
        if name[:len(package)+1] == package+'.':
            ps = self.javadepends.get(name, [])
            ps.append(parent)
            if len(ps) == 1:
                self.javadepends[name] = ps
</t>
<t tx="ekr.20040227065519.513">def addDependency(self, m, attrs, mod, value=1):
    if m is None:
        return

    if isinstance(m, ImportName.Package):
        if value == '*':
            self.packages[m.name] = m.getClasses()
        else:
            if not self.packages.has_key(m.name):
                self.packages[m.name] = None
    elif isinstance(m, ImportName.Module):
        if m.file is None:
            if m.path is not None:
                file = os.path.join(m.path[0], '__init__.py')
                name = m.name+'.__init__'
                self.depends[file] = name
                self.pypackages[m.path[0]] = m.name
        else:
            self.depends[m.file] = m.name
    elif isinstance(m, ImportName.JavaClass):
        m.addEvents(attrs, self.events, mod.name)
        self.addJavaClass(m.name, mod.name)
    elif isinstance(m, ImportName.Resource):
        self.javadepends[m.name] = mod.name

    if self.dependencies.has_key(m):
        return
    self.dependencies[m] = 1
    for depend in m.getDepends():
        #print 'depends on', depend
        self.addDependency(depend, attrs, mod)
</t>
<t tx="ekr.20040227065519.514">def addDependencies(self, mod):
    attrs = PyObject.attributes
    PyObject.attributes = {}
    #print '  attrs', attrs.keys()

    for name, (value, module) in mod.imports.items():
        #print '  depends', name
        if module.package:
            m = ImportName.lookupName(module.package + '.' + name)
            if m is None:
                m = ImportName.lookupName(name)
        else:
            m = ImportName.lookupName(name)
        self.addDependency(m, attrs, mod, value)            

    if self.deep:
        for filename, name in self.depends.items():
            #self.write('%s requires %s' % (mod.name, name))
            if name in self.skip:
                self.write('  %s skipping %s' % (mod.name, name))
            self.compilefile(filename, name)
</t>
<t tx="ekr.20040227065519.515">def filterpackages(self):
    DOT = '.'
    prefixes = {}
    for name in self.packages.keys():
        parts = name.split('.')
        for i in range(1, len(parts)):
            prefixes[DOT.join(parts[:i])] = 1
    #print prefixes
    for name, value in self.packages.items():
        if value is not None:
            continue

        if prefixes.has_key(name):
            del self.packages[name]
</t>
<t tx="ekr.20040227065519.516">def makeJavaProxy(self, module, pyc):
    frame = pyc.frame
    methods = []
    for name, func in frame.names.items():
        v = func.value
        args = None
        if hasattr(v, 'frame'):
            args = v.frame.scope.ac
        sig = None
        if hasattr(v, 'doc'):
            if name == "__init__":
                sig = getsig(v.doc, args, constructor=1)
            else:
                sig = getsig(v.doc, args, constructor=0)
        methods.append( (name, args, sig) )
    if pyc.isSuperclassJava():
        supername, pySupername = pyc.supername, pyc.pySupername
        return proxies.JavaProxy(pyc.name, (supername, pySupername), 
                                pyc.javaclasses, methods, module, pyc.issuperproxy)
    return None
</t>
<t tx="ekr.20040227065519.517">def preprocessModule(self, mod):
    self.write('  %s module' % mod.name)
    proxyClasses = []
    mainProxy = None
    for name, pyc in mod.classes.items():
        proxy = self.makeJavaProxy(mod, pyc.value)
        if proxy is None:
            continue

        self.write('    '+proxy.getDescription())

        if name == mod.name:
            mainProxy = proxy
        else:
            proxyClasses.append(proxy)

    mod.packages = self.packages
    #print self.packages
    specialClasses = {}
    pkg = mod.package
    if pkg is None:
        pkg = ""
    else:
        pkg = pkg+'.'

    if mainProxy is not None:
        mod.javaproxy = mainProxy
        specialClasses[mod.name+'.'+mainProxy.name] = pkg+mod.name

    for proxy in proxyClasses:
        proxy.modifier = "public static"
        mod.innerClasses.append(proxy)
        specialClasses[mod.name+'.'+proxy.name] = \
                                                pkg+mod.name+'$'+proxy.name

    mod.specialClasses = specialClasses
</t>
<t tx="ekr.20040227065519.518">def processModule(self,mod,outdir):
    self.javasources.append(mod.dump(outdir))
    if self.options.bean is not None:
        mod.javaclasses[0] = mod.javaclasses[0], {'Java-Bean':'True'}
    self.javaclasses.extend(mod.javaclasses)
</t>
<t tx="ekr.20040227065519.519">def displayPackages(self):
    print
    print 'Required packages:'
    for package, classes in self.packages.items():
        if classes is None:
            print '  '+package
        else:
            print '  '+package+'*'
</t>
<t tx="ekr.20040227065519.520">def dump(self, outdir):
    self.filterpackages()
    self.displayPackages()
    adapters = {}
    for jc, sources in self.events.items():
        adapters[jc] = sources.keys()

    self.write('\nCreating adapters:')
    COMMA = ', '
    for adapter, sources in adapters.items():
        self.write('  %s used in %s' % \
                       (adapter.__name__, COMMA.join(sources)))
        self.makeAdapter(outdir, adapter)

    self.write('\nCreating .java files:')
    for filename, mod in self.modules.items():
        mod.modules = Compiler.allmodules
        self.preprocessModule(mod)

    #self.write('\n...')

    for filename, mod in self.modules.items():
        self.processModule(mod,outdir)
    
    self.java2class(outdir)
</t>
<t tx="ekr.20040227065519.521">def java2class(self, outdir):
    if self.options.compiler == "NONE":
        self.write('\nLeaving .java files, no compiler specified')
        return
    self.write('\nCompiling .java to .class...')
    code, outtext, errtext = javac.compile(
        self.javasources,
        javac=self.options.compiler,
        options=self.options.jopts,
        sourcedir=outdir)
    print code, outtext, errtext
</t>
<t tx="ekr.20040227065519.522">if code &lt;&gt; 0:
    print 'ERROR DURING JAVA COMPILATION... EXITING'
    sys.exit(code)

def makeAdapter(self, outdir, proxy):
    os = java.io.ByteArrayOutputStream()
    adaptername = org.python.compiler.AdapterMaker.makeAdapter(proxy, os)
    filename = writeclass(outdir, adaptername, os)
    self.javaclasses.append(adaptername)
</t>
<t tx="ekr.20040227065519.523">def trackJavaDependencies(self):
    # TBD: huh?
    if len(self.javadepends) == 0: []

    from depend import depends
    done = {}
    self.write('Tracking java dependencies:')
    indent = 1
    while len(done) &lt; len(self.javadepends):
        for name, parents in self.javadepends.items():
            if done.has_key(name):
                continue
            self.write(('  '*indent)+name)
            ze, jcs = depends(name)
            done[name] = ze
            for jc in jcs:
                self.addJavaClass(jc, name)
        #print len(done), len(self.javadepends)
        indent = indent+1
    return done.values()
</t>
<t tx="ekr.20040227065519.524">
from java.io import *

def writefile(filename, instream):
    file = File(filename)
    File(file.getParent()).mkdirs()
    outstream = FileOutputStream(file)  
    instream.writeTo(outstream)
</t>
<t tx="ekr.20040227065519.525">def writeclass(outdir, classname, stream):
    filename = apply(os.path.join, tuple(classname.split('.')))+'.class'
    filename = os.path.join(outdir, filename)
    writefile(filename, stream)
    return filename
</t>
<t tx="ekr.20040227065519.526">def compile(files, outdir):
    c = Compiler()
    for filename, classname in files:
        c.compilefile(filename, classname)
    c.dump(outdir)
    return c.files, c.javaclasses
</t>
<t tx="ekr.20040227065519.527">@ignore
@language python
&lt;&lt; depend declarations &gt;&gt;
@others


if __name__ == '__main__':
    #print getFile('org.python.modules.strop')
    #print getFile('java.lang.String')

    #print depend('com.oroinc.text.regex.Perl5Matcher')
    for name in ['javax.swing.JButton', 'java.lang.String']:
        print depends(name)
</t>
<t tx="ekr.20040227065519.528"># Copyright (c) Corporation for National Research Initiatives

import sys
import os
from types import TypeType

from java import io
from java.util.zip import ZipFile



</t>
<t tx="ekr.20040227065519.529">def fix(n):
    DOT = '.'
    return DOT.join(n.split('/'))
</t>
<t tx="ekr.20040227065519.530">def unfix(n):
    SLASH = '/'
    return SLASH.join(n.split('.'))
</t>
<t tx="ekr.20040227065519.531">def getClass(t, names):
    #print t, names
    if t[0] == '(':
        index = 1
        while index &lt; len(t) and t[index] != ')':
            off, value = getClass(t[index:], names)
            index = index+off
        getClass(t[index+1:], names)
    elif t[0] == 'L':
        end = t.index(';')
        value = t[1:end]
        names[fix(value)] = 1
        return end, t[1:end]
    elif t[0] == '[':
        off, ret = getClass(t[1:], names)
        return off+1, ret
    else:
        return 1, None
</t>
<t tx="ekr.20040227065519.532">
def dependencies(file):
    data = io.DataInputStream(file)

    data.readInt()
    data.readShort()
    data.readShort()

    n = data.readShort()

    strings = [None]*n
    classes = []
    types = []

    i = 0
    while i &lt; n-1:
        tag = data.readByte()
        if tag == 1:
            name = data.readUTF()
            strings[i] = name
        elif tag == 7:
            classes.append(data.readShort())
        elif tag == 9 or tag == 10 or tag == 11:
            data.readShort()
            data.readShort()
        elif tag == 8:
            data.readShort()
        elif tag == 3:
            data.readInt()
        elif tag == 4:
            data.readFloat()
        elif tag == 5:
            data.readLong()
            i = i+1
        elif tag == 6:
            data.readDouble()
            i = i+1
        elif tag == 12:
            data.readShort()
            types.append(data.readShort())
        i = i+1
    data.readShort() # access_flags
    data.readShort() # this_class
    data.readShort() # super_class

    interfaces_count = data.readShort()
    for i in range(interfaces_count):
        data.readShort()

    fields_count = data.readShort()
    for i in range(fields_count):
        data.readShort() # access_flags
    	data.readShort() # name_index
        types.append(data.readShort())
        attributes_count = data.readShort()
        for j in range(attributes_count):
            data.readShort() # attribute_name_index 
            attribute_length = data.readInt()
            data.skip(attribute_length)

    names = {}
    for c in classes:
        #print c, strings[c-1]
        name = fix(strings[c-1])
        if name[0] == '[':
            continue
        names[name]= 1

    for t in types:
        getClass(strings[t-1], names)

    return filter(defaultFilter, names.keys())
</t>
<t tx="ekr.20040227065519.533">
def defaultFilter(name):
    return not (name[:5] == 'java.' or name[:16] == 'org.python.core.')
</t>
<t tx="ekr.20040227065519.534">
from org.python.core import PyJavaPackage
from util import lookup, getzip
from util import openResource
def getFile(name):
    dot = name.rfind('.')
    if dot == -1:
        return PkgEntry(name)
##        return topFile(name)

    package = lookup(name[:dot])
    if isinstance(package, PyJavaPackage):
        return PkgEntry(name)
##    if hasattr(package, '__file__'):
##        return ZipEntry(package.__file__, name)
##    elif hasattr(package, '__path__') and len(package.__path__) == 1:
##        return DirEntry(package.__path__[0], name)
    elif isinstance(package, TypeType):
        # this 'package' is a java class
        f = getFile(name[:dot])
        if f:
            return f
</t>
<t tx="ekr.20040227065519.535">
class PkgEntry:
	@others
</t>
<t tx="ekr.20040227065519.536">def __init__(self, classname):
    self.classname = classname
</t>
<t tx="ekr.20040227065519.537">def __repr__(self):
    return "PkgEntry(%s)" % (self.classname)
</t>
<t tx="ekr.20040227065519.538">def getInputStream(self):
    res = unfix(self.classname) + '.class'
    return openResource(res)
</t>
<t tx="ekr.20040227065519.539">def getZipName(self):
    return '/'.join(self.classname.split('.')) + '.class'
</t>
<t tx="ekr.20040227065519.540">
class ResourceEntry:
	@others
</t>
<t tx="ekr.20040227065519.541">def __init__(self, name):
    self.name = name
</t>
<t tx="ekr.20040227065519.542">def __repr__(self):
    return "ResourceEntry(%s)" % (self.name)
</t>
<t tx="ekr.20040227065519.543">def getInputStream(self):
    import java
    return java.lang.Class.getResourceAsStream("".__class__, self.name)
</t>
<t tx="ekr.20040227065519.544">def getZipName(self):
    return self.name[1:]
</t>
<t tx="ekr.20040227065519.545">
##class ZipEntry:
##    def __init__(self, filename, classname):
##        self.filename = filename
##        self.classname = classname
##
##    def __repr__(self):
##        return "ZipEntry(%s, %s)" % (self.filename, self.classname)
##
##    def getInputStream(self):
##        zf = getzip(self.filename)
##        zfilename = unfix(self.classname) + '.class'
##        entry = zf.getEntry(zfilename)
##        return zf.getInputStream(entry)
##
##
##class DirEntry:
##    def __init__(self, dirname, classname):
##        self.dirname = dirname
##        self.classname = classname
##
##    def __repr__(self):
##        return "DirEntry(%s, %s)" % (self.dirname, self.classname)
##
##    def getInputStream(self):
##        lastname = self.classname.split('.')[-1]
##        fullname = os.path.join(self.dirname, lastname+'.class')
##        return io.FileInputStream(fullname)


def depends(name):
    if name[0] == '/':
        return ResourceEntry(name), []
    ze = getFile(name)
    ip = ze.getInputStream()
    ret = dependencies(ip)
    ip.close()
    return ze, ret
</t>
<t tx="ekr.20040227065519.546">@ignore
@language python
&lt;&lt; jar declarations &gt;&gt;
@others
            
##    # add just one class from a package
##    def addOneClass(self, pkgclass):
##        parts = pkgclass.split('.')
##        package = DOT.join(parts[:-1])
##        pkg = lookup(package)
##        filename = os.path.join(pkg.__path__[0], parts[-1]) + '.class'
##        entryname = '/'.join(parts) + '.class'
##        self.zipfile.putNextEntry(ZipEntry(entryname))
##        instream = FileInputStream(filename)
##        copy(instream, self.zipfile)
##        instream.close()
##
##    # The next three methods handle packages (typically org.python.core, ...)
##    def addPackage(self, package, skiplist=[]):
##        pkg = lookup(package)
##        if hasattr(pkg, '__file__'):
##            return self.addZipPackage(package+'.', pkg.__file__, skiplist)
##        elif hasattr(pkg, '__path__') and len(pkg.__path__) == 1:
##            return self.addDirectoryPackage(package+'.',
##                                            pkg.__path__[0], skiplist)
##        raise ValueError, "can't find package: "+repr(package)
##
##    def addZipPackage(self, package, zipfile, skiplist):
##        zf = ZipFile(zipfile)
##        for entry in zf.entries():
##            filename = entry.name
##            if filename[-6:] != '.class':
##                continue
##            name = filename[:-6].replace(SLASH, DOT)
##
##            if name[:len(package)] != package:
##                continue
##            self.zipfile.putNextEntry(ZipEntry(filename))
##            copy(zf.getInputStream(entry), self.zipfile)
##        zf.close()
##
##    def addDirectoryPackage(self, package, directory, skiplist):
##        for file in os.listdir(directory):
##            if file[-6:] != '.class':
##                continue
##            name = package+file[:-6]
##            if name in skiplist:
##                continue
##            entryname = SLASH.join(name.split('.')) + '.class'
##            self.zipfile.putNextEntry(ZipEntry(entryname))
##            instream = FileInputStream(os.path.join(directory, file))
##            copy(instream, self.zipfile)
##            instream.close()



if __name__ == '__main__':
    root = "c:\\jpython\\tools\\jpythonc2"
    ja = JavaArchive()
    ja.addFile(root, "jar.py")
    ja.addFile(root, "proxies.py")
    ja.addClass(root, "jast.Statement$py")
    print ja.files
    ja.dump(os.path.join(root, "test\\t.jar"))
</t>
<t tx="ekr.20040227065519.547"># Copyright (c) Corporation for National Research Initiatives

import os

import jarray
from java.util.zip import *
from java.io import *
from util import lookup
from util import listAllClasses, openResource

DOT = '.'
SLASH = '/'



</t>
<t tx="ekr.20040227065519.548">def copy(instream, outstream):
    data = jarray.zeros(1024*4, 'b')
    while 1:
        if instream.available() == 0:
            break
        n = instream.read(data)
        if n == -1:
            break
        outstream.write(data, 0, n)
</t>
<t tx="ekr.20040227065519.549">


class JavaArchive:
	@others
</t>
<t tx="ekr.20040227065519.550">def __init__(self, packages=[]):
    self.files = []
    self.entries = []
    self.packages = packages
    self.manifest = []
    self.jar_entries = {}
</t>
<t tx="ekr.20040227065519.551">def addFile(self, rootdir, filename):
    self.files.append( (rootdir, filename) )
</t>
<t tx="ekr.20040227065519.552">def addClass(self, rootdir, classname, properties=None):
    filename = apply(os.path.join, classname.split('.'))+'.class'
    outfile = SLASH.join(filename.split(os.sep))
    if self.jar_entries.has_key(outfile):
        return
    self.jar_entries[outfile] = 1

    self.addFile(rootdir, filename)
    if properties is not None:
        self.manifest.append("Name: "+ SLASH.join(classname.split('.')))
        self.addToManifest(properties)
</t>
<t tx="ekr.20040227065519.553">def addEntry(self, entry):
    outfile = entry.getZipName()
    if self.jar_entries.has_key(outfile):
        return
    self.jar_entries[outfile] = 1

    self.entries.append(entry)
</t>
<t tx="ekr.20040227065519.554">def addToManifest(self, properties=None, **kw):
    if properties is None:
        properties = {}
    properties.update(kw)
    for name, value in properties.items():
        self.manifest.append(name+": "+value)
    self.manifest.append("")
</t>
<t tx="ekr.20040227065519.555">def dumpManifest(self):
    if len(self.manifest) == 0:
        return
    outfile = "META-INF/MANIFEST.MF"
    NL = '\n'
    self.zipfile.putNextEntry(ZipEntry(outfile))
    self.zipfile.write(NL.join(self.manifest))
</t>
<t tx="ekr.20040227065519.556">def dumpFiles(self):
    for rootdir, filename in self.files:
        infile = os.path.join(rootdir, filename)
        outfile = SLASH.join(filename.split(os.sep))
        instream = FileInputStream(infile)
        self.zipfile.putNextEntry(ZipEntry(outfile))
        copy(instream, self.zipfile)
        instream.close()

    for entry in self.entries:
        outfile = entry.getZipName()
        instream = entry.getInputStream()
        self.zipfile.putNextEntry(ZipEntry(outfile))
        copy(instream, self.zipfile)
        instream.close()                    

    for package, skiplist in self.packages:
        self.addPackage(package, skiplist)

    self.dumpManifest()
</t>
<t tx="ekr.20040227065519.557">def dump(self, filename):
    self.zipfile = ZipOutputStream(FileOutputStream(filename))
    self.dumpFiles()
    self.zipfile.close()
</t>
<t tx="ekr.20040227065519.558"># handle packages (typically org.python.core, ...)
def addPackage(self, package, skiplist = []):
    pkg = lookup(package)
    base = package.replace(DOT,SLASH)
    for cl in listAllClasses(pkg):
        name = package+ '.' +cl
        if name in skiplist:
            # print 'skipping',name # ?? dbg
            continue
        entryname = base +'/' + cl + '.class'
        self.zipfile.putNextEntry(ZipEntry(entryname))
        instream = openResource(entryname)
        copy(instream, self.zipfile)
        instream.close()
</t>
<t tx="ekr.20040227065519.559">@ignore
@language python
&lt;&lt; javac declarations &gt;&gt;

@others

if __name__ == '__main__':
    files = ["c:\\jpython\\tools\\jpythonc2\\test\\ButtonDemo.java",
            "c:\\jpython\\tools\\jpythonc2\\test\\pawt.java",]

    print compile(files)
    print compile(files, ["-foo", "bar"])
    print 'done'
</t>
<t tx="ekr.20040227065519.560"># Copyright (c) Corporation for National Research Initiatives

import java, jarray, os, time, sys, thread
from java.lang import System

runtime = java.lang.Runtime.getRuntime()

</t>
<t tx="ekr.20040227065519.561">def dumpStream(stream, txtarr):
    array = jarray.zeros( 1024, 'b' )
    while 1:
        len = stream.read(array)
        if len &lt; 0:
            break
        txtarr.append(array[:len].tostring())
</t>
<t tx="ekr.20040227065519.562">def findDefaultJavac():
    jhome = System.getProperty("java.home")
    if jhome is None:
        return None
    root, dir = os.path.split(jhome)
    if dir.lower() == "jre":
        jhome = root
    javac = os.path.join(os.path.join(jhome, "bin"), "javac")
    return javac
</t>
<t tx="ekr.20040227065519.563">def getClasspath():
    cpath = System.getProperty("java.class.path")
    return cpath
</t>
<t tx="ekr.20040227065519.564">import sys

def compile(files, javac=None, cpathopt="-classpath",
            cpath=None, options=None, sourcedir=None):
    cmd = []
    # Search order for a Java compiler:
    #   1. -C/--compiler command line option
    #   2. python.jythonc.compiler property (see registry)
    #   3. guess a path to javac
    if javac is None:
        javac = sys.registry.getProperty("python.jythonc.compiler")
    if javac is None:
        javac = findDefaultJavac()
    cmd.append(javac)
    # Extra options
    #   1. -J/--compileropts command line option (passed in options)
    #   2. python.jythonc.compileropts property
    if options is None:
        options = sys.registry.getProperty("python.jythonc.compileropts")
        if options:
            options = options.split()
    if options is None:
        options = []
    cmd.extend(options)
    # new:
    # Classpath:
    #   1. python.jythonc.classpath property
    #   +
    #   2. java.class.path property
    #   +
    #   3. sourcedir
    #   +
    #   4. sys.path
    if cpath is None:
        sep = java.io.File.pathSeparator
        cpath = []
        part = sys.registry.getProperty("python.jythonc.classpath")
        if part != None:
            cpath.extend(part.split(sep))
        part = getClasspath()
        if part != None:
            cpath.extend(part.split(sep))
        if sourcedir:
            cpath.append(sourcedir)
        cpath.extend(sys.path)
        cpath = sep.join(cpath)
        if System.getProperty("os.name")[:7] == 'Windows' and \
                        System.getProperty("java.version") &lt; "1.2":
            cpath = '"%s"' % cpath
    cmd.extend([cpathopt, cpath])
    cmd.extend(files)
    print 'Compiling with args:', cmd

    try:
        proc = runtime.exec(cmd)
    except IOError, e:
        msg = '''%s

Consider using the -C/--compiler command line switch, or setting
the property python.jythonc.compiler in the registry.''' % e
        return 1, '', msg
    done = None
    procout = []
    procerr = []
    thread.start_new_thread(dumpStream, (proc.inputStream, procout))
    thread.start_new_thread(dumpStream, (proc.errorStream, procerr))
    while not done:
        proc.waitFor()
	try:
	    proc.exitValue()
	    done = 1
	except java.lang.IllegalThreadStateException:
	    pass
    return (proc.exitValue(), "".join(procout), "".join(procerr))
</t>
<t tx="ekr.20040227065519.565">@ignore
@language python
# Copyright (c) Corporation for National Research Initiatives

# Driver script for jpythonc2.  See module main.py for details
import main
main.main()

import os
os._exit(0)
</t>
<t tx="ekr.20040227065519.566">@ignore
@language python
&lt;&lt; main declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040227065519.567"># Copyright (c) Corporation for National Research Initiatives

"""Usage: jpythonc [options] [module]*

where options include:

  --package package
  -p package
      put all compiled code into the named Java package

  --jar jarfile
  -j jarfile
      Compile into jarfile (implies --deep)

  --deep
  -d
      Compile all Python dependencies of the module 

  --core
  -c
      Include the core JPython libraries (implies --deep)
      
  --all
  -a
      Include all of the JPython libraries (implies --deep)

  --bean jarfile
  -b jarfile
      Compile into jarfile, include manifest for bean
      
  --addpackages packages
  -A packages
      Include Java dependencies from this list of packages.  Default is
      org.python.modules and org.apache.oro.text.regex
      
  --workdir directory
  -w directory
      Specify working directory for compiler (default is ./jpywork)
      
  --skip modules
  -s modules
      Don't include any of these modules in compilation
      
  --compiler path
  -C path
      Use a different compiler than `standard' javac.  If this is set to
      `NONE' then compile ends with .java.  Alternatively, you can set the
      property python.jpythonc.compiler in the registry.

  --compileropts options
  -J options
      Options passed directly to the Java compiler.  Alternatively, you can
      set the property python.jpythonc.compileropts in the registry.

  --falsenames names
  -f names
      A comma-separated list of names that are always false.  Can be used to
      short-circuit if clauses.

  --help
  -h
      Print this message and exit
"""

import sys
import os
import getopt
from types import TupleType

from compile import Compiler
</t>
<t tx="ekr.20040227065519.568"># Standard usage message printing

def usage(errcode, msg=''):
    print __doc__ % globals()
    if msg:
        print msg
    sys.exit(errcode)
</t>
<t tx="ekr.20040227065519.569">def getOptions():
    class Opts:
        jar = None
        workdir = 'jpywork'
        core = 0
        all = 0
        deep = 0
        bean = None
        skip = ''
        package = None
        addfiles = ''
        falsenames = []
        compiler = None
        jopts = None
        addpackages = ''
        
    options = Opts()

    oldopts = ['-jar', '-workdir', '-core', '-all', '-deep',
               '-bean', '-skip', '-package', '-addfiles', '-falsenames',
               '-compiler', '-addpackages']

    # For backwards compatibility, long options used to take only a single
    # dash.  Convert them to GNU style (e.g. as supported by getopt)
    sysargs = []
    for arg in sys.argv[1:]:
        if arg in oldopts:
            newarg = '-'+arg
            print 'Warning:', arg, 'is deprecated, use', newarg
            sysargs.append(newarg)
        else:
            sysargs.append(arg)

    try:
        opts, args = getopt.getopt(
            sysargs, 'p:j:dcab:A:w:s:C:f:J:h',
            ['package=', 'jar=', 'deep', 'core', 'all', 'bean=',
             'addpackages=', 'workdir=', 'skip=', 'compiler=',
             'falsenames=', 'compileropts=', 'help'])
    except getopt.error, msg:
        usage(1, msg)

    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage(0)
        elif opt in ('-p', '--package'):
            options.package = arg
        elif opt in ('-j', '--jar'):
            options.jar = arg
            options.deep = 1
        elif opt in ('-d', '--deep'):
            options.deep = 1
        elif opt in ('-c', '--core'):
            options.core = 1
            options.deep = 1
        elif opt in ('-a', '--all'):
            options.all = 1
            options.deep = 1
        elif opt in ('-b', '--bean'):
            options.bean = arg
        elif opt in ('-A', '--addpackages'):
            options.addpackages = arg
        elif opt in ('-w', '--workdir'):
            options.workdir = arg
        elif opt in ('-s', '--skip'):
            options.skip = arg
        elif opt in ('-C', '--compiler'):
            options.compiler = arg
        elif opt in ('-J', '--compileropts'):
            options.jopts = arg.split()
        elif opt in ('-f', '--falsenames'):
            options.falsenames = arg.split(',')

    # there should be at least one module to compile
    if not args:
        usage(0, 'nothing to compile')

    # post processing
    options.args = args

    if not os.path.isabs(options.workdir):
        options.workdir = os.path.join(os.curdir, options.workdir)  

    return options</t>
<t tx="ekr.20040227065519.570">def addCore(extraPackages):
    skiplist = [ 'org.python.core.parser',
                 #'org.python.core.BytecodeLoader',
                ]
    extraPackages.append(('org.python.core', skiplist))
</t>
<t tx="ekr.20040227065519.571">def addAll(extraPackages):
    for name in ('core', 'compiler', 'parser'):
        extraPackages.append(('org.python.'+name, []))
</t>
<t tx="ekr.20040227065519.572">mainclass = basepath = None

def doCompile(opts):
    global mainclass
    global basepath

    skiplist = opts.skip.split(',')
    optpkgs = opts.addpackages.split(',')
    addpackages = ['org.python.modules',
                   'org.apache.oro.text.regex',
                   ] + optpkgs

    comp = Compiler(javapackage=opts.package,
                    deep=opts.deep,
                    include=addpackages,
                    skip=skiplist,
                    options=opts)

    for target in opts.args:
        if target.endswith('.py'):
            classname = os.path.splitext(os.path.basename(target))[0]
            filename = target
            if basepath is None:
                basepath = os.path.split(target)[0]
                sys.path.insert(0, basepath)
        else:
            classname = target
            import ImportName
            m = ImportName.lookupName(classname)
            if not m:
                print 'Could not find class:', classname
                sys.exit(1)
            filename = m.file
        if mainclass is None:
            mainclass = classname
            if opts.package is not None:
                mainclass = opts.package+'.'+mainclass
        comp.compilefile(filename, classname)

    comp.dump(opts.workdir)
    return comp
</t>
<t tx="ekr.20040227065519.573">def copyclass(jc, fromdir, todir):
    import jar
    from java.io import FileInputStream, FileOutputStream

    name = apply(os.path.join, jc.split('.'))+'.class'
    fromname = os.path.join(fromdir, name)
    toname = os.path.join(todir, name)
    tohead = os.path.split(toname)[0]
    if not os.path.exists(tohead):
        os.makedirs(tohead)
    istream = FileInputStream(fromname)
    ostream = FileOutputStream(toname)
    jar.copy(istream, ostream)
    istream.close()
    ostream.close()
</t>
<t tx="ekr.20040227065519.574">def writeResults(comp, opts):
    global mainclass
    global basepath

    javaclasses = comp.javaclasses

    if opts.bean is not None:
        jarfile = opts.bean
    else:
        jarfile = opts.jar              

    if jarfile is None:
        if not opts.deep and opts.package is not None:
            for jc in javaclasses:
                if isinstance(jc, TupleType):
                    jc = jc[0]
                if basepath is None:
                    basepath = '.'
                copyclass(jc, opts.workdir, basepath)
        sys.exit(0)

    print 'Building archive:', jarfile
    from jar import JavaArchive

    extraPackages = []

    if opts.all:
        addAll(extraPackages)
    elif opts.core:
        addCore(extraPackages)

    ja = JavaArchive(extraPackages)
    ja.addToManifest({'Main-Class': mainclass})
    for jc in javaclasses:
        if isinstance(jc, TupleType):
            ja.addClass(opts.workdir, jc[0], jc[1])
        else:
            ja.addClass(opts.workdir, jc)

    for dep in comp.trackJavaDependencies():
        ja.addEntry(dep)

    if opts.core or opts.all:
        import depend
        ja.addEntry(depend.getFile('org.python.modules.Setup'))
#        ze, jcs = depend.depends('org.python.modules.exceptions')
#        ja.addEntry(ze)
#        for jc in jcs:
#            ja.addEntry(depend.getFile(jc))

    ja.dump(jarfile)
</t>
<t tx="ekr.20040227065519.575">def main():
    opts = getOptions()
    comp = doCompile(opts)
    writeResults(comp, opts)
</t>
<t tx="ekr.20040227065519.576">@ignore
@language python
&lt;&lt; proxies declarations &gt;&gt;
@others



if __name__ == '__main__':
    import java
    methods = [("init", None, None),
               ("enable", None, ("public", Void.TYPE,
                                 [(java.awt.Event, 'event')]
                                 ))
               ]
    jp = JavaProxy("Foo", [java.util.Random], methods) #applet.Applet], methods)

    print jast.Block(jp.dumpAll())
</t>
<t tx="ekr.20040227065519.577"># Copyright (c) Corporation for National Research Initiatives

from types import TupleType, IntType

import jast

from java.lang.reflect.Modifier import *
from java.lang.reflect import Modifier
from java.lang import *
import org, java



</t>
<t tx="ekr.20040227065519.578">def aget(dict, key, default):
    if dict.has_key(key):
        return dict[key]
    else:
        ret = {}
        dict[key] = ret
        return ret
</t>
<t tx="ekr.20040227065519.579">
#Utility functions for converting between java and python types
def typeName(cls):
    if Class.isArray(cls):
        return typeName(Class.getComponentType(cls))+"[]"
    else:
        if '$' in cls.__name__:
            outer = cls.getDeclaringClass()
            if outer:
                l = len(outer.__name__)
                return "%s.%s" % (typeName(outer), cls.__name__[l+1:])
        return cls.__name__
</t>
<t tx="ekr.20040227065519.580">
def nullReturn(ret):
    if ret == Void.TYPE:
        return jast.Return()

    if Class.isPrimitive(ret):
        if ret.__name__ == 'boolean':
            value = jast.False
        elif ret.__name__ == 'char':
            value = jast.CharacterConstant('x')
        else:
            value = jast.IntegerConstant(0)
    else:
        value = jast.Null
    return jast.Return(value)
</t>
<t tx="ekr.20040227065519.581">
def makeReturn(code, ret):
    if ret == Void.TYPE:
        return code

    if Class.isPrimitive(ret):
        r = jast.InvokeStatic("Py", "py2"+ret.__name__, [code])
    else:
        typname = typeName(ret)
        r = jast.InvokeStatic("Py", "tojava",
                              [code, jast.GetStaticAttribute(typname,'class')])
        r = jast.Cast(typname, r)
    return jast.Return(r)
</t>
<t tx="ekr.20040227065519.582">
def makeObject(code, c):
    if c in [Integer.TYPE, Byte.TYPE, Short.TYPE, Long.TYPE]:
        mname = "newInteger"
    elif c in [Character.TYPE]:
        mname = "newString"
    elif c in [Float.TYPE, Double.TYPE]:
        mname = "newFloat"
    elif c in [Boolean.TYPE]:
        mname = "newBoolean"
    else:
        return code
    return jast.InvokeStatic("Py", mname, [code])
</t>
<t tx="ekr.20040227065519.583">
def filterThrows(throws):
    ret = []
    for throwc in throws:
        #might want to remove subclasses of Error and RuntimeException here
        ret.append(throwc.__name__)
    return ret
</t>
<t tx="ekr.20040227065519.584">
def wrapThrows(stmt, throws, retType):
    if len(throws) == 0: return stmt
    catches = []
    throwableFound = 0
    for i in range(len(throws)):
        throw = throws[i]
        exctype = throw
        excname = jast.Identifier("exc%d" % i)
        body = jast.Block([jast.Throw(excname)])
        catches.append( (exctype, excname, body) )
        if throw == "java.lang.Throwable":
            throwableFound = 1

    if not throwableFound:
        body = jast.Block([jast.Invoke(jast.Identifier("inst"),
                                   "_jthrow", [jast.Identifier("t")]),
                       nullReturn(retType)])
        catches.append( ("java.lang.Throwable", jast.Identifier("t"), body) )
    return jast.TryCatches(jast.Block([stmt]), catches)
</t>
<t tx="ekr.20040227065519.585">


class JavaProxy:
	@others
</t>
<t tx="ekr.20040227065519.586">def __init__(self, name, supername, bases, methods, module=None,
                   issuperproxy = 1):
    self.bases = bases
    self.name = name
    self.supername, self.pySupername = supername
    self.methods = methods
    self.issuperproxy = 0 #issuperproxy

    self.packages = self.properties = jast.Null
    self.modname = "foo"

    self.modifier = "public"
    self.initsigs = None

    self.package = None
    self.module = module
    if module is not None:
        self.packages = module.getPackages(qual=1)
        self.properties = module.getProxyProperties(qual=1)
        self.modname = module.name
        if module.package is not None:
            self.modname = module.package+'.'+self.modname
        self.modules = module.modules.keys()

    self.isAdapter = 0
    self.frozen = 1

    self.superclass = Object
    self.interfaces = []

    self.jmethods = {}
    self.jabstract = {}
    self.supermethods = {}
    for base in bases:
        self.addMethods(base)
        if base.isInterface():
            self.interfaces.append(base)
        else:
            self.superclass = base
    self.cleanMethods()

    if self.supername is None:
        self.supername = self.superclass.__name__

    self.jconstructors = []
    self.addConstructors(self.superclass)

    self.innerClasses = []

    # gather info about methods, and methods requiring a super__foo counterpart
    self.superproxy = self
    self.myCandSupermethods = []
    self.candSupermethods = None
    self.methodsMemo = []
    self.prepMethods()
</t>
<t tx="ekr.20040227065519.587">def __repr__(self): return "&lt;JavaProxy %s.%s&gt;" % (self.modname,self.name)
</t>
<t tx="ekr.20040227065519.588">def getSuperproxy(self):
    if self.superproxy is not self:
        return self.superproxy
    supername = self.pySupername
    if supername is None: return None
    modules = self.module.modules
    parts = supername.split('.')
    modname = '.'.join(parts[0:-1])
    dmodname = parts[-2]
    supername = parts[-1]
    superproxy = None
    if modules.has_key(modname):
        mod = modules[modname]
        if dmodname == supername:
            superproxy = getattr(mod,'javaproxy',None)
        else:
            for px in getattr(mod,'innerClasses',[]):
                if isinstance(px,JavaProxy) and px.name == supername:
                    superproxy = px
                    break
    self.superproxy = superproxy
    return superproxy
</t>
<t tx="ekr.20040227065519.589">def getCandSupermethods(self,incl):
    if incl and self.candSupermethods is not None:
        return self.candSupermethods
    px = self.getSuperproxy()
    if px is not None:
        cands = px.getCandSupermethods(incl = 1)[:]
    else:
        cands = []
    if incl:
        cands.extend(self.myCandSupermethods)
        self.candSupermethods = cands
    return cands
</t>
<t tx="ekr.20040227065519.590">def dumpAll(self):
    self.statements = []
    self.dumpInnerClasses()
    self.dumpMethods()
    self.dumpConstructors()
    self.addPyProxyInterface()
    self.addClassDictInit()
    return self.statements
</t>
<t tx="ekr.20040227065519.591">def dumpInnerClasses(self):
    for ic in self.innerClasses:
        self.statements.append(ic)
</t>
<t tx="ekr.20040227065519.592">def prepMethods(self):
    names = self.jmethods.keys()
    names.sort()
    #print 'preparing adding methods', self.name, names
    pymethods = {}
    for name, args, sigs in self.methods:
        pymethods[name] = 1
        #print name, args, sig
        if sigs is not None:
            if name == "__init__":
                self.initsigs = sigs
                continue

            #print sigs
            for access, ret, sig, throws in sigs:
                dosuper = 0
                if self.jmethods.has_key(name):
                    x = filter(lambda c: isinstance(c, TupleType), sig)
                    x = tuple(map(lambda c: c[0], x))
                    if self.jmethods[name].has_key(x):
                        del self.jmethods[name][x]
                        if not self.jabstract[name][x]:
                            dosuper = 1
                            self.myCandSupermethods.append(name)

                self.methodsMemo.append(('n',name, access, ret, sig, throws,
                                         dosuper))

    for name in names:
        for sig, (access, ret, throws) in self.jmethods[name].items():
            #print name, access, isProtected(access), isFinal(access)
            if isProtected(access):
                supername = name
                if isFinal(access):
                 	access = access &amp; ~FINAL
                    access = access &amp; ~PROTECTED | PUBLIC
                    self.methodsMemo.append(('s',name, "super__" + name,
                                             access, ret, sig, throws))
	    	continue
            elif isFinal(access):
                continue

            if self.jabstract[name][sig]: #isAbstract(access):
                access = access &amp; ~PROTECTED | PUBLIC
                self.methodsMemo.append(('n',name, access, ret, sig, throws,
                                         0))                    
            elif pymethods.has_key(name):
                access = access &amp; ~PROTECTED | PUBLIC
                self.methodsMemo.append(('n',name, access, ret, sig, throws,
                                         1))
                self.myCandSupermethods.append(name)
            elif isProtected(access):
                access = access &amp; ~PROTECTED | PUBLIC
                self.methodsMemo.append(('s',name, name,
                                         access, ret, sig, throws))
</t>
<t tx="ekr.20040227065519.593">def dumpMethods(self): # use info gathered by prepMethods
    dispatch = { 's': self.callSuperMethod, 'n': self.callMethod }
    for m in self.methodsMemo:
        apply(dispatch[m[0]],m[1:])
</t>
<t tx="ekr.20040227065519.594">def dumpConstructors(self):
    if self.initsigs is not None:
        #print self.initsigs
        for access, ret, sig, throws in self.initsigs:
            self.callConstructor(access, sig, throws, 0)
    else:
        for access, sig, throws in self.jconstructors:
            self.callConstructor(access, sig, throws, 1)
</t>
<t tx="ekr.20040227065519.595">def cleanMethods(self):
    for name, value in self.jmethods.items():
        if len(value) == 0:
            del self.jmethods[name]
            del self.jabstract[name]
</t>
<t tx="ekr.20040227065519.596">def addMethods(self, c):
    #print 'adding', c.__name__, c.getDeclaredMethods()

    for method in c.getDeclaredMethods():
        #Check that it's not already included
        name = method.name
        sig = tuple(method.parameterTypes)
        ret = method.returnType

        mdict = aget(self.jmethods, name, {})
        absdict = aget(self.jabstract, name, {})

        access = method.modifiers

        if mdict.has_key(sig):
            if not isAbstract(access): absdict[sig] = 0
            continue

        if isPrivate(access) or isStatic(access):
            continue

        if isNative(access):
            access = access &amp; ~NATIVE

        if isProtected(access):
            #access = access &amp; ~PROTECTED | PUBLIC
            if isFinal(access):
                pass
                #addSuperMethod(method, access)     
        #elif isFinal(access):
        #    continue

        throws = method.exceptionTypes
        mdict[sig] = access, ret, throws
        absdict[sig] = isAbstract(access)

    sc = c.getSuperclass()
    if sc is not None:
        self.addMethods(sc)

    for interface in c.getInterfaces():
        self.addMethods(interface)
</t>
<t tx="ekr.20040227065519.597">def addConstructors(self, c):
    for constructor in c.getDeclaredConstructors():
        access = constructor.modifiers
        if isPrivate(access):
            continue
        if isNative(access):
            access = access &amp; ~NATIVE
        if isProtected(access):
            access = access &amp; ~PROTECTED | PUBLIC
        parameters = tuple(constructor.parameterTypes)
        throws = constructor.exceptionTypes
        self.jconstructors.append( (access, parameters, throws) )
</t>
<t tx="ekr.20040227065519.598">def callSuperMethod(self, name, supername, access, ret, sig, throws=[]):
    if self.issuperproxy:
        return
    self.supermethods[supername] = supername
    args = [typeName(ret)]
    argids = []
    throws = filterThrows(throws)
    for c in sig:
        if isinstance(c, TupleType):
            argname = c[1]
            c = c[0]
        else:
            argname = "arg"+str(len(argids))
        args.append( (typeName(c), argname) )
        argid = jast.Identifier(argname)
        argids.append(argid)

    supercall = jast.Invoke(jast.Identifier("super"), name, argids)
    if ret != Void.TYPE:
        supercall = jast.Return(supercall)

    supermethod = jast.Method(supername,
                              jast.Modifier.ModifierString(access), 
                              args, jast.Block([supercall]), throws)
    self.statements.append(supermethod)
    return
</t>
<t tx="ekr.20040227065519.599">def callMethod(self, name, access, ret, sig, throws=[], dosuper=1):
    args = [typeName(ret)]
    argids = []
    objects = []
    throws = filterThrows(throws)
    for c in sig:
        if isinstance(c, TupleType):
            argname = c[1]
            c = c[0]
        else:
            argname = "arg"+str(len(argids))
        args.append( (typeName(c), argname) )
        argid = jast.Identifier(argname)
        argids.append(argid)
        objects.append(makeObject(argid, c))

    objects = jast.FilledArray("Object", objects)

    stmts = []
    this = jast.Identifier("this")

    if isinstance(access, IntType) and isAbstract(access):
        dosuper = 0
        access = access &amp; ~ABSTRACT

    if not dosuper and not self.isAdapter:
        getattr = jast.InvokeStatic("Py", "jgetattr",
                                    [this, jast.StringConstant(name)])
    else:
        getattr = jast.InvokeStatic("Py", "jfindattr",
                                    [this, jast.StringConstant(name)])

    inst = jast.Identifier("inst")
    if len(throws) == 0:
        jcall = "_jcall"
    else:
        jcall = "_jcallexc"

    jcall = makeReturn(jast.Invoke(inst, jcall, [objects]), ret)
    jcall = wrapThrows(jcall, throws, ret)

    if dosuper:
        supercall = jast.Invoke(jast.Identifier("super"), name, argids)
        if ret != Void.TYPE:
            supercall = jast.Return(supercall)

        supermethod = None
        if not self.issuperproxy and name not in self.getCandSupermethods(incl=0):
            supermethod = jast.Method("super__"+name,
                                  jast.Modifier.ModifierString(access), 
                                  args, jast.Block([supercall]), throws)
            self.supermethods["super__"+name] = "super__"+name
    else:           
        if self.isAdapter:
            supercall = nullReturn(ret)
        else:
            supercall = None
        supermethod = None

    if not dosuper and not self.isAdapter:
        test = jcall
    else:
        test = jast.If(jast.Operation("!=", inst, jast.Null),
                       jcall, supercall)
    code = jast.Block([jast.Declare("PyObject", inst, getattr), test])

    meth = jast.Method(name, jast.Modifier.ModifierString(access),
                       args, code, throws)

    if supermethod is not None:
        self.statements.append(supermethod)

    self.statements.append(meth)
</t>
<t tx="ekr.20040227065519.600">def callConstructor(self, access, sig, throws=[], dosuper=1):
    args = []
    argids = []
    objects = []
    throws = filterThrows(throws)
    for c in sig:
        if isinstance(c, TupleType):
            argname = c[1]
            c = c[0]
        else:
            argname = "arg"+str(len(argids))
        args.append( (typeName(c), argname) )
        argid = jast.Identifier(argname)
        argids.append(argid)
        objects.append(makeObject(argid, c))

    objects = jast.FilledArray("Object", objects)

    stmts = []
    this = jast.Identifier("this")

    if dosuper:
        supercall = jast.InvokeLocal("super", argids)
    else:
        supercall = jast.InvokeLocal("super", [])
##          for saccess, ssig in self.jconstructors:
##              if len(ssig) == len(sig):
##                  supercall = jast.InvokeLocal("super", argids)
##                  break
##          else:
##              supercall = jast.InvokeLocal("super", [])

    frozen = self.module.getFrozen()

    initargs = [objects]
    initproxy = jast.InvokeLocal("__initProxy__", initargs)

    code = jast.Block([supercall, initproxy])
    self.statements.append(jast.Constructor(
        self.name,
        jast.Modifier.ModifierString(access), args, code, throws))
</t>
<t tx="ekr.20040227065519.601">def addPyProxyInterface(self):
    self.statements.append(jast.Declare('private PyInstance',
                                        jast.Identifier('__proxy')))
    code = jast.Set(jast.Identifier("__proxy"), jast.Identifier("inst")) 
    code = jast.Block( [code] )
    self.statements.append(jast.Method("_setPyInstance", "public",
                                       ["void", ("PyInstance", "inst")],
                                       code))
    code = jast.Block([jast.Return(jast.Identifier("__proxy"))])
    self.statements.append(jast.Method("_getPyInstance", "public",
                                       ["PyInstance"], code))

    self.statements.append(jast.Declare('private PySystemState',
                                        jast.Identifier('__sysstate')))
    code = jast.Set(jast.Identifier("__sysstate"),
                    jast.Identifier("inst")) 
    code = jast.Block( [code] )
    self.statements.append(jast.Method("_setPySystemState", "public",
                                       ["void", ("PySystemState", "inst")],
                                       code))
    code = jast.Block([jast.Return(jast.Identifier("__sysstate"))])
    self.statements.append(jast.Method("_getPySystemState", "public",
                                       ["PySystemState"], code))


    frozen = self.module.getFrozen()
    this = jast.Identifier("this")
    initargs = [this, jast.StringConstant(self.modname),
                jast.StringConstant(self.name),
                jast.Identifier("args"), self.packages, self.properties,
                frozen, jast.StringArray(self.modules)]

    initproxy = jast.InvokeStatic("Py", "initProxy", initargs)


    code = jast.Block([initproxy])
    self.statements.append(jast.Method("__initProxy__", "public",
                                       ["void", ("Object[]", "args")], code))

    self.interfaces.append(org.python.core.PyProxy)
</t>
<t tx="ekr.20040227065519.602">def addClassDictInit(self):
    self.interfaces.append(org.python.core.ClassDictInit)

    namelist = jast.InvokeStatic("Py", "java2py", [
         jast.StringArray(self.supermethods.keys()) ]);

    code = jast.Invoke(jast.Identifier("dict"), "__setitem__", [
                     jast.StringConstant("__supernames__"), namelist]);

    code = jast.Block([code])
    self.statements.append(jast.Method("classDictInit", "static public",
                                       ["void", ("PyObject", "dict")], code))
</t>
<t tx="ekr.20040227065519.603">def makeClass(self):
    mycode = self.dumpAll()                 
    body = jast.Block(mycode)
    return jast.Class(self.name, self.modifier, self.supername,
                      map(lambda i: i.__name__, self.interfaces), body)
</t>
<t tx="ekr.20040227065519.604">def getDescription(self):
    COMMASPACE = ', '
    ret = self.name+' extends '+self.supername
    if len(self.interfaces) &gt; 0:
        ret = ret + ' implements ' + \
              COMMASPACE.join(map(lambda i: i.__name__, self.interfaces))
    return ret
</t>
<t tx="ekr.20040227065519.605">@ignore
@language python
&lt;&lt; util declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040227065519.606"># Copyright (c) Corporation for National Research Initiatives

</t>
<t tx="ekr.20040227065519.607">def lookup(name):
    names = name.split('.')
    top = __import__(names[0])
    for name in names[1:]:
        top = getattr(top, name)
    return top
</t>
<t tx="ekr.20040227065519.608">from java.util.zip import ZipFile

zipfiles = {}

def getzip(filename):
    if zipfiles.has_key(filename):
        return zipfiles[filename]
    zipfile = ZipFile(filename)
    zipfiles[filename] = zipfile
    return zipfile
</t>
<t tx="ekr.20040227065519.609">def closezips():
    for zf in zipfiles.values():
        zf.close()
    zipfiles.clear()
</t>
<t tx="ekr.20040227065519.610"># "tentative"

import sys
import string

from org.python.core import Py

from yapm import YaPM
from PathVFS import PathVFS

def findClass(c):
    return Py.findClassEx(c, "java class")
</t>
<t tx="ekr.20040227065519.611">def reportPublicPlainClasses(jpkg):
    classes = sys.packageManager.doDir(jpkg,0,1)
    classes.remove('__name__')
    return string.join(classes,',')
</t>
<t tx="ekr.20040227065519.612">_path_vfs = None

def openResource(res):
    global _path_vfs
    if not _path_vfs:
        _path_vfs = PathVFS(sys.registry)    
    return _path_vfs.open(res)
</t>
<t tx="ekr.20040227065519.613">_ypm = None

def listAllClasses(jpkg):
    global _ypm
    classes = sys.packageManager.doDir(jpkg,0,1)
    classes.remove('__name__')
    if _ypm is None:
        _ypm = YaPM(sys.registry)
    pkg2 = _ypm.lookupName(jpkg.__name__)
    classes2 = _ypm.doDir(pkg2,0,1)
    classes2.remove('__name__')
    classes.extend(classes2)
    return classes
</t>
<t tx="ekr.20040227065519.614">@ignore
@language python
&lt;&lt; yapm declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040227065519.615"># Copyright 2000 Samuele Pedroni
# see org.python.core.SysPackageManager

import sys
import os
from string import strip

from java import io

from org.python.core import PathPackageManager
</t>
<t tx="ekr.20040227065519.616">class YaPM(PathPackageManager):
	@others
</t>
<t tx="ekr.20040227065519.617">def __init__(self, registry):
    self.findAllPackages(registry)
</t>
<t tx="ekr.20040227065519.618">def findClass(self, pkg, name):
    return None
</t>
<t tx="ekr.20040227065519.619">def findAllPackages(self,registry):
    paths = registry.getProperty("python.packages.paths","java.class.path")
    paths = paths.split(',')
    # opt
    if "sun.boot.class.path" in paths: # ??pending strip boot class paths of other jvms?
        paths.remove("sun.boot.class.path")
    fakepath = registry.getProperty("python.packages.fakepath", None)

    for p in paths:
        e = registry.getProperty(p)
        if e != None:
            self.addClassPath(e)

    if fakepath != None:
        self.addClassPath(fakepath)
</t>
<t tx="ekr.20040227065519.620">def filterByName(self,name,pkg):
    return 0
</t>
<t tx="ekr.20040227065519.621">def filterByAccess(self,name,acc):
    return not ((name.find('$') != -1) or (acc &amp; 1 == 0))
</t>
<t tx="ekr.20040227065519.622">def doDir(self, jpkg, instantiate, exclpkgs):
    basic = self.basicDoDir(jpkg, 0, exclpkgs)
    ret = []

    self.super__doDir(self.searchPath,ret,jpkg,0,exclpkgs)
    self.super__doDir(sys.path,ret,jpkg,0,exclpkgs)

    return self.merge(basic,ret)
</t>
<t tx="ekr.20040227065519.623">def packageExists(self,pkg,name):
    return self.super__packageExists(self.searchPath,pkg,name) or self.super__packageExists(sys.path,pkg,name)
</t>
<t tx="ekr.20040227065519.624"></t>
<t tx="ekr.20040227065519.625">@ignore
@language python
&lt;&lt; Modifier declarations &gt;&gt;
@others

if __name__ == '__main__':
    m0 = Modifier(0)
    m1 = Modifier(public=1, final=1)
    m2 = Modifier(1023)
    print ModifierString(m0)
    print ModifierString(m1)
    print ModifierString(m2)
</t>
<t tx="ekr.20040227065519.626"># Copyright (c) Corporation for National Research Initiatives
names = {
    1024: 'abstract',
      16: 'final',
     512: 'interface',
     256: 'native',
       2: 'private',
       4: 'protected',
       1: 'public',
       8: 'static',
      32: 'synchronized',
     128: 'transient',
      64: 'volatile'
    }

numbers = {}
for number, name in names.items():
    numbers[name] = number

</t>
<t tx="ekr.20040227065519.627">def Modifier(base=0, **kw):
    """Construct the appropriate integer to represent
    modifiers for a method, class, or field declaration.
    This should probably do some error checking:
    "public private" doesn't make much sense.
    """
    for name, value in kw.items():
        if value:
            base = base | numbers[name]
    return base
</t>
<t tx="ekr.20040227065519.628">def ModifierString(modifier):
    if type(modifier) == type(""): return modifier
    text = []
    base = 1
    while base &lt;= modifier:
        if modifier &amp; base:
            text.append(names[base])
        base = base * 2
    SPACE = ' '
    return SPACE.join(text)
</t>
<t tx="ekr.20040227065519.629">@ignore
@language python
&lt;&lt; Output declarations &gt;&gt;
@others




if __name__ == '__main__':
    sf = SourceFile('foo')
    sf.write('public class foo')
    sf.beginBlock()
    sf.writeln()
    sf.writeln("int bar;")
    sf.write("abc")
    sf.write("def")
    sf.beginBlock()
    sf.writeln("hi there")
    sf.endBlock()
    sf.writeList(['a', 'b', 'c'])
    sf.writeln(" extra")
    sf.endBlock()

    print sf
</t>
<t tx="ekr.20040227065519.630"># Copyright (c) Corporation for National Research Initiatives
import os
from Modifier import ModifierString



</t>
<t tx="ekr.20040227065519.631">class SourceFile:
	@others
	self.indentation = self.indentation-1
	self.writeln('}')</t>
<t tx="ekr.20040227065519.632">def __init__(self, classname):
</t>
<t tx="ekr.20040227065519.633">self.text = []
self.indentation = 0
self.indent = '    '
self.startLine = 1
self.classname = classname
self.filename = classname+'.java'

def dump(self, directory="c:\\jpython\\test\\comp"):
</t>
<t tx="ekr.20040227065519.634">fp = open(os.path.join(directory, self.filename), 'w')
for bit in self.text:
    fp.write(bit)
fp.close()

def __repr__(self):
    EMPTYSTRING = ''
</t>
<t tx="ekr.20040227065519.635">return EMPTYSTRING.join(self.text)

def writeModifiers(self, modifiers):
</t>
<t tx="ekr.20040227065519.636">self.write(ModifierString(modifiers))

def write(self, text, *args):
</t>
<t tx="ekr.20040227065519.637">newArgs = []
for arg in args:
    if hasattr(arg, 'sourceString'):
	arg = arg.sourceString()
    newArgs.append(arg)

if self.startLine:
    self.text.append(self.indent*self.indentation)
    self.startLine = 0

if len(args) &gt; 0:
    text = text % tuple(newArgs)
self.text.append(text)

def writeln(self, text="", *args):
</t>
<t tx="ekr.20040227065519.638">apply(self.write, (text+'\n',)+args)
self.startLine = 1

def writeList(self, values):
</t>
<t tx="ekr.20040227065519.639">if len(values) == 0:
    return
text = "%s, "*(len(values)-1) + "%s "
print text
apply(self.write, (text, )+tuple(values))

def beginBlock(self):
</t>
<t tx="ekr.20040227065519.640">self.writeln('{')
self.indentation = self.indentation+1

def endBlock(self):
</t>
<t tx="ekr.20040227065519.641">@ignore
@language python
&lt;&lt; Statement declarations &gt;&gt;
@others



True = Identifier("true")
False = Identifier("false")
Null = Identifier("null")


##class SetIndex(Expression):
##    def __init__(self, lvalue, index, value):

##class SetAttribute(Expression):
##    def __init__(self, lvalue, name, value):



# Python also has a complicated set sequence form here, but that's just sugar
# for ???

if __name__ == '__main__':
    from Output import SourceFile
    out = SourceFile('Foo')

    x = Identifier('x')
    one = IntegerConstant(1)
    s = While(Operation('&lt;', x, one), Set(x, Operation('+', x, one)))
    s.writeSource(out)

    print out

"""
public static int Func1(char CharPar1, char CharPar2) {
    char CharLoc1 = CharPar1;
    char CharLoc2 = CharLoc1;
    if (CharLoc2 != CharPar2) {
        return Ident1;
    } else {
        return Ident2;
    }
}
"""
</t>
<t tx="ekr.20040227065519.642"># Copyright (c) Corporation for National Research Initiatives
from Output import SourceFile

COMMASPACE = ', '



</t>
<t tx="ekr.20040227065519.643">class Statement:
	@others
</t>
<t tx="ekr.20040227065519.644">def __repr__(self):
    out = SourceFile('Foo')
    self.writeSource(out)
    return str(out)
</t>
<t tx="ekr.20040227065519.645">def exits(self):
    return 0
</t>
<t tx="ekr.20040227065519.646">

class Class(Statement):
	@others
</t>
<t tx="ekr.20040227065519.647">def __init__(self, name, access, superclass, interfaces, body):
    self.name = name
    self.access = access
    self.superclass = superclass
    self.interfaces = interfaces
    self.body = body
</t>
<t tx="ekr.20040227065519.648">def writeSource(self, out):
    out.write("%s class %s extends %s ", self.access, self.name,
              self.superclass)
    if len(self.interfaces) &gt; 0:
        out.write("implements %s ", COMMASPACE.join(self.interfaces))
    self.body.writeSource(out)
</t>
<t tx="ekr.20040227065519.649">def __repr__(self):
    return "Class(%s, %s, %s, %s, %s)" % (self.name, self.access,
                                          self.superclass,
                                          self.interfaces, self.body)
</t>
<t tx="ekr.20040227065519.650">

class Method(Statement):
	@others
</t>
<t tx="ekr.20040227065519.651">def __init__(self, name, access, args, body, throws=[]):
    self.name = name
    self.access = access
    self.args = args
    self.body = body
    self.throws = throws
</t>
<t tx="ekr.20040227065519.652">def writeSource(self, out):
    argtext = []
    for type, name in self.args[1:]:
        argtext.append(type+" "+name)
    if len(self.throws) == 0:
        throwstext = ""
    else:
        throwstext = " throws " + COMMASPACE.join(self.throws)

    out.write("%s %s %s(%s)%s ", self.access, self.args[0], self.name,
              COMMASPACE.join(argtext), throwstext)
    self.body.writeSource(out)
    out.writeln()
</t>
<t tx="ekr.20040227065519.653">def __repr__(self):
    return "Method(%s, %s, %s, %s)" % (self.name, self.access,
                                       self.args, self.body)
</t>
<t tx="ekr.20040227065519.654">

class Constructor(Statement):
	@others
</t>
<t tx="ekr.20040227065519.655">def __init__(self, name, access, args, body, throws=[]):
    self.name = name
    self.access = access
    self.args = args
    self.body = body
    self.throws = throws
</t>
<t tx="ekr.20040227065519.656">def writeSource(self, out):
    argtext = []
    for type, name in self.args:
        argtext.append(type+" "+name)
    if len(self.throws) == 0:
        throwstext = ""
    else:
        throwstext = " throws " + COMMASPACE.join(self.throws)

    out.write("%s %s(%s)%s ", self.access, self.name,
              COMMASPACE.join(argtext), throwstext)
    self.body.writeSource(out)
    out.writeln()
</t>
<t tx="ekr.20040227065519.657">def __repr__(self):
    return "Constructor(%s, %s, %s, %s)" % (self.name, self.access,
                                            self.args, self.body)
</t>
<t tx="ekr.20040227065519.658">


class BlankLine(Statement):
	@others
</t>
<t tx="ekr.20040227065519.659">def writeSource(self, out):
    out.writeln()
</t>
<t tx="ekr.20040227065519.660">def __repr__(self):
    return "BlankLine()"
</t>
<t tx="ekr.20040227065519.661">
Blank = BlankLine()



class Import(Statement):
	@others
</t>
<t tx="ekr.20040227065519.662">def __init__(self, package):
    self.package = package
</t>
<t tx="ekr.20040227065519.663">def writeSource(self, out):         
    out.writeln("import %s;", self.package)
</t>
<t tx="ekr.20040227065519.664">def __repr__(self):
    return "Import(%s)" % (self.package)
</t>
<t tx="ekr.20040227065519.665">


class SimpleComment(Statement):
    """ ??? """
	@others
</t>
<t tx="ekr.20040227065519.666">def __init__(self, text):
    self.text = text
</t>
<t tx="ekr.20040227065519.667">def writeSource(self, out):         
    out.writeln("// "+self.text)
</t>
<t tx="ekr.20040227065519.668">def __repr__(self):
    return "SimpleComment(%s)" % (self.text)
</t>
<t tx="ekr.20040227065519.669">


class Comment(Statement):
    """ ??? """
	@others
</t>
<t tx="ekr.20040227065519.670">def __init__(self, text):
    self.text = text
</t>
<t tx="ekr.20040227065519.671">def writeSource(self, out):
    lines = self.text.split('\n')
    if len(lines) == 1:
        out.writeln("/* %s */", self.text)
        return

    out.writeln("/* %s", lines[0])
    for line in lines[1:-1]:
        out.writeln(line)
    out.writeln("%s */", lines[-1])
</t>
<t tx="ekr.20040227065519.672">def __repr__(self):
    return "Comment(%s)" % (self.package)
</t>
<t tx="ekr.20040227065519.673">


class Declare(Statement):
	@others
</t>
<t tx="ekr.20040227065519.674">def __init__(self, type, name, value=None):
    self.type = type
    self.name = name
    self.value = value
</t>
<t tx="ekr.20040227065519.675">def writeSource(self, out):
    if self.value is not None:
        out.writeln("%s %s = %s;", self.type, self.name.sourceString(),
                    self.value.sourceString())
    else:
        out.writeln("%s %s;", self.type, self.name.sourceString())
</t>
<t tx="ekr.20040227065519.676">def __repr__(self):
    return "Declare(%s, %s, %s)" % (self.type, self.name, self.value)
</t>
<t tx="ekr.20040227065519.677">


class Pass(Statement):
	@others
</t>
<t tx="ekr.20040227065519.678">def writeSource(self, out):
    pass
</t>
<t tx="ekr.20040227065519.679">def __repr__(self):
    return "Pass()"
</t>
<t tx="ekr.20040227065519.680">
def flatten(lst):
    ret = []
    for item in lst:
        if isinstance(item, type(lst)):
            ret.extend(flatten(item))
        elif isinstance(item, Block):
            ret.extend(item.code)
        else:
            ret.append(item)
    return ret
</t>
<t tx="ekr.20040227065519.681">


class FreeBlock(Statement):
	@others
</t>
<t tx="ekr.20040227065519.682">def __init__(self, code=None):
    if code is None:
        code = []
    self.code = flatten(code)
    self.locals = {}
    self.tempindex = 0
</t>
<t tx="ekr.20040227065519.683">def addlocal(self, name, type):
    self.locals[name] = type
</t>
<t tx="ekr.20040227065519.684">def writeSource(self, out):
    for name, type in self.locals.items():
        tn = type.typename
        if tn == 'PyObject':
            out.writeln('%s %s = null;', tn, name)
        elif tn == 'int':
            out.writeln('%s %s = 0;', tn, name)
        elif tn == 'char':
            out.writeln("%s %s = '\\000';", tn, name)
        else:
            out.writeln('%s %s;', tn, name)

    if len(self.locals) &gt; 0:
        out.writeln()

    for stmt in self.code:
        #print stmt
        stmt.writeSource(out)
        if stmt.exits():
            break
</t>
<t tx="ekr.20040227065519.685">def exits(self):
    for i in range(len(self.code)):
        if not hasattr(self.code[i], 'exits'):
            print self.code[i]
            print 'oops'
            continue
        if self.code[i].exits():
             del self.code[i+1:]
             return 1
    return 0
</t>
<t tx="ekr.20040227065519.686">def __repr__(self):
    return "FreeBlock(%s)" % (self.code)
</t>
<t tx="ekr.20040227065519.687">


class Block(FreeBlock):
	@others
</t>
<t tx="ekr.20040227065519.688">def writeSource(self, out):
    out.beginBlock()
    FreeBlock.writeSource(self, out)
    out.endBlock()
</t>
<t tx="ekr.20040227065519.689">def __repr__(self):
    return "Block(%s)" % (self.code)
</t>
<t tx="ekr.20040227065519.690">


class TryCatch(Statement):
	@others
</t>
<t tx="ekr.20040227065519.691">def __init__(self, body, exctype, excname, catchbody):
    self.body = body
    self.exctype = exctype
    self.excname = excname
    self.catchbody = catchbody
</t>
<t tx="ekr.20040227065519.692">def writeSource(self, out):
    out.write("try ")
    self.body.writeSource(out)
    out.write("catch (%s %s) ", self.exctype, self.excname.sourceString())
    self.catchbody.writeSource(out)
</t>
<t tx="ekr.20040227065519.693">def exits(self):
    return self.body.exits() and self.catchbody.exits()
</t>
<t tx="ekr.20040227065519.694">


class TryCatches(Statement):
	@others
</t>
<t tx="ekr.20040227065519.695">def __init__(self, body, catches):
    self.body = body
    self.catches = catches
</t>
<t tx="ekr.20040227065519.696">def writeSource(self, out):
    out.write("try ")
    self.body.writeSource(out)
    for exctype, excname, catchbody in self.catches:
        out.write("catch (%s %s) ", exctype, excname.sourceString())
        catchbody.writeSource(out)
</t>
<t tx="ekr.20040227065519.697">def exits(self):
    r = self.body.exits()
    for exctype, excname, catchbody in self.catches:
        r = r and catchbody.exits()
    return r
</t>
<t tx="ekr.20040227065519.698">

class TryFinally(Statement):
	@others
</t>
<t tx="ekr.20040227065519.699">def __init__(self, body, finalbody):
    self.body = body
    self.finalbody = finalbody
</t>
<t tx="ekr.20040227065519.700">def writeSource(self, out):
    out.write("try ")
    self.body.writeSource(out)
    out.write("finally ")
    self.finalbody.writeSource(out)
</t>
<t tx="ekr.20040227065519.701">def exits(self):
    return self.body.exits() or self.finalbody.exits()
</t>
<t tx="ekr.20040227065519.702">


class If(Statement):
	@others
</t>
<t tx="ekr.20040227065519.703">def __init__(self, test, thenBody, elseBody=None):
    self.test = test
    self.thenBody = thenBody
    self.elseBody = elseBody
</t>
<t tx="ekr.20040227065519.704">def writeSource(self, out):
    out.write("if (%s) ", self.test.sourceString())
    self.thenBody.writeSource(out)
    if self.elseBody is not None:
        out.write("else ")
        self.elseBody.writeSource(out)
</t>
<t tx="ekr.20040227065519.705">def exits(self):
    if self.elseBody is None:
        return 0
    return self.thenBody.exits() and self.elseBody.exits()
</t>
<t tx="ekr.20040227065519.706">


class MultiIf(Statement):
	@others
</t>
<t tx="ekr.20040227065519.707">def __init__(self, tests, elseBody=None):
    self.tests = tests
    self.elseBody = elseBody
</t>
<t tx="ekr.20040227065519.708">def writeSource(self, out):
    for i in range(len(self.tests)):
        test, body = self.tests[i]
        if i &gt; 0:
            out.write("else ")

        out.write("if (%s) ", test.sourceString())
        body.writeSource(out)
    if self.elseBody is not None:
        out.write("else ")
        self.elseBody.writeSource(out)
</t>
<t tx="ekr.20040227065519.709">def exits(self):
    if self.elseBody is None:
        return 0
    if not self.elseBody.exits():
        return 0
    for test, body in self.tests:
        if not body.exits():
            return 0
    return 1
</t>
<t tx="ekr.20040227065519.710">


class While(Statement):
	@others
</t>
<t tx="ekr.20040227065519.711">def __init__(self, test, body):
    self.test = test
    self.body = body
</t>
<t tx="ekr.20040227065519.712">def writeSource(self, out):
    out.write("while (%s) ", self.test.sourceString())
    self.body.writeSource(out)
</t>
<t tx="ekr.20040227065519.713">


class WhileElse(Statement):
	@others
</t>
<t tx="ekr.20040227065519.714">def __init__(self, test, body, else_body, while_temp):
    self.test = test
    self.body = body
    self.else_body = else_body
    self.while_temp = while_temp
</t>
<t tx="ekr.20040227065519.715">def writeSource(self, out):
    out.write("while (%s=%s) ", self.while_temp.sourceString(),
              self.test.sourceString())
    self.body.writeSource(out)
    out.write("if (!%s) ", self.while_temp.sourceString())
    self.else_body.writeSource(out)
</t>
<t tx="ekr.20040227065519.716">


class Switch(Statement):
	@others
</t>
<t tx="ekr.20040227065519.717">def __init__(self, index, cases, defaultCase=None):
    self.index = index
    self.cases = cases
    self.defaultCase = defaultCase
</t>
<t tx="ekr.20040227065519.718">def writeSource(self, out):
    out.write("switch (%s)", self.index.sourceString())
    out.beginBlock()
    for label, code in self.cases:
        out.writeln("case %s:", label.sourceString())
        code.writeSource(out)
    if self.defaultCase is not None:
        out.writeln("default:")
        self.defaultCase.writeSource(out)
    out.endBlock()
</t>
<t tx="ekr.20040227065519.719">


class Return(Statement):
	@others
</t>
<t tx="ekr.20040227065519.720">def __init__(self, value=None):
    self.value = value
</t>
<t tx="ekr.20040227065519.721">def writeSource(self, out):
    if self.value is None:
        out.writeln("return;")
    else:
        out.writeln("return %s;", self.value.sourceString())
</t>
<t tx="ekr.20040227065519.722">def exits(self):
    return 1
</t>
<t tx="ekr.20040227065519.723">


class Throw(Statement):
	@others
</t>
<t tx="ekr.20040227065519.724">def __init__(self, value):
    self.value = value
</t>
<t tx="ekr.20040227065519.725">def writeSource(self, out):
    out.writeln("throw %s;", self.value.sourceString())
</t>
<t tx="ekr.20040227065519.726">def exits(self):
    # Interesting question...
    return 1
</t>
<t tx="ekr.20040227065519.727">


class Break(Statement):
	@others
</t>
<t tx="ekr.20040227065519.728">def writeSource(self, out):
    out.writeln("break;")
</t>
<t tx="ekr.20040227065519.729">
class Continue(Statement):
	@others
</t>
<t tx="ekr.20040227065519.730">def writeSource(self, out):
    out.writeln("continue;")
</t>
<t tx="ekr.20040227065519.731">


class Expression:
	@others
</t>
<t tx="ekr.20040227065519.732">def __repr__(self):
    return self.sourceString()
</t>
<t tx="ekr.20040227065519.733">def safeSourceString(self):
    return self.sourceString()
</t>
<t tx="ekr.20040227065519.734">def writeSource(self, out):
    out.writeln(self.sourceString()+";")
</t>
<t tx="ekr.20040227065519.735">def _calcargs(self):
    args = []
    for a in self.args:
        try:
            ss = a.sourceString()
        except AttributeError, msg:
            print '=====&gt;', msg
            print '=====&gt;', a.__class__
            print '=====&gt;', a
            raise
        args.append(ss)
    return COMMASPACE.join(args)
</t>
<t tx="ekr.20040227065519.736">def exits(self):
    return 0
</t>
<t tx="ekr.20040227065519.737">


class UnsafeExpression(Expression):
	@others
</t>
<t tx="ekr.20040227065519.738">def safeSourceString(self):
    return "("+self.sourceString()+")"      
</t>
<t tx="ekr.20040227065519.739">


class Cast(UnsafeExpression):
	@others
</t>
<t tx="ekr.20040227065519.740">def __init__(self, totype, value):
    self.totype = totype
    self.value = value
</t>
<t tx="ekr.20040227065519.741">def sourceString(self):
    return "(%s)%s" % (self.totype, self.value.safeSourceString())
</t>
<t tx="ekr.20040227065519.742">


class Set(UnsafeExpression):
	@others
</t>
<t tx="ekr.20040227065519.743">def __init__(self, lvalue, value):
    self.lvalue = lvalue
    self.value = value
</t>
<t tx="ekr.20040227065519.744">def sourceString(self):
    return "%s = %s" % (self.lvalue.safeSourceString(),
                        self.value.safeSourceString())      
</t>
<t tx="ekr.20040227065519.745">


class Constant(Expression):
	@others
</t>
<t tx="ekr.20040227065519.746">def __init__(self, value):
    self.value = value
</t>
<t tx="ekr.20040227065519.747">def sourceString(self):
    return repr(self.value)
</t>
<t tx="ekr.20040227065519.748">

class IntegerConstant(Constant):
	&lt;&lt; class IntegerConstant declarations &gt;&gt;
</t>
<t tx="ekr.20040227065519.749">pass

</t>
<t tx="ekr.20040227065519.750">class FloatConstant(Constant):
	&lt;&lt; class FloatConstant declarations &gt;&gt;
</t>
<t tx="ekr.20040227065519.751">pass

</t>
<t tx="ekr.20040227065519.752">class CharacterConstant(Constant):
	&lt;&lt; class CharacterConstant declarations &gt;&gt;
</t>
<t tx="ekr.20040227065519.753">pass


</t>
<t tx="ekr.20040227065519.754">
class StringConstant(Constant):
	@others
</t>
<t tx="ekr.20040227065519.755">def sourceString(self):
    ret = ['"']
    for c in self.value:
        oc = ord(c)
        if c == '"':
            ret.append('\\"')
        elif c == '\\':
            ret.append('\\\\')
        elif oc &gt;= 032 and oc &lt;= 0177:
            ret.append(c)
        elif oc &lt;= 0377:
            ret.append("\\%03o" % oc)
        else:
            ret.append("\\u%04x" % oc)
    ret.append('"')
    return ''.join(ret)
</t>
<t tx="ekr.20040227065519.756">


class Operation(UnsafeExpression):
	@others
</t>
<t tx="ekr.20040227065519.757">def __init__(self, op, x, y=None):
    self.op = op
    self.x = x
    self.y = y
</t>
<t tx="ekr.20040227065519.758">def sourceString(self):
    if self.y is None:
        return "%s%s" % (self.op, self.x.safeSourceString())
    else:
        return "%s %s %s" % (self.x.safeSourceString(), self.op,
                             self.y.safeSourceString())
</t>
<t tx="ekr.20040227065519.759">

class TriTest(UnsafeExpression):
	@others
</t>
<t tx="ekr.20040227065519.760">def __init__(self, test, x, y):
    self.test = test
    self.x = x
    self.y = y
</t>
<t tx="ekr.20040227065519.761">def sourceString(self):
    return "%s ? %s : %s" % (self.test.safeSourceString(),
                             self.x.safeSourceString(),
                             self.y.safeSourceString())
</t>
<t tx="ekr.20040227065519.762">


class PostOperation(UnsafeExpression):
	@others
</t>
<t tx="ekr.20040227065519.763">def __init__(self, x, op):
    self.op = op
    self.x = x
</t>
<t tx="ekr.20040227065519.764">def sourceString(self):
    return "%s%s" % (self.x.safeSourceString(), self.op)
</t>
<t tx="ekr.20040227065519.765">

class Subscript(UnsafeExpression):
	@others
</t>
<t tx="ekr.20040227065519.766">def __init__(self, x, ind):
    self.ind = ind
    self.x = x
</t>
<t tx="ekr.20040227065519.767">def sourceString(self):
    return "%s[%s]" % (self.x.safeSourceString(), self.ind)
</t>
<t tx="ekr.20040227065519.768">


class InvokeLocal(Expression):
	@others
</t>
<t tx="ekr.20040227065519.769">def __init__(self, name, args):
    self.name = name
    self.args = args
</t>
<t tx="ekr.20040227065519.770">def sourceString(self):
    return '%s(%s)' % (self.name, self._calcargs())
</t>
<t tx="ekr.20040227065519.771">


class Invoke(Expression):
	@others
</t>
<t tx="ekr.20040227065519.772">def __init__(self, this, name, args):
    self.name = name
    self.this = this
    self.args = args
</t>
<t tx="ekr.20040227065519.773">def sourceString(self):
    return '%s.%s(%s)' % (self.this.safeSourceString(),
                          self.name, self._calcargs())
</t>
<t tx="ekr.20040227065519.774">


class InvokeStatic(Expression):
	@others
</t>
<t tx="ekr.20040227065519.775">def __init__(self, this, name, args):
    self.name = name
    self.this = this
    self.args = args
</t>
<t tx="ekr.20040227065519.776">def sourceString(self):
    return '%s.%s(%s)' % (self.this, self.name, self._calcargs())
</t>
<t tx="ekr.20040227065519.777">


class GetInstanceAttribute(Expression):
	@others
</t>
<t tx="ekr.20040227065519.778">def __init__(self, this, name):
    self.name = name
    self.this = this
</t>
<t tx="ekr.20040227065519.779">def sourceString(self):
    return "%s.%s" % (self.this.sourceString(), self.name)
</t>
<t tx="ekr.20040227065519.780">


class GetStaticAttribute(Expression):
	@others
</t>
<t tx="ekr.20040227065519.781">def __init__(self, this, name):
    self.name = name
    self.this = this
</t>
<t tx="ekr.20040227065519.782">def sourceString(self):
    return "%s.%s" % (self.this, self.name)
</t>
<t tx="ekr.20040227065519.783">


class SetInstanceAttribute(Expression):
	@others
</t>
<t tx="ekr.20040227065519.784">def __init__(self, this, name, value):
    self.name = name
    self.this = this
    self.value = value
</t>
<t tx="ekr.20040227065519.785">def sourceString(self):
    return "%s.%s = %s" % (self.this.sourceString(), self.name,
                           self.value.sourceString())
</t>
<t tx="ekr.20040227065519.786">


class SetStaticAttribute(Expression):
	@others
</t>
<t tx="ekr.20040227065519.787">def __init__(self, this, name, value):
    self.name = name
    self.this = this
    self.value = value
</t>
<t tx="ekr.20040227065519.788">def sourceString(self):
    return "%s.%s = %s" % (self.this, self.name, self.value.sourceString())
</t>
<t tx="ekr.20040227065519.789">


class Identifier(Expression):
	@others
</t>
<t tx="ekr.20040227065519.790">def __init__(self, name):
    self.name = name
</t>
<t tx="ekr.20040227065519.791">def sourceString(self):
    return str(self.name)
</t>
<t tx="ekr.20040227065519.792">


class New(Expression):
	@others
</t>
<t tx="ekr.20040227065519.793">def __init__(self, name, args):
    self.name = name
    self.args = args
</t>
<t tx="ekr.20040227065519.794">def sourceString(self):
    return 'new %s(%s)' % (self.name, self._calcargs())
</t>
<t tx="ekr.20040227065519.795">


class FilledArray(Expression):
	@others
</t>
<t tx="ekr.20040227065519.796">def __init__(self, type, values):
    self.type = type
    self.values = values
</t>
<t tx="ekr.20040227065519.797">def sourceString(self):
    return 'new %s[] {%s}' % (
        self.type,
        COMMASPACE.join(map(lambda arg: arg.sourceString(), self.values)))
</t>
<t tx="ekr.20040227065519.798">


class NewArray(Expression):
	@others
</t>
<t tx="ekr.20040227065519.799">def __init__(self, mytype, dimensions):
    self.type = mytype
    if type(dimensions) == type(0):
        dimensions = [dimensions]
    self.dimensions = dimensions
</t>
<t tx="ekr.20040227065519.800">def sourceString(self):
    return 'new %s[%s]' % (
        self.type,
        ']['.join(map(lambda arg: str(arg), self.dimensions)))
</t>
<t tx="ekr.20040227065519.801">


class StringArray(FilledArray):
	@others
</t>
<t tx="ekr.20040227065519.802">def __init__(self, values):
    lst = []
    for value in values:
        if value is None:
            jv = Null
        else:
            jv = StringConstant(value)
        lst.append(jv)
    self.values = lst
    self.type = "String"
</t>
<t tx="ekr.20040227065519.803">


class ClassReference(Expression):
	@others
</t>
<t tx="ekr.20040227065519.804">def __init__(self, name):
    self.name = name
</t>
<t tx="ekr.20040227065519.805">def sourceString(self):
    return module.simpleClassName(self.name)
</t>
<t tx="ekr.20040227065519.806">@ignore
@language python
# Copyright (c) Corporation for National Research Initiatives
from Statement import *
</t>
</tnodes>
</leo_file>
