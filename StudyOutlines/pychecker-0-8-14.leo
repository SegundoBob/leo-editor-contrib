<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="458" clone_windows="0"/>
<globals body_outline_ratio="0.551666666667">
	<global_window_position top="31" left="212" height="890" width="1000"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20040701040524.1"><vh>Read me or SUFFER</vh>
<v t="ekr.20040701144838"><vh>Recursive import script</vh>
<v t="ekr.20040701144838.1"><vh>importFiles</vh></v>
<v t="ekr.20040701144838.2"><vh>importDir</vh></v>
<v t="ekr.20040701144838.3"><vh>createLastChildOf</vh></v>
</v>
</v>
<v t="ekr.20040701041311"><vh>Docs &amp; copyright...</vh>
<v t="ekr.20040702152154"><vh>Why a modified pychecker might be useful.</vh></v>
<v t="ekr.20040701154748"><vh>@url http://pychecker.sourceforge.net/</vh></v>
<v t="ekr.20040701040524.2"><vh>@url http://python.org/doc/2.3/ref/types.html</vh>
<v t="ekr.20040701040524.3"><vh>Code objects</vh></v>
<v t="ekr.20040701040524.4"><vh>Frame objects</vh></v>
<v t="ekr.20040701040524.5"><vh>Static method objects </vh></v>
<v t="ekr.20040701040524.6"><vh>Class method objects </vh></v>
</v>
<v t="ekr.20040701040524.7"><vh>@url http://docs.python.org/lib/inspect-types.html</vh></v>
<v t="ekr.20040701040524.8"><vh>Copyright notice (BSD)</vh></v>
</v>
<v t="ekr.20040701145236"><vh>imported files (originals as imported by Leo)</vh>
<v t="ekr.20040701145236.57"><vh>@file c:/python23/Lib/site-packages/pychecker\CodeChecks.py</vh>
<v t="ekr.20040701145236.58"><vh>&lt;&lt; CodeChecks declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.59"><vh>cfg</vh></v>
<v t="ekr.20040701145236.60"><vh>getFunctionArgErr</vh></v>
<v t="ekr.20040701145236.61"><vh>_checkFunctionArgCount</vh></v>
<v t="ekr.20040701145236.62"><vh>_checkFunctionArgs</vh></v>
<v t="ekr.20040701145236.63"><vh>_getReferenceFromModule</vh></v>
<v t="ekr.20040701145236.64"><vh>_getFunction</vh></v>
<v t="ekr.20040701145236.65"><vh>_checkBuiltin</vh></v>
<v t="ekr.20040701145236.66"><vh>_checkModifyDefaultArg</vh></v>
<v t="ekr.20040701145236.67"><vh>_isexception</vh></v>
<v t="ekr.20040701145236.68"><vh>_checkStringFind</vh></v>
<v t="ekr.20040701145236.69"><vh>_checkAbstract</vh></v>
<v t="ekr.20040701145236.70"><vh>_checkReturnValueUse</vh></v>
<v t="ekr.20040701145236.71"><vh>_handleFunctionCall</vh></v>
<v t="ekr.20040701145236.72"><vh>_classHasAttribute</vh></v>
<v t="ekr.20040701145236.73"><vh>_checkClassAttribute</vh></v>
<v t="ekr.20040701145236.74"><vh>_checkModuleAttribute</vh></v>
<v t="ekr.20040701145236.75"><vh>_getGlobalName</vh></v>
<v t="ekr.20040701145236.76"><vh>_checkNoEffect</vh></v>
<v t="ekr.20040701145236.77"><vh>_makeConstant</vh></v>
<v t="ekr.20040701145236.78"><vh>_hasGlobal</vh></v>
<v t="ekr.20040701145236.79"><vh>_checkGlobal</vh></v>
<v t="ekr.20040701145236.80"><vh>_handleComparison</vh></v>
<v t="ekr.20040701145236.81"><vh>_handleImport</vh></v>
<v t="ekr.20040701145236.82"><vh>_handleImportFrom</vh></v>
<v t="ekr.20040701145236.83"><vh>_getFormatInfo</vh></v>
<v t="ekr.20040701145236.84"><vh>_getConstant</vh></v>
<v t="ekr.20040701145236.85"><vh>_getFormatString</vh></v>
<v t="ekr.20040701145236.86"><vh>_getFormatWarnings</vh></v>
<v t="ekr.20040701145236.87"><vh>_checkAttributeType</vh></v>
<v t="ekr.20040701145236.88"><vh>_getTypeStr</vh></v>
<v t="ekr.20040701145236.89"><vh>_getLineNum</vh></v>
<v t="ekr.20040701145236.90"><vh>class Code</vh>
<v t="ekr.20040701145236.91"><vh>&lt;&lt; class Code declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.92"><vh>__init__</vh></v>
<v t="ekr.20040701145236.93"><vh>init</vh></v>
<v t="ekr.20040701145236.94"><vh>getLineNum</vh></v>
<v t="ekr.20040701145236.95"><vh>getWarning</vh></v>
<v t="ekr.20040701145236.96"><vh>addWarning</vh></v>
<v t="ekr.20040701145236.97"><vh>popNextOp</vh></v>
<v t="ekr.20040701145236.98"><vh>nextOpInfo</vh></v>
<v t="ekr.20040701145236.99"><vh>getFirstOp</vh></v>
<v t="ekr.20040701145236.100"><vh>pushStack</vh></v>
<v t="ekr.20040701145236.101"><vh>popStack</vh></v>
<v t="ekr.20040701145236.102"><vh>popStackItems</vh></v>
<v t="ekr.20040701145236.103"><vh>unpack</vh></v>
<v t="ekr.20040701145236.104"><vh>__getStringStackType</vh></v>
<v t="ekr.20040701145236.105"><vh>__getStackType</vh></v>
<v t="ekr.20040701145236.106"><vh>setType</vh></v>
<v t="ekr.20040701145236.107"><vh>addReturn</vh></v>
<v t="ekr.20040701145236.108"><vh>addRaise</vh></v>
<v t="ekr.20040701145236.109"><vh>addBranch</vh></v>
<v t="ekr.20040701145236.110"><vh>removeBranch</vh></v>
<v t="ekr.20040701145236.111"><vh>remove_unreachable_code</vh></v>
<v t="ekr.20040701145236.112"><vh>updateCheckerArgs</vh></v>
<v t="ekr.20040701145236.113"><vh>updateModuleLineNums</vh></v>
</v>
<v t="ekr.20040701145236.114"><vh>class CodeSource</vh>
<v t="ekr.20040701145236.115"><vh>&lt;&lt; class CodeSource declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.116"><vh>__init__</vh></v>
</v>
<v t="ekr.20040701145236.117"><vh>_checkException</vh></v>
<v t="ekr.20040701145236.118"><vh>_checkAssign</vh></v>
<v t="ekr.20040701145236.119"><vh>_checkVariableOperationOnItself</vh></v>
<v t="ekr.20040701145236.120"><vh>_checkFutureKeywords</vh></v>
<v t="ekr.20040701145236.121"><vh>_STORE_NAME</vh></v>
<v t="ekr.20040701145236.122"><vh>_checkLoadGlobal</vh></v>
<v t="ekr.20040701145236.123"><vh>_LOAD_NAME</vh></v>
<v t="ekr.20040701145236.124"><vh>_LOAD_DEREF</vh></v>
<v t="ekr.20040701145236.125"><vh>_DELETE_NAME</vh></v>
<v t="ekr.20040701145236.126"><vh>_LOAD_CONST</vh></v>
<v t="ekr.20040701145236.127"><vh>_checkLocalShadow</vh></v>
<v t="ekr.20040701145236.128"><vh>_checkShadowBuiltin</vh></v>
<v t="ekr.20040701145236.129"><vh>_checkLoadLocal</vh></v>
<v t="ekr.20040701145236.130"><vh>_handleLoadLocal</vh></v>
<v t="ekr.20040701145236.131"><vh>_LOAD_FAST</vh></v>
<v t="ekr.20040701145236.132"><vh>_STORE_FAST</vh></v>
<v t="ekr.20040701145236.133"><vh>_DELETE_FAST</vh></v>
<v t="ekr.20040701145236.134"><vh>_checkAttribute</vh></v>
<v t="ekr.20040701145236.135"><vh>_checkExcessiveReferences</vh></v>
<v t="ekr.20040701145236.136"><vh>_checkDeprecated</vh></v>
<v t="ekr.20040701145236.137"><vh>_LOAD_ATTR</vh></v>
<v t="ekr.20040701145236.138"><vh>_ok_to_set_attr</vh></v>
<v t="ekr.20040701145236.139"><vh>_STORE_ATTR</vh></v>
<v t="ekr.20040701145236.140"><vh>_DELETE_ATTR</vh></v>
<v t="ekr.20040701145236.141"><vh>_getExceptionInfo</vh></v>
<v t="ekr.20040701145236.142"><vh>_checkCatchException</vh></v>
<v t="ekr.20040701145236.143"><vh>_handleExceptionChecks</vh></v>
<v t="ekr.20040701145236.144"><vh>_checkBoolean</vh></v>
<v t="ekr.20040701145236.145"><vh>_COMPARE_OP</vh></v>
<v t="ekr.20040701145236.146"><vh>_IMPORT_NAME</vh></v>
<v t="ekr.20040701145236.147"><vh>_IMPORT_FROM</vh></v>
<v t="ekr.20040701145236.148"><vh>_IMPORT_STAR</vh></v>
<v t="ekr.20040701145236.149"><vh>_shouldIgnoreCodeOptimizations</vh></v>
<v t="ekr.20040701145236.150"><vh>_shouldIgnoreNoEffectWarning</vh></v>
<v t="ekr.20040701145236.151"><vh>_DUP_TOP</vh></v>
<v t="ekr.20040701145236.152"><vh>_popn</vh></v>
<v t="ekr.20040701145236.153"><vh>_DELETE_SUBSCR</vh></v>
<v t="ekr.20040701145236.154"><vh>_STORE_SUBSCR</vh></v>
<v t="ekr.20040701145236.155"><vh>_CALL_FUNCTION</vh></v>
<v t="ekr.20040701145236.156"><vh>_CALL_FUNCTION_VAR</vh></v>
<v t="ekr.20040701145236.157"><vh>_CALL_FUNCTION_KW</vh></v>
<v t="ekr.20040701145236.158"><vh>_CALL_FUNCTION_VAR_KW</vh></v>
<v t="ekr.20040701145236.159"><vh>_MAKE_FUNCTION</vh></v>
<v t="ekr.20040701145236.160"><vh>_MAKE_CLOSURE</vh></v>
<v t="ekr.20040701145236.161"><vh>_BUILD_MAP</vh></v>
<v t="ekr.20040701145236.162"><vh>_BUILD_TUPLE</vh></v>
<v t="ekr.20040701145236.163"><vh>_BUILD_LIST</vh></v>
<v t="ekr.20040701145236.164"><vh>_BUILD_CLASS</vh></v>
<v t="ekr.20040701145236.165"><vh>_LIST_APPEND</vh></v>
<v t="ekr.20040701145236.166"><vh>_modifyStackName</vh></v>
<v t="ekr.20040701145236.167"><vh>_UNARY_CONVERT</vh></v>
<v t="ekr.20040701145236.168"><vh>_UNARY_POSITIVE</vh></v>
<v t="ekr.20040701145236.169"><vh>_UNARY_NEGATIVE</vh></v>
<v t="ekr.20040701145236.170"><vh>_UNARY_NOT</vh></v>
<v t="ekr.20040701145236.171"><vh>_UNARY_INVERT</vh></v>
<v t="ekr.20040701145236.172"><vh>_popStackRef</vh></v>
<v t="ekr.20040701145236.173"><vh>_popModifiedStack</vh></v>
<v t="ekr.20040701145236.174"><vh>_pop</vh></v>
<v t="ekr.20040701145236.175"><vh>_popModified</vh></v>
<v t="ekr.20040701145236.176"><vh>_checkModifyNoOp</vh></v>
<v t="ekr.20040701145236.177"><vh>_BINARY_AND</vh></v>
<v t="ekr.20040701145236.178"><vh>_BINARY_OR</vh></v>
<v t="ekr.20040701145236.179"><vh>_BINARY_XOR</vh></v>
<v t="ekr.20040701145236.180"><vh>_PRINT_ITEM_TO</vh></v>
<v t="ekr.20040701145236.181"><vh>_coerce_type</vh></v>
<v t="ekr.20040701145236.182"><vh>_BINARY_ADD</vh></v>
<v t="ekr.20040701145236.183"><vh>_BINARY_SUBTRACT</vh></v>
<v t="ekr.20040701145236.184"><vh>_BINARY_SUBSCR</vh></v>
<v t="ekr.20040701145236.185"><vh>_isint</vh></v>
<v t="ekr.20040701145236.186"><vh>_BINARY_DIVIDE</vh></v>
<v t="ekr.20040701145236.187"><vh>_BINARY_TRUE_DIVIDE</vh></v>
<v t="ekr.20040701145236.188"><vh>_BINARY_MULTIPLY</vh></v>
<v t="ekr.20040701145236.189"><vh>_BINARY_MODULO</vh></v>
<v t="ekr.20040701145236.190"><vh>_ROT_TWO</vh></v>
<v t="ekr.20040701145236.191"><vh>_SETUP_EXCEPT</vh></v>
<v t="ekr.20040701145236.192"><vh>_SETUP_FINALLY</vh></v>
<v t="ekr.20040701145236.193"><vh>_END_FINALLY</vh></v>
<v t="ekr.20040701145236.194"><vh>_LINE_NUM</vh></v>
<v t="ekr.20040701145236.195"><vh>_UNPACK_SEQUENCE</vh></v>
<v t="ekr.20040701145236.196"><vh>_SLICE_1_ARG</vh></v>
<v t="ekr.20040701145236.197"><vh>_SLICE3</vh></v>
<v t="ekr.20040701145236.198"><vh>_check_string_iteration</vh></v>
<v t="ekr.20040701145236.199"><vh>_FOR_LOOP</vh></v>
<v t="ekr.20040701145236.200"><vh>_GET_ITER</vh></v>
<v t="ekr.20040701145236.201"><vh>_FOR_ITER</vh></v>
<v t="ekr.20040701145236.202"><vh>_jump</vh></v>
<v t="ekr.20040701145236.203"><vh>_skip_loops</vh></v>
<v t="ekr.20040701145236.204"><vh>_is_unreachable</vh></v>
<v t="ekr.20040701145236.205"><vh>_shouldIgnoreBogusJumps</vh></v>
<v t="ekr.20040701145236.206"><vh>_checkConstantCondition</vh></v>
<v t="ekr.20040701145236.207"><vh>_jump_conditional</vh></v>
<v t="ekr.20040701145236.208"><vh>_JUMP_IF_FALSE</vh></v>
<v t="ekr.20040701145236.209"><vh>_JUMP_IF_TRUE</vh></v>
<v t="ekr.20040701145236.210"><vh>_JUMP_FORWARD</vh></v>
<v t="ekr.20040701145236.211"><vh>_RETURN_VALUE</vh></v>
<v t="ekr.20040701145236.212"><vh>_EXEC_STMT</vh></v>
<v t="ekr.20040701145236.213"><vh>_checkStrException</vh></v>
<v t="ekr.20040701145236.214"><vh>_RAISE_VARARGS</vh></v>
</v>
<v t="ekr.20040701145236.232"><vh>@file c:/python23/Lib/site-packages/pychecker\function.py</vh>
<v t="ekr.20040701145236.233"><vh>&lt;&lt; function declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.234"><vh>class _ReturnValues</vh>
<v t="ekr.20040701145236.235"><vh>__init__</vh></v>
<v t="ekr.20040701145236.236"><vh>returnsNoValue</vh></v>
</v>
<v t="ekr.20040701145236.237"><vh>class FakeCode</vh>
<v t="ekr.20040701145236.238"><vh>&lt;&lt; class FakeCode declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.239"><vh>__init__</vh></v>
</v>
<v t="ekr.20040701145236.240"><vh>class FakeFunction</vh>
<v t="ekr.20040701145236.241"><vh>&lt;&lt; class FakeFunction declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.242"><vh>__init__</vh></v>
<v t="ekr.20040701145236.243"><vh>__str__</vh></v>
<v t="ekr.20040701145236.244"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040701145236.245"><vh>class Function</vh>
<v t="ekr.20040701145236.246"><vh>&lt;&lt; class Function declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.247"><vh>__init__</vh></v>
<v t="ekr.20040701145236.248"><vh>__str__</vh></v>
<v t="ekr.20040701145236.249"><vh>__repr__</vh></v>
<v t="ekr.20040701145236.250"><vh>arguments</vh></v>
<v t="ekr.20040701145236.251"><vh>isParam</vh></v>
<v t="ekr.20040701145236.252"><vh>isStaticMethod</vh></v>
<v t="ekr.20040701145236.253"><vh>isClassMethod</vh></v>
<v t="ekr.20040701145236.254"><vh>defaultValue</vh></v>
<v t="ekr.20040701145236.255"><vh>varArgName</vh></v>
</v>
<v t="ekr.20040701145236.256"><vh>create_fake</vh></v>
<v t="ekr.20040701145236.257"><vh>create_from_file</vh></v>
<v t="ekr.20040701145236.258"><vh>_co_flags_equal</vh></v>
<v t="ekr.20040701145236.259"><vh>same_signature</vh></v>
</v>
<v t="ekr.20040701145236.260"><vh>@file c:/python23/Lib/site-packages/pychecker\msgs.py</vh></v>
<v t="ekr.20040701145236.261"><vh>@file c:/python23/Lib/site-packages/pychecker\OP.py</vh>
<v t="ekr.20040701145236.262"><vh>&lt;&lt; OP declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.263"><vh>LINE_NUM</vh></v>
<v t="ekr.20040701145236.264"><vh>LOAD_GLOBAL</vh></v>
<v t="ekr.20040701145236.265"><vh>LOAD_CONST</vh></v>
<v t="ekr.20040701145236.266"><vh>LOAD_FAST</vh></v>
<v t="ekr.20040701145236.267"><vh>LOAD_ATTR</vh></v>
<v t="ekr.20040701145236.268"><vh>STORE_ATTR</vh></v>
<v t="ekr.20040701145236.269"><vh>POP_TOP</vh></v>
<v t="ekr.20040701145236.270"><vh>IMPORT_FROM</vh></v>
<v t="ekr.20040701145236.271"><vh>IMPORT_STAR</vh></v>
<v t="ekr.20040701145236.272"><vh>UNARY_POSITIVE</vh></v>
<v t="ekr.20040701145236.273"><vh>UNARY_NEGATIVE</vh></v>
<v t="ekr.20040701145236.274"><vh>UNARY_INVERT</vh></v>
<v t="ekr.20040701145236.275"><vh>RETURN_VALUE</vh></v>
<v t="ekr.20040701145236.276"><vh>JUMP_FORWARD</vh></v>
<v t="ekr.20040701145236.277"><vh>JUMP_ABSOLUTE</vh></v>
<v t="ekr.20040701145236.278"><vh>FOR_ITER</vh></v>
<v t="ekr.20040701145236.279"><vh>FOR_LOOP</vh></v>
<v t="ekr.20040701145236.280"><vh>SETUP_LOOP</vh></v>
<v t="ekr.20040701145236.281"><vh>BREAK_LOOP</vh></v>
<v t="ekr.20040701145236.282"><vh>RAISE_VARARGS</vh></v>
<v t="ekr.20040701145236.283"><vh>POP_BLOCK</vh></v>
<v t="ekr.20040701145236.284"><vh>END_FINALLY</vh></v>
<v t="ekr.20040701145236.285"><vh>UNPACK_SEQUENCE</vh></v>
<v t="ekr.20040701145236.286"><vh>IS_CONDITIONAL_JUMP</vh></v>
<v t="ekr.20040701145236.287"><vh>IS_NOT</vh></v>
<v t="ekr.20040701145236.288"><vh>getOperand</vh></v>
<v t="ekr.20040701145236.289"><vh>getLabel</vh></v>
<v t="ekr.20040701145236.290"><vh>getInfo</vh></v>
<v t="ekr.20040701145236.291"><vh>initFuncCode</vh></v>
<v t="ekr.20040701145236.292"><vh>conditional</vh></v>
<v t="ekr.20040701145236.293"><vh>class Name</vh>
<v t="ekr.20040701145236.294"><vh>&lt;&lt; class Name declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.295"><vh>__getitem__</vh></v>
</v>
</v>
<v t="ekr.20040701145236.296"><vh>@file c:/python23/Lib/site-packages/pychecker\options.py</vh>
<v t="ekr.20040701145236.297"><vh>&lt;&lt; options declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.298"><vh>col_weight</vh></v>
<v t="ekr.20040701145236.299"><vh>spawn</vh></v>
<v t="ekr.20040701145236.300"><vh>edit</vh></v>
<v t="ekr.20040701145236.301"><vh>closeCB</vh></v>
<v t="ekr.20040701145236.302"><vh>class Results</vh>
<v t="ekr.20040701145236.303"><vh>&lt;&lt; class Results declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.304"><vh>__init__</vh></v>
<v t="ekr.20040701145236.305"><vh>show</vh></v>
<v t="ekr.20040701145236.306"><vh>hide</vh></v>
<v t="ekr.20040701145236.307"><vh>line</vh></v>
<v t="ekr.20040701145236.308"><vh>showFile</vh></v>
<v t="ekr.20040701145236.309"><vh>selectLine</vh></v>
</v>
<v t="ekr.20040701145236.310"><vh>class ConfigDialog</vh>
<v t="ekr.20040701145236.311"><vh>&lt;&lt; class ConfigDialog declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.312"><vh>__init__</vh></v>
<v t="ekr.20040701145236.313"><vh>_add_fields</vh></v>
<v t="ekr.20040701145236.314"><vh>_add_group</vh></v>
<v t="ekr.20040701145236.315"><vh>main</vh></v>
<v t="ekr.20040701145236.316"><vh>help</vh></v>
<v t="ekr.20040701145236.317"><vh>focus</vh></v>
<v t="ekr.20040701145236.318"><vh>click</vh></v>
<v t="ekr.20040701145236.319"><vh>ok</vh></v>
<v t="ekr.20040701145236.320"><vh>default</vh></v>
<v t="ekr.20040701145236.321"><vh>file</vh></v>
<v t="ekr.20040701145236.322"><vh>check</vh></v>
</v>
</v>
<v t="ekr.20040701145236.323"><vh>@file c:/python23/Lib/site-packages/pychecker\OptionTypes.py</vh>
<v t="ekr.20040701145236.324"><vh>&lt;&lt; OptionTypes declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.325"><vh>bool</vh></v>
<v t="ekr.20040701145236.326"><vh>class Base</vh>
<v t="ekr.20040701145236.327"><vh>&lt;&lt; class Base declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.328"><vh>__init__</vh></v>
<v t="ekr.20040701145236.329"><vh>name</vh></v>
<v t="ekr.20040701145236.330"><vh>set</vh></v>
</v>
<v t="ekr.20040701145236.331"><vh>class Boolean</vh>
<v t="ekr.20040701145236.332"><vh>&lt;&lt; class Boolean declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.333"><vh>__init__</vh></v>
<v t="ekr.20040701145236.334"><vh>field</vh></v>
<v t="ekr.20040701145236.335"><vh>arg</vh></v>
</v>
<v t="ekr.20040701145236.336"><vh>class Number</vh>
<v t="ekr.20040701145236.337"><vh>&lt;&lt; class Number declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.338"><vh>__init__</vh></v>
<v t="ekr.20040701145236.339"><vh>field</vh></v>
<v t="ekr.20040701145236.340"><vh>arg</vh></v>
</v>
<v t="ekr.20040701145236.341"><vh>class Text</vh>
<v t="ekr.20040701145236.342"><vh>&lt;&lt; class Text declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.343"><vh>__init__</vh></v>
<v t="ekr.20040701145236.344"><vh>width</vh></v>
<v t="ekr.20040701145236.345"><vh>field</vh></v>
<v t="ekr.20040701145236.346"><vh>arg</vh></v>
</v>
<v t="ekr.20040701145236.347"><vh>join</vh></v>
<v t="ekr.20040701145236.348"><vh>class List</vh>
<v t="ekr.20040701145236.349"><vh>&lt;&lt; class List declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.350"><vh>__init__</vh></v>
<v t="ekr.20040701145236.351"><vh>set</vh></v>
</v>
</v>
<v t="ekr.20040701145236.352"><vh>@file c:/python23/Lib/site-packages/pychecker\printer.py</vh>
<v t="ekr.20040701145236.353"><vh>&lt;&lt; printer declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.354"><vh>printFunction</vh></v>
<v t="ekr.20040701145236.355"><vh>module</vh></v>
<v t="ekr.20040701145236.356"><vh>attrs</vh></v>
</v>
<v t="ekr.20040701145236.357"><vh>@file c:/python23/Lib/site-packages/pychecker\python.py</vh>
<v t="ekr.20040701145236.358"><vh>&lt;&lt; python declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.359"><vh>tryAddGlobal</vh></v>
<v t="ekr.20040701145236.360"><vh>_setupBuiltinMethods</vh></v>
<v t="ekr.20040701145236.361"><vh>_setupBuiltinAttrs</vh></v>
</v>
<v t="ekr.20040701145236.362"><vh>@file c:/python23/Lib/site-packages/pychecker\Stack.py</vh>
<v t="ekr.20040701145236.363"><vh>&lt;&lt; Stack declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.364"><vh>class Item</vh>
<v t="ekr.20040701145236.365"><vh>&lt;&lt; class Item declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.366"><vh>__init__</vh></v>
<v t="ekr.20040701145236.367"><vh>__str__</vh></v>
<v t="ekr.20040701145236.368"><vh>__repr__</vh></v>
<v t="ekr.20040701145236.369"><vh>isNone</vh></v>
<v t="ekr.20040701145236.370"><vh>isImplicitNone</vh></v>
<v t="ekr.20040701145236.371"><vh>isMethodCall</vh></v>
<v t="ekr.20040701145236.372"><vh>isLocals</vh></v>
<v t="ekr.20040701145236.373"><vh>setStringType</vh></v>
<v t="ekr.20040701145236.374"><vh>getType</vh></v>
<v t="ekr.20040701145236.375"><vh>getName</vh></v>
<v t="ekr.20040701145236.376"><vh>addAttribute</vh></v>
</v>
<v t="ekr.20040701145236.377"><vh>makeDict</vh></v>
<v t="ekr.20040701145236.378"><vh>makeTuple</vh></v>
<v t="ekr.20040701145236.379"><vh>makeList</vh></v>
<v t="ekr.20040701145236.380"><vh>makeFuncReturnValue</vh></v>
<v t="ekr.20040701145236.381"><vh>makeComparison</vh></v>
</v>
<v t="ekr.20040701145236.382"><vh>@file c:/python23/Lib/site-packages/pychecker\utils.py</vh>
<v t="ekr.20040701145236.383"><vh>&lt;&lt; utils declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.384"><vh>cfg</vh></v>
<v t="ekr.20040701145236.385"><vh>initConfig</vh></v>
<v t="ekr.20040701145236.386"><vh>pushConfig</vh></v>
<v t="ekr.20040701145236.387"><vh>popConfig</vh></v>
<v t="ekr.20040701145236.388"><vh>shouldUpdateArgs</vh></v>
<v t="ekr.20040701145236.389"><vh>updateCheckerArgs</vh></v>
<v t="ekr.20040701145236.390"><vh>debug</vh></v>
<v t="ekr.20040701145236.391"><vh>pythonVersion</vh></v>
<v t="ekr.20040701145236.392"><vh>startswith</vh></v>
<v t="ekr.20040701145236.393"><vh>endswith</vh></v>
<v t="ekr.20040701145236.394"><vh>std_repr</vh></v>
</v>
<v t="ekr.20040701145236.395"><vh>@file c:/python23/Lib/site-packages/pychecker\warn.py</vh>
<v t="ekr.20040701145236.396"><vh>&lt;&lt; warn declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.397"><vh>cfg</vh></v>
<v t="ekr.20040701145236.398"><vh>_checkSelfArg</vh></v>
<v t="ekr.20040701145236.399"><vh>_checkNoSelfArg</vh></v>
<v t="ekr.20040701145236.400"><vh>_checkSubclass</vh></v>
<v t="ekr.20040701145236.401"><vh>_checkReturnWarnings</vh></v>
<v t="ekr.20040701145236.402"><vh>_checkComplex</vh></v>
<v t="ekr.20040701145236.403"><vh>_checkCode</vh></v>
<v t="ekr.20040701145236.404"><vh>_name_unused</vh></v>
<v t="ekr.20040701145236.405"><vh>_checkUnusedParam</vh></v>
<v t="ekr.20040701145236.406"><vh>_handleNestedCode</vh></v>
<v t="ekr.20040701145236.407"><vh>_findUnreachableCode</vh></v>
<v t="ekr.20040701145236.408"><vh>_checkFunction</vh></v>
<v t="ekr.20040701145236.409"><vh>_getUnused</vh></v>
<v t="ekr.20040701145236.410"><vh>_get_func_info</vh></v>
<v t="ekr.20040701145236.411"><vh>_baseInitCalled</vh></v>
<v t="ekr.20040701145236.412"><vh>_checkBaseClassInit</vh></v>
<v t="ekr.20040701145236.413"><vh>_checkOverridenMethods</vh></v>
<v t="ekr.20040701145236.414"><vh>_updateFunctionWarnings</vh></v>
<v t="ekr.20040701145236.415"><vh>getBlackList</vh></v>
<v t="ekr.20040701145236.416"><vh>getStandardLibrary</vh></v>
<v t="ekr.20040701145236.417"><vh>normalize_path</vh></v>
<v t="ekr.20040701145236.418"><vh>removeWarnings</vh></v>
<v t="ekr.20040701145236.419"><vh>class _SuppressionError</vh>
<v t="ekr.20040701145236.420"><vh>&lt;&lt; class _SuppressionError declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040701145236.421"><vh>_updateSuppressions</vh></v>
<v t="ekr.20040701145236.422"><vh>getSuppression</vh></v>
<v t="ekr.20040701145236.423"><vh>_findFunctionWarnings</vh></v>
<v t="ekr.20040701145236.424"><vh>_getModuleFromFilename</vh></v>
<v t="ekr.20040701145236.425"><vh>_findClassWarnings</vh></v>
<v t="ekr.20040701145236.426"><vh>find</vh></v>
</v>
<v t="ekr.20040701145236.427"><vh>@file c:/python23/Lib/site-packages/pychecker\Warning.py</vh>
<v t="ekr.20040701145236.428"><vh>&lt;&lt; Warning declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.429"><vh>class Warning</vh>
<v t="ekr.20040701145236.430"><vh>&lt;&lt; class Warning declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.431"><vh>__init__</vh></v>
<v t="ekr.20040701145236.432"><vh>__cmp__</vh></v>
<v t="ekr.20040701145236.433"><vh>format</vh></v>
<v t="ekr.20040701145236.434"><vh>output</vh></v>
</v>
</v>
<v t="ekr.20040701145236.435"><vh>@file c:/python23/Lib/site-packages/pychecker\__init__.py</vh></v>
</v>
<v t="ekr.20040701041311.1"><vh>Files...</vh>
<v t="ekr.20040701145236.2" tnodeList="ekr.20040701145236.2,ekr.20040701145236.3,ekr.20040701145236.4,ekr.20040701145236.5,ekr.20040701145236.6,ekr.20040701145236.7,ekr.20040701145236.8,ekr.20040701145236.9,ekr.20040701145236.10,ekr.20040701145236.11,ekr.20040701145236.12,ekr.20040701145236.13,ekr.20040701145236.14,ekr.20040701145236.15,ekr.20040701145236.16,ekr.20040701145236.17,ekr.20040701145236.18,ekr.20040701145236.19,ekr.20040701145236.20,ekr.20040701145236.21,ekr.20040701145236.22,ekr.20040701145236.23,ekr.20040701145236.24,ekr.20040701145236.25,ekr.20040701145236.26,ekr.20040701145236.27,ekr.20040701145236.28,ekr.20040701145236.29,ekr.20040701145236.30,ekr.20040701145236.31,ekr.20040701145236.32,ekr.20040701145236.33,ekr.20040701145236.34,ekr.20040701145236.35,ekr.20040701145236.36,ekr.20040701145236.37,ekr.20040701145236.38,ekr.20040701145236.39,ekr.20040701145236.40,ekr.20040701145236.41,ekr.20040701145236.42,ekr.20040701145236.43,ekr.20040701145236.44,ekr.20040701145236.45,ekr.20040701145236.46,ekr.20040701145236.47,ekr.20040701145236.48,ekr.20040701145236.49,ekr.20040701145236.50,ekr.20040701145236.51,ekr.20040701145236.52,ekr.20040701145236.53,ekr.20040701145236.54,ekr.20040701145236.55,ekr.20040701145236.56"><vh>@file c:/python23/Lib/site-packages/pychecker\checker.py</vh>
<v t="ekr.20040701145236.3"><vh>&lt;&lt; checker declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.4"><vh>setupNamespace</vh></v>
<v t="ekr.20040701145236.5"><vh>cfg</vh></v>
<v t="ekr.20040701145236.6"><vh>_flattenList</vh></v>
<v t="ekr.20040701145236.7"><vh>getModules</vh></v>
<v t="ekr.20040701145236.8"><vh>_q_file</vh></v>
<v t="ekr.20040701145236.9"><vh>_q_find_module</vh></v>
<v t="ekr.20040701145236.10"><vh>_findModule</vh></v>
<v t="ekr.20040701145236.11"><vh>class Variable</vh>
<v t="ekr.20040701145236.12"><vh>&lt;&lt; class Variable declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.13"><vh>__init__</vh></v>
<v t="ekr.20040701145236.14"><vh>__str__</vh></v>
</v>
<v t="ekr.20040701145236.15"><vh>_filterDir</vh></v>
<v t="ekr.20040701145236.16"><vh>_getClassTokens</vh></v>
<v t="ekr.20040701145236.17"><vh>class Class</vh>
<v t="ekr.20040701145236.18"><vh>&lt;&lt; class Class declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.19"><vh>__init__</vh></v>
<v t="ekr.20040701145236.20"><vh>__str__</vh></v>
<v t="ekr.20040701145236.21"><vh>getFirstLine</vh></v>
<v t="ekr.20040701145236.22"><vh>allBaseClasses</vh></v>
<v t="ekr.20040701145236.23"><vh>__getMethodName</vh></v>
<v t="ekr.20040701145236.24"><vh>addMethod</vh></v>
<v t="ekr.20040701145236.25"><vh>addMethods</vh></v>
<v t="ekr.20040701145236.26"><vh>addMembers</vh></v>
<v t="ekr.20040701145236.27"><vh>addMembersFromMethod</vh></v>
<v t="ekr.20040701145236.28"><vh>cleanupMemberRefs</vh></v>
<v t="ekr.20040701145236.29"><vh>abstractMethod</vh></v>
<v t="ekr.20040701145236.30"><vh>isAbstract</vh></v>
</v>
<v t="ekr.20040701145236.31"><vh>_getLineInFile</vh></v>
<v t="ekr.20040701145236.32"><vh>importError</vh></v>
<v t="ekr.20040701145236.33"><vh>_getPyFile</vh></v>
<v t="ekr.20040701145236.34"><vh>class Module</vh>
<v t="ekr.20040701145236.35"><vh>&lt;&lt; class Module declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.36"><vh>__init__</vh></v>
<v t="ekr.20040701145236.37"><vh>__str__</vh></v>
<v t="ekr.20040701145236.38"><vh>addVariable</vh></v>
<v t="ekr.20040701145236.39"><vh>addFunction</vh></v>
<v t="ekr.20040701145236.40"><vh>__addAttributes</vh></v>
<v t="ekr.20040701145236.41"><vh>addClass</vh></v>
<v t="ekr.20040701145236.42"><vh>addModule</vh></v>
<v t="ekr.20040701145236.43"><vh>filename</vh></v>
<v t="ekr.20040701145236.44"><vh>load</vh></v>
<v t="ekr.20040701145236.45"><vh>initModule</vh></v>
<v t="ekr.20040701145236.46"><vh>_initModule</vh></v>
<v t="ekr.20040701145236.47"><vh>setupMainCode</vh></v>
<v t="ekr.20040701145236.48"><vh>_setupMainCode</vh></v>
</v>
<v t="ekr.20040701145236.49"><vh>getAllModules</vh></v>
<v t="ekr.20040701145236.50"><vh>fixupBuiltinModules</vh></v>
<v t="ekr.20040701145236.51"><vh>_printWarnings</vh></v>
<v t="ekr.20040701145236.52"><vh>processFiles</vh></v>
<v t="ekr.20040701145236.53"><vh>getWarnings</vh></v>
<v t="ekr.20040701145236.54"><vh>_print_processing</vh></v>
<v t="ekr.20040701145236.55"><vh>main</vh></v>
<v t="ekr.20040701145236.56"><vh>_get_unique_warnings</vh></v>
</v>
<v t="ekr.20040701145236.215" tnodeList="ekr.20040701145236.215,ekr.20040701145236.216,ekr.20040701145236.217,ekr.20040701145236.218,ekr.20040701145236.219,ekr.20040701145236.220,ekr.20040701145236.221,ekr.20040701145236.222,ekr.20040701145236.223,ekr.20040701145236.224,ekr.20040701145236.225,ekr.20040701145236.226,ekr.20040701145236.227,ekr.20040701145236.228,ekr.20040701145236.229,ekr.20040701145236.230,ekr.20040701145236.231"><vh>@file c:/python23/Lib/site-packages/pychecker\Config.py</vh>
<v t="ekr.20040701145236.216"><vh>&lt;&lt; Config declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.217"><vh>init (Config.py) Defines _SHORT_ARGS &amp; _Long_ARGS</vh></v>
<v t="ekr.20040701145236.218"><vh>_getRCfiles</vh></v>
<v t="ekr.20040701145236.219"><vh>outputRc</vh></v>
<v t="ekr.20040701145236.220"><vh>class UsageError</vh></v>
<v t="ekr.20040701145236.221"><vh>_getSuppressions</vh></v>
<v t="ekr.20040701145236.222"><vh>class Config</vh>
<v t="ekr.20040701145236.223"><vh>&lt;&lt; class Config declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.224"><vh>__init__ Config.py class config (Hard-coded defaults)</vh></v>
<v t="ekr.20040701145236.225"><vh>loadFile</vh></v>
<v t="ekr.20040701145236.226"><vh>loadFiles</vh></v>
<v t="ekr.20040701145236.227"><vh>processArgs</vh></v>
</v>
<v t="ekr.20040701145236.228"><vh>errors_only</vh></v>
<v t="ekr.20040701145236.229"><vh>printArg</vh></v>
<v t="ekr.20040701145236.230"><vh>usage</vh></v>
<v t="ekr.20040701145236.231"><vh>setupFromArgs</vh></v>
</v>
<v t="ekr.20040701040524.64"><vh>CodeChecks.py  (Builds data structures and checks them)</vh>
<v t="ekr.20040701040524.65"><vh>&lt;&lt; CodeChecks imports &gt;&gt;</vh></v>
<v t="ekr.20040701040524.66"><vh>cfg</vh></v>
<v t="ekr.20040701040524.67"><vh>getFunctionArgErr</vh></v>
<v t="ekr.20040701040524.68"><vh>_checkFunctionArgCount</vh></v>
<v t="ekr.20040701040524.69"><vh>_checkFunctionArgs</vh></v>
<v t="ekr.20040701040524.70"><vh>_getReferenceFromModule</vh></v>
<v t="ekr.20040701040524.71"><vh>_getFunction</vh></v>
<v t="ekr.20040701040524.72"><vh>_checkBuiltin (gives const getattr warning)</vh></v>
<v t="ekr.20040701040524.73"><vh>_checkModifyDefaultArg</vh></v>
<v t="ekr.20040701040524.74"><vh>_isexception</vh></v>
<v t="ekr.20040701040524.75"><vh>_checkStringFind</vh></v>
<v t="ekr.20040701040524.76"><vh>_checkAbstract</vh></v>
<v t="ekr.20040701040524.77"><vh>_checkReturnValueUse</vh></v>
<v t="ekr.20040701040524.78"><vh>_handleFunctionCall</vh></v>
<v t="ekr.20040701040524.79"><vh>_classHasAttribute</vh></v>
<v t="ekr.20040701040524.80"><vh>_checkClassAttribute</vh></v>
<v t="ekr.20040701040524.81"><vh>_checkModuleAttribute</vh></v>
<v t="ekr.20040701040524.82"><vh>_getGlobalName</vh></v>
<v t="ekr.20040701040524.83"><vh>_checkNoEffect</vh></v>
<v t="ekr.20040701040524.84"><vh>_makeConstant</vh></v>
<v t="ekr.20040701040524.85"><vh>_hasGlobal</vh></v>
<v t="ekr.20040701040524.86"><vh>_checkGlobal</vh></v>
<v t="ekr.20040701040524.87"><vh>_handleComparison</vh></v>
<v t="ekr.20040701040524.88"><vh>_handleImport</vh></v>
<v t="ekr.20040701040524.89"><vh>_handleImportFrom</vh></v>
<v t="ekr.20040701040524.90"><vh>_getFormatInfo</vh></v>
<v t="ekr.20040701040524.91"><vh>_getConstant</vh></v>
<v t="ekr.20040701040524.92"><vh>_getFormatString</vh></v>
<v t="ekr.20040701040524.93"><vh>_getFormatWarnings</vh></v>
<v t="ekr.20040701040524.94"><vh>_checkAttributeType</vh></v>
<v t="ekr.20040701040524.95"><vh>_getTypeStr</vh></v>
<v t="ekr.20040701040524.96"><vh>_getLineNum</vh></v>
<v t="ekr.20040701040524.97"><vh>class Code</vh>
<v t="ekr.20040701040524.98"><vh>&lt;&lt; class Code declarations &gt;&gt;</vh></v>
<v t="ekr.20040701040524.99"><vh>__init__</vh></v>
<v t="ekr.20040701040524.100"><vh>init</vh></v>
<v t="ekr.20040701040524.101"><vh>getLineNum</vh></v>
<v t="ekr.20040701040524.102"><vh>getWarning</vh></v>
<v t="ekr.20040701040524.103"><vh>addWarning</vh></v>
<v t="ekr.20040701040524.104"><vh>popNextOp</vh></v>
<v t="ekr.20040701040524.105"><vh>nextOpInfo</vh></v>
<v t="ekr.20040701040524.106"><vh>getFirstOp</vh></v>
<v t="ekr.20040701040524.107"><vh>pushStack</vh></v>
<v t="ekr.20040701040524.108"><vh>popStack</vh></v>
<v t="ekr.20040701040524.109"><vh>popStackItems</vh></v>
<v t="ekr.20040701040524.110"><vh>unpack</vh></v>
<v t="ekr.20040701040524.111"><vh>__getStringStackType</vh></v>
<v t="ekr.20040701040524.112"><vh>__getStackType</vh></v>
<v t="ekr.20040701040524.113"><vh>setType</vh></v>
<v t="ekr.20040701040524.114"><vh>addReturn</vh></v>
<v t="ekr.20040701040524.115"><vh>addRaise</vh></v>
<v t="ekr.20040701040524.116"><vh>addBranch</vh></v>
<v t="ekr.20040701040524.117"><vh>removeBranch</vh></v>
<v t="ekr.20040701040524.118"><vh>remove_unreachable_code</vh></v>
<v t="ekr.20040701040524.119"><vh>updateCheckerArgs</vh></v>
<v t="ekr.20040701040524.120"><vh>updateModuleLineNums</vh></v>
</v>
<v t="ekr.20040701040524.121"><vh>class CodeSource</vh>
<v t="ekr.20040701040524.122"><vh>__init__</vh></v>
</v>
<v t="ekr.20040701040524.123"><vh>_checkException</vh></v>
<v t="ekr.20040701040524.124"><vh>_checkAssign</vh></v>
<v t="ekr.20040701040524.125"><vh>_checkVariableOperationOnItself</vh></v>
<v t="ekr.20040701040524.126"><vh>_checkFutureKeywords</vh></v>
<v t="ekr.20040701040524.127"><vh>_STORE_NAME</vh></v>
<v t="ekr.20040701040524.128"><vh>_checkLoadGlobal</vh></v>
<v t="ekr.20040701040524.129"><vh>_LOAD_NAME</vh></v>
<v t="ekr.20040701040524.130"><vh>_LOAD_DEREF</vh></v>
<v t="ekr.20040701040524.131"><vh>_DELETE_NAME</vh></v>
<v t="ekr.20040701040524.132"><vh>_LOAD_CONST</vh></v>
<v t="ekr.20040701040524.133"><vh>_checkLocalShadow</vh></v>
<v t="ekr.20040701040524.134"><vh>_checkShadowBuiltin</vh></v>
<v t="ekr.20040701040524.135"><vh>_checkLoadLocal</vh></v>
<v t="ekr.20040701040524.136"><vh>_handleLoadLocal</vh></v>
<v t="ekr.20040701040524.137"><vh>_LOAD_FAST</vh></v>
<v t="ekr.20040701040524.138"><vh>_STORE_FAST</vh></v>
<v t="ekr.20040701040524.139"><vh>_DELETE_FAST</vh></v>
<v t="ekr.20040701040524.140"><vh>_checkAttribute</vh></v>
<v t="ekr.20040701040524.141"><vh>_checkExcessiveReferences</vh></v>
<v t="ekr.20040701040524.142"><vh>_checkDeprecated</vh></v>
<v t="ekr.20040701040524.143"><vh>_LOAD_ATTR</vh></v>
<v t="ekr.20040701040524.144"><vh>_ok_to_set_attr</vh></v>
<v t="ekr.20040701040524.145"><vh>_STORE_ATTR</vh></v>
<v t="ekr.20040701040524.146"><vh>_DELETE_ATTR</vh></v>
<v t="ekr.20040701040524.147"><vh>_getExceptionInfo</vh></v>
<v t="ekr.20040701040524.148"><vh>_checkCatchException</vh></v>
<v t="ekr.20040701040524.149"><vh>_handleExceptionChecks</vh></v>
<v t="ekr.20040701040524.150"><vh>_checkBoolean</vh></v>
<v t="ekr.20040701040524.151"><vh>_COMPARE_OP</vh></v>
<v t="ekr.20040701040524.152"><vh>_IMPORT_NAME</vh></v>
<v t="ekr.20040701040524.153"><vh>_IMPORT_FROM</vh></v>
<v t="ekr.20040701040524.154"><vh>_IMPORT_STAR</vh></v>
<v t="ekr.20040701040524.155"><vh>_shouldIgnoreCodeOptimizations</vh></v>
<v t="ekr.20040701040524.156"><vh>_shouldIgnoreNoEffectWarning</vh></v>
<v t="ekr.20040701040524.157"><vh>_DUP_TOP</vh></v>
<v t="ekr.20040701040524.158"><vh>_popn</vh></v>
<v t="ekr.20040701040524.159"><vh>_DELETE_SUBSCR</vh></v>
<v t="ekr.20040701040524.160"><vh>_STORE_SUBSCR</vh></v>
<v t="ekr.20040701040524.161"><vh>_CALL_FUNCTION</vh></v>
<v t="ekr.20040701040524.162"><vh>_CALL_FUNCTION_VAR</vh></v>
<v t="ekr.20040701040524.163"><vh>_CALL_FUNCTION_KW</vh></v>
<v t="ekr.20040701040524.164"><vh>_CALL_FUNCTION_VAR_KW</vh></v>
<v t="ekr.20040701040524.165"><vh>_MAKE_FUNCTION</vh></v>
<v t="ekr.20040701040524.166"><vh>_MAKE_CLOSURE</vh></v>
<v t="ekr.20040701040524.167"><vh>_BUILD_MAP</vh></v>
<v t="ekr.20040701040524.168"><vh>_BUILD_TUPLE</vh></v>
<v t="ekr.20040701040524.169"><vh>_BUILD_LIST</vh></v>
<v t="ekr.20040701040524.170"><vh>_BUILD_CLASS</vh></v>
<v t="ekr.20040701040524.171"><vh>_LIST_APPEND</vh></v>
<v t="ekr.20040701040524.172"><vh>_modifyStackName</vh></v>
<v t="ekr.20040701040524.173"><vh>_UNARY_CONVERT</vh></v>
<v t="ekr.20040701040524.174"><vh>_UNARY_POSITIVE</vh></v>
<v t="ekr.20040701040524.175"><vh>_UNARY_NEGATIVE</vh></v>
<v t="ekr.20040701040524.176"><vh>_UNARY_NOT</vh></v>
<v t="ekr.20040701040524.177"><vh>_UNARY_INVERT</vh></v>
<v t="ekr.20040701040524.178"><vh>_popStackRef</vh></v>
<v t="ekr.20040701040524.179"><vh>_popModifiedStack</vh></v>
<v t="ekr.20040701040524.180"><vh>_pop</vh></v>
<v t="ekr.20040701040524.181"><vh>_popModified</vh></v>
<v t="ekr.20040701040524.182"><vh>_checkModifyNoOp</vh></v>
<v t="ekr.20040701040524.183"><vh>_BINARY_AND</vh></v>
<v t="ekr.20040701040524.184"><vh>_BINARY_OR</vh></v>
<v t="ekr.20040701040524.185"><vh>_BINARY_XOR</vh></v>
<v t="ekr.20040701040524.186"><vh>_PRINT_ITEM_TO</vh></v>
<v t="ekr.20040701040524.187"><vh>_coerce_type</vh></v>
<v t="ekr.20040701040524.188"><vh>_BINARY_ADD</vh></v>
<v t="ekr.20040701040524.189"><vh>_BINARY_SUBTRACT</vh></v>
<v t="ekr.20040701040524.190"><vh>_BINARY_SUBSCR</vh></v>
<v t="ekr.20040701040524.191"><vh>_isint</vh></v>
<v t="ekr.20040701040524.192"><vh>_BINARY_DIVIDE</vh></v>
<v t="ekr.20040701040524.193"><vh>_BINARY_TRUE_DIVIDE</vh></v>
<v t="ekr.20040701040524.194"><vh>_BINARY_MULTIPLY</vh></v>
<v t="ekr.20040701040524.195"><vh>_BINARY_MODULO</vh></v>
<v t="ekr.20040701040524.196"><vh>_ROT_TWO</vh></v>
<v t="ekr.20040701040524.197"><vh>_SETUP_EXCEPT</vh></v>
<v t="ekr.20040701040524.198"><vh>_SETUP_FINALLY</vh></v>
<v t="ekr.20040701040524.199"><vh>_END_FINALLY</vh></v>
<v t="ekr.20040701040524.200"><vh>_LINE_NUM</vh></v>
<v t="ekr.20040701040524.201"><vh>_UNPACK_SEQUENCE</vh></v>
<v t="ekr.20040701040524.202"><vh>_SLICE_1_ARG</vh></v>
<v t="ekr.20040701040524.203"><vh>_SLICE3</vh></v>
<v t="ekr.20040701040524.204"><vh>_check_string_iteration</vh></v>
<v t="ekr.20040701040524.205"><vh>_FOR_LOOP</vh></v>
<v t="ekr.20040701040524.206"><vh>_GET_ITER</vh></v>
<v t="ekr.20040701040524.207"><vh>_FOR_ITER</vh></v>
<v t="ekr.20040701040524.208"><vh>_jump</vh></v>
<v t="ekr.20040701040524.209"><vh>_skip_loops</vh></v>
<v t="ekr.20040701040524.210"><vh>_is_unreachable</vh></v>
<v t="ekr.20040701040524.211"><vh>_shouldIgnoreBogusJumps</vh></v>
<v t="ekr.20040701040524.212"><vh>_checkConstantCondition</vh></v>
<v t="ekr.20040701040524.213"><vh>_jump_conditional</vh></v>
<v t="ekr.20040701040524.214"><vh>_JUMP_IF_FALSE</vh></v>
<v t="ekr.20040701040524.215"><vh>_JUMP_IF_TRUE</vh></v>
<v t="ekr.20040701040524.216"><vh>_JUMP_FORWARD</vh></v>
<v t="ekr.20040701040524.217"><vh>_RETURN_VALUE</vh></v>
<v t="ekr.20040701040524.218"><vh>_EXEC_STMT</vh></v>
<v t="ekr.20040701040524.219"><vh>_checkStrException</vh></v>
<v t="ekr.20040701040524.220"><vh>_RAISE_VARARGS</vh></v>
</v>
<v t="ekr.20040701040524.238"><vh>function.py</vh>
<v t="ekr.20040701040524.239"><vh>class _ReturnValues</vh>
<v t="ekr.20040701040524.240"><vh>__init__</vh></v>
<v t="ekr.20040701040524.241"><vh>returnsNoValue</vh></v>
</v>
<v t="ekr.20040701040524.242"><vh>class FakeCode (Holder for code objects)</vh>
<v t="ekr.20040701040524.243"><vh>__init__</vh></v>
</v>
<v t="ekr.20040701040524.244"><vh>class FakeFunction (_ReturnValues)</vh>
<v t="ekr.20040701040524.245"><vh>__init__</vh></v>
<v t="ekr.20040701040524.246"><vh>__str__</vh></v>
<v t="ekr.20040701040524.247"><vh>__repr__</vh></v>
</v>
<v t="ekr.20040701040524.248"><vh>class Function(_ReturnValues) function.py</vh>
<v t="ekr.20040701040524.249"><vh>__init__</vh></v>
<v t="ekr.20040701040524.250"><vh>__str__</vh></v>
<v t="ekr.20040701040524.251"><vh>__repr__</vh></v>
<v t="ekr.20040701040524.252"><vh>arguments</vh></v>
<v t="ekr.20040701040524.253"><vh>isParam</vh></v>
<v t="ekr.20040701040524.254"><vh>isStaticMethod</vh></v>
<v t="ekr.20040701040524.255"><vh>isClassMethod</vh></v>
<v t="ekr.20040701040524.256"><vh>defaultValue</vh></v>
<v t="ekr.20040701040524.257"><vh>varArgName</vh></v>
</v>
<v t="ekr.20040701040524.258"><vh>create_fake</vh></v>
<v t="ekr.20040701040524.259"><vh>create_from_file</vh></v>
<v t="ekr.20040701040524.260"><vh>_co_flags_equal</vh></v>
<v t="ekr.20040701040524.261"><vh>same_signature</vh></v>
</v>
<v t="ekr.20040701040524.262"><vh>msgs.py</vh></v>
<v t="ekr.20040701040524.263"><vh>OP.py</vh>
<v t="ekr.20040701040524.264"><vh>op code handlers (return numeric code)</vh>
<v t="ekr.20040701040524.265"><vh>LINE_NUM</vh></v>
<v t="ekr.20040701040524.266"><vh>LOAD_GLOBAL</vh></v>
<v t="ekr.20040701040524.267"><vh>LOAD_CONST</vh></v>
<v t="ekr.20040701040524.268"><vh>LOAD_FAST</vh></v>
<v t="ekr.20040701040524.269"><vh>LOAD_ATTR</vh></v>
<v t="ekr.20040701040524.270"><vh>STORE_ATTR</vh></v>
<v t="ekr.20040701040524.271"><vh>POP_TOP</vh></v>
<v t="ekr.20040701040524.272"><vh>IMPORT_FROM</vh></v>
<v t="ekr.20040701040524.273"><vh>IMPORT_STAR</vh></v>
<v t="ekr.20040701040524.274"><vh>UNARY_POSITIVE</vh></v>
<v t="ekr.20040701040524.275"><vh>UNARY_NEGATIVE</vh></v>
<v t="ekr.20040701040524.276"><vh>UNARY_INVERT</vh></v>
<v t="ekr.20040701040524.277"><vh>RETURN_VALUE</vh></v>
<v t="ekr.20040701040524.278"><vh>JUMP_FORWARD</vh></v>
<v t="ekr.20040701040524.279"><vh>JUMP_ABSOLUTE</vh></v>
<v t="ekr.20040701040524.280"><vh>FOR_ITER</vh></v>
<v t="ekr.20040701040524.281"><vh>FOR_LOOP</vh></v>
<v t="ekr.20040701040524.282"><vh>SETUP_LOOP</vh></v>
<v t="ekr.20040701040524.283"><vh>BREAK_LOOP</vh></v>
<v t="ekr.20040701040524.284"><vh>RAISE_VARARGS</vh></v>
<v t="ekr.20040701040524.285"><vh>POP_BLOCK</vh></v>
<v t="ekr.20040701040524.286"><vh>END_FINALLY</vh></v>
</v>
<v t="ekr.20040701040524.287"><vh>Op tests:  return Bool</vh>
<v t="ekr.20040701040524.288"><vh>UNPACK_SEQUENCE</vh></v>
<v t="ekr.20040701040524.289"><vh>IS_CONDITIONAL_JUMP</vh></v>
<v t="ekr.20040701040524.290"><vh>IS_NOT</vh></v>
</v>
<v t="ekr.20040701040524.291"><vh>getOperand</vh></v>
<v t="ekr.20040701040524.292"><vh>getLabel</vh></v>
<v t="ekr.20040701040524.293"><vh>getInfo</vh></v>
<v t="ekr.20040701040524.294"><vh>initFuncCode</vh></v>
<v t="ekr.20040701040524.295"><vh>conditional</vh></v>
<v t="ekr.20040701040524.296"><vh>class Name</vh>
<v t="ekr.20040701040524.297"><vh>__getitem__</vh></v>
</v>
</v>
<v t="ekr.20040701040524.298"><vh>options.py</vh>
<v t="ekr.20040701040524.299"><vh>&lt;&lt; options declarations &gt;&gt;</vh></v>
<v t="ekr.20040701040524.300"><vh>col_weight</vh></v>
<v t="ekr.20040701040524.301"><vh>spawn</vh></v>
<v t="ekr.20040701040524.302"><vh>edit</vh></v>
<v t="ekr.20040701040524.303"><vh>closeCB</vh></v>
<v t="ekr.20040701040524.304"><vh>class Results</vh>
<v t="ekr.20040701040524.305"><vh>&lt;&lt; class Results declarations &gt;&gt;</vh></v>
<v t="ekr.20040701040524.306"><vh>__init__</vh></v>
<v t="ekr.20040701040524.307"><vh>show</vh></v>
<v t="ekr.20040701040524.308"><vh>hide</vh></v>
<v t="ekr.20040701040524.309"><vh>line</vh></v>
<v t="ekr.20040701040524.310"><vh>showFile</vh></v>
<v t="ekr.20040701040524.311"><vh>selectLine</vh></v>
</v>
<v t="ekr.20040701040524.312"><vh>class ConfigDialog</vh>
<v t="ekr.20040701040524.313"><vh>&lt;&lt; class ConfigDialog declarations &gt;&gt;</vh></v>
<v t="ekr.20040701040524.314"><vh>__init__</vh></v>
<v t="ekr.20040701040524.315"><vh>_add_fields</vh></v>
<v t="ekr.20040701040524.316"><vh>_add_group</vh></v>
<v t="ekr.20040701040524.317"><vh>main</vh></v>
<v t="ekr.20040701040524.318"><vh>help</vh></v>
<v t="ekr.20040701040524.319"><vh>focus</vh></v>
<v t="ekr.20040701040524.320"><vh>click</vh></v>
<v t="ekr.20040701040524.321"><vh>ok</vh></v>
<v t="ekr.20040701040524.322"><vh>default</vh></v>
<v t="ekr.20040701040524.323"><vh>file</vh></v>
<v t="ekr.20040701040524.324"><vh>check</vh></v>
</v>
</v>
<v t="ekr.20040701040524.325"><vh>OptionTypes.py Tkinter dialog</vh>
<v t="ekr.20040701040524.326"><vh>bool</vh></v>
<v t="ekr.20040701040524.327"><vh>class Base</vh>
<v t="ekr.20040701040524.328"><vh>&lt;&lt; class Base declarations &gt;&gt;</vh></v>
<v t="ekr.20040701040524.329"><vh>__init__</vh></v>
<v t="ekr.20040701040524.330"><vh>name</vh></v>
<v t="ekr.20040701040524.331"><vh>set</vh></v>
</v>
<v t="ekr.20040701040524.332"><vh>class Boolean</vh>
<v t="ekr.20040701040524.333"><vh>&lt;&lt; class Boolean declarations &gt;&gt;</vh></v>
<v t="ekr.20040701040524.334"><vh>__init__</vh></v>
<v t="ekr.20040701040524.335"><vh>field</vh></v>
<v t="ekr.20040701040524.336"><vh>arg</vh></v>
</v>
<v t="ekr.20040701040524.337"><vh>class Number</vh>
<v t="ekr.20040701040524.338"><vh>&lt;&lt; class Number declarations &gt;&gt;</vh></v>
<v t="ekr.20040701040524.339"><vh>__init__</vh></v>
<v t="ekr.20040701040524.340"><vh>field</vh></v>
<v t="ekr.20040701040524.341"><vh>arg</vh></v>
</v>
<v t="ekr.20040701040524.342"><vh>class Text</vh>
<v t="ekr.20040701040524.343"><vh>&lt;&lt; class Text declarations &gt;&gt;</vh></v>
<v t="ekr.20040701040524.344"><vh>__init__</vh></v>
<v t="ekr.20040701040524.345"><vh>width</vh></v>
<v t="ekr.20040701040524.346"><vh>field</vh></v>
<v t="ekr.20040701040524.347"><vh>arg</vh></v>
</v>
<v t="ekr.20040701040524.348"><vh>join</vh></v>
<v t="ekr.20040701040524.349"><vh>class List</vh>
<v t="ekr.20040701040524.350"><vh>&lt;&lt; class List declarations &gt;&gt;</vh></v>
<v t="ekr.20040701040524.351"><vh>__init__</vh></v>
<v t="ekr.20040701040524.352"><vh>set</vh></v>
</v>
</v>
<v t="ekr.20040701040524.353"><vh>printer.py</vh>
<v t="ekr.20040701040524.354"><vh>printFunction</vh></v>
<v t="ekr.20040701040524.355"><vh>module</vh></v>
<v t="ekr.20040701040524.356"><vh>attrs</vh></v>
</v>
<v t="ekr.20040701040524.357"><vh>python.py (data structures about python)</vh>
<v t="ekr.20040701040524.358"><vh>&lt;&lt; python imports &gt;&gt;</vh></v>
<v t="ekr.20040701040524.359"><vh>_OS_AND_POSIX_FUNCS</vh></v>
<v t="ekr.20040701040524.360"><vh>_STRING_METHODS</vh>
<v t="ekr.20040701040524.361"><vh>&lt;&lt; _STRING_METHODS &gt;&gt;</vh></v>
</v>
<v t="ekr.20040701040524.362"><vh>BUILTIN_ATTRS</vh>
<v t="ekr.20040701040524.363"><vh>_setupBuiltinAttrs</vh></v>
</v>
<v t="ekr.20040701040524.364"><vh>BUILTIN_METHODS</vh>
<v t="ekr.20040701040524.365"><vh>&lt;&lt; BUILTIN_METHODS &gt;&gt;</vh></v>
<v t="ekr.20040701040524.366"><vh>_setupBuiltinMethods</vh></v>
</v>
<v t="ekr.20040701040524.367"><vh>DEPRECATED_ATTRS</vh></v>
<v t="ekr.20040701040524.368"><vh>DEPRECATED_METHODS</vh></v>
<v t="ekr.20040701040524.369"><vh>DEPRECATED_MODULES</vh></v>
<v t="ekr.20040701040524.370"><vh>FUTURE_KEYWORDS</vh></v>
<v t="ekr.20040701040524.371"><vh>GLOBAL_FUNC_INFO</vh>
<v t="ekr.20040701040524.372"><vh>&lt;&lt; GLOBAL_FUNC_INFO &gt;&gt;</vh></v>
<v t="ekr.20040701040524.373"><vh>&lt;&lt; add python 2.2 functions to GLOBAL_FUNC_INFO &gt;&gt;</vh></v>
<v t="ekr.20040701040524.374"><vh>&lt;&lt; add unicode functions to GLOBAL_FUNC_INFO &gt;&gt;</vh></v>
</v>
<v t="ekr.20040701040524.375"><vh>METHODLESS_OBJECTS</vh></v>
<v t="ekr.20040701040524.376"><vh>MUTABLE_TYPES</vh></v>
<v t="ekr.20040701040524.377"><vh>PENDING_DEPRECATED_MODULES</vh></v>
<v t="ekr.20040701040524.378"><vh>SECURITY_FUNCS</vh></v>
<v t="ekr.20040701040524.379"><vh>SPECIAL_METHODS</vh>
<v t="ekr.20040701040524.380"><vh>&lt;&lt; SPECIAL_METHODS &gt;&gt;</vh></v>
</v>
<v t="ekr.20040701040524.381"><vh>tryAddGlobal</vh></v>
</v>
<v t="ekr.20040701040524.382" a="M"><vh>Stack.py</vh>
<v t="ekr.20040701040524.383"><vh>class Item</vh>
<v t="ekr.20040701040524.384"><vh>__init__</vh></v>
<v t="ekr.20040701040524.385"><vh>__str__</vh></v>
<v t="ekr.20040701040524.386"><vh>__repr__</vh></v>
<v t="ekr.20040701040524.387"><vh>isNone</vh></v>
<v t="ekr.20040701040524.388"><vh>isImplicitNone</vh></v>
<v t="ekr.20040701040524.389"><vh>isMethodCall</vh></v>
<v t="ekr.20040701040524.390"><vh>isLocals</vh></v>
<v t="ekr.20040701040524.391"><vh>setStringType</vh></v>
<v t="ekr.20040701040524.392"><vh>getType</vh></v>
<v t="ekr.20040701040524.393"><vh>getName</vh></v>
<v t="ekr.20040701040524.394"><vh>addAttribute</vh></v>
</v>
<v t="ekr.20040701040524.395"><vh>makeDict</vh></v>
<v t="ekr.20040701040524.396"><vh>makeTuple</vh></v>
<v t="ekr.20040701040524.397"><vh>makeList</vh></v>
<v t="ekr.20040701040524.398"><vh>makeFuncReturnValue</vh></v>
<v t="ekr.20040701040524.399"><vh>makeComparison</vh></v>
</v>
<v t="ekr.20040701040524.400"><vh>utils.py</vh>
<v t="ekr.20040701040524.401"><vh>&lt;&lt; utils imports &gt;&gt;</vh></v>
<v t="ekr.20040701040524.402"><vh>cfg</vh></v>
<v t="ekr.20040701040524.403"><vh>initConfig</vh></v>
<v t="ekr.20040701040524.404"><vh>pushConfig</vh></v>
<v t="ekr.20040701040524.405"><vh>popConfig</vh></v>
<v t="ekr.20040701040524.406"><vh>shouldUpdateArgs</vh></v>
<v t="ekr.20040701040524.407"><vh>updateCheckerArgs</vh></v>
<v t="ekr.20040701040524.408"><vh>debug</vh></v>
<v t="ekr.20040701040524.409"><vh>pythonVersion</vh></v>
<v t="ekr.20040701040524.410"><vh>startswith</vh></v>
<v t="ekr.20040701040524.411"><vh>endswith</vh></v>
<v t="ekr.20040701040524.412"><vh>std_repr</vh></v>
</v>
<v t="ekr.20040701040524.413" a="M"><vh>warn.py (Does the actual checking)</vh>
<v t="ekr.20040701040524.414"><vh>&lt;&lt; warn imports &gt;&gt;</vh></v>
<v t="ekr.20040701040524.415"><vh>cfg</vh></v>
<v t="ekr.20040701040524.416"><vh>_checkSelfArg</vh></v>
<v t="ekr.20040701040524.417"><vh>_checkNoSelfArg</vh></v>
<v t="ekr.20040701040524.418"><vh>_checkSubclass</vh></v>
<v t="ekr.20040701040524.419"><vh>_checkReturnWarnings</vh></v>
<v t="ekr.20040701040524.420"><vh>_checkComplex</vh></v>
<v t="ekr.20040701040524.421"><vh>_checkCode</vh></v>
<v t="ekr.20040701040524.422"><vh>_name_unused</vh></v>
<v t="ekr.20040701040524.423"><vh>_checkUnusedParam</vh></v>
<v t="ekr.20040701040524.424"><vh>_handleNestedCode</vh></v>
<v t="ekr.20040701040524.425"><vh>_findUnreachableCode</vh></v>
<v t="ekr.20040701040524.426"><vh>_checkFunction</vh></v>
<v t="ekr.20040701040524.427"><vh>_getUnused</vh></v>
<v t="ekr.20040701040524.428"><vh>_get_func_info</vh></v>
<v t="ekr.20040701040524.429"><vh>_baseInitCalled</vh></v>
<v t="ekr.20040701040524.430"><vh>_checkBaseClassInit</vh></v>
<v t="ekr.20040701040524.431"><vh>_checkOverridenMethods</vh></v>
<v t="ekr.20040701040524.432"><vh>_updateFunctionWarnings</vh></v>
<v t="ekr.20040701040524.433"><vh>getBlackList</vh></v>
<v t="ekr.20040701040524.434"><vh>getStandardLibrary</vh></v>
<v t="ekr.20040701040524.435"><vh>normalize_path</vh></v>
<v t="ekr.20040701040524.436"><vh>removeWarnings</vh></v>
<v t="ekr.20040701040524.437"><vh>class _SuppressionError</vh>
<v t="ekr.20040701040524.438"><vh>&lt;&lt; class _SuppressionError declarations &gt;&gt;</vh></v>
</v>
<v t="ekr.20040701040524.439"><vh>_updateSuppressions</vh></v>
<v t="ekr.20040701040524.440"><vh>getSuppression</vh></v>
<v t="ekr.20040701040524.441" a="M"><vh>_findFunctionWarnings warn.py</vh></v>
<v t="ekr.20040701040524.442"><vh>_getModuleFromFilename</vh></v>
<v t="ekr.20040701040524.443" a="M"><vh>_findClassWarnings warn.py</vh></v>
<v t="ekr.20040701040524.444"><vh>find</vh></v>
</v>
<v t="ekr.20040701040524.445"><vh>Warning.py (represents warning message)</vh>
<v t="ekr.20040701040524.446"><vh>__init__</vh></v>
<v t="ekr.20040701040524.447"><vh>__cmp__</vh></v>
<v t="ekr.20040701040524.448"><vh>format</vh></v>
<v t="ekr.20040701040524.449"><vh>output</vh></v>
</v>
<v t="ekr.20040701040524.450"><vh>__init__.py</vh></v>
</v>
<v t="ekr.20040701041311.2"><vh>Views...</vh>
<v t="ekr.20040701040524.451"><vh>argument handling...</vh>
<v t="ekr.20040701145236.217"><vh>init (Config.py) Defines _SHORT_ARGS &amp; _Long_ARGS</vh></v>
<v t="ekr.20040701145236.224"><vh>__init__ Config.py class config (Hard-coded defaults)</vh></v>
<v t="ekr.20040701145236.216"><vh>&lt;&lt; Config declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.227"><vh>processArgs</vh></v>
<v t="ekr.20040701145236.231"><vh>setupFromArgs</vh></v>
<v t="ekr.20040701040524.407"><vh>updateCheckerArgs</vh></v>
</v>
<v t="ekr.20040701040524.452"><vh>Main line...</vh>
<v t="ekr.20040701145236.55"><vh>main</vh></v>
<v t="ekr.20040701145236.52"><vh>processFiles</vh></v>
<v t="ekr.20040701145236.34"><vh>class Module</vh>
<v t="ekr.20040701145236.35"><vh>&lt;&lt; class Module declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.36"><vh>__init__</vh></v>
<v t="ekr.20040701145236.37"><vh>__str__</vh></v>
<v t="ekr.20040701145236.38"><vh>addVariable</vh></v>
<v t="ekr.20040701145236.39"><vh>addFunction</vh></v>
<v t="ekr.20040701145236.40"><vh>__addAttributes</vh></v>
<v t="ekr.20040701145236.41"><vh>addClass</vh></v>
<v t="ekr.20040701145236.42"><vh>addModule</vh></v>
<v t="ekr.20040701145236.43"><vh>filename</vh></v>
<v t="ekr.20040701145236.44"><vh>load</vh></v>
<v t="ekr.20040701145236.45"><vh>initModule</vh></v>
<v t="ekr.20040701145236.46"><vh>_initModule</vh></v>
<v t="ekr.20040701145236.47"><vh>setupMainCode</vh></v>
<v t="ekr.20040701145236.48"><vh>_setupMainCode</vh></v>
</v>
</v>
<v t="ekr.20040701040524.453"><vh>Classes that hold data about objects</vh>
<v t="ekr.20040701040524.248"><vh>class Function(_ReturnValues) function.py</vh>
<v t="ekr.20040701040524.249"><vh>__init__</vh></v>
<v t="ekr.20040701040524.250"><vh>__str__</vh></v>
<v t="ekr.20040701040524.251"><vh>__repr__</vh></v>
<v t="ekr.20040701040524.252"><vh>arguments</vh></v>
<v t="ekr.20040701040524.253"><vh>isParam</vh></v>
<v t="ekr.20040701040524.254"><vh>isStaticMethod</vh></v>
<v t="ekr.20040701040524.255"><vh>isClassMethod</vh></v>
<v t="ekr.20040701040524.256"><vh>defaultValue</vh></v>
<v t="ekr.20040701040524.257"><vh>varArgName</vh></v>
</v>
<v t="ekr.20040701145236.11"><vh>class Variable</vh>
<v t="ekr.20040701145236.12"><vh>&lt;&lt; class Variable declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.13"><vh>__init__</vh></v>
<v t="ekr.20040701145236.14"><vh>__str__</vh></v>
</v>
<v t="ekr.20040701145236.17"><vh>class Class</vh>
<v t="ekr.20040701145236.18"><vh>&lt;&lt; class Class declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.19"><vh>__init__</vh></v>
<v t="ekr.20040701145236.20"><vh>__str__</vh></v>
<v t="ekr.20040701145236.21"><vh>getFirstLine</vh></v>
<v t="ekr.20040701145236.22"><vh>allBaseClasses</vh></v>
<v t="ekr.20040701145236.23"><vh>__getMethodName</vh></v>
<v t="ekr.20040701145236.24"><vh>addMethod</vh></v>
<v t="ekr.20040701145236.25"><vh>addMethods</vh></v>
<v t="ekr.20040701145236.26"><vh>addMembers</vh></v>
<v t="ekr.20040701145236.27"><vh>addMembersFromMethod</vh></v>
<v t="ekr.20040701145236.28"><vh>cleanupMemberRefs</vh></v>
<v t="ekr.20040701145236.29"><vh>abstractMethod</vh></v>
<v t="ekr.20040701145236.30"><vh>isAbstract</vh></v>
</v>
</v>
<v t="ekr.20040701040524.454"><vh>Code that actually creates warnings</vh>
<v t="ekr.20040701040524.444"><vh>find</vh></v>
<v t="ekr.20040701040524.443"><vh>_findClassWarnings warn.py</vh></v>
<v t="ekr.20040701040524.441"><vh>_findFunctionWarnings warn.py</vh></v>
</v>
<v t="ekr.20040701153754"><vh>Code modified by EKR</vh>
<v t="ekr.20040701145236.216"><vh>&lt;&lt; Config declarations &gt;&gt;</vh></v>
<v t="ekr.20040701145236.217"><vh>init (Config.py) Defines _SHORT_ARGS &amp; _Long_ARGS</vh></v>
<v t="ekr.20040701145236.221"><vh>_getSuppressions</vh></v>
<v t="ekr.20040701145236.227"><vh>processArgs</vh></v>
<v t="ekr.20040701145236.224"><vh>__init__ Config.py class config (Hard-coded defaults)</vh></v>
<v t="ekr.20040701040524.72"><vh>_checkBuiltin (gives const getattr warning)</vh></v>
</v>
</v>
<v t="ekr.20050212115612" a="E"><vh>New work feb/2005 (notes)</vh>
<v t="ekr.20050212125851"><vh>config.c</vh></v>
<v t="ekr.20050212115612.1"><vh>warn.c</vh>
<v t="ekr.20050212115612.2"><vh>_getUnused</vh></v>
<v t="ekr.20050212115612.3"><vh>_updateSuppressions</vh></v>
<v t="ekr.20050212115612.4"><vh>getSuppression</vh></v>
</v>
<v t="ekr.20050212115612.5"><vh>msgs.py (contains error message) INVALID_GLOBAL</vh></v>
<v t="ekr.20050212115612.6" a="E"><vh>CodeChecks.py (modified)</vh>
<v t="ekr.20050212115612.8"><vh>_checkGlobal (modified)</vh></v>
<v t="ekr.20050212135409" a="TV"><vh>_checkModuleAttribute</vh></v>
</v>
<v t="ekr.20050212132124" a="E"><vh>warn.c</vh>
<v t="ekr.20050212132124.1"><vh>find</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20040701040524.1">@  Please read the following CAREFULLY.

- These sources were imported using Leo from the original pychecker-0.8.14
sources. The import process is NOT necessarily completely accurate. This file is
intened primarily for study. If you use these sources at all, use with EXTREME
CAUTION.

- This software is Copyright (c) 2000-2001, MetaSlash Inc. See the full
copyright notice below (in a following node).

- This repackaging of the sources and these notes were written by Edward K. Ream

DISCLAIMER OF WARRANTIES

EDWARD K. REAM (REAM) SPECIFICALLY DISCLAIMS ALL WARRANTIES, EXPRESSED OR
IMPLIED, WITH RESPECT TO THIS COMPUTER SOFTWARE, INCLUDING BUT NOT LIMITED TO
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS RO A PARTICULAR PURPOSE. IN NO
EVENT SHALL REAM BE LIABLE FOR ANY LOSS OF PROFIT OR ANY COMMERCIAL DAMAGE,
INCLUDING BUT NOT LIMITED TO SPECIAL, INCIDENTAL, CONSEQUENTIAL OR OTHER
DAMAGES.

- I (Edward K. Ream) have successfully used the two @file nodes in the
"Files..." node to place traces in the code for study. To use these files,
remove the @ignore directive in the "Files..." node.</t>
<t tx="ekr.20040701040524.2">@killcolor

These data are used throughout pychecker.</t>
<t tx="ekr.20040701040524.3">Code objects represent byte-compiled executable Python code, or bytecode.

The difference between a code object and a function object is that the function
object contains an explicit reference to the function's globals (the module in
which it was defined), while a code object contains no context; also the default
argument values are stored in the function object, not in the code object
(because they represent values calculated at run-time). Unlike function objects,
code objects are immutable and contain no references (directly or indirectly) to
mutable objects. 

Special read-only attributes:

co_name is the function name;

co_argcount is the number of positional arguments (including arguments with default values);

co_nlocals is the number of local variables used by the function (including arguments);

co_varnames is a tuple containing the names of the local variables (starting with the argument names);

co_cellvars is a tuple containing the names of local variables that are referenced by nested functions;

co_freevars is a tuple containing the names of free variables;

co_code is a string representing the sequence of bytecode instructions;

co_consts is a tuple containing the literals used by the bytecode;

co_names is a tuple containing the names used by the bytecode;

co_filename is the filename from which the code was compiled;

co_firstlineno is the first line number of the function;

co_lnotab is a string encoding the mapping from byte code offsets to line numbers
(for details see the source code of the interpreter);

co_stacksize is the required stack size (including local variables); co_flags is an integer encoding a number of flags for the interpreter. 

The following flag bits are defined for co_flags:

bit 0x04 is set if the function uses the "*arguments" syntax to accept an arbitrary number of positional arguments; 

bit 0x08 is set if the function uses the "**keywords" syntax to accept arbitrary keyword arguments;

bit 0x20 is set if the function is a generator.   

Future feature declarations ("from __future__ import division") also use bits in co_flags to indicate whether a code object was compiled with a particular feature enabled: bit 0x2000 is set if the function was compiled with future division enabled; bits 0x10 and 0x1000 were used in earlier versions of Python. 

Other bits in co_flags are reserved for internal use. 

If a code object represents a function, the first item in co_consts is the documentation string of the function, or None if undefined. 
</t>
<t tx="ekr.20040701040524.4">Frame objects represent execution frames. They may occur in traceback objects (see below).

Special read-only attributes:

f_back is to the previous stack frame (towards the caller), or None if this is the bottom stack frame;

f_code is the code object being executed in this frame;

f_locals is the dictionary used to look up local variables;

f_globals is used for global variables;

f_builtins is used for built-in (intrinsic) names;

f_restricted is a flag indicating whether the function is executing in restricted execution mode;

f_lasti gives the precise instruction (this is an index into the bytecode string of the code object).   

Special writable attributes:

f_trace, if not None, is a function called at the start of each source code line (this is used by the debugger);

f_exc_type, f_exc_value, f_exc_traceback represent the most recent exception caught in this frame;

f_lineno is the current line number of the frame.

Writing to this from within a trace function jumps to the given line (only for the bottom-most frame). A debugger can implement a Jump command (aka Set Next Statement) by writing to f_lineno.   
</t>
<t tx="ekr.20040701040524.5">Static method objects provide a way of defeating the transformation of function
objects to method objects described above. A static method object is a wrapper
around any other object, usually a user-defined method object. When a static
method object is retrieved from a class or a class instance, the object actually
returned is the wrapped object, which is not subject to any further
transformation. Static method objects are not themselves callable, although the
objects they wrap usually are. Static method objects are created by the built-in
staticmethod() constructor.</t>
<t tx="ekr.20040701040524.6">A class method object, like a static method object, is a wrapper around another
object that alters the way in which that object is retrieved from classes and
class instances. The behaviour of class method objects upon such retrieval is
described above, under ``User-defined methods''. Class method objects are
created by the built-in classmethod() constructor.</t>
<t tx="ekr.20040701040524.7"></t>
<t tx="ekr.20040701040524.8">@killcolor

Copyright (c) 2000-2001, MetaSlash Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

 - Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

 - Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the
   distribution.

 - Neither name of MetaSlash Inc. nor the names of contributors
   may be used to endorse or promote products derived
   from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</t>
<t tx="ekr.20040701040524.64">@first #!/usr/bin/env python

# Copyright (c) 2001-2004, MetaSlash Inc.  All rights reserved.

"""
Find warnings in byte code from Python source files.
"""

@language python
&lt;&lt; CodeChecks imports &gt;&gt;

__pychecker__ = 'no-argsused'

@others

DISPATCH = [ None ] * 256
DISPATCH[  1] = _POP_TOP
DISPATCH[  2] = _ROT_TWO
DISPATCH[  4] = _DUP_TOP
DISPATCH[ 10] = _UNARY_POSITIVE
DISPATCH[ 11] = _UNARY_NEGATIVE
DISPATCH[ 12] = _UNARY_NOT
DISPATCH[ 13] = _UNARY_CONVERT
DISPATCH[ 15] = _UNARY_INVERT
DISPATCH[ 18] = _LIST_APPEND
DISPATCH[ 19] = _BINARY_POWER
DISPATCH[ 20] = _BINARY_MULTIPLY
DISPATCH[ 21] = _BINARY_DIVIDE
DISPATCH[ 22] = _BINARY_MODULO
DISPATCH[ 23] = _BINARY_ADD
DISPATCH[ 24] = _BINARY_SUBTRACT
DISPATCH[ 25] = _BINARY_SUBSCR
DISPATCH[ 26] = _BINARY_FLOOR_DIVIDE
DISPATCH[ 27] = _BINARY_TRUE_DIVIDE
# FIXME: add INPLACE FLOOR/TRUE DIVIDE: 28/29
DISPATCH[ 31] = _SLICE1
DISPATCH[ 32] = _SLICE2
DISPATCH[ 33] = _SLICE3
DISPATCH[ 55] = _BINARY_ADD             # INPLACE
DISPATCH[ 56] = _BINARY_SUBTRACT        # INPLACE
DISPATCH[ 57] = _BINARY_MULTIPLY        # INPLACE
DISPATCH[ 58] = _BINARY_DIVIDE          # INPLACE
DISPATCH[ 59] = _BINARY_MODULO          # INPLACE
DISPATCH[ 60] = _STORE_SUBSCR
DISPATCH[ 61] = _DELETE_SUBSCR
DISPATCH[ 62] = _BINARY_LSHIFT
DISPATCH[ 63] = _BINARY_RSHIFT
DISPATCH[ 64] = _BINARY_AND
DISPATCH[ 65] = _BINARY_XOR
DISPATCH[ 66] = _BINARY_OR
DISPATCH[ 67] = _BINARY_POWER           # INPLACE
DISPATCH[ 68] = _GET_ITER
DISPATCH[ 71] = _PRINT_ITEM
DISPATCH[ 73] = _PRINT_ITEM_TO
DISPATCH[ 75] = _BINARY_LSHIFT          # INPLACE
DISPATCH[ 76] = _BINARY_RSHIFT          # INPLACE
DISPATCH[ 77] = _BINARY_AND             # INPLACE
DISPATCH[ 78] = _BINARY_XOR             # INPLACE
DISPATCH[ 79] = _BINARY_OR              # INPLACE
DISPATCH[ 83] = _RETURN_VALUE
DISPATCH[ 84] = _IMPORT_STAR
DISPATCH[ 85] = _EXEC_STMT
DISPATCH[ 88] = _END_FINALLY
DISPATCH[ 89] = _BUILD_CLASS
DISPATCH[ 90] = _STORE_NAME
DISPATCH[ 91] = _DELETE_NAME
DISPATCH[ 92] = _UNPACK_SEQUENCE
DISPATCH[ 93] = _FOR_ITER
DISPATCH[ 95] = _STORE_ATTR
DISPATCH[ 96] = _DELETE_ATTR
DISPATCH[ 97] = _STORE_GLOBAL
DISPATCH[ 98] = _DELETE_GLOBAL
DISPATCH[100] = _LOAD_CONST
DISPATCH[101] = _LOAD_NAME
DISPATCH[102] = _BUILD_TUPLE
DISPATCH[103] = _BUILD_LIST
DISPATCH[104] = _BUILD_MAP
DISPATCH[105] = _LOAD_ATTR
DISPATCH[106] = _COMPARE_OP
DISPATCH[107] = _IMPORT_NAME
DISPATCH[108] = _IMPORT_FROM
DISPATCH[110] = _JUMP_FORWARD
DISPATCH[111] = _JUMP_IF_FALSE
DISPATCH[112] = _JUMP_IF_TRUE
DISPATCH[113] = _JUMP_ABSOLUTE
DISPATCH[114] = _FOR_LOOP
DISPATCH[116] = _LOAD_GLOBAL
DISPATCH[121] = _SETUP_EXCEPT
DISPATCH[122] = _SETUP_FINALLY
DISPATCH[124] = _LOAD_FAST
DISPATCH[125] = _STORE_FAST
DISPATCH[126] = _DELETE_FAST
DISPATCH[127] = _LINE_NUM
DISPATCH[130] = _RAISE_VARARGS
DISPATCH[131] = _CALL_FUNCTION
DISPATCH[132] = _MAKE_FUNCTION
DISPATCH[134] = _MAKE_CLOSURE
DISPATCH[135] = _LOAD_CLOSURE
DISPATCH[136] = _LOAD_DEREF
DISPATCH[140] = _CALL_FUNCTION_VAR
DISPATCH[141] = _CALL_FUNCTION_KW
DISPATCH[142] = _CALL_FUNCTION_VAR_KW
</t>
<t tx="ekr.20040701040524.65">import string
import types

from pychecker import msgs
from pychecker import utils
from pychecker import Warning
from pychecker import OP
from pychecker import Stack
from pychecker import python


</t>
<t tx="ekr.20040701040524.66">def cfg() :
    return utils.cfg()
</t>
<t tx="ekr.20040701040524.67">def getFunctionArgErr(func_name, argCount, minArgs, maxArgs):
    
    err = None
    
    if maxArgs == None:
        if argCount &lt; minArgs :
            err = msgs.INVALID_ARG_COUNT2 % (func_name, argCount, minArgs)
    elif argCount &lt; minArgs or argCount &gt; maxArgs:
        if minArgs == maxArgs:
            err = msgs.INVALID_ARG_COUNT1 % (func_name, argCount, minArgs)
        else:
            err = msgs.INVALID_ARG_COUNT3 % (func_name, argCount, minArgs, maxArgs)
    return err

</t>
<t tx="ekr.20040701040524.68">def _checkFunctionArgCount(code, func_name, argCount, minArgs, maxArgs,
                           objectReference = 0) :
                
    # there is an implied argument for object creation and self.xxx()
    if objectReference :
        minArgs = minArgs - 1
        if maxArgs is not None :
            maxArgs = maxArgs - 1

    err = getFunctionArgErr(func_name, argCount, minArgs, maxArgs)
    if err :
        code.addWarning(err)
</t>
<t tx="ekr.20040701040524.69">def _checkFunctionArgs(code, func, objectReference, argCount, kwArgs,
                       check_arg_count = 1) :

    func_name = func.function.func_code.co_name

    if kwArgs :
        args_len = func.function.func_code.co_argcount
        arg_names = func.function.func_code.co_varnames[argCount:args_len]

        if argCount &lt; args_len and kwArgs[0] in arg_names:
            if cfg().namedArgs :
                code.addWarning(msgs.FUNC_USES_NAMED_ARGS % func_name)

            # convert the named args into regular params, and really check
            while argCount &lt; args_len and kwArgs and kwArgs[0] in arg_names:
                argCount = argCount + 1
                kwArgs = kwArgs[1:]
            _checkFunctionArgs(code, func, objectReference, argCount, kwArgs,
                               check_arg_count)
            return

        if not func.supportsKW :
            code.addWarning(msgs.FUNC_DOESNT_SUPPORT_KW % func_name)

    if check_arg_count :
        _checkFunctionArgCount(code, func_name, argCount,
                               func.minArgs, func.maxArgs, objectReference)
</t>
<t tx="ekr.20040701040524.70">def _getReferenceFromModule(module, identifier) :
    func = module.functions.get(identifier, None)
    if func is not None :
        return func, None, 0

    create = 0
    c = module.classes.get(identifier, None)
    if c is not None :
        func = c.methods.get(utils.INIT, None)
        create = 1
    return func, c, create
</t>
<t tx="ekr.20040701040524.71">def _getFunction(module, stackValue) :
    'Return (function, class) from the stack value'

    identifier = stackValue.data
    if type(identifier) == types.StringType :
        return _getReferenceFromModule(module, identifier)

    # find the module this references
    i, maxLen = 0, len(identifier)
    while i &lt; maxLen :
        id = str(identifier[i])
        if module.classes.has_key(id) or module.functions.has_key(id) :
            break
        refModule = module.modules.get(id, None)
        if refModule is not None :
            module = refModule
        else :
            return None, None, 0
        i = i + 1

    # if we got to the end, there is only modules, nothing we can do
    # we also can't handle if there is more than 2 items left
    if i &gt;= maxLen or (i+2) &lt; maxLen :
        return None, None, 0

    if (i+1) == maxLen :
        return _getReferenceFromModule(module, identifier[-1])

    # we can't handle self.x.y
    if (i+2) == maxLen and identifier[0] == cfg().methodArgName:
        return None, None, 0

    c = module.classes.get(identifier[-2], None)
    if c is None :
        return None, None, 0
    return c.methods.get(identifier[-1], None), c, 0
</t>
<t tx="ekr.20040701040524.72">def _checkBuiltin(code, loadValue, argCount, kwArgs, check_arg_count = 1) :
    returnValue = Stack.makeFuncReturnValue(loadValue, argCount)
    func_name = loadValue.data
    if loadValue.type == Stack.TYPE_GLOBAL :
        info = python.GLOBAL_FUNC_INFO.get(func_name, None)
        if info is not None :
            if func_name == 'input' and cfg().usesInput:
                code.addWarning(msgs.USES_INPUT)
            if cfg().constAttr and \
               ((func_name == 'setattr' and argCount &gt;= 2) or 
                (func_name == 'getattr' and argCount == 2)):
                arg2 = code.stack[-argCount + 1]
                if arg2.const:
                    code.addWarning(msgs.USES_CONST_ATTR % func_name)

            if kwArgs:
                if len(info) &lt; 4:
                    code.addWarning(msgs.FUNC_DOESNT_SUPPORT_KW % func_name)
                elif info[3]:
                    for arg in kwArgs:
                        if arg not in info[3]:
                            code.addWarning(msgs.FUNC_DOESNT_SUPPORT_KW_ARG % (func_name, arg))
            elif check_arg_count :
                _checkFunctionArgCount(code, func_name, argCount,
                                       info[1], info[2])
            returnValue = Stack.Item(returnValue.data, info[0])
            returnValue.setStringType(info[0])
    elif type(func_name) == types.TupleType and len(func_name) &lt;= 2 :
        objType = code.typeMap.get(str(func_name[0]), [])
        if types.ListType in objType :
            try :
                if func_name[1] == 'append' and argCount &gt; 1 :
                    code.addWarning(msgs.LIST_APPEND_ARGS % func_name[0])
                    check_arg_count = 0
            except AttributeError :
                # FIXME: why do we need to catch AttributeError???
                pass
        if len(objType) == 1 :
            # if it's a builtin, check method
            builtinType = python.BUILTIN_METHODS.get(objType[0])
            if builtinType is not None :
                methodInfo = builtinType.get(func_name[1])
                # set func properly
                if kwArgs :
                    code.addWarning(msgs.FUNC_DOESNT_SUPPORT_KW % func_name[1])
                elif methodInfo :
                    returnValue = Stack.Item(func_name[1], methodInfo[0])
                    returnValue.setStringType(methodInfo[0])
                    if check_arg_count and methodInfo is not None :
                        _checkFunctionArgCount(code, func_name[1], argCount,
                                               methodInfo[1], methodInfo[2])

    return returnValue
</t>
<t tx="ekr.20040701040524.73">_IMMUTABLE_LIST_METHODS = ('count', 'index',)
_IMMUTABLE_DICT_METHODS = ('copy', 'get', 'has_key',
                           'items', 'keys', 'values',
                           'iteritems', 'iterkeys', 'itervalues')

def _checkModifyDefaultArg(code, objectName, methodName=None) :

    try :
        value = code.func.defaultValue(objectName)
        objectType = type(value)
        if objectType in python.MUTABLE_TYPES :
            if objectType == types.DictType and \
               methodName in _IMMUTABLE_DICT_METHODS :
                return 
            if objectType == types.ListType and \
               methodName in _IMMUTABLE_LIST_METHODS :
                return
            code.addWarning(msgs.MODIFYING_DEFAULT_ARG % objectName)
    except ValueError :
        pass
</t>
<t tx="ekr.20040701040524.74">def _isexception(object) :
    # FIXME: i have no idea why this function is necessary
    # it seems that the issubclass() should work, but it doesn't always
    try:
        # try/except is necessary for globals like NotImplemented
        if issubclass(object, Exception) :
            return 1
    except TypeError:
        return 0

    for c in object.__bases__ :
        if utils.startswith(str(c), 'exceptions.') :
            return 1
        if len(c.__bases__) &gt; 0 and _isexception(c) :
            return 1
    return 0
</t>
<t tx="ekr.20040701040524.75">def _checkStringFind(code, loadValue):
    
    if len(loadValue.data) == 2 and loadValue.data[1] == 'find':
        try:
            if types.StringType in code.typeMap.get(loadValue.data[0], []):
                op = code.nextOpInfo()[0]
                if OP.IS_CONDITIONAL_JUMP(op) or OP.IS_NOT(op):
                    code.addWarning(msgs.BAD_STRING_FIND)

        except TypeError:
            # we don't care if loadValue.data[0] is not hashable
            pass
</t>
<t tx="ekr.20040701040524.76">def _checkAbstract(refClass, code, name):

    name_list = refClass.isAbstract()
    if name_list:
        name_list.sort()
        names = string.join(name_list, ", ")
        code.addWarning(msgs.METHODS_NEED_OVERRIDE % (names, name))
</t>
<t tx="ekr.20040701040524.77">_SEQUENCE_TYPES = (types.TupleType, types.ListType, types.StringType)
try: _SEQUENCE_TYPES = _SEQUENCE_TYPES + (types.UnicodeType,)
except AttributeError: pass

# FIXME: this is not complete. errors will be caught only sometimes,
#        depending on the order the functions/methods are processed
#        in the dict.  Need to be able to run through all functions
#        twice, but because the code sucks, this is not possible.
def _checkReturnValueUse(code, func):
    if func.returnValues is None:
        return

    err = None
    opInfo = code.nextOpInfo()
    if func.returnsNoValue():
        # make sure we really know how to check for all the return types
        for rv in func.returnValues:
            if rv[1].type in _UNCHECKABLE_STACK_TYPES:
                return

        if not OP.POP_TOP(opInfo[0]):
            err = msgs.USING_NONE_RETURN_VALUE % str(func)
    elif OP.UNPACK_SEQUENCE(opInfo[0]):
        # verify unpacking into proper # of vars
        varCount = opInfo[1]
        stackRV = func.returnValues[0][1]
        returnType = stackRV.getType({})
        funcCount = stackRV.length
        if returnType in _SEQUENCE_TYPES:
            if varCount != funcCount and funcCount &gt; 0:
                err = msgs.WRONG_UNPACK_FUNCTION % (str(func), funcCount, varCount)
        elif returnType not in _UNCHECKABLE_STACK_TYPES:
            err = msgs.UNPACK_NON_SEQUENCE % (str(func), _getTypeStr(returnType))
    if err:
        code.addWarning(err)
</t>
<t tx="ekr.20040701040524.78">def _handleFunctionCall(codeSource, code, argCount, indexOffset = 0,
                        check_arg_count = 1) :
    'Checks for warnings, returns function called (may be None)'

    if not code.stack :
        return

    kwArgCount = argCount &gt;&gt; utils.VAR_ARGS_BITS
    argCount = argCount &amp; utils.MAX_ARGS_MASK

    # function call on stack is before the args, and keyword args
    funcIndex = argCount + 2 * kwArgCount + 1 + indexOffset
    if funcIndex &gt; len(code.stack) :
        funcIndex = 0
    # to find on stack, we have to look backwards from top of stack (end)
    funcIndex = -funcIndex

    # store the keyword names/keys to check if using named arguments
    kwArgs = []
    if kwArgCount &gt; 0 :
        # loop backwards by 2 (keyword, value) in stack to find keyword args
        for i in range(-2 - indexOffset, (-2 * kwArgCount - 1), -2) :
            kwArgs.append(code.stack[i].data)
        kwArgs.reverse()

    loadValue = code.stack[funcIndex]
    funcName = loadValue.getName()
    returnValue = Stack.makeFuncReturnValue(loadValue, argCount)

    if loadValue.isMethodCall(codeSource.classObject, cfg().methodArgName):
        methodName = loadValue.data[1]
        try :
            m = codeSource.classObject.methods[methodName]
            if m != None :
                objRef = not m.isStaticMethod()
                _checkFunctionArgs(code, m, objRef, argCount, kwArgs,
                                   check_arg_count)
        except KeyError :
            sattr = codeSource.classObject.statics.get(methodName)
            if sattr is not None :
                funcName = sattr.getName()

            if sattr is None and cfg().callingAttribute :
                code.addWarning(msgs.INVALID_METHOD % methodName)

    elif loadValue.type in (Stack.TYPE_ATTRIBUTE, Stack.TYPE_GLOBAL) and \
         type(loadValue.data) in (types.StringType, types.TupleType) :
        # apply(func, (args)), can't check # of args, so just return func
        if loadValue.data == 'apply' :
            loadValue = code.stack[funcIndex+1]
            funcName = loadValue.getName()
        else :
            if cfg().modifyDefaultValue and \
               type(loadValue.data) == types.TupleType :
                _checkModifyDefaultArg(code, loadValue.data[0],
                                       loadValue.data[1])

            func, refClass, method = _getFunction(codeSource.module, loadValue)
            if func == None and type(loadValue.data) == types.TupleType and \
               len(loadValue.data) == 2 :
                # looks like we are making a method call
                data = loadValue.data
                if type(data[0]) == types.StringType :
                    # do we know the type of the local variable?
                    varType = code.typeMap.get(data[0])
                    if varType is not None and len(varType) == 1 :
                        if hasattr(varType[0], 'methods') :
                            # it's a class &amp; we know the type, get the method
                            func = varType[0].methods.get(data[1])
                            if func is not None :
                                method = 1

            if cfg().abstractClasses and refClass and method:
                _checkAbstract(refClass, code, funcName)

            if cfg().stringFind:
                _checkStringFind(code, loadValue)

            if func != None :
                if refClass and func.isClassMethod():
                    argCount = argCount + 1
                _checkFunctionArgs(code, func, method, argCount, kwArgs,
                                   check_arg_count)
                # if this isn't a c'tor, we should check
                if not (refClass and method) and cfg().checkReturnValues:
                    _checkReturnValueUse(code, func)

                if refClass :
                    if method :
                        # c'tor, return the class as the type
                        returnValue = Stack.Item(loadValue, refClass)
                    elif func.isClassMethod():
                        # FIXME: do anything here?
                        pass
                    elif argCount &gt; 0 and cfg().methodArgName and \
                         not func.isStaticMethod() and \
                         code.stack[funcIndex].type == Stack.TYPE_ATTRIBUTE and \
                         code.stack[funcIndex+1].data != cfg().methodArgName:
                        e = msgs.SELF_NOT_FIRST_ARG % (cfg().methodArgName, '')
                        code.addWarning(e)
            elif refClass and method :
                returnValue = Stack.Item(loadValue, refClass)
                if (argCount &gt; 0 or len(kwArgs) &gt; 0) and \
                   not refClass.ignoreAttrs and \
                   not refClass.methods.has_key(utils.INIT) and \
                   not _isexception(refClass.classObject) :
                    code.addWarning(msgs.NO_CTOR_ARGS)
            else :
                returnValue = _checkBuiltin(code, loadValue, argCount, kwArgs,
                                            check_arg_count)
                if returnValue.type is types.NoneType and \
                   not OP.POP_TOP(code.nextOpInfo()[0]) :
                    name = str(loadValue.data)
                    if type(loadValue.data) == types.TupleType :
                        name = string.join(loadValue.data, '.')
                    code.addWarning(msgs.USING_NONE_RETURN_VALUE % name)

    code.stack = code.stack[:funcIndex] + [ returnValue ]
    code.functionsCalled[funcName] = loadValue
</t>
<t tx="ekr.20040701040524.79">def _classHasAttribute(c, attr) :
    return (c.methods.has_key(attr) or c.members.has_key(attr) or
            hasattr(c.classObject, attr))
</t>
<t tx="ekr.20040701040524.80">def _checkClassAttribute(attr, c, code) :
    if _classHasAttribute(c, attr) :
        try :
            del c.memberRefs[attr]
        except KeyError :
            pass
    elif cfg().classAttrExists :
        code.addWarning(msgs.INVALID_CLASS_ATTR % attr)
</t>
<t tx="ekr.20040701040524.81">def _checkModuleAttribute(attr, module, code, ref) :
    try:
        if attr not in module.modules[ref].attributes and \
           not utils.endswith(ref, '.' + attr) :
            code.addWarning(msgs.INVALID_MODULE_ATTR % attr)
    except (KeyError, TypeError):
        # if ref isn't found, or ref isn't even hashable, we don't care
        # we may not know, or ref could be something funky [e for e].method()
        pass

    try:
        _checkClassAttribute(attr, module.classes[ref], code)
    except (KeyError, TypeError):
        # if ref isn't found, or ref isn't even hashable, we don't care
        # we may not know, or ref could be something funky [e for e].method()
        pass
</t>
<t tx="ekr.20040701040524.82">def _getGlobalName(name, func) :
    # get the right name of global refs (for from XXX import YYY)
    opModule = func.function.func_globals.get(name)
    try :
        if opModule and isinstance(opModule, types.ModuleType) :
            name = opModule.__name__
    except :
        # we have to do this in case the class raises an access exception
        # due to overriding __special__() methods
        pass

    return name
</t>
<t tx="ekr.20040701040524.83">def _checkNoEffect(code, ignoreStmtWithNoEffect=0):
    if (not ignoreStmtWithNoEffect and
        OP.POP_TOP(code.nextOpInfo()[0]) and cfg().noEffect):
        code.addWarning(msgs.POSSIBLE_STMT_WITH_NO_EFFECT)
</t>
<t tx="ekr.20040701040524.84">def _makeConstant(code, index, factoryFunction) :
    "Build a constant on the stack ((), [], or {})"
    if index &gt; 0 :
        code.stack[-index:] = [ factoryFunction(code.stack[-index:]) ]
        _checkNoEffect(code)
    else :
        code.pushStack(factoryFunction())
</t>
<t tx="ekr.20040701040524.85">def _hasGlobal(operand, module, func, main) :
    return (func.function.func_globals.has_key(operand) or
             main or module.moduleLineNums.has_key(operand) or
             __builtins__.has_key(operand))
</t>
<t tx="ekr.20040701040524.86">def _checkGlobal(operand, module, func, code, err, main = 0) :
    if not _hasGlobal(operand, module, func, main) :
        code.addWarning(err % operand)
        if not cfg().reportAllGlobals :
            func.function.func_globals[operand] = operand
</t>
<t tx="ekr.20040701040524.87">def _handleComparison(stack, operand) :
    si = min(len(stack), 2)
    compareValues = stack[-si:]
    for _ in range(si, 2) :
        compareValues.append(None)
    stack[-si:] = [ Stack.makeComparison(compareValues, operand) ]
    return compareValues
</t>
<t tx="ekr.20040701040524.88">def _handleImport(code, operand, module, main, fromName) :
    # FIXME: this function should be refactored/cleaned up
    key = operand
    tmpOperand = tmpFromName = operand
    if fromName is not None :
        tmpOperand = tmpFromName = fromName
        key = (fromName, operand)

    if cfg().deprecated:
        try:
            undeprecated = python.DEPRECATED_MODULES[tmpFromName]
        except KeyError:
            pass
        else:
            msg = msgs.USING_DEPRECATED_MODULE % tmpFromName
            if undeprecated:
                msg = msg + msgs.USE_INSTEAD % undeprecated
            code.addWarning(msg)

    if cfg().reimportSelf and tmpOperand == module.module.__name__ :
        code.addWarning(msgs.IMPORT_SELF % tmpOperand)

    modline1 = module.moduleLineNums.get(tmpOperand, None)
    modline2 = module.moduleLineNums.get((tmpFromName, '*'), None)
    key2 = (tmpFromName,)
    if fromName is not None and operand != '*' :
        key2 = (tmpFromName, operand)
    modline3 = module.moduleLineNums.get(key2, None)

    if modline1 is not None or modline2 is not None or modline3 is not None :
        err = None

        if fromName is None :
            if modline1 is not None :
                err = msgs.MODULE_IMPORTED_AGAIN % operand
            elif cfg().mixImport :
                err = msgs.MIX_IMPORT_AND_FROM_IMPORT % tmpFromName
        else :
            if modline3 is not None and operand != '*' :
                err = 'from %s import %s' % (tmpFromName, operand)
                err = msgs.MODULE_MEMBER_IMPORTED_AGAIN % err
            elif modline1 is not None :
                if cfg().mixImport and code.getLineNum() != modline1[1] :
                    err = msgs.MIX_IMPORT_AND_FROM_IMPORT % tmpFromName
            else :
                err = msgs.MODULE_MEMBER_ALSO_STAR_IMPORTED % fromName

        # filter out warnings when files are different (ie, from X import ...)
        if err is not None and cfg().moduleImportErrors :
            bytes = module.main_code
            if bytes is None or \
               bytes.function.func_code.co_filename == code.func_code.co_filename :
                code.addWarning(err)

    if main :
        fileline = (code.func_code.co_filename, code.getLineNum())
        module.moduleLineNums[key] = fileline
        if fromName is not None :
            module.moduleLineNums[(fromName,)] = fileline
</t>
<t tx="ekr.20040701040524.89">def _handleImportFrom(code, operand, module, main) :
    fromName = code.stack[-1].data
    if utils.pythonVersion() &lt; utils.PYTHON_2_0 and \
       OP.POP_TOP(code.nextOpInfo()[0]):
        code.popNextOp()
    code.pushStack(Stack.Item(operand, types.ModuleType))
    _handleImport(code, operand, module, main, fromName)
</t>
<t tx="ekr.20040701040524.90"># http://www.python.org/doc/current/lib/typesseq-strings.html
_FORMAT_CONVERTERS = 'diouxXeEfFgGcrs'
# NOTE: lLh are legal in the flags, but are ignored by python, we warn
_FORMAT_FLAGS = '*#- +.' + string.digits

def _getFormatInfo(format, code) :
    vars = []

    # first get rid of all the instances of %% in the string, they don't count
    format = string.replace(format, "%%", "")
    sections = string.split(format, '%')
    percentFormatCount = formatCount = string.count(format, '%')
    mappingFormatCount = 0

    # skip the first item in the list, it's always empty
    for section in sections[1:] :
        orig_section = section
        if not section:
            code.addWarning(msgs.INVALID_FORMAT % orig_section +
                            ' (end of format string)')
            continue

        # handle dictionary formats
        if section[0] == '(' :
            mappingFormatCount = mappingFormatCount + 1
            varname = string.split(section, ')')
            if varname[1] == '' :
                code.addWarning(msgs.INVALID_FORMAT % section)
            vars.append(varname[0][1:])
            section = varname[1]

        if not section :
            # no format data to check
            continue

        # FIXME: we ought to just define a regular expression to check
        # formatRE = '[ #+-]*([0-9]*|*)(|.(|*|[0-9]*)[diouxXeEfFgGcrs].*'
        stars = 0
        for i in range(0, len(section)) :
            if section[i] in _FORMAT_CONVERTERS :
                break
            if section[i] in _FORMAT_FLAGS :
                if section[i] == '*' :
                    stars = stars + 1
                    if mappingFormatCount &gt; 0 :
                        code.addWarning(msgs.USING_STAR_IN_FORMAT_MAPPING % section)

        if stars &gt; 2 :
            code.addWarning(msgs.TOO_MANY_STARS_IN_FORMAT)

        formatCount = formatCount + stars
        if section[i] not in _FORMAT_CONVERTERS :
            code.addWarning(msgs.INVALID_FORMAT % orig_section)

    if mappingFormatCount &gt; 0 and mappingFormatCount != percentFormatCount :
        code.addWarning(msgs.CANT_MIX_MAPPING_IN_FORMATS)

    return formatCount, vars
</t>
<t tx="ekr.20040701040524.91">try:
    unicode, UnicodeError
except NameError:
    UnicodeError = None

def _getConstant(code, module, data) :
    try:
        data = str(data.data)
    except UnicodeError:
        data = unicode(data.data)
    format = code.constants.get(data)
    if format is not None :
        return format

    format = module.variables.get(data)
    if format is not None and format.value is not None :
        return format.value
    return None
</t>
<t tx="ekr.20040701040524.92">_UNCHECKABLE_FORMAT_STACK_TYPES = \
      (Stack.TYPE_UNKNOWN, Stack.TYPE_FUNC_RETURN, Stack.TYPE_ATTRIBUTE,
       Stack.TYPE_GLOBAL, Stack.TYPE_EXCEPT)
_UNCHECKABLE_STACK_TYPES = _UNCHECKABLE_FORMAT_STACK_TYPES + (types.NoneType,)

def _getFormatString(code, codeSource) :
    if len(code.stack) &lt;= 1 :
        return ''

    format = code.stack[-2]
    if format.type != types.StringType or not format.const :
        format = _getConstant(code, codeSource.module, format)
        if format is None or type(format) != types.StringType :
            return ''
        return format
    return format.data
</t>
<t tx="ekr.20040701040524.93">def _getFormatWarnings(code, codeSource) :
    format = _getFormatString(code, codeSource)
    if not format :
        return

    args = 0
    count, vars = _getFormatInfo(format, code)
    topOfStack = code.stack[-1]
    if topOfStack.isLocals() :
        for varname in vars :
            if not code.unusedLocals.has_key(varname) :
                code.addWarning(msgs.NO_LOCAL_VAR % varname)
            else :
                code.unusedLocals[varname] = None
    else :
        stackItemType = topOfStack.getType(code.typeMap)
        if ((stackItemType == types.DictType and len(vars) &gt; 0) or
            codeSource.func.isParam(topOfStack.data) or
            stackItemType in _UNCHECKABLE_FORMAT_STACK_TYPES) :
            return

        if topOfStack.type == types.TupleType :
            args = topOfStack.length
        elif stackItemType == types.TupleType :
            args = len(code.constants.get(topOfStack.data, (0,)))
        else :
            args = 1

    if args and count != args :
        code.addWarning(msgs.INVALID_FORMAT_COUNT % (count, args))
</t>
<t tx="ekr.20040701040524.94">def _checkAttributeType(code, stackValue, attr) :
    if not cfg().checkObjectAttrs :
        return

    varTypes = code.typeMap.get(str(stackValue.data), None)
    if not varTypes :
        return

    # the value may have been converted on stack (`v`)
    other_types = []
    if stackValue.type not in varTypes :
        other_types = [stackValue.type]

    for varType in varTypes + other_types :
        # ignore built-in types that have no attributes
        if python.METHODLESS_OBJECTS.has_key(varType) :
            continue

        attrs = python.BUILTIN_ATTRS.get(varType, None)
        if attrs is not None :
            if attr in attrs :
                return
            continue

        if hasattr(varType, 'ignoreAttrs') :
            if varType.ignoreAttrs or _classHasAttribute(varType, attr) :
                return
        elif not hasattr(varType, 'attributes') or attr in varType.attributes :
            return

    code.addWarning(msgs.OBJECT_HAS_NO_ATTR % (stackValue.data, attr))
</t>
<t tx="ekr.20040701040524.95">def _getTypeStr(t):
    returnStr = str(t)
    strs = string.split(returnStr, "'")
    try:
        if len(strs) == 3:
            returnStr = strs[-2]
    except IndexError:
        pass
    return returnStr
</t>
<t tx="ekr.20040701040524.96">def _getLineNum(co, instr_index):
    co_lnotab = co.co_lnotab
    lineno = co.co_firstlineno
    addr = 0
    for lnotab_index in range(0, len(co_lnotab), 2):
        addr = addr + ord(co_lnotab[lnotab_index])
        if addr &gt; instr_index:
            return lineno
        lineno = lineno + ord(co_lnotab[lnotab_index+1])
    return lineno
</t>
<t tx="ekr.20040701040524.97">class Code :
	&lt;&lt; class Code declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701040524.98">'Hold all the code state information necessary to find warnings'

</t>
<t tx="ekr.20040701040524.99">def __init__(self) :
    self.bytes = None
    self.func = None
    self.func_code = None
    self.index = 0
    self.indexList = []
    self.extended_arg = 0
    self.lastLineNum = 0
    self.maxCode = 0
    self.has_except = 0
    self.try_finally_first = 0
    self.starts_and_ends_with_finally = 0

    self.returnValues = []
    self.raiseValues = []
    self.stack = []

    self.unpackCount = 0
    self.loops = 0
    self.branches = {}

    self.warnings = []

    self.globalRefs = {}
    self.unusedLocals = {}
    self.deletedLocals = {}
    self.functionsCalled = {}
    self.typeMap = {}
    self.constants = {}
    self.codeObjects = {}
</t>
<t tx="ekr.20040701040524.100">def init(self, func) :
    self.func = func
    self.func_code, self.bytes, self.index, self.maxCode, self.extended_arg = \
                    OP.initFuncCode(func.function)
    self.lastLineNum = self.func_code.co_firstlineno

    # initialize the arguments to unused
    for arg in func.arguments() :
        self.unusedLocals[arg] = 0
        self.typeMap[arg] = [ Stack.TYPE_UNKNOWN ]
</t>
<t tx="ekr.20040701040524.101">def getLineNum(self):
    line = self.lastLineNum
    # if we don't have linenum info, calc it from co_lntab &amp; index
    if line == self.func_code.co_firstlineno:
        # FIXME: this could be optimized, if we kept last line info
        line = _getLineNum(self.func_code, self.index - 1)
    return line
</t>
<t tx="ekr.20040701040524.102">def getWarning(self, err, line = None) :
    if line is None :
        line = self.getLineNum()
    return Warning.Warning(self.func_code, line, err)
</t>
<t tx="ekr.20040701040524.103">def addWarning(self, err, line = None) :
    w = err
    if not isinstance(w, Warning.Warning):
        w = self.getWarning(err, line)
    self.warnings.append(w)
</t>
<t tx="ekr.20040701040524.104">def popNextOp(self) :
    self.indexList.append(self.index)
    info = OP.getInfo(self.bytes, self.index, self.extended_arg)
    op, oparg, self.index, self.extended_arg = info
    if op &lt; OP.HAVE_ARGUMENT :
        utils.debug("  %d %s" % (self.indexList[-1], OP.name[op]))
        operand = None
    else :
        operand = OP.getOperand(op, self.func_code, oparg)
        self.label = label = OP.getLabel(op, oparg, self.index)
        utils.debug("  %d %s" % (self.indexList[-1], OP.name[op]), oparg, operand)
        if label != None :
            self.addBranch(label)

    return op, oparg, operand
</t>
<t tx="ekr.20040701040524.105">def nextOpInfo(self, offset = 0) :
    try :
        return OP.getInfo(self.bytes, self.index + offset, 0)[0:3]
    except IndexError :
        return -1, 0, -1
</t>
<t tx="ekr.20040701040524.106">def getFirstOp(self) :
    # find the first real op, maybe we should not check if params are used
    i = extended_arg = 0
    while i &lt; self.maxCode :
        op, oparg, i, extended_arg = OP.getInfo(self.bytes, i, extended_arg)
        if not OP.LINE_NUM(op) :
            if not (OP.LOAD_CONST(op) or OP.LOAD_GLOBAL(op)) :
                return op
    raise RuntimeError('Could not find first opcode in function')
</t>
<t tx="ekr.20040701040524.107">def pushStack(self, item, ignoreStmtWithNoEffect=0):
    self.stack.append(item)
    _checkNoEffect(self, ignoreStmtWithNoEffect)
</t>
<t tx="ekr.20040701040524.108">def popStack(self) :
    if self.stack :
        del self.stack[-1]
</t>
<t tx="ekr.20040701040524.109">def popStackItems(self, count) :
    stackLen = len(self.stack)
    if stackLen &gt; 0 :
        count = min(count, stackLen)
        del self.stack[-count:]
</t>
<t tx="ekr.20040701040524.110">def unpack(self) :
    if self.unpackCount :
        self.unpackCount = self.unpackCount - 1
    else :
        self.popStack()
</t>
<t tx="ekr.20040701040524.111">def __getStringStackType(self, data) :
    try :
        return data.getType({})
    except AttributeError :
        return Stack.TYPE_UNKNOWN
</t>
<t tx="ekr.20040701040524.112">def __getStackType(self) :
    if not self.stack :
        return Stack.TYPE_UNKNOWN

    if not self.unpackCount :
        return self.__getStringStackType(self.stack[-1])

    data = self.stack[-1].data
    if type(data) == types.TupleType :
        try :
            return self.__getStringStackType(data[len(data)-self.unpackCount])
        except IndexError :
            # happens when unpacking a var for which we don't know the size
            pass

    return Stack.TYPE_UNKNOWN
</t>
<t tx="ekr.20040701040524.113">def setType(self, name) :
    valueList = self.typeMap.get(name, [])
    newType = self.__getStackType()
    # longs are being merged with ints, assume they are the same
    # comparisons are really ints anyways
    if newType in (types.LongType, Stack.TYPE_COMPARISON):
        newType = types.IntType
    if newType not in valueList :
        valueList.append(newType)

        # need to ignore various types (Unknown, Func return values, etc)
        # also ignore None, don't care if they use it and a real type
        if valueList and newType not in _UNCHECKABLE_STACK_TYPES and \
           cfg().inconsistentTypes:
            oldTypes = []
            # only add types to the value list that are "interesting"
            for typeToAdd in valueList:
                if typeToAdd not in _UNCHECKABLE_STACK_TYPES and \
                   typeToAdd != newType:
                    oldTypes.append(_getTypeStr(typeToAdd))
            # do we have any "interesting" old types?  if so, warn
            if oldTypes:
                self.addWarning(msgs.INCONSISTENT_TYPE % \
                                (name, oldTypes, _getTypeStr(newType)))
    self.typeMap[name] = valueList
</t>
<t tx="ekr.20040701040524.114">def addReturn(self) :
    if len(self.stack) &gt; 0 :
        value = (self.getLineNum(), self.stack[-1], self.nextOpInfo()[2])
        self.returnValues.append(value)
        self.popStack()
</t>
<t tx="ekr.20040701040524.115">def addRaise(self) :
    self.raiseValues.append((self.getLineNum(), None, self.nextOpInfo()[2]))
</t>
<t tx="ekr.20040701040524.116">def addBranch(self, label) :
    if label is not None :
        self.branches[label] = self.branches.get(label, 0) + 1
</t>
<t tx="ekr.20040701040524.117">def removeBranch(self, label) :
    branch = self.branches.get(label, None)
    if branch is not None :
        if branch == 1 :
            del self.branches[label]
        else :
            self.branches[label] = branch - 1
</t>
<t tx="ekr.20040701040524.118">def remove_unreachable_code(self, label) :
    if len(self.indexList) &gt;= 2 :
        index = self.indexList[-2]
        if index &gt;= 0 and OP.POP_BLOCK(ord(self.bytes[index])) :
            index = self.indexList[-3]
        if index &gt;= 0 :
            op = ord(self.bytes[index])
            if OP.RETURN_VALUE(op) or OP.RAISE_VARARGS(op) or \
               OP.END_FINALLY(ord(self.bytes[label-1])) :
                self.removeBranch(label)
</t>
<t tx="ekr.20040701040524.119">def updateCheckerArgs(self, operand) :
    rc = utils.shouldUpdateArgs(operand)
    if rc :
        utils.updateCheckerArgs(self.stack[-1].data, self.func_code,
                                self.getLineNum(), self.warnings)
    return rc
</t>
<t tx="ekr.20040701040524.120">def updateModuleLineNums(self, module, operand) :
    filelist = (self.func_code.co_filename, self.getLineNum())
    module.moduleLineNums[operand] = filelist
</t>
<t tx="ekr.20040701040524.121">class CodeSource :

	'Holds source information about a code block (module, class, func, etc)'

	@others</t>
<t tx="ekr.20040701040524.122">def __init__(self, module, func, c, main, in_class, code) :
    self.module = module
    self.func = func
    self.classObject = c
    self.main = main
    self.in_class = in_class
    self.code = code
    self.calling_code = []
</t>
<t tx="ekr.20040701040524.123">def _checkException(code, name) :
    if code.stack and code.stack[-1].type == Stack.TYPE_EXCEPT :
        if __builtins__.has_key(name) :
            code.addWarning(msgs.SET_EXCEPT_TO_BUILTIN % name)
</t>
<t tx="ekr.20040701040524.124">def _checkAssign(code, name):
    if name in _BAD_ASSIGN_NAMES:
        code.addWarning(msgs.SHOULDNT_ASSIGN_BUILTIN % name)
    else:
        cap = string.capitalize(name)
        if cap in _BAD_ASSIGN_NAMES:
            code.addWarning(msgs.SHOULDNT_ASSIGN_NAME % (name, cap))
</t>
<t tx="ekr.20040701040524.125">def _checkVariableOperationOnItself(code, lname, msg):
    if code.stack and code.stack[-1].getName() == lname:
        code.addWarning(msg % lname)
</t>
<t tx="ekr.20040701040524.126">def _checkFutureKeywords(code, varname) :
    kw = python.FUTURE_KEYWORDS.get(varname)
    if kw is not None :
        code.addWarning(msgs.USING_KEYWORD % (varname, kw))
</t>
<t tx="ekr.20040701040524.127">def _STORE_NAME(oparg, operand, codeSource, code) :
    if not code.updateCheckerArgs(operand) :
        _checkFutureKeywords(code, operand)
        module = codeSource.module
        if not codeSource.in_class :
            _checkShadowBuiltin(code, operand)
            if not codeSource.calling_code :
                _checkGlobal(operand, module, codeSource.func, code,
                             msgs.GLOBAL_DEFINED_NOT_DECLARED, codeSource.main)
        else :
            if code.stack :
                codeSource.classObject.statics[operand] = code.stack[-1]
                codeSource.classObject.lineNums[operand] = code.getLineNum()

        var = module.variables.get(operand)
        if var is not None and code.stack and code.stack[-1].const :
            var.value = code.stack[-1].data

        if code.unpackCount :
            code.unpackCount = code.unpackCount - 1
        else:
            _checkAssign(code, operand)
            _checkException(code, operand)
            code.popStack()
        if not module.moduleLineNums.has_key(operand) and codeSource.main :
            code.updateModuleLineNums(module, operand)
</t>
<t tx="ekr.20040701040524.128">_STORE_GLOBAL = _STORE_NAME

def _checkLoadGlobal(codeSource, code, varname) :
    _checkFutureKeywords(code, varname)
    should_check = 1
    if code.func_code.co_name == utils.LAMBDA :
        # this could really be a local reference, check first
        if not codeSource.main and codeSource.calling_code:
            func = getattr(codeSource.calling_code[-1], 'function', None)
            if func is not None and varname in func.func_code.co_varnames :
                _handleLoadLocal(code, codeSource, varname)
                should_check = 0

    if should_check :
        # if a global var starts w/__ and the global is referenced in a class
        # we have to strip off the _class-name, to get the original name
        if codeSource.classObject and \
           utils.startswith(varname, '_' + codeSource.classObject.name + '__'):
            varname = varname[len(codeSource.classObject.name)+1:]
            
        # make sure we remember each global ref to check for unused
        code.globalRefs[_getGlobalName(varname, codeSource.func)] = varname
        if not codeSource.in_class :
            _checkGlobal(varname, codeSource.module, codeSource.func,
                         code, msgs.INVALID_GLOBAL)
</t>
<t tx="ekr.20040701040524.129">def _LOAD_NAME(oparg, operand, codeSource, code) :
    _checkLoadGlobal(codeSource, code, operand)

    # if there was from XXX import *, _* names aren't imported
    if codeSource.module.modules.has_key(operand) and \
       hasattr(codeSource.module.module, operand) :
        operand = getattr(codeSource.module.module, operand).__name__

    opType, const = Stack.TYPE_GLOBAL, 0
    if operand == 'None' :
        opType, const = types.NoneType, 0
    elif operand == 'Ellipsis' :
        opType, const = types.EllipsisType, 1
    code.pushStack(Stack.Item(operand, opType, const))
</t>
<t tx="ekr.20040701040524.130">_LOAD_GLOBAL = _LOAD_NAME

def _LOAD_DEREF(oparg, operand, codeSource, code) :
    if type(oparg) == types.IntType :
        func_code = code.func_code
        if codeSource.calling_code :
            func_code = codeSource.calling_code[-1].function.func_code
        try:
            argname = func_code.co_cellvars[oparg]
        except IndexError:
            argname = func_code.co_freevars[oparg - len(func_code.co_cellvars)]
        code.pushStack(Stack.Item(argname, types.StringType))
        if code.func_code.co_name != utils.LAMBDA :
            code.unusedLocals[argname] = None
    else :
        _LOAD_GLOBAL(oparg, operand, codeSource, code)
</t>
<t tx="ekr.20040701040524.131">_LOAD_CLOSURE = _LOAD_DEREF

def _DELETE_NAME(oparg, operand, codeSource, code) :
    _checkLoadGlobal(codeSource, code, operand)
</t>
<t tx="ekr.20040701040524.132">    # FIXME: handle deleting global multiple times
_DELETE_GLOBAL = _DELETE_NAME

def _LOAD_CONST(oparg, operand, codeSource, code) :
    code.pushStack(Stack.Item(operand, type(operand), 1))
    if type(operand) == types.CodeType :
        name = operand.co_name
        obj = code.codeObjects.get(name, None)
        if name == utils.LAMBDA :
            # use a unique key, so we can have multiple lambdas
            code.codeObjects[code.index] = operand
        elif obj is None :
            code.codeObjects[name] = operand
        elif cfg().redefiningFunction :
            code.addWarning(msgs.REDEFINING_ATTR % (name, obj.co_firstlineno))
</t>
<t tx="ekr.20040701040524.133">def _checkLocalShadow(code, module, varname) :
    if module.variables.has_key(varname) and cfg().shadows :
        line = module.moduleLineNums.get(varname, ('&lt;unknown&gt;', 0))
        w = code.getWarning(msgs.LOCAL_SHADOWS_GLOBAL % (varname, line[1]))
        if line[0] != w.file:
            w.err = '%s in file %s' % (w.err, line[0])
        code.addWarning(w)
</t>
<t tx="ekr.20040701040524.134">def _checkShadowBuiltin(code, varname) :
    if __builtins__.has_key(varname) and varname[0] != '_' and \
       cfg().shadowBuiltins:
        code.addWarning(msgs.VARIABLE_SHADOWS_BUILTIN % varname)
</t>
<t tx="ekr.20040701040524.135">def _checkLoadLocal(code, codeSource, varname, deletedWarn, usedBeforeSetWarn) :
    _checkFutureKeywords(code, varname)
    deletedLine = code.deletedLocals.get(varname)
    if deletedLine :
        code.addWarning(deletedWarn % (varname, deletedLine))
    elif not code.unusedLocals.has_key(varname) and \
         not codeSource.func.isParam(varname) :
        code.addWarning(usedBeforeSetWarn % varname)
    code.unusedLocals[varname] = None
    _checkLocalShadow(code, codeSource.module, varname)
</t>
<t tx="ekr.20040701040524.136">def _handleLoadLocal(code, codeSource, varname) :
    _checkLoadLocal(code, codeSource, varname,
                    msgs.LOCAL_DELETED, msgs.VAR_USED_BEFORE_SET)
</t>
<t tx="ekr.20040701040524.137">def _LOAD_FAST(oparg, operand, codeSource, code) :
    code.pushStack(Stack.Item(operand, type(operand)))
    _handleLoadLocal(code, codeSource, operand)
</t>
<t tx="ekr.20040701040524.138">def _STORE_FAST(oparg, operand, codeSource, code) :
    if not code.updateCheckerArgs(operand) :
        _checkFutureKeywords(code, operand)
        if code.stack and code.stack[-1].type == types.StringType and \
               not code.stack[-1].const:
            _checkVariableOperationOnItself(code, operand,
                                            msgs.SET_VAR_TO_ITSELF)
        code.setType(operand)
        if not code.unpackCount and code.stack and \
           (code.stack[-1].const or code.stack[-1].type == types.TupleType) :
            if code.constants.has_key(operand) :
                del code.constants[operand]
            else :
                code.constants[operand] = code.stack[-1].data

        _checkLocalShadow(code, codeSource.module, operand)
        _checkShadowBuiltin(code, operand)
        _checkAssign(code, operand)
        _checkException(code, operand)
        if code.deletedLocals.has_key(operand) :
            del code.deletedLocals[operand]
        if not code.unusedLocals.has_key(operand) :
            errLine = code.getLineNum()
            if code.unpackCount and not cfg().unusedLocalTuple :
                errLine = -errLine
            code.unusedLocals[operand] = errLine
        code.unpack()
</t>
<t tx="ekr.20040701040524.139">def _DELETE_FAST(oparg, operand, codeSource, code) :
    _checkLoadLocal(code, codeSource, operand,
                    msgs.LOCAL_ALREADY_DELETED, msgs.VAR_DELETED_BEFORE_SET)
    code.deletedLocals[operand] = code.getLineNum()
</t>
<t tx="ekr.20040701040524.140">def _checkAttribute(top, operand, codeSource, code) :
    if top.data == cfg().methodArgName and codeSource.classObject != None :
        _checkClassAttribute(operand, codeSource.classObject, code)
    elif type(top.type) == types.StringType or top.type == types.ModuleType :
        _checkModuleAttribute(operand, codeSource.module, code, top.data)
    else :
        _checkAttributeType(code, top, operand)
</t>
<t tx="ekr.20040701040524.141">def _checkExcessiveReferences(code, top, extraAttr = None) :
    if cfg().maxReferences &lt;= 0 :
        return

    try :
        data = top.data
        if extraAttr is not None :
            data = data + (extraAttr,)
        
        maxReferences = cfg().maxReferences
        if data[0] == cfg().methodArgName:
            maxReferences = maxReferences + 1
        if len(data) &gt; maxReferences :
            name = string.join(top.data, '.')
            code.addWarning(msgs.TOO_MANY_REFERENCES % (maxReferences, name))
    except TypeError :
        pass
</t>
<t tx="ekr.20040701040524.142">def _checkDeprecated(code, identifierTuple):
    # check deprecated module.function
    try:
        name = string.join(identifierTuple, '.')
        undeprecated = python.DEPRECATED_ATTRS[name]
    except (KeyError, TypeError):
        pass
    else:
        msg = msgs.USING_DEPRECATED_ATTR % name
        if undeprecated:
            msg = msg + msgs.USE_INSTEAD % undeprecated
        code.addWarning(msg)
</t>
<t tx="ekr.20040701040524.143">def _LOAD_ATTR(oparg, operand, codeSource, code) :
    if len(code.stack) &gt; 0 :
        top = code.stack[-1]
        _checkAttribute(top, operand, codeSource, code)
        top.addAttribute(operand)

        if len(top.data) == 2:
            if cfg().deprecated:
                _checkDeprecated(code, top.data)

            try:
                insecure = python.SECURITY_FUNCS.get(top.data[0])
            except TypeError:
                pass
            else:
                if insecure and insecure.has_key(operand):
                    func = string.join(top.data, '.')
                    code.addWarning(msgs.USING_INSECURE_FUNC % func)

        nextOp = code.nextOpInfo()[0]
        if not OP.LOAD_ATTR(nextOp) :
            if OP.POP_TOP(nextOp) and cfg().noEffect:
                code.addWarning(msgs.POSSIBLE_STMT_WITH_NO_EFFECT)
            else :
                _checkExcessiveReferences(code, top)
</t>
<t tx="ekr.20040701040524.144">def _ok_to_set_attr(classObject, basename, attr) :
    return (cfg().onlyCheckInitForMembers and classObject != None and
            basename == cfg().methodArgName and 
            not _classHasAttribute(classObject, attr))
</t>
<t tx="ekr.20040701040524.145">def _STORE_ATTR(oparg, operand, codeSource, code) :
    if code.stack :
        top = code.stack.pop()
        top_name = '%s.%s' % (top.getName(), operand)
        try:
            # FIXME: this is a hack to handle code like:
            #        a.a = [x for x in range(2) if x &gt; 1]
            previous = code.stack[-1]
        except IndexError:
            previous = None
        if top.type in (types.StringType, Stack.TYPE_ATTRIBUTE) and \
           previous and previous.type == Stack.TYPE_ATTRIBUTE:
            _checkVariableOperationOnItself(code, top_name,
                                            msgs.SET_VAR_TO_ITSELF)
        _checkExcessiveReferences(code, top, operand)
        if _ok_to_set_attr(codeSource.classObject, top.data, operand) :
            code.addWarning(msgs.INVALID_SET_CLASS_ATTR % operand)
    code.unpack()
</t>
<t tx="ekr.20040701040524.146">def _DELETE_ATTR(oparg, operand, codeSource, code) :
    if len(code.stack) &gt; 0 :
        _checkAttribute(code.stack[-1], operand, codeSource, code)
</t>
<t tx="ekr.20040701040524.147">def _getExceptionInfo(codeSource, item):
    # FIXME: probably ought to try to handle raise module.Error
    if item.type is types.StringType and item.const == 1:
        return item.data, 1

    e = None
    if item.type is Stack.TYPE_GLOBAL:
        try:
            e = eval(item.data)
        except NameError:
            pass

    if not e:
        try:
            c = codeSource.module.classes.get(item.data)
        except TypeError:     # item.data may not be hashable (e.g., list)
            return e, 0

        if c is not None:
            e = c.classObject
        else:
            v = codeSource.module.variables.get(item.data)
            if v is not None:
                return v, 1
    return e, 0
</t>
<t tx="ekr.20040701040524.148">_UNCHECKABLE_CATCH_TYPES = (Stack.TYPE_UNKNOWN, Stack.TYPE_ATTRIBUTE)
def _checkCatchException(codeSource, code, item):
    if not cfg().badExceptions:
        return

    if item.data is None or item.type in _UNCHECKABLE_CATCH_TYPES:
        return

    e, is_str = _getExceptionInfo(codeSource, item)
    if is_str:
        code.addWarning(msgs.CATCH_STR_EXCEPTION % item.data)
    elif e is not None and not _isexception(e):
        code.addWarning(msgs.CATCH_BAD_EXCEPTION % item.data)
</t>
<t tx="ekr.20040701040524.149">def _handleExceptionChecks(codeSource, code, checks):
    for item in checks:
        if item is not None:
            if item.type is not types.TupleType:
                _checkCatchException(codeSource, code, item)
            else:
                for ti in item.data:
                    if isinstance(ti, Stack.Item):
                        _checkCatchException(codeSource, code, ti)
</t>
<t tx="ekr.20040701040524.150">_BOOL_NAMES = ('True', 'False')
_BAD_ASSIGN_NAMES = _BOOL_NAMES + ('None',)

def _checkBoolean(code, checks):
    for item in checks:
        try:
            data = string.capitalize(item.data)
            if item.type is Stack.TYPE_GLOBAL and data in _BOOL_NAMES:
                code.addWarning(msgs.BOOL_COMPARE % item.data)
        except (AttributeError, TypeError):
            # TypeError is necessary for Python 1.5.2
            pass # ignore items that are not a StackItem or a string
</t>
<t tx="ekr.20040701040524.151">def _COMPARE_OP(oparg, operand, codeSource, code) :
    compareValues = _handleComparison(code.stack, operand)
    if oparg == OP.EXCEPT_COMPARISON:
        _handleExceptionChecks(codeSource, code, compareValues)
    elif oparg &lt; OP.IS_COMPARISON:
        _checkBoolean(code, compareValues)
    elif cfg().isLiteral:
        # X is Y   or   X is not Y   comparison
        second_arg = code.stack[-1].data[2]
        # FIXME: how should booleans should e handled, need to think about it
##        if second_arg.const or (second_arg.type == Stack.TYPE_GLOBAL and
##                                second_arg.data in ['True', 'False']):
        if second_arg.const:
            data = second_arg.data
            if second_arg.type is types.DictType:
                data = {}
            not_str = ''
            if oparg != OP.IS_COMPARISON:
                not_str = ' not'
            code.addWarning(msgs.IS_LITERAL % (not_str, data))

    _checkNoEffect(code)
</t>
<t tx="ekr.20040701040524.152">def _IMPORT_NAME(oparg, operand, codeSource, code) :
    code.pushStack(Stack.Item(operand, types.ModuleType))
    nextOp = code.nextOpInfo()[0]
    if not OP.IMPORT_FROM(nextOp) and not OP.IMPORT_STAR(nextOp) :
        _handleImport(code, operand, codeSource.module, codeSource.main, None)
</t>
<t tx="ekr.20040701040524.153">def _IMPORT_FROM(oparg, operand, codeSource, code) :
    _handleImportFrom(code, operand, codeSource.module, codeSource.main)
    # this is necessary for python 1.5 (see STORE_GLOBAL/NAME)
    if utils.pythonVersion() &lt; utils.PYTHON_2_0 :
        code.popStack()
        if not codeSource.main :
            code.unusedLocals[operand] = None
        elif not codeSource.module.moduleLineNums.has_key(operand) :
            code.updateModuleLineNums(codeSource.module, operand)
</t>
<t tx="ekr.20040701040524.154">def _IMPORT_STAR(oparg, operand, codeSource, code) :
    _handleImportFrom(code, '*', codeSource.module, codeSource.main)
</t>
<t tx="ekr.20040701040524.155"># Python 2.3 introduced some optimizations that create problems
# this is a utility for ignoring these cases
def _shouldIgnoreCodeOptimizations(code, bytecodes, offset, length=None):
    if utils.pythonVersion() &lt; utils.PYTHON_2_3:
        return 0

    if length is None:
        length = offset - 1
    try:
        start = code.index - offset
        return bytecodes == code.bytes[start:start+length]
    except IndexError:
        return 0
</t>
<t tx="ekr.20040701040524.156"># In Python 2.3, a, b = 1,2 generates this code:
# ...
# ROT_TWO
# JUMP_FORWARD 2
# DUP_TOP
# POP_TOP
#
# which generates a Possible stmt w/no effect

# ROT_TWO = 2; JUMP_FORWARD = 110; 2, 0 is the offset (2)
_IGNORE_SEQ = '%c%c%c%c' % (2, 110, 2, 0)
def _shouldIgnoreNoEffectWarning(code):
    return _shouldIgnoreCodeOptimizations(code, _IGNORE_SEQ, 5)
</t>
<t tx="ekr.20040701040524.157">def _DUP_TOP(oparg, operand, codeSource, code) :
    if len(code.stack) &gt; 0 :
        code.pushStack(code.stack[-1], _shouldIgnoreNoEffectWarning(code))
</t>
<t tx="ekr.20040701040524.158">def _popn(code, n) :
    if len(code.stack) &gt;= 2 :
        loadValue = code.stack[-2]
        if cfg().modifyDefaultValue and loadValue.type == types.StringType :
            _checkModifyDefaultArg(code, loadValue.data)

    code.popStackItems(n)
</t>
<t tx="ekr.20040701040524.159">def _DELETE_SUBSCR(oparg, operand, codeSource, code) :
    _popn(code, 2)
</t>
<t tx="ekr.20040701040524.160">def _STORE_SUBSCR(oparg, operand, codeSource, code) :
    _popn(code, 3)
</t>
<t tx="ekr.20040701040524.161">def _CALL_FUNCTION(oparg, operand, codeSource, code) :
    _handleFunctionCall(codeSource, code, oparg)
</t>
<t tx="ekr.20040701040524.162">def _CALL_FUNCTION_VAR(oparg, operand, codeSource, code) :
    _handleFunctionCall(codeSource, code, oparg, 1, 0)
</t>
<t tx="ekr.20040701040524.163">def _CALL_FUNCTION_KW(oparg, operand, codeSource, code) :
    _handleFunctionCall(codeSource, code, oparg, 1)
</t>
<t tx="ekr.20040701040524.164">def _CALL_FUNCTION_VAR_KW(oparg, operand, codeSource, code) :
    _handleFunctionCall(codeSource, code, oparg, 2, 0)
</t>
<t tx="ekr.20040701040524.165">def _MAKE_FUNCTION(oparg, operand, codeSource, code) :
    newValue = Stack.makeFuncReturnValue(code.stack[-1], oparg)
    code.popStackItems(oparg+1)
    code.pushStack(newValue)
</t>
<t tx="ekr.20040701040524.166">def _MAKE_CLOSURE(oparg, operand, codeSource, code) :
    _MAKE_FUNCTION(max(0, oparg - 1), operand, codeSource, code)
</t>
<t tx="ekr.20040701040524.167">def _BUILD_MAP(oparg, operand, codeSource, code) :
    _makeConstant(code, oparg, Stack.makeDict)
</t>
<t tx="ekr.20040701040524.168">def _BUILD_TUPLE(oparg, operand, codeSource, code) :
    _makeConstant(code, oparg, Stack.makeTuple)
</t>
<t tx="ekr.20040701040524.169">def _BUILD_LIST(oparg, operand, codeSource, code) :
    _makeConstant(code, oparg, Stack.makeList)
</t>
<t tx="ekr.20040701040524.170">def _BUILD_CLASS(oparg, operand, codeSource, code) :
    newValue = Stack.makeFuncReturnValue(code.stack[-1], types.ClassType)
    code.popStackItems(3)
    code.pushStack(newValue)
</t>
<t tx="ekr.20040701040524.171">def _LIST_APPEND(oparg, operand, codeSource, code):
    code.popStackItems(2)
</t>
<t tx="ekr.20040701040524.172">def _modifyStackName(code, suffix):
    if code.stack:
        tos = code.stack[-1]
        tos_type = type(tos.data)
        if tos_type == types.StringType:
            tos.data = tos.data + suffix
        elif tos_type == types.TupleType and \
             type(tos.data[-1]) == types.StringType:
            tos.data = tos.data[:-1] + (tos.data[-1] + suffix,)
</t>
<t tx="ekr.20040701040524.173">def _UNARY_CONVERT(oparg, operand, codeSource, code) :
    if code.stack:
        stackValue = code.stack[-1]
        if stackValue.data == cfg().methodArgName and \
           stackValue.const == 0 and codeSource.classObject is not None and \
           codeSource.func.function.func_name == '__repr__' :
            code.addWarning(msgs.USING_SELF_IN_REPR)
        stackValue.data = str(stackValue.data)
        stackValue.type = types.StringType
    _modifyStackName(code, '-repr')
</t>
<t tx="ekr.20040701040524.174">def _UNARY_POSITIVE(oparg, operand, codeSource, code) :
    if OP.UNARY_POSITIVE(code.nextOpInfo()[0]) :
        code.addWarning(msgs.STMT_WITH_NO_EFFECT % '++')
        code.popNextOp()
    elif cfg().unaryPositive and code.stack and not code.stack[-1].const :
        code.addWarning(msgs.UNARY_POSITIVE_HAS_NO_EFFECT)
    _modifyStackName(code, '-pos')
</t>
<t tx="ekr.20040701040524.175">def _UNARY_NEGATIVE(oparg, operand, codeSource, code) :
    if OP.UNARY_NEGATIVE(code.nextOpInfo()[0]) :
        code.addWarning(msgs.STMT_WITH_NO_EFFECT % '--')
    _modifyStackName(code, '-neg')
</t>
<t tx="ekr.20040701040524.176">def _UNARY_NOT(oparg, operand, codeSource, code) :
    _modifyStackName(code, '-not')
</t>
<t tx="ekr.20040701040524.177">def _UNARY_INVERT(oparg, operand, codeSource, code) :
    if OP.UNARY_INVERT(code.nextOpInfo()[0]) :
        code.addWarning(msgs.STMT_WITH_NO_EFFECT % '~~')
    _modifyStackName(code, '-invert')
</t>
<t tx="ekr.20040701040524.178">def _popStackRef(code, operand, count = 2) :
    code.popStackItems(count)
    code.pushStack(Stack.Item(operand, Stack.TYPE_UNKNOWN))
</t>
<t tx="ekr.20040701040524.179">def _popModifiedStack(code, suffix=' '):
    code.popStack()
    _modifyStackName(code, suffix)
</t>
<t tx="ekr.20040701040524.180">def _pop(oparg, operand, codeSource, code) :
    code.popStack()
</t>
<t tx="ekr.20040701040524.181">_POP_TOP = _PRINT_ITEM = _pop

def _popModified(oparg, operand, codeSource, code):
    _popModifiedStack(code)
</t>
<t tx="ekr.20040701040524.182">_BINARY_LSHIFT = _BINARY_RSHIFT = _popModified

def _checkModifyNoOp(code, op, msg=msgs.MODIFY_VAR_NOOP, modifyStack=1):
    stack = code.stack
    if len(stack) &gt;= 2:
        name = stack[-1].getName()
        if name != Stack.TYPE_UNKNOWN and name == stack[-2].getName():
            code.addWarning(msg % (name, op, name))

        if modifyStack:
            code.popStack()
            stack[-1].const = 0
            _modifyStackName(code, op)
</t>
<t tx="ekr.20040701040524.183">def _BINARY_AND(oparg, operand, codeSource, code):
    _checkModifyNoOp(code, '&amp;')
</t>
<t tx="ekr.20040701040524.184">def _BINARY_OR(oparg, operand, codeSource, code):
    _checkModifyNoOp(code, '|')
</t>
<t tx="ekr.20040701040524.185">def _BINARY_XOR(oparg, operand, codeSource, code):
    _checkModifyNoOp(code, '^', msgs.XOR_VAR_WITH_ITSELF)
</t>
<t tx="ekr.20040701040524.186">def _PRINT_ITEM_TO(oparg, operand, codeSource, code) :
    code.popStackItems(2)
</t>
<t tx="ekr.20040701040524.187">try:
    ComplexType = types.ComplexType
except NameError:
    ComplexType = types.FloatType    # need some numeric type here

_NUMERIC_TYPES = (types.IntType, types.FloatType, ComplexType)

# FIXME: This is pathetically weak, need to handle more types
def _coerce_type(code) :
    _checkNoEffect(code)
    newItem = Stack.Item('&lt;stack&gt;', Stack.TYPE_UNKNOWN)
    if len(code.stack) &gt;= 2 :
        s1, s2 = code.stack[-2:]
        s1type = s1.getType(code.typeMap)
        s2type = s2.getType(code.typeMap)
        if s1type != s2type :
            if s1type in _NUMERIC_TYPES and s2type in _NUMERIC_TYPES :
                newType = types.FloatType
                if s1type == ComplexType or s2type == ComplexType:
                    newType = ComplexType
                newItem.type = newType

    code.popStackItems(2)
    code.pushStack(newItem)
</t>
<t tx="ekr.20040701040524.188">def _BINARY_ADD(oparg, operand, codeSource, code) :
    stack = code.stack
    if len(stack) &gt;= 2 and (stack[-1].const and stack[-2].const and
                            stack[-1].type == stack[-2].type) :
        value = stack[-2].data + stack[-1].data
        code.popStackItems(2)
        code.pushStack(Stack.Item(value, type(value), 1))
    else :
        _coerce_type(code)
</t>
<t tx="ekr.20040701040524.189">def _BINARY_SUBTRACT(oparg, operand, codeSource, code) :
    _coerce_type(code)
</t>
<t tx="ekr.20040701040524.190">_BINARY_POWER = _BINARY_SUBTRACT

def _BINARY_SUBSCR(oparg, operand, codeSource, code) :
    _checkNoEffect(code)
    if len(code.stack) &gt;= 2 :
        stack = code.stack
        varType = code.typeMap.get(str(stack[-2].data), [])
        if types.ListType in varType and stack[-1].type == types.TupleType :
            code.addWarning(msgs.USING_TUPLE_ACCESS_TO_LIST % stack[-2].data)
    _popStackRef(code, operand)
</t>
<t tx="ekr.20040701040524.191">def _isint(stackItem, code) :
    if type(stackItem.data) == types.IntType :
        return 1
    stackTypes = code.typeMap.get(stackItem.data, [])
    if len(stackTypes) != 1 :
        return 0
    return types.IntType in stackTypes
</t>
<t tx="ekr.20040701040524.192">def _BINARY_DIVIDE(oparg, operand, codeSource, code) :
    _checkNoEffect(code)
    _checkModifyNoOp(code, '/', msgs.DIVIDE_VAR_BY_ITSELF, 0)
    if cfg().intDivide and len(code.stack) &gt;= 2 :
        if _isint(code.stack[-1], code) and _isint(code.stack[-2], code) :
            code.addWarning(msgs.INTEGER_DIVISION % tuple(code.stack[-2:]))

    _popModifiedStack(code, '/')
</t>
<t tx="ekr.20040701040524.193">def _BINARY_TRUE_DIVIDE(oparg, operand, codeSource, code) :
    _checkNoEffect(code)
    _checkVariableOperationOnItself(code, operand, msgs.DIVIDE_VAR_BY_ITSELF)
    _popModifiedStack(code, '/')
</t>
<t tx="ekr.20040701040524.194">_BINARY_FLOOR_DIVIDE = _BINARY_TRUE_DIVIDE

def _BINARY_MULTIPLY(oparg, operand, codeSource, code) :
    if len(code.stack) &gt;= 2 :
        format = _getFormatString(code, codeSource)
        if format and type(code.stack[-1].data) == types.IntType :
            code.stack[-2].data = format * code.stack[-1].data
            code.popStack()
        else:
            _coerce_type(code)
    else:
        _popModifiedStack(code, '*')
</t>
<t tx="ekr.20040701040524.195">def _BINARY_MODULO(oparg, operand, codeSource, code) :
    _checkNoEffect(code)
    if cfg().modulo1 and code.stack and code.stack[-1].data == 1:
        if len(code.stack) &lt; 2 or \
           code.stack[-2].getType(code.typeMap) != types.FloatType:
            code.addWarning(msgs.MODULO_1)
    _getFormatWarnings(code, codeSource)
    _popModifiedStack(code, '%')
    if code.stack:
        code.stack[-1].const = 0
</t>
<t tx="ekr.20040701040524.196">def _ROT_TWO(oparg, operand, codeSource, code) :
    if len(code.stack) &gt;= 2 :
        tmp = code.stack[-2]
        code.stack[-2] = code.stack[-1]
        code.stack[-1] = tmp
</t>
<t tx="ekr.20040701040524.197">def _SETUP_EXCEPT(oparg, operand, codeSource, code) :
    code.has_except = 1
    code.pushStack(Stack.Item(None, Stack.TYPE_EXCEPT))
    code.pushStack(Stack.Item(None, Stack.TYPE_EXCEPT))
</t>
<t tx="ekr.20040701040524.198">def _SETUP_FINALLY(oparg, operand, codeSource, code) :
    if not code.has_except :
        code.try_finally_first = 1
</t>
<t tx="ekr.20040701040524.199">def _END_FINALLY(oparg, operand, codeSource, code) :
    if code.try_finally_first and code.index == (len(code.bytes) - 4) :
        code.starts_and_ends_with_finally = 1
</t>
<t tx="ekr.20040701040524.200">def _LINE_NUM(oparg, operand, codeSource, code) :
    code.lastLineNum = oparg
</t>
<t tx="ekr.20040701040524.201">def _UNPACK_SEQUENCE(oparg, operand, codeSource, code) :
    code.unpackCount = oparg
    if code.stack:
        top = code.stack[-1]
        # if we know we have a tuple, make sure we unpack it into the
        # right # of variables
        topType = top.getType(code.typeMap)
        if topType in _SEQUENCE_TYPES:
            length = top.length
            # we don't know the length, maybe it's constant and we can find out
            if length == 0:
                value = code.constants.get(str(top.data))
                if type(value) in _SEQUENCE_TYPES:
                    length = len(value)
            if length &gt; 0 and length != oparg:
                if cfg().unpackLength:
                    code.addWarning(msgs.WRONG_UNPACK_SIZE % (length, oparg))
        elif topType not in _UNCHECKABLE_STACK_TYPES:
            if cfg().unpackNonSequence:
                code.addWarning(msgs.UNPACK_NON_SEQUENCE %
                                (top.data, _getTypeStr(topType)))
        _modifyStackName(code, '-unpack')
</t>
<t tx="ekr.20040701040524.202">def _SLICE_1_ARG(oparg, operand, codeSource, code) :
    _popStackRef(code, operand)
</t>
<t tx="ekr.20040701040524.203">_SLICE1 = _SLICE2 = _SLICE_1_ARG

def _SLICE3(oparg, operand, codeSource, code) :
    _popStackRef(code, operand, 3)
</t>
<t tx="ekr.20040701040524.204">def _check_string_iteration(code, index):
    try:
        item = code.stack[index]
    except IndexError:
        return
    if item.getType(code.typeMap) == types.StringType and \
       cfg().stringIteration:
        code.addWarning(msgs.STRING_ITERATION % item.data)
</t>
<t tx="ekr.20040701040524.205">def _FOR_LOOP(oparg, operand, codeSource, code) :
    code.loops = code.loops + 1
    _check_string_iteration(code, -2)
    _popStackRef(code, '&lt;for_loop&gt;', 2)
</t>
<t tx="ekr.20040701040524.206">def _GET_ITER(oparg, operand, codeSource, code) :
    _check_string_iteration(code, -1)
</t>
<t tx="ekr.20040701040524.207">def _FOR_ITER(oparg, operand, codeSource, code) :
    code.loops = code.loops + 1
    _popStackRef(code, '&lt;for_iter&gt;', 1)
</t>
<t tx="ekr.20040701040524.208">def _jump(oparg, operand, codeSource, code) :
    if len(code.stack) &gt; 0 :
        topOfStack = code.stack[-1]
        if topOfStack.isMethodCall(codeSource.classObject, cfg().methodArgName):
            name = topOfStack.data[-1]
            if codeSource.classObject.methods.has_key(name) :
                code.addWarning(msgs.USING_METHOD_AS_ATTR % name)
</t>
<t tx="ekr.20040701040524.209">_JUMP_ABSOLUTE = _jump

def _skip_loops(bytes, i, lastLineNum, max) :
    extended_arg = 0
    blockCount = 1
    while i &lt; max :
        op, oparg, i, extended_arg = OP.getInfo(bytes, i, extended_arg)
        if OP.LINE_NUM(op) :
            lastLineNum = oparg
        elif OP.FOR_LOOP(op) or OP.FOR_ITER(op) or OP.SETUP_LOOP(op) :
            blockCount = blockCount + 1
        elif OP.POP_BLOCK(op) :
            blockCount = blockCount - 1
            if blockCount &lt;= 0 :
                break

    return lastLineNum, i
</t>
<t tx="ekr.20040701040524.210">def _is_unreachable(code, topOfStack, branch, if_false) :
    # Are we are checking exceptions, but we not catching all exceptions?
    if (topOfStack.type == Stack.TYPE_COMPARISON and 
        topOfStack.data[1] == 'exception match' and 
        topOfStack.data[2] is not Exception) :
        return 1

    # do we possibly have while 1: ?
    if not (topOfStack.const and topOfStack.data == 1 and if_false) :
        return 0

    # get the op just before the branch (ie, -3)
    op, oparg, i, extended_arg = OP.getInfo(code.bytes, branch - 3, 0)
    # are we are jumping to before the while 1: (LOAD_CONST, JUMP_IF_FALSE)
    if not (OP.JUMP_ABSOLUTE(op) and oparg == (code.index - 3*3)) :
        return 0

    # check if we break out of the loop
    i = code.index
    lastLineNum = code.getLineNum()
    while i &lt; branch :
        op, oparg, i, extended_arg = OP.getInfo(code.bytes, i, extended_arg)
        if OP.LINE_NUM(op) :
            lastLineNum = oparg
        elif OP.BREAK_LOOP(op) :
            return 0
        elif OP.FOR_LOOP(op) or OP.FOR_ITER(op) or OP.SETUP_LOOP(op) :
            lastLineNum, i = _skip_loops(code.bytes, i, lastLineNum, branch)

    i = code.index - 3*4
    op, oparg, i, extended_arg = OP.getInfo(code.bytes, i, 0)
    if OP.SETUP_LOOP(op) :
        # a little lie to pretend we have a raise after a while 1:
        code.removeBranch(i + oparg)
        code.raiseValues.append((lastLineNum, None, i + oparg))
    return 1
</t>
<t tx="ekr.20040701040524.211"># In Python 2.3, while/if 1: gets optimized to
# ...
# JUMP_FORWARD 4
# JUMP_IF_FALSE ?
# POP_TOP
#
# which generates a Using a conditional statement with a constant value

# JUMP_FORWARD = 110; 4, 0 is the offset (4)
_IGNORE_BOGUS_JUMP = '%c%c%c' % (110, 4, 0)
def _shouldIgnoreBogusJumps(code):
    return _shouldIgnoreCodeOptimizations(code, _IGNORE_BOGUS_JUMP, 6, 3)
</t>
<t tx="ekr.20040701040524.212">def _checkConstantCondition(code, topOfStack, if_false):
    # don't warn when doing (test and 'true' or 'false')
    # still warn when doing (test and None or 'false')
    if if_false or not OP.LOAD_CONST(code.nextOpInfo(1)[0]) or \
       not topOfStack.data or topOfStack.type is types.NoneType:
        if not _shouldIgnoreBogusJumps(code):
            code.addWarning(msgs.CONSTANT_CONDITION % str(topOfStack))
</t>
<t tx="ekr.20040701040524.213">def _jump_conditional(oparg, operand, codeSource, code, if_false) :
    # FIXME: this doesn't work in 2.3+ since constant conditions
    #        are optimized away by the compiler.
    if code.stack :
        topOfStack = code.stack[-1]
        if (topOfStack.const or topOfStack.type is types.NoneType) and \
           cfg().constantConditions and \
           (topOfStack.data != 1 or cfg().constant1):
            _checkConstantCondition(code, topOfStack, if_false)

        if _is_unreachable(code, topOfStack, code.label, if_false) :
            code.removeBranch(code.label)

    _jump(oparg, operand, codeSource, code)
</t>
<t tx="ekr.20040701040524.214">def _JUMP_IF_FALSE(oparg, operand, codeSource, code) :
    _jump_conditional(oparg, operand, codeSource, code, 1)
</t>
<t tx="ekr.20040701040524.215">def _JUMP_IF_TRUE(oparg, operand, codeSource, code) :
    _jump_conditional(oparg, operand, codeSource, code, 0)
</t>
<t tx="ekr.20040701040524.216">def _JUMP_FORWARD(oparg, operand, codeSource, code) :
    _jump(oparg, operand, codeSource, code)
    code.remove_unreachable_code(code.label)
</t>
<t tx="ekr.20040701040524.217">def _RETURN_VALUE(oparg, operand, codeSource, code) :
    if not codeSource.calling_code :
        code.addReturn()
</t>
<t tx="ekr.20040701040524.218">def _EXEC_STMT(oparg, operand, codeSource, code) :
    if cfg().usesExec :
        if code.stack and code.stack[-1].isNone() :
            code.addWarning(msgs.USES_GLOBAL_EXEC)
        else :
            code.addWarning(msgs.USES_EXEC)
</t>
<t tx="ekr.20040701040524.219">def _checkStrException(code, varType, item):
    if varType is types.StringType:
        code.addWarning(msgs.RAISE_STR_EXCEPTION % item.data)
</t>
<t tx="ekr.20040701040524.220">def _RAISE_VARARGS(oparg, operand, codeSource, code) :
    code.addRaise()
    if not cfg().badExceptions:
        return

    if oparg &gt; 0 and len(code.stack) &gt;= oparg:
        item = code.stack[-oparg]
        if item.type not in (Stack.TYPE_FUNC_RETURN, Stack.TYPE_UNKNOWN):
            if item.type is Stack.TYPE_GLOBAL:
                e, is_str = _getExceptionInfo(codeSource, item)
                if is_str:
                    _checkStrException(code, e.type, item)
                elif e is not None and not _isexception(e):
                    code.addWarning(msgs.RAISE_BAD_EXCEPTION % item.data)
            else:
                _checkStrException(code, item.getType(code.typeMap), item)
</t>
<t tx="ekr.20040701040524.238">
#!/usr/bin/env python

# Copyright (c) 2001-2002, MetaSlash Inc.  All rights reserved.

"""
Object to hold information about functions.
Also contain a pseudo Python function object

"""

@language python

import string

_ARGS_ARGS_FLAG = 4
_KW_ARGS_FLAG = 8
_CO_FLAGS_MASK = _ARGS_ARGS_FLAG + _KW_ARGS_FLAG

@others</t>
<t tx="ekr.20040701040524.239">class _ReturnValues:

	@others
</t>
<t tx="ekr.20040701040524.240">def __init__(self):

    self.returnValues = None
</t>
<t tx="ekr.20040701040524.241">def returnsNoValue(self):

    returnValues = self.returnValues

    # if unset, we don't know
    if returnValues is None:
        return 0
        
    # it's an empty list, that means no values
    if not returnValues:
        return 1

    # make sure each value is not None
    for rv in returnValues:
        if not rv[1].isNone():
            return 0

    return returnValues[-1][1].isImplicitNone() # stack.isImplicitNone
</t>
<t tx="ekr.20040701040524.242">class FakeCode :
	"This is a holder class for code objects (so we can modify them)"
	@others
</t>
<t tx="ekr.20040701040524.243">def __init__(self, code, varnames = None) :
    for attr in dir(code):
        try:
            setattr(self, attr, getattr(code, attr))
        except:
            pass
    if varnames is not None:
        self.co_varnames = varnames
</t>
<t tx="ekr.20040701040524.244">class FakeFunction(_ReturnValues):

	"This is a holder class for turning code at module level into a function"

	@others
</t>
<t tx="ekr.20040701040524.245">def __init__(self, name, code, func_globals = {}, varnames = None) :
    
    _ReturnValues.__init__(self)
    
    self.func_name = self.__name__ = name
    self.func_doc  = self.__doc__  = "ignore"

    self.func_code = FakeCode(code, varnames)

    self.func_defaults = None
    self.func_globals = func_globals</t>
<t tx="ekr.20040701040524.246">def __str__(self):
    return self.func_name
</t>
<t tx="ekr.20040701040524.247">def __repr__(self):
    return '%s from %s' % (self.func_name, self.func_code.co_filename)
</t>
<t tx="ekr.20040701040524.248">class Function(_ReturnValues):
	"Class to hold all information about a function"
	@others
</t>
<t tx="ekr.20040701040524.249">def __init__(self, function, isMethod=0):

    _ReturnValues.__init__(self)

    self.function = function
    self.isMethod = isMethod
    self.minArgs = self.maxArgs = function.func_code.co_argcount

    if function.func_defaults is not None :
        self.minArgs = self.minArgs - len(function.func_defaults)
        
    # if function uses *args, there is no max # args
    try:
        if function.func_code.co_flags &amp; _ARGS_ARGS_FLAG != 0 :
            self.maxArgs = None
        self.supportsKW = function.func_code.co_flags &amp; _KW_ARGS_FLAG

    except AttributeError:
        # this happens w/Zope
        self.supportsKW = 0
</t>
<t tx="ekr.20040701040524.250">def __str__(self):

    return self.function.func_name
</t>
<t tx="ekr.20040701040524.251">def __repr__(self):

    return '%s from %s:%d' % (self.function.func_name,
                              self.function.func_code.co_filename,
                              self.function.func_code.co_firstlineno)
</t>
<t tx="ekr.20040701040524.252">def arguments(self) :

    numArgs = self.function.func_code.co_argcount

    if self.maxArgs is None :
        numArgs = numArgs + 1

    if self.supportsKW :
        numArgs = numArgs + 1

    return self.function.func_code.co_varnames[:numArgs]
</t>
<t tx="ekr.20040701040524.253">def isParam(self, name) :

    return name in self.arguments()
</t>
<t tx="ekr.20040701040524.254">def isStaticMethod(self):

    return self.isMethod and isinstance(self.function, type(create_fake))</t>
<t tx="ekr.20040701040524.255">def isClassMethod(self):

    try:
        return self.isMethod and self.function.im_self is not None
    except AttributeError:
        return 0
</t>
<t tx="ekr.20040701040524.256">def defaultValue(self, name) :

    func_code = self.function.func_code
    arg_names = list(func_code.co_varnames[:func_code.co_argcount])
    i = arg_names.index(name)

    if i &lt; self.minArgs :
        raise ValueError

    return self.function.func_defaults[i - self.minArgs]
</t>
<t tx="ekr.20040701040524.257">def varArgName(self) :
    
    if self.maxArgs is not None :
        return None

    func_code = self.function.func_code
    return func_code.co_varnames[func_code.co_argcount]
</t>
<t tx="ekr.20040701040524.258">def create_fake(name, code, func_globals = {}, varnames = None) :
    return Function(FakeFunction(name, code, func_globals, varnames))
</t>
<t tx="ekr.20040701040524.259">def create_from_file(file, filename, module) :
    # Make sure the file is at the beginning
    #   if python compiled the file, it will be at the end
    file.seek(0)

    # Read in the source file, see py_compile.compile() for games w/src str
    codestr = file.read()
    codestr = string.replace(codestr, "\r\n", "\n")
    codestr = string.replace(codestr, "\r", "\n")
    if codestr and codestr[-1] != '\n' :
        codestr = codestr + '\n'
    code = compile(codestr, filename, 'exec')
    return Function(FakeFunction('__main__', code, module.__dict__))
</t>
<t tx="ekr.20040701040524.260">def _co_flags_equal(o1, o2) :
    return (o1.co_flags &amp; _CO_FLAGS_MASK) == (o2.co_flags &amp; _CO_FLAGS_MASK)
</t>
<t tx="ekr.20040701040524.261">def same_signature(func, object) :
    '''Return a boolean value if the &lt;func&gt; has the same signature as
       a function with the same name in &lt;object&gt; (ie, an overriden method)'''

    try :
        baseMethod = getattr(object, func.func_name)
        base_func_code = baseMethod.im_func.func_code
    except AttributeError :
        return 1

    return _co_flags_equal(base_func_code, func.func_code) and \
           base_func_code.co_argcount == func.func_code.co_argcount
</t>
<t tx="ekr.20040701040524.262">@first #!/usr/bin/env python

# Copyright (c) 2001-2004, MetaSlash Inc.  All rights reserved.

"""
Warning Messages for PyChecker
"""

@language python

CHECKER_BROKEN = "INTERNAL ERROR -- STOPPED PROCESSING FUNCTION --\n\t%s"
INVALID_CHECKER_ARGS = "Invalid warning suppression arguments --\n\t%s"

NO_MODULE_DOC = "No module doc string"
NO_CLASS_DOC = "No doc string for class %s"
NO_FUNC_DOC = "No doc string for function %s"

VAR_NOT_USED = "Variable (%s) not used"
IMPORT_NOT_USED = "Imported module (%s) not used"
UNUSED_LOCAL = "Local variable (%s) not used"
UNUSED_PARAMETER = "Parameter (%s) not used"
UNUSED_MEMBERS = "Members (%s) not used in class (%s)"
NO_LOCAL_VAR = "No local variable (%s)"
VAR_USED_BEFORE_SET = "Variable (%s) used before being set"

REDEFINING_ATTR = "Redefining attribute (%s) original line (%d)"

MODULE_IMPORTED_AGAIN = "Module (%s) re-imported"
MODULE_MEMBER_IMPORTED_AGAIN = "Module member (%s) re-imported"
MODULE_MEMBER_ALSO_STAR_IMPORTED = "Module member (%s) re-imported with *"
MIX_IMPORT_AND_FROM_IMPORT = "Using import and from ... import for (%s)"
IMPORT_SELF = "Module (%s) imports itself"

NO_METHOD_ARGS = "No method arguments, should have %s as argument"
SELF_NOT_FIRST_ARG = "%s is not first %smethod argument"
SELF_IS_ARG = "self is argument in %s"
RETURN_FROM_INIT = "Cannot return a value from __init__"
NO_CTOR_ARGS = "Instantiating an object with arguments, but no constructor"

GLOBAL_DEFINED_NOT_DECLARED = "Global variable (%s) not defined in module scope"
INVALID_GLOBAL = "No global (%s) found"
INVALID_METHOD = "No method (%s) found"
INVALID_CLASS_ATTR = "No class attribute (%s) found"
INVALID_SET_CLASS_ATTR = "Setting class attribute (%s) not set in __init__"
INVALID_MODULE_ATTR = "No module attribute (%s) found"

LOCAL_SHADOWS_GLOBAL = "Local variable (%s) shadows global defined on line %d"
VARIABLE_SHADOWS_BUILTIN = "(%s) shadows builtin"
USING_METHOD_AS_ATTR = "Using method (%s) as an attribute (not invoked)"
OBJECT_HAS_NO_ATTR = "Object (%s) has no attribute (%s)"
METHOD_SIGNATURE_MISMATCH = "Overridden method (%s) doesn't match signature in class (%s)"

INVALID_ARG_COUNT1 = "Invalid arguments to (%s), got %d, expected %d"
INVALID_ARG_COUNT2 = "Invalid arguments to (%s), got %d, expected at least %d"
INVALID_ARG_COUNT3 = "Invalid arguments to (%s), got %d, expected between %d and %d"
FUNC_DOESNT_SUPPORT_KW = "Function (%s) doesn't support **kwArgs"
FUNC_DOESNT_SUPPORT_KW_ARG = "Function (%s) doesn't support **kwArgs for name (%s)"
FUNC_USES_NAMED_ARGS = "Function (%s) uses named arguments"

BASE_CLASS_NOT_INIT = "Base class (%s) __init__() not called"
NO_INIT_IN_SUBCLASS = "No __init__() in subclass (%s)"
METHODS_NEED_OVERRIDE = "Methods (%s) in %s need to be overridden in a subclass"

FUNC_TOO_LONG = "Function (%s) has too many lines (%d)"
TOO_MANY_BRANCHES = "Function (%s) has too many branches (%d)"
TOO_MANY_RETURNS = "Function (%s) has too many returns (%d)"
TOO_MANY_ARGS = "Function (%s) has too many arguments (%d)"
TOO_MANY_LOCALS = "Function (%s) has too many local variables (%d)"
TOO_MANY_REFERENCES = 'Law of Demeter violated, more than %d references for (%s)'

IMPLICIT_AND_EXPLICIT_RETURNS = "Function returns a value and also implicitly returns None"
INCONSISTENT_RETURN_TYPE = "Function return types are inconsistent"
INCONSISTENT_TYPE = "Variable (%s) already has types %s and set to %s"
CODE_UNREACHABLE = "Code appears to be unreachable"
CONSTANT_CONDITION = "Using a conditional statement with a constant value (%s)"
STRING_ITERATION = "Iterating over a string (%s)"
DONT_RETURN_NONE = "%s should not return None, raise an exception if not found"
IS_LITERAL = "Using is%s %s, may not always work"
INVALID_FORMAT = "Invalid format string, problem starts near: '%s'"
INVALID_FORMAT_COUNT = "Format string argument count (%d) doesn't match arguments (%d)"
TOO_MANY_STARS_IN_FORMAT = "Too many *s in format flags"
USING_STAR_IN_FORMAT_MAPPING = "Can't use * in formats when using a mapping (dictionary), near: '%s'"
CANT_MIX_MAPPING_IN_FORMATS = "Can't mix tuple/mapping (dictionary) formats in same format string"

INTEGER_DIVISION = "Using integer division (%s / %s) may return integer or float"
MODULO_1 = "... % 1 may be constant"
USING_TUPLE_ACCESS_TO_LIST = "Using a tuple instead of slice as list accessor for (%s)"
BOOL_COMPARE = "Comparisons with %s are not necessary and may not work as expected"
SHOULDNT_ASSIGN_BUILTIN = "Should not assign to %s, it is (or will be) a builtin"
SHOULDNT_ASSIGN_NAME = "Should not assign to %s, it is similar to builtin %s"
SET_VAR_TO_ITSELF = "Setting %s to itself has no effect"
MODIFY_VAR_NOOP = "%s %s %s has no effect"
DIVIDE_VAR_BY_ITSELF = "%s %s %s is always 1 or ZeroDivisionError"
XOR_VAR_WITH_ITSELF = "%s %s %s is always 0"

STMT_WITH_NO_EFFECT = "Operator (%s) doesn't exist, statement has no effect"
POSSIBLE_STMT_WITH_NO_EFFECT = "Statement appears to have no effect"
UNARY_POSITIVE_HAS_NO_EFFECT = "Unary positive (+) usually has no effect"
LIST_APPEND_ARGS = "[].append() only takes 1 argument in Python 1.6 and above for (%s)"

LOCAL_DELETED = "(%s) cannot be used after being deleted on line %d"
LOCAL_ALREADY_DELETED = "Local variable (%s) has already been deleted on line %d"
VAR_DELETED_BEFORE_SET = "Variable (%s) deleted before being set"

CATCH_BAD_EXCEPTION = "Catching a non-Exception object (%s)"
CATCH_STR_EXCEPTION = "Catching string exceptions are deprecated (%s)"
RAISE_BAD_EXCEPTION = "Raising an exception on a non-Exception object (%s)"
RAISE_STR_EXCEPTION = "Raising string exceptions are deprecated (%s)"
SET_EXCEPT_TO_BUILTIN = "Setting exception to builtin (%s), consider () around exceptions"
USING_KEYWORD = "Using identifier (%s) which will become a keyword in version %s"
MODIFYING_DEFAULT_ARG = "Modifying parameter (%s) with a default value may have unexpected consequences"
USING_SELF_IN_REPR = "Using `self` in __repr__ method"
USING_NONE_RETURN_VALUE = "Using the return value from (%s) which is always None"
WRONG_UNPACK_SIZE = "Unpacking %d values into %d variables"
WRONG_UNPACK_FUNCTION = "Unpacking function (%s) which returns %d values into %d variables"
UNPACK_NON_SEQUENCE = "Unpacking a non-sequence (%s) of type %s"

NOT_SPECIAL_METHOD = "%s is not a special method"
USING_COERCE_IN_NEW_CLASS = "Using __coerce__ in new-style class (%s) will not work for binary operations"
USING_GETATTRIBUTE_IN_OLD_CLASS = "Using __getattribute__ in old-style class (%s) does not work"
USING_PROPERTIES_IN_CLASSIC_CLASS = "Using property (%s) in classic class %s may not work"
USING_SLOTS_IN_CLASSIC_CLASS = "Using __slots__ in classic class %s has no effect, consider deriving from object"
EMPTY_SLOTS = "__slots__ are empty in %s"

USES_EXEC = "Using the exec statement"
USES_GLOBAL_EXEC = "Using the exec statement in global namespace"
USES_INPUT = "Using input() is a security problem, consider using raw_input()"

USING_DEPRECATED_MODULE = "%s module is deprecated"
USING_DEPRECATED_ATTR = "%s is deprecated"
USING_INSECURE_FUNC = "%s() is a security problem"
USE_INSTEAD = ", consider using %s"

USES_CONST_ATTR = "Passing a constant string to %s, consider direct reference"

BAD_STRING_FIND = "string.find() returns an integer, consider checking &gt;= 0 or &lt; 0 for not found"
</t>
<t tx="ekr.20040701040524.263">@first #!/usr/bin/env python

# Copyright (c) 2001-2004, MetaSlash Inc.  All rights reserved.

"""
Python byte code operations.

Very similar to the dis module, but dis does not exist in Jython,
so recreate the small portion we need here.
"""

@language python

@others</t>
<t tx="ekr.20040701040524.264"></t>
<t tx="ekr.20040701040524.265">def LINE_NUM(op):              return op == 127
</t>
<t tx="ekr.20040701040524.266">def LOAD_GLOBAL(op):           return op == 116
</t>
<t tx="ekr.20040701040524.267">def LOAD_CONST(op):            return op == 100
</t>
<t tx="ekr.20040701040524.268">def LOAD_FAST(op):             return op == 124
</t>
<t tx="ekr.20040701040524.269">def LOAD_ATTR(op):             return op == 105
</t>
<t tx="ekr.20040701040524.270">def STORE_ATTR(op):            return op == 95
</t>
<t tx="ekr.20040701040524.271">def POP_TOP(op):               return op == 1
</t>
<t tx="ekr.20040701040524.272">def IMPORT_FROM(op):           return op == 108
</t>
<t tx="ekr.20040701040524.273">def IMPORT_STAR(op):           return op == 84
</t>
<t tx="ekr.20040701040524.274">def UNARY_POSITIVE(op):        return op == 10
</t>
<t tx="ekr.20040701040524.275">def UNARY_NEGATIVE(op):        return op == 11
</t>
<t tx="ekr.20040701040524.276">def UNARY_INVERT(op):          return op == 15
</t>
<t tx="ekr.20040701040524.277">def RETURN_VALUE(op):          return op == 83
</t>
<t tx="ekr.20040701040524.278">def JUMP_FORWARD(op):          return op == 110
</t>
<t tx="ekr.20040701040524.279">def JUMP_ABSOLUTE(op):         return op == 113
</t>
<t tx="ekr.20040701040524.280">def FOR_ITER(op):              return op == 93
</t>
<t tx="ekr.20040701040524.281">def FOR_LOOP(op):              return op == 114
</t>
<t tx="ekr.20040701040524.282">def SETUP_LOOP(op):            return op == 120
</t>
<t tx="ekr.20040701040524.283">def BREAK_LOOP(op):            return op == 80
</t>
<t tx="ekr.20040701040524.284">def RAISE_VARARGS(op):         return op == 130
</t>
<t tx="ekr.20040701040524.285">def POP_BLOCK(op):             return op == 87
</t>
<t tx="ekr.20040701040524.286">def END_FINALLY(op):           return op == 88
</t>
<t tx="ekr.20040701040524.287"></t>
<t tx="ekr.20040701040524.288">def UNPACK_SEQUENCE(op) :
    "Deal w/Python 1.5.2 (UNPACK_[LIST|TUPLE]) or 2.0 (UNPACK_SEQUENCE)"
    return op in (92, 93,)
</t>
<t tx="ekr.20040701040524.289">def IS_CONDITIONAL_JUMP(op):
    return op in (111, 112)
</t>
<t tx="ekr.20040701040524.290">def IS_NOT(op):
    return op == 12
</t>
<t tx="ekr.20040701040524.291">HAVE_ARGUMENT = 90
EXTENDED_ARG = 143

_HAS_NAME = (90, 91, 95, 96, 97, 98, 101, 105, 107, 108, 116,)
_HAS_LOCAL = (124, 125, 126,)
_HAS_CONST = (100,)
_HAS_COMPARE = (106,)
_HAS_JREL = (110, 111, 112, 114, 120, 121, 122,)
_HAS_JABS = (113, 119,)

_CMP_OP =  ('&lt;', '&lt;=', '==', '!=', '&gt;', '&gt;=', 'in', 'not in', 'is',
            'is not', 'exception match', 'BAD')

EXCEPT_COMPARISON = 10
IS_COMPARISON = 8

def getOperand(op, func_code, oparg) :
    if op in _HAS_NAME :
        return func_code.co_names[oparg]
    elif op in _HAS_LOCAL :
        return func_code.co_varnames[oparg]
    elif op in _HAS_CONST :
        return func_code.co_consts[oparg]
    elif op in _HAS_COMPARE :
        return _CMP_OP[oparg]
    return None
</t>
<t tx="ekr.20040701040524.292">def getLabel(op, oparg, i) :
    if op in _HAS_JREL :
        return i + oparg
    elif op in _HAS_JABS :
        return oparg
    return None
</t>
<t tx="ekr.20040701040524.293">def getInfo(code, index, extended_arg) :
    """Returns (op, oparg, index, extended_arg) based on code
       this is a helper function while looping through byte code,
       refer to the standard module dis.disassemble() for more info"""

    # get the operation we are performing
    op = ord(code[index])
    index = index + 1
    if op &gt;= HAVE_ARGUMENT :
        # get the argument to the operation
        oparg = ord(code[index]) + ord(code[index+1])*256 + extended_arg
        index = index + 2
        extended_arg = 0
        if op == EXTENDED_ARG :
            extended_arg = oparg * 65536L
    else :
        oparg, extended_arg = 0, 0
    return op, oparg, index, extended_arg
</t>
<t tx="ekr.20040701040524.294">def initFuncCode(func) :
    """Returns (func_code, code, i, maxCode, extended_arg) based on func,
       this is a helper function to setup looping through byte code"""

    func_code = func.func_code
    code = func_code.co_code
    return func_code, code, 0, len(code), 0
</t>
<t tx="ekr.20040701040524.295">def conditional(op):
    "returns true if the code results in conditional execution"
    return op in [83,                   # return
                  93,                   # for_iter
                  111, 112, 114,        # conditional jump
                  121,                  # setup_exec
                  130                   # raise_varargs
                  ]
</t>
<t tx="ekr.20040701040524.296"># this code is here for debugging purposes.
# Jython doesn't support dis, so don't rely on it
try :
    import dis
    name = dis.opname
except ImportError :
    class Name:
	    'Turn name[x] into x'
	    @others
    name = Name()</t>
<t tx="ekr.20040701040524.297">def __getitem__(self, x):
    return str(x)</t>
<t tx="ekr.20040701040524.298">@ignore
@language python
&lt;&lt; options declarations &gt;&gt;
@others


if __name__=='__main__':
    dirs = os.path.join(os.path.split(os.getcwd())[:-1])
    sys.path.append(dirs[0])
    tk = Tkinter.Tk()
    tk.title('PyChecker')
    ConfigDialog(tk).main()
</t>
<t tx="ekr.20040701040524.299">"Main module for running pychecker a Tkinter GUI for all the options"

import sys
import os
import Tkinter, tkFileDialog

from OptionTypes import *
from string import capitalize, strip, rstrip, split

import Config

MAX_SUBBOX_ROWS = 8
MAX_BOX_COLS = 3
PAD = 10
EDITOR = "xterm -e vi -n +%(line)d %(file)s"
if sys.platform == 'win32':
    EDITOR = "notepad %(file)s"

</t>
<t tx="ekr.20040701040524.300">def col_weight(grid):
    "Set column weights so that sticky grid settings actually work"
    unused, col = grid.grid_size()
    for c in range(col):
        grid.columnconfigure(c, weight=1)
</t>
<t tx="ekr.20040701040524.301">def spawn(cmd_list):
    try:
        if os.fork():
            try:
                os.execvp(cmd_list[0], cmd_list)
            finally:
                sys.exit()
    except AttributeError:
        os.execvp(cmd_list[0], cmd_list)
</t>
<t tx="ekr.20040701040524.302">def edit(file, line):
    "Fire up an external editor to see the file at the given line"
    unused = file, line
    list = split(EDITOR)
    cmd_list = []
    for word in list:
        cmd_list.append(word % locals())
    spawn(cmd_list)
</t>
<t tx="ekr.20040701040524.303">def closeCB():
    sys.exit(0)
</t>
<t tx="ekr.20040701040524.304">
class Results:
	&lt;&lt; class Results declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701040524.305">"Display the warnings produced by checker"

</t>
<t tx="ekr.20040701040524.306">def __init__(self, w):
    self.top = Tkinter.Toplevel(w, name="results")
    self.top.transient(w)
    self.top.bind('&lt;Return&gt;', self.hide)
    self.top.bind('&lt;Escape&gt;', self.hide)
    self.text = Tkinter.Text(self.top, name="text")
    self.text.grid()
    self.text.bind('&lt;Double-Button-1&gt;', self.showFile)
    close = Tkinter.Button(self.top,
                        name="close",
                        default=Tkinter.ACTIVE,
                        command=self.hide)
    close.grid()
    self.text.update_idletasks()
</t>
<t tx="ekr.20040701040524.307">def show(self, text):
    self.text.delete("0.1", "end")
    self.text.insert("0.1", text)
    self.top.deiconify()
    self.top.lift()
</t>
<t tx="ekr.20040701040524.308">def hide(self, *unused):
    self.top.withdraw()
</t>
<t tx="ekr.20040701040524.309">def line(self):
    return split(self.text.index(Tkinter.CURRENT), ".")[0]
</t>
<t tx="ekr.20040701040524.310">def showFile(self, unused):
    import re
    line = self.line()
    text = self.text.get(line + ".0", line + ".end")
    text = rstrip(text)
    result = re.search("(.*):([0-9]+):", text)
    if result:
        file, line = result.groups()
        edit(file, int(line))
        self.text.after(0, self.selectLine)
</t>
<t tx="ekr.20040701040524.311">def selectLine(self):
    line = self.line()
    self.text.tag_remove(Tkinter.SEL, "1.0", Tkinter.END)
    self.text.tag_add(Tkinter.SEL, line + ".0", line + ".end")
</t>
<t tx="ekr.20040701040524.312">
class ConfigDialog:
	&lt;&lt; class ConfigDialog declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701040524.313">"Dialog for editing options"

</t>
<t tx="ekr.20040701040524.314">def __init__(self, tk):
    self._tk = tk
    self._cfg, _, _ = Config.setupFromArgs(sys.argv)

    self._help = None
    self._optMap = {}
    self._opts = []
    self._file = Tkinter.StringVar()
    self._results = None
</t>
<t tx="ekr.20040701040524.315">if len(sys.argv) &gt; 1:
        self._file.set(sys.argv[1])

    for name, group in Config._OPTIONS:
      opts = []
      for _, useValue, longArg, member, description in group:
          value = None
          if member:
              value = getattr(self._cfg, member)
              description = member + ": " + capitalize(description)
              description = strip(description)
          tk.option_add('*' + longArg + ".help", description)
          if useValue:
              if type(value) == type([]):
                  field = List(longArg, value)
              elif type(value) == type(1):
                  field = Number(longArg, int(value))
              elif type(value) == type(''):
                  field = Text(longArg, value)
              else:
                  field = Boolean(longArg, value)
          else:
              field = Boolean(longArg, value)
          self._optMap[longArg] = field
          opts.append(field)
      self._opts.append( (name, opts))

def _add_fields(self, w, opts):
    count = 0
    for opt in opts:
        f = opt.field(w)
        c, r = divmod(count, MAX_SUBBOX_ROWS)
        f.grid(row=r, column=c, sticky=Tkinter.NSEW)
        count = count + 1
</t>
<t tx="ekr.20040701040524.316">def _add_group(self, w, name, opts):
    colFrame = Tkinter.Frame(w)
    
    label = Tkinter.Label(colFrame, text=name + ":")
    label.grid(row=0, column=0, sticky=Tkinter.NSEW)
    
    gframe = Tkinter.Frame(colFrame, relief=Tkinter.GROOVE, borderwidth=2)
    gframe.grid(row=1, column=0, sticky=Tkinter.NSEW)
    self._add_fields(gframe, opts)
    
    label = Tkinter.Label(colFrame)
    label.grid(row=2, column=0, sticky=Tkinter.NSEW)
    colFrame.rowconfigure(2, weight=1)
    return colFrame
</t>
<t tx="ekr.20040701040524.317">def main(self):
    frame = Tkinter.Frame(self._tk, name="opts")
    frame.grid()
    self._tk.option_readfile('Options.ad')
    self._fields = {}
    row, col = 0, 0
    rowFrame = Tkinter.Frame(frame)
    rowFrame.grid(row=row)
    row = row + 1
    for name, opts in self._opts:
        w = self._add_group(rowFrame, name, opts)
        w.grid(row=row, column=col, sticky=Tkinter.NSEW, padx=PAD)
        col = col + 1
        if col &gt;= MAX_BOX_COLS:
            col_weight(rowFrame)
            rowFrame=Tkinter.Frame(frame)
            rowFrame.grid(row=row, sticky=Tkinter.NSEW)
            col = 0
            row = row + 1
    col_weight(rowFrame)

    self._help = Tkinter.Label(self._tk, name="helpBox")
    self._help.grid(row=row)
    self._help.config(takefocus=0)
    buttons = Tkinter.Frame(self._tk, name="buttons")
    ok = Tkinter.Button(buttons, name="ok", command=self.ok, default=Tkinter.ACTIVE)
    ok.grid(row=row, column=0)
    default = Tkinter.Button(buttons, name="default", command=self.default)
    default.grid(row=row, column=1)
    close = Tkinter.Button(buttons, name="close", command=closeCB)
    close.grid(row=row, column=2)
    buttons.grid()

    f = Tkinter.Frame(self._tk, name="fileStuff")
    Tkinter.Button(f, name="getfile", command=self.file).grid(row=0, column=1)
    fileEntry = Tkinter.Entry(f, name="fname", textvariable=self._file)
</t>
<t tx="ekr.20040701040524.318">fileEntry.grid(row=0, column=2)
    Tkinter.Button(f, name="check", command=self.check).grid(row=0, column=3)
    f.grid(sticky=Tkinter.EW)
    
    self._tk.bind_all('&lt;FocusIn&gt;', self.focus)
    self._tk.bind_all('&lt;Enter&gt;', self.focus)
    self._tk.bind_all('&lt;ButtonPress&gt;', self.click)
    fileEntry.bind('&lt;Return&gt;', self.check)
    self._tk.mainloop()

#
# Callbacks
#

def help(self, w):
    if type(w) == type(''):         # occurs with file dialog...
        return
    if self._help == w:             # ignore help events on help...
        return
    help = w.option_get("help", "help")
    self._help.configure(text=help)
</t>
<t tx="ekr.20040701040524.319">def focus(self, ev):
    self.help(ev.widget)
</t>
<t tx="ekr.20040701040524.320">def click(self, ev):
    self.help(ev.widget)
</t>
<t tx="ekr.20040701040524.321">def ok(self):
    opts = []
    # Pull command-line args
    for _, group in self._opts:
        for opt in group:
            arg = opt.arg()
            if arg:
                opts.append(arg)

    # Calculate config
    self._cfg, _, _ = Config.setupFromArgs(opts)

    # Set controls based on new config
    for _, group in Config._OPTIONS:
        for _, _, longArg, member, _ in group:
            if member:
                self._optMap[longArg].set(getattr(self._cfg, member))
</t>
<t tx="ekr.20040701040524.322">def default(self):
    self._cfg, _, _ = Config.setupFromArgs(sys.argv)
    for _, group in Config._OPTIONS:
        for _, _, longArg, member, _ in group:
            if member:
                self._optMap[longArg].set(getattr(self._cfg, member))
            else:
                self._optMap[longArg].set(0)
</t>
<t tx="ekr.20040701040524.323">def file(self):
    self._file.set(tkFileDialog.askopenfilename())
</t>
<t tx="ekr.20040701040524.324">def check(self, *unused):
    import checker
    import StringIO
    
    self.ok()                       # show effect of all settings

    checker._allModules = {}
    warnings = checker.getWarnings([self._file.get()], self._cfg)
    capture = StringIO.StringIO()
    
    if not self._results:
        self._results = Results(self._help)
    checker._printWarnings(warnings, capture)

    value = strip(capture.getvalue())
    if not value:
        value = "None"
    self._results.show(value)
</t>
<t tx="ekr.20040701040524.325">@language python
import Tkinter
@others
</t>
<t tx="ekr.20040701040524.326">def bool(value):
    if value:
        return 1
    return 0
</t>
<t tx="ekr.20040701040524.327">
class Base:
	&lt;&lt; class Base declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701040524.328">"Base class for all OptionTypes"

</t>
<t tx="ekr.20040701040524.329">def __init__(self, name, default):
    self._name = name
    self._default = default
    self._var = None
</t>
<t tx="ekr.20040701040524.330">def name(self):
    return self._name
</t>
<t tx="ekr.20040701040524.331">def set(self, value):
    self._var.set(value)
</t>
<t tx="ekr.20040701040524.332">
class Boolean(Base):
	&lt;&lt; class Boolean declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701040524.333">"A option type for editing boolean values"

</t>
<t tx="ekr.20040701040524.334">def __init__(self, name, default):
    Base.__init__(self, name, default)
</t>
<t tx="ekr.20040701040524.335">def field(self, w):
    self._var = Tkinter.BooleanVar()
    if self._default:
        self._var.set(1)
    else:
        self._var.set(0)
    frame = Tkinter.Frame(w, name = self._name + "Frame")
    result = Tkinter.Checkbutton(frame,
                                 name=self._name,
                                 text=self._name,
                                 variable=self._var)
    result.grid(sticky=Tkinter.W)
    frame.columnconfigure(0, weight=1)
    return frame
</t>
<t tx="ekr.20040701040524.336">def arg(self):
    if bool(self._var.get()) != bool(self._default):
        if bool(self._var.get()):
            return "--" + self._name
        return "--no-" + self._name
    return None
</t>
<t tx="ekr.20040701040524.337">
class Number(Base):
	&lt;&lt; class Number declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701040524.338">"OptionType for editing numbers"

</t>
<t tx="ekr.20040701040524.339">def __init__(self, name, default):
    Base.__init__(self, name, default)
</t>
<t tx="ekr.20040701040524.340">def field(self, w):
    self._var = Tkinter.IntVar()
    self._var.set(self._default)
    frame = Tkinter.Frame(w, name = self._name + "Frame")
    label = Tkinter.Label(frame, text=self._name + ":")
    label.grid(row=0, column=0, sticky=Tkinter.W)
    entry = Tkinter.Entry(frame,
                          name=self._name,
                          textvariable=self._var,
                          width=4)
    entry.grid(row=0, column=1, sticky=Tkinter.E)
    for i in range(2):
        frame.columnconfigure(i, weight=1)
    return frame
</t>
<t tx="ekr.20040701040524.341">def arg(self):
    if self._var.get() != self._default:
        return "--%s=%d" % (self._name, self._var.get())
    return None
</t>
<t tx="ekr.20040701040524.342">    
class Text(Base):
	&lt;&lt; class Text declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701040524.343">"OptionType for editing a little bit of text"

</t>
<t tx="ekr.20040701040524.344">def __init__(self, name, default):
    Base.__init__(self, name, default)
</t>
<t tx="ekr.20040701040524.345">def width(self):
    return int(min(15, len(self._default) * 1.20))
</t>
<t tx="ekr.20040701040524.346">def field(self, w):
    self._var = Tkinter.StringVar()
    self._var.set(self._default)
    frame = Tkinter.Frame(w, name = self._name + "Frame")
    label = Tkinter.Label(frame, text=self._name + ":")
    label.grid(row=0, column=0, sticky=Tkinter.W)
    entry = Tkinter.Entry(frame,
                          name=self._name,
                          textvariable=self._var,
                          width=self.width())
    entry.grid(row=0, column=1, sticky=Tkinter.E)
    for i in range(2):
        frame.columnconfigure(i, weight=1)
    return frame
</t>
<t tx="ekr.20040701040524.347">def arg(self):
    if self._var.get() != self._default:
        return "--%s=%s" % (self._name, self._var.get())
    return None
</t>
<t tx="ekr.20040701040524.348">def join(list):
    import string
    return string.join(list, ", ")
</t>
<t tx="ekr.20040701040524.349">
class List(Text):
	&lt;&lt; class List declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701040524.350">"OptionType for editing a list of values"

</t>
<t tx="ekr.20040701040524.351">def __init__(self, name, default):
    Text.__init__(self, name, join(default))
</t>
<t tx="ekr.20040701040524.352">def set(self, value):
    self._var.set(join(value))
</t>
<t tx="ekr.20040701040524.353">@first #!/usr/bin/env python

# Copyright (c) 2001, MetaSlash Inc.  All rights reserved.

"Helper functions for printing out info about objects"

@language python

@others
</t>
<t tx="ekr.20040701040524.354">def printFunction(spaces, prefix, func, className = None) :
    params = ''
    argcount = func.func_code.co_argcount
    defaultArgStart = argcount
    if func.func_defaults != None :
        defaultArgStart = argcount - len(func.func_defaults)
    for i in range(0, argcount) :
        arg = func.func_code.co_varnames[i]
        if i &gt;= defaultArgStart :
            arg = arg + " = %s" % str(func.func_defaults[i - defaultArgStart])
        params = params + "%s, " % arg
    params = "(%s)" % params[:-2]
    if className == None :
        className = ""
    else :
        className = className + "."
    print "%s%s%s%s%s" % (spaces, prefix, className, func.func_name, params)
</t>
<t tx="ekr.20040701040524.355">def module(module) :
    print "Module: ", module.moduleName
    if module.module == None :
        return

    print "  Imports:  ", module.modules.keys()
    print "  Variables:", module.variables.keys()
    print ""
    for function in module.functions.values() :
        printFunction("  ", "Function:  ", function.function)
    print ""
    for c in module.classes.values() :
        for method in c.methods.values() :
            if method != None :
                printFunction("  ", "", method.function, c.name)
        print ""
</t>
<t tx="ekr.20040701040524.356">def attrs(object) :
    for attr in dir(object) :
        print " %s: %s" % (attr, `getattr(object, attr)`)
</t>
<t tx="ekr.20040701040524.357">#!/usr/bin/env python

# Copyright (c) 2001-2004, MetaSlash Inc.  All rights reserved.

"""
Setup a lot of info about Python builtin types, functions, methods, etc.
"""

@language python

&lt;&lt; python imports &gt;&gt;

BOOL = types.IntType

@others</t>
<t tx="ekr.20040701040524.358">import types
import sys

from pychecker import utils
from pychecker import Stack
from pychecker import Warning</t>
<t tx="ekr.20040701040524.359">_OS_AND_POSIX_FUNCS = {
    'tempnam': None,
    'tmpnam': None
}
</t>
<t tx="ekr.20040701040524.360">_STRING_METHODS = {
    &lt;&lt; _STRING_METHODS &gt;&gt;
}

if utils.pythonVersion() &gt;= utils.PYTHON_2_2 :
    _STRING_METHODS['decode'] = (types.UnicodeType, 0, 2)</t>
<t tx="ekr.20040701040524.361">'capitalize': (types.StringType, 0, 0),
'center': (types.StringType, 1, 1),
'count': (types.IntType, 1, 1),
'encode': (types.StringType, 0, 2),
'endswith': (BOOL, 1, 3),
'expandtabs': (types.StringType, 0, 1),
'find': (types.IntType, 1, 3),
'index': (types.IntType, 1, 3),
'isalnum': (BOOL, 0, 0),
'isalpha': (BOOL, 0, 0),
'isdigit': (BOOL, 0, 0),
'islower': (BOOL, 0, 0),
'isspace': (BOOL, 0, 0),
'istitle': (BOOL, 0, 0),
'isupper': (BOOL, 0, 0),
'join': (types.StringType, 1, 1),
'ljust': (types.StringType, 1, 1),
'lower': (types.StringType, 0, 0),
'lstrip': (types.StringType, 0, 0),
'replace': (types.StringType, 2, 3),
'rfind': (types.IntType, 1, 3),
'rindex': (types.IntType, 1, 3),
'rjust': (types.StringType, 1, 1),
'rstrip': (types.StringType, 0, 0),
'split': (types.ListType, 0, 2),
'splitlines': (types.ListType, 0, 1),
'startswith': (BOOL, 1, 3),
'strip': (types.StringType, 0, 0),
'swapcase': (types.StringType, 0, 0),
'title': (types.StringType, 0, 0),
'translate': (types.StringType, 1, 2),
'upper': (types.StringType, 0, 0),</t>
<t tx="ekr.20040701040524.362">BUILTIN_ATTRS = {
    types.StringType : dir(''),
    types.TypeType : dir(type(type)),
    types.ListType : dir([]),
    types.DictType : dir({}),
    types.FunctionType : dir(_setupBuiltinAttrs),
    types.BuiltinFunctionType : dir(len),
    types.BuiltinMethodType : dir([].append),
    types.ClassType : dir(Stack.Item),
    types.UnboundMethodType : dir(Stack.Item.__init__),
    types.LambdaType : dir(lambda: None),
    types.SliceType : dir(slice(0)),
}

# have to setup the rest this way to support different versions of Python
_setupBuiltinAttrs()</t>
<t tx="ekr.20040701040524.363">
def _setupBuiltinAttrs() :
    w = Warning.Warning('', 0, '')
    BUILTIN_ATTRS[types.MethodType] = dir(w.__init__)
    del w

    if utils.pythonVersion() &gt;= utils.PYTHON_2_2 :
        # FIXME: I'm sure more types need to be added here
        BUILTIN_ATTRS[types.StringType] = dir(''.__class__)
        BUILTIN_ATTRS[types.ListType] = dir([].__class__)
        BUILTIN_ATTRS[types.DictType] = dir({}.__class__)

    try :
        import warnings
        _MSG = "xrange object's 'start', 'stop' and 'step' attributes are deprecated"
        warnings.filterwarnings('ignore', _MSG)
        del warnings, _MSG
    except (ImportError, AssertionError):
        pass
    BUILTIN_ATTRS[types.XRangeType] = dir(xrange(0))

    try: BUILTIN_ATTRS[types.ComplexType] = dir(complex(0, 1))
    except: pass

    try: BUILTIN_ATTRS[types.UnicodeType] = dir(unicode(''))
    except: pass

    try: BUILTIN_ATTRS[types.CodeType] = dir(_setupBuiltinAttrs.func_code)
    except: pass

    try: BUILTIN_ATTRS[types.FileType] = dir(sys.__stdin__)
    except: pass

    try:
        raise TypeError
    except TypeError :
        try:
            tb = sys.exc_info()[2]
            BUILTIN_ATTRS[types.TracebackType] = dir(tb)
            BUILTIN_ATTRS[types.FrameType] = dir(tb.tb_frame)
        except:
            pass
        tb = None
</t>
<t tx="ekr.20040701040524.364">BUILTIN_METHODS = {
    &lt;&lt; BUILTIN_METHODS &gt;&gt;
}

_setupBuiltinMethods()

if hasattr({}, 'pop'):
    BUILTIN_METHODS[types.DictType]['pop'] = (Stack.TYPE_UNKNOWN, 1, 1)</t>
<t tx="ekr.20040701040524.365">types.DictType :
{ 'clear': (types.NoneType, 0, 0),
  'copy': (types.DictType, 0, 0),
  'get': (Stack.TYPE_UNKNOWN, 1, 2),
  'has_key': (BOOL, 1, 1),
  'items': (types.ListType, 0, 0),
  'keys': (types.ListType, 0, 0),
  'popitem': (types.TupleType, 0, 0),
  'setdefault': (Stack.TYPE_UNKNOWN, 1, 2),
  'update': (types.NoneType, 1, 1),
  'values': (types.ListType, 0, 0),
},
types.ListType :
{ 'append': (types.NoneType, 1, 1),
  'count': (types.IntType, 1, 1),
  'extend': (types.NoneType, 1, 1),
  'index': (types.IntType, 1, 1),
  'insert': (types.NoneType, 2, 2),
  'pop': (Stack.TYPE_UNKNOWN, 0, 1),
  'remove': (types.NoneType, 1, 1),
  'reverse': (types.NoneType, 0, 0),
  'sort': (types.NoneType, 0, 1),
},
types.FileType :
{ 'close': (types.NoneType, 0, 0),
  'fileno': (types.IntType, 0, 0),
  'flush': (types.NoneType, 0, 0),
  'isatty': (BOOL, 0, 0),
  'read': (types.StringType, 0, 1),
  'readinto': (types.NoneType, 1, 1),
  'readline': (types.StringType, 0, 1),
  'readlines': (types.ListType, 0, 1),
  'seek': (types.NoneType, 1, 2),
  'tell': (types.IntType, 0, 0),
  'truncate': (types.NoneType, 0, 1),
  'write': (types.NoneType, 1, 1),
  'writelines': (types.NoneType, 1, 1),
  'xreadlines': (types.ListType, 0, 0),
},</t>
<t tx="ekr.20040701040524.366">def _setupBuiltinMethods() :
    if utils.pythonVersion() &gt;= utils.PYTHON_2_2 :
        PY22_DICT_METHODS = { 'iteritems': (types.ListType, 0, 0),
                              'iterkeys': (types.ListType, 0, 0),
                              'itervalues': (types.ListType, 0, 0),
                            }

        BUILTIN_METHODS[types.DictType].update(PY22_DICT_METHODS)

    try :
        BUILTIN_METHODS[types.ComplexType] = \
                                  { 'conjugate': (types.ComplexType, 0, 0), }
    except AttributeError :
        pass

    if len(dir('')) &gt; 0 :
        BUILTIN_METHODS[types.StringType] = _STRING_METHODS

    try :
        BUILTIN_METHODS[types.UnicodeType] = _STRING_METHODS
    except AttributeError :
        pass</t>
<t tx="ekr.20040701040524.367">DEPRECATED_ATTRS = {
    'array.read': None, 'array.write': None,
    'operator.isCallable': None,
    'operator.sequenceIncludes': None,
    'pty.master_open': None, 'pty.slave_open': None,
    'random.stdgamma': 'random.gammavariate',
    'rfc822.AddrlistClass': 'rfc822.AddressList',
    'string.atof': None, 'string.atoi': None,
    'string.atol': None, 'string.zfill': None,
    'sys.exc_traceback': None, 'sys.exit_thread': None,
    'tempfile.mktemp': None, 'tempfile.template': None,
}
</t>
<t tx="ekr.20040701040524.368">DEPRECATED_METHODS = {
    # FIXME: can't check these right now, maybe later
    'email.Message.get_type': 'email.Message.get_content_type',
    'email.Message.get_subtype': 'email.Message.get_content_subtype',
    'email.Message.get_main_type': 'email.Message.get_content_maintype',
    'htmllib.HTMLParser.do_nextid': None,
    'pstats.Stats.ignore': None,
    'random.Random.cunifvariate': None,
    'random.Random.stdgamma': 'Random.gammavariate',
}
</t>
<t tx="ekr.20040701040524.369">DEPRECATED_MODULES = {
    'audioop': None, 'FCNTL': 'fcntl', 'gopherlib': None,
    'macfs': 'Carbon.File or Carbon.Folder',
    'posixfile': 'fcntl', 'pre': None, 'regsub': 're',
    'statcache': 'os.stat()',
    'stringold': None, 'tzparse': None,
    'TERMIOS': 'termios', 'whrandom':'random',
    'xmllib': 'xml.sax',
    
    # C Modules
    'mpz': None, 'pcre': None, 'pypcre': None,
    'rgbimg': None, 'strop': None, 'xreadlines': 'file',
}</t>
<t tx="ekr.20040701040524.370"># identifiers which will become a keyword in a future version
FUTURE_KEYWORDS = { 'yield': '2.2' }</t>
<t tx="ekr.20040701040524.371">GLOBAL_FUNC_INFO = {
    &lt;&lt; GLOBAL_FUNC_INFO &gt;&gt;
}

# name   (type,  args: min, max, kwArgs?

if hasattr(types, 'UnicodeType') :
    &lt;&lt; add unicode functions to GLOBAL_FUNC_INFO &gt;&gt;

if utils.pythonVersion() &gt;= utils.PYTHON_2_2 :
    &lt;&lt; add python 2.2 functions to GLOBAL_FUNC_INFO &gt;&gt;
    
tryAddGlobal('zip', types.ListType, 1, None)
tryAddGlobal('enumerate', types.TupleType, 1, 1, ['sequence'])
# sum() could also return float/long
tryAddGlobal('sum', types.IntType, 1, 2, ['start'])
# reversed() always returns an iterator  (FIXME: support iterator)
tryAddGlobal('reversed', Stack.TYPE_UNKNOWN, 1, 1)</t>
<t tx="ekr.20040701040524.372">'__import__': (types.ModuleType, 1, 4),
'abs': (Stack.TYPE_UNKNOWN, 1, 1),
'apply': (Stack.TYPE_UNKNOWN, 2, 3),
'buffer': (types.BufferType, 1, 3),
'callable': (BOOL, 1, 1),
'chr': (types.StringType, 1, 1),
'cmp': (types.IntType, 2, 2),
'coerce': ([ types.NoneType, types.TupleType ], 2, 2),
'compile': (types.CodeType, 3, 3),
'complex': (types.ComplexType, 1, 2, ['real', 'imag']),
'delattr': (types.NoneType, 2, 2),
'dir': (types.ListType, 0, 1),
'divmod': (types.TupleType, 2, 2),
'eval': (Stack.TYPE_UNKNOWN, 1, 3),
'execfile': (types.NoneType, 1, 3),
'filter': (types.ListType, 2, 2),
'float': (types.FloatType, 1, 1),
'getattr': (Stack.TYPE_UNKNOWN, 2, 3),
'globals': (types.DictType, 0, 0),
'hasattr': (BOOL, 2, 2),
'hash': (types.IntType, 1, 1),
'hex': (types.StringType, 1, 1),
'id': (types.IntType, 1, 1),
'input': (Stack.TYPE_UNKNOWN, 0, 1),
'int': (types.IntType, 1, 2, ['x']),
'intern': (types.StringType, 1, 1),
'isinstance': (BOOL, 2, 2),
'issubclass': (BOOL, 2, 2),
'len': (types.IntType, 1, 1),
'list': (types.ListType, 1, 1, ['sequence']),
'locals': (types.DictType, 0, 0),
'long': (types.LongType, 1, 2, ['x']),
'map': (types.ListType, 2, None),
'max': (Stack.TYPE_UNKNOWN, 1, None),
'min': (Stack.TYPE_UNKNOWN, 1, None),
'oct': (types.StringType, 1, 1),
'open': (types.FileType, 1, 3, ['name', 'mode', 'buffering']),
'ord': (types.IntType, 1, 1),
'pow': (Stack.TYPE_UNKNOWN, 2, 3),
'range': (types.ListType, 1, 3),
'raw_input': (types.StringType, 0, 1),
'reduce': (Stack.TYPE_UNKNOWN, 2, 3),
'reload': (types.ModuleType, 1, 1),
'repr': (types.StringType, 1, 1),
'round': (types.FloatType, 1, 2),
'setattr': (types.NoneType, 3, 3),
'slice': (types.SliceType, 1, 3),
'str': (types.StringType, 1, 1),
'tuple': (types.TupleType, 1, 1),
'type': (types.TypeType, 1, 1),
'vars': (types.DictType, 0, 1),
'xrange': (types.ListType, 1, 3),</t>
<t tx="ekr.20040701040524.373">GLOBAL_FUNC_INFO['compile'] = (types.CodeType, 3, 5)
GLOBAL_FUNC_INFO['dict']    = (types.DictType, 0, 1, ['items'])
GLOBAL_FUNC_INFO['file']    = GLOBAL_FUNC_INFO['open']
GLOBAL_FUNC_INFO['float']   = (types.FloatType, 0, 1, ['x'])
GLOBAL_FUNC_INFO['int']     = (types.IntType, 0, 2, ['x'])
GLOBAL_FUNC_INFO['list']    = (types.ListType, 0, 1, ['sequence'])
GLOBAL_FUNC_INFO['long']    = (types.LongType, 0, 2, ['x'])
GLOBAL_FUNC_INFO['str']     = (types.StringType, 0, 1, ['object'])
# FIXME: type doesn't take 2 args, only 1 or 3
GLOBAL_FUNC_INFO['type']    = (types.TypeType, 1, 3, ['name', 'bases', 'dict'])
GLOBAL_FUNC_INFO['tuple']   = (types.TupleType, 0, 1, ['sequence'])

GLOBAL_FUNC_INFO['classmethod']  = (types.MethodType, 1, 1)
GLOBAL_FUNC_INFO['iter']         = (Stack.TYPE_UNKNOWN, 1, 2)
GLOBAL_FUNC_INFO['property']     = (Stack.TYPE_UNKNOWN, 0, 4, ['fget', 'fset', 'fdel', 'doc'])
GLOBAL_FUNC_INFO['super']        = (Stack.TYPE_UNKNOWN, 1, 2)
GLOBAL_FUNC_INFO['staticmethod'] = (types.MethodType, 1, 1)
GLOBAL_FUNC_INFO['unicode']      = (types.UnicodeType, 0, 3, ['string', 'encoding', 'errors'])

GLOBAL_FUNC_INFO['bool'] = (BOOL, 1, 1, ['x'])</t>
<t tx="ekr.20040701040524.374">GLOBAL_FUNC_INFO['unichr']  = (types.UnicodeType, 1, 1)
GLOBAL_FUNC_INFO['unicode'] = (types.UnicodeType, 1, 3, ['string', 'encoding', 'errors'])</t>
<t tx="ekr.20040701040524.375">METHODLESS_OBJECTS = {
    types.NoneType : None, types.IntType : None,
    types.LongType : None, types.FloatType : None,
    types.BufferType : None, types.TupleType : None,
    types.EllipsisType : None,
}</t>
<t tx="ekr.20040701040524.376">MUTABLE_TYPES = (
    types.ListType, types.DictType, types.InstanceType,
)
</t>
<t tx="ekr.20040701040524.377">PENDING_DEPRECATED_MODULES = {
    'string': None,
    'types': None,
}
</t>
<t tx="ekr.20040701040524.378">SECURITY_FUNCS = {
    'os' : _OS_AND_POSIX_FUNCS,
    'posix': _OS_AND_POSIX_FUNCS
}</t>
<t tx="ekr.20040701040524.379">SPECIAL_METHODS = {
    &lt;&lt; SPECIAL_METHODS &gt;&gt;
}</t>
<t tx="ekr.20040701040524.380">'__call__': None,                   # any number &gt; 1
'__cmp__': 2,
'__coerce__': 2,
'__contains__': 2,
'__del__': 1,
'__hash__': 1,
'__iter__': 1,
'__len__': 1,
'__new__': None,			# new-style class constructor
'__nonzero__': 1,
'__reduce__': 1,

'__hex__': 1,
'__oct__': 1,
'__repr__': 1,
'__str__': 1,

'__invert__': 1,	'__neg__': 1,	'__pos__': 1,     '__abs__': 1,     
'__complex__': 1,	'__int__': 1,	'__long__': 1,    '__float__': 1,

'__eq__': 2,	'__ne__': 2,
'__ge__': 2,	'__gt__': 2,
'__le__': 2,	'__lt__': 2,

'__getattribute__': 2,	# only in new-style classes
'__getattr__': 2,		'__setattr__': 3,	'__delattr__': 2,
'__getitem__': 2,		'__setitem__': 3,	'__delitem__': 2,
'__getslice__': 3,		'__setslice__': 4,	'__delslice__': 3,
# getslice is deprecated

'__add__': 2,	'__radd__': 2,		'__iadd__': 2,    
'__sub__': 2,	'__rsub__': 2,		'__isub__': 2,
'__mul__': 2,	'__rmul__': 2,		'__imul__': 2,    
'__div__': 2,	'__rdiv__': 2,		'__idiv__': 2,    
'__pow__': 2,	'__rpow__': 2,		'__ipow__': 2,    # 2 or 3
'__truediv__': 2,	'__rtruediv__': 2,	'__itruediv__': 2,	
'__floordiv__': 2,	'__rfloordiv__': 2,	'__ifloordiv__': 2,	
'__mod__': 2,	'__rmod__': 2,		'__imod__': 2,    
'__divmod__': 2,	'__rdivmod__': 2,	# no inplace op for divmod()

'__lshift__': 2,	'__rlshift__': 2,	'__ilshift__': 2,
'__rshift__': 2,	'__rrshift__': 2,	'__irshift__': 2, 

'__and__': 2,	'__rand__': 2,		'__iand__': 2,
'__xor__': 2,	'__rxor__': 2,		'__ixor__': 2,
'__or__': 2,	'__ror__': 2,		'__ior__': 2,

# these are related to pickling 
'__getstate__': 1,		'__setstate__': 2,
'__copy__': 1,		'__deepcopy__': 2,
'__getinitargs__': 1,</t>
<t tx="ekr.20040701040524.381">def tryAddGlobal(name, *args):
    if globals().has_key(name):
        GLOBAL_FUNC_INFO[name] = args
</t>
<t tx="ekr.20040701040524.382">#!/usr/bin/env python

# Copyright (c) 2001-2002, MetaSlash Inc.  All rights reserved.

"""
Module to hold manipulation of elements on the stack.
"""

import types

DATA_UNKNOWN = "-unknown-"
LOCALS = 'locals'

# These should really be defined by subclasses
TYPE_UNKNOWN = "-unknown-"
TYPE_FUNC_RETURN = "-return-value-"
TYPE_ATTRIBUTE = "-attribute-"
TYPE_COMPARISON = "-comparison-"
TYPE_GLOBAL = "-global-"
TYPE_EXCEPT = "-except-"

@language python

@others
</t>
<t tx="ekr.20040701040524.383">class Item :
	"Representation of data on the stack"
	@others
</t>
<t tx="ekr.20040701040524.384">def __init__(self, data, dataType, const = 0, length = 0) :
    
    self.data = data
    self.type = dataType
    self.const = const
    self.length = length
    self.is_really_string = 0

</t>
<t tx="ekr.20040701040524.385">def __str__(self) :

    if type(self.data) == types.TupleType :
        value = '('
        for item in self.data :
            value = value + str(item) + ', '
        # strip off the ', ' for multiple items
        if len(self.data) &gt; 1 :
            value = value[:-2]
        return value + ')'

    return str(self.data)
</t>
<t tx="ekr.20040701040524.386">def __repr__(self):
    
    return 'Stack Item: (%s, %s, %d)' % (self.data, self.type, self.const)

</t>
<t tx="ekr.20040701040524.387">def isNone(self) :

    return (self.type != TYPE_UNKNOWN and self.data is None or
            (self.data == 'None' and not self.const))
</t>
<t tx="ekr.20040701040524.388">def isImplicitNone(self) :

    return self.data is None and self.const
</t>
<t tx="ekr.20040701040524.389">def isMethodCall(self, c, methodArgName):

    return self.type == TYPE_ATTRIBUTE and c != None and \
           len(self.data) == 2 and self.data[0] == methodArgName
</t>
<t tx="ekr.20040701040524.390">def isLocals(self) :

    return self.type == types.DictType and self.data == LOCALS
</t>
<t tx="ekr.20040701040524.391">def setStringType(self, value = types.StringType):

    self.is_really_string = value == types.StringType
</t>
<t tx="ekr.20040701040524.392">def getType(self, typeMap) :
    
    if self.type != types.StringType or self.is_really_string:
        return self.type

    if self.const :
        return type(self.data)

    if type(self.data) == types.StringType :
        localTypes = typeMap.get(self.data, [])
        if len(localTypes) == 1 :
            return localTypes[0]

    return TYPE_UNKNOWN
</t>
<t tx="ekr.20040701040524.393">def getName(self) :
    
    if self.type == TYPE_ATTRIBUTE and type(self.data) != types.StringType:

        strValue = ""
        # convert the tuple into a string ('self', 'data') -&gt; self.data
        for item in self.data :
            strValue = '%s.%s' % (strValue, str(item))
        return strValue[1:]

    return str(self.data)
</t>
<t tx="ekr.20040701040524.394">def addAttribute(self, attr) :
    
    if type(self.data) == types.TupleType :
        self.data = self.data + (attr,)
    else :
        self.data = (self.data, attr)

    self.type = TYPE_ATTRIBUTE
</t>
<t tx="ekr.20040701040524.395">def makeDict(values = (), const = 1) :

    values = tuple(values)

    if not values:
        values = ('&lt;on-stack&gt;',)

    return Item(values, types.DictType, const, len(values))
</t>
<t tx="ekr.20040701040524.396">def makeTuple(values = (), const = 1) :

    return Item(tuple(values), types.TupleType, const, len(values))
</t>
<t tx="ekr.20040701040524.397">def makeList(values = [], const = 1) :

    return Item(values, types.ListType, const, len(values))
</t>
<t tx="ekr.20040701040524.398">def makeFuncReturnValue(stackValue, argCount) :
    
    data = DATA_UNKNOWN
    # vars() without params == locals()

    if stackValue.type == TYPE_GLOBAL and \
       (stackValue.data == LOCALS or
        (argCount == 0 and stackValue.data == 'vars')) :
        data = LOCALS

    return Item(data, TYPE_FUNC_RETURN)
</t>
<t tx="ekr.20040701040524.399">def makeComparison(stackItems, comparison) :

    return Item((stackItems[0], comparison, stackItems[1]), TYPE_COMPARISON)
</t>
<t tx="ekr.20040701040524.400">@first #!/usr/bin/env python

# Copyright (c) 2001-2004, MetaSlash Inc.  All rights reserved.

"""
Print out warnings from Python source files.
"""
&lt;&lt; utils imports &gt;&gt;

VAR_ARGS_BITS = 8
MAX_ARGS_MASK = ((1 &lt;&lt; VAR_ARGS_BITS) - 1)

INIT = '__init__'
LAMBDA = '&lt;lambda&gt;'

# number of instructions to check backwards if it was a return
BACK_RETURN_INDEX = 4

_cfg = []

@language python

@others</t>
<t tx="ekr.20040701040524.401">import sys
import string
import copy

from pychecker import msgs
from pychecker import Config
from pychecker.Warning import Warning</t>
<t tx="ekr.20040701040524.402">def cfg() :
    return _cfg[-1]
</t>
<t tx="ekr.20040701040524.403">def initConfig(cfg) :
    _cfg.append(cfg)
</t>
<t tx="ekr.20040701040524.404">def pushConfig() :
    newCfg = copy.copy(cfg())
    _cfg.append(newCfg)
</t>
<t tx="ekr.20040701040524.405">def popConfig() :
    del _cfg[-1]
</t>
<t tx="ekr.20040701040524.406">def shouldUpdateArgs(operand) :
    return operand == Config.CHECKER_VAR
</t>
<t tx="ekr.20040701040524.407">def updateCheckerArgs(argStr, func, lastLineNum, warnings) :
    try :
        argList = string.split(argStr)
        # don't require long options to start w/--, we can add that for them
        for i in range(0, len(argList)) :
            if argList[i][0] != '-' :
                argList[i] = '--' + argList[i]

        cfg().processArgs(argList)
        return 1
    except Config.UsageError, detail :
        warn = Warning(func, lastLineNum, msgs.INVALID_CHECKER_ARGS % detail)
        warnings.append(warn)
        return 0
</t>
<t tx="ekr.20040701040524.408">def debug(*args) :
    if cfg().debug: print args
</t>
<t tx="ekr.20040701040524.409">PYTHON_1_5 = 0x10502
PYTHON_2_0 = 0x20000
PYTHON_2_1 = 0x20100
PYTHON_2_2 = 0x20200
PYTHON_2_3 = 0x20300
PYTHON_2_4 = 0x20400

def pythonVersion() :
    return sys.hexversion &gt;&gt; 8
</t>
<t tx="ekr.20040701040524.410">def startswith(s, substr) :
    "Ugh, supporting python 1.5 is a pain"
    return s[0:len(substr)] == substr
</t>
<t tx="ekr.20040701040524.411">def endswith(s, substr) :
    "Ugh, supporting python 1.5 is a pain"
    return s[-len(substr):] == substr
</t>
<t tx="ekr.20040701040524.412"># generic method that can be slapped into any class, thus the self parameter
def std_repr(self) :
    return "&lt;%s at 0x%x: %s&gt;" % (self.__class__.__name__, id(self), str(self))
</t>
<t tx="ekr.20040701040524.413">@first #!/usr/bin/env python

# Copyright (c) 2001-2002, MetaSlash Inc.  All rights reserved.

"""
Print out warnings from Python source files.
"""

@language python

&lt;&lt; warn imports &gt;&gt;

@others

if 0:
    # if you want to test w/psyco, include this
    import psyco
    psyco.bind(_checkCode)</t>
<t tx="ekr.20040701040524.414">import os.path
import sys
import string
import types
import traceback
import imp

from pychecker import OP
from pychecker import Stack
from pychecker import function
from pychecker import python

from pychecker import msgs
from pychecker import utils
from pychecker import CodeChecks
from pychecker.Warning import Warning</t>
<t tx="ekr.20040701040524.415">def cfg() :
    return utils.cfg()
</t>
<t tx="ekr.20040701040524.416">def _checkSelfArg(method, warnings) :
    """Return a Warning if there is no self parameter or
       the first parameter to a method is not self."""

    if not cfg().methodArgName:
        return

    code = method.function.func_code
    err = None
    if method.isStaticMethod():
        if code.co_argcount &gt; 0 and cfg().methodArgName == code.co_varnames[0]:
            err = msgs.SELF_IS_ARG % 'staticmethod'
    elif code.co_argcount &lt; 1: 
        err = msgs.NO_METHOD_ARGS % cfg().methodArgName
    else:
        if method.isClassMethod():
            if code.co_varnames[0] not in cfg().classmethodArgNames:
                err = msgs.SELF_NOT_FIRST_ARG % \
                      (cfg().classmethodArgNames, 'class')
        elif code.co_varnames[0] != cfg().methodArgName:
            err = msgs.SELF_NOT_FIRST_ARG % (cfg().methodArgName, '')

    if err is not None :
        warnings.append(Warning(code, code, err))
</t>
<t tx="ekr.20040701040524.417">def _checkNoSelfArg(func, warnings) :
    "Return a Warning if there is a self parameter to a function."

    code = func.function.func_code
    if code.co_argcount &gt; 0 and cfg().methodArgName in code.co_varnames:
        warnings.append(Warning(code, code, msgs.SELF_IS_ARG % 'function'))
</t>
<t tx="ekr.20040701040524.418">def _checkSubclass(c1, c2):
    try:
        return issubclass(c1.classObject, c2.classObject)
    except (TypeError, AttributeError):
        return 0
</t>
<t tx="ekr.20040701040524.419">_IGNORE_RETURN_TYPES = ( Stack.TYPE_FUNC_RETURN, Stack.TYPE_ATTRIBUTE,
                         Stack.TYPE_GLOBAL, Stack.TYPE_COMPARISON,
                         Stack.TYPE_UNKNOWN)

def _checkReturnWarnings(code) :
    is_getattr = code.func_code.co_name in ('__getattr__', '__getattribute__')
    if is_getattr :
        for line, retval, dummy in code.returnValues :
            if retval.isNone() :
                err = msgs.DONT_RETURN_NONE % code.func_code.co_name
                code.addWarning(err, line+1)

    # there must be at least 2 real return values to check for consistency
    returnValuesLen = len(code.returnValues)
    if returnValuesLen &lt; 2 :
        return

    # if the last return is implicit, check if there are non None returns
    lastReturn = code.returnValues[-1]
    if not code.starts_and_ends_with_finally and \
       cfg().checkImplicitReturns and lastReturn[1].isImplicitNone() :
        for line, retval, dummy in code.returnValues[:-1] :
            if not retval.isNone() :
                code.addWarning(msgs.IMPLICIT_AND_EXPLICIT_RETURNS,
                                lastReturn[0]+1)
                break

    # __get*__ funcs can return different types, don't warn about inconsistency
    if utils.startswith(code.func_code.co_name, '__get') and \
       utils.endswith(code.func_code.co_name, '__') :
        return

    returnType, returnData = None, None
    for line, value, dummy in code.returnValues :
        if not value.isNone() :
            valueType = value.getType(code.typeMap)
            if returnType is None and valueType not in _IGNORE_RETURN_TYPES :
                returnData = value
                returnType = valueType
                continue

            # always ignore None, None can be returned w/any other type
            # FIXME: if we stored func return values, we could do better
            if returnType is not None and not value.isNone() and \
               valueType not in _IGNORE_RETURN_TYPES and \
               returnData.type not in _IGNORE_RETURN_TYPES :
                ok = returnType in (type(value.data), valueType)
                if ok :
                    if returnType == types.TupleType :
                        # FIXME: this isn't perfect, if len == 0
                        # the length can really be 0 OR unknown
                        # we shouldn't check the lengths for equality
                        # ONLY IF one of the lengths is truly unknown
                        if returnData.length &gt; 0 and value.length &gt; 0:
                            ok = returnData.length == value.length
                else :
                    ok = _checkSubclass(returnType, valueType) or \
                         _checkSubclass(valueType, returnType)
                if not ok :
                    code.addWarning(msgs.INCONSISTENT_RETURN_TYPE, line)
</t>
<t tx="ekr.20040701040524.420">def _checkComplex(code, maxValue, value, func, err) :
    if maxValue and value &gt; maxValue :
        line = func.function.func_code.co_firstlineno
        code.addWarning(err % (func.function.__name__, value), line)
</t>
<t tx="ekr.20040701040524.421">def _checkCode(code, codeSource) :
    while code.index &lt; code.maxCode :
        op, oparg, operand = code.popNextOp()
        dispatch_func = CodeChecks.DISPATCH[op]
        if dispatch_func is not None :
            dispatch_func(oparg, operand, codeSource, code)
</t>
<t tx="ekr.20040701040524.422">def _name_unused(var) :
    if var in cfg().unusedNames :
        return 0
    for name in cfg().unusedNames :
        if name != '_' and utils.startswith(var, name) :
            return 0
    return 1
</t>
<t tx="ekr.20040701040524.423">def _checkUnusedParam(var, line, func, code) :
    if line is not None and line == 0 and _name_unused(var) :
        if ((cfg().ignoreSelfUnused or var != cfg().methodArgName) and
            (cfg().varArgumentsUsed or func.varArgName() != var)) :
            code.addWarning(msgs.UNUSED_PARAMETER % var, code.func_code)
</t>
<t tx="ekr.20040701040524.424">def _handleNestedCode(func_code, code, codeSource):
    nested = not (codeSource.main or codeSource.in_class)
    if func_code.co_name == utils.LAMBDA or nested:
        utils.debug(' handling nested code')
        varnames = None
        if nested and func_code.co_name != utils.LAMBDA:
            varnames = func_code.co_varnames + \
                     codeSource.calling_code[-1].function.func_code.co_varnames
        code.init(function.create_fake(func_code.co_name, func_code, {},
                                       varnames))
        _checkCode(code, codeSource)
</t>
<t tx="ekr.20040701040524.425">def _findUnreachableCode(code) :
    # code after RETURN or RAISE is unreachable unless there's a branch to it
    unreachable = {}
    terminals = code.returnValues[:-1] + code.raiseValues
    terminals.sort(lambda a, b: cmp(a[2], b[2]))
    for line, dummy, i in terminals :
        if not code.branches.has_key(i) :
            unreachable[i] = line

    # find the index of the last return
    lastLine, lastItem, lastIndex = code.returnValues[-1]
    if len(code.returnValues) &gt;= 2 :
        lastIndex = code.returnValues[-2][2]
    if code.raiseValues :
        lastIndex = max(lastIndex, code.raiseValues[-1][2])

    # remove last return if it's unreachable AND implicit
    if unreachable.get(lastIndex) == lastLine and lastItem.isImplicitNone() :
        del code.returnValues[-1]
        del unreachable[lastIndex]

    if cfg().unreachableCode :
        for index in unreachable.keys() :
            try :
                if not OP.JUMP_FORWARD(ord(code.bytes[index])) :
                    code.addWarning(msgs.CODE_UNREACHABLE, unreachable[index])
            except IndexError :
                pass
</t>
<t tx="ekr.20040701040524.426">def _checkFunction(module, func, c = None, main = 0, in_class = 0) :
    "Return a list of Warnings found in a function/method."

    # always push a new config object, so we can pop at end of function
    utils.pushConfig()

    code = CodeChecks.Code()
    code.init(func)
    if main:
        for key in func.function.func_globals.keys():
            code.unusedLocals[key] = -1
    codeSource = CodeChecks.CodeSource(module, func, c, main, in_class, code)
    try :
        _checkCode(code, codeSource)

        # handle lambdas
        codeSource.calling_code.append(func)
        for func_code in code.codeObjects.values() :
            _handleNestedCode(func_code, code, codeSource)
        del codeSource.calling_code[-1]

        if not in_class :
            _findUnreachableCode(code)

    except (SystemExit, KeyboardInterrupt) :
        exc_type, exc_value, exc_tb = sys.exc_info()
        raise exc_type, exc_value
    except :
        exc_type, exc_value, exc_tb = sys.exc_info()
        exc_list = traceback.format_exception(exc_type, exc_value, exc_tb)
        for index in range(0, len(exc_list)) :
            exc_list[index] = string.replace(exc_list[index], "\n", "\n\t")
        code.addWarning(msgs.CHECKER_BROKEN % string.join(exc_list, ""))

    if cfg().checkReturnValues :
        _checkReturnWarnings(code)

    if cfg().localVariablesUsed :
        for var, line in code.unusedLocals.items() :
            if line is not None and line &gt; 0 and _name_unused(var) :
                code.addWarning(msgs.UNUSED_LOCAL % var, line)

    if cfg().argumentsUsed :
        op = code.getFirstOp()
        if not (OP.RAISE_VARARGS(op) or OP.RETURN_VALUE(op)) :
            for var, line in code.unusedLocals.items() :
                _checkUnusedParam(var, line, func, code)

    # Check code complexity:
    #   loops should be counted as one branch, but there are typically 3
    #   branches in byte code to setup a loop, so subtract off 2/3's of them
    #    / 2 to approximate real branches
    branches = (len(code.branches.keys()) - (2 * code.loops)) / 2
    lines = (code.getLineNum() - code.func_code.co_firstlineno)
    returns = len(code.returnValues)
    if not main and not in_class :
        args = code.func_code.co_argcount
        locals = len(code.func_code.co_varnames) - args
        _checkComplex(code, cfg().maxArgs, args, func, msgs.TOO_MANY_ARGS)
        _checkComplex(code, cfg().maxLocals, locals, func, msgs.TOO_MANY_LOCALS)
        _checkComplex(code, cfg().maxLines, lines, func, msgs.FUNC_TOO_LONG)
    _checkComplex(code, cfg().maxReturns, returns, func, msgs.TOO_MANY_RETURNS)
    _checkComplex(code, cfg().maxBranches, branches, func, msgs.TOO_MANY_BRANCHES)

    if not (main or in_class) :
        utils.popConfig()
    func.returnValues = code.returnValues
    return (code.warnings, code.globalRefs, code.functionsCalled,
            code.codeObjects.values(), code.returnValues)
</t>
<t tx="ekr.20040701040524.427">def _getUnused(module, globalRefs, dict, msg, filterPrefix = None) :
    "Return a list of warnings for unused globals"

    warnings = []
    for ref in dict.keys() :
        check = not filterPrefix or utils.startswith(ref, filterPrefix)
        if check and globalRefs.get(ref) == None :
            lineInfo = module.moduleLineNums.get(ref)
            if lineInfo:
                warnings.append(Warning(lineInfo[0], lineInfo[1], msg % ref))
    return warnings
</t>
<t tx="ekr.20040701040524.428">def _get_func_info(method) :
    try:
        fc = getattr(method.im_func, 'func_code', None)
        if fc is not None :
            return fc.co_filename, fc.co_firstlineno
    except AttributeError:
        # if the object derives from any object in 2.2,
        # the builtin methods are wrapper_descriptors and
        # have no im_func attr
        pass
    return None, None
</t>
<t tx="ekr.20040701040524.429">_DOT_INIT = '.' + utils.INIT

def _baseInitCalled(classInitInfo, base, functionsCalled) :
    baseInit = getattr(base, utils.INIT, None)
    if baseInit is None or _get_func_info(baseInit) == classInitInfo :
        return 1

    initName = str(base) + _DOT_INIT
    if functionsCalled.has_key(initName) :
        return 1

    # ok, do this the hard way, there may be aliases, so check here
    names = string.split(initName, '.')
    try:
        # i think this can raise an exception if the module is a library (.so)
        obj = sys.modules[names[0]]
    except KeyError:
        return 1
    for i in range(1, len(names)) :
        obj = getattr(obj, names[i], None)
        if obj is None:
            return 0
        if functionsCalled.has_key(string.join(names[i:], '.')) :
            return 1

    return 0
</t>
<t tx="ekr.20040701040524.430">def _checkBaseClassInit(moduleFilename, c, func_code, funcInfo) :
    """Return a list of warnings that occur
       for each base class whose __init__() is not called"""

    warnings = []
    functionsCalled, _, returnValues = funcInfo
    for line, stackItem, dummy in returnValues :
        if stackItem.data != None :
            if not stackItem.isNone() or cfg().returnNoneFromInit :
                warn = Warning(moduleFilename, line, msgs.RETURN_FROM_INIT)
                warnings.append(warn)

    classInit = getattr(c.classObject, utils.INIT, None)
    if cfg().baseClassInitted and classInit is not None :
        classInitInfo = _get_func_info(classInit)
        for base in c.classObject.__bases__ :
            if not _baseInitCalled(classInitInfo, base, functionsCalled) :
                warn = Warning(moduleFilename, func_code,
                               msgs.BASE_CLASS_NOT_INIT % str(base))
                warnings.append(warn)
    return warnings
</t>
<t tx="ekr.20040701040524.431">def _checkOverridenMethods(func, baseClasses, warnings) :
    for baseClass in baseClasses :
        if func.func_name != utils.INIT and \
           not function.same_signature(func, baseClass) :
            err = msgs.METHOD_SIGNATURE_MISMATCH % (func.func_name, str(baseClass))
            warnings.append(Warning(func.func_code, func.func_code, err))
            break
</t>
<t tx="ekr.20040701040524.432">def _updateFunctionWarnings(module, func, c, warnings, globalRefs,
                            main = 0, in_class = 0) :
    "Update function warnings and global references"

    newWarnings, newGlobalRefs, funcs, codeObjects, returnValues = \
                 _checkFunction(module, func, c, main, in_class)

    warnings.extend(newWarnings)
    globalRefs.update(newGlobalRefs)

    return funcs, codeObjects, returnValues
</t>
<t tx="ekr.20040701040524.433">def getBlackList(moduleList) :
    blacklist = []
    for badBoy in moduleList :
        if badBoy[-3:] == ".py":
            badBoy = badBoy[0:-3]
        try :
            file, path, flags = imp.find_module(badBoy)
            if file :
                file.close()
                blacklist.append(path)
        except ImportError :
            pass
    return blacklist
</t>
<t tx="ekr.20040701040524.434">def getStandardLibrary() :
    if cfg().ignoreStandardLibrary :
        try :
            from distutils import sysconfig

            std_lib = sysconfig.get_python_lib()
            path = os.path.split(std_lib)
            if path[1] == 'site-packages' :
                std_lib = path[0]
            return std_lib
        except ImportError :
            return None
</t>
<t tx="ekr.20040701040524.435">def normalize_path(path):
    return os.path.normpath(os.path.normcase(path))
</t>
<t tx="ekr.20040701040524.436">def removeWarnings(warnings, blacklist, std_lib) :
    if std_lib is not None:
        std_lib = normalize_path(std_lib)
    for index in range(len(warnings)-1, -1, -1) :
        filename = normalize_path(warnings[index].file)
        if filename in blacklist or (std_lib is not None and
                                     utils.startswith(filename, std_lib)) :
            del warnings[index]

    return warnings
</t>
<t tx="ekr.20040701040524.437">

class _SuppressionError(Exception) :
	&lt;&lt; class _SuppressionError declarations &gt;&gt;
</t>
<t tx="ekr.20040701040524.438">pass

</t>
<t tx="ekr.20040701040524.439">def _updateSuppressions(suppress, warnings) :
    if not utils.updateCheckerArgs(suppress, 'suppressions', 0, warnings) :
        utils.popConfig()
        raise _SuppressionError
</t>
<t tx="ekr.20040701040524.440">def getSuppression(name, suppressions, warnings) :
    try :
        utils.pushConfig()

        suppress = suppressions[0].get(name, None)
        if suppress is not None :
            _updateSuppressions(suppress, warnings)

        regexList = suppressions[1].keys()
        regexList.sort()
        for regex in regexList :
            match = regex.match(name)
            if match and match.group() == name :
                suppress = 1
                _updateSuppressions(suppressions[1][regex], warnings)

        if not suppress :
            utils.popConfig()

        return suppress
    except _SuppressionError :
        return None
</t>
<t tx="ekr.20040701040524.441">def _findFunctionWarnings(module, globalRefs, warnings, suppressions) :

    for func in module.functions.values() :
        func_code = func.function.func_code
        utils.debug("function:", func_code)

        name = '%s.%s' % (module.moduleName, func.function.__name__)
        suppress = getSuppression(name, suppressions, warnings)

        if cfg().noDocFunc and func.function.__doc__ == None :
            err = msgs.NO_FUNC_DOC % func.function.__name__
            warnings.append(Warning(module.filename(), func_code, err))

        _checkNoSelfArg(func, warnings)
        _updateFunctionWarnings(module, func, None, warnings, globalRefs)
        if suppress is not None :
            utils.popConfig()
</t>
<t tx="ekr.20040701040524.442">def _getModuleFromFilename(module, filename):
    if module.filename() != filename:
        for m in module.modules.values():
            if m.filename() == filename:
                return m
    return module
</t>
<t tx="ekr.20040701040524.443"># Create object for non-2.2 interpreters, any class object will do
try:
    if object: pass
except NameError:
    object = _SuppressionError

# Create property for pre-2.2 interpreters
try :
    if property: pass
except NameError:
    property = None

def _findClassWarnings(module, c, class_code,
                       globalRefs, warnings, suppressions) :
    try:
        className = str(c.classObject)
    except TypeError:
        # goofy __getattr__
        return
    classSuppress = getSuppression(className, suppressions, warnings)
    baseClasses = c.allBaseClasses()
    for base in baseClasses :
        baseModule = str(base)
        if '.' in baseModule :
            # make sure we handle import x.y.z
            packages = string.split(baseModule, '.')
            baseModuleDir = string.join(packages[:-1], '.')
            globalRefs[baseModuleDir] = baseModule

    # handle class variables
    if class_code is not None :
        func = function.create_fake(c.name, class_code)
        _updateFunctionWarnings(module, func, c, warnings, globalRefs, 0, 1)

    filename = module.filename()
    func_code = None
    for method in c.methods.values() :
        if method == None :
            continue
        func_code = method.function.func_code
        utils.debug("method:", func_code)

        try:
            name = str(c.classObject) + '.' + method.function.func_name
        except AttributeError:
            # func_name may not exist
            continue
        methodSuppress = getSuppression(name, suppressions, warnings)

        if cfg().checkSpecialMethods:
            funcname = method.function.func_name
            if funcname[:2] == '__' == funcname[-2:] and \
               funcname != '__init__':
                err = None
                argCount = python.SPECIAL_METHODS.get(funcname, -1)
                if argCount != -1:
                    # if the args are None, it can be any # of args
                    if argCount is not None:
                        minArgs = maxArgs = argCount
                        err = CodeChecks.getFunctionArgErr(funcname,
                                     func_code.co_argcount, minArgs, maxArgs)
                else:
                    err = msgs.NOT_SPECIAL_METHOD % funcname

                if err is not None:
                    warnings.append(Warning(filename, func_code, err))
                
        if cfg().checkOverridenMethods :
            _checkOverridenMethods(method.function, baseClasses, warnings)

        if cfg().noDocFunc and method.function.__doc__ == None :
            err = msgs.NO_FUNC_DOC % method.function.__name__
            warnings.append(Warning(filename, func_code, err))

        _checkSelfArg(method, warnings)
        tmpModule = _getModuleFromFilename(module, func_code.co_filename)
        funcInfo = _updateFunctionWarnings(tmpModule, method, c, warnings, globalRefs)
        
        if func_code.co_name == utils.INIT :
            if utils.INIT in dir(c.classObject) :
                warns = _checkBaseClassInit(filename, c, func_code, funcInfo)
                warnings.extend(warns)
            elif cfg().initDefinedInSubclass :
                err = msgs.NO_INIT_IN_SUBCLASS % c.name
                warnings.append(Warning(filename, c.getFirstLine(), err))
        if methodSuppress is not None :
            utils.popConfig()

    if c.memberRefs and cfg().membersUsed :
        memberList = c.memberRefs.keys()
        memberList.sort()
        err = msgs.UNUSED_MEMBERS % (string.join(memberList, ', '), c.name)
        warnings.append(Warning(filename, c.getFirstLine(), err))

    try:
        newStyleClass = issubclass(c.classObject, object)
    except TypeError:
        # FIXME: perhaps this should warn b/c it may be a class???
        newStyleClass = 0

    slots = c.statics.get('__slots__')
    if slots is not None and cfg().slots:
        lineNum = c.lineNums['__slots__']
        if not newStyleClass:
            err = msgs.USING_SLOTS_IN_CLASSIC_CLASS % c.name
            warnings.append(Warning(filename, lineNum, err))
        elif len(slots.data) == 0 and cfg().emptySlots:
            err = msgs.EMPTY_SLOTS % c.name
            warnings.append(Warning(filename, lineNum, err))

    if not newStyleClass and property is not None and cfg().classicProperties:
        for static in c.statics.keys():
            if type(getattr(c.classObject, static, None)) == property:
                err = msgs.USING_PROPERTIES_IN_CLASSIC_CLASS % (static, c.name)
                warnings.append(Warning(filename, c.lineNums[static], err))

    coerceMethod = c.methods.get('__coerce__')
    if newStyleClass and coerceMethod:
        lineNum = coerceMethod.function.func_code.co_firstlineno
        err = msgs.USING_COERCE_IN_NEW_CLASS % c.name
        warnings.append(Warning(filename, lineNum, err))

    gettroMethod = c.methods.get('__getattribute__')
    if not newStyleClass and gettroMethod:
        lineNum = gettroMethod.function.func_code.co_firstlineno
        err = msgs.USING_GETATTRIBUTE_IN_OLD_CLASS % c.name
        warnings.append(Warning(filename, lineNum, err))

    if cfg().noDocClass and c.classObject.__doc__ == None :
        method = c.methods.get(utils.INIT, None)
        if method != None :
            func_code = method.function.func_code
        # FIXME: check to make sure this is in our file,
        #        not a base class file???
        err = msgs.NO_CLASS_DOC % c.classObject.__name__
        warnings.append(Warning(filename, func_code, err))

    # we have to do this here, b/c checkFunction doesn't popConfig for classes
    # this allows us to have __pychecker__ apply to all methods
    # when defined at class scope
    if class_code is not None :
        utils.popConfig()

    if classSuppress is not None :
        utils.popConfig()

</t>
<t tx="ekr.20040701040524.444">def find(moduleList, initialCfg, suppressions = None) :
    "Return a list of warnings found in the module list"

    if suppressions is None :
        suppressions = {}, {}

    utils.initConfig(initialCfg)

    warnings = []
    for module in moduleList :
        if module.moduleName in cfg().blacklist :
            continue

        modSuppress = getSuppression(module.moduleName, suppressions, warnings)
        globalRefs, classCodes = {}, {}

        # main_code can be null if there was a syntax error
        if module.main_code != None :
            funcInfo = _updateFunctionWarnings(module, module.main_code,
                                               None, warnings, globalRefs, 1)
            for code in funcInfo[1] :
                classCodes[code.co_name] = code

        _findFunctionWarnings(module, globalRefs, warnings, suppressions)

        for c in module.classes.values() :
                _findClassWarnings(module, c, classCodes.get(c.name),
                                   globalRefs, warnings, suppressions)

        if cfg().noDocModule and \
           module.module != None and module.module.__doc__ == None :
            warnings.append(Warning(module.filename(), 1, msgs.NO_MODULE_DOC))

        if cfg().allVariablesUsed or cfg().privateVariableUsed :
            prefix = None
            if not cfg().allVariablesUsed :
                prefix = "_"
            for ignoreVar in cfg().variablesToIgnore + cfg().unusedNames :
                globalRefs[ignoreVar] = ignoreVar
            warnings.extend(_getUnused(module, globalRefs, module.variables,
                                       msgs.VAR_NOT_USED, prefix))
        if cfg().importUsed :
            if module.moduleName != utils.INIT or cfg().packageImportUsed :
                # always ignore readline module, if [raw_]input() is used
                if globalRefs.has_key('input') or \
                   globalRefs.has_key('raw_input'):
                    globalRefs['readline'] = 0
                warnings.extend(_getUnused(module, globalRefs, module.modules,
                                           msgs.IMPORT_NOT_USED))

        if module.main_code != None :
            utils.popConfig()
        if modSuppress is not None :
            utils.popConfig()

    std_lib = None
    if cfg().ignoreStandardLibrary :
        std_lib = getStandardLibrary()
    return removeWarnings(warnings, getBlackList(cfg().blacklist), std_lib)</t>
<t tx="ekr.20040701040524.445">@first #!/usr/bin/env python

# Copyright (c) 2001, MetaSlash Inc.  All rights reserved.

"""
Warning class to hold info about each warning.
"""

@language python

class Warning :
	"Class which holds error information."
	@others</t>
<t tx="ekr.20040701040524.446">def __init__(self, file, line, err) :
    if hasattr(file, "function") :
        file = file.function.func_code.co_filename
    elif hasattr(file, "co_filename") :
        file = file.co_filename
    elif hasattr(line, "co_filename") :
        file = line.co_filename
    if file[:2] == './' :
        file = file[2:]
    self.file = file

    if hasattr(line, "co_firstlineno") :
        line = line.co_firstlineno
    if line == None :
        line = 1
    self.line = line
    self.err = err
</t>
<t tx="ekr.20040701040524.447">def __cmp__(self, warn) :
    if warn == None :
        return 1
    if self.file != warn.file :
        return cmp(self.file, warn.file)
    if self.line != warn.line :
        return cmp(self.line, warn.line)
    return cmp(self.err, warn.err)
</t>
<t tx="ekr.20040701040524.448">def format(self) :
    return "%s:%d: %s" % (self.file, self.line, self.err)
</t>
<t tx="ekr.20040701040524.449">def output(self, stream) :
    stream.write(self.format() + "\n")
</t>
<t tx="ekr.20040701040524.450">"""
Copyright (c) 2001, MetaSlash Inc.  All rights reserved.

PyChecker is a tool for finding common bugs in python source code.
It finds problems that are typically caught by a compiler for less
dynamic languages, like C and C++.  It is also similar to lint.

Contact Info:
  http://pychecker.sourceforge.net/
  pychecker-list@lists.sourceforge.net
"""

@language python

# A version # to check against in the main module (checker.py)
# this will allow us to check if there are two versions of checker
# in site-packages and local dir

MAIN_MODULE_VERSION = 1</t>
<t tx="ekr.20040701040524.451"></t>
<t tx="ekr.20040701040524.452">@nocolor

All works happens as the result of importing a module.

The Module class mirrors the actual work that Python does.

The top-level call is Module.load, which calls Module._initModule.

Module.initModule handles tokens:

The heart of the code is:

@color
    
    for tokenName in _filterDir(self.module, _DEFAULT_MODULE_TOKENS) :
        token = getattr(self.module, tokenName)
        if isinstance(token, types.ModuleType) :
            # get the real module name, tokenName could be an alias
            self.addModule(token.__name__)
        elif isinstance(token, types.FunctionType) :
            self.addFunction(token)
        elif isinstance(token, types.ClassType) or \
             hasattr(token, '__bases__') :
            self.addClass(tokenName)
        else :
            self.addVariable(tokenName, type(token))</t>
<t tx="ekr.20040701040524.453"></t>
<t tx="ekr.20040701040524.454"></t>
<t tx="ekr.20040701041311"></t>
<t tx="ekr.20040701041311.1">@ The children of this node contains source code I (Edward K. Ream) have used for
study. I have successfully used the two @file nodes to overwrite two pychecker
source files.

If you actually want to use any of this code, remove the @ignore directive
below, edit the path in the @file node to match the path to your pychecker
sources, and save this Leo file.
@c

@ignore</t>
<t tx="ekr.20040701041311.2"># The following are clones of children of the "Files..." node.
# They provide various different views of the code.</t>
<t tx="ekr.20040701144838"># An example of running this script:
import leoGlobals as g
import os

@others

theTypes = (".py",)
theDir = "c:/python23/Lib/site-packages/pychecker"

importFiles(theDir,theTypes,recursive=False)

g.es("done",color="blue")
</t>
<t tx="ekr.20040701144838.1">def importFiles (dir,type=None,kind="@file",recursive=False):
    
    c = g.top() ; v = c.currentVnode()

    # Check the params.
    if kind != "@file" and kind != "@root":
        g.es("kind must be @file or @root: " + kind)
        return

    if not g.os_path_exists(dir):
        g.es("directory does not exist: " + dir)
        return
    
    c.beginUpdate()
    root = createLastChildOf(v,"imported files")
    try:
        importDir (dir,type,kind,recursive,root)
        root.contract()
    except:
        g.es_exception()
    c.endUpdate()
</t>
<t tx="ekr.20040701144838.2">def importDir (dir,types,kind,recursive,root):
    
    c = g.top() # Get the commander.
    g.es("dir: " + dir,color="blue")
    
    try:
        files = os.listdir(dir)
        files2 = [] ; dirs =[]
        for f in files:
            path = g.os_path_join(dir,f)
            if g.os_path_isfile(path):
                name, ext = g.os_path_splitext(f)
                if not types or ext in types:
                    files2.append(path)
            elif recursive:
                dirs.append(path)
        if len(files2) &gt; 0 or len(dirs) &gt; 0:
            child = createLastChildOf(root,dir)
            c.selectVnode(child)
        if len(files2) &gt; 0:
            c.importCommands.importFilesCommand(files2,kind)
        if len(dirs) &gt; 0:
            dirs.sort()
            for dir in dirs:
                importDir(dir,types,kind,recursive,child)
    except:
        g.es("exception in importFiles script")
        g.es_exception()
</t>
<t tx="ekr.20040701144838.3">def createLastChildOf (v,headline):
    
    child = v.insertAsLastChild()
    child.initHeadString(headline)
    return child
</t>
<t tx="ekr.20040701145236"># Warning:  The children of this node contained the pychecker source files as produced by Leo's Import command.
# There is NO GUARANTEE that these files were imported accurately.  Use at your own risk!

@ignore</t>
<t tx="ekr.20040701145236.2">@first #!/usr/bin/env python

# Copyright (c) 2001-2004, MetaSlash Inc.  All rights reserved.

"""
Check python source code files for possible errors and print warnings

Contact Info:
  http://pychecker.sourceforge.net/
  pychecker-list@lists.sourceforge.net
"""

@language python

from leoGlobals import trace
print "Changed by EKR: pychecker.checker"

&lt;&lt; checker declarations &gt;&gt;

@others
</t>
<t tx="ekr.20040701145236.3">
import string
import types
import sys
import imp
import os
import glob
import traceback
import re

# see __init__.py for meaning, this must match the version there
LOCAL_MAIN_VERSION = 1


</t>
<t tx="ekr.20040701145236.4">def setupNamespace(path) :
    # remove pychecker if it's the first component, it needs to be last
    if sys.path[0][-9:] == 'pychecker' :
        del sys.path[0]

    # make sure pychecker is last in path, so we can import
    checker_path = os.path.dirname(os.path.dirname(path))
    if checker_path not in sys.path :
        sys.path.append(checker_path)
</t>
<t tx="ekr.20040701145236.5">if __name__ == '__main__' :
    setupNamespace(sys.argv[0])

from pychecker import utils
from pychecker import printer
from pychecker import warn
from pychecker import OP
from pychecker import Config
from pychecker import function
from pychecker.Warning import Warning

# Globals for storing a dictionary of info about modules and classes
_allModules = {}
_cfg = None

# Constants
_DEFAULT_MODULE_TOKENS = ('__builtins__', '__doc__', '__file__', '__name__',
                          '__path__')
_DEFAULT_CLASS_TOKENS = ('__doc__', '__name__', '__module__')

_VERSION_MISMATCH_ERROR = '''
There seem to be two versions of PyChecker being used.
One is probably in python/site-packages, the other in a local directory.
If you want to run the local version, you must remove the version
from site-packages.  Or you can install the current version
by doing python setup.py install.
'''

def cfg() :
    return utils.cfg()
</t>
<t tx="ekr.20040701145236.6">def _flattenList(list) :
    "Returns a list which contains no lists"

    new_list = []
    for element in list :
        if type(element) == types.ListType :
            new_list.extend(_flattenList(element))
        else :
            new_list.append(element)

    return new_list
</t>
<t tx="ekr.20040701145236.7">def getModules(arg_list) :
    "Returns a list of module names that can be imported"

    new_arguments = []
    for arg in arg_list :
        # is this a wildcard filespec? (necessary for windows)
        if '*' in arg or '?' in arg or '[' in arg :
            arg = glob.glob(arg)
        new_arguments.append(arg)

    PY_SUFFIXES = ['.py']
    PY_SUFFIX_LENS = [3]
    if _cfg.quixote:
        PY_SUFFIXES.append('.ptl')
        PY_SUFFIX_LENS.append(4)
        
    modules = []
    for arg in _flattenList(new_arguments) :
        # is it a .py file?
        for suf, suflen in zip(PY_SUFFIXES, PY_SUFFIX_LENS):
            if len(arg) &gt; suflen and arg[-suflen:] == suf:
                arg_dir = os.path.dirname(arg)
                if arg_dir and not os.path.exists(arg) :
                    print 'File or pathname element does not exist: "%s"' % arg
                    continue

                module_name = os.path.basename(arg)[:-suflen]
                if arg_dir not in sys.path :
                    sys.path.insert(0, arg_dir)
                arg = module_name
        modules.append(arg)

    return modules
</t>
<t tx="ekr.20040701145236.8">def _q_file(f):
    # crude hack!!!
    # imp.load_module requires a real file object, so we can't just
    # fiddle def lines and yield them
    import tempfile
    fd, newfname = tempfile.mkstemp(suffix=".py", text=True)
    newf = os.fdopen(fd, 'r+')
    os.unlink(newfname)
    for line in f:
        mat = re.match(r'(\s*def\s+\w+\s*)\[(html|plain)\](.*)', line)
        if mat is None:
            newf.write(line)
        else:
            newf.write(mat.group(1)+mat.group(3)+'\n')
    newf.seek(0)
    return newf
</t>
<t tx="ekr.20040701145236.9">def _q_find_module(p, path):
    if not _cfg.quixote:
        return imp.find_module(p, path)
    else:
        for direc in path:
            try:
                return imp.find_module(p, [direc])
            except ImportError:
                f = os.path.join(direc, p+".ptl")
                if os.path.exists(f):
                    return _q_file(file(f)), f, ('.ptl', 'U', 1)
</t>
<t tx="ekr.20040701145236.10">def _findModule(name) :
    """Returns the result of an imp.find_module(), ie, (file, filename, smt)
       name can be a module or a package name.  It is *not* a filename."""

    path = sys.path[:]
    packages = string.split(name, '.')
    for p in packages :
        # smt = (suffix, mode, type)
        file, filename, smt = _q_find_module(p, path)
        if smt[-1] == imp.PKG_DIRECTORY :
            try :
                # package found - read path info from init file
                m = imp.load_module(p, file, filename, smt)
            finally :
                if file is not None :
                    file.close()

            # importing xml plays a trick, which replaces itself with _xmlplus
            # both have subdirs w/same name, but different modules in them
            # we need to choose the real (replaced) version
            if m.__name__ != p :
                try :
                    file, filename, smt = _q_find_module(m.__name__, path)
                    m = imp.load_module(p, file, filename, smt)
                finally :
                    if file is not None :
                        file.close()

            new_path = m.__path__
            if type(new_path) == types.ListType :
                new_path = filename
            if new_path not in path :
                path.insert(1, new_path)
        elif smt[-1] != imp.PY_COMPILED:
            if p is not packages[-1] :
                if file is not None :
                    file.close()
                raise ImportError, "No module named %s" % packages[-1]
            return file, filename, smt

    # in case we have been given a package to check
    return file, filename, smt
</t>
<t tx="ekr.20040701145236.11">

class Variable :
	&lt;&lt; class Variable declarations &gt;&gt;
	@others

    __repr__ = utils.std_repr</t>
<t tx="ekr.20040701145236.12">"Class to hold all information about a variable"

</t>
<t tx="ekr.20040701145236.13">def __init__(self, name, type):
    self.name = name
    self.type = type
    self.value = None
</t>
<t tx="ekr.20040701145236.14">def __str__(self) :
    return self.name
</t>
<t tx="ekr.20040701145236.15">def _filterDir(object, ignoreList) :
    "Return a list of tokens (attributes) in a class, except for ignoreList"

    tokens = dir(object)
    for token in ignoreList :
        if token in tokens :
            tokens.remove(token)
    return tokens
</t>
<t tx="ekr.20040701145236.16">def _getClassTokens(c) :
    return _filterDir(c, _DEFAULT_CLASS_TOKENS)
</t>
<t tx="ekr.20040701145236.17">class Class :
	&lt;&lt; class Class declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.18">"Class to hold all information about a class"

</t>
<t tx="ekr.20040701145236.19">def __init__(self, name, module) :
    self.name = name
    self.classObject = getattr(module, name)

    modname = getattr(self.classObject, '__module__', None)
    if modname is None:
        # hm, some ExtensionClasses don't have a __module__ attribute
        # so try parsing the type output
        typerepr = repr(type(self.classObject))
        mo = re.match("^&lt;type ['\"](.+)['\"]&gt;$", typerepr)
        if mo:
            modname = ".".join(mo.group(1).split(".")[:-1])

    self.module = sys.modules.get(modname)
    if not self.module:
        self.module = module
        sys.stderr.write("warning: couldn't find real module for class %s "
                         "(module name: %s)\n"
                         % (self.classObject, modname))
    self.ignoreAttrs = 0
    self.methods = {}
    self.members = { '__class__': types.ClassType,
                     '__doc__': types.StringType,
                     '__dict__': types.DictType, }
    self.memberRefs = {}
    self.statics = {}
    self.lineNums = {}
</t>
<t tx="ekr.20040701145236.20">def __str__(self) :
    return self.name
</t>
<t tx="ekr.20040701145236.21">__repr__ = utils.std_repr

def getFirstLine(self) :
    "Return first line we can find in THIS class, not any base classes"

    lineNums = []
    classDir = dir(self.classObject)
    for m in self.methods.values() :
        if m != None and m.function.func_code.co_name in classDir:
            lineNums.append(m.function.func_code.co_firstlineno)
    if lineNums :
        return min(lineNums)
    return 0
</t>
<t tx="ekr.20040701145236.22">def allBaseClasses(self, c = None) :
    "Return a list of all base classes for this class and it's subclasses"

    baseClasses = []
    if c == None :
        c = self.classObject
    for base in c.__bases__ :
        baseClasses = baseClasses + [ base ] + self.allBaseClasses(base)
    return baseClasses
</t>
<t tx="ekr.20040701145236.23">def __getMethodName(self, func_name, className = None) :
    if func_name[0:2] == '__' and func_name[-2:] != '__' :
        if className == None :
            className = self.name
        if className[0] != '_' :
            className = '_' + className
        func_name = className + func_name
    return func_name
</t>
<t tx="ekr.20040701145236.24">def addMethod(self, method, methodName = None) :
    if type(method) == types.StringType :
        self.methods[method] = None
    else :
        assert methodName is not None, "must supply methodName"
        self.methods[methodName] = function.Function(method, 1)
</t>
<t tx="ekr.20040701145236.25">def addMethods(self, classObject) :
    for classToken in _getClassTokens(classObject) :
        token = getattr(classObject, classToken, None)
        if token is None:
            continue

        # Looks like a method.  Need to code it this way to
        # accommodate ExtensionClass and Python 2.2.  Yecchh.
        if (hasattr(token, "func_code") and
            hasattr(token.func_code, "co_argcount")): 
            self.addMethod(token, token.__name__)

        elif hasattr(token, '__get__') and \
             not hasattr(token, '__set__') and \
             type(token) is not types.ClassType :
            self.addMethod(getattr(token, '__name__', classToken))
        else :
            self.members[classToken] = type(token)
            self.memberRefs[classToken] = None

    self.cleanupMemberRefs()
    # add standard methods
    for methodName in ('__class__',) :
        self.addMethod(methodName, classObject.__name__)
</t>
<t tx="ekr.20040701145236.26">def addMembers(self, classObject) :
    if not cfg().onlyCheckInitForMembers :
        for classToken in _getClassTokens(classObject) :
            method = getattr(classObject, classToken, None)
            if type(method) == types.MethodType :
                self.addMembersFromMethod(method.im_func)
    else:
        try:
            self.addMembersFromMethod(classObject.__init__.im_func)
        except AttributeError:
            pass
</t>
<t tx="ekr.20040701145236.27">def addMembersFromMethod(self, method) :
    if not hasattr(method, 'func_code') :
        return

    func_code, code, i, maxCode, extended_arg = OP.initFuncCode(method)
    stack = []
    while i &lt; maxCode :
        op, oparg, i, extended_arg = OP.getInfo(code, i, extended_arg)
        if op &gt;= OP.HAVE_ARGUMENT :
            operand = OP.getOperand(op, func_code, oparg)
            if OP.LOAD_CONST(op) or OP.LOAD_FAST(op) :
                stack.append(operand)
            elif OP.STORE_ATTR(op) :
                if len(stack) &gt; 0 :
                    if stack[-1] == cfg().methodArgName:
                        value = None
                        if len(stack) &gt; 1 :
                            value = type(stack[-2])
                        self.members[operand] = value
                        self.memberRefs[operand] = None
                    stack = []

    self.cleanupMemberRefs()
</t>
<t tx="ekr.20040701145236.28">def cleanupMemberRefs(self) :
    try :
        del self.memberRefs[Config.CHECKER_VAR]
    except KeyError :
        pass
</t>
<t tx="ekr.20040701145236.29">def abstractMethod(self, m):
    """Return 1 if method is abstract, None if not
       An abstract method always raises an exception.
    """
    if not self.methods.get(m, None):
        return None
    func_code, bytes, i, maxCode, extended_arg = \
               OP.initFuncCode(self.methods[m].function)
    # abstract if the first conditional is RAISE_VARARGS
    while i &lt; maxCode:
        op, oparg, i, extended_arg = OP.getInfo(bytes, i, extended_arg)
        if OP.RAISE_VARARGS(op):
            return 1
        if OP.conditional(op):
            break
    return None
</t>
<t tx="ekr.20040701145236.30">def isAbstract(self):
    """Return the method names that make a class abstract.
       An abstract class has at least one abstract method."""
    result = []
    for m in self.methods.keys():
        if self.abstractMethod(m):
            result.append(m)
    return result
</t>
<t tx="ekr.20040701145236.31">def _getLineInFile(moduleName, linenum):
    line = ''
    file, filename, smt = _findModule(moduleName)
    try:
        lines = file.readlines()
        line = string.rstrip(lines[linenum - 1])
    except (IOError, IndexError):
        pass
    file.close()
    return line
</t>
<t tx="ekr.20040701145236.32">def importError(moduleName):
    exc_type, exc_value, tb = sys.exc_info()

    # First, try to get a nice-looking name for this exception type.
    exc_name = getattr(exc_type, '__name__', None)
    if not exc_name:
        # either it's a string exception or a user-defined exception class
        # show string or fully-qualified class name
        exc_name = str(exc_type)
        
    # Print a traceback, unless this is an ImportError.  ImportError is
    # presumably the most common import-time exception, so this saves
    # the clutter of a traceback most of the time.  Also, the locus of
    # the error is usually irrelevant for ImportError, so the lack of
    # traceback shouldn't be a problem.
    if exc_type is SyntaxError:
        # SyntaxErrors are special, we want to control how we format
        # the output and make it consistent for all versions of Python
        e = exc_value
        msg = '%s (%s, line %d)' % (e.msg, e.filename, e.lineno)
        line = _getLineInFile(moduleName, e.lineno)
        offset = e.offset
        if type(offset) is not types.IntType:
            offset = 0
        exc_value = '%s\n    %s\n   %s^' % (msg, line, ' ' * offset)
    elif exc_type is not ImportError:
        sys.stderr.write("  Caught exception importing module %s:\n" %
                         moduleName)

        try:
            tbinfo = traceback.extract_tb(tb)
        except:
            tbinfo = []
            sys.stderr.write("      Unable to format traceback\n")
        for filename, line, func, text in tbinfo[1:]:
            sys.stderr.write("    File \"%s\", line %d" % (filename, line))
            if func != "?":
                sys.stderr.write(", in %s()" % func)
            sys.stderr.write("\n")
            if text:
                sys.stderr.write("      %s\n" % text)

    # And finally print the exception type and value.
    # Careful formatting exc_value -- can fail for some user exceptions
    sys.stderr.write("  %s: " % exc_name)
    try:
        sys.stderr.write(str(exc_value) + '\n')
    except:
        sys.stderr.write('**error formatting exception value**\n')
</t>
<t tx="ekr.20040701145236.33">def _getPyFile(filename):
    """Return the file and '.py' filename from a filename which could
    end with .py, .pyc, or .pyo"""

    if filename[-1] in 'oc' and filename[-4:-1] == '.py':
        return filename[:-1]
    return filename
</t>
<t tx="ekr.20040701145236.34">
class Module :
	&lt;&lt; class Module declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.35">"Class to hold all information for a module"

</t>
<t tx="ekr.20040701145236.36">def __init__(self, moduleName, check = 1) :

    if 0: # moduleName.startswith("leo"):
        trace("Module",moduleName)
    self.moduleName = moduleName
    self.variables = {}
    self.functions = {}
    self.classes = {}
    self.modules = {}
    self.moduleLineNums = {}
    self.attributes = [ '__dict__' ]
    self.main_code = None
    self.module = None
    self.check = check
    _allModules[moduleName] = self
</t>
<t tx="ekr.20040701145236.37">def __str__(self) :
    return self.moduleName
</t>
<t tx="ekr.20040701145236.38">__repr__ = utils.std_repr

def addVariable(self, var, varType) :
    # trace(var)
    self.variables[var] = Variable(var, varType)
</t>
<t tx="ekr.20040701145236.39">def addFunction(self, func) :
    # trace(func)
    self.functions[func.__name__] = function.Function(func)
</t>
<t tx="ekr.20040701145236.40">def __addAttributes(self, c, classObject) :
    for base in classObject.__bases__ :
        self.__addAttributes(c, base)
    c.addMethods(classObject)
    c.addMembers(classObject)
</t>
<t tx="ekr.20040701145236.41">def addClass(self, name) :
    self.classes[name] = c = Class(name, self.module)
    try:
        objName = str(c.classObject)
    except TypeError:
        # this can happen if there is a goofy __getattr__
        c.ignoreAttrs = 1
    else:
        packages = string.split(objName, '.')
        c.ignoreAttrs = packages[0] in cfg().blacklist
    if not c.ignoreAttrs :
        self.__addAttributes(c, c.classObject)
</t>
<t tx="ekr.20040701145236.42">def addModule(self, name) :
    module = _allModules.get(name, None)
    if module is None :
        self.modules[name] = module = Module(name, 0)
        if imp.is_builtin(name) == 0 :
            module.load()
        else :
            globalModule = globals().get(name)
            if globalModule :
                module.attributes.extend(dir(globalModule))
    else :
        self.modules[name] = module
</t>
<t tx="ekr.20040701145236.43">def filename(self) :
    try :
        filename = self.module.__file__
    except AttributeError :
        filename = self.moduleName
    return _getPyFile(filename)
</t>
<t tx="ekr.20040701145236.44">def load(self):
    try :
        # there's no need to reload modules we already have
        module = sys.modules.get(self.moduleName)
        if module :
            if not _allModules[self.moduleName].module :
                return self._initModule(module)
            return 1

        return self._initModule(self.setupMainCode())
    except (SystemExit, KeyboardInterrupt) :
        exc_type, exc_value, exc_tb = sys.exc_info()
        raise exc_type, exc_value
    except :
        importError(self.moduleName)
        return 0
</t>
<t tx="ekr.20040701145236.45">def initModule(self, module) :
    if not self.module:
        filename = _getPyFile(module.__file__)
        if string.lower(filename[-3:]) == '.py':
            try:
                file = open(filename)
            except IOError:
                pass
            else:
                self._setupMainCode(file, filename, module)
        return self._initModule(module)
    return 1
</t>
<t tx="ekr.20040701145236.46">def _initModule(self, module):
    self.module = module
    self.attributes = dir(self.module)

    pychecker_attr = getattr(module, Config.CHECKER_VAR, None)
    if pychecker_attr is not None :
        utils.pushConfig()
        utils.updateCheckerArgs(pychecker_attr, 'suppressions', 0, [])

    for tokenName in _filterDir(self.module, _DEFAULT_MODULE_TOKENS) :
        token = getattr(self.module, tokenName)
        if isinstance(token, types.ModuleType) :
            # get the real module name, tokenName could be an alias
            self.addModule(token.__name__)
        elif isinstance(token, types.FunctionType) :
            self.addFunction(token)
        elif isinstance(token, types.ClassType) or \
             hasattr(token, '__bases__') :
            self.addClass(tokenName)
        else :
            self.addVariable(tokenName, type(token))

    if pychecker_attr is not None :
        utils.popConfig()
    return 1
</t>
<t tx="ekr.20040701145236.47">def setupMainCode(self) :
    file, filename, smt = _findModule(self.moduleName)
    # FIXME: if the smt[-1] == imp.PKG_DIRECTORY : load __all__
    module = imp.load_module(self.moduleName, file, filename, smt)
    self._setupMainCode(file, filename, module)
    return module
</t>
<t tx="ekr.20040701145236.48">def _setupMainCode(self, file, filename, module):
    try :
        self.main_code = function.create_from_file(file, filename, module)
    finally :
        if file != None :
            file.close()
</t>
<t tx="ekr.20040701145236.49">def getAllModules() :
    "Returns a list of all modules that should be checked."
    modules = []
    for module in _allModules.values() :
        if module.check :
            modules.append(module)
    return modules
</t>
<t tx="ekr.20040701145236.50">_BUILTIN_MODULE_ATTRS = { 'sys': [ 'ps1', 'ps2', 'tracebacklimit', 
                                   'exc_type', 'exc_value', 'exc_traceback',
                                   'last_type', 'last_value', 'last_traceback',
                                 ],
                        }

def fixupBuiltinModules(needs_init=0):
    for moduleName in sys.builtin_module_names :
        if needs_init:
            _ = Module(moduleName, 0)
        module = _allModules.get(moduleName, None)
        if module is not None:
            if moduleName not in ( ## EKR
                ("regex","rotor","xreadlines")
            ):
                try :
                    m = imp.init_builtin(moduleName)
                except ImportError :
                    pass
                else :
                    extra_attrs = _BUILTIN_MODULE_ATTRS.get(moduleName, [])
                    module.attributes = [ '__dict__' ] + dir(m) + extra_attrs
</t>
<t tx="ekr.20040701145236.51">def _printWarnings(warnings, stream=None):
    if stream is None:
        stream = sys.stdout
    
    warnings.sort()
    lastWarning = None
    for warning in warnings :
        if lastWarning != None :
            # ignore duplicate warnings
            if cmp(lastWarning, warning) == 0 :
                continue
            # print blank line between files
            if lastWarning.file != warning.file :
                stream.write("\n")

        lastWarning = warning
        warning.output(stream)
</t>
<t tx="ekr.20040701145236.52">def processFiles(files, cfg = None, pre_process_cb = None) :
    # insert this here, so we find files in the local dir before std library
    if sys.path[0] != '' :
        sys.path.insert(0, '')

    # ensure we have a config object, it's necessary
    global _cfg
    if cfg is not None :
        _cfg = cfg
    elif _cfg is None :
        _cfg = Config.Config()

    warnings = []
    utils.initConfig(_cfg)
    for moduleName in getModules(files) :
        if callable(pre_process_cb) :
            pre_process_cb(moduleName)
        module = Module(moduleName)
        if not module.load() :
            w = Warning(module.filename(), 1, "NOT PROCESSED UNABLE TO IMPORT")
            warnings.append(w)
    utils.popConfig()
    return warnings
</t>
<t tx="ekr.20040701145236.53">def getWarnings(files, cfg = None, suppressions = None):
    warnings = processFiles(files, cfg)
    fixupBuiltinModules()
    return warnings + warn.find(getAllModules(), _cfg, suppressions)
</t>
<t tx="ekr.20040701145236.54">def _print_processing(name) :
    if not _cfg.quiet :
        sys.stderr.write("Processing %s...\n" % name)
</t>
<t tx="ekr.20040701145236.55">def main(argv) :
    __pychecker__ = 'no-miximport'
    import pychecker
    if LOCAL_MAIN_VERSION != pychecker.MAIN_MODULE_VERSION :
        sys.stderr.write(_VERSION_MISMATCH_ERROR)
        sys.exit(100)

    # remove empty arguments
    argv = filter(None, argv)
        
    # if the first arg starts with an @, read options from the file
    # after the @ (this is mostly for windows)
    if len(argv) &gt;= 2 and argv[1][0] == '@':
        # read data from the file
        command_file = argv[1][1:]
        try:
            f = open(command_file, 'r')
            command_line = f.read()
            f.close()
        except IOError, err:
            sys.stderr.write("Unable to read commands from file: %s\n  %s\n" % \
                             (command_file, err))
            sys.exit(101)

        # convert to an argv list, keeping argv[0] and the files to process
        argv = argv[:1] + string.split(command_line) + argv[2:]
 
    global _cfg
    _cfg, files, suppressions = Config.setupFromArgs(argv[1:])
    if not files :
        return 0

    # insert this here, so we find files in the local dir before std library
    sys.path.insert(0, '')

    importWarnings = processFiles(files, _cfg, _print_processing)
    fixupBuiltinModules()
    if _cfg.printParse :
        for module in getAllModules() :
            printer.module(module)

    warnings = warn.find(getAllModules(), _cfg, suppressions)
    if not _cfg.quiet :
        print "\nWarnings...\n"
    if warnings or importWarnings :
        _printWarnings(importWarnings + warnings)
        return 1

    if not _cfg.quiet :
        print "None"
    return 0
</t>
<t tx="ekr.20040701145236.56">if __name__ == '__main__' :
    try :
        sys.exit(main(sys.argv))
    except Config.UsageError :
        sys.exit(127)

else :
    _orig__import__ = None
    _suppressions = None
    _warnings_cache = {}

    def _get_unique_warnings(warnings):
        for i in range(len(warnings)-1, -1, -1):
            w = warnings[i].format()
            if _warnings_cache.has_key(w):
                del warnings[i]
            else:
                _warnings_cache[w] = 1
        return warnings

    def __import__(name, globals=None, locals=None, fromlist=None):
        if globals is None:
            globals = {}
        if locals is None:
            locals = {}
        if fromlist is None:
            fromlist = []

        check = not sys.modules.has_key(name) and name[:10] != 'pychecker.'
        pymodule = _orig__import__(name, globals, locals, fromlist)
        if check :
            try :
                module = Module(pymodule.__name__)
                if module.initModule(pymodule):
                    warnings = warn.find([module], _cfg, _suppressions)
                    _printWarnings(_get_unique_warnings(warnings))
                else :
                    print 'Unable to load module', pymodule.__name__
            except Exception:
                name = getattr(pymodule, '__name__', str(pymodule))
                importError(name)

        return pymodule

    def _init() :
        global _cfg, _suppressions, _orig__import__

        args = string.split(os.environ.get('PYCHECKER', ''))
        _cfg, files, _suppressions = Config.setupFromArgs(args)
        utils.initConfig(_cfg)
        fixupBuiltinModules(1)

        # keep the orig __import__ around so we can call it
        import __builtin__
        _orig__import__ = __builtin__.__import__
        __builtin__.__import__ = __import__

    if not os.environ.get('PYCHECKER_DISABLED') :
        _init()
</t>
<t tx="ekr.20040701145236.57">@ignore
@language python
&lt;&lt; CodeChecks declarations &gt;&gt;
@others

DISPATCH = [ None ] * 256
DISPATCH[  1] = _POP_TOP
DISPATCH[  2] = _ROT_TWO
DISPATCH[  4] = _DUP_TOP
DISPATCH[ 10] = _UNARY_POSITIVE
DISPATCH[ 11] = _UNARY_NEGATIVE
DISPATCH[ 12] = _UNARY_NOT
DISPATCH[ 13] = _UNARY_CONVERT
DISPATCH[ 15] = _UNARY_INVERT
DISPATCH[ 18] = _LIST_APPEND
DISPATCH[ 19] = _BINARY_POWER
DISPATCH[ 20] = _BINARY_MULTIPLY
DISPATCH[ 21] = _BINARY_DIVIDE
DISPATCH[ 22] = _BINARY_MODULO
DISPATCH[ 23] = _BINARY_ADD
DISPATCH[ 24] = _BINARY_SUBTRACT
DISPATCH[ 25] = _BINARY_SUBSCR
DISPATCH[ 26] = _BINARY_FLOOR_DIVIDE
DISPATCH[ 27] = _BINARY_TRUE_DIVIDE
# FIXME: add INPLACE FLOOR/TRUE DIVIDE: 28/29
DISPATCH[ 31] = _SLICE1
DISPATCH[ 32] = _SLICE2
DISPATCH[ 33] = _SLICE3
DISPATCH[ 55] = _BINARY_ADD             # INPLACE
DISPATCH[ 56] = _BINARY_SUBTRACT        # INPLACE
DISPATCH[ 57] = _BINARY_MULTIPLY        # INPLACE
DISPATCH[ 58] = _BINARY_DIVIDE          # INPLACE
DISPATCH[ 59] = _BINARY_MODULO          # INPLACE
DISPATCH[ 60] = _STORE_SUBSCR
DISPATCH[ 61] = _DELETE_SUBSCR
DISPATCH[ 62] = _BINARY_LSHIFT
DISPATCH[ 63] = _BINARY_RSHIFT
DISPATCH[ 64] = _BINARY_AND
DISPATCH[ 65] = _BINARY_XOR
DISPATCH[ 66] = _BINARY_OR
DISPATCH[ 67] = _BINARY_POWER           # INPLACE
DISPATCH[ 68] = _GET_ITER
DISPATCH[ 71] = _PRINT_ITEM
DISPATCH[ 73] = _PRINT_ITEM_TO
DISPATCH[ 75] = _BINARY_LSHIFT          # INPLACE
DISPATCH[ 76] = _BINARY_RSHIFT          # INPLACE
DISPATCH[ 77] = _BINARY_AND             # INPLACE
DISPATCH[ 78] = _BINARY_XOR             # INPLACE
DISPATCH[ 79] = _BINARY_OR              # INPLACE
DISPATCH[ 83] = _RETURN_VALUE
DISPATCH[ 84] = _IMPORT_STAR
DISPATCH[ 85] = _EXEC_STMT
DISPATCH[ 88] = _END_FINALLY
DISPATCH[ 89] = _BUILD_CLASS
DISPATCH[ 90] = _STORE_NAME
DISPATCH[ 91] = _DELETE_NAME
DISPATCH[ 92] = _UNPACK_SEQUENCE
DISPATCH[ 93] = _FOR_ITER
DISPATCH[ 95] = _STORE_ATTR
DISPATCH[ 96] = _DELETE_ATTR
DISPATCH[ 97] = _STORE_GLOBAL
DISPATCH[ 98] = _DELETE_GLOBAL
DISPATCH[100] = _LOAD_CONST
DISPATCH[101] = _LOAD_NAME
DISPATCH[102] = _BUILD_TUPLE
DISPATCH[103] = _BUILD_LIST
DISPATCH[104] = _BUILD_MAP
DISPATCH[105] = _LOAD_ATTR
DISPATCH[106] = _COMPARE_OP
DISPATCH[107] = _IMPORT_NAME
DISPATCH[108] = _IMPORT_FROM
DISPATCH[110] = _JUMP_FORWARD
DISPATCH[111] = _JUMP_IF_FALSE
DISPATCH[112] = _JUMP_IF_TRUE
DISPATCH[113] = _JUMP_ABSOLUTE
DISPATCH[114] = _FOR_LOOP
DISPATCH[116] = _LOAD_GLOBAL
DISPATCH[121] = _SETUP_EXCEPT
DISPATCH[122] = _SETUP_FINALLY
DISPATCH[124] = _LOAD_FAST
DISPATCH[125] = _STORE_FAST
DISPATCH[126] = _DELETE_FAST
DISPATCH[127] = _LINE_NUM
DISPATCH[130] = _RAISE_VARARGS
DISPATCH[131] = _CALL_FUNCTION
DISPATCH[132] = _MAKE_FUNCTION
DISPATCH[134] = _MAKE_CLOSURE
DISPATCH[135] = _LOAD_CLOSURE
DISPATCH[136] = _LOAD_DEREF
DISPATCH[140] = _CALL_FUNCTION_VAR
DISPATCH[141] = _CALL_FUNCTION_KW
DISPATCH[142] = _CALL_FUNCTION_VAR_KW
</t>
<t tx="ekr.20040701145236.58">#!/usr/bin/env python

# Copyright (c) 2001-2004, MetaSlash Inc.  All rights reserved.

"""
Find warnings in byte code from Python source files.
"""

import string
import types

from pychecker import msgs
from pychecker import utils
from pychecker import Warning
from pychecker import OP
from pychecker import Stack
from pychecker import python

from leoGlobals import trace

__pychecker__ = 'no-argsused'


</t>
<t tx="ekr.20040701145236.59">def cfg() :
    return utils.cfg()
</t>
<t tx="ekr.20040701145236.60">def getFunctionArgErr(func_name, argCount, minArgs, maxArgs):
    err = None
    if maxArgs == None:
        if argCount &lt; minArgs :
            err = msgs.INVALID_ARG_COUNT2 % (func_name, argCount, minArgs)
    elif argCount &lt; minArgs or argCount &gt; maxArgs:
        if minArgs == maxArgs:
            err = msgs.INVALID_ARG_COUNT1 % (func_name, argCount, minArgs)
        else:
            err = msgs.INVALID_ARG_COUNT3 % (func_name, argCount, minArgs, maxArgs)
    return err
</t>
<t tx="ekr.20040701145236.61">def _checkFunctionArgCount(code, func_name, argCount, minArgs, maxArgs,
                           objectReference = 0) :
    # there is an implied argument for object creation and self.xxx()
    if objectReference :
        minArgs = minArgs - 1
        if maxArgs is not None :
            maxArgs = maxArgs - 1

    err = getFunctionArgErr(func_name, argCount, minArgs, maxArgs)
    if err :
        code.addWarning(err)
</t>
<t tx="ekr.20040701145236.62">def _checkFunctionArgs(code, func, objectReference, argCount, kwArgs,
                       check_arg_count = 1) :
    func_name = func.function.func_code.co_name
    if kwArgs :
        args_len = func.function.func_code.co_argcount
        arg_names = func.function.func_code.co_varnames[argCount:args_len]
        if argCount &lt; args_len and kwArgs[0] in arg_names:
            if cfg().namedArgs :
                code.addWarning(msgs.FUNC_USES_NAMED_ARGS % func_name)

            # convert the named args into regular params, and really check
            while argCount &lt; args_len and kwArgs and kwArgs[0] in arg_names:
                argCount = argCount + 1
                kwArgs = kwArgs[1:]
            _checkFunctionArgs(code, func, objectReference, argCount, kwArgs,
                               check_arg_count)
            return

        if not func.supportsKW :
            code.addWarning(msgs.FUNC_DOESNT_SUPPORT_KW % func_name)

    if check_arg_count :
        _checkFunctionArgCount(code, func_name, argCount,
                               func.minArgs, func.maxArgs, objectReference)
</t>
<t tx="ekr.20040701145236.63">def _getReferenceFromModule(module, identifier) :
    func = module.functions.get(identifier, None)
    if func is not None :
        return func, None, 0

    create = 0
    c = module.classes.get(identifier, None)
    if c is not None :
        func = c.methods.get(utils.INIT, None)
        create = 1
    return func, c, create
</t>
<t tx="ekr.20040701145236.64">def _getFunction(module, stackValue) :
    'Return (function, class) from the stack value'

    identifier = stackValue.data
    if type(identifier) == types.StringType :
        return _getReferenceFromModule(module, identifier)

    # find the module this references
    i, maxLen = 0, len(identifier)
    while i &lt; maxLen :
        id = str(identifier[i])
        if module.classes.has_key(id) or module.functions.has_key(id) :
            break
        refModule = module.modules.get(id, None)
        if refModule is not None :
            module = refModule
        else :
            return None, None, 0
        i = i + 1

    # if we got to the end, there is only modules, nothing we can do
    # we also can't handle if there is more than 2 items left
    if i &gt;= maxLen or (i+2) &lt; maxLen :
        return None, None, 0

    if (i+1) == maxLen :
        return _getReferenceFromModule(module, identifier[-1])

    # we can't handle self.x.y
    if (i+2) == maxLen and identifier[0] == cfg().methodArgName:
        return None, None, 0

    c = module.classes.get(identifier[-2], None)
    if c is None :
        return None, None, 0
    return c.methods.get(identifier[-1], None), c, 0
</t>
<t tx="ekr.20040701145236.65">def _checkBuiltin(code, loadValue, argCount, kwArgs, check_arg_count = 1) :
    returnValue = Stack.makeFuncReturnValue(loadValue, argCount)
    func_name = loadValue.data
    if loadValue.type == Stack.TYPE_GLOBAL :
        info = python.GLOBAL_FUNC_INFO.get(func_name, None)
        if info is not None :
            if func_name == 'input' and cfg().usesInput:
                code.addWarning(msgs.USES_INPUT)
            if cfg().constAttr and \
               ((func_name == 'setattr' and argCount &gt;= 2) or 
                (func_name == 'getattr' and argCount == 2)):
                arg2 = code.stack[-argCount + 1]
                if arg2.const:
                    code.addWarning(msgs.USES_CONST_ATTR % func_name)

            if kwArgs:
                if len(info) &lt; 4:
                    code.addWarning(msgs.FUNC_DOESNT_SUPPORT_KW % func_name)
                elif info[3]:
                    for arg in kwArgs:
                        if arg not in info[3]:
                            code.addWarning(msgs.FUNC_DOESNT_SUPPORT_KW_ARG % (func_name, arg))
            elif check_arg_count :
                _checkFunctionArgCount(code, func_name, argCount,
                                       info[1], info[2])
            returnValue = Stack.Item(returnValue.data, info[0])
            returnValue.setStringType(info[0])
    elif type(func_name) == types.TupleType and len(func_name) &lt;= 2 :
        objType = code.typeMap.get(str(func_name[0]), [])
        if types.ListType in objType :
            try :
                if func_name[1] == 'append' and argCount &gt; 1 :
                    code.addWarning(msgs.LIST_APPEND_ARGS % func_name[0])
                    check_arg_count = 0
            except AttributeError :
                # FIXME: why do we need to catch AttributeError???
                pass
        if len(objType) == 1 :
            # if it's a builtin, check method
            builtinType = python.BUILTIN_METHODS.get(objType[0])
            if builtinType is not None :
                methodInfo = builtinType.get(func_name[1])
                # set func properly
                if kwArgs :
                    code.addWarning(msgs.FUNC_DOESNT_SUPPORT_KW % func_name[1])
                elif methodInfo :
                    returnValue = Stack.Item(func_name[1], methodInfo[0])
                    returnValue.setStringType(methodInfo[0])
                    if check_arg_count and methodInfo is not None :
                        _checkFunctionArgCount(code, func_name[1], argCount,
                                               methodInfo[1], methodInfo[2])

    return returnValue
</t>
<t tx="ekr.20040701145236.66">_IMMUTABLE_LIST_METHODS = ('count', 'index',)
_IMMUTABLE_DICT_METHODS = ('copy', 'get', 'has_key',
                           'items', 'keys', 'values',
                           'iteritems', 'iterkeys', 'itervalues')

def _checkModifyDefaultArg(code, objectName, methodName=None) :
    try :
        value = code.func.defaultValue(objectName)
        objectType = type(value)
        if objectType in python.MUTABLE_TYPES :
            if objectType == types.DictType and \
               methodName in _IMMUTABLE_DICT_METHODS :
                return 
            if objectType == types.ListType and \
               methodName in _IMMUTABLE_LIST_METHODS :
                return
            code.addWarning(msgs.MODIFYING_DEFAULT_ARG % objectName)
    except ValueError :
        pass
</t>
<t tx="ekr.20040701145236.67">def _isexception(object) :
    # FIXME: i have no idea why this function is necessary
    # it seems that the issubclass() should work, but it doesn't always
    try:
        # try/except is necessary for globals like NotImplemented
        if issubclass(object, Exception) :
            return 1
    except TypeError:
        return 0

    for c in object.__bases__ :
        if utils.startswith(str(c), 'exceptions.') :
            return 1
        if len(c.__bases__) &gt; 0 and _isexception(c) :
            return 1
    return 0
</t>
<t tx="ekr.20040701145236.68">def _checkStringFind(code, loadValue):
    if len(loadValue.data) == 2 and loadValue.data[1] == 'find':
        try:
            if types.StringType in code.typeMap.get(loadValue.data[0], []):
                op = code.nextOpInfo()[0]
                if OP.IS_CONDITIONAL_JUMP(op) or OP.IS_NOT(op):
                    code.addWarning(msgs.BAD_STRING_FIND)
        except TypeError:
            # we don't care if loadValue.data[0] is not hashable
            pass
</t>
<t tx="ekr.20040701145236.69">def _checkAbstract(refClass, code, name):
    name_list = refClass.isAbstract()
    if name_list:
        name_list.sort()
        names = string.join(name_list, ", ")
        code.addWarning(msgs.METHODS_NEED_OVERRIDE % (names, name))
</t>
<t tx="ekr.20040701145236.70">_SEQUENCE_TYPES = (types.TupleType, types.ListType, types.StringType)
try: _SEQUENCE_TYPES = _SEQUENCE_TYPES + (types.UnicodeType,)
except AttributeError: pass

# FIXME: this is not complete. errors will be caught only sometimes,
#        depending on the order the functions/methods are processed
#        in the dict.  Need to be able to run through all functions
#        twice, but because the code sucks, this is not possible.
def _checkReturnValueUse(code, func):
    if func.returnValues is None:
        return

    err = None
    opInfo = code.nextOpInfo()
    if func.returnsNoValue():
        # make sure we really know how to check for all the return types
        for rv in func.returnValues:
            if rv[1].type in _UNCHECKABLE_STACK_TYPES:
                return

        if not OP.POP_TOP(opInfo[0]):
            err = msgs.USING_NONE_RETURN_VALUE % str(func)
    elif OP.UNPACK_SEQUENCE(opInfo[0]):
        # verify unpacking into proper # of vars
        varCount = opInfo[1]
        stackRV = func.returnValues[0][1]
        returnType = stackRV.getType({})
        funcCount = stackRV.length
        if returnType in _SEQUENCE_TYPES:
            if varCount != funcCount and funcCount &gt; 0:
                err = msgs.WRONG_UNPACK_FUNCTION % (str(func), funcCount, varCount)
        elif returnType not in _UNCHECKABLE_STACK_TYPES:
            err = msgs.UNPACK_NON_SEQUENCE % (str(func), _getTypeStr(returnType))
    if err:
        code.addWarning(err)
</t>
<t tx="ekr.20040701145236.71">def _handleFunctionCall(codeSource, code, argCount, indexOffset = 0,
                        check_arg_count = 1) :
    'Checks for warnings, returns function called (may be None)'

    if not code.stack :
        return

    kwArgCount = argCount &gt;&gt; utils.VAR_ARGS_BITS
    argCount = argCount &amp; utils.MAX_ARGS_MASK

    # function call on stack is before the args, and keyword args
    funcIndex = argCount + 2 * kwArgCount + 1 + indexOffset
    if funcIndex &gt; len(code.stack) :
        funcIndex = 0
    # to find on stack, we have to look backwards from top of stack (end)
    funcIndex = -funcIndex

    # store the keyword names/keys to check if using named arguments
    kwArgs = []
    if kwArgCount &gt; 0 :
        # loop backwards by 2 (keyword, value) in stack to find keyword args
        for i in range(-2 - indexOffset, (-2 * kwArgCount - 1), -2) :
            kwArgs.append(code.stack[i].data)
        kwArgs.reverse()

    loadValue = code.stack[funcIndex]
    funcName = loadValue.getName()
    returnValue = Stack.makeFuncReturnValue(loadValue, argCount)

    if loadValue.isMethodCall(codeSource.classObject, cfg().methodArgName):
        methodName = loadValue.data[1]
        try :
            m = codeSource.classObject.methods[methodName]
            if m != None :
                objRef = not m.isStaticMethod()
                _checkFunctionArgs(code, m, objRef, argCount, kwArgs,
                                   check_arg_count)
        except KeyError :
            sattr = codeSource.classObject.statics.get(methodName)
            if sattr is not None :
                funcName = sattr.getName()

            if sattr is None and cfg().callingAttribute :
                code.addWarning(msgs.INVALID_METHOD % methodName)

    elif loadValue.type in (Stack.TYPE_ATTRIBUTE, Stack.TYPE_GLOBAL) and \
         type(loadValue.data) in (types.StringType, types.TupleType) :
        # apply(func, (args)), can't check # of args, so just return func
        if loadValue.data == 'apply' :
            loadValue = code.stack[funcIndex+1]
            funcName = loadValue.getName()
        else :
            if cfg().modifyDefaultValue and \
               type(loadValue.data) == types.TupleType :
                _checkModifyDefaultArg(code, loadValue.data[0],
                                       loadValue.data[1])

            func, refClass, method = _getFunction(codeSource.module, loadValue)
            if func == None and type(loadValue.data) == types.TupleType and \
               len(loadValue.data) == 2 :
                # looks like we are making a method call
                data = loadValue.data
                if type(data[0]) == types.StringType :
                    # do we know the type of the local variable?
                    varType = code.typeMap.get(data[0])
                    if varType is not None and len(varType) == 1 :
                        if hasattr(varType[0], 'methods') :
                            # it's a class &amp; we know the type, get the method
                            func = varType[0].methods.get(data[1])
                            if func is not None :
                                method = 1

            if cfg().abstractClasses and refClass and method:
                _checkAbstract(refClass, code, funcName)

            if cfg().stringFind:
                _checkStringFind(code, loadValue)

            if func != None :
                if refClass and func.isClassMethod():
                    argCount = argCount + 1
                _checkFunctionArgs(code, func, method, argCount, kwArgs,
                                   check_arg_count)
                # if this isn't a c'tor, we should check
                if not (refClass and method) and cfg().checkReturnValues:
                    _checkReturnValueUse(code, func)

                if refClass :
                    if method :
                        # c'tor, return the class as the type
                        returnValue = Stack.Item(loadValue, refClass)
                    elif func.isClassMethod():
                        # FIXME: do anything here?
                        pass
                    elif argCount &gt; 0 and cfg().methodArgName and \
                         not func.isStaticMethod() and \
                         code.stack[funcIndex].type == Stack.TYPE_ATTRIBUTE and \
                         code.stack[funcIndex+1].data != cfg().methodArgName:
                        e = msgs.SELF_NOT_FIRST_ARG % (cfg().methodArgName, '')
                        code.addWarning(e)
            elif refClass and method :
                returnValue = Stack.Item(loadValue, refClass)
                if (argCount &gt; 0 or len(kwArgs) &gt; 0) and \
                   not refClass.ignoreAttrs and \
                   not refClass.methods.has_key(utils.INIT) and \
                   not _isexception(refClass.classObject) :
                    code.addWarning(msgs.NO_CTOR_ARGS)
            else :
                returnValue = _checkBuiltin(code, loadValue, argCount, kwArgs,
                                            check_arg_count)
                if returnValue.type is types.NoneType and \
                   not OP.POP_TOP(code.nextOpInfo()[0]) :
                    name = str(loadValue.data)
                    if type(loadValue.data) == types.TupleType :
                        name = string.join(loadValue.data, '.')
                    code.addWarning(msgs.USING_NONE_RETURN_VALUE % name)

    code.stack = code.stack[:funcIndex] + [ returnValue ]
    code.functionsCalled[funcName] = loadValue
</t>
<t tx="ekr.20040701145236.72">def _classHasAttribute(c, attr) :
    return (c.methods.has_key(attr) or c.members.has_key(attr) or
            hasattr(c.classObject, attr))
</t>
<t tx="ekr.20040701145236.73">def _checkClassAttribute(attr, c, code) :
    if _classHasAttribute(c, attr) :
        try :
            del c.memberRefs[attr]
        except KeyError :
            pass
    elif cfg().classAttrExists :
        code.addWarning(msgs.INVALID_CLASS_ATTR % attr)
</t>
<t tx="ekr.20040701145236.74">def _checkModuleAttribute(attr, module, code, ref) :
    try:
        if attr not in module.modules[ref].attributes and \
           not utils.endswith(ref, '.' + attr) :
            code.addWarning(msgs.INVALID_MODULE_ATTR % attr)
    except (KeyError, TypeError):
        # if ref isn't found, or ref isn't even hashable, we don't care
        # we may not know, or ref could be something funky [e for e].method()
        pass

    try:
        _checkClassAttribute(attr, module.classes[ref], code)
    except (KeyError, TypeError):
        # if ref isn't found, or ref isn't even hashable, we don't care
        # we may not know, or ref could be something funky [e for e].method()
        pass
</t>
<t tx="ekr.20040701145236.75">def _getGlobalName(name, func) :
    # get the right name of global refs (for from XXX import YYY)
    opModule = func.function.func_globals.get(name)
    try :
        if opModule and isinstance(opModule, types.ModuleType) :
            name = opModule.__name__
    except :
        # we have to do this in case the class raises an access exception
        # due to overriding __special__() methods
        pass

    return name
</t>
<t tx="ekr.20040701145236.76">def _checkNoEffect(code, ignoreStmtWithNoEffect=0):
    if (not ignoreStmtWithNoEffect and
        OP.POP_TOP(code.nextOpInfo()[0]) and cfg().noEffect):
        code.addWarning(msgs.POSSIBLE_STMT_WITH_NO_EFFECT)
</t>
<t tx="ekr.20040701145236.77">def _makeConstant(code, index, factoryFunction) :
    "Build a constant on the stack ((), [], or {})"
    if index &gt; 0 :
        code.stack[-index:] = [ factoryFunction(code.stack[-index:]) ]
        _checkNoEffect(code)
    else :
        code.pushStack(factoryFunction())
</t>
<t tx="ekr.20040701145236.78">def _hasGlobal(operand, module, func, main) :
    return (func.function.func_globals.has_key(operand) or
             main or module.moduleLineNums.has_key(operand) or
             __builtins__.has_key(operand))
</t>
<t tx="ekr.20040701145236.79">def _checkGlobal(operand, module, func, code, err, main = 0) :
    if not _hasGlobal(operand, module, func, main) :
        code.addWarning(err % operand)
        if not cfg().reportAllGlobals :
            func.function.func_globals[operand] = operand
</t>
<t tx="ekr.20040701145236.80">def _handleComparison(stack, operand) :
    si = min(len(stack), 2)
    compareValues = stack[-si:]
    for _ in range(si, 2) :
        compareValues.append(None)
    stack[-si:] = [ Stack.makeComparison(compareValues, operand) ]
    return compareValues
</t>
<t tx="ekr.20040701145236.81">def _handleImport(code, operand, module, main, fromName) :
    # FIXME: this function should be refactored/cleaned up
    key = operand
    tmpOperand = tmpFromName = operand
    if fromName is not None :
        tmpOperand = tmpFromName = fromName
        key = (fromName, operand)

    if cfg().deprecated:
        try:
            undeprecated = python.DEPRECATED_MODULES[tmpFromName]
        except KeyError:
            pass
        else:
            msg = msgs.USING_DEPRECATED_MODULE % tmpFromName
            if undeprecated:
                msg = msg + msgs.USE_INSTEAD % undeprecated
            code.addWarning(msg)

    if cfg().reimportSelf and tmpOperand == module.module.__name__ :
        code.addWarning(msgs.IMPORT_SELF % tmpOperand)

    modline1 = module.moduleLineNums.get(tmpOperand, None)
    modline2 = module.moduleLineNums.get((tmpFromName, '*'), None)
    key2 = (tmpFromName,)
    if fromName is not None and operand != '*' :
        key2 = (tmpFromName, operand)
    modline3 = module.moduleLineNums.get(key2, None)

    if modline1 is not None or modline2 is not None or modline3 is not None :
        err = None

        if fromName is None :
            if modline1 is not None :
                err = msgs.MODULE_IMPORTED_AGAIN % operand
            elif cfg().mixImport :
                err = msgs.MIX_IMPORT_AND_FROM_IMPORT % tmpFromName
        else :
            if modline3 is not None and operand != '*' :
                err = 'from %s import %s' % (tmpFromName, operand)
                err = msgs.MODULE_MEMBER_IMPORTED_AGAIN % err
            elif modline1 is not None :
                if cfg().mixImport and code.getLineNum() != modline1[1] :
                    err = msgs.MIX_IMPORT_AND_FROM_IMPORT % tmpFromName
            else :
                err = msgs.MODULE_MEMBER_ALSO_STAR_IMPORTED % fromName

        # filter out warnings when files are different (ie, from X import ...)
        if err is not None and cfg().moduleImportErrors :
            bytes = module.main_code
            if bytes is None or \
               bytes.function.func_code.co_filename == code.func_code.co_filename :
                code.addWarning(err)

    if main :
        fileline = (code.func_code.co_filename, code.getLineNum())
        module.moduleLineNums[key] = fileline
        if fromName is not None :
            module.moduleLineNums[(fromName,)] = fileline
</t>
<t tx="ekr.20040701145236.82">def _handleImportFrom(code, operand, module, main) :
    fromName = code.stack[-1].data
    if utils.pythonVersion() &lt; utils.PYTHON_2_0 and \
       OP.POP_TOP(code.nextOpInfo()[0]):
        code.popNextOp()
    code.pushStack(Stack.Item(operand, types.ModuleType))
    _handleImport(code, operand, module, main, fromName)
</t>
<t tx="ekr.20040701145236.83"># http://www.python.org/doc/current/lib/typesseq-strings.html
_FORMAT_CONVERTERS = 'diouxXeEfFgGcrs'
# NOTE: lLh are legal in the flags, but are ignored by python, we warn
_FORMAT_FLAGS = '*#- +.' + string.digits

def _getFormatInfo(format, code) :
    vars = []

    # first get rid of all the instances of %% in the string, they don't count
    format = string.replace(format, "%%", "")
    sections = string.split(format, '%')
    percentFormatCount = formatCount = string.count(format, '%')
    mappingFormatCount = 0

    # skip the first item in the list, it's always empty
    for section in sections[1:] :
        orig_section = section
        if not section:
            code.addWarning(msgs.INVALID_FORMAT % orig_section +
                            ' (end of format string)')
            continue

        # handle dictionary formats
        if section[0] == '(' :
            mappingFormatCount = mappingFormatCount + 1
            varname = string.split(section, ')')
            if varname[1] == '' :
                code.addWarning(msgs.INVALID_FORMAT % section)
            vars.append(varname[0][1:])
            section = varname[1]

        if not section :
            # no format data to check
            continue

        # FIXME: we ought to just define a regular expression to check
        # formatRE = '[ #+-]*([0-9]*|*)(|.(|*|[0-9]*)[diouxXeEfFgGcrs].*'
        stars = 0
        for i in range(0, len(section)) :
            if section[i] in _FORMAT_CONVERTERS :
                break
            if section[i] in _FORMAT_FLAGS :
                if section[i] == '*' :
                    stars = stars + 1
                    if mappingFormatCount &gt; 0 :
                        code.addWarning(msgs.USING_STAR_IN_FORMAT_MAPPING % section)

        if stars &gt; 2 :
            code.addWarning(msgs.TOO_MANY_STARS_IN_FORMAT)

        formatCount = formatCount + stars
        if section[i] not in _FORMAT_CONVERTERS :
            code.addWarning(msgs.INVALID_FORMAT % orig_section)

    if mappingFormatCount &gt; 0 and mappingFormatCount != percentFormatCount :
        code.addWarning(msgs.CANT_MIX_MAPPING_IN_FORMATS)

    return formatCount, vars
</t>
<t tx="ekr.20040701145236.84">try:
    unicode, UnicodeError
except NameError:
    UnicodeError = None

def _getConstant(code, module, data) :
    try:
        data = str(data.data)
    except UnicodeError:
        data = unicode(data.data)
    format = code.constants.get(data)
    if format is not None :
        return format

    format = module.variables.get(data)
    if format is not None and format.value is not None :
        return format.value
    return None
</t>
<t tx="ekr.20040701145236.85">_UNCHECKABLE_FORMAT_STACK_TYPES = \
      (Stack.TYPE_UNKNOWN, Stack.TYPE_FUNC_RETURN, Stack.TYPE_ATTRIBUTE,
       Stack.TYPE_GLOBAL, Stack.TYPE_EXCEPT)
_UNCHECKABLE_STACK_TYPES = _UNCHECKABLE_FORMAT_STACK_TYPES + (types.NoneType,)

def _getFormatString(code, codeSource) :
    if len(code.stack) &lt;= 1 :
        return ''

    format = code.stack[-2]
    if format.type != types.StringType or not format.const :
        format = _getConstant(code, codeSource.module, format)
        if format is None or type(format) != types.StringType :
            return ''
        return format
    return format.data
</t>
<t tx="ekr.20040701145236.86">def _getFormatWarnings(code, codeSource) :
    format = _getFormatString(code, codeSource)
    if not format :
        return

    args = 0
    count, vars = _getFormatInfo(format, code)
    topOfStack = code.stack[-1]
    if topOfStack.isLocals() :
        for varname in vars :
            if not code.unusedLocals.has_key(varname) :
                code.addWarning(msgs.NO_LOCAL_VAR % varname)
            else :
                code.unusedLocals[varname] = None
    else :
        stackItemType = topOfStack.getType(code.typeMap)
        if ((stackItemType == types.DictType and len(vars) &gt; 0) or
            codeSource.func.isParam(topOfStack.data) or
            stackItemType in _UNCHECKABLE_FORMAT_STACK_TYPES) :
            return

        if topOfStack.type == types.TupleType :
            args = topOfStack.length
        elif stackItemType == types.TupleType :
            args = len(code.constants.get(topOfStack.data, (0,)))
        else :
            args = 1

    if args and count != args :
        code.addWarning(msgs.INVALID_FORMAT_COUNT % (count, args))
</t>
<t tx="ekr.20040701145236.87">def _checkAttributeType(code, stackValue, attr) :
    if not cfg().checkObjectAttrs :
        return

    varTypes = code.typeMap.get(str(stackValue.data), None)
    if not varTypes :
        return

    # the value may have been converted on stack (`v`)
    other_types = []
    if stackValue.type not in varTypes :
        other_types = [stackValue.type]

    for varType in varTypes + other_types :
        # ignore built-in types that have no attributes
        if python.METHODLESS_OBJECTS.has_key(varType) :
            continue

        attrs = python.BUILTIN_ATTRS.get(varType, None)
        if attrs is not None :
            if attr in attrs :
                return
            continue

        if hasattr(varType, 'ignoreAttrs') :
            if varType.ignoreAttrs or _classHasAttribute(varType, attr) :
                return
        elif not hasattr(varType, 'attributes') or attr in varType.attributes :
            return

    code.addWarning(msgs.OBJECT_HAS_NO_ATTR % (stackValue.data, attr))
</t>
<t tx="ekr.20040701145236.88">def _getTypeStr(t):
    returnStr = str(t)
    strs = string.split(returnStr, "'")
    try:
        if len(strs) == 3:
            returnStr = strs[-2]
    except IndexError:
        pass
    return returnStr
</t>
<t tx="ekr.20040701145236.89">def _getLineNum(co, instr_index):
    co_lnotab = co.co_lnotab
    lineno = co.co_firstlineno
    addr = 0
    for lnotab_index in range(0, len(co_lnotab), 2):
        addr = addr + ord(co_lnotab[lnotab_index])
        if addr &gt; instr_index:
            return lineno
        lineno = lineno + ord(co_lnotab[lnotab_index+1])
    return lineno
</t>
<t tx="ekr.20040701145236.90">

class Code :
	&lt;&lt; class Code declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.91">'Hold all the code state information necessary to find warnings'

</t>
<t tx="ekr.20040701145236.92">def __init__(self) :
    self.bytes = None
    self.func = None
    self.func_code = None
    self.index = 0
    self.indexList = []
    self.extended_arg = 0
    self.lastLineNum = 0
    self.maxCode = 0
    self.has_except = 0
    self.try_finally_first = 0
    self.starts_and_ends_with_finally = 0

    self.returnValues = []
    self.raiseValues = []
    self.stack = []

    self.unpackCount = 0
    self.loops = 0
    self.branches = {}

    self.warnings = []

    self.globalRefs = {}
    self.unusedLocals = {}
    self.deletedLocals = {}
    self.functionsCalled = {}
    self.typeMap = {}
    self.constants = {}
    self.codeObjects = {}
</t>
<t tx="ekr.20040701145236.93">def init(self, func) :
    self.func = func
    self.func_code, self.bytes, self.index, self.maxCode, self.extended_arg = \
                    OP.initFuncCode(func.function)
    self.lastLineNum = self.func_code.co_firstlineno

    # initialize the arguments to unused
    for arg in func.arguments() :
        self.unusedLocals[arg] = 0
        self.typeMap[arg] = [ Stack.TYPE_UNKNOWN ]
</t>
<t tx="ekr.20040701145236.94">def getLineNum(self):
    line = self.lastLineNum
    # if we don't have linenum info, calc it from co_lntab &amp; index
    if line == self.func_code.co_firstlineno:
        # FIXME: this could be optimized, if we kept last line info
        line = _getLineNum(self.func_code, self.index - 1)
    return line
</t>
<t tx="ekr.20040701145236.95">def getWarning(self, err, line = None) :
    if line is None :
        line = self.getLineNum()
    return Warning.Warning(self.func_code, line, err)
</t>
<t tx="ekr.20040701145236.96">def addWarning(self, err, line = None) :
    w = err
    if not isinstance(w, Warning.Warning):
        w = self.getWarning(err, line)
    self.warnings.append(w)
</t>
<t tx="ekr.20040701145236.97">def popNextOp(self) :
    self.indexList.append(self.index)
    info = OP.getInfo(self.bytes, self.index, self.extended_arg)
    op, oparg, self.index, self.extended_arg = info
    if op &lt; OP.HAVE_ARGUMENT :
        utils.debug("  %d %s" % (self.indexList[-1], OP.name[op]))
        operand = None
    else :
        operand = OP.getOperand(op, self.func_code, oparg)
        self.label = label = OP.getLabel(op, oparg, self.index)
        utils.debug("  %d %s" % (self.indexList[-1], OP.name[op]), oparg, operand)
        if label != None :
            self.addBranch(label)

    return op, oparg, operand
</t>
<t tx="ekr.20040701145236.98">def nextOpInfo(self, offset = 0) :
    try :
        return OP.getInfo(self.bytes, self.index + offset, 0)[0:3]
    except IndexError :
        return -1, 0, -1
</t>
<t tx="ekr.20040701145236.99">def getFirstOp(self) :
    # find the first real op, maybe we should not check if params are used
    i = extended_arg = 0
    while i &lt; self.maxCode :
        op, oparg, i, extended_arg = OP.getInfo(self.bytes, i, extended_arg)
        if not OP.LINE_NUM(op) :
            if not (OP.LOAD_CONST(op) or OP.LOAD_GLOBAL(op)) :
                return op
    raise RuntimeError('Could not find first opcode in function')
</t>
<t tx="ekr.20040701145236.100">def pushStack(self, item, ignoreStmtWithNoEffect=0):
    self.stack.append(item)
    _checkNoEffect(self, ignoreStmtWithNoEffect)
</t>
<t tx="ekr.20040701145236.101">def popStack(self) :
    if self.stack :
        del self.stack[-1]
</t>
<t tx="ekr.20040701145236.102">def popStackItems(self, count) :
    stackLen = len(self.stack)
    if stackLen &gt; 0 :
        count = min(count, stackLen)
        del self.stack[-count:]
</t>
<t tx="ekr.20040701145236.103">def unpack(self) :
    if self.unpackCount :
        self.unpackCount = self.unpackCount - 1
    else :
        self.popStack()
</t>
<t tx="ekr.20040701145236.104">def __getStringStackType(self, data) :
    try :
        return data.getType({})
    except AttributeError :
        return Stack.TYPE_UNKNOWN
</t>
<t tx="ekr.20040701145236.105">def __getStackType(self) :
    if not self.stack :
        return Stack.TYPE_UNKNOWN

    if not self.unpackCount :
        return self.__getStringStackType(self.stack[-1])

    data = self.stack[-1].data
    if type(data) == types.TupleType :
        try :
            return self.__getStringStackType(data[len(data)-self.unpackCount])
        except IndexError :
            # happens when unpacking a var for which we don't know the size
            pass

    return Stack.TYPE_UNKNOWN
</t>
<t tx="ekr.20040701145236.106">def setType(self, name) :
    valueList = self.typeMap.get(name, [])
    newType = self.__getStackType()
    # longs are being merged with ints, assume they are the same
    # comparisons are really ints anyways
    if newType in (types.LongType, Stack.TYPE_COMPARISON):
        newType = types.IntType
    if newType not in valueList :
        valueList.append(newType)

        # need to ignore various types (Unknown, Func return values, etc)
        # also ignore None, don't care if they use it and a real type
        if valueList and newType not in _UNCHECKABLE_STACK_TYPES and \
           cfg().inconsistentTypes:
            oldTypes = []
            # only add types to the value list that are "interesting"
            for typeToAdd in valueList:
                if typeToAdd not in _UNCHECKABLE_STACK_TYPES and \
                   typeToAdd != newType:
                    oldTypes.append(_getTypeStr(typeToAdd))
            # do we have any "interesting" old types?  if so, warn
            if oldTypes:
                self.addWarning(msgs.INCONSISTENT_TYPE % \
                                (name, oldTypes, _getTypeStr(newType)))
    self.typeMap[name] = valueList
</t>
<t tx="ekr.20040701145236.107">def addReturn(self) :
    if len(self.stack) &gt; 0 :
        value = (self.getLineNum(), self.stack[-1], self.nextOpInfo()[2])
        self.returnValues.append(value)
        self.popStack()
</t>
<t tx="ekr.20040701145236.108">def addRaise(self) :
    self.raiseValues.append((self.getLineNum(), None, self.nextOpInfo()[2]))
</t>
<t tx="ekr.20040701145236.109">def addBranch(self, label) :
    if label is not None :
        self.branches[label] = self.branches.get(label, 0) + 1
</t>
<t tx="ekr.20040701145236.110">def removeBranch(self, label) :
    branch = self.branches.get(label, None)
    if branch is not None :
        if branch == 1 :
            del self.branches[label]
        else :
            self.branches[label] = branch - 1
</t>
<t tx="ekr.20040701145236.111">def remove_unreachable_code(self, label) :
    if len(self.indexList) &gt;= 2 :
        index = self.indexList[-2]
        if index &gt;= 0 and OP.POP_BLOCK(ord(self.bytes[index])) :
            index = self.indexList[-3]
        if index &gt;= 0 :
            op = ord(self.bytes[index])
            if OP.RETURN_VALUE(op) or OP.RAISE_VARARGS(op) or \
               OP.END_FINALLY(ord(self.bytes[label-1])) :
                self.removeBranch(label)
</t>
<t tx="ekr.20040701145236.112">def updateCheckerArgs(self, operand) :
    rc = utils.shouldUpdateArgs(operand)
    if rc :
        utils.updateCheckerArgs(self.stack[-1].data, self.func_code,
                                self.getLineNum(), self.warnings)
    return rc
</t>
<t tx="ekr.20040701145236.113">def updateModuleLineNums(self, module, operand) :
    filelist = (self.func_code.co_filename, self.getLineNum())
    module.moduleLineNums[operand] = filelist
</t>
<t tx="ekr.20040701145236.114">

class CodeSource :
	&lt;&lt; class CodeSource declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.115">'Holds source information about a code block (module, class, func, etc)'
</t>
<t tx="ekr.20040701145236.116">def __init__(self, module, func, c, main, in_class, code) :
    self.module = module
    self.func = func
    self.classObject = c
    self.main = main
    self.in_class = in_class
    self.code = code
    self.calling_code = []
</t>
<t tx="ekr.20040701145236.117">def _checkException(code, name) :
    if code.stack and code.stack[-1].type == Stack.TYPE_EXCEPT :
        if __builtins__.has_key(name) :
            code.addWarning(msgs.SET_EXCEPT_TO_BUILTIN % name)
</t>
<t tx="ekr.20040701145236.118">def _checkAssign(code, name):
    if name in _BAD_ASSIGN_NAMES:
        code.addWarning(msgs.SHOULDNT_ASSIGN_BUILTIN % name)
    else:
        cap = string.capitalize(name)
        if cap in _BAD_ASSIGN_NAMES:
            code.addWarning(msgs.SHOULDNT_ASSIGN_NAME % (name, cap))
</t>
<t tx="ekr.20040701145236.119">def _checkVariableOperationOnItself(code, lname, msg):
    if code.stack and code.stack[-1].getName() == lname:
        code.addWarning(msg % lname)
</t>
<t tx="ekr.20040701145236.120">def _checkFutureKeywords(code, varname) :
    kw = python.FUTURE_KEYWORDS.get(varname)
    if kw is not None :
        code.addWarning(msgs.USING_KEYWORD % (varname, kw))
</t>
<t tx="ekr.20040701145236.121">def _STORE_NAME(oparg, operand, codeSource, code) :
    if not code.updateCheckerArgs(operand) :
        _checkFutureKeywords(code, operand)
        module = codeSource.module
        if not codeSource.in_class :
            _checkShadowBuiltin(code, operand)
            if not codeSource.calling_code :
                _checkGlobal(operand, module, codeSource.func, code,
                             msgs.GLOBAL_DEFINED_NOT_DECLARED, codeSource.main)
        else :
            if code.stack :
                codeSource.classObject.statics[operand] = code.stack[-1]
                codeSource.classObject.lineNums[operand] = code.getLineNum()

        var = module.variables.get(operand)
        if var is not None and code.stack and code.stack[-1].const :
            var.value = code.stack[-1].data

        if code.unpackCount :
            code.unpackCount = code.unpackCount - 1
        else:
            _checkAssign(code, operand)
            _checkException(code, operand)
            code.popStack()
        if not module.moduleLineNums.has_key(operand) and codeSource.main :
            code.updateModuleLineNums(module, operand)
</t>
<t tx="ekr.20040701145236.122">_STORE_GLOBAL = _STORE_NAME

def _checkLoadGlobal(codeSource, code, varname) :
    _checkFutureKeywords(code, varname)
    should_check = 1
    if code.func_code.co_name == utils.LAMBDA :
        # this could really be a local reference, check first
        if not codeSource.main and codeSource.calling_code:
            func = getattr(codeSource.calling_code[-1], 'function', None)
            if func is not None and varname in func.func_code.co_varnames :
                _handleLoadLocal(code, codeSource, varname)
                should_check = 0

    if should_check :
        # if a global var starts w/__ and the global is referenced in a class
        # we have to strip off the _class-name, to get the original name
        if codeSource.classObject and \
           utils.startswith(varname, '_' + codeSource.classObject.name + '__'):
            varname = varname[len(codeSource.classObject.name)+1:]
            
        # make sure we remember each global ref to check for unused
        code.globalRefs[_getGlobalName(varname, codeSource.func)] = varname
        if not codeSource.in_class :
            _checkGlobal(varname, codeSource.module, codeSource.func,
                         code, msgs.INVALID_GLOBAL)
</t>
<t tx="ekr.20040701145236.123">def _LOAD_NAME(oparg, operand, codeSource, code) :
    _checkLoadGlobal(codeSource, code, operand)

    # if there was from XXX import *, _* names aren't imported
    if codeSource.module.modules.has_key(operand) and \
       hasattr(codeSource.module.module, operand) :
        operand = getattr(codeSource.module.module, operand).__name__

    opType, const = Stack.TYPE_GLOBAL, 0
    if operand == 'None' :
        opType, const = types.NoneType, 0
    elif operand == 'Ellipsis' :
        opType, const = types.EllipsisType, 1
    code.pushStack(Stack.Item(operand, opType, const))
</t>
<t tx="ekr.20040701145236.124">_LOAD_GLOBAL = _LOAD_NAME

def _LOAD_DEREF(oparg, operand, codeSource, code) :
    if type(oparg) == types.IntType :
        func_code = code.func_code
        if codeSource.calling_code :
            func_code = codeSource.calling_code[-1].function.func_code
        try:
            argname = func_code.co_cellvars[oparg]
        except IndexError:
            argname = func_code.co_freevars[oparg - len(func_code.co_cellvars)]
        code.pushStack(Stack.Item(argname, types.StringType))
        if code.func_code.co_name != utils.LAMBDA :
            code.unusedLocals[argname] = None
    else :
        _LOAD_GLOBAL(oparg, operand, codeSource, code)
</t>
<t tx="ekr.20040701145236.125">_LOAD_CLOSURE = _LOAD_DEREF

def _DELETE_NAME(oparg, operand, codeSource, code) :
    _checkLoadGlobal(codeSource, code, operand)
</t>
<t tx="ekr.20040701145236.126">    # FIXME: handle deleting global multiple times
_DELETE_GLOBAL = _DELETE_NAME

def _LOAD_CONST(oparg, operand, codeSource, code) :
    code.pushStack(Stack.Item(operand, type(operand), 1))
    if type(operand) == types.CodeType :
        name = operand.co_name
        obj = code.codeObjects.get(name, None)
        if name == utils.LAMBDA :
            # use a unique key, so we can have multiple lambdas
            code.codeObjects[code.index] = operand
        elif obj is None :
            code.codeObjects[name] = operand
        elif cfg().redefiningFunction :
            code.addWarning(msgs.REDEFINING_ATTR % (name, obj.co_firstlineno))
</t>
<t tx="ekr.20040701145236.127">def _checkLocalShadow(code, module, varname) :
    if module.variables.has_key(varname) and cfg().shadows :
        line = module.moduleLineNums.get(varname, ('&lt;unknown&gt;', 0))
        w = code.getWarning(msgs.LOCAL_SHADOWS_GLOBAL % (varname, line[1]))
        if line[0] != w.file:
            w.err = '%s in file %s' % (w.err, line[0])
        code.addWarning(w)
</t>
<t tx="ekr.20040701145236.128">def _checkShadowBuiltin(code, varname) :
    if __builtins__.has_key(varname) and varname[0] != '_' and \
       cfg().shadowBuiltins:
        code.addWarning(msgs.VARIABLE_SHADOWS_BUILTIN % varname)
</t>
<t tx="ekr.20040701145236.129">def _checkLoadLocal(code, codeSource, varname, deletedWarn, usedBeforeSetWarn) :
    _checkFutureKeywords(code, varname)
    deletedLine = code.deletedLocals.get(varname)
    if deletedLine :
        code.addWarning(deletedWarn % (varname, deletedLine))
    elif not code.unusedLocals.has_key(varname) and \
         not codeSource.func.isParam(varname) :
        code.addWarning(usedBeforeSetWarn % varname)
    code.unusedLocals[varname] = None
    _checkLocalShadow(code, codeSource.module, varname)
</t>
<t tx="ekr.20040701145236.130">def _handleLoadLocal(code, codeSource, varname) :
    _checkLoadLocal(code, codeSource, varname,
                    msgs.LOCAL_DELETED, msgs.VAR_USED_BEFORE_SET)
</t>
<t tx="ekr.20040701145236.131">def _LOAD_FAST(oparg, operand, codeSource, code) :
    code.pushStack(Stack.Item(operand, type(operand)))
    _handleLoadLocal(code, codeSource, operand)
</t>
<t tx="ekr.20040701145236.132">def _STORE_FAST(oparg, operand, codeSource, code) :
    if not code.updateCheckerArgs(operand) :
        _checkFutureKeywords(code, operand)
        if code.stack and code.stack[-1].type == types.StringType and \
               not code.stack[-1].const:
            _checkVariableOperationOnItself(code, operand,
                                            msgs.SET_VAR_TO_ITSELF)
        code.setType(operand)
        if not code.unpackCount and code.stack and \
           (code.stack[-1].const or code.stack[-1].type == types.TupleType) :
            if code.constants.has_key(operand) :
                del code.constants[operand]
            else :
                code.constants[operand] = code.stack[-1].data

        _checkLocalShadow(code, codeSource.module, operand)
        _checkShadowBuiltin(code, operand)
        _checkAssign(code, operand)
        _checkException(code, operand)
        if code.deletedLocals.has_key(operand) :
            del code.deletedLocals[operand]
        if not code.unusedLocals.has_key(operand) :
            errLine = code.getLineNum()
            if code.unpackCount and not cfg().unusedLocalTuple :
                errLine = -errLine
            code.unusedLocals[operand] = errLine
        code.unpack()
</t>
<t tx="ekr.20040701145236.133">def _DELETE_FAST(oparg, operand, codeSource, code) :
    _checkLoadLocal(code, codeSource, operand,
                    msgs.LOCAL_ALREADY_DELETED, msgs.VAR_DELETED_BEFORE_SET)
    code.deletedLocals[operand] = code.getLineNum()
</t>
<t tx="ekr.20040701145236.134">def _checkAttribute(top, operand, codeSource, code) :
    if top.data == cfg().methodArgName and codeSource.classObject != None :
        _checkClassAttribute(operand, codeSource.classObject, code)
    elif type(top.type) == types.StringType or top.type == types.ModuleType :
        _checkModuleAttribute(operand, codeSource.module, code, top.data)
    else :
        _checkAttributeType(code, top, operand)
</t>
<t tx="ekr.20040701145236.135">def _checkExcessiveReferences(code, top, extraAttr = None) :
    if cfg().maxReferences &lt;= 0 :
        return

    try :
        data = top.data
        if extraAttr is not None :
            data = data + (extraAttr,)
        
        maxReferences = cfg().maxReferences
        if data[0] == cfg().methodArgName:
            maxReferences = maxReferences + 1
        if len(data) &gt; maxReferences :
            name = string.join(top.data, '.')
            code.addWarning(msgs.TOO_MANY_REFERENCES % (maxReferences, name))
    except TypeError :
        pass
</t>
<t tx="ekr.20040701145236.136">def _checkDeprecated(code, identifierTuple):
    # check deprecated module.function
    try:
        name = string.join(identifierTuple, '.')
        undeprecated = python.DEPRECATED_ATTRS[name]
    except (KeyError, TypeError):
        pass
    else:
        msg = msgs.USING_DEPRECATED_ATTR % name
        if undeprecated:
            msg = msg + msgs.USE_INSTEAD % undeprecated
        code.addWarning(msg)
</t>
<t tx="ekr.20040701145236.137">def _LOAD_ATTR(oparg, operand, codeSource, code) :
    if len(code.stack) &gt; 0 :
        top = code.stack[-1]
        _checkAttribute(top, operand, codeSource, code)
        top.addAttribute(operand)

        if len(top.data) == 2:
            if cfg().deprecated:
                _checkDeprecated(code, top.data)

            try:
                insecure = python.SECURITY_FUNCS.get(top.data[0])
            except TypeError:
                pass
            else:
                if insecure and insecure.has_key(operand):
                    func = string.join(top.data, '.')
                    code.addWarning(msgs.USING_INSECURE_FUNC % func)

        nextOp = code.nextOpInfo()[0]
        if not OP.LOAD_ATTR(nextOp) :
            if OP.POP_TOP(nextOp) and cfg().noEffect:
                code.addWarning(msgs.POSSIBLE_STMT_WITH_NO_EFFECT)
            else :
                _checkExcessiveReferences(code, top)
</t>
<t tx="ekr.20040701145236.138">def _ok_to_set_attr(classObject, basename, attr) :
    return (cfg().onlyCheckInitForMembers and classObject != None and
            basename == cfg().methodArgName and 
            not _classHasAttribute(classObject, attr))
</t>
<t tx="ekr.20040701145236.139">def _STORE_ATTR(oparg, operand, codeSource, code) :
    if code.stack :
        top = code.stack.pop()
        top_name = '%s.%s' % (top.getName(), operand)
        try:
            # FIXME: this is a hack to handle code like:
            #        a.a = [x for x in range(2) if x &gt; 1]
            previous = code.stack[-1]
        except IndexError:
            previous = None
        if top.type in (types.StringType, Stack.TYPE_ATTRIBUTE) and \
           previous and previous.type == Stack.TYPE_ATTRIBUTE:
            _checkVariableOperationOnItself(code, top_name,
                                            msgs.SET_VAR_TO_ITSELF)
        _checkExcessiveReferences(code, top, operand)
        if _ok_to_set_attr(codeSource.classObject, top.data, operand) :
            code.addWarning(msgs.INVALID_SET_CLASS_ATTR % operand)
    code.unpack()
</t>
<t tx="ekr.20040701145236.140">def _DELETE_ATTR(oparg, operand, codeSource, code) :
    if len(code.stack) &gt; 0 :
        _checkAttribute(code.stack[-1], operand, codeSource, code)
</t>
<t tx="ekr.20040701145236.141">def _getExceptionInfo(codeSource, item):
    # FIXME: probably ought to try to handle raise module.Error
    if item.type is types.StringType and item.const == 1:
        return item.data, 1

    e = None
    if item.type is Stack.TYPE_GLOBAL:
        try:
            e = eval(item.data)
        except NameError:
            pass

    if not e:
        try:
            c = codeSource.module.classes.get(item.data)
        except TypeError:     # item.data may not be hashable (e.g., list)
            return e, 0

        if c is not None:
            e = c.classObject
        else:
            v = codeSource.module.variables.get(item.data)
            if v is not None:
                return v, 1
    return e, 0
</t>
<t tx="ekr.20040701145236.142">_UNCHECKABLE_CATCH_TYPES = (Stack.TYPE_UNKNOWN, Stack.TYPE_ATTRIBUTE)
def _checkCatchException(codeSource, code, item):
    if not cfg().badExceptions:
        return

    if item.data is None or item.type in _UNCHECKABLE_CATCH_TYPES:
        return

    e, is_str = _getExceptionInfo(codeSource, item)
    if is_str:
        code.addWarning(msgs.CATCH_STR_EXCEPTION % item.data)
    elif e is not None and not _isexception(e):
        code.addWarning(msgs.CATCH_BAD_EXCEPTION % item.data)
</t>
<t tx="ekr.20040701145236.143">def _handleExceptionChecks(codeSource, code, checks):
    for item in checks:
        if item is not None:
            if item.type is not types.TupleType:
                _checkCatchException(codeSource, code, item)
            else:
                for ti in item.data:
                    if isinstance(ti, Stack.Item):
                        _checkCatchException(codeSource, code, ti)
</t>
<t tx="ekr.20040701145236.144">_BOOL_NAMES = ('True', 'False')
_BAD_ASSIGN_NAMES = _BOOL_NAMES + ('None',)

def _checkBoolean(code, checks):

    for item in checks:
        try:
            data = string.capitalize(item.data)
            if item.type is Stack.TYPE_GLOBAL and data in _BOOL_NAMES:
                # trace(checks)
                if 0: # EKR
                    code.addWarning(msgs.BOOL_COMPARE % item.data)
        except (AttributeError, TypeError):
            # TypeError is necessary for Python 1.5.2
            pass # ignore items that are not a StackItem or a string
</t>
<t tx="ekr.20040701145236.145">def _COMPARE_OP(oparg, operand, codeSource, code) :
    compareValues = _handleComparison(code.stack, operand)
    if oparg == OP.EXCEPT_COMPARISON:
        _handleExceptionChecks(codeSource, code, compareValues)
    elif oparg &lt; OP.IS_COMPARISON:
        _checkBoolean(code, compareValues)
    elif cfg().isLiteral:
        # X is Y   or   X is not Y   comparison
        second_arg = code.stack[-1].data[2]
        # FIXME: how should booleans should e handled, need to think about it
##        if second_arg.const or (second_arg.type == Stack.TYPE_GLOBAL and
##                                second_arg.data in ['True', 'False']):
        if second_arg.const:
            data = second_arg.data
            if second_arg.type is types.DictType:
                data = {}
            not_str = ''
            if oparg != OP.IS_COMPARISON:
                not_str = ' not'
            code.addWarning(msgs.IS_LITERAL % (not_str, data))

    _checkNoEffect(code)
</t>
<t tx="ekr.20040701145236.146">def _IMPORT_NAME(oparg, operand, codeSource, code) :
    code.pushStack(Stack.Item(operand, types.ModuleType))
    nextOp = code.nextOpInfo()[0]
    if not OP.IMPORT_FROM(nextOp) and not OP.IMPORT_STAR(nextOp) :
        _handleImport(code, operand, codeSource.module, codeSource.main, None)
</t>
<t tx="ekr.20040701145236.147">def _IMPORT_FROM(oparg, operand, codeSource, code) :
    _handleImportFrom(code, operand, codeSource.module, codeSource.main)
    # this is necessary for python 1.5 (see STORE_GLOBAL/NAME)
    if utils.pythonVersion() &lt; utils.PYTHON_2_0 :
        code.popStack()
        if not codeSource.main :
            code.unusedLocals[operand] = None
        elif not codeSource.module.moduleLineNums.has_key(operand) :
            code.updateModuleLineNums(codeSource.module, operand)
</t>
<t tx="ekr.20040701145236.148">def _IMPORT_STAR(oparg, operand, codeSource, code) :
    _handleImportFrom(code, '*', codeSource.module, codeSource.main)
</t>
<t tx="ekr.20040701145236.149"># Python 2.3 introduced some optimizations that create problems
# this is a utility for ignoring these cases
def _shouldIgnoreCodeOptimizations(code, bytecodes, offset, length=None):
    if utils.pythonVersion() &lt; utils.PYTHON_2_3:
        return 0

    if length is None:
        length = offset - 1
    try:
        start = code.index - offset
        return bytecodes == code.bytes[start:start+length]
    except IndexError:
        return 0
</t>
<t tx="ekr.20040701145236.150"># In Python 2.3, a, b = 1,2 generates this code:
# ...
# ROT_TWO
# JUMP_FORWARD 2
# DUP_TOP
# POP_TOP
#
# which generates a Possible stmt w/no effect

# ROT_TWO = 2; JUMP_FORWARD = 110; 2, 0 is the offset (2)
_IGNORE_SEQ = '%c%c%c%c' % (2, 110, 2, 0)
def _shouldIgnoreNoEffectWarning(code):
    return _shouldIgnoreCodeOptimizations(code, _IGNORE_SEQ, 5)
</t>
<t tx="ekr.20040701145236.151">def _DUP_TOP(oparg, operand, codeSource, code) :
    if len(code.stack) &gt; 0 :
        code.pushStack(code.stack[-1], _shouldIgnoreNoEffectWarning(code))
</t>
<t tx="ekr.20040701145236.152">def _popn(code, n) :
    if len(code.stack) &gt;= 2 :
        loadValue = code.stack[-2]
        if cfg().modifyDefaultValue and loadValue.type == types.StringType :
            _checkModifyDefaultArg(code, loadValue.data)

    code.popStackItems(n)
</t>
<t tx="ekr.20040701145236.153">def _DELETE_SUBSCR(oparg, operand, codeSource, code) :
    _popn(code, 2)
</t>
<t tx="ekr.20040701145236.154">def _STORE_SUBSCR(oparg, operand, codeSource, code) :
    _popn(code, 3)
</t>
<t tx="ekr.20040701145236.155">def _CALL_FUNCTION(oparg, operand, codeSource, code) :
    _handleFunctionCall(codeSource, code, oparg)
</t>
<t tx="ekr.20040701145236.156">def _CALL_FUNCTION_VAR(oparg, operand, codeSource, code) :
    _handleFunctionCall(codeSource, code, oparg, 1, 0)
</t>
<t tx="ekr.20040701145236.157">def _CALL_FUNCTION_KW(oparg, operand, codeSource, code) :
    _handleFunctionCall(codeSource, code, oparg, 1)
</t>
<t tx="ekr.20040701145236.158">def _CALL_FUNCTION_VAR_KW(oparg, operand, codeSource, code) :
    _handleFunctionCall(codeSource, code, oparg, 2, 0)
</t>
<t tx="ekr.20040701145236.159">def _MAKE_FUNCTION(oparg, operand, codeSource, code) :
    newValue = Stack.makeFuncReturnValue(code.stack[-1], oparg)
    code.popStackItems(oparg+1)
    code.pushStack(newValue)
</t>
<t tx="ekr.20040701145236.160">def _MAKE_CLOSURE(oparg, operand, codeSource, code) :
    _MAKE_FUNCTION(max(0, oparg - 1), operand, codeSource, code)
</t>
<t tx="ekr.20040701145236.161">def _BUILD_MAP(oparg, operand, codeSource, code) :
    _makeConstant(code, oparg, Stack.makeDict)
</t>
<t tx="ekr.20040701145236.162">def _BUILD_TUPLE(oparg, operand, codeSource, code) :
    _makeConstant(code, oparg, Stack.makeTuple)
</t>
<t tx="ekr.20040701145236.163">def _BUILD_LIST(oparg, operand, codeSource, code) :
    _makeConstant(code, oparg, Stack.makeList)
</t>
<t tx="ekr.20040701145236.164">def _BUILD_CLASS(oparg, operand, codeSource, code) :
    newValue = Stack.makeFuncReturnValue(code.stack[-1], types.ClassType)
    code.popStackItems(3)
    code.pushStack(newValue)
</t>
<t tx="ekr.20040701145236.165">def _LIST_APPEND(oparg, operand, codeSource, code):
    code.popStackItems(2)
</t>
<t tx="ekr.20040701145236.166">def _modifyStackName(code, suffix):
    if code.stack:
        tos = code.stack[-1]
        tos_type = type(tos.data)
        if tos_type == types.StringType:
            tos.data = tos.data + suffix
        elif tos_type == types.TupleType and \
             type(tos.data[-1]) == types.StringType:
            tos.data = tos.data[:-1] + (tos.data[-1] + suffix,)
</t>
<t tx="ekr.20040701145236.167">def _UNARY_CONVERT(oparg, operand, codeSource, code) :
    if code.stack:
        stackValue = code.stack[-1]
        if stackValue.data == cfg().methodArgName and \
           stackValue.const == 0 and codeSource.classObject is not None and \
           codeSource.func.function.func_name == '__repr__' :
            code.addWarning(msgs.USING_SELF_IN_REPR)
        stackValue.data = str(stackValue.data)
        stackValue.type = types.StringType
    _modifyStackName(code, '-repr')
</t>
<t tx="ekr.20040701145236.168">def _UNARY_POSITIVE(oparg, operand, codeSource, code) :
    if OP.UNARY_POSITIVE(code.nextOpInfo()[0]) :
        code.addWarning(msgs.STMT_WITH_NO_EFFECT % '++')
        code.popNextOp()
    elif cfg().unaryPositive and code.stack and not code.stack[-1].const :
        code.addWarning(msgs.UNARY_POSITIVE_HAS_NO_EFFECT)
    _modifyStackName(code, '-pos')
</t>
<t tx="ekr.20040701145236.169">def _UNARY_NEGATIVE(oparg, operand, codeSource, code) :
    if OP.UNARY_NEGATIVE(code.nextOpInfo()[0]) :
        code.addWarning(msgs.STMT_WITH_NO_EFFECT % '--')
    _modifyStackName(code, '-neg')
</t>
<t tx="ekr.20040701145236.170">def _UNARY_NOT(oparg, operand, codeSource, code) :
    _modifyStackName(code, '-not')
</t>
<t tx="ekr.20040701145236.171">def _UNARY_INVERT(oparg, operand, codeSource, code) :
    if OP.UNARY_INVERT(code.nextOpInfo()[0]) :
        code.addWarning(msgs.STMT_WITH_NO_EFFECT % '~~')
    _modifyStackName(code, '-invert')
</t>
<t tx="ekr.20040701145236.172">def _popStackRef(code, operand, count = 2) :
    code.popStackItems(count)
    code.pushStack(Stack.Item(operand, Stack.TYPE_UNKNOWN))
</t>
<t tx="ekr.20040701145236.173">def _popModifiedStack(code, suffix=' '):
    code.popStack()
    _modifyStackName(code, suffix)
</t>
<t tx="ekr.20040701145236.174">def _pop(oparg, operand, codeSource, code) :
    code.popStack()
</t>
<t tx="ekr.20040701145236.175">_POP_TOP = _PRINT_ITEM = _pop

def _popModified(oparg, operand, codeSource, code):
    _popModifiedStack(code)
</t>
<t tx="ekr.20040701145236.176">_BINARY_LSHIFT = _BINARY_RSHIFT = _popModified

def _checkModifyNoOp(code, op, msg=msgs.MODIFY_VAR_NOOP, modifyStack=1):
    stack = code.stack
    if len(stack) &gt;= 2:
        name = stack[-1].getName()
        if name != Stack.TYPE_UNKNOWN and name == stack[-2].getName():
            code.addWarning(msg % (name, op, name))

        if modifyStack:
            code.popStack()
            stack[-1].const = 0
            _modifyStackName(code, op)
</t>
<t tx="ekr.20040701145236.177">def _BINARY_AND(oparg, operand, codeSource, code):
    _checkModifyNoOp(code, '&amp;')
</t>
<t tx="ekr.20040701145236.178">def _BINARY_OR(oparg, operand, codeSource, code):
    _checkModifyNoOp(code, '|')
</t>
<t tx="ekr.20040701145236.179">def _BINARY_XOR(oparg, operand, codeSource, code):
    _checkModifyNoOp(code, '^', msgs.XOR_VAR_WITH_ITSELF)
</t>
<t tx="ekr.20040701145236.180">def _PRINT_ITEM_TO(oparg, operand, codeSource, code) :
    code.popStackItems(2)
</t>
<t tx="ekr.20040701145236.181">try:
    ComplexType = types.ComplexType
except NameError:
    ComplexType = types.FloatType    # need some numeric type here

_NUMERIC_TYPES = (types.IntType, types.FloatType, ComplexType)

# FIXME: This is pathetically weak, need to handle more types
def _coerce_type(code) :
    _checkNoEffect(code)
    newItem = Stack.Item('&lt;stack&gt;', Stack.TYPE_UNKNOWN)
    if len(code.stack) &gt;= 2 :
        s1, s2 = code.stack[-2:]
        s1type = s1.getType(code.typeMap)
        s2type = s2.getType(code.typeMap)
        if s1type != s2type :
            if s1type in _NUMERIC_TYPES and s2type in _NUMERIC_TYPES :
                newType = types.FloatType
                if s1type == ComplexType or s2type == ComplexType:
                    newType = ComplexType
                newItem.type = newType

    code.popStackItems(2)
    code.pushStack(newItem)
</t>
<t tx="ekr.20040701145236.182">def _BINARY_ADD(oparg, operand, codeSource, code) :
    stack = code.stack
    if len(stack) &gt;= 2 and (stack[-1].const and stack[-2].const and
                            stack[-1].type == stack[-2].type) :
        value = stack[-2].data + stack[-1].data
        code.popStackItems(2)
        code.pushStack(Stack.Item(value, type(value), 1))
    else :
        _coerce_type(code)
</t>
<t tx="ekr.20040701145236.183">def _BINARY_SUBTRACT(oparg, operand, codeSource, code) :
    _coerce_type(code)
</t>
<t tx="ekr.20040701145236.184">_BINARY_POWER = _BINARY_SUBTRACT

def _BINARY_SUBSCR(oparg, operand, codeSource, code) :
    _checkNoEffect(code)
    if len(code.stack) &gt;= 2 :
        stack = code.stack
        varType = code.typeMap.get(str(stack[-2].data), [])
        if types.ListType in varType and stack[-1].type == types.TupleType :
            code.addWarning(msgs.USING_TUPLE_ACCESS_TO_LIST % stack[-2].data)
    _popStackRef(code, operand)
</t>
<t tx="ekr.20040701145236.185">def _isint(stackItem, code) :
    if type(stackItem.data) == types.IntType :
        return 1
    stackTypes = code.typeMap.get(stackItem.data, [])
    if len(stackTypes) != 1 :
        return 0
    return types.IntType in stackTypes
</t>
<t tx="ekr.20040701145236.186">def _BINARY_DIVIDE(oparg, operand, codeSource, code) :
    _checkNoEffect(code)
    _checkModifyNoOp(code, '/', msgs.DIVIDE_VAR_BY_ITSELF, 0)
    if cfg().intDivide and len(code.stack) &gt;= 2 :
        if _isint(code.stack[-1], code) and _isint(code.stack[-2], code) :
            code.addWarning(msgs.INTEGER_DIVISION % tuple(code.stack[-2:]))

    _popModifiedStack(code, '/')
</t>
<t tx="ekr.20040701145236.187">def _BINARY_TRUE_DIVIDE(oparg, operand, codeSource, code) :
    _checkNoEffect(code)
    _checkVariableOperationOnItself(code, operand, msgs.DIVIDE_VAR_BY_ITSELF)
    _popModifiedStack(code, '/')
</t>
<t tx="ekr.20040701145236.188">_BINARY_FLOOR_DIVIDE = _BINARY_TRUE_DIVIDE

def _BINARY_MULTIPLY(oparg, operand, codeSource, code) :
    if len(code.stack) &gt;= 2 :
        format = _getFormatString(code, codeSource)
        if format and type(code.stack[-1].data) == types.IntType :
            code.stack[-2].data = format * code.stack[-1].data
            code.popStack()
        else:
            _coerce_type(code)
    else:
        _popModifiedStack(code, '*')
</t>
<t tx="ekr.20040701145236.189">def _BINARY_MODULO(oparg, operand, codeSource, code) :
    _checkNoEffect(code)
    if cfg().modulo1 and code.stack and code.stack[-1].data == 1:
        if len(code.stack) &lt; 2 or \
           code.stack[-2].getType(code.typeMap) != types.FloatType:
            code.addWarning(msgs.MODULO_1)
    _getFormatWarnings(code, codeSource)
    _popModifiedStack(code, '%')
    if code.stack:
        code.stack[-1].const = 0
</t>
<t tx="ekr.20040701145236.190">def _ROT_TWO(oparg, operand, codeSource, code) :
    if len(code.stack) &gt;= 2 :
        tmp = code.stack[-2]
        code.stack[-2] = code.stack[-1]
        code.stack[-1] = tmp
</t>
<t tx="ekr.20040701145236.191">def _SETUP_EXCEPT(oparg, operand, codeSource, code) :
    code.has_except = 1
    code.pushStack(Stack.Item(None, Stack.TYPE_EXCEPT))
    code.pushStack(Stack.Item(None, Stack.TYPE_EXCEPT))
</t>
<t tx="ekr.20040701145236.192">def _SETUP_FINALLY(oparg, operand, codeSource, code) :
    if not code.has_except :
        code.try_finally_first = 1
</t>
<t tx="ekr.20040701145236.193">def _END_FINALLY(oparg, operand, codeSource, code) :
    if code.try_finally_first and code.index == (len(code.bytes) - 4) :
        code.starts_and_ends_with_finally = 1
</t>
<t tx="ekr.20040701145236.194">def _LINE_NUM(oparg, operand, codeSource, code) :
    code.lastLineNum = oparg
</t>
<t tx="ekr.20040701145236.195">def _UNPACK_SEQUENCE(oparg, operand, codeSource, code) :
    code.unpackCount = oparg
    if code.stack:
        top = code.stack[-1]
        # if we know we have a tuple, make sure we unpack it into the
        # right # of variables
        topType = top.getType(code.typeMap)
        if topType in _SEQUENCE_TYPES:
            length = top.length
            # we don't know the length, maybe it's constant and we can find out
            if length == 0:
                value = code.constants.get(str(top.data))
                if type(value) in _SEQUENCE_TYPES:
                    length = len(value)
            if length &gt; 0 and length != oparg:
                if cfg().unpackLength:
                    code.addWarning(msgs.WRONG_UNPACK_SIZE % (length, oparg))
        elif topType not in _UNCHECKABLE_STACK_TYPES:
            if cfg().unpackNonSequence:
                code.addWarning(msgs.UNPACK_NON_SEQUENCE %
                                (top.data, _getTypeStr(topType)))
        _modifyStackName(code, '-unpack')
</t>
<t tx="ekr.20040701145236.196">def _SLICE_1_ARG(oparg, operand, codeSource, code) :
    _popStackRef(code, operand)
</t>
<t tx="ekr.20040701145236.197">_SLICE1 = _SLICE2 = _SLICE_1_ARG

def _SLICE3(oparg, operand, codeSource, code) :
    _popStackRef(code, operand, 3)
</t>
<t tx="ekr.20040701145236.198">def _check_string_iteration(code, index):
    try:
        item = code.stack[index]
    except IndexError:
        return
    if item.getType(code.typeMap) == types.StringType and \
       cfg().stringIteration:
        code.addWarning(msgs.STRING_ITERATION % item.data)
</t>
<t tx="ekr.20040701145236.199">def _FOR_LOOP(oparg, operand, codeSource, code) :
    code.loops = code.loops + 1
    _check_string_iteration(code, -2)
    _popStackRef(code, '&lt;for_loop&gt;', 2)
</t>
<t tx="ekr.20040701145236.200">def _GET_ITER(oparg, operand, codeSource, code) :
    _check_string_iteration(code, -1)
</t>
<t tx="ekr.20040701145236.201">def _FOR_ITER(oparg, operand, codeSource, code) :
    code.loops = code.loops + 1
    _popStackRef(code, '&lt;for_iter&gt;', 1)
</t>
<t tx="ekr.20040701145236.202">def _jump(oparg, operand, codeSource, code) :
    if len(code.stack) &gt; 0 :
        topOfStack = code.stack[-1]
        if topOfStack.isMethodCall(codeSource.classObject, cfg().methodArgName):
            name = topOfStack.data[-1]
            if codeSource.classObject.methods.has_key(name) :
                code.addWarning(msgs.USING_METHOD_AS_ATTR % name)
</t>
<t tx="ekr.20040701145236.203">_JUMP_ABSOLUTE = _jump

def _skip_loops(bytes, i, lastLineNum, max) :
    extended_arg = 0
    blockCount = 1
    while i &lt; max :
        op, oparg, i, extended_arg = OP.getInfo(bytes, i, extended_arg)
        if OP.LINE_NUM(op) :
            lastLineNum = oparg
        elif OP.FOR_LOOP(op) or OP.FOR_ITER(op) or OP.SETUP_LOOP(op) :
            blockCount = blockCount + 1
        elif OP.POP_BLOCK(op) :
            blockCount = blockCount - 1
            if blockCount &lt;= 0 :
                break

    return lastLineNum, i
</t>
<t tx="ekr.20040701145236.204">def _is_unreachable(code, topOfStack, branch, if_false) :
    # Are we are checking exceptions, but we not catching all exceptions?
    if (topOfStack.type == Stack.TYPE_COMPARISON and 
        topOfStack.data[1] == 'exception match' and 
        topOfStack.data[2] is not Exception) :
        return 1

    # do we possibly have while 1: ?
    if not (topOfStack.const and topOfStack.data == 1 and if_false) :
        return 0

    # get the op just before the branch (ie, -3)
    op, oparg, i, extended_arg = OP.getInfo(code.bytes, branch - 3, 0)
    # are we are jumping to before the while 1: (LOAD_CONST, JUMP_IF_FALSE)
    if not (OP.JUMP_ABSOLUTE(op) and oparg == (code.index - 3*3)) :
        return 0

    # check if we break out of the loop
    i = code.index
    lastLineNum = code.getLineNum()
    while i &lt; branch :
        op, oparg, i, extended_arg = OP.getInfo(code.bytes, i, extended_arg)
        if OP.LINE_NUM(op) :
            lastLineNum = oparg
        elif OP.BREAK_LOOP(op) :
            return 0
        elif OP.FOR_LOOP(op) or OP.FOR_ITER(op) or OP.SETUP_LOOP(op) :
            lastLineNum, i = _skip_loops(code.bytes, i, lastLineNum, branch)

    i = code.index - 3*4
    op, oparg, i, extended_arg = OP.getInfo(code.bytes, i, 0)
    if OP.SETUP_LOOP(op) :
        # a little lie to pretend we have a raise after a while 1:
        code.removeBranch(i + oparg)
        code.raiseValues.append((lastLineNum, None, i + oparg))
    return 1
</t>
<t tx="ekr.20040701145236.205"># In Python 2.3, while/if 1: gets optimized to
# ...
# JUMP_FORWARD 4
# JUMP_IF_FALSE ?
# POP_TOP
#
# which generates a Using a conditional statement with a constant value

# JUMP_FORWARD = 110; 4, 0 is the offset (4)
_IGNORE_BOGUS_JUMP = '%c%c%c' % (110, 4, 0)
def _shouldIgnoreBogusJumps(code):
    return _shouldIgnoreCodeOptimizations(code, _IGNORE_BOGUS_JUMP, 6, 3)
</t>
<t tx="ekr.20040701145236.206">def _checkConstantCondition(code, topOfStack, if_false):
    # don't warn when doing (test and 'true' or 'false')
    # still warn when doing (test and None or 'false')
    if if_false or not OP.LOAD_CONST(code.nextOpInfo(1)[0]) or \
       not topOfStack.data or topOfStack.type is types.NoneType:
        if not _shouldIgnoreBogusJumps(code):
            code.addWarning(msgs.CONSTANT_CONDITION % str(topOfStack))
</t>
<t tx="ekr.20040701145236.207">def _jump_conditional(oparg, operand, codeSource, code, if_false) :
    # FIXME: this doesn't work in 2.3+ since constant conditions
    #        are optimized away by the compiler.
    if code.stack :
        topOfStack = code.stack[-1]
        if (topOfStack.const or topOfStack.type is types.NoneType) and \
           cfg().constantConditions and \
           (topOfStack.data != 1 or cfg().constant1):
            _checkConstantCondition(code, topOfStack, if_false)

        if _is_unreachable(code, topOfStack, code.label, if_false) :
            code.removeBranch(code.label)

    _jump(oparg, operand, codeSource, code)
</t>
<t tx="ekr.20040701145236.208">def _JUMP_IF_FALSE(oparg, operand, codeSource, code) :
    _jump_conditional(oparg, operand, codeSource, code, 1)
</t>
<t tx="ekr.20040701145236.209">def _JUMP_IF_TRUE(oparg, operand, codeSource, code) :
    _jump_conditional(oparg, operand, codeSource, code, 0)
</t>
<t tx="ekr.20040701145236.210">def _JUMP_FORWARD(oparg, operand, codeSource, code) :
    _jump(oparg, operand, codeSource, code)
    code.remove_unreachable_code(code.label)
</t>
<t tx="ekr.20040701145236.211">def _RETURN_VALUE(oparg, operand, codeSource, code) :
    if not codeSource.calling_code :
        code.addReturn()
</t>
<t tx="ekr.20040701145236.212">def _EXEC_STMT(oparg, operand, codeSource, code) :
    if cfg().usesExec :
        if code.stack and code.stack[-1].isNone() :
            code.addWarning(msgs.USES_GLOBAL_EXEC)
        else :
            code.addWarning(msgs.USES_EXEC)
</t>
<t tx="ekr.20040701145236.213">def _checkStrException(code, varType, item):
    if varType is types.StringType:
        code.addWarning(msgs.RAISE_STR_EXCEPTION % item.data)
</t>
<t tx="ekr.20040701145236.214">def _RAISE_VARARGS(oparg, operand, codeSource, code) :
    code.addRaise()
    if not cfg().badExceptions:
        return

    if oparg &gt; 0 and len(code.stack) &gt;= oparg:
        item = code.stack[-oparg]
        if item.type not in (Stack.TYPE_FUNC_RETURN, Stack.TYPE_UNKNOWN):
            if item.type is Stack.TYPE_GLOBAL:
                e, is_str = _getExceptionInfo(codeSource, item)
                if is_str:
                    _checkStrException(code, e.type, item)
                elif e is not None and not _isexception(e):
                    code.addWarning(msgs.RAISE_BAD_EXCEPTION % item.data)
            else:
                _checkStrException(code, item.getType(code.typeMap), item)
</t>
<t tx="ekr.20040701145236.215">@first #!/usr/bin/env python

# Copyright (c) 2001-2004, MetaSlash Inc.  All rights reserved.

"""
Configuration information for checker.
"""

from leoGlobals import trace
print "Changed by EKR: pychecker.Config"

@language python

&lt;&lt; Config declarations &gt;&gt;

@others
</t>
<t tx="ekr.20040701145236.216">import sys
import os
import getopt
import string
import re
import time

_RC_FILE = ".pycheckrc"
CHECKER_VAR = '__pychecker__'
_VERSION = '0.8.14'

_DEFAULT_BLACK_LIST = [ "Tkinter", "wxPython", "gtk", "GTK", "GDK", ]
_DEFAULT_VARIABLE_IGNORE_LIST = [ '__version__', '__warningregistry__', 
                                  '__all__', '__credits__', '__test__',
                                  '__author__', '__email__', '__revision__', ]
_DEFAULT_UNUSED_LIST = [ '_', 'empty', 'unused', 'dummy', ]

# All these options are on even if -e/--errors is used
_ERRORS = { 'noEffect': 1, }

_OPTIONS = (
    ('Major Options', [
 ('e', 0, 'errors', None, 'turn off all warnings which are not likely errors'),
 ( '', 0, 'complexity', None, 'turn off all warnings which are related to complexity'),
 ('F', 1, 'config', None, 'specify .pycheckrc file to use'),
 ('',  0, 'quixote', None, 'support Quixote\'s PTL modules'),
     ]),
    ('Error Control', [
 ('i', 0, 'import', 'importUsed', 'unused imports'),
 ('k', 0, 'pkgimport', 'packageImportUsed', 'unused imports from __init__.py'),
 ('M', 0, 'reimportself', 'reimportSelf', 'module imports itself'),
 ('X', 0, 'reimport', 'moduleImportErrors', 'reimporting a module'),
 ('x', 0, 'miximport', 'mixImport', 'module does import and from ... import'),
 ('l', 0, 'local', 'localVariablesUsed', 'unused local variables, except tuples'),
 ('t', 0, 'tuple', 'unusedLocalTuple', 'all unused local variables, including tuples'),
 ('9', 0, 'members', 'membersUsed', 'all unused class data members'),
 ('v', 0, 'var', 'allVariablesUsed', 'all unused module variables'),
 ('p', 0, 'privatevar', 'privateVariableUsed', 'unused private module variables'),
 ('g', 0, 'allglobals', 'reportAllGlobals', 'report each occurrence of global warnings'),
 ('n', 0, 'namedargs', 'namedArgs', 'functions called with named arguments (like keywords)'),
 ('a', 0, 'initattr', 'onlyCheckInitForMembers', 'Attributes (members) must be defined in __init__()'),
 ('I', 0, 'initsubclass', 'initDefinedInSubclass', 'Subclass.__init__() not defined'),
 ('u', 0, 'callinit', 'baseClassInitted', 'Baseclass.__init__() not called'),
 ('0', 0, 'abstract', 'abstractClasses', 'Subclass needs to override methods that only throw exceptions'),
 ('N', 0, 'initreturn', 'returnNoneFromInit', 'Return None from __init__()'),
 ('8', 0, 'unreachable', 'unreachableCode', 'unreachable code'),
 ('2', 0, 'constCond', 'constantConditions', 'a constant is used in a conditional statement'),
 ('1', 0, 'constant1', 'constant1', '1 is used in a conditional statement (if 1: or while 1:)'),
 ( '', 0, 'stringiter', 'stringIteration', 'check if iterating over a string'),
 ( '', 0, 'stringfind', 'stringFind', 'check improper use of string.find()'),
 ('A', 0, 'callattr', 'callingAttribute', 'Calling data members as functions'),
 ('y', 0, 'classattr', 'classAttrExists', 'class attribute does not exist'),
 ('S', 1, 'self', 'methodArgName', 'First argument to methods'),
 ('',  1, 'classmethodargs', 'classmethodArgNames', 'First argument to classmethods'),
 ('T', 0, 'argsused', 'argumentsUsed', 'unused method/function arguments'),
 ('z', 0, 'varargsused', 'varArgumentsUsed', 'unused method/function variable arguments'),
 ('G', 0, 'selfused', 'ignoreSelfUnused', 'ignore if self is unused in methods'),
 ('o', 0, 'override', 'checkOverridenMethods', 'check if overridden methods have the same signature'),
 ('',  0, 'special', 'checkSpecialMethods', 'check if __special__ methods exist and have the correct signature'),
 ('U', 0, 'reuseattr', 'redefiningFunction', 'check if function/class/method names are reused'),
 ('Y', 0, 'positive', 'unaryPositive', 'check if using unary positive (+) which is usually meaningless'),
 ('j', 0, 'moddefvalue', 'modifyDefaultValue', 'check if modify (call method) on a parameter that has a default value'),
 ( '', 0, 'changetypes', 'inconsistentTypes', 'check if variables are set to different types'),
 ( '', 0, 'unpack', 'unpackNonSequence', 'check if unpacking a non-sequence'),
 ( '', 0, 'unpacklen', 'unpackLength', 'check if unpacking sequence with the wrong length'),
 ( '', 0, 'badexcept', 'badExceptions', 'check if raising or catching bad exceptions'),
 ('4', 0, 'noeffect', 'noEffect', 'check if statement appears to have no effect'),
 ('',  0, 'modulo1', 'modulo1', 'check if using (expr % 1), it has no effect on integers and strings'),
 ('',  0, 'isliteral', 'isLiteral', "check if using (expr is const-literal), doesn't always work on integers and strings"),
     ]),
    ('Possible Errors', [
 ('r', 0, 'returnvalues', 'checkReturnValues', 'check consistent return values'),
 ('C', 0, 'implicitreturns', 'checkImplicitReturns', 'check if using implict and explicit return values'),
 ('O', 0, 'objattrs', 'checkObjectAttrs', 'check that attributes of objects exist'),
 ('7', 0, 'slots', 'slots', 'various warnings about incorrect usage of __slots__'),
 ('3', 0, 'properties', 'classicProperties', 'using properties with classic classes'),
 ( '', 0, 'emptyslots', 'emptySlots', 'check if __slots__ is empty'),
 ('D', 0, 'intdivide', 'intDivide', 'check if using integer division'),
 ('w', 0, 'shadow', 'shadows', 'check if local variable shadows a global'),
 ('s', 0, 'shadowbuiltin', 'shadowBuiltins', 'check if a variable shadows a builtin'),
     ]),
    ('Security', [
 ( '', 0, 'input', 'usesInput', 'check if input() is used'),
 ('6', 0, 'exec', 'usesExec', 'check if the exec statement is used'),
     ]),
    ('Suppressions', [
 ('q', 0, 'stdlib', 'ignoreStandardLibrary', 'ignore warnings from files under standard library'),
 ('b', 1, 'blacklist', 'blacklist', 'ignore warnings from the list of modules\n\t\t\t'),
 ('Z', 1, 'varlist', 'variablesToIgnore', 'ignore global variables not used if name is one of these values\n\t\t\t'),
 ('E', 1, 'unusednames', 'unusedNames', 'ignore unused locals/arguments if name is one of these values\n\t\t\t'),
 ( '', 0, 'deprecated', 'deprecated', 'ignore use of deprecated modules/functions'),
     ]),
    ('Complexity', [
 ('L', 1, 'maxlines', 'maxLines', 'maximum lines in a function'),
 ('B', 1, 'maxbranches', 'maxBranches', 'maximum branches in a function'),
 ('R', 1, 'maxreturns', 'maxReturns', 'maximum returns in a function'),
 ('J', 1, 'maxargs', 'maxArgs', 'maximum # of arguments to a function'),
 ('K', 1, 'maxlocals', 'maxLocals', 'maximum # of locals in a function'),
 ('5', 1, 'maxrefs', 'maxReferences', 'maximum # of identifier references (Law of Demeter)'),
 ('m', 0, 'moduledoc', 'noDocModule', 'no module doc strings'),
 ('c', 0, 'classdoc', 'noDocClass', 'no class doc strings'),
 ('f', 0, 'funcdoc', 'noDocFunc', 'no function/method doc strings'),
     ]),
    ('Debug', [
 ( '', 0, 'rcfile', None, 'print a .pycheckrc file generated from command line args'),
 ('P', 0, 'printparse', 'printParse', 'print internal checker parse structures'),
 ('d', 0, 'debug', 'debug', 'turn on debugging for checker'),
 ('Q', 0, 'quiet', None, 'turn off all output except warnings'),
 ('V', 0, 'version', None, 'print the version of PyChecker and exit'),
     ])
)
</t>
<t tx="ekr.20040701145236.217">def init() :
    GET_OPT_VALUE = (('', ''), (':', '='),)
    shortArgs, longArgs = "", []
    for _, group in _OPTIONS :
        for opt in group:
            optStr = GET_OPT_VALUE[opt[1]]
            shortArgs = shortArgs + opt[0] + optStr[0]
            longArgs.append(opt[2] + optStr[1])
            longArgs.append('no-' + opt[2] + optStr[1])

    options = {}
    for _, group in _OPTIONS :
        for opt in group:
            shortArg, useValue, longArg, member, description = opt
            if shortArg != '' :
                options['-' + shortArg] = opt
            options['--no-' + longArg] = options['--' + longArg] = opt
            
    if 0:  ## EKR
        #print "short args..."
        #for s in shortArgs: print s
        print "long args..."
        longArgs.sort()
        for s in longArgs: print s

    return shortArgs, longArgs, options
</t>
<t tx="ekr.20040701145236.218">_SHORT_ARGS, _LONG_ARGS, _OPTIONS_DICT = init()

def _getRCfiles(filename) :
    """Return a list of .rc filenames, on Windows use the current directory
                                       on UNIX use the user's home directory
    """

    files = []
    home = os.environ.get('HOME')
    if home :
        files.append(home + os.sep + filename)
    files.append(filename)
    return files
</t>
<t tx="ekr.20040701145236.219">_RC_FILE_HEADER = '''#
# .pycheckrc file created by PyChecker v%s @ %s
#
# It should be placed in your home directory (value of $HOME).
# If $HOME is not set, it will look in the current directory.
#

'''

def outputRc(cfg) :
    output = _RC_FILE_HEADER % (_VERSION, time.ctime(time.time()))
    for name, group in _OPTIONS :
        for opt in group:
            shortArg, useValue, longArg, member, description = opt
            if member is None :
                continue
            description = string.strip(description)
            value = getattr(cfg, member)
            optStr = '# %s\n%s = %s\n\n' % (description, member, `value`)
            output = output + optStr

    return output
</t>
<t tx="ekr.20040701145236.220">        

class UsageError(Exception) :
    """Exception to indicate that the application should exit due to
       command line usage error."""
</t>
<t tx="ekr.20040701145236.221">_SUPPRESSIONS_ERR = \
'''\nWarning, error processing defaults file: %s
\%s must be a dictionary ({}) -- ignoring suppressions\n'''

def _getSuppressions(name, dict, filename) :
    
    if 0: ## EKR
        trace(filename)
        keys = dict.keys()
        keys.sort()
        for s in keys:
            print s, dict[s]

    suppressions = dict.get(name, {})
    if type(suppressions) != type({}) :
        print _SUPPRESSIONS_ERR % (filename, name)
        suppressions = {}
    return suppressions
</t>
<t tx="ekr.20040701145236.222">

class Config :
	&lt;&lt; class Config declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.223">"Hold configuration information"

</t>
<t tx="ekr.20040701145236.224">def __init__(self) :
    "Initialize configuration with default values."

    self.debug = 0
    self.quiet = 0
    self.onlyCheckInitForMembers = 0
    self.printParse = 0
    self.quixote = 0

    self.noDocModule = 0
    self.noDocClass = 0
    self.noDocFunc = 0

    self.reportAllGlobals = 0
    self.allVariablesUsed = 0
    self.privateVariableUsed = 1
    self.membersUsed = 0
    self.importUsed = 1
    self.reimportSelf = 1
    self.moduleImportErrors = 1
    self.mixImport = 1
    self.packageImportUsed = 1
    self.localVariablesUsed = 1
    self.unusedLocalTuple = 0
    self.initDefinedInSubclass = 0
    self.baseClassInitted = 1
    self.abstractClasses = 1
    self.callingAttribute = 0
    self.classAttrExists = 1
    self.namedArgs = 0
    self.returnNoneFromInit = 1
    self.unreachableCode = 0
    self.constantConditions = 1
    self.constant1 = 0
    self.stringIteration = 1
    self.inconsistentTypes = 0
    self.unpackNonSequence = 1
    self.unpackLength = 1
    self.badExceptions = 1
    self.noEffect = 1
    self.deprecated = 1
    self.modulo1 = 1
    self.isLiteral = 1
    self.stringFind = 1

    self.unusedNames = _DEFAULT_UNUSED_LIST
    self.variablesToIgnore = _DEFAULT_VARIABLE_IGNORE_LIST
    self.blacklist = _DEFAULT_BLACK_LIST
    self.ignoreStandardLibrary = 0
    self.methodArgName = 'self'
    self.classmethodArgNames = ['cls', 'klass']
    self.checkOverridenMethods = 1
    self.checkSpecialMethods = 1

    self.argumentsUsed = 1
    self.varArgumentsUsed = 1
    self.ignoreSelfUnused = 0
    self.redefiningFunction = 1

    self.maxLines = 200
    self.maxBranches = 50
    self.maxReturns = 10
    self.maxArgs = 10
    self.maxLocals = 40
    self.maxReferences = 5

    self.slots = 1
    self.emptySlots = 1
    self.classicProperties = 1
    self.checkObjectAttrs = 1
    self.checkReturnValues = 1
    self.checkImplicitReturns = 1
    self.intDivide = 1
    self.shadows = 1
    self.shadowBuiltins = 1
    self.unaryPositive = 1
    self.modifyDefaultValue = 1
    self.usesExec = 0
    self.usesInput = 1
    self.constAttr = 1
</t>
<t tx="ekr.20040701145236.225">def loadFile(self, filename) :
    suppressions = {}
    suppressionRegexs = {}
    try :
        tmpGlobal, dict = {}, {}
        execfile(filename, tmpGlobal, dict)
        for key, value in dict.items() :
            if self.__dict__.has_key(key) :
                self.__dict__[key] = value
            elif key not in ('suppressions', 'suppressionRegexs') and \
                 key[0] != '_':
                print "Warning, option (%s) doesn't exist, ignoring" % key

        suppressions = _getSuppressions('suppressions', dict, filename)
        regexs = _getSuppressions('suppressionRegexs', dict, filename)
        for regex_str in regexs.keys() :
            regex = re.compile(regex_str)
            suppressionRegexs[regex] = regexs[regex_str]
    except IOError :
        pass       # ignore if no file
    except Exception, detail:
        print "Warning, error loading defaults file:", filename, detail
    return suppressions, suppressionRegexs
</t>
<t tx="ekr.20040701145236.226">def loadFiles(self, filenames, oldSuppressions = None) :
    if oldSuppressions is None :
        oldSuppressions = ({}, {})
    suppressions = oldSuppressions[0]
    suppressionRegexs = oldSuppressions[1]
    for filename in filenames:
        updates = self.loadFile(filename)
        suppressions.update(updates[0])
        suppressionRegexs.update(updates[1])
    return suppressions, suppressionRegexs
</t>
<t tx="ekr.20040701145236.227">def processArgs(self, argList, otherConfigFiles = None) :
    
    # trace(argList)

    try :
        args, files = getopt.getopt(argList, _SHORT_ARGS, _LONG_ARGS)
    except getopt.error, detail :
        raise UsageError, detail

    quiet = self.quiet
    if otherConfigFiles is None:
        otherConfigFiles = []
    for arg, value in args :
        shortArg, useValue, longArg, member, description = _OPTIONS_DICT[arg]
        if member == None :
            # FIXME: this whole block is a hack
            if longArg == 'rcfile' :
                sys.stdout.write(outputRc(self))
                continue
            elif longArg == 'quiet' :
                quiet = 1
                continue
            elif longArg == 'quixote' :
                import quixote
                quixote.enable_ptl()
                self.quixote = 1
                continue
            elif longArg == 'config' :
                otherConfigFiles.append(value)
                continue
            elif longArg == 'version' :
                # FIXME: it would be nice to define this in only one place
                print _VERSION
                sys.exit(0)

            self.noDocModule = 0
            self.noDocClass = 0
            self.noDocFunc = 0
            if longArg == 'errors' :
                self.__dict__.update(errors_only())
            elif longArg == 'complexity' :
                self.__dict__.update(errors_only(2))
        elif value  :
            newValue = value
            memberType = type(getattr(self, member))
            if memberType == type(0) :
                newValue = int(newValue)
            elif memberType == type([]) :
                newValue = string.split(newValue, ',')
            elif memberType == type('') and \
                 newValue[0] in '\'"':
                    try:
                        newValue = eval(newValue)
                    except:
                        msg = 'Invalid option parameter: %s for %s\n' % \
                              (`newValue`, arg)
                        sys.stderr.write(msg)
            setattr(self, member, newValue)
        elif arg[0:2] == '--' :
            setattr(self, member, arg[2:5] != 'no-')
        else :
            # for shortArgs we only toggle
            setattr(self, member, not getattr(self, member))

    self.quiet = quiet
    if self.variablesToIgnore.count(CHECKER_VAR) &lt;= 0 :
        self.variablesToIgnore.append(CHECKER_VAR)

    return files
</t>
<t tx="ekr.20040701145236.228">def errors_only(complexity = 0) :
    "Return {} of Config with all warnings turned off"
    dict = Config().__dict__
    for k, v in dict.items() :
        if type(v) == type(0) and v &gt;= complexity and not _ERRORS.has_key(k):
            dict[k] = 0
    return dict
</t>
<t tx="ekr.20040701145236.229">def printArg(shortArg, longArg, description, defaultValue, useValue) :
    defStr = ''
    shortArgStr = '   '
    if shortArg:
        shortArgStr = '-%s,' % shortArg

    if defaultValue != None :
        if not useValue :
            if defaultValue :
                defaultValue = 'on'
            else :
                defaultValue = 'off'
        defStr = ' [%s]' % defaultValue
    args = "%s --%s" % (shortArgStr, longArg)
    print "  %-18s %s%s" % (args, description, defStr)
</t>
<t tx="ekr.20040701145236.230">def usage(cfg = None) :
    print "Usage for: checker.py [options] PACKAGE ...\n"
    print "    PACKAGEs can be a python package, module or filename\n"
    print "Long options can be preceded with no- to turn off (e.g., no-namedargs)\n"
    print "Category"
    print "  Options:           Change warning for ... [default value]"
    
    if cfg is None :
        cfg = Config()
    for name, group in _OPTIONS :
        print
        print name + ":"
        for opt in group:  
            shortArg, useValue, longArg, member, description = opt
            defValue = None
            if member != None :
                defValue = cfg.__dict__[member]

            printArg(shortArg, longArg, description, defValue, useValue)
</t>
<t tx="ekr.20040701145236.231">def setupFromArgs(argList) :
    "Returns (Config, [ file1, file2, ... ]) from argList"

    cfg = Config()
    try :
        suppressions = cfg.loadFiles(_getRCfiles(_RC_FILE))
        otherConfigFiles = []
        files = cfg.processArgs(argList, otherConfigFiles)
        if otherConfigFiles:
            suppressions = cfg.loadFiles(otherConfigFiles, suppressions)
        return cfg, files, suppressions
    except UsageError :
        usage(cfg)
        raise
</t>
<t tx="ekr.20040701145236.232">@ignore
@language python
&lt;&lt; function declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040701145236.233">#!/usr/bin/env python

# Copyright (c) 2001-2002, MetaSlash Inc.  All rights reserved.

"""
Object to hold information about functions.
Also contain a pseudo Python function object
"""

import string

_ARGS_ARGS_FLAG = 4
_KW_ARGS_FLAG = 8
_CO_FLAGS_MASK = _ARGS_ARGS_FLAG + _KW_ARGS_FLAG

</t>
<t tx="ekr.20040701145236.234">class _ReturnValues:
	@others
</t>
<t tx="ekr.20040701145236.235">def __init__(self):
    self.returnValues = None
</t>
<t tx="ekr.20040701145236.236">def returnsNoValue(self):
    returnValues = self.returnValues
    # if unset, we don't know
    if returnValues is None:
        return 0
    # it's an empty list, that means no values
    if not returnValues:
        return 1
    # make sure each value is not None
    for rv in returnValues:
        if not rv[1].isNone():
            return 0
    return returnValues[-1][1].isImplicitNone()
</t>
<t tx="ekr.20040701145236.237">
class FakeCode :
	&lt;&lt; class FakeCode declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.238">"This is a holder class for code objects (so we can modify them)"
</t>
<t tx="ekr.20040701145236.239">def __init__(self, code, varnames = None) :
    for attr in dir(code):
        try:
            setattr(self, attr, getattr(code, attr))
        except:
            pass
    if varnames is not None:
        self.co_varnames = varnames
</t>
<t tx="ekr.20040701145236.240">
class FakeFunction(_ReturnValues):
	&lt;&lt; class FakeFunction declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.241">"This is a holder class for turning code at module level into a function"

</t>
<t tx="ekr.20040701145236.242">def __init__(self, name, code, func_globals = {}, varnames = None) :
    _ReturnValues.__init__(self)
    self.func_name = self.__name__ = name
    self.func_doc  = self.__doc__  = "ignore"

    self.func_code = FakeCode(code, varnames)
    self.func_defaults = None
    self.func_globals = func_globals
</t>
<t tx="ekr.20040701145236.243">def __str__(self):
    return self.func_name
</t>
<t tx="ekr.20040701145236.244">def __repr__(self):
    return '%s from %s' % (self.func_name, self.func_code.co_filename)
</t>
<t tx="ekr.20040701145236.245">
class Function(_ReturnValues):
	&lt;&lt; class Function declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.246">"Class to hold all information about a function"

</t>
<t tx="ekr.20040701145236.247">def __init__(self, function, isMethod=0):
    _ReturnValues.__init__(self)
    self.function = function
    self.isMethod = isMethod
    self.minArgs = self.maxArgs = function.func_code.co_argcount
    if function.func_defaults is not None :
        self.minArgs = self.minArgs - len(function.func_defaults)
    # if function uses *args, there is no max # args
    try:
        if function.func_code.co_flags &amp; _ARGS_ARGS_FLAG != 0 :
            self.maxArgs = None
        self.supportsKW = function.func_code.co_flags &amp; _KW_ARGS_FLAG
    except AttributeError:
        # this happens w/Zope
        self.supportsKW = 0
</t>
<t tx="ekr.20040701145236.248">def __str__(self):
    return self.function.func_name
</t>
<t tx="ekr.20040701145236.249">def __repr__(self):
    return '%s from %s:%d' % (self.function.func_name,
                              self.function.func_code.co_filename,
                              self.function.func_code.co_firstlineno)
</t>
<t tx="ekr.20040701145236.250">def arguments(self) :
    numArgs = self.function.func_code.co_argcount
    if self.maxArgs is None :
        numArgs = numArgs + 1
    if self.supportsKW :
        numArgs = numArgs + 1
    return self.function.func_code.co_varnames[:numArgs]
</t>
<t tx="ekr.20040701145236.251">def isParam(self, name) :
    return name in self.arguments()
</t>
<t tx="ekr.20040701145236.252">def isStaticMethod(self):
    return self.isMethod and isinstance(self.function, type(create_fake))
</t>
<t tx="ekr.20040701145236.253">def isClassMethod(self):
    try:
        return self.isMethod and self.function.im_self is not None
    except AttributeError:
        return 0
</t>
<t tx="ekr.20040701145236.254">def defaultValue(self, name) :
    func_code = self.function.func_code
    arg_names = list(func_code.co_varnames[:func_code.co_argcount])
    i = arg_names.index(name)
    if i &lt; self.minArgs :
        raise ValueError
    return self.function.func_defaults[i - self.minArgs]
</t>
<t tx="ekr.20040701145236.255">def varArgName(self) :
    if self.maxArgs is not None :
        return None
    func_code = self.function.func_code
    return func_code.co_varnames[func_code.co_argcount]
</t>
<t tx="ekr.20040701145236.256">def create_fake(name, code, func_globals = {}, varnames = None) :
    return Function(FakeFunction(name, code, func_globals, varnames))
</t>
<t tx="ekr.20040701145236.257">def create_from_file(file, filename, module) :
    # Make sure the file is at the beginning
    #   if python compiled the file, it will be at the end
    file.seek(0)

    # Read in the source file, see py_compile.compile() for games w/src str
    codestr = file.read()
    codestr = string.replace(codestr, "\r\n", "\n")
    codestr = string.replace(codestr, "\r", "\n")
    if codestr and codestr[-1] != '\n' :
        codestr = codestr + '\n'
    code = compile(codestr, filename, 'exec')
    return Function(FakeFunction('__main__', code, module.__dict__))
</t>
<t tx="ekr.20040701145236.258">def _co_flags_equal(o1, o2) :
    return (o1.co_flags &amp; _CO_FLAGS_MASK) == (o2.co_flags &amp; _CO_FLAGS_MASK)
</t>
<t tx="ekr.20040701145236.259">def same_signature(func, object) :
    '''Return a boolean value if the &lt;func&gt; has the same signature as
       a function with the same name in &lt;object&gt; (ie, an overriden method)'''

    try :
        baseMethod = getattr(object, func.func_name)
        base_func_code = baseMethod.im_func.func_code
    except AttributeError :
        return 1

    return _co_flags_equal(base_func_code, func.func_code) and \
           base_func_code.co_argcount == func.func_code.co_argcount
</t>
<t tx="ekr.20040701145236.260">@ignore
@language python
#!/usr/bin/env python

# Copyright (c) 2001-2004, MetaSlash Inc.  All rights reserved.

"""
Warning Messages for PyChecker
"""

CHECKER_BROKEN = "INTERNAL ERROR -- STOPPED PROCESSING FUNCTION --\n\t%s"
INVALID_CHECKER_ARGS = "Invalid warning suppression arguments --\n\t%s"

NO_MODULE_DOC = "No module doc string"
NO_CLASS_DOC = "No doc string for class %s"
NO_FUNC_DOC = "No doc string for function %s"

VAR_NOT_USED = "Variable (%s) not used"
IMPORT_NOT_USED = "Imported module (%s) not used"
UNUSED_LOCAL = "Local variable (%s) not used"
UNUSED_PARAMETER = "Parameter (%s) not used"
UNUSED_MEMBERS = "Members (%s) not used in class (%s)"
NO_LOCAL_VAR = "No local variable (%s)"
VAR_USED_BEFORE_SET = "Variable (%s) used before being set"

REDEFINING_ATTR = "Redefining attribute (%s) original line (%d)"

MODULE_IMPORTED_AGAIN = "Module (%s) re-imported"
MODULE_MEMBER_IMPORTED_AGAIN = "Module member (%s) re-imported"
MODULE_MEMBER_ALSO_STAR_IMPORTED = "Module member (%s) re-imported with *"
MIX_IMPORT_AND_FROM_IMPORT = "Using import and from ... import for (%s)"
IMPORT_SELF = "Module (%s) imports itself"

NO_METHOD_ARGS = "No method arguments, should have %s as argument"
SELF_NOT_FIRST_ARG = "%s is not first %smethod argument"
SELF_IS_ARG = "self is argument in %s"
RETURN_FROM_INIT = "Cannot return a value from __init__"
NO_CTOR_ARGS = "Instantiating an object with arguments, but no constructor"

GLOBAL_DEFINED_NOT_DECLARED = "Global variable (%s) not defined in module scope"
INVALID_GLOBAL = "No global (%s) found"
INVALID_METHOD = "No method (%s) found"
INVALID_CLASS_ATTR = "No class attribute (%s) found"
INVALID_SET_CLASS_ATTR = "Setting class attribute (%s) not set in __init__"
INVALID_MODULE_ATTR = "No module attribute (%s) found"

LOCAL_SHADOWS_GLOBAL = "Local variable (%s) shadows global defined on line %d"
VARIABLE_SHADOWS_BUILTIN = "(%s) shadows builtin"
USING_METHOD_AS_ATTR = "Using method (%s) as an attribute (not invoked)"
OBJECT_HAS_NO_ATTR = "Object (%s) has no attribute (%s)"
METHOD_SIGNATURE_MISMATCH = "Overridden method (%s) doesn't match signature in class (%s)"

INVALID_ARG_COUNT1 = "Invalid arguments to (%s), got %d, expected %d"
INVALID_ARG_COUNT2 = "Invalid arguments to (%s), got %d, expected at least %d"
INVALID_ARG_COUNT3 = "Invalid arguments to (%s), got %d, expected between %d and %d"
FUNC_DOESNT_SUPPORT_KW = "Function (%s) doesn't support **kwArgs"
FUNC_DOESNT_SUPPORT_KW_ARG = "Function (%s) doesn't support **kwArgs for name (%s)"
FUNC_USES_NAMED_ARGS = "Function (%s) uses named arguments"

BASE_CLASS_NOT_INIT = "Base class (%s) __init__() not called"
NO_INIT_IN_SUBCLASS = "No __init__() in subclass (%s)"
METHODS_NEED_OVERRIDE = "Methods (%s) in %s need to be overridden in a subclass"

FUNC_TOO_LONG = "Function (%s) has too many lines (%d)"
TOO_MANY_BRANCHES = "Function (%s) has too many branches (%d)"
TOO_MANY_RETURNS = "Function (%s) has too many returns (%d)"
TOO_MANY_ARGS = "Function (%s) has too many arguments (%d)"
TOO_MANY_LOCALS = "Function (%s) has too many local variables (%d)"
TOO_MANY_REFERENCES = 'Law of Demeter violated, more than %d references for (%s)'

IMPLICIT_AND_EXPLICIT_RETURNS = "Function returns a value and also implicitly returns None"
INCONSISTENT_RETURN_TYPE = "Function return types are inconsistent"
INCONSISTENT_TYPE = "Variable (%s) already has types %s and set to %s"
CODE_UNREACHABLE = "Code appears to be unreachable"
CONSTANT_CONDITION = "Using a conditional statement with a constant value (%s)"
STRING_ITERATION = "Iterating over a string (%s)"
DONT_RETURN_NONE = "%s should not return None, raise an exception if not found"
IS_LITERAL = "Using is%s %s, may not always work"
INVALID_FORMAT = "Invalid format string, problem starts near: '%s'"
INVALID_FORMAT_COUNT = "Format string argument count (%d) doesn't match arguments (%d)"
TOO_MANY_STARS_IN_FORMAT = "Too many *s in format flags"
USING_STAR_IN_FORMAT_MAPPING = "Can't use * in formats when using a mapping (dictionary), near: '%s'"
CANT_MIX_MAPPING_IN_FORMATS = "Can't mix tuple/mapping (dictionary) formats in same format string"

INTEGER_DIVISION = "Using integer division (%s / %s) may return integer or float"
MODULO_1 = "... % 1 may be constant"
USING_TUPLE_ACCESS_TO_LIST = "Using a tuple instead of slice as list accessor for (%s)"
BOOL_COMPARE = "Comparisons with %s are not necessary and may not work as expected"
SHOULDNT_ASSIGN_BUILTIN = "Should not assign to %s, it is (or will be) a builtin"
SHOULDNT_ASSIGN_NAME = "Should not assign to %s, it is similar to builtin %s"
SET_VAR_TO_ITSELF = "Setting %s to itself has no effect"
MODIFY_VAR_NOOP = "%s %s %s has no effect"
DIVIDE_VAR_BY_ITSELF = "%s %s %s is always 1 or ZeroDivisionError"
XOR_VAR_WITH_ITSELF = "%s %s %s is always 0"

STMT_WITH_NO_EFFECT = "Operator (%s) doesn't exist, statement has no effect"
POSSIBLE_STMT_WITH_NO_EFFECT = "Statement appears to have no effect"
UNARY_POSITIVE_HAS_NO_EFFECT = "Unary positive (+) usually has no effect"
LIST_APPEND_ARGS = "[].append() only takes 1 argument in Python 1.6 and above for (%s)"

LOCAL_DELETED = "(%s) cannot be used after being deleted on line %d"
LOCAL_ALREADY_DELETED = "Local variable (%s) has already been deleted on line %d"
VAR_DELETED_BEFORE_SET = "Variable (%s) deleted before being set"

CATCH_BAD_EXCEPTION = "Catching a non-Exception object (%s)"
CATCH_STR_EXCEPTION = "Catching string exceptions are deprecated (%s)"
RAISE_BAD_EXCEPTION = "Raising an exception on a non-Exception object (%s)"
RAISE_STR_EXCEPTION = "Raising string exceptions are deprecated (%s)"
SET_EXCEPT_TO_BUILTIN = "Setting exception to builtin (%s), consider () around exceptions"
USING_KEYWORD = "Using identifier (%s) which will become a keyword in version %s"
MODIFYING_DEFAULT_ARG = "Modifying parameter (%s) with a default value may have unexpected consequences"
USING_SELF_IN_REPR = "Using `self` in __repr__ method"
USING_NONE_RETURN_VALUE = "Using the return value from (%s) which is always None"
WRONG_UNPACK_SIZE = "Unpacking %d values into %d variables"
WRONG_UNPACK_FUNCTION = "Unpacking function (%s) which returns %d values into %d variables"
UNPACK_NON_SEQUENCE = "Unpacking a non-sequence (%s) of type %s"

NOT_SPECIAL_METHOD = "%s is not a special method"
USING_COERCE_IN_NEW_CLASS = "Using __coerce__ in new-style class (%s) will not work for binary operations"
USING_GETATTRIBUTE_IN_OLD_CLASS = "Using __getattribute__ in old-style class (%s) does not work"
USING_PROPERTIES_IN_CLASSIC_CLASS = "Using property (%s) in classic class %s may not work"
USING_SLOTS_IN_CLASSIC_CLASS = "Using __slots__ in classic class %s has no effect, consider deriving from object"
EMPTY_SLOTS = "__slots__ are empty in %s"

USES_EXEC = "Using the exec statement"
USES_GLOBAL_EXEC = "Using the exec statement in global namespace"
USES_INPUT = "Using input() is a security problem, consider using raw_input()"

USING_DEPRECATED_MODULE = "%s module is deprecated"
USING_DEPRECATED_ATTR = "%s is deprecated"
USING_INSECURE_FUNC = "%s() is a security problem"
USE_INSTEAD = ", consider using %s"

USES_CONST_ATTR = "Passing a constant string to %s, consider direct reference"

BAD_STRING_FIND = "string.find() returns an integer, consider checking &gt;= 0 or &lt; 0 for not found"
</t>
<t tx="ekr.20040701145236.261">@ignore
@language python
&lt;&lt; OP declarations &gt;&gt;
@others
    name = Name()
</t>
<t tx="ekr.20040701145236.262">#!/usr/bin/env python

# Copyright (c) 2001-2004, MetaSlash Inc.  All rights reserved.

"""
Python byte code operations.

Very similar to the dis module, but dis does not exist in Jython,
so recreate the small portion we need here.
"""

</t>
<t tx="ekr.20040701145236.263">def LINE_NUM(op):              return op == 127
</t>
<t tx="ekr.20040701145236.264">def LOAD_GLOBAL(op):           return op == 116
</t>
<t tx="ekr.20040701145236.265">def LOAD_CONST(op):            return op == 100
</t>
<t tx="ekr.20040701145236.266">def LOAD_FAST(op):             return op == 124
</t>
<t tx="ekr.20040701145236.267">def LOAD_ATTR(op):             return op == 105
</t>
<t tx="ekr.20040701145236.268">def STORE_ATTR(op):            return op == 95
</t>
<t tx="ekr.20040701145236.269">def POP_TOP(op):               return op == 1
</t>
<t tx="ekr.20040701145236.270">def IMPORT_FROM(op):           return op == 108
</t>
<t tx="ekr.20040701145236.271">def IMPORT_STAR(op):           return op == 84
</t>
<t tx="ekr.20040701145236.272">def UNARY_POSITIVE(op):        return op == 10
</t>
<t tx="ekr.20040701145236.273">def UNARY_NEGATIVE(op):        return op == 11
</t>
<t tx="ekr.20040701145236.274">def UNARY_INVERT(op):          return op == 15
</t>
<t tx="ekr.20040701145236.275">def RETURN_VALUE(op):          return op == 83
</t>
<t tx="ekr.20040701145236.276">def JUMP_FORWARD(op):          return op == 110
</t>
<t tx="ekr.20040701145236.277">def JUMP_ABSOLUTE(op):         return op == 113
</t>
<t tx="ekr.20040701145236.278">def FOR_ITER(op):              return op == 93
</t>
<t tx="ekr.20040701145236.279">def FOR_LOOP(op):              return op == 114
</t>
<t tx="ekr.20040701145236.280">def SETUP_LOOP(op):            return op == 120
</t>
<t tx="ekr.20040701145236.281">def BREAK_LOOP(op):            return op == 80
</t>
<t tx="ekr.20040701145236.282">def RAISE_VARARGS(op):         return op == 130
</t>
<t tx="ekr.20040701145236.283">def POP_BLOCK(op):             return op == 87
</t>
<t tx="ekr.20040701145236.284">def END_FINALLY(op):           return op == 88
</t>
<t tx="ekr.20040701145236.285">def UNPACK_SEQUENCE(op) :
    "Deal w/Python 1.5.2 (UNPACK_[LIST|TUPLE]) or 2.0 (UNPACK_SEQUENCE)"
    return op in (92, 93,)
</t>
<t tx="ekr.20040701145236.286">def IS_CONDITIONAL_JUMP(op):
    return op in (111, 112)
</t>
<t tx="ekr.20040701145236.287">def IS_NOT(op):
    return op == 12
</t>
<t tx="ekr.20040701145236.288">HAVE_ARGUMENT = 90
EXTENDED_ARG = 143

_HAS_NAME = (90, 91, 95, 96, 97, 98, 101, 105, 107, 108, 116,)
_HAS_LOCAL = (124, 125, 126,)
_HAS_CONST = (100,)
_HAS_COMPARE = (106,)
_HAS_JREL = (110, 111, 112, 114, 120, 121, 122,)
_HAS_JABS = (113, 119,)

_CMP_OP =  ('&lt;', '&lt;=', '==', '!=', '&gt;', '&gt;=', 'in', 'not in', 'is',
            'is not', 'exception match', 'BAD')

EXCEPT_COMPARISON = 10
IS_COMPARISON = 8

def getOperand(op, func_code, oparg) :
    if op in _HAS_NAME :
        return func_code.co_names[oparg]
    elif op in _HAS_LOCAL :
        return func_code.co_varnames[oparg]
    elif op in _HAS_CONST :
        return func_code.co_consts[oparg]
    elif op in _HAS_COMPARE :
        return _CMP_OP[oparg]
    return None
</t>
<t tx="ekr.20040701145236.289">def getLabel(op, oparg, i) :
    if op in _HAS_JREL :
        return i + oparg
    elif op in _HAS_JABS :
        return oparg
    return None
</t>
<t tx="ekr.20040701145236.290">def getInfo(code, index, extended_arg) :
    """Returns (op, oparg, index, extended_arg) based on code
       this is a helper function while looping through byte code,
       refer to the standard module dis.disassemble() for more info"""

    # get the operation we are performing
    op = ord(code[index])
    index = index + 1
    if op &gt;= HAVE_ARGUMENT :
        # get the argument to the operation
        oparg = ord(code[index]) + ord(code[index+1])*256 + extended_arg
        index = index + 2
        extended_arg = 0
        if op == EXTENDED_ARG :
            extended_arg = oparg * 65536L
    else :
        oparg, extended_arg = 0, 0
    return op, oparg, index, extended_arg
</t>
<t tx="ekr.20040701145236.291">def initFuncCode(func) :
    """Returns (func_code, code, i, maxCode, extended_arg) based on func,
       this is a helper function to setup looping through byte code"""

    func_code = func.func_code
    code = func_code.co_code
    return func_code, code, 0, len(code), 0
</t>
<t tx="ekr.20040701145236.292">def conditional(op):
    "returns true if the code results in conditional execution"
    return op in [83,                   # return
                  93,                   # for_iter
                  111, 112, 114,        # conditional jump
                  121,                  # setup_exec
                  130                   # raise_varargs
                  ]
</t>
<t tx="ekr.20040701145236.293">
# this code is here for debugging purposes.
# Jython doesn't support dis, so don't rely on it
try :
    import dis
    name = dis.opname
except ImportError :
    class Name:
	&lt;&lt; class Name declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.294">'Turn name[x] into x'
</t>
<t tx="ekr.20040701145236.295">def __getitem__(self, x):
    return str(x)
</t>
<t tx="ekr.20040701145236.296">@ignore
@language python
&lt;&lt; options declarations &gt;&gt;
@others


if __name__=='__main__':
    dirs = os.path.join(os.path.split(os.getcwd())[:-1])
    sys.path.append(dirs[0])
    tk = Tkinter.Tk()
    tk.title('PyChecker')
    ConfigDialog(tk).main()
</t>
<t tx="ekr.20040701145236.297">"Main module for running pychecker a Tkinter GUI for all the options"

import sys
import os
import Tkinter, tkFileDialog

from OptionTypes import *
from string import capitalize, strip, rstrip, split

import Config

MAX_SUBBOX_ROWS = 8
MAX_BOX_COLS = 3
PAD = 10
EDITOR = "xterm -e vi -n +%(line)d %(file)s"
if sys.platform == 'win32':
    EDITOR = "notepad %(file)s"

</t>
<t tx="ekr.20040701145236.298">def col_weight(grid):
    "Set column weights so that sticky grid settings actually work"
    unused, col = grid.grid_size()
    for c in range(col):
        grid.columnconfigure(c, weight=1)
</t>
<t tx="ekr.20040701145236.299">def spawn(cmd_list):
    try:
        if os.fork():
            try:
                os.execvp(cmd_list[0], cmd_list)
            finally:
                sys.exit()
    except AttributeError:
        os.execvp(cmd_list[0], cmd_list)
</t>
<t tx="ekr.20040701145236.300">def edit(file, line):
    "Fire up an external editor to see the file at the given line"
    unused = file, line
    list = split(EDITOR)
    cmd_list = []
    for word in list:
        cmd_list.append(word % locals())
    spawn(cmd_list)
</t>
<t tx="ekr.20040701145236.301">def closeCB():
    sys.exit(0)
</t>
<t tx="ekr.20040701145236.302">
class Results:
	&lt;&lt; class Results declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.303">"Display the warnings produced by checker"

</t>
<t tx="ekr.20040701145236.304">def __init__(self, w):
    self.top = Tkinter.Toplevel(w, name="results")
    self.top.transient(w)
    self.top.bind('&lt;Return&gt;', self.hide)
    self.top.bind('&lt;Escape&gt;', self.hide)
    self.text = Tkinter.Text(self.top, name="text")
    self.text.grid()
    self.text.bind('&lt;Double-Button-1&gt;', self.showFile)
    close = Tkinter.Button(self.top,
                        name="close",
                        default=Tkinter.ACTIVE,
                        command=self.hide)
    close.grid()
    self.text.update_idletasks()
</t>
<t tx="ekr.20040701145236.305">def show(self, text):
    self.text.delete("0.1", "end")
    self.text.insert("0.1", text)
    self.top.deiconify()
    self.top.lift()
</t>
<t tx="ekr.20040701145236.306">def hide(self, *unused):
    self.top.withdraw()
</t>
<t tx="ekr.20040701145236.307">def line(self):
    return split(self.text.index(Tkinter.CURRENT), ".")[0]
</t>
<t tx="ekr.20040701145236.308">def showFile(self, unused):
    import re
    line = self.line()
    text = self.text.get(line + ".0", line + ".end")
    text = rstrip(text)
    result = re.search("(.*):([0-9]+):", text)
    if result:
        file, line = result.groups()
        edit(file, int(line))
        self.text.after(0, self.selectLine)
</t>
<t tx="ekr.20040701145236.309">def selectLine(self):
    line = self.line()
    self.text.tag_remove(Tkinter.SEL, "1.0", Tkinter.END)
    self.text.tag_add(Tkinter.SEL, line + ".0", line + ".end")
</t>
<t tx="ekr.20040701145236.310">
class ConfigDialog:
	&lt;&lt; class ConfigDialog declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.311">"Dialog for editing options"

</t>
<t tx="ekr.20040701145236.312">def __init__(self, tk):
    self._tk = tk
    self._cfg, _, _ = Config.setupFromArgs(sys.argv)

    self._help = None
    self._optMap = {}
    self._opts = []
    self._file = Tkinter.StringVar()
    self._results = None
</t>
<t tx="ekr.20040701145236.313">if len(sys.argv) &gt; 1:
        self._file.set(sys.argv[1])

    for name, group in Config._OPTIONS:
      opts = []
      for _, useValue, longArg, member, description in group:
          value = None
          if member:
              value = getattr(self._cfg, member)
              description = member + ": " + capitalize(description)
              description = strip(description)
          tk.option_add('*' + longArg + ".help", description)
          if useValue:
              if type(value) == type([]):
                  field = List(longArg, value)
              elif type(value) == type(1):
                  field = Number(longArg, int(value))
              elif type(value) == type(''):
                  field = Text(longArg, value)
              else:
                  field = Boolean(longArg, value)
          else:
              field = Boolean(longArg, value)
          self._optMap[longArg] = field
          opts.append(field)
      self._opts.append( (name, opts))

def _add_fields(self, w, opts):
    count = 0
    for opt in opts:
        f = opt.field(w)
        c, r = divmod(count, MAX_SUBBOX_ROWS)
        f.grid(row=r, column=c, sticky=Tkinter.NSEW)
        count = count + 1
</t>
<t tx="ekr.20040701145236.314">def _add_group(self, w, name, opts):
    colFrame = Tkinter.Frame(w)
    
    label = Tkinter.Label(colFrame, text=name + ":")
    label.grid(row=0, column=0, sticky=Tkinter.NSEW)
    
    gframe = Tkinter.Frame(colFrame, relief=Tkinter.GROOVE, borderwidth=2)
    gframe.grid(row=1, column=0, sticky=Tkinter.NSEW)
    self._add_fields(gframe, opts)
    
    label = Tkinter.Label(colFrame)
    label.grid(row=2, column=0, sticky=Tkinter.NSEW)
    colFrame.rowconfigure(2, weight=1)
    return colFrame
</t>
<t tx="ekr.20040701145236.315">def main(self):
    frame = Tkinter.Frame(self._tk, name="opts")
    frame.grid()
    self._tk.option_readfile('Options.ad')
    self._fields = {}
    row, col = 0, 0
    rowFrame = Tkinter.Frame(frame)
    rowFrame.grid(row=row)
    row = row + 1
    for name, opts in self._opts:
        w = self._add_group(rowFrame, name, opts)
        w.grid(row=row, column=col, sticky=Tkinter.NSEW, padx=PAD)
        col = col + 1
        if col &gt;= MAX_BOX_COLS:
            col_weight(rowFrame)
            rowFrame=Tkinter.Frame(frame)
            rowFrame.grid(row=row, sticky=Tkinter.NSEW)
            col = 0
            row = row + 1
    col_weight(rowFrame)

    self._help = Tkinter.Label(self._tk, name="helpBox")
    self._help.grid(row=row)
    self._help.config(takefocus=0)
    buttons = Tkinter.Frame(self._tk, name="buttons")
    ok = Tkinter.Button(buttons, name="ok", command=self.ok, default=Tkinter.ACTIVE)
    ok.grid(row=row, column=0)
    default = Tkinter.Button(buttons, name="default", command=self.default)
    default.grid(row=row, column=1)
    close = Tkinter.Button(buttons, name="close", command=closeCB)
    close.grid(row=row, column=2)
    buttons.grid()

    f = Tkinter.Frame(self._tk, name="fileStuff")
    Tkinter.Button(f, name="getfile", command=self.file).grid(row=0, column=1)
    fileEntry = Tkinter.Entry(f, name="fname", textvariable=self._file)
</t>
<t tx="ekr.20040701145236.316">fileEntry.grid(row=0, column=2)
    Tkinter.Button(f, name="check", command=self.check).grid(row=0, column=3)
    f.grid(sticky=Tkinter.EW)
    
    self._tk.bind_all('&lt;FocusIn&gt;', self.focus)
    self._tk.bind_all('&lt;Enter&gt;', self.focus)
    self._tk.bind_all('&lt;ButtonPress&gt;', self.click)
    fileEntry.bind('&lt;Return&gt;', self.check)
    self._tk.mainloop()

#
# Callbacks
#

def help(self, w):
    if type(w) == type(''):         # occurs with file dialog...
        return
    if self._help == w:             # ignore help events on help...
        return
    help = w.option_get("help", "help")
    self._help.configure(text=help)
</t>
<t tx="ekr.20040701145236.317">def focus(self, ev):
    self.help(ev.widget)
</t>
<t tx="ekr.20040701145236.318">def click(self, ev):
    self.help(ev.widget)
</t>
<t tx="ekr.20040701145236.319">def ok(self):
    opts = []
    # Pull command-line args
    for _, group in self._opts:
        for opt in group:
            arg = opt.arg()
            if arg:
                opts.append(arg)

    # Calculate config
    self._cfg, _, _ = Config.setupFromArgs(opts)

    # Set controls based on new config
    for _, group in Config._OPTIONS:
        for _, _, longArg, member, _ in group:
            if member:
                self._optMap[longArg].set(getattr(self._cfg, member))
</t>
<t tx="ekr.20040701145236.320">def default(self):
    self._cfg, _, _ = Config.setupFromArgs(sys.argv)
    for _, group in Config._OPTIONS:
        for _, _, longArg, member, _ in group:
            if member:
                self._optMap[longArg].set(getattr(self._cfg, member))
            else:
                self._optMap[longArg].set(0)
</t>
<t tx="ekr.20040701145236.321">def file(self):
    self._file.set(tkFileDialog.askopenfilename())
</t>
<t tx="ekr.20040701145236.322">def check(self, *unused):
    import checker
    import StringIO
    
    self.ok()                       # show effect of all settings

    checker._allModules = {}
    warnings = checker.getWarnings([self._file.get()], self._cfg)
    capture = StringIO.StringIO()
    
    if not self._results:
        self._results = Results(self._help)
    checker._printWarnings(warnings, capture)

    value = strip(capture.getvalue())
    if not value:
        value = "None"
    self._results.show(value)
</t>
<t tx="ekr.20040701145236.323">@ignore
@language python
&lt;&lt; OptionTypes declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040701145236.324">import Tkinter

</t>
<t tx="ekr.20040701145236.325">def bool(value):
    if value:
        return 1
    return 0
</t>
<t tx="ekr.20040701145236.326">
class Base:
	&lt;&lt; class Base declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.327">"Base class for all OptionTypes"

</t>
<t tx="ekr.20040701145236.328">def __init__(self, name, default):
    self._name = name
    self._default = default
    self._var = None
</t>
<t tx="ekr.20040701145236.329">def name(self):
    return self._name
</t>
<t tx="ekr.20040701145236.330">def set(self, value):
    self._var.set(value)
</t>
<t tx="ekr.20040701145236.331">
class Boolean(Base):
	&lt;&lt; class Boolean declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.332">"A option type for editing boolean values"

</t>
<t tx="ekr.20040701145236.333">def __init__(self, name, default):
    Base.__init__(self, name, default)
</t>
<t tx="ekr.20040701145236.334">def field(self, w):
    self._var = Tkinter.BooleanVar()
    if self._default:
        self._var.set(1)
    else:
        self._var.set(0)
    frame = Tkinter.Frame(w, name = self._name + "Frame")
    result = Tkinter.Checkbutton(frame,
                                 name=self._name,
                                 text=self._name,
                                 variable=self._var)
    result.grid(sticky=Tkinter.W)
    frame.columnconfigure(0, weight=1)
    return frame
</t>
<t tx="ekr.20040701145236.335">def arg(self):
    if bool(self._var.get()) != bool(self._default):
        if bool(self._var.get()):
            return "--" + self._name
        return "--no-" + self._name
    return None
</t>
<t tx="ekr.20040701145236.336">
class Number(Base):
	&lt;&lt; class Number declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.337">"OptionType for editing numbers"

</t>
<t tx="ekr.20040701145236.338">def __init__(self, name, default):
    Base.__init__(self, name, default)
</t>
<t tx="ekr.20040701145236.339">def field(self, w):
    self._var = Tkinter.IntVar()
    self._var.set(self._default)
    frame = Tkinter.Frame(w, name = self._name + "Frame")
    label = Tkinter.Label(frame, text=self._name + ":")
    label.grid(row=0, column=0, sticky=Tkinter.W)
    entry = Tkinter.Entry(frame,
                          name=self._name,
                          textvariable=self._var,
                          width=4)
    entry.grid(row=0, column=1, sticky=Tkinter.E)
    for i in range(2):
        frame.columnconfigure(i, weight=1)
    return frame
</t>
<t tx="ekr.20040701145236.340">def arg(self):
    if self._var.get() != self._default:
        return "--%s=%d" % (self._name, self._var.get())
    return None
</t>
<t tx="ekr.20040701145236.341">    
class Text(Base):
	&lt;&lt; class Text declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.342">"OptionType for editing a little bit of text"

</t>
<t tx="ekr.20040701145236.343">def __init__(self, name, default):
    Base.__init__(self, name, default)
</t>
<t tx="ekr.20040701145236.344">def width(self):
    return int(min(15, len(self._default) * 1.20))
</t>
<t tx="ekr.20040701145236.345">def field(self, w):
    self._var = Tkinter.StringVar()
    self._var.set(self._default)
    frame = Tkinter.Frame(w, name = self._name + "Frame")
    label = Tkinter.Label(frame, text=self._name + ":")
    label.grid(row=0, column=0, sticky=Tkinter.W)
    entry = Tkinter.Entry(frame,
                          name=self._name,
                          textvariable=self._var,
                          width=self.width())
    entry.grid(row=0, column=1, sticky=Tkinter.E)
    for i in range(2):
        frame.columnconfigure(i, weight=1)
    return frame
</t>
<t tx="ekr.20040701145236.346">def arg(self):
    if self._var.get() != self._default:
        return "--%s=%s" % (self._name, self._var.get())
    return None
</t>
<t tx="ekr.20040701145236.347">def join(list):
    import string
    return string.join(list, ", ")
</t>
<t tx="ekr.20040701145236.348">
class List(Text):
	&lt;&lt; class List declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.349">"OptionType for editing a list of values"

</t>
<t tx="ekr.20040701145236.350">def __init__(self, name, default):
    Text.__init__(self, name, join(default))
</t>
<t tx="ekr.20040701145236.351">def set(self, value):
    self._var.set(join(value))
</t>
<t tx="ekr.20040701145236.352">@ignore
@language python
&lt;&lt; printer declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040701145236.353">#!/usr/bin/env python

# Copyright (c) 2001, MetaSlash Inc.  All rights reserved.

"Helper functions for printing out info about objects"


</t>
<t tx="ekr.20040701145236.354">def printFunction(spaces, prefix, func, className = None) :
    params = ''
    argcount = func.func_code.co_argcount
    defaultArgStart = argcount
    if func.func_defaults != None :
        defaultArgStart = argcount - len(func.func_defaults)
    for i in range(0, argcount) :
        arg = func.func_code.co_varnames[i]
        if i &gt;= defaultArgStart :
            arg = arg + " = %s" % str(func.func_defaults[i - defaultArgStart])
        params = params + "%s, " % arg
    params = "(%s)" % params[:-2]
    if className == None :
        className = ""
    else :
        className = className + "."
    print "%s%s%s%s%s" % (spaces, prefix, className, func.func_name, params)
</t>
<t tx="ekr.20040701145236.355">def module(module) :
    print "Module: ", module.moduleName
    if module.module == None :
        return

    print "  Imports:  ", module.modules.keys()
    print "  Variables:", module.variables.keys()
    print ""
    for function in module.functions.values() :
        printFunction("  ", "Function:  ", function.function)
    print ""
    for c in module.classes.values() :
        for method in c.methods.values() :
            if method != None :
                printFunction("  ", "", method.function, c.name)
        print ""
</t>
<t tx="ekr.20040701145236.356">def attrs(object) :
    for attr in dir(object) :
        print " %s: %s" % (attr, `getattr(object, attr)`)
</t>
<t tx="ekr.20040701145236.357">@ignore
@language python
&lt;&lt; python declarations &gt;&gt;
@others

BUILTIN_ATTRS = { types.StringType : dir(''),
                  types.TypeType : dir(type(type)),
                  types.ListType : dir([]),
                  types.DictType : dir({}),
                  types.FunctionType : dir(_setupBuiltinAttrs),
                  types.BuiltinFunctionType : dir(len),
                  types.BuiltinMethodType : dir([].append),
                  types.ClassType : dir(Stack.Item),
                  types.UnboundMethodType : dir(Stack.Item.__init__),
                  types.LambdaType : dir(lambda: None),
                  types.SliceType : dir(slice(0)),
                }

# have to setup the rest this way to support different versions of Python
_setupBuiltinAttrs()

PENDING_DEPRECATED_MODULES = { 'string': None, 'types': None,
                             }
DEPRECATED_MODULES = { 'audioop': None, 'FCNTL': 'fcntl', 'gopherlib': None,
                       'macfs': 'Carbon.File or Carbon.Folder',
                       'posixfile': 'fcntl', 'pre': None, 'regsub': 're',
                       'statcache': 'os.stat()',
                       'stringold': None, 'tzparse': None,
                       'TERMIOS': 'termios', 'whrandom':'random',
                       'xmllib': 'xml.sax',

                       # C Modules
                       'mpz': None, 'pcre': None, 'pypcre': None,
                       'rgbimg': None, 'strop': None, 'xreadlines': 'file',
                     }
DEPRECATED_ATTRS = { 'array.read': None, 'array.write': None,
                     'operator.isCallable': None,
                     'operator.sequenceIncludes': None,
                     'pty.master_open': None, 'pty.slave_open': None,
                     'random.stdgamma': 'random.gammavariate',
                     'rfc822.AddrlistClass': 'rfc822.AddressList',
                     'string.atof': None, 'string.atoi': None,
                     'string.atol': None, 'string.zfill': None,
                     'sys.exc_traceback': None, 'sys.exit_thread': None,
                     'tempfile.mktemp': None, 'tempfile.template': None,
                   }

# FIXME: can't check these right now, maybe later
DEPRECATED_METHODS = {
                       'email.Message.get_type': 'email.Message.get_content_type',
                       'email.Message.get_subtype': 'email.Message.get_content_subtype',
                       'email.Message.get_main_type': 'email.Message.get_content_maintype',
                       'htmllib.HTMLParser.do_nextid': None,
                       'pstats.Stats.ignore': None,
                       'random.Random.cunifvariate': None,
                       'random.Random.stdgamma': 'Random.gammavariate',
                     }

_OS_AND_POSIX_FUNCS = { 'tempnam': None, 'tmpnam': None }
SECURITY_FUNCS = { 'os' : _OS_AND_POSIX_FUNCS, 'posix': _OS_AND_POSIX_FUNCS }

SPECIAL_METHODS = {
    '__call__': None,                   # any number &gt; 1
    '__cmp__': 2,
    '__coerce__': 2,
    '__contains__': 2,
    '__del__': 1,
    '__hash__': 1,
    '__iter__': 1,
    '__len__': 1,
    '__new__': None,			# new-style class constructor
    '__nonzero__': 1,
    '__reduce__': 1,

    '__hex__': 1,
    '__oct__': 1,
    '__repr__': 1,
    '__str__': 1,

    '__invert__': 1,	'__neg__': 1,	'__pos__': 1,     '__abs__': 1,     
    '__complex__': 1,	'__int__': 1,	'__long__': 1,    '__float__': 1,

    '__eq__': 2,	'__ne__': 2,
    '__ge__': 2,	'__gt__': 2,
    '__le__': 2,	'__lt__': 2,

    '__getattribute__': 2,	# only in new-style classes
    '__getattr__': 2,		'__setattr__': 3,	'__delattr__': 2,
    '__getitem__': 2,		'__setitem__': 3,	'__delitem__': 2,
    '__getslice__': 3,		'__setslice__': 4,	'__delslice__': 3,
    # getslice is deprecated

    '__add__': 2,	'__radd__': 2,		'__iadd__': 2,    
    '__sub__': 2,	'__rsub__': 2,		'__isub__': 2,
    '__mul__': 2,	'__rmul__': 2,		'__imul__': 2,    
    '__div__': 2,	'__rdiv__': 2,		'__idiv__': 2,    
    '__pow__': 2,	'__rpow__': 2,		'__ipow__': 2,    # 2 or 3
    '__truediv__': 2,	'__rtruediv__': 2,	'__itruediv__': 2,	
    '__floordiv__': 2,	'__rfloordiv__': 2,	'__ifloordiv__': 2,	
    '__mod__': 2,	'__rmod__': 2,		'__imod__': 2,    
    '__divmod__': 2,	'__rdivmod__': 2,	# no inplace op for divmod()

    '__lshift__': 2,	'__rlshift__': 2,	'__ilshift__': 2,
    '__rshift__': 2,	'__rrshift__': 2,	'__irshift__': 2, 

    '__and__': 2,	'__rand__': 2,		'__iand__': 2,
    '__xor__': 2,	'__rxor__': 2,		'__ixor__': 2,
    '__or__': 2,	'__ror__': 2,		'__ior__': 2,

    # these are related to pickling 
    '__getstate__': 1,		'__setstate__': 2,
    '__copy__': 1,		'__deepcopy__': 2,
    '__getinitargs__': 1,	
    }
</t>
<t tx="ekr.20040701145236.358">#!/usr/bin/env python

# Copyright (c) 2001-2004, MetaSlash Inc.  All rights reserved.

"""
Setup a lot of info about Python builtin types, functions, methods, etc.
"""

import types
import sys

from pychecker import utils
from pychecker import Stack
from pychecker import Warning


BOOL = types.IntType
#                    name   (type,  args: min, max, kwArgs?
GLOBAL_FUNC_INFO = { '__import__': (types.ModuleType, 1, 4),
                     'abs': (Stack.TYPE_UNKNOWN, 1, 1),
                     'apply': (Stack.TYPE_UNKNOWN, 2, 3),
                     'buffer': (types.BufferType, 1, 3),
                     'callable': (BOOL, 1, 1),
                     'chr': (types.StringType, 1, 1),
                     'cmp': (types.IntType, 2, 2),
                     'coerce': ([ types.NoneType, types.TupleType ], 2, 2),
                     'compile': (types.CodeType, 3, 3),
                     'complex': (types.ComplexType, 1, 2, ['real', 'imag']),
                     'delattr': (types.NoneType, 2, 2),
                     'dir': (types.ListType, 0, 1),
                     'divmod': (types.TupleType, 2, 2),
                     'eval': (Stack.TYPE_UNKNOWN, 1, 3),
                     'execfile': (types.NoneType, 1, 3),
                     'filter': (types.ListType, 2, 2),
                     'float': (types.FloatType, 1, 1),
                     'getattr': (Stack.TYPE_UNKNOWN, 2, 3),
                     'globals': (types.DictType, 0, 0),
                     'hasattr': (BOOL, 2, 2),
                     'hash': (types.IntType, 1, 1),
                     'hex': (types.StringType, 1, 1),
                     'id': (types.IntType, 1, 1),
                     'input': (Stack.TYPE_UNKNOWN, 0, 1),
                     'int': (types.IntType, 1, 2, ['x']),
                     'intern': (types.StringType, 1, 1),
                     'isinstance': (BOOL, 2, 2),
                     'issubclass': (BOOL, 2, 2),
                     'len': (types.IntType, 1, 1),
                     'list': (types.ListType, 1, 1, ['sequence']),
                     'locals': (types.DictType, 0, 0),
                     'long': (types.LongType, 1, 2, ['x']),
                     'map': (types.ListType, 2, None),
                     'max': (Stack.TYPE_UNKNOWN, 1, None),
                     'min': (Stack.TYPE_UNKNOWN, 1, None),
                     'oct': (types.StringType, 1, 1),
                     'open': (types.FileType, 1, 3, ['name', 'mode', 'buffering']),
                     'ord': (types.IntType, 1, 1),
                     'pow': (Stack.TYPE_UNKNOWN, 2, 3),
                     'range': (types.ListType, 1, 3),
                     'raw_input': (types.StringType, 0, 1),
                     'reduce': (Stack.TYPE_UNKNOWN, 2, 3),
                     'reload': (types.ModuleType, 1, 1),
                     'repr': (types.StringType, 1, 1),
                     'round': (types.FloatType, 1, 2),
                     'setattr': (types.NoneType, 3, 3),
                     'slice': (types.SliceType, 1, 3),
                     'str': (types.StringType, 1, 1),
                     'tuple': (types.TupleType, 1, 1),
                     'type': (types.TypeType, 1, 1),
                     'vars': (types.DictType, 0, 1),
                     'xrange': (types.ListType, 1, 3),
                   }

if hasattr(types, 'UnicodeType') :
    GLOBAL_FUNC_INFO['unichr'] = (types.UnicodeType, 1, 1)
    GLOBAL_FUNC_INFO['unicode'] = (types.UnicodeType, 1, 3, ['string', 'encoding', 'errors'])

if utils.pythonVersion() &gt;= utils.PYTHON_2_2 :
    GLOBAL_FUNC_INFO['compile'] = (types.CodeType, 3, 5)
    GLOBAL_FUNC_INFO['dict'] = (types.DictType, 0, 1, ['items'])
    GLOBAL_FUNC_INFO['file'] = GLOBAL_FUNC_INFO['open']
    GLOBAL_FUNC_INFO['float'] = (types.FloatType, 0, 1, ['x'])
    GLOBAL_FUNC_INFO['int'] = (types.IntType, 0, 2, ['x'])
    GLOBAL_FUNC_INFO['list'] = (types.ListType, 0, 1, ['sequence'])
    GLOBAL_FUNC_INFO['long'] = (types.LongType, 0, 2, ['x'])
    GLOBAL_FUNC_INFO['str'] = (types.StringType, 0, 1, ['object'])
    # FIXME: type doesn't take 2 args, only 1 or 3
    GLOBAL_FUNC_INFO['type'] = (types.TypeType, 1, 3, ['name', 'bases', 'dict'])
    GLOBAL_FUNC_INFO['tuple'] = (types.TupleType, 0, 1, ['sequence'])

    GLOBAL_FUNC_INFO['classmethod'] = (types.MethodType, 1, 1)
    GLOBAL_FUNC_INFO['iter'] = (Stack.TYPE_UNKNOWN, 1, 2)
    GLOBAL_FUNC_INFO['property'] = (Stack.TYPE_UNKNOWN, 0, 4, ['fget', 'fset', 'fdel', 'doc'])
    GLOBAL_FUNC_INFO['super'] = (Stack.TYPE_UNKNOWN, 1, 2)
    GLOBAL_FUNC_INFO['staticmethod'] = (types.MethodType, 1, 1)
    GLOBAL_FUNC_INFO['unicode'] = (types.UnicodeType, 0, 3, ['string', 'encoding', 'errors'])

    GLOBAL_FUNC_INFO['bool'] = (BOOL, 1, 1, ['x'])

</t>
<t tx="ekr.20040701145236.359">def tryAddGlobal(name, *args):
    if globals().has_key(name):
        GLOBAL_FUNC_INFO[name] = args
</t>
<t tx="ekr.20040701145236.360">tryAddGlobal('zip', types.ListType, 1, None)
tryAddGlobal('enumerate', types.TupleType, 1, 1, ['sequence'])
# sum() could also return float/long
tryAddGlobal('sum', types.IntType, 1, 2, ['start'])
# reversed() always returns an iterator  (FIXME: support iterator)
tryAddGlobal('reversed', Stack.TYPE_UNKNOWN, 1, 1)

_STRING_METHODS = { 'capitalize': (types.StringType, 0, 0),
                    'center': (types.StringType, 1, 1),
                    'count': (types.IntType, 1, 1),
                    'encode': (types.StringType, 0, 2),
                    'endswith': (BOOL, 1, 3),
                    'expandtabs': (types.StringType, 0, 1),
                    'find': (types.IntType, 1, 3),
                    'index': (types.IntType, 1, 3),
                    'isalnum': (BOOL, 0, 0),
                    'isalpha': (BOOL, 0, 0),
                    'isdigit': (BOOL, 0, 0),
                    'islower': (BOOL, 0, 0),
                    'isspace': (BOOL, 0, 0),
                    'istitle': (BOOL, 0, 0),
                    'isupper': (BOOL, 0, 0),
                    'join': (types.StringType, 1, 1),
                    'ljust': (types.StringType, 1, 1),
                    'lower': (types.StringType, 0, 0),
                    'lstrip': (types.StringType, 0, 0),
                    'replace': (types.StringType, 2, 3),
                    'rfind': (types.IntType, 1, 3),
                    'rindex': (types.IntType, 1, 3),
                    'rjust': (types.StringType, 1, 1),
                    'rstrip': (types.StringType, 0, 0),
                    'split': (types.ListType, 0, 2),
                    'splitlines': (types.ListType, 0, 1),
                    'startswith': (BOOL, 1, 3),
                    'strip': (types.StringType, 0, 0),
                    'swapcase': (types.StringType, 0, 0),
                    'title': (types.StringType, 0, 0),
                    'translate': (types.StringType, 1, 2),
                    'upper': (types.StringType, 0, 0),
                  }

if utils.pythonVersion() &gt;= utils.PYTHON_2_2 :
    _STRING_METHODS['decode'] = (types.UnicodeType, 0, 2)

BUILTIN_METHODS = { types.DictType :
                    { 'clear': (types.NoneType, 0, 0),
                      'copy': (types.DictType, 0, 0),
                      'get': (Stack.TYPE_UNKNOWN, 1, 2),
                      'has_key': (BOOL, 1, 1),
                      'items': (types.ListType, 0, 0),
                      'keys': (types.ListType, 0, 0),
                      'popitem': (types.TupleType, 0, 0),
                      'setdefault': (Stack.TYPE_UNKNOWN, 1, 2),
                      'update': (types.NoneType, 1, 1),
                      'values': (types.ListType, 0, 0),
                    },
                    types.ListType :
                    { 'append': (types.NoneType, 1, 1),
                      'count': (types.IntType, 1, 1),
                      'extend': (types.NoneType, 1, 1),
                      'index': (types.IntType, 1, 1),
                      'insert': (types.NoneType, 2, 2),
                      'pop': (Stack.TYPE_UNKNOWN, 0, 1),
                      'remove': (types.NoneType, 1, 1),
                      'reverse': (types.NoneType, 0, 0),
                      'sort': (types.NoneType, 0, 1),
                    },
                    types.FileType :
                    { 'close': (types.NoneType, 0, 0),
                      'fileno': (types.IntType, 0, 0),
                      'flush': (types.NoneType, 0, 0),
                      'isatty': (BOOL, 0, 0),
                      'read': (types.StringType, 0, 1),
                      'readinto': (types.NoneType, 1, 1),
                      'readline': (types.StringType, 0, 1),
                      'readlines': (types.ListType, 0, 1),
                      'seek': (types.NoneType, 1, 2),
                      'tell': (types.IntType, 0, 0),
                      'truncate': (types.NoneType, 0, 1),
                      'write': (types.NoneType, 1, 1),
                      'writelines': (types.NoneType, 1, 1),
                      'xreadlines': (types.ListType, 0, 0),
                    },
                  }

if hasattr({}, 'pop'):
    BUILTIN_METHODS[types.DictType]['pop'] = (Stack.TYPE_UNKNOWN, 1, 1)

def _setupBuiltinMethods() :
    if utils.pythonVersion() &gt;= utils.PYTHON_2_2 :
        PY22_DICT_METHODS = { 'iteritems': (types.ListType, 0, 0),
                              'iterkeys': (types.ListType, 0, 0),
                              'itervalues': (types.ListType, 0, 0),
                            }

        BUILTIN_METHODS[types.DictType].update(PY22_DICT_METHODS)

    try :
        BUILTIN_METHODS[types.ComplexType] = \
                                  { 'conjugate': (types.ComplexType, 0, 0), }
    except AttributeError :
        pass

    if len(dir('')) &gt; 0 :
        BUILTIN_METHODS[types.StringType] = _STRING_METHODS

    try :
        BUILTIN_METHODS[types.UnicodeType] = _STRING_METHODS
    except AttributeError :
        pass
</t>
<t tx="ekr.20040701145236.361">_setupBuiltinMethods()

MUTABLE_TYPES = (types.ListType, types.DictType, types.InstanceType,)

# identifiers which will become a keyword in a future version
FUTURE_KEYWORDS = { 'yield': '2.2' }

METHODLESS_OBJECTS = { types.NoneType : None, types.IntType : None,
                       types.LongType : None, types.FloatType : None,
                       types.BufferType : None, types.TupleType : None,
                       types.EllipsisType : None,
                     }

def _setupBuiltinAttrs() :
    w = Warning.Warning('', 0, '')
    BUILTIN_ATTRS[types.MethodType] = dir(w.__init__)
    del w

    if utils.pythonVersion() &gt;= utils.PYTHON_2_2 :
        # FIXME: I'm sure more types need to be added here
        BUILTIN_ATTRS[types.StringType] = dir(''.__class__)
        BUILTIN_ATTRS[types.ListType] = dir([].__class__)
        BUILTIN_ATTRS[types.DictType] = dir({}.__class__)

    try :
        import warnings
        _MSG = "xrange object's 'start', 'stop' and 'step' attributes are deprecated"
        warnings.filterwarnings('ignore', _MSG)
        del warnings, _MSG
    except (ImportError, AssertionError):
        pass
    BUILTIN_ATTRS[types.XRangeType] = dir(xrange(0))

    try: BUILTIN_ATTRS[types.ComplexType] = dir(complex(0, 1))
    except: pass

    try: BUILTIN_ATTRS[types.UnicodeType] = dir(unicode(''))
    except: pass

    try: BUILTIN_ATTRS[types.CodeType] = dir(_setupBuiltinAttrs.func_code)
    except: pass

    try: BUILTIN_ATTRS[types.FileType] = dir(sys.__stdin__)
    except: pass

    try:
        raise TypeError
    except TypeError :
        try:
            tb = sys.exc_info()[2]
            BUILTIN_ATTRS[types.TracebackType] = dir(tb)
            BUILTIN_ATTRS[types.FrameType] = dir(tb.tb_frame)
        except:
            pass
        tb = None
</t>
<t tx="ekr.20040701145236.362">@ignore
@language python
&lt;&lt; Stack declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040701145236.363">#!/usr/bin/env python

# Copyright (c) 2001-2002, MetaSlash Inc.  All rights reserved.

"""
Module to hold manipulation of elements on the stack.
"""

import types


DATA_UNKNOWN = "-unknown-"
LOCALS = 'locals'

# These should really be defined by subclasses
TYPE_UNKNOWN = "-unknown-"
TYPE_FUNC_RETURN = "-return-value-"
TYPE_ATTRIBUTE = "-attribute-"
TYPE_COMPARISON = "-comparison-"
TYPE_GLOBAL = "-global-"
TYPE_EXCEPT = "-except-"

</t>
<t tx="ekr.20040701145236.364">class Item :
	&lt;&lt; class Item declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.365">"Representation of data on the stack"

</t>
<t tx="ekr.20040701145236.366">def __init__(self, data, dataType, const = 0, length = 0) :
    self.data = data
    self.type = dataType
    self.const = const
    self.length = length
    self.is_really_string = 0
</t>
<t tx="ekr.20040701145236.367">def __str__(self) :
    if type(self.data) == types.TupleType :
        value = '('
        for item in self.data :
            value = value + str(item) + ', '
        # strip off the ', ' for multiple items
        if len(self.data) &gt; 1 :
            value = value[:-2]
        return value + ')'
    return str(self.data)
</t>
<t tx="ekr.20040701145236.368">def __repr__(self):
    return 'Stack Item: (%s, %s, %d)' % (self.data, self.type, self.const)
</t>
<t tx="ekr.20040701145236.369">def isNone(self) :
    return (self.type != TYPE_UNKNOWN and self.data is None or
            (self.data == 'None' and not self.const))
</t>
<t tx="ekr.20040701145236.370">def isImplicitNone(self) :
    return self.data is None and self.const
</t>
<t tx="ekr.20040701145236.371">def isMethodCall(self, c, methodArgName):
    return self.type == TYPE_ATTRIBUTE and c != None and \
           len(self.data) == 2 and self.data[0] == methodArgName
</t>
<t tx="ekr.20040701145236.372">def isLocals(self) :
    return self.type == types.DictType and self.data == LOCALS
</t>
<t tx="ekr.20040701145236.373">def setStringType(self, value = types.StringType):
    self.is_really_string = value == types.StringType
</t>
<t tx="ekr.20040701145236.374">def getType(self, typeMap) :
    if self.type != types.StringType or self.is_really_string:
        return self.type
    if self.const :
        return type(self.data)
    if type(self.data) == types.StringType :
        localTypes = typeMap.get(self.data, [])
        if len(localTypes) == 1 :
            return localTypes[0]
    return TYPE_UNKNOWN
</t>
<t tx="ekr.20040701145236.375">def getName(self) :
    if self.type == TYPE_ATTRIBUTE and type(self.data) != types.StringType:
        strValue = ""
        # convert the tuple into a string ('self', 'data') -&gt; self.data
        for item in self.data :
            strValue = '%s.%s' % (strValue, str(item))
        return strValue[1:]
    return str(self.data)
</t>
<t tx="ekr.20040701145236.376">def addAttribute(self, attr) :
    if type(self.data) == types.TupleType :
        self.data = self.data + (attr,)
    else :
        self.data = (self.data, attr)
    self.type = TYPE_ATTRIBUTE
</t>
<t tx="ekr.20040701145236.377">def makeDict(values = (), const = 1) :
    values = tuple(values)
    if not values:
        values = ('&lt;on-stack&gt;',)
    return Item(values, types.DictType, const, len(values))
</t>
<t tx="ekr.20040701145236.378">def makeTuple(values = (), const = 1) :
    return Item(tuple(values), types.TupleType, const, len(values))
</t>
<t tx="ekr.20040701145236.379">def makeList(values = [], const = 1) :
    return Item(values, types.ListType, const, len(values))
</t>
<t tx="ekr.20040701145236.380">def makeFuncReturnValue(stackValue, argCount) :
    data = DATA_UNKNOWN
    # vars() without params == locals()
    if stackValue.type == TYPE_GLOBAL and \
       (stackValue.data == LOCALS or
        (argCount == 0 and stackValue.data == 'vars')) :
        data = LOCALS
    return Item(data, TYPE_FUNC_RETURN)
</t>
<t tx="ekr.20040701145236.381">def makeComparison(stackItems, comparison) :
    return Item((stackItems[0], comparison, stackItems[1]), TYPE_COMPARISON)
</t>
<t tx="ekr.20040701145236.382">@ignore
@language python
&lt;&lt; utils declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040701145236.383">#!/usr/bin/env python

# Copyright (c) 2001-2004, MetaSlash Inc.  All rights reserved.

"""
Print out warnings from Python source files.
"""

import sys
import string
import copy

from pychecker import msgs
from pychecker import Config
from pychecker.Warning import Warning


VAR_ARGS_BITS = 8
MAX_ARGS_MASK = ((1 &lt;&lt; VAR_ARGS_BITS) - 1)

INIT = '__init__'
LAMBDA = '&lt;lambda&gt;'

# number of instructions to check backwards if it was a return
BACK_RETURN_INDEX = 4


_cfg = []

</t>
<t tx="ekr.20040701145236.384">def cfg() :
    return _cfg[-1]
</t>
<t tx="ekr.20040701145236.385">def initConfig(cfg) :
    _cfg.append(cfg)
</t>
<t tx="ekr.20040701145236.386">def pushConfig() :
    newCfg = copy.copy(cfg())
    _cfg.append(newCfg)
</t>
<t tx="ekr.20040701145236.387">def popConfig() :
    del _cfg[-1]
</t>
<t tx="ekr.20040701145236.388">def shouldUpdateArgs(operand) :
    return operand == Config.CHECKER_VAR
</t>
<t tx="ekr.20040701145236.389">def updateCheckerArgs(argStr, func, lastLineNum, warnings) :
    try :
        argList = string.split(argStr)
        # don't require long options to start w/--, we can add that for them
        for i in range(0, len(argList)) :
            if argList[i][0] != '-' :
                argList[i] = '--' + argList[i]

        cfg().processArgs(argList)
        return 1
    except Config.UsageError, detail :
        warn = Warning(func, lastLineNum, msgs.INVALID_CHECKER_ARGS % detail)
        warnings.append(warn)
        return 0
</t>
<t tx="ekr.20040701145236.390">def debug(*args) :
    if cfg().debug: print args
</t>
<t tx="ekr.20040701145236.391">PYTHON_1_5 = 0x10502
PYTHON_2_0 = 0x20000
PYTHON_2_1 = 0x20100
PYTHON_2_2 = 0x20200
PYTHON_2_3 = 0x20300
PYTHON_2_4 = 0x20400

def pythonVersion() :
    return sys.hexversion &gt;&gt; 8
</t>
<t tx="ekr.20040701145236.392">def startswith(s, substr) :
    "Ugh, supporting python 1.5 is a pain"
    return s[0:len(substr)] == substr
</t>
<t tx="ekr.20040701145236.393">def endswith(s, substr) :
    "Ugh, supporting python 1.5 is a pain"
    return s[-len(substr):] == substr
</t>
<t tx="ekr.20040701145236.394"># generic method that can be slapped into any class, thus the self parameter
def std_repr(self) :
    return "&lt;%s at 0x%x: %s&gt;" % (self.__class__.__name__, id(self), str(self))
</t>
<t tx="ekr.20040701145236.395">@ignore
@language python
&lt;&lt; warn declarations &gt;&gt;
@others

if 0:
    # if you want to test w/psyco, include this
    import psyco
    psyco.bind(_checkCode)
</t>
<t tx="ekr.20040701145236.396">#!/usr/bin/env python

# Copyright (c) 2001-2002, MetaSlash Inc.  All rights reserved.

"""
Print out warnings from Python source files.
"""

import os.path
import sys
import string
import types
import traceback
import imp

from pychecker import OP
from pychecker import Stack
from pychecker import function
from pychecker import python

from pychecker import msgs
from pychecker import utils
from pychecker import CodeChecks
from pychecker.Warning import Warning

from leoGlobals import trace


</t>
<t tx="ekr.20040701145236.397">def cfg() :
    return utils.cfg()
</t>
<t tx="ekr.20040701145236.398">def _checkSelfArg(method, warnings) :
    """Return a Warning if there is no self parameter or
       the first parameter to a method is not self."""

    if not cfg().methodArgName:
        return

    code = method.function.func_code
    err = None
    if method.isStaticMethod():
        if code.co_argcount &gt; 0 and cfg().methodArgName == code.co_varnames[0]:
            err = msgs.SELF_IS_ARG % 'staticmethod'
    elif code.co_argcount &lt; 1: 
        err = msgs.NO_METHOD_ARGS % cfg().methodArgName
    else:
        if method.isClassMethod():
            if code.co_varnames[0] not in cfg().classmethodArgNames:
                err = msgs.SELF_NOT_FIRST_ARG % \
                      (cfg().classmethodArgNames, 'class')
        elif code.co_varnames[0] != cfg().methodArgName:
            err = msgs.SELF_NOT_FIRST_ARG % (cfg().methodArgName, '')

    if err is not None :
        warnings.append(Warning(code, code, err))
</t>
<t tx="ekr.20040701145236.399">def _checkNoSelfArg(func, warnings) :
    "Return a Warning if there is a self parameter to a function."

    code = func.function.func_code
    if code.co_argcount &gt; 0 and cfg().methodArgName in code.co_varnames:
        warnings.append(Warning(code, code, msgs.SELF_IS_ARG % 'function'))
</t>
<t tx="ekr.20040701145236.400">def _checkSubclass(c1, c2):
    try:
        return issubclass(c1.classObject, c2.classObject)
    except (TypeError, AttributeError):
        return 0
</t>
<t tx="ekr.20040701145236.401">_IGNORE_RETURN_TYPES = ( Stack.TYPE_FUNC_RETURN, Stack.TYPE_ATTRIBUTE,
                         Stack.TYPE_GLOBAL, Stack.TYPE_COMPARISON,
                         Stack.TYPE_UNKNOWN)

def _checkReturnWarnings(code) :
    is_getattr = code.func_code.co_name in ('__getattr__', '__getattribute__')
    if is_getattr :
        for line, retval, dummy in code.returnValues :
            if retval.isNone() :
                err = msgs.DONT_RETURN_NONE % code.func_code.co_name
                code.addWarning(err, line+1)

    # there must be at least 2 real return values to check for consistency
    returnValuesLen = len(code.returnValues)
    if returnValuesLen &lt; 2 :
        return

    # if the last return is implicit, check if there are non None returns
    lastReturn = code.returnValues[-1]
    if not code.starts_and_ends_with_finally and \
       cfg().checkImplicitReturns and lastReturn[1].isImplicitNone() :
        for line, retval, dummy in code.returnValues[:-1] :
            if not retval.isNone() :
                code.addWarning(msgs.IMPLICIT_AND_EXPLICIT_RETURNS,
                                lastReturn[0]+1)
                break

    # __get*__ funcs can return different types, don't warn about inconsistency
    if utils.startswith(code.func_code.co_name, '__get') and \
       utils.endswith(code.func_code.co_name, '__') :
        return

    returnType, returnData = None, None
    for line, value, dummy in code.returnValues :
        if not value.isNone() :
            valueType = value.getType(code.typeMap)
            if returnType is None and valueType not in _IGNORE_RETURN_TYPES :
                returnData = value
                returnType = valueType
                continue

            # always ignore None, None can be returned w/any other type
            # FIXME: if we stored func return values, we could do better
            if returnType is not None and not value.isNone() and \
               valueType not in _IGNORE_RETURN_TYPES and \
               returnData.type not in _IGNORE_RETURN_TYPES :
                ok = returnType in (type(value.data), valueType)
                if ok :
                    if returnType == types.TupleType :
                        # FIXME: this isn't perfect, if len == 0
                        # the length can really be 0 OR unknown
                        # we shouldn't check the lengths for equality
                        # ONLY IF one of the lengths is truly unknown
                        if returnData.length &gt; 0 and value.length &gt; 0:
                            ok = returnData.length == value.length
                else :
                    ok = _checkSubclass(returnType, valueType) or \
                         _checkSubclass(valueType, returnType)
                if not ok :
                    code.addWarning(msgs.INCONSISTENT_RETURN_TYPE, line)
</t>
<t tx="ekr.20040701145236.402">def _checkComplex(code, maxValue, value, func, err) :
    if maxValue and value &gt; maxValue :
        line = func.function.func_code.co_firstlineno
        code.addWarning(err % (func.function.__name__, value), line)
</t>
<t tx="ekr.20040701145236.403">def _checkCode(code, codeSource) :
    while code.index &lt; code.maxCode :
        op, oparg, operand = code.popNextOp()
        dispatch_func = CodeChecks.DISPATCH[op]
        if dispatch_func is not None :
            dispatch_func(oparg, operand, codeSource, code)
</t>
<t tx="ekr.20040701145236.404">def _name_unused(var) :
    if var in cfg().unusedNames :
        return 0
    for name in cfg().unusedNames :
        if name != '_' and utils.startswith(var, name) :
            return 0
    return 1
</t>
<t tx="ekr.20040701145236.405">def _checkUnusedParam(var, line, func, code) :
    if line is not None and line == 0 and _name_unused(var) :
        if ((cfg().ignoreSelfUnused or var != cfg().methodArgName) and
            (cfg().varArgumentsUsed or func.varArgName() != var)) :
            code.addWarning(msgs.UNUSED_PARAMETER % var, code.func_code)
</t>
<t tx="ekr.20040701145236.406">def _handleNestedCode(func_code, code, codeSource):
    nested = not (codeSource.main or codeSource.in_class)
    if func_code.co_name == utils.LAMBDA or nested:
        utils.debug(' handling nested code')
        varnames = None
        if nested and func_code.co_name != utils.LAMBDA:
            varnames = func_code.co_varnames + \
                     codeSource.calling_code[-1].function.func_code.co_varnames
        code.init(function.create_fake(func_code.co_name, func_code, {},
                                       varnames))
        _checkCode(code, codeSource)
</t>
<t tx="ekr.20040701145236.407">def _findUnreachableCode(code) :
    # code after RETURN or RAISE is unreachable unless there's a branch to it
    unreachable = {}
    terminals = code.returnValues[:-1] + code.raiseValues
    terminals.sort(lambda a, b: cmp(a[2], b[2]))
    for line, dummy, i in terminals :
        if not code.branches.has_key(i) :
            unreachable[i] = line

    # find the index of the last return
    lastLine, lastItem, lastIndex = code.returnValues[-1]
    if len(code.returnValues) &gt;= 2 :
        lastIndex = code.returnValues[-2][2]
    if code.raiseValues :
        lastIndex = max(lastIndex, code.raiseValues[-1][2])

    # remove last return if it's unreachable AND implicit
    if unreachable.get(lastIndex) == lastLine and lastItem.isImplicitNone() :
        del code.returnValues[-1]
        del unreachable[lastIndex]

    if cfg().unreachableCode :
        for index in unreachable.keys() :
            try :
                if not OP.JUMP_FORWARD(ord(code.bytes[index])) :
                    code.addWarning(msgs.CODE_UNREACHABLE, unreachable[index])
            except IndexError :
                pass
</t>
<t tx="ekr.20040701145236.408">def _checkFunction(module, func, c = None, main = 0, in_class = 0) :
    "Return a list of Warnings found in a function/method."

    # always push a new config object, so we can pop at end of function
    utils.pushConfig()

    code = CodeChecks.Code()
    code.init(func)
    if main:
        for key in func.function.func_globals.keys():
            code.unusedLocals[key] = -1
    codeSource = CodeChecks.CodeSource(module, func, c, main, in_class, code)
    try :
        _checkCode(code, codeSource)

        # handle lambdas
        codeSource.calling_code.append(func)
        for func_code in code.codeObjects.values() :
            _handleNestedCode(func_code, code, codeSource)
        del codeSource.calling_code[-1]

        if not in_class :
            _findUnreachableCode(code)

    except (SystemExit, KeyboardInterrupt) :
        exc_type, exc_value, exc_tb = sys.exc_info()
        raise exc_type, exc_value
    except :
        exc_type, exc_value, exc_tb = sys.exc_info()
        exc_list = traceback.format_exception(exc_type, exc_value, exc_tb)
        for index in range(0, len(exc_list)) :
            exc_list[index] = string.replace(exc_list[index], "\n", "\n\t")
        code.addWarning(msgs.CHECKER_BROKEN % string.join(exc_list, ""))

    if cfg().checkReturnValues :
        _checkReturnWarnings(code)

    if cfg().localVariablesUsed :
        for var, line in code.unusedLocals.items() :
            if line is not None and line &gt; 0 and _name_unused(var) :
                code.addWarning(msgs.UNUSED_LOCAL % var, line)

    if cfg().argumentsUsed :
        op = code.getFirstOp()
        if not (OP.RAISE_VARARGS(op) or OP.RETURN_VALUE(op)) :
            for var, line in code.unusedLocals.items() :
                _checkUnusedParam(var, line, func, code)

    # Check code complexity:
    #   loops should be counted as one branch, but there are typically 3
    #   branches in byte code to setup a loop, so subtract off 2/3's of them
    #    / 2 to approximate real branches
    branches = (len(code.branches.keys()) - (2 * code.loops)) / 2
    lines = (code.getLineNum() - code.func_code.co_firstlineno)
    returns = len(code.returnValues)
    if not main and not in_class :
        args = code.func_code.co_argcount
        locals = len(code.func_code.co_varnames) - args
        _checkComplex(code, cfg().maxArgs, args, func, msgs.TOO_MANY_ARGS)
        _checkComplex(code, cfg().maxLocals, locals, func, msgs.TOO_MANY_LOCALS)
        _checkComplex(code, cfg().maxLines, lines, func, msgs.FUNC_TOO_LONG)
    _checkComplex(code, cfg().maxReturns, returns, func, msgs.TOO_MANY_RETURNS)
    _checkComplex(code, cfg().maxBranches, branches, func, msgs.TOO_MANY_BRANCHES)

    if not (main or in_class) :
        utils.popConfig()
    func.returnValues = code.returnValues
    return (code.warnings, code.globalRefs, code.functionsCalled,
            code.codeObjects.values(), code.returnValues)
</t>
<t tx="ekr.20040701145236.409">def _getUnused(module, globalRefs, dict, msg, filterPrefix = None) :
    "Return a list of warnings for unused globals"

    warnings = []
    for ref in dict.keys() :
        check = not filterPrefix or utils.startswith(ref, filterPrefix)
        if check and globalRefs.get(ref) == None :
            lineInfo = module.moduleLineNums.get(ref)
            if lineInfo:
                warnings.append(Warning(lineInfo[0], lineInfo[1], msg % ref))
    return warnings
</t>
<t tx="ekr.20040701145236.410">def _get_func_info(method) :
    try:
        fc = getattr(method.im_func, 'func_code', None)
        if fc is not None :
            return fc.co_filename, fc.co_firstlineno
    except AttributeError:
        # if the object derives from any object in 2.2,
        # the builtin methods are wrapper_descriptors and
        # have no im_func attr
        pass
    return None, None
</t>
<t tx="ekr.20040701145236.411">_DOT_INIT = '.' + utils.INIT

def _baseInitCalled(classInitInfo, base, functionsCalled) :
    baseInit = getattr(base, utils.INIT, None)
    if baseInit is None or _get_func_info(baseInit) == classInitInfo :
        return 1

    initName = str(base) + _DOT_INIT
    if functionsCalled.has_key(initName) :
        return 1

    # ok, do this the hard way, there may be aliases, so check here
    names = string.split(initName, '.')
    try:
        # i think this can raise an exception if the module is a library (.so)
        obj = sys.modules[names[0]]
    except KeyError:
        return 1
    for i in range(1, len(names)) :
        obj = getattr(obj, names[i], None)
        if obj is None:
            return 0
        if functionsCalled.has_key(string.join(names[i:], '.')) :
            return 1

    return 0
</t>
<t tx="ekr.20040701145236.412">def _checkBaseClassInit(moduleFilename, c, func_code, funcInfo) :
    """Return a list of warnings that occur
       for each base class whose __init__() is not called"""

    warnings = []
    functionsCalled, _, returnValues = funcInfo
    for line, stackItem, dummy in returnValues :
        if stackItem.data != None :
            if not stackItem.isNone() or cfg().returnNoneFromInit :
                warn = Warning(moduleFilename, line, msgs.RETURN_FROM_INIT)
                warnings.append(warn)

    classInit = getattr(c.classObject, utils.INIT, None)
    if cfg().baseClassInitted and classInit is not None :
        classInitInfo = _get_func_info(classInit)
        for base in c.classObject.__bases__ :
            if not _baseInitCalled(classInitInfo, base, functionsCalled) :
                warn = Warning(moduleFilename, func_code,
                               msgs.BASE_CLASS_NOT_INIT % str(base))
                warnings.append(warn)
    return warnings
</t>
<t tx="ekr.20040701145236.413">def _checkOverridenMethods(func, baseClasses, warnings) :
    for baseClass in baseClasses :
        if func.func_name != utils.INIT and \
           not function.same_signature(func, baseClass) :
            err = msgs.METHOD_SIGNATURE_MISMATCH % (func.func_name, str(baseClass))
            warnings.append(Warning(func.func_code, func.func_code, err))
            break
</t>
<t tx="ekr.20040701145236.414">def _updateFunctionWarnings(module, func, c, warnings, globalRefs,
                            main = 0, in_class = 0) :
    "Update function warnings and global references"

    newWarnings, newGlobalRefs, funcs, codeObjects, returnValues = \
                 _checkFunction(module, func, c, main, in_class)
    warnings.extend(newWarnings)
    globalRefs.update(newGlobalRefs)

    return funcs, codeObjects, returnValues
</t>
<t tx="ekr.20040701145236.415">def getBlackList(moduleList) :
    blacklist = []
    for badBoy in moduleList :
        if badBoy[-3:] == ".py":
            badBoy = badBoy[0:-3]
        try :
            file, path, flags = imp.find_module(badBoy)
            if file :
                file.close()
                blacklist.append(path)
        except ImportError :
            pass
    return blacklist
</t>
<t tx="ekr.20040701145236.416">def getStandardLibrary() :
    if cfg().ignoreStandardLibrary :
        try :
            from distutils import sysconfig

            std_lib = sysconfig.get_python_lib()
            path = os.path.split(std_lib)
            if path[1] == 'site-packages' :
                std_lib = path[0]
            return std_lib
        except ImportError :
            return None
</t>
<t tx="ekr.20040701145236.417">def normalize_path(path):
    return os.path.normpath(os.path.normcase(path))
</t>
<t tx="ekr.20040701145236.418">def removeWarnings(warnings, blacklist, std_lib) :
    if std_lib is not None:
        std_lib = normalize_path(std_lib)
    for index in range(len(warnings)-1, -1, -1) :
        filename = normalize_path(warnings[index].file)
        if filename in blacklist or (std_lib is not None and
                                     utils.startswith(filename, std_lib)) :
            del warnings[index]

    return warnings
</t>
<t tx="ekr.20040701145236.419">

class _SuppressionError(Exception) :
	&lt;&lt; class _SuppressionError declarations &gt;&gt;
</t>
<t tx="ekr.20040701145236.420">pass

</t>
<t tx="ekr.20040701145236.421">def _updateSuppressions(suppress, warnings) :
    if not utils.updateCheckerArgs(suppress, 'suppressions', 0, warnings) :
        utils.popConfig()
        raise _SuppressionError
</t>
<t tx="ekr.20040701145236.422">def getSuppression(name, suppressions, warnings) :
    try :
        utils.pushConfig()

        suppress = suppressions[0].get(name, None)
        if suppress is not None :
            _updateSuppressions(suppress, warnings)

        regexList = suppressions[1].keys()
        regexList.sort()
        for regex in regexList :
            match = regex.match(name)
            if match and match.group() == name :
                suppress = 1
                _updateSuppressions(suppressions[1][regex], warnings)

        if not suppress :
            utils.popConfig()

        return suppress
    except _SuppressionError :
        return None
</t>
<t tx="ekr.20040701145236.423">def _findFunctionWarnings(module, globalRefs, warnings, suppressions) :
    for func in module.functions.values() :
        func_code = func.function.func_code
        utils.debug("function:", func_code)

        name = '%s.%s' % (module.moduleName, func.function.__name__)
        suppress = getSuppression(name, suppressions, warnings)
        if cfg().noDocFunc and func.function.__doc__ == None :
            err = msgs.NO_FUNC_DOC % func.function.__name__
            warnings.append(Warning(module.filename(), func_code, err))

        _checkNoSelfArg(func, warnings)
        _updateFunctionWarnings(module, func, None, warnings, globalRefs)
        if suppress is not None :
            utils.popConfig()
</t>
<t tx="ekr.20040701145236.424">def _getModuleFromFilename(module, filename):
    if module.filename() != filename:
        for m in module.modules.values():
            if m.filename() == filename:
                return m
    return module
</t>
<t tx="ekr.20040701145236.425"># Create object for non-2.2 interpreters, any class object will do
try:
    if object: pass
except NameError:
    object = _SuppressionError

# Create property for pre-2.2 interpreters
try :
    if property: pass
except NameError:
    property = None

def _findClassWarnings(module, c, class_code,
                       globalRefs, warnings, suppressions) :
    try:
        className = str(c.classObject)
    except TypeError:
        # goofy __getattr__
        return
    classSuppress = getSuppression(className, suppressions, warnings)
    baseClasses = c.allBaseClasses()
    for base in baseClasses :
        baseModule = str(base)
        if '.' in baseModule :
            # make sure we handle import x.y.z
            packages = string.split(baseModule, '.')
            baseModuleDir = string.join(packages[:-1], '.')
            globalRefs[baseModuleDir] = baseModule

    # handle class variables
    if class_code is not None :
        func = function.create_fake(c.name, class_code)
        _updateFunctionWarnings(module, func, c, warnings, globalRefs, 0, 1)

    filename = module.filename()
    func_code = None
    for method in c.methods.values() :
        if method == None :
            continue
        func_code = method.function.func_code
        utils.debug("method:", func_code)

        try:
            name = str(c.classObject) + '.' + method.function.func_name
        except AttributeError:
            # func_name may not exist
            continue
        methodSuppress = getSuppression(name, suppressions, warnings)

        if cfg().checkSpecialMethods:
            funcname = method.function.func_name
            if funcname[:2] == '__' == funcname[-2:] and \
               funcname != '__init__':
                err = None
                argCount = python.SPECIAL_METHODS.get(funcname, -1)
                if argCount != -1:
                    # if the args are None, it can be any # of args
                    if argCount is not None:
                        minArgs = maxArgs = argCount
                        err = CodeChecks.getFunctionArgErr(funcname,
                                     func_code.co_argcount, minArgs, maxArgs)
                else:
                    err = msgs.NOT_SPECIAL_METHOD % funcname

                if err is not None:
                    warnings.append(Warning(filename, func_code, err))
                
        if cfg().checkOverridenMethods :
            _checkOverridenMethods(method.function, baseClasses, warnings)

        if cfg().noDocFunc and method.function.__doc__ == None :
            err = msgs.NO_FUNC_DOC % method.function.__name__
            warnings.append(Warning(filename, func_code, err))

        _checkSelfArg(method, warnings)
        tmpModule = _getModuleFromFilename(module, func_code.co_filename)
        funcInfo = _updateFunctionWarnings(tmpModule, method, c, warnings, globalRefs)
        if func_code.co_name == utils.INIT :
            if utils.INIT in dir(c.classObject) :
                warns = _checkBaseClassInit(filename, c, func_code, funcInfo)
                warnings.extend(warns)
            elif cfg().initDefinedInSubclass :
                err = msgs.NO_INIT_IN_SUBCLASS % c.name
                warnings.append(Warning(filename, c.getFirstLine(), err))
        if methodSuppress is not None :
            utils.popConfig()

    if c.memberRefs and cfg().membersUsed :
        memberList = c.memberRefs.keys()
        memberList.sort()
        err = msgs.UNUSED_MEMBERS % (string.join(memberList, ', '), c.name)
        warnings.append(Warning(filename, c.getFirstLine(), err))

    try:
        newStyleClass = issubclass(c.classObject, object)
    except TypeError:
        # FIXME: perhaps this should warn b/c it may be a class???
        newStyleClass = 0

    slots = c.statics.get('__slots__')
    if slots is not None and cfg().slots:
        lineNum = c.lineNums['__slots__']
        if not newStyleClass:
            err = msgs.USING_SLOTS_IN_CLASSIC_CLASS % c.name
            warnings.append(Warning(filename, lineNum, err))
        elif len(slots.data) == 0 and cfg().emptySlots:
            err = msgs.EMPTY_SLOTS % c.name
            warnings.append(Warning(filename, lineNum, err))

    if not newStyleClass and property is not None and cfg().classicProperties:
        for static in c.statics.keys():
            if type(getattr(c.classObject, static, None)) == property:
                err = msgs.USING_PROPERTIES_IN_CLASSIC_CLASS % (static, c.name)
                warnings.append(Warning(filename, c.lineNums[static], err))

    coerceMethod = c.methods.get('__coerce__')
    if newStyleClass and coerceMethod:
        lineNum = coerceMethod.function.func_code.co_firstlineno
        err = msgs.USING_COERCE_IN_NEW_CLASS % c.name
        warnings.append(Warning(filename, lineNum, err))

    gettroMethod = c.methods.get('__getattribute__')
    if not newStyleClass and gettroMethod:
        lineNum = gettroMethod.function.func_code.co_firstlineno
        err = msgs.USING_GETATTRIBUTE_IN_OLD_CLASS % c.name
        warnings.append(Warning(filename, lineNum, err))

    if cfg().noDocClass and c.classObject.__doc__ == None :
        method = c.methods.get(utils.INIT, None)
        if method != None :
            func_code = method.function.func_code
        # FIXME: check to make sure this is in our file,
        #        not a base class file???
        err = msgs.NO_CLASS_DOC % c.classObject.__name__
        warnings.append(Warning(filename, func_code, err))

    # we have to do this here, b/c checkFunction doesn't popConfig for classes
    # this allows us to have __pychecker__ apply to all methods
    # when defined at class scope
    if class_code is not None :
        utils.popConfig()

    if classSuppress is not None :
        utils.popConfig()
</t>
<t tx="ekr.20040701145236.426">def find(moduleList, initialCfg, suppressions = None) :
    "Return a list of warnings found in the module list"

    # trace(moduleList)

    if suppressions is None :
        suppressions = {}, {}

    utils.initConfig(initialCfg)

    warnings = []
    for module in moduleList :
        if module.moduleName in cfg().blacklist :
            continue

        modSuppress = getSuppression(module.moduleName, suppressions, warnings)
        globalRefs, classCodes = {}, {}

        # main_code can be null if there was a syntax error
        if module.main_code != None :
            funcInfo = _updateFunctionWarnings(module, module.main_code,
                                               None, warnings, globalRefs, 1)
            for code in funcInfo[1] :
                classCodes[code.co_name] = code

        _findFunctionWarnings(module, globalRefs, warnings, suppressions)

        for c in module.classes.values() :
                _findClassWarnings(module, c, classCodes.get(c.name),
                                   globalRefs, warnings, suppressions)

        if cfg().noDocModule and \
           module.module != None and module.module.__doc__ == None :
            warnings.append(Warning(module.filename(), 1, msgs.NO_MODULE_DOC))

        if cfg().allVariablesUsed or cfg().privateVariableUsed :
            prefix = None
            if not cfg().allVariablesUsed :
                prefix = "_"
            for ignoreVar in cfg().variablesToIgnore + cfg().unusedNames :
                globalRefs[ignoreVar] = ignoreVar
            warnings.extend(_getUnused(module, globalRefs, module.variables,
                                       msgs.VAR_NOT_USED, prefix))
        if cfg().importUsed :
            if module.moduleName != utils.INIT or cfg().packageImportUsed :
                # always ignore readline module, if [raw_]input() is used
                if globalRefs.has_key('input') or \
                   globalRefs.has_key('raw_input'):
                    globalRefs['readline'] = 0
                warnings.extend(_getUnused(module, globalRefs, module.modules,
                                           msgs.IMPORT_NOT_USED))

        if module.main_code != None :
            utils.popConfig()
        if modSuppress is not None :
            utils.popConfig()

    std_lib = None
    if cfg().ignoreStandardLibrary :
        std_lib = getStandardLibrary()
    return removeWarnings(warnings, getBlackList(cfg().blacklist), std_lib)
</t>
<t tx="ekr.20040701145236.427">@ignore
@language python
&lt;&lt; Warning declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040701145236.428">#!/usr/bin/env python

# Copyright (c) 2001, MetaSlash Inc.  All rights reserved.

"""
Warning class to hold info about each warning.
"""


</t>
<t tx="ekr.20040701145236.429">class Warning :
	&lt;&lt; class Warning declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20040701145236.430">"Class which holds error information."

</t>
<t tx="ekr.20040701145236.431">def __init__(self, file, line, err) :
    if hasattr(file, "function") :
        file = file.function.func_code.co_filename
    elif hasattr(file, "co_filename") :
        file = file.co_filename
    elif hasattr(line, "co_filename") :
        file = line.co_filename
    if file[:2] == './' :
        file = file[2:]
    self.file = file

    if hasattr(line, "co_firstlineno") :
        line = line.co_firstlineno
    if line == None :
        line = 1
    self.line = line
    self.err = err
</t>
<t tx="ekr.20040701145236.432">def __cmp__(self, warn) :
    if warn == None :
        return 1
    if self.file != warn.file :
        return cmp(self.file, warn.file)
    if self.line != warn.line :
        return cmp(self.line, warn.line)
    return cmp(self.err, warn.err)
</t>
<t tx="ekr.20040701145236.433">def format(self) :
    return "%s:%d: %s" % (self.file, self.line, self.err)
</t>
<t tx="ekr.20040701145236.434">def output(self, stream) :
    stream.write(self.format() + "\n")
</t>
<t tx="ekr.20040701145236.435">@ignore
@language python
"""
Copyright (c) 2001, MetaSlash Inc.  All rights reserved.

PyChecker is a tool for finding common bugs in python source code.
It finds problems that are typically caught by a compiler for less
dynamic languages, like C and C++.  It is also similar to lint.

Contact Info:
  http://pychecker.sourceforge.net/
  pychecker-list@lists.sourceforge.net
"""

# A version # to check against in the main module (checker.py)
# this will allow us to check if there are two versions of checker
# in site-packages and local dir
MAIN_MODULE_VERSION = 1

</t>
<t tx="ekr.20040701153754">@

These clones show the nodes that I have modified. These changes consist just of
prints and traces.

I also added the following line to each @file node:
    from leoGlobals importtrace.

There appears to be a bug in this version of pychecker. The node &lt;&lt; Config
declarations &gt;&gt; contains no option to set or clear the constAttr setting.

Adding code to do this is left as an excercise to the reader :-)
@c</t>
<t tx="ekr.20040701154748"></t>
<t tx="ekr.20040702152154">@killcolor

A modified pychecker could be valuable for unit testing. For example, rather
than writing many tests to make sure that format strings are correct, a better
way would be to assert that pychecker gives no warnings of the form:
    
"Format string argument count (n1) doesnt match arguments (n2)"

Just how to do this is unclear just now. The enclosed copyright notice makes
clear that Leo can use the pychecker code pretty much as it pleases. I would
like to make minimal modifications to pychecker so as to minimize the work that
will have to be done when future versions of pychecker are released.</t>
<t tx="ekr.20050212115612"></t>
<t tx="ekr.20050212115612.1"></t>
<t tx="ekr.20050212115612.2">def _getUnused(module, globalRefs, dict, msg, filterPrefix = None) :
    "Return a list of warnings for unused globals"

    warnings = []
    for ref in dict.keys() :
        check = not filterPrefix or utils.startswith(ref, filterPrefix)
        if check and globalRefs.get(ref) == None :
            lineInfo = module.moduleLineNums.get(ref)
            if lineInfo:
                warnings.append(Warning(lineInfo[0], lineInfo[1], msg % ref))
    return warnings</t>
<t tx="ekr.20050212115612.3">def _updateSuppressions(suppress, warnings) :
    if not utils.updateCheckerArgs(suppress, 'suppressions', 0, warnings) :
        utils.popConfig()
        raise _SuppressionError</t>
<t tx="ekr.20050212115612.4">def getSuppression(name, suppressions, warnings) :
    try :
        utils.pushConfig()

        suppress = suppressions[0].get(name, None)
        if suppress is not None :
            _updateSuppressions(suppress, warnings)

        regexList = suppressions[1].keys()
        regexList.sort()
        for regex in regexList :
            match = regex.match(name)
            if match and match.group() == name :
                suppress = 1
                _updateSuppressions(suppressions[1][regex], warnings)

        if not suppress :
            utils.popConfig()

        return suppress
    except _SuppressionError :
        return None
</t>
<t tx="ekr.20050212115612.5">CHECKER_BROKEN = "INTERNAL ERROR -- STOPPED PROCESSING FUNCTION --\n\t%s"
INVALID_CHECKER_ARGS = "Invalid warning suppression arguments --\n\t%s"

NO_MODULE_DOC = "No module doc string"
NO_CLASS_DOC = "No doc string for class %s"
NO_FUNC_DOC = "No doc string for function %s"

VAR_NOT_USED = "Variable (%s) not used"
IMPORT_NOT_USED = "Imported module (%s) not used"
UNUSED_LOCAL = "Local variable (%s) not used"
UNUSED_PARAMETER = "Parameter (%s) not used"
UNUSED_MEMBERS = "Members (%s) not used in class (%s)"
NO_LOCAL_VAR = "No local variable (%s)"
VAR_USED_BEFORE_SET = "Variable (%s) used before being set"

REDEFINING_ATTR = "Redefining attribute (%s) original line (%d)"

MODULE_IMPORTED_AGAIN = "Module (%s) re-imported"
MODULE_MEMBER_IMPORTED_AGAIN = "Module member (%s) re-imported"
MODULE_MEMBER_ALSO_STAR_IMPORTED = "Module member (%s) re-imported with *"
MIX_IMPORT_AND_FROM_IMPORT = "Using import and from ... import for (%s)"
IMPORT_SELF = "Module (%s) imports itself"

NO_METHOD_ARGS = "No method arguments, should have %s as argument"
SELF_NOT_FIRST_ARG = "%s is not first %smethod argument"
SELF_IS_ARG = "self is argument in %s"
RETURN_FROM_INIT = "Cannot return a value from __init__"
NO_CTOR_ARGS = "Instantiating an object with arguments, but no constructor"

GLOBAL_DEFINED_NOT_DECLARED = "Global variable (%s) not defined in module scope"
INVALID_GLOBAL = "No global (%s) found"
INVALID_METHOD = "No method (%s) found"
INVALID_CLASS_ATTR = "No class attribute (%s) found"
INVALID_SET_CLASS_ATTR = "Setting class attribute (%s) not set in __init__"
INVALID_MODULE_ATTR = "No module attribute (%s) found"

LOCAL_SHADOWS_GLOBAL = "Local variable (%s) shadows global defined on line %d"
VARIABLE_SHADOWS_BUILTIN = "(%s) shadows builtin"
USING_METHOD_AS_ATTR = "Using method (%s) as an attribute (not invoked)"
OBJECT_HAS_NO_ATTR = "Object (%s) has no attribute (%s)"
METHOD_SIGNATURE_MISMATCH = "Overridden method (%s) doesn't match signature in class (%s)"

INVALID_ARG_COUNT1 = "Invalid arguments to (%s), got %d, expected %d"
INVALID_ARG_COUNT2 = "Invalid arguments to (%s), got %d, expected at least %d"
INVALID_ARG_COUNT3 = "Invalid arguments to (%s), got %d, expected between %d and %d"
FUNC_DOESNT_SUPPORT_KW = "Function (%s) doesn't support **kwArgs"
FUNC_DOESNT_SUPPORT_KW_ARG = "Function (%s) doesn't support **kwArgs for name (%s)"
FUNC_USES_NAMED_ARGS = "Function (%s) uses named arguments"

BASE_CLASS_NOT_INIT = "Base class (%s) __init__() not called"
NO_INIT_IN_SUBCLASS = "No __init__() in subclass (%s)"
METHODS_NEED_OVERRIDE = "Methods (%s) in %s need to be overridden in a subclass"

FUNC_TOO_LONG = "Function (%s) has too many lines (%d)"
TOO_MANY_BRANCHES = "Function (%s) has too many branches (%d)"
TOO_MANY_RETURNS = "Function (%s) has too many returns (%d)"
TOO_MANY_ARGS = "Function (%s) has too many arguments (%d)"
TOO_MANY_LOCALS = "Function (%s) has too many local variables (%d)"
TOO_MANY_REFERENCES = 'Law of Demeter violated, more than %d references for (%s)'

IMPLICIT_AND_EXPLICIT_RETURNS = "Function returns a value and also implicitly returns None"
INCONSISTENT_RETURN_TYPE = "Function return types are inconsistent"
INCONSISTENT_TYPE = "Variable (%s) already has types %s and set to %s"
CODE_UNREACHABLE = "Code appears to be unreachable"
CONSTANT_CONDITION = "Using a conditional statement with a constant value (%s)"
STRING_ITERATION = "Iterating over a string (%s)"
DONT_RETURN_NONE = "%s should not return None, raise an exception if not found"
IS_LITERAL = "Using is%s %s, may not always work"
INVALID_FORMAT = "Invalid format string, problem starts near: '%s'"
INVALID_FORMAT_COUNT = "Format string argument count (%d) doesn't match arguments (%d)"
TOO_MANY_STARS_IN_FORMAT = "Too many *s in format flags"
USING_STAR_IN_FORMAT_MAPPING = "Can't use * in formats when using a mapping (dictionary), near: '%s'"
CANT_MIX_MAPPING_IN_FORMATS = "Can't mix tuple/mapping (dictionary) formats in same format string"

INTEGER_DIVISION = "Using integer division (%s / %s) may return integer or float"
MODULO_1 = "... % 1 may be constant"
USING_TUPLE_ACCESS_TO_LIST = "Using a tuple instead of slice as list accessor for (%s)"
BOOL_COMPARE = "Comparisons with %s are not necessary and may not work as expected"
SHOULDNT_ASSIGN_BUILTIN = "Should not assign to %s, it is (or will be) a builtin"
SHOULDNT_ASSIGN_NAME = "Should not assign to %s, it is similar to builtin %s"
SET_VAR_TO_ITSELF = "Setting %s to itself has no effect"
MODIFY_VAR_NOOP = "%s %s %s has no effect"
DIVIDE_VAR_BY_ITSELF = "%s %s %s is always 1 or ZeroDivisionError"
XOR_VAR_WITH_ITSELF = "%s %s %s is always 0"

STMT_WITH_NO_EFFECT = "Operator (%s) doesn't exist, statement has no effect"
POSSIBLE_STMT_WITH_NO_EFFECT = "Statement appears to have no effect"
UNARY_POSITIVE_HAS_NO_EFFECT = "Unary positive (+) usually has no effect"
LIST_APPEND_ARGS = "[].append() only takes 1 argument in Python 1.6 and above for (%s)"

LOCAL_DELETED = "(%s) cannot be used after being deleted on line %d"
LOCAL_ALREADY_DELETED = "Local variable (%s) has already been deleted on line %d"
VAR_DELETED_BEFORE_SET = "Variable (%s) deleted before being set"

CATCH_BAD_EXCEPTION = "Catching a non-Exception object (%s)"
CATCH_STR_EXCEPTION = "Catching string exceptions are deprecated (%s)"
RAISE_BAD_EXCEPTION = "Raising an exception on a non-Exception object (%s)"
RAISE_STR_EXCEPTION = "Raising string exceptions are deprecated (%s)"
SET_EXCEPT_TO_BUILTIN = "Setting exception to builtin (%s), consider () around exceptions"
USING_KEYWORD = "Using identifier (%s) which will become a keyword in version %s"
MODIFYING_DEFAULT_ARG = "Modifying parameter (%s) with a default value may have unexpected consequences"
USING_SELF_IN_REPR = "Using `self` in __repr__ method"
USING_NONE_RETURN_VALUE = "Using the return value from (%s) which is always None"
WRONG_UNPACK_SIZE = "Unpacking %d values into %d variables"
WRONG_UNPACK_FUNCTION = "Unpacking function (%s) which returns %d values into %d variables"
UNPACK_NON_SEQUENCE = "Unpacking a non-sequence (%s) of type %s"

NOT_SPECIAL_METHOD = "%s is not a special method"
USING_COERCE_IN_NEW_CLASS = "Using __coerce__ in new-style class (%s) will not work for binary operations"
USING_GETATTRIBUTE_IN_OLD_CLASS = "Using __getattribute__ in old-style class (%s) does not work"
USING_PROPERTIES_IN_CLASSIC_CLASS = "Using property (%s) in classic class %s may not work"
USING_SLOTS_IN_CLASSIC_CLASS = "Using __slots__ in classic class %s has no effect, consider deriving from object"
EMPTY_SLOTS = "__slots__ are empty in %s"

USES_EXEC = "Using the exec statement"
USES_GLOBAL_EXEC = "Using the exec statement in global namespace"
USES_INPUT = "Using input() is a security problem, consider using raw_input()"

USING_DEPRECATED_MODULE = "%s module is deprecated"
USING_DEPRECATED_ATTR = "%s is deprecated"
USING_INSECURE_FUNC = "%s() is a security problem"
USE_INSTEAD = ", consider using %s"

USES_CONST_ATTR = "Passing a constant string to %s, consider direct reference"

BAD_STRING_FIND = "string.find() returns an integer, consider checking &gt;= 0 or &lt; 0 for not found"
</t>
<t tx="ekr.20050212115612.6"></t>
<t tx="ekr.20050212115612.8">def _checkGlobal(operand, module, func, code, err, main = 0) :
    if not _hasGlobal(operand, module, func, main) :
        if str(func).startswith('test_') and str(operand) in ('g','c','p'):
            # print 'ekr',str(func),repr(operand)
            return # EKR: Suppress this test
        code.addWarning(err % operand)
        if not cfg().reportAllGlobals :
            func.function.func_globals[operand] = operand</t>
<t tx="ekr.20050212125851">_DEFAULT_BLACK_LIST = [ "Tkinter", "wxPython", "gtk", "GTK", "GDK", ]
_DEFAULT_VARIABLE_IGNORE_LIST = [ '__version__', '__warningregistry__', 
                                  '__all__', '__credits__', '__test__',
                                  '__author__', '__email__', '__revision__', ]
_DEFAULT_UNUSED_LIST = [ '_', 'empty', 'unused', 'dummy', ]

# All these options are on even if -e/--errors is used
_ERRORS = { 'noEffect': 1, }

_OPTIONS = (
    ('Major Options', [
 ('e', 0, 'errors', None, 'turn off all warnings which are not likely errors'),
 ( '', 0, 'complexity', None, 'turn off all warnings which are related to complexity'),
 ('F', 1, 'config', None, 'specify .pycheckrc file to use'),
 ('',  0, 'quixote', None, 'support Quixote\'s PTL modules'),
     ]),
    ('Error Control', [
 ('i', 0, 'import', 'importUsed', 'unused imports'),
 ('k', 0, 'pkgimport', 'packageImportUsed', 'unused imports from __init__.py'),
 ('M', 0, 'reimportself', 'reimportSelf', 'module imports itself'),
 ('X', 0, 'reimport', 'moduleImportErrors', 'reimporting a module'),
 ('x', 0, 'miximport', 'mixImport', 'module does import and from ... import'),
 ('l', 0, 'local', 'localVariablesUsed', 'unused local variables, except tuples'),
 ('t', 0, 'tuple', 'unusedLocalTuple', 'all unused local variables, including tuples'),
 ('9', 0, 'members', 'membersUsed', 'all unused class data members'),
 ('v', 0, 'var', 'allVariablesUsed', 'all unused module variables'),
 ('p', 0, 'privatevar', 'privateVariableUsed', 'unused private module variables'),
 ('g', 0, 'allglobals', 'reportAllGlobals', 'report each occurrence of global warnings'),
 ('n', 0, 'namedargs', 'namedArgs', 'functions called with named arguments (like keywords)'),
 ('a', 0, 'initattr', 'onlyCheckInitForMembers', 'Attributes (members) must be defined in __init__()'),
 ('I', 0, 'initsubclass', 'initDefinedInSubclass', 'Subclass.__init__() not defined'),
 ('u', 0, 'callinit', 'baseClassInitted', 'Baseclass.__init__() not called'),
 ('0', 0, 'abstract', 'abstractClasses', 'Subclass needs to override methods that only throw exceptions'),
 ('N', 0, 'initreturn', 'returnNoneFromInit', 'Return None from __init__()'),
 ('8', 0, 'unreachable', 'unreachableCode', 'unreachable code'),
 ('2', 0, 'constCond', 'constantConditions', 'a constant is used in a conditional statement'),
 ('1', 0, 'constant1', 'constant1', '1 is used in a conditional statement (if 1: or while 1:)'),
 ( '', 0, 'stringiter', 'stringIteration', 'check if iterating over a string'),
 ( '', 0, 'stringfind', 'stringFind', 'check improper use of string.find()'),
 ('A', 0, 'callattr', 'callingAttribute', 'Calling data members as functions'),
 ('y', 0, 'classattr', 'classAttrExists', 'class attribute does not exist'),
 ('S', 1, 'self', 'methodArgName', 'First argument to methods'),
 ('',  1, 'classmethodargs', 'classmethodArgNames', 'First argument to classmethods'),
 ('T', 0, 'argsused', 'argumentsUsed', 'unused method/function arguments'),
 ('z', 0, 'varargsused', 'varArgumentsUsed', 'unused method/function variable arguments'),
 ('G', 0, 'selfused', 'ignoreSelfUnused', 'ignore if self is unused in methods'),
 ('o', 0, 'override', 'checkOverridenMethods', 'check if overridden methods have the same signature'),
 ('',  0, 'special', 'checkSpecialMethods', 'check if __special__ methods exist and have the correct signature'),
 ('U', 0, 'reuseattr', 'redefiningFunction', 'check if function/class/method names are reused'),
 ('Y', 0, 'positive', 'unaryPositive', 'check if using unary positive (+) which is usually meaningless'),
 ('j', 0, 'moddefvalue', 'modifyDefaultValue', 'check if modify (call method) on a parameter that has a default value'),
 ( '', 0, 'changetypes', 'inconsistentTypes', 'check if variables are set to different types'),
 ( '', 0, 'unpack', 'unpackNonSequence', 'check if unpacking a non-sequence'),
 ( '', 0, 'unpacklen', 'unpackLength', 'check if unpacking sequence with the wrong length'),
 ( '', 0, 'badexcept', 'badExceptions', 'check if raising or catching bad exceptions'),
 ('4', 0, 'noeffect', 'noEffect', 'check if statement appears to have no effect'),
 ('',  0, 'modulo1', 'modulo1', 'check if using (expr % 1), it has no effect on integers and strings'),
 ('',  0, 'isliteral', 'isLiteral', "check if using (expr is const-literal), doesn't always work on integers and strings"),
     ]),
    ('Possible Errors', [
 ('r', 0, 'returnvalues', 'checkReturnValues', 'check consistent return values'),
 ('C', 0, 'implicitreturns', 'checkImplicitReturns', 'check if using implict and explicit return values'),
 ('O', 0, 'objattrs', 'checkObjectAttrs', 'check that attributes of objects exist'),
 ('7', 0, 'slots', 'slots', 'various warnings about incorrect usage of __slots__'),
 ('3', 0, 'properties', 'classicProperties', 'using properties with classic classes'),
 ( '', 0, 'emptyslots', 'emptySlots', 'check if __slots__ is empty'),
 ('D', 0, 'intdivide', 'intDivide', 'check if using integer division'),
 ('w', 0, 'shadow', 'shadows', 'check if local variable shadows a global'),
 ('s', 0, 'shadowbuiltin', 'shadowBuiltins', 'check if a variable shadows a builtin'),
     ]),
    ('Security', [
 ( '', 0, 'input', 'usesInput', 'check if input() is used'),
 ('6', 0, 'exec', 'usesExec', 'check if the exec statement is used'),
     ]),
    ('Suppressions', [
 ('q', 0, 'stdlib', 'ignoreStandardLibrary', 'ignore warnings from files under standard library'),
 ('b', 1, 'blacklist', 'blacklist', 'ignore warnings from the list of modules\n\t\t\t'),
 ('Z', 1, 'varlist', 'variablesToIgnore', 'ignore global variables not used if name is one of these values\n\t\t\t'),
 ('E', 1, 'unusednames', 'unusedNames', 'ignore unused locals/arguments if name is one of these values\n\t\t\t'),
 ( '', 0, 'deprecated', 'deprecated', 'ignore use of deprecated modules/functions'),
     ]),
    ('Complexity', [
 ('L', 1, 'maxlines', 'maxLines', 'maximum lines in a function'),
 ('B', 1, 'maxbranches', 'maxBranches', 'maximum branches in a function'),
 ('R', 1, 'maxreturns', 'maxReturns', 'maximum returns in a function'),
 ('J', 1, 'maxargs', 'maxArgs', 'maximum # of arguments to a function'),
 ('K', 1, 'maxlocals', 'maxLocals', 'maximum # of locals in a function'),
 ('5', 1, 'maxrefs', 'maxReferences', 'maximum # of identifier references (Law of Demeter)'),
 ('m', 0, 'moduledoc', 'noDocModule', 'no module doc strings'),
 ('c', 0, 'classdoc', 'noDocClass', 'no class doc strings'),
 ('f', 0, 'funcdoc', 'noDocFunc', 'no function/method doc strings'),
     ]),
    ('Debug', [
 ( '', 0, 'rcfile', None, 'print a .pycheckrc file generated from command line args'),
 ('P', 0, 'printparse', 'printParse', 'print internal checker parse structures'),
 ('d', 0, 'debug', 'debug', 'turn on debugging for checker'),
 ('Q', 0, 'quiet', None, 'turn off all output except warnings'),
 ('V', 0, 'version', None, 'print the version of PyChecker and exit'),
     ])
)

def init() :
    GET_OPT_VALUE = (('', ''), (':', '='),)
    shortArgs, longArgs = "", []
    for _, group in _OPTIONS :
        for opt in group:
            optStr = GET_OPT_VALUE[opt[1]]
            shortArgs = shortArgs + opt[0] + optStr[0]
            longArgs.append(opt[2] + optStr[1])
            longArgs.append('no-' + opt[2] + optStr[1])

    options = {}
    for _, group in _OPTIONS :
        for opt in group:
            shortArg, useValue, longArg, member, description = opt
            if shortArg != '' :
                options['-' + shortArg] = opt
            options['--no-' + longArg] = options['--' + longArg] = opt

    return shortArgs, longArgs, options

_SHORT_ARGS, _LONG_ARGS, _OPTIONS_DICT = init()

def _getRCfiles(filename) :
    """Return a list of .rc filenames, on Windows use the current directory
                                       on UNIX use the user's home directory
    """

    files = []
    home = os.environ.get('HOME')
    if home :
        files.append(home + os.sep + filename)
    files.append(filename)
    return files


_RC_FILE_HEADER = '''#
# .pycheckrc file created by PyChecker v%s @ %s
#
# It should be placed in your home directory (value of $HOME).
# If $HOME is not set, it will look in the current directory.
#

'''

def outputRc(cfg) :
    output = _RC_FILE_HEADER % (_VERSION, time.ctime(time.time()))
    for name, group in _OPTIONS :
        for opt in group:
            shortArg, useValue, longArg, member, description = opt
            if member is None :
                continue
            description = string.strip(description)
            value = getattr(cfg, member)
            optStr = '# %s\n%s = %s\n\n' % (description, member, `value`)
            output = output + optStr

    return output
        

class UsageError(Exception) :
    """Exception to indicate that the application should exit due to
       command line usage error."""

_SUPPRESSIONS_ERR = \
'''\nWarning, error processing defaults file: %s
\%s must be a dictionary ({}) -- ignoring suppressions\n'''

def _getSuppressions(name, dict, filename) :
    suppressions = dict.get(name, {})
    if type(suppressions) != type({}) :
        print _SUPPRESSIONS_ERR % (filename, name)
        suppressions = {}
    return suppressions


class Config :
    "Hold configuration information"

    def __init__(self) :
        "Initialize configuration with default values."

        self.debug = 0
        self.quiet = 0
        self.onlyCheckInitForMembers = 0
        self.printParse = 0
        self.quixote = 0

        self.noDocModule = 0
        self.noDocClass = 0
        self.noDocFunc = 0

        self.reportAllGlobals = 0
        self.allVariablesUsed = 0
        self.privateVariableUsed = 1
        self.membersUsed = 0
        self.importUsed = 1
        self.reimportSelf = 1
        self.moduleImportErrors = 1
        self.mixImport = 1
        self.packageImportUsed = 1
        self.localVariablesUsed = 1
        self.unusedLocalTuple = 0
        self.initDefinedInSubclass = 0
        self.baseClassInitted = 1
        self.abstractClasses = 1
        self.callingAttribute = 0
        self.classAttrExists = 1
        self.namedArgs = 0
        self.returnNoneFromInit = 1
        self.unreachableCode = 0
        self.constantConditions = 1
        self.constant1 = 0
        self.stringIteration = 1
        self.inconsistentTypes = 0
        self.unpackNonSequence = 1
        self.unpackLength = 1
        self.badExceptions = 1
        self.noEffect = 1
        self.deprecated = 1
        self.modulo1 = 1
        self.isLiteral = 1
        self.stringFind = 1

        self.unusedNames = _DEFAULT_UNUSED_LIST
        self.variablesToIgnore = _DEFAULT_VARIABLE_IGNORE_LIST
        self.blacklist = _DEFAULT_BLACK_LIST
        self.ignoreStandardLibrary = 0
        self.methodArgName = 'self'
        self.classmethodArgNames = ['cls', 'klass']
        self.checkOverridenMethods = 1
        self.checkSpecialMethods = 1

        self.argumentsUsed = 1
        self.varArgumentsUsed = 1
        self.ignoreSelfUnused = 0
        self.redefiningFunction = 1

        self.maxLines = 200
        self.maxBranches = 50
        self.maxReturns = 10
        self.maxArgs = 10
        self.maxLocals = 40
        self.maxReferences = 5

        self.slots = 1
        self.emptySlots = 1
        self.classicProperties = 1
        self.checkObjectAttrs = 1
        self.checkReturnValues = 1
        self.checkImplicitReturns = 1
        self.intDivide = 1
        self.shadows = 1
        self.shadowBuiltins = 1
        self.unaryPositive = 1
        self.modifyDefaultValue = 1
        self.usesExec = 0
        self.usesInput = 1
        self.constAttr = 1

    def loadFile(self, filename) :
        suppressions = {}
        suppressionRegexs = {}
        try :
            tmpGlobal, dict = {}, {}
            execfile(filename, tmpGlobal, dict)
            for key, value in dict.items() :
                if self.__dict__.has_key(key) :
                    self.__dict__[key] = value
                elif key not in ('suppressions', 'suppressionRegexs') and \
                     key[0] != '_':
                    print "Warning, option (%s) doesn't exist, ignoring" % key

            suppressions = _getSuppressions('suppressions', dict, filename)
            regexs = _getSuppressions('suppressionRegexs', dict, filename)
            for regex_str in regexs.keys() :
                regex = re.compile(regex_str)
                suppressionRegexs[regex] = regexs[regex_str]
        except IOError :
            pass       # ignore if no file
        except Exception, detail:
            print "Warning, error loading defaults file:", filename, detail
        return suppressions, suppressionRegexs

    def loadFiles(self, filenames, oldSuppressions = None) :
        if oldSuppressions is None :
            oldSuppressions = ({}, {})
        suppressions = oldSuppressions[0]
        suppressionRegexs = oldSuppressions[1]
        for filename in filenames:
            updates = self.loadFile(filename)
            suppressions.update(updates[0])
            suppressionRegexs.update(updates[1])
        return suppressions, suppressionRegexs

    def processArgs(self, argList, otherConfigFiles = None) :
        try :
            args, files = getopt.getopt(argList, _SHORT_ARGS, _LONG_ARGS)
        except getopt.error, detail :
            raise UsageError, detail

        quiet = self.quiet
        if otherConfigFiles is None:
            otherConfigFiles = []
        for arg, value in args :
            shortArg, useValue, longArg, member, description = _OPTIONS_DICT[arg]
            if member == None :
                # FIXME: this whole block is a hack
                if longArg == 'rcfile' :
                    sys.stdout.write(outputRc(self))
                    continue
                elif longArg == 'quiet' :
                    quiet = 1
                    continue
                elif longArg == 'quixote' :
                    import quixote
                    quixote.enable_ptl()
                    self.quixote = 1
                    continue
                elif longArg == 'config' :
                    otherConfigFiles.append(value)
                    continue
                elif longArg == 'version' :
                    # FIXME: it would be nice to define this in only one place
                    print _VERSION
                    sys.exit(0)

                self.noDocModule = 0
                self.noDocClass = 0
                self.noDocFunc = 0
                if longArg == 'errors' :
                    self.__dict__.update(errors_only())
                elif longArg == 'complexity' :
                    self.__dict__.update(errors_only(2))
            elif value  :
                newValue = value
                memberType = type(getattr(self, member))
                if memberType == type(0) :
                    newValue = int(newValue)
                elif memberType == type([]) :
                    newValue = string.split(newValue, ',')
                elif memberType == type('') and \
                     newValue[0] in '\'"':
                        try:
                            newValue = eval(newValue)
                        except:
                            msg = 'Invalid option parameter: %s for %s\n' % \
                                  (`newValue`, arg)
                            sys.stderr.write(msg)
                setattr(self, member, newValue)
            elif arg[0:2] == '--' :
                setattr(self, member, arg[2:5] != 'no-')
            else :
                # for shortArgs we only toggle
                setattr(self, member, not getattr(self, member))

        self.quiet = quiet
        if self.variablesToIgnore.count(CHECKER_VAR) &lt;= 0 :
            self.variablesToIgnore.append(CHECKER_VAR)

        return files

def errors_only(complexity = 0) :
    "Return {} of Config with all warnings turned off"
    dict = Config().__dict__
    for k, v in dict.items() :
        if type(v) == type(0) and v &gt;= complexity and not _ERRORS.has_key(k):
            dict[k] = 0
    return dict


def printArg(shortArg, longArg, description, defaultValue, useValue) :
    defStr = ''
    shortArgStr = '   '
    if shortArg:
        shortArgStr = '-%s,' % shortArg

    if defaultValue != None :
        if not useValue :
            if defaultValue :
                defaultValue = 'on'
            else :
                defaultValue = 'off'
        defStr = ' [%s]' % defaultValue
    args = "%s --%s" % (shortArgStr, longArg)
    print "  %-18s %s%s" % (args, description, defStr)

def usage(cfg = None) :
    print "Usage for: checker.py [options] PACKAGE ...\n"
    print "    PACKAGEs can be a python package, module or filename\n"
    print "Long options can be preceded with no- to turn off (e.g., no-namedargs)\n"
    print "Category"
    print "  Options:           Change warning for ... [default value]"
    
    if cfg is None :
        cfg = Config()
    for name, group in _OPTIONS :
        print
        print name + ":"
        for opt in group:  
            shortArg, useValue, longArg, member, description = opt
            defValue = None
            if member != None :
                defValue = cfg.__dict__[member]

            printArg(shortArg, longArg, description, defValue, useValue)


def setupFromArgs(argList) :
    "Returns (Config, [ file1, file2, ... ]) from argList"

    cfg = Config()
    try :
        suppressions = cfg.loadFiles(_getRCfiles(_RC_FILE))
        otherConfigFiles = []
        files = cfg.processArgs(argList, otherConfigFiles)
        if otherConfigFiles:
            suppressions = cfg.loadFiles(otherConfigFiles, suppressions)
        return cfg, files, suppressions
    except UsageError :
        usage(cfg)
        raise</t>
<t tx="ekr.20050212132124"></t>
<t tx="ekr.20050212132124.1">def find(moduleList, initialCfg, suppressions = None) :
    "Return a list of warnings found in the module list"

    if suppressions is None :
        suppressions = {}, {}

    utils.initConfig(initialCfg)

    warnings = []
    for module in moduleList :
        if module.moduleName in cfg().blacklist :
            continue

        modSuppress = getSuppression(module.moduleName, suppressions, warnings)
        globalRefs, classCodes = {}, {}

        # main_code can be null if there was a syntax error
        if module.main_code != None :
            funcInfo = _updateFunctionWarnings(module, module.main_code,
                                               None, warnings, globalRefs, 1)
            for code in funcInfo[1] :
                classCodes[code.co_name] = code

        _findFunctionWarnings(module, globalRefs, warnings, suppressions)

        for c in module.classes.values() :
                _findClassWarnings(module, c, classCodes.get(c.name),
                                   globalRefs, warnings, suppressions)

        if cfg().noDocModule and \
           module.module != None and module.module.__doc__ == None :
            warnings.append(Warning(module.filename(), 1, msgs.NO_MODULE_DOC))

        if cfg().allVariablesUsed or cfg().privateVariableUsed :
            prefix = None
            if not cfg().allVariablesUsed :
                prefix = "_"
            for ignoreVar in cfg().variablesToIgnore + cfg().unusedNames :
                globalRefs[ignoreVar] = ignoreVar
            warnings.extend(_getUnused(module, globalRefs, module.variables,
                                       msgs.VAR_NOT_USED, prefix))
        if cfg().importUsed :
            if module.moduleName != utils.INIT or cfg().packageImportUsed :
                # always ignore readline module, if [raw_]input() is used
                if globalRefs.has_key('input') or \
                   globalRefs.has_key('raw_input'):
                    globalRefs['readline'] = 0
                warnings.extend(_getUnused(module, globalRefs, module.modules,
                                           msgs.IMPORT_NOT_USED))

        if module.main_code != None :
            utils.popConfig()
        if modSuppress is not None :
            utils.popConfig()

    std_lib = None
    if cfg().ignoreStandardLibrary :
        std_lib = getStandardLibrary()
    return removeWarnings(warnings, getBlackList(cfg().blacklist), std_lib)</t>
<t tx="ekr.20050212135409">def _checkModuleAttribute(attr, module, code, ref) :
    # EKR
    if str(attr) in ('leo_config_directory','CODESET','mtime'): return
    
    try:
        if attr not in module.modules[ref].attributes and not utils.endswith(ref, '.' + attr) :
            code.addWarning(msgs.INVALID_MODULE_ATTR % attr)
    except (KeyError, TypeError):
        # if ref isn't found, or ref isn't even hashable, we don't care
        # we may not know, or ref could be something funky [e for e].method()
        pass

    try:
        _checkClassAttribute(attr, module.classes[ref], code)
    except (KeyError, TypeError):
        # if ref isn't found, or ref isn't even hashable, we don't care
        # we may not know, or ref could be something funky [e for e].method()
        pass
</t>
</tnodes>
</leo_file>
