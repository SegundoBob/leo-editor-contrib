<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="120" left="340" height="630" width="909"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20070626112503" str_leo_pos="4"><vh>@chapters</vh></v>
<v t="ekr.20070105153901"><vh>Tuple notes (revised originals)</vh>
<v t="ekr.20070105153901.1"><vh>Overview</vh></v>
<v t="ekr.20070105153901.2"><vh>Ahas</vh></v>
<v t="ekr.20070105153901.3"><vh>Block allocation</vh></v>
<v t="ekr.20070105153901.4"><vh>Stream allocation</vh></v>
<v t="ekr.20070105153901.5"><vh>Details</vh></v>
<v t="ekr.20070105153901.6"><vh>Deallocating objects</vh></v>
<v t="ekr.20070105153901.7"><vh>Debugging and production objects</vh></v>
<v t="ekr.20070105153901.8"><vh>Simplifications</vh></v>
<v t="ekr.20070105153901.9"><vh>Defining polymorphic streams</vh></v>
<v t="ekr.20070105153901.10"><vh>Using Streams</vh></v>
<v t="ekr.20070105153901.11"><vh>Lists Are Streams</vh></v>
<v t="ekr.20070105153901.12"><vh>Are any calls to calloc needed?</vh></v>
<v t="ekr.20070105153901.13"><vh>Abbreviation Macros</vh></v>
</v>
<v t="ekr.20071028032929"><vh>From LeoDiary.leo</vh>
<v t="ekr.20071028032929.1"><vh>Early Milestones</vh>
<v t="ekr.20071028032929.2"><vh>02/03/02 Leo 0.08 released</vh></v>
<v t="ekr.20071028032929.3"><vh>12/17/01 ** Leo 0.05 released</vh></v>
<v t="ekr.20071028032929.4"><vh>12/16/01 Leo becomes functional</vh></v>
<v t="ekr.20071028032929.5"><vh>12/13/01 Syntax coloring works</vh></v>
<v t="ekr.20071028032929.6"><vh>12/09/01 Tree now drawn properly</vh></v>
<v t="ekr.20071028032929.7"><vh>12/05/01 Tree works with Tkinter</vh></v>
<v t="ekr.20071028032929.8"><vh>11/10/01 ** began conversion to tk</vh></v>
<v t="ekr.20071028032929.9"><vh>10/26/01 First successful read of .leo file w/ @file nodes</vh></v>
<v t="ekr.20071028032929.10"><vh>9/29/01 c2py: Totally in love with Python</vh></v>
<v t="ekr.20071028032929.11"><vh>ca. 9/1/01 began work on wxPython version of Leo</vh></v>
</v>
<v t="ekr.20071028032929.12"><vh>Diary</vh>
<v t="ekr.20071028032929.13"><vh>2004</vh>
<v t="ekr.20071028032929.14" a="E"><vh>June 2004</vh>
<v t="ekr.20071028032929.15" a="E"><vh>6/3</vh>
<v t="ekr.20071028032929.16"><vh>Dimmed selection-only radio button in Find Panel</vh></v>
</v>
</v>
<v t="ekr.20071028032929.17"><vh>May 2004</vh>
<v t="ekr.20071028032929.18"><vh>5/19</vh>
<v t="ekr.20071028032929.19"><vh>Fixed @file read bug</vh></v>
<v t="ekr.20071028032929.20"><vh>Removed leoPluginsRef.leo from manifest.in</vh></v>
</v>
<v t="ekr.20071028032929.21"><vh>5/18 Released 4.2 a2</vh></v>
<v t="ekr.20071028032929.22"><vh>5/3 Made sure file indices are always assigned when writing files.</vh></v>
</v>
<v t="ekr.20071028032929.23"><vh>March 2004</vh>
<v t="ekr.20071028032929.24"><vh>4/30</vh>
<v t="ekr.20071028032929.25"><vh>Convert all plugins to g. style</vh></v>
<v t="ekr.20071028032929.26"><vh>Modified g. conversion script so it can be run anywhere</vh></v>
</v>
<v t="ekr.20071028032929.27"><vh>4/27</vh>
<v t="ekr.20071028032929.28"><vh>Added unit tests for batch mode</vh></v>
<v t="ekr.20071028032929.29"><vh>Added useNullUndoer option to nullFrame class</vh></v>
</v>
<v t="ekr.20071028032929.30"><vh>4/26</vh>
<v t="ekr.20071028032929.31"><vh>Removed v.iterators</vh></v>
<v t="ekr.20071028032929.32"><vh>Disambiguted clones while selecting</vh></v>
<v t="ekr.20071028032929.33"><vh>Added code to restore top and current positions</vh></v>
<v t="ekr.20071028032929.34"><vh>Fixed bug in find.changeSelection</vh></v>
<v t="ekr.20071028032929.35"><vh>Converted vnodes, tnodes and positions to new-style classes</vh></v>
<v t="ekr.20071028032929.36"><vh>Removed verbose option from setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20071028032929.37"><vh>Eliminated calls to p.__cmp__(None)</vh></v>
<v t="ekr.20071028032929.38"><vh>Converted vnode,tnode,position classes to new-style classes</vh></v>
<v t="ekr.20071028032929.39"><vh>Improved the speed of isAnyAtFileNode</vh></v>
</v>
<v t="ekr.20071028032929.40"><vh>4/25 Released 4.2 a1</vh>
<v t="ekr.20071028032929.41"><vh>Fix three major performance bugs</vh></v>
<v t="ekr.20071028032929.42"><vh>Removed all  back quotes</vh></v>
</v>
<v t="ekr.20071028032929.43"><vh>3/22</vh>
<v t="ekr.20071028032929.44"><vh>Replaced joinList by vnodeList</vh></v>
</v>
<v t="ekr.20071028032929.45"><vh>3/14</vh>
<v t="ekr.20071028032929.46"><vh>Added asserts when g.app.debug is true</vh></v>
<v t="ekr.20071028032929.47"><vh>HUGE AHA: greatly simplified p.nodeAfter and p.threadNext</vh></v>
</v>
<v t="ekr.20071028032929.48"><vh>3/12</vh>
<v t="ekr.20071028032929.49"><vh>Fixed nasty bug in p.linkAsRoot</vh></v>
<v t="ekr.20071028032929.50"><vh>Fixed and tested the script to replace x by g.x</vh></v>
<v t="ekr.20071028032929.51"><vh>Added c.allNodes_iter</vh></v>
<v t="ekr.20071028032929.52"><vh>Replaced porv by p</vh></v>
<v t="ekr.20071028032929.53"><vh>Removed g.sharedNodes ivar and related code</vh></v>
</v>
<v t="ekr.20071028032929.54"><vh>3/11</vh>
<v t="ekr.20071028032929.55"><vh>Got Save To command working</vh></v>
<v t="ekr.20071028032929.56"><vh>Added new iters</vh></v>
<v t="ekr.20071028032929.57"><vh>Added copy param to all position iterators</vh></v>
</v>
<v t="ekr.20071028032929.58"><vh>3/9 All calls to tag_bind must use a copy of position</vh></v>
<v t="ekr.20071028032929.59"><vh>3/6 Realized that position proxies are now efficient</vh></v>
<v t="ekr.20071028032929.60"><vh>3/4 Realized that iterators make the position class safe</vh></v>
<v t="ekr.20071028032929.61"><vh>3/5</vh>
<v t="ekr.20071028032929.62"><vh>Replaced x by g.x for all x in leoGlobals</vh></v>
<v t="ekr.20071028032929.63"><vh>Replaced app proxy class from leoGlobals by app global var</vh></v>
<v t="ekr.20071028032929.64"><vh>Replaced true,false by True,False</vh></v>
</v>
</v>
<v t="ekr.20071028032929.65"><vh>February 2004</vh>
<v t="ekr.20071028032929.66"><vh>2/16</vh>
<v t="ekr.20071028032929.67"><vh>Restored Toggle Angle Bracket command (without shortcut)</vh></v>
<v t="ekr.20071028032929.68"><vh>Changed Undo/Redo messages</vh></v>
</v>
<v t="ekr.20071028032929.69"><vh>2/1</vh>
<v t="ekr.20071028032929.70"><vh>Fixed bugs in Script-Find/change and improved documentation</vh></v>
</v>
</v>
<v t="ekr.20071028032929.71"><vh>January 2004</vh>
<v t="ekr.20071028032929.72"><vh>1/30</vh>
<v t="ekr.20071028032929.73"><vh>Added script to look for blanks preceding tabs in leading whitespace</vh></v>
<v t="ekr.20071028032929.74"><vh>Fixed several bugs</vh></v>
</v>
<v t="ekr.20071028032929.75"><vh>1/29</vh>
<v t="ekr.20071028032929.76"><vh>Only mark ancestor @file nodes dirty when creating,moving,changing nodes</vh></v>
<v t="ekr.20071028032929.77"><vh>fixed bugs: see 4.1 rc4 projects for details</vh></v>
</v>
<v t="ekr.20071028032929.78"><vh>1/26</vh>
<v t="ekr.20071028032929.79"><vh>Properly handle exceptions in commands</vh></v>
<v t="ekr.20071028032929.80"><vh>Eliminated control-v bug on various platforms</vh></v>
<v t="ekr.20071028032929.81"><vh>Added Dave Hein's Reformat Paragraph code.</vh></v>
<v t="ekr.20071028032929.82"><vh>Fixed Move Up bug involving clones</vh></v>
</v>
<v t="ekr.20071028032929.83"><vh>1/8</vh>
<v t="ekr.20071028032929.84"><vh>Esc hides the Find panel</vh></v>
<v t="ekr.20071028032929.85"><vh>Return in Find panel simuatest the Find button</vh></v>
<v t="ekr.20071028032929.86"><vh>Fixed huge performance bug in cut/copy nodes.</vh></v>
<v t="ekr.20071028032929.87"><vh>Improved sample code for batch mode in LeoDocs.leo</vh></v>
<v t="ekr.20071028032929.88"><vh>Removed a complex assert in colorizer</vh></v>
<v t="ekr.20071028032929.89"><vh>Change file extenstion for LaTeX files from .latext to .tex</vh></v>
</v>
<v t="ekr.20071028032929.90"><vh>1/6 Enable drawing after exceptions</vh></v>
<v t="ekr.20071028032929.91"><vh>1/5</vh>
<v t="ekr.20071028032929.92"><vh>Import now creates @root-code</vh></v>
<v t="ekr.20071028032929.93"><vh>Added sys.platform to signon message in log pane</vh></v>
<v t="ekr.20071028032929.94"><vh>Added test/test.leo to all distributions</vh></v>
<v t="ekr.20071028032929.95"><vh>Added LP link to Leo's site</vh></v>
</v>
</v>
</v>
<v t="ekr.20071028032929.96"><vh>2003</vh>
<v t="ekr.20071028032929.97"><vh>December 2003</vh>
<v t="ekr.20071028032929.98"><vh>12/19</vh>
<v t="ekr.20071028032929.99"><vh>Released 4.1 rc3</vh></v>
<v t="ekr.20071028032929.100"><vh>All unittests pass (but only with tkinterGui)</vh></v>
<v t="ekr.20071028032929.101"><vh>Added nullObject class to leoGlobals.py</vh></v>
<v t="ekr.20071028032929.102"><vh>Fixed serious problem reading 3.x files</vh></v>
</v>
<v t="ekr.20071028032929.103"><vh>12/18</vh>
<v t="ekr.20071028032929.104"><vh>Fixed crasher in 3.x version of scanText</vh></v>
<v t="ekr.20071028032929.105"><vh>Released 4.1 rc2</vh></v>
<v t="ekr.20071028032929.106"><vh>Added year to timestamp</vh></v>
<v t="ekr.20071028032929.107"><vh>Fixed bug in getInsertLines</vh></v>
</v>
<v t="ekr.20071028032929.108"><vh>12/17</vh>
<v t="ekr.20071028032929.109"><vh>Unittests for import don't alter test.leo</vh></v>
</v>
<v t="ekr.20071028032929.110"><vh>12/15</vh>
<v t="ekr.20071028032929.111"><vh>Supported default font sizes for all panes</vh></v>
<v t="ekr.20071028032929.112"><vh>Changed format of timestamps</vh></v>
<v t="ekr.20071028032929.113"><vh>Changed *.* to * in dialogs</vh></v>
<v t="ekr.20071028032929.114"><vh>Released 4.1 rc1</vh></v>
<v t="ekr.20071028032929.115"><vh>All unit tests now pass (import tests leave stuff behind)</vh></v>
<v t="ekr.20071028032929.116"><vh>Don't warn about missing path when writing scripts</vh></v>
<v t="ekr.20071028032929.117"><vh>Set default font size to None in leoConfig.txt.</vh></v>
</v>
<v t="ekr.20071028032929.118"><vh>12/13</vh>
<v t="ekr.20071028032929.119"><vh>Completed move code in leoTest.py</vh></v>
<v t="ekr.20071028032929.120"><vh>Moved encoding messages so they don't appear in batch mode</vh></v>
<v t="ekr.20071028032929.121"><vh>Autoclean outline on save &amp; executeScript does not set tnodeList</vh></v>
<v t="ekr.20071028032929.122"><vh>Patched scanPythonClass to put class docstrings in class nodes</vh></v>
</v>
<v t="ekr.20071028032929.123"><vh>12/11</vh>
<v t="ekr.20071028032929.124"><vh>Fixed big performance bug in removeSentinelLines</vh></v>
<v t="ekr.20071028032929.125"><vh>Call leoTest.fail in when import/export routines can't open a file</vh></v>
<v t="ekr.20071028032929.126"><vh>created unitTestGui class</vh></v>
</v>
<v t="ekr.20071028032929.127"><vh>12/09</vh>
<v t="ekr.20071028032929.128"><vh>Leo now allows @ignore nodes and orphan nodes in @file-nosent trees</vh></v>
<v t="ekr.20071028032929.129"><vh>Looked at report of import bug</vh></v>
</v>
<v t="ekr.20071028032929.130"><vh>12/08</vh>
<v t="ekr.20071028032929.131"><vh>Investigated &amp; fixed copy/paste bugs</vh></v>
</v>
<v t="ekr.20071028032929.132"><vh>12/07</vh>
<v t="ekr.20071028032929.133"><vh>Corrected counts when replacing tabs/blanks</vh></v>
<v t="ekr.20071028032929.134"><vh>Added file open dialog to Import Derived Files command</vh></v>
<v t="ekr.20071028032929.135"><vh>Made sure that Reformat Paragraph makes the new insertion point visible</vh></v>
<v t="ekr.20071028032929.136"><vh>Changed logControl to logCtrl</vh></v>
</v>
<v t="ekr.20071028032929.137"><vh>12/06</vh>
<v t="ekr.20071028032929.138"><vh>Fixed bug when untangling html</vh></v>
<v t="ekr.20071028032929.139"><vh>Fixed clone-dragging bug</vh></v>
<v t="ekr.20071028032929.140"><vh>Load plugins dynamically using pluginsManager.txt</vh></v>
</v>
<v t="ekr.20071028032929.141"><vh>12/05</vh>
<v t="ekr.20071028032929.142"><vh>Ran pychecker</vh></v>
</v>
<v t="ekr.20071028032929.143"><vh>12/04</vh>
<v t="ekr.20071028032929.144"><vh>Created and read paths with chinese characters in folder and file names</vh></v>
<v t="ekr.20071028032929.145"><vh>Fixed all remaining bugs (except duplicate tnode index)</vh></v>
</v>
<v t="ekr.20071028032929.146"><vh>12/03</vh>
<v t="ekr.20071028032929.147"><vh>Replaced c.OpenWithFileName by global openWithFileName</vh></v>
<v t="ekr.20071028032929.148"><vh>Fixed dangerous bug in Convert Blanks command</vh></v>
<v t="ekr.20071028032929.149"><vh>Added the mod_tempfname plugin</vh></v>
</v>
<v t="ekr.20071028032929.150"><vh>12/01</vh>
<v t="ekr.20071028032929.151"><vh>Update recent files in newLeoCommanderAndFrame</vh></v>
</v>
</v>
<v t="ekr.20071028032929.152"><vh>November 2003</vh>
<v t="ekr.20071028032929.153"><vh>11/23 Released 4.1 beta 5 to cvs only</vh>
<v t="ekr.20071028032929.154"><vh>Replaced app.batchLog with app.log</vh></v>
<v t="ekr.20071028032929.155"><vh>Fixed Undo Change All (in headlines) problem</vh></v>
<v t="ekr.20071028032929.156"><vh>Added defensive code to prevent crash in colorizer</vh></v>
<v t="ekr.20071028032929.157"><vh>Removed annoying Go To Line Number "error" message.</vh></v>
<v t="ekr.20071028032929.158"><vh>Fixed duplicate shortcut message when creating a popup menu</vh></v>
<v t="ekr.20071028032929.159"><vh>Made newTnode more robust</vh></v>
<v t="ekr.20071028032929.160"><vh>Fixed crashers in extract and extract section</vh></v>
<v t="ekr.20071028032929.161"><vh>Fixed bug in putRefLine</vh></v>
<v t="ekr.20071028032929.162"><vh>Tested --script from command line</vh></v>
</v>
<v t="ekr.20071028032929.163"><vh>11/22</vh>
<v t="ekr.20071028032929.164"><vh>Moved batch plugin into Leo's core.</vh></v>
<v t="ekr.20071028032929.165"><vh>Added nullUndoer class</vh></v>
<v t="ekr.20071028032929.166"><vh>Disabled Edit Body/Headline commands in batch mode</vh></v>
<v t="ekr.20071028032929.167"><vh>Added app.batchMode ivar</vh></v>
<v t="ekr.20071028032929.168"><vh>Added enable/disable methods to nullLog</vh></v>
<v t="ekr.20071028032929.169"><vh>Created  v.scriptSetBodyString</vh></v>
</v>
<v t="ekr.20071028032929.170"><vh>11/20 released 4.1 beta 4</vh>
<v t="ekr.20071028032929.171"><vh>created null frame,log,body,tree,menu,gui classes</vh></v>
</v>
<v t="ekr.20071028032929.172"><vh>11/19</vh>
<v t="ekr.20071028032929.173"><vh>Initialize write routines properly in Execute Script command</vh></v>
<v t="ekr.20071028032929.174"><vh>Leo now generates reference properly when more than one on the same line</vh></v>
<v t="ekr.20071028032929.175"><vh>Fixed several reorg bugs in leoPlugins.leo</vh></v>
<v t="ekr.20071028032929.176"><vh>Allow all Leo constructs in Execute Script command</vh></v>
<v t="ekr.20071028032929.177"><vh>Protected all tk code in leoPlugins.leo</vh></v>
<v t="ekr.20071028032929.178"><vh>Fixed reorg problem in the nav bar</vh></v>
<v t="ekr.20071028032929.179"><vh>Wrapped all calls to os.path</vh></v>
<v t="ekr.20071028032929.180"><vh>Convert doc sections to doc strings</vh></v>
</v>
<v t="ekr.20071028032929.181"><vh>11/18 released 4.1 beta 3</vh>
<v t="ekr.20071028032929.182"><vh>Fixed bug in initScriptFind</vh></v>
<v t="ekr.20071028032929.183"><vh>released 4.1b3</vh></v>
</v>
<v t="ekr.20071028032929.184"><vh>11/17</vh>
<v t="ekr.20071028032929.185"><vh>Fixed all problems reported by Pychecker</vh></v>
<v t="ekr.20071028032929.186"><vh>Fixed new crasher in batch change commands</vh></v>
<v t="ekr.20071028032929.187"><vh>Fixed new crasher in Show Invisibles command</vh></v>
<v t="ekr.20071028032929.188"><vh>Fixed (new?) unbounded recursion in Go To Next Clone command</vh></v>
<v t="ekr.20071028032929.189"><vh>Fixed (new?) crasher in Abort Edit Headline command</vh></v>
<v t="ekr.20071028032929.190"><vh>Fixed new crashers when opening popup menu</vh></v>
<v t="ekr.20071028032929.191"><vh>Fixed new crasher in Font panel</vh></v>
<v t="ekr.20071028032929.192"><vh>Import traceback only as needed</vh></v>
<v t="ekr.20071028032929.193"><vh>Fixed bug that caused new headlines not to be selected</vh></v>
<v t="ekr.20071028032929.194"><vh>getSelectionLines now returns the insertion line if no selection</vh></v>
<v t="ekr.20071028032929.195"><vh>Replaced c.body and c.log by c.frame.body &amp; c.frame.log</vh></v>
</v>
<v t="ekr.20071028032929.196"><vh>11/16</vh>
<v t="ekr.20071028032929.197"><vh>Reorg is now complete!</vh></v>
<v t="ekr.20071028032929.198"><vh>Moved menu utilities to leoMenu class</vh></v>
<v t="ekr.20071028032929.199"><vh>Removed all redirectors from frame to body</vh></v>
<v t="ekr.20071028032929.200"><vh>Simplified menu bindings</vh></v>
<v t="ekr.20071028032929.201"><vh>Fixed Find Matching Brackets command</vh></v>
</v>
<v t="ekr.20071028032929.202"><vh>11/15</vh>
<v t="ekr.20071028032929.203"><vh>Fixed problem with whole-word searches</vh></v>
<v t="ekr.20071028032929.204"><vh>Fixed problem with attaching icons to dialogs</vh></v>
<v t="ekr.20071028032929.205"><vh>Fixed crasher in Toggle Active Pane command</vh></v>
</v>
<v t="ekr.20071028032929.206"><vh>11/13</vh>
<v t="ekr.20071028032929.207"><vh>wx gui plugin now works again</vh></v>
<v t="ekr.20071028032929.208"><vh>Finished reorg</vh></v>
</v>
<v t="ekr.20071028032929.209"><vh>11/12</vh>
<v t="ekr.20071028032929.210"><vh>Created app.gui.utils class</vh></v>
<v t="ekr.20071028032929.211"><vh>Created base classes for color, compare, find, font &amp; prefs panels</vh></v>
<v t="ekr.20071028032929.212"><vh>Fixed Recent Files regression</vh></v>
</v>
<v t="ekr.20071028032929.213"><vh>11/10</vh>
<v t="ekr.20071028032929.214"><vh>Continued major reorg</vh></v>
<v t="ekr.20071028032929.215"><vh>Added redirection routines to leoFrame class</vh></v>
</v>
<v t="ekr.20071028032929.216"><vh>11/9</vh>
<v t="ekr.20071028032929.217"><vh>Reorganized the code to use leoMenu and leoTkinterMenu classes</vh></v>
<v t="ekr.20071028032929.218"><vh>Fixed LaTeX syntax coloring bug</vh></v>
<v t="ekr.20071028032929.219"><vh>Implemented a limited form of the Selection Only find/change commands</vh></v>
<v t="ekr.20071028032929.220"><vh>Created unit tests to run Check Outline command</vh></v>
</v>
<v t="ekr.20071028032929.221"><vh>11/8</vh>
<v t="ekr.20071028032929.222"><vh>Created Page Count script</vh></v>
</v>
<v t="ekr.20071028032929.223"><vh>11/7 4.1 beta 1 released</vh>
<v t="ekr.20071028032929.224"><vh>Fixed crasher in computeLoadDir</vh></v>
<v t="ekr.20071028032929.225"><vh>Fixed a real bug in the Change, Then Find command</vh></v>
<v t="ekr.20071028032929.226"><vh>Cleaned up Pychecker complaints</vh></v>
<v t="ekr.20071028032929.227"><vh>Released 4.1 beta 1</vh></v>
</v>
<v t="ekr.20071028032929.228"><vh>11/6</vh>
<v t="ekr.20071028032929.229"><vh>Create initScriptFind</vh></v>
<v t="ekr.20071028032929.230"><vh>Added support for undo</vh></v>
<v t="ekr.20071028032929.231"><vh>Yes, a script change checkbox IS a good idea</vh></v>
</v>
<v t="ekr.20071028032929.232"><vh>11/5</vh>
<v t="ekr.20071028032929.233"><vh>Got script search/change working (!!)</vh>
<v t="ekr.20071028032929.234"><vh>find script</vh></v>
</v>
<v t="ekr.20071028032929.235"><vh>Fixed Serious Undo Change All bug</vh></v>
<v t="ekr.20071028032929.236"><vh>Leo now ignores unknown prefs and find prefs</vh></v>
<v t="ekr.20071028032929.237"><vh>Leo now writes node_only find prefs</vh></v>
<v t="ekr.20071028032929.238"><vh>Fixed first node-only find bug</vh></v>
</v>
<v t="ekr.20071028032929.239"><vh>11/4</vh>
<v t="ekr.20071028032929.240"><vh>Fixed bug involving 0x1a characters in body text.</vh></v>
<v t="ekr.20071028032929.241"><vh>Added Check Outline command</vh></v>
<v t="ekr.20071028032929.242"><vh>Added Hoist/De-Hoist commands</vh></v>
</v>
<v t="ekr.20071028032929.243"><vh>11/3</vh>
<v t="ekr.20071028032929.244"><vh>Leo now does an auto-save only if files have actually been changed.</vh></v>
<v t="ekr.20071028032929.245"><vh>Changed all .leo files to use the -ko cvs option</vh></v>
</v>
<v t="ekr.20071028032929.246"><vh>11/2</vh>
<v t="ekr.20071028032929.247"><vh>Added use_gnx config setting</vh></v>
<v t="ekr.20071028032929.248"><vh>Converted to using gnx</vh></v>
</v>
</v>
<v t="ekr.20071028032929.249"><vh>October 2003</vh>
<v t="ekr.20071028032929.250"><vh>10/31</vh>
<v t="ekr.20071028032929.251"><vh>Added bindings to app.gui.root to catch all control keys</vh></v>
<v t="ekr.20071028032929.252"><vh>Added config_encoding setting</vh></v>
</v>
<v t="ekr.20071028032929.253"><vh>10/27</vh>
<v t="ekr.20071028032929.254"><vh>Colorizer now uses c.body routines</vh></v>
<v t="ekr.20071028032929.255"><vh>Replaced frame.top by frame in call to set_focus</vh></v>
<v t="ekr.20071028032929.256"><vh>Replace calls to after and after_idle by app.gui calls.</vh></v>
<v t="ekr.20071028032929.257"><vh>Removed app.root from all non-gui code</vh></v>
</v>
<v t="ekr.20071028032929.258"><vh>10/26 code reorg</vh>
<v t="ekr.20071028032929.259"><vh>Replaced all references to leoDialog by corresponding app.gui calls</vh></v>
<v t="ekr.20071028032929.260"><vh>Moved color panels into leoTkinterColorPanels.py</vh></v>
<v t="ekr.20071028032929.261"><vh>Replaced all direct references to color panels by corresponding appl.gui calls</vh></v>
<v t="ekr.20071028032929.262"><vh>Replaced all direct references to find panel by corresponding appl.gui calls</vh></v>
</v>
<v t="ekr.20071028032929.263"><vh>10/25</vh>
<v t="ekr.20071028032929.264"><vh>Made tnode indices immutable: fixed bad copy/paste bug</vh></v>
<v t="ekr.20071028032929.265"><vh>Fixed crasher with bad pattern match patterns</vh></v>
<v t="ekr.20071028032929.266"><vh>Fixed bug in Go To Line Number command</vh></v>
<v t="ekr.20071028032929.267"><vh>Disabled startup traces</vh></v>
<v t="ekr.20071028032929.268"><vh>Fixed plugin problems (now fixed in 4.0.2 and 4.1)</vh></v>
<v t="ekr.20071028032929.269"><vh>Cleaned up the reformatParagraph code</vh></v>
<v t="ekr.20071028032929.270"><vh>Removed kludge from setSelectionAreas</vh></v>
</v>
<v t="ekr.20071028032929.271"><vh>10/24</vh>
<v t="ekr.20071028032929.272"><vh>Completed new version of reformatParagraph</vh></v>
<v t="ekr.20071028032929.273"><vh>Rewrote findBoundParagraph using splitLines</vh></v>
<v t="ekr.20071028032929.274"><vh>Rewrote getInsertLines (leoTkinterBody)</vh></v>
<v t="ekr.20071028032929.275"><vh>Wrote splitLines &amp; joinLines utilities</vh></v>
<v t="ekr.20071028032929.276"><vh>Fixed problem with indent/undent</vh></v>
</v>
<v t="ekr.20071028032929.277"><vh>10/22</vh>
<v t="ekr.20071028032929.278"><vh>Fixed crasher in onOpenWithFileName</vh></v>
</v>
<v t="ekr.20071028032929.279"><vh>10/19</vh>
<v t="ekr.20071028032929.280"><vh>Made app.forceShutdown work in "idle" hook</vh></v>
<v t="ekr.20071028032929.281"><vh>Properly enable green back arrow in nav bar</vh></v>
</v>
<v t="ekr.20071028032929.282"><vh>10/17</vh>
<v t="ekr.20071028032929.283"><vh>Renamed .body to .bodyCtrl</vh></v>
<v t="ekr.20071028032929.284"><vh>Create leoTkinterLog  &amp; leoTkinterBody classes</vh></v>
<v t="ekr.20071028032929.285"><vh>Created frame.destroySelf routine</vh></v>
<v t="ekr.20071028032929.286"><vh>Eliminated all references to frame.top outside of LeoTkinterFrame class</vh></v>
<v t="ekr.20071028032929.287"><vh>tree.drawIcon now injects v.iconx and v.iconv ivars</vh></v>
<v t="ekr.20071028032929.288"><vh>Began gui reorg</vh></v>
<v t="ekr.20071028032929.289"><vh>4.0 final released</vh></v>
</v>
<v t="ekr.20071028032929.290"><vh>10/16</vh>
<v t="ekr.20071028032929.291"><vh>Created app.forceShutdown</vh></v>
<v t="ekr.20071028032929.292"><vh>Fixed more bugs in undoReplace: all undo tests now pass</vh></v>
</v>
<v t="ekr.20071028032929.293"><vh>10/15</vh>
<v t="ekr.20071028032929.294"><vh>Added several plugins and scripts to leoPlugins.leo</vh></v>
<v t="ekr.20071028032929.295"><vh>Removed "invalid @lineending directive" warning</vh></v>
<v t="ekr.20071028032929.296"><vh>Added support so plugins can force Leo to quit during startup</vh></v>
<v t="ekr.20071028032929.297"><vh>Fixed bug in removeSentinelsCommand</vh></v>
<v t="ekr.20071028032929.298"><vh>Improved Go To Line Number command</vh></v>
<v t="ekr.20071028032929.299"><vh>Improved confusing error message from Go To Line Number command</vh></v>
</v>
<v t="ekr.20071028032929.300"><vh>10/14</vh>
<v t="ekr.20071028032929.301"><vh>Added redirect_execute_script_output_to_log_pane setting</vh></v>
<v t="ekr.20071028032929.302"><vh>Speed up clone operation by calling initAllCloneBitsInTree</vh></v>
<v t="ekr.20071028032929.303"><vh>Several undo changes &amp; bug fixes</vh></v>
</v>
<v t="ekr.20071028032929.304"><vh>10/13 Released 4.0 beta 4</vh></v>
<v t="ekr.20071028032929.305"><vh>10/10</vh>
<v t="ekr.20071028032929.306"><vh>Added var or const prefixes when importing elisp</vh></v>
<v t="ekr.20071028032929.307"><vh>Added support for elisp colorising</vh></v>
<v t="ekr.20071028032929.308"><vh>Fixed bug in c.clone</vh></v>
<v t="ekr.20071028032929.309"><vh>Created hint messages for Extract Section &amp; Extract Section Names commands</vh></v>
<v t="ekr.20071028032929.310"><vh>changed string.letters to string.ascii_letters throughout</vh></v>
<v t="ekr.20071028032929.311"><vh>Fixed bug in bracket scanner</vh></v>
</v>
<v t="ekr.20071028032929.312"><vh>10/9 Released 4.0 beta 3</vh>
<v t="ekr.20071028032929.313"><vh>Added support for importing elisp (.el) files</vh></v>
<v t="ekr.20071028032929.314"><vh>Force a complete recolor after any cut/paste or corresponding undo/redo</vh></v>
<v t="ekr.20071028032929.315"><vh>Improved 4.0 version of Go To Line Number command</vh></v>
<v t="ekr.20071028032929.316"><vh>Released 4.0 beta 3</vh></v>
</v>
<v t="ekr.20071028032929.317"><vh>10/8</vh>
<v t="ekr.20071028032929.318"><vh>Fixed long-standing clone-mark bug</vh></v>
<v t="ekr.20071028032929.319"><vh>Added support for unknown tnode and vnode attributes</vh></v>
<v t="ekr.20071028032929.320"><vh>Fixed bug in gui destroy logic</vh></v>
<v t="ekr.20071028032929.321"><vh>Changed c.frame.mFileName to c.mFileName in plugins.leo</vh></v>
</v>
<v t="ekr.20071028032929.322"><vh>10/7</vh>
<v t="ekr.20071028032929.323"><vh>Fixed crash in sentinelName</vh></v>
<v t="ekr.20071028032929.324"><vh>Added __setattr__ method to leoProxy class</vh></v>
<v t="ekr.20071028032929.325"><vh>Reenabled orphans &amp; ignored test in new write logic</vh></v>
<v t="ekr.20071028032929.326"><vh>Cleaned up version code and added build number to signon</vh></v>
</v>
<v t="ekr.20071028032929.327"><vh>10/6</vh>
<v t="ekr.20071028032929.328"><vh>Converted the code to use newLeoCommanderAndFrame</vh></v>
<v t="ekr.20071028032929.329"><vh>Added better error message in setDefaultIcon</vh></v>
</v>
<v t="ekr.20071028032929.330"><vh>10/3 Released 4.0 beta 2</vh>
<v t="ekr.20071028032929.331"><vh>Released 4.0 beta 2</vh></v>
<v t="ekr.20071028032929.332"><vh>Fixed problem setting loadDir in startup logic</vh></v>
</v>
<v t="ekr.20071028032929.333"><vh>10/2</vh>
<v t="ekr.20071028032929.334"><vh>Still problems making Read @file Nodes undoable</vh></v>
<v t="ekr.20071028032929.335"><vh>Import Derived File command is now undoable</vh></v>
<v t="ekr.20071028032929.336"><vh>Moved Clear Recent Files menu item into Recent Files menu</vh></v>
<v t="ekr.20071028032929.337"><vh>Fixed bugs involving find params</vh></v>
<v t="ekr.20071028032929.338"><vh>Fixed Python Import bug</vh></v>
</v>
<v t="ekr.20071028032929.339"><vh>10/1</vh>
<v t="ekr.20071028032929.340"><vh>Added support for two new settings affecting drags</vh></v>
<v t="ekr.20071028032929.341"><vh>Marked changed nodes &amp; make the @file node and the outline dirty.</vh></v>
<v t="ekr.20071028032929.342"><vh>Fixed Go To Outline command so it doesn't crash: More work needed.</vh></v>
<v t="ekr.20071028032929.343"><vh>Ensured newlines before all sentinels in @rawfile</vh></v>
<v t="ekr.20071028032929.344"><vh>Fixed @rawfile write problem</vh></v>
</v>
</v>
<v t="ekr.20071028032929.345"><vh>Sept 2003</vh>
<v t="ekr.20071028032929.346"><vh>9/30</vh>
<v t="ekr.20071028032929.347"><vh>Removed unused v arg from writeOld/NewDerivedFiles</vh></v>
<v t="ekr.20071028032929.348"><vh>Removed unused nosentinels arg from writeNewDerivedFiles</vh></v>
<v t="ekr.20071028032929.349"><vh>Removed putLeadingNewlineFlag arg from putSentinel</vh></v>
<v t="ekr.20071028032929.350"><vh>Renamed new scanText to scanText4</vh></v>
<v t="ekr.20071028032929.351"><vh>Removed many Pychecker warnings</vh>
<v t="ekr.20071028032929.352"><vh>Details</vh></v>
</v>
<v t="ekr.20071028032929.353"><vh>Added better log message for Convert All Tabs/Blanks commands</vh></v>
<v t="ekr.20071028032929.354"><vh>Created leoProxy class and simplified the code</vh></v>
</v>
<v t="ekr.20071028032929.355"><vh>9/29</vh>
<v t="ekr.20071028032929.356"><vh>A "gotcha" re using global app var</vh></v>
<v t="ekr.20071028032929.357"><vh>Added crucial defensive checks in v.headString() and v.bodySting()</vh></v>
<v t="ekr.20071028032929.358"><vh>Fixed several more unicode bugs</vh></v>
<v t="ekr.20071028032929.359"><vh>Removed setApp function</vh></v>
</v>
<v t="ekr.20071028032929.360"><vh>9/28</vh>
<v t="ekr.20071028032929.361"><vh>Added many calls to toUnicode.  Marked with 9/28/03</vh></v>
<v t="ekr.20071028032929.362"><vh>trace now always prints arguments.</vh></v>
<v t="ekr.20071028032929.363"><vh>Rewrote icon code so it doesn't use PIL or tkIcon in Python 2.3</vh></v>
</v>
<v t="ekr.20071028032929.364"><vh>9/27 </vh>
<v t="ekr.20071028032929.365"><vh>Defined dialog and icons routines in tkinterGui and leoGui</vh></v>
<v t="ekr.20071028032929.366"><vh>Defined focus routines in tkinterGui and leoGui</vh></v>
<v t="ekr.20071028032929.367"><vh>Replaced app.runMainLoop with app.gui.runMainLoop</vh></v>
<v t="ekr.20071028032929.368"><vh>Created leoGui base class for tkinterGui class</vh></v>
<v t="ekr.20071028032929.369"><vh>Moved all gui startup logic into tkingerGui class</vh></v>
</v>
<v t="ekr.20071028032929.370"><vh>9/26 4.0 beta 1 released</vh>
<v t="ekr.20071028032929.371"><vh>changed default for config.write_old_format_derived_files</vh></v>
</v>
<v t="ekr.20071028032929.372"><vh>9/22</vh>
<v t="ekr.20071028032929.373"><vh>Changed leoConfig.txt so we write 3.x derived files if leoConfig.txt does not exist</vh></v>
<v t="ekr.20071028032929.374"><vh>writeAll and writeMissing now return a count of the written files</vh></v>
<v t="ekr.20071028032929.375"><vh>getLeoFile computes joinLists before reading derived files</vh></v>
<v t="ekr.20071028032929.376"><vh>Fixed putCode so @raw test passes</vh></v>
<v t="ekr.20071028032929.377"><vh>4.x code passes @delims test</vh></v>
</v>
<v t="ekr.20071028032929.378"><vh>9/21</vh>
<v t="ekr.20071028032929.379"><vh>Import derived file command now works for both 3.x and 4.x files</vh></v>
<v t="ekr.20071028032929.380"><vh>Test @file-nosent</vh></v>
<v t="ekr.20071028032929.381"><vh>Enclosed top-level read/write code in try/except</vh></v>
<v t="ekr.20071028032929.382"><vh>findChild now handles bad tnodeList indices without crashing</vh></v>
<v t="ekr.20071028032929.383"><vh>Fixed bugs in @+doc and @+at sentinels.</vh></v>
<v t="ekr.20071028032929.384"><vh>Removed Write 3.x Outline command</vh></v>
<v t="ekr.20071028032929.385"><vh>Auto-save on Write 3.x derived files.</vh></v>
<v t="ekr.20071028032929.386"><vh>Put section references only if not in raw mode</vh></v>
</v>
<v t="ekr.20071028032929.387"><vh>9/20 4.0 code works &amp; integrated with LeoPy.leo !!</vh>
<v t="ekr.20071028032929.388"><vh>Started merging of plugin code with leoAtFile.py</vh></v>
<v t="ekr.20071028032929.389"><vh>Fixed problems with @doc parts</vh></v>
<v t="ekr.20071028032929.390"><vh>Write @file Nodes does auto-save if we are writing new-format files</vh></v>
<v t="ekr.20071028032929.391"><vh>Changed Wirte 3.x/4x Derived File so they write multiple files</vh></v>
<v t="ekr.20071028032929.392"><vh>Fixed @last bug by using same code as in 3.x</vh></v>
<v t="ekr.20071028032929.393"><vh>Write 4.x Derived File command auto-saves outline</vh></v>
<v t="ekr.20071028032929.394"><vh>Fixed (?) @last newline bug</vh></v>
<v t="ekr.20071028032929.395"><vh>Removed all using_gnx ivars</vh></v>
<v t="ekr.20071028032929.396"><vh>Write code now clears tnodeList attribute before writing</vh></v>
<v t="ekr.20071028032929.397"><vh>Removed "not undoable" message from Read @file Nodes command</vh></v>
<v t="ekr.20071028032929.398"><vh>Removed app.use_gnx ivar</vh></v>
<v t="ekr.20071028032929.399"><vh>Set using_gnx in top_df.write_all</vh></v>
<v t="ekr.20071028032929.400"><vh>Created top_df.oldWrite and top_df.newWrite</vh></v>
<v t="ekr.20071028032929.401"><vh>Added test for unvisited nodes in read logic</vh></v>
</v>
<v t="ekr.20071028032929.402"><vh>9/19</vh>
<v t="ekr.20071028032929.403"><vh>Major reorganization of leoAtFile.py</vh></v>
<v t="ekr.20071028032929.404"><vh>Moved code from leoPlugins.leo to LeoPy.leo</vh></v>
<v t="ekr.20071028032929.405"><vh>Tested splitting very long doc words.</vh></v>
<v t="ekr.20071028032929.406"><vh>Removed @ws stuff</vh></v>
<v t="ekr.20071028032929.407"><vh>Fixed bug related to @last</vh></v>
<v t="ekr.20071028032929.408"><vh>Added Write 3.x Format Derived File command.</vh></v>
<v t="ekr.20071028032929.409"><vh>Added Clear Recent Files command</vh></v>
<v t="ekr.20071028032929.410"><vh>Added write_old_format_derived_files option</vh></v>
<v t="ekr.20071028032929.411"><vh>Removed @ws stuff</vh></v>
</v>
<v t="ekr.20071028032929.412"><vh>9/18</vh>
<v t="ekr.20071028032929.413"><vh>Fixed some (all?) problems with tnodeList</vh></v>
<v t="ekr.20071028032929.414"><vh>All files now pass the file-compare (semantic test)</vh></v>
<v t="ekr.20071028032929.415"><vh>Fixed @others bug</vh></v>
</v>
<v t="ekr.20071028032929.416"><vh>9/17</vh>
<v t="ekr.20071028032929.417"><vh>Wrote compare script</vh></v>
<v t="ekr.20071028032929.418"><vh>Wrote Import Derived File command</vh></v>
</v>
<v t="ekr.20071028032929.419"><vh>9/16</vh>
<v t="ekr.20071028032929.420"><vh>Changed how @ws sentinel works</vh></v>
<v t="ekr.20071028032929.421"><vh>Properly indent @nl sentinels</vh></v>
<v t="ekr.20071028032929.422"><vh>Fixed bugs in putting doc parts</vh></v>
<v t="ekr.20071028032929.423"><vh>Fixed bugs in readLastDocLine</vh></v>
</v>
<v t="ekr.20071028032929.424"><vh>9/14</vh>
<v t="ekr.20071028032929.425"><vh>Added ignoreOldSentinel to warn about 3.x sentinels</vh></v>
<v t="ekr.20071028032929.426"><vh>Milestone: first successful use of hidden machinery</vh></v>
<v t="ekr.20071028032929.427"><vh>Added support for tnodeList tag in fileCommands.getVnode</vh></v>
<v t="ekr.20071028032929.428"><vh>Rewrote createChild and renamed it to findChild</vh></v>
<v t="ekr.20071028032929.429"><vh>Added check to see whether read is the same as the write.</vh></v>
<v t="ekr.20071028032929.430"><vh>Added support for tnodeList</vh></v>
</v>
<v t="ekr.20071028032929.431"><vh>9/13 work on 4.0 read code</vh></v>
</v>
<v t="ekr.20071028032929.432"><vh>August 2003</vh>
<v t="ekr.20071028032929.433"><vh>8/30 Added horizontal scrollbar in body pane when @nowrap in effect</vh></v>
<v t="ekr.20071028032929.434"><vh>8/29 Removed Open Python Window command</vh></v>
<v t="ekr.20071028032929.435"><vh>8/28</vh>
<v t="ekr.20071028032929.436"><vh>Added encoding comments to leoGlobals.py and french plugins</vh></v>
<v t="ekr.20071028032929.437"><vh>Tested with Python 2.3</vh></v>
</v>
<v t="ekr.20071028032929.438"><vh>8/27 Recycle window objects only if more than one window open</vh></v>
</v>
<v t="ekr.20071028032929.439"><vh>July 2003</vh>
<v t="ekr.20071028032929.440"><vh>7/25 Improved Leo's FAQ</vh></v>
<v t="ekr.20071028032929.441"><vh>7/24</vh>
<v t="ekr.20071028032929.442"><vh>Fixed Linux install scripts</vh></v>
<v t="ekr.20071028032929.443"><vh>Changed default new window size in leoConfig.py to match leoConfig.txt</vh></v>
<v t="ekr.20071028032929.444"><vh>Added Help Wanted section to the main todo list</vh></v>
</v>
<v t="ekr.20071028032929.445"><vh>7/22</vh>
<v t="ekr.20071028032929.446"><vh>Called setDefaultDirectoryForNewFiles from all variants of the Save command</vh></v>
<v t="ekr.20071028032929.447"><vh>Added new hook for LeoN in the startup code</vh></v>
</v>
<v t="ekr.20071028032929.448"><vh>7/19 Fixed shortcut bug</vh></v>
<v t="ekr.20071028032929.449"><vh>7/18: Released 3.12 final</vh></v>
<v t="ekr.20071028032929.450"><vh>7/18:  Added preliminary wxWindows project</vh></v>
<v t="ekr.20071028032929.451"><vh>7/16</vh>
<v t="ekr.20071028032929.452"><vh>Finished unit testing of colorizer</vh></v>
<v t="ekr.20071028032929.453"><vh>Allow minus signs in rebol keywords</vh></v>
</v>
<v t="ekr.20071028032929.454"><vh>7/13</vh>
<v t="ekr.20071028032929.455"><vh>Fixed double-click bug on startup</vh></v>
<v t="ekr.20071028032929.456"><vh>Simplified startup logic</vh></v>
<v t="ekr.20071028032929.457"><vh>Created new screen shot on Leo's web site</vh></v>
</v>
<v t="ekr.20071028032929.458"><vh>7/11</vh>
<v t="ekr.20071028032929.459"><vh>Fixed reporting bug in convertAllTabs/Blanks</vh></v>
<v t="ekr.20071028032929.460"><vh>Removed c.copyTree and v.copyNode and rewrote v.copyTree</vh></v>
<v t="ekr.20071028032929.461"><vh>Fixed bugs involving undoing entire trees.</vh></v>
</v>
<v t="ekr.20071028032929.462"><vh>7/10</vh>
<v t="ekr.20071028032929.463"><vh>Improved (I hope) dragging code</vh></v>
<v t="ekr.20071028032929.464"><vh>Added support for actionscript and rebol</vh></v>
</v>
<v t="ekr.20071028032929.465"><vh>7/7</vh>
<v t="ekr.20071028032929.466"><vh>Improved how headlines are edited</vh></v>
<v t="ekr.20071028032929.467"><vh>Created separate leoPlugins.leo</vh></v>
<v t="ekr.20071028032929.468"><vh>(Checked all code involving getTextSelection)</vh></v>
</v>
<v t="ekr.20071028032929.469"><vh>Undo/redo now restore selection and insert point</vh></v>
<v t="ekr.20071028032929.470"><vh>Fixed still more Open With problems</vh></v>
</v>
<v t="ekr.20071028032929.471"><vh>June 2003</vh>
<v t="ekr.20071028032929.472"><vh>6/30</vh>
<v t="ekr.20071028032929.473"><vh>lift dialogs when they are deiconified</vh></v>
<v t="ekr.20071028032929.474"><vh>Fixed another bug in createOpenWithTempFile</vh></v>
<v t="ekr.20071028032929.475"><vh>Fixed missing log messages bug</vh></v>
<v t="ekr.20071028032929.476"><vh>Changed destroyOpenWithFilesForFrame and createOpenWithTempFile</vh></v>
</v>
<v t="ekr.20071028032929.477"><vh>6/29</vh>
<v t="ekr.20071028032929.478"><vh>Added doc strings for most classes.</vh></v>
<v t="ekr.20071028032929.479"><vh>Redefined all major classes so they can be overridden by plugins</vh></v>
<v t="ekr.20071028032929.480"><vh>Improved spell-check plugin</vh></v>
</v>
<v t="ekr.20071028032929.481"><vh>6/28 3.12 beta 1 released</vh>
<v t="ekr.20071028032929.482"><vh>Rewrote distribution scripts to handle new directory organization</vh></v>
<v t="ekr.20071028032929.483"><vh>Fixed three bugs reported by pychecker</vh></v>
</v>
<v t="ekr.20071028032929.484"><vh>6/27 Rewrote callbacks in createMenuEntries</vh></v>
<v t="ekr.20071028032929.485"><vh>6/24 Added @wrap and @nowrap directives</vh></v>
<v t="ekr.20071028032929.486"><vh>6/22</vh>
<v t="ekr.20071028032929.487"><vh>Investigated new Open With problem</vh></v>
<v t="ekr.20071028032929.488"><vh>Added special case to idle_body_key to handle delete key</vh></v>
<v t="ekr.20071028032929.489"><vh>atFile.scanText no longer strips leading whitespace from headlines</vh></v>
<v t="ekr.20071028032929.490"><vh>Made window bigger when opening Leo from leo.py</vh></v>
</v>
<v t="ekr.20071028032929.491"><vh>6/21 Completed all gc cleanup tasks</vh></v>
<v t="ekr.20071028032929.492"><vh>6/19</vh>
<v t="ekr.20071028032929.493"><vh>Moved all window closing code into app class</vh></v>
<v t="ekr.20071028032929.494"><vh>Removed all destroy routines</vh></v>
<v t="ekr.20071028032929.495"><vh>Removed all 4.0 debris</vh></v>
</v>
<v t="ekr.20071028032929.496"><vh>6/18</vh>
<v t="ekr.20071028032929.497"><vh>Scanned for fractional height/width params.  None remain.</vh></v>
<v t="ekr.20071028032929.498"><vh>Removed unused fractional widths from leoFind ctor</vh></v>
<v t="ekr.20071028032929.499"><vh>Set initial_window_width to 150 in leoConfig</vh></v>
</v>
<v t="ekr.20071028032929.500"><vh>6/16 Fixed _huge_ leak in Tk.Canvas</vh></v>
<v t="ekr.20071028032929.501"><vh>6/10 Implemented incremental redrawing</vh></v>
<v t="ekr.20071028032929.502"><vh>6/8 Resolved copying issue</vh></v>
<v t="ekr.20071028032929.503"><vh>6/1 Removed improper clones</vh></v>
</v>
<v t="ekr.20071028032929.504"><vh>May 2003</vh>
<v t="ekr.20071028032929.505"><vh>5/31</vh>
<v t="ekr.20071028032929.506"><vh>Disabled cut/paste of outlines</vh></v>
</v>
<v t="ekr.20071028032929.507"><vh>5/23</vh>
<v t="ekr.20071028032929.508"><vh>Added "close-frame" &amp; "destroy-all-global-windows" hook code to destroy nav windows</vh></v>
<v t="ekr.20071028032929.509"><vh>Added titles to Recent and Marks dialogs.</vh></v>
<v t="ekr.20071028032929.510"><vh>Added "close-frame" and "destroy-all-global-windows" hooks</vh></v>
</v>
<v t="ekr.20071028032929.511"><vh>5/22</vh>
<v t="ekr.20071028032929.512"><vh>Rewrote the nav_buttons plugin using classes</vh></v>
<v t="ekr.20071028032929.513"><vh>Completed nav_buttons plugin</vh></v>
</v>
<v t="ekr.20071028032929.514"><vh>5/22 ** nav_buttons plugin!</vh>
<v t="ekr.20071028032929.515"><vh>Created nav_buttons plugin</vh></v>
<v t="ekr.20071028032929.516"><vh>use string.zfill instead of aString.zfill in color_markup plugin</vh></v>
</v>
<v t="ekr.20071028032929.517"><vh>5/21</vh>
<v t="ekr.20071028032929.518"><vh>Experiments with startup scripts</vh></v>
</v>
<v t="ekr.20071028032929.519"><vh>5/20 ** Added Icon &amp; Status areas</vh>
<v t="ekr.20071028032929.520"><vh>Added idle handler to update the row/col indicator in the status area</vh></v>
<v t="ekr.20071028032929.521"><vh>Added convenience routines for icon &amp; status areas</vh></v>
<v t="ekr.20071028032929.522"><vh>Disable non-functional parts of Find panel</vh></v>
<v t="ekr.20071028032929.523"><vh>Selected find text on entry to find panel</vh></v>
<v t="ekr.20071028032929.524"><vh>Added icon/status areas.  REMOVED MAJOR KLUDGE</vh></v>
</v>
<v t="ekr.20071028032929.525"><vh>5/19</vh>
<v t="ekr.20071028032929.526"><vh>Partially cleaned up leoFind class</vh></v>
<v t="ekr.20071028032929.527"><vh>TO DO: Convenience routines</vh></v>
<v t="ekr.20071028032929.528"><vh>Removed checkForLeoCustomize &amp; related logic</vh></v>
<v t="ekr.20071028032929.529"><vh>Documented new stub hooks</vh></v>
</v>
<v t="ekr.20071028032929.530"><vh>5/18</vh>
<v t="ekr.20071028032929.531"><vh>Added support for bolditalic and italicbold</vh></v>
<v t="ekr.20071028032929.532"><vh>Rewrote logic involving images.</vh></v>
</v>
<v t="ekr.20071028032929.533"><vh>5/17</vh>
<v t="ekr.20071028032929.534"><vh>Simplified startup code</vh></v>
<v t="ekr.20071028032929.535"><vh>Created the add_directives plugin</vh></v>
<v t="ekr.20071028032929.536"><vh>Created "scan-directives" hook in scanDirectives</vh></v>
<v t="ekr.20071028032929.537"><vh>Created "init-color-markup" hook</vh></v>
<v t="ekr.20071028032929.538"><vh>Fixed recent bug in colorizer</vh></v>
</v>
<v t="ekr.20071028032929.539"><vh>5/16</vh>
<v t="ekr.20071028032929.540"><vh>Improved how Leo loads plugins</vh></v>
<v t="ekr.20071028032929.541"><vh>Cleaned up some hooks</vh></v>
<v t="ekr.20071028032929.542"><vh>Created plugin to handle markup in body pane</vh></v>
<v t="ekr.20071028032929.543"><vh>Added stub hooks for cutomizing the drawing of the outline</vh></v>
<v t="ekr.20071028032929.544"><vh>Removed toggle &lt;&lt; &gt;&gt; command</vh></v>
</v>
<v t="ekr.20071028032929.545"><vh>5/15 stub hooks</vh>
<v t="ekr.20071028032929.546"><vh>Created the plugin and script menu plugins</vh></v>
<v t="ekr.20071028032929.547"><vh>Breakthough: stub hooks &amp; alphabetical order</vh></v>
</v>
<v t="ekr.20071028032929.548"><vh>5/13</vh>
<v t="ekr.20071028032929.549"><vh>Progress report 5/13/03: please read</vh></v>
<v t="ekr.20071028032929.550"><vh>Merged devel folder into main cvs folder</vh></v>
<v t="ekr.20071028032929.551"><vh>Updated version number to 4.0 alpha 1</vh></v>
<v t="ekr.20071028032929.552"><vh>Removed __init__ from files managed by LeoPy.leo</vh></v>
<v t="ekr.20071028032929.553"><vh>Use @ignore for all scripts</vh></v>
</v>
<v t="ekr.20071028032929.554"><vh>5/12</vh>
<v t="ekr.20071028032929.555"><vh>Reorganized Leo folder: big change to cvs</vh></v>
<v t="ekr.20071028032929.556"><vh>Investigated strange behavior of log pane during Open commands</vh></v>
</v>
<v t="ekr.20071028032929.557"><vh>5/4</vh>
<v t="ekr.20071028032929.558"><vh>Gathered statistics for threadNext</vh></v>
<v t="ekr.20071028032929.559"><vh>defined funcToMethod in leoGlobals.py</vh></v>
<v t="ekr.20071028032929.560"><vh>Experimented with precomputing threadNext and threadBack when linking nodes</vh></v>
<v t="ekr.20071028032929.561"><vh>Experimented with using v.mChildren to represent children</vh></v>
<v t="ekr.20071028032929.562"><vh>Changed OnIconDoubleClick to allow @url url comments</vh></v>
<v t="ekr.20071028032929.563"><vh>atFile code now use _permanent_ fileCommands.tnodesDict</vh></v>
<v t="ekr.20071028032929.564"><vh>Improved and tested checkForPossiblyBrokenLinks</vh></v>
<v t="ekr.20071028032929.565"><vh>Cleaned up atFile.read code</vh></v>
<v t="ekr.20071028032929.566"><vh>Cleaned up getVnode code</vh></v>
<v t="ekr.20071028032929.567"><vh>Added headString arg to tnode ctor</vh></v>
<v t="ekr.20071028032929.568"><vh>Moved createTopologyList to leoGlobals.py</vh></v>
</v>
<v t="ekr.20071028032929.569"><vh>5/3</vh>
<v t="ekr.20071028032929.570"><vh>Many changes to file reading code</vh></v>
<v t="ekr.20071028032929.571"><vh>Created scripts to check outline for clone &amp; joinList errors</vh></v>
<v t="ekr.20071028032929.572"><vh>Moved headlines into tnodes</vh></v>
<v t="ekr.20071028032929.573"><vh>Second rewrite of v.joinNodeTo</vh></v>
</v>
<v t="ekr.20071028032929.574"><vh>5/2</vh>
<v t="ekr.20071028032929.575"><vh>updateRecentFiles does nothing on Null filenames</vh></v>
<v t="ekr.20071028032929.576"><vh>Major change: rewrote joinList code and move joinLists to tnodes</vh></v>
</v>
<v t="ekr.20071028032929.577"><vh>5/1</vh>
<v t="ekr.20071028032929.578"><vh>Fixed bug when userID != defaultID</vh></v>
<v t="ekr.20071028032929.579"><vh>Made lines following @+t and @+v look like sentinels</vh></v>
<v t="ekr.20071028032929.580"><vh>Checked that Leo 3.11 can read new .leo files</vh></v>
<v t="ekr.20071028032929.581"><vh>Made sure leo works without leoID.txt when use_gnx is false</vh></v>
<v t="ekr.20071028032929.582"><vh>Optimized how Leo allocates t.gnx</vh></v>
</v>
</v>
<v t="ekr.20071028032929.583"><vh>April 2003</vh>
<v t="ekr.20071028032929.584"><vh>4/20</vh>
<v t="ekr.20071028032929.585"><vh>Removed vnx fields from vnodes and +v sentinels</vh></v>
<v t="ekr.20071028032929.586"><vh>Put getpreferredencoding code in try: except blocks</vh></v>
<v t="ekr.20071028032929.587"><vh>Made sure that code works on old files when a.use_gnx is true</vh></v>
<v t="ekr.20071028032929.588"><vh>Replaced fileCommands.getT by self.tnodesDict.get</vh></v>
</v>
<v t="ekr.20071028032929.589"><vh>4/29 Transition to 4.0 .leo files</vh>
<v t="ekr.20071028032929.590"><vh>Allocate gnx's only when needed (when writing files)</vh></v>
<v t="ekr.20071028032929.591"><vh>4.0 code writes tnodes even if they have no body text</vh></v>
<v t="ekr.20071028032929.592"><vh>4.0 code writes tnx="tnx" instead of t="index" in vnodes and tnodes</vh></v>
<v t="ekr.20071028032929.593"><vh>Write vnx and tnx instead of gnx in vnodes and tnodes</vh></v>
<v t="ekr.20071028032929.594"><vh>Made use_pre_4pt0_file_formats setting functional</vh></v>
</v>
<v t="ekr.20071028032929.595"><vh>4/28</vh>
<v t="ekr.20071028032929.596"><vh>Use tuples instead of dicts in nodeIndices class</vh></v>
<v t="ekr.20071028032929.597"><vh>Added code to remove gnx id if it matches default_gnx_id</vh></v>
<v t="ekr.20071028032929.598"><vh>Added code to read/write default_gnx_id field in globals section</vh></v>
<v t="ekr.20071028032929.599"><vh>Added code to write gnx attribute of tnodes and vnodes</vh></v>
<v t="ekr.20071028032929.600"><vh>Added code to read gnx attribute of tnodes and vnodes</vh></v>
<v t="ekr.20071028032929.601"><vh>Added old and new to list of valid @file options</vh></v>
<v t="ekr.20071028032929.602"><vh>Added use_pre_4pt0_file_formats config option</vh></v>
<v t="ekr.20071028032929.603"><vh>Added Write Old Format Outline command to Export menu</vh></v>
</v>
<v t="ekr.20071028032929.604"><vh>4/27</vh>
<v t="ekr.20071028032929.605"><vh>Made read-only messages red</vh></v>
<v t="ekr.20071028032929.606"><vh>4.x code always writes @+t sentinels even for empty nodes</vh></v>
<v t="ekr.20071028032929.607"><vh>Created gnx's in vnode and tnode ctors</vh></v>
</v>
<v t="ekr.20071028032929.608"><vh>4/27 3.11 final released</vh></v>
<v t="ekr.20071028032929.609"><vh>4/26</vh>
<v t="ekr.20071028032929.610"><vh>Greatly simplified Plugins menu code using list comprehensions</vh></v>
<v t="ekr.20071028032929.611"><vh>Added 4.0 code to atFile.read that deletes all children of root</vh></v>
<v t="ekr.20071028032929.612"><vh>Fixed bug that prevented email line in About Leo from working</vh></v>
<v t="ekr.20071028032929.613"><vh>Prepared for 3.11 final: updated dates and urls</vh></v>
<v t="ekr.20071028032929.614"><vh>Fixed various bugs reported by Pychecker</vh></v>
</v>
<v t="ekr.20071028032929.615"><vh>4/24</vh>
<v t="ekr.20071028032929.616"><vh>Added support for @lineending directive</vh></v>
<v t="ekr.20071028032929.617"><vh>Created utility routines for scanAllDirectives and scanDirectives</vh></v>
<v t="ekr.20071028032929.618"><vh>Fixed bug in skip_long</vh></v>
</v>
<v t="ekr.20071028032929.619"><vh>4/23 Improved dialog that gets id for leoID.txt</vh></v>
<v t="ekr.20071028032929.620"><vh>4/22 Added getpreferredencoding to leoGlobals.py</vh></v>
<v t="ekr.20071028032929.621"><vh>4/21 Added patch by Davide Salomoni to OnIconDoubleClick</vh></v>
<v t="ekr.20071028032929.622"><vh>4/20 Removed all __del__ methods</vh></v>
<v t="ekr.20071028032929.623"><vh>4/5 Removed write_clone_indices &amp; use_relative_node_indices config ivars</vh></v>
<v t="ekr.20071028032929.624"><vh>4/5 Added thin_at_file_trees &amp; load_derived_files_immediately options</vh></v>
<v t="ekr.20071028032929.625"><vh>4/4 Added call to c.redraw() in fileCommands.readAtFileNodes</vh></v>
<v t="ekr.20071028032929.626"><vh>4/4 Fixed unicode bugs when Tangling and Untangling</vh></v>
<v t="ekr.20071028032929.627"><vh>4/3 Eliminated caught exception in frame.setTabWidth</vh></v>
</v>
<v t="ekr.20071028032929.628"><vh>March 2003</vh>
<v t="ekr.20071028032929.629"><vh>3/30 Don't write gnx for ending sentinels</vh></v>
<v t="ekr.20071028032929.630"><vh>3/30 Added code to handle afterref sentinels</vh></v>
<v t="ekr.20071028032929.631"><vh>3/29 New read logic passes its first test</vh></v>
<v t="ekr.20071028032929.632"><vh>3/28 Use scanText as a base for 4.0 read logic</vh></v>
<v t="ekr.20071028032929.633"><vh>3/26</vh>
<v t="ekr.20071028032929.634"><vh>Installer now creates plugins directory</vh></v>
<v t="ekr.20071028032929.635"><vh>Improved scrolling when moving right</vh>
<v t="ekr.20071028032929.636"><vh>Test</vh>
<v t="ekr.20071028032929.637"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.638"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.639"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.640"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.641"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.642"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.643"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.644"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.645"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.646"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.647"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.648"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.649"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.650"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.651"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.652"><vh>NewHeadline</vh></v>
<v t="ekr.20071028032929.653"><vh>NewHeadline</vh></v>
</v>
</v>
<v t="ekr.20071028032929.654"><vh>3/26 Removed duplicate redraws when renaming nodes</vh></v>
</v>
<v t="ekr.20071028032929.655"><vh>3/25 Created frame.setWindowTitle and associated logic</vh></v>
<v t="ekr.20071028032929.656"><vh>3/22</vh>
<v t="ekr.20071028032929.657"><vh>3/22 Added support for body/headline_gmt_time settings</vh></v>
<v t="ekr.20071028032929.658"><vh>3/22 Allow color param when queuing messages to log pane</vh></v>
<v t="ekr.20071028032929.659"><vh>3/22 Check for valid encoding when setting app().tkEncoding</vh></v>
</v>
<v t="ekr.20071028032929.660"><vh>3/18</vh>
<v t="ekr.20071028032929.661"><vh>3/18 Use app().tkEncoding to convert to unicode in log pane</vh></v>
<v t="ekr.20071028032929.662"><vh>3/18 Tangle now supports output_newline option</vh></v>
</v>
<v t="ekr.20071028032929.663"><vh>3/17 Fixed bugs in promote/demote</vh></v>
<v t="ekr.20071028032929.664"><vh>3/8</vh>
<v t="ekr.20071028032929.665"><vh>3/8 Full recolor after paste</vh></v>
<v t="ekr.20071028032929.666"><vh>3/8 Put file name first in window title</vh></v>
<v t="ekr.20071028032929.667"><vh>3/8 Added calls to toEncodedString before many calls to write</vh></v>
</v>
<v t="ekr.20071028032929.668"><vh>3/7</vh>
<v t="ekr.20071028032929.669"><vh>3/7 Fixed huge performance bug in v.unjoinNode</vh></v>
<v t="ekr.20071028032929.670"><vh>3/7 Added statistics gathering routines to leoGlobals.py</vh></v>
</v>
</v>
<v t="ekr.20071028032929.671"><vh>Feb 2003</vh>
<v t="ekr.20071028032929.672"><vh>2/26 3.11b3 released</vh></v>
<v t="ekr.20071028032929.673"><vh>2/20 Reinstated Expand All command</vh></v>
<v t="ekr.20071028032929.674"><vh>2/18 Fixed auto-indent for python</vh></v>
<v t="ekr.20071028032929.675"><vh>2/17 Fixed minor Import @root bugs</vh></v>
<v t="ekr.20071028032929.676"><vh>02/17 3.11b1 released</vh></v>
<v t="ekr.20071028032929.677"><vh>02/11</vh>
<v t="ekr.20071028032929.678"><vh>Fixed crasher in canFindMatchingBracket</vh></v>
<v t="ekr.20071028032929.679"><vh>Removed odious locks on customizeLeo.py</vh></v>
<v t="ekr.20071028032929.680"><vh>Fixed control-V bug for Linux</vh></v>
</v>
<v t="ekr.20071028032929.681"><vh>02/08</vh>
<v t="ekr.20071028032929.682"><vh>Major reorganization of hooks</vh></v>
<v t="ekr.20071028032929.683"><vh>Fixed bug: double-clicking icon set the cursor to the hand</vh></v>
<v t="ekr.20071028032929.684"><vh>Fixed bug: v.OnEndDrag fires event only if dragging</vh></v>
</v>
<v t="ekr.20071028032929.685"><vh>02/07</vh>
<v t="ekr.20071028032929.686"><vh>replaced c.contractVnode and c.expandVnode</vh></v>
</v>
<v t="ekr.20071028032929.687"><vh>02/04</vh>
<v t="ekr.20071028032929.688"><vh>Fixed "% (greenOgre)" config bug</vh></v>
</v>
<v t="ekr.20071028032929.689"><vh>02/02</vh>
<v t="ekr.20071028032929.690"><vh>Added code to scroll partially visible headlines when they are selected</vh></v>
</v>
<v t="ekr.20071028032929.691"><vh>02/01</vh>
<v t="ekr.20071028032929.692"><vh>Added code to allow sorting of top-level nodes</vh></v>
<v t="ekr.20071028032929.693"><vh>Hacked atFile.writeAll to allow multiple writes of cloned nodes</vh></v>
<v t="ekr.20071028032929.694"><vh>Removed redundant code from v.set/clearDirty routines</vh></v>
</v>
</v>
<v t="ekr.20071028032929.695"><vh>Jan 2003</vh>
<v t="ekr.20071028032929.696"><vh>01/31</vh>
<v t="ekr.20071028032929.697"><vh>Udated recent files menu when saving a new .leo file</vh></v>
<v t="ekr.20071028032929.698"><vh>Prefs dialog close button equivalent to cancel</vh></v>
<v t="ekr.20071028032929.699"><vh>Fixed about hooks typo</vh></v>
<v t="ekr.20071028032929.700"><vh>New Go To First/Last/Parent/Prev Sibling/Next Sibling commands</vh></v>
<v t="ekr.20071028032929.701"><vh>Major improvements to expand/contract commands</vh></v>
</v>
<v t="ekr.20071028032929.702"><vh>1/30</vh>
<v t="ekr.20071028032929.703"><vh>Create Toggle Angle Brackets command</vh></v>
<v t="ekr.20071028032929.704"><vh>Created Insert Body/Headline Time/Date routines</vh></v>
<v t="ekr.20071028032929.705"><vh>Added "Replace tabs with spaces" checkbox in Prefs panel</vh></v>
<v t="ekr.20071028032929.706"><vh>Made Find button the default button in the Find panel</vh></v>
<v t="ekr.20071028032929.707"><vh>Allowed @comment with @language plain</vh></v>
</v>
<v t="ekr.20071028032929.708"><vh>1/29</vh>
<v t="ekr.20071028032929.709"><vh>Added "save1" and "save2" hooks</vh></v>
<v t="ekr.20071028032929.710"><vh>Added disabled support for @folder to customizeLeo.py</vh></v>
<v t="ekr.20071028032929.711"><vh>Added support for Show Invisible color options</vh></v>
<v t="ekr.20071028032929.712"><vh>Added support for look_for_control_drag_on_mouse_down option</vh></v>
</v>
<v t="ekr.20071028032929.713"><vh>1/25</vh>
<v t="ekr.20071028032929.714"><vh>Fixed problem with block comments</vh>
<v t="ekr.20071028032929.715"><vh>Report</vh></v>
<v t="ekr.20071028032929.716"><vh>Reply</vh></v>
</v>
</v>
<v t="ekr.20071028032929.717"><vh>1/24</vh>
<v t="ekr.20071028032929.718"><vh>Fixed problem with cutting &amp; pasting nodes</vh></v>
<v t="ekr.20071028032929.719"><vh>Removed potential hang in frame.OnOpenWith</vh></v>
<v t="ekr.20071028032929.720"><vh>Added support for body_insertion_cursor_color setting</vh></v>
<v t="ekr.20071028032929.721"><vh>Fixed unicode in Tangle logic</vh></v>
</v>
<v t="ekr.20071028032929.722"><vh>1/23 Completed transition to unicode</vh></v>
<v t="ekr.20071028032929.723"><vh>1/21 Encode find/change strings as utf-8 in leoConfig.txt</vh></v>
<v t="ekr.20071028032929.724"><vh>1/20 Began conversion to unicode internally</vh></v>
<v t="ekr.20071028032929.725"><vh>1/18</vh>
<v t="ekr.20071028032929.726"><vh>Worked around True/False problems in Python 2.3 a1</vh></v>
</v>
<v t="ekr.20071028032929.727"><vh>1/7</vh>
<v t="ekr.20071028032929.728"><vh>Added colon to list of bad characters removed by sanitize_filename</vh></v>
</v>
</v>
</v>
<v t="ekr.20071028032929.729"><vh>2002</vh>
<v t="ekr.20071028032929.730"><vh>Dec 2002</vh>
<v t="ekr.20071028032929.731"><vh>12/18</vh>
<v t="ekr.20071028032929.732"><vh>Added event=event to handleLeoHook</vh></v>
<v t="ekr.20071028032929.733"><vh>Demoted up/down arrow stuff to a disabled hook for now.</vh></v>
</v>
<v t="ekr.20071028032929.734"><vh>12/17</vh>
<v t="ekr.20071028032929.735"><vh>Created tree.moveUpDown</vh></v>
</v>
<v t="ekr.20071028032929.736"><vh>112/16</vh>
<v t="ekr.20071028032929.737"><vh>Replaced string.x(s...) by s.x(...)</vh></v>
<v t="ekr.20071028032929.738"><vh>Improved es and trace, added trace_tag</vh></v>
<v t="ekr.20071028032929.739"><vh>Fixed crasher in undo logic</vh></v>
<v t="ekr.20071028032929.740"><vh>Reset the canvas cursor by brute force</vh></v>
<v t="ekr.20071028032929.741"><vh>Tried to prevent "stuck" drag cursor</vh></v>
<v t="ekr.20071028032929.742"><vh>Reviewed all calls to handleLeoHook </vh></v>
<v t="ekr.20071028032929.743"><vh>Fixed pychecker problems</vh></v>
</v>
<v t="ekr.20071028032929.744"><vh>12/14/02 3.10 released</vh></v>
<v t="ekr.20071028032929.745"><vh>12/12</vh>
<v t="ekr.20071028032929.746"><vh>Added "missing" event hooks</vh></v>
</v>
<v t="ekr.20071028032929.747"><vh>12/11</vh>
<v t="ekr.20071028032929.748"><vh>Fixed major bug in Execute Script command</vh></v>
</v>
<v t="ekr.20071028032929.749"><vh>12/10</vh>
<v t="ekr.20071028032929.750"><vh>Added convenience routines to redirect stderr and stdout</vh></v>
</v>
<v t="ekr.20071028032929.751"><vh>12/8</vh>
<v t="ekr.20071028032929.752"><vh>wrote redirectPrintToLog &amp; restorePrintFromLog</vh></v>
<v t="ekr.20071028032929.753"><vh>Fixed @nsf bug reported by Travers A. Hough</vh></v>
<v t="ekr.20071028032929.754"><vh>Discovered bugs in undoReplace logic</vh></v>
</v>
<v t="ekr.20071028032929.755"><vh>12/7</vh>
<v t="ekr.20071028032929.756"><vh>Fixed undo bug</vh></v>
</v>
<v t="ekr.20071028032929.757"><vh>12/6</vh>
<v t="ekr.20071028032929.758"><vh>Fixed reversion involving @comment &amp; @language together</vh></v>
<v t="ekr.20071028032929.759"><vh>major revision of the menu code</vh></v>
</v>
<v t="ekr.20071028032929.760"><vh>12/4</vh>
<v t="ekr.20071028032929.761"><vh>Fixed path problem in paths passed to tangle_done.py</vh></v>
<v t="ekr.20071028032929.762"><vh>Fixed Recent Files command</vh></v>
<v t="ekr.20071028032929.763"><vh>Fixed problems with Open With code in customizeLeo.py</vh></v>
<v t="ekr.20071028032929.764"><vh>Fixed crasher in colorizeAnyLanguage</vh></v>
<v t="ekr.20071028032929.765"><vh>Fixed major memory leak</vh></v>
<v t="ekr.20071028032929.766"><vh>Changed shortcut to Find Previous so Alt - F4 closes Leo</vh></v>
<v t="ekr.20071028032929.767"><vh>Changed url of help file</vh></v>
<v t="ekr.20071028032929.768"><vh>Removed backquotes from most print statements</vh></v>
<v t="ekr.20071028032929.769"><vh>Removed synonyms from leoImport.py and leoTangle.py</vh></v>
</v>
<v t="ekr.20071028032929.770"><vh>12/3</vh>
<v t="ekr.20071028032929.771"><vh>Converted leoConfig.py to use @root-code</vh></v>
<v t="ekr.20071028032929.772"><vh>Added @file &amp; @root options</vh></v>
<v t="ekr.20071028032929.773"><vh>Fixed a bug in Untangle</vh></v>
<v t="ekr.20071028032929.774"><vh>Decided not to do utils_normpath</vh></v>
</v>
</v>
<v t="ekr.20071028032929.775"><vh>Nov 2002</vh>
<v t="ekr.20071028032929.776"><vh>11/25</vh>
<v t="ekr.20071028032929.777"><vh>Improved Leo's window icon</vh></v>
<v t="ekr.20071028032929.778"><vh>cleaned up config code relating to find settings</vh></v>
<v t="ekr.20071028032929.779"><vh>Added Node only option to find menu</vh></v>
<v t="ekr.20071028032929.780"><vh>Added Export Headlines command</vh></v>
</v>
<v t="ekr.20071028032929.781"><vh>11/21</vh>
<v t="ekr.20071028032929.782"><vh>Fixed bug in colorizeAnyLine</vh></v>
<v t="ekr.20071028032929.783"><vh>Improved undo for Edit Body commands</vh></v>
</v>
<v t="ekr.20071028032929.784"><vh>11/20</vh>
<v t="ekr.20071028032929.785"><vh>Fixed unicode bugs</vh></v>
</v>
<v t="ekr.20071028032929.786"><vh>11/19</vh>
<v t="ekr.20071028032929.787"><vh>Changed use_configureLeo_dot_py to use_customizeLeo_dot_py</vh></v>
<v t="ekr.20071028032929.788"><vh>Create all non-existent directories using makeAllNonExistentDirectories</vh></v>
<v t="ekr.20071028032929.789"><vh>Made sure all open calls are in try blocks.</vh></v>
<v t="ekr.20071028032929.790"><vh>Recolor entire pane if @color or @nocolor change</vh></v>
<v t="ekr.20071028032929.791"><vh>Changed the lamda used to define the Recent Files callback</vh></v>
<v t="ekr.20071028032929.792"><vh>Added "openwith", "recentfiles" and "@url" hooks</vh></v>
<v t="ekr.20071028032929.793"><vh>Fixed big leak in undo</vh></v>
<v t="ekr.20071028032929.794"><vh>Properly save and restore selection range for undo.</vh></v>
<v t="ekr.20071028032929.795"><vh>Fixed bug that caused a backspace in an empty body text to insert a newline.</vh></v>
<v t="ekr.20071028032929.796"><vh>Made Undo bulletproof</vh></v>
<v t="ekr.20071028032929.797"><vh>Removed code in tree.select that removed trailing newlines</vh></v>
</v>
<v t="ekr.20071028032929.798"><vh>11/18</vh>
<v t="ekr.20071028032929.799"><vh>Added Open with entries to popup menus</vh></v>
<v t="ekr.20071028032929.800"><vh>Added David McNab's auto-indent patch (smart_auto_indent option)</vh></v>
</v>
<v t="ekr.20071028032929.801"><vh>11/17</vh>
<v t="ekr.20071028032929.802"><vh>Added "headkey1" and "headkey2" hooks</vh></v>
</v>
<v t="ekr.20071028032929.803"><vh>11/16</vh>
<v t="ekr.20071028032929.804"><vh>added enableIdleTimeHook, disableIdleTimeHook, idleTimeHookHandler</vh></v>
<v t="ekr.20071028032929.805"><vh>Completed first draft of Go To Line Number command</vh></v>
</v>
<v t="ekr.20071028032929.806"><vh>11/15</vh>
<v t="ekr.20071028032929.807"><vh>Added Go To Line Number command</vh></v>
<v t="ekr.20071028032929.808"><vh>Rewrote syntax coloring for cweb</vh></v>
</v>
<v t="ekr.20071028032929.809"><vh>11/14</vh>
<v t="ekr.20071028032929.810"><vh>Fixed bug in atFile.scanAllDirectives involving @language</vh></v>
</v>
<v t="ekr.20071028032929.811"><vh>11/13</vh>
<v t="ekr.20071028032929.812"><vh>Added keywords parameter to customizeLeo</vh></v>
<v t="ekr.20071028032929.813"><vh>Implemented the use_configureLeo_dot_py option</vh></v>
<v t="ekr.20071028032929.814"><vh>Released first public draft of incremental undo</vh></v>
</v>
<v t="ekr.20071028032929.815"><vh>11/10</vh>
<v t="ekr.20071028032929.816"><vh>Correctly colors Pascal's "private" and "uses" keywords</vh></v>
</v>
<v t="ekr.20071028032929.817"><vh>11/9</vh>
<v t="ekr.20071028032929.818"><vh>Fixed blunder in undo/redraw code</vh></v>
<v t="ekr.20071028032929.819"><vh>Fixed Dave Hein's @language issue</vh></v>
<v t="ekr.20071028032929.820"><vh>Completed incremental syntax coloring</vh></v>
</v>
<v t="ekr.20071028032929.821"><vh>11/8</vh>
<v t="ekr.20071028032929.822"><vh>Worked on incremental syntax coloring</vh></v>
<v t="ekr.20071028032929.823"><vh>Changed leoCustomize.py to customizeLeo.py to make distribution easier.</vh></v>
<v t="ekr.20071028032929.824"><vh>Warn if @node leoCustomize.py is not @ignored</vh></v>
<v t="ekr.20071028032929.825"><vh>Execute script no longer supports @pythonscript</vh></v>
<v t="ekr.20071028032929.826"><vh>Added example of how to customize individual .leo files safely in leoCustomize.py</vh></v>
<v t="ekr.20071028032929.827"><vh>Added frame.longFileName and shortFileName methods</vh></v>
</v>
<v t="ekr.20071028032929.828"><vh>11/7</vh>
<v t="ekr.20071028032929.829"><vh>Prompt when writing leoCustomize.py</vh></v>
<v t="ekr.20071028032929.830"><vh>Disabled the "virus-word" in leCustomize.py</vh></v>
</v>
<v t="ekr.20071028032929.831"><vh>11/6</vh>
<v t="ekr.20071028032929.832"><vh>Fixed a major bug in top()</vh>
<v t="ekr.20071028032929.833"><vh>top</vh></v>
</v>
<v t="ekr.20071028032929.834"><vh>Implemented per-window hook scheme</vh></v>
</v>
<v t="ekr.20071028032929.835"><vh>11/5</vh>
<v t="ekr.20071028032929.836"><vh>Fixed bug in cweb coloring, made latex work more like cweb</vh></v>
<v t="ekr.20071028032929.837"><vh>Added app().realMenuName logic</vh></v>
<v t="ekr.20071028032929.838"><vh>Added "open1", "open2", "menu1" and "menu2" hooks</vh></v>
<v t="ekr.20071028032929.839"><vh>Completed generalization of menu code</vh></v>
</v>
<v t="ekr.20071028032929.840"><vh>11/4</vh>
<v t="ekr.20071028032929.841"><vh>Replaced all frame menu ivars with frame.menus dict</vh></v>
<v t="ekr.20071028032929.842"><vh>Generalized how commands are called</vh></v>
<v t="ekr.20071028032929.843"><vh>Added general-purpose hook handling</vh></v>
<v t="ekr.20071028032929.844"><vh>Use original leading whitespace when reformatting paragraphs</vh></v>
<v t="ekr.20071028032929.845"><vh>Use scanDirectives in Convert All Blanks/Tabs commands</vh></v>
<v t="ekr.20071028032929.846"><vh>Incorporated Dave Hein's recent changes</vh></v>
</v>
<v t="ekr.20071028032929.847"><vh>11/3</vh>
<v t="ekr.20071028032929.848"><vh>Implemented @pythonscript and Execute Script</vh></v>
</v>
<v t="ekr.20071028032929.849"><vh>11/2</vh>
<v t="ekr.20071028032929.850"><vh>Fixed bugs when importing Java files.</vh></v>
<v t="ekr.20071028032929.851"><vh>Fixed important bug in find_line_start</vh></v>
</v>
<v t="ekr.20071028032929.852"><vh>1/11</vh>
<v t="ekr.20071028032929.853"><vh>Fixed cweb hack using Jonathon Gilligan's patches</vh></v>
</v>
<v t="ekr.20071028032929.854"><vh>(reducing name polution)</vh></v>
</v>
<v t="ekr.20071028032929.855"><vh>Oct 2002</vh>
<v t="ekr.20071028032929.856"><vh>10/30</vh>
<v t="ekr.20071028032929.857"><vh>Applied cweb hack to all sentinels</vh></v>
<v t="ekr.20071028032929.858"><vh>raw cweb mode in @root trees</vh></v>
<v t="ekr.20071028032929.859"><vh>simplified Reformat Paragraph command</vh></v>
</v>
<v t="ekr.20071028032929.860"><vh>10/29 Released 3.8</vh>
<v t="ekr.20071028032929.861"><vh>10/28</vh>
<v t="ekr.20071028032929.862"><vh>Don't recognize @*, @&lt; or @( in cweb mode</vh></v>
<v t="ekr.20071028032929.863"><vh>Completed documentation for 3.8</vh></v>
</v>
<v t="ekr.20071028032929.864"><vh>10/27</vh>
<v t="ekr.20071028032929.865"><vh>Fixed problems report by Pychecker</vh></v>
<v t="ekr.20071028032929.866"><vh>Fixed path bugs in tangle.scanAllDirectives</vh></v>
<v t="ekr.20071028032929.867"><vh>Changed path_directive_creates_directories to create_nonexistent_directories</vh></v>
</v>
<v t="ekr.20071028032929.868"><vh>10/26</vh>
<v t="ekr.20071028032929.869"><vh>Fixed foo.leo bug</vh></v>
<v t="ekr.20071028032929.870"><vh>Worked around Control-T bug</vh></v>
<v t="ekr.20071028032929.871"><vh>Reset hand cursor after failed drag</vh></v>
</v>
<v t="ekr.20071028032929.872"><vh>10/25</vh>
<v t="ekr.20071028032929.873"><vh>Used dicts to speed up checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20071028032929.874"><vh>Created reloadAll in leoGlobals.py</vh></v>
<v t="ekr.20071028032929.875"><vh>Allow noweb section refs in @file cweb code</vh></v>
<v t="ekr.20071028032929.876"><vh>Added support for &lt;?xml-stylesheet...?&gt; line</vh></v>
<v t="ekr.20071028032929.877"><vh>Documented @rawfile and @silentfile</vh></v>
</v>
<v t="ekr.20071028032929.878"><vh>10/24</vh>
<v t="ekr.20071028032929.879"><vh>Fixed cweb sentinel bug</vh></v>
</v>
<v t="ekr.20071028032929.880"><vh>10/23</vh>
<v t="ekr.20071028032929.881"><vh>Completed first draft of new @rawfile and @silentfile</vh></v>
<v t="ekr.20071028032929.882"><vh>Discovered that gti's _are_ possible</vh></v>
<v t="ekr.20071028032929.883"><vh>Finished cweb hack</vh></v>
<v t="ekr.20071028032929.884"><vh>Fixed @delims "round trip" bug</vh></v>
<v t="ekr.20071028032929.885"><vh>Fixed bug involving menu pastes in headlines</vh></v>
</v>
<v t="ekr.20071028032929.886"><vh>10/19</vh>
<v t="ekr.20071028032929.887"><vh>Fixed import to @root problems</vh></v>
</v>
<v t="ekr.20071028032929.888"><vh>10/18</vh>
<v t="ekr.20071028032929.889"><vh>Completed handling of output_initial_comment option</vh></v>
<v t="ekr.20071028032929.890"><vh>Fixed block-comment bug in Java and HTML</vh></v>
<v t="ekr.20071028032929.891"><vh>Use // as single-line comment in Java</vh></v>
</v>
<v t="ekr.20071028032929.892"><vh>10/17</vh>
<v t="ekr.20071028032929.893"><vh>Allow @comment and @language to coexist</vh></v>
<v t="ekr.20071028032929.894"><vh>Match routines all return false if pattern is None or empty</vh></v>
<v t="ekr.20071028032929.895"><vh>Colorizer now recognizes comments after preprocessor directives</vh></v>
<v t="ekr.20071028032929.896"><vh>Corrected reversion in set_delims_from_string</vh></v>
</v>
<v t="ekr.20071028032929.897"><vh>10/16</vh>
<v t="ekr.20071028032929.898"><vh>Added support for forth language comments</vh></v>
<v t="ekr.20071028032929.899"><vh>Fixed another crasher in scanAllDirectives</vh></v>
<v t="ekr.20071028032929.900"><vh>Fixed assert failure in putBodyPart</vh></v>
<v t="ekr.20071028032929.901"><vh>Fixed crasher in scanAllDirectives</vh></v>
</v>
<v t="ekr.20071028032929.902"><vh>10/15</vh>
<v t="ekr.20071028032929.903"><vh>Added @raw support</vh></v>
<v t="ekr.20071028032929.904"><vh>Changed names of commands in help menu and corresponding entries in leoConfig.leo</vh></v>
<v t="ekr.20071028032929.905"><vh>Updated docs for recent features</vh></v>
</v>
<v t="ekr.20071028032929.906"><vh>10/14</vh>
<v t="ekr.20071028032929.907"><vh>All export commands now use output_newline option</vh></v>
<v t="ekr.20071028032929.908"><vh>Forced focus to body pane after ending headline edit</vh></v>
<v t="ekr.20071028032929.909"><vh>wrote "finished" after write @file nodes command</vh></v>
<v t="ekr.20071028032929.910"><vh>Use @@ sentinels only for real Leo directives</vh></v>
</v>
<v t="ekr.20071028032929.911"><vh>10/13 Rewrote colorizer using dispatch dict</vh></v>
<v t="ekr.20071028032929.912"><vh>10/12</vh>
<v t="ekr.20071028032929.913"><vh>Added Configuration Options item to help menu</vh></v>
</v>
<v t="ekr.20071028032929.914"><vh>10/11</vh>
<v t="ekr.20071028032929.915"><vh>added code to support output_newline option</vh></v>
<v t="ekr.20071028032929.916"><vh>Fixed reversion in file write code</vh></v>
<v t="ekr.20071028032929.917"><vh>Greatly simplified leoConfig.py</vh></v>
<v t="ekr.20071028032929.918"><vh>Completed support for @quiet</vh></v>
<v t="ekr.20071028032929.919"><vh>Syntax color perl's alarm function</vh></v>
</v>
<v t="ekr.20071028032929.920"><vh>10/10</vh>
<v t="ekr.20071028032929.921"><vh>Removed language bits</vh></v>
<v t="ekr.20071028032929.922"><vh>Removed directive bits</vh></v>
<v t="ekr.20071028032929.923"><vh>Used @q and @&gt; as sentinels in cweb mode</vh></v>
</v>
<v t="ekr.20071028032929.924"><vh>10/9 (after 3.7 released)</vh>
<v t="ekr.20071028032929.925"><vh>fixed Unicode bug in setBodyStringOrPane</vh></v>
<v t="ekr.20071028032929.926"><vh>Created es_exception</vh></v>
<v t="ekr.20071028032929.927"><vh>Added support for @rawfile (fixed bug in endEditLabel)</vh></v>
</v>
</v>
<v t="ekr.20071028032929.928"><vh>10/09 Released 3.7</vh>
<v t="ekr.20071028032929.929"><vh>10/8 Ran pychecker</vh></v>
<v t="ekr.20071028032929.930"><vh>10/7 Improved error messages for Unicode errors</vh></v>
<v t="ekr.20071028032929.931"><vh>10/6 leoOpen sets file name if it doesn't exist</vh></v>
<v t="ekr.20071028032929.932"><vh>10/5 Leo now closes an empty window when opening a recent file</vh></v>
<v t="ekr.20071028032929.933"><vh>10/4</vh>
<v t="ekr.20071028032929.934"><vh>Improved handling of Latin-1 encoding</vh></v>
<v t="ekr.20071028032929.935"><vh>Initialize all "config" section params to valid values</vh></v>
</v>
<v t="ekr.20071028032929.936"><vh>10/3</vh>
<v t="ekr.20071028032929.937"><vh>Removed all calls to decode</vh></v>
<v t="ekr.20071028032929.938"><vh>Got information about encode/decode</vh>
<v t="ekr.20071028032929.939"><vh>From  Martin v. Löwis (use unicode to interface with tk)</vh></v>
</v>
<v t="ekr.20071028032929.940"><vh>Fixed Find previous bug</vh></v>
<v t="ekr.20071028032929.941"><vh>Retained file modes when tangling and writing derived files</vh></v>
<v t="ekr.20071028032929.942"><vh>Added remove_sentinels_extension option</vh></v>
</v>
<v t="ekr.20071028032929.943"><vh>10/2 Changed find to findr when scanning @@ sentinels</vh></v>
</v>
</v>
<v t="ekr.20071028032929.944"><vh>Sept 2002</vh>
<v t="ekr.20071028032929.945"><vh>9/27</vh>
<v t="ekr.20071028032929.946"><vh>Removed extra newline following @+leo directive</vh></v>
</v>
<v t="ekr.20071028032929.947"><vh>9/26</vh>
<v t="ekr.20071028032929.948"><vh>"Relative" node indices aren't</vh></v>
<v t="ekr.20071028032929.949"><vh>Eliminated writing clone indices!</vh></v>
<v t="ekr.20071028032929.950"><vh>Allowed reads and writes of cloned @file nodes</vh></v>
</v>
<v t="ekr.20071028032929.951"><vh>9/25</vh>
<v t="ekr.20071028032929.952"><vh>Added perlpod hack</vh></v>
<v t="ekr.20071028032929.953"><vh>Added getBaseDirectory and used it to resolve relative paths</vh></v>
<v t="ekr.20071028032929.954"><vh>Removed bodyKeepsFocus logic in leoTree.py</vh></v>
<v t="ekr.20071028032929.955"><vh>Added code to various scanAllDirectives routines to create paths</vh></v>
<v t="ekr.20071028032929.956"><vh>Created "path_directive_creates_directories" option</vh></v>
</v>
<v t="ekr.20071028032929.957"><vh>9/24</vh>
<v t="ekr.20071028032929.958"><vh>"Mysterious" changes to files were due to setting Page Width = 80</vh></v>
<v t="ekr.20071028032929.959"><vh>Added code to configure headline colors</vh></v>
<v t="ekr.20071028032929.960"><vh>Made the About Leo dialog non-modal</vh></v>
<v t="ekr.20071028032929.961"><vh>Fixed bug that disabled all shortcuts</vh></v>
<v t="ekr.20071028032929.962"><vh>Added support for Esc in shortcuts</vh></v>
<v t="ekr.20071028032929.963"><vh>Added End Edit Headline and Abort Edit Headline commands</vh></v>
<v t="ekr.20071028032929.964"><vh>Fixed undo cloned headline bug</vh></v>
</v>
<v t="ekr.20071028032929.965"><vh>9/23 Finished user-configurable shortcuts</vh></v>
<v t="ekr.20071028032929.966"><vh>9/21</vh>
<v t="ekr.20071028032929.967"><vh>Fixed colorizing for "while" in C</vh></v>
<v t="ekr.20071028032929.968"><vh>Leo now remembers insert point always</vh></v>
</v>
<v t="ekr.20071028032929.969"><vh>9/20 Fixed tab problems</vh></v>
<v t="ekr.20071028032929.970"><vh>9/19 Removed setup.py from binary distribution</vh></v>
<v t="ekr.20071028032929.971"><vh>9/18 New file code: end of cursed newlines.</vh>
<v t="ekr.20071028032929.972"><vh>Write only \n (Linux newlines) in derived files and .leo files</vh></v>
<v t="ekr.20071028032929.973"><vh>Major change to atFile::read code</vh></v>
</v>
<v t="ekr.20071028032929.974"><vh>9/15</vh>
<v t="ekr.20071028032929.975"><vh>Added self=self to lambda definitions to keep Python 2.1 happy</vh></v>
<v t="ekr.20071028032929.976"><vh>Folded all CVS changes into this file</vh></v>
</v>
<v t="ekr.20071028032929.977"><vh>9/14 Added secondary pane ratios to leoConfig.txt</vh></v>
<v t="ekr.20071028032929.978"><vh>9/13</vh>
<v t="ekr.20071028032929.979"><vh>Folded Steven P. Schaefer's @first in @root code.</vh></v>
<v t="ekr.20071028032929.980"><vh>Fixed "Unselected Ctrl-[ four times" bug</vh></v>
<v t="ekr.20071028032929.981"><vh>Investigated reported font settings bug: works for me</vh></v>
<v t="ekr.20071028032929.982"><vh>Incorporated Dave Heins code into getBodyLines</vh></v>
</v>
<v t="ekr.20071028032929.983"><vh>9/12</vh>
<v t="ekr.20071028032929.984"><vh>Fixed bug in updateBodyPane affecting Edit Body commands</vh></v>
<v t="ekr.20071028032929.985"><vh>Suggested ISO-8859-15 instead of ISO-8859-1 in leoConfig.leo</vh></v>
<v t="ekr.20071028032929.986"><vh>Generated PKG-INFO in Version Stuff section</vh></v>
<v t="ekr.20071028032929.987"><vh>Fixed @language plain # bug.</vh></v>
<v t="ekr.20071028032929.988"><vh>Improved enabling of menu items in popup menus</vh></v>
<v t="ekr.20071028032929.989"><vh>Fixed @language plain single-quote bug</vh></v>
<v t="ekr.20071028032929.990"><vh>Incorporated Dave Hein's "wrapping in doc part" bug fix</vh></v>
<v t="ekr.20071028032929.991"><vh>Changed accelerator of Go To Next Changed to Alt-D</vh></v>
</v>
<v t="ekr.20071028032929.992"><vh>9/11 Released 3.6</vh>
<v t="ekr.20071028032929.993"><vh>9/11 Hacked colorizeAnyLanguage to support all PHP constructs</vh></v>
<v t="ekr.20071028032929.994"><vh>9/11 Implemented @last</vh></v>
</v>
<v t="ekr.20071028032929.995"><vh>9/9</vh>
<v t="ekr.20071028032929.996"><vh>Removed most error messages in atFile::read logic</vh></v>
<v t="ekr.20071028032929.997"><vh>Integrated changes in PHP changes into this file</vh></v>
</v>
<v t="ekr.20071028032929.998"><vh>9/7</vh>
<v t="ekr.20071028032929.999"><vh>9/7 and later: started to design the "Resolve CVS Conflicts command"</vh></v>
<v t="ekr.20071028032929.1000"><vh>Dave Hein: added new code to make Python window work on Linux.</vh></v>
</v>
<v t="ekr.20071028032929.1001"><vh>9/5 Fixed bugs in @path logic in tangle.scanAllDirectives</vh></v>
<v t="ekr.20071028032929.1002"><vh>9/4</vh>
<v t="ekr.20071028032929.1003"><vh>Tomaz Ficko: Added support for MouseWheel (Linux only)</vh></v>
<v t="ekr.20071028032929.1004"><vh>Steven P. Schaefer: Fixed cursed newline bug for Linux</vh></v>
</v>
<v t="ekr.20071028032929.1005"><vh>9/3</vh>
<v t="ekr.20071028032929.1006"><vh>Experimented with CVS Revision keyword in About box.</vh></v>
<v t="ekr.20071028032929.1007"><vh>Added Match Brackets command</vh></v>
<v t="ekr.20071028032929.1008"><vh>Added shortcuts for Read/Write @file Nodes commands</vh></v>
</v>
<v t="ekr.20071028032929.1009"><vh>9/2</vh>
<v t="ekr.20071028032929.1010"><vh>Steven P. Schaefer: Improved handling of directives in @root trees</vh></v>
<v t="ekr.20071028032929.1011"><vh>Dave Hein: added CheckVersion to leoUtils.py</vh></v>
<v t="ekr.20071028032929.1012"><vh>Dave Hein: fixed Tk 8.4 problem in Prefs Panel</vh></v>
<v t="ekr.20071028032929.1013"><vh>Body pane now gets focus after Go Back/Next</vh></v>
<v t="ekr.20071028032929.1014"><vh>Changed leoTangle.scanAllDirectives</vh></v>
<v t="ekr.20071028032929.1015"><vh>Leo now remembers scrollbar positions</vh></v>
<v t="ekr.20071028032929.1016"><vh>Removed windows newlines in leoConfig.update</vh></v>
<v t="ekr.20071028032929.1017"><vh>Improved call to os.path.join in leoApp.finishCreate</vh></v>
</v>
<v t="ekr.20071028032929.1018"><vh>9/1</vh>
<v t="ekr.20071028032929.1019"><vh>Saved edit position of tnodes</vh></v>
<v t="ekr.20071028032929.1020"><vh>Investigated @language for @root trees</vh></v>
<v t="ekr.20071028032929.1021"><vh>Fixed missing headline bug on startup</vh></v>
<v t="ekr.20071028032929.1022"><vh>Changed all os.rename to utils_rename</vh></v>
<v t="ekr.20071028032929.1023"><vh>Changed mode in leoConfig::update</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1024"><vh>Aug 2002</vh>
<v t="ekr.20071028032929.1025"><vh>8/24</vh>
<v t="ekr.20071028032929.1026"><vh>Added version to url for online tutorial</vh></v>
<v t="ekr.20071028032929.1027"><vh>Improved About Leo dialog</vh></v>
<v t="ekr.20071028032929.1028"><vh>Improved dowloading of sbooks.chm</vh></v>
</v>
<v t="ekr.20071028032929.1029"><vh>8/15</vh>
<v t="ekr.20071028032929.1030"><vh>prototyped window icons in Tk</vh></v>
<v t="ekr.20071028032929.1031"><vh>Attempted to make mouse wheel functional in tree pane</vh></v>
<v t="ekr.20071028032929.1032"><vh>Rewrote About Leo dialog with icon &amp; hyperlinks</vh></v>
<v t="ekr.20071028032929.1033"><vh>Improved download dialog in Help-Tutorial command</vh></v>
</v>
<v t="ekr.20071028032929.1034"><vh>8/14 Released 3.5</vh>
<v t="ekr.20071028032929.1035"><vh>Corrected wrapping in log window when horizontal scrollbar is present</vh></v>
<v t="ekr.20071028032929.1036"><vh>Released 3.5</vh></v>
<v t="ekr.20071028032929.1037"><vh>Added log_pane_wraps and outline_pane_scrolls_horizontally params</vh></v>
<v t="ekr.20071028032929.1038"><vh>Fixed Tangle logic</vh></v>
</v>
<v t="ekr.20071028032929.1039"><vh>8/13 Bugs, bugs, bugs</vh>
<v t="ekr.20071028032929.1040"><vh>called cf.flush in leoConfig.update</vh></v>
<v t="ekr.20071028032929.1041"><vh>Open url's from help menu</vh></v>
<v t="ekr.20071028032929.1042"><vh>Rewrote path logic</vh></v>
<v t="ekr.20071028032929.1043"><vh>Warn on read-only files</vh></v>
<v t="ekr.20071028032929.1044"><vh>Hacked on leoAtFile.scanAllDirectives to fix directory problem</vh></v>
<v t="ekr.20071028032929.1045"><vh>Fixed (?) cursed newline bug in leoAtFile</vh></v>
</v>
<v t="ekr.20071028032929.1046"><vh>8/11 Released 3.4</vh>
<v t="ekr.20071028032929.1047"><vh>Fixed crasher when leoConfig.txt does not exist</vh></v>
<v t="ekr.20071028032929.1048"><vh>Fixed bug in leoFileCommands.readOutlineOnly</vh></v>
<v t="ekr.20071028032929.1049"><vh>Wrote importFiles script in leoImport.leo</vh></v>
<v t="ekr.20071028032929.1050"><vh>Released 3.4</vh></v>
<v t="ekr.20071028032929.1051"><vh>Syntax colorer now honors @comment</vh></v>
</v>
<v t="ekr.20071028032929.1052"><vh>8/10</vh>
<v t="ekr.20071028032929.1053"><vh>Added save_clears_undo_buffer configuration option</vh></v>
<v t="ekr.20071028032929.1054"><vh>Improved Recent Files menu</vh></v>
</v>
<v t="ekr.20071028032929.1055"><vh>8/9 Fixed Unicode Bugs</vh></v>
<v t="ekr.20071028032929.1056"><vh>8/6</vh>
<v t="ekr.20071028032929.1057"><vh>Corrected problems with find/prefs settings</vh></v>
<v t="ekr.20071028032929.1058"><vh>created leoConfig.leo</vh></v>
<v t="ekr.20071028032929.1059"><vh>Fixed a bug in config.setDict (!) (This fixes font problems)</vh></v>
<v t="ekr.20071028032929.1060"><vh>Leo writes split direction to leoConfig.txt</vh></v>
<v t="ekr.20071028032929.1061"><vh>Leo writes prefs if leoConfig.txt is read-only</vh></v>
</v>
<v t="ekr.20071028032929.1062"><vh>8/5 Leo honors pane ratio stored in .leo files</vh></v>
<v t="ekr.20071028032929.1063"><vh>8/4</vh>
<v t="ekr.20071028032929.1064"><vh>Improved highlighting of whitespace</vh></v>
<v t="ekr.20071028032929.1065"><vh>Fixed revert problems in font panel</vh></v>
<v t="ekr.20071028032929.1066"><vh>Added @ignore to "raw" imported files</vh></v>
<v t="ekr.20071028032929.1067"><vh>Remove Sentinels command now uses .txt extension instead of .tmp</vh></v>
<v t="ekr.20071028032929.1068"><vh>Added log message for Remove Sentinels command</vh></v>
<v t="ekr.20071028032929.1069"><vh>Corrected spelling of limit_directory_search_extenstion </vh></v>
<v t="ekr.20071028032929.1070"><vh>Fixed wandering insertion point bug</vh></v>
</v>
<v t="ekr.20071028032929.1071"><vh>8/3</vh>
<v t="ekr.20071028032929.1072"><vh>looked for backticks</vh></v>
<v t="ekr.20071028032929.1073"><vh>Cleaned up files using nested compares</vh></v>
<v t="ekr.20071028032929.1074"><vh>Fixed another clone bug: created setAncestorsOfClonedNodesInTreeDirty</vh></v>
<v t="ekr.20071028032929.1075"><vh>Released 3.3</vh></v>
</v>
<v t="ekr.20071028032929.1076"><vh>8/2</vh>
<v t="ekr.20071028032929.1077"><vh>Leo supports Unicode !!</vh></v>
<v t="ekr.20071028032929.1078"><vh>changed skip_long to handle negative values</vh></v>
<v t="ekr.20071028032929.1079"><vh>initialized atFile.default_directory to None</vh></v>
<v t="ekr.20071028032929.1080"><vh>eliminated both presentLanguage and targetLanguage ivars from leoAtFile</vh></v>
<v t="ekr.20071028032929.1081"><vh>Removed default param from set_language</vh></v>
</v>
<v t="ekr.20071028032929.1082"><vh>8/1</vh>
<v t="ekr.20071028032929.1083"><vh>Fixed crasher in leoTangle.putDoc</vh></v>
<v t="ekr.20071028032929.1084"><vh>Fixed problems with negative tab widths</vh></v>
<v t="ekr.20071028032929.1085"><vh>Fixed the "delims botch"</vh></v>
<v t="ekr.20071028032929.1086"><vh>Made 'additional_body_text_border' setting functional</vh></v>
<v t="ekr.20071028032929.1087"><vh>Made 'body_pane_wraps' setting functional</vh></v>
<v t="ekr.20071028032929.1088"><vh>Fixed config tables</vh></v>
<v t="ekr.20071028032929.1089"><vh>Initialized leoAtFile properly</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1090"><vh>July 2002</vh>
<v t="ekr.20071028032929.1091"><vh>7/30 Fixed many bugs in Color panel</vh></v>
<v t="ekr.20071028032929.1092"><vh>7/30 Proved that Leo handles nested @others directives properly</vh>
<v t="ekr.20071028032929.1093"><vh>Proof that nested @others directives are valid</vh></v>
</v>
<v t="ekr.20071028032929.1094"><vh>7/29</vh>
<v t="ekr.20071028032929.1095"><vh>7/29 Fixed bug in skip_pp_if and added skip_pp_part</vh></v>
<v t="ekr.20071028032929.1096"><vh>7/29 Added @ignore to the root of all imported trees</vh></v>
<v t="ekr.20071028032929.1097"><vh>7/29 Fixed bug in scanPythonDef.&lt;&lt; skip the Python def &gt;&gt;</vh></v>
<v t="ekr.20071028032929.1098"><vh>7/29 Improved import of classes</vh></v>
<v t="ekr.20071028032929.1099"><vh>7/29 Relaxed the rules for @others: allowed @others within @others tree</vh></v>
<v t="ekr.20071028032929.1100"><vh>7/29 Added glossary entries</vh></v>
<v t="ekr.20071028032929.1101"><vh>7/29 Fixed crasher in Prefs onCancel</vh></v>
<v t="ekr.20071028032929.1102"><vh>7/29 Fixed problems with Outline/Move/Select Go commands</vh></v>
<v t="ekr.20071028032929.1103"><vh>7/29 Added email address &amp; URL to About Leo dialog</vh></v>
<v t="ekr.20071028032929.1104"><vh>7/29 Fixed import bug</vh></v>
</v>
<v t="ekr.20071028032929.1105"><vh>7/27 Continued comments for lines ending in \</vh></v>
<v t="ekr.20071028032929.1106"><vh>7/24 Added @file disStats.py</vh></v>
<v t="ekr.20071028032929.1107"><vh>7/24 Added leo.profile()</vh></v>
<v t="ekr.20071028032929.1108"><vh>7/20 Released 3.1</vh>
<v t="ekr.20071028032929.1109"><vh>7/20 Finished Compare panel code, including using leoConfig.txt params</vh></v>
</v>
<v t="ekr.20071028032929.1110"><vh>7/19</vh>
<v t="ekr.20071028032929.1111"><vh>7/19 Leo now adds path to Idle automatically</vh></v>
<v t="ekr.20071028032929.1112"><vh>7/19 Fixed bug that caused leo.py not to run</vh></v>
<v t="ekr.20071028032929.1113"><vh>7/19 Completed the visual design of the Compare panel</vh></v>
</v>
<v t="ekr.20071028032929.1114"><vh>7/18</vh>
<v t="ekr.20071028032929.1115"><vh>7/18 Revised leoCompare.py</vh></v>
<v t="ekr.20071028032929.1116"><vh>7/18 Changed precedence scheme for preferences</vh></v>
<v t="ekr.20071028032929.1117"><vh>7/18 Added support for @language tcl/tk</vh></v>
<v t="ekr.20071028032929.1118"><vh>7/18 Fixed major bugs in skip_long &amp; tangle.scanAllDirectives!</vh></v>
</v>
<v t="ekr.20071028032929.1119"><vh>7/17</vh>
<v t="ekr.20071028032929.1120"><vh>7/17 v.moreBody now only escapes first non-blank character on a line</vh></v>
<v t="ekr.20071028032929.1121"><vh>7/17 Told where to download Python 2.2 and Tk 8.3 In 2.2 required dialog</vh>
<v t="ekr.20071028032929.1122"><vh>7/17 Added optional text param to leoDialog.askOk</vh></v>
<v t="ekr.20071028032929.1123"><vh>7/17 Tried closing Leo window during a long write</vh></v>
<v t="ekr.20071028032929.1124"><vh>7/17 The compare window is important!</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1125"><vh>7/16 Released 3.0</vh>
<v t="ekr.20071028032929.1126"><vh>7/16 Added leoConfig.txt to manifest</vh></v>
<v t="ekr.20071028032929.1127"><vh>7/16 Did spellcheck on LeoDocs.leo using MS Word</vh></v>
<v t="ekr.20071028032929.1128"><vh>7/16 Fixed autoscrolling so it can stop</vh></v>
<v t="ekr.20071028032929.1129"><vh>7/16 Ran pychecker</vh></v>
<v t="ekr.20071028032929.1130"><vh>7/16 Called traceback.print_exc for all serious exceptions</vh></v>
</v>
<v t="ekr.20071028032929.1131"><vh>7/15 Leo code complete</vh>
<v t="ekr.20071028032929.1132"><vh>7/15 Adjusted tree to handle larger font size</vh></v>
<v t="ekr.20071028032929.1133"><vh>7/15 Make Convert All Blanks and Convert All Tabs undoable</vh></v>
<v t="ekr.20071028032929.1134"><vh>7/15 ** Speeded up autoscrolling enough to be useful</vh></v>
<v t="ekr.20071028032929.1135"><vh>7/15 New windows now open using config params.</vh></v>
<v t="ekr.20071028032929.1136"><vh>7/15 Cleaned up how windows are opened</vh></v>
<v t="ekr.20071028032929.1137"><vh>7/15 Fixed bug that disabled window positioning!</vh></v>
<v t="ekr.20071028032929.1138"><vh>7/15 Changed config getters to get from defaults</vh></v>
<v t="ekr.20071028032929.1139"><vh>7/15 Added code to support font prefs.</vh></v>
<v t="ekr.20071028032929.1140"><vh>7/15 Added frame code to support non-modal panes</vh></v>
</v>
<v t="ekr.20071028032929.1141"><vh>Earlier</vh>
<v t="ekr.20071028032929.1142"><vh>7/14</vh>
<v t="ekr.20071028032929.1143"><vh>7/13 Added default tables to config module</vh></v>
<v t="ekr.20071028032929.1144"><vh>7/13 Added name picker to color panel</vh></v>
<v t="ekr.20071028032929.1145"><vh>7/13 Finished handlers for Font frame</vh></v>
</v>
<v t="ekr.20071028032929.1146"><vh>7/12</vh>
<v t="ekr.20071028032929.1147"><vh>7/12 Font &amp; color panels need not be modal !</vh></v>
<v t="ekr.20071028032929.1148"><vh>7/12 Finished Tk work on Font frame</vh></v>
</v>
<v t="ekr.20071028032929.1149"><vh>7/11</vh>
<v t="ekr.20071028032929.1150"><vh>7/11 Fixed syntax coloring bug</vh></v>
<v t="ekr.20071028032929.1151"><vh>7/11 Lots of work on preferences and color panel</vh></v>
</v>
<v t="ekr.20071028032929.1152"><vh>7/10 File (and clipboard) format changed!</vh>
<v t="ekr.20071028032929.1153"><vh>7/10 Allowed "ISO-8859-1" specification</vh></v>
<v t="ekr.20071028032929.1154"><vh>7/10 Warn and abort if not Python 2.2 or above</vh></v>
<v t="ekr.20071028032929.1155"><vh>7/10 app.finishCreate checks for Python 2.2 or higher</vh></v>
<v t="ekr.20071028032929.1156"><vh>7/10 Cleaned up Recent Files menu code</vh></v>
<v t="ekr.20071028032929.1157"><vh>7/10 All panels now have labeled frames and grooved borders</vh></v>
<v t="ekr.20071028032929.1158"><vh>7/10 Created leoFontPanel.py and added leoColorPanel class to leoColor.py</vh></v>
</v>
<v t="ekr.20071028032929.1159"><vh>7/9 Created create_labeled_frame and Font and Colors panels</vh></v>
<v t="ekr.20071028032929.1160"><vh>7/8</vh>
<v t="ekr.20071028032929.1161"><vh>7/8 Improved syntax coloring</vh></v>
<v t="ekr.20071028032929.1162"><vh>7/8 The REM hack &amp; fixed crasher</vh></v>
<v t="ekr.20071028032929.1163"><vh>7/8 Fixed crasher in atFile.scanAllDirectives</vh></v>
<v t="ekr.20071028032929.1164"><vh>7/8 Finished Toggle Split Direction</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1165"><vh>leo.py 2.5 and earlier</vh>
<v t="ekr.20071028032929.1166"><vh>7/7</vh>
<v t="ekr.20071028032929.1167"><vh>7/7 Fixed crashers when undoing or redoing moves</vh></v>
<v t="ekr.20071028032929.1168"><vh>7/7 Updated LeoDocs.leo and Leo's web site</vh></v>
<v t="ekr.20071028032929.1169"><vh>7/7 Released 2.5 and updated CVS</vh></v>
</v>
<v t="ekr.20071028032929.1170"><vh>7/6 version 2.5 is now code complete</vh>
<v t="ekr.20071028032929.1171"><vh>7/6 Improved Import to @root</vh></v>
<v t="ekr.20071028032929.1172"><vh>7/6 Fixed Import bug: empty classes and nested classes</vh></v>
<v t="ekr.20071028032929.1173"><vh>7/6 Fixed Import bug that caused orphan nodes</vh></v>
<v t="ekr.20071028032929.1174"><vh>7/6 Fixed Import bug that caused duplicate class lines.</vh></v>
<v t="ekr.20071028032929.1175"><vh>7/6 Renamed Font to Set Font... and Syntax Coloring... to Set Colors...</vh></v>
<v t="ekr.20071028032929.1176"><vh>7/6 Created c.initJoinedCloneBits</vh></v>
<v t="ekr.20071028032929.1177"><vh>7/6 Verified that undo works</vh></v>
</v>
<v t="ekr.20071028032929.1178"><vh>7/5</vh>
<v t="ekr.20071028032929.1179"><vh>7/5 Made extract commands undoable &amp; simplified undo.</vh></v>
<v t="ekr.20071028032929.1180"><vh>7/5 Made import commands undoable.</vh></v>
<v t="ekr.20071028032929.1181"><vh>7/5 Discovered traceback module</vh></v>
<v t="ekr.20071028032929.1182"><vh>7/5 Made Cascade command functional</vh></v>
<v t="ekr.20071028032929.1183"><vh>7/5 Enabled Minimize All command</vh></v>
<v t="ekr.20071028032929.1184"><vh>7/5 Forced syntax coloring after extract commands</vh></v>
</v>
<v t="ekr.20071028032929.1185"><vh>7/4</vh>
<v t="ekr.20071028032929.1186"><vh>7/4 Find/Change settings can be overridden by leoConfig.txt</vh></v>
<v t="ekr.20071028032929.1187"><vh>7/4 Invalid directories are no longer errors in leoAtFiles.scanAllDirectives</vh></v>
<v t="ekr.20071028032929.1188"><vh>7/4 Prefs now can be overridden by leoConfig.txt</vh></v>
</v>
<v t="ekr.20071028032929.1189"><vh>7/3</vh>
<v t="ekr.20071028032929.1190"><vh>7/3 Added Convert All Blanks and Convert All Tabs commands</vh></v>
<v t="ekr.20071028032929.1191"><vh>7/3 Added Convert Tabs command</vh></v>
<v t="ekr.20071028032929.1192"><vh>7/3 Changed tabs to blanks when tab width is negative</vh></v>
<v t="ekr.20071028032929.1193"><vh>7/3 Changed c.tab/page_width to self.tab/page_width in leoAtFile.py</vh></v>
<v t="ekr.20071028032929.1194"><vh>7/3 Added OK, Cancel, Revert buttons to Prefs panel</vh></v>
<v t="ekr.20071028032929.1195"><vh>7/3 Added window name to Prefs title</vh></v>
<v t="ekr.20071028032929.1196"><vh>7/3 Added @language python to all @file nodes</vh></v>
</v>
<v t="ekr.20071028032929.1197"><vh>7/2</vh>
<v t="ekr.20071028032929.1198"><vh>7/2 Changed defaultextension from "x" to ".x"</vh></v>
<v t="ekr.20071028032929.1199"><vh>7/2 Made prefs a modal dialog</vh></v>
<v t="ekr.20071028032929.1200"><vh>7/2 About c.defaultDirectory</vh></v>
<v t="ekr.20071028032929.1201"><vh>7/2 Changed Save and Save As...</vh></v>
<v t="ekr.20071028032929.1202"><vh>7/2 Fixed crashers in Remove Sentinels command</vh></v>
<v t="ekr.20071028032929.1203"><vh>7/2 Fixed crasher in import.scanAllDirectives)</vh></v>
<v t="ekr.20071028032929.1204"><vh>7/2 Hacked code so tab width works</vh></v>
<v t="ekr.20071028032929.1205"><vh>7/2 Fixed doc problems</vh>
<v t="ekr.20071028032929.1206"><vh>Demote docs</vh></v>
<v t="ekr.20071028032929.1207"><vh>Open/Close log window docs</vh></v>
<v t="ekr.20071028032929.1208"><vh>Insert Headline docs</vh></v>
<v t="ekr.20071028032929.1209"><vh>Extract Section docs</vh></v>
<v t="ekr.20071028032929.1210"><vh>Syntax Coloring... &amp; Font...</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1211"><vh>7/1 Cut/Paste now works properly</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1212"><vh>June 2002	</vh>
<v t="ekr.20071028032929.1213"><vh>06/22 Implemented Recent Files menu &amp; leoConfig.py</vh></v>
<v t="ekr.20071028032929.1214"><vh>06/19 Removed assert from st_enter_root_name</vh></v>
<v t="ekr.20071028032929.1215"><vh>06/18 Improved error recovery when writing .leo files</vh></v>
<v t="ekr.20071028032929.1216"><vh>06/16 Changed leo.py so Leo can open files when files are double-clicked</vh></v>
<v t="ekr.20071028032929.1217"><vh>06/16 Finished updating LeoDocs.leo to match Leo's web site</vh></v>
<v t="ekr.20071028032929.1218"><vh>06/15 Fixed the control-I and control-H bugs</vh></v>
<v t="ekr.20071028032929.1219"><vh>06/15 Double clicking in a headline now selects a word</vh></v>
<v t="ekr.20071028032929.1220"><vh>06/15 Implemented Drag and Drop</vh></v>
<v t="ekr.20071028032929.1221"><vh>06/04 Changed atFile.scanAllDirectives to use c.openDirectory as default</vh></v>
<v t="ekr.20071028032929.1222"><vh>06/03 Changed cursor to double arrow when cursor is over splitter bars</vh></v>
<v t="ekr.20071028032929.1223"><vh>06/02 Bug fix in es in leoGlobals</vh></v>
<v t="ekr.20071028032929.1224"><vh>06/02 Tried and failed to call wm_iconbitmap</vh></v>
</v>
<v t="ekr.20071028032929.1225"><vh>May 2002</vh>
<v t="ekr.20071028032929.1226"><vh>5/30/02 Move theory of operation sections back into this outline</vh></v>
<v t="ekr.20071028032929.1227"><vh>5/27/02 Undo move down doesn't always work</vh></v>
<v t="ekr.20071028032929.1228"><vh>5/27/02 Fixed bugs involving changing roots</vh></v>
<v t="ekr.20071028032929.1229"><vh>5/27/02 Handled unicode error in leoFileCommands::put</vh></v>
<v t="ekr.20071028032929.1230"><vh>5/13/02 LeoPy.leo corrupted</vh></v>
</v>
<v t="ekr.20071028032929.1231"><vh>April 2002</vh>
<v t="ekr.20071028032929.1232"><vh>4/27/02 Started Remove Sentinels command</vh></v>
<v t="ekr.20071028032929.1233"><vh>4/27/02 Changes to Export Noweb command</vh></v>
<v t="ekr.20071028032929.1234"><vh>4/25/02 Added code to os()</vh></v>
<v t="ekr.20071028032929.1235"><vh>4/7/02 Added frame.outlineToNowebDefaultFileName ivar</vh></v>
<v t="ekr.20071028032929.1236"><vh>4/7/02 Replaced &lt;&lt;*&gt;&gt;= with &lt;&lt;fileName&gt;&gt;= whenever possible</vh></v>
<v t="ekr.20071028032929.1237"><vh>4/7/02 Added code to make @ defs not start a doc part</vh></v>
<v t="ekr.20071028032929.1238"><vh>4/7/02 Added warnings for all non-undoable import commands</vh></v>
</v>
<v t="ekr.20071028032929.1239"><vh>March 2002</vh>
<v t="ekr.20071028032929.1240"><vh>3/16 Fixed moves up to root postion</vh></v>
<v t="ekr.20071028032929.1241"><vh>3/16 Simplified syntax colorer for docState</vh></v>
<v t="ekr.20071028032929.1242"><vh>3/10 Rewrote skipLeadingComments</vh></v>
<v t="ekr.20071028032929.1243"><vh>3/08 Modified colorer for CWEB</vh></v>
<v t="ekr.20071028032929.1244"><vh>3/07 Color strings green</vh></v>
<v t="ekr.20071028032929.1245"><vh>3/07 Rewrote importWebCommand and its allies</vh></v>
<v t="ekr.20071028032929.1246"><vh>3/06 Import/Export commands</vh>
<v t="ekr.20071028032929.1247"><vh>3/06 Outline To Noweb works (as well as it is going to)</vh></v>
<v t="ekr.20071028032929.1248"><vh>3/06 Flatten Outline and Import Flattened Outline work</vh></v>
<v t="ekr.20071028032929.1249"><vh>3/06 Python, C, Java and Pascal Imports now work</vh></v>
</v>
<v t="ekr.20071028032929.1250"><vh>3/05 Import commands, colorizer, clear IDLE breakpoints</vh>
<v t="ekr.20071028032929.1251"><vh>3/05 Import commands, colorizer</vh></v>
<v t="ekr.20071028032929.1252"><vh>3/05 Added ability to clear breakpoints in IDLE</vh></v>
</v>
<v t="ekr.20071028032929.1253"><vh>3/04 Released leo.py 2.0 and Borland v2.6</vh>
<v t="ekr.20071028032929.1254"><vh>3/04 Improved read error messages.</vh></v>
<v t="ekr.20071028032929.1255"><vh>3/04 Untangle calls v.trimTrailingLines only for changed nodes</vh></v>
<v t="ekr.20071028032929.1256"><vh>3/04 changed v.setBodyStringOrPane</vh></v>
<v t="ekr.20071028032929.1257"><vh>3/04 Added finished messages for Tangle/Untangle</vh></v>
</v>
<v t="ekr.20071028032929.1258"><vh>3/03 Fixed Untangle, </vh>
<v t="ekr.20071028032929.1259"><vh>3/03 Created readme files</vh></v>
<v t="ekr.20071028032929.1260"><vh>3/03 Fixed Untangle bug</vh></v>
</v>
<v t="ekr.20071028032929.1261"><vh>3/02 Finished Undo, Preparing for release</vh>
<v t="ekr.20071028032929.1262"><vh>3/02 Created distutils files to distribute Borland Leo</vh></v>
<v t="ekr.20071028032929.1263"><vh>3/02 Created release notes for Borland v2.6</vh></v>
<v t="ekr.20071028032929.1264"><vh>3/02 Documented new commands and features</vh></v>
<v t="ekr.20071028032929.1265"><vh>3/02 Fixed all pychecker complaints against leoImport.py</vh></v>
<v t="ekr.20071028032929.1266"><vh>3/02 Added @space to Utils &amp; Tangle/Untangle code in LeoCB</vh></v>
<v t="ekr.20071028032929.1267"><vh>3/02 Completed Undo Change All</vh></v>
</v>
<v t="ekr.20071028032929.1268"><vh>3/01 Finished Tangle, Finished v2.6, etc.</vh>
<v t="ekr.20071028032929.1269"><vh>3/01 Completely supress all auto-indent in @nocolor mode</vh></v>
<v t="ekr.20071028032929.1270"><vh>3/01 Tangle now works exactly like LeoCB Tangle</vh></v>
<v t="ekr.20071028032929.1271"><vh>3/01 Finished Borland version 2.6</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1272"><vh>Feb 2002</vh>
<v t="ekr.20071028032929.1273"><vh>2/28 Small fixes</vh>
<v t="ekr.20071028032929.1274"><vh>Tangle now treats @c like @code</vh></v>
<v t="ekr.20071028032929.1275"><vh>Changed is_special_bits</vh></v>
<v t="ekr.20071028032929.1276"><vh>Installed Johansson patches</vh></v>
</v>
<v t="ekr.20071028032929.1277"><vh>2/27 pychecker(!), colorizer bug</vh>
<v t="ekr.20071028032929.1278"><vh>2/27 Fixed bug in colorizer</vh></v>
<v t="ekr.20071028032929.1279"><vh>2/27 Discovered pychecker (several bug fixes)</vh>
<v t="ekr.20071028032929.1280"><vh>Fixed bug in Mark Changed Roots</vh></v>
<v t="ekr.20071028032929.1281"><vh>Fixed bug in scanText related to @delims sentinel</vh></v>
<v t="ekr.20071028032929.1282"><vh>Fixed bug in write</vh></v>
<v t="ekr.20071028032929.1283"><vh>Fixed bugs in leoFileCommands</vh></v>
<v t="ekr.20071028032929.1284"><vh>Fixed bugs in leoNodes</vh></v>
<v t="ekr.20071028032929.1285"><vh>Fixed bugs in leoTangle</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1286"><vh>2/26 LeoCB can read compressed derived files</vh></v>
<v t="ekr.20071028032929.1287"><vh>2/25 Fixed IDLE, added verbatimAfterRef sentinel</vh>
<v t="ekr.20071028032929.1288"><vh>2/25 Fixed breakpoints in IDLE</vh></v>
<v t="ekr.20071028032929.1289"><vh>2/25 Added verbatimAfterRef sentinel</vh></v>
</v>
<v t="ekr.20071028032929.1290"><vh>2/24 suppressing newlines</vh></v>
<v t="ekr.20071028032929.1291"><vh>2/23 Untangle, colorizer bug</vh>
<v t="ekr.20071028032929.1292"><vh>2/23 Debugging untangle: fixed leading single-comments bug</vh></v>
<v t="ekr.20071028032929.1293"><vh>2/23 Fixed small colorizing bug</vh></v>
</v>
<v t="ekr.20071028032929.1294"><vh>2/22 askOKCancel dialog, suppressing auto-indent.</vh>
<v t="ekr.20071028032929.1295"><vh>2/22 Created askOkCancel dialog for Read @file Nodes</vh></v>
<v t="ekr.20071028032929.1296"><vh>2/22 Supressed auto-indent in @nocolor mode.</vh></v>
</v>
<v t="ekr.20071028032929.1297"><vh>2/20 and 2/21 Debugged Untangle</vh></v>
<v t="ekr.20071028032929.1298"><vh>2/19 Improved Unlimited Undo</vh></v>
<v t="ekr.20071028032929.1299"><vh>2/18 Unlimited Undo works</vh></v>
<v t="ekr.20071028032929.1300"><vh>2/16 Syntax coloring</vh>
<v t="ekr.20071028032929.1301"><vh>2/16 Fixed bugs in colorAnyLanguage</vh></v>
<v t="ekr.20071028032929.1302"><vh>2/16 Finished adding keywords for colorAnyLanguage</vh></v>
</v>
<v t="ekr.20071028032929.1303"><vh>2/15 Syntax coloring, undo, @space bug</vh>
<v t="ekr.20071028032929.1304"><vh>02/15 Created colorAnyLanguage</vh></v>
<v t="ekr.20071028032929.1305"><vh>02/15 Fixed @space bug</vh></v>
<v t="ekr.20071028032929.1306"><vh>02/15 Bug fix: section definition lines now end coloring for doc parts</vh></v>
<v t="ekr.20071028032929.1307"><vh>02/15 Finished Limited undo.</vh></v>
<v t="ekr.20071028032929.1308"><vh>02/15 Added files to manifest</vh></v>
</v>
<v t="ekr.20071028032929.1309"><vh>02/14 CVS</vh>
<v t="ekr.20071028032929.1310"><vh>02/14 Fixed Undo problems</vh></v>
<v t="ekr.20071028032929.1311"><vh>02/14 Checked out Leo from CVS</vh></v>
<v t="ekr.20071028032929.1312"><vh>02/14 Cant mend clones, How to use CVS</vh>
<v t="ekr.20071028032929.1313"><vh>CVS: Making a virtue out of necessity</vh></v>
<v t="ekr.20071028032929.1314"><vh>Ooops: Leo can't mend clone links!</vh></v>
<v t="ekr.20071028032929.1315"><vh>Completed Mending dialog</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1316"><vh>02/13 Mending clone links, undo</vh>
<v t="ekr.20071028032929.1317"><vh>Made the undo class partly functional</vh></v>
<v t="ekr.20071028032929.1318"><vh>Created menu utilities</vh></v>
<v t="ekr.20071028032929.1319"><vh>Fixed bug in Extract and Extract Section commands</vh></v>
</v>
<v t="ekr.20071028032929.1320"><vh>02/12 Minor fixes</vh>
<v t="ekr.20071028032929.1321"><vh>Studied the DnD code</vh></v>
<v t="ekr.20071028032929.1322"><vh>Cleared tab and space tags in colorizePython</vh></v>
<v t="ekr.20071028032929.1323"><vh>Made headlines longer</vh></v>
<v t="ekr.20071028032929.1324"><vh>Cleaned code</vh></v>
</v>
<v t="ekr.20071028032929.1325"><vh>02/11 experiments</vh>
<v t="ekr.20071028032929.1326"><vh>created sortSequence utility</vh></v>
<v t="ekr.20071028032929.1327"><vh>experimented with inspect</vh></v>
</v>
<v t="ekr.20071028032929.1328"><vh>02/10 1.0 released</vh>
<v t="ekr.20071028032929.1329"><vh>Removed "from x import *" from reload_all() and OnOpenPythonWindow'</vh></v>
<v t="ekr.20071028032929.1330"><vh>Released 1.0</vh></v>
<v t="ekr.20071028032929.1331"><vh>Added Contract Parent (Alt-0)</vh></v>
<v t="ekr.20071028032929.1332"><vh>Fixed bugs in Prefs panel</vh></v>
</v>
<v t="ekr.20071028032929.1333"><vh>02/09 Preparing for release</vh>
<v t="ekr.20071028032929.1334"><vh>02/09 Got clean import of leoImport.py</vh></v>
<v t="ekr.20071028032929.1335"><vh>02/09 Created do-nothing leoUndo.py</vh></v>
<v t="ekr.20071028032929.1336"><vh>02/09 Updated current language properly in Prefs panel</vh></v>
<v t="ekr.20071028032929.1337"><vh>02/09 Re-marked @file nodes dirty on write errors</vh></v>
<v t="ekr.20071028032929.1338"><vh>02/09 Prefs Panel stick to current window</vh></v>
<v t="ekr.20071028032929.1339"><vh>02/09 Tangle passes full regression test</vh></v>
<v t="ekr.20071028032929.1340"><vh>02/09 Added Sort Siblings</vh></v>
</v>
<v t="ekr.20071028032929.1341"><vh>02/08 Regression testing</vh>
<v t="ekr.20071028032929.1342"><vh>02/08 Found Tangle problem</vh></v>
<v t="ekr.20071028032929.1343"><vh>02/08 Cleaned up leoCompare.py</vh></v>
<v t="ekr.20071028032929.1344"><vh>02/08 @c in Tangled files</vh></v>
<v t="ekr.20071028032929.1345"><vh>02/08 Testing wiped out files!</vh></v>
</v>
<v t="ekr.20071028032929.1346"><vh>02/07 New commands and bug fixes</vh>
<v t="ekr.20071028032929.1347"><vh>02/07 Possible reversion</vh></v>
<v t="ekr.20071028032929.1348"><vh>02/07 Converted Import Files code</vh></v>
<v t="ekr.20071028032929.1349"><vh>02/07 Search suboutline only now applies to Search/ChangeAll</vh></v>
<v t="ekr.20071028032929.1350"><vh>02/07 Fixed bug in search()</vh></v>
<v t="ekr.20071028032929.1351"><vh>02/07 Fixed bug: @others wasn't colored unless at left margin.</vh></v>
<v t="ekr.20071028032929.1352"><vh>02/07 * Added indent and undent commands</vh></v>
<v t="ekr.20071028032929.1353"><vh>02/07 * Improved idle_body_key</vh></v>
</v>
<v t="ekr.20071028032929.1354"><vh>02/06 Finished commands</vh>
<v t="ekr.20071028032929.1355"><vh>02/06 Rewrote and tested all Edit Body commands</vh></v>
<v t="ekr.20071028032929.1356"><vh>02/06 Rewrote and tested Convert Blanks command</vh></v>
<v t="ekr.20071028032929.1357"><vh>02/06 Removed Print and Page Setup commands</vh></v>
<v t="ekr.20071028032929.1358"><vh>02/06 * Implemented View All Characters</vh></v>
<v t="ekr.20071028032929.1359"><vh>02/06 Got the arrow binding right</vh></v>
<v t="ekr.20071028032929.1360"><vh>02/06 finished Delete command</vh></v>
<v t="ekr.20071028032929.1361"><vh>02/06 created tree.onBodyChanged</vh></v>
<v t="ekr.20071028032929.1362"><vh>02/06 rewrote and tested Revert</vh></v>
<v t="ekr.20071028032929.1363"><vh>02/06 created leoDialog.yesNo</vh></v>
</v>
<v t="ekr.20071028032929.1364"><vh>2/05 More bug fixes</vh>
<v t="ekr.20071028032929.1365"><vh>02/05 * Extended Sherlock</vh></v>
<v t="ekr.20071028032929.1366"><vh>02/05 * Properly enabled and disabled all menu items</vh></v>
<v t="ekr.20071028032929.1367"><vh>02/05 Got special accelerator keys working</vh></v>
<v t="ekr.20071028032929.1368"><vh>02/05 GoTo commands now working</vh></v>
<v t="ekr.20071028032929.1369"><vh>02/05 Got Alt-keys working</vh></v>
<v t="ekr.20071028032929.1370"><vh>02/05 Made es and trace safer during quit</vh></v>
<v t="ekr.20071028032929.1371"><vh>02/05 Fixed bugs in Search Headline and Find, Then Change</vh></v>
<v t="ekr.20071028032929.1372"><vh>02/05 Do not eliminate begin/endUpdate!</vh></v>
</v>
<v t="ekr.20071028032929.1373"><vh>02/04 Many bug fixes &amp; some big improvements</vh>
<v t="ekr.20071028032929.1374"><vh>02/04 Fixed Change command in headline</vh></v>
<v t="ekr.20071028032929.1375"><vh>02/04 A kludgy way to cut &amp; paste between Leo &amp; Leo.py</vh></v>
<v t="ekr.20071028032929.1376"><vh>02/04 Ended all event handlers with return "break"</vh></v>
<v t="ekr.20071028032929.1377"><vh>02/04 Changed Insert Node accelerator from Control-K to Control-I</vh></v>
<v t="ekr.20071028032929.1378"><vh>02/04 Implemented Toggle Active Pane</vh></v>
<v t="ekr.20071028032929.1379"><vh>02/04 ** Overrode default text keys</vh></v>
<v t="ekr.20071028032929.1380"><vh>02/04 Documented control characters used in the body pane.</vh></v>
<v t="ekr.20071028032929.1381"><vh>02/04 ** Breakthrough regarding events and accelerators</vh></v>
<v t="ekr.20071028032929.1382"><vh>02/04 Implemented Select All command</vh></v>
<v t="ekr.20071028032929.1383"><vh>02/04 created OnBodyDoubleClick and allies</vh></v>
<v t="ekr.20071028032929.1384"><vh>02/04 create setTextSelelection utility</vh></v>
<v t="ekr.20071028032929.1385"><vh>02/04 Created Sort command</vh></v>
<v t="ekr.20071028032929.1386"><vh>02/04 Fixed Tangle Marked and Tangle All commands</vh></v>
</v>
<v t="ekr.20071028032929.1387"><vh>02/03 Created shortcuts for opening LeoPy.leo</vh></v>
<v t="ekr.20071028032929.1388"><vh>02/03 Released 0.08</vh></v>
<v t="ekr.20071028032929.1389"><vh>02/02 Fixing Bugs</vh>
<v t="ekr.20071028032929.1390"><vh>02/02 Fixed bugs in outline-only and whole-word searches &amp; is_c_id</vh></v>
<v t="ekr.20071028032929.1391"><vh>02/02 ** Drawing breakthroughs</vh></v>
<v t="ekr.20071028032929.1392"><vh>02/02 Fixed control-d bug</vh></v>
<v t="ekr.20071028032929.1393"><vh>02/02 ** About redrawing</vh></v>
</v>
<v t="ekr.20071028032929.1394"><vh>02/01 Fixing bugs</vh>
<v t="ekr.20071028032929.1395"><vh>02/01 Test tangle path errors</vh></v>
<v t="ekr.20071028032929.1396"><vh>02/01 ** started tree.makeVisible &amp; tree.scrollTo</vh></v>
<v t="ekr.20071028032929.1397"><vh>02/01 ** used distutils</vh></v>
</v>
</v>
<v t="ekr.20071028032929.1398"><vh>Jan 2002</vh>
<v t="ekr.20071028032929.1399"><vh>01/31 Preparing for release...</vh>
<v t="ekr.20071028032929.1400"><vh>** 01/31 leo.py now tangles better than LeoCB</vh></v>
<v t="ekr.20071028032929.1401"><vh>01/31 Created open script in leo.py</vh></v>
<v t="ekr.20071028032929.1402"><vh>01/31 Fixed suboutline only logic</vh></v>
<v t="ekr.20071028032929.1403"><vh>01/31 Tested directory logic</vh></v>
<v t="ekr.20071028032929.1404"><vh>01/31 replaced frame.defaultDirectory by c.tangle_directory</vh></v>
</v>
<v t="ekr.20071028032929.1405"><vh>01/30 Major improvements...</vh>
<v t="ekr.20071028032929.1406"><vh>01/30 ** May have solved the load path problem</vh></v>
<v t="ekr.20071028032929.1407"><vh>01/30 ** Rewrote path logic: removed all calls to os.chdir</vh></v>
<v t="ekr.20071028032929.1408"><vh>01/30 ** Fixed major bug causing @file read errors</vh></v>
<v t="ekr.20071028032929.1409"><vh>01/30 ** Changed how directories are handled</vh></v>
</v>
<v t="ekr.20071028032929.1410"><vh>01/29 Improved Paste Node command</vh></v>
<v t="ekr.20071028032929.1411"><vh>01/28 Generalized trace to allow function args</vh></v>
<v t="ekr.20071028032929.1412"><vh>01/28 Found source of Find performance bug</vh></v>
<v t="ekr.20071028032929.1413"><vh>01/25 Found one source of misreads</vh></v>
<v t="ekr.20071028032929.1414"><vh>01/24 Implemented Sherlock: init_trace and trace</vh></v>
<v t="ekr.20071028032929.1415"><vh>01/22 More work on leoTangle.py</vh></v>
<v t="ekr.20071028032929.1416"><vh>01/21 Started workon leoTangle.py</vh></v>
<v t="ekr.20071028032929.1417"><vh>01/20</vh>
<v t="ekr.20071028032929.1418"><vh>01/20 Lost clones into leoColor.py</vh></v>
<v t="ekr.20071028032929.1419"><vh>01/20 Implemented hyperlinks</vh></v>
</v>
<v t="ekr.20071028032929.1420"><vh>01/18 Completed Change all command</vh></v>
<v t="ekr.20071028032929.1421"><vh>01/17</vh>
<v t="ekr.20071028032929.1422"><vh>01/17 Breakthrough: tree.redraw_now</vh></v>
<v t="ekr.20071028032929.1423"><vh>01/17 much work on Find class</vh></v>
<v t="ekr.20071028032929.1424"><vh>01/17 v.edit_text defined only if v is visible</vh></v>
</v>
<v t="ekr.20071028032929.1425"><vh>01/16</vh>
<v t="ekr.20071028032929.1426"><vh>01/16 Fixed idle_headline logic</vh></v>
<v t="ekr.20071028032929.1427"><vh>01/16 Lost data in outline (not derived files)</vh></v>
<v t="ekr.20071028032929.1428"><vh>01/16 Fixed minor find/change bugs and removed batch checkbox</vh></v>
<v t="ekr.20071028032929.1429"><vh>01/16 Breakthrough re event handlers!</vh></v>
</v>
<v t="ekr.20071028032929.1430"><vh>01/15 Find/Change</vh>
<v t="ekr.20071028032929.1431"><vh>01/15 ** Completed find/change commands</vh></v>
<v t="ekr.20071028032929.1432"><vh>01/15 Converted headline from Tk.Entry to Tk.Text</vh></v>
</v>
<v t="ekr.20071028032929.1433"><vh>01/14</vh>
<v t="ekr.20071028032929.1434"><vh>01/14 Fixed bug: cancelling dialog wrote .leo</vh></v>
<v t="ekr.20071028032929.1435"><vh>01/14 Got basic Find commands to work</vh></v>
<v t="ekr.20071028032929.1436"><vh>01/14 Fixed Save To bug</vh></v>
<v t="ekr.20071028032929.1437"><vh>01/14 Added log messages for saves</vh></v>
<v t="ekr.20071028032929.1438"><vh>01/14 Always recompute file indices on saves</vh></v>
<v t="ekr.20071028032929.1439"><vh>01/14 Reduced width of log window</vh></v>
</v>
<v t="ekr.20071028032929.1440"><vh>01/13</vh>
<v t="ekr.20071028032929.1441"><vh>01/13 exec statement simplifies code</vh></v>
<v t="ekr.20071028032929.1442"><vh>01/13 Prefs/Find settings now functional</vh></v>
</v>
<v t="ekr.20071028032929.1443"><vh>01/11</vh>
<v t="ekr.20071028032929.1444"><vh>01/11 Replaced globals with app() ivars</vh></v>
<v t="ekr.20071028032929.1445"><vh>01/11 New memory management: created c/v/tree/frame destroy routines</vh></v>
<v t="ekr.20071028032929.1446"><vh>01/11 About destroy routines: eliminating circular references</vh></v>
<v t="ekr.20071028032929.1447"><vh>01/11 disabled c.setChanged while loading</vh></v>
<v t="ekr.20071028032929.1448"><vh>01/11 Eliminated ?? error message on exit</vh></v>
<v t="ekr.20071028032929.1449"><vh>01/11 created leoFrame.__del__</vh></v>
</v>
<v t="ekr.20071028032929.1450"><vh>01/10</vh>
<v t="ekr.20071028032929.1451"><vh>01/10 Worked on Quit error messages</vh></v>
<v t="ekr.20071028032929.1452"><vh>01/10 Released v 0.07</vh></v>
<v t="ekr.20071028032929.1453"><vh>01/10 Tested c2py on Borland</vh></v>
</v>
<v t="ekr.20071028032929.1454"><vh>01/09</vh>
<v t="ekr.20071028032929.1455"><vh>01/09 Wrote and debugged leo1to2 scripts !</vh></v>
<v t="ekr.20071028032929.1456"><vh>01/09 Made Python window functional !</vh></v>
<v t="ekr.20071028032929.1457"><vh>01/09 Added auto indent</vh></v>
</v>
<v t="ekr.20071028032929.1458"><vh>01/08</vh>
<v t="ekr.20071028032929.1459"><vh>01/08 bodyKeepsFocus logic</vh></v>
<v t="ekr.20071028032929.1460"><vh>01/08 Fixed bug: no doesn't abort a Quit command</vh></v>
<v t="ekr.20071028032929.1461"><vh>01/08 Fixed bug: changing clones didn't mark joined dirty.</vh></v>
<v t="ekr.20071028032929.1462"><vh>01/08 Got cut/copy/paste working</vh></v>
<v t="ekr.20071028032929.1463"><vh>01/08 Fixed reooloring problem</vh></v>
<v t="ekr.20071028032929.1464"><vh>01/08 Added Help-Leo Documentation command</vh></v>
<v t="ekr.20071028032929.1465"><vh>01/08 Save commands now ensure .leo extension</vh></v>
<v t="ekr.20071028032929.1466"><vh>01/08 Still no joy with canvas border</vh></v>
<v t="ekr.20071028032929.1467"><vh>01/08 Expermented with window icons</vh></v>
<v t="ekr.20071028032929.1468"><vh>01/08 Increased size of open windows</vh></v>
<v t="ekr.20071028032929.1469"><vh>01/08 Improved look of prefs panel</vh></v>
<v t="ekr.20071028032929.1470"><vh>01/08 Made progress towards "Show invisibles"</vh></v>
<v t="ekr.20071028032929.1471"><vh>01/08 @ignore now colored properly</vh></v>
<v t="ekr.20071028032929.1472"><vh>01/08 @color and @nocolor are now inherited</vh></v>
</v>
<v t="ekr.20071028032929.1473"><vh>01/07</vh>
<v t="ekr.20071028032929.1474"><vh>01/07 Fixed some bugs in Move Up and Move Down commands</vh></v>
<v t="ekr.20071028032929.1475"><vh>01/07 Fixed loss-of-data on insert command</vh></v>
<v t="ekr.20071028032929.1476"><vh>01/07 tab width</vh></v>
</v>
<v t="ekr.20071028032929.1477"><vh>01/06</vh>
<v t="ekr.20071028032929.1478"><vh>01/06 borders again</vh></v>
<v t="ekr.20071028032929.1479"><vh>01/06 editing and selecting</vh></v>
</v>
</v>
</v>
<v t="ekr.20071028032929.1480"><vh>2001</vh>
<v t="ekr.20071028032929.1481"><vh>Dec 2001</vh>
<v t="ekr.20071028032929.1482"><vh>12/20/01 Fixed Linux problems</vh></v>
<v t="ekr.20071028032929.1483"><vh>12/19/01 Improved LeoDocs.leo</vh></v>
<v t="ekr.20071028032929.1484"><vh>12/18/01 Improved Leo2 documentation</vh></v>
<v t="ekr.20071028032929.1485"><vh>12/17/01 ** Leo 0.05 released</vh></v>
<v t="ekr.20071028032929.1486"><vh>12/16/01 Found the source of the file mismatches</vh></v>
<v t="ekr.20071028032929.1487"><vh>12/16/01 Created directory compare routines</vh></v>
<v t="ekr.20071028032929.1488"><vh>12/15/01 Leo is operational</vh></v>
<v t="ekr.20071028032929.1489"><vh>12/15/01 Fixed bug in scanText</vh></v>
<v t="ekr.20071028032929.1490"><vh>12/15/01 Fixed bug in putBodyPart</vh></v>
<v t="ekr.20071028032929.1491"><vh>12/15/01 Fixed lookahead code in scanText, scanDoc</vh></v>
<v t="ekr.20071028032929.1492"><vh>12/14/01 Created leoCompare.py</vh></v>
<v t="ekr.20071028032929.1493"><vh>12/14/01 Create leoDialog.py</vh></v>
<v t="ekr.20071028032929.1494"><vh>12/14/01 Fixed minor problems</vh></v>
<v t="ekr.20071028032929.1495"><vh>12/13/01 Fixed several clone bugs</vh></v>
<v t="ekr.20071028032929.1496"><vh>12/13/01 Aha: we can eliminate v.setIcon !</vh></v>
<v t="ekr.20071028032929.1497"><vh>12/13/01 ** Fixed bottleneck with endupdate(flag)</vh></v>
<v t="ekr.20071028032929.1498"><vh>12/13/01 ** Syntax coloring now works</vh></v>
<v t="ekr.20071028032929.1499"><vh>12/12/01 Cut/copy/paste of nodes now done using internal clipboard</vh></v>
<v t="ekr.20071028032929.1500"><vh>12/12/01 Fixed insert, move, clone and delete commands</vh></v>
<v t="ekr.20071028032929.1501"><vh>12/12/01 Looked into Tk &amp; Python clipboard commands</vh></v>
<v t="ekr.20071028032929.1502"><vh>12/11/01 Menu accelerators</vh></v>
<v t="ekr.20071028032929.1503"><vh>12/11/01 Properly initialized the file in getLeoFile</vh></v>
<v t="ekr.20071028032929.1504"><vh>12/10/01 Got accellerators working</vh></v>
<v t="ekr.20071028032929.1505"><vh>12/10/01 Simplified icon handling, tree.redraw</vh></v>
<v t="ekr.20071028032929.1506"><vh>12/10/01 Used idle-time handler to work around event problems</vh></v>
<v t="ekr.20071028032929.1507"><vh>12/09/01 Problems with canvas border</vh></v>
<v t="ekr.20071028032929.1508"><vh>12/09/01 Tree now drawn properly</vh></v>
<v t="ekr.20071028032929.1509"><vh>12/08/01 Progress with selection</vh></v>
<v t="ekr.20071028032929.1510"><vh>12/07/01 Small improvements</vh></v>
<v t="ekr.20071028032929.1511"><vh>12/07/01 Tree now contains labels for editing</vh></v>
<v t="ekr.20071028032929.1512"><vh>12/06/01 Open/Close events now handled properly</vh></v>
<v t="ekr.20071028032929.1513"><vh>12/06/01 Tree drawn correctly, slowly</vh></v>
<v t="ekr.20071028032929.1514"><vh>12/04/01 Create .gif icons</vh></v>
<v t="ekr.20071028032929.1515"><vh>12/04/01 replaced dvnodes with vnodes!</vh></v>
<v t="ekr.20071028032929.1516"><vh>12/04/01 read code is now fast enough!</vh></v>
<v t="ekr.20071028032929.1517"><vh>12/04/01 tree starts to work</vh></v>
<v t="ekr.20071028032929.1518"><vh>12/01/01</vh></v>
</v>
<v t="ekr.20071028032929.1519"><vh>Nov 2001</vh>
<v t="ekr.20071028032929.1520"><vh>11/15/01 Created do-nothing tk app using Tkinter</vh></v>
<v t="ekr.20071028032929.1521"><vh>11/15/01 added -padx to log window</vh></v>
<v t="ekr.20071028032929.1522"><vh>11/13/01 Speeding up reads</vh></v>
<v t="ekr.20071028032929.1523"><vh>11/11/01 Design of tree class</vh></v>
<v t="ekr.20071028032929.1524"><vh>11/10/01 began conversion to tk</vh></v>
<v t="ekr.20071028032929.1525"><vh>11/10/01 es outputs newline</vh></v>
<v t="ekr.20071028032929.1526"><vh>11/10/01 fixed bug in putDocPart</vh></v>
<v t="ekr.20071028032929.1527"><vh>11/10/01 added code for @delims</vh></v>
<v t="ekr.20071028032929.1528"><vh>11/10/01 got @first working</vh></v>
<v t="ekr.20071028032929.1529"><vh>11/09/01 moved all globals into class</vh></v>
<v t="ekr.20071028032929.1530"><vh>11/09/01 fixed bugs in write logic</vh></v>
<v t="ekr.20071028032929.1531"><vh>11/09/01 fixed bugs read logic</vh></v>
<v t="ekr.20071028032929.1532"><vh>11/06/01 created Leo window using Tk</vh></v>
</v>
<v t="ekr.20071028032929.1533"><vh>Oct 2001</vh>
<v t="ekr.20071028032929.1534"><vh>11/01/01 Write code works except for comments</vh></v>
<v t="ekr.20071028032929.1535"><vh>10/31/01 Added Read/write submenu</vh></v>
<v t="ekr.20071028032929.1536"><vh>10/31/01 Fixed write code</vh></v>
<v t="ekr.20071028032929.1537"><vh>10/26/01 Read code is slow</vh></v>
<v t="ekr.20071028032929.1538"><vh>10/26/01 Read/write code now works</vh></v>
<v t="ekr.20071028032929.1539"><vh>10/11/01 Outline commands now work</vh></v>
<v t="ekr.20071028032929.1540"><vh>10/11/01 Removed redundant getters</vh></v>
<v t="ekr.20071028032929.1541"><vh>10/10/01 Debugged Commands, nodes, fileCommands</vh></v>
<v t="ekr.20071028032929.1542"><vh>10/08/01 design of leoFileCommands</vh></v>
<v t="ekr.20071028032929.1543"><vh>10/07/01 removed info and tagList classes</vh></v>
<v t="ekr.20071028032929.1544"><vh>10/05/01 c2py fixes, speedTest</vh></v>
<v t="ekr.20071028032929.1545"><vh>10/02/01 through 1/10/4</vh></v>
<v t="ekr.20071028032929.1546"><vh>10/01/01 fxed bugs in c2py</vh></v>
<v t="ekr.20071028032929.1547"><vh>10/01/01 c2py in leo</vh></v>
</v>
<v t="ekr.20071028032929.1548"><vh>Sept 2001</vh>
<v t="ekr.20071028032929.1549"><vh>9/30/01 documented c2py</vh></v>
<v t="ekr.20071028032929.1550"><vh>9/29/01 c2py.py</vh></v>
<v t="ekr.20071028032929.1551"><vh>9/25/01 Idle has trees &amp; syntax coloring</vh></v>
<v t="ekr.20071028032929.1552"><vh>9/14/01</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20080408060320.781"><vh>Leo 4.4.x projects</vh></v>
<v t="ekr.20090401102247.2"><vh>Leo 4.6.x projects</vh>
<v t="ekr.20090401102247.3"><vh>Leo 4.6 b1 projects</vh>
<v t="ekr.20090401102247.4"><vh>Completed 3-day bugs</vh>
<v t="ekr.20090401102247.5"><vh>Added support for smart_tab setting</vh>
<v t="ekr.20090401102247.6"><vh>insertNewLineAndTab (changed)</vh></v>
<v t="ekr.20090401102247.7"><vh> c.Birth &amp; death</vh>
<v t="ekr.20090401102247.8"><vh>c.__init__</vh></v>
<v t="ekr.20090401102247.9"><vh>c.__repr__ &amp; __str__</vh></v>
<v t="ekr.20090401102247.10"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20090401102247.11"><vh>printCommandsDict</vh></v>
</v>
<v t="ekr.20090401102247.12"><vh>c.hash</vh></v>
<v t="ekr.20090401102247.13"><vh>c.initAfterLoad</vh></v>
<v t="ekr.20090401102247.14"><vh>c.initConfigSettings</vh></v>
<v t="ekr.20090401102247.15"><vh>c.initIvars</vh>
<v t="ekr.20090401102247.16"><vh>&lt;&lt; initialize ivars &gt;&gt; (commands)</vh></v>
</v>
<v t="ekr.20090401102247.17"><vh>c.setWindowPosition</vh></v>
</v>
<v t="ekr.20090401102247.18"><vh>selfInsertCommand, helpers</vh>
<v t="ekr.20090401102247.19"><vh>&lt;&lt; set local vars &gt;&gt;</vh></v>
<v t="ekr.20090401102247.20"><vh>doPlainTab</vh></v>
<v t="ekr.20090401102247.21"><vh>flashCharacter</vh></v>
<v t="ekr.20090401102247.22"><vh>flashMatchingBracketsHelper</vh></v>
<v t="ekr.20090401102247.23"><vh>initBracketMatcher</vh></v>
<v t="ekr.20090401102247.24"><vh>insertNewlineHelper</vh></v>
<v t="ekr.20090401102247.25"><vh>updateAutoIndent (leoEditCommands)</vh></v>
<v t="ekr.20090401102247.26"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20090401102247.27"><vh>updateTab</vh></v>
</v>
</v>
<v t="ekr.20090401102247.28"><vh>Support existing @int tab_width setting</vh>
<v t="ekr.20090401102247.14"></v>
</v>
<v t="ekr.20090401102247.29"><vh>Use re to scan for directives</vh>
<v t="ekr.20090401102247.30"><vh>&lt;&lt; define global data structures &gt;&gt;</vh></v>
<v t="ekr.20090401102247.31"><vh>frame.scanForTabWidth (must be fast)</vh></v>
<v t="ekr.20090401102247.25"></v>
<v t="ekr.20090401102247.32"><vh>g.Directive utils...</vh>
<v t="ekr.20090401102247.33"><vh>g.comment_delims_from_extension</vh></v>
<v t="ekr.20090401102247.34"><vh>g.computeRelativePath</vh></v>
<v t="ekr.20090401102247.35"><vh>g.findAtTabWidthDirectives (must be fast)</vh></v>
<v t="ekr.20090401102247.36"><vh>g.findLanguageDirectives (must be fast)</vh></v>
<v t="ekr.20090401102247.37"><vh>g.findReference</vh></v>
<v t="ekr.20090401102247.38"><vh>g.get_directives_dict (must be fast)</vh>
<v t="ekr.20090401102247.39"><vh>compute_directives_re</vh></v>
</v>
<v t="ekr.20090401102247.40"><vh>g.get_directives_dict_list (must be fast)</vh></v>
<v t="ekr.20090401102247.41"><vh>g.getOutputNewline</vh></v>
<v t="ekr.20090401102247.42"><vh>g.scanAtCommentAndLanguageDirectives</vh></v>
<v t="ekr.20090401102247.43"><vh>g.scanAtEncodingDirectives</vh></v>
<v t="ekr.20090401102247.44"><vh>g.scanAtHeaderDirectives</vh></v>
<v t="ekr.20090401102247.45"><vh>g.scanAtLineendingDirectives</vh></v>
<v t="ekr.20090401102247.46"><vh>g.scanAtPagewidthDirectives</vh></v>
<v t="ekr.20090401102247.47"><vh>g.scanAtRootOptions</vh>
<v t="ekr.20090401102247.48"><vh>&lt;&lt; scan another @root option &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.49"><vh>g.scanAtTabwidthDirectives</vh></v>
<v t="ekr.20090401102247.50"><vh>g.scanAtWrapDirectives</vh></v>
<v t="ekr.20090401102247.51"><vh>g.scanDirectives  (for compatibility only)</vh></v>
<v t="ekr.20090401102247.52"><vh>g.scanForAtIgnore</vh></v>
<v t="ekr.20090401102247.53"><vh>g.scanForAtLanguage</vh></v>
<v t="ekr.20090401102247.54"><vh>g.scanForAtSettings</vh></v>
<v t="ekr.20090401102247.55"><vh>g.set_delims_from_language</vh></v>
<v t="ekr.20090401102247.56"><vh>g.set_delims_from_string</vh></v>
<v t="ekr.20090401102247.57"><vh>g.set_language</vh></v>
<v t="ekr.20090401102247.58"><vh>g.setDefaultDirectory</vh>
<v t="ekr.20090401102247.59"><vh>&lt;&lt; Set path from @file node &gt;&gt;</vh></v>
<v t="ekr.20090401102247.60"><vh>&lt;&lt; handle @path &gt;&gt;</vh></v>
<v t="ekr.20090401102247.61"><vh>&lt;&lt; Set current directory &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20090401102247.62"><vh>Timing</vh></v>
</v>
<v t="ekr.20090401102247.63"><vh>@chapter problem with qt plugin</vh></v>
<v t="ekr.20090401102247.64"><vh>Fixed body-pane-out-of-synch bug</vh>
<v t="ekr.20090401102247.65"><vh>chapter.select &amp; helpers</vh>
<v t="ekr.20090401102247.66"><vh>chapterSelectHelper</vh></v>
<v t="ekr.20090401102247.67"><vh>chapter.findPositionInChapter</vh></v>
<v t="ekr.20090401102247.68"><vh>chapter.findEditorInChapter</vh></v>
<v t="ekr.20090401102247.69"><vh>chapter.positionIsInChapter</vh></v>
<v t="ekr.20090401102247.70"><vh>chapter.rename (not used)</vh></v>
</v>
<v t="ekr.20090401102247.71"><vh>leoTree.select &amp; helpers</vh>
<v t="ekr.20090401102247.72"><vh>selectHelper</vh>
<v t="ekr.20090401102247.73"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20090401102247.74"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20090401102247.75"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.76"><vh>setBodyTextAfterSelect</vh></v>
</v>
<v t="ekr.20090401102247.77"><vh>c.expandAllAncestors</vh></v>
<v t="ekr.20090401102247.78"><vh>c.redraw_after_select</vh></v>
</v>
<v t="ekr.20090401102247.79"><vh>Predefined 'self' in @test/@suite nodes</vh>
<v t="ekr.20090401102247.80"><vh>runTest</vh></v>
<v t="ekr.20090401102247.81"><vh>class generalTestCase</vh>
<v t="ekr.20090401102247.82"><vh>__init__</vh></v>
<v t="ekr.20090401102247.83"><vh> fail</vh></v>
<v t="ekr.20090401102247.84"><vh>tearDown</vh></v>
<v t="ekr.20090401102247.85"><vh>setUp</vh></v>
<v t="ekr.20090401102247.80"></v>
<v t="ekr.20090401102247.86"><vh>shortDescription</vh></v>
</v>
</v>
<v t="ekr.20090401102247.87"><vh>Fixed check-leo-outline bug</vh>
<v t="ekr.20090401102247.88"><vh>checkDerivedFile (atFile)</vh></v>
<v t="ekr.20090401102247.89"><vh>scanHeaderForThin</vh></v>
<v t="ekr.20090401102247.90"><vh>scanHeader</vh>
<v t="ekr.20090401102247.91"><vh>&lt;&lt; skip any non @+leo lines &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20090401102247.92"><vh>Bugs</vh>
<v t="ekr.20090401102247.93"><vh>Not bugs</vh>
<v t="ekr.20090401102247.94"><vh>Investigated settings strangeness re @string debugger_path</vh></v>
<v t="ekr.20090401102247.95"><vh>Don't put relative paths on the recent file list</vh>
<v t="ekr.20090401102247.96"><vh>c.updateRecentFiles</vh></v>
</v>
</v>
<v t="ekr.20090401102247.97"><vh>Ensure that Python\Scripts exists in installer script</vh></v>
<v t="ekr.20090401102247.98"><vh>Fix config crasher</vh>
<v t="ekr.20090401102247.99"><vh>typesMatch</vh></v>
</v>
<v t="ekr.20090401102247.100"><vh>Fixed encoding problems with rst3 plugin</vh></v>
<v t="ekr.20090401102247.101"><vh>Simplified c.scanAtPathDirectives</vh>
<v t="ekr.20090401102247.102"><vh>c.scanAtPathDirectives</vh></v>
</v>
<v t="ekr.20090401102247.103"><vh>Fixed goto-global-line crasher</vh>
<v t="ekr.20090401102247.104"><vh>c.scanAllDirectives</vh></v>
<v t="ekr.20090401102247.102"></v>
<v t="ekr.20090401102247.105"><vh>g.makeAllNonExistentDirectories</vh></v>
<v t="ekr.20090401102247.106"><vh>c.gotoLineNumber and helpers</vh>
<v t="ekr.20090401102247.107"><vh>&lt;&lt; trace gotoLineNumber results &gt;&gt;</vh></v>
<v t="ekr.20090401102247.108"><vh>goto_applyLineNumberMapping</vh></v>
<v t="ekr.20090401102247.109"><vh>goto_countLines</vh></v>
<v t="ekr.20090401102247.110"><vh>goto_findPosition &amp; helpers</vh>
<v t="ekr.20090401102247.111"><vh>goto_findGnx</vh></v>
<v t="ekr.20090401102247.112"><vh>goto_scanTnodeList</vh>
<v t="ekr.20090401102247.113"><vh>&lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;</vh></v>
<v t="ekr.20090401102247.114"><vh>&lt;&lt; set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false &gt;&gt;</vh></v>
<v t="ekr.20090401102247.115"><vh>&lt;&lt; set p to the first node whose headline matches vnodeName &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20090401102247.116"><vh>goto_findVnode</vh>
<v t="ekr.20090401102247.117"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="ekr.20090401102247.118"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="ekr.20090401102247.119"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.120"><vh>&lt;&lt; set gnx and vnodeName from s &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.121"><vh>goto_setup &amp; helpers</vh>
<v t="ekr.20090401102247.122"><vh>goto_findRoot</vh></v>
<v t="ekr.20090401102247.123"><vh>goto_getFileLines</vh></v>
<v t="ekr.20090401102247.124"><vh>goto_getScriptLines</vh></v>
<v t="ekr.20090401102247.125"><vh>goto_open</vh></v>
</v>
<v t="ekr.20090401102247.126"><vh>goto_showResults</vh></v>
<v t="ekr.20090401102247.127"><vh>goto_skipToMatchingNodeSentinel</vh></v>
</v>
</v>
<v t="ekr.20090401102247.128"><vh>Removed pychecker stuff</vh></v>
<v t="ekr.20090401102247.129"><vh>Fixed new rst3 crash</vh>
<v t="ekr.20090401102247.130"><vh>Report</vh></v>
<v t="ekr.20090401102247.105"></v>
</v>
<v t="ekr.20090401102247.131"><vh>Fixed two c syntax-coloring bugs</vh>
<v t="ekr.20090401102247.132"><vh>Bug 1</vh>
<v t="ekr.20090401102247.133"><vh>@url http://www.freenet.org.nz/misc/leo-c-screenshot.jpg</vh></v>
</v>
<v t="ekr.20090401102247.134"><vh>Bug 2</vh></v>
<v t="ekr.20090401102247.135"><vh>skip_line, skip_to_start/end_of_line</vh></v>
</v>
<v t="ekr.20090401102247.136"><vh>Restored deleted unit tests for p.textOffset</vh></v>
<v t="ekr.20090401102247.137"><vh>Fixed bug that prevented Leo from opening files on the XP desktop</vh>
<v t="ekr.20090401102247.138"><vh>getFileName &amp; helper</vh>
<v t="ekr.20090401102247.139"><vh>completeFileName</vh></v>
</v>
</v>
<v t="ekr.20090401102247.140"><vh>Fixed nested @path problem</vh>
<v t="ekr.20090401102247.141" a="E"><vh>createOutline (leoImport)</vh>
<v t="ekr.20090401102247.142"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
<v t="ekr.20090401102247.143"><vh>&lt;&lt; convert s to the proper encoding &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.144"><vh>scanDefaultDirectory (leoImport)</vh></v>
<v t="ekr.20090401102247.145"><vh>atFile.scanDefaultDirectory</vh></v>
<v t="ekr.20090401102247.58"></v>
</v>
<v t="ekr.20090401102247.146"><vh>Fixed one failed unit test on Linux</vh>
<v t="ekr.20090401102247.147"><vh>checkTrialWrite</vh></v>
<v t="ekr.20090401102247.148"><vh>compareHelper</vh></v>
<v t="ekr.20090401102247.149"><vh>reportMismatch</vh></v>
<v t="ekr.20090401102247.150"><vh>Import/Export test code (leoTest.py)</vh>
<v t="ekr.20090401102247.151"><vh>makeImportExportSuite</vh></v>
<v t="ekr.20090401102247.152"><vh>class importExportTestCase</vh>
<v t="ekr.20090401102247.153"><vh>__init__</vh></v>
<v t="ekr.20090401102247.154"><vh> fail</vh></v>
<v t="ekr.20090401102247.155"><vh>importExport</vh></v>
<v t="ekr.20090401102247.156"><vh>runTest</vh></v>
<v t="ekr.20090401102247.157"><vh>setUp</vh></v>
<v t="ekr.20090401102247.158"><vh>shortDescription</vh></v>
<v t="ekr.20090401102247.159"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20090401102247.160"><vh>importAtFile</vh></v>
<v t="ekr.20090401102247.161"><vh>importFilesCommand</vh>
<v t="ekr.20090401102247.162"><vh>&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20090401102247.163"><vh>Save/restore tnodeList in atFile.write</vh>
<v t="ekr.20090401102247.164"><vh>write &amp; helper</vh>
<v t="ekr.20090401102247.165"><vh>&lt;&lt; set at.targetFileName &gt;&gt;</vh></v>
<v t="ekr.20090401102247.166"><vh>&lt;&lt; set dirty and orphan bits &gt;&gt;</vh></v>
<v t="ekr.20090401102247.167"><vh>shouldWriteAtNosentNode</vh></v>
</v>
<v t="ekr.20090401102247.168"><vh>clean_file</vh></v>
</v>
<v t="ekr.20090401102247.169"><vh>Fixed (?) bug in plugins dispatcher</vh>
<v t="ekr.20090401102247.170"><vh>callTagHandler</vh></v>
</v>
<v t="ekr.20090401102247.171"><vh>Paste outline problem</vh>
<v t="ekr.20090401102247.172"><vh>c.new</vh></v>
</v>
<v t="ekr.20090401102247.173"><vh>backwardKill word doesn't work w/ qt gui</vh>
<v t="ekr.20090401102247.174"><vh>backwardKillWord &amp; killWord</vh></v>
<v t="ekr.20090401102247.175"><vh>extend-to-word</vh></v>
<v t="ekr.20090401102247.176"><vh>move cursor... (leoEditCommands)</vh>
<v t="ekr.20090401102247.177"><vh> helpers</vh>
<v t="ekr.20090401102247.178"><vh>extendHelper</vh></v>
<v t="ekr.20090401102247.179"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20090401102247.180"><vh>moveToHelper</vh></v>
<v t="ekr.20090401102247.181"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20090401102247.182"><vh>moveWordHelper</vh></v>
<v t="ekr.20090401102247.183"><vh>backSentenceHelper</vh></v>
<v t="ekr.20090401102247.184"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20090401102247.185"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20090401102247.186"><vh>backwardParagraphHelper</vh></v>
<v t="ekr.20090401102247.187"><vh>setMoveCol</vh></v>
</v>
<v t="ekr.20090401102247.188"><vh>backToHome</vh></v>
<v t="ekr.20090401102247.189"><vh>backToIndentation</vh></v>
<v t="ekr.20090401102247.190"><vh>buffers</vh></v>
<v t="ekr.20090401102247.191"><vh>characters</vh></v>
<v t="ekr.20090401102247.192"><vh>clear/set/ToggleExtendMode</vh></v>
<v t="ekr.20090401102247.193"><vh>exchangePointMark</vh></v>
<v t="ekr.20090401102247.194"><vh>extend-to-line</vh></v>
<v t="ekr.20090401102247.195"><vh>extend-to-sentence</vh></v>
<v t="ekr.20090401102247.175"></v>
<v t="ekr.20090401102247.196"><vh>lines</vh></v>
<v t="ekr.20090401102247.197"><vh>movePastClose</vh></v>
<v t="ekr.20090401102247.198"><vh>paragraphs</vh></v>
<v t="ekr.20090401102247.199"><vh>sentences</vh></v>
<v t="ekr.20090401102247.200"><vh>words</vh></v>
</v>
</v>
<v t="ekr.20090401102247.201"><vh>Fixed positionExists bug</vh>
<v t="ekr.20090401102247.202"><vh>c.positionExists</vh></v>
<v t="ekr.20090401102247.203"><vh>p.doDelete</vh></v>
</v>
<v t="ekr.20090401102247.204"><vh>Speed up autocompleter prints</vh>
<v t="ekr.20090401102247.205"><vh>changed</vh>
<v t="ekr.20090401102247.206"><vh>computeCompletionList</vh></v>
<v t="ekr.20090401102247.207"><vh>k.computeCompletionList</vh></v>
</v>
</v>
<v t="ekr.20090401102247.208"><vh>Fixed new bug in positionExists</vh>
<v t="ekr.20090401102247.202"></v>
</v>
<v t="ekr.20090401102247.209"><vh>Made sure $Home works for @nosent</vh>
<v t="ekr.20090401102247.164"></v>
<v t="ekr.20090401102247.210"><vh>initWriteIvars</vh>
<v t="ekr.20090401102247.211"><vh>&lt;&lt; init ivars for writing &gt;&gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.212"><vh>atFile.scanAllDirectives</vh>
<v t="ekr.20090401102247.213"><vh>&lt;&lt; Set ivars &gt;&gt;</vh></v>
<v t="ekr.20090401102247.214"><vh>&lt;&lt; Set comment strings from delims &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.102"></v>
<v t="ekr.20090401102247.215"><vh>c.os_path_finalize and c.os_path_finalize_join</vh></v>
<v t="ekr.20090401102247.216"><vh>g.os_path_finalize &amp; os_path_finalize_join</vh></v>
<v t="ekr.20090401102247.217"><vh>os_path_expandExpression</vh></v>
</v>
<v t="ekr.20090401102247.218"><vh>Fixed atFile unicode bug</vh>
<v t="ekr.20090401102247.219"><vh>os</vh></v>
<v t="ekr.20090401102247.220"><vh>putIndent</vh></v>
<v t="ekr.20090401102247.221"><vh>parseUnderindentTag</vh></v>
</v>
<v t="ekr.20090401102247.222"><vh>Removed redundant calls to expandAllAncestors</vh>
<v t="ekr.20090401102247.223"><vh>c.redrawAndEdit</vh></v>
<v t="ekr.20090401102247.224"><vh>c.redraw</vh></v>
<v t="ekr.20090401102247.78"></v>
<v t="ekr.20090401102247.225"><vh>c.selectPosition</vh></v>
<v t="ekr.20090401102247.71"></v>
</v>
<v t="ekr.20090401102247.226"><vh>Removed most calls to edit_widget</vh>
<v t="ekr.20090401102247.227"><vh>Found: edit_widget</vh>
<v t="ekr.20090401102247.228"><vh>Tests</vh>
<v t="ekr.20090401102247.229"><vh>@test return ends editing of headline</vh></v>
<v t="ekr.20090401102247.230"><vh>@test editLabel selects entire headline</vh></v>
<v t="ekr.20090401102247.231"><vh>@test paste at end of headline</vh></v>
<v t="ekr.20090401102247.232"><vh>@@@test typing and undo in headline - at end</vh></v>
<v t="ekr.20090401102247.233"><vh>@test paste and undo in headline - at end</vh></v>
<v t="ekr.20090401102247.234"><vh>@test paste and undo in headline - with selection</vh></v>
<v t="ekr.20090401102247.235"><vh>@@@test selecting new node retains typing in headline</vh></v>
<v t="ekr.20090401102247.236"><vh>@test paste from menu into headline sticks</vh></v>
<v t="ekr.20090401102247.237"><vh>@@@test typing in headline recomputes width</vh></v>
<v t="ekr.20090401102247.238"><vh>@test selecting new node retains paste in headline</vh></v>
<v t="ekr.20090401102247.239"><vh>@test &lt;Delete&gt; key sticks in headline</vh></v>
<v t="ekr.20090401102247.240"><vh>@test Select a node when file is first loaded</vh></v>
<v t="ekr.20090401102247.241"><vh>@test k.registerCommand</vh></v>
</v>
<v t="ekr.20090401102247.242"><vh>Can't be changed, but may possibly be eliminated</vh>
<v t="ekr.20090401102247.243"><vh>c.edit_widget</vh></v>
<v t="ekr.20090401102247.244"><vh>onHeadChanged (leoTree)</vh>
<v t="ekr.20090401102247.245"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20090401102247.246"><vh>Changed</vh>
<v t="ekr.20090401102247.247"><vh>toggleAngleBrackets</vh></v>
<v t="ekr.20090401102247.248"><vh>insertHeadlineTime</vh></v>
<v t="ekr.20090401102247.223"></v>
<v t="ekr.20090401102247.223"></v>
<v t="ekr.20090401102247.249"><vh>showSuccess (leoFind)</vh></v>
<v t="ekr.20090401102247.250"><vh>c.xWantsFocus</vh></v>
<v t="ekr.20090401102247.251"><vh>initInteractiveCommands</vh></v>
<v t="ekr.20090401102247.252"><vh>c.setHeadString</vh></v>
<v t="ekr.20090401102247.253"><vh>abortEditLabelCommand (leoFrame)</vh></v>
<v t="ekr.20090401102247.254"><vh>changeSelection</vh>
<v t="ekr.20090401102247.255"><vh>makeRegexSubs</vh></v>
</v>
</v>
<v t="ekr.20090401102247.256"><vh>Unchanged</vh>
<v t="ekr.20090401102247.257"><vh>Headlines (nullTree)</vh>
<v t="ekr.20090401102247.258"><vh>editLabel (nullTree)</vh></v>
<v t="ekr.20090401102247.259"><vh>setHeadline (nullTree)</vh></v>
</v>
<v t="ekr.20090401102247.260"><vh> Must be defined in subclasses</vh></v>
<v t="ekr.20090401102247.261"><vh>  tree.__init__ (base class)</vh>
<v t="ekr.20090401102247.262"><vh>leoTree.mustBeDefined</vh></v>
<v t="ekr.20090401102247.263"><vh>leoTree.mustBeDefinedOnlyInBaseClass</vh></v>
<v t="ekr.20090401102247.264"><vh>leoTree.mustBeDefinedInSubclasses</vh></v>
</v>
<v t="ekr.20090401102247.265"><vh>save (leoFind)</vh></v>
</v>
</v>
<v t="ekr.20090401102247.244"></v>
</v>
<v t="ekr.20090401102247.266"><vh>Fixed Kent's @auto bug</vh>
<v t="ekr.20090401102247.267"><vh>readOneAtAutoNode (leoImport)</vh></v>
<v t="ekr.20090401102247.268"><vh>readOneAtAutoNode (atFile)</vh></v>
<v t="ekr.20090401102247.269"><vh>c.appendStringToBody</vh></v>
<v t="ekr.20090401102247.270"><vh>c.setBodyString</vh></v>
<v t="ekr.20090401102247.271"><vh>setSelectionAreas</vh></v>
<v t="ekr.20090401102247.272"><vh>appendStringToBody &amp; setBodyString (baseScannerClass)</vh></v>
</v>
<v t="ekr.20090401102247.273"><vh>Retain headline changes when expanding/contracting nodes</vh>
<v t="ekr.20090401102247.274"><vh>c.endEditing (calls tree.endEditLabel)</vh></v>
<v t="ekr.20090401102247.275"><vh>c.redrawing...</vh>
<v t="ekr.20090401102247.224"></v>
<v t="ekr.20090401102247.276"><vh>c.redraw_after_contract</vh></v>
<v t="ekr.20090401102247.277"><vh>c.redraw_after_expand</vh></v>
<v t="ekr.20090401102247.278"><vh>c.redraw_after_head_changed</vh></v>
<v t="ekr.20090401102247.279"><vh>c.redraw_afer_icons_changed</vh></v>
<v t="ekr.20090401102247.78"></v>
</v>
<v t="ekr.20090401102247.280"><vh>expandNodeAnd/OrGoToFirstChild</vh></v>
<v t="ekr.20090401102247.281"><vh>expandNode</vh></v>
<v t="ekr.20090401102247.225"></v>
<v t="ekr.20090401102247.71"></v>
</v>
<v t="ekr.20090401102247.282"><vh>Changed to headlines do not stick after clone</vh>
<v t="ekr.20090401102247.274"></v>
<v t="ekr.20090401102247.283"><vh>c.clone</vh></v>
<v t="ekr.20090401102247.224"></v>
<v t="ekr.20090401102247.225"></v>
</v>
<v t="ekr.20090401102247.284"><vh>Fixed hard crasher in minibuffer find</vh>
<v t="ekr.20090401102247.285"><vh>editWidget (minibufferFind)</vh></v>
</v>
<v t="ekr.20090401102247.286"><vh>c.redraw now calls c.endEditing</vh>
<v t="ekr.20090401102247.224"></v>
</v>
<v t="ekr.20090401102247.287"><vh>Fixed headline reversions</vh>
<v t="ekr.20090401102247.288"><vh>Search classes</vh>
<v t="ekr.20090401102247.289"><vh>class minibufferFind( (the findHandler)</vh>
<v t="ekr.20090401102247.290"><vh> ctor (minibufferFind)</vh></v>
<v t="ekr.20090401102247.285"></v>
<v t="ekr.20090401102247.291"><vh> Options (minibufferFind)</vh>
<v t="ekr.20090401102247.292"><vh>setFindScope</vh></v>
<v t="ekr.20090401102247.293"><vh>get/set/toggleOption (minibufferFind)</vh></v>
<v t="ekr.20090401102247.294"><vh>showFindOptions</vh></v>
<v t="ekr.20090401102247.295"><vh>setupChangePattern</vh></v>
<v t="ekr.20090401102247.296"><vh>setupSearchPattern</vh></v>
</v>
<v t="ekr.20090401102247.297"><vh>addChangeStringToLabel</vh></v>
<v t="ekr.20090401102247.298"><vh>addFindStringToLabel</vh></v>
<v t="ekr.20090401102247.299"><vh>changeAll</vh></v>
<v t="ekr.20090401102247.300"><vh>cloneFindAll</vh></v>
<v t="ekr.20090401102247.301"><vh>findAgain</vh></v>
<v t="ekr.20090401102247.302"><vh>findAll</vh></v>
<v t="ekr.20090401102247.303"><vh>generalChangeHelper</vh></v>
<v t="ekr.20090401102247.304"><vh>generalSearchHelper</vh></v>
<v t="ekr.20090401102247.305"><vh>lastStateHelper</vh></v>
<v t="ekr.20090401102247.306"><vh>replaceString</vh></v>
<v t="ekr.20090401102247.307"><vh>reSearchBackward/Forward</vh></v>
<v t="ekr.20090401102247.308"><vh>seachForward/Backward</vh></v>
<v t="ekr.20090401102247.309"><vh>searchWithPresentOptions</vh></v>
<v t="ekr.20090401102247.310"><vh>setupArgs</vh></v>
<v t="ekr.20090401102247.311"><vh>stateZeroHelper</vh></v>
<v t="ekr.20090401102247.312"><vh>updateChange/FindList</vh></v>
<v t="ekr.20090401102247.313"><vh>wordSearchBackward/Forward</vh></v>
</v>
<v t="ekr.20090401102247.314"><vh>class searchCommandsClass</vh>
<v t="ekr.20090401102247.315"><vh> ctor (searchCommandsClass)</vh></v>
<v t="ekr.20090401102247.316"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20090401102247.317"><vh>Top-level methods</vh>
<v t="ekr.20090401102247.318"><vh>openFindTab</vh></v>
<v t="ekr.20090401102247.319"><vh>Find Tab commands</vh></v>
<v t="ekr.20090401102247.320"><vh>getHandler</vh></v>
<v t="ekr.20090401102247.321"><vh>Find options wrappers</vh></v>
<v t="ekr.20090401102247.322"><vh>Find wrappers</vh></v>
<v t="ekr.20090401102247.323"><vh>findAgain</vh></v>
</v>
<v t="ekr.20090401102247.324"><vh>incremental search...</vh>
<v t="ekr.20090401102247.325"><vh>abortSearch</vh></v>
<v t="ekr.20090401102247.326"><vh>endSearch</vh></v>
<v t="ekr.20090401102247.327"><vh>iSearch</vh></v>
<v t="ekr.20090401102247.328"><vh>iSearchStateHandler</vh></v>
<v t="ekr.20090401102247.329"><vh>iSearchBackspace</vh></v>
<v t="ekr.20090401102247.330"><vh>getStrokes</vh></v>
<v t="ekr.20090401102247.331"><vh>push &amp; pop</vh></v>
<v t="ekr.20090401102247.332"><vh>setWidget</vh></v>
<v t="ekr.20090401102247.333"><vh>startIncremental</vh></v>
</v>
</v>
</v>
<v t="ekr.20090401102247.309"></v>
<v t="ekr.20090401102247.334"><vh>getArg</vh>
<v t="ekr.20090401102247.335"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.274"></v>
<v t="ekr.20090401102247.252"></v>
</v>
<v t="ekr.20090401102247.336"><vh>Fixed (?) body corruption</vh>
<v t="ekr.20090401102247.71"></v>
<v t="ekr.20090401102247.78"></v>
</v>
<v t="ekr.20090401102247.337"><vh>Fixed cut/paste outline bug</vh>
<v t="ekr.20090401102247.338"><vh>pasteOutline</vh>
<v t="ekr.20090401102247.339"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20090401102247.340"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20090401102247.341"><vh>Fixed Mark Edgington's @shadow bug</vh>
<v t="ekr.20090401102247.342"><vh>&lt;&lt; define global data structures &gt;&gt; (leoApp.py)</vh></v>
<v t="ekr.20090401102247.90"></v>
</v>
<v t="ekr.20090401102247.343"><vh>Don't scroll when expanding/contracting node.</vh>
<v t="ekr.20090401102247.344"><vh>selectVisBack</vh></v>
<v t="ekr.20090401102247.345"><vh>selectVisNext</vh></v>
<v t="ekr.20090401102247.71"></v>
</v>
<v t="ekr.20090401102247.346"><vh>Go to parent was causing a full redraw!</vh>
<v t="ekr.20090401102247.347"><vh>goToParent</vh></v>
<v t="ekr.20090401102247.348"><vh> treeSelectHelper</vh></v>
</v>
<v t="ekr.20090401102247.349"><vh>minimized calls to setAllText</vh>
<v t="ekr.20090401102247.350"><vh>class baseTextWidget</vh>
<v t="ekr.20090401102247.351"><vh>Birth &amp; special methods (baseText)</vh>
<v t="ekr.20090401102247.352"><vh>baseTextWidget: must be defined in base class</vh></v>
<v t="ekr.20090401102247.353"><vh>baseTextWidget: must be defined in subclasses</vh></v>
<v t="ekr.20090401102247.354"><vh>baseTextWidget: mustBeDefined</vh></v>
</v>
<v t="ekr.20090401102247.355"><vh>must be defined in base class</vh>
<v t="ekr.20090401102247.356"><vh>onChar</vh></v>
<v t="ekr.20090401102247.357"><vh>clipboard_clear &amp; clipboard_append</vh></v>
</v>
<v t="ekr.20090401102247.358"><vh>May be defined in subclasses</vh>
<v t="ekr.20090401102247.359"><vh> do-nothings</vh></v>
<v t="ekr.20090401102247.360"><vh>toPythonIndexToRowCol (baseText) (may be overridden)</vh></v>
<v t="ekr.20090401102247.361"><vh>delete</vh></v>
<v t="ekr.20090401102247.362"><vh>deleteTextSelection</vh></v>
<v t="ekr.20090401102247.363"><vh>event_generate (baseTextWidget)</vh></v>
<v t="ekr.20090401102247.364"><vh>getName &amp; GetName</vh></v>
<v t="ekr.20090401102247.365"><vh>hasSelection</vh></v>
<v t="ekr.20090401102247.366"><vh>oops</vh></v>
<v t="ekr.20090401102247.367"><vh>replace</vh></v>
<v t="ekr.20090401102247.368"><vh>selectAllText</vh></v>
<v t="ekr.20090401102247.369"><vh>w.rowColToGuiIndex</vh></v>
<v t="ekr.20090401102247.370"><vh>w.toGuiIndex &amp; toPythonIndex</vh></v>
</v>
<v t="ekr.20090401102247.371"><vh>Must be defined in subclasses (low-level interface)</vh></v>
<v t="ekr.20090401102247.372"><vh>Must be defined in subclasses (high-level interface)</vh>
<v t="ekr.20090401102247.373"><vh>appendText</vh></v>
<v t="ekr.20090401102247.374"><vh>get</vh></v>
<v t="ekr.20090401102247.375"><vh>getAllText</vh></v>
<v t="ekr.20090401102247.376"><vh>getFocus</vh></v>
<v t="ekr.20090401102247.377"><vh>getInsertPoint</vh></v>
<v t="ekr.20090401102247.378"><vh>getSelectedText</vh></v>
<v t="ekr.20090401102247.379"><vh>getSelectionRange</vh></v>
<v t="ekr.20090401102247.380"><vh>getYScrollPosition</vh></v>
<v t="ekr.20090401102247.381"><vh>insert</vh></v>
<v t="ekr.20090401102247.382"><vh>scrollLines</vh></v>
<v t="ekr.20090401102247.383"><vh>see &amp; seeInsertPoint</vh></v>
<v t="ekr.20090401102247.384"><vh>setAllText</vh></v>
<v t="ekr.20090401102247.385"><vh>setBackgroundColor</vh></v>
<v t="ekr.20090401102247.386"><vh>setFocus</vh></v>
<v t="ekr.20090401102247.387"><vh>setForegroundColor</vh></v>
<v t="ekr.20090401102247.388"><vh>setInsertPoint</vh></v>
<v t="ekr.20090401102247.389"><vh>setSelectionRange</vh></v>
<v t="ekr.20090401102247.390"><vh>setYScrollPosition</vh></v>
</v>
</v>
<v t="ekr.20090401102247.391"><vh>masterKeyHandler &amp; helpers</vh>
<v t="ekr.20090401102247.392"><vh>&lt;&lt; define vars &gt;&gt;</vh></v>
<v t="ekr.20090401102247.393"><vh>&lt;&lt; handle mode bindings &gt;&gt;</vh></v>
<v t="ekr.20090401102247.394"><vh>&lt;&lt; handle special cases for plain keys &gt;&gt;</vh></v>
<v t="ekr.20090401102247.395"><vh>&lt;&lt; handle per-pane bindings &gt;&gt;</vh></v>
<v t="ekr.20090401102247.396"><vh>callStateFunction</vh></v>
<v t="ekr.20090401102247.397"><vh>handleMiniBindings</vh></v>
<v t="ekr.20090401102247.398"><vh>k.handleUnboudKeys</vh></v>
</v>
</v>
<v t="ekr.20090401102247.399"><vh>Multiple recolors</vh>
<v t="ekr.20090401102247.78"></v>
<v t="ekr.20090401102247.348"></v>
<v t="ekr.20090401102247.344"></v>
<v t="ekr.20090401102247.345"></v>
</v>
<v t="ekr.20090401102247.400"><vh>Don't call recolor if hasattr fails</vh></v>
<v t="ekr.20090401102247.401"><vh>Fixed problems with dirty bits</vh>
<v t="ekr.20090401102247.402"><vh>c.insertHeadline</vh></v>
<v t="ekr.20090401102247.403"><vh>writeAtFileNodes</vh></v>
<v t="ekr.20090401102247.404"><vh>writeAll (atFile)</vh>
<v t="ekr.20090401102247.405"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="ekr.20090401102247.406"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="ekr.20090401102247.407"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.408"><vh>replaceTargetFileIfDifferent &amp; helper</vh>
<v t="ekr.20090401102247.409"><vh>&lt;&lt; report if the files differ only in line endings &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.410"><vh>p.Dirty bits</vh>
<v t="ekr.20090401102247.411"><vh>p.clearDirty</vh></v>
<v t="ekr.20090401102247.412"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20090401102247.413"><vh>p.inAtIgnoreRange</vh></v>
<v t="ekr.20090401102247.414"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20090401102247.415"><vh>p.setDirty</vh></v>
</v>
<v t="ekr.20090401102247.416"><vh>onBodyChanged (leoBody)</vh>
<v t="ekr.20090401102247.417"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20090401102247.418"><vh>&lt;&lt; update icons if necessary &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20090401102247.419"><vh>Fixed bug: Ctrl-s destroys headline selection</vh>
<v t="ekr.20090401102247.420"><vh>save (commands)</vh></v>
<v t="ekr.20090401102247.421"><vh>save (fileCommands)</vh></v>
<v t="ekr.20090401102247.274"></v>
<v t="ekr.20090401102247.275"></v>
<v t="ekr.20090401102247.422"><vh>c.outerUpdate</vh></v>
</v>
<v t="ekr.20090401102247.423"><vh>Fixed isearch with tk</vh>
<v t="ekr.20090401102247.324"></v>
<v t="ekr.20090401102247.333"></v>
<v t="ekr.20090401102247.328"></v>
<v t="ekr.20090401102247.424"><vh>setLabel</vh></v>
<v t="ekr.20090401102247.425"><vh>showStateAndMode</vh></v>
<v t="ekr.20090401102247.329"></v>
</v>
<v t="ekr.20090401102247.426"><vh>Fixed clone-find-all in qt plugin</vh>
<v t="ekr.20090401102247.427"><vh>findAll</vh>
<v t="ekr.20090401102247.428"><vh>&lt;&lt; create the found node &gt;&gt;</vh></v>
<v t="ekr.20090401102247.429"><vh>&lt;&lt; create a clone of p under the find node &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.430"><vh>cc.createChaptersNode</vh></v>
<v t="ekr.20090401102247.431"><vh>moveOutlineUp</vh>
<v t="ekr.20090401102247.432"><vh>&lt;&lt; Move p up &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.71"></v>
</v>
<v t="ekr.20090401102247.433"><vh>Fixed redraw_after_select bug</vh>
<v t="ekr.20090401102247.434"><vh>c.executeScript &amp; helpers</vh>
<v t="ekr.20090401102247.435"><vh>redirectScriptOutput</vh></v>
<v t="ekr.20090401102247.436"><vh>unredirectScriptOutput</vh></v>
<v t="ekr.20090401102247.437"><vh>writeScriptFile</vh></v>
</v>
<v t="ekr.20090401102247.172"></v>
<v t="ekr.20090401102247.224"></v>
<v t="ekr.20090401102247.77"></v>
<v t="ekr.20090401102247.438"><vh>cc.selectChapterForPosition</vh></v>
<v t="ekr.20090401102247.439"><vh>cc.selectChapterByName &amp; helper</vh>
<v t="ekr.20090401102247.440"><vh>selectChapterHelper</vh></v>
</v>
<v t="ekr.20090401102247.225"></v>
<v t="ekr.20090401102247.78"></v>
<v t="ekr.20090401102247.422"></v>
<v t="ekr.20090401102247.71"></v>
</v>
<v t="ekr.20090401102247.441"><vh>Fixed whitespace problems with @auto/@shadow</vh>
<v t="ekr.20090401102247.442"><vh> Report</vh></v>
<v t="ekr.20090401102247.443"><vh>From kdiff</vh></v>
<v t="ekr.20090401102247.210"></v>
<v t="ekr.20090401102247.444"><vh>writeOneAtAutoNode &amp; helper</vh>
<v t="ekr.20090401102247.445"><vh>shouldWriteAtAutoNode</vh></v>
</v>
<v t="ekr.20090401102247.446"><vh>writeOneAtShadowNode &amp; helpers</vh>
<v t="ekr.20090401102247.447"><vh>shouldWriteAtShadowNode</vh></v>
<v t="ekr.20090401102247.448"><vh>adjustTargetLanguage</vh></v>
</v>
<v t="ekr.20090401102247.449"><vh>openFileForWriting &amp; openFileForWritingHelper</vh>
<v t="ekr.20090401102247.450"><vh>openFileForWritingHelper &amp; helper</vh>
<v t="ekr.20090401102247.451"><vh>openForWrite (atFile)</vh></v>
</v>
</v>
<v t="ekr.20090401102247.452"><vh>writeOpenFile</vh></v>
<v t="ekr.20090401102247.453"><vh>Writing 4.x</vh>
<v t="ekr.20090401102247.454"><vh>putBody</vh>
<v t="ekr.20090401102247.455"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20090401102247.456"><vh>&lt;&lt; handle line at s[i]  &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.457"><vh>writing code lines...</vh>
<v t="ekr.20090401102247.458"><vh>@all</vh>
<v t="ekr.20090401102247.459"><vh>putAtAllLine</vh></v>
<v t="ekr.20090401102247.460"><vh>putatAllBody</vh>
<v t="ekr.20090401102247.461"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.462"><vh>putAtAllChild</vh></v>
</v>
<v t="ekr.20090401102247.463"><vh>@others</vh>
<v t="ekr.20090401102247.464"><vh>inAtOthers</vh></v>
<v t="ekr.20090401102247.465"><vh>putAtOthersChild</vh></v>
<v t="ekr.20090401102247.466"><vh>putAtOthersLine</vh></v>
</v>
<v t="ekr.20090401102247.467"><vh>putCodeLine (leoAtFile)</vh></v>
<v t="ekr.20090401102247.468"><vh>putRefLine &amp; allies</vh>
<v t="ekr.20090401102247.469"><vh>putRefLine</vh></v>
<v t="ekr.20090401102247.470"><vh>putRefAt</vh></v>
<v t="ekr.20090401102247.471"><vh>putAfterLastRef</vh></v>
<v t="ekr.20090401102247.472"><vh>putAfterMiddleef</vh></v>
</v>
</v>
<v t="ekr.20090401102247.473"><vh>writing doc lines...</vh>
<v t="ekr.20090401102247.474"><vh>putBlankDocLine</vh></v>
<v t="ekr.20090401102247.475"><vh>putStartDocLine</vh></v>
<v t="ekr.20090401102247.476"><vh>putDocLine</vh>
<v t="ekr.20090401102247.477"><vh>&lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.478"><vh>putEndDocLine</vh></v>
<v t="ekr.20090401102247.479"><vh>putPending</vh></v>
</v>
</v>
<v t="ekr.20090401102247.480"><vh>underindentEscapeString</vh>
<v t="ekr.20090401102247.481"><vh>in leoAtFile</vh>
<v t="ekr.20090401102247.219"></v>
<v t="ekr.20090401102247.220"></v>
<v t="ekr.20090401102247.221"></v>
</v>
<v t="ekr.20090401102247.482"><vh>In leoImport</vh>
<v t="ekr.20090401102247.483"><vh>putClass &amp; helpers</vh>
<v t="ekr.20090401102247.484"><vh>appendTextToClassNode</vh></v>
<v t="ekr.20090401102247.485"><vh>createClassNodePrefix</vh></v>
<v t="ekr.20090401102247.486"><vh>getClassNodeRef</vh></v>
<v t="ekr.20090401102247.487"><vh>putClassHelper</vh></v>
</v>
<v t="ekr.20090401102247.488"><vh>undentBody</vh></v>
<v t="ekr.20090401102247.489"><vh>undentBy</vh></v>
</v>
</v>
</v>
<v t="ekr.20090401102247.490"><vh>Fixed headline reversion problem</vh>
<v t="ekr.20090401102247.402"></v>
</v>
<v t="ekr.20090401102247.491"><vh>Fixed autocompletion problems with qt gui</vh>
<v t="ekr.20090401102247.492"><vh>autoCompleterStateHandler</vh></v>
</v>
<v t="ekr.20090401102247.493"><vh>Removed call to getAllText from setMoveCol</vh>
<v t="ekr.20090401102247.494"><vh>g.convertPythonIndexToRowCol</vh></v>
<v t="ekr.20090401102247.187"></v>
<v t="ekr.20090401102247.360"></v>
</v>
<v t="ekr.20090401102247.495"><vh>Fixed undo problems with qt gui</vh></v>
<v t="ekr.20090401102247.496"><vh>Investigated reported @shadow bug</vh></v>
<v t="ekr.20090401102247.497"><vh>Opening non-existent file now draws the outline properly</vh></v>
</v>
<v t="ekr.20090401102247.498"><vh>Documentation</vh>
<v t="ekr.20090401102247.499"><vh>Added getInput example to Leo's docs</vh></v>
<v t="ekr.20090401102247.500"><vh>Drive Leo's autocompleter from a list</vh>
<v t="ekr.20090401102247.501"><vh>class autoCompleterClass</vh>
<v t="ekr.20090401102247.502"><vh> ctor (autocompleter)</vh>
<v t="ekr.20090401102247.503"><vh>defineClassesDict</vh></v>
<v t="ekr.20090401102247.504"><vh>defineObjectDict</vh></v>
</v>
<v t="ekr.20090401102247.505"><vh>Top level</vh>
<v t="ekr.20090401102247.506"><vh>autoComplete</vh></v>
<v t="ekr.20090401102247.507"><vh>autoCompleteForce</vh></v>
<v t="ekr.20090401102247.492"></v>
<v t="ekr.20090401102247.508"><vh>getExternalCompletions</vh></v>
<v t="ekr.20090401102247.509"><vh>enable/disable/toggleAutocompleter/Calltips</vh></v>
<v t="ekr.20090401102247.510"><vh>showCalltips</vh></v>
<v t="ekr.20090401102247.511"><vh>showCalltipsForce</vh></v>
<v t="ekr.20090401102247.512"><vh>showAutocompleter/CalltipsStatus</vh></v>
</v>
<v t="ekr.20090401102247.513"><vh>Helpers</vh>
<v t="ekr.20090401102247.514"><vh>.abort &amp; exit (autocompleter) (test)</vh></v>
<v t="ekr.20090401102247.515"><vh>append/begin/popTabName</vh></v>
<v t="ekr.20090401102247.516"><vh>appendToKnownObjects</vh></v>
<v t="ekr.20090401102247.517"><vh>calltip</vh>
<v t="ekr.20090401102247.518"><vh>&lt;&lt; try to set s from a Python global function &gt;&gt;</vh></v>
<v t="ekr.20090401102247.519"><vh>&lt;&lt; get s using inspect &gt;&gt;</vh></v>
<v t="ekr.20090401102247.520"><vh>&lt;&lt; remove 'self' from s, but not from args &gt;&gt;</vh></v>
<v t="ekr.20090401102247.521"><vh>&lt;&lt; remove 's' from s *and* args &gt;&gt;</vh></v>
<v t="ekr.20090401102247.522"><vh>&lt;&lt; insert the text and set j1 and j2 &gt;&gt;</vh></v>
<v t="ekr.20090401102247.523"><vh>&lt;&lt; put the status line &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.524"><vh>chain</vh></v>
<v t="ekr.20090401102247.206"></v>
<v t="ekr.20090401102247.525"><vh>doBackSpace (autocompleter)</vh></v>
<v t="ekr.20090401102247.526"><vh>doTabCompletion (autocompleter)</vh></v>
<v t="ekr.20090401102247.527"><vh>extendSelection</vh></v>
<v t="ekr.20090401102247.528"><vh>findCalltipWord</vh></v>
<v t="ekr.20090401102247.529"><vh>findAnchor</vh></v>
<v t="ekr.20090401102247.530"><vh>finish</vh></v>
<v t="ekr.20090401102247.531"><vh>getAttr and hasAttr</vh></v>
<v t="ekr.20090401102247.532"><vh>getLeadinWord</vh></v>
<v t="ekr.20090401102247.533"><vh>getMembersList</vh></v>
<v t="ekr.20090401102247.534"><vh>info</vh></v>
<v t="ekr.20090401102247.535"><vh>insertNormalChar</vh></v>
<v t="ekr.20090401102247.536"><vh>push, pop, clear, stackNames</vh></v>
<v t="ekr.20090401102247.537"><vh>setObjectAndMembersList &amp; helpers</vh>
<v t="ekr.20090401102247.538"><vh>getObjectFromAttribute</vh></v>
<v t="ekr.20090401102247.539"><vh>completeSelf</vh></v>
<v t="ekr.20090401102247.540"><vh>completeFromObject</vh></v>
</v>
<v t="ekr.20090401102247.541"><vh>setSelection</vh></v>
<v t="ekr.20090401102247.542"><vh>start</vh></v>
</v>
<v t="ekr.20090401102247.543"><vh>Scanning (not used)</vh>
<v t="ekr.20090401102247.544"><vh>initialScan</vh></v>
<v t="ekr.20090401102247.545"><vh>scan</vh></v>
<v t="ekr.20090401102247.546"><vh>definePatterns</vh></v>
<v t="ekr.20090401102247.547"><vh>scanOutline</vh></v>
<v t="ekr.20090401102247.548"><vh>scanForCallTip</vh></v>
<v t="ekr.20090401102247.549"><vh>scanForAutoCompleter</vh>
<v t="ekr.20090401102247.550"><vh>makeAutocompletionList</vh>
<v t="ekr.20090401102247.551"><vh>reverseFindWhitespace</vh></v>
<v t="ekr.20090401102247.552"><vh>getCleanString</vh></v>
</v>
</v>
</v>
<v t="ekr.20090401102247.553"><vh>Proxy classes and objects</vh>
<v t="ekr.20090401102247.554"><vh>createProxyObjectFromClass</vh></v>
<v t="ekr.20090401102247.555"><vh>createClassObjectFromString</vh></v>
</v>
<v t="ekr.20090401102247.556"><vh>class forgivingParserClass</vh>
<v t="ekr.20090401102247.557"><vh>ctor (forgivingParserClass)</vh></v>
<v t="ekr.20090401102247.558"><vh>parse</vh></v>
<v t="ekr.20090401102247.559"><vh>forgivingParser</vh></v>
<v t="ekr.20090401102247.560"><vh>computeErrorNode</vh></v>
<v t="ekr.20090401102247.561"><vh>newPutBody</vh></v>
</v>
<v t="ekr.20090401102247.562"><vh>class classScannerClass</vh>
<v t="ekr.20090401102247.563"><vh>ctor</vh></v>
<v t="ekr.20090401102247.564"><vh>scan</vh></v>
<v t="ekr.20090401102247.565"><vh>findParentClass</vh></v>
<v t="ekr.20090401102247.566"><vh>findClass &amp; helpers</vh>
<v t="ekr.20090401102247.567"><vh>endsDoc</vh></v>
<v t="ekr.20090401102247.568"><vh>startsClass</vh></v>
<v t="ekr.20090401102247.569"><vh>startsDoc</vh></v>
</v>
</v>
</v>
<v t="ekr.20090401102247.542"></v>
<v t="ekr.20090401102247.492"></v>
<v t="ekr.20090401102247.206"></v>
</v>
<v t="ekr.20090401102247.570"><vh>Added warning about running test unitTest.leo when it is opened from another .leo file</vh></v>
<v t="ekr.20090401102247.571"><vh>Documented the high-level api for text wrappers</vh></v>
</v>
<v t="ekr.20090401102247.572"><vh>Leo3k work</vh>
<v t="ekr.20090401102247.573"><vh>Fixed hangs in Leo3k</vh>
<v t="ekr.20090401102247.574"><vh>leoConfig</vh>
<v t="ekr.20090401102247.575"><vh>doMenus &amp; helpers (ParserBaseClass)</vh>
<v t="ekr.20090401102247.576"><vh>doItems</vh></v>
<v t="ekr.20090401102247.577"><vh>dumpMenuList</vh></v>
</v>
<v t="ekr.20090401102247.576"></v>
<v t="ekr.20090401102247.578"><vh>traverse (parserBaseClass)</vh></v>
<v t="ekr.20090401102247.579"><vh>g.app.config.readSettingsFiles &amp; helpers</vh>
<v t="ekr.20090401102247.580"><vh>&lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;</vh></v>
<v t="ekr.20090401102247.581"><vh>g.app.config.createMyLeoSettingsFile (not used)</vh>
<v t="ekr.20090401102247.582"><vh>&lt;&lt; define s, a minimalMyLeoSettings.leo string &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.583"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20090401102247.584"><vh>g.app.config.updateSettings</vh></v>
</v>
<v t="ekr.20090401102247.585"><vh>g.app.config.readSettings</vh></v>
</v>
<v t="ekr.20090401102247.586"><vh>leoFileCommands</vh>
<v t="ekr.20090401102247.587"><vh>parse_leo_file</vh></v>
</v>
<v t="ekr.20090401102247.588"><vh>leoPlugins</vh>
<v t="ekr.20090401102247.589"><vh>doPlugins</vh></v>
</v>
<v t="ekr.20090401102247.590"><vh>runLeo</vh>
<v t="ekr.20090401102247.591"><vh>run &amp; helpers</vh>
<v t="ekr.20090401102247.592"><vh>adjustSysPath</vh></v>
<v t="ekr.20090401102247.593"><vh>createFrame (runLeo.py)</vh></v>
<v t="ekr.20090401102247.594"><vh>createSpecialGui &amp; helper</vh>
<v t="ekr.20090401102247.595"><vh>createNullGuiWithScript</vh></v>
</v>
<v t="ekr.20090401102247.596"><vh>finishInitApp</vh></v>
<v t="ekr.20090401102247.138"></v>
<v t="ekr.20090401102247.597"><vh>initApp</vh></v>
<v t="ekr.20090401102247.598"><vh>initFocusAndDraw</vh></v>
<v t="ekr.20090401102247.599"><vh>isValidPython</vh>
<v t="ekr.20090401102247.600"><vh>&lt;&lt; define emergency dialog class &gt;&gt;</vh>
<v t="ekr.20090401102247.601"><vh>__init__ (emergencyDialog)</vh></v>
<v t="ekr.20090401102247.602"><vh>createButtons</vh></v>
<v t="ekr.20090401102247.603"><vh>createTopFrame</vh></v>
<v t="ekr.20090401102247.604"><vh>okButton</vh></v>
<v t="ekr.20090401102247.605"><vh>onKey</vh></v>
<v t="ekr.20090401102247.606"><vh>run</vh></v>
</v>
</v>
<v t="ekr.20090401102247.607"><vh>profile_leo</vh></v>
<v t="ekr.20090401102247.608"><vh>reportDirectories</vh></v>
<v t="ekr.20090401102247.609"><vh>scanOptions</vh></v>
<v t="ekr.20090401102247.610"><vh>startPsyco</vh></v>
</v>
</v>
<v t="ekr.20090401102247.611"><vh>Major short circuits</vh>
<v t="ekr.20090401102247.579"></v>
<v t="ekr.20090401102247.585"></v>
<v t="ekr.20090401102247.589"></v>
<v t="ekr.20090401102247.591"></v>
</v>
<v t="ekr.20090401102247.612"><vh>Problems opening .leo files</vh>
<v t="ekr.20090401102247.587"></v>
<v t="ekr.20090401102247.613"><vh>g.openLeoOrZipFile</vh></v>
</v>
<v t="ekr.20090401102247.614"><vh>Problems reading derived files</vh>
<v t="ekr.20090401102247.615"><vh>closeWriteFile</vh></v>
<v t="ekr.20090401102247.219"></v>
<v t="ekr.20090401102247.616"><vh>g.fileLikeObject</vh>
<v t="ekr.20090401102247.617"><vh> ctor</vh></v>
<v t="ekr.20090401102247.618"><vh>clear</vh></v>
<v t="ekr.20090401102247.619"><vh>close</vh></v>
<v t="ekr.20090401102247.620"><vh>flush</vh></v>
<v t="ekr.20090401102247.621"><vh>get &amp; getvalue &amp; read</vh></v>
<v t="ekr.20090401102247.622"><vh>readline</vh></v>
<v t="ekr.20090401102247.623"><vh>write</vh></v>
</v>
</v>
<v t="ekr.20090401102247.624"><vh>Unicode problems</vh>
<v t="ekr.20090401102247.625"><vh>g.isBytes, isChar, isString &amp; isUnicode</vh></v>
<v t="ekr.20090401102247.626"><vh>g.toEncodedString</vh></v>
<v t="ekr.20090401102247.627"><vh>g.toUnicode</vh></v>
<v t="ekr.20090401102247.628"><vh>g.trace</vh></v>
<v t="ekr.20090401102247.629"><vh>g.pr</vh></v>
</v>
<v t="ekr.20090401102247.630"><vh>Unbounded loops</vh>
<v t="ekr.20090401102247.631"><vh> p.ctor &amp; other special methods...</vh>
<v t="ekr.20090401102247.632"><vh> p.__init__</vh></v>
<v t="ekr.20090401102247.633"><vh>p.__eq__ &amp; __ne__</vh></v>
<v t="ekr.20090401102247.634"><vh>p.__getattr__  ON:  must be ON if use_plugins</vh></v>
<v t="ekr.20090401102247.635"><vh>p.__nonzero__ &amp; __bool__</vh></v>
<v t="ekr.20090401102247.636"><vh>p.__str__ and p.__repr__</vh></v>
<v t="ekr.20090401102247.637"><vh>p.archivedPosition</vh></v>
<v t="ekr.20090401102247.638"><vh>p.copy</vh></v>
<v t="ekr.20090401102247.639"><vh>p.dump &amp; p.vnodeListIds</vh></v>
<v t="ekr.20090401102247.640"><vh>p.key</vh></v>
</v>
<v t="ekr.20090401102247.575"></v>
</v>
</v>
</v>
<v t="ekr.20090401102247.641"><vh>New features</vh>
<v t="ekr.20090401102247.642"><vh>Improved @path handling</vh>
<v t="ekr.20090401102247.643"><vh>Done</vh>
<v t="ekr.20090401102247.644"><vh>Cumulative @path directives</vh></v>
</v>
<v t="ekr.20090401102247.645"><vh>Replaced g.os_path.abspath with g.os_path_finalize/_join</vh>
<v t="ekr.20090401102247.646"><vh>os_path_expanduser</vh></v>
<v t="ekr.20090401102247.216"></v>
<v t="ekr.20090401102247.647"><vh>os_path_join</vh></v>
</v>
<v t="ekr.20090401102247.648"><vh>Make sure '~' is handled properly in all contexts: add unit tests</vh></v>
<v t="ekr.20090401102247.649"><vh>Added support for {{exp}}</vh>
<v t="ekr.20090401102247.650"><vh>Made {{exp}} work in @path</vh>
<v t="ekr.20090401102247.651"><vh>os.path wrappers (leoGlobals.py)</vh>
<v t="ekr.20090401102247.652"><vh>os_path_abspath</vh></v>
<v t="ekr.20090401102247.653"><vh>os_path_basename</vh></v>
<v t="ekr.20090401102247.654"><vh>os_path_dirname</vh></v>
<v t="ekr.20090401102247.655"><vh>os_path_exists</vh></v>
<v t="ekr.20090401102247.217"></v>
<v t="ekr.20090401102247.646"></v>
<v t="ekr.20090401102247.216"></v>
<v t="ekr.20090401102247.656"><vh>os_path_getmtime</vh></v>
<v t="ekr.20090401102247.657"><vh>os_path_getsize</vh></v>
<v t="ekr.20090401102247.658"><vh>os_path_isabs</vh></v>
<v t="ekr.20090401102247.659"><vh>os_path_isdir</vh></v>
<v t="ekr.20090401102247.660"><vh>os_path_isfile</vh></v>
<v t="ekr.20090401102247.647"></v>
<v t="ekr.20090401102247.661"><vh>os_path_normcase</vh></v>
<v t="ekr.20090401102247.662"><vh>os_path_normpath</vh></v>
<v t="ekr.20090401102247.663"><vh>os_path_realpath</vh></v>
<v t="ekr.20090401102247.664"><vh>os_path_split</vh></v>
<v t="ekr.20090401102247.665"><vh>os_path_splitext</vh></v>
<v t="ekr.20090401102247.666"><vh>toUnicodeFileEncoding</vh></v>
</v>
<v t="ekr.20090401102247.145"></v>
<v t="ekr.20090401102247.215"></v>
<v t="ekr.20090401102247.102"></v>
<v t="ekr.20090401102247.141" a="E"></v>
<v t="ekr.20090401102247.34"></v>
<v t="ekr.20090401102247.105"></v>
<v t="ekr.20090401102247.216"></v>
<v t="ekr.20090401102247.647"></v>
<v t="ekr.20090401102247.667"><vh>readOneAtShadowNode (atFile) &amp; helper</vh>
<v t="ekr.20090401102247.668"><vh>importAtShadowNode</vh></v>
</v>
</v>
</v>
<v t="ekr.20090401102247.669"><vh>Finished at-path branch items</vh>
<v t="ekr.20090401102247.670"><vh>c.Directive scanning</vh>
<v t="ekr.20090401102247.104"></v>
<v t="ekr.20090401102247.102"></v>
<v t="ekr.20090401102247.671"><vh>c.scanAtRootDirectives</vh></v>
<v t="ekr.20090401102247.215"></v>
<v t="ekr.20090401102247.672"><vh>c.getNodePath &amp; c.getNodeFileName</vh></v>
</v>
<v t="ekr.20090401102247.32"></v>
<v t="ekr.20090401102247.673"><vh>Rewrote</vh>
<v t="ekr.20090401102247.674"><vh>scanColorDirectives (leoColor)</vh></v>
<v t="ekr.20090401102247.212"></v>
<v t="ekr.20090401102247.31"></v>
<v t="ekr.20090401102247.675"><vh>tangle.scanAllDirectives</vh>
<v t="ekr.20090401102247.676"><vh>&lt;&lt; Collect @first attributes &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20090401102247.677"><vh>Merge leo-30 branch</vh></v>
<v t="ekr.20090401102247.678"><vh>Open a default .leo file if no other is specified</vh>
<v t="ekr.20090401102247.679"><vh> Request</vh></v>
<v t="ekr.20090401102247.680"><vh>Refactoring runLeo.run</vh>
<v t="ekr.20090401102247.594"></v>
<v t="ekr.20090401102247.681"><vh>doEarlyInits</vh></v>
<v t="ekr.20090401102247.596"></v>
<v t="ekr.20090401102247.138"></v>
<v t="ekr.20090401102247.598"></v>
<v t="ekr.20090401102247.591"></v>
<v t="ekr.20090401102247.609"></v>
</v>
<v t="ekr.20090401102247.682"><vh>Support for @string default_leo_file = ~/.leo/workbook.leo</vh>
<v t="ekr.20090401102247.646"></v>
<v t="ekr.20090401102247.613"></v>
<v t="ekr.20090401102247.683"><vh>g.openWithFileName</vh></v>
<v t="ekr.20090401102247.593"></v>
</v>
</v>
<v t="ekr.20090401102247.684"><vh>Added better default fonts for Leo on Linux</vh>
<v t="ekr.20090401102247.685"><vh>Fonts</vh>
<v t="ekr.20090401102247.686"><vh>@font body text font</vh></v>
<v t="ekr.20090401102247.687"><vh>@font button font</vh></v>
<v t="ekr.20090401102247.688"><vh>@font log font</vh></v>
<v t="ekr.20090401102247.689"><vh>@font menu text font</vh></v>
<v t="ekr.20090401102247.690"><vh>@font outline font</vh></v>
</v>
</v>
<v t="ekr.20090401102247.691"><vh>Enter tree pane after clone-find-all</vh></v>
<v t="ekr.20090401102247.692"><vh>Added autoCompleter.getExternalCompletions</vh>
<v t="ekr.20090401102247.501"></v>
<v t="ekr.20090401102247.502"></v>
<v t="ekr.20090401102247.542"></v>
<v t="ekr.20090401102247.532"></v>
<v t="ekr.20090401102247.529"></v>
<v t="ekr.20090401102247.206"></v>
<v t="ekr.20090401102247.508"></v>
</v>
<v t="ekr.20090401102247.693"><vh>Added @nocolor-node directive</vh>
<v t="ekr.20090401102247.694"><vh>useSyntaxColoring</vh></v>
<v t="ekr.20090401102247.30"></v>
<v t="ekr.20090401102247.695"><vh>skip_id</vh></v>
<v t="ekr.20090401102247.40"></v>
<v t="ekr.20090401102247.696"><vh>Failed unit test</vh>
<v t="ekr.20090401102247.697"><vh>match_word</vh></v>
<v t="ekr.20090401102247.671"></v>
</v>
</v>
<v t="ekr.20090401102247.698"><vh>Added c.getNodePath and c.getNodeFileName</vh>
<v t="ekr.20090401102247.672"></v>
</v>
<v t="ekr.20090401102247.699"><vh>Added support for meta keys</vh></v>
<v t="ekr.20090401102247.700"><vh>Better plugin info</vh>
<v t="ekr.20090401102247.701"><vh>loadOnePlugin</vh></v>
<v t="ekr.20090401102247.702"><vh>print plugins info...</vh></v>
<v t="ekr.20090401102247.703"><vh>printPluginsInfo</vh></v>
<v t="ekr.20090401102247.704"><vh>printHandlers</vh></v>
<v t="ekr.20090401102247.705"><vh>printPlugins</vh></v>
<v t="ekr.20090401102247.434"></v>
</v>
<v t="ekr.20090401102247.706"><vh>Added smart home (back-to-home) command</vh>
<v t="ekr.20090401102247.188"></v>
</v>
<v t="ekr.20090401102247.707"><vh>Added escapes for underindented lines</vh>
<v t="ekr.20090401102247.708"><vh>Whitespace...</vh>
<v t="ekr.20090401102247.709"><vh>g.adjustTripleString (same as removeExtraLws)</vh></v>
<v t="ekr.20090401102247.710"><vh>computeLeadingWhitespace</vh></v>
<v t="ekr.20090401102247.711"><vh>computeWidth</vh></v>
<v t="ekr.20090401102247.712"><vh>get_leading_ws</vh></v>
<v t="ekr.20090401102247.713"><vh>optimizeLeadingWhitespace</vh></v>
<v t="ekr.20090401102247.714"><vh>regularizeTrailingNewlines</vh></v>
<v t="ekr.20090401102247.715"><vh>removeLeadingWhitespace</vh></v>
<v t="ekr.20090401102247.716"><vh>g.removeExtraLws</vh></v>
<v t="ekr.20090401102247.717"><vh>removeTrailingWs</vh></v>
<v t="ekr.20090401102247.718"><vh>skip_leading_ws</vh></v>
<v t="ekr.20090401102247.719"><vh>skip_leading_ws_with_indent</vh></v>
<v t="ekr.20090401102247.720"><vh>stripBlankLines</vh></v>
</v>
<v t="ekr.20090401102247.721"><vh>Checking</vh>
<v t="ekr.20090401102247.722"><vh>check</vh></v>
<v t="ekr.20090401102247.147"></v>
<v t="ekr.20090401102247.148"></v>
<v t="ekr.20090401102247.723"><vh>checkLeadingWhitespace</vh></v>
<v t="ekr.20090401102247.149"></v>
</v>
<v t="ekr.20090401102247.724"><vh>From base class</vh>
<v t="ekr.20090401102247.725"><vh>underindentedComment &amp; underindentedLine</vh></v>
<v t="ekr.20090401102247.726"><vh>startsHelper</vh></v>
<v t="ekr.20090401102247.727"><vh>skipInterface</vh></v>
<v t="ekr.20090401102247.728"><vh>skipBlock</vh></v>
</v>
<v t="ekr.20090401102247.729"><vh>class pythonScanner</vh>
<v t="ekr.20090401102247.730"><vh> __init__</vh></v>
<v t="ekr.20090401102247.731"><vh>adjustDefStart (python)</vh></v>
<v t="ekr.20090401102247.732"><vh>extendSignature</vh></v>
<v t="ekr.20090401102247.733"><vh>skipString</vh></v>
<v t="ekr.20090401102247.734"><vh>skipCodeBlock (python) &amp; helper</vh>
<v t="ekr.20090401102247.735"><vh>pythonNewlineHelper</vh></v>
</v>
<v t="ekr.20090401102247.736"><vh>skipSigTail</vh></v>
</v>
<v t="ekr.20090401102247.737"><vh>Code generation</vh>
<v t="ekr.20090401102247.738"><vh>addRef</vh></v>
<v t="ekr.20090401102247.739"><vh>appendStringToBody &amp; setBodyString (baseScannerClass)</vh></v>
<v t="ekr.20090401102247.740"><vh>createDeclsNode</vh></v>
<v t="ekr.20090401102247.741"><vh>createFunctionNode</vh></v>
<v t="ekr.20090401102247.742"><vh>createHeadline</vh></v>
<v t="ekr.20090401102247.743"><vh>getLeadingIndent</vh></v>
<v t="ekr.20090401102247.744"><vh>indentBody</vh></v>
<v t="ekr.20090401102247.745"><vh>insertIgnoreDirective</vh></v>
<v t="ekr.20090401102247.483"></v>
<v t="ekr.20090401102247.746"><vh>putFunction</vh></v>
<v t="ekr.20090401102247.747"><vh>putRootText</vh></v>
<v t="ekr.20090401102247.748"><vh>setBodyString</vh></v>
<v t="ekr.20090401102247.488"></v>
<v t="ekr.20090401102247.489"></v>
<v t="ekr.20090401102247.725"></v>
</v>
<v t="ekr.20090401102247.749"><vh>atFile.__init__ &amp; initIvars</vh>
<v t="ekr.20090401102247.750"><vh>&lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.489"></v>
<v t="ekr.20090401102247.221"></v>
<v t="ekr.20090401102247.220"></v>
<v t="ekr.20090401102247.219"></v>
</v>
<v t="ekr.20090401102247.751"><vh>Warn when writing an externally changed file</vh>
<v t="ekr.20090401102247.752"><vh>New</vh>
<v t="ekr.20090401102247.753"><vh>c.setFileTimeStamp</vh></v>
<v t="ekr.20090401102247.754"><vh>c.checkFileTimeStamp</vh></v>
</v>
<v t="ekr.20090401102247.755"><vh>Changed</vh>
<v t="ekr.20090401102247.756"><vh>getLeoFile</vh>
<v t="ekr.20090401102247.757"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.451"></v>
<v t="ekr.20090401102247.758"><vh>read (atFile)</vh>
<v t="ekr.20090401102247.759"><vh>&lt;&lt; set fileName &gt;&gt;</vh></v>
<v t="ekr.20090401102247.760"><vh>&lt;&lt; advise user to delete all unvisited nodes &gt;&gt;</vh></v>
<v t="ekr.20090401102247.761"><vh>&lt;&lt; delete all tempBodyStrings &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.408"></v>
<v t="ekr.20090401102247.421"></v>
<v t="ekr.20090401102247.164"></v>
<v t="ekr.20090401102247.762"><vh>write_Leo_file</vh>
<v t="ekr.20090401102247.763"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20090401102247.764"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20090401102247.765"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20090401102247.766"><vh>&lt;&lt; ensure that filename ends with .opml &gt;&gt;</vh></v>
<v t="ekr.20090401102247.767"><vh>&lt;&lt; create theActualFile &gt;&gt;</vh></v>
<v t="ekr.20090401102247.768"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
<v t="ekr.20090401102247.769"><vh>&lt;&lt; delete fileName &gt;&gt;</vh></v>
<v t="ekr.20090401102247.770"><vh>&lt;&lt; rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20090401102247.771"><vh>writeZipFile</vh></v>
</v>
</v>
</v>
<v t="ekr.20090401102247.772"><vh>back-to-home/indentation now save state</vh>
<v t="ekr.20090401102247.176"></v>
<v t="ekr.20090401102247.188"></v>
<v t="ekr.20090401102247.189"></v>
</v>
<v t="ekr.20090401102247.773"><vh>Added g.posList</vh>
<v t="ekr.20090401102247.774"><vh>g.posList</vh>
<v t="ekr.20090401102247.775"><vh>&lt;&lt; docstring for posList &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20090401102247.776"><vh>Added properties to leoNodes.py</vh>
<v t="ekr.20090401102247.252"></v>
<v t="ekr.20090401102247.777"><vh>p.Properties</vh>
<v t="ekr.20090401102247.778"><vh>p.b property</vh></v>
<v t="ekr.20090401102247.779"><vh>p.h property</vh></v>
<v t="ekr.20090401102247.780"><vh>p.gnx property</vh></v>
</v>
<v t="ekr.20090401102247.781"><vh>v.Properties</vh>
<v t="ekr.20090401102247.782"><vh>v.b Property</vh></v>
<v t="ekr.20090401102247.783"><vh>v.h property</vh></v>
<v t="ekr.20090401102247.784"><vh>v.u Property</vh></v>
<v t="ekr.20090401102247.785"><vh>v.gnx Property</vh></v>
</v>
<v t="ekr.20090401102247.786"><vh>t Properties</vh>
<v t="ekr.20090401102247.787"><vh>t.b Property</vh></v>
<v t="ekr.20090401102247.788"><vh>t.h property</vh></v>
<v t="ekr.20090401102247.789"><vh>t.u Property</vh></v>
<v t="ekr.20090401102247.790"><vh>t.gnx Property</vh></v>
</v>
</v>
<v t="ekr.20090401102247.791"><vh>Use myLeoSettings when opening leoSettings.leo</vh>
<v t="ekr.20090401102247.792"><vh>get &amp; allies (g.app.config)</vh>
<v t="ekr.20090401102247.793"><vh>getValFromDict</vh></v>
<v t="ekr.20090401102247.99"></v>
</v>
</v>
<v t="ekr.20090401102247.794"><vh>Added script to leoSettings.leo to ensure all menu items are valid</vh></v>
<v t="ekr.20090401102247.795"><vh>Allow ctrl-o to open non-.leo files</vh>
<v t="ekr.20090401102247.796" annotate="7d71002e"><vh>Posting</vh></v>
<v t="ekr.20090401102247.797"><vh>@url http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626</vh></v>
<v t="ekr.20090401102247.342"></v>
<v t="ekr.20090401102247.798"><vh>c.open &amp; helper</vh>
<v t="ekr.20090401102247.799"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
<v t="ekr.20090401102247.800"><vh>c.createNodeFromExternalFile</vh></v>
</v>
<v t="ekr.20090401102247.801"><vh>tests</vh></v>
</v>
<v t="ekr.20090401102247.802"><vh>Added support for --file=fileName command-line option</vh></v>
<v t="ekr.20090401102247.803"><vh>Added p/t/v.gnx property</vh>
<v t="ekr.20090401102247.780"></v>
<v t="ekr.20090401102247.790"></v>
<v t="ekr.20090401102247.785"></v>
</v>
<v t="ekr.20090401102247.804"><vh>Added support for @edit</vh>
<v t="ekr.20090401102247.342"></v>
<v t="ekr.20090401102247.805"><vh>at-File test code (leoTest.py)</vh>
<v t="ekr.20090401102247.806"><vh>&lt;&lt; dump result and expected &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.798"></v>
<v t="ekr.20090401102247.141" a="E"></v>
<v t="ekr.20090401102247.800"></v>
<v t="ekr.20090401102247.807"><vh>p.Comparisons</vh></v>
<v t="ekr.20090401102247.808"><vh>at...FileNodeName</vh></v>
<v t="ekr.20090401102247.809"><vh>anyAtFileNodeName</vh></v>
<v t="ekr.20090401102247.810"><vh>readAll (atFile)</vh></v>
<v t="ekr.20090401102247.811"><vh>readOneAtEditNode (atFile)</vh></v>
<v t="ekr.20090401102247.812"><vh>languageForExtension</vh></v>
<v t="ekr.20090401102247.210"></v>
<v t="ekr.20090401102247.404"></v>
<v t="ekr.20090401102247.813"><vh>writeOneAtEditNode</vh>
<v t="ekr.20090401102247.814"><vh>shouldWriteAtEditNode</vh></v>
</v>
<v t="ekr.20090401102247.452"></v>
<v t="ekr.20090401102247.219"></v>
<v t="ekr.20090401102247.454"></v>
<v t="ekr.20090401102247.414"></v>
<v t="ekr.20090401102247.412"></v>
</v>
<v t="ekr.20090401102247.815"><vh>added pdb minibuffer command</vh></v>
<v t="ekr.20090401102247.816"><vh>Tab = indent when there is a text selection</vh>
<v t="ekr.20090401102247.18"></v>
<v t="ekr.20090401102247.27"></v>
<v t="ekr.20090401102247.817"><vh>indentBody (indent-region)</vh></v>
</v>
<v t="ekr.20090401102247.818"><vh>Shift-tab undents selected text</vh>
<v t="ekr.20090401102247.819"><vh>dedentBody</vh></v>
<v t="ekr.20090401102247.820"><vh>class leoKeyEvent (leoGui)</vh></v>
<v t="ekr.20090401102247.821"><vh>Events (leoGui)</vh></v>
<v t="ekr.20090401102247.822"><vh>Master event handlers (keyHandler)</vh>
<v t="ekr.20090401102247.391"></v>
<v t="ekr.20090401102247.823"><vh>masterClickHandler</vh></v>
<v t="ekr.20090401102247.824"><vh>masterDoubleClickHandler</vh></v>
<v t="ekr.20090401102247.825"><vh>masterMenuHandler</vh></v>
</v>
<v t="ekr.20090401102247.18"></v>
</v>
</v>
<v t="ekr.20090401102247.826"><vh>New options</vh>
<v t="ekr.20090401102247.827"><vh>Added -c option to specify config files</vh>
<v t="ekr.20090401102247.609"></v>
<v t="ekr.20090401102247.579"></v>
</v>
<v t="ekr.20090401102247.828"><vh>Added c.config.getSettingSource</vh></v>
<v t="ekr.20090401102247.829"><vh>Added support for @int icon_bar_widgets_per_row setting</vh>
<v t="ekr.20090401102247.830"><vh>Icon area convenience methods</vh></v>
<v t="ekr.20090401102247.831"><vh>class tkIconBarClass</vh>
<v t="ekr.20090401102247.832"><vh> ctor</vh></v>
<v t="ekr.20090401102247.833"><vh>add</vh>
<v t="ekr.20090401102247.834"><vh>&lt;&lt; create a picture &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.835"><vh>addRow</vh></v>
<v t="ekr.20090401102247.836"><vh>addRowIfNeeded</vh></v>
<v t="ekr.20090401102247.837"><vh>addWidget</vh></v>
<v t="ekr.20090401102247.838"><vh>clear</vh></v>
<v t="ekr.20090401102247.839"><vh>deleteButton (new in Leo 4.4.3)</vh></v>
<v t="ekr.20090401102247.840"><vh>getFrame &amp; getNewFrame</vh></v>
<v t="ekr.20090401102247.841"><vh>pack (show)</vh></v>
<v t="ekr.20090401102247.842"><vh>setCommandForButton (new in Leo 4.4.3)</vh></v>
<v t="ekr.20090401102247.843"><vh>unpack (hide)</vh></v>
</v>
<v t="ekr.20090401102247.844"><vh>New/changed code</vh>
<v t="ekr.20090401102247.833"></v>
<v t="ekr.20090401102247.837"></v>
<v t="ekr.20090401102247.836"></v>
<v t="ekr.20090401102247.835"></v>
<v t="ekr.20090401102247.840"></v>
<v t="ekr.20090401102247.845"><vh>tt.createControl</vh></v>
</v>
</v>
<v t="ekr.20090401102247.846"><vh>Added support for --gui option</vh></v>
<v t="ekr.20090401102247.847"><vh>removed query-replace</vh>
<v t="ekr.20090401102247.848"><vh>&lt;&lt; define classesList &gt;&gt;</vh></v>
</v>
<v t="ekr.20090401102247.849"><vh>Escape now ends isearch</vh>
<v t="ekr.20090401102247.324"></v>
<v t="ekr.20090401102247.820"></v>
<v t="ekr.20090401102247.391"></v>
</v>
<v t="ekr.20090401102247.850"><vh>Improved isearch commands</vh>
<v t="ekr.20090401102247.820"></v>
<v t="ekr.20090401102247.391"></v>
<v t="ekr.20090401102247.315"></v>
<v t="ekr.20090401102247.324"></v>
<v t="ekr.20090401102247.327"></v>
<v t="ekr.20090401102247.249"></v>
<v t="ekr.20090401102247.851"><vh>updateLabel</vh></v>
<v t="ekr.20090401102247.328"></v>
<v t="ekr.20090401102247.852"><vh>findNextMatch</vh></v>
<v t="ekr.20090401102247.223"></v>
</v>
</v>
<v t="ekr.20090401102247.853"><vh>Plugins</vh>
<v t="ekr.20090401102247.854"><vh>Improved nav_buttons plugin and corresponding nodeHistory class</vh>
<v t="ekr.20090401102247.855"><vh>goPrevVisitedNode</vh></v>
<v t="ekr.20090401102247.856"><vh>goNextVisitedNode</vh></v>
<v t="ekr.20090401102247.857"><vh>class nodeHistory</vh>
<v t="ekr.20090401102247.858"><vh> ctor (nodeHistory)</vh></v>
<v t="ekr.20090401102247.859"><vh>canGoToNext/Prev</vh></v>
<v t="ekr.20090401102247.860"><vh>clear</vh></v>
<v t="ekr.20090401102247.861"><vh>goNext/Prev</vh></v>
<v t="ekr.20090401102247.862"><vh>remove</vh></v>
<v t="ekr.20090401102247.863"><vh>selectChapter</vh></v>
<v t="ekr.20090401102247.864"><vh>update</vh></v>
<v t="ekr.20090401102247.865"><vh>visitedPositions</vh></v>
</v>
</v>
<v t="ekr.20090401102247.866"><vh>Created qtGui and tkGui plugins</vh>
<v t="ekr.20090401102247.867"><vh>Put getImage in the gui class</vh>
<v t="ekr.20090401102247.868"><vh>appendImageDictToList</vh></v>
</v>
<v t="ekr.20090401102247.869"><vh>g.alert calls g.app.gui.alert</vh>
<v t="ekr.20090401102247.870"><vh>alert</vh></v>
<v t="ekr.20090401102247.871"><vh>Found: g.alert</vh>
<v t="ekr.20090401102247.756"></v>
<v t="ekr.20090401102247.872"><vh>checkMoveWithParentWithWarning</vh></v>
<v t="ekr.20090401102247.873"><vh>checkDrag</vh></v>
<v t="ekr.20090401102247.874"><vh>p.invalidOutline</vh></v>
</v>
</v>
</v>
<v t="ekr.20090401102247.875"><vh>Created leoGuiPluginsRef.leo</vh></v>
<v t="ekr.20090401102247.876"><vh>Added support for wx gui plugin</vh>
<v t="ekr.20090401102247.609"></v>
<v t="ekr.20090401102247.877"><vh>app.createWxGui</vh></v>
</v>
</v>
<v t="ekr.20090401102247.878"><vh>Testing</vh>
<v t="ekr.20090401102247.879"><vh>Added @test consistency of leoApp tables</vh>
<v t="ekr.20090401102247.342"></v>
</v>
<v t="ekr.20090401102247.880"><vh>Improved @test paste-node</vh></v>
</v>
<v t="ekr.20090401102247.881"><vh>Leo and Python 2.6</vh>
<v t="ekr.20090401102247.882"><vh>Failed unit tests with Python 2.6</vh>
<v t="ekr.20090401102247.33"></v>
<v t="ekr.20090401102247.883"><vh>g.is_sentinel</vh>
<v t="ekr.20090401102247.884"><vh>&lt;&lt; is_sentinel doc tests &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20070105153901">@language c
@nocolor</t>
<t tx="ekr.20070105153901.1">Storage allocation is crucial to any compiler because of the number, size and
complexity of data which must be allocated. You would not be far off to say that
a compiler consists of storage allocation and everything else. Indeed, the
design of CC2 was driven by the goal of creating the token list quickly, and
that goal has far-reaching implications for how memory is allocated.

CC2 allocates objects one-at-a-time (simple allocation), in blocks of
fixed-sized objects (block allocation) or in blocks of variable-sized objects
(stream allocation). Simple allocation requires just a single macro call, but
results in a call to calloc for each object allocated. It is appropriate only
for infrequently allocated data structures. Block allocation and stream
allocation are optimizations which reduce calls to calloc by more than an order
of magnitude.
</t>
<t tx="ekr.20070105153901.2">I have recently made some discoveries concerning storage allocation and register
allocation that promise to significantly improve CC2. These discoveries were
surprising because they seemed to contradict either common sense or conclusions
based on performance measurements. Happily, the new code is significantly
smaller and measurably faster than the old code!

These discoveries can be summarized as follows:

- There is no speed penalty for having the stream reservation macros use a
  subroutine to allocate a new stream block. This came as a shock, though the
  reason is clear in retrospect.

- Streams are polymorphic: they may contain items of varying types.

- Streams are defined primarily by their lifetime and only secondarily by their type.

- Lists are special-purpose streams.

- Abbreviation macros highlight relationships among source text, while removing
  the actual source text from view.
</t>
<t tx="ekr.20070105153901.3">Block allocation allocates an array of items all of the same size and kind from
a area of memory obtained from calloc. In the front end, hash table nodes and
some kinds of tokens are allocated using block allocation. Block allocation will
be used extensively in the parser and code generator to allocate nodes for
parsing, semantic analysis and code generation.
</t>
<t tx="ekr.20070105153901.4">Stream allocation allocates a stream block, then adds variable-sized items to
the block until the stream block is nearly full, at which time another stream
block is allocated. Steam blocks contain a stream avail count to keep track of
what is in the stream. The first unused portion of the stream block is
calculated from the stream avail count.

The definition of "nearly full" depends on the individual stream. Because stream
allocation is tricky, the details are hidden by two sets of macros. **Stream
reservation macros** allocate another stream block when the current block is
nearly full. **Stream put macros** add an element to the stream without checking
to see if the stream block is big enough to hold it. I shall speak of stream put
macros being protected by stream reservation macros. Because of differences
between streams, there are separate reservation and put macros for each distinct
stream. While tokenize uses stream allocation for both tokens and streams, the
details of stream allocation for tokens and streams differ substantially.

Tokens form a packed list--tokens usually follow one right after another.
Packing the list eliminates the need for a next token pointer and saves a lot of
space. At the end of a token block a HIDDEN_END_BLOCK_TOK is inserted so that
the next token in the token list can be found. Therefore, a token block is
"almost full" when there is no longer room for an arbitrary token and a
HIDDEN_END_BLOCK_TOK. Tokens have a maximum size, BIG_TOKEN_SIZE. Since
HIDDEN_END_BLOCK_TOK is a big token, a token block is "almost full" when less
than 2 * BIG_TOKEN_SIZE bytes remain.

Strings are handled differently from tokens because strings may be arbitrarily
large but are not part of a list. sreserve_macro is the stream reservation macro
for the string stream. scopy_macro and big_scopy_macro are the put macros for
the string stream.

Huge strings are strings larger than the size of the string space in a string
block. big_scopy_macro allocates string space for huge tokens, creating a block
just big enough to hold the huge string. Such a block does not contain avail or
used counts. big_scopy_macro need not be protected since it always creates its
own string block. By the way, huge strings are seldom allocated now that
multi-line comments are split into one COMMENT_TOK per line.

Normal strings, i.e., strings smaller than the size of a stream block, are
allocated by the scopy_macro. A string block is "almost full" when the next
string to be allocated will not fit in the current block. This wastes some space
if the string to be allocated is large and the current block is almost empty but
not empty enough. Fortunately, large strings are rare so I have ignored this
waste.

The extra work involved in using stream reserve and put macros produces a
spectacular increase in speed of tokenize. Among the benefits:

- Crucial pointers may be allocated in registers throughout the lifetime of
  tokenize. These registers are never unloaded because there are no function calls
  inside tokenize!

- The compiler is able to generate perfect code without doing any global
  optimization. Local code optimization is sufficient to produce code as good as
  would be produced by an excellent assembly language coder.

- There are no get-next-character or put_next_token routines. Earlier versions
  of tokenize, using such routines, ran more than 5 times slower than the present
  version.

- Storage is allocated in uniformly sized blocks, not in small pieces. This
  keeps calloc happy.
</t>
<t tx="ekr.20070105153901.5">tokenize is called in a variety of contexts: to tokenize the main file, header
files, pasted strings, and command-line #define's and #undef's. Many calls to
tokenize create short token lists so it would be very wasteful for tokenize to
create new token and string blocks each time it was called. Also, the hash table
must be retained between calls so that all variables with the same spelling have
the same pointer to the spelling table. The global variables tok_block_list,
str_block_list and sym_hash_list are used to keep track of the current token,
string and hash blocks, respectively.

The compiler allocates strings for several purposes outside of tokenize. Such
strings could often be allocated in a string block, but that would be clumsy.
The str_alloc macros allocate a list object big enough to hold the list pointer
and the actual string.  We put strings on a list so they can be deallocated easily...
</t>
<t tx="ekr.20070105153901.6">**The proper time to specify when an object will be deallocated is when the object
if created**. This simple rule was a big Aha.

All object allocation macros take a parameter specifying a deallocation list. If
the parameter is non-NULL, the allocation macro places the newly created object
on the list. Objects on deallocation lists are freed in the following places:

- At the end of cpp. All preprocessing objects not part of the token list are
  freed here.

- In comp_free_all. Objects which are logically part of the token list may only
  be freed when the entire source file has been compiled. comp_free_all is
  called at the start of compile in the production version of the compiler, and
  it is called at the end of compile in the debugging version. In the debugging
  version we want to make sure that all objects are eventually freed. In the
  production version, the objects used by the last compiled file need never be
  freed, a small time gain.

Objects are placed on no deallocation list in the following situations:
		
- When object are deallocated in the routine in which they are allocated. This
  is seldom used, since most such objects can be allocated on the stack.
  Variable-length objects could be freed in this way.
		
- The ap_first and ap_last arrays are allocated in mac_get_actuals but freed in
  mac_expand.
</t>
<t tx="ekr.20070105153901.7">Debugging objects and production objects are allocated, used and freed in
exactly the same way. However, debugging objects provide increased statistics
and error-checking capabilities. Debugging objects are created by the object
macros when the OBJ_DEBUG compile-time constant is defined. Otherwise,
production objects are created.

Debugging objects contain several fields not found in production objects:

- Lists fields: All debugging objects are placed on lists. These lists ensure
  that obj_free frees only objects. These lists are also used to check the
  integrity of all objects.

- Statistics fields.

- Header and trailer protection fields. These fields are filled with a fixed bit
  pattern when the object is allocated. The fields are checked on request, and
  certainly when the object is freed. This provides an excellent, though not
  foolproof, test for over-writing a buffer allocated by calloc. Using these
  protection fields has found some bugs that otherwise would have been really
  tough to find.
</t>
<t tx="ekr.20070105153901.8">The original treserve_macro was too large to include in each call to put_id_tok,
put_small_tok, etc. The macro was large because I wanted to avoid a
function call here. Similar kinds of function calls had grossly slowed down
previous versions of tokenize. However, I was surprised when measurements showed
that a function call here does not matter at all. So the new version of
treserve_macro, called tok_protect_macro, is::

	#define tok_protect_macro(tp, tavail)\
	if (tavail &lt; MAX_TOKEN_SIZE) {\
		tp = tok_new_block(tp, tavail);\
		tavail = tok_avail;\
	}

The tok_new_block allocates a new token block, sets two global variables,
tok_ptr and tok_avail and returns tok_ptr.

In retrospect, it is clear why a function call is acceptable here. tok_new_block
is called when a new block of tokens is required. An average token comprises
almost exactly 4 characters and there are about 200 tokens per block so
tok_new_block is called only about once every 800 input characters. The function
that had previously slowed down tokenize so much was called once every input
character. Clearly, the overhead of calling tok_new_block is 3 orders of
magnitude smaller.

Because tok_protect_macro is so much smaller than treserve_macro,
tok_protect_macro can be made part of the various stream put macros, such as
put_small_tok.  This ensures that tok_protect_macro is called as needed.

Using function calls in allocation macros creates opportunities for more
simplifications. The put_comment_string_macro no longer exists--tokenize simply
calls str_copy2block, which handles all the details::

	/* Output a comment string token */
	put_ptr(WS_COMMENT_TOK,str_copy2block(string_start, string_length), comments);
 
Simplifying the code to allocate strings created more opportunities to simplify
the code...
</t>
<t tx="ekr.20070105153901.9">Global variables [nowadays we would use ivars of stream classes] drastically
simplify defining a stream. Especially in the back end, streams are used across
numerous functions so there is no possibility of keeping important stream
variables in registers anyway. This was an Aha--defining a stream involves
defining a complex of global variables. [Nowadays we would make each stream a
class.] For instance, the globals [ivars] needed to define the string stream
are::

	string_block * str_block_list = NULL; /* List of string blocks. */
	long	 str_avail = 0;	  /* Available bytes in current block. */
	char * str_ptr = NULL;	/* Pointer to first free byte. */

These variables are all controlled by str_copy2block, so they are benign. In
addition to these essential stream variables, it is useful to define global
stream statistics::

	long	str_blocks; /* Total allocated string blocks. */
	long	str_bytes;		/* Total bytes in strings. */
	long	str_number;	/* Number of strings. */
	long	str_waste;		/* Total wasted bytes. */

Previous schemes required a different kind of block for every kind of allocated
item. Actually allocating an item from such a block was clumsy. There is a much
better way. If global variables are used to keep track of streams, it became
clear that streams themselves have a global nature. [Nowadays we would have
global instances of stream objects.] In addition, both the token stream and the
string stream deals with variable size items, so streams may be composed of a
variety of different **kinds** of items.

If streams may contain different kinds of items, what determines which items go
in which streams? The answer is so simple: a stream is defined by its lifetime,
i.e., when the whole stream is deallocated.

Looking back at the documentation on storage allocation, I am struck by the
section called Deallocating Objects. My subconscious was apparently telling me
that when objects were deallocated was more important than I consciously
realized at the time. This section is not just describing how to free objects;
it tells us how to define streams! In short::

    Streams may contain items of varying sizes and types
    as long as all items of a stream are deallocated at the same time,
    i.e., if all items have the same lifetime.

In practice, it may be convenient to have several streams that are deallocated
at the same time.
</t>
<t tx="ekr.20070105153901.10">The CC2 compiler uses a separate stream (the cs stream) for all items to be in
comp_free_all at the end of compile phase. The cs_ptr and cs_avail global
variables are just like the str_ptr and str_avail variables. The cs_put,
cs_protect and cs_new_block macros suffice to allocate any kind of item that
share this lifetime.

Let's look ahead to the parser and code generator. There will be a parser stream
that contains all parse nodes and other nodes that will be freed at the same
time as the parse tree. The code stream will contain all code nodes. Defining
and using these streams will be trivial and will comprise essentially all the
storage allocation for the back end.

The new storage allocation scheme also guarantees absolute highest storage
allocation speed. Indeed, allocating a new parse or code node will require only
one function call per about 200 nodes, so the call-return overhead in calling
cs_new_block can be ignored. It is also clear that the other processing done by
the cs_put macro can not be reduced further, even if written in assembly
language. These discoveries drastically reduce the design, coding and testing
required to allocated and free objects.
</t>
<t tx="ekr.20070105153901.11">Objects in the front end are on only one list, their deallocation list.
Sometimes the deallocation list does double duty, but the fact remains that each
object appears on only one list.

Objects in the back end, however, may be on several lists simultaneously. For
instance, nodes in a parse tree may be threaded. Many overlapping lists of
symbols may need to be maintained. To maintain these lists separate list nodes
will be required. These will be called cons nodes after LISP terminology. The
definition of a cons node will be something like::

	typedef struct cons_struct cons_node;
	struct const_struct {
		void * cons_next;
		void * cons_item;
	}
	
Thousands of such nodes will be needed throughout the back end. Clearly, cons
nodes should be allocated in list blocks to speed the storage allocation
process. When should list blocks be deallocated? The surprising answer is:
usually never. In other words, cons nodes have permanent lifetime. Cons nodes
will be allocated in a special purpose stream, the cons stream.

The cons_new_block macro allocates a new block of cons_nodes and puts them on
an avail list. When an individual cons node is freed, it is simply added to a
list of free cons nodes. Thus, in general list blocks will contain both free and
used cons nodes. cons_new_block is called only when no free cons nodes exist.
List blocks need never be deallocated because free cons nodes will eventually be
reused--unless the number of cons nodes grows truly enormous, there should never
be a need for garbage collection.

There may be some instances when it would save time to deallocate all the cons
nodes of a specialized stream at once. In that case, the cons nodes would be
allocated using a specialized version of the new_cons_node macro.
</t>
<t tx="ekr.20070105153901.12">We could, in fact, allocate *all* items using streams, but this would be going
too far. The object routines provide detailed statistics about objects which are
lost when items are allocated from blocks. Also, the object routines provide
important error checking for the stream blocks themselves. Finally, it would be
silly to have to allocate an entire stream when allocating an object once or
twice is all that is needed. Having said that, it seems to me that streams are a
more fundamental implementation concept than objects. All the fancy object
macros seem to be overshadowed by the elegantly simple stream allocation macros.

Whatever the theoretical relationship between objects and streams, this storage
allocation scheme seems perfect:

- Items may be allocated simply and flexibly with minimal time or space overhead.
- Streams can be created easily for special purposes.
- Blocks can be of uniform size so that minimal stress is put on calloc.
- Objects can be used instead of stream items during development for greater error
  detection and greater resolution of statistics.
</t>
<t tx="ekr.20070105153901.13">One final Aha simplifies the tokenize code considerably. Abbreviation macros
formalize a relationship between source text that could not be efficiently
expressed as a function call. For instance, consider the macro::

	#define put_small(a,b) put_small_tok(tp, tavail, a, b)

This macro shows clearly that all calls to put_small_tok in tokenize
will have tp and tavail as parameters. This relationship could be expressed as a
function call, but not efficiently.

Once I saw how to use put_small to hide the constant details of the calls to
put_small_tok, I was able to generalize the concept of abbreviation macros to
similar situations.</t>
<t tx="ekr.20070626112503"></t>
<t tx="ekr.20071028032929"></t>
<t tx="ekr.20071028032929.1"></t>
<t tx="ekr.20071028032929.2"></t>
<t tx="ekr.20071028032929.3"></t>
<t tx="ekr.20071028032929.4">leo.py reads and writes exactly like LeoCB</t>
<t tx="ekr.20071028032929.5">Amazing.  I wrote some dummy code last night, read up on indices this morning, and got everything to work in a couple of hours. The result is very fast: no optimization is needed for Leo. I love Tkinter!

Added c.recolor and tree.recolor routines.  This hooks should be called whenever the body text changes.  Apparently there is no "OnTextChanged" event in Tk.</t>
<t tx="ekr.20071028032929.6"></t>
<t tx="ekr.20071028032929.7"></t>
<t tx="ekr.20071028032929.8">This marked my complete frustration with wxLeo and wxPython, and the real beginning of the work on leo.py.</t>
<t tx="ekr.20071028032929.9"></t>
<t tx="ekr.20071028032929.10">I am totally in love with Python.  Everything is so much easier:  Automatic debugging, no declarations, no types, no compilation. Great data structures. Even without single stepping the debugging is easy.

All major aspects of c2py are now complete.</t>
<t tx="ekr.20071028032929.11">I am not sure exactly when this happened.  The details apparently have been lost.  There was a time when I was experimenting with Python and wxPython, and a time when I was working on wxWindows version of Leo.</t>
<t tx="ekr.20071028032929.12"></t>
<t tx="ekr.20071028032929.13"></t>
<t tx="ekr.20071028032929.14"></t>
<t tx="ekr.20071028032929.15"></t>
<t tx="ekr.20071028032929.16"></t>
<t tx="ekr.20071028032929.17"></t>
<t tx="ekr.20071028032929.18"></t>
<t tx="ekr.20071028032929.19">atFile.scanAllDirectives was overriding the delim computed by scanHeader.

The fix was to add a reading param to scanAllDirectives that suppresses the scan for delims.</t>
<t tx="ekr.20071028032929.20"></t>
<t tx="ekr.20071028032929.21"></t>
<t tx="ekr.20071028032929.22">- Moved call to assignFileIndices into write_Leo_file.
- Called assignFileIndices in writeAtFileNodes, writeDirtyAtFileNodes, writeMissingAtFileNodes</t>
<t tx="ekr.20071028032929.23">Otherwise the tree-drawing code will change the position!</t>
<t tx="ekr.20071028032929.24"></t>
<t tx="ekr.20071028032929.25">What I did:

1. Converted the following ivars by hand:

app -&gt; g.app
globalDirectiveList -&gt; g.globalDirectiveList

2.  Replaced Tkinter by tk:

try: import Tkinter as Tk
except ImportError: Tk = None

3. Replaced "from leoPlugins import *" by import leoPlugins.
	- Replaced registerHandler by leoPlugins.registerHandler.</t>
<t tx="ekr.20071028032929.26">@nocolor 

Create the list of functions in leoGlobals.py.
	OR:  create the list by importing leoGlobals.py and looking at g.__dict__
Put this list in the script.</t>
<t tx="ekr.20071028032929.27"></t>
<t tx="ekr.20071028032929.28"></t>
<t tx="ekr.20071028032929.29"></t>
<t tx="ekr.20071028032929.30"></t>
<t tx="ekr.20071028032929.31"></t>
<t tx="ekr.20071028032929.32">See notes in project.  This was very clever code.</t>
<t tx="ekr.20071028032929.33">- created convertStackToPosition.
- created getExistingVnode.
- Major hack to getVnode.
</t>
<t tx="ekr.20071028032929.34">Moved a call to c.frame.tree.drawIcon(v) so that the icon will, in fact, be redrawn.

This was apparently an old bug.</t>
<t tx="ekr.20071028032929.35">This requires Python 2.2, as does iterators.</t>
<t tx="ekr.20071028032929.36">The setDirty logic is now about as clean as it can be.</t>
<t tx="ekr.20071028032929.37">- Changed readAll so it uses c.nullPosition by default.
- Test p is None in scanDirectives.

These two changes _might_ be enough to ensure the arg to p.__cmp__ is always a position in Leo's _core_.  However, user code is a different matter!

The coding style is to use: "if p is None:" rather than "if p == None:".  However, there is no way to enforce that style, so I have left the test against None in p.__cmp__.

Use the p.equal method when speed is crucial.</t>
<t tx="ekr.20071028032929.38"></t>
<t tx="ekr.20071028032929.39">This is a time-critical routine.</t>
<t tx="ekr.20071028032929.40"></t>
<t tx="ekr.20071028032929.41">1. Reduced copies of positions in drawTree.

Allocated copies in drawTree rather than in drawBox, drawIcon and drawText.  This reduces the number of copies by one third.

2. Eliminated extraneous positions in fileCommands read logic.

This was due to calling v.setMarked rather than v.initMarked, which calls c.doHook.  I don't know why this allocates so many positions, and it does.

3. Sped up fileCommands write logic by 30% (or more?)

This was a weird one.  p.__cmp__ is up to 10 times slower than p.equal.  I don't think there is any recursive code in p.__cmp__, and I suppose there might be...</t>
<t tx="ekr.20071028032929.42"></t>
<t tx="ekr.20071028032929.43"></t>
<t tx="ekr.20071028032929.44"></t>
<t tx="ekr.20071028032929.45"></t>
<t tx="ekr.20071028032929.46">These assert that the old or simple ways of computing positions and levels are equivalent to the optimized ways.

These assertions significantly slow down moves.  This shows that the optimized code truly is essential.</t>
<t tx="ekr.20071028032929.47"></t>
<t tx="ekr.20071028032929.48"></t>
<t tx="ekr.20071028032929.49">The code set a _next field to a position instead of a vnode.</t>
<t tx="ekr.20071028032929.50">Changes since the last cvs update:
	
- Disables changes if not a complete word.
- Disables changes if preceded by prefix:
	- Running this script twice is now safe.
- Disables changes if preceded by "def " or "."
- Added replace parameter for safety.
</t>
<t tx="ekr.20071028032929.51"></t>
<t tx="ekr.20071028032929.52"></t>
<t tx="ekr.20071028032929.53">Removed all code governed by "if not g.sharedNodes".
</t>
<t tx="ekr.20071028032929.54"></t>
<t tx="ekr.20071028032929.55">I started the transition to "pure" position code.

That is, I started eliminating code in "not g.sharedNodes" parts.  I did this because doing things "both ways" doesn't make any sense: much easier to change code.</t>
<t tx="ekr.20071028032929.56">self_and_siblings_iter()
self_and_parents_iter()
</t>
<t tx="ekr.20071028032929.57">This allows the user to choose a "safe mode".  It is off by default.</t>
<t tx="ekr.20071028032929.58"></t>
<t tx="ekr.20071028032929.59">We _can_ make the Leo compatible with old scripts !!!

1. Iterators replace most calls to next(), threadNext() etc., so any _other_ calls to there routines do _not_ have to be efficient:

2. In other words, iterators are the place to "optimize" tree traversals.

3. I added proxies to the position class so that p.x() is valid almost anywhere that v.x() is valid.

The only exceptions is that the v.linkX and v.unlink routines should only be called explicitly from the position class.

4.  I shall define porv.setCurrentVnode() and porv.currentVnode () in terms of porv.setCurrentPosition and porv.currentPosition.

This will deal with positions or vnodes as appropriate.

5. Added t ivar to position class:  self.t = self.v.t

Therefore, almost all code should continue to work!
</t>
<t tx="ekr.20071028032929.60"></t>
<t tx="ekr.20071028032929.61"></t>
<t tx="ekr.20071028032929.62"></t>
<t tx="ekr.20071028032929.63"></t>
<t tx="ekr.20071028032929.64"></t>
<t tx="ekr.20071028032929.65"></t>
<t tx="ekr.20071028032929.66"></t>
<t tx="ekr.20071028032929.67">Changed leoConfig.leo, and the popup menu.

By: sbeards ( Scott Beardsley ) 
 BUG: Toggle brackets via Ctrl+B   
2004-02-11 17:21  

The ToggleAngleBrackets keyboard command (Ctrl+B) doesn't seem to be working at all. </t>
<t tx="ekr.20071028032929.68">Changed Undo/Redo messages:

- Insert Outline to Insert Node.
- Delete Outline to Delete Node.
- Clone to Clone Node.

This is a real code change: it affects the undo/redo logic.

BTW, some way should be found to translate these (and all other text as well!!).</t>
<t tx="ekr.20071028032929.69"></t>
<t tx="ekr.20071028032929.70"></t>
<t tx="ekr.20071028032929.71">
</t>
<t tx="ekr.20071028032929.72"></t>
<t tx="ekr.20071028032929.73"></t>
<t tx="ekr.20071028032929.74">- Fixed Dan Winkler's bug with CashRegister.ss.

- Possibly fixed the "Zope Sprint" bug.

- Ensure trailing newline in scripts.

- Fixed indent problem in leoTkinterGui.py.

- Fixed several problems in the Convert All Blanks/Tabs commands.

- Give shorter message when saving a read-only file fails.
  This is a bit of a kludge.  Only time will tell if it works acceptably.

- Leo no longer writes "empty" attributes like a="".  This arose because Leo no longer writes cloned attributes.

- Added some code to save and restore the "top" vnode, but this really is useless at present: the "top" vnode is a function of the scroll state, and that is a Tk-dependent value.  The only proper way of computing the top node would be to look at the scroll state, and this I don't care to do now.

</t>
<t tx="ekr.20071028032929.75"></t>
<t tx="ekr.20071028032929.76">This is correct and more accurate.

- Created v.setAllAncestorAtFileNodesDirty.

- Call v.setAllAncestorAtFileNodesDirty instead of v.setDirty.

- "Duplicate" calls to v.setAllAncestorAtFileNodesDirty are needed just as with v.setDirty.

- This change affects drags, moves, clones, insert, delete, sorting.</t>
<t tx="ekr.20071028032929.77"></t>
<t tx="ekr.20071028032929.78"></t>
<t tx="ekr.20071028032929.79">c.doCommand calls tree.redrawAfterException on exceptions.  This works because doCommand is itself _not_ contained in any begin/endUpdate pair, so setting self.updateCount = 0 in tree.redrawAfterException will work.</t>
<t tx="ekr.20071028032929.80">Changed:

if sys.platform not in ("linux1","linux2"):

to:

if sys.platform not in ("darwin",freebsd4","freebsd5","linux1","linux2"):

in:

&lt; &lt; set bind_shortcut and menu_shortcut using accel &gt; &gt;</t>
<t tx="ekr.20071028032929.81"></t>
<t tx="ekr.20071028032929.82">The fix was to insert code to test for a special case.

I wonder what this code would look like in the shared-tnode world?
</t>
<t tx="ekr.20071028032929.83"></t>
<t tx="ekr.20071028032929.84"></t>
<t tx="ekr.20071028032929.85">This is so handy.</t>
<t tx="ekr.20071028032929.86"></t>
<t tx="ekr.20071028032929.87"></t>
<t tx="ekr.20071028032929.88">The assertion

assert(i == new_len)

in &lt; &lt; initialize new states &gt; &gt; has caused no end of troubles.  The new code eliminates the assertion by brute force.  It has never been clear why the assert has failed, and it does so rarely.  However, the very worst that can happen is that some lines aren't colored properly, so it's not a big deal.</t>
<t tx="ekr.20071028032929.89"></t>
<t tx="ekr.20071028032929.90">Created tree.enableDrawingAfterException and called it in es_exception.</t>
<t tx="ekr.20071028032929.91"></t>
<t tx="ekr.20071028032929.92"></t>
<t tx="ekr.20071028032929.93"></t>
<t tx="ekr.20071028032929.94"></t>
<t tx="ekr.20071028032929.95"></t>
<t tx="ekr.20071028032929.96"></t>
<t tx="ekr.20071028032929.97"></t>
<t tx="ekr.20071028032929.98"></t>
<t tx="ekr.20071028032929.99"></t>
<t tx="ekr.20071028032929.100">The nullGui class is not ready for prime time yet.</t>
<t tx="ekr.20071028032929.101">Useful for unit testing.</t>
<t tx="ekr.20071028032929.102"></t>
<t tx="ekr.20071028032929.103"></t>
<t tx="ekr.20071028032929.104">Added at = self</t>
<t tx="ekr.20071028032929.105"></t>
<t tx="ekr.20071028032929.106"></t>
<t tx="ekr.20071028032929.107">This affects only the Reformat Paragraph command.</t>
<t tx="ekr.20071028032929.108"></t>
<t tx="ekr.20071028032929.109"></t>
<t tx="ekr.20071028032929.110"></t>
<t tx="ekr.20071028032929.111"></t>
<t tx="ekr.20071028032929.112">@nocolor

Leo now uses yymmddhhmmss as the format of timestamps.  This is good for sorting chronologically.</t>
<t tx="ekr.20071028032929.113">Using * shows files like readme that don't have a file extension.</t>
<t tx="ekr.20071028032929.114"></t>
<t tx="ekr.20071028032929.115"></t>
<t tx="ekr.20071028032929.116">The fix is to add a scripting arg to atFile.scanAllDirectives.</t>
<t tx="ekr.20071028032929.117">Also removed a confusing traceback.</t>
<t tx="ekr.20071028032929.118"></t>
<t tx="ekr.20071028032929.119">Found a batch-mode bug: the meaning of moves depends on whether nodes are expanded.  This won't be good in batch mode.</t>
<t tx="ekr.20071028032929.120"></t>
<t tx="ekr.20071028032929.121">It turns out that executing a script was setting the tnodeList for the node if the node had section refs!  This was the source of the ongoing mystery about why some nodes had tnodeLists.  Resolving this mystery puts Leo's read/write code on a firmer foundation.

This was tricky to make sure that tnodeList's are created and written only when necessary:

- The fileCommands.putVnode writes tnodeList only for @file nodes.
  (and only non-empty tnodeList's)

- new_df.write clears at.root.tnodeList when writing a script.

- c.checkOutline (and the related script) does not consider that an empty tnodeList is an error.</t>
<t tx="ekr.20071028032929.122"></t>
<t tx="ekr.20071028032929.123"></t>
<t tx="ekr.20071028032929.124">Replaced string concatenation with list operations.</t>
<t tx="ekr.20071028032929.125"></t>
<t tx="ekr.20071028032929.126">Dialogs return a predefined value.</t>
<t tx="ekr.20071028032929.127"></t>
<t tx="ekr.20071028032929.128"></t>
<t tx="ekr.20071028032929.129"># Line 1108: _multiples = [(2., Numeric.log10(2.)), (5., Numeric.log10(5.))]

I suspect this was a file that contained both tabs and spaces.</t>
<t tx="ekr.20071028032929.130"></t>
<t tx="ekr.20071028032929.131">My conclusion at present is that the problem lies with 4.0.4, not 4.1.  I can see nothing seriously wrong with the present code:

- Missing tnodeList errors are possible when @file nodes are cloned when converting from 3.x to 4.x.  The tnodeList probably should have been made part of tnodes, not vnodes; it's too late to change now.

- Missing tnodeList errors are not serious: Leo will recover as usual.

- The copy/paste code had a few bugs that I corrected today.  I doubt whether these would have caused major problems.

In short, the present code appears to be reasonably solid.  I should withdraw the 4.0.4 code asap.</t>
<t tx="ekr.20071028032929.132"></t>
<t tx="ekr.20071028032929.133"></t>
<t tx="ekr.20071028032929.134">The old way always surprised me.

To make this work I disabled checks in the read logic if at.importing is true</t>
<t tx="ekr.20071028032929.135"></t>
<t tx="ekr.20071028032929.136"></t>
<t tx="ekr.20071028032929.137"></t>
<t tx="ekr.20071028032929.138">Only double-quoted strings are valid in html.  A lone single-quote caused a cascade of mismatched comments.</t>
<t tx="ekr.20071028032929.139">This has been around ever since the dragging code was created.</t>
<t tx="ekr.20071028032929.140">Plugins are now loaded in the order in which they appear in pluginsManager.txt.

Removed all "compile-time" enabling/disabling code from leoPlugins.leo.

The only such checks that remain are checks to see if Tkinter can be imported, and other similar checks.
</t>
<t tx="ekr.20071028032929.141"></t>
<t tx="ekr.20071028032929.142">The only change was that replaceClipboardWith now no longer returns a value.</t>
<t tx="ekr.20071028032929.143"></t>
<t tx="ekr.20071028032929.144"></t>
<t tx="ekr.20071028032929.145"></t>
<t tx="ekr.20071028032929.146"></t>
<t tx="ekr.20071028032929.147"></t>
<t tx="ekr.20071028032929.148">getBodyLines must set head = tail = None when lines is expanded to include everything.

This probably affects several other commands.</t>
<t tx="ekr.20071028032929.149"></t>
<t tx="ekr.20071028032929.150"></t>
<t tx="ekr.20071028032929.151">This fixes several related bugs:  updateRecentFiles was not being called except when openWithFileName was called.</t>
<t tx="ekr.20071028032929.152"></t>
<t tx="ekr.20071028032929.153"></t>
<t tx="ekr.20071028032929.154">app.batchLog was completely redundant.</t>
<t tx="ekr.20071028032929.155"></t>
<t tx="ekr.20071028032929.156"></t>
<t tx="ekr.20071028032929.157">The command seems to work well enough when we get this message.</t>
<t tx="ekr.20071028032929.158">Apparently I added shortcuts to the popup menu for the first time recently.

The "duplicate binding" logic would complain if popups actually tried to bind the shortcuts.

The fix: to add a dontBind param to createMenuEntries and set that param when creating the popup menu.</t>
<t tx="ekr.20071028032929.159">Replaced asserts with warnings.</t>
<t tx="ekr.20071028032929.160">Renaming bodyCtrl to body conflicted with a previous var named body.</t>
<t tx="ekr.20071028032929.161">putRefLine must return if putRefAt finds an error.</t>
<t tx="ekr.20071028032929.162">This "real" test exposed several problems:

- Only --script was recognized, not -script.
- Created global app.batchLog var.
- Changes to nullLog.__init__
	- inits app.batchLog if app.batchMode is true.
	- inits app.batchLog if app.batchMode is true (only if app.batchLog not inited).
- trace now _always_ uses print.  This prevents problems with traces in nullLog.
- es now uses app.batchLog.put if app.batchMode is true.
- nullGui.runMainLoop prints nothing unless app.batchLog is enabled.</t>
<t tx="ekr.20071028032929.163"></t>
<t tx="ekr.20071028032929.164"></t>
<t tx="ekr.20071028032929.165"></t>
<t tx="ekr.20071028032929.166"></t>
<t tx="ekr.20071028032929.167"></t>
<t tx="ekr.20071028032929.168"></t>
<t tx="ekr.20071028032929.169">This is a convenience routine for scripts.  It does not update the body pane.</t>
<t tx="ekr.20071028032929.170"></t>
<t tx="ekr.20071028032929.171">These exposed some further problems with the reorg.
</t>
<t tx="ekr.20071028032929.172"></t>
<t tx="ekr.20071028032929.173">Must call </t>
<t tx="ekr.20071028032929.174"></t>
<t tx="ekr.20071028032929.175">@nocolor

- (fixed) I noticed this in leoConfig.leo: config_encoding = iso-8859-1

- (fixed) ImportError: No module named leoDialog.

- (fixed) TypeError: about() takes exactly 2 arguments (1 given) (plugin_menu plugin)

- (fixed) mod_spelling plugin: several bugs.</t>
<t tx="ekr.20071028032929.176">It was very easy to do: just use the atFile.write to write into a file-like object.

The only other complication: we temporarily replace the root's body text with just the selected text.

Created app.scriptDict to communicate between the Execute Script command and the scripts being executed.

app.script["script1"] contains the original script.

app.script["script2"] contains the preprocessed script.  This will contain Leo sentinel lines.</t>
<t tx="ekr.20071028032929.177">Moved @others inside if "tk and 1:"</t>
<t tx="ekr.20071028032929.178"></t>
<t tx="ekr.20071028032929.179">This is a necessary precondition to supporting Unicode file and directory names properly.  It's not at all clear whether this is sufficient.  Anyway, these routines help clean up the code.

I took care that scripts import only those os_path_xxx routines that are necessary.  However, this process could have introduced bugs.</t>
<t tx="ekr.20071028032929.180">The find &amp; change scripts show the power of Leo's new script find/change commands.

Getting these scripts correct was a bit tricky.</t>
<t tx="ekr.20071028032929.181"></t>
<t tx="ekr.20071028032929.182"></t>
<t tx="ekr.20071028032929.183"></t>
<t tx="ekr.20071028032929.184"></t>
<t tx="ekr.20071028032929.185"></t>
<t tx="ekr.20071028032929.186"></t>
<t tx="ekr.20071028032929.187"></t>
<t tx="ekr.20071028032929.188"></t>
<t tx="ekr.20071028032929.189"></t>
<t tx="ekr.20071028032929.190">Due to moving and renaming some commands routines.</t>
<t tx="ekr.20071028032929.191">A simple bug due to the reorg.</t>
<t tx="ekr.20071028032929.192"></t>
<t tx="ekr.20071028032929.193">The new setEditVnode setter didn't set the global.</t>
<t tx="ekr.20071028032929.194">This is much more natural than the old way.</t>
<t tx="ekr.20071028032929.195">This removes a bit of a kludge.</t>
<t tx="ekr.20071028032929.196"></t>
<t tx="ekr.20071028032929.197">The biggest Aha was getting rid of redirection routines.

I could get rid of the tree redicrection routines if I used a proper tree class.  It's probably not worth it...</t>
<t tx="ekr.20071028032929.198">Moved get/setRealMenuName &amp; setRealMenuNamesFromTable.

It is really satisfying to get rid of these globals.  It makes the leoGlobals file much stronger.</t>
<t tx="ekr.20071028032929.199">These were hardly used anyway, and getting rid of them greatly clarifies the code.

These may create small problems in plugins...</t>
<t tx="ekr.20071028032929.200">- Key insight 1:  menus must belong to frames, _not_ to a gui.

- Key insight 2:  frame.menu.getFrame is gui-independed, so no need to "redirect"

- Key insight 3:  We prefer "binding" routines to "redirection" routines.

	Redirection routines just cause confusion and unnecessary work.

- Moved all global menu routines into gui-specific classes.

	This is an application of insight 3.  We want to bind things, not redirect calls.

- Moved all gui menu routines into gui-specfic classes.

	Same principle at work.  Much less work.

- Key insight 4:  Leo's core always calls frame.menu.x, _not_ app.gui.menu.x.

	For one thing, menu code must be frame-dependent, so a general app.gui.menu method WILL NOT WORK.

- Eliminated all frame "redirection" routines relating to menus.

I am very pleased with the result.  The new code is simpler and much less confusion.</t>
<t tx="ekr.20071028032929.201">There was a name colision between the code that used to be in the Frame class.</t>
<t tx="ekr.20071028032929.202"></t>
<t tx="ekr.20071028032929.203">Another problems due to the reorg.

Whole word searches did not succeed if the pattern was at the start or end of body text.

The getCharBeforeIndex and getCharAfterIndex routines must check for start and end of text.

While I was at it, I changed is_c_id so that it returns false if the argument is None.</t>
<t tx="ekr.20071028032929.204">Apparently this must be done after creating the dialog.</t>
<t tx="ekr.20071028032929.205">This was the result of the reorg.</t>
<t tx="ekr.20071028032929.206"></t>
<t tx="ekr.20071028032929.207"></t>
<t tx="ekr.20071028032929.208">- Eliminated app.gui.utils class (all code in app.gui class).

- Eliminated Focus routines in leoGlobals.py (now in app.gui class).</t>
<t tx="ekr.20071028032929.209"></t>
<t tx="ekr.20071028032929.210">At long last I realized that the gui-specific app.gui class should have an associated utils class to handle gui-specific routines that used to be in leoGlobals.py.

The pattern is:

	gu = app.gui.utils
	...
	gu.xxx(args)

It would be possible to define all the body wrapper methods in terms of the app.gui.utils class.  However, these routines naturally belong in the gui-specific class, so not as much is gained by doing this as might be imagined at first.

Anyway, the road is now clear to rewrite the wx gui plugin.  It will probably take only a few hours to do this!</t>
<t tx="ekr.20071028032929.211">This went remarkably smoothly.

The separation of gui-dependent from gui-independent code was usually trivial.

The Find classes were a bit harder: I created about a dozen tkinter wrapper routines so that all the utils could be moved into the base class.  This means that all the find logic is in the base class, and implementing a wx Find panel will be very easy.

The app.gui routines no longer require a "run" routine.  Instead, calling app.gui.createXPanel creates the panel and runs it.  All panels now support a "bringToFront" routine that is called to make the panel visible when the panel already exists.</t>
<t tx="ekr.20071028032929.212">- Moved recentFiles ivar from frame class to commands class.

- updateRecentFiles must call app.config.setRecentFiles with self.recentFiles as the arg, not c.recentFiles.</t>
<t tx="ekr.20071028032929.213"></t>
<t tx="ekr.20071028032929.214">What I did:

- Created wrappers for tk calls in core.
	- Removed all tk calls in undoRedoText
- Created wrappers for all tk calls in leoTkinterFrame
	(exception) OnInsertHeadlineTime uses v.edit_text
- Moved gui-independent commands code from leoTkinterFrame to leoFrame.
	No changes were needed!
- Changed x.commands to x.c for all classes x.
- Eliminated intermediate event handlers in frame class.
- Removed event param from all commands handlers.
	- Exception: the cut/copy/paste handlers must have an event param.
-Moved all non-gui commands into commands class.
	- Removed all frame routines that called commands.
	**There is now a clear separation between gui-dependent routines in leoFrame subclasses
	  and gui-independent routines in Commands class.
- Created stub routines for gui-dependent routines in leoFrame class</t>
<t tx="ekr.20071028032929.215">Rather than calling oops, it is so much more intelligent to call the corresponding bodyCtrl routine!</t>
<t tx="ekr.20071028032929.216"></t>
<t tx="ekr.20071028032929.217">This was very easy.  Almost all the menu code is now gui-independent.  This will make implementing the wx gui plugin _much_ easier.</t>
<t tx="ekr.20071028032929.218">Leo was mistaking the escaped percentile sign "\%" (backslash followed by
percentile) for the LaTeX comment delimiter (plain percentile sign).

The fix was:

1. Add "\\%" to the list of LaTeX keywords.
2. Create latex_special_keyword_characters = "@(){}%"
3. Use latex_special_keyword_characters when scanning for possible LaTeX keywords.
</t>
<t tx="ekr.20071028032929.219">The problem is that a successful search _must_ reset the selection range, so there isn't much point to this command.  Moreover, the Find All and Change All commands would loop if they aren't equivalent to the Find and Change commands when this option is in effect.  All in all, an almost useless option.  Too bad.</t>
<t tx="ekr.20071028032929.220"></t>
<t tx="ekr.20071028032929.221"></t>
<t tx="ekr.20071028032929.222">LeoPy.leo, The "Code" part only:

nodes,lines,pages, 2398, 79524, 2070

leoPlugins.leo:  Plugins &amp; scripts

nodes,lines,pages, 403, 10880, 298

LeoDocs.leo:  Users Guide

nodes,lines,pages, 379, 44606, 967</t>
<t tx="ekr.20071028032929.223"></t>
<t tx="ekr.20071028032929.224">"mbcs" probably will work only on Windows!</t>
<t tx="ekr.20071028032929.225">A recent change was done incorrectly.  There is no "find()" method: I changed it to findNext().</t>
<t tx="ekr.20071028032929.226"></t>
<t tx="ekr.20071028032929.227"></t>
<t tx="ekr.20071028032929.228"></t>
<t tx="ekr.20071028032929.229">A useful little utility to set up script-find/change.</t>
<t tx="ekr.20071028032929.230">This involved fixing a bug in idle_body_key so that the oldText param is honored if present.</t>
<t tx="ekr.20071028032929.231">The Script Change checkbox will have a few uses:

- It is replacement for a script that replaces the selection with text.  Yes, this script would be easy to write, but why not write it for the user?

Leo will execute a "default change script" when the Script Change checkbox is checked.  Simple and effective.</t>
<t tx="ekr.20071028032929.232"></t>
<t tx="ekr.20071028032929.233">Yes, we really do need script-based find/change.  The reason is that the find panel (and the associated find commands) is really the only good place to allow the user to do an interactive search.  Without this feature, all interactive find/change scripts would have to duplicate all the work of the find/change commands.

Still to do: help scripts do undo.

Conventions enforced by Leo:

- The app.searchDict ivar can be used for communication between find &amp; change scripts.
- app.searchDict["type"] contains either "find", "change", "findAll" or "changeAll".
- The Find All command executes the find script only once unless the script sets
  app.searchDict["Continue"] = true  (similarly for the change all command.
- The Find Then Change command executes the find command followed by the change command.
- The Change Script command supports undo if app.searchDict has the following entry after the script executes:
	{ "v" : v, "oldText" : oldText, "newText" : s }
	A "keys" key is an optional keyword dict to be passed to setUndoParams.

Leo actually doesn't do much:

- Leo doesn't clear app.searchDict.
	- However, a _script_ can
		a) init itself and
		b) bring up the find window (Eureka!)
- The find script is repsonsible for traversing the tree.
- The find script is responsible for highlighting the found text
  or otherwise indicating to the change script what the found text was.
  For example, the re find script can set app.searchDict["m"] to the match object.
- The find script must communicate with the change script.  Leo does nothing.
- The change script must change the text, usually by using v.setBodyStringOrPane.</t>
<t tx="ekr.20071028032929.234">@color

# Example showing how a script can init the Find panel

script = """from leoGlobals import *
c = top() ; v = c.currentVnode()
print `v`
v = v.threadNext()
c.selectVnode(v)"""

from leoGlobals import *
app.searchDict = {} # Communication between search &amp; change scripts
c = top()
c.script_search_flag = true
c.find_text = script
app.findFrame.init(c)
c.frame.OnFindPanel()
</t>
<t tx="ekr.20071028032929.235">Undoing Change All cleared the body pane.

The fix was simple: call setUndoParams instead of setUndoTypingParams in batchChange.</t>
<t tx="ekr.20071028032929.236"></t>
<t tx="ekr.20071028032929.237"></t>
<t tx="ekr.20071028032929.238">The node-only option wasn't working due to a bug in createFrame.

There still may be a problem with the interaction between Node-only,Change All and Undo.</t>
<t tx="ekr.20071028032929.239"></t>
<t tx="ekr.20071028032929.240">The fix was to open files with 'rb' instead of 'r'.  This probably should be done in more places.</t>
<t tx="ekr.20071028032929.241">This command checks for unused tnodeLists and checks the topology of all clones.</t>
<t tx="ekr.20071028032929.242">Hoisting itself is easy.  The biggest challenge was preventing moves outside the hoisted area, which would too confusing.</t>
<t tx="ekr.20071028032929.243"></t>
<t tx="ekr.20071028032929.244">- Added df.fileChanged flag.  This is set by replaceTargetFileIfDifferent.

- Separated the "written" logic from the "changed" logic.  We do an auto-save only if something has actually been changed.  The "written" logic is used to warn if a tree contains no @file nodes.</t>
<t tx="ekr.20071028032929.245"></t>
<t tx="ekr.20071028032929.246"></t>
<t tx="ekr.20071028032929.247">This is required for compatibility with Leo 3.x versions.</t>
<t tx="ekr.20071028032929.248">app.use_gnx controls whether we generate full gnx's or not.  At present there is no setting for this, so 4.1 really defines a new file format.

There was some weirdness: assignFileIndices didn't actually assign all file indices!  As a hack, putTnodeList also assigns file indices.  The mystery is solved.  Leo only clears the tnodeList of roots when writing, so once a non-root node gets a tnode list it can stay a long time.  Probably should clear all non-root tnode lists, and this would slow things down.

Perhaps a script could do the job?</t>
<t tx="ekr.20071028032929.249"></t>
<t tx="ekr.20071028032929.250"></t>
<t tx="ekr.20071028032929.251">The state of frame.controlKeyIsDown is not always correct.  I added bindings to the hidden root window to try to catch this.  This may not be a good idea...</t>
<t tx="ekr.20071028032929.252">- Added config_encoding setting to specify the encoding of leoConfig.txt.
- Converted all options to Unicode when reading leoConfig.txt.
- Converted all options to config.config_encoding when writing leoConfig.txt.</t>
<t tx="ekr.20071028032929.253"></t>
<t tx="ekr.20071028032929.254">- Replaced all references in colorizer to bodyCtrl by body.x.
- Removed colorizer.bodyCtrl ivar.
- Created colorizer.body ivar.</t>
<t tx="ekr.20071028032929.255">This removes all possibility that call set_focus from Leo's core will cause problems.

Actually though, Leo's core calls no focus routines, so there should be no problems.</t>
<t tx="ekr.20071028032929.256"></t>
<t tx="ekr.20071028032929.257">Create new Idle-time and clipboard routines in leoGui and leoTkinterGui classes.  Also updated wx plugin.</t>
<t tx="ekr.20071028032929.258"></t>
<t tx="ekr.20071028032929.259"></t>
<t tx="ekr.20071028032929.260"></t>
<t tx="ekr.20071028032929.261"></t>
<t tx="ekr.20071028032929.262"></t>
<t tx="ekr.20071028032929.263"></t>
<t tx="ekr.20071028032929.264">What I did:

- assignFileIndices &amp; compactFileIndices now are identical.

- putVnode now assigns vnode indices to _all_ tnodes.
	(not all of them may be written, but that doesn't matter)

- putVnode no longer writes the "C" (cloned) attribute.

- finishPaste now _reallocates_ tnode indices in all pasted nodes.  This fixes a major copy/paste bug.  Failure to do this would have created "false clones": hidden clones that would show up when the file was read again.</t>
<t tx="ekr.20071028032929.265"></t>
<t tx="ekr.20071028032929.266">The root wasn't being set properly because of a missing break statement.</t>
<t tx="ekr.20071028032929.267"></t>
<t tx="ekr.20071028032929.268"># Changed col= to column= in several places.
# Changed @file to @file-nosent mod_autosave.ini.</t>
<t tx="ekr.20071028032929.269">The code now uses updateBodyPane as before.</t>
<t tx="ekr.20071028032929.270">We don't have to mess with the ending selection for reformatParagraph because the shift commands now properly restore the selection.</t>
<t tx="ekr.20071028032929.271"></t>
<t tx="ekr.20071028032929.272">This is a bit kludgy, due to Tk weirdnesses.  I don't think it can be helped...</t>
<t tx="ekr.20071028032929.273"></t>
<t tx="ekr.20071028032929.274">This now preserves trailing newlines correctly.  Far from intuitive.</t>
<t tx="ekr.20071028032929.275">Unlike using string.split and string.join, these preserve the state of the trailing newline.</t>
<t tx="ekr.20071028032929.276">Added -1c in setSelectionAreas and getSelectionLines.

Tk's selection mechanism isn't great here.  I want to select to the end of the line, and if I specifing x lineend the cursor actually gets placed at the start of the next line!</t>
<t tx="ekr.20071028032929.277"></t>
<t tx="ekr.20071028032929.278">The code was mistakenly calling frame.destroySelf() if the file could not be opened.  This is always wrong.

While I was at it, I added an except IOError: clause that simply reports that the file could not be opened.

I really should create a wrapper for file to handle the except IOError: case...</t>
<t tx="ekr.20071028032929.279"></t>
<t tx="ekr.20071028032929.280">"idle" hooks must test app.initing before calling app.forceShutdown().
</t>
<t tx="ekr.20071028032929.281"></t>
<t tx="ekr.20071028032929.282"></t>
<t tx="ekr.20071028032929.283">This will allow me to define frame.body as an instance of the leoTkinterBody class.</t>
<t tx="ekr.20071028032929.284"></t>
<t tx="ekr.20071028032929.285">This removes some of the frame details from the app class.

As a result, several app methods went away.</t>
<t tx="ekr.20071028032929.286">- Added new getters and setters to leoTkinterFrame.

- The following classes will soon become tkinter classes, so references to top are not important:

LeoColorPanel, LeoColorNamePanel, leoCompare, leoDialog, leoFind, leoFont, leoPrefs</t>
<t tx="ekr.20071028032929.287">- Removed v.iconx and vicony from Leo's core.
	- Added default args in tree.drawIcon() so Leo's core doesn't know about the ivars.

- tree.drawIcon is now the only routine that accesses these ivars!</t>
<t tx="ekr.20071028032929.288">
- tkinterTree now injects callbacks into vnode class.
- leoFrame.py now contains base classes named leoFrame, leoBody, leoLog and leoTree.
- Renamed present LeoFrame class to leoTkinterFrame and move it to leoTkinterFrame.py.
- Renamed present leoTree class to leoTkinterTree and move it to leoTkinterTree.py.</t>
<t tx="ekr.20071028032929.289"></t>
<t tx="ekr.20071028032929.290"></t>
<t tx="ekr.20071028032929.291"></t>
<t tx="ekr.20071028032929.292">- Simplified undoReplace code &amp; removed asserts.
- The text param is no longer used and could be removed.

Undo tests:

(passed) Read @file Nodes.
(passed) Import Derived Files

(passed) Extract Section
(passed) Extract Section Names.
(passed) Extract

(passed) Convert Tabs &amp; Convert All Tabs.
</t>
<t tx="ekr.20071028032929.293"></t>
<t tx="ekr.20071028032929.294"></t>
<t tx="ekr.20071028032929.295">This is too distracting while typing the directive.</t>
<t tx="ekr.20071028032929.296">@nocolor

The following appears in run() in leo.py:

@color

doHook("start1")
if app.killed: return # 10/15/03: allows the plugin to kill the app.</t>
<t tx="ekr.20071028032929.297">This command was not taking into account the optional -ver= part of the @+leo sentinel.</t>
<t tx="ekr.20071028032929.298">The command now looks at joined nodes if no ancestor @file node.</t>
<t tx="ekr.20071028032929.299"></t>
<t tx="ekr.20071028032929.300"></t>
<t tx="ekr.20071028032929.301"></t>
<t tx="ekr.20071028032929.302"></t>
<t tx="ekr.20071028032929.303">- Replaced all calls to v.copyTree related to undo by c.undoer.saveTree.

- Hacked u.undoReplace to handle tuple returned by u.saveTree.

- Fixed bugs in Convert All Blanks and Convert All Tabs routines.
	- These routines call convertBlanks and convertTabs as helpers.
	- Added arg to convertBlanks and convertTabs controlling whether these routines set undo state.
</t>
<t tx="ekr.20071028032929.304"></t>
<t tx="ekr.20071028032929.305"></t>
<t tx="ekr.20071028032929.306"></t>
<t tx="ekr.20071028032929.307">@language elisp
@color

(defun abc 'a "abc
xyz" cons)</t>
<t tx="ekr.20071028032929.308">Must call c.initAllCloneBits.</t>
<t tx="ekr.20071028032929.309"></t>
<t tx="ekr.20071028032929.310">This is a temporary expedient.  Probably using ch.isalpha() would be better</t>
<t tx="ekr.20071028032929.311">When doing a back scan we must test for the start of the text _after_ looking for brackets.</t>
<t tx="ekr.20071028032929.312"></t>
<t tx="ekr.20071028032929.313"></t>
<t tx="ekr.20071028032929.314">This was tricky to get right:

- There are several calls to after_idle(idle_body_key), so which gets scheduled is a matter of timing.  To handle that I added the tree.forceFullRedraw() routine.

- The undo/redo code also recolors the text.  Added a new param to undoRedoText so that it could force a full redraw after cut/paste.
</t>
<t tx="ekr.20071028032929.315">The new code is now guaranteed to go to the proper node of the outline.  However, @doc parts may disrupt line counts within a node.</t>
<t tx="ekr.20071028032929.316"></t>
<t tx="ekr.20071028032929.317"></t>
<t tx="ekr.20071028032929.318">Somehow a number of calls to c.initJoinedCloneBits got omitted.</t>
<t tx="ekr.20071028032929.319">vnode attributes would typically be used for things like marks or additional icons.

tnode attributes would typically be used for anything associated with shared headline or body text.</t>
<t tx="ekr.20071028032929.320">tkinterGui.destroy must call frame.top.destroy.</t>
<t tx="ekr.20071028032929.321"></t>
<t tx="ekr.20071028032929.322"></t>
<t tx="ekr.20071028032929.323">The code was attempting to reference an ivar.  I placed sentinelNameDict inside sentinelName() and referenced it directly.</t>
<t tx="ekr.20071028032929.324">This is required so that attributes get set in the leoApp object rather than the proxy object.</t>
<t tx="ekr.20071028032929.325"></t>
<t tx="ekr.20071028032929.326"></t>
<t tx="ekr.20071028032929.327"></t>
<t tx="ekr.20071028032929.328">This is a big step forward.  newLeoCommanderAndFrame provides a place to explore the complexities of initializing LeoFrames and their commanders.

newLeoCommanderAndFrame does the following.  Order is _crucial_:

- first creates an "empty" frame first to pass to the commanders.  This was an Aha!
- then creates the commander and all subcommanders.
- then calls the new frame.finishCreate routine to create the actual frames.
- finally calls c.undoer.clearUndoState(), which requires that menus have already been created.

The present code should be moved to the tkinterGui class.</t>
<t tx="ekr.20071028032929.329">Leo now warns if it can't find either the Icons directory or the LeoApp16.ico icon in that directory.</t>
<t tx="ekr.20071028032929.330"></t>
<t tx="ekr.20071028032929.331"></t>
<t tx="ekr.20071028032929.332"></t>
<t tx="ekr.20071028032929.333"></t>
<t tx="ekr.20071028032929.334"></t>
<t tx="ekr.20071028032929.335"></t>
<t tx="ekr.20071028032929.336">This is much more natural and less cluttered.</t>
<t tx="ekr.20071028032929.337">There were bugs involving the c.pattern_match_flag and c.suboutline_only_flag.

The present code is way too fragil and clumsy.  I plan to rewrite it completely when the configuration logic is redone.

Also, the present code using only a single copy of leoConfig.txt, so changing a setting in one .leo file may change settings in other .leo files.</t>
<t tx="ekr.20071028032929.338">@nocolor

Class level-code after the method definitions was dropped:

@color

class someclass:
	def __init__(self):
		pass

	# this code is dropped
	class_var = None

def some_proc():
	pass</t>
<t tx="ekr.20071028032929.339"></t>
<t tx="ekr.20071028032929.340">allow_clone_drags = 1
# 1: Allows control-dragging to create clones.
# 0: All drags move nodes.
# See also: look_for_control_drag_on_mouse_down
# Setting this setting to 0 allows Leo to be used on Aqua.

enable_drag_messages = 1
# 1: Tell whether drags will move nodes or clone nodes.
# 0: Don't issue such messages.</t>
<t tx="ekr.20071028032929.341">The read code now clears the dirty bit in the root vnode before looking for changed text.

While I was at it, I moved some of the dirty bit logic into getLeoFile.  This makes all read commands work the same.</t>
<t tx="ekr.20071028032929.342">Fixed Go To Outline command so it doesn't crash on 4.0 files.  More work is needed:

- There are "off-by-one" errors.
- It is possible that a complete rewrite in the 4.0 case would be significantly better.</t>
<t tx="ekr.20071028032929.343">This was easy: just write a newline and an @nonl sentinel if the text does not end in a newline.

Compare with the messy 3.x code: a huge simplification.</t>
<t tx="ekr.20071028032929.344">The reason this was so strange is that the at.sentinels ivar was not initialized properly, either in the the old or new classes.  Usually this ivar is set properly (to true) because the _preceding_ file is an @file node that does init the ivar to true.

So the fix was just to set self.sentinel = true in new_df.rawWrite and old_df.rawWrite</t>
<t tx="ekr.20071028032929.345"></t>
<t tx="ekr.20071028032929.346"></t>
<t tx="ekr.20071028032929.347">Again, this wasn't an error, and it was confusing.</t>
<t tx="ekr.20071028032929.348">This wasn't a bug, but it was quite confusing.</t>
<t tx="ekr.20071028032929.349">This avoids overriding the base putSentinel routine with a routine with a different signature.

This argument was never used anyway.</t>
<t tx="ekr.20071028032929.350">This avoids overriding the base scanText routine with a routine with a different signature.</t>
<t tx="ekr.20071028032929.351">leo.py

- Added leoDialog and traceback to import list.
- Removed app args from createFrame and initSherlock.

leoApp

- Changed tList = [] to tDict = {}
- Removed app.finishCreate.

- leoCommands

- Removed some unused local vars in Convert Blanks/Tabs and Reformat Paragraph commands.

leoCompare

- Removed import leoApp, leoCommands from run() method.

leoFileCommands

- Removed unused self.a ivar.
- Removed unused first line below in getPrefs:
	s = string.lower(name)
	language = string.replace(name,"/","")

leoFrame:

- removed some imports from inside createNewMenu and deleteMenuItem.  Plugins should not need these.

- Removed unused vars:
	changed: &lt;&lt; read optional version param &gt;&gt;
	changed: old_df.readOpenFile
	changed: scanText
	changed: &lt;&lt; Test for @path &gt;&gt;
	changed: &lt;&lt; compute relative path from s[k:] &gt;&gt;
	changed: putDocPart (3.x)
	changed: putCodePart &amp; allies
	changed: new_df.readOpenFile
	changed: nodeSentinelText
	changed: &lt;&lt; write then entire @file tree &gt;&gt; (4.x)

leoGlobals:

- Removed unused vars in
	scanAtTabwidthDirective,skip_braces,skip_php_braces,skip_pp_part,isValidEncoding
	&lt;&lt; Set local vars &gt;&gt;
	&lt;&lt; compute relative path from s[k:] &gt;&gt;

leoGui

- Changed self.defaultFont to app.config.defaultFont in getFontFromParams.
- Added leoFrame to import list.

leoNodes

- Fixed real bug in appendStringToBody.
	- The code used none instead of None: changed test just to if not s: return

leoPlugins

- Removed import sys from loadHanders()

leoTree

- Disabled unused call to canvas.find_closest in OnContinueDrag.  Maybe this will help performance?</t>
<t tx="ekr.20071028032929.352">Fixed:

c:\prog\leoCVS\leo\src\leoFileCommands.py:814: Local variable (config) not used
c:\prog\leoCVS\leo\src\leoImport.py:994: Local variable (c) not used
c:\prog\leoCVS\leo\src\leoCompare.py:707: Local variable (c) not used
c:\prog\leoCVS\leo\src\leoCompare.py:707: Local variable (cmp) not used
c:\prog\leoCVS\leo\src\leoFontPanel.py:155: Local variable (c) not used
c:\prog\leoCVS\leo\src\leoApp.py:224: Local variable (tList) not used
c:\prog\leoCVS\leo\src\leoTree.py:1512: Parameter (v) not used (createPopupMenu)
c:\prog\leoCVS\leo\src\leoTree.py:1603: Parameter (v) not used (showPopupMenu)
c:\prog\leoCVS\leo\src\leoApp.py:365: No module attribute (leoID) found (remove app.setLeoId)</t>
<t tx="ekr.20071028032929.353"></t>
<t tx="ekr.20071028032929.354">- Changed app().x to app.x everywhere.

- Changed a.x to app.x everywhere, and eliminated the assignments a = app()

This paves the way to use the app.gui.x pattern more widely.

I did this now so that I could check this with Pychecker: I must run Pychecker anyway so this kills two birds with one stone.
</t>
<t tx="ekr.20071028032929.355"></t>
<t tx="ekr.20071028032929.356">The reason app() is needed is that it's definition doesn't change, even though what it returns does change during startup.

The problem with using a global app var is that from leoGlobals import * picks up and _caches_ the _uninitialized_ value.  Setting leoGlobals.app in the startup logic does not affect all the cached values.

The only way to prevent this would be be avoid importing any of Leo's modules until after the app object has been created.  This looks impossible, and it would be very brittle even if it were possible.

I _really_ would like from leoGlobals import app to work, but how to delay the import until later?</t>
<t tx="ekr.20071028032929.357">These routines now do the following:

1. Print a warning message if their internal string representation is not a unicode string.

2. Convert their results to unicode.</t>
<t tx="ekr.20071028032929.358">The tnode ctor now ensures that headline and body text are converted to Unicode using app.tkEncoding.</t>
<t tx="ekr.20071028032929.359">This was never needed, and removing it prepares to change app from a function to a global var.
</t>
<t tx="ekr.20071028032929.360"></t>
<t tx="ekr.20071028032929.361">1. Called getAllText in the following routines:

colorizeAnyLanguage
convertAllBlanks,convertAllTabs,extract,extractSection,extractSectionNames
OnExecuteScript

2. Called getSelectedText in the following routines:

OnExecuteScript

3. Called x = toUnicode(s,app().tkEncoding) in the following routines after a call to t.get(...)

bound_paragraph,getBodyLines,reformatParagraph
OnReturnKey
OnFindMatchingBracket,findMatchingBracket
updateStatusRowCol
changeAll,findAll
&lt;&lt; test for whole word match &gt;&gt;</t>
<t tx="ekr.20071028032929.362">Previously, nothing was printed if </t>
<t tx="ekr.20071028032929.363">Created new LeoApp16.ico icon w.wm_iconbitmap().

The old code still works with Python 2.2.</t>
<t tx="ekr.20071028032929.364"></t>
<t tx="ekr.20071028032929.365">All the real code has now been moved from leoGlobals.py to leoGui.py.</t>
<t tx="ekr.20071028032929.366"></t>
<t tx="ekr.20071028032929.367"></t>
<t tx="ekr.20071028032929.368">This is the foundation for "foreign" guis.</t>
<t tx="ekr.20071028032929.369"></t>
<t tx="ekr.20071028032929.370"></t>
<t tx="ekr.20071028032929.371">After the 4.0 beta 1 release I changed the default so that _new_ format derived files are written if leoConfig.txt does not exist.</t>
<t tx="ekr.20071028032929.372"></t>
<t tx="ekr.20071028032929.373"></t>
<t tx="ekr.20071028032929.374">This allows the caller to do an auto-save only if something was really written.</t>
<t tx="ekr.20071028032929.375">When I first tried to open LeoPy.leo after writing all @file nodes (With the Write @file Nodes command) I got a

"No joinList for tnode" message.

What I did:

1. Error recovery worked perfectly.  No damage was done!

2. getLeoFile must call setAllJoinLinks _before_ reading @file nodes so that findChild will see a valid joinList.

	- This is perfectly safe in 4.0 because reading _never_ creates vnodes or alters vnode links.

3. writeAtFileNodes now does an auto-save.</t>
<t tx="ekr.20071028032929.376"></t>
<t tx="ekr.20071028032929.377"></t>
<t tx="ekr.20071028032929.378"></t>
<t tx="ekr.20071028032929.379"></t>
<t tx="ekr.20071028032929.380">The output is the same in both the old and new versions.</t>
<t tx="ekr.20071028032929.381"></t>
<t tx="ekr.20071028032929.382">findChild now calls at.readError when t.joinList is None so reading will stop immediately without crashing.</t>
<t tx="ekr.20071028032929.383">@+doc and @+at sentinels indicate trailing whitespace.

It is crucial that whitespace is _always_ handled correctly.</t>
<t tx="ekr.20071028032929.384">This didn't do anything...</t>
<t tx="ekr.20071028032929.385">Must be done to clear tnodeList in the .leo file.  This allows the user to create a 3.x compatible .leo file.</t>
<t tx="ekr.20071028032929.386"></t>
<t tx="ekr.20071028032929.387"></t>
<t tx="ekr.20071028032929.388">I was surprised that the top-level class was a subclass of oldDerivedFile.  This isn't really good.

The first step of separating the class was to make the sentinel constants global to the module.  This required substantial changes.

After that, I separated the atFile class just by providing the initIvars and readLine routines.  To make readLine work I had to init self.encoding.  That's all!

Derived classes must follow base classes in the module, so I changed the top-level node to force the correct order regardless of node order.</t>
<t tx="ekr.20071028032929.389">Changed made:

1. Look ahead in putDocLine to preserve additional leading whitespace.
2. Do _not_ eliminate newline in readLastDocLine.  That must be done only by @nonl logic.

Note:  The code can not do a perfect job of restoring whitespace: it can not distinguish between @ and @space on a line by itself.  However, this construction is rare, and there really is no difference between them.</t>
<t tx="ekr.20071028032929.390"></t>
<t tx="ekr.20071028032929.391">The code calls at.writeAll(writeAtFileNodesFlag=true) to write all nodes in the selected tree.</t>
<t tx="ekr.20071028032929.392">Handling @first and @last is actually quite subtle, and the old code handles the job correctly.

getAtFirstLastLines simply couldn't cut it.  Thanks again to Dave Hein.</t>
<t tx="ekr.20071028032929.393">This must be done to preserve the tnodeList.</t>
<t tx="ekr.20071028032929.394">This code hasn't been tested yet.

- Don't change body text if a) @last and b) only difference is last newline.</t>
<t tx="ekr.20071028032929.395">This is a big step forward:  it eliminates some nasty modes.

- scanHeader returns flag instead of setting ivar.
- Write code uses config.write_old_format_derived_files.</t>
<t tx="ekr.20071028032929.396">Both the old and new write code does this.</t>
<t tx="ekr.20071028032929.397">This is too annoying during testing.</t>
<t tx="ekr.20071028032929.398">We no longer need this: the write_old_format_derived_files setting is enough to disable new writes.

In other words, the transition to 4.0 has begun!</t>
<t tx="ekr.20071028032929.399">This is the clean way of setting the default using the config.write_old_format_derived_files setting.</t>
<t tx="ekr.20071028032929.400">This is the clean way of forcing writes using old or new format.</t>
<t tx="ekr.20071028032929.401">findChild(4.0) and createNthChild (3.x) both now call v.t.setVisited.  The code in top_df.read warns if any non-empty node is unvisited.

This check, and the check that headlines match pretty much guarantees that out-of-synch outlines will generate errors.  In that case, there is no need a gnx timestamp in @+leo sentinels!</t>
<t tx="ekr.20071028032929.402"></t>
<t tx="ekr.20071028032929.403">These changes made in leoPlugins.leo (use_gnx) first.  They will be moved into LeoPy.leo soon.

What I did:
	- Removed gnx's for now (maybe forever?)
	- Eliminated use_gnx and using_gnx code from new read code.
	- All old read/write routines pass.
	- Fixed a bug in old write code(!!) @verbatim was not output correctly!
	- Created top_df.scanDefaultDirectory and top_df.error.
		- We must have this in order to open files in the proper directory.
	- Replaced calls to at.init_ivars by df.init_ivars
	- Created new_df.raw_write
	- Create top_df write routines.
	- Created class topLevelDerivedFileCommands
	- Created class oldDerivedFile
	- Created class newDerivedFile(oldDerivedFile)
	- Removed all error recovery logic from old read code.
	- Replaced structureErrors ivar with errors ivar.
	- Old read code now sets t.tempBodyString.
	- Move all common read code into top_df.read.
</t>
<t tx="ekr.20071028032929.404">- Moved setLeoID into leoApp.py
- Moved nodeIndices class into leoNodes.py.
- Moved askLeoID into leoDialogs.py
- Eliminated myTnode class.
- Moved myFrame methods into leoFrame.py and eliminated myFrame.
</t>
<t tx="ekr.20071028032929.405"></t>
<t tx="ekr.20071028032929.406"></t>
<t tx="ekr.20071028032929.407"></t>
<t tx="ekr.20071028032929.408"></t>
<t tx="ekr.20071028032929.409"></t>
<t tx="ekr.20071028032929.410"></t>
<t tx="ekr.20071028032929.411"></t>
<t tx="ekr.20071028032929.412"></t>
<t tx="ekr.20071028032929.413">tnodeList must be a list of tnodes, _not_ a list of tnode indices.

Indices may be reassigned, tnodes won't.

The _only_ place that an index is proper is in the file format itelf.</t>
<t tx="ekr.20071028032929.414">The script is called "Script to compare 3.x and 4.x derived files" in test.leo.
</t>
<t tx="ekr.20071028032929.415">The bug was in directiveKind.  There are two ways for the code to recognize @others.  After inserting the second way, I mistakenly commented out the first way (by commenting out @others in the table).</t>
<t tx="ekr.20071028032929.416"></t>
<t tx="ekr.20071028032929.417"></t>
<t tx="ekr.20071028032929.418"></t>
<t tx="ekr.20071028032929.419"></t>
<t tx="ekr.20071028032929.420">The new version of putLeadInSentinel works as follows:

1. It calls at.putIndent(at.indent) followed by the leading whitespace in the outline line.

The effect of this is

a) to align the @ws sentinel with the following sentinel and
b) to preserve the "spelling" of the leading whitespace on the line.

2. N.B. The calls to putLeadInSentinel happen _before_ at.indent is changed as the result of the leading whitespace. 

Again, this is so that putLeadInSentinel can preserve the spelling of whitespace.

3. The contribution of the @ws sentinel is the _difference_ between the value of at.indent when the @ws sentinel is being read and the actual whitespace on the line.  Again, we do this to make the derived file look better.</t>
<t tx="ekr.20071028032929.421">This makes the @nl look better, and has no other effect.</t>
<t tx="ekr.20071028032929.422">- Special case code for blank lines.
- Created putBlankDocLine.</t>
<t tx="ekr.20071028032929.423"></t>
<t tx="ekr.20071028032929.424"></t>
<t tx="ekr.20071028032929.425"></t>
<t tx="ekr.20071028032929.426"></t>
<t tx="ekr.20071028032929.427">I added this code to the "main" line for upward compatibility with 4.0.  The main line code does nothing with the new tnodeList attribute as yet.</t>
<t tx="ekr.20071028032929.428">This method now uses the tnode list to find the indicated tnode.  It also checks the headline.</t>
<t tx="ekr.20071028032929.429"></t>
<t tx="ekr.20071028032929.430">The code that reads the new tnodeList attribute of vnodes is contained in the "main line" code, i.e., in LeoPy.leo.  This means that Leo will always be able to read (and ignore) the tnodeList attribute.

The code that writes the attribute is part of the use_gnx plugin.

The tnodeList returns a tnode, not a vnode, so it makes sense to keep track of at.t not at.v.
</t>
<t tx="ekr.20071028032929.431">- The new code now hanles the basic cases properly.

- Added @nl sentinel to indicate whether a section ref should be followed by a newline.

- The read code now sets v.t.tempBodyString instead of call v.setBodyStringOrPane.  This is a major advance in error recovery:  nothing at all changes if errors happen.

What I did earlier:
	- Removed @+body and @-body
	- Don't write organizer nodes in @others</t>
<t tx="ekr.20071028032929.432"></t>
<t tx="ekr.20071028032929.433"></t>
<t tx="ekr.20071028032929.434">This has been changed in Python 2.3 and it probably wasn't ever a good idea...</t>
<t tx="ekr.20071028032929.435"></t>
<t tx="ekr.20071028032929.436">This removes a warning new in Python 2.3.
</t>
<t tx="ekr.20071028032929.437"></t>
<t tx="ekr.20071028032929.438"></t>
<t tx="ekr.20071028032929.439"></t>
<t tx="ekr.20071028032929.440">However, no change was required to cutomizing.html.  In other words, the online description of plugins and hooks was already good.</t>
<t tx="ekr.20071028032929.441"></t>
<t tx="ekr.20071028032929.442">@nocolor

Put install/uninstall in base directory of distribution

Put leo-script.txt goes in ./scripts/install/leo-script.txt
</t>
<t tx="ekr.20071028032929.443">The new values are:

"initial_window_height" : 600, # 7/24/03: In pixels.
"initial_window_width" :  800, # 7/24/03: In pixels.</t>
<t tx="ekr.20071028032929.444"></t>
<t tx="ekr.20071028032929.445"></t>
<t tx="ekr.20071028032929.446"></t>
<t tx="ekr.20071028032929.447"></t>
<t tx="ekr.20071028032929.448">There was no way to remove a default shortcut so that no shortcut was used.

The problem:

You attempted to remove a shortcut merely by removing an entry in the shortcuts section of leoConfig.leo/.txt.  That doesn't work:  the default shortcut remained and conflicted with a new shortcut.  BTW, Leo does need defaults for when leoConfig.txt does not exist.

The workaround:

Specify in leoConfig.leo/.txt some shortcut to override the conflicting shortcuts.
The proper fixes (now on cvs):

1. Leo now sends a warning both to the console window (if any) and to the log pane when it detects a duplicate shortcut.

2. Leo now allows leoConfig.txt to remove the shortcut for a command by specifying None (case doesn't matter) as the value of the shortcut.</t>
<t tx="ekr.20071028032929.449"></t>
<t tx="ekr.20071028032929.450"></t>
<t tx="ekr.20071028032929.451"></t>
<t tx="ekr.20071028032929.452">These aren't great tests, and they do show that now exceptions are thrown in the colorizer.</t>
<t tx="ekr.20071028032929.453">Also fixed some bugs (missing commas) in the list of rebol keywords.</t>
<t tx="ekr.20071028032929.454"></t>
<t tx="ekr.20071028032929.455">This was a most irritating bug.

The problem was in tree.OnDeactivate.  The calls to tree.endEditLabel() and tree. self.dimEditLabel() were interfering with the double-click logic.

What I did:

- Changed tree.OnDeactivate so that it only tried to deactivate the headline if the focus was previously in the tree.  Simple, effective.

- Added get_focus to leoGlobals.py.

- Removed unused frame.active and frame.activeFrame ivars.
	
- Changed set_focus so it only call widget.focus_set if there has been a real change in focus.
	- This has no effect, and could cause problems due to bad params being passed.</t>
<t tx="ekr.20071028032929.456">Added openWithFileName to leoGlobals.py.

	- This allows startup code to create a frame without an existing frame.
	- frame.OpenWithFileName now just calls this global.

Changed startup code so that:

	- Only one window is ever created on startup.
	- Windows are not witdrawn when they are created.</t>
<t tx="ekr.20071028032929.457">This shows Leo's nav buttons and status line.</t>
<t tx="ekr.20071028032929.458"></t>
<t tx="ekr.20071028032929.459">Fixed minor bugs in convertAllBlanks and convertAllTabs (reported no change when there was a change.)</t>
<t tx="ekr.20071028032929.460">This constitutes a major changes to Leo's fundamental vnode code.  

v.copyTree now creates a free-standing tree that may be linked into an existing outline using any of the v.linkX routines.  This is a major simplification that was long overdue.

N.B.  Copied trees share tnodes with the original code.  It would be easy to make this optional, and at present all code expects tnodes to be shared.

N.B.  Nodes of the copied trees are _not_ joined to the original tree.  That is, the copied vnodes v do not appear in v.t.joinList.
</t>
<t tx="ekr.20071028032929.461">The following commands are affected:

Convert All Blanks, Convert All Tabs, Extract, Extract Names, Extract Section.

What I did:

- Rewrote undoer.undoReplace.
	- It is not enough to call createDependents or destroyDependents.
	- 

- Called setUndoParams with oldText, newText, oldSel, newSel params.
</t>
<t tx="ekr.20071028032929.462"></t>
<t tx="ekr.20071028032929.463">The new code assumes nothing about when event handlers get called.</t>
<t tx="ekr.20071028032929.464"></t>
<t tx="ekr.20071028032929.465"></t>
<t tx="ekr.20071028032929.466">- added set_focus and force_focus utilities for better tracing.
- changed drawText so it calls setNormalLabelState when v == editVnode.
	idle_redraw no longer interferes with the headline being edited.
- setNormalLabelState now selects all text and calls set_focus.
- added callers keyword param to trace.
- simplified c.insertHeadline: it no longer has to avoid redraws.</t>
<t tx="ekr.20071028032929.467">This must be done to plug a major security hole.
</t>
<t tx="ekr.20071028032929.468"></t>
<t tx="ekr.20071028032929.469">This was pretty easy.  What I did:

- Changed getTextSelection so that it returns a tuple (insert,insert) instead of (None,None) if the selection range is empty.  This does most of the work!  However, the changeSelection code must now explicitly test to see whether start==end

- Pass an oldSel param to most calls of onBodyChanged.

- Added a newSel param to onBodyChanged and idle_body_key.

- Forced the focus to the body pane after pressing undo/redo buttons in the Spell Checker.  This makes the selection visible.</t>
<t tx="ekr.20071028032929.470">Shift-Control-O was causing a crash.  Not surprising since it had no business in call OnOpenWith.

What I did:
	
- removed event param from OnOpenWith.
- Created an Open With Submenu in &lt;&lt; create the top-level file entries &gt;&gt;
	This has the effect of not allowing a shortcut for this menu.
- Use app().hasOpenWithMenu to enable or disable Open With menu.
- Removed Shift-Control-O setting in leoConfig.leo/.txt.</t>
<t tx="ekr.20071028032929.471"></t>
<t tx="ekr.20071028032929.472"></t>
<t tx="ekr.20071028032929.473">Made this change to the Color, Compare, Font, Prefs and Spelling panels.  However, this doesn't set the focus as I would like.</t>
<t tx="ekr.20071028032929.474">dict was being altered in a loop where it shouldn't be.  Changed the name of the var in the loop from dict to d.</t>
<t tx="ekr.20071028032929.475">Symptom: Sometimes the "reading" messages would not appear when reading an outline.

Cause: Several event handlers are called at unpredictable times during the load process.  These may try to reset the log.

Solution:

- create app.setLog, app.lockLog and app.unlocklog methods.
- call app.lockLog before opening an outline.</t>
<t tx="ekr.20071028032929.476">Changed destroyOpenWithFilesForFrame and createOpenWithTempFile so they don't loop on a list that is being modified.</t>
<t tx="ekr.20071028032929.477"></t>
<t tx="ekr.20071028032929.478"></t>
<t tx="ekr.20071028032929.479">@color

# Commanders and subcommanders.
class Commands (baseCommands): pass
class atFile (baseAtFile): pass
class fileCommands (baseFileCommands): pass
class leoImportCommands (baseLeoImportCommands): pass
class tangleCommands (baseTangleCommands): pass

# Helper classes.
class colorizer (baseColorizer): pass
class config (baseConfig): pass
class undoer (baseUndoer): pass

# Key data classes.
class LeoFrame (baseLeoFrame): pass
class leoTree (baseLeoTree): pass
class tnode (baseTnode): pass
class vnode (baseVnode): pass

# Dialogs and other panels
class leoColorPanel (baseLeoColorPanel): pass
class leoColorNamePanel(baseLeoColorNamePanel): pass
class leoComparePanel (baseLeoComparePanel): pass
class leoCompare (baseLeoCompare): pass
class leoFontPanel (baseLeoFontPanel): pass
class leoDialog (baseLeoDialog): pass
class LeoPrefs (baseLeoPrefs): pass
</t>
<t tx="ekr.20071028032929.480">- Made functions into class methods.
- Make sure to close pipes after every command.
- Rewrite local dictionary in alph order.
</t>
<t tx="ekr.20071028032929.481"></t>
<t tx="ekr.20071028032929.482">At present setup.py must be run from the top level leo directory.  Hopefully this will be fixed.

Also, the linux install script won't work.
</t>
<t tx="ekr.20071028032929.483">c:\prog\leoCVS\leo\src\leoAtFile.py:2791: Format string argument count (1) doesn't match arguments (2)

c:\prog\leoCVS\leo\src\leoFrame.py:976: No global (a) found

This may have been the cause of some problems with the log panel.

c:\prog\leoCVS\leo\src\leoNodes.py:1174: Parameter (encoding) not used

This may have been the cause of some "unicode" problems.</t>
<t tx="ekr.20071028032929.484">The old code had no chance of working.  I think I actually understand what is happening now...</t>
<t tx="ekr.20071028032929.485">The body_pane_wraps setting is used if neither of these directives is in effect.
</t>
<t tx="ekr.20071028032929.486"></t>
<t tx="ekr.20071028032929.487">Added code to check for errors in the table passed to createOpenWithMenuFromTable.</t>
<t tx="ekr.20071028032929.488">We have to do the &lt;&lt; set removeTrailing &gt;&gt; logic when the delete key is pressed, and that wasn't happening.

The new code now remembers properly when the user deletes a trailing newline.</t>
<t tx="ekr.20071028032929.489"></t>
<t tx="ekr.20071028032929.490">created frame.setInitialWindowGeometry.</t>
<t tx="ekr.20071028032929.491">1. Added destroy routines for all major classes

This allows most window objects to be garbage collected when a window closes.  In practice it is _very_ difficult to remove all references to all window objects.  Breaking those links "by hand" in the destroy routines is a more pragmatic approach.

The big drawback is that destroy methods must be updated when a new ivar is added to a ctor that refers to other objects.  In practice, such ivars aren't added often.

With these new routines in place Leo does, in fact, recycle most objects from windows when a window closes.  This plugs the last (relatively minor) leak in Leo.

2. Created a _general_ way of clearing all ivars of an object.

o.__dict__.clear() does the job!

3. Remvoed all destroy routines, replacing them by app.destroyAllWindowObjects().

This is a simple, effective, pragmatic approach, and it doesn't require changes when new ivars are added to ivars!</t>
<t tx="ekr.20071028032929.492"></t>
<t tx="ekr.20071028032929.493"></t>
<t tx="ekr.20071028032929.494">These are not needed now that Python has a gc that can recover cycles.

Everything should go away because:

- app().windowList no longer points to a frame.
- frame.top.destroy() eliminates all the Tk pointers.</t>
<t tx="ekr.20071028032929.495">I did the following:

- Searched for use_gnx, using_gnx, use_pre_4pt0_file_formats.
- Removed all 4.0 constants from &lt;&lt; atFile constants &gt;&gt;
- Removed the setting corresponding to use_pre_4pt0_file_formats config ivar.

As I was doing this I moved routines and code snippets into the Abandoned Code from 4.0 node.

This is a major step forward for Leo!  The code base is mostly back to 3.10 days, with some improvements to vnodes and tnodes.</t>
<t tx="ekr.20071028032929.496"></t>
<t tx="ekr.20071028032929.497"></t>
<t tx="ekr.20071028032929.498">Fractions cause problems in some locales.  The height/width params weren't used anyway!
</t>
<t tx="ekr.20071028032929.499">This was all that was needed to correct the problem with new windows.</t>
<t tx="ekr.20071028032929.500">- Added self.widgets list and associated logic in deleteBindings.

We can't rely on the Tk.Widget to delete the associated Python objects!

- Added printGarbage routine to leoGlobals.py.</t>
<t tx="ekr.20071028032929.501">This is significant for two reasons:

1.  It shows how to reduce the number of Tk widgets allocated to a constant (linear in size of the canvas).

2.  It shows that incremental drawing could be used with vxnodes.

This code took a lot of work.  Issues involving the scrollbar resulted in a two-pass drawing algorithm.  The first pass populates the canvas.  The second pass sets the visible area properly after the scrollbar is set properly.

The visual appearance of scrolling appears identical, regardless of whether incremental allocation is used.  This is an important result.

To enable incremental allocation of Tk widgets during redraws, set self.allocateOnlyVisibleNodes = true in tree.__init__.

Pros:
	
- substantially reduces the number of Tk widgets that get allocated.

Cons:
	
- More complex code (it appears solid)
- A two-pass screen redrawing algorithm (it appears fast enough)
- Not all nodes become visible immediately when sliding the scrollbar.
	This is mostly likely because the actual redrawing of the screen happens at idle time.</t>
<t tx="ekr.20071028032929.502">The new code is simple, elegant, efficient, flexible.  A good day.</t>
<t tx="ekr.20071028032929.503">Here are the results from running checkClones2Links script on this file:

multipleTargetsInDerivedFiles: 8

(fixed) class nodeIndices      (improperly duplicated in leoAtFile.py)
(fixed) frame.OpenWithFileName (improperly duplicated in Recent Files submenu)
(fixed) recentButtonCallback   (improperly duplicated in Mark/Goto submenu)

-- Used several times in same derived file.  Will this be valid in LeoN?

&lt;&lt; Append any unused text to the parent's body text &gt;&gt; (used several times in leoImport.py)
&lt;&lt; Check both parts for @ comment conventions &gt;&gt; (used several times in leoTangle.py)
&lt;&lt; Compare single characters &gt;&gt; (used several times in leoTangle.py)
&lt;&lt; Set the default directory &gt;&gt; (used several times in leoAtFile.py)

-- Used (properly) in two different derived files:

replacePatterns (used on purpose in setup.py and postSetup.py)

clonedAtFileNodes: 9

@file ../plugins/add_directives.py
@file ../plugins/french_fm.py
@file ../plugins/open_with.py
@file ../plugins/vim.py
@file ../plugins/xemacs.py
@file c:\prog\test\multiple.txt
@file-nosent nosentCloneTest.txt
@silentfile ../doc/PKG-INFO.TXT
@silentfile ../doc/README.TXT
</t>
<t tx="ekr.20071028032929.504"></t>
<t tx="ekr.20071028032929.505"></t>
<t tx="ekr.20071028032929.506">This code is extremely dangerous at present.</t>
<t tx="ekr.20071028032929.507"></t>
<t tx="ekr.20071028032929.508"></t>
<t tx="ekr.20071028032929.509"></t>
<t tx="ekr.20071028032929.510"></t>
<t tx="ekr.20071028032929.511"></t>
<t tx="ekr.20071028032929.512">This completely eliminates namespace polution and also simplifies tree.select.</t>
<t tx="ekr.20071028032929.513">Nav plugin now warns if icons do not exist.

Leo now destroys the Recent Nodes dialog when user hit the close button at the top of the window.

Leo updates the Recent Nodes panel only if it is visible.</t>
<t tx="ekr.20071028032929.514"></t>
<t tx="ekr.20071028032929.515">Created new nav_buttons plugin.  This plugin adds 4 new buttons to the icon area at the top of each Leo window:

- Back and Forward arrows that work like a typical web browser.  Clicking the back arrow button takes you to the last node in the tree you visited.  Clicking the forward arrow button moves you forward.  The forward arrow button is dimmed unless you have clicked the back arrow button recently.

- The Recent button opens a non-modal dialog showing all the nodes you have visited recently.  This dialog is updated cleanly by the tree.select method.  You will see this entries change dynamically.  There are buttons in this dialog for clearing individual entries or clearing all entries.  Double-clicking any entry in this dialog takes you to that node, as does clicking the Go button.

The entries in the Recent Nodes pane do _not_ correspond to the order implied by the Forward and Back arrows.  Rather, the most recently visited node is on top, followed by the next most recently visited node, and so on, with the additional feature that nodes appear only once in the list.

- The Marks button opens a non-modal dialog showing all marked nodes in the tree.  Marking or unmarking nodes in the tree adds or deletes entries from this dialog.  Double-clicking any entry in this dialog takes you to that node, as does clicking the Go button.

I think the Marks dialog will be more useful for most people, for the following reasons:
1. You get to choose the nodes that appear in the dialog (using the Mark and Unmark commands)
2. The nodes appear in outline order.

In addition, hypertext links now enabled by default.  Control-click any section reference to go to its definition.  I changed the colorer so that it does _not_ underline active hyperlinks in section reference.  If a section reference is underlined, it means the definition does _not_ exist.  Otherwise the section reference _does_ exist and control-clicking the reference takes you to the defining node in one of its descendents.

Still to do: extending the color_markup plugin so that it underlines hypertext links in comments, """ python strings and doc parts.

It was great fun doing this project: plugins rule!  However, I am not really convinced that these dialogs are actually going to get used all that much.  For me, gathering nodes together using clones is by far the best way to make sense of a complex project.

Anyway, the code looks robust and fairly complete.  I have no plans for any more hacking, though all sorts of additions are fairly obvious, including more buttons in the Marks window. 

What I did:

leoColor.py

- Hypertext links now enabled by default.  Control-click any section reference to go to its definition.

- Leo no longer underlines active hypertext links. 

- To do: http hypertext links in color_markup plugin?

leoCommands.py

- Added c.beadList &amp; c.beadPointer to implement browser-style forward and back buttons.  Adding these ivars to the commands class is reasonable because the Forward &amp; Back commands are now official Leo commands.

The logic for the Forward &amp; Back commands is similar to the "bead" scheme used by undo.  However, it is completely separate.  In particular, these commands are careful to check that a node actually exists in the present tree before going to it!  And the Recent Nodes dialog removes nodes that do not presently exist using the v.exists method.

- Added optional updateBeadList param to c.selectVnode.  This adds flexibility to how the Forward &amp; Back commands work: I'm not sure that Leo uses this flexibility at present.

leoDialog.py

Added three new classes to support Recent nodes and Marks listboxes: class listBoxDialog and two derived classes:
	
- class recentSectionsDialog (listBoxDialog):
- class marksDialog (listBoxDialog):

leoFrame.py

- Initialized bead logic in frame.__init__.  This is a kludge.  Beads should be a separate class.

- Added support for existing graphics to addIconButton. (different names for keyword args).

- Added Go Back and Go Forward commands (and related logic) renaming the old commands to Go To Prev Node and Go To Next Node.

leoNodes.py

- Added exists method.  This method is used to check (quickly!) whether v is in c's tree.  We need this logic because undo may have altered nodes that appear on the bead list.

leoTree.py

- Added support for Forward &amp; Back commands to tree.select after select2 hook.

- Added select3 so that plugins can call their own code following this new code.</t>
<t tx="ekr.20071028032929.516">Apparaently the zfill string method was added in Python 2.2.2.</t>
<t tx="ekr.20071028032929.517"></t>
<t tx="ekr.20071028032929.518">@color

I am uneasy about the security implications of having Leo execute script x if it is passed a "script:x" parameter.  Perhaps I am being over-cautious.

Anyway, there is no need for this machinery.  To create reference file for unit testing call leoUnitTest.createReferenceFiles in the old copy of Leo.  This only needs to be done once.

@color

if 0: # Just run this from the reference copy of Leo.
	import leoUnitTest
	leoUnitTest.createReferenceFiles()

if 0: # Not needed.  It does work, though.

	from leoGlobals import *
	import os

	os.spawnl(os.P_NOWAIT,"c:/python22/python.exe",
		"-i c:/prog/leoCVS/leo/src/leo.py",
		"script:leoUnitTest,createReferenceFiles")</t>
<t tx="ekr.20071028032929.519"></t>
<t tx="ekr.20071028032929.520">Using an idle hooks completely simplifies the code, and it means that Leo never slows down to update the area.</t>
<t tx="ekr.20071028032929.521"></t>
<t tx="ekr.20071028032929.522"></t>
<t tx="ekr.20071028032929.523"></t>
<t tx="ekr.20071028032929.524">Removed the ancient kludge for forcing the height &amp; width of f.  The code in leoFileCommands.getGlobals now works!

The reason that Leo was opening small windows without the height &amp; width params is that getGlobals was telling it to do so!

Changed leoConfig.leo/.txt to use 75 and 200 for the initial height and width.</t>
<t tx="ekr.20071028032929.525"></t>
<t tx="ekr.20071028032929.526">I replaced all the ivars with a dict and several lists.  This is much more clean.  However, the same idea isn't so good for the commands class: using individual ivars is much simpler.  Similar remarks apply to the Prefs panel.</t>
<t tx="ekr.20071028032929.527">destroyIconFrame
createIconFrame
insertButtonInIconFrame</t>
<t tx="ekr.20071028032929.528">This affect the Write Missing @file Nodes command.</t>
<t tx="ekr.20071028032929.529"></t>
<t tx="ekr.20071028032929.530"></t>
<t tx="ekr.20071028032929.531"></t>
<t tx="ekr.20071028032929.532">The new code uses three passes in colorizeAnyLanguage!

Pass 0:  The normal code.

insertWiki picture sets colorer.redoColoring = true if it is ever called in pass 0.  This ensures that the following two passes will be called.  If the body contains no images, the new code is equivalent to the old.

Pass 1:  Insert graphics into the body text.

We do this in a separate pass to simplify the following kludge.

Pass 2:  Insert dummy characters and recolor the text.

Images take up a real index, yet the get routine does not return any character for them!  We insert dummy blanks in s at the positions corresponding to each image to keep everything in synch.  We then recolor the line normally.

This three-pass algorithm appears to be robust.  In particular, it handles the following special cases:

- The user can invalidate an image name, requiring a full redraw.

- The user can delete an image itself, leaving the markup unchanged.  The image will reappear the next time Leo does a full redraw.

- An image may appear twice in the body text.

- The user may edit any line not containing a graphic without invoking passes 1 and 2.</t>
<t tx="ekr.20071028032929.533">	- Fixed bug: continued """ weren't colored properly when @markup wiki not in effect!

</t>
<t tx="ekr.20071028032929.534">There is now only a single entry point into Leo: the run() routine.

This routine uses an optional fileName arg.</t>
<t tx="ekr.20071028032929.535">- This supports the @markup wiki directive.

- It can add arbitrarily many directives.</t>
<t tx="ekr.20071028032929.536">Not yet: user directives for leoAtFile.py or leoTangle.py.</t>
<t tx="ekr.20071028032929.537">Created "init-color-markup" hook for use of markup plugins.

This allows the colorizer to completely recolor a node when the @markup directive changes.</t>
<t tx="ekr.20071028032929.538">Continued """ weren't colored properly when @markup wiki not in effect!
</t>
<t tx="ekr.20071028032929.539"></t>
<t tx="ekr.20071028032929.540">1.  Leo now scans all .py files in the plugins folder when looking for plugins.

Filenames need not start with mod_, and Leo scans only the plugins folder.

2. Replaced detailed loading message with a summary of the number of files loaded &amp; examined.

3. Added importFromPath in leoGlobals.py.

This encapsulates a lot of details, and makes it unnecessary to alter sys.path.

</t>
<t tx="ekr.20071028032929.541">1.  Changed handleLeoHook to doHook.

2. Changed most instances of:

  if doHook(...) == None:

to:

	if not doHook(...)

This works provided that doHook does not return a "significant" value.</t>
<t tx="ekr.20071028032929.542">- Converted wiki code to a plugin.  No need for config settings!

- Added code to parse wiki stuff in doc parts and comments.</t>
<t tx="ekr.20071028032929.543">Added the following stub hooks for customizing the outline pane:

	drawBox   doHook("draw-outine-box",tree=self,v=v,x=x,y=y)
	drawIcon  doHook("draw-outline-icon",tree=self,v=v,x=x,y=y)
	drawNode  doHook("draw-outline-node",tree=self,v=v,x=x,y=y)
	drawText  doHook("draw-outline-text-box",tree=self,v=v,x=x,y=y)
	drawTree  doHook("draw-sub-outline",tree=self,v=v,x=x,y=y,h=h,level=level)
	redraw    doHook("redraw-entire-outline",c=self.commands)

Conceivably it would be better for a plugin just to replace these routines.</t>
<t tx="ekr.20071028032929.544">I have found this command to be highly annoying and unwanted.</t>
<t tx="ekr.20071028032929.545"></t>
<t tx="ekr.20071028032929.546"></t>
<t tx="ekr.20071028032929.547">- Load plugins and execute hooks in alphabetical order.

- Created "new" hook.  Somewhat useful.

Created "create-optional-menus" hook: extremely useful.  The first stub hook.</t>
<t tx="ekr.20071028032929.548"></t>
<t tx="ekr.20071028032929.549">

Early this morning I uploaded the new 4.0 code base to cvs.  This is an important milestone in Leo's history.  I urge anyone using code on cvs to at least skim through this long posting.

1.  Code on cvs is safe and stable

AT PRESENT, the code on cvs reads and writes 3.x files just as before.   The code appears stable, which is not surprising because the new code is based on the old.  Very few changes were needed to handle the new file formats.  These changes are enabled when app().use_gnx is true. app().use_gnx is false on cvs now.

I think the present cvs code is safe and stable.  However, I _strongly_ recommend that you assume otherwise:  Please make backups of any files or folders affected by the new cvs code.

Most of the work required to read and write 4.x .leo and derived files is complete; there are only a few days work left before the transition to 4.x formats.  I do NOT recommend that you enable the new code; some file format changes are in store.  You will be warned when the transition to the new file formats happens on cvs.  This will be another major event: all sentinels will change.

2.  Code bases have merged

The code on cvs merges the 3.x and 4.x code bases.  In retrospect, I regret splitting the development.  It really didn't help.  In any event, there will be no more splits in development.

With the merged code base, one can easily imaging releasing both 3.x versions and 4.0 beta versions in parallel.  Indeed, the only difference between the two versions would be the setting of app().use_gnx.  Also note that even in the 4.0 final version you will be able to write 3.x files.  Just set use_pre_4pt0_file_formats = 1 in leoConfig.txt.

The latest cvs code assumes that leo folders contain the config, doc,  plugins, scripts and src subfolders.  The new version of the installer script, leo.nsi, found in LeoPy.leo, creates these folders.  See the diary entry for 5/12 in LeoPy.leo for a list of the changes made to support the new directory structure.

3.  Improved code base &amp; new invariant

I took the opportunity afforded by 4.0 to clean up the old code base in several important ways.  First, the new code uses proper Python lists to represent join lists.  This greatly clarifies the relevant sections of code, and may even provide a performance boost.  Secondly, tnodes now contain both headline and body text.   This change creates an important invariant:  vnodes with the same vnx's always point to tnodes with the same tnx's.  This invariant is vital to resolving conflicts properly.

4.  Prototype of graphics &amp; styled text

leoColor.py contains a prototype of code that allows wiki-style markup in body panes.  This is important work, because it tests Tk's abilities to handle styling and graphics in the highly dynamic environment that is Leo's body pane.  Some details:

- There are a few bugs left to fix, and it is clear that this prototype is a great success.  The combination of Python and Tk are easily up to the job.  The programming details are interesting, and not interesting enough to discuss here :-)  Look at the topic called (Graphics &amp; Styled Text: Wiki format) in LeoPy.leo if you are curious.

- The code that handles the wiki formatting is disabled at present on cvs.  To enable it, just change if 1: to if 0: in doWikiText.  It is quite safe to do so: the syntax colorer catches all exceptions.  The worst that can happen is that some of your text won't be colored properly.

- The present code only handles wiki markup in Python triple-quoted strings denoted by three double quotes.  Because wiki markup uses single quotes, it does not seem prudent to allow wiki formatting in ''' strings.  Still to do: allow wiki markup in doc parts and comments.  This will be easy enough.

- doWikiText at present only handles the following markup:

    __bold__,
    ''italics'' (two single quotes, not a single double quote!)
   {picture file=&lt;filename&gt;}
   ~~&lt;color specifier&gt;~~ 

To repeat: using wiki markup to denote styling and graphics is merely a prototyping expedient.  I'm not sure how to represent such information.  The great advantage of a text-based specification is that it doesn't change the rest of Leo _at all_.  In particular, I had a nice aha: we can use the Show Invisibles command to show or hide the wiki text.  When invisibles are hidden, all you see are the _effects_ of the wiki markup.  When invisibles are visible, you see the markup plus their effects.  No need for extra commands.

- rst is another alternative to wiki format.  I'll soon start another thread to discuss the pros &amp; cons.  Please don't vote here.

- Instead of the present hand-written parser, Leo should use an "official" parser for whatever markup is chosen.  However, this can wait.

5. To do

There are significant additional work to do before 4.0 final.  After 4.0 alpha 1 comes out (maybe in a week?), I plan to rewrite the code that reads .leo files.  The new code will use an xml parser (probably sax) to read .leo files rather than the present hand-written mess.  I have fairly high hopes that sax will significantly speed up the reading of .leo files themselves.  Note, however, that such tools can _not_ be used to read derived files because derived files are not xml files.

Edward</t>
<t tx="ekr.20071028032929.550">This required folder-by-folder copies, so it was potentially error prone.</t>
<t tx="ekr.20071028032929.551"></t>
<t tx="ekr.20071028032929.552">This cleans up the list of files being read.</t>
<t tx="ekr.20071028032929.553">These don't change often enough to warrant reading every time.</t>
<t tx="ekr.20071028032929.554"></t>
<t tx="ekr.20071028032929.555">1. Created config, doc, examples, plugins, scripts, src, test &amp; tools folders.  This really clarifies matters.

2. Removed the following files:

- nsi.leo file.  This was a duplicate of code in LeoPy.leo.  
- The following unused .bat files: bdist.bat, go.bat, help.bat, sdist.bat.
- The two resource files: leo.rc and leo.res.  These are for Delphi!

3. These changes required changes to:

- Actual code.  The following commands were affected:
	- The About Leo dialog (path to icon in dialog).
	- Tree drawing code (path to icons)
	- Open LeoDocs.leo and Open leoConfig.leo commands in help dialog.
	- Initialization in leoConfig.py.

Note: Tangle/Untangle will find tangle_done.py and untangle_done.py provided that the scripts folder is in sys.path.

- The leo.nsi script that creates leoinstall.exe.  This required considerable amount of work.

- Paths specified in @file nodes.

- All files in cvs.  The attic contains all the old files.  cvs contains new 1.1 versions of all code.  This is most unfortunate.  However, the cvs code started out with the 3.11.1 code base, so 4.0 changes will be visible.
</t>
<t tx="ekr.20071028032929.556">Sometimes the reading: @file messages were not showing up during Open commands. Perhaps the are differences in the events that caused app().log to be set to None, or to be set before the Tk text widget was initialized.  Could problems with configuration show up like this?  Or maybe it was just a weird Windoze bug...

Added code to force setting of app().log in OpenWithFileName.

If this bug shows itself again I'll add print code to show the following:

- The frame associated with app().log.
- The events that set app().log to something _other than_ None.</t>
<t tx="ekr.20071028032929.557"></t>
<t tx="ekr.20071028032929.558">Saving LeoPy.leo generated 46740 calls to v.threadNext!

It looks like optimizing threadNext would be useful.
There seems to be no need to optimize threadBack.</t>
<t tx="ekr.20071028032929.559"></t>
<t tx="ekr.20071028032929.560"></t>
<t tx="ekr.20071028032929.561">What I did:

- Replaced mFirstChild with mChildren.
- Partially replaced mBack and mNext fields.
- Assumed the existence of c.frame.dummyChildren array.

I abaondoned this code for the following reasons:

- The new code might be slower than the old code!

- mBack, mNext and mFirstChild will take less space than mChildren.

- Precomputing threadNext() and maybe threadBack() may be _much_ faster.</t>
<t tx="ekr.20071028032929.562"></t>
<t tx="ekr.20071028032929.563">In 4.0 we must have a single, global (per-outline) tnodesDict so that all joined vnodes in fact use the same tnode.

This dict must never be reinitialized!

*** N.B.: we create the sharing of the common tnode first, then create the join link later, at the end of getLeo2 or other top-level read routines.

</t>
<t tx="ekr.20071028032929.564">This actually may have found one broken clone.  It certainly did find a copy of code.</t>
<t tx="ekr.20071028032929.565">nodeAfterTree was being called too often.

Used same logic to delete tree after read errors that was used to delete tree when using gnx.  The old code called doDelete, and that was the cause of huge delays when there were read errors.

Removed the &lt;&lt; Handle all status bits &gt;&gt; logic from atFile.read.  There is no need for this!  The fileCommands logic sets the current node logic.</t>
<t tx="ekr.20071028032929.566">Eliminated awkward dummy nodes.</t>
<t tx="ekr.20071028032929.567"></t>
<t tx="ekr.20071028032929.568"></t>
<t tx="ekr.20071028032929.569"></t>
<t tx="ekr.20071028032929.570">What I did:

- Created fileCommands.setAllJoinLinks to create or update all join links.

- The fileCommands.getLeoFile and fileCommands.readAtFileNodes now contain:

self.setAllJoinLinks(c.rootVnode())
c.initAllCloneBits()

** Removed the code equivalent to setAllJoinLinks from atFile.read.

** Removed the code that scans the entire vnode tree for the current &amp; top attributes.
	The code _must_ set these without rescanning an entire derived file!

- Added atFileNodesFlag=true param to getLeoFile.

- Added partialFlag=false param to atFile.readAll.</t>
<t tx="ekr.20071028032929.571">More checks would be good.</t>
<t tx="ekr.20071028032929.572">This was easy to do because most code uses the v.headString() getter.
</t>
<t tx="ekr.20071028032929.573">The first version didn't work, and caused clones not to work!

This could have caused a major mess with Leo.py, but I reverted to a previous copy and I believe no clone links have been damaged.</t>
<t tx="ekr.20071028032929.574"></t>
<t tx="ekr.20071028032929.575">I'm not sure how an empty filename got passed to this routine, and it did happen.</t>
<t tx="ekr.20071028032929.576">See the (Rewriting joinList code) project for full details.

Examining the code revealed that the undoReplace code does not work.  This is a long-standing bug!

</t>
<t tx="ekr.20071028032929.577"></t>
<t tx="ekr.20071028032929.578">Leo was using the defaultID when creating new gnx's.  We must always use app().userID when creating new gnx's!

- Added userID ivar to node indices class.
- Removed the id arg to getNewIndex.</t>
<t tx="ekr.20071028032929.579">We do this to discourage users from messing with such lines.

Leo writes bogus @space "sentinels" following @+v and @+t sentinels, and readLinesToNextSentinel looks for such lines while scanning without calling sentinelKind.

Perhaps readLinesToNextSentinel should be called readLinesToNextRealSentinel ;-)</t>
<t tx="ekr.20071028032929.580"></t>
<t tx="ekr.20071028032929.581"></t>
<t tx="ekr.20071028032929.582">What I did:

- created nodeIndices.setTimestamp() routine.

This sets the new timeString ivar.  This saves a large number of calls to time.strftime.
All write routines should call setTimestamp once.

- created assignAllGnx method.  The compact/AssignFileIndices methods call this if use_gnx is true.

This ensures that all fileCommands write code assigns gnx's.

Also, Leo doesn't needlessly compute file indices when use_gnx is true.

- Assert's will fail in the fileCommands write code if we try to write a node without a gnx.

- The atFile.write code allocates t.gnx if needed.

This may be needed for the Write @file Nodes command.</t>
<t tx="ekr.20071028032929.583"></t>
<t tx="ekr.20071028032929.584"></t>
<t tx="ekr.20071028032929.585">I left in the commented out code that reads these fields, just in case we come across old .leo files with them in.  This code should be removed completely soon.

What I did:

For reading/writing .leo files:

- Removed gnx arg from createChild.
- Removed the code that allocates v.gnx.
- Removed the code that reads and writes the vnx= field.
- Removed v.getGnx

For reading/writing derived files:

- Removed the code that reads the gnx field in @+v sentinel lines.
- Called putSentinel instead of putSentinelAndGnx when writing vnodes in derived files.</t>
<t tx="ekr.20071028032929.586">This should minimize any pain on Linux systems.</t>
<t tx="ekr.20071028032929.587">I want to make sure that the proper read code is executed when reading _old_ .leo files when a.use_gnx is true.

I checked to make sure that node indices are resolved properly in all cases.  They are because self.tnodesDict is used regardless of a.use_gnx.

I also did a search on .use_gnx and in all cases the code will handle old .leo files even when use_gnx is true.</t>
<t tx="ekr.20071028032929.588">This makes the code clearer and cleaner.  I wrote getT before knowing about dict.get.</t>
<t tx="ekr.20071028032929.589"></t>
<t tx="ekr.20071028032929.590">This is far simpler than trying to figure out whether to allocate them beforehand.

Added code to do this when writing both .leo files and derived files.
</t>
<t tx="ekr.20071028032929.591"></t>
<t tx="ekr.20071028032929.592">The read code handles both txn and t attributes for compatibility wity old files.</t>
<t tx="ekr.20071028032929.593">We want to be specific because v elements will have both vnx and tnx fields.  The tnx field is about to replace the old tx field.</t>
<t tx="ekr.20071028032929.594">It sets app().use_gnx = false.</t>
<t tx="ekr.20071028032929.595"></t>
<t tx="ekr.20071028032929.596">This was a vain attempt to speed up the code.  Apparently the problem is elsewhere.  However, the new code is much simpler, so I'll stay with it.</t>
<t tx="ekr.20071028032929.597">This substantially reduces the size and clutter of .leo files.</t>
<t tx="ekr.20071028032929.598"></t>
<t tx="ekr.20071028032929.599"></t>
<t tx="ekr.20071028032929.600"></t>
<t tx="ekr.20071028032929.601"></t>
<t tx="ekr.20071028032929.602">This should be false if you plan to upload changes to Leo's cvs site.</t>
<t tx="ekr.20071028032929.603">This command is needed, I think, so that people can continue to use older versions of Leo.</t>
<t tx="ekr.20071028032929.604"></t>
<t tx="ekr.20071028032929.605"></t>
<t tx="ekr.20071028032929.606">This is required to be able to recognize shared nodes.
</t>
<t tx="ekr.20071028032929.607">The nodes are created by default, and we must be very careful to share tnodes properly.

The present code probably does this, but we must be ever vigilant.</t>
<t tx="ekr.20071028032929.608"></t>
<t tx="ekr.20071028032929.609"></t>
<t tx="ekr.20071028032929.610">List comprehensions are present in Python 2.0 or above.</t>
<t tx="ekr.20071028032929.611"></t>
<t tx="ekr.20071028032929.612"></t>
<t tx="ekr.20071028032929.613"></t>
<t tx="ekr.20071028032929.614">Fixed bug in handleLinesFollowingSentinel:
c:\prog\LeoCVS\leo\leoAtFile.py:482: No global (i) found
Removed i arg from rfind.

Fixed bug in definition of BadLeoFile:
c:\prog\LeoCVS\leo\leoFileCommands.py:27: Base class (exceptions.Exception) __init__() not called
Added call to Exception.__init__(self,message)

Fixed bug in askYesNoCancel
c:\prog\LeoCVS\leo\leoDialog.py:283: Variable (no) used before being set.
Disabled defaultButton logic.  New code would have to be thoroughly tested.

Removing unused routine: setDefaultLoc.
c:\prog\LeoCVS\leo\leoNodes.py:2581: No class attribute (defaultLoc) found

Fixed bug in put: changed a to app()
c:\prog\leoCvs\leo\leoFrame.py:4973: No global (a) found
</t>
<t tx="ekr.20071028032929.615"></t>
<t tx="ekr.20071028032929.616">@nocolor

I have just uploaded code to cvs that supports a new @lineending directive.  This directive allows you to specify the line endings for individual derived files.  This directive will override the output_newline setting in leoConfig.txt.  Note that @lineending _never_ affects the line endings in .leo files themselves:  we must have consistent line endings in .leo files!  See below for more details.

More importantly, I have "cleaned up" the code in the vital tangle.scanAllDirectives, atFile.scanAllDirectives and the scanDirectives global function by factoring out code to global helper functions.  Normally this should have been done at the start of a release cycle, not at the end, but I got carried away :-)

So please test this new code by writing all your files with the Write @file Nodes command and the Tangle all command.

I'll delay 3.11 final just a little longer to make sure I haven't done something really stupid, though I have reviewed the cvs change logs carefully (and found a few minor mistakes in the process).  I promise this will be the last changes to 3.11 (except for bug fixes) before 3.11 final finally goes out the door.

Anyway, the valid forms of the new @lineending directive are:

@lineending nl         (the default, Linux)
@lineending cr         (Mac)
@lineending crlf       (Windows)
@lineending lf          (same as nl, not recommended)
@lineending platform (same as platform value for output_newline setting in leoConfig.txt)

Edward</t>
<t tx="ekr.20071028032929.617">These utilities simplify and regularize scanning for the @encoding, @lineending, @pagewidth and @tabwidth directives for atFile.scanAllDirectives, tangle.scanAllDirectives and scanDirectives.

This is a partial solution for the problem of duplicated code in these routines.</t>
<t tx="ekr.20071028032929.618">skip_long was throwing an exception if there were no valid digits following a + or - sign.</t>
<t tx="ekr.20071028032929.619">- Enabled ok button only if 4 or more characters.
- Message now says that 4 or more characters are required.</t>
<t tx="ekr.20071028032929.620">Browsing the comp.lang.python yesturday I found that there are serious problems with Python's getdefaultlocale() routine.  Martin v. Löwis says "getdefaultlocale() is broken, and cannot be fixed", though he does suggest the following workaround:

leoGlobals.py uses locale.getpreferredencoding to define getpreferredencoding if locale.getpreferredencoding exists (it is new in Python 2.3alpha).  Otherwise, Leo uses the code copied from the 2.3a2 version of Python to define getpreferredencoding.  Either way, leoGlobals.py now defines getpreferredencoding and Leo uses getpreferredencoding rather than getdefaultlocale.</t>
<t tx="ekr.20071028032929.621">This adds http:\\ to url's if needed.</t>
<t tx="ekr.20071028032929.622">I had completely misunderstood __del__ methods!  __del__ methods _disable_ the gc's ability to collect circular garbage (!!) and so __del__ methods will _never_ be called (!!)

BTW, when deleting an entire Leo window Leo calls various destroy methods to unlink items.  This allows the garbage collector to collect all data structures.  Because of unlimited undo only these destroy methods have the potential for creating "real" garbage.</t>
<t tx="ekr.20071028032929.623"></t>
<t tx="ekr.20071028032929.624"></t>
<t tx="ekr.20071028032929.625"></t>
<t tx="ekr.20071028032929.626">- tangle.scanAllDirectives was not setting self.encoding when handling @encoding.
- tangle.scanAllDirectives wasn't scanning the @encoding line properly.
- fixed crashers in Tangle and Untangle logic.</t>
<t tx="ekr.20071028032929.627">After opening the Python window the call to tkFont() threw a (caught) exception on every call to frame.setTabWidth.  The fix was to add the optional root param.</t>
<t tx="ekr.20071028032929.628"></t>
<t tx="ekr.20071028032929.629">This makes the output look much better.  Only time will tell whether cvs likes this way...</t>
<t tx="ekr.20071028032929.630">- Added comments param to handleLinesFollowingSentinel.

- Hacked readLinesToNextSentinel so it accepts the first line even if it looks like a sentinel.
  This won't handle all cvs conflicts perfectly, but perfection isn't possible anyway...</t>
<t tx="ekr.20071028032929.631">- wrote readLinesToNextSentinel and handleLinesFollowingSentinel.
- added optional nextLine param to scanText to handle look-ahead.</t>
<t tx="ekr.20071028032929.632">I spent several days on a false start. My first try was to create a new version
of scanText called scanGnxText. This dispatched routines to handle 4.x
sentinels. There were several big problems with this approach:

- Much of scanGnxText was identical to scanText.

- Using separate routines to do the work meant that ivars had to be used for
communication between the routines rather than the local vars.

- Instead of using recursion to handle nested sentinels, scanGnxText had to
manage explicit stacks. This was so ugly...

This morning I threw in the towel. Rather than do all this extra work in the
name of "elegance" I simply added a few new cases to the old scanText. The
result is that all the old code works exactly as before, and the new code gets
to use the old tested code.

While I was at it, I made the following changes:

- Renumbered the constants in leoAtFile. Some of these numbers were duplicates,
which might have caused problems, though apparently it did not.

- Removed the "implicit child index" logic from scanText. This was never used.

BTW, the write logic always used the old logic as a starting point. The present
4.0 write code was up and running in a couple of hours.

Other notes:

- Setting app().use_gnx to true enables two commands in the Read/Write menu
that test the new code. I don't recommend doing this: there are plenty of
problems yet... app().use_gnx will be false for all 3.x releases.

- The present code uses id(v) as a dummy global node index (gnx). This will be
changed very soon.

- Still to do: the code in leoFileCommands to read and write "mark" elements.
This isn't essential, and without this no marks will be remembered in derived
files. I must also handle the process of telling Leo the user's cvs id. This
will probably involve reading leoId.txt.</t>
<t tx="ekr.20071028032929.633"></t>
<t tx="ekr.20071028032929.634">I had forgotten to compile leo.nsi.</t>
<t tx="ekr.20071028032929.635">The children of this node are a test of this.</t>
<t tx="ekr.20071028032929.636"></t>
<t tx="ekr.20071028032929.637"></t>
<t tx="ekr.20071028032929.638"></t>
<t tx="ekr.20071028032929.639"></t>
<t tx="ekr.20071028032929.640"></t>
<t tx="ekr.20071028032929.641"></t>
<t tx="ekr.20071028032929.642"></t>
<t tx="ekr.20071028032929.643"></t>
<t tx="ekr.20071028032929.644"></t>
<t tx="ekr.20071028032929.645"></t>
<t tx="ekr.20071028032929.646"></t>
<t tx="ekr.20071028032929.647"></t>
<t tx="ekr.20071028032929.648"></t>
<t tx="ekr.20071028032929.649"></t>
<t tx="ekr.20071028032929.650"></t>
<t tx="ekr.20071028032929.651"></t>
<t tx="ekr.20071028032929.652"></t>
<t tx="ekr.20071028032929.653"></t>
<t tx="ekr.20071028032929.654">Changed redraw_now to force_redraw in tree select routines.</t>
<t tx="ekr.20071028032929.655"></t>
<t tx="ekr.20071028032929.656"></t>
<t tx="ekr.20071028032929.657">This allows time to be expressed as local time or gmttime.</t>
<t tx="ekr.20071028032929.658"></t>
<t tx="ekr.20071028032929.659"></t>
<t tx="ekr.20071028032929.660"></t>
<t tx="ekr.20071028032929.661"></t>
<t tx="ekr.20071028032929.662"></t>
<t tx="ekr.20071028032929.663">These were long-standing bugs.</t>
<t tx="ekr.20071028032929.664"></t>
<t tx="ekr.20071028032929.665"></t>
<t tx="ekr.20071028032929.666">This makes the file name easier to see in the Windows task bar.
</t>
<t tx="ekr.20071028032929.667">This fixes several bugs.</t>
<t tx="ekr.20071028032929.668"></t>
<t tx="ekr.20071028032929.669">Every call to v.unjoinNode was calling c.clearAllVistied.

Fixing this bug will allow me not to use inodes &amp; locations for the foreseeable future.</t>
<t tx="ekr.20071028032929.670"></t>
<t tx="ekr.20071028032929.671"></t>
<t tx="ekr.20071028032929.672"></t>
<t tx="ekr.20071028032929.673"></t>
<t tx="ekr.20071028032929.674">scanColorDirectives now returns self.language.</t>
<t tx="ekr.20071028032929.675"></t>
<t tx="ekr.20071028032929.676"></t>
<t tx="ekr.20071028032929.677"></t>
<t tx="ekr.20071028032929.678"></t>
<t tx="ekr.20071028032929.679">@nocolor

1. Put customizeLeo.py on cvs.  I don't particularly see why this file should be much more dangerous than any other file.

2. Remove the @ignore directive from the ancestor of @file customizeLeo.py.

3. Remove the warning when customizeLeo.py is written.  However, I shall _insert_ a lock that prevents customizeLeo.py from being written unless use_customize_leo_dot_py = 1 in leoConfig.txt.

Leo will write a message to the log if customizeLeo.py is dirty but was not written because of the setting in leoConfig.txt.
</t>
<t tx="ekr.20071028032929.680"></t>
<t tx="ekr.20071028032929.681"></t>
<t tx="ekr.20071028032929.682">Simplified and regularized hooks:

- replaced "event1" and "event2" hooks with 'regular' hooks.
	* Much easier to understand.
- added "iconrclick" hooks.
- added "bodyrclick" hooks.
- added "dragging" hooks.
	* These are called when drag hook called while already dragging.
- added "hyperenter" and "hyperleave" hooks.
	* These only fire if use_hyperlinks = 1 in leoConfig.txt.
- removed "activate" and "deactivate" hooks.
	* These were not reliable.
- almost all hooks have c,v arguments now.
- "command" hooks now return "undo" and "redo" rather than "cantundo" and "cantredo"

Improved code:

- improved the tracing of hooks in customizeLeo.py.
- the tracing code also checks to make sure that most hooks have c,v keywords.
- created es_event_exception().
- put all event handlers in try/except blocks that call es_event_exception on errors.</t>
<t tx="ekr.20071028032929.683">The fix was to set the hand cursor in </t>
<t tx="ekr.20071028032929.684">v.OnEndDrag can be called even though tree.dragging is false.  </t>
<t tx="ekr.20071028032929.685"></t>
<t tx="ekr.20071028032929.686">replaced c.contractVnode by v.contract.
replaced c.expandVnode by v.expand.

This was mostly done earlier, but wasn't done completely.  Not doing so completely caused exceptions in the promote, demote and import commands.</t>
<t tx="ekr.20071028032929.687"></t>
<t tx="ekr.20071028032929.688">added raw=1 to all calls to config.get in leoConfig.py.</t>
<t tx="ekr.20071028032929.689"></t>
<t tx="ekr.20071028032929.690"></t>
<t tx="ekr.20071028032929.691"></t>
<t tx="ekr.20071028032929.692"></t>
<t tx="ekr.20071028032929.693">This can be useful when clones are in the range of different @path directives.</t>
<t tx="ekr.20071028032929.694">Dirty bits are kept in tnodes, so setting/clearing a dirty bit in a node v does the same in all nodes joined to v.

Also, made setDirtyDeleted equivalent to setDirty, which means that setAncestorsOfClonedNodesInTreeDirty is no longer used.  This is a bizarre routine:  I have no idea why it should be needed.</t>
<t tx="ekr.20071028032929.695"></t>
<t tx="ekr.20071028032929.696"></t>
<t tx="ekr.20071028032929.697">Previously saving a new file did not result update the Recent Files menu.

Created frame.updateRecentFiles routine and called it from openWithFileName and all Save routines.</t>
<t tx="ekr.20071028032929.698">In the preferences dialog the close button is now equivalent to the Cancel button.

While I was at it, I eliminated OnClosePrefsFrame.  The OnCancel routine works just fine.
</t>
<t tx="ekr.20071028032929.699">There was a typo in the documentation of chapter 8, "About hooks". In the hook table the "when called" column of "headkey1" and "headkey2" says "before/after *body* keystrokes", instead of "headline keystrokes".

Fixed in LeoPy.leo, LeoDocs.leo and on the web site.</t>
<t tx="ekr.20071028032929.700">These were easy to do and they may be of real help to some people in some situations.</t>
<t tx="ekr.20071028032929.701">I have just uploaded a major improvement to Leo's expand/contract routines.
This came about as the result of a request by Travers A. Hough.

His comment was that it would be better to have the Expand To Level n commands
work only on the presently selected outline: "Having Expand" commands that work
only on a suboutline...would most likely be what the programmer really wanted."
Indeed, this is correct. I'm not sure why I didn't see this earlier.

As I played with the expand/contract commands it gradually became apparent that
the new way of doing things makes a number of existing or requested commands
obsolete:

1. I redefined Expand To Level 1 to mean contract the presently selected
outline. So there is no need for a Contract Present Node command (!)

2. Expand To Level 2 now does what the requested Expand Present Node command
would have done. Moreover, this command eliminates the need for the old
Contract Subheads command!

3. Expand to Level 3 now does what the old Expand Subheads command did!

4. With all these commands now gone (without sacrificing anything!) it became
possible to consolidate the Expand and Contract submenus into a single
Expand/Contract submenu. This is a pretty big win, in fact, because it shows in
one place all the shortcuts that cause expansion and contraction.

As requested, I changed the Contract All command to select the topmost ancestor
of the presently selected node if that node becomes invisible as the result of
the contraction. This eliminates what was in fact quite irritating behavior.

It is truly unusual that a feature request should spark both wholesale
simplifications and an increase in power, and that is what has happened. In
this area, I think, as perhaps in no other, Leo's way of handling outlines is
now clearly superior to how the great MORE outliner worked.</t>
<t tx="ekr.20071028032929.702"></t>
<t tx="ekr.20071028032929.703"></t>
<t tx="ekr.20071028032929.704"></t>
<t tx="ekr.20071028032929.705"></t>
<t tx="ekr.20071028032929.706">In other words, the Pressing the Enter key in the Find panel executes the Find Next command.
</t>
<t tx="ekr.20071028032929.707"></t>
<t tx="ekr.20071028032929.708"></t>
<t tx="ekr.20071028032929.709">These are just conveniences, so the user doesn't have to check for save, saveas and saveto command hooks.</t>
<t tx="ekr.20071028032929.710"></t>
<t tx="ekr.20071028032929.711"></t>
<t tx="ekr.20071028032929.712"></t>
<t tx="ekr.20071028032929.713"></t>
<t tx="ekr.20071028032929.714">In the unusual case that a language has no single-line comment delimiter, Leo will remove the block delimiters from the headline text in node sentinels.  createNthChild must take this into account by doing a second comparison of headlines if the normal comparison fails.  If the second comparison of headlines succeeds we assume that we should use the headline from the outline instead of the derived file.  I believe some kind of kludge like this will also be required for 4.0.

This is kludgy, and I don't know what else to do.</t>
<t tx="ekr.20071028032929.715">@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1806338
By: stwerff
Open Discussion 12/23/02

There seems to be a problem to find the correct vnode when there is a double
comment given:

vnode not found in outline: exp_definitions*)

The finish comment seems to interfere with the @+node:

(*@+node:1::exp_definitions*)

Jurjen

</t>
<t tx="ekr.20071028032929.716">@nocolor

I see. This is an interesting hole. This problem only arises with languages such as html that have
paired comment delims _and_ that have no single-line comment delimiter. 

The only solution seems to me to remove either just the closing comment delim or both comment
delims from the headline text of +-node sentinels. Do you agree? I'll make the change today.
</t>
<t tx="ekr.20071028032929.717"></t>
<t tx="ekr.20071028032929.718">leoFileCommands.put was recently changed, and the following code was accidentally omitted:

	elif self.outputString != None: # Write to a string
		self.outputString += s</t>
<t tx="ekr.20071028032929.719">Re-enabled the following code in
&lt;&lt; set path to the full pathname of a temp file using ext &gt;&gt;

a.openWithFileNum += 1</t>
<t tx="ekr.20071028032929.720">This allows Leo to be used with a black background.</t>
<t tx="ekr.20071028032929.721">changed s.self to s,self in tangle.os.</t>
<t tx="ekr.20071028032929.722">The error reporting code is still highly experimental.  In particular, encoding errors in headlines may generate many redundant messages as sentinel lines are written.

Here is what I did:

Phase I: get body text working with utf-8.
	done: accept @+leo,encoding=&lt;the_encoding&gt; when reading derived files.
	done: always use &lt;?xml version="1.0" encoding="UTF-8"&gt;
	done: Read and write .leo files using utf-8 encoding. (It's always been this way).
	done: convert body text to unicode when reading .leo files.
	done: ensure unicode in body key handler.

Phase II: get find/change working with utf-8.
	done:  don't call repr on unicode strings in es().
	done: convert from utf-8 to unicode when reading find/change params in leoConfig.txt
	done: encode unicode to utf-8 before writing find/change params in leoConfig.txt.

Phase III: support @encode.  Test with iso-8859-1 and utf-8 encodings.
	done: Colorize @encoding.
	done: Recognize @encoding in various scanDirectives routines.
	done: Add self.encoding ivars to atFile and Tangle classes.
	done: Write -encoding=x. in @+leo header
	done: Write derived files using atFile.self.encoding
	done: Use unicode for all headline text.
	done: Read derived files using atFile.self.encoding.
	done: Add leo_file_encoding to leoFileCommands class.
	done: Initialize leo_file_encoding when reading .leo file
	done: Use leo_file_encoding when reading tnode and vnode text.
	done: Use leo_file_encoding when writing tnode and vnode text.
	done: Create config.new_leo_file_encoding.
	done: Create config.default_derived_file_encoding.
	done: Use default_derived_file_encoding when writing derived files.
	done: Use new_leo_file_encoding when creating new .leo files.

Phase IV: Use unicode everywhere
	done: @encoding on import/export
	done: @encoding on tangle/untangle

Phase V: cleanup
	done: replace fnW by fn.  replace pathW by path.
	done: assert unicode type when writing derived files.
	done: remove unused unicode utilities
	done: remove or replace all instances of xml_version_string.
	done: create toUnicode and toString utils.
	done: change test+unicode to toUnicode
	done: change test+encode to toString
	done: create isValidEncoding
	- better error reporting</t>
<t tx="ekr.20071028032929.723">I don't believe there is a great need for other encodings in leoConfig.txt and I don't plan to support anything but utf-8 encoding in leoConfig.txt.</t>
<t tx="ekr.20071028032929.724"></t>
<t tx="ekr.20071028032929.725"></t>
<t tx="ekr.20071028032929.726">The fix was to set true = 1 ; false = 0 in leoGlobals.py.</t>
<t tx="ekr.20071028032929.727"></t>
<t tx="ekr.20071028032929.728">This corrects a hang in the Open With command.
</t>
<t tx="ekr.20071028032929.729"></t>
<t tx="ekr.20071028032929.730"></t>
<t tx="ekr.20071028032929.731"></t>
<t tx="ekr.20071028032929.732">@ Please add "event=event" to the parameter list when calling handleLeoHook() from event handlers. 

I'm trying to add a menu item to the popup menu and am trying to use "event1"
for "headPopup" to do so.

I need to replace the OnPopup method with my custom method.  But I find that
I need the event object in order to do so.  However, the calls to handleLeoHook
(in event handler methods) do not pass the event object.

It seems like a good idea to pass the event as one of the keywords for event1
and event2.</t>
<t tx="ekr.20071028032929.733"></t>
<t tx="ekr.20071028032929.734"></t>
<t tx="ekr.20071028032929.735">It's actually working, but it's work is being undone by a previous binding.</t>
<t tx="ekr.20071028032929.736"></t>
<t tx="ekr.20071028032929.737">This was done in c2py.py, leoAtFile.py and leoColor.py.

I actually think this was foolish to do, regardless of how much "cleaner" the code looks.  The problem is that it is not at all easy to test.  I think this kind of thing should wait until has a full regression testing suite.</t>
<t tx="ekr.20071028032929.738">What I did:

- es, trace &amp; trace_tag take a variable number of args.
- es, trace &amp; trace_tag convert to string using repr as needed.
- move init_sherlock to leoGlobals where it belongs.
- init_sherlock now takes an echo param.
- only trace_tag takes a "tracepoint" arg.</t>
<t tx="ekr.20071028032929.739">redoMenuLabel and undoMenuLabel must be initialized in the ctor, _not_ in clearUndoState.
</t>
<t tx="ekr.20071028032929.740">The self.oldcursor logic wasn't working reliably.
</t>
<t tx="ekr.20071028032929.741"></t>
<t tx="ekr.20071028032929.742">In most case the "x2" hook is always called, whether or not the "x1" hook overrides the default code.

The only time this can possibly make a difference is when the "x1" hook actually does override, so the issue of whether or not this is a good idea is almost always moot.</t>
<t tx="ekr.20071028032929.743">@nocolor

The following are real problems that should be cleaned up:

c:\prog\leoCvs\leo\leoApp.py:293: Object (d) has no attribute (testDialogs)

	(done) remove app.testDialogs

c:\prog\LeoCVS\leo\leoFileCommands.py:342: No class attribute (getCollapsedOpenTag) found

	(done) change getCollapsedOpenTag to getOpenTag

c:\prog\LeoCVS\leo\leoFileCommands.py:525: Catching a non-Exception object (BadLeoFile)
c:\prog\LeoCVS\leo\leoFileCommands.py:583: Catching a non-Exception object (BadLeoFile)

	(done) derive class BadLeoFile from Execption

(done) c:\prog\LeoCVS\leo\leoUndo.py:134: No class attribute (redoMenuLabel) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:138: No class attribute (undoMenuLabel) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:320: No class attribute (commands) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:394: No class attribute (debug_print) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:423: No class attribute (new_undo) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:424: No class attribute (debug) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:430: No class attribute (old_mem) found
(done) c:\prog\LeoCVS\leo\leoUndo.py:433: No class attribute (new_mem) found

	These arise because we refer to both self.x and u.x.
	to do: change self.x to u.x.

c:\prog\LeoCVS\leo\leoCompare.py:425: No class attribute (makeWhitespaceVisible) found

(done) changed self.makeWhitespaceVisible to cmp.makeWhitespaceVisible</t>
<t tx="ekr.20071028032929.744"></t>
<t tx="ekr.20071028032929.745"></t>
<t tx="ekr.20071028032929.746"></t>
<t tx="ekr.20071028032929.747"></t>
<t tx="ekr.20071028032929.748">We must do

exec s in {}

NOT

exec s in __builtins__

Passing __builtins__ to exec is the _worst possible_ thing to do, because it pollutes the only truly global namespace FOREVER.</t>
<t tx="ekr.20071028032929.749"></t>
<t tx="ekr.20071028032929.750"></t>
<t tx="ekr.20071028032929.751"></t>
<t tx="ekr.20071028032929.752"></t>
<t tx="ekr.20071028032929.753">What I did:
	
- added self.trace ivar to trace write logic.

- changed the following sections of putCodePart:

1. &lt;&lt; put the line &gt;&gt;
	Buffered characters to make tracing easier. (reduces calls to self.os)
	Don't write trailing indentation if not writing sentinels.

2. &lt;&lt; handle @others &gt;&gt;
	Skip the newline after @others if we aren't putting sentinels.
</t>
<t tx="ekr.20071028032929.754">The present code properly handles undo/redo for operations that copy trees, but copying trees itself causes problems for further undoes.  I've disabled further undos, as was done previously, but this is a pity.

To fix this, we may have to hack on the beads to indicated that a copy has been made.  No doubt about it: copying trees is tricky.</t>
<t tx="ekr.20071028032929.755"></t>
<t tx="ekr.20071028032929.756">This bug was created recently by the new underline/realMenuName logic.  We must not set the undo/redoRealMenuName ivars in clearUndoState: that should only be done when actually setting the menu names.</t>
<t tx="ekr.20071028032929.757"></t>
<t tx="ekr.20071028032929.758">The fix was made to atFile.scanAllDirectives() and leoGlobals.scanDirectives()
tangle.scanAllDirectives() was not affected.

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):</t>
<t tx="ekr.20071028032929.759">Completed a major revision of the menu handling code to handle underlined menus.  The new code has a chance of working with translated menus.


What I did:

- Added app()./frame.setRealMenuNamesFromTable() convenience methods.
- Use underline param to specify underlined characters in menu names.
- Translate &amp; to underline index before removing &amp;.
- Alt-E conflicts with Edit menu: changed to Alt+Shift+E
- Added f.get/setMenu (canonicalize menu names)
- Used realMenuNames for undo/redo.
- Disabled Can't Undo, Can't Redo.
</t>
<t tx="ekr.20071028032929.760"></t>
<t tx="ekr.20071028032929.761"></t>
<t tx="ekr.20071028032929.762">The lambda functions for callbacks were not working properly.  While I was at it I simplified the code</t>
<t tx="ekr.20071028032929.763">The original bug report:

"The sample code to invoke idle via "Open With" does not work if leo 
is installed in a path with a blank, for example "program files/leo". 
On windows, the pathname needs to be quoted in this case."

I did not find this to be the case.  However, there were problems with the sample Open With code in customizeLeo.py and I corrected these.
</t>
<t tx="ekr.20071028032929.764">We scanning for the initial state we must make sure that i &lt; old_len and i &lt; new_len.</t>
<t tx="ekr.20071028032929.765">This was reported by David LeBlanc and fixed with major hints from Chad Netzer.
</t>
<t tx="ekr.20071028032929.766">Apparently the F4 shortcuts interferes with the Alt-F4 shortcut.</t>
<t tx="ekr.20071028032929.767">The content formerly on evisa.com, including the Leo tutorials is now on 3dtree.com.</t>
<t tx="ekr.20071028032929.768"></t>
<t tx="ekr.20071028032929.769">Use keyword params instead of synonym constants.

- import
	- removed dont_indent_refs and indent_refs synonyms.

- tangle
	- removed verbose and brief synonyms to st_dump.
	- left other flags alone: they are complex.</t>
<t tx="ekr.20071028032929.770"></t>
<t tx="ekr.20071028032929.771"></t>
<t tx="ekr.20071028032929.772">Added options for @file and @root.

The options to @root are more important (and potentially more buggy).  For the first time Leo allows you to choose whether body text in @root trees will start in code mode or doc mode by default.  Ever since I created @file trees I've regretted the choice of making doc mode the default.  Just last week I realized I'm not stuck with that old choice.

This is a little tricky, so please pay attention :-)

1. @root-doc filename and @root-code filename specify that body text is assumed to start in doc mode or code mode respectively.  The options (-doc and -code) must follow @root immediately with no intervening whitespace.  In effect, @root-code and @root-doc are two new directives.  (They aren't syntax colored yet: they will be today or tomorrow.)

2. These @root options override the new at_root_bodies_start_in_doc_mode option in leoConfig.py.  This option affects only @root trees without options.  Such "plain" @root trees are now deprecated, which only means that it is now better style to use either @root-code or @root-doc.  The reason is simple: the meaning of plain @root trees will depend on the at_root_bodies_start_in_doc_mode option, and that isn't good.

3. By default, at_root_bodies_start_in_doc_mode = 1 for compatibility for old @root trees.  I actually don't think this option is good for much; I created it before I created @root-doc and @root-code, and I decided it wouldn't hurt to leave it in.  Anyway, you now have complete flexibility about how @root works, and in particular you can make @root work just like @file.

Only minor changes were made to the Tangle and Untangle code, and the new code appears to work.  However, it has not been extensively tested.  I would like to get 3.9.1 out the door this week so the latest "official" version of Leo won't crash when PIL or tkIcon are not present.  So please report any problems with the new code immediately.</t>
<t tx="ekr.20071028032929.773">Untangle was warning about a missing section if the section had only an @doc part.</t>
<t tx="ekr.20071028032929.774">There is a good reason why os.path.normpath does not mess with slashes on Linux, and there is no reason to create another routine to do so.
</t>
<t tx="ekr.20071028032929.775"></t>
<t tx="ekr.20071028032929.776"></t>
<t tx="ekr.20071028032929.777">Used .gif file so transparency info used by tkIcon code.
Rewrote tkIcon code so it doesn't try to resize the icon.
Created custom 16x16 LeoWin.gif.</t>
<t tx="ekr.20071028032929.778">The code now uses the list leoConfig.ivars to generate exec statements that do the work.  This makes it possible to add ivars to leoConfig.ivars without changing code in leoConfig.py.
</t>
<t tx="ekr.20071028032929.779">It might be beter if the Suboutline Only and Node Only checkboxes were Radio buttons, but then we would need yet another radio button to say "Search Entire Outline", which is a bit pedantic.

Note that Node Only takes precedence over Suboutline Only if they are both checked.</t>
<t tx="ekr.20071028032929.780">This works just like the Flatten Outline command except it writes only headlines.</t>
<t tx="ekr.20071028032929.781"></t>
<t tx="ekr.20071028032929.782">The code that checks whether leading and trailing have been supplied must check against None.  Otherwise, a leading or trailing value of zero will cause middle_lines to be miscalculated.</t>
<t tx="ekr.20071028032929.783">The commands now remember the scroll position so the screen doesn't hope around.</t>
<t tx="ekr.20071028032929.784"></t>
<t tx="ekr.20071028032929.785">Created the long-overdue convertUnicodeToString utility.</t>
<t tx="ekr.20071028032929.786"></t>
<t tx="ekr.20071028032929.787"></t>
<t tx="ekr.20071028032929.788">This is called from atFile.scanAllDirectives, tangle.scanAllDirectives and utils_rename.</t>
<t tx="ekr.20071028032929.789"></t>
<t tx="ekr.20071028032929.790">@ test

@nocolor

@ test

@color</t>
<t tx="ekr.20071028032929.791">This may or may not solve a crash under Python 2.1.</t>
<t tx="ekr.20071028032929.792"></t>
<t tx="ekr.20071028032929.793">Leo now ensures that u.oldText and u.newText are set to None when using the new undo scheme.  This means that Python now has a chance of reclaiming much more memory.</t>
<t tx="ekr.20071028032929.794"></t>
<t tx="ekr.20071028032929.795"></t>
<t tx="ekr.20071028032929.796">Leo now forces a full update and redraw if there is a mismatch between the expected value and the result calculated from the Tk.Text widget.  This is safe, and won't happen often.</t>
<t tx="ekr.20071028032929.797">This was making it impossible to specify trailing newlines.  It also seems to have helped undo.</t>
<t tx="ekr.20071028032929.798"></t>
<t tx="ekr.20071028032929.799"></t>
<t tx="ekr.20071028032929.800"></t>
<t tx="ekr.20071028032929.801"></t>
<t tx="ekr.20071028032929.802"></t>
<t tx="ekr.20071028032929.803"></t>
<t tx="ekr.20071028032929.804">We can't use after_idle because that completely overloads the system.  On my machine a delay of 500-1000 msec between calls would be sufficient to handle most "periodic" tasks.</t>
<t tx="ekr.20071028032929.805">It's not perfect, and it will do for now.</t>
<t tx="ekr.20071028032929.806"></t>
<t tx="ekr.20071028032929.807"></t>
<t tx="ekr.20071028032929.808">Noweb section refs and defs _are_ valid in cweb mode!
Allow LaTex coloring in cweb @space, @* and @** doc parts.</t>
<t tx="ekr.20071028032929.809"></t>
<t tx="ekr.20071028032929.810">Cweb prefs panel setting was overriding @language python (!)</t>
<t tx="ekr.20071028032929.811"></t>
<t tx="ekr.20071028032929.812">This makes it much easier to pass parameters to hooks.
</t>
<t tx="ekr.20071028032929.813"></t>
<t tx="ekr.20071028032929.814"></t>
<t tx="ekr.20071028032929.815"></t>
<t tx="ekr.20071028032929.816">@language pascal
@color

private
uses</t>
<t tx="ekr.20071028032929.817"></t>
<t tx="ekr.20071028032929.818">We can only suppress redraws in undo/redo under very special conditions, namely that we are undoing typing in the same node.

The recent code will leave the screen in the wrong state!</t>
<t tx="ekr.20071028032929.819"></t>
<t tx="ekr.20071028032929.820">Eliminated the self.delim ivar.  This can't be set correctly when coloring incrementally.

Realized that full, non-incremental coloring must _always_ be done when switching nodes.  Even if we move from one cloned node to another, the context can be different:  different @color, @nocolor, @language and @comment directives may be in effect.

Used incremental syntax coloring when undoing.  This speed up undo tremendously.</t>
<t tx="ekr.20071028032929.821"></t>
<t tx="ekr.20071028032929.822"></t>
<t tx="ekr.20071028032929.823"></t>
<t tx="ekr.20071028032929.824"></t>
<t tx="ekr.20071028032929.825">The principle is this: people should see the scripts they are executed.
</t>
<t tx="ekr.20071028032929.826"></t>
<t tx="ekr.20071028032929.827"></t>
<t tx="ekr.20071028032929.828"></t>
<t tx="ekr.20071028032929.829"></t>
<t tx="ekr.20071028032929.830"></t>
<t tx="ekr.20071028032929.831"></t>
<t tx="ekr.20071028032929.832">@color

@ See the actual code in the child node for complete notes.</t>
<t tx="ekr.20071028032929.833">@ frame.doCommand and frame.OnMenuClick now set app.log, so top() will be reliable after any command is executed.

Note 1: The value of top() may change during a new or open command, which may change the routine used to execute the "command1" and "command2" hooks.  This is not a bug, and hook routines must be aware of this fact.
@c

def top():
	
	"""Return the commander of the topmost window"""
	
	# Warning: may be called during startup or shutdown when nothing exists.
	try:
		return app.log.commands
	except:
		return None</t>
<t tx="ekr.20071028032929.834"></t>
<t tx="ekr.20071028032929.835"></t>
<t tx="ekr.20071028032929.836">The old code jumped through hoops not to duplicate code.  The new code just uses a new doAtKeyword routine.</t>
<t tx="ekr.20071028032929.837">The key invarient:  frame.menus contains _untranslated_ names.  The translated names are used only in the label param to the Tk.menu routines.</t>
<t tx="ekr.20071028032929.838">The menu hooks make it easy to customize menus.

The open hooks make it easy to perform custom actions when opening already-existing files.</t>
<t tx="ekr.20071028032929.839">Finished convenience routines.

Used createNewMenu to create Leo's menus.</t>
<t tx="ekr.20071028032929.840"></t>
<t tx="ekr.20071028032929.841">This will allow users to create new menus without creating new ivars, an important generalization.

self.menus["top"] represents the top-level menu.  All other menus are represented by their menu name.</t>
<t tx="ekr.20071028032929.842">This is long overdue:

- put the entire command in a try: except: block.
- eliminates the need for return "break"
- provides the natural place for hooks.

It was quite easy now that we have createMenuEntries.</t>
<t tx="ekr.20071028032929.843">At present, only the start1, start2 and end1 hooks are handled, and many more could be added easily.</t>
<t tx="ekr.20071028032929.844"></t>
<t tx="ekr.20071028032929.845"></t>
<t tx="ekr.20071028032929.846"></t>
<t tx="ekr.20071028032929.847"></t>
<t tx="ekr.20071028032929.848">This was almost too easy :-)</t>
<t tx="ekr.20071028032929.849"></t>
<t tx="ekr.20071028032929.850">Leo no longer massages comments when importing Java files.

There was a bug in massageBody that prevented text from being undented properly.  There was a bug in find_line_start (!!) that caused the start of the _previous_ line to be found if s[i] was a newline.  It's amazing that these bugs were undiscovered for so long.

Treat interface like class.</t>
<t tx="ekr.20071028032929.851">It was moving past the present line if the s[i] was a newline.

This caused problems in the Java scanner, and could also cause problems in other places.</t>
<t tx="ekr.20071028032929.852"></t>
<t tx="ekr.20071028032929.853">The trailing @ in @q@ "doubles" the first @ in a sentinel, so putSentinel should not do this, and sentinelKind needs no special code to test for sentinels.

The tcweb.py script tests cweb files.  Invoke as follows:

python tcweb.py file1 file2...</t>
<t tx="ekr.20071028032929.854">@ What I did:
	
- Changed g to geom or glob.
- Removed print_stack.
- Moved alert, handleLeoHook &amp; unloadAll to leoUtils.
- Moved all leoUtils routines into leoGlobals.py.
- Removed all instances of "from leoUtils import *"
- Removed "script functions" from leo.py: getCommands, topCommands, topCommand.
	These are no longer used anywhere in the code.
- Made the prolog_xxx constants ivars of leoApp.
- Made language_delims_dict and language_extension_dict ivars of leoApp.

I have decided to leave the present scheme pretty much in place,
except to move the variables in leoGlobals.py to leoApp.py.

This will allow us to say the following:
	
1. any function f() is defined in leoGlobals.py.
2. any variable v not of the form x.f is a local variable.


</t>
<t tx="ekr.20071028032929.855"></t>
<t tx="ekr.20071028032929.856"></t>
<t tx="ekr.20071028032929.857">We must double _all_ @ signs following the @q@, so, e.g., a @@color sentinel gets turned into @q@@@@@color@&gt;.

This is easy to do in putSentinel, but a bit harder to undo:

1. sentinelKind locally adjusts the string in cweb mode.
2. skipSentinelStart skips both @@ signs in cweb mode.
3. All sections in scanText that deal with variable text must change @@ to @ within that text.</t>
<t tx="ekr.20071028032929.858"></t>
<t tx="ekr.20071028032929.859">Only rarely does a routine as elegant as wrap_lines come along.</t>
<t tx="ekr.20071028032929.860"></t>
<t tx="ekr.20071028032929.861"></t>
<t tx="ekr.20071028032929.862"></t>
<t tx="ekr.20071028032929.863"></t>
<t tx="ekr.20071028032929.864"></t>
<t tx="ekr.20071028032929.865">Added return "break" to body and headline key handlers.
Added unreachable return 0 to end of findMatchingBracket.</t>
<t tx="ekr.20071028032929.866">@nocolor

This is miserable code to get just right because there are so many paths through the code.  In addition, making informative error messages is a bit tricky too.

Changes made:

1. Removed unhelpful warnings about non-existent paths.  Only errors are given now.
2. Added logic to set self.root_name if it has not already been set.  Without this, it is impossible to test for relative filenames in @root directives, and errors happen only after tangling is complete, which is quite confusing.
3. Added error messages when a "computed" file name does not exist.
4. Removed unused self.default_directory ivar from leoTangle.py.
5. Set self.tangle_directory ivar to base directory when @root node specifies a relative directory.  This is required so the later code will try to create the proper file.
6. Renamed the path_directive_creates_directories option to create_nonexistent_directories.  This makes clearer what is going on.
</t>
<t tx="ekr.20071028032929.867">The old name was too misleading.</t>
<t tx="ekr.20071028032929.868"></t>
<t tx="ekr.20071028032929.869">Leo was not warning about orphan nodes in cweb mode.

There was new code in atFile.write _not_ to check for orphan nodes in cweb mode.  I just removed the test for language=="cweb".</t>
<t tx="ekr.20071028032929.870">The present code explicitly eliminates control-T processing in headlines, which means that control-T does not switch panes when editing headline text.  Control-T _does_ switch panes in all other cases.

This appears to be another Tk bug.</t>
<t tx="ekr.20071028032929.871"></t>
<t tx="ekr.20071028032929.872"></t>
<t tx="ekr.20071028032929.873">The old code scanned the moved tree once for every parent.  The new code scans the tree only once.  This can result in a significant speedup.</t>
<t tx="ekr.20071028032929.874">This is taken from Python Cookbook.
It's not clear how useful this is with Tk programs.</t>
<t tx="ekr.20071028032929.875">1. Eliminated special-case code (putCWEB) in atFile.write code.
2. Changed directiveKind so it returns noDirective for @space and @c when language=="cweb".
3. Changed colorizer to recognize both cweb and noweb section definitions and references when language == "cweb"</t>
<t tx="ekr.20071028032929.876">Leo preserves the &lt;?xml-stylesheet...?&gt; line if it is already present in the .leo file.

Otherwise, Leo writes a &lt;?xml-stylesheet...?&gt; line only if the stylesheet option is present in the configuration file.  The stylesheet option specifies s in &lt;?xml-stylesheet s?&gt;</t>
<t tx="ekr.20071028032929.877"></t>
<t tx="ekr.20071028032929.878"></t>
<t tx="ekr.20071028032929.879">Changed find to rfind in &lt;&lt; Set headline and ref &gt;&gt;</t>
<t tx="ekr.20071028032929.880"></t>
<t tx="ekr.20071028032929.881">scanAllDirectives just about must be called on the root of the tree, so directives are recognized.  Not @first or @last though.</t>
<t tx="ekr.20071028032929.882">The aha, just concatenate a unique user id with any local timestamp.</t>
<t tx="ekr.20071028032929.883">This may complete raw cweb mode.</t>
<t tx="ekr.20071028032929.884">It appears that nobody ever used @delims in @file trees!</t>
<t tx="ekr.20071028032929.885">Only shortcut pastes worked before.</t>
<t tx="ekr.20071028032929.886"></t>
<t tx="ekr.20071028032929.887">1. Changed "c" to "." in

methodKind = choose(self.fileType==".c","functions","methods")

2. Added self.rootLine logic to add @root self.fileName when importing to @root nodes.</t>
<t tx="ekr.20071028032929.888"></t>
<t tx="ekr.20071028032929.889"></t>
<t tx="ekr.20071028032929.890">Previously, Java only had block comments, and the ending delim wasn't being removed from doc parts.</t>
<t tx="ekr.20071028032929.891"></t>
<t tx="ekr.20071028032929.892"></t>
<t tx="ekr.20071028032929.893">As usual, I am leary of changing the Untangle logic.

To be effective, the @comment directive should follow the @language directive.</t>
<t tx="ekr.20071028032929.894"></t>
<t tx="ekr.20071028032929.895"></t>
<t tx="ekr.20071028032929.896"></t>
<t tx="ekr.20071028032929.897"></t>
<t tx="ekr.20071028032929.898"></t>
<t tx="ekr.20071028032929.899">The warning for "unknown language" had an unbound var.</t>
<t tx="ekr.20071028032929.900">The new code must check for @raw and @end_raw directives.</t>
<t tx="ekr.20071028032929.901">The &lt;&lt; Set path from @file node &gt;&gt; code was assuming that v.isAtFileNode() was non-Null.  This is no longer true with @rawfile.  The traceback was:

 File "c:\prog\leoCvs\leo\leoAtFile.py", line 424, in scanAllDirectives
    name = v.atFileNodeName()
AttributeError: 'NoneType' object has no attribute 'atFileNodeName'

The correct code is:

if v.isAtFileNode():
	name = v.atFileNodeName()
else:
	name = v.atRawFileNodeName()

dir = choose(name,os.path.dirname(name),None)</t>
<t tx="ekr.20071028032929.902"></t>
<t tx="ekr.20071028032929.903"></t>
<t tx="ekr.20071028032929.904"></t>
<t tx="ekr.20071028032929.905"></t>
<t tx="ekr.20071028032929.906"></t>
<t tx="ekr.20071028032929.907"></t>
<t tx="ekr.20071028032929.908">A small convenience urgently requested.</t>
<t tx="ekr.20071028032929.909">It wasn't always completely clear when the command was complete.</t>
<t tx="ekr.20071028032929.910">atFile.directiveKind returned miscDirective on _any_ line that starts with @.</t>
<t tx="ekr.20071028032929.911">This entailed using lots of ivars for communication between routines.</t>
<t tx="ekr.20071028032929.912"></t>
<t tx="ekr.20071028032929.913"></t>
<t tx="ekr.20071028032929.914"></t>
<t tx="ekr.20071028032929.915"></t>
<t tx="ekr.20071028032929.916">A recent change was not writing language names properly (double quotes were ommitted) in the &lt;preferences&gt; element of .leo files.</t>
<t tx="ekr.20071028032929.917">The new code is much simpler and more rational than the old, without affecting the defaults that are delivered by the module.

In addition, fixed a but that was causing most new params not to be written.</t>
<t tx="ekr.20071028032929.918">This directive only applies to @root trees.  Like @silent, it inhibits untangling.</t>
<t tx="ekr.20071028032929.919">Added missing comma before the keyword.</t>
<t tx="ekr.20071028032929.920"></t>
<t tx="ekr.20071028032929.921">Another major reorganization.</t>
<t tx="ekr.20071028032929.922">This was a major reorganization.</t>
<t tx="ekr.20071028032929.923"></t>
<t tx="ekr.20071028032929.924"></t>
<t tx="ekr.20071028032929.925"></t>
<t tx="ekr.20071028032929.926">Replaced almost all calls to traceback.print_exc by calls to es_exception.</t>
<t tx="ekr.20071028032929.927">We call scanAllDirectives on the _parent_ node, so no directives are recognized in the @rawfile tree itself, and directives _are_ recognized in ancestor nodes.  atFile::writeAll has new logic that recognizes @ignore in ancestors of @rawfile nodes, but not in @rawfile nodes themselves.

Writing the file was easy; updating the screen was harder.  We must redraw the screen whenever a headline changes, regardless of whether a node is joined to another.  The reason is that we must redraw the dirty bits of ancestor @file and @rawfile nodes.</t>
<t tx="ekr.20071028032929.928"></t>
<t tx="ekr.20071028032929.929">Removed v22 var from leoApp.py.
Removed ch3 var from getCwebWord() in leoColor.py
Removed self and name args from go function in leoCompare.py.
Added from leoUtils import * and from leoGlobals import * to leoCompare.py
Removed ok from onCompareFiles in leoCompare.py
Removed c from setAncestorsOfClonedNodesInTreeDirty in leoNodes.py
Removed import leoPrefs from leoAtFile.py
Moved unused assignment to top into #if 0 block in open in leoFileCommands.py
Removed unused name var from scanPHPText in leoImport.py
Bug fix: changed tangle_state to self in several places in root_attributes.__repr__
Bug fix: converted represent_print_bits to a method
	(It was indented as a method under class root_attributes)
Removed language,single_comment_string,start_comment_string,end_comment_string params from st_enter in leoTangle.py.
Bug fix (Major?): restored code to return part number at end of st_enter.
Latent bug fix: changed self.font to font in tree.setLineHeight.
Bug fix: all paths through idle_body_key and idle_head_key now return "break"
Removed topMenu var from tree.OnPopup.
Removed config var from leoFrame.__init__
Latent bug fix: changed editHeadlineMenu to self.editHeadlineMenu in leoFrame.__init__ 
Real bug fix: changed editHeadlineMenu to self.editHeadlineMenu in leoFrame.__del__
	(This affects how storage is freed)
Removed interp var from leoPyShellMain.</t>
<t tx="ekr.20071028032929.930"></t>
<t tx="ekr.20071028032929.931">Asumming that python and tcl are installed, It shouldn't take familiarity with python to be able to use leo. I want to be able to type

leo foo

and have leo start up on a new [outline] named foo.leo, or open the existing one if it's there.</t>
<t tx="ekr.20071028032929.932"></t>
<t tx="ekr.20071028032929.933"></t>
<t tx="ekr.20071028032929.934">Leo now does the following: 

1. Leo checks all characters that are entered (via typing or via paste) into headline and body text to see whether they can be represented in the encoding specified in leoConfig.txt. 

2. Leo issues a message and _disallows_ the entry of the character if it can't be represented in the encoding specified in leoConfig.txt. 

In practice, this draconian behavior shouldn't be too much of a nuisance, at least temporarily. Note that _all_ characters are valid in UTF-8 encoding, so the present version of Leo will allow you to specify all characters if you must. But the Latin-1 (iso-8859-1) encoding, being a one-byte encoding, limits you to at most 256 separate characters. 

In 3.8 I plan to allow you to use _all_ Unicode characters, regardless of encoding, by using so-called character references.  This will require some reorganization of the present code, so I don't want to delay 3.7 to handle them.</t>
<t tx="ekr.20071028032929.935">It is much more convenient to set these to proper defaults than it would be for the callers to do so.  Nevertheless, perhaps the caller should do so, but not now...</t>
<t tx="ekr.20071028032929.936"></t>
<t tx="ekr.20071028032929.937">This makes the present code compatible with Python 2.1.</t>
<t tx="ekr.20071028032929.938">I needed this clarification.</t>
<t tx="ekr.20071028032929.939">&gt; # Tk always uses utf-8 encoding.

You may get that impression, but it is slightly wrong. It is more
reliable if you pass Unicode strings to Tk, instead of UTF-8 encoded
byte strings.

For a byte string, Tk will guess the encoding. If it looks like UTF-8,
it is taken treated UTF-8. Otherwise, it is treated as the locale's
encoding. Unfortunately, if you ever manage to mix the two, you get
byte salad that you can't ever chew. By using Unicode strings to
interface with Tk only, you can avoid those problems.

&gt; print `s`,"tk"
&gt; s = s.encode("utf-8") # result is a string.
&gt; print `s`,"utf-8"
&gt; s = s.decode(xml_encoding) # result is unicode.
&gt; s = s.encode(xml_encoding) # result is a string.

Since xml_encoding is iso-8859-1, you are making a mistake here. You
have UTF-8 data, but you are decoding them as Latin-1. This will
succeed, but it will give an incorrect result. It will succeed since
iso-8859-1 is an single-byte code where every byte value is valid.
That means an arbitrary byte sequence can be interpreted as Latin-1,
but for many byte sequences, the resulting string is non-sense
(mojibake, as the Japanese say).

&gt; BTW, with out the first encode/decode pair I can take exceptions in
&gt; the last encode.

Nevertheless, this is the correct processing. If you have a Unicode
object, as originally obtained from Tk, you should encode as Latin-1
using

s = s.encode("iso-8859-1")

Now, for this specific string (u'a\u0102\xdf\xc9\n'), you will get a
Unicode error. The reason is that one character (\u0102) is not
supported in Latin-1 - this encoding supports only the first 256
Unicode characters.

So, when saving this as XML, the proper representation would be

'a&amp;#x102;\xdf\xc9\n'

i.e. you'll have to use a character reference. Python 2.2 does not
support generating such text very well - you'll have to catch the
Unicode error yourself, find the offending character, encode it as a
character reference, and encode all other characters as requested.

Alternatively, you can refuse encoding a document in a certain
encoding (such as Latin-1), and fall back to UTF-8.

PEP 293 (http://www.python.org/peps/pep-0293.html) will provide a
mechanism to generate character references more conveniently - in
Python 2.3, you can specify

  s.encode('iso-8859-1',errors='xmlcharrefreplace')

HTH,
Martin</t>
<t tx="ekr.20071028032929.940">The Find Previous command could not go to previous nodes.</t>
<t tx="ekr.20071028032929.941"></t>
<t tx="ekr.20071028032929.942">It would be good to have a prefix option too.</t>
<t tx="ekr.20071028032929.943">This fix was suggested by Rich Ries.  The original report follows:

I found the culprit; it's in the node &lt;&lt; scan @@ &gt;&gt; that reads: 

k = string.find(s,self.endSentinelComment,i) 

This means it stops at the FIRST endSentinelComment, which is the "*/". The rest of the line (with the correct "*/") gets chucked. Changing the line to: 

k = string.rfind(s,self.endSentinelComment,i) 

(note the "r" before "find") seems to fix the problem. 
</t>
<t tx="ekr.20071028032929.944"></t>
<t tx="ekr.20071028032929.945"></t>
<t tx="ekr.20071028032929.946">The new code in putOpenLeoSentinel follows the example of putSentinel.</t>
<t tx="ekr.20071028032929.947"></t>
<t tx="ekr.20071028032929.948">They are simply relative representations of absolute indices, and so are basically useless.</t>
<t tx="ekr.20071028032929.949">This is a huge step, and I hope it is forward. In any event, the change is simple and reversable.

I am now considering whether to use relative node indices instead of absolute node indices.

These would have the form +n and -n.  This would eliminate the cascade of changes when nodes were inserted.  The key question is whether the read logic can handle them.  I believe it can, with just a single ivar.</t>
<t tx="ekr.20071028032929.950">Amazingly, the only change required to allow reads and writes of cloned @file nodes was to eliminate the error in updateCloneIndices.  I also fixed a bug: set self.errors = 0 in atFile.read.</t>
<t tx="ekr.20071028032929.951"></t>
<t tx="ekr.20071028032929.952">The upshot: both =pod and =cut must be preceded and followed by blank lines.  The simple tests have this.

Added perlpod hack to set_delims_from_string and changed delims to use double underscores in set_delims_from_language.</t>
<t tx="ekr.20071028032929.953">This affects @path, @file and @root code.  This is probably the code with the most separate paths in all of Leo.  I would be amazed if there were no bugs here, and it does seem mostly to work.

The getBaseDirectory utility routine implements the relative_path_base_directory option:

"!" means relative to leo.py
"." means relative to .leo file.
anything else should be absolute path.</t>
<t tx="ekr.20071028032929.954">This was just too horrible to keep straight, and bodyKeepsFocus should always be true anyway.</t>
<t tx="ekr.20071028032929.955"></t>
<t tx="ekr.20071028032929.956"></t>
<t tx="ekr.20071028032929.957"></t>
<t tx="ekr.20071028032929.958"></t>
<t tx="ekr.20071028032929.959"></t>
<t tx="ekr.20071028032929.960"></t>
<t tx="ekr.20071028032929.961"></t>
<t tx="ekr.20071028032929.962"></t>
<t tx="ekr.20071028032929.963"></t>
<t tx="ekr.20071028032929.964">It looks like the undo command does not fully undo changes to cloned nodes. Follow these steps to experience this effect: 

1) clone a node (same effect whether @file / @root or other) 
2) change the headline of either node. 
3) Edit-&gt;Undo change Headline (or ctrl-Z) 

Only the node that was changed will go back to the original headline. The undo command appears to be the problem since it does not properly undo changes to all cloned nodes' headlines. </t>
<t tx="ekr.20071028032929.965">The new code is much more elegant than the old, and does a better job of reporting errors.

One new restriction has been imposed: at most one shortcut can be associated with a command.  If one really wanted to have two shortcuts, one would have to use two different command names.

In particular, there is now only one shortcut for the Find Next command.  This should not be a problem.

It is now possible to bind the arrow keys as desired.  See the complete discussion in leoConfig.leo.

Note that all bindings are made both to the body pane and the top-level pane. This keeps things consistent.</t>
<t tx="ekr.20071028032929.966"></t>
<t tx="ekr.20071028032929.967">There was a missing comma.</t>
<t tx="ekr.20071028032929.968">It was remembering it only if set as the result of a keystroke.  The present code is redundant, but what the heck.</t>
<t tx="ekr.20071028032929.969">1. Use the present body font in frame.setTabWidth.

2. Do not call frame.setTabWidth in setCommandsIvars.  Just set the ivar.  This fixes the following bug:

"If you set the @tabwidth to something other than the Preference value, you'll
see the body displayed appropriately.  However, if you do a Ctrl-s to save the
leo file, the body is redisplayed using the Preferences setting -- of course,
clicking on another node and then back to the original node displays with the
correct tab setting again.  The redisplay on save must not go through precisely
the same body display logic."
</t>
<t tx="ekr.20071028032929.970">This was too confusing to users.</t>
<t tx="ekr.20071028032929.971"></t>
<t tx="ekr.20071028032929.972">This was done simply by opening derived files and .leo files in "wb" mode.</t>
<t tx="ekr.20071028032929.973">Essentially I moved the code that updates body text from the @+node logic to the @+body logic.

This can not be completely correct.  It breaks verbatimAfterRef

From the forum message:

I have just uploaded a major change to the logic that reads derived files. Indeed, this is the first change to that logic that has ever been made since I first invented @file trees. This change is needed to correct a bug reported by Rich Ries involving referencing a section defined in a grandchild of the referencing node. 

WARNING: although this code is similar to previous code, and passes all the tests that I can think of, you
should still consider this code experimental for a while. 

The problem: Body text was being updated as the result of @+node sentinels rather than @+body sentinels.
This was stupid, as extra @+node sentinels are often generated when no body text is generated. The result is
that the body text was being cleared. 

The fix: I simply moved the code that creates body text from the @+node logic to the @+body logic in
scanText. This was relatively straightforward, and I do have some hopes that everything will once again be rock
solid. However, the context in which this code is executing is obviously changed (that is, after all, the whole
point), so no guarantees can be given at this point. 

Everything appears to work (all files derived from this file appear to be OK), and this code must be considered experimental for now.</t>
<t tx="ekr.20071028032929.974"></t>
<t tx="ekr.20071028032929.975">At this point there are no known issues with Leo and Python 2.1.

Python 2.1 gave the following warnings when importing Leo:

Python 2.1.3 (#35, Apr  8 2002, 17:47:50) [MSC 32 bit (Intel)] on win32
Type "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import leo

leoFrame.py:197: SyntaxWarning: local name 'self' in 'createMenuBar' shadows use of 'self' as
global in nested scope 'lambda'
  def createMenuBar(self, top):

leoFrame.py:1262: SyntaxWarning: local name 'self' in 'OpenWithFileName' shadows use of 'self' as
global in nested scope
 'lambda'
  def OpenWithFileName(self, fileName):

leoColor.py:1367: SyntaxWarning: local name 'self' in 'run' shadows use of 'self' as
global in nested scope 'lambda'
  def run (self):
</t>
<t tx="ekr.20071028032929.976"></t>
<t tx="ekr.20071028032929.977"></t>
<t tx="ekr.20071028032929.978"></t>
<t tx="ekr.20071028032929.979"></t>
<t tx="ekr.20071028032929.980">It was just a matter of binding some unbound vars to defaults.</t>
<t tx="ekr.20071028032929.981">- The font settings in leoConfig.txt are not active when I open Leo. They instantly activate when opening the Edit|Set Font... dialog, without having to click anything in said dialog. Then, once the .leo file is saved, the problem goes away.</t>
<t tx="ekr.20071028032929.982"></t>
<t tx="ekr.20071028032929.983"></t>
<t tx="ekr.20071028032929.984">This code improperly removed trailing whitespace, including newlines, from the "middle" text.  Clearly this is wrong, regardless of what other effects it might have.

Affected commands are indent, dedent, extract and extract section.</t>
<t tx="ekr.20071028032929.985"></t>
<t tx="ekr.20071028032929.986">This makes it convenient to update the version number in this file properly.</t>
<t tx="ekr.20071028032929.987"></t>
<t tx="ekr.20071028032929.988">We now look through the entire tree looking for @root and @file nodes.</t>
<t tx="ekr.20071028032929.989">single quote colorized text in plain text mode.  This was due to missing parentheses.</t>
<t tx="ekr.20071028032929.990"></t>
<t tx="ekr.20071028032929.991"></t>
<t tx="ekr.20071028032929.992"></t>
<t tx="ekr.20071028032929.993"></t>
<t tx="ekr.20071028032929.994"></t>
<t tx="ekr.20071028032929.995"></t>
<t tx="ekr.20071028032929.996">CVS conflict files produce so many error messages that these errors are useless.</t>
<t tx="ekr.20071028032929.997">1. Created a new sandbox and updated CVS into it.  This did not update LeoPy.leo.
2. Opened LeoPY.leo.  There were read errors in leoImport.py and leoUtils.py.
3. Used diff on CVS to determine which routines had been added to these files.
4. Cut and pasted from updated LeoPy.leo to my "real" copy of LeoPy.leo.

This is most annoying, though it is helpful to pay attention to the added code.

The read errors themselves are useless, and I removed them.

I forgot to do an update first, so after I opened LeoPy.leo with Read Outline Only, saving all files with Write @file Nodes reverted Dave Hein's changes.  So I reloaded them from the temporary sandbox.  This is very bad.</t>
<t tx="ekr.20071028032929.998"></t>
<t tx="ekr.20071028032929.999"></t>
<t tx="ekr.20071028032929.1000"></t>
<t tx="ekr.20071028032929.1001">The code is now functionally identical to the similar code in atFile.scanAllDirectives.  The old code did not handle relative paths properly in all cases.</t>
<t tx="ekr.20071028032929.1002"></t>
<t tx="ekr.20071028032929.1003">This code crashes on some Windows systems, including my XP system.  It may work on Win98.</t>
<t tx="ekr.20071028032929.1004">This involved calling readlineForceUnixNewline instead of readline in the atFile:read logic.</t>
<t tx="ekr.20071028032929.1005"></t>
<t tx="ekr.20071028032929.1006"></t>
<t tx="ekr.20071028032929.1007"></t>
<t tx="ekr.20071028032929.1008"></t>
<t tx="ekr.20071028032929.1009"></t>
<t tx="ekr.20071028032929.1010">Only the last directive was in effect in @root trees.  The new code allows node-by-node control.</t>
<t tx="ekr.20071028032929.1011">This routine does a better job of checking the Tk version than the old code in leoApp.py</t>
<t tx="ekr.20071028032929.1012">With Tk/Tcl 8.4, the Preferences window is empty (no buttons, fields, labels). 

Tcl 8.4 complains about using "col" in the grid() calls.</t>
<t tx="ekr.20071028032929.1013">Removed calls to c.frame.canvas.focus_force() selectThreadBack/Next, selectVisBack/Next.

I have no idea why this code was there originally.</t>
<t tx="ekr.20071028032929.1014">This may or may not fix Rich Reis's problems.</t>
<t tx="ekr.20071028032929.1015">How did I ever live without this?</t>
<t tx="ekr.20071028032929.1016"></t>
<t tx="ekr.20071028032929.1017">Changed:

bitmap_name = os.path.join(self.loadDir,"Icons\LeoApp.ico") 

to:

bitmap_name = os.path.join(self.loadDir,"Icons","LeoApp.ico") 
</t>
<t tx="ekr.20071028032929.1018"></t>
<t tx="ekr.20071028032929.1019">&gt; I'd love to open a node and be in the same place as when I was last there.
</t>
<t tx="ekr.20071028032929.1020">Everything appears to be working properly.</t>
<t tx="ekr.20071028032929.1021">When starting Leo with no arguments the 'NewHeadline' node was not displayed. </t>
<t tx="ekr.20071028032929.1022">os.rename can fail on some Linux systems.</t>
<t tx="ekr.20071028032929.1023">@nocolor

The new code is as follows.  This is extremely ugly, and I'm not sure there is any workaround.  The problem is that open is really just a stand-in for C's fopen routine, and the mode param is not uniform across platforms.

@color

# 9/1/02: apparently Linux requires w+ and XP requires w.
mode = choose(sys.platform=="win32","w","w+")
cf = open(self.configFileName,mode)</t>
<t tx="ekr.20071028032929.1024"></t>
<t tx="ekr.20071028032929.1025"></t>
<t tx="ekr.20071028032929.1026">This will allow Joe Orr to keep track of hits.</t>
<t tx="ekr.20071028032929.1027">The cursor now changes to an arrow when it moves over a link.</t>
<t tx="ekr.20071028032929.1028">1.  The link now takes the user to the SourceForge download page.
2.  Called os.setcwd(app().loadDir) to set the working directory for the download.</t>
<t tx="ekr.20071028032929.1029"></t>
<t tx="ekr.20071028032929.1030">This is still not working, and I am beginning to doubt that it can be done.

Notes:

1. In Tk terminology, bitmaps are 2-color only.  Most .bmp files must be considered _photo_ files.
2. I have figured out how to read .bmp and .gif files using image create photo.
3. All tests were run using tcl/tk 8.3.4, and wm iconbitmap has never worked.</t>
<t tx="ekr.20071028032929.1031">It already works in the other panes, but the recommended code crashes tk83.dll!</t>
<t tx="ekr.20071028032929.1032"></t>
<t tx="ekr.20071028032929.1033"></t>
<t tx="ekr.20071028032929.1034"></t>
<t tx="ekr.20071028032929.1035"></t>
<t tx="ekr.20071028032929.1036"></t>
<t tx="ekr.20071028032929.1037"></t>
<t tx="ekr.20071028032929.1038">There were a couple of botches in the new code:

1. leoTangle.scanAllDirectives should not issue any warning when it sees a relative path name in the @root directive.  (Which is the only place it will see it).  This is not an error.

2. leoTangle.pathError would create an exception when called.</t>
<t tx="ekr.20071028032929.1039"></t>
<t tx="ekr.20071028032929.1040"></t>
<t tx="ekr.20071028032929.1041">Amazing!</t>
<t tx="ekr.20071028032929.1042">1. Simplified the path logic in the various scanAllDirectives routines.

2. Distinguished between absolute and relative paths.  Relative paths do _not_ set the global defaults: they are handled by the file open logic which does os.path.join(default_path,file_name).

The logic is still quite complex, and for the first time the code may be simple enough to work.</t>
<t tx="ekr.20071028032929.1043">This should end most of the confusion.</t>
<t tx="ekr.20071028032929.1044">There are several problems here:

1. os.path.join(dir,file) won't work if both dir and file contain a partial path name.  I'm not sure whether this is a bug--there is probably no behavior that makes sense in all cases.

2. Unless os.path.join works above there is no way to see whether the directory is valid.</t>
<t tx="ekr.20071028032929.1045">Removed '\r' characters when reading.  The write logic is unchanged, which makes the changes slightly safer.</t>
<t tx="ekr.20071028032929.1046"></t>
<t tx="ekr.20071028032929.1047"></t>
<t tx="ekr.20071028032929.1048">An arg got dropped out when I added a flag.</t>
<t tx="ekr.20071028032929.1049">Found several bugs while doing so.  What else is new...

Use this script as follows:

- Select the node under which you want the imported files to appear.
- Open the Python window within Leo.
- Type the following in the Python window:

import leoImport
dir = "c:/prog/test"  # or some other directory
type = ".py"  # Type of files you want to import, or None for all files.
leoImport.importFiles(dir,type)</t>
<t tx="ekr.20071028032929.1050"></t>
<t tx="ekr.20071028032929.1051"></t>
<t tx="ekr.20071028032929.1052"></t>
<t tx="ekr.20071028032929.1053"></t>
<t tx="ekr.20071028032929.1054">The new code properly deletes previous entries regardless of case or path separators.</t>
<t tx="ekr.20071028032929.1055">Changed idle_body_key and idle_head_key so the old values are also checked for Unicode strings.  I don't understand why that is needed, and after a cut and paste operation it is needed.

Also fixed Tangle's version of the os routine.

Also changed the assertion and converted to unicode in tnode::setTnodeText.</t>
<t tx="ekr.20071028032929.1056"></t>
<t tx="ekr.20071028032929.1057">The calls to config.setX in the put routines in leoFileCommands.py were happening _after_ the calls to config.update().  There is not need to call the config.set routines in putPrefs and putFindSettings provided we do the following in write_LEO_file:

	c.setIvarsFromFind()
	config.setConfigFindIvars(c)
	c.setIvarsFromPrefs()
	config.setCommandsIvars(c)
	config.update()</t>
<t tx="ekr.20071028032929.1058">This creates leoConfig.txt</t>
<t tx="ekr.20071028032929.1059">The old code was totally brain dead.  If a setting was missing or "ignore" it could never be set!!  Sheesh.  This is a major bug because _all_ writes to leoConfig.txt go throught this routine.</t>
<t tx="ekr.20071028032929.1060"></t>
<t tx="ekr.20071028032929.1061">Otherwise there is no way to change the prefs!</t>
<t tx="ekr.20071028032929.1062">There were a couple of bugs here.

Note that the ratio (whichever the direction) is stored in the .leo file.  The initial_splitter_orientation setting in leoConfig.txt applies to _all_ files.  The initial_vertical_ratio and the corresponding initial_horizontal_ratio  apply only to new files, so are essentially useless.

Yes, this is pretty stupid; it's the result of not wanting to add more stuff to Leo's file format.</t>
<t tx="ekr.20071028032929.1063"></t>
<t tx="ekr.20071028032929.1064">This makes selected text look much better and makes Show Invisibles look much better as well.  

This was not easy to do.  Apparently tag settings interfer with the Tk.Text settings.  I have not found a way to specify the selectbackground color for tags.  The only way I could get things to work is only define whitespace tags when in showInvisibles mode.</t>
<t tx="ekr.20071028032929.1065">Added setRevertVars to update revert settings.  This is called from __init__ and onOk.</t>
<t tx="ekr.20071028032929.1066">This is consistent with what the Import commands do for the other file types.  It's also much safer.</t>
<t tx="ekr.20071028032929.1067">.tmp files disappear On Windows XP after Leo exits!</t>
<t tx="ekr.20071028032929.1068"></t>
<t tx="ekr.20071028032929.1069">The new spelling is to limit_directory_search_extension.  Note that this affects the valid entries in leoConfig.txt.</t>
<t tx="ekr.20071028032929.1070">Repeated double-clicking (without intervening single-click) caused the selection to move to the left.</t>
<t tx="ekr.20071028032929.1071"></t>
<t tx="ekr.20071028032929.1072">We must remove backticks from messages that might contain unicode characters so they will print properly.  There were only a few instances, and they are all error messages that hardly ever get executed, so I hope I was careful putting them in.  I should be able to find them all by looking for '"'.</t>
<t tx="ekr.20071028032929.1073">Simplified leoCompare.py and leoTangle.py.</t>
<t tx="ekr.20071028032929.1074">Now at last it is clear why Leo hasn't been writing derived files affected by clones.  It's not enough to mark v dirty.  We must mark all the cloned nodes of v's tree dirty as well.

However, we only need do this when a node is deleted, and we definitely do _not_ want to do this otherwise, for that would mark far too many nodes dirty.  To get around this, we leave v.setDirty() as it was, and use the new code only in v.setDirtyDeleted.

Note that the undo and redo cases handle this automatically because they call c.doDelete.</t>
<t tx="ekr.20071028032929.1075"></t>
<t tx="ekr.20071028032929.1076"></t>
<t tx="ekr.20071028032929.1077">Amazing.  All that was needed was some code to force conversion on write, and code in the event handlers to convert "real" unicode to UTF-8.  We are talking about 10 lines of code!

There was a problem in leoFind.findNext: it was backquoting the search string when reporting search failures.  Removing the back quotes made the message appear properly.

What was needed was simply to do:

	if type(s) == types.UnicodeType:
		xml_encoding = app().config.xml_version_string
		s = s.encode(xml_encoding)

On the string s gotten from the Text widgets in the event handlers.

As a defensive measure, I also changed the write code in two places to:

	try:
		self.outputFile.write(s)
	except UnicodeError: # This might never happen.
		xml_encoding = app().config.xml_version_string
		s = s.encode(xml_encoding)
		self.outputFile.write(s)

The old code wrote `s` instead of s.encode(xml_encoding).</t>
<t tx="ekr.20071028032929.1078">Also changed the calling code to check for val != None and val &gt; 0 or val != 0.  The only callers of skip_long are the various places that handle the @pagewidth and @tabwidth code.  Negative tab widths are allowed, but not negative page widths.</t>
<t tx="ekr.20071028032929.1079">Initializing to something else was preventing a lot of code from being used!

Retested the @path logic.  Everything seems good.</t>
<t tx="ekr.20071028032929.1080">These were used only to set the delim1, delim2 and delim3 locals in atFile.scanAllDirectives.  Getting rid of these two useless ivars greatly clarifies the code.</t>
<t tx="ekr.20071028032929.1081">This is weird.  set_language would set the delims to the default_language delims if the lanuage was "default"</t>
<t tx="ekr.20071028032929.1082"></t>
<t tx="ekr.20071028032929.1083">We can't use choose because both branches are evaluated.

self.single_comment_string was never None before because all languages had either 1 or 3 delims.  But Java now has only 2 delims to force block comments.</t>
<t tx="ekr.20071028032929.1084">The same bug appeared in leoAtFile.putIndent and leoTangle.put_leading_ws.  These routines should not do w = abs(tab_width) before the test.  I was confused that n (the desired indentation) might be negative.

Anyway, as a defensive measure, I used ' ' * abs(n) and '\t' * abs(n) in the routines in leoAtFile and leoTangle that put tabs and spaces.

Also, changed n / w to int(n/w) to avoid problems with future division.</t>
<t tx="ekr.20071028032929.1085">1. The botch was this: set_delims_from_language used to return
	delim1 = start_block_comment_string
	delim2 = end_block_comment_string
if there were only two delims.  But the callers thought that delim1 was _always_ the single_comment_string.

This actually never caused problems with @language, because all languages had either 1 or 3 delimiters.  However, it appeared when I forced block comments in Java by using only two delims.  And it could always have caused problems when people used the @comment directive.

2. Issued a warning and do nothing when no delims specified with @comment.  This could have caused crashes.

3. set_delims_from_string no longer returns hard-coded defaults.  Instead it returns None.  Callers must now beware, but this is the correct action to take.</t>
<t tx="ekr.20071028032929.1086">The change was made to leoFrame.py::reconfigurePanes.</t>
<t tx="ekr.20071028032929.1087"></t>
<t tx="ekr.20071028032929.1088">If a name table has only one name, it must be defined like

name = ("x",)

rather than

name = ("x")

This affected the following options:

"read_only"
"xml_version_string"
"limit_count"
"body_pane_wraps"</t>
<t tx="ekr.20071028032929.1089">1. Removed the following ivars.  They were never used.

self.singleCommentString = "#"
self.startCommentString = ""
self.endCommentString = ""

2. Initialized the following ivars to None in the ctor:

self.default_directory = None
self.page_width = None
self.tab_width  = None
self.presentLanguage = None
self.targetLanguage = None
self.startSentinelComment = None
self.endSentinelComment = None

This makes clear that they are really initialized in leoAtFile.scanAllDirectives.

3. Renamed leoAtFile.scanAllDirectives.&lt;&lt; Set delims to default values &gt;&gt; to &lt;&lt; Set ivars &gt;&gt;.  It's contents is now:

if 1: # 8/2/02
	self.page_width = self.commands.page_width
	self.tab_width = self.commands.tab_width
	self.presentLanguage = self.targetLanguage = c.target_language
else:
	self.page_width = leoPrefs.default_page_width
	self.tab_width = leoPrefs.default_tab_width
	self.presentLanguage = self.targetLanguage = leoPrefs.default_target_language
	
self.default_directory = leoPrefs.default_default_directory
delim1, delim2, delim3 = set_delims_from_language(self.presentLanguage)</t>
<t tx="ekr.20071028032929.1090"></t>
<t tx="ekr.20071028032929.1091">There were many, many problems in the old color panel.

- Completely revised the Revert logic in the main Color panel.
- The color name picker now reverts properly.
- Color names and color swatches are now properly updated in all cases.
  As a result, there is no need to write color values to the log window.
- Used str(name) rather than `name` to eliminate quotation marks around color names and values.
- The color picker now shows the value of the present color, not the revert color.
- Increased the width of name buttons to handle long color names.
</t>
<t tx="ekr.20071028032929.1092">See the child node for a proof.</t>
<t tx="ekr.20071028032929.1093">@nocolor

The test code shows that all normal cases are handled correctly.  Nevertheless, we must prove that Leo can properly read and write @file nodes with nested @others directives.

Writing:

putAtOthers writes all nodes to be generated by @others.  inAtOthers returns false if the node has already been visited.  Nodes will not be visited when expanding the "outer" or "upper" @others, and will be visited thereafter.  Thus, nodes will be written at most once.

putAtOthers writes only sibling nodes and nodes descending from sibling nodes.  The expansion of inner @others nodes will never include parent nodes.  The expansion of an @others directive at @file node will write all unwritten nodes in the @file node.

In short,

1. all nodes in the "range" of an @others directive are written once and only once.
2. all nodes in the "range" of an @others directive are written enclosed in @+-others sentinels.
3. No orpan nodes are written.

Reading:

The read logic is unchanged.  Everything will work as before.  In particular, note that @+-others sentinels create trees under nodes containing the @others directive, just as before.  The read logic naturally handles nesting!</t>
<t tx="ekr.20071028032929.1094"></t>
<t tx="ekr.20071028032929.1095">The bug was testing for ifdef instead of #ifdef at the start of skip_pp_if.  However, I thought the bug might be related to something else, so I ended up being much more careful about brace levels in different branches of an #if statement.  The result was the skip_pp_part routine.</t>
<t tx="ekr.20071028032929.1096">I think this is most reasonable: we don't wan't people generating files from imported files unless they take some positive action.</t>
<t tx="ekr.20071028032929.1097">This bug caused following defs to be included in the current def if the line ended in a comment that was followed immediately by another def.</t>
<t tx="ekr.20071028032929.1098">I wanted to generate the following if a class declaration is in a separate node:

class x:
	@others

Instead of:

class x:
	&lt;&lt; class x methods &gt;&gt;

+ &lt;&lt; class x methods &gt;&gt;
@others

This doesn't work at first: all nodes under class x become orphans.  However, the new version of 
</t>
<t tx="ekr.20071028032929.1099">In order to make the new import code work, I have _experimentally_ allowed a change to how leoAtFile writes code.  This is the first such change in about a year.

The old code in leoAtFile.inAtOthers did not write nodes in @others trees if such nodes descended from another @others node.  The new code allows such nodes.  Apparently the write code handles this case just fine and the old restriction was unnecessary...</t>
<t tx="ekr.20071028032929.1100">Added entries for default target language, outline, promote and demote.</t>
<t tx="ekr.20071028032929.1101">The code now makes sure that c.target_language and related vars are not None.  This should fix the problem, and I wouldn't bet my life on it.</t>
<t tx="ekr.20071028032929.1102">It's too confusing to have arrow keys mean different things in different panes.

For one thing, we want to leave the focus in the body pane after the first click in the outline pane, but that means that the arrow keys must still be functional in the _body_ pane!

Alas, all the various combinations of key bindings of arrow keys appear to do something; there are none left to use for moving around in the outline pane.  So we are stuck with poor shortcuts.</t>
<t tx="ekr.20071028032929.1103"></t>
<t tx="ekr.20071028032929.1104">The @others directive was appearing before &lt;&lt; declarations &gt;&gt; reference.

The bug report and the fix were from Walter H. Rauser.</t>
<t tx="ekr.20071028032929.1105"></t>
<t tx="ekr.20071028032929.1106">I used the dis module as a base.  It was remarkably easy.  All I needed was

1. dis.opname, the names of the opcodes and
2. some code in the dis module to use as a starting point.</t>
<t tx="ekr.20071028032929.1107">The performance of Leo is as I expected.  In particular, reading files is the biggest bottleneck, and scanning string.find, isAtFileNode, is_ws, etc. are called frequently.</t>
<t tx="ekr.20071028032929.1108"></t>
<t tx="ekr.20071028032929.1109"></t>
<t tx="ekr.20071028032929.1110"></t>
<t tx="ekr.20071028032929.1111">@nocolor

Bernhard Mulder suggested the following code for adding the path to idle to sys.path.  I used this code with only trivial modifications.  I retained the previous error handling code in case there are further exceptions...

@color

try: 
	import idle 
except: 
	executable_dir = os.path.split(sys.executable)[0]
	idledir=os.path.join(executable_dir, "tools/idle") 
	sys.path.append(idledir)
</t>
<t tx="ekr.20071028032929.1112">The fix was to put a call to frame.top.deiconify() in run() right after the call to the frame ctor.

Apparently I only use openLeo.py to open Leo.</t>
<t tx="ekr.20071028032929.1113">The Compare panel is much easier to use than the old scripts in leoCompare.py.</t>
<t tx="ekr.20071028032929.1114"></t>
<t tx="ekr.20071028032929.1115">It is remarkable how recasting the code as two classes clarifies and fortifies the code.</t>
<t tx="ekr.20071028032929.1116">@nocolor

The new rules allow leo.py 3.1 to read and write .leo files more like leo.py 2.x when there is no leoConfig.txt file.  The scheme used in leo.py 3.0 meant that preferences were _never_ written to .leo files.  It's advantage was that all defaults were specified in:

	leoConfig.&lt;&lt; define default tables for settings &gt;&gt;

I think the present scheme is more natural, but we shall see...

In effect, Leo sets and gets various options in the following order of precedence:

1. Use explicit settings in leoConfig.txt if they exist.

2. Use defaults for leoConfig.txt, but only if leoConfig.txt exists.  These defaults are found in:

	leoConfig.&lt;&lt; define default tables for settings &gt;&gt;

3. Use settings in .leo files if leoConfig.txt does not exist.

4. If leoConfig.txt does not exist, and the .leo file does not specify a setting, use hard-coded settings in the various classes, just as leo.py 2.x did.

Added the config.configsExist ivar to tell whether leoConfig.txt exists (as far as Leo is concerned).</t>
<t tx="ekr.20071028032929.1117">Also added tcl keywords for syntax coloring.</t>
<t tx="ekr.20071028032929.1118">The @pagewidth, @tabwidth and @language directives could not have worked while tangling!  Apparently nobody has every used these directives in @root trees!

1. Apparently, skip_long had never been executed successfully (!!)  Indeed, it computed the value of a string character by character using (s[i] - '0') which has no chance of ever working!

2. The code in tangle.scanAllDirectives that handles @pagewidth and @tabwidth could not have ever worked. is_special_bits sets the dict entries for "page_width" and "tab_width", but tangle.scanAllDirectives looks for dict["pagewidth"] and dict["tab_width"], both of which will cause exceptions!

3. The code in tangle.scanAllDirectives that handles @language failed to set the self.x copies of the c.x ivars relating to language! This bug may have dated from fairly recent times when I changed the tangle code to use the self.x ivars rather than the c.x ivars.</t>
<t tx="ekr.20071028032929.1119"></t>
<t tx="ekr.20071028032929.1120">This affects Flatten Outline and Import Flattened Outline.</t>
<t tx="ekr.20071028032929.1121">While I was at it, I made a few minor changes to leoDialog.py.

1.  Added padx and pady padding in dialogs.
2.  Added text="OK" param to AskOk.
3.  Used center_dialog utility in leoDialog.center.

The leoDialog code is still ugly, but not ugly enough to fix.</t>
<t tx="ekr.20071028032929.1122"></t>
<t tx="ekr.20071028032929.1123">I wanted to see if this would corrupt any derived files by interrupting the write.  I doubted that this would be so: events do not work like interrupts.

What happened was that the pending event seemed to slow the writing, and all derived files were written correctly.</t>
<t tx="ekr.20071028032929.1124">The answer to the question, "why not just improve compare scripts?" is that people rarely use scripts.  A compare window would be much more convenient.  And convenience matters here: it is very important that people feel comfortable importing and exporing files.</t>
<t tx="ekr.20071028032929.1125"></t>
<t tx="ekr.20071028032929.1126"></t>
<t tx="ekr.20071028032929.1127">Found many spelling errors and repeated words.</t>
<t tx="ekr.20071028032929.1128">We can't just keep getting the x,y coordinates from the event, because then we can't stop.</t>
<t tx="ekr.20071028032929.1129">All files now pass.  I changed the followoing:

	leoAtFile.py:   found bug: unbound c in read()
	leoColor.py:    removed import keyword
	leoCommands.py: removed unused vars from Convert Blanks.
</t>
<t tx="ekr.20071028032929.1130"></t>
<t tx="ekr.20071028032929.1131"></t>
<t tx="ekr.20071028032929.1132">It was amazingly easy to do this.  We need only compute self.line_height from self.font.metrics().</t>
<t tx="ekr.20071028032929.1133">Also fixed a but that resulted in Convert Tabs being undoable.</t>
<t tx="ekr.20071028032929.1134">There were several important optimizations:

1. OnDrag precomputes self.numberOfVisibleNodes().
2. Eliminate all calls to findVnodeWithIconId() in OnContinueDrag.</t>
<t tx="ekr.20071028032929.1135">Including the split direction and split ration.

Leo now uses all configuration settings from leoConfig.txt.</t>
<t tx="ekr.20071028032929.1136">Just putting a call to update() in leoFileCommands.getGlobals() does 90% of what we want.  Moving the calls to

	frame.top.deiconify()
	frame.top.lift()
	
from OpenWithFileName to getGlobals gets us to 99% of perfection.  There is a tiny flash when the frame created in leoFrame.__init__ is drawn then withdrawn.

The last 1% is accomplished by withdrawing the newly-created frame in frame.__init__.  With this last change there is no perceptable flash when a window is opened.  Of course, all callers of frame.__init__ must now call deiconify as needed.

Trying not to create a frame at all until its size is known would be much, much harder, because the frame and commands classes initialize each other.
</t>
<t tx="ekr.20071028032929.1137">The bug was in leoFileCommands.getGlobals.

This was a _really_ irritating bug.  Now windows open where they were when closed.</t>
<t tx="ekr.20071028032929.1138">This saves the "user" code a lot of work.

Note: if leoConfig.txt does not exist, the default tables in the section called:

&lt;&lt; define default tables for settings &gt;&gt;

in leoConfig.py take effect, so modifying these tables is yet another way of managing preferences.</t>
<t tx="ekr.20071028032929.1139"></t>
<t tx="ekr.20071028032929.1140">The present code works wether we destroy the prefs, font and color panels when we close them, or just withdraw them.  It is best to withdraw them, because this preserves their location on the screen when we bring them back.

Some things to keep in mind about this code:

1.  There must be code in frame.OnCloseLeoEvent to destroy these frames if present.  The reason is that these are now non-modal frames, so they could still be open when we close the Leo window that "owns" them.
This is true Regardless of whether these frames are withdrawn or destroyed when closed.

2.  Since the window are no longer modal, we might try creating them after they exist.  In that case, we must simply deiconify the panel, even if we destroy panels when they are closed.

In both cases, we _must_ maintain ivars accurately telling whether the panels have been created or not.  These ivars are owned by the leoFrame class.  They are created by leoFrame when creating a frame, and set to Null by panel code if panels are destroyed when closed.  Since the leoFrame class owns these ivars, a cleaner way would be to create a frameDestroy method for each kind of panel.  But that borders on the pedantic...</t>
<t tx="ekr.20071028032929.1141"></t>
<t tx="ekr.20071028032929.1142"></t>
<t tx="ekr.20071028032929.1143">so code can say getXparam("name") and always get a proper value.</t>
<t tx="ekr.20071028032929.1144">This was easy to do and useful.</t>
<t tx="ekr.20071028032929.1145">This was much more work than it "ought" to have been, due mainly to the fact that Tk.ListBox does not have a callback for changed selection.  So the selection becomes active only on a double-click or a change to the size or bold or italics boxes.

The present frame seems to handle all cases properly and without surprise.  The code to do so is tricky.</t>
<t tx="ekr.20071028032929.1146"></t>
<t tx="ekr.20071028032929.1147">All that is needed is that each Font and Color panel be firmly connected to a particular Leo window.  In fact, we must have separate Font &amp; Color panels for each Leo window.  The point isn't that we want all these window: in practice there is almost always just one Leo around. The point is that we can eliminate the irritation of modal windows!

This insight also applies to the Preferences panel.  It's not so important for the Find/Change window.</t>
<t tx="ekr.20071028032929.1148">This was a _huge_ amount of work.  I am quite proud of the result.  The present font panel is much more elegant and less cluttered than the examples I have looked at.  Indeed, the font panel pack a lot of power in a very small space.  I think this is really elegant design.

I spent hours and hours experimenting with different looks.  I finally realized that there is no need for radiobuttons:  they just add clutter.  More importantly, there is no need for an example frame!  The entire Leo window becomes an example.</t>
<t tx="ekr.20071028032929.1149"></t>
<t tx="ekr.20071028032929.1150">Leo keywords were mostly being coloring under the keyword settings.</t>
<t tx="ekr.20071028032929.1151">Using Ok, Cancel &amp; Revert buttons is _much_ better than Ok, Apply, Cancel because changes are made instantly.  The only problem is that the modal dialog makes it impossible to change text.  But with just a little foresight the user could create a "test" document beforehand.</t>
<t tx="ekr.20071028032929.1152"></t>
<t tx="ekr.20071028032929.1153">Leo now uses the xml_version_string configuration setting, if present, to override the UTF-8 setting used in all previous versions of Leo.  The usual value of the setting is = ISO-8859-1.  This effective changes Leo's file format: older versions of Leo will not be able to read the new files.

If the setting does not exist, whatever value is present in the .leo file will be written when the file is written.  For new files, a value of ISO-8859-1 will be used when this setting is not present.

Notice that this also affects what is written to the clipboard.</t>
<t tx="ekr.20071028032929.1154"></t>
<t tx="ekr.20071028032929.1155"></t>
<t tx="ekr.20071028032929.1156">Used the following to bind callbac:

@color

for i in xrange(len(self.recentFiles)):
	name = self.recentFiles[i]
	callback = lambda n=i: self.OnOpenRecentFile(n)
	recentFilesMenu.add_command(label=name,command=callback)
	
@nocolor
</t>
<t tx="ekr.20071028032929.1157"></t>
<t tx="ekr.20071028032929.1158"></t>
<t tx="ekr.20071028032929.1159"></t>
<t tx="ekr.20071028032929.1160"></t>
<t tx="ekr.20071028032929.1161">1. The @comment directive no longer suppresses syntax coloring.

2. Directives (but not doc parts) are colored when @language plain is in effect.  The user can, as always, suppress all coloring by using @nocolor.

The new rules are much more natural than the old, and much less confusing.</t>
<t tx="ekr.20071028032929.1162">This was a bit of a fiasco.  I updated CVS without a real test.  Hopefully I'll learn from this.

Anyway, the REM hack is as follows:  Leo will convert underscores in the @comment directives to significant spaces.  For example,

@comment REM_

causes the comment delimiter to be "REM " (Note the trailing space).

I originally inserted a skip_space in sentinelKind where the comment was "Do not skip spaces here!".  However, I eventually settled on a better solution, namely making spaces significant in scanHeader. To quote from scanHeader:

"Leading whitespace is now significant here before the @+leo.  This is part of the "REM hack".  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches."</t>
<t tx="ekr.20071028032929.1163">The "comment" code was looking for "language", not "comment" in dict.</t>
<t tx="ekr.20071028032929.1164">I'm proud of the code: it is simpler, clearer and more general than the previous code.

There were several important breakthroughs:

1. The old divideSplitter routine had hard binding to various panes.  This was wrong.  The new divideAnySplitter routine uses params for all frames, so it can be general.

2. The key invariant is that self.splitVerticalFlag tells the alignment of the main splitter.  Getting clear about this was crucial to making everything work.  I could then split the old divideSplitter routine into divideLeoSplitter and divideAnySplitter.  Once that happened, everything just worked when I changed self.splitVerticalFlag from true to false in frame.__init__ (!!)

3. We shouldn't ever delete any frames when toggling the split direction.  It's just too hard to reinitialize them.  The key to making this happen are:

a) the calls to pack_forget and
b) creating placeSplitter from the old createSplitter (now createLeoSplitter) code.

4. The key invariant allows us to define onDragMainSplitBar and onDragMainSplitBar instead of the old onDragVSplitBar and onDragHSplitBar. The new routines work regardless of split direction, so we don't have to rebind the split bars when the split direction changes.</t>
<t tx="ekr.20071028032929.1165"></t>
<t tx="ekr.20071028032929.1166"></t>
<t tx="ekr.20071028032929.1167">Change c.initJoinedCloneBit to c.initJoinedCloneBits.</t>
<t tx="ekr.20071028032929.1168"></t>
<t tx="ekr.20071028032929.1169"></t>
<t tx="ekr.20071028032929.1170"></t>
<t tx="ekr.20071028032929.1171">Added @root node to root of tree and eliminated @language and @others directives.</t>
<t tx="ekr.20071028032929.1172">Importing a Python file containing classes without methods results in nested classes.  A workaround is to insert a dummy method in each class.

The fix was to define classIndent and defIndent variables, and to ensure that we break on equality with these values.  Also changed code to generate reference to methods only if methods or nested classes were seen.

There is still a minor bug:  The following

class A:
	pass

Puts the pass statement in &lt;&lt; class A declarations &gt;&gt;.  This bug is not so easy to fix, and it is easy to correct by hand.</t>
<t tx="ekr.20071028032929.1173">Importing the following file creates orphan nodes for declaration.

import sys # This line becomes an orphaned node
class C:
    xyz = 'xyz' # This line becomes an orphaned node
    def __init__(self):
        pass

The fix was in &lt;&lt; Create a child node for declarations &gt;&gt;.</t>
<t tx="ekr.20071028032929.1174">Importing the following script

class C:
    def __init__(self):
        pass

created an outline with class C appearing in two nodes, something like:

class C:
        class C:
                def __init__(self):
                    pass

The fix was to &lt;&lt; Append a reference to class_vnode's methods &gt;&gt;.</t>
<t tx="ekr.20071028032929.1175"></t>
<t tx="ekr.20071028032929.1176">This fixes a bug involving clone bits, and is much faster than calling c.initAllCloneBits.  The code involves c.moveOutlineRight and similar code in the undo and redo logic.</t>
<t tx="ekr.20071028032929.1177">Verified that u.undoReplace will handle all clones properly.  c.copyTree simply makes copies of all tnodes after v.copyTree has actually copied the tree.  These are really simple and elegant routines.</t>
<t tx="ekr.20071028032929.1178"></t>
<t tx="ekr.20071028032929.1179">The new "replace" paradigm greatly simplifies complex undo.  The ahas:

1. swap_links is a very simple way of replacing trees.
2. The caller of swap_links can easily redo join lists and clone info.
3. We need to use new tnodes in copied trees.  This hasn't been done yet.
4. Undo and redo use exactly the same code.</t>
<t tx="ekr.20071028032929.1180">The aha is this: the import commands are in essence nothing but an insertion of a tree rather than a single node, so exactly the same code will work for undo and redo!</t>
<t tx="ekr.20071028032929.1181">@ It is often useful to print a traceback message when a try block unexpected fails.  This can be done as follows:
@color

import traceback
try:
	...
except:
	# traceback.print_exc()
	pass</t>
<t tx="ekr.20071028032929.1182"></t>
<t tx="ekr.20071028032929.1183"></t>
<t tx="ekr.20071028032929.1184"></t>
<t tx="ekr.20071028032929.1185"></t>
<t tx="ekr.20071028032929.1186"></t>
<t tx="ekr.20071028032929.1187">This is important, because it means that invalid entries in, say, the Default Tangle Directory preference will no longer abort an attempted read.</t>
<t tx="ekr.20071028032929.1188">This is a little tricky.  The general rules are:

1. Settings in the [override .leo file prefs] section of leoConfig.txt override similar settings that exist in the &lt;preferences&gt; element in .leo files.

2. You may cancel this overriding by using "ignore" (without the quotes) as the value of a setting in leoConfig.txt.  For example:

[override .leo file prefs]
tab_width = ignore

In this example, Leo will use the tab width in each .leo file, or a default value if it doesn't exist.

3. Leo won't write overridden settings to .leo files.

The actual rules are as follows:

1. If a setting is not found in either the [override .leo file prefs] section of leoConfig.txt or the preferences section of the .leo file, Leo uses a default, hard-coded value.

2. When reading a .leo file, Leo will use settings in the [override .leo file prefs] section of leoConfig.txt unless the value of the setting is "ignore" (without the quotes).  Case is insignificant when specifying the value of default_target_language.

3. When writing leoConfig.txt, Leo will write settings in the [override .leo file prefs] section of leoConfig.txt if the setting exists in leoConfig.txt and its value is not "ignore" (without the quotes).

4. When Leo saves a .leo file, Leo updates leoConfig.txt (using rule 3) and Leo will write a Preferences setting to the .leo file only if the setting will not be written to leoConfig.txt using rule 3.  NB: this rule does not change Leo's file format because all atrributes of the &lt;preferences&gt; element have always been optional.

5. Leo will update leoConfig.txt (using rule 3) whenever the user closes the Preferences Panel successfully.

As the result of these rules, changes made in the Preferences Panel will become permanent immediately if the the setting will be written under rule 3.  Otherwise, the change will become permanent when any .leo file is saved.

I believe these rules are flexible and good.</t>
<t tx="ekr.20071028032929.1189"></t>
<t tx="ekr.20071028032929.1190">These commands convert an entire tree.</t>
<t tx="ekr.20071028032929.1191"></t>
<t tx="ekr.20071028032929.1192"></t>
<t tx="ekr.20071028032929.1193">It is important not to change the c. copies of these ivars.</t>
<t tx="ekr.20071028032929.1194">These are actually quite nice to have, and they are possible only because we have a modal dialog.</t>
<t tx="ekr.20071028032929.1195">This makes it absolutely clear what is happening.</t>
<t tx="ekr.20071028032929.1196">Added @language to all @file nodes.  This is good style.</t>
<t tx="ekr.20071028032929.1197"></t>
<t tx="ekr.20071028032929.1198">Gary Herron suggested this change.  This affects a number of commands.  Apparently this makes a difference in Linux...</t>
<t tx="ekr.20071028032929.1199">This allows us to remove the c.setIvarsFromPrefs routine.  I have left it in as a reminder of what needed to be done formerly.

Removed app().prefs and all references to it.</t>
<t tx="ekr.20071028032929.1200">This variable should _not_ be eliminated!  It is needed when reading the .leo file for the first time.</t>
<t tx="ekr.20071028032929.1201">These commands now set self.mFileName only if the dialog succeeds.  This is much more natural.</t>
<t tx="ekr.20071028032929.1202"></t>
<t tx="ekr.20071028032929.1203">This was a weird one.  I have no idea what I was thinking about!  Using c.openDirectory makes absolutely no sense.  Probably the c.openDirectory ivar should go away!</t>
<t tx="ekr.20071028032929.1204">The whole preferences issue needs rethinking and reworking...</t>
<t tx="ekr.20071028032929.1205"></t>
<t tx="ekr.20071028032929.1206">DEMOTE:

  Doc: The Demote command makes all the siblings of a node children of
  the node.

  Reality: Not quite: it makes all sibilings WHICH FOLLOW a node into
  children
</t>
<t tx="ekr.20071028032929.1207">LOG WINDOW:

  Doc: The Open Log Window command opens the window, and the Close Log
  Window command closes it.  Only one of these commands is present in
  the Window menu at any time.

  Reality: These don't seem to exist.
</t>
<t tx="ekr.20071028032929.1208">INSERT HEADLINE:

  Doc: The Insert Headline command inserts a new headline as the next
  sibling of the currently selected headline.  If the root headline is
  selected, this command inserts the new headline as the first child
  of the root.

  Reality: Insert Headline appears to insert a child if the current
  headline has any children, and it appears to insert a sibling
  otherwise.
</t>
<t tx="ekr.20071028032929.1209">EXTRACT SECTION COMMAND:

  Doc: The Extract Section command creates a new node ...

  Reality: The menu item is highlighted (no mater what the first line
  contains), but NOTHING HAPPENS (no mater what the first line
  contains).

Leo.py works correctly.  Fixed docs.</t>
<t tx="ekr.20071028032929.1210">SYNTAX COLORING

  Is never highlighted so can't be used


FONT PANEL:

  Is never highlighted so can't be used

</t>
<t tx="ekr.20071028032929.1211">At long last cut/paste works properly!

1.  The way to get the contents of the clipboard is:

s = app().root.selection_get(selection="CLIPBOARD")

The following does _not_ work:

s = app().root.selection_get(selection="clipboard")

2.  Added stringIsValidMoreFile and convertMoreStringToOutlineAfter to leoImport.py.  These routines just convert the string to an array and call stringsAreValidMoreFile and convertMoreStringsToOutlineAfter.

3.  Removed app().clipboard ivar.</t>
<t tx="ekr.20071028032929.1212"></t>
<t tx="ekr.20071028032929.1213">Once again, things are easier with Python than I expect.  The ConfigParser class is quite nice: it gives a flexible framework for all kinds of preferences.  It would be good to move most, if not all, preferences into this framework.

Note: we no longer need to change the format of .leo files to handle new kinds of preferences!  Indeed, we can just define new sections of leoConfig.txt!

Leo reads and writes leoConfig.txt.  Leo looks first in sys.leo_config_directory.  If that has not been set in sitecustomize.py, then Leo looks in app().loaddir.

</t>
<t tx="ekr.20071028032929.1214">This assert isn't useful and doesn't have to be true.</t>
<t tx="ekr.20071028032929.1215">Added code to recover the old .leo file if the write fails.  We create a backup (.bak) file by renaming the .leo file if it exists.  If there is a write error, we rename the .bak file back to .leo.  Otherwise, we just delete the .bak file.</t>
<t tx="ekr.20071028032929.1216">This was so easy...It should have been done ages ago.</t>
<t tx="ekr.20071028032929.1217">LeoDocs.leo now matches Leo's web site as closely as possible.  At this point, I consider Leo's documentation completely finished.</t>
<t tx="ekr.20071028032929.1218">The solutions to the control-H bug was to call v.edit_text.focus_force() in tree.editLabel().

Adding a call to es() in endEditLabel() makes everything work, at least on XP, but this is too strange.  I finaly fixed the problem by having c.insertHeadline call c.endUpdate(false) followed by c.tree.redraw_now().  This is pretty kludgy. Apparently the call to c.endUpdate() was redrawing the outline after the headline had been selected, with the usual bad results.  </t>
<t tx="ekr.20071028032929.1219">I removed a binding that resulted in double-clicks in headlines expanding or contracting nodes.  You can expand or contract headlines now by double-clicking a node's headline or by clicking its plus/minus box.

This change was requested by Bill Drissel.</t>
<t tx="ekr.20071028032929.1220">I have spent quite a bit of time on getting dragging to work as smoothly as possible.  This has been made more difficult because I know of know way of reading the state of the mouse button without generating a mouse-moved event.

To start a drag, press the main (left) mouse button while the cursor is over the icon for a node.  The cursor will change to a hand icon. Continuing to drag the mouse will scroll the outline pane if the hand cursor moves above or below the outline pane.  If you release the mouse button while the hand cursor is above another icon, Leo will move the dragged node after the node over which the cursor rests.  If you release the mouse button when the hand cursor is not over an icon, Leo will print "not moved" and leave the outline pane as it is.  This can result in the dragged node not being visible on the screen, but it seems less alarming not to force the current node to become visible as that would undo any scrolling that has just been done.

As usual, there are a number of details.  

1. Leo only allows dragging from one icon to another.  In particular, you can't move a node to the first child of another node unless that node is already expanded.   I experimented with automatically open nodes when the cursor moves over an unexpanded node with children.  However, this was highly confusing.  It seems less alarming to expand and contract nodes explicitly. 

2. Leo scrolls the outline pane as the result of mouse-moved events, so to continue scrolling you must keep moving the mouse.  I experimented with scrolling the outline pane whenever the cursor is dragged outside it, but the results are not good.  There was a noticable delay between releasing the cursors and halting the scrolling.  The present code is simpler and more likely to work on all platforms.</t>
<t tx="ekr.20071028032929.1221">Note that tangle.scanAllDirectives already did this.</t>
<t tx="ekr.20071028032929.1222"></t>
<t tx="ekr.20071028032929.1223">es() failed if log is None because log.newlines does not exist.  The new code alters log.newlines only if log is not None.</t>
<t tx="ekr.20071028032929.1224">Leo takes an exception.  It may be because tcl 8.3.4+ is required.  The download tcl is 8.3.4.2, but I'm not sure what version is included in Python 2.2.1.</t>
<t tx="ekr.20071028032929.1225"></t>
<t tx="ekr.20071028032929.1226">In particular, the theory of operation for Tangle and Untangle was eliminated by mistake several months ago.</t>
<t tx="ekr.20071028032929.1227"></t>
<t tx="ekr.20071028032929.1228">There were two problems in this area.  First, v.moveToRoot wasn't preserving the tree when a node was moved to the root.  This caused nodes to disappear.  Second, the code wasn't taking care to change c.tree.rootVnode as needed when nodes moved up or down.

Several important routines had to be changed.  v.moveAfter and v.moveToNthChild now are careful to set c.tree.rootVnode if the root changes.  I hacked v.moveToRoot and v.linkAsRoot so that they update c.tree.rootVnode only if the oldRoot param is not None.  This allows the init code to work properly, and allows the v.moveToRoot routine to properly link in the rest of the tree.  The undo and redo code now use the new param to v.moveToRoot.</t>
<t tx="ekr.20071028032929.1229">@nocolor

The new code isn't great, and it seems to solve the immediate problem.

@color

try: # 5/27/02: We can get Unicode strings here via cut/paste.
	try:
		self.outputFile.write(s)
	except UnicodeError:
		self.outputFile.write(`s`)
except:
	es("error writing:" + `s`)</t>
<t tx="ekr.20071028032929.1230">After creating some clone nodes with the Borland version of Leo, LeoPy.leo was corrupted.  Reading the damaged file with Read Outline Only works, so apparently the problem involves the clone indices in the derived files.

The problem was that not all the code in atFile::updateCloneIndices got copied back to the Borland code.  In particular, clone indices were not cleared before being reassigned!</t>
<t tx="ekr.20071028032929.1231"></t>
<t tx="ekr.20071028032929.1232">Added skip_matching_delims utility function.</t>
<t tx="ekr.20071028032929.1233">Removed extra whitespace between sections.

Fixed bug in convertCodePartToWeb: added code to skip @file line.</t>
<t tx="ekr.20071028032929.1234">This was an attempt (probably futile) to fix a crash in cut/paste logic.</t>
<t tx="ekr.20071028032929.1235">This allows the the last filename used to be the default for the Outline To Noweb dialog.</t>
<t tx="ekr.20071028032929.1236">We generate &lt;&lt;*&gt;&gt;= only if no file name is given in @root or @file.  The old code always generated * for @root.

Also, changed &lt;&lt; append head_ref &gt;&gt; so that @c generates &lt;&lt;fileName&gt;&gt;= instead of &lt;&lt;*&gt;&gt;= whenever possible.</t>
<t tx="ekr.20071028032929.1237">I rewrote isDocStart.</t>
<t tx="ekr.20071028032929.1238"></t>
<t tx="ekr.20071028032929.1239"></t>
<t tx="ekr.20071028032929.1240">Moving an outline up before the "root" node hung in v.setDirty.

The fix was in c.moveOutlineUp: we must call v.moveToRoot, followed by back.moveAfter.  To make this work, v.moveToRoot must leave the mFirstChild link unchanged.

Fixes were also needed in undo.undo() and undo.redo() to handle this special case.</t>
<t tx="ekr.20071028032929.1241">This fixed a bug that caused Leo to hang when syntax coloring noweb code with the CWEB syntax colorer.</t>
<t tx="ekr.20071028032929.1242">This routine must take into account the kind of file being imported.</t>
<t tx="ekr.20071028032929.1243">There are many details here.  The present code handles substantial code well, and looks good.</t>
<t tx="ekr.20071028032929.1244">The green used by IDLE looks really good to me.</t>
<t tx="ekr.20071028032929.1245">The code now purports to work for both CWEB and noweb files.</t>
<t tx="ekr.20071028032929.1246"></t>
<t tx="ekr.20071028032929.1247">Outline To Noweb creates &lt;&lt; * &gt;&gt; sections when it doesn't know what name to give something.  This may be partially correct, or entirely wrong.</t>
<t tx="ekr.20071028032929.1248">Please note that the same mechanisms work unchnaged for both @root and @file trees.</t>
<t tx="ekr.20071028032929.1249">I hacked the Python and Java code (hacks on hacks) to insert nodes to carry @others commands when generating @file trees.  The Python code now handles nested classes fairly well.

At this point I'm not sure what is a bigger kludge, the "parsing" parts or the "code generation" parts.  I really don't want to do full parsing here, but the present code is pretty wild.  OTOH, it works.

Fixed bug in skip_pascal_string.

Split the Import Files command into Import To @file and Import To @root.</t>
<t tx="ekr.20071028032929.1250"></t>
<t tx="ekr.20071028032929.1251">Debugged the Import Files command for .py files.  The main problems were getting the params to the scanPythonX routines correct: these were just transcription problems.

Fixed 2 bugs in the colorizer: it wasn't handling Python triple strings or C preprocessor directives properly.

Fixed a bug in skip_python_string.  It was returning the start of the ending delim, not past it.</t>
<t tx="ekr.20071028032929.1252">It only took an hour.  I am amazed this hasn't been done long ago.</t>
<t tx="ekr.20071028032929.1253"></t>
<t tx="ekr.20071028032929.1254">Issue the "reading:" message only if the file can be opened.
Eliminated the #--- error reading x" message before read errors.</t>
<t tx="ekr.20071028032929.1255">Added a return value to update_def so that skip_body can tell if a node has been changed.  skip_body now calls v.trimTrailingLines only if the node has changed.</t>
<t tx="ekr.20071028032929.1256">Untangle was setting the pane changed even when not reporting any changes.  This was due to a call to v.trimTrailingLines.  Changed v.setBodyStringOrPane so that it calls c.setChanged and v.setDirty only if the new text is different from the old, but this doesn't completely solve the problem.</t>
<t tx="ekr.20071028032929.1257">These are helpful in leo.py because the commands are slower than in LeoCB.</t>
<t tx="ekr.20071028032929.1258"></t>
<t tx="ekr.20071028032929.1259"></t>
<t tx="ekr.20071028032929.1260">The code mistakenly set part to zero before calling update_def, with the result that the wrong parts were compared.  This simple blunder took several hours to find.</t>
<t tx="ekr.20071028032929.1261"></t>
<t tx="ekr.20071028032929.1262"></t>
<t tx="ekr.20071028032929.1263"></t>
<t tx="ekr.20071028032929.1264">Documented new file format, unlimited undo/redo, auto indent, Contract Parent and Sort Siblings commands.</t>
<t tx="ekr.20071028032929.1265">Note: this code is still untested and very likely has major bugs.</t>
<t tx="ekr.20071028032929.1266">I did this to reasssure myself that such changes were benign, and they are: all files Tangle and Untangle as before.  Also, @space (or @doc) is needed at the start of all doc parts so that Leo2 will syntax color them properly.

This took quite a bit of time, and I really should do this for all of LeoCB.leo, or alternatively, convert all of LeoCB.leo to @file trees.  I'll probably leave this as an exercise for someone else to do ;-)  Actually, the proper way to do this is probably to write a Python script.</t>
<t tx="ekr.20071028032929.1267">The code is straightforward.</t>
<t tx="ekr.20071028032929.1268"></t>
<t tx="ekr.20071028032929.1269"></t>
<t tx="ekr.20071028032929.1270">Fixed &lt;&lt; Scan and define an @code defininition &gt;&gt; and &lt;&lt; Scan and define a section definition &gt;&gt; in skip_body.  The calls to skip_code were setting k, not i.  I'm not sure how Tangle could ever have worked before.  Perhaps a reversion of some kind.

With these fixes, all files are tangled identically by LeoCB and leo.py.

Removed trailing lines in code part in st_enter.  With this change almost all files compare identical except those containing (!newline).  Fixed a bug in put_section which caused whitespace not to be properly output after (!newline).  With this fix leo.py tangles all files in tangleTest.leo exactly the same as LeoCB!</t>
<t tx="ekr.20071028032929.1271">One bug remains in the Borland version and will probably never be fixed: Preferences settings do not stick to windows.  This is a result of using the arg_xxx vars rather than ivars.</t>
<t tx="ekr.20071028032929.1272"></t>
<t tx="ekr.20071028032929.1273"></t>
<t tx="ekr.20071028032929.1274">It is intolerable to have misleading syntax coloring.  The syntax colorer treats @c just like @code.  Tangle must do the same.</t>
<t tx="ekr.20071028032929.1275">Made the root arg optional.  If present it is a list with one element and is_special_bits checks for @root.  We pass a list of one element to is_special_bits so we can distinguish between None and [None].

Removed @owncolor code.</t>
<t tx="ekr.20071028032929.1276">In leoFrame.py: make the font size platform-dependent.
In leoTree.py: use os.path.join to join Icons and file names.</t>
<t tx="ekr.20071028032929.1277"></t>
<t tx="ekr.20071028032929.1278">''' wasn't handled like """</t>
<t tx="ekr.20071028032929.1279">pychecker is a marvelous tool.  It fixes most of the problems that compilers fix.</t>
<t tx="ekr.20071028032929.1280">Caught by pychecker:  the call to special_bits was missing the i param.  This would cause a fault when executed.</t>
<t tx="ekr.20071028032929.1281">changed mStartSentinelComment to self.startSentinelComment.
changed mEndSentinelComment to self.endSentinelComment.</t>
<t tx="ekr.20071028032929.1282">changed writeError to self.writeError.</t>
<t tx="ekr.20071028032929.1283">Changed message to self.message in BadLeoFile.__init__.

Changed param to es in getTnode().</t>
<t tx="ekr.20071028032929.1284">Initialized s to "" in moreHead.

Note: v.trimTrailingLines does nothing(!)

removed v.saveOutlineWithLevel.  This uses dvnodes and is old, old code.

removed v.setThreadLinks.  This was a bad idea that should have gone away a long time ago.</t>
<t tx="ekr.20071028032929.1285">x Changed all arg_ vars to ivars in scanAllDirectives:
	arg_present_language --&gt; self.language
	arg_tab_width --&gt; self.tab_width
	arg_page_width --&gt; self.page_width
	arg_use_header_flag -&gt; self.use_header_flag
	These will affect the @comment and @language directives!
x Changed set_root_delims() to self.set_root_delims()
x Changed end_sentinel_len to len(end_sentinel)
x Changed sentinel_end to self.sentinel_end in scanDerivedFile.
x Added c = self.commands in massage_block_comment. (This routine is never used, though).
x Removed extra param to match in put_section.
x Initialized code = None in skip_body.
x Initialized path in untangleRoot before error messages that use path.
x Used marked_flag properly in untangleMarked.</t>
<t tx="ekr.20071028032929.1286">A weird one: LeoCB was removing the last character (typically half of a cr-lf combination), probably in the mistaken belief that it was an end-of-file character.  Geeze:  how do C++ programs ever work when you have to deal with minutia like eof marks and 2-character newlines.  Tk has really spoiled me.

I added code to leo.py to ensure that even compressed derived files end in a newline, which will help.</t>
<t tx="ekr.20071028032929.1287"></t>
<t tx="ekr.20071028032929.1288">Emailed Guido.  He indicated that the fix just involves filenames, so I took a look at it immediately.  Used Leo to study the code and made a simple fix.</t>
<t tx="ekr.20071028032929.1289">This fixes a serious hole in Leo:  The read logic would crash (report corrupted sentinels) if what follows a reference looked like a sentinel line!</t>
<t tx="ekr.20071028032929.1290">It turns out to be easy to suppress newlines between sentinels.  It is a bit harder to make the read logic work properly.

By single-stepping through the Borland code (which also fails when newlines are suppressed) I see that there is logic in scanText that checks for a non-blank line after a +body sentinel!  By adding a check to see that the next line is not another sentinel line we can make the read logic work properly.

I wonder: suppose the text after a reference looks like a sentinel?  What happens then?</t>
<t tx="ekr.20071028032929.1291"></t>
<t tx="ekr.20071028032929.1292">Fixed a bug that for all languages (like Python and Perl) that do not have block comments.  The change was to update_def.</t>
<t tx="ekr.20071028032929.1293">Three characters were colored blue at the start of a section def in:
  &lt;&lt;name&gt;&gt;=
The fix was to change k to 2 in one spot.</t>
<t tx="ekr.20071028032929.1294"></t>
<t tx="ekr.20071028032929.1295">This is the only undoable command.  Now it puts up a dialog saying that.</t>
<t tx="ekr.20071028032929.1296"></t>
<t tx="ekr.20071028032929.1297"></t>
<t tx="ekr.20071028032929.1298">Optimize Undo Typing by suppressing the "oldText" entry in the dict if the previous entry was "Typing" and the vnode match.  This optimization saves almost half the space used in the bead list!

Verified that the Change All and Read @file Nodes commands call clearUndoState().

The "Cut", "Copy", "Delete", "Change", "Convert Blanks", "Indent", "Undent" are now undoable.  The only change was a new param to the body key handler.

Created onBodyWillChange event handler.  We must distinguish between commands like "Find, Then Change", which must call onBodyChanged, and commands like "Cut" and "Paste" that must call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.

Keystrokes in the headline are now undoable.</t>
<t tx="ekr.20071028032929.1299">The code is hardly more complex than the old limited code.  In many places it is simpler.

The code now saves only the "optional" ivars that are non-None.  This should be an important space optimization for "Undo Typing".

While messing with Undo in the body pane I realized I could simplify idle_body_key a bit.  I believe this is important.</t>
<t tx="ekr.20071028032929.1300"></t>
<t tx="ekr.20071028032929.1301">alt-v now work in @nocolor mode.</t>
<t tx="ekr.20071028032929.1302"></t>
<t tx="ekr.20071028032929.1303"></t>
<t tx="ekr.20071028032929.1304">Almost all of the logic is language independent!

Added keywords for c,pascal,perl &amp; python.</t>
<t tx="ekr.20071028032929.1305">skip_doc must test for actual strings, not the return value from token_type.</t>
<t tx="ekr.20071028032929.1306">This was a fix to the syntax colorer only.

Also colored the equal sign in &lt;&lt;name&gt;&gt;=.</t>
<t tx="ekr.20071028032929.1307">Added undoers for Cut/Past Node commands and Sort commands.

Apparently the Copy Node command has no undo consequences.

Added calls to clearUndoState for Read and Import commands.  Actually, the Import commands could easily be undone: they are just like insert commands.

Decided not to clear the undo state after Save commands.  Do so is confusing and seems pointless.  I may revisit this issue when implementing Unlimited Undo.</t>
<t tx="ekr.20071028032929.1308">These are not present in the CVS tree.  They should be.

c2py.py, openLeo.py, tangle_done.py, untangle_done.py, __init__.py.</t>
<t tx="ekr.20071028032929.1309"></t>
<t tx="ekr.20071028032929.1310">Most problems had to do with changing c.undoX to c.undoer.undoX or u.undoX.

Everything with an undoer now works.

Cut/Copy/Paste Nodes have no undoers.
Sort commands have no undoers.</t>
<t tx="ekr.20071028032929.1311">Apparently WinCVS is set up appropriately.  Remember to use my corrct password

Did a checkout from the create menu and everything went well!</t>
<t tx="ekr.20071028032929.1312"></t>
<t tx="ekr.20071028032929.1313">It is clear that broken clone links can't be mended automatically.  That is, Leo can't be made significantly more CVS friendly.  That being so, let us consider how to use CVS with Leo.

Our goal is this: we don't want clone links to break when we check derived files into or out of the repository.  In general, clone links will break whenever we a read derived file from a .leo file different from the .leo file that created it.  So to meet our goal we must obey the following rules:

Rules for using Leo files with CVS:
	
1. All derived files in a particular revision in the CVS repository must be generated by a single .leo file. Call that file the _generating_ .leo file (for the revision as a whole and for each derived file in particular).
	
2. When we check out files from the repository we must check out the generating .leo file in addition to the derived files that we are checking out.

3. When we check in files to the repository we must check in the single .leo file that generated the derived files that we are checking in.

4. When CVS detect update conflicts in derived files, developers must resolve those conflicts in a "merged" .leo file.  All derived files that are later checked in must be derived from this .leo file.  When creating this merged .leo files, developers should take care to retain clone links.  

These rules make a virtue out of necessity.  I always envisioned that update conflicts would have to be resolved in .leo files rather than derived files.  What I now see is that this is the also the only way to prevent clone links from being broken.</t>
<t tx="ekr.20071028032929.1314">Just after I completed the Mending Dialog I realized that the concept behind this dialog was fatally flawed: cloned nodes must have the same structure!

Indeed, at the time the Mend Clone dialog is put up, the user would have no way of knowing whether any joins made sense.  Conceivably Leo could test for structural simularity, and in that case this dialog would be useless.  Note: many read errors arise from structural mismatches; clones could never be mended properly in those cases.

About the only situation in which mending would be possible is if the only differences between trees were outline differences.  This suggests that we don't test headline text at all and just rely on structure identity.</t>
<t tx="ekr.20071028032929.1315">This dialog returns a list of pairs of names.  It is up to the caller to associate the names with vnodes.</t>
<t tx="ekr.20071028032929.1316"></t>
<t tx="ekr.20071028032929.1317"></t>
<t tx="ekr.20071028032929.1318">Moved these out of the frame class: the undo class also uses them.</t>
<t tx="ekr.20071028032929.1319">We want to remove only the leading whitespace present on the first line, not all leading whitespace!

Also, the Extract Section command was deleting the section reference line.

I could have sworn I tested these commands.  Apparently not.</t>
<t tx="ekr.20071028032929.1320"></t>
<t tx="ekr.20071028032929.1321">It appears that DnD will be straightforward: probably less then 100 lines of code!</t>
<t tx="ekr.20071028032929.1322">Removed "blank" and "tab" tags on entry.  I thought I did this!  Anyway, it remains to be seen whether this has any effect on the "disappearing" selection bug.

I did some perfunctory tests on the various find/change commands and everything appears to be working well.  We shall see...</t>
<t tx="ekr.20071028032929.1323">Made headlines longer in tree.headWidth(). Sometimes the right edge of a headline was being cut off.  This must be a Tk bug, and the workaround is easy enough.</t>
<t tx="ekr.20071028032929.1324">Cleaned up the code in several ways.  Some of these have been bugging me for a while.

Yesturday I realized that the proper time to clean up code is just _after_ a release.  That way the new code will be thoroughly tested before the next release.

c.tree.currentVnode -&gt; c.currentVnode()
Used keyword.iskeyword() in leoColor.py to test whether a word is a Python keyword.
Used string.endswith() in Import code.
Renamed is_c_word() to match_c_word() to be compatible with the match and match_word names.</t>
<t tx="ekr.20071028032929.1325"></t>
<t tx="ekr.20071028032929.1326">This is used in v.sortChildren and in leoImport.sort testing routine.  Apparently the latest code is about the best that can be done.  Passing a param to the list.sort() routine might seem elegant, and apparently it is slow.  Also, it is not clear how to pass the "n" param to the sort routine. I might challenge the net to do better, but the present code works and is fast, general, elegant and clear.</t>
<t tx="ekr.20071028032929.1327">Experimented with using Python's inspect module.  However, it doesn't provide nearly the level of parsing needed for Leo's import commands.  We need access to the entire parse tree.  It is probably possible...</t>
<t tx="ekr.20071028032929.1328"></t>
<t tx="ekr.20071028032929.1329">Removing from leoUtils import * from reload_all() will cause problems.  The only workaround appears to quit Python when modifying leoUtils.  Sigh.</t>
<t tx="ekr.20071028032929.1330"></t>
<t tx="ekr.20071028032929.1331">This is a really useful command!</t>
<t tx="ekr.20071028032929.1332">This is quite tricky code.  To capture changed values we typically must set a commands method that calls an idle routine. We can't capture the values by binding Button clicks because values haven't changed yet, or so it seems.

Anyway, the preferences panel settings now appear to "stick" to the presently active window.

The print_prefs routine was vital to sorting out what was happening.</t>
<t tx="ekr.20071028032929.1333"></t>
<t tx="ekr.20071028032929.1334">Now the real work begins.</t>
<t tx="ekr.20071028032929.1335">This will serve as a start for CVS.</t>
<t tx="ekr.20071028032929.1336">Added commands handler for all radio buttons.  There was a timing problem: it took 2 clicks to set the current language.  Also added code to recolor the body pane immediately.</t>
<t tx="ekr.20071028032929.1337">It is vital that @file nodes remain dirty until they are written without errors.  Otherwise, a Save command will succeeed without warning, and a later read may cause the dreaded "clones have been cleared" message.</t>
<t tx="ekr.20071028032929.1338">The settings in the Preferences panel now "stick" to the current window.  This turns out to be very important for Tangling: I ran into serious problems with Tangling to the wrong directory when more than one window was open.</t>
<t tx="ekr.20071028032929.1339"></t>
<t tx="ekr.20071028032929.1340">This turns out to be more useful than Sort Children.</t>
<t tx="ekr.20071028032929.1341"></t>
<t tx="ekr.20071028032929.1342">All the "Tangle" Constants must be defined in the same place.  It turns out that leoUtils no longer use any of these constants anyway, so I moved them to leoTangle where they have always belonged.

scanError() is now the only part of leoUtils that uses Tangle data.  It accesses the commands instances using the top() function.  A kludge...

In any event, when I split them I also defined some new values, so values from leoGlobals.py overlapped with values from leoTangle.py.  It is a good thing I caught the problem now...</t>
<t tx="ekr.20071028032929.1343"></t>
<t tx="ekr.20071028032929.1344">Moved the tangle constants into the tangle class.

Changed header to self.header in an error message in scanAllDirective.

The source of the "mismatch" in Utils.h was that somehow I inserted @c into the root of Utils.h, which should produce errors, and eventually it did.</t>
<t tx="ekr.20071028032929.1345">I reset the default tangle directory while doing regression testing, then saved LeoPy.leo.  This destroyed files LeoPy directory, I'm not sure how, so I had to revert.  All looks well now.</t>
<t tx="ekr.20071028032929.1346"></t>
<t tx="ekr.20071028032929.1347">There was a problem with a global change command.  I'll have to do a full regression test of Tangle.  This would be a good time to use the new whitespace utility routines.</t>
<t tx="ekr.20071028032929.1348"></t>
<t tx="ekr.20071028032929.1349">This was the result of a Change All disaster.</t>
<t tx="ekr.20071028032929.1350">We have to update s_text as well as c.body so that another call to search on the same line will find the updated text.</t>
<t tx="ekr.20071028032929.1351"></t>
<t tx="ekr.20071028032929.1352"></t>
<t tx="ekr.20071028032929.1353">Newlines now set the dirty bit.

We increase auto indent after a colon.  This should happen only for Python mode...</t>
<t tx="ekr.20071028032929.1354"></t>
<t tx="ekr.20071028032929.1355">Once again, I am astounded at how easy this is.</t>
<t tx="ekr.20071028032929.1356">Convert Blanks now converts the entire body pane if there is no selected text.</t>
<t tx="ekr.20071028032929.1357">It is doubtful that leo.py will ever support a Print command directly.  Rather, users can use export commands to create text files that may then be formatted and printed as desired.  Tk does provide print support.</t>
<t tx="ekr.20071028032929.1358">Only blanks and tabs are shown, and they not very well.

What we need is a font that shows blanks and tabs as descent symbols for blanks, tabs and newlines.</t>
<t tx="ekr.20071028032929.1359">The key is that two things have to happen:

1. Menu items should be enabled only when focus is in the canvas pane.
2. Bindings for for the outline commands should be added only to the canvas pane.</t>
<t tx="ekr.20071028032929.1360"></t>
<t tx="ekr.20071028032929.1361">A useful convenience method that makes it much clearer what is going on.</t>
<t tx="ekr.20071028032929.1362"></t>
<t tx="ekr.20071028032929.1363"></t>
<t tx="ekr.20071028032929.1364"></t>
<t tx="ekr.20071028032929.1365">Sherlock attempts to read the file SherlockArgs.  If found, each line is assumed to be a separate sherlock argument.

However, the main improvement is defaulting empty arguments to "+*".  This makes tracing as easy to use as print statements.

Could trace accept multiple arguments, just like print?  No: we would lose the ability to specify tracepoints by default.  There is no need to duplicate print!</t>
<t tx="ekr.20071028032929.1366">Very easy to do, compared with other systems.</t>
<t tx="ekr.20071028032929.1367">This should solve some compatibility problems.</t>
<t tx="ekr.20071028032929.1368"></t>
<t tx="ekr.20071028032929.1369">Alt-1 refers to Alt-Button-1, not Alt-Key-1 (!)</t>
<t tx="ekr.20071028032929.1370">Changed frame.put routines so that they return during quitting.

Also removed trace statements from __del__ routines.</t>
<t tx="ekr.20071028032929.1371">We must be careful to enclose all find/change code in c.beginUpdate/c.endUpdate(false) so a redraw after the call to tree.redraw_now() in find.showSuccess won't deselect the headline text.

It would be elegant to cancel any pending redraw in tree.redraw_now, and that does not seem to work.

Because we don't always redraw the screen, we must update icons "by hand" by calling c.tree.drawIcon.

It is very tricky to compute self.in_headline correctly.

Perhaps a more sensible approach would be to have the tree.redraw routine save and restore the editing status and selection of the current headline.  However, the present code works and minimizes redraws, so there isn't much incentive...</t>
<t tx="ekr.20071028032929.1372">The idea was that if all drawing happens at idle time we could do the following:

	Eliminate all c.beginUpdate()
	Eliminate all c.endUpdate(false)
	Replace c.endUpdate() with c.redraw()
	Replace c.endUpdate(flag) with if flag: c.redraw()
	
However, the find command needs to _prohibit_ drawing, and there doesn't seem to be a clean way to do this, so using c.endUpdate(false) seems to be needed.

In other words, without c.endUpdate(false) we would need c.cancelDrawing(), and this doesn't seem any cleaner than the present code.</t>
<t tx="ekr.20071028032929.1373"></t>
<t tx="ekr.20071028032929.1374">I messed things up when I "optimized" the redraw code.  The Find code must redraw the screen _before_ making selections in the headline--otherwise the headline becomes inactive.</t>
<t tx="ekr.20071028032929.1375">Altered the Cut/Copy routines so they set Leo's internal clipboard (app().clipboard).  So to cut from LeoCB to leo.py do the following:

Copy the tree in LeoCB.
Paste the tree into empty body text of leo.py.
Select all the body text and paste.
Move to the tree view, and do a Paste Node.

Yes, this is very clumsy, but how often do we want to transfer information between LeoCB and leo.py?</t>
<t tx="ekr.20071028032929.1376">This is defensive programming.  Only a few event handlers override body handlers:  These include Control-I, Control-T and Control-D.

Exception: the command handlers for cut/copy/paste must _not_ return "break"!  The actual work is done by the Tk.Text widget.</t>
<t tx="ekr.20071028032929.1377"></t>
<t tx="ekr.20071028032929.1378">Now that event handlers return "break" they can do things involving focus that they could not do before.</t>
<t tx="ekr.20071028032929.1379">This is done in frame.createAccelerators().  For the first time leo.py handles keystrokes properly!

We could override _all_ body pane keys, and this would be dangerous until all event handlers return "break."  Indeed, doing so would create duplicate bindings, one for frame.top and one for frame.body, so without a "break" the command would be done twice!</t>
<t tx="ekr.20071028032929.1380"></t>
<t tx="ekr.20071028032929.1381">Event scripts need only return the string "break" to inhibit all further event processing!  This is what I have been missing all along, and it was staring me right in the face.  Sheesh.

This eliminates the need for several kludgy workarounds:
	The double-click event handler no longer needs to wait till idle time.
	The c.moveDown routine no longer needs to call c.select.

Another breakthrough.  Way down at the bottom of the Tk.Text documentation I discovered a list of all the key bindings defined by default in Text widgets.  This includes Control-O, which explains why body text sometimes had blanks lines inserted at the top. (Amazingly, Control-O never seems to have split lines, purely by luck.)

I can now use control-I to insert nodes again!</t>
<t tx="ekr.20071028032929.1382">This is similar to the double-click logic!</t>
<t tx="ekr.20071028032929.1383">We must compute the word to be selected before the Tk.Text widget does its default double-click handling, then actually select the text at idle-time.</t>
<t tx="ekr.20071028032929.1384"></t>
<t tx="ekr.20071028032929.1385">The code was easy to write and worked the first time.  I love Python.  I chose to ignore case in the comparison.

A more elegant solution would be to define a v.__cmp__ method, but the present code is clear enough and works.</t>
<t tx="ekr.20071028032929.1386">Fixed the Tangle Marked command.  It had numerous problems.

The code that executes Leo_done.bat and Leo_un.bat didn't work.  Now these options specify Python scripts to execute, and these scripts are passed a list of filenames that were tangled or untangled.</t>
<t tx="ekr.20071028032929.1387">Created go.bat and openLeo.py.  These simplify the process of starting leo.  Just open a console window and type go.

Added "c:\prog\LeoPy\LeoPy.leo" as default to filename argument to leo.open().</t>
<t tx="ekr.20071028032929.1388"></t>
<t tx="ekr.20071028032929.1389"></t>
<t tx="ekr.20071028032929.1390">The whole-word search only fails if there are two consecutive "in-word" characters at the beginning or end of the supposed match.

Added some logic to make suboutline-only searches work correctly.

In the process, discovered a bug in is_c_id.  It was testing for blank instead of underscore!</t>
<t tx="ekr.20071028032929.1391">tree.select now calls tree.recolor_now instead of tree.recolor.  The result is much better than before.

Did add the tree.updateScheduled ivar and logic.  This ensures that only one redraw ever happens at idle time.  It seems like the body text is drawn much faster now.  This may have been a big performance bug!

At present the performance of leo.py seems excellent.</t>
<t tx="ekr.20071028032929.1392">When the "Move Down" command did nothing the control-d ate the character at the cursor!  The workaround is to have c.moveOutlineDown call c.selectVnode(v) even if nothing happens.  This forces the body text to be restored.</t>
<t tx="ekr.20071028032929.1393">c.makeVisible and even c.beginUpdate/c.endUpdate can be eliminated!  Indeed, the tree class can work as follows:

1. All ancestors of the current node are expanded at the start of tree.redraw.
2. The current node is scrolled into view at the end of tree.redraw.

We want to do the expansion of nodes before drawing so offsets are computed properly.  We must do scrolling after idle tasks are complete so Tk.Scrollbar.get() will return proper values.

Note: we still may want to inhibit drawing even though all drawing happens at idle time.  We don't really need begin/endUpdate to do that:  just keep a flag and call c.redraw() only if the flag is true.

I'm not going to eliminate c.beginUpdate/c.endUpdate just yet.</t>
<t tx="ekr.20071028032929.1394"></t>
<t tx="ekr.20071028032929.1395">Eliminated redundant error messages.
All path problems now generate an error.  This seems safest.</t>
<t tx="ekr.20071028032929.1396">tree.makeVisible and tree.scrollTo are called before the tree is redrawn, so we can't get accurate measurements from the canvas class.  I created tree.yoffset() and tree.lastVisible() to get proper measurements.  The final code is deceptively simple; it took several hours to get it all right.

This is an important step forward because now the screen is drawn properly during interactive search commands.  It would have been intolerable to release Leo with only partly functional Find commands.

There are still "policy" questions about when and how to scroll.  The present code doesn't work smoothly in all cases.  It may be that the Tk.canvas.yview routine doesn nothing in certain unexpected situations.</t>
<t tx="ekr.20071028032929.1397">I have spent several pleasant hours preparing setup.py, manifest.in and sdist.bat.

Create a source distribution (.zip file) by running sdist.bat from c:\prog\LeoPy.

I have not been able to create a .gzip file yet.</t>
<t tx="ekr.20071028032929.1398"></t>
<t tx="ekr.20071028032929.1399"></t>
<t tx="ekr.20071028032929.1400">There was an assignment kind = kind in the section &lt;&lt; set kind for directive &gt;&gt;, so @chapter, @section were never recognized.  Amazingly, this blunder did not seem to affect anything else.

With this this bug fixed, all files in LeoCB.leo are tangled the same by LeoCB and leo.py, except for the first line and whitespace.  The first line is different because LeoCB puts slashes differently than leo.py.

When ignoring only trailing whitespace and blank lines, we see that LeoCB and leo.py differ in how they output (!newline).  LeoCB outputs a single space before (!newline) in put_section(), so this is what leo.py must do as well.

With this bugs fixed, the only differences between LeoCB.leo and leo.py involve leading and trailing whitespace and blank lines.  Tangle works!  Actually, leo.py now does a better job than LeoCB, for the following reasons:

1. leo.py does a good job of deleting trailing blank lines in sections, and this should simplify Untangle.
2. leo.py does a better job of putting leading whitespace than LeoCB, because leo.py more accurately computes the effective width of leading whitespace than does LeoCB.</t>
<t tx="ekr.20071028032929.1401">This allows us to open a file when leo starts.  From the Python interpreter do the following:

import leo
fn = "c:\prog\LeoPy\LeoPy.leo"
leo.open(fn)

The open script is the companion to the run and go scripts.  leo.run() just runs leo.  leo.go() reloads all modules before running. For reasons that I don't fully understand, leo.go() does not always handle leoUtils properly: it is sometimes necessary to do

from leoUtils import *</t>
<t tx="ekr.20071028032929.1402">Actually, clicking on another node should probably reset the "wrap_node", but it doesn't.  Only changing something in the Find panel does that.</t>
<t tx="ekr.20071028032929.1403">Tested paths when Leo invoked directly.
Tested explicit paths in @file nodes
Tested paths in prefs panel.
Tested paths in @path directive.
Tested no path anywhere.

As a result, changed writeError by error in atFile.scanAllDirectives.</t>
<t tx="ekr.20071028032929.1404">frame.defaultDirectory was never being used.</t>
<t tx="ekr.20071028032929.1405"></t>
<t tx="ekr.20071028032929.1406">It appears that putting the following in app.finishCreate will work:

	import leo
	loaddir = os.path.dirname(leo.__file__)

Apparently we can not reference leo.__file__ reliably until leo has been completely imported.  The workaround is to do so in app.finishCreate.  This is a bit mysterious, and it appears to work.</t>
<t tx="ekr.20071028032929.1407">The new path philosophy is as follows:

1. Leo will not call os.chdir except possibly after file dialogs that are not cancelled.  This will leave the file system's current directory (returned by os.getcwd()) unchanged by tangling, importing, reading or writing.

2. Commands that access files (tangling, untangling, reading, writing, importing) call either os.getcwd(), atFile.scanAllDirectives or tangle.scanAllDirectives to set appropriate ivars indicating what the proper default directory will be.

3. These commands open a file as follows, where self.default_directory is set in step 2:

	fn = os.path.join(self.default_directory, fileName)
	f = open(fn,...)</t>
<t tx="ekr.20071028032929.1408">@file trees were not being marked as dirty when cloned headlines outside those trees were changed.  This definitely would have caused errors while reading @file trees!  Fixing this bug is a big step forward.

The fix was to to have v.setDirty() ensure that all cloned nodes are set dirty and that all ancestor @file nodes are set dirty.  I eliminated v.setDirtyJoined() entirely, and eliminated all calls to v.setAncestorAtFileNodeDirty() outside of v.setDirty().  The result is much safer, cleaner and simpler code.

As a side effect, nodes now become dirty when they move.</t>
<t tx="ekr.20071028032929.1409">leo.py used to call chdir from many places to indicate which default directory should be in effect.  That was wrong. From now on, leo.py will call chdir only file dialogs return without being cancelled, that is, for Open, Save and Import commands.

Otherwise, directives will set ivars, and the code will compute full path names using
os.path.join(directory_ivar, pathname).  The neat thing about this is that if pathname already contains a full path name it will override the path in directory_ivar.

For example, the Tangle code now writes the final file like this:

	file_name = os.path.join(self.tangle_directory,section.name)
	... # tangle into temp file
	update_file_if_changed(file_name,temp_name)

This works properly whether or not section.name contains a full path name.</t>
<t tx="ekr.20071028032929.1410">If the present node is expanded, the Paste Nodes command now pastes the pasted node as the first child of the present node, rather than as the next sibling of the present node.</t>
<t tx="ekr.20071028032929.1411">trace(a) prints a if s is a string and executes a() if a is a function.</t>
<t tx="ekr.20071028032929.1412">The symptom of the bug was that it was taking a _long_ time to close windows after doing many interactive find commands.  Actually, it was redrawing the tree that was the real problem.

Disable the recycling of nodes made no difference.  By removing code I isolated the performance bug to the call to tree.redraw in find.showSuccess().  This was very good news, as it meant that the bug was in the tree code rather than in Tk or Tkinter.

The bug was caused by "extra" links to the Tk.text widgets in the vnode, specifically, the v.box_id, v.edit_text_id, v.icon_id and v.box_id ivars.  These links apparently created permanent references that prevented widgets from being deallocated when the tree was redrawn, so a large number of widgets and their binding had to be deleted when the tree was deleted.

The fix was just to eliminate these vnode ivars entirely: they were not being used!  The v.edit_text ivar could not be eliminated, so I added a call to self.edit_text.destroy() just before reallocating.  Perhaps just moving the edit_text would be better than destroying and reallocating it, but that wouldn't be so easy because of the call to self.canvas.destroy("all").</t>
<t tx="ekr.20071028032929.1413">If a clone problem is reported, the @file node is not marked dirty again, so if we save the .leo file and then quit the problem will still exist in the derived file.

This happened in Borland Leo, so it is clear if it is a problem in leo.py.

I recovered by doing a Read Outline Only.</t>
<t tx="ekr.20071028032929.1414"></t>
<t tx="ekr.20071028032929.1415">Moved Tangle utils into Tangle leoTangle.py.  These should be methods because they deal with tangle ivars.

Separated utils that call scanError from other utils.</t>
<t tx="ekr.20071028032929.1416"></t>
<t tx="ekr.20071028032929.1417"></t>
<t tx="ekr.20071028032929.1418">This happened after deleting a clone outside of the tree for @file leoColor.py.  I am not sure of the exact sequence.  Perhaps LeoCB was involved.</t>
<t tx="ekr.20071028032929.1419">This was pretty easy.  I think underlining hyperlinked section references looks good.

Still to do:

1. We need browser-style navigation: forward, up, back, home.

2. We may have to change things for Leo1.</t>
<t tx="ekr.20071028032929.1420"></t>
<t tx="ekr.20071028032929.1421"></t>
<t tx="ekr.20071028032929.1422">I finally realized why c.redraw and c.endUpdate wiped out the edit status:

1.  tree.redraw does not preserve the edit status (it probably should)
2.  tree.redraw only causes queuing of the redraw.  It doesn't happen immediately.

This was causing problems in find.show_success.  My quick fix was to create tree.redraw_now, and then to restore the status as needed.  Another, probably better, way would be to have tree.redraw restore edit status.  Duh.

However, in this case tree.redraw_now is exactly what is needed, so I feel a bit less stupid...</t>
<t tx="ekr.20071028032929.1423">There are a huge number of details to get exactly correct.  It appears that the code is close to working.</t>
<t tx="ekr.20071028032929.1424">I finally realized that v.edit_text is defined only if v is visible on the screen, that is, only if all of v's ancestors are expanded.</t>
<t tx="ekr.20071028032929.1425"></t>
<t tx="ekr.20071028032929.1426">Previously, cloned headlines were not updated in unison.  This could have been the source of some apparent "lost data".  It is remarkable how complex this logic is.

I finally chose to do a redraw in tree.endUpdate() to force headlines in synch.  We can't typically just do a redraw() in idle_headline because that messes up the editing state of v.edit_text.

I also fixed a bug in idle_body that caused control-Q to call c.setChanged() again.  The new code just sees whether the code has caused the text to change: it does not need the value of ch to do that.

idle_headline also now handles all details of marking nodes dirty.  This used to be done partly in undimHeadline.</t>
<t tx="ekr.20071028032929.1427">I made terrible blunder: I eliminated a commands ivar that was involved in writing, so the write failed and wiped out the .leo file.  Since I didn't have a recent backup .leo file, I lost todays notes.

Let this be a lesson to myself:

1.  Backup .leo files _are_ useful for backing up ouline only data.
2.  Make backup of entire LeoPy folder when there are problems.  I came very close to all of today's programming work, which would have been hard to bear.</t>
<t tx="ekr.20071028032929.1428"></t>
<t tx="ekr.20071028032929.1429">We don't need to keep track of the status of control or alt keys!  Instead, we let idle_body_key and idle_head_key compare the old with the new value.  They do nothing on a match.

An important point:  idle_body_key must make sure that v == c.currentVnode.  If it doesn't make this check we will lose data when the user types Control-K to create a new node.

The new code also takes care not to allow any newlines in headline text.</t>
<t tx="ekr.20071028032929.1430"></t>
<t tx="ekr.20071028032929.1431">This code is _vastly_ superior to the Borland code, for several reasons:

1.  Unlike the Borland code, the Python code uses no "state" variables.  This not only greatly simplifies the code, it makes it possible to restart incremental searches after the user has changed nodes or changed postion in body text.

Instead of using state variables in the find class, the code uses the c.currentVnode and the "insert" and "sel" tags of the Tk.text widgets.  This automatically ensures that the state of the search matches the state of the outline and body panes!

2. At last!  I know how to restart incremental searches without using state variables.  The trick is _not_ to call c.endEditing() in the setup routines, so set_in_headline() can use c.tree.editVnode to see if we are editing a headline.  If so, we start there.  OTOH, select_next_v _does_ call c.endEditing() and c.editVnode() to force c.tree.editVnode to have the proper value.

3. Leo now uses Tk.Text widgets for both headline and body text.  This eliminates all the special case code that selects between headline and body searches.  Moreover, the same regular expressions are now used for searches in both headlines and body text.  I doubt I could ever have produced bug-free code without this simplification.</t>
<t tx="ekr.20071028032929.1432">This hugely simplfies the find/change commands, and makes them more capable.

This also solves the "Control-K" problem in headlines.</t>
<t tx="ekr.20071028032929.1433"></t>
<t tx="ekr.20071028032929.1434">The ensure_extension routine was adding a .leo extension, thereby defeating the test for an empty file name.</t>
<t tx="ekr.20071028032929.1435">This code is much cleaner than the Borland code.  The search commands keep almost no state variables now: we always search from the present location.  This hugely simplifies the logic, and makes the code do what is expected more often.

In particular, is no longer any "first_v" or "first_position" state.  The various find and change commands will save the present state on entry, and restore that state if no finds are found.  This "local" save/restore makes much clearer what is happening.

Still to do: searching in headlines.</t>
<t tx="ekr.20071028032929.1436">The save message immediately showed a Save bug.  After doing a Save To, a following Save command used the Save To file name!  This explains why some saves "didn't take".</t>
<t tx="ekr.20071028032929.1437"></t>
<t tx="ekr.20071028032929.1438"></t>
<t tx="ekr.20071028032929.1439">This probably should depend on the size of the window, and at present it does not.</t>
<t tx="ekr.20071028032929.1440"></t>
<t tx="ekr.20071028032929.1441">I have a new toy: Python's exec statement.  This allows one to have all the flexibility found in tcl scripts.  For example, one can treat the name of variables as variables themselves.  Building statements from strings isn't quite as simple as in tcl, but the effect is exactly the same.

The added flexibily is useful when loading and saving many variables, as in the prefs and find code.  For example:

ivars = [ "tangle_batch_flag", "untangle_batch_flag",
	"use_header_flag", "output_doc_flag",
	"tangle_directory", "page_width", "tab_width" ]
	
for var in ivars:
	exec("self." + var + " = c." + var)  # self.var = c.var
	
This exec statement expresses the pattern directly.  Moreover, once the ivars list is defined many similar exec statements are possible.  Using the % operator might be even clearer:

	exec("self.%s = c.%s" % (var,var))</t>
<t tx="ekr.20071028032929.1442">This is tedious code, and Tk makes it much simpler than with other systems.</t>
<t tx="ekr.20071028032929.1443"></t>
<t tx="ekr.20071028032929.1444">Replaced global with app().idle_imported.

Replaced global with fileCommands..  This fixed a big memory botch: previously a new dummy vnode was allocated for every vnode created!

Replaced es_newline global with app().log.es_newline, i.e., frame.es_newline.  This is better than before because each log stream has its own count.</t>
<t tx="ekr.20071028032929.1445">These allow us to reclaim memory when closing a window.  It also showed a that we are wasting lots of space allocating dummy vnodes in the read logic.

With these routines in place, all __del__ routines are eventually being called, which indicates that all circular references are being destroyed by the destroy() routines.  Note that it is _not_ necessary to do any of the following:  del v, del tree, del commands or del frame.  Setting the pointers to None is enough.

Added tree.vnode_alloc_list.  v.__init__ adds items to this list.  tree.destroy removes items from this list.  This is an elegant and powerful solution: all vnodes will be reclaimed eventually, and we don't need to worry about reclaiming them while the window is open.  In particular, this avoids all problems with undo.

Added two new app() ivars to control memory management and tracing.
	self.deleteOnClose	# true: delete all frame objects when a frame closes.
	self.printDel		# true: enable prints in __del__ routines</t>
<t tx="ekr.20071028032929.1446">The frame dtor is never being called because (I think) of circular references throughout the vnode, commands and frame classes.  There are several possible approaches:

1.  Ignore the problem completely.  This makes a lot of sense, for several reasons.
	A: Memory is not an issue, and reclaiming memory at termination time doesn't help!
	B: Memory reclamation can legitimately be called a Python implementation issue.
	C: It takes time and memory to reclaim memory.
	D: Errors in reclaiming memory can lead to intermittent crashes.
	
2.  Create destroy() routine for vnodes, tnodes, commands and frames.  These routines would eliminate links between nodes, thereby freeing Python's references.  The frame.destroy() routine would also call self.top.destroy() to force the closing of the frame's window.  The destroy() routine would also do a del self to reduce the reference count of the object.

Note:  deleting vnodes and tnodes is tricky because of undo.  By far the safest course of action is never to delete these nodes until a window closes.  The easy way to do this is put every vnode in a vnode allocation list, an ivar of the tree class.  Calling tree.destroy() would do the following:

	for v in self.vnode_alloc_list:
		v.destroy()
		del v
		
With this structure in place, the __del__ routines would do nothing.  We could insert a print statement in the routines to show when the routines are actually called.  This would indicate whether circular references remain.</t>
<t tx="ekr.20071028032929.1447">The old code marked the loading headline as changed.  Added c.loading ivar to disable update of window title during loading.</t>
<t tx="ekr.20071028032929.1448">This happens when a save is quickly followed by a quit.  I can get this error when in the Python window, which is reassuring, I suppose.

frame in app().windowList trick doesn't work: very weird.

I enclosed the code in idle_redraw() in a try/except block.  I'm not sure whether this will cure all problems, but it seems like it should.</t>
<t tx="ekr.20071028032929.1449">The old code never got around to deleting the frame, tree and commands objects.

However, del self just decrements the reference count; it does not guarantee that self.__del__ is called.  In fact, it doesn't seem that __del_ is _ever_ called!  So much for cleaning up memory.

There may be a bug here, or perhaps this is just a weirdness of usint Tk or Tkinter.  At this point I haven't a clue.</t>
<t tx="ekr.20071028032929.1450"></t>
<t tx="ekr.20071028032929.1451">This is a strange one.  The problem happens when a save is quickly followed by a quit.  It appears that there is a fault in idle_redraw(), even when the code is locked out with if self in app().windowList.  This is very weird.  Even stranger is that the error traceback never happens when the Python window is opened first (so it stays open).</t>
<t tx="ekr.20071028032929.1452"></t>
<t tx="ekr.20071028032929.1453">Tested c2py.leo1to2() on LeoCB.  The script now works on both Borland and leo.py.

There is a problem with the v.commands method on Borland. The workaround was to pass the value from top() to convertLeo1to2(v,c).</t>
<t tx="ekr.20071028032929.1454"></t>
<t tx="ekr.20071028032929.1455">Once again, I am making faster progress with Python than expected.  Amazing.</t>
<t tx="ekr.20071028032929.1456">I just imported idle and voila: the IDLE IDE is available!

I did have to add r"c:\Python21\Tools\Idle" to sys.path.  I also removed the wxPython stuff from the path: they interfered with the include.

I added a few top-level functions to leo.py that were described in the scripting documentation.

I added the public commands and vnodes methods described in the scripting documentation.  Several of these routines had names that conflicted with ivars.  In those cases I changed x to mX.  The changed vnode ivars were back, firstChild, headString, next and parent.

I also added several vnode and commands methods that were described in the documentation but that did not presently exist.  Like c.findRoot, c.currentVnode, etc.

The script c2py.convertLeoTree(v) appears to work, so leo.py appears to be largely compatible with scripting in LeoCB.</t>
<t tx="ekr.20071028032929.1457"></t>
<t tx="ekr.20071028032929.1458"></t>
<t tx="ekr.20071028032929.1459">I spent almost an entire day messing with focus issues.  There are two choices:

1.  If tree.bodyKeepsFocus is true the body pane will always have focus unless we are editing a headline.  The current headline is highlighted in grey to indicate the tree has no focus.

2.  If tree.bodyKeepsFocus is false the body pane will not have focus if we select a headline by clicking on it.  In that case the curren headline will be white text on a dark blue background.  When focus shifts to the body pane, the current headline will be greyed.

After much experimentation, it seems that the first way is more convenient, though slightly less accurate as far as visual protocol goes.  I think the convenience of having focus in the body pane (where it is useful) outweighs the small visual incongruity of having the current headline be grayed even when the tree canvas is selected.

Warning: Using frame.getFocus() is much less good than using the tree.active flag, because we can edit a headline with at most two clicks.  That is not true when using frame.getFocus()

The bodyKeepsFocus logic affects all routines that alter the highlighting of headlines.</t>
<t tx="ekr.20071028032929.1460">Changed OnCloseLeoEvent so it returns not veto.</t>
<t tx="ekr.20071028032929.1461">TThe body handler didn't call setDirtyJoined.  Changed setDirtyJoined so it returns a redraw flag.</t>
<t tx="ekr.20071028032929.1462">Added virtual_event_name utility to generate &lt; &lt; name &gt; &gt;.  Sigh.

The OnCut, OnCopy and OnPaste routines just call the body key event handler to do syntax coloring and set the various dirty/changed bits.

There is a small glitch: choosing cut/copy/paste "by hand" from the menu doesn't work when the focus is in an edit label in a headline.  I'm not sure how to fix this and it is extremely minor anyway.</t>
<t tx="ekr.20071028032929.1463">Added v param to tree.recolor so we don't assume that v is the current vnode.</t>
<t tx="ekr.20071028032929.1464"></t>
<t tx="ekr.20071028032929.1465"></t>
<t tx="ekr.20071028032929.1466">I tried several options, with no luck: selectborderwidth, selectbackground, selectforground.</t>
<t tx="ekr.20071028032929.1467">Added code to leo.py to set the window icon.  Alas, the documentation is poor enough so that I don't know what the arguments to iconbitmap should be.</t>
<t tx="ekr.20071028032929.1468">I tried a lot of experiments in fileCommands.getGlobals(), and it is still not possible to set the height and width of the top level window properly.  It is still too large, and its size does not depend on the requrested width.

Note that the size of the window is set in createSplitter, by setting the size of a Frame object.  Perhaps this is interfering with matters.

The present situation is poor, but tolerable.</t>
<t tx="ekr.20071028032929.1469">Changed bd="2m" to bd=2.  This makes a big difference in how the panel looks.</t>
<t tx="ekr.20071028032929.1470">The syntax colorers can use tag_config to show tabs and spaces.  This isn't perfect (it doesn't look good now) and does not work for newlines.  It may be better than nothing, however.</t>
<t tx="ekr.20071028032929.1471">I just forgot to add it to the list of @keywords.</t>
<t tx="ekr.20071028032929.1472"></t>
<t tx="ekr.20071028032929.1473"></t>
<t tx="ekr.20071028032929.1474">These "bugs" may be appearing because these commands are always enabled in the menu.  In any case, the fixes were straightforward.</t>
<t tx="ekr.20071028032929.1475">The problem was that the body key handler was being scheduled before the new node was inserted and being called at idle time after the new node was inserted, so the body text disappeared.  The fix was to disabling scheduling if control or alt keys are down.</t>
<t tx="ekr.20071028032929.1476">All it took was the following:

font = tkFont.Font(family="Courier",size=9)
tabw = font.measure("    ")
self.body = body = Tk.Text(...font=font,tabs=tabw...)

This hard codes tabs as 4 spaces.  Later I'll make it more general.</t>
<t tx="ekr.20071028032929.1477"></t>
<t tx="ekr.20071028032929.1478">I am getting closer to getting the look of the splitter panes just right.  Setting bg="white",relief="flat",bd=0 in createSplitter helps quite a bit.

The problem with the tree pane is clearly in the Canvas widget.  If that widget is not packed the pane looks fine.  There seems to be no way to eliminate the canvas's border, and no way to prevent the border from being overwritten by the Entry widget.

Maybe there is a way: the problem may be that Entry widgets are embedded in their own windows...</t>
<t tx="ekr.20071028032929.1479">I will use leo.py from now on to develop leo.py.  It is the only way to really get the bugs out.

Changed the code that computes the length of the edit box for headlines.  We always use len(v.headString) now.  This still does not quite work properly, but it is better.

Fixed a bug in the selection logic.  The colors for the previous headline are changed only if the previous is not the same as the current.  This can happen if we click in the icon or plus/minus icon of the current headline.

Added the v.iconx and v.icony ivars so the tree.OnHeadlineKey routine can just redraw the cursor in place if it needs to change.  This is a workaround to a problem that I haven't been able to solve: namely, how to force the cursor to be visible again after the headline loses focus.  This is more than a little kludgy, especially after creating the elegant endUpdate mechanisim.  OTOH, it may point a way towards incremental redrawing of the screen.</t>
<t tx="ekr.20071028032929.1480"></t>
<t tx="ekr.20071028032929.1481"></t>
<t tx="ekr.20071028032929.1482">Changed "darkblue" to "DarkBlue".  The colors known to Tk are listed at
	http://tcl.activestate.com/man/tcl8.4/TkCmd/colors.htm 

Changed print_stack() to Print statements in es() logic.  This was more confusing than helpful.

Eliminated some accelerators (Linux only)

Added loaddir code to leo.py.
</t>
<t tx="ekr.20071028032929.1483">Added many terms to the Glossary.

Improved description of Leo2.  Partially merged Leo1 and Leo2 documentation.  It still isn't perfect.</t>
<t tx="ekr.20071028032929.1484">Probably very few people could understand the description of Leo2.</t>
<t tx="ekr.20071028032929.1485">I fixed the "last" serious bug in this version.  What was happening was that the clone information in leoFileCommands.py and leoCommands.py was alternatively being written and not being written.  The fix was to v.joinNodeTo:  there was a bug that was fixed in the Borland version that had not been fixed in this version.</t>
<t tx="ekr.20071028032929.1486">It turns out the updateCloneIndices routines in both LeoCB and leo.py are slightly buggy.  Both can increment indices multiple times for the same tnode.  In addition, LeoCB computes indices for parts of the tree beyond the actual tree, so that would increase the indices further, which is why the LeoCB version sometimes has a larger clone indices.

Neither of these "bugs" really makes a difference.  In either case, nodes are joined properly.

To "minimize" the clone indices we would do the following:

	index = 0
	v = root
	# Zero all indices.
	while v and v != next:
		v.t.cloneIndex = 0
	# Set clone index only if it has not already been set.
	while v and v != next:
		if v.t.cloneIndex == 0 and v.isCloned() and v.shouldBeClone():
			index += 1
			v.t.cloneIndex = index
		v = v.threadNext()
		
This might be just slightly slower than the "wasteful" way.</t>
<t tx="ekr.20071028032929.1487">The directory compare routines in the Python lib do not seem to exist.  The new routines compare only .py files.</t>
<t tx="ekr.20071028032929.1488"></t>
<t tx="ekr.20071028032929.1489">The lineIndent var was not set properly in &lt;&lt; Set lineIndent, linep and leading_ws &gt;&gt;, with the result that some sections contained extra leading whitespace in their body parts.

With this bug fixed, leo.py reads and writes all files correctly!</t>
<t tx="ekr.20071028032929.1490">Fixed a bug that was causing the last newline of doc parts to be deleted.  The problem was that string.rstrip() also strips newlines!  With this bug fixed it appears that Leo.py can read and write @file nodes just like Leo2CB does.

Created the removeTrailingWs() in leoUtils that strips trailing blanks and tabs.</t>
<t tx="ekr.20071028032929.1491">Rewrote the code in scanText and scanDoc that figures out where sentinels start.

The new nextLine and nextKind vars clarify what is going on.  When a non-sentinel line is output, the trailing newline is part of a sentinel if and only if nextKind is some kind of sentinel.

I'm not convinced the code in scanDoc is correct...

</t>
<t tx="ekr.20071028032929.1492">This is a very useful comparison tool.  It allows me to compare whitespace easily.</t>
<t tx="ekr.20071028032929.1493">This puts up a model dialog.  The hardest part was writing the code that centers the dialog on the screen.  Sheesh.</t>
<t tx="ekr.20071028032929.1494">I fixed many minor problems in preparation for releasing the first usable version of Leo.py.</t>
<t tx="ekr.20071028032929.1495">These bugs were simple transcription errors; they do not occur in LeoCB.

v.childIndex() was always returning 0, so naturally v.createDependents() was not working well.

Added a call to v.unlink() in v.destroyDependents.  The call to v.destroyTree() no longer does anything.</t>
<t tx="ekr.20071028032929.1496">We no longer need setIcon!!  Indeed, setIcon just calls c.redraw(), so as long as the callers enclose code in beginUpdate/endUpdate all will be well.  This eliminates a _major_ mess, and will result in further simplifications: we no longer need the distinction between the setX and initX routines!</t>
<t tx="ekr.20071028032929.1497">It turned out that tree.idle_body_key was the bottleneck, _not_ syntax coloring!

What was happening was this:  tree.redraw was being called on _every_ keystroke, and that was causing a huge amount of memory allocation and deallocation.  After a while everything ground to a halt.

The fix was very clever: I added a flag to c.endUpdate and tree.endUpdate, true by default.  tree.redraw is called only if count==0 and flag==true. So calling endUpdate(false) prevents all redraws from happening in a range of code.  This is a wonderful addition to the beginUpdate/endUpdate pattern.

Both tree.idle_body_key and v.setAncestorAtFileNodeDirty use this pattern.  The result is that tree.redraw() is called only when the icon really and truly must change.
</t>
<t tx="ekr.20071028032929.1498">Amazing.  I wrote some dummy code last night, read up on indices this morning, and got everything to work in a couple of hours. The result is very fast: no optimization is needed for Leo. I love Tkinter!

Added c.recolor and tree.recolor routines.  This hooks should be called whenever the body text changes.  Apparently there is no "OnTextChanged" event in Tk.</t>
<t tx="ekr.20071028032929.1499">Implementing this was trivial: we use a app.clipboard ivar, a string.  Using an internal clipboard means that we can't inadvertantly paste the XML representation of a string into body text.</t>
<t tx="ekr.20071028032929.1500">The only major step left before releasing a functional version of Leo is to check the @file write code.
</t>
<t tx="ekr.20071028032929.1501">The Tk clipboard handling is confusing: there are routines for clearing and setting the clipboard, but no obvious way to get the contents of the clipboard.  I could use an internal clipboard (part of the LeoApp class) for leo nodes, which would work pretty well.  If I did that I might want other commands: cut, copy and paste between node clipboard and the text widgets...

There doesn't seem to be any Python support for the clipboard, which is weird.</t>
<t tx="ekr.20071028032929.1502">This is a tedious task, no matter how it is done.</t>
<t tx="ekr.20071028032929.1503">Simplified the code that sets the current vnode and initializes icons.  Having tree.redraw update icons automatically helps a lot.

Added tree.initing hack to disable endEditLabel from marking the tree as changed. Actually, this probably isn't necessary, as top.title probably won't be redrawn until idle time anyway.</t>
<t tx="ekr.20071028032929.1504">Here is how to get accelerators working:

fileMenu.add_command(label="New", accelerator="Ctrl+N", command=self.OnNew)
self.top.bind("&lt;Control-n&gt;", self.OnNew)

Warning: using top.bind_all would not work well with multiple windows.

The accelerator="Ctrl+N" option merely sets the menu text(!).  The bind_all method actually does the work.  BTW, I had to change (self) to (self,event=None) in all the command handlers.  When an accelerator is used the handler is called with two args.  When the menu is used the handler is called with only one arg.

IDLE shows how to be a bit more clever with initialization.  I probably should study the Idle code and be clever ;-)  IDLE also use the configuration data base, and I probably should study that too.</t>
<t tx="ekr.20071028032929.1505">There are now just two routines, v.computeIcon() and v.setIcon().

v.setIcon just does c.tree.redraw() (!)

c.tree.redraw() now does nothing if the update count &gt; 0, so this is safe. Moreover, we can now enclose any code in c.beginUpdate()/c.endUpdate() without worry.

This is the way it is written in the Book.</t>
<t tx="ekr.20071028032929.1506">The &lt;Key&gt; event is called _before_ the body text is updated, so it is not possible to properly update syntax coloring, icons or tnodes there.  Instead, the &lt;Key&gt; event handler just registers an idle-time event to do the real work.  Very simple!</t>
<t tx="ekr.20071028032929.1507">The canvas widget appears to have an improper 1 or 2 pixel gray border.  I have worked around this by limiting the size of the Tk.Entry widget: expanding it only when editing is enabled.</t>
<t tx="ekr.20071028032929.1508"></t>
<t tx="ekr.20071028032929.1509">Following the IDLE code lead me astray.  IDLE does not allow the headline text to be edited!  At last some of the confusion is gone.</t>
<t tx="ekr.20071028032929.1510">openWithFileName now shows the window before loading, so that reading messages become visible.  To do this, we call app().root.update().

Made leoFrames bigger: this is done in createSplitter(!)</t>
<t tx="ekr.20071028032929.1511"></t>
<t tx="ekr.20071028032929.1512">We close the initial open window if it has not been changed.

app.quit() now closes the hidden root window to close the app.

Close processing now calls the close event handler.

There are no bugs as in wxWindows!  Everything is straightforward.</t>
<t tx="ekr.20071028032929.1513">I have rewritten the code to draw the tree, and it seems to work reliably.  However, expanding an entire tree is slow, and redrawing the tree is also slow is many nodes are visible.  I'm not sure what is causing this...

Disabling drawNode speeds up the redraw greatly.
Disabling only tags also speeds up the redraw greatly.  Indeed, way too many tags appear to be created...

Still to do: I have not been able to create edit windows in the canvas properly...</t>
<t tx="ekr.20071028032929.1514">I'm not sure whether Tkinter can read .bmp icons, so I created .gif icons, which work well.</t>
<t tx="ekr.20071028032929.1515">Rewrote v.restoreOutlineFromDVnodes.  It is now very simple because undo no longer creates dvnodes; vnodes now contain all tree information.  So when we "delete" a tree we just unlink and unjoin it, and when we "restore a tree we just relink and rejoin it.  It is truly amazing how simple the tree code now is.</t>
<t tx="ekr.20071028032929.1516">It now takes about 3 seconds to read this file, rather than the 9+ seconds needed by wxPython!  Apparently the wxPython tree class was very slow.

The _old_ bottleneck was as follows:
	Most of the time is spent in atFile scanning code
		.. c.clearAllVisited is very slow(!!) because it clears the entire tree.
			c.clearAllVisited takes about 1/3 time of the entire scanning phase (!!)
		.. Reading the file itself, is very fast, scanning in atFile::read is slow.
		.. es calls are fast.
</t>
<t tx="ekr.20071028032929.1517">A milestone.  It is now possible to read a .leo file and to draw the tree at least partially.  Most of the conversion to Tkinter has now been completed.

I removed vnode and commands getters that merely returned ivars.  Also converted wxWindows calls to Tk calls.  It is remarkable how easily the changes went.  
</t>
<t tx="ekr.20071028032929.1518">Converted all Tk prototype code to Tkinter.  It was straightforward for the most part.  The Leo window works: scrollbars work and the text panes work.  However, the tree pane is a text pane at present.

Copied menu code from Leo.py version 0.04.  Somehow the old code was lost, I have no idea why.  The copied code is wxWindows code, so it will have to be rewritten for Python.  Still, it is much easier to use the properly converted Python code.  Perhaps I deleted the code thinking that it would all have to be rewritten.  If so, that was a minor mistake.</t>
<t tx="ekr.20071028032929.1519"></t>
<t tx="ekr.20071028032929.1520">The use_tk global indicates whether Leo will use wxPython or Tkinter.  The next step is to transliterate the Tk code that creates the Leo window into Tkinter.</t>
<t tx="ekr.20071028032929.1521">After much experimentation, adding a -padx param to the log window pane seems like the only way to handle the width of the vertical scroll bar.  Without this extra padding, the scroll bar obscures the left edge of the log window.</t>
<t tx="ekr.20071028032929.1522">It simplifies and speeds up the code to use file.readline to process lines as a unit.  This way I never have to scan to the end of a line.  However, it turns out that scanning is not really the bottleneck.  In addition, we no longer read entire derived files into memory at once.

BTW, it may be possible to use readline() in the getLeoFile logic as well.  I have no idea whether this would help or not.

The problem is the _second_ half of atFile::read, that is, after the derived file has been completely scanned and all vnodes have been created!  Apparently, something (maybe shouldBeClone?) involved with setting bits is horribly slow.  I'm not sure why earlier testing didn't show this problem.  I must have been mistaken somehow in my earlier conclusions.

This actually is very good news.  It means that the raw file code is good enough as it is.  Note:  reading derived files will not slow down when I switch to Tk because we don't create vnodes unless there are file errors!

I have just found that a single call to c.clearAllVisited() in read() _substantially_ slows down the read!  Amazing.

Create v.clearVisitedInTree() and v.clearAllVisitedInTree()</t>
<t tx="ekr.20071028032929.1523">@nocolor
@ignore

This is a _very_ easy class.

Ivars
	self.root: the root vnode
	self.update: update count
		tree::beginUpdate increments.  tree::endUpdate decrements.
		Disable redraw if &gt; 0
		Redraw when falls to 0.
	self.selected: the selected vnode
	self.top the top vnode on the screen (needed?)

Tree methods know about vnodes(!) Greatly simplifies both tree and vnode classes.
tree:endUpdate does nothing if self.update &gt; 0
	User code should not call tree::redraw directly.
	Most tree methods call redraw
Insert methods create a vnode, set links and redraw.
Move methods just set links and redraw
Commands methods enclose complex operations in tree.beginUpdate/endUpdate, as they do now.
tree::delete(v) just unlinks v's tree
	vnodes are not deleted until window goes away: unlimited undo!
	v.threadNext ivar makes deleting a list trivial.

vnodes

vnodes contain headString, expanded, firstChild, parent, back, next and threadNext ivars
	tree::getThreadNext() used to set v.threadNext
	no need for dvnodes: vnodes contain all undo info!


		</t>
<t tx="ekr.20071028032929.1524">added use_tk constant in leoGlobals.</t>
<t tx="ekr.20071028032929.1525">es now outputs a newline, which makes most uses of enl and ecnl superfluous.  We can do this be string concatenation is so easy.</t>
<t tx="ekr.20071028032929.1526">There was a transliteration error in computing the line to be output which mangled long lines.</t>
<t tx="ekr.20071028032929.1527">This code has not been tested.</t>
<t tx="ekr.20071028032929.1528">There was a bug in sentinelKind.  skip_c_id won't handle @@, so @@ must be handled separately.</t>
<t tx="ekr.20071028032929.1529">It is not possible to access global _variables_ using from leoGlobals import * because that creates copies of the data.  The new way is simpler and more modular.

Revised how the prefs panel works.  The new code just sets the prefs ivars.  It is up to the caller to access the prefs panel as needed. Added tab_width preference and prefs.tab_width ivar.  This should have been done long ago.</t>
<t tx="ekr.20071028032929.1530">Fixed problems with at_xxx_ptr globals.  The problem that from leoGlobals import * doesn't work, so I changed is_special_bits so it returns a dictionary containing name:value pairs rather than setting globals.

Fixed many problems in scanAllDirectives involving paths.  Also rewrote the code in atFile::write that opens files.

At this point leo.py can read and write files except files containing @first.
</t>
<t tx="ekr.20071028032929.1531">.. initAllCloneBits had several errors.
.. self.structureErrors wasn't being initialized in atFile::Read
.. createNthChild must mark nodes as visited to suppress unvisited node logic later.
.. Added log messages any time self.structureErrors is incremented in createNthChild

At this point leo.py can read a simple test file properly, except files containing @first.</t>
<t tx="ekr.20071028032929.1532">It wasn't too hard to create a proper splitter window.  After that, creating a Leo window was trivial.</t>
<t tx="ekr.20071028032929.1533"></t>
<t tx="ekr.20071028032929.1534">I am beginning to think that globals should _never_ be used.

The @language bug appears to be a problem of not setting globals properly.</t>
<t tx="ekr.20071028032929.1535"></t>
<t tx="ekr.20071028032929.1536">Added assert in tnode::setTnodeText that we are getting a string.  This assert was not always true before I added a call to listToString in &lt;&lt; copy new_out to child's body t't' in scanText.</t>
<t tx="ekr.20071028032929.1537">The read code is slow.  I'll have to see why.

3 seconds with read doing nothing (reads leoPy.leo)
5 seconds with read reading files but not scanning them.
9 seconds with read fully enabled.

Therefore:

3 sec to read and scan LeoPy.leo
2 sec for reading all derived files
4 sec to scan all derived files.

So scanning derived files is pretty slow.

BTW, LeoCB can do everything in about 2 sec.
</t>
<t tx="ekr.20071028032929.1538">There was the usual assortment of minor problems.

.. The write code was writing flags using `flag`, and this fails if false is None.
.. Added code to make sure None is never passed to wxFileDialog as a file name.  I wonder if this could have caused problems earlier.  Once again, the C++ code is shown to be radically unsafe.

.. I think false should be defined as 0, not None.  There are several advantages:

1.  not 0 == not None, so various tests work as before.
2.  `0` is very different from `None`, and this affects the file format.

I'll make this change.  Hope it works ;-)</t>
<t tx="ekr.20071028032929.1539">A major milestone:  the read command works and so do most outline commands.  It is now clear that reading a file is fast enough so that no further work is required!

The main problems today:

1.  The code must use the test: id and id.IsOk().  Failure to make _both_ tests will cause the code to fail, possibly in an unbounded loop.  This was ultimately the problem with the Move Down command:  the threadNext code didn't make these test.  I finally called wxGetThreadNext inside threadNext and that solved the problem.

2.  I added the self.changing lockout in the LeoFrame OnTextUpdate handler so that tnodes would not be erroneously updated while switching tnodes.  The new code seems simple and robust.</t>
<t tx="ekr.20071028032929.1540">A case can be made for getters of the form:

	def getX():
		return x
		
In particular, they are a reaonable place to put asserts.  However, such getters do not seem good style in Python because all ivars are public anyway.  Moreover, getters like

	def x():
		return x
		
are invalid in Python, so there is a problem.  The simplest approach seems to be to get rid of all such redundant getters, and that is what I have just done.  Note that assert's aren't so important in wxPython, because nothing bad can happen anyway.</t>
<t tx="ekr.20071028032929.1541">This was a very interesting experience, for the following reason.

1.  The weakness of a non-compiled language is that problems don't show up until code is actually executed.
2.  Python is very safe.  The only real problem are unbounded loops.
3.  In particular, the continue statement will _always_ loop in Python unless progress the loop variable is incremented.  So care must be taken when translating C for loops into Python while loops.
4.  Even without the ability to set breakpoints (which means that single-stepping is impossible in wxPython!) it wasn't too hard to trace with print statements.  Amazing.
5.  The biggest mess came with getters that return an ivar of the same name.  I'll sleep on this, and I think the thing to do is get rid of the getter entirely:  convert x.getY() x.Y.
6.  Defining constants in a class is nice: they are accessed by class name.  For example: vnode.dirtyBit.

Status:
1.  The outline is being read in correctly.
2.  The atFile::read logic hasn't been tested.
3.  The body pane (and probably all the tnode text) is not being set properly.
4.  It is possible that we might be able to get rid of join lists!  They are used:
	a) To update the headline text
	b) For shouldBeClone.
	We could replace join lists by a reference count and temporary join lists.
	This could be really cool, and I'll have to think about this more...
	</t>
<t tx="ekr.20071028032929.1542">Created leoFileCommands.py.  We use com=self.mCommands to access the "real" commander for this class.  It would be wrong to make fileCommands a subclass of Commands; we must have exactly one commander per frame so that mCurrentVnode, mRootVnode, etc. are updated properly.

In short, the ivars of fileCommands are mFrame, mCommands and any ivars used exclusively by fileCommands.  This pattern will be used to create outlineCommands.py, findCommands.py, etc.</t>
<t tx="ekr.20071028032929.1543">The info class was confusing.  All the ivars from that class now become ivars in the fileCommands class.  The mTnodes array is now a Python dict, so there is no need for the mNumberOfTnodes or mMaxTnodeIndex ivars!  The new clode is _much_ clearer.  A major victory.</t>
<t tx="ekr.20071028032929.1544">Fixed several bugs in c2py.

Greatly simplified handlePossibleFunctionHeader; there is no need to compute a delta there:  we munge the head, args and body separately, then replace the original all at once with the new lists.  This is bullet proof.

Fixed some bugs in safeReplace and matchWord.

Fixed bugs in convertCStringToPython that caused skipDoc and skipCode to be called in the wrong places.  That was really messing things up!

Tested the speed of tests by writing speedTest.  This is so much fun!</t>
<t tx="ekr.20071028032929.1545">I have been happily converting, with the help of c2py, Leo's C++ code to python.  The new code is far, far easier to understand.</t>
<t tx="ekr.20071028032929.1546">Fixed several bugs in c2py:

1. removeExcessWS was sometimes skipping past a newline, thereby removing leading whitespace in the following line.  This made it look like the code for "if", "while" and "for" was bad.

2. the function scanning code had several bugs.  Added new code to ignore "if", "while" and "for" code.  Added new code to ignore # lines (preprocessor directives).  Added the firstOpen variable to eliminate scanning later.  This is pretty tricky code.

3. Added code to replace " . " by "." and "\t " by "\t".

4. Fixed skipPastWord so it handles underscores and digits.  This helped a lot ;-)

5. @code was not always properly converted to @c.

I think I will leave c2py as is for now.  It has the following rough edges:

1.  I don't know how to break long scripts.
2.  c2py doesn't handle : initializers in constructors well; they inhibit processing of the initializer.
3.  c2py doesn't place self. in all the places it is needed.  I'm not sure there is an elegant way to do this...</t>
<t tx="ekr.20071028032929.1547">Worked on c2py.  As documented in LeoCB.leo, had to add a __cmp__ routine in leo.py so that vnodes compare equal properly.  Fixed some minor bugs in c2py.

We now have two separate routines called leo.py.  The one used by LeoCB and LeoWX is the python expression evaluator.  The leo.py in LeoPy is the top level of leo.py.

Added signed, unsigned and bool to the list of type names.</t>
<t tx="ekr.20071028032929.1548"></t>
<t tx="ekr.20071028032929.1549">Documented the theory of operation of c2py.  This is a remarkably simple program!  Converting from string to list representation turns out to be a very good choice.</t>
<t tx="ekr.20071028032929.1550">For the last two days I have been working on c2py.py.  I am totally in love with Python.  Everything is so much easier:  Automatic debugging, no declarations, no types, no compilation. Great data structures. Even without single stepping the debugging is easy.

All major aspects of c2py are now complete.</t>
<t tx="ekr.20071028032929.1551">It has been staring me right in the face.  Idle.py supports tree views and syntax coloring!  All I need do is adapt the Idle code for Leo.  The only remaining piece of the puzzle is a good splitter window (and splitter events?)
</t>
<t tx="ekr.20071028032929.1552">All menu work is now complete, with stubs for many calls to Commands routines...
The Python menu is functional.
The Find Panel can be opened.
The Find Panel can be opened.

Still to do:
	Icons for outline
	Nodes classes
	Commands classes:
		outline commands
		file commands,
		find commands,
		tangle/untangle commands</t>
<t tx="ekr.20080408060320.781"></t>
<t tx="ekr.20090401102247.2"></t>
<t tx="ekr.20090401102247.3"></t>
<t tx="ekr.20090401102247.4"></t>
<t tx="ekr.20090401102247.5">@nocolor-node

Should only do smart tab if we are at the end if the indentation.

(X)Emacs gets it right:

* The &lt;tab&gt; key means "indent this line as it should be"

 - (done) if you are at the beginning of a blank the line, it puts the cursor at the
 right indent level, whatever that is.

 - (not done) Unnecessary, and prevents inserting of whitespace.
 if you are in the middle of the line, it indents that line to where it should
 be

* (this has always been done)
if the &lt;backspace&gt; key is pressed in the indentation space, it means: reduce
the indentation level by one.
</t>
<t tx="ekr.20090401102247.6">def insertNewLineAndTab (self,event):

    '''Insert a newline and tab at the cursor.'''

    c = self.c ; k = c.k
    w = self.editWidget(event) ; p = c.p
    if not w: return

    assert g.app.gui.isTextWidget(w)
    name = c.widget_name(w)
    if name.startswith('head'): return

    self.beginCommand(undoType='insert-newline-and-indent')

    # New in Leo 4.5: use the same logic as in selfInsertCommand.
    oldSel = w.getSelectionRange()
    self.insertNewlineHelper(w=w,oldSel=oldSel,undoType=None)
    self.updateTab(p,w,smartTab=False)
    k.setInputState('insert')
    k.showStateAndMode()

    self.endCommand(changed=True,setLabel=False)
</t>
<t tx="ekr.20090401102247.7"></t>
<t tx="ekr.20090401102247.8">def __init__(self,frame,fileName,relativeFileName=None):

    c = self

    self.requestedFocusWidget = None
    self.requestRedrawFlag = False
    self.requestedIconify = '' # 'iconify','deiconify'
    self.requestRecolorFlag = False

    # print('Commands.__init__')
    self.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.

    # Init ivars with self.x instead of c.x to keep pylint happy
    self.chapterController = None
    self.frame = frame

    self.hiddenRootNode = leoNodes.vnode(context=c)
    self.hiddenRootNode.setHeadString('&lt;hidden root vnode&gt;')
    self.hiddenRootNode.t.vnodeList = [self.hiddenRootNode]
    self.isZipped = False # May be set to True by g.openWithFileName.
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)
    self.mRelativeFileName = relativeFileName

    self.initIvars()
    self.nodeHistory = nodeHistory(c)
    self.initConfigSettings()
    c.setWindowPosition() # Do this after initing settings.

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.

    # Break circular import dependencies by importing here.
    import leo.core.leoAtFile as leoAtFile
    import leo.core.leoEditCommands as leoEditCommands
    import leo.core.leoFileCommands as leoFileCommands
    import leo.core.leoImport as leoImport
    import leo.core.leoShadow as leoShadow
    import leo.core.leoTangle as leoTangle
    import leo.core.leoUndo as leoUndo


    self.shadowController = leoShadow.shadowController(c)
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0:
        g.pr("\n*** using Null undoer ***\n")
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
</t>
<t tx="ekr.20090401102247.9">def __repr__ (self):

    return "Commander %d: %s" % (id(self),repr(self.mFileName))

__str__ = __repr__
</t>
<t tx="ekr.20090401102247.10">def finishCreate (self,initEditCommanders=True):  # New in 4.4.

    '''Finish creating the commander after frame.finishCreate.

    Important: this is the last step in the startup process.'''

    c = self ; p = c.p
    c.miniBufferWidget = c.frame.miniBufferWidget
    # print('Commands.finishCreate',c.fileName())

    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = g.app.gui.createKeyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if initEditCommanders:
        # A 'real' .leo file.
        import leo.core.leoEditCommands as leoEditCommands
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    c.frame.log.finishCreate()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20090401102247.11">def printCommandsDict (self):

    c = self

    print('Commands...')
    for key in sorted(c.commandsDict):
        command = c.commandsDict.get(key)
        print('%30s = %s' % (
            key,g.choose(command,command.__name__,'&lt;None&gt;')))
    print('')
</t>
<t tx="ekr.20090401102247.12">def hash (self):

    c = self
    if c.mFileName:
        return c.os_path_finalize(c.mFileName).lower()
    else:
        return 0
</t>
<t tx="ekr.20090401102247.13">def initAfterLoad (self):

    '''Provide an offical hook for late inits of the commander.'''

    pass</t>
<t tx="ekr.20090401102247.14">def initConfigSettings (self):

    '''Init all cached commander config settings.'''

    c = self ; cf = c.config

    c.autoindent_in_nocolor = cf.getBool('autoindent_in_nocolor_mode')
    c.contractVisitedNodes  = cf.getBool('contractVisitedNodes')
    c.fixed                 = cf.getBool('fixedWindow',False)
    c.fixedWindowPosition   = cf.getData('fixedWindowPosition')
    c.showMinibuffer        = cf.getBool('useMinibuffer')
    c.sparse_goto_parent    = cf.getBool('sparse_goto_parent')
    c.stayInTree            = cf.getBool('stayInTreeAfterSelect')
    c.smart_tab             = cf.getBool('smart_tab')
        # Note: there is also a smart_auto_indent setting.
    c.tab_width             = cf.getInt('tab_width') or -4

    # g.trace('smart %s, tab_width %s' % (c.smart_tab, c.tab_width))

</t>
<t tx="ekr.20090401102247.15">def initIvars(self):

    c = self
    &lt;&lt; initialize ivars &gt;&gt;
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
</t>
<t tx="ekr.20090401102247.16">self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.doubleClickFlag = False
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui
self.ipythonController = None # Set only by the ipython plugin.

# Interlock to prevent setting c.changed when switching chapters.
c.suppressHeadChanged = False

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None
self.timeStampDict = {} # New in Leo 4.6.

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False

# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False

# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files

# For outline navigation.
self.navPrefix = '' # Must always be a string.
self.navTime = None

# Controller-specific pickleshare db at /foo/bar.leo_db/

import leo.external.pickleshare
pth, bname = os.path.split(self.mFileName)

if pth and bname:
    dbdirname = '%s/.%s_db' % (pth, bname)
    self.db = leo.external.pickleshare.PickleShareDB(dbdirname)
else:
    self.db = None
    if not g.app.silentMode and not g.unitTesting:
        print("\n*** No file in controller, using c.db=None ***\n")
</t>
<t tx="ekr.20090401102247.17">def setWindowPosition (self):

    c = self

    if c.fixedWindowPosition:
        try:
            w,h,l,t = self.fixedWindowPosition
            c.fixedWindowPosition = int(w),int(h),int(l),int(t)
        except Exception:
            g.es_print('bad @data fixedWindowPosition',
                repr(self.fixedWindowPosition),color='red')
    else:
        c.windowPosition = 500,700,50,50 # width,height,left,top.
</t>
<t tx="ekr.20090401102247.18">def selfInsertCommand(self,event,action='insert'):

    '''Insert a character in the body pane.
    This is the default binding for all keys in the body pane.'''

    trace = False and not g.unitTesting # or c.config.getBool('trace_masterCommand')
    verbose = False
    w = self.editWidget(event)
    if not w: return 'break'
    &lt;&lt; set local vars &gt;&gt;
    if trace: g.trace('ch',repr(ch),'keysym',repr(keysym)) # ,'stroke',repr(stroke))
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        self.insertNewlineHelper(w,oldSel,undoType)
    elif inBrackets and self.autocompleteBrackets:
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i &gt; j: i,j = j,i
        # Use raw insert/delete to retain the coloring.
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
        if inBrackets and self.flashMatchingBrackets:

            self.flashMatchingBracketsHelper(w,i,ch)               
    else:
        return 'break' # This method *always* returns 'break'

    # Set the column for up and down keys.
    spot = w.getInsertPoint()
    c.editCommands.setMoveCol(w,spot)

    # Update the text and handle undo.
    newText = w.getAllText()
    changed = newText != oldText
    if trace and verbose:
        g.trace('ch',repr(ch),'changed',changed,'newText',repr(newText[-10:]))
    if changed:
        # g.trace('ins',w.getInsertPoint())
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None)

    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'
</t>
<t tx="ekr.20090401102247.19">c = self.c
p = c.p
gui = g.app.gui
ch = gui.eventChar(event)
keysym = gui.eventKeysym(event)
# stroke = gui.eventStroke(event)
if keysym == 'Return':
    ch = '\n' # This fixes the MacOS return bug.
if keysym == 'Tab': # Support for wx_alt_gui plugin.
    ch = '\t'
name = c.widget_name(w)
oldSel =  name.startswith('body') and w.getSelectionRange() or (None,None)
oldText = name.startswith('body') and p.b or ''
undoType = 'Typing'
brackets = self.openBracketsList + self.closeBracketsList
inBrackets = ch and g.toUnicode(ch,g.app.tkEncoding) in brackets
# if trace: g.trace(name,repr(ch),ch and ch in brackets)</t>
<t tx="ekr.20090401102247.20">def doPlainTab(self,s,i,tab_width,w):

    '''Insert spaces equivalent to one tab.'''

    start,end = g.getLine(s,i)
    s2 = s[start:i]
    width = g.computeWidth(s2,tab_width)

    if tab_width &gt; 0:
        w.insert(i,'\t')
        ins = i+1
    else:
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert(i,' ' * n)
        ins = i+n

    w.setSelectionRange(ins,ins,insert=ins)
</t>
<t tx="ekr.20090401102247.21">def flashCharacter(self,w,i):

    bg      = self.bracketsFlashBg or 'DodgerBlue1'
    fg      = self.bracketsFlashFg or 'white'
    flashes = self.bracketsFlashCount or 3
    delay   = self.bracketsFlashDelay or 75

    w.flashCharacter(i,bg,fg,flashes,delay)
</t>
<t tx="ekr.20090401102247.22">def flashMatchingBracketsHelper (self,w,i,ch):

    d = {}
    if ch in self.openBracketsList:
        for z in range(len(self.openBracketsList)):
            d [self.openBracketsList[z]] = self.closeBracketsList[z]
        reverse = False # Search forward
    else:
        for z in range(len(self.openBracketsList)):
            d [self.closeBracketsList[z]] = self.openBracketsList[z]
        reverse = True # Search backward

    delim2 = d.get(ch)

    s = w.getAllText()
    j = g.skip_matching_python_delims(s,i,ch,delim2,reverse=reverse)
    if j != -1:
        self.flashCharacter(w,j)
</t>
<t tx="ekr.20090401102247.23">def initBracketMatcher (self,c):

    if len(self.openBracketsList) != len(self.closeBracketsList):

        g.es_print('bad open/close_flash_brackets setting: using defaults')
        self.openBracketsList  = '([{'
        self.closeBracketsList = ')]}'

    # g.trace('self.openBrackets',openBrackets)
    # g.trace('self.closeBrackets',closeBrackets)
</t>
<t tx="ekr.20090401102247.24">def insertNewlineHelper (self,w,oldSel,undoType):

    c = self.c ; p = c.p
    i,j = oldSel ; ch = '\n'

    if i != j:
        # No auto-indent if there is selected text.
        w.delete(i,j)
        w.insert(i,ch)
        w.setInsertPoint(i+1)
    else:
        w.insert(i,ch)
        w.setInsertPoint(i+1)

        if (c.autoindent_in_nocolor or 
            (c.frame.body.colorizer.useSyntaxColoring(p) and
            undoType != "Change")
        ):
            # No auto-indent if in @nocolor mode or after a Change command.
            self.updateAutoIndent(p,w)

    w.seeInsertPoint()
</t>
<t tx="ekr.20090401102247.25">def updateAutoIndent (self,p,w):

    c = self.c ; d = c.scanAllDirectives(p)
    tab_width = d.get("tabwidth",c.tab_width)
    # Get the previous line.
    s = w.getAllText()
    ins = w.getInsertPoint()
    i = g.skip_to_start_of_line(s,ins)
    i,j = g.getLine(s,i-1)
    s = s[i:j-1]
    # g.trace(i,j,repr(s))

    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    # g.trace('width',width,'tab_width',tab_width)

    if s and s [-1] == ':':
        # For Python: increase auto-indent after colons.
        if g.findLanguageDirectives(c,p) == 'python':
            width += abs(tab_width)
    if self.smartAutoIndent:
        # Determine if prev line has unclosed parens/brackets/braces
        bracketWidths = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                bracketWidths.append(i+tabex+1)
            elif s [i] in '}])' and len(bracketWidths) &gt; 1:
                bracketWidths.pop()
        width = bracketWidths.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        i = w.getInsertPoint()
        w.insert(i,ws)
        w.setInsertPoint(i+len(ws))
</t>
<t tx="ekr.20090401102247.26">def updateAutomatchBracket (self,p,w,ch,oldSel):

    # assert ch in ('(',')','[',']','{','}')

    c = self.c ; d = c.scanAllDirectives(p)
    i,j = oldSel
    language = d.get('language')
    s = w.getAllText()

    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j: w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            ins = w.getInsertPoint()
            w.setInsertPoint(ins-1)
    else:
        ins = w.getInsertPoint()
        ch2 = ins&lt;len(s) and s[ins] or ''
        if ch2 in (')',']','}'):
            ins = w.getInsertPoint()
            w.setInsertPoint(ins+1)
        else:
            if i != j: w.delete(i,j)
            w.insert(i,ch)
            w.setInsertPoint(i+1)
</t>
<t tx="ekr.20090401102247.27">def updateTab (self,p,w,smartTab=True):

    c = self.c

    # g.trace('tab_width',tab_width)
    i,j = w.getSelectionRange()
        # Returns insert point if no selection, with i &lt;= j.

    if i != j:
        # w.delete(i,j)
        c.indentBody()
    else:
        d = c.scanAllDirectives(p)
        tab_width = d.get("tabwidth",c.tab_width)
        # Get the preceeding characters.
        s = w.getAllText()
        # start = g.skip_to_start_of_line(s,i)
        start,end = g.getLine(s,i)
        before = s[start:i]
        after = s[i:end]
        if after.endswith('\n'): after = after[:-1]
        ws = g.get_leading_ws(before)
        s2 = s[start:i] # The characters before the insert point.

        # Only do smart tab at the start of a blank line.
        doSmartTab = (smartTab and c.smart_tab and i == start)
            # Truly at the start of the line.
            # and not after # Nothing *at all* after the cursor.
        # g.trace(doSmartTab,'i %s start %s after %s' % (i,start,repr(after)))

        if doSmartTab:
            self.updateAutoIndent(p,w)
            # Add a tab if otherwise nothing would happen.
            if s == w.getAllText():
                self.doPlainTab(s,i,tab_width,w)
        else:
            self.doPlainTab(s,i,tab_width,w)
</t>
<t tx="ekr.20090401102247.28"></t>
<t tx="ekr.20090401102247.29"># This should result in a huge speed improvement.</t>
<t tx="ekr.20090401102247.30"># Visible externally so plugins may add to the list of directives.

globalDirectiveList = [

    # Longer prefixes must appear before shorter.
    'all',
    'code','color', 'comment','c',
    'delims','doc','encoding','end_raw',
    'first','header','ignore','killcolor',
    'language','last','lineending',
    'markup', # Make this an official directive,
    'nocolor-node','nocolor','noheader','nowrap',
    'others','pagewidth','path','quiet',
    'raw','root-code','root-doc','root','silent',
    'tabwidth', 'terse',
    'unit','verbose', 'wrap',
]</t>
<t tx="ekr.20090401102247.31">def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    # aList = g.get_directives_dict_list(p)
    # w = g.scanAtTabwidthDirectives(aList)

    w = g.findTabWidthDirectives(c,p)
    if w is None: w = c.tab_width
    c.frame.setTabWidth(w)
</t>
<t tx="ekr.20090401102247.32"># New in Leo 4.6:
# g.findAtTabWidthDirectives, g.findLanguageDirectives and
# g.get_directives_dict use re module for faster searching.</t>
<t tx="ekr.20090401102247.33">def comment_delims_from_extension(filename):

    """
    Return the comment delims corresponding to the filename's extension.

    &gt;&gt;&gt; import leo.core.leoGlobals as g
    &gt;&gt;&gt; g.comment_delims_from_extension(".py")
    ('#', None, None)

    &gt;&gt;&gt; g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')

    &gt;&gt;&gt; g.comment_delims_from_extension(".html")
    (None, '&lt;!--', '--&gt;')

    """

    if filename.startswith('.'):
        # Python 2.6 changes how splitext works.
        root,ext = None,filename
    else:
        root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)

    language = g.app.extension_dict.get(ext[1:])
    if ext:
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension: %s, filename: %s, root: %s" % (
            repr(ext),repr(filename),repr(root)))
        return None,None,None
</t>
<t tx="ekr.20090401102247.34">def computeRelativePath (path):

    if len(path) &gt; 2 and (
        (path[0]=='&lt;' and path[-1] == '&gt;') or
        (path[0]=='"' and path[-1] == '"') or
        (path[0]=="'" and path[-1] == "'")
    ):
        path = path[1:-1].strip()

    # We want a *relative* path, not an absolute path.
    return path
</t>
<t tx="ekr.20090401102247.35">g_tabwidth_pat = re.compile(r'(^@tabwidth)',re.MULTILINE)

def findTabWidthDirectives(c,p):

    '''Return the language in effect at position p.'''

    if c is None:
        return # c may be None for testing.

    w = None
    for p in p.self_and_parents_iter(copy=True):
        if w: break
        for s in p.h,p.b:
            if w: break
            anIter = g_tabwidth_pat.finditer(s)
            for m in anIter:
                word = m.group(0)
                i = m.start(0)
                j = g.skip_ws(s,i + len(word))
                junk,w = g.skip_long(s,j)
                if w == 0: w = None
    return w
</t>
<t tx="ekr.20090401102247.36">g_language_pat = re.compile(r'(^@language)',re.MULTILINE)

def findLanguageDirectives(c,p):

    '''Return the language in effect at position p.'''

    trace = False and not g.unitTesting

    if c is None:
        return # c may be None for testing. 
    if c.target_language:
        language = c.target_language.lower()
    else:
        language = 'python'
    found = False
    for p in p.self_and_parents_iter(copy=True):
        if found: break
        for s in p.h,p.b:
            if found: break
            anIter = g_language_pat.finditer(s)
            for m in anIter:
                word = m.group(0)
                i = m.start(0)
                j = i + len(word)
                k = g.skip_line(s,j)
                language = s[j:k].strip()
                found = True

    if trace: g.trace(language)
    return language
</t>
<t tx="ekr.20090401102247.37">@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(c,name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return c.nullPosition()
</t>
<t tx="ekr.20090401102247.38"># The caller passes [root_node] or None as the second arg.
# This allows us to distinguish between None and [None].

g_noweb_root = re.compile('&lt;'+'&lt;'+'*'+'&gt;'+'&gt;'+'=',re.MULTILINE)

def get_directives_dict(p,root=None):

    """Scan p for @directives found in globalDirectiveList.

    Returns a dict containing pointers to the start of each directive"""

    trace = False and not g.unitTesting

    if root: root_node = root[0]
    d = {}

    # Do this every time so plugins can add directives.
    pat = g.compute_directives_re()
    directives_pat = re.compile(pat,re.MULTILINE)

    # The headline has higher precedence because it is more visible.
    for kind,s in (('body',p.h),('head',p.b)):
        anIter = directives_pat.finditer(s)
        for m in anIter:
            word = m.group(0)[1:] # Omit the @
            i = m.start(0)
            if word.strip() not in d:
                j = i + 1 + len(word)
                k = g.skip_line(s,j)
                val = s[j:k].strip()
                if trace: g.trace(word,repr(val))
                d[word.strip()] = val

    if root:
        anIter = g_noweb_root.finditer(p.b)
        for m in anIter:
            if root_node:
                d["root"]=0 # value not immportant
            else:
                g.es('%s= requires @root in the headline' % (
                    g.angleBrackets('*')))
            break

    if trace: g.trace('%4d' % (len(p.h) + len(p.b)),g.callers(5))
    return d
</t>
<t tx="ekr.20090401102247.39">def compute_directives_re ():

    '''Return an re pattern which will match all Leo directives.'''

    global globalDirectiveList

    aList = ['^@%s' % z for z in globalDirectiveList
                if z != 'others']

    # @others can have leading whitespace.
    aList.append(r'^\s@others')

    return '|'.join(aList)
</t>
<t tx="ekr.20090401102247.40">def get_directives_dict_list(p1):

    """Scans p and all its ancestors for directives.

    Returns a list of dicts containing pointers to
    the start of each directive"""

    trace = False and not g.unitTesting

    if trace: time1 = g.getTime()

    result = [] ; p1 = p1.copy()

    for p in p1.self_and_parents_iter():
        if p.hasParent(): root = None
        else:             root = [p.copy()]
        result.append(g.get_directives_dict(p,root=root))

    if trace:
        n = len(p1.h) + len(p1.b)
        g.trace('%4d %s' % (n,g.timeSince(time1)))

    return result
</t>
<t tx="ekr.20090401102247.41">def getOutputNewline (c=None,name=None):

    '''Convert the name of a line ending to the line ending itself.

    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''

    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    # g.trace(c,name,c.config.output_newline,'returns',repr(s))
    return s
</t>
<t tx="ekr.20090401102247.42">def scanAtCommentAndAtLanguageDirectives(aList):

    '''Scan aList for @comment and @language directives.

    @comment should follow @language if both appear in the same node.'''

    lang = None

    for d in aList:

        comment = d.get('comment')
        language = d.get('language')

        # Important: assume @comment follows @language.
        if language:
            # if g.unitTesting: g.trace('language',language)
            lang,delim1,delim2,delim3 = g.set_language(language,0)

        if comment:
            # if g.unitTesting: g.trace('comment',comment)
            delim1,delim2,delim3 = g.set_delims_from_string(comment)

        if comment or language:
            delims = delim1,delim2,delim3
            return {'language':lang,'comment':comment,'delims':delims}

    return None
</t>
<t tx="ekr.20090401102247.43">def scanAtEncodingDirectives(aList):

    '''Scan aList for @encoding directives.'''

    for d in aList:
        encoding = d.get('encoding')
        if encoding and g.isValidEncoding(encoding):
            # g.trace(encoding)
            return encoding
        elif encoding and not g.app.unitTesting:
            g.es("invalid @encoding:",encoding,color="red")

    return None
</t>
<t tx="ekr.20090401102247.44">def scanAtHeaderDirectives(aList):

    '''scan aList for @header and @noheader directives.'''

    for d in aList:
        if d.get('header') and d.get('noheader'):
            g.es_print("conflicting @header and @noheader directives",color='red')</t>
<t tx="ekr.20090401102247.45">def scanAtLineendingDirectives(aList):

    '''Scan aList for @lineending directives.'''

    for d in aList:

        e = d.get('lineending')
        if e in ("cr","crlf","lf","nl","platform"):
            lineending = g.getOutputNewline(name=e)
            return lineending
        # else:
            # g.es("invalid @lineending directive:",e,color="red")

    return None
</t>
<t tx="ekr.20090401102247.46">def scanAtPagewidthDirectives(aList,issue_error_flag=False):

    '''Scan aList for @pagewidth directives.'''

    for d in aList:
        s = d.get('pagewidth')
        if s is not None:
            i, val = g.skip_long(s,0)
            if val != None and val &gt; 0:
                # g.trace(val)
                return val
            else:
                if issue_error_flag and not g.app.unitTesting:
                    g.es("ignoring @pagewidth",s,color="red")

    return None
</t>
<t tx="ekr.20090401102247.47">def scanAtRootOptions (s,i,err_flag=False):

    # The @root has been eaten when called from tangle.scanAllDirectives.
    if g.match(s,i,"@root"):
        i += len("@root")
        i = g.skip_ws(s,i)

    mode = None 
    while g.match(s,i,'-'):
        &lt;&lt; scan another @root option &gt;&gt;

    if mode == None:
        doc = app.config.at_root_bodies_start_in_doc_mode
        mode = g.choose(doc,"doc","code")

    return i,mode
</t>
<t tx="ekr.20090401102247.48">i += 1 ; err = -1

if g.match_word(s,i,"code"): # Just match the prefix.
    if not mode: mode = "code"
    elif err_flag: g.es("modes conflict in:",g.get_line(s,i))
elif g.match(s,i,"doc"): # Just match the prefix.
    if not mode: mode = "doc"
    elif err_flag: g.es("modes conflict in:",g.get_line(s,i))
else:
    err = i-1

# Scan to the next minus sign.
while i &lt; len(s) and s[i] not in (' ','\t','-'):
    i += 1

if err &gt; -1 and err_flag:
    z_opt = s[err:i]
    z_line = g.get_line(s,i)
    g.es("unknown option:",z_opt,"in",z_line)
</t>
<t tx="ekr.20090401102247.49">def scanAtTabwidthDirectives(aList,issue_error_flag=False):

    '''Scan aList for @tabwidth directives.'''

    for d in aList:
        s = d.get('tabwidth')
        if s is not None:
            junk,val = g.skip_long(s,0)

            if val not in (None,0):
                # g.trace(val)
                return val
            else:
                if issue_error_flag and not g.app.unitTesting:
                    g.es("ignoring @tabwidth",s,color="red")

    return None
</t>
<t tx="ekr.20090401102247.50">def scanAtWrapDirectives(aList,issue_error_flag=False):

    '''Scan aList for @wrap and @nowrap directives.'''

    for d in aList:
        if d.get('wrap') is not None:
            return True
        elif d.get('nowrap') is not None:
            return False

    return None</t>
<t tx="ekr.20090401102247.51">def scanDirectives(c,p=None):

    return c.scanAllDirectives(p)</t>
<t tx="ekr.20090401102247.52">def scanForAtIgnore(c,p):

    """Scan position p and its ancestors looking for @ignore directives."""

    if g.app.unitTesting:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        d = g.get_directives_dict(p)
        if 'ignore' in d:
            return True

    return False
</t>
<t tx="ekr.20090401102247.53">def scanForAtLanguage(c,p):

    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""

    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents_iter():
            d = g.get_directives_dict(p)
            if 'language' in d:
                z = d["language"]
                language,delim1,delim2,delim3 = g.set_language(z,0)
                return language

    return c.target_language
</t>
<t tx="ekr.20090401102247.54">def scanForAtSettings(p):

    """Scan position p and its ancestors looking for @settings nodes."""

    for p in p.self_and_parents_iter():
        h = p.h
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
</t>
<t tx="ekr.20090401102247.55"># Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    # g.trace(g.callers())

    val = g.app.language_delims_dict.get(language)
    # if language.startswith('huh'): g.pdb()

    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
</t>
<t tx="ekr.20090401102247.56">def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.

    This code can be called from @language logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)

    count = 0 ; delims = [None, None, None]
    while count &lt; 3 and i &lt; len(s):
        i = j = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1

    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in range(0,3):
        if delims[i]:
            delims[i] = delims[i].replace("__",'\n').replace('_',' ')

    return delims[0], delims[1], delims[2]
</t>
<t tx="ekr.20090401102247.57">def set_language(s,i,issue_errors_flag=False):

    """Scan the @language directive that appears at s[i:].

    The @language may have been stripped away.

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    # assert(g.match_word(s,i,tag))
    if g.match_word(s,i,tag):
        i += len(tag)
    # Get the argument.
    i = g.skip_ws(s, i)
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = s[j:i].lower()
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3

    if issue_errors_flag:
        g.es("ignoring:",g.get_line(s,i))

    return None, None, None, None,
</t>
<t tx="ekr.20090401102247.58"># This is a refactoring, used by leoImport.scanDefaultDirectory and
# atFile.scanDefault directory

def setDefaultDirectory(c,p,importing=False):

    '''Set default_directory by scanning @path directives.
    Return (default_directory,error_message).'''

    default_directory = '' ; error = ''
    if not p: return default_directory,error

    &lt;&lt; Set path from @file node &gt;&gt;

    if not default_directory:
        # Scan for @path directives.
        aList = g.get_directives_dict_list(p)
        path = c.scanAtPathDirectives(aList)
        if path:
            &lt;&lt; handle @path &gt;&gt;

    if not default_directory:
        &lt;&lt; Set current directory &gt;&gt;

    if not default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        error = "No absolute directory specified anywhere."

    # g.trace('returns',default_directory)
    return default_directory, error
</t>
<t tx="ekr.20090401102247.59"># An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName()
theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        default_directory = theDir
    else:
        default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
        if not default_directory:
            error = "Directory \"%s\" does not exist" % theDir
</t>
<t tx="ekr.20090401102247.60">path = g.computeRelativePath (path)

if path:
    base = g.getBaseDirectory(c) # returns "" on error.
    path = c.os_path_finalize_join(base,path)

    if g.os_path_isabs(path):
        if g.os_path_exists(path):
            default_directory = path
        else:
            default_directory = g.makeAllNonExistentDirectories(path,c=c)
            if not default_directory:
                error = "invalid @path: %s" % path
            else:
                error = "ignoring bad @path: %s" % path
else:
    error = "ignoring empty @path"
</t>
<t tx="ekr.20090401102247.61"># This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not default_directory)

if c.frame:
    base = g.getBaseDirectory(c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) &gt; 0:
            theDir = c.os_path_finalize_join(base,theDir) # Bug fix: 2008/9/23
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    default_directory = theDir ; break
                else:
                    default_directory = g.makeAllNonExistentDirectories(theDir,c=c)
</t>
<t tx="ekr.20090401102247.62">def getTime():
    return time.clock()

def esDiffTime(message, start):
    delta = time.clock()-start
    g.es('',"%s %6.3f sec." % (message,delta))
    return time.clock()

def printDiffTime(message, start):
    delta = time.clock()-start
    g.pr("%s %6.3f sec." % (message,delta))
    return time.clock()

def timeSince(start):
    return "%6.3f sec." % (time.clock()-start)
</t>
<t tx="ekr.20090401102247.63">@nocolor-node

This has probably been fixed by the body-pane-out-of-synch bug fix.

http://groups.google.com/group/leo-editor/browse_thread/thread/cf688f9c47eb5fd7

Hi. I have just tried new qt plug-in and found out that when I open a
leo file with chapters, I can see in outline on the top node with
headline @chapters. But when I click in any node, the @chapters node
disappears and when I execute mini-buffer command select-chapter I can
not see selected chapter until I click in top node in outline.

I am using Windows Vista
Leo Log Window...
Leo 4.5.1 final, build  1.244 , September 14, 2008
python 2.5.1, qt version 263169
Windows 6, 0, 6001, 2, Service Pack 1
Rev 1537

Vitalije </t>
<t tx="ekr.20090401102247.64">@nocolor

Note: putting nodes under the @chapters node is not recommended.

here you are a file that requested to me. When I open it the tree pane
appears fully contracted and no node is selected but the content of the
body pane is that of the node named "Moment angular". Anyway I don't
think the problem is in any particular file because I've observed this
behavior in different files. In fact I've seen worse things:

- I start it leo passing the filename as an argument
- the file gets opened. Sometimes the tree pane is expanded and
 sometimes it is fully collapsed
- when the tree pane is fully collapsed sometimes the @chapters node is
 selected and sometimes not.  In any case the body pane contents always
 correspond to the most recently edited node of the file
- I've also observed that if the tree pane is collapsed *and* the
 @chapters node is selected then expanding the tr`ee results in the node
 whose content is being displayed in the body pane being renamed to
 @chapters

I'm really sorry because I cannot reproduce this behavior systematically
so maybe the attached file will work just fine for you. However I'm
seeing the described behavior here quite often.

@color
</t>
<t tx="ekr.20090401102247.65">def select (self,w=None,selectEditor=True):

    '''Restore chapter information and redraw the tree when a chapter is selected.'''

    if self.selectLockout: return

    try:
        self.selectLockout = True
        self.chapterSelectHelper(w,selectEditor)
        if self.cc.tt:
            self.cc.tt.setTabLabel(self.name)
    finally:
        self.selectLockout = False
</t>
<t tx="ekr.20090401102247.66">def chapterSelectHelper (self,w=None,selectEditor=True):

    c = self.c ; cc = self.cc ; name = self.name

    # g.trace(name,'self.p',self.p) # ,'self.root',self.root) # 'w.leo_p',w and w.leo_p)

    cc.selectedChapter = self

    # Next, recompute p and possibly select a new editor.
    if w:
        assert w == c.frame.body.bodyCtrl
        assert w.leo_p
        # g.trace(name,'w.leo_p',w.leo_p,'p',p)
        self.p = p = self.findPositionInChapter(w.leo_p)
        if p != w.leo_p: g.trace('****** can not happen: lost p',w.leo_p)
    else:
        # This must be done *after* switching roots.
        target_p = self.p or self.root.firstChild() or self.root
        #g.trace(name,'target_p',target_p)
        #g.trace(name,'self.p',self.p,'self.root',self.root)
        self.p = p = self.findPositionInChapter(target_p)
        if selectEditor:
            w = self.findEditorInChapter(p)
            c.frame.body.selectEditor(w) # Switches text.

    if name == 'main' and cc.chaptersNode:
        cc.chaptersNode.contract()    
    c.hoistStack = self.hoistStack[:]

    c.selectPosition(p)
    c.redraw_after_select(p)
    g.doHook('hoist-changed',c=c)
    c.bodyWantsFocusNow()</t>
<t tx="ekr.20090401102247.67">def findPositionInChapter (self,p1,strict=False):

    '''Return a valid position p such that p.v == v.'''

    # Do nothing if the present position is in the proper chapter.
    c = self.c ; name = self.name 

    root = g.choose(self.name=='main',c.rootPosition(),self.root)
    # g.trace('p1',p1)
    if p1 and c.positionExists(p1,root=root):
        # g.trace('using existing position',p)
        return p1

    if name == 'main':
        for p in self.c.all_positions_with_unique_vnodes_iter():
            if p.v == p1.v:
                # g.trace('*** found in main chapter',p)
                self.p = p.copy()
                return self.p
        if strict:
            return None
        else:
            self.p = c.rootPosition()
    else:
        for p in self.root.self_and_subtree_iter():
            # g.trace('testing',p,p1)
            if p.v == p1.v:
                # g.trace('*** found in chapter',p)
                self.p = p.copy()
                return self.p
        if strict:
            return None
        else:
            self.p = self.root.copy()

    if 0:
        self.error('***** chapter: %s findPositionInChapter: lost %s' % (
            self.name,p1.v.t._headString))
        g.trace(g.callers())

    return self.p.copy()
</t>
<t tx="ekr.20090401102247.68">def findEditorInChapter (self,p):

    '''return w, an editor displaying position p.'''

    chapter = self ; c = self.c

    w = c.frame.body.findEditorForChapter(chapter,p)
    w.leo_chapter = chapter
    w.leo_p = p and p.copy()
    return w</t>
<t tx="ekr.20090401102247.69">def positionIsInChapter (self,p):

    p2 = self.findPositionInChapter (p,strict=True)

    # g.trace(self.name,'returns',p2)
    return p2</t>
<t tx="ekr.20090401102247.70">def rename (self,newName):

    p = self.root
    s = '@chapter ' + newName
    p.setHeadString(s)
</t>
<t tx="ekr.20090401102247.71">tree_select_lockout = False

def select (self,p,scroll=True):

    '''Select a node.
    Never redraws outline, but may change coloring of individual headlines.
    The scroll argument is used by tk to suppress scrolling while dragging.'''

    if g.app.killed or self.tree_select_lockout: return None

    try:
        c = self.c ; old_p = c.p
        val = 'break'
        self.tree_select_lockout = True
        c.frame.tree.beforeSelectHint(p,old_p)
        val = self.selectHelper(p,scroll=scroll)
    finally:
        self.tree_select_lockout = False
        c.frame.tree.afterSelectHint(p,old_p)

    return val  # Don't put a return in a finally clause.
</t>
<t tx="ekr.20090401102247.72">#  Do **not** try to "optimize" this by returning if p==tree.currentPosition.

def selectHelper (self,p,scroll):

    trace = False and not g.unitTesting
    verbose = True
    c = self.c ; frame = c.frame
    body = w = frame.body.bodyCtrl
    if not w: return # Defensive.

    old_p = c.p

    if not p:
        # Do *not* test c.positionExists(p) here.
        # We may be in the process of changing roots.
        return None # Not an error.

    if trace:
        if verbose: g.trace(
            '\nold:',old_p and old_p.h,'\nnew:',p and p.h)
        else: g.trace(p and p.h)

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.p here!
                if 0: # Interferes with new colorizer.
                    self.canvas.update_idletasks()
                    self.scrollTo(p)
                if scroll and g.app.gui.guiName() == 'tkinter':
                    def scrollCallback(self=self,p=p):
                        self.scrollTo(p)
                    self.canvas.after(100,scrollCallback)
            except Exception: pass
        c.nodeHistory.update(p) # Remember this position.
    c.setCurrentPosition(p)
    &lt;&lt; set the current node &gt;&gt;
    c.frame.body.assignPositionToEditor(p) # New in Leo 4.4.1.
    c.frame.updateStatusLine() # New in Leo 4.4.1.

    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)

    return 'break' # Supresses unwanted selection.
</t>
<t tx="ekr.20090401102247.73"># Remember the position of the scrollbar before making any changes.
if body:
    yview = body.getYScrollPosition()
    insertSpot = c.frame.body.getInsertPoint()
else:
    g.trace('no body!','c.frame',c.frame,'old_p',old_p)
    yview,insertSpot = None,0

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p:
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
</t>
<t tx="ekr.20090401102247.74"># Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.h
frame.setWrap(p)
self.setBodyTextAfterSelect(p,old_p)
</t>
<t tx="ekr.20090401102247.75">self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.use_chapters:
    cc = c.chapterController
    theChapter = cc and cc.getSelectedChapter()
    if theChapter:
        theChapter.p = p.copy()
        # g.trace('tkTree',theChapter.name,'v',id(p.v),p.h)

if self.stayInTree:
    c.treeWantsFocus()
else:
    c.bodyWantsFocus()</t>
<t tx="ekr.20090401102247.76">def setBodyTextAfterSelect (self,p,old_p):

    # Always do this.  Otherwise there can be problems with trailing newlines.
    c = self.c ; w = c.frame.body.bodyCtrl
    s = g.toUnicode(p.v.t._bodyString,"utf-8")
    old_s = w.getAllText()

    if p and p == old_p and c.frame.body.colorizer.isSameColorState() and s == old_s:
        pass
    else:
        # This destroys all color tags, so do a full recolor.
        colorizer = c.frame.body.colorizer
        if hasattr(colorizer,'setHighlighter'):
            colorizer.setHighlighter(p)
        w.setAllText(s)
        self.frame.body.recolor(p)

    if p.v and p.v.t.scrollBarSpot != None:
        first,last = p.v.t.scrollBarSpot
        w.setYScrollPosition(first)

    if p.v and p.v.t.insertSpot != None:
        spot = p.v.t.insertSpot
        w.setInsertPoint(spot)
        w.see(spot)
    else:
        w.setInsertPoint(0)</t>
<t tx="ekr.20090401102247.77">def expandAllAncestors (self,p):

    '''Expand all ancestors without redrawing.

    Return a flag telling whether a redraw is needed.'''

    trace = False and not g.unitTesting
    c = self ; cc = c.chapterController
    redraw_flag = False

    for p in p.parents_iter():
        if not p.isExpanded():
            p.expand()
            redraw_flag = True

    if trace: g.trace(redraw_flag,repr(p and p.h),g.callers())
    return redraw_flag
</t>
<t tx="ekr.20090401102247.78">def redraw_after_select(self,p):

    '''Redraw the screen after node p has been selected.'''

    trace = False and not g.unitTesting
    if trace: g.trace('(Commands)',p and p.h or '&lt;No p&gt;', g.callers(4))

    c = self

    flag = c.expandAllAncestors(p)
    if flag:
        c.frame.tree.redraw_after_select(p)
</t>
<t tx="ekr.20090401102247.79"></t>
<t tx="ekr.20090401102247.80">def runTest (self,define_g = True):

    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    # print ('p',p,'len(script)',len(script))
    self.assert_(script)
    writeScriptFile = c.config.getBool('write_script_file')

    # import leo.core.leoGlobals as g

    # New in Leo 4.4.3: always define the entries in g.app.unitTestDict.
    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    if define_g:
        d = {'c':c,'g':g,'p':p,'self':self,}
    else:
        d = {'self':self,}

    script = script + '\n'
    # g.trace(type(script),script)

    # Execute the script. Let unit test handle any errors!

    if writeScriptFile:
        scriptFile = c.writeScriptFile(script)
        execfile(scriptFile,d)
    else:
        exec(script,d)

    # if 0: # debug
        # import pdb
        # pdb.run(script+'\n',d)
    # else:
        # exec script + '\n' in d
</t>
<t tx="ekr.20090401102247.81">class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others
</t>
<t tx="ekr.20090401102247.82">def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
</t>
<t tx="ekr.20090401102247.83">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
</t>
<t tx="ekr.20090401102247.84">def tearDown (self):

    pass

    # Restore the outline.
    self.c.outerUpdate()</t>
<t tx="ekr.20090401102247.85">def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p)
</t>
<t tx="ekr.20090401102247.86">def shortDescription (self):

    s = self.p.h

    # g.trace(s)

    return s + '\n'
</t>
<t tx="ekr.20090401102247.87">@nocolor

https://bugs.launchpad.net/leo-editor/+bug/306213

To reproduce (in the latest bzr version, qt-plugin enabled):

create a node "@thin a_directory/a_file" where a_file has some text in it but no sentinels/leo-specific data.

Select File-&gt; read/write -&gt; check derived file. The log window shows:

Bad @+leo sentinel in: check-derived-file
can not open: '@file /home/user/a_directory/check-derived-file'

Clearly the file is not named 'check-derived-file', so there is a bug somewhere.

@color</t>
<t tx="ekr.20090401102247.88">def checkDerivedFile (self, event=None):

    at = self ; c = at.c ; p = c.p

    if not p.isAtFileNode() and not p.isAtThinFileNode():
        return g.es('Please select an @thin or @file node',color='red')

    fn = p.anyAtFileNodeName()
    path = g.os_path_dirname(c.mFileName)
    fn = g.os_path_finalize_join(g.app.loadDir,path,fn)
    if not g.os_path_exists(fn):
        return g.es_print('file not found: %s' % (fn),color='red')

    try:
        s = open(fn,'r').read()
    except IOError:
        return g.es_print('can not open %s' % (fn),color='red')

    # Create a dummy, unconnected, vnode as the root.
    root_v = leoNodes.vnode(context=c)
    root = leoNodes.position(root_v)
    theFile = g.fileLikeObject(fromString=s)
    thinFile = at.scanHeaderForThin (theFile,fn)
    at.initReadIvars(root,fn,thinFile=thinFile)
    if at.errors: return
    at.openFileForReading(fn,fromString=s)
    if not at.inputFile: return
    at.readOpenFile(root,at.inputFile,fn)
    at.inputFile.close()
    if at.errors == 0:
        g.es_print('check-derived-file passed',color='blue')
</t>
<t tx="ekr.20090401102247.89">def scanHeaderForThin (self,theFile,fileName):

    '''Scan the header of a derived file and return True if it is a thin file.

    N.B. We are not interested in @first lines, so any encoding will do.'''

    at = self

    # The encoding doesn't matter.  No error messages are given.
    at.encoding = at.c.config.default_derived_file_encoding

    junk,junk,isThin = at.scanHeader(theFile,fileName)

    return isThin
</t>
<t tx="ekr.20090401102247.90">def scanHeader(self,theFile,fileName):

    """Scan the @+leo sentinel.

    Sets self.encoding, and self.start/endSentinelComment.

    Returns (firstLines,new_df,isThinDerivedFile) where:
    firstLines        contains all @first lines,
    new_df            is True if we are reading a new-format derived file.
    isThinDerivedFile is True if the file is an @thin file."""

    trace = False
    at = self
    firstLines = [] # The lines before @+leo.
    tag = "@+leo"
    valid = True ; new_df = False ; isThinDerivedFile = False
    &lt;&lt; skip any non @+leo lines &gt;&gt;
    if valid:
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
        # g.trace('start',repr(start),'end',repr(end))
    else:
        at.error("No @+leo sentinel in: %s" % fileName)
    # g.trace("start,end",repr(at.startSentinelComment),repr(at.endSentinelComment))
    return firstLines,new_df,isThinDerivedFile
</t>
<t tx="ekr.20090401102247.91">@ Queue up the lines before the @+leo.

These will be used to add as parameters to the @first directives, if any.
Empty lines are ignored (because empty @first directives are ignored).
NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on
the comment delimiters we set here.

at-first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(theFile)
if trace: g.trace('first line',repr(s))
while len(s) &gt; 0:
    j = s.find(tag)
    if j != -1: break
    firstLines.append(s) # Queue the line
    s = at.readLine(theFile)

n = len(s)
valid = n &gt; 0
</t>
<t tx="ekr.20090401102247.92"></t>
<t tx="ekr.20090401102247.93">@ This contains investigations which revealed no bug at present.</t>
<t tx="ekr.20090401102247.94">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/d38704eb27eb9340

I find that
@settings
  @string debugger_path = /usr/bin/winpdb

sets the config string successfully if in
home/.leo/myLeoSettings.leo
not if in
cwd/myLeoSettings.leo

============

This works as expected, provided that by 'cwd' you mean the directory from which the .leo file was loaded.

</t>
<t tx="ekr.20090401102247.95">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/5c6653927911de0d#

Code--&gt;Core classes--&gt;@thin runLeo.py --&gt;utils--&gt;createFrame (leo.py)

        c.updateRecentFiles(relativeFileName or fileName)

I don't think relative filenames should be passed to
c.updateRecentFiles()?  They get stuff in the recent file list but
don't work there.

Also appears to happen here:

Code--&gt;Core classes--&gt;@thin leoCommands.py--&gt;class commands--&gt;Command
handlers...--&gt;File Menu--&gt;Recent Files submenu &amp;
allies--&gt;clearRecentFiles

c.updateRecentFiles(c.relativeFileName())

and here

Code--&gt;Core classes--&gt;@thin leoGlobals.py--&gt;Files &amp;
Directories...--&gt;g.openWithFileName

c.updateRecentFiles(relativeFileName or fileName)

The only way I've seen a relative path get into the list is from
command line invocation, so I'm not sure if all these routes are
active, but I think it should be avoided.

Cheers -Terry 


======

c.updateRecentFiles calls g.os_path_finalize/join so only abs paths can be put on the list.

@color</t>
<t tx="ekr.20090401102247.96">def updateRecentFiles (self,fileName):

    """Create the RecentFiles menu.  May be called with Null fileName."""

    c = self

    if g.app.unitTesting: return

    def munge(name):
        return c.os_path_finalize(name or '').lower()
    def munge2(name):
        return c.os_path_finalize_join(g.app.loadDir,name or '')

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if munge(fileName) == munge(name) or munge2(fileName) == munge2(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace('adding',fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
</t>
<t tx="ekr.20090401102247.97"></t>
<t tx="ekr.20090401102247.98">@nocolor

Latest revision from trunk.

To reproduce:

- open a new outline.
- create a @settings node.
- create two children of the @settings node with the following
headlines "@string xxx = aaa" and "@button xxx".
- save the outline and close it.
- reopen the outline.

I'm getting the following traceback:

Traceback (most recent call last):
 File "/home/shadow/leo/leo-current/leo/core/leoGlobals.py", line
2818, in doHook
   return f(tag,keywords)
 File "/home/shadow/leo/leo-current/leo/core/leoPlugins.py", line 97,
in doPlugins
   return doHandlersForTag(tag,keywords)
 File "/home/shadow/leo/leo-current/leo/core/leoPlugins.py", line 76,
in doHandlersForTag
   val = callTagHandler(bunch,tag,keywords)
 File "/home/shadow/leo/leo-current/leo/core/leoPlugins.py", line 55,
in callTagHandler
   result = handler(tag,keywords)
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 197, in onCreate
   sc.createAllButtons()
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 261, in createAllButtons
   self.handleAtButtonNode(p)
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 533, in handleAtButtonNode
   b =
self.createAtButtonHelper(p,h,statusLine,shortcut,verbose=False)
 File "/home/shadow/leo/leo-current/leo/plugins/mod_scripting.py",
line 681, in createAtButtonHelper
   pane='button',verbose=verbose)
 File "/home/shadow/leo/leo-current/leo/core/leoKeys.py", line 3161,
in registerCommand
   junk,bunchList = c.config.getShortcut(commandName)
 File "/home/shadow/leo/leo-current/leo/core/leoCommands.py", line
7271, in getShortcut
   return g.app.config.getShortcut(self.c,shortcutName)
 File "/home/shadow/leo/leo-current/leo/core/leoConfig.py", line
1682, in getShortcut
   if bunch.val and bunch.val.lower() != 'none']
AttributeError: 'unicode' object has no attribute 'val'

@color</t>
<t tx="ekr.20090401102247.99">def typesMatch (self,type1,type2):

    '''
    Return True if type1, the actual type, matches type2, the requeseted type.

    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything *except* shortcuts.
    - Shortcut matches shortcuts.
    '''

    shortcuts = ('shortcut','shortcuts',)

    return (
        type1 == None or type2 == None or
        type1.startswith('string') and type2 not in shortcuts or
        type1 == 'int' and type2 == 'size' or
        (type1 in shortcuts and type2 in shortcuts) or
        type1 == type2
    )
</t>
<t tx="ekr.20090401102247.100">http://groups.google.com/group/leo-editor/browse_thread/thread/5f5219fedd977ec2

@nocolor

I recently discovered leo and decided to give it a try. I'm using the
rst3 plugin for generating latex docs. In general it works like a
charm, but I'm having some problems with the text encoding. The most
annoying one follows. If in my rst tree I've nodes with the character

ŀ (U+0140)

(or other character from the catalan alphabet) in the body text, I get
conversion errors in the log pane when the Write-Restructured-Text
command is executed. For instance, a node with the following body text

Nuŀla

causes the following error in the log pane:

1 errors converting Nu?la.

 to iso-8859-1

If I process the generated .tex file via pdflatex the character is
displayed as a ? symbol in the pdf.

The rst-options are:

@ @rst-options
default_path=latex
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
write_intermediate_file = False
verbose=True
publish_argv_for_missing_stylesheets=--language=ca,--output-
encoding=utf-8,--stylesheet=/home/vmas/.leo/custom_style.sty
@c

If, instead of using leo, I put the problematic text content in a
plain rst file and process it via rst2latex I get no conversion
errors. The command line is:

rst2latex --language=ca --output-encoding=utf-8 --stylesheet=/home/
vmas/.leo/custom_style.sty prova.txt prova.tex </t>
<t tx="ekr.20090401102247.101"></t>
<t tx="ekr.20090401102247.102">
def scanAtPathDirectives(self,aList,force=False):

    '''Scan aList for @path directives.'''

    c = self ; trace = False ; verbose = True

    # Step 1: Compute the starting path.
    # The correct fallback directory is the absolute path to the base.
    if c.openDirectory:  # Bug fix: 2008/9/18
        base = c.openDirectory
    else:
        base = g.app.config.relative_path_base_directory
        if base and base == "!":    base = g.app.loadDir
        elif base and base == ".":  base = c.openDirectory

    if trace and verbose: g.trace('base',base,'loadDir',g.app.loadDir)

    absbase = c.os_path_finalize_join(g.app.loadDir,base)

    if trace and verbose: g.trace('absbase',absbase)

    # Step 2: look for @path directives.
    paths = [] ; fileName = None
    for d in aList:
        # Look for @path directives.
        path = d.get('path')
        if path:
            # Convert "path" or &lt;path&gt; to path.
            path = g.computeRelativePath(path)
            if path: paths.append(path)

    # Add absbase and reverse the list.
    paths.append(absbase)
    paths.reverse()

    if trace and verbose: g.trace('paths',paths)

    # Step 3: Compute the full, effective, absolute path.
    if trace and verbose: g.printList(paths,tag='c.scanAtPathDirectives: raw paths')
    path = c.os_path_finalize_join(*paths)
    if trace and verbose: g.trace('joined path:',path)

    # Step 4: Make the path if necessary.
    if path and not g.os_path_exists(path):
        ok = g.makeAllNonExistentDirectories(path,c=c,force=force)
        if not ok:
            if force:
                g.es_print('c.scanAtPathDirectives: invalid @path: %s' % (path),color='red')
            path = absbase # Bug fix: 2008/9/18

    if trace: g.trace('returns',path)

    return path
</t>
<t tx="ekr.20090401102247.103"></t>
<t tx="ekr.20090401102247.104">def scanAllDirectives(self,p=None):

    '''Scan p and ancestors for directives.

    Returns a dict containing the results, including defaults.'''

    c = self ; p = p or c.p

    # Set defaults
    language = c.target_language and c.target_language.lower()
    lang_dict = {
        'language':language,
        'delims':g.set_delims_from_language(language),
    }
    wrap = c.config.getBool("body_pane_wraps")

    table = (
        ('encoding',    None,           g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
        ('wrap',        wrap,           g.scanAtWrapDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process: do *not* set commander ivars.
    lang_dict = d.get('lang-dict')

    return {
        "delims"        : lang_dict.get('delims'),
        "encoding"      : d.get('encoding'),
        "language"      : lang_dict.get('language'),
        "lineending"    : d.get('lineending'),
        "pagewidth"     : d.get('pagewidth'),
        "path"          : d.get('path') or g.getBaseDirectory(c),
        "tabwidth"      : d.get('tabwidth'),
        "pluginsList"   : [], # No longer used.
        "wrap"          : d.get('wrap'),
    }</t>
<t tx="ekr.20090401102247.105"># This is a generalization of os.makedir.

def makeAllNonExistentDirectories (theDir,c=None,force=False,verbose=True):

    """Attempt to make all non-existent directories"""

    # g.trace('theDir',theDir,c.config.create_nonexistent_directories,g.callers())

    if not force:
        if c:
            if not c.config.create_nonexistent_directories:
                return None
        elif not app.config.create_nonexistent_directories:
            return None

    if c:
        theDir = g.os_path_expandExpression(theDir,c=c)

    dir1 = theDir = g.os_path_normpath(theDir)

    # Split theDir into all its component parts.
    paths = []
    while len(theDir) &gt; 0:
        head,tail=g.os_path_split(theDir)
        if len(tail) == 0:
            paths.append(head)
            break
        else:
            paths.append(tail)
            theDir = head
    path = ""
    paths.reverse()
    for s in paths:
        path = g.os_path_join(path,s)
        if not g.os_path_exists(path):
            try:
                os.mkdir(path)
                if verbose and not g.app.unitTesting:
                    # g.trace('***callers***',g.callers(5))
                    g.es_print("created directory:",path,color='red')
            except Exception:
                # g.trace(g.callers())
                if verbose: g.es_print("exception creating directory:",path,color='red')
                g.es_exception()
                return None
    return dir1 # All have been created.
</t>
<t tx="ekr.20090401102247.106">def goToLineNumber (self,n,p=None,scriptData=None):

    '''Place the cursor on the n'th line of a derived file or script.
    When present scriptData is a dict with 'root' and 'lines' keys.'''

    c = self
    delim = None ; gnx = None ; vnodeName = None
    if n &lt; 0: return

    fileName,ignoreSentinels,isRaw,lines,n,root = c.goto_setup(n,p,scriptData)

    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n &gt;= len(lines):
        p = root ; n2 = root.b.count('\n') ; found = False
    elif isRaw:
        p,n2,found = c.goto_countLines(root,n)
    else:
        vnodeName,gnx,n2,delim = c.goto_findVnode(root,lines,n,ignoreSentinels)
        if delim:
            p,found = c.goto_findPosition(
                root,lines,vnodeName,gnx,n,delim)
        else:
            p,found = root,False
    if 0:
        &lt;&lt; trace gotoLineNumber results &gt;&gt;
    c.goto_showResults(found,p or root,n,n2,lines)
</t>
<t tx="ekr.20090401102247.107">g.trace(
    '\n  found',found,'n2',n2,'gnx',gnx,'delim',repr(delim),
    '\n  vnodeName',vnodeName,
    '\n  p        ',p and p.h,
    '\n  root     ',root and root.h)
</t>
<t tx="ekr.20090401102247.108">def goto_applyLineNumberMapping(self, n):

    c = self ; x = c.shadowController

    if len(x.line_mapping) &gt; n:
        return x.line_mapping[n]
    else:
        return n
</t>
<t tx="ekr.20090401102247.109">def goto_countLines (self,root,n):

    '''Scan through root's outline, looking for line n.
    Return (p,n2,found) where p is the found node,
    n2 is the actural line found, and found is True if the line was found.'''

    p = lastv = root
    prev = 0 ; found = False
    isNosent = root.isAtNoSentFileNode()
    isAuto = root.isAtAutoNode()

    for p in p.self_and_subtree_iter():
        lastv = p.copy()
        s = p.b
        if isNosent or isAuto:
            s = ''.join([z for z in g.splitLines(s) if not z.startswith('@')])
        n_lines = s.count('\n')
        if len(s) &gt; 0 and s[-1] != '\n': n_lines += 1
        # g.trace(n,prev,n_lines,p.h)
        if prev + n_lines &gt;= n:
            found = True ; break
        prev += n_lines

    p = lastv
    n2 = max(1,n-prev)

    return p,n2,found
</t>
<t tx="ekr.20090401102247.110">def goto_findPosition(self,root,lines,vnodeName,gnx,n,delim):

    c = self

    # if scriptFind:
        # p,found = c.scanForVnodeName(root,vnodeName

    if gnx:
        p,found = c.goto_findGnx(root,gnx,vnodeName)
    else:
        p,found = c.goto_scanTnodeList(root,delim,lines,n,vnodeName)

    # if not found:
        # g.es("not found:",vnodeName,color="red")

    return p,found
</t>
<t tx="ekr.20090401102247.111">def goto_findGnx (self,root,gnx,vnodeName):

    '''Scan root's tree for a node with the given gnx and vnodeName.

    return (p,found)'''

    gnx = g.app.nodeIndices.scanGnx(gnx,0)

    for p in root.self_and_subtree_iter():
        if p.matchHeadline(vnodeName):
            if p.v.t.fileIndex == gnx:
                return p.copy(),True

    return None,False
</t>
<t tx="ekr.20090401102247.112">def goto_scanTnodeList (self,root,delim,lines,n,vnodeName):

    # This is about the best that can be done without replicating the entire atFile write logic.
    found = False
    ok = hasattr(root.v.t,"tnodeList")

    if ok:
        # Use getattr to keep pylint happy.
        tnodeList = getattr(root.v.t,'tnodeList')
        &lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;
        tnodeIndex = max(0,tnodeIndex)
        &lt;&lt; set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False &gt;&gt;
    else:
        g.es_print("no child index for",root.h,color="red")

    if not ok:
        # Fall back to the old logic.
        &lt;&lt; set p to the first node whose headline matches vnodeName &gt;&gt;

    return p,found
</t>
<t tx="ekr.20090401102247.113">
tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned &gt;= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1
</t>
<t tx="ekr.20090401102247.114">@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex &lt; len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        g.es_print(s, color="red") ; ok = False
    elif p.h.strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.h,vnodeName)
            g.es_print(s, color="red")
        ok = False
else:
    if root is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        g.es_print(s, color = "red")
    ok = False
</t>
<t tx="ekr.20090401102247.115">for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break
</t>
<t tx="ekr.20090401102247.116">def goto_findVnode (self,root,lines,n,ignoreSentinels):

    '''Search the lines of a derived file containing sentinels for a vnode.
    return (vnodeName,gnx,offset,delim):

    vnodeName:  the name found in the previous @+body sentinel.
    gnx:        the gnx of the found node.
    offset:     the offset within the node of the desired line.
    delim:      the comment delim from the @+leo sentinel.
    '''

    c = self ; at = c.atFileCommands
    # g.trace('lines...\n',g.listToString(lines))
    gnx = None
    &lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;
    if not delim:
        g.es('no sentinels in:',root.h)
        return None,None,None,None

    &lt;&lt; scan back to @+node, setting offset,nodeSentinelLine &gt;&gt;
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        g.trace('no @+node!!')
        return root.h,gnx,1,delim

    s = lines[nodeSentinelLine]

    &lt;&lt; set gnx and vnodeName from s &gt;&gt;
    if delim and vnodeName:
        # g.trace('offset',offset)
        return vnodeName,gnx,offset,delim
    else:
        g.es("bad @+node sentinel")
        return None,None,None,None
</t>
<t tx="ekr.20090401102247.117"># Find the @+leo line.
tag = "@+leo"
i = 0 
while i &lt; len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

# Set delim from the @+leo line.
delim = None
if leoLine &lt; len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,thinFile = at.parseLeoSentinel(s)
    # New in Leo 4.5.1: only support 4.x files.
    if valid and newDerivedFile:
        delim = start + '@'
</t>
<t tx="ekr.20090401102247.118">@
Scan backwards from the requested line, looking for an @-body line. When found,
we get the vnode's name from that line and set p to the indicated vnode. This
will fail if vnode names have been changed, and that can't be helped.

We compute the offset of the requested line **within the found node**.
@c

offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1 # Start with the requested line.
while line &gt;= 0:
    progress = line
    s = lines[line]
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        &lt;&lt; handle delim while scanning backward &gt;&gt;
    else:
        # offset += 1 # Assume the line is real.  A dubious assumption.
        line -= 1
    assert line &lt; progress
</t>
<t tx="ekr.20090401102247.119">if line == n:
    g.es("line",str(n),"is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    old_line = line
    line = c.goto_skipToMatchingNodeSentinel(lines,line,delim)
    assert line &lt; old_line
    # g.trace('found',repr(lines[line]))
    nodeSentinelLine = line
    offset = n-line
    break
elif g.match(s,i,"+node"):
    # g.trace('found',repr(lines[line]))
    nodeSentinelLine = line
    offset = n-line
    break
elif g.match(s,i,"&lt;&lt;") or g.match(s,i,"@first"):
    # if not ignoreSentinels:
        # offset += 1 # Count these as a "real" lines.
    line -= 1
else:
    line -= 1
</t>
<t tx="ekr.20090401102247.120">i = 0 ; gnx = None ; vnodeName = None

if thinFile:
    # gnx is lies between the first and second ':':
    i = s.find(':',i)
    if i &gt; 0:
        i += 1
        j = s.find(':',i)
        if j &gt; 0:   gnx = s[i:j]
        else:       i = len(s) # Force an error.
    else:
        i = len(s) # Force an error.

# vnode name is everything following the first or second':'
i = s.find(':',i)
if i &gt; -1:
    vnodeName = s[i+1:].strip()
else:
    vnodeName = None
    g.es_print("bad @+node sentinel",color='red')
</t>
<t tx="ekr.20090401102247.121">def goto_setup (self,n,p=None,scriptData=None):

    '''Return (fileName,isRaw,lines,n,p,root) where:

    fileName is the name of the nearest @file node, or None.
    isRaw is True if there are no sentinels in the file.
    lines are the lines to be scanned.
    n is the effective line number (munged for @shadow nodes).
    root is the nearest @file node, or c.currentPosition.'''

    c = self

    if scriptData:
        assert p is None
        lines = scriptData.get('lines')
        p = scriptData.get('p')
        root,fileName = c.goto_findRoot(p)
    else:
        # p is for unit testing only!
        if not p: p = c.p
        root,fileName = c.goto_findRoot(p)
        if root and fileName:
            c.shadowController.line_mapping = [] # Set by goto_open.
            lines = c.goto_getFileLines(root,fileName)
            n = c.goto_applyLineNumberMapping(n)
        else:
            lines = c.goto_getScriptLines(p)

    isRaw = not root or (
        root.isAtAsisFileNode() or root.isAtNoSentFileNode() or root.isAtAutoNode())

    ignoreSentinels = root and root.isAtNoSentFileNode()

    if scriptData:
        if not root: root = p.copy()
    else:
        if not root: root = c.p

    return fileName,ignoreSentinels,isRaw,lines,n,root
</t>
<t tx="ekr.20090401102247.122">def goto_findRoot (self,p):

    '''Find the closest ancestor @file node, of any type, except @all nodes.

    return root, fileName.'''

    c = self ; p1 = p.copy()

    # First look for ancestor @file node.
    for p in p.self_and_parents_iter():
        fileName = not p.isAtAllNode() and p.anyAtFileNodeName()
        if fileName:
            return p.copy(),fileName

    # Search the entire tree for joined nodes.
    # Bug fix: Leo 4.5.1: *must* search *all* positions.
    for p in c.all_positions_iter():
        # if p.v.t == p1.v.t: g.trace('p1',p1,'p',p)
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p2 in p.self_and_parents_iter():
                fileName = not p2.isAtAllNode() and p2.anyAtFileNodeName()
                if fileName:
                    return p2.copy(),fileName

    return None,None
</t>
<t tx="ekr.20090401102247.123">def goto_getFileLines (self,root,fileName):

    '''Read the file into lines.'''

    c = self

    if root.isAtNoSentFileNode():
        # Write a virtual file containing sentinels.
        at = c.atFileCommands
        at.write(root,nosentinels=False,toString=True)
        lines = g.splitLines(at.stringOutput)
    else:
        # Calculate the full path.
        d = g.scanDirectives(c,p=root)
        path = d.get("path")
        # g.trace('path',path,'fileName',fileName)
        fileName = c.os_path_finalize_join(path,fileName)
        lines    = c.goto_open(fileName)

    return lines
</t>
<t tx="ekr.20090401102247.124">def goto_getScriptLines (self,p):

    c = self

    if not g.unitTesting:
        g.es("no ancestor @file node: using script line numbers", color="blue")

    lines = g.getScript (c,p,useSelectedText=False)
    lines = g.splitLines(lines)

    return lines
</t>
<t tx="ekr.20090401102247.125">def goto_open (self,filename):
    """
    Open a file for "goto linenumber" command and check if a shadow file exists.
    Construct a line mapping. This ivar is empty i no shadow file exists.
    Otherwise it contains a mapping shadow file number -&gt; real file number.
    """

    c = self ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        if os.path.exists(shadow_filename):
            fn = shadow_filename
            lines = open(shadow_filename).readlines()
            x.line_mapping = x.push_filter_mapping(
                lines, x.marker_from_extension(shadow_filename))
        else:
            # Just open the original file.  This is not an error!
            fn = filename
            c.line_mapping = []
            lines = open(filename).readlines()
    except Exception:
        # Make sure failures to open a file generate clear messages.
        g.es_print('can not open',fn,color='blue')
        # g.es_exception()
        lines = []

    return lines
</t>
<t tx="ekr.20090401102247.126">def goto_showResults(self,found,p,n,n2,lines):

    c = self ; w = c.frame.body.bodyCtrl

    # Select p and make it visible.
    c.redraw(p)

    # Put the cursor on line n2 of the body text.
    s = w.getAllText()
    if found:
        ins = g.convertRowColToPythonIndex(s,n2-1,0)    
    else:
        ins = len(s)
        if len(lines) &lt; n and not g.unitTesting:
            g.es('only',len(lines),'lines',color="blue")

    # g.trace(p.h,g.callers())

    w.setInsertPoint(ins)
    c.bodyWantsFocusNow()
    w.seeInsertPoint()</t>
<t tx="ekr.20090401102247.127">def goto_skipToMatchingNodeSentinel (self,lines,n,delim):

    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 &lt;= n &lt; len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta

    # g.trace(n)
    return n
</t>
<t tx="ekr.20090401102247.128"># It's time.</t>
<t tx="ekr.20090401102247.129"># Calls g.makeAllNonExistentDirectories instead of os.mkdir.</t>
<t tx="ekr.20090401102247.130">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/414137b93c7e4b90

I receive the following traceback, when I try to create an HTML-
File from a @rst-Node.

&lt;Traceback&gt;

Leo Log Window...
Leo 4.5.1 final, build  1.244 , September 14, 2008
python 2.5.2, Tk 8.4.12, Pmw 1.3
Windows 5, 1, 2600, 2, Service Pack 3

Can not load c:\aspell\bin\aspell-15.dll
leoID=vr20080824 (in C:\Dokumente und Einstellungen\VR\.leo)
load dir: C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\core
global config dir: C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo
\config
home dir: C:\Dokumente und Einstellungen\VR
reading settings in C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo
\config\leoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\.leo
\myLeoSettings.leo
reading settings in C:\Dokumente und Einstellungen\VR\Eigene Dateien
\Tools\Leo\Leo-20080921.leo
rewriting empty .leo file: C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Tools\Leo\Leo-20080921.leo
reading: C:\Dokumente und Einstellungen\VR\Eigene Dateien\Tools\Leo
\Leo-20080921.leo
saved: Leo-20080921.leo
SilverCity not present so no syntax highlighting
exception executing command
Traceback (most recent call last):
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\core
\leoCommands.py", line 309, in doCommand
    val = command(event)
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\core
\leoCommands.py", line 482, in minibufferCallback
    retval = function(keywords)
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\plugins
\rst3.py", line 675, in rst3PluginCallback
    self.processTopTree(c.currentPosition())
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\plugins
\rst3.py", line 1152, in processTopTree

self.processTree(p,ext=None,toString=False,justOneFile=justOneFile)
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\plugins
\rst3.py", line 1184, in processTree
    ok =
self.writeSpecialTree(p,toString=toString,justOneFile=justOneFile)
  File "C:\Python25\Lib\site-packages\Leo-4-5-1-2-final\leo\plugins
\rst3.py", line 1222, in writeSpecialTree
    os.mkdir(dir)
WindowsError: [Error 3] Das System kann den angegebenen Pfad nicht
finden: u'C:\\Python25\\Lib\\site-packages\\Leo-4-5-1-2-final\\2008\
\09'

&lt;/Traceback&gt;

The related outline can be reduced to:

Worklog--&gt;2008--&gt;09--&gt;@rst WLE-2008-09-21.html

The content of the right-most node is:

@ @rst-options
default_path=./2008/09
@c
======================
Worklog for 2008-09-21
======================

Kind regards,

Viktor </t>
<t tx="ekr.20090401102247.131">@
There were two separate bugs:

1. The eol_span and eol_span_regex now honor the mode's escape character.

2. colorRangeWithTag now colors delegates with the default tag color.

Happily, no changes were required in the modes/c.py or modes/c.xml.</t>
<t tx="ekr.20090401102247.132">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/707a910f975f3715

Coloring of macro definitions is not extended after '\'.

More than that - refer again to the screenshot and look at the
comments and #defines at the bottom. The comments after the multi-line
macro are either not coloured or are coloured incorrectly. At the top,
the '#define ADDPRIM_CO' macro is only partially coloured. The macros
below the multi-line macro are incorrectly comment-coloured.

@color</t>
<t tx="ekr.20090401102247.133"></t>
<t tx="ekr.20090401102247.134">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/74c6ab4809bde980

I've noticed a strange behaviour of the "@language cplusplus" mode
using doxygen style comments.
I wrote this code doxygen java-like commenting style:

/**
 * first comment
 */

/**
 * second comment
 */

now I've the string "first comment" highlited as code and the string
"second comment" highlithed as comment.
Qt-style doxygen comments have the same behaviour and if I don't use
doxygen comments it's all ok.
I'm using leo 4.5.1 final on Windows XP.
It's a bug or I haven't understood something?

@color</t>
<t tx="ekr.20090401102247.135">@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

    if i &gt;= len(s): return len(s) # Bug fix: 2007/5/22
    if i &lt; 0: i = 0
    i = s.find('\n',i)
    if i == -1: return len(s)
    else: return i + 1

def skip_to_end_of_line (s,i):

    if i &gt;= len(s): return len(s) # Bug fix: 2007/5/22
    if i &lt; 0: i = 0
    i = s.find('\n',i)
    if i == -1: return len(s)
    else: return i

def skip_to_start_of_line (s,i):

    if i &gt;= len(s): return len(s)
    if i &lt;= 0:      return 0
    i = s.rfind('\n',0,i) # Don't find s[i], so it doesn't matter if s[i] is a newline.
    if i == -1: return 0
    else:       return i + 1
</t>
<t tx="ekr.20090401102247.136">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/6f744c2a5819e3

I was browsing the source code and I've incidentally found that the
tests for p.textOffset() are not in the trunk. Perhaps they were lost
during a merge.

Relevant pointers:

------------------------------------------------------------
revno: 903
committer: Edward K. Ream &lt;edream...@gmail.com&gt;
branch nick: trunk
timestamp: Mon 2008-08-25 11:14:15 -0500
message:
  commit after merge
    ------------------------------------------------------------
    revno: 899.1.3
    committer: zpcspm zpc...@gmail.com
    branch nick: leo-fcol
    timestamp: Mon 2008-08-25 17:53:37 +0300
    message:
      commit after merge

The following command shows that the tests disappeared here.

$ bzr diff leo/test/unitTest.leo -r 899.1.3..903 </t>
<t tx="ekr.20090401102247.137"></t>
<t tx="ekr.20090401102247.138">def getFileName (fileName,script):

    '''Return the filename from sys.argv.'''

    if g.isPython3:
        ### Testing only.
        fileName = r'c:\leo.repo\trunk\leo\test\test.leo'
        assert g.os_path_exists(fileName)
    elif script:
        fileName = None
    elif fileName:
        pass
    else:
        # Bug fix: 2008/10/1
        if sys.platform.startswith('win'):
            if len(sys.argv) &gt; 1:
                fileName = ' '.join(sys.argv[1:])
            else:
                fileName = None
        else:
            fileName = len(sys.argv) &gt; 1 and sys.argv[-1]

    return completeFileName(fileName)
</t>
<t tx="ekr.20090401102247.139">def completeFileName (fileName):

    if not (fileName and fileName.strip()):
        return None,None

    # This does not depend on config settings.
    try:
        if sys.platform.lower().startswith('win'):
            fileName = g.toUnicode(fileName,'mbcs')
        else:
            fileName = g.toUnicode(fileName,'utf-8')
    except Exception: pass

    relativeFileName = fileName
    fileName = g.os_path_finalize(fileName)

    junk,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"
        relativeFileName = relativeFileName + ".leo"

    return fileName,relativeFileName
</t>
<t tx="ekr.20090401102247.140">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/7d8325d055cbef30

I'm finding

@path project
 \
   @shadow one.py
   @shadow two.py
   @path subdir
     \
       @shadow three.py

I'm finding three.py is considered project/three.py instead of
project/subdir/three.py 

===========

The problem was that leoAtFile/leoImport.scanDefaultDirectory did not support
nested @path directives.

I refactored them so all the common work is done in g.setDefaultDirectory.

@color</t>
<t tx="ekr.20090401102247.141">def createOutline (self,fileName,parent,
    atAuto=False,atShadow=False,s=None,ext=None):

    c = self.c ; u = c.undoer ; s1 = s

    # New in Leo 4.4.7: honor @path directives.

    self.scanDefaultDirectory(parent) # sets .defaultDirectory.
    fileName = c.os_path_finalize_join(self.default_directory,fileName)
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,self.fileType = g.os_path_splitext(self.fileName)
    self.setEncoding(p=parent,atAuto=atAuto)
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    if not ext: ext = self.fileType
    ext = ext.lower()
    if not s:
        &lt;&lt; Read file into s &gt;&gt;

    &lt;&lt; convert s to the proper encoding &gt;&gt;

    # Create the top-level headline.
    if atAuto:
        p = parent.copy()
        p.setBodyString('')
    else:
        undoData = u.beforeInsertNode(parent)
        p = parent.insertAsLastChild()

        if self.treeType == "@file":
            p.initHeadString("@file " + fileName)
        else:
            # @root nodes don't have @root in the headline.
            p.initHeadString(fileName)
        u.afterInsertNode(p,'Import',undoData)

    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    func = self.importDispatchDict.get(ext)
    if func and not c.config.getBool('suppress_import_parsing',default=False):
        func(s,p,atAuto=atAuto)
    else:
        self.scanUnknownFileType(s,p,ext,atAuto=atAuto)

    p.contract()
    return p</t>
<t tx="ekr.20090401102247.142">try:
    fileName = c.os_path_finalize(fileName)
    theFile = open(fileName)
    s = theFile.read()
    theFile.close()
except IOError:
    if atShadow: kind = '@shadow '
    elif atAuto: kind = '@auto '
    else: kind = ''
    # g.trace('c.frame.openDirectory',c.frame.openDirectory)
    g.es("can not open", "%s%s" % (kind,fileName),color='red')
    # g.trace(g.callers())
    leoTest.fail()
    return None
</t>
<t tx="ekr.20090401102247.143">if s and fileName.endswith('.py'):
    # Python's encoding comments override everything else.
    lines = g.splitLines(s)
    tag = '# -*- coding:' ; tag2 = '-*-'
    n1,n2 = len(tag),len(tag2)
    line1 = lines[0].strip()
    if line1.startswith(tag) and line1.endswith(tag2):
        e = line1[n1:-n2].strip()
        if e and g.isValidEncoding(e):
            # g.pr('found',e,'in',line1)
            self.encoding = e

s = g.toUnicode(s,self.encoding)
</t>
<t tx="ekr.20090401102247.144">def scanDefaultDirectory(self,p):

    """Set the default_directory ivar by looking for @path directives."""

    c = self.c

    self.default_directory, error = g.setDefaultDirectory(c,p,importing=False)

    if error: self.error(error)
</t>
<t tx="ekr.20090401102247.145">def scanDefaultDirectory(self,p,importing=False):

    """Set the default_directory ivar by looking for @path directives."""

    at = self ; c = at.c

    at.default_directory,error = g.setDefaultDirectory(c,p,importing)

    if error: at.error(error)
</t>
<t tx="ekr.20090401102247.146">@

This happened at line 36 of leo/test/unittest/perfectImport/formatter.py

It was caused by non-Linux line-endings.

I also fixed a bug that caused the unit test not to fail.</t>
<t tx="ekr.20090401102247.147">def checkTrialWrite (self,s1=None,s2=None):

    '''Return True if a trial write produces the original file.'''

    # s1 and s2 are for unit testing.

    c = self.c ; at = c.atFileCommands

    if s1 is None and s2 is None:
        at.write(self.root,
            nosentinels=True,thinFile=False,
            scriptWrite=False,toString=True)
        s1,s2 = self.file_s, at.stringOutput

    s1 = g.toUnicode(s1,self.encoding)
    s2 = g.toUnicode(s2,self.encoding)

    # Make sure we have a trailing newline in both strings.
    s1 = s1.replace('\r','')
    s2 = s2.replace('\r','')
    if not s1.endswith('\n'): s1 = s1 + '\n'
    if not s2.endswith('\n'): s2 = s2 + '\n'

    if s1 == s2: return True

    lines1 = g.splitLines(s1) ; n1 = len(lines1)
    lines2 = g.splitLines(s2) ; n2 = len(lines2)

    # g.trace('lines1',lines1)
    # g.trace('lines2',lines2)

    ok = True ; bad_i = 0
    for i in range(max(n1,n2)):
        ok = self.compareHelper(lines1,lines2,i,self.strict)
        if not ok:
            bad_i = i + 1
            break

    if g.app.unitTesting:
        d = g.app.unitTestDict
        # g.trace('expected',d.get('expectedMismatchLine'),'actual',d.get('actualMismatchLine'))
        ok = d.get('expectedMismatchLine') == d.get('actualMismatchLine')
        # Unit tests do not generate errors unless the mismatch line does not match.
        if not ok: d['fail'] = g.callers() # 2008/10/3

    if not ok:
        self.reportMismatch(lines1,lines2,bad_i)

    return ok
</t>
<t tx="ekr.20090401102247.148">def compareHelper (self,lines1,lines2,i,strict):

    '''Compare lines1[i] and lines2[i].
    strict is True if leading whitespace is very significant.'''

    def pr(*args,**keys): #compareHelper
        g.es_print(color='blue',*args,**keys)

    def pr_mismatch(i,line1,line2):
        g.es_print('first mismatched line at line',str(i+1))
        g.es_print('original line: ',line1)
        g.es_print('generated line:',line2)

    d = g.app.unitTestDict
    expectedMismatch = g.app.unitTesting and d.get('expectedMismatchLine')
    enableWarning = not self.mismatchWarningGiven and self.atAutoWarnsAboutLeadingWhitespace
    messageKind = None

    if i &gt;= len(lines1):
        if i != expectedMismatch or not g.unitTesting:
            pr('extra lines')
            for line in lines2[i:]:
                pr(repr(line))
        d ['actualMismatchLine'] = i
        return False

    if i &gt;= len(lines2):
        if i != expectedMismatch or not g.unitTesting:
            g.es_print('missing lines')
            for line in lines2[i:]:
                g.es_print('',repr(line))
        d ['actualMismatchLine'] = i
        return False

    line1,line2 = lines1[i],lines2[i]

    if line1 == line2:
        return True # An exact match.
    elif not line1.strip() and not line2.strip():
        return True # Blank lines compare equal.
    elif strict:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(
            s1 == s2 and self.startsComment(s1,0) and self.startsComment(s2,0),
            'comment','error')
    else:
        s1,s2 = line1.lstrip(),line2.lstrip()
        messageKind = g.choose(s1==s2,'warning','error')

    if g.unitTesting:
        d ['actualMismatchLine'] = i+1
        ok = i+1 == expectedMismatch
        if not ok:  pr_mismatch(i,line1,line2)
        return ok
    elif strict:
        if enableWarning:
            self.mismatchWarningGiven = True
            if messageKind == 'comment':
                self.warning('mismatch in leading whitespace before comment')
            else:
                self.error('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind == 'comment' # Only mismatched comment lines are valid.
    else:
        if enableWarning:
            self.mismatchWarningGiven = True
            self.checkLeadingWhitespace(line1)
            self.warning('mismatch in leading whitespace')
            pr_mismatch(i,line1,line2)
        return messageKind in ('comment','warning') # Only errors are invalid.</t>
<t tx="ekr.20090401102247.149">def reportMismatch (self,lines1,lines2,bad_i):

    def pr(*args,**keys): # reportMismatch
        g.es_print(color='blue',*args,**keys)

    kind = g.choose(self.atAuto,'@auto','import command')

    self.error(
        '%s did not import %s perfectly\nfirst mismatched line: %d\n%s' % (
            kind,self.root.h,bad_i,repr(lines2[bad_i-1])))

    if len(lines1) &lt; 100:
        pr('input...')
        for i in range(len(lines1)):
            pr('%3d %s' % (i,lines1[i]),newline=False)
        pr('output...')
        for i in range(len(lines2)):
            pr('%3d %s' % (i,lines2[i]),newline=False)

    return False
</t>
<t tx="ekr.20090401102247.150"></t>
<t tx="ekr.20090401102247.151">def makeImportExportSuite(c,parentHeadline,doImport):

    """Create an Import/Export test for every descendant of testParentHeadline.."""

    u = testUtils(c)
    parent = u.findNodeAnywhere(parentHeadline)
    assert(parent)
    temp = u.findNodeInTree(parent,"tempNode")
    assert(temp)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)

    for p in parent.children_iter(copy=True):
        if p == temp: continue
        dialog = u.findNodeInTree(p,"dialog")
        assert(dialog)
        test = importExportTestCase(c,p,dialog,temp,doImport)
        suite.addTest(test)

    return suite
</t>
<t tx="ekr.20090401102247.152">class importExportTestCase(unittest.TestCase):

    """Data-driven unit tests for Leo's edit body commands."""

    @others
</t>
<t tx="ekr.20090401102247.153">def __init__ (self,c,p,dialog,temp_p,doImport):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.dialog = dialog
    self.p = p.copy()
    self.temp_p = temp_p.copy()

    self.gui = None
    self.oldGui = None
    self.wasChanged = c.changed
    self.fileName = ""
    self.doImport = doImport

    self.old_p = c.p
</t>
<t tx="ekr.20090401102247.154">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    import leo.core.leoGlobals as g

    g.app.unitTestDict["fail"] = g.callers()
</t>
<t tx="ekr.20090401102247.155">def importExport (self):

    c = self.c ; p = self.p

    g.app.unitTestDict = {'c':c,'g':g,'p':p and p.copy()}

    commandName = p.h
    command = getattr(c,commandName) # Will fail if command does not exist.
    command(event=None)

    failedMethod = g.app.unitTestDict.get("fail")
    self.failIf(failedMethod,failedMethod)
</t>
<t tx="ekr.20090401102247.156">def runTest(self):

    # """Import Export Test Case"""

    self.importExport()
</t>
<t tx="ekr.20090401102247.157">def setUp(self):

    c = self.c ; temp_p = self.temp_p ; d = self.dialog

    temp_p.setBodyString('',g.app.tkEncoding)

    # Create a node under temp_p.
    child = temp_p.insertAsLastChild()
    assert(child)
    c.setHeadString(child,"import test: " + self.p.h)
    c.selectPosition(child)

    assert(d)
    s = d.bodyString()
    lines = s.split('\n')
    name = lines[0]
    fileName = lines[1]

    # Replace '\\' by os.path.sep in fileName
    try:
        # os.path.sep does not exist in Python 2.2.x.
        sep = os.path.sep
        fileName = fileName.replace('\\',sep)
    except AttributeError:
        fileName = g.os_path_normpath(fileName)

    self.fileName = fileName = g.os_path_finalize_join(g.app.loadDir,"..",fileName)

    if self.doImport:
        theDict = {name: [fileName]}
    else:
        theDict = {name: fileName}

    self.oldGui = g.app.gui
    self.gui = leoGui.unitTestGui(theDict,trace=False)
</t>
<t tx="ekr.20090401102247.158">def shortDescription (self):

    try:
        return "ImportExportTestCase: %s %s" % (self.p.h,self.fileName)
    except Exception:
        return "ImportExportTestCase"
</t>
<t tx="ekr.20090401102247.159">def tearDown (self):

    c = self.c ; temp_p = self.temp_p

    if self.gui:
        self.gui.destroySelf()
        self.gui = None

    temp_p.setBodyString("",g.app.tkEncoding)
    temp_p.clearDirty()

    if not self.wasChanged:
        c.setChanged (False)

    if 1: # Delete all children of temp node.
        while temp_p.firstChild():
            temp_p.firstChild().doDelete()

    g.app.gui = self.oldGui
    c.selectPosition(self.old_p)
</t>
<t tx="ekr.20090401102247.160">def importAtFile (self,event=None):

    '''Import one or more external files, creating @file trees.'''

    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Lua files", "*.lua"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @file",
        filetypes=types,
        defaultextension=".py",
        multiple=True)
    c.bringToFront()

    if names:
        g.chdir(names[0])
        c.importCommands.importFilesCommand(names,"@file")
</t>
<t tx="ekr.20090401102247.161">def importFilesCommand (self,files=None,treeType=None):
    # Not a command.  It must *not* have an event arg.

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) &lt; 1: return
    self.tab_width = self.getTabWidth() # New in 4.3.
    self.treeType = treeType
    if len(files) == 2:
        &lt;&lt; Create a parent for two files having a common prefix &gt;&gt;
    for fileName in files:
        g.setGlobalOpenDir(fileName)
        v = self.createOutline(fileName,current)
        if v: # createOutline may fail.
            if not g.unitTesting:
                g.es("imported",fileName,color="blue")
            v.contract()
            v.setDirty()
            c.setChanged(True)
    c.validateOutline()
    current.expand()
    c.redraw(current)
</t>
<t tx="ekr.20090401102247.162">@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) &gt; 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    # junk, nameExt = g.os_path_split(prefix1)
    name,junk = g.os_path_splitext(prefix1)
    current.initHeadString(name)
</t>
<t tx="ekr.20090401102247.163">The code should save/restore, just as in the clean_file function (from scripts.leo)</t>
<t tx="ekr.20090401102247.164"># This is the entry point to the write code.  root should be an @file vnode.

def write (self,root,
    nosentinels = False,
    thinFile = False,
    scriptWrite = False,
    toString = False,
):

    """Write a 4.x derived file."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    # g.trace(root.h)

    if hasattr(root.v.t,'tnodeList'):# 2008/10/3
        has_list,old_list = True,root.v.t.tnodeList[:]
    else:
        has_list,old_list = False,[]

    &lt;&lt; set at.targetFileName &gt;&gt;
    at.initWriteIvars(root,at.targetFileName,
        nosentinels = nosentinels, thinFile = thinFile,
        scriptWrite = scriptWrite, toString = toString)

    if nosentinels and not scriptWrite and not toString:
        fileName = c.os_path_finalize_join(at.default_directory,at.targetFileName)
        # g.trace('fileName',fileName,'at.targetFileName',at.targetFileName)
        exists = g.os_path_exists(fileName)
        if not self.shouldWriteAtNosentNode(root,exists):
            return

    if not at.openFileForWriting(root,at.targetFileName,toString):
        # openFileForWriting calls root.setDirty() if there are errors.
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile() # sets self.stringOutput
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.closeWriteFile()
            if at.errors &gt; 0 or at.root.isOrphan():
                &lt;&lt; set dirty and orphan bits &gt;&gt;
                g.es("not written:",at.outputFileName)
            else:
                at.replaceTargetFileIfDifferent(root)
                    # Sets/clears dirty and orphan bits.
            if has_list: root.v.t.tnodeList = old_list # 2008/10/3
    except Exception:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
            at.root.v.t._p_changed = True
        else:
            at.writeException() # Sets dirty and orphan bits.
            if has_list: root.v.t.tnodeList = old_list # 2008/10/3
</t>
<t tx="ekr.20090401102247.165">if toString:
    at.targetFileName = "&lt;string-file&gt;"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
</t>
<t tx="ekr.20090401102247.166"># Setting the orphan and dirty flags tells Leo to write the tree..
root.setOrphan()
root.setDirty()
# Delete the temp file.
self.remove(at.outputFileName) 

</t>
<t tx="ekr.20090401102247.167">@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.That ' s too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the.leo file is opened.
- We don ' t want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtNosentNode (self,p,exists):

    '''Return True if we should write the @auto node at p.'''

    if not exists: # We can write a non-existent file without danger.
        return True
    elif self.isSignificantTree(p):
        return True # Assume the tree contains what should be written.
    else:
        g.es_print(p.h,'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='blue')
        return False
</t>
<t tx="ekr.20090401102247.168">def clean_file(p):

    at = c.atFileCommands

    if hasattr(p.v.t,'tnodeList'):
        has_list = True
        old_list =  p.v.t.tnodeList[:]
    else:
        has_list = False

    at.write(
        root=p,nosentinels=True,
        thinFile=False,
        scriptWrite=True,
        toString=True,
        write_strips_blank_lines=False)

    if has_list:
        p.v.t.tnodeList = old_list

    fileName = g.os_path_normpath(g.os_path_join(
        at.default_directory,
        'clean',
        g.os_path_basename(p.anyAtFileNodeName())))

    # g.trace(p.h,len(at.stringOutput),fileName)

    # Adapted from at.openFileForWritingHelper
    path = g.os_path_dirname(fileName)
    if not g.os_path_exists(path):
        g.es('clean directory does not exist',path)
        return

    try:
        f = file(fileName,'w')
        f.write(at.stringOutput)
        f.close()
        g.es_print('wrote',fileName)
    except IOError:
        g.es_print('can not write',fileName,color='red')
        g.es_exception()
</t>
<t tx="ekr.20090401102247.169">@nocolor-node

callTagHandler now checks c.exists when possible.</t>
<t tx="ekr.20090401102247.170">def callTagHandler (bunch,tag,keywords):

    handler = bunch.fn ; moduleName = bunch.moduleName

    # if tag != 'idle': g.pr('callTagHandler',tag,keywords.get('c'))

    # Make sure the new commander exists.
    if True: # tag == 'idle':
        for key in ('c','new_c'):
            c = keywords.get(key)
            if c:
                # Make sure c exists and has a frame.
                if not c.exists or not hasattr(c,'frame'):
                    g.pr('skipping tag %s: c does not exists or does not have a frame.' % tag)
                    return None

    # Calls to registerHandler from inside the handler belong to moduleName.
    global loadingModuleNameStack
    loadingModuleNameStack.append(moduleName)
    result = handler(tag,keywords)
    loadingModuleNameStack.pop()
    return result
</t>
<t tx="ekr.20090401102247.171"># The problem was missing calls to initAfterLoad in c.new.</t>
<t tx="ekr.20090401102247.172">def new (self,event=None,gui=None):

    '''Create a new Leo window.'''

    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=None,relativeFileName=None,gui=gui)

    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
    v = leoNodes.vnode(context=c)
    p = leoNodes.position(v)
    v.initHeadString("NewHeadline")
    # New in Leo 4.5: p.moveToRoot would be wrong: the node hasn't been linked yet.
    p._linkAsRoot(oldRoot=None)
    c.setRootVnode(v) # New in Leo 4.4.2.
    c.selectPosition(p)
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.p
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(fileName=None)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    useChapters = c.config.getBool('use_chapters') and c.chapterController
    if useChapters:
        c.chapterController.finishCreate()
        frame.c.setChanged(False)
        # Clear the changed flag set when creating the @chapters node.
    else:
        c.redraw(p)
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    # Force a call to c.outerUpdate.
    # This is needed when we execute this command from a menu.
    c.outerUpdate()
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.frame.initCompleteHint()

    return c # For unit test.</t>
<t tx="ekr.20090401102247.173"></t>
<t tx="ekr.20090401102247.174">def backwardKillWord (self,event):
    '''Kill the previous word.'''
    c = self.c ; e = c.editCommands
    self.beginCommand(undoType='backward-kill-word')
    e.backwardWord(event)
    self.killWordHelper(event,'back')

def killWord (self,event):
    '''Kill the word containing the cursor.'''
    self.beginCommand(undoType='kill-word')
    self.killWordHelper(event,'forward')

def killWordHelper(self,event,direction):
    c = self.c ; e = c.editCommands ; w = e.editWidget(event)
    # self.killWs(event)
    e.extendToWord(event,direction)
    i,j = w.getSelectionRange()
    self.kill(event,i,j,undoType = None)
    c.frame.body.forceFullRecolor()
    self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20090401102247.175">def extendToWord (self,event,direction='forward'):

    '''Select the word at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    if direction == 'forward':
        while i &lt; n and not g.isWordChar(s[i]):
            i += 1
    else:
        while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
            i -= 1

    while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
        i -= 1
    i += 1
    i1 = i

    # Move to the end of the word.
    while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
        i += 1

    w.setSelectionRange(i1,i)</t>
<t tx="ekr.20090401102247.176"></t>
<t tx="ekr.20090401102247.177"></t>
<t tx="ekr.20090401102247.178">def extendHelper (self,w,extend,spot,upOrDown=False):
    '''Handle the details of extending the selection.
    This method is called for all cursor moves.

    extend: Clear the selection unless this is True.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.p
    extend = extend or self.extendMode
    ins = w.getInsertPoint()
    i,j = w.getSelectionRange()
    # g.trace('extend',extend,'ins',ins,'sel=',i,j,'spot=',spot,'moveSpot',self.moveSpot)

    # Reset the move spot if needed.
    if self.moveSpot is None or p.v.t != self.moveSpotNode:
        # g.trace('no spot')
        self.setMoveCol(w,g.choose(extend,ins,spot)) # sets self.moveSpot.
    elif extend:
        if i == j or self.moveSpot not in (i,j):
            # g.trace('spot not in sel')
            self.setMoveCol(w,ins) # sets self.moveSpot.
    else:
        if upOrDown:
            s = w.getAllText()
            i2,j2 = g.getLine(s,spot)
            line = s[i2:j2]
            row,col = g.convertPythonIndexToRowCol(s,spot)
            if True: # was j2 &lt; len(s)-1:
                n = min(self.moveCol,max(0,len(line)-1))
            else:
                n = min(self.moveCol,max(0,len(line))) # A tricky boundary.
            # g.trace('using moveCol',self.moveCol,'line',repr(line),'n',n)
            spot = g.convertRowColToPythonIndex(s,row,n)
        else:  # Plain move forward or back.
            # g.trace('plain forward/back move')
            self.setMoveCol(w,spot) # sets self.moveSpot.

    if extend:
        if spot &lt; self.moveSpot:
            w.setSelectionRange(spot,self.moveSpot,insert=spot)
        else:
            w.setSelectionRange(self.moveSpot,spot,insert=spot)
    else:
        w.setSelectionRange(spot,spot,insert=spot)

    w.seeInsertPoint()
    c.frame.updateStatusLine()</t>
<t tx="ekr.20090401102247.179">def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return
    trace = False

    ins = w.getInsertPoint()
    s = w.getAllText()
    w.seeInsertPoint()

    # Find the start of the next/prev line.
    row,col = g.convertPythonIndexToRowCol(s,ins)
    if trace:
        gui_ins = w.toGuiIndex(ins)
        bbox = w.bbox(gui_ins)
        if bbox:
            x,y,width,height = bbox
            # bbox: x,y,width,height;  dlineinfo: x,y,width,height,offset
            g.trace('gui_ins',gui_ins,'dlineinfo',w.dlineinfo(gui_ins),'bbox',bbox)
            g.trace('ins',ins,'row',row,'col',col,'event.x',event.x,'event.y',event.y)
            g.trace('subtracting line height',w.index('@%s,%s' % (x,y-height)))
            g.trace('adding      line height',w.index('@%s,%s' % (x,y+height)))
    i,j = g.getLine(s,ins)
    if direction == 'down':
        i2,j2 = g.getLine(s,j)
    else:
        i2,j2 = g.getLine(s,i-1)

    # The spot is the start of the line plus the column index.
    n = max(0,j2-i2-1) # The length of the new line.
    col2 = min(col,n)
    spot = i2 + col2
    if trace: g.trace('spot',spot,'n',n,'col',col,'line',repr(s[i2:j2]))

    self.extendHelper(w,extend,spot,upOrDown=True)</t>
<t tx="ekr.20090401102247.180">def moveToHelper (self,event,spot,extend):

    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''

    c = self.c ; k = c.k ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    # Put the request in the proper range.
    if c.widget_name(w).startswith('mini'):
        i,j = k.getEditableTextRange()
        if   spot &lt; i: spot = i
        elif spot &gt; j: spot = j

    self.extendHelper(w,extend,spot,upOrDown=False)</t>
<t tx="ekr.20090401102247.181">def movePastCloseHelper (self,event,extend):

    c = self.c ; w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    ins = w.getInsertPoint()
    # Scan backwards for i,j.
    i = ins
    while i &gt;= 0 and s[i] != '\n':
        if s[i] == '(': break
        i -= 1
    else: return
    j = ins
    while j &gt;= 0 and s[j] != '\n':
        if s[j] == '(': break
        j -= 1
    if i &lt; j: return
    # Scan forward for i2,j2.
    i2 = ins
    while i2 &lt; len(s) and s[i2] != '\n':
        if s[i2] == ')': break
        i2 += 1
    else: return
    j2 = ins
    while j2 &lt; len(s) and s[j2] != '\n':
        if s[j2] == ')': break
        j2 += 1
    if i2 &gt; j2: return

    self.moveToHelper(event,i2+1,extend)
</t>
<t tx="ekr.20090401102247.182">def moveWordHelper (self,event,extend,forward,end=False):

    '''Move the cursor to the next/previous word.
    The cursor is placed at the start of the word unless end=True'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    if forward:
        # Unlike backward-word moves, there are two options...
        if end:
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
        else:
            while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
                i += 1
            while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
                i += 1
    else:
        i -= 1
        while 0 &lt;= i &lt; n and not g.isWordChar(s[i]):
            i -= 1
        while 0 &lt;= i &lt; n and g.isWordChar(s[i]):
            i -= 1
        i += 1

    self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20090401102247.183">def backSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    s = w.getAllText()
    i = w.getInsertPoint()

    while i &gt;= 0:
        if s[i] == '.': break
        i -= 1
    else: return

    j = i-1
    while j &gt;= 0:
        if s[j] == '.':
            j += 1 ; break
        j -= 1
    else: j = 0

    while j &lt; i and s[j].isspace():
        j += 1

    if j &lt; i:
        self.moveToHelper(event,j,extend)
</t>
<t tx="ekr.20090401102247.184">def forwardSentenceHelper (self,event,extend):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)

    s = w.getAllText()
    ins = w.getInsertPoint()
    i = s.find('.',ins) + 1
    i = min(i,len(s))
    self.moveToHelper(event,i,extend)
</t>
<t tx="ekr.20090401102247.185">def forwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return
    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    line = s[i:j]

    if line.strip(): # Skip past the present paragraph.
        self.selectParagraphHelper(w,i)
        i,j = w.getSelectionRange()
        j += 1

    # Skip to the next non-blank line.
    i = j
    while j &lt; len(s):
        i,j = g.getLine(s,j)
        line = s[i:j]
        if line.strip(): break

    w.setInsertPoint(ins) # Restore the original insert point.
    self.moveToHelper(event,i,extend)
</t>
<t tx="ekr.20090401102247.186">def backwardParagraphHelper (self,event,extend):

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    i,j = w.getSelectionRange()
    # A hack for wx gui: set the insertion point to the end of the selection range.
    if g.app.unitTesting:
        w.setInsertPoint(j)
    i,j = g.getLine(s,j)
    line = s[i:j]

    if line.strip():
        # Find the start of the present paragraph.
        while i &gt; 0:
            i,j = g.getLine(s,i-1)
            line = s[i:j]
            if not line.strip(): break

    # Find the end of the previous paragraph.
    while i &gt; 0:
        i,j = g.getLine(s,i-1)
        line = s[i:j]
        if line.strip():
            i = j-1 ; break

    self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20090401102247.187">def setMoveCol (self,w,spot):

    '''Set the column to which an up or down arrow will attempt to move.'''

    c = self.c ; p = c.p

    i,row,col = w.toPythonIndexRowCol(spot)

    self.moveSpot = i
    self.moveCol = col
    self.moveSpotNode = p.v.t
</t>
<t tx="ekr.20090401102247.188">def backToHome (self,event):

    '''Smart home:
    Position the point at the first non-blank character on the line,
    or the start of the line if already at the first-non-blank character,
    or to the start of the next line if already at the start of a line.'''

    w = self.editWidget(event)
    if not w: return

    s = w.getAllText()
    ins = w.getInsertPoint()
    if ins == 0 or not(s): return

    # None of the other cursor move commands are undoable.
    # self.beginCommand(undoType='back-to-home')

    i,j = g.getLine(s,ins)
    if ins == i:
        i,j = g.getLine(s,i-1)
    i1 = i

    while i &lt; j and s[i] in (' \t'):
        i += 1

    if i1 &lt; ins &lt;= i: i = i1

    self.moveToHelper(event,i,extend=False)

    # self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20090401102247.189">def backToIndentation (self,event):

    '''Position the point at the first non-blank character on the line.'''

    w = self.editWidget(event)
    if not w: return

    # None of the other cursor move commands are undoable.
    # self.beginCommand(undoType='back-to-indentation')

    s = w.getAllText()
    ins = w.getInsertPoint()
    i,j = g.getLine(s,ins)
    while i &lt; j and s[i] in (' \t'):
        i += 1

    self.moveToHelper(event,i,extend=False)

    # self.endCommand(changed=True,setLabel=True)
</t>
<t tx="ekr.20090401102247.190">def beginningOfBuffer (self,event):
    '''Move the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=False)

def beginningOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the start of the body text.'''
    self.moveToHelper(event,0,extend=True)

def endOfBuffer (self,event):
    '''Move the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=False)

def endOfBufferExtendSelection (self,event):
    '''Extend the text selection by moving the cursor to the end of the body text.'''
    w = self.editWidget(event)
    s = w.getAllText()
    self.moveToHelper(event,len(s),extend=True)
</t>
<t tx="ekr.20090401102247.191">def backCharacter (self,event):
    '''Move the cursor back one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=False)

def backCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor back one character.'''
    w = self.editWidget(event)
    i = w.getInsertPoint()
    i = max(0,i-1)
    self.moveToHelper(event,i,extend=True)

def forwardCharacter (self,event):
    '''Move the cursor forward one character, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=False)

def forwardCharacterExtendSelection (self,event):
    '''Extend the selection by moving the cursor forward one character.'''
    w = self.editWidget(event)
    s = w.getAllText()
    i = w.getInsertPoint()
    i = min(i+1,len(s))
    self.moveToHelper(event,i,extend=True)
</t>
<t tx="ekr.20090401102247.192">def clearExtendMode (self,event):
    '''Turn off extend mode: cursor movement commands do not extend the selection.'''
    self.extendModeHelper(event,False)

def setExtendMode (self,event):
    '''Turn on extend mode: cursor movement commands do extend the selection.'''
    self.extendModeHelper(event,True)

def toggleExtendMode (self,event):
    '''Toggle extend mode, i.e., toggle whether cursor movement commands extend the selections.'''
    self.extendModeHelper(event,not self.extendMode)

def extendModeHelper (self,event,val):

    c = self.c
    w = self.editWidget(event)
    if not w: return

    self.extendMode = val
    g.es('extend mode',g.choose(val,'on','off'),color='red')
    c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20090401102247.193">def exchangePointMark (self,event):

    '''Exchange the point (insert point) with the mark (the other end of the selected text).'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange(sort=False)
    if i == j: return

    ins = w.getInsertPoint()
    ins = g.choose(ins==i,j,i)
    w.setInsertPoint(ins)
    w.setSelectionRange(i,j,insert=None)
</t>
<t tx="ekr.20090401102247.194">def extendToLine (self,event):

    '''Select the line at the cursor.'''

    c = self.c ; w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i -= 1
    i += 1 ; i1 = i
    while 0 &lt;= i &lt; n and not s[i] == '\n':
        i += 1

    w.setSelectionRange(i1,i)
</t>
<t tx="ekr.20090401102247.195">def extendToSentence (self,event):

    '''Select the line at the cursor.'''

    c = self.c
    w = self.editWidget(event)
    if not w: return

    s = w.getAllText() ; n = len(s)
    i = w.getInsertPoint()

    i2 = 1 + s.find('.',i)
    if i2 == -1: i2 = n
    i1 = 1 + s.rfind('.',0,i2-1)

    w.setSelectionRange(i1,i2)</t>
<t tx="ekr.20090401102247.196">def beginningOfLine (self,event):
    '''Move the cursor to the start of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText() ; ins = w.getInsertPoint()
    i,junk = g.getLine(s,ins)
    if i &gt; 0 and i == ins:
        i,junk = g.getLine(s,i-1)
    self.moveToHelper(event,i,extend=False)

def beginningOfLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the start of the line.'''
    w = self.editWidget(event)
    s = w.getAllText() ; ins = w.getInsertPoint()
    i,junk = g.getLine(s,ins)
    if i &gt; 0 and i == ins:
        i,junk = g.getLine(s,i-1)
    self.moveToHelper(event,i,extend=True)

def endOfLine (self,event): # passed
    '''Move the cursor to the end of the line, extending the selection if in extend mode.'''
    w = self.editWidget(event)
    s = w.getAllText() ; ins = w.getInsertPoint()
    junk,i = g.getLine(s,ins)
    if ins == i-1: junk,i = g.getLine(s,i)
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=False)

def endOfLineExtendSelection (self,event): # passed
    '''Extend the selection by moving the cursor to the end of the line.'''
    w = self.editWidget(event)
    s = w.getAllText() ; ins = w.getInsertPoint()
    junk,i = g.getLine(s,ins)
    if ins == i-1: junk,i = g.getLine(s,i)
    if g.match(s,i-1,'\n'): i -= 1
    self.moveToHelper(event,i,extend=True)

def nextLine (self,event):
    '''Move the cursor down, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'down',extend=False)

def nextLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor down.'''
    self.moveUpOrDownHelper(event,'down',extend=True)

def prevLine (self,event):
    '''Move the cursor up, extending the selection if in extend mode.'''
    self.moveUpOrDownHelper(event,'up',extend=False)

def prevLineExtendSelection (self,event):
    '''Extend the selection by moving the cursor up.'''
    self.moveUpOrDownHelper(event,'up',extend=True)
</t>
<t tx="ekr.20090401102247.197">def movePastClose (self,event):
    '''Move the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=False)

def movePastCloseExtendSelection (self,event):
    '''Extend the selection by moving the cursor past the closing parenthesis.'''
    self.movePastCloseHelper(event,extend=True)
</t>
<t tx="ekr.20090401102247.198">def backwardParagraph (self,event):
    '''Move the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=False)

def backwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous paragraph.'''
    self.backwardParagraphHelper (event,extend=True)

def forwardParagraph (self,event):
    '''Move the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=False)

def forwardParagraphExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next paragraph.'''
    self.forwardParagraphHelper(event,extend=True)
</t>
<t tx="ekr.20090401102247.199">def backSentence (self,event):
    '''Move the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=False)

def backSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous sentence.'''
    self.backSentenceHelper(event,extend=True)

def forwardSentence (self,event):
    '''Move the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=False)

def forwardSentenceExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next sentence.'''
    self.forwardSentenceHelper(event,extend=True)
</t>
<t tx="ekr.20090401102247.200">def backwardWord (self,event):
    '''Move the cursor to the previous word.'''
    self.moveWordHelper(event,extend=False,forward=False)

def backwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the next word.'''
    self.moveWordHelper(event,extend=True,forward=False)

def forwardEndWord (self,event): # New in Leo 4.4.2
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True,end=True)

def forwardEndWordExtendSelection (self,event): # New in Leo 4.4.2
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True,end=True)

def forwardWord (self,event):
    '''Move the cursor to the next word.'''
    self.moveWordHelper(event,extend=False,forward=True)

def forwardWordExtendSelection (self,event):
    '''Extend the selection by moving the cursor to the previous word.'''
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20090401102247.201"></t>
<t tx="ekr.20090401102247.202">def positionExists(self,p,root=None):

    """Return True if a position exists in c's tree"""

    c = self ; p = p.copy()

    # This code must be fast.
    if not root:
        root = c.rootPosition()

    while p:
        if p == root:
            return True
        if p.hasParent():
            old_v = p.v
            i = p._childIndex
            p.moveToParent()
            children = p.v.t.children
            # Major bug fix: 2009/1/2 and 2009/1/5
            if i &gt;= len(children) or children[i] != old_v:
                return False
        else:
            p.moveToBack()

    return False
</t>
<t tx="ekr.20090401102247.203">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self,newNode=None):

    """Deletes position p from the outline."""

    p = self
    p.setDirty() # Mark @file nodes dirty!

    # Adjust newNode._childIndex if newNode is a following sibling of p.
    sib = p.copy()
    while sib.hasNext():
        sib.moveToNext()
        if sib == newNode:
            newNode._childIndex -= 1
            break

    p._unlink()
    p._deleteLinksInTree()
    p.v._computeParentsOfChildren()
    p._parentVnode()._computeParentsOfChildren()
</t>
<t tx="ekr.20090401102247.204"></t>
<t tx="ekr.20090401102247.205"></t>
<t tx="ekr.20090401102247.206">def computeCompletionList (self,verbose=False):

    c = self.c ; w = self.widget
    c.widgetWantsFocus(w)
    s = w.getSelectedText()
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)

    if not common_prefix:
        if verbose or len(self.tabList) &lt; 25 or not self.useTabs:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in sorted(d)]
            self.tabList = aList

    if self.useTabs:
        c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        g.es('','\n'.join(self.tabList),tabName=self.tabName)
</t>
<t tx="ekr.20090401102247.207"># Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace):

    k = self ; c = k.c ; s = k.getLabel() ; tabName = 'Completion'
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)
    c.frame.log.clearTab(tabName)

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.

        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)

        inverseBindingDict = k.computeInverseBindingDict()
        data = [] ; n1 = 20; n2 = 4
        for commandName in k.mb_tabList:
            dataList = inverseBindingDict.get(commandName,[('',''),])
            for z in dataList:
                pane,key = z
                s1 = commandName
                s2 = pane
                s3 = k.prettyPrintKey(key)
                n1 = max(n1,len(s1))
                n2 = max(n2,len(s2))
                data.append((s1,s2,s3),)
        aList = '\n'.join(
            ['%*s %*s %s' % (-(min(20,n1)),s1,n2,s2,s3)
                for s1,s2,s3 in data])
        g.es('',aList,tabName=tabName)
    c.bodyWantsFocus()
</t>
<t tx="ekr.20090401102247.208">@nocolor-node

&gt; The fix is on the trunk at rev 1374.  All unit tests pass, including
&gt; two new unit tests for c.positionExists.  However, this is a major
&gt; bug fix--as described below this change has the potential to cause
&gt; subtle problems. Please take care, and please report any further
&gt; problems immediately.

=== modified file 'leo/core/leoCommands.py'
--- leo/core/leoCommands.py     2008-11-21 16:43:33 +0000
+++ leo/core/leoCommands.py     2009-01-02 12:32:18 +0000
@@ -6928,7 +6928,11 @@
            if p == root:
                return True
            if p.hasParent():
+                v = p.v
                p.moveToParent()
+                # Major bug fix: 2009/1/2
+                if v not in p.v.t.children:
+                    return False
            else:
                p.moveToBack()

to be absolutely correct I think that the index of the position (or is
it the vnode?) in the list of children needs to be the same.  The above
seems to allow for the position to exist, but not in the same, um,
position.  p._childIndex is not checked, in other words.

Of course, if you fix it (which you probably should) I'll have to use
my one positionExists() code for caching positions, as it's better to
find that the position still exists and update the index (i.e. search
self_and_siblings_iter), than to search the whole tree again for a
position containing a particular vnode.</t>
<t tx="ekr.20090401102247.209">http://groups.google.com/group/leo-editor/browse_thread/thread/f27e3514310a5c90</t>
<t tx="ekr.20090401102247.210">def initWriteIvars(self,root,targetFileName,
    atAuto=False,
    atShadow=False,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False,
    forcePythonSentinels=None,
):

    self.initCommonIvars()
    &lt;&lt; init ivars for writing &gt;&gt;

    if forcePythonSentinels is None:
        forcePythonSentinels = scriptWrite

    if root:
        self.scanAllDirectives(root,
            scripting=scriptWrite,
            forcePythonSentinels=forcePythonSentinels)

    # g.trace(forcePythonSentinels,self.startSentinelComment,self.endSentinelComment)

    if forcePythonSentinels:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root

    # Ignore config settings for unit testing.
    if toString and g.app.unitTesting: self.output_newline = '\n'

    # Init all other ivars even if there is an error.
    if not self.errors and self.root:
        self.root.v.t.tnodeList = []
        self.root.v.t._p_changed = True
</t>
<t tx="ekr.20090401102247.211">@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.atAuto = atAuto
self.atShadow = atShadow
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False
self.force_newlines_in_at_nosent_bodies = self.c.config.getBool(
    'force_newlines_in_at_nosent_bodies')

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "&lt;string-file&gt;"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None

    if g.isPython3:
        self.targetFileName = self.outputFileName = ''
    else:
        self.targetFileName = self.outputFileName = unicode('')
</t>
<t tx="ekr.20090401102247.212">def scanAllDirectives(self,p,
    scripting=False,importing=False,
    reading=False,forcePythonSentinels=False,
):

    '''Scan p and p's ancestors looking for directives,
    setting corresponding atFile ivars.'''

    at = self ; c = self.c

    &lt;&lt; set ivars &gt;&gt;

    lang_dict = {'language':at.language,'delims':delims,}

    table = (
        ('encoding',    at.encoding,    g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process.
    lang_dict       = d.get('lang-dict')
    delims          = lang_dict.get('delims')
    lineending      = d.get('lineending')
    if lineending:
        at.explicitLineEnding = True
        at.output_newline = lineending
    else:
        at.output_newline = g.getOutputNewline(c=c) # Init from config settings.

    at.encoding             = d.get('encoding')
    at.language             = lang_dict.get('language')
    at.page_width           = d.get('pagewidth')
    at.default_directory    = d.get('path')
    at.tab_width            = d.get('tabwidth')

    if not importing and not reading:
        # Don't override comment delims when reading!
        &lt;&lt; set comment strings from delims &gt;&gt;

    # For unit testing.
    return {
        "encoding"  : at.encoding,
        "language"  : at.language,
        "lineending": at.output_newline,
        "pagewidth" : at.page_width,
        "path"      : at.default_directory,
        "tabwidth"  : at.tab_width,
    }
</t>
<t tx="ekr.20090401102247.213">self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

# g.trace(c.target_language)

if c.target_language:
    c.target_language = c.target_language.lower()

delims = g.set_delims_from_language(c.target_language)
at.language = c.target_language

at.encoding = c.config.default_derived_file_encoding
at.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
</t>
<t tx="ekr.20090401102247.214">if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
else:
    delim1,delim2,delim3 = delims

# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    if not g.app.unitTesting:
        g.es_print("unknown language: using Python comment delimiters")
        g.es_print("c.target_language:",c.target_language)
        g.es_print('','delim1,delim2,delim3:','',delim1,'',delim2,'',delim3)
    at.startSentinelComment = "#" # This should never happen!
    at.endSentinelComment = ""

# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
</t>
<t tx="ekr.20090401102247.215">def os_path_finalize (self,path,**keys):

    c = self

    keys['c'] = c

    return g.os_path_finalize(path,**keys)

def os_path_finalize_join (self,*args,**keys):

    c = self

    keys['c'] = c

    return g.os_path_finalize_join(*args,**keys)
</t>
<t tx="ekr.20090401102247.216">def os_path_finalize (path,**keys):

    '''
    Expand '~', then return os.path.normpath, os.path.abspath of the path.

    There is no corresponding os.path method'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: path = g.os_path_expandExpression(path,**keys)

    path = g.os_path_expanduser(path,encoding=encoding)
    return os.path.normpath(os.path.abspath(path))

def os_path_finalize_join (*args,**keys):

    '''Do os.path.join(*args), then finalize the result.'''

    c,encoding = keys.get('c'),keys.get('encoding')

    if c: args = [g.os_path_expandExpression(path,**keys)
        for path in args if path]

    return os.path.normpath(os.path.abspath(
        g.os_path_join(*args,**keys))) # Handles expanduser
</t>
<t tx="ekr.20090401102247.217">def os_path_expandExpression (s,**keys):

    '''Expand {{anExpression}} in c's context.'''

    c = keys.get('c')
    if not c:
        g.trace('can not happen: no c',g.callers())
        return s

    i = s.find('{{')
    j = s.find('}}')
    if -1 &lt; i &lt; j:
        exp = s[i+2:j].strip()
        if exp:
            try:
                import os
                import sys
                p = c.p
                d = {'c':c,'g':g,'p':p,'os':os,'sys':sys,}
                val = eval(exp,d)
                s = s[:i] + str(val) + s[j+2:]
            except Exception:
                g.trace(g.callers())
                g.es_exception(full=True, c=c, color='red')

    return s
</t>
<t tx="ekr.20090401102247.218"></t>
<t tx="ekr.20090401102247.219">def os (self,s):

    """Write a string to the output stream.

    All output produced by leoAtFile module goes here."""

    trace = False
    at = self ; tag = self.underindentEscapeString
    f = at.outputFile

    if s and f:
        try:
            if trace: g.trace(repr(s),g.callers(4))
            if s.startswith(tag):
                junk,s = self.parseUnderindentTag(s)
            # Bug fix: this must be done last.
            s = g.toEncodedString(s,at.encoding,reportErrors=True)
            f.write(s)
        except Exception:
            at.exception("exception writing:" + s)
</t>
<t tx="ekr.20090401102247.220">def putIndent(self,n,s=''):

    """Put tabs and spaces corresponding to n spaces,
    assuming that we are at the start of a line.

    Remove extra blanks if the line starts with the underindentEscapeString"""

    # g.trace(repr(s))
    tag = self.underindentEscapeString

    if s.startswith(tag):
        n2,s2 = self.parseUnderindentTag(s)
        if n2 &gt;= n: return
        elif n &gt; 0: n -= n2
        else:       n += n2

    if n != 0:
        w = self.tab_width
        if w &gt; 1:
            q,r = divmod(n,w) 
            self.otabs(q) 
            self.oblanks(r)
        else:
            self.oblanks(n)
</t>
<t tx="ekr.20090401102247.221">def parseUnderindentTag (self,s):

    tag = self.underindentEscapeString
    s2 = s[len(tag):]

    # To be valid, the escape must be followed by at least one digit.
    i = 0
    while i &lt; len(s2) and s2[i].isdigit():
        i += 1

    if i &gt; 0:
        n = int(s2[:i])
        return n,s2[i:]
    else:
        return 0,s
</t>
<t tx="ekr.20090401102247.222"># Both c.redraw and c.redraw_after_select call c.expandAllAncestors.</t>
<t tx="ekr.20090401102247.223"># Sets the focus to p and edits p.

def redrawAndEdit(self,p,selectAll=False,selection=None,keepMinibuffer=False):

    '''Redraw the screen and start editing the headline at position p.'''

    c = self ; k = c.k

    c.redraw(p)

    if p:
        # This should request focus.
        c.frame.tree.editLabel(p,selectAll=selectAll,selection=selection)

        if k and not keepMinibuffer:
            # Setting the input state has no effect on focus.
            if selectAll:
                k.setInputState('insert')
            else:
                k.setDefaultInputState()

            # This *does* affect focus.
            k.showStateAndMode()

    # Update the focus immediately.
    if not keepMinibuffer:
        c.outerUpdate()</t>
<t tx="ekr.20090401102247.224">def redraw (self,p=None,setFocus=False):
    '''Redraw the screen immediately.'''

    c = self
    if not p: p = c.p or c.rootPosition()

    c.expandAllAncestors(p)
    c.frame.tree.redraw(p)
    c.selectPosition(p)

    if setFocus: c.treeFocusHelper()

# Compatibility with old scripts
force_redraw = redraw
redraw_now = redraw
</t>
<t tx="ekr.20090401102247.225">def selectPosition(self,p):

    """Select a new position."""

    c = self ; cc = c.chapterController

    if cc:
        cc.selectChapterForPosition(p)

    # g.trace(p.h,g.callers())

    c.frame.tree.select(p)

    # New in Leo 4.4.2.
    c.setCurrentPosition(p)
        # Do *not* test whether the position exists!
        # We may be in the midst of an undo.

selectVnode = selectPosition
</t>
<t tx="ekr.20090401102247.226">@nocolor-node

It's not possible to remove edit_widget entirely.
The base find code uses it to init and complete the search.

What I did:

- removed c.headlineWantsFocus.  It was only used in the nullGui(!)
- qtTree.edit_label does *not* use remembered widget;
  it computes it, and returns None if not editing!
- Replaced edit_widget by p.setHeadline in several places.</t>
<t tx="ekr.20090401102247.227"></t>
<t tx="ekr.20090401102247.228"></t>
<t tx="ekr.20090401102247.229">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)

h = '@test return ends editing of headline'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
guiName = g.app.gui.guiName()
wName = g.app.gui.widget_name(w)
assert wName.startswith('head'),'w.name:%s' % wName
w.event_generate('&lt;Return&gt;')
c.outerUpdate()
assert w != c.get_focus(),'oops2: focus in headline'</t>
<t tx="ekr.20090401102247.230">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)

k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = '@test editLabel selects entire headline'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
assert w
s = w.getAllText()
selectAll = c.config.getBool('select_all_text_when_editing_headlines')
# g.trace('editLabel selects entire headline',selectAll)
i,j = w.getSelectionRange()
if selectAll:
    assert i == 0 and j == len(s),'oops1: i: %d, j: %d' % (i,j)
else:
    assert i == len(s) and j == len(s),'oops2: i: %d, j: %d' % (i,j)
</t>
<t tx="ekr.20090401102247.231">trace = False ; verbose = False
import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
if trace: print('='*20)
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
g.app.gui.set_focus(c,w)
w2 = g.app.gui.get_focus(c)
if trace: print ('focus 1',w2)
if trace: print ('*** w ***',w)
if 0: # The tkGui.set_focus now does an update to force the focus.
    w2 = g.app.gui.get_focus(c)
    if w != w2:
        print ('*** FAIL ***\nw: %s\nw2: %s' % (w,w2))
    assert w == w2 or hasattr(w,'widget') and w.widget == w2,'w: %s\nw2: %s' % (w,w2)
    if trace: print('focus',w2)
# For the qt gui w is a wrapper and w.widget is the actual widget.

try:
    assert w
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    g.app.gui.set_focus(c,w)
    w2 = g.app.gui.get_focus(c)
    if trace: print ('focus 1',w2)
    w.setSelectionRange('end','end')
    k.manufactureKeyPressForCommandName(w,'paste-text')
    if 0: # Easiest.
        c.endEditing()
    else: # More thorough test.
        w.event_generate('&lt;Return&gt;')
        w.update()
    if 1:
        assert p.h == h + paste,'Expected: %s, got %s' % (
            h + paste,p.h)
finally:
    if trace: print('-'*20)
    if 1:
        c.setHeadString(p,h) # Essential.
        c.redraw(p)</t>
<t tx="ekr.20090401102247.232">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.k

if k.defaultUnboundKeyAction == 'insert':
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = u.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redrawAndEdit(p) # To make the node visible.
    w = c.edit_widget(p)
    # print('guiName',g.app.gui.guiName())
    try:
        assert w, 'oops1'
        wName = g.app.gui.widget_name(w)
        assert wName.startswith('head'),'w.name:%s' % wName
        w.setSelectionRange('end','end')
        w.event_generate('X')
        w.event_generate('Y')
        w.event_generate('Z')
        w.event_generate('&lt;Return&gt;')
        assert p.h == h + 'XYZ',(
            'oops2: expected: %s, got: %s' % (
                h + 'XYZ',p.h))
        if g.app.gui.guiName() != 'nullGui':
            assert c.undoer.undoMenuLabel == 'Undo Typing','oops3: %s' % (
                c.undoer.undoMenuLabel)
        k.manufactureKeyPressForCommandName(w,'undo')
        if g.app.gui.guiName() != 'nullGui':
            assert c.undoer.redoMenuLabel == 'Redo Typing','oops4'
        assert p.h == h,'oops5 got: %s, expected: %s' % (
            p.h,h)
    finally:
        if 1:
            c.setHeadString(p,h) # Essential.
            c.redraw(p)</t>
<t tx="ekr.20090401102247.233">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redrawAndEdit(p) # To make node visible
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    k.manufactureKeyPressForCommandName(w,'paste-text')
    w.event_generate('&lt;Return&gt;')
    assert p.h == h + paste,'oops2 got: %s' % p.h
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h,'oops3 got: %s' % p.h
finally:
    if 1:
        c.setHeadString(p,h) # Essential.
        c.redraw(p)</t>
<t tx="ekr.20090401102247.234">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w, 'Null w'
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('1.1','1.2')
    k.manufactureKeyPressForCommandName(w,'paste-text')
    w.event_generate('&lt;Return&gt;')
    assert p.h == h[0] + paste + h[2:]
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h, 'head mismatch'
finally:
    if 1:
        c.setHeadString(p,h) # Essential.
        c.redraw(p)</t>
<t tx="ekr.20090401102247.235">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.k

if k.defaultUnboundKeyAction == 'insert':
    frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
    h = 'Test headline abc'
    p = u.findNodeAnywhere(h)
    assert p,'node not found: %s' % h
    c.redraw(p) # To make node visible
    tree.editLabel(p)
    w = c.edit_widget(p)
    try:
        assert w
        w.setSelectionRange('end','end')
        w.event_generate('X')
        w.event_generate('Y')
        w.event_generate('Z')
        w.event_generate('&lt;Return&gt;')
        assert p.h == h + 'XYZ'
        k.manufactureKeyPressForCommandName(w,'undo')
        assert p.h == h
    finally:
        if 1:
            c.setHeadString(p,h) # Essential.
            c.redraw(p)</t>
<t tx="ekr.20090401102247.236">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.selectPosition(p)
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
w.setSelectionRange('end','end',insert='end')
paste = 'ABC'
g.app.gui.replaceClipboardWith(paste)
if 1: # New code calls pasteText directly.
    event = g.Bunch(widget=w)
    c.frame.pasteText(event)
else:
    menu = c.frame.menu.getMenu('Edit')
    i = menu.index('Paste')
    menu.invoke(i)
# Move around and and make sure it doesn't change.
try:
    # g.trace('before select',w,w.getAllText())
    c.selectPosition(p.threadBack())
    assert p.h == h + paste,'oops1: expected: %s, got %s' % (h + paste,p.h)
    c.selectPosition(p)
    assert p.h == h + paste,'oops2: expected: %s, got %s' % (h + paste,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential.
        c.redraw(p)</t>
<t tx="ekr.20090401102247.237">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w
    g.app.gui.set_focus(c,w)
    w2 = g.app.gui.get_focus(c)
    # assert w == w2 or hasattr(w,'widget') and w.widget == w2,'w: %s\nw2: %s' % (w,w2)
    w.setSelectionRange('end','end')
    n = w.getWidth()
    w.event_generate('X')
    w.event_generate('Y')
    w.event_generate('Z')
    w.update()
    if 1: # Easiest.
        c.endEditing()
    else: # More thorough test.
        w.event_generate('&lt;Return&gt;')
        w.update()
    assert w, 'fail 2'
    n2 = w.getWidth()
    if g.app.gui.guiName() == 'tkinter':
        assert n2 &gt; n, '%s %s' % (n2,n)
    # g.trace(n,n2)
finally:
    if 1:
        c.setHeadString(p,h) # Essential.
        c.redraw(p)</t>
<t tx="ekr.20090401102247.238">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.keyHandler
frame = c.frame ; tree = frame.tree ; canvas = tree.canvas
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w,'oops1'
    w.setSelectionRange('end','end')
    paste = 'ABC'
    g.app.gui.replaceClipboardWith(paste)
    w.setSelectionRange('end','end')
    k.manufactureKeyPressForCommandName(w,'paste-text')
    c.selectPosition(p.visBack(c))
    assert p.h == h + paste
    k.manufactureKeyPressForCommandName(w,'undo')
    assert p.h == h,'expected: %s, got: %s' % (
        h,p.h)
finally:
    if 1:
        c.setHeadString(p,h) # Essential.
        c.redraw(p)</t>
<t tx="ekr.20090401102247.239">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
h = 'Test headline abc'
p = u.findNodeAnywhere(h)
assert p,'node not found: %s' % h
c.redraw(p) # To make node visible
c.frame.tree.editLabel(p)
w = c.edit_widget(p)
try:
    assert w
    w.setSelectionRange('end','end')
    # w.event_generate('X')
finally:
    if 1:
        c.setHeadString(p,h) # Essential.
        c.redraw(p)</t>
<t tx="ekr.20090401102247.240">c.redraw(p) # To make node visible

c2 = c.new()
p2 = c2.p

try:
    # This fails, but it is possible to edit the headline.
    # assert c2.edit_widget(p2),'c2.edit_widget(p2) failed: %s' % repr(p2)
    assert p2,'p2 failed: %s' % repr(p2)
    # assert c.edit_widget(p),'c.edit_widget(p) failed: %s' % repr(p)
finally:
    c2.setChanged(False)
    c2.close()</t>
<t tx="ekr.20090401102247.241">import leo.core.leoTest as leoTest ; u = leoTest.testUtils(c)
k = c.k ; p = c.currentPosition() ; w = c.edit_widget(p)
commandName = 'test-registerCommand'

def callback (event=None,c=c): # Must have an event param to pass later unit test.
    g.app.unitTestDict[commandName] = True

# Test 1
g.app.unitTestDict[commandName] = False
k.registerCommand(commandName,'Alt-Ctrl-Shift-z',callback,pane='all',verbose=True)
k.simulateCommand(commandName)
assert g.app.unitTestDict.get(commandName)

if 0: # Test 2
    g.app.unitTestDict[commandName] = False
    k.manufactureKeyPressForCommandName(w,commandName)
    assert g.app.unitTestDict.get(commandName)</t>
<t tx="ekr.20090401102247.242"># However, the qt version of onHeadChanged can recompute e, the edit widget!</t>
<t tx="ekr.20090401102247.243">def edit_widget (self,p):

    c = self

    return p and c.frame.tree.edit_widget(p)</t>
<t tx="ekr.20090401102247.244"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing',s=None):

    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''

    trace = False and g.unitTesting
    c = self.c ; u = c.undoer
    w = self.edit_widget(p)

    if c.suppressHeadChanged: return
    if not w:
        if trace: g.trace('****** no w for p: %s',repr(p))
        return

    ch = '\n' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    if s is None: s = w.getAllText()
    if trace: g.trace('w',repr(w),'s',repr(s))
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    # Make the change official, but undo to the *old* revert point.
    oldRevert = self.revertHeadline
    changed = s != oldRevert
    self.revertHeadline = s
    p.initHeadString(s)
    if trace: g.trace('changed',changed,'new',repr(s))
    if changed:
        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
        if not c.changed: c.setChanged(True)
        # New in Leo 4.4.5: we must recolor the body because
        # the headline may contain directives.
        c.frame.scanForTabWidth(p)
        c.frame.body.recolor(p,incremental=True)
        dirtyVnodeList = p.setDirty()
        u.afterChangeNodeContents(p,undoType,undoData,
            dirtyVnodeList=dirtyVnodeList)
    if changed:
        c.redraw_after_head_changed()
        if self.stayInTree:
            c.treeWantsFocus()
        else:
            c.bodyWantsFocus()
    else:
        c.frame.tree.setSelectedLabelState(p)

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
</t>
<t tx="ekr.20090401102247.245"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("truncating headline to",limit,"characters",color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)
</t>
<t tx="ekr.20090401102247.246"></t>
<t tx="ekr.20090401102247.247">def toggleAngleBrackets (self,event=None):

    '''Add or remove double angle brackets from the headline of the selected node.'''

    c = self ; p = c.p

    if g.app.batchMode:
        c.notValidInBatchMode("Toggle Angle Brackets")
        return

    c.endEditing()
    s = p.h.strip()

    if (s[0:2] == "&lt;&lt;"
        or s[-2:] == "&gt;&gt;"): # Must be on separate line.
        if s[0:2] == "&lt;&lt;": s = s[2:]
        if s[-2:] == "&gt;&gt;": s = s[:-2]
        s = s.strip()
    else:
        s = g.angleBrackets(' ' + s + ' ')

    p.setHeadString(s)
    c.redrawAndEdit(p, selectAll=True)</t>
<t tx="ekr.20090401102247.248">def insertHeadlineTime (self,event=None):

    '''Insert a date/time stamp in the headline of the selected node.'''

    frame = self ; c = frame.c ; p = c.p

    if g.app.batchMode:
        c.notValidInBatchMode("Insert Headline Time")
        return

    c.endEditing()
    time = c.getTime(body=False)
    s = p.h.rstrip()
    c.setHeadString(p,'%s %s' % (s,time))
    c.redrawAndEdit(p,selectAll=True)</t>
<t tx="ekr.20090401102247.249">def showSuccess(self,pos,newpos,showState=True):

    '''Display the result of a successful find operation.'''

    trace = False
    c = self.c ; p = self.p
    if not p:
        return g.trace('can not happen: self.p is None')

    current = c.p
    sparseFind = c.config.getBool('collapse_nodes_during_finds')
    c.frame.bringToFront() # Needed on the Mac

    # Expand ancestors and set redraw if a redraw is needed.
    redraw1 = not p.isVisible(c)
    if sparseFind:
        # Show only the 'sparse' tree when redrawing.
        for p2 in c.p.self_and_parents_iter():
            if p2.isAncestorOf(p):
                break
            p2.contract()
            redraw1 = True # Important bug fix. Was redraw = True.

    redraw2 = c.expandAllAncestors(self.p)
    redraw = redraw1 or redraw2

    # Set state vars.
    # Ensure progress in backwards searches.
    insert = g.choose(self.reverse,min(pos,newpos),max(pos,newpos))
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p

    if trace: g.trace('in_headline',self.in_headline)
    if self.in_headline:
        selection = pos,newpos,insert
        c.redrawAndEdit(p,
            selection=selection,
            keepMinibuffer=True)
        w = c.edit_widget(p)
    else:
        w = c.frame.body.bodyCtrl
        # This is like the logic in c.selectPosition.
        if redraw:
            c.redraw(p)
        else:
            c.selectPosition(p)
            c.redraw_after_select(p)
        c.bodyWantsFocus()
        if showState:
            c.k.showStateAndMode(w)
        # g.trace(pos,newpos,insert)
        w.setSelectionRange(pos,newpos,insert=insert)
        w.seeInsertPoint()
        c.outerUpdate()
    return w # Support for isearch.
</t>
<t tx="ekr.20090401102247.250">
def bodyWantsFocus(self):
    c = self ; body = c.frame.body
    c.request_focus(body and body.bodyCtrl)

def logWantsFocus(self):
    c = self ; log = c.frame.log
    c.request_focus(log and log.logCtrl)

def minibufferWantsFocus(self):
    c = self ; k = c.k
    if k: k.minibufferWantsFocus()

def treeWantsFocus(self):
    c = self ; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)

def widgetWantsFocus(self,w):
    c = self ; c.request_focus(w)
</t>
<t tx="ekr.20090401102247.251">def initInteractiveCommands(self):

    c = self.c ; p = self.p
    bodyCtrl = c.frame.body and c.frame.body.bodyCtrl

    w = g.choose(self.in_headline,c.edit_widget(p),bodyCtrl)
    if not w:
        self.in_headline = False
        w = bodyCtrl
    if not w: return

    self.errors = 0

    # We only use the insert point, *never* the selection range.
    ins = w.getInsertPoint()
    # g.trace('ins',ins)
    self.debugCount = 0
    self.initNextText(ins=ins)
    c.widgetWantsFocus(w)

    self.wrapping = self.wrap
    if self.wrap and self.wrapPosition == None:
        self.wrapPos = ins
        # Do not set self.wrapPosition here: that must be done after the first search.
</t>
<t tx="ekr.20090401102247.252">def setHeadString (self,p,s,encoding="utf-8"):

    '''Set the p's headline and the corresponding tree widget to s.

    This is used in by unit tests to restore the outline.'''

    c = self

    p.initHeadString(s,encoding)
    p.setDirty()

    # Change the actual tree widget so
    # A later call to c.endEditing or c.redraw will use s.
    c.frame.tree.setHeadline(p,s)
</t>
<t tx="ekr.20090401102247.253">def abortEditLabelCommand (self,event=None):

    '''End editing of a headline and revert to its previous value.'''

    frame = self ; c = frame.c ; tree = frame.tree
    p = c.p

    if g.app.batchMode:
        c.notValidInBatchMode("Abort Edit Headline")
        return

    # Revert the headline text.
    # Calling c.setHeadString is required.
    # Otherwise c.redraw would undo the change!
    c.setHeadString(p,tree.revertHeadline)
    c.redraw(p)
</t>
<t tx="ekr.20090401102247.254"># Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p
    bodyCtrl = c.frame.body and c.frame.body.bodyCtrl
    w = g.choose(self.in_headline,c.edit_widget(p),bodyCtrl)
    if not w:
        self.in_headline = False
        w = bodyCtrl
    if not w: return

    oldSel = sel = w.getSelectionRange()
    start,end = sel
    if start &gt; end: start,end = end,start
    if start == end:
        g.es("no text selected") ; return False

    # g.trace(start,end)

    # Replace the selection in _both_ controls.
    start,end = oldSel
    change_text = self.change_text

    # Perform regex substitutions of \1, \2, ...\9 in the change text.
    if self.pattern_match and self.match_obj:
        groups = self.match_obj.groups()
        if groups:
            change_text = self.makeRegexSubs(change_text,groups)
    # change_text = change_text.replace('\\n','\n').replace('\\t','\t')
    change_text = self.replaceBackSlashes(change_text)

    for w2 in (w,self.s_ctrl):
        if start != end: w2.delete(start,end)
        w2.insert(start,change_text)
        w2.setInsertPoint(g.choose(self.reverse,start,start+len(change_text)))

    # Update the selection for the next match.
    w.setSelectionRange(start,start+len(change_text))
    c.widgetWantsFocus(w)

    # No redraws here: they would destroy the headline selection.
    if self.mark_changes:
        p.setMarked()
    if self.in_headline:
        c.frame.tree.onHeadChanged(p,'Change')
    else:
        c.frame.body.onBodyChanged('Change',oldSel=oldSel)

    c.frame.tree.drawIcon(p) # redraw only the icon.

    return True
</t>
<t tx="ekr.20090401102247.255">def makeRegexSubs(self,s,groups):

    '''Carefully substitute group[i-1] for \i strings in s.
    The group strings may contain \i strings: they are *not* substituted.'''

    digits = '123456789'
    result = [] ; n = len(s)
    i = j = 0 # s[i:j] is the text between \i markers.
    while j &lt; n:
        k = s.find('\\',j)
        if k == -1 or k + 1 &gt;= n:
            break
        j = k + 1 ; ch = s[j]
        if ch in digits:
            j += 1
            result.append(s[i:k]) # Append up to \i
            i = j
            gn = int(ch)-1
            if gn &lt; len(groups):
                result.append(groups[gn]) # Append groups[i-1]
            else:
                result.append('\\%s' % ch) # Append raw '\i'
    result.append(s[i:])
    return ''.join(result)
</t>
<t tx="ekr.20090401102247.256"></t>
<t tx="ekr.20090401102247.257">def edit_widget (self,p):
    d = self.editWidgetsDict
    if not p.v or not p.v.t:
        return None
    w = d.get(p.v.t)
    if not w:
        d[p.v.t] = w = stringTextWidget(
            c=self.c,
            name='head-%d' % (1 + len(d.keys())))
        w.setAllText(p.h)
    # g.trace('w',w,'p',p.h)
    return w

def headWidth(self,p=None,s=''):
    return len(s)

def setEditLabelState(self,v,selectAll=False):
    pass

def setSelectedLabelState(self,p):
    pass

def setUnselectedLabelState(self,p):
    pass
</t>
<t tx="ekr.20090401102247.258">def editLabel (self,p,selectAll=False,selection=None):

    """Start editing p's headline."""

    c = self.c

    self.endEditLabel()
    self.setEditPosition(p)
        # That is, self._editPosition = p

    if p:
        self.revertHeadline = p.h
            # New in 4.4b2: helps undo.</t>
<t tx="ekr.20090401102247.259">def setHeadline (self,p,s):

    '''Set the actual text of the headline widget.

    This is called from the undo/redo logic to change the text before redrawing.'''

    # g.trace('p',p.h,'s',repr(s),g.callers())

    w = self.edit_widget(p)
    if w:
        w.delete(0,'end')
        if s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        w.insert(0,s)
        self.revertHeadline = s
        # g.trace(repr(s),w.getAllText())
    else:
        g.trace('-'*20,'oops')
</t>
<t tx="ekr.20090401102247.260"># Bidings.
def setBindings (self):                         self.oops()

# Fonts.
def getFont(self):                              self.oops()
def setFont(self,font=None,fontName=None):      self.oops()
def setFontFromConfig (self):                   self.oops()

# Drawing &amp; scrolling.
def drawIcon(self,p):                                       self.oops()
def redraw(self,p=None,scroll=True,forceDraw=False):        self.oops()
def redraw_now(self,p=None,scroll=True,forceDraw=False):    self.oops()
def scrollTo(self,p):                           self.oops()
idle_scrollTo = scrollTo # For compatibility.

# Headlines.
def editLabel(self,v,selectAll=False,selection=None): self.oops()
def edit_widget (self,p):                       self.oops() ; return None
def headWidth(self,p=None,s=''):                self.oops() ; return 0
def setEditLabelState(self,v,selectAll=False):  self.oops()
def setSelectedLabelState(self,p):              self.oops()
def setUnselectedLabelState(self,p):            self.oops()</t>
<t tx="ekr.20090401102247.261">def __init__ (self,frame):

    self.frame = frame
    self.c = frame.c

    self.edit_text_dict = {}
        # New in 3.12: keys vnodes, values are edit_widget (Tk.Text widgets)
        # New in 4.2: keys are vnodes, values are pairs (p,Tk.Text).

    # "public" ivars: correspond to setters &amp; getters.
    self._editPosition = None
    self.redrawCount = 0 # For traces
    self.revertHeadline = None
    self.use_chapters = False # May be overridden in subclasses.

    # Define these here to keep pylint happy.
    self.canvas = None
    self.stayInTree = True
    self.trace_select = None
</t>
<t tx="ekr.20090401102247.262"># List of methods that must be defined either in the base class or a subclass.

mustBeDefined = (
    'initAfterLoad', # New in Leo 4.6.
    'treeSelectHint', # New in Leo 4.6.
)</t>
<t tx="ekr.20090401102247.263">mustBeDefinedOnlyInBaseClass = (
    # Getters &amp; setters.
    'editPosition',
    'getEditTextDict',
    'setEditPosition',
    # Others.
    'endEditLabel',
    # 'expandAllAncestors', # Now defined in Commands class.
    'injectCallbacks',
    'OnIconDoubleClick',
    'onHeadChanged',
    'onHeadlineKey',
    'updateHead',
    'oops',
)</t>
<t tx="ekr.20090401102247.264">mustBeDefinedInSubclasses = (
    # Colors &amp; fonts.
    'getFont',
    'setFont',
    'setFontFromConfig ',
    # Drawing &amp; scrolling.
    'drawIcon',
    'redraw_now',
    'scrollTo',
    # Headlines.
    'editLabel',
    # 'setEditLabelState',
    # Selecting.
    # 'select', # Defined in base class, may be overridden in do-nothing subclasses.
)
</t>
<t tx="ekr.20090401102247.265">def save (self):

    c = self.c ; p = self.p

    w = g.choose(self.in_headline,c.edit_widget(p),c.frame.body.bodyCtrl)

    if w:
        insert = w.getInsertPoint()
        sel = w.getSelectionRange()
        if len(sel) == 2:
            start,end = sel
        else:
            start,end = None,None
    else:
        insert,start,end = None,None,None

    return (self.in_headline,p,w,insert,start,end)
</t>
<t tx="ekr.20090401102247.266"></t>
<t tx="ekr.20090401102247.267">def readOneAtAutoNode(self,p):

    '''Read the @auto node at p'''

    c = self.c

    self.createOutline(
        fileName=p.atAutoNodeName(),
        parent=p.copy(),
        atAuto=True)

    # Force an update of the body pane.
    self.setBodyString(p,p.b)
    c.frame.body.onBodyChanged(undoType=None)
</t>
<t tx="ekr.20090401102247.268">def readOneAtAutoNode (self,fileName,p):

    at = self ; c = at.c ; ic = c.importCommands

    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)

    if not g.unitTesting:
        g.es("reading:",p.h)

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    ic.createOutline(fileName,parent=p.copy(),atAuto=True)

    if ic.errors:
        g.es_print('errors inhibited read @auto',fileName,color='red')

    if ic.errors or not g.os_path_exists(fileName):
        #c.setBodyString(p,'')
        p.clearDirty()
        c.setChanged(oldChanged)
    else:
        g.doHook('after-auto', p = p)  # call after-auto callbacks
</t>
<t tx="ekr.20090401102247.269">def appendStringToBody (self,p,s,encoding="utf-8"):

    c = self
    if not s: return

    body = p.b
    assert(g.isUnicode(body))
    s = g.toUnicode(s,encoding)

    c.setBodyString(p,body + s,encoding)
</t>
<t tx="ekr.20090401102247.270">def setBodyString (self,p,s,encoding="utf-8"):

    c = self ; v = p.v
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    current = c.p
    # 1/22/05: Major change: the previous test was: 'if p == current:'
    # This worked because commands work on the presently selected node.
    # But setRecentFiles may change a _clone_ of the selected node!
    if current and p.v.t==current.v.t:
        # Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        w = c.frame.body.bodyCtrl
        i = w.getInsertPoint()
        w.setSelectionRange(i,i)
        # This code destoys all tags, so we must recolor.
        c.recolor()

    # Keep the body text in the tnode up-to-date.
    if v.t._bodyString != s:
        v.setBodyString(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)
        c.redraw_after_icons_changed()</t>
<t tx="ekr.20090401102247.271">def setSelectionAreas (self,before,sel,after):

    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    body = self ; w = body.bodyCtrl
    s = w.getAllText()
    before = before or ''
    sel = sel or ''
    after = after or ''
    w.delete(0,len(s))
    w.insert(0,before+sel+after)
    i = len(before)
    j = max(i,len(before)+len(sel)-1)
    # g.trace(i,j,repr(sel))
    w.setSelectionRange(i,j,insert=j)
    return i,j
</t>
<t tx="ekr.20090401102247.272">def appendStringToBody (self,p,s,encoding="utf-8"):

    '''Similar to c.appendStringToBody,
    but does not recolor the text or redraw the screen.'''

    if s:
        body = p.b
        assert(g.isUnicode(body))
        s = g.toUnicode(s,encoding)
        self.setBodyString(p,body + s,encoding)

def setBodyString (self,p,s,encoding="utf-8"):

    '''Similar to c.setBodyString,
    but does not recolor the text or redraw the screen.'''

    c = self.c ; v = p.v
    if not c or not p: return

    s = g.toUnicode(s,encoding)
    current = c.p
    if current and p.v.t==current.v.t:
        c.frame.body.setSelectionAreas(s,None,None)
        w = c.frame.body.bodyCtrl
        i = w.getInsertPoint()
        w.setSelectionRange(i,i)

    # Keep the body text in the tnode up-to-date.
    if v.t._bodyString != s:
        v.setBodyString(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)
</t>
<t tx="ekr.20090401102247.273">@nocolor-node

@
This is the expand-and-go-right command.

Adding a call to c.endEditing to c.redraw_after_expand/contract seems to work.</t>
<t tx="ekr.20090401102247.274"># Ends the editing in the outline.

def endEditing(self):

    c = self ; k = c.k

    p = c.p

    if p:
        c.frame.tree.endEditLabel()
        c.frame.tree.setSelectedLabelState(p)

    # The following code would be wrong; c.endEditing is a utility method.
    # if k:
        # k.setDefaultInputState()
        # # Recolor the *body* text, **not** the headline.
        # k.showStateAndMode(w=c.frame.body.bodyCtrl)
</t>
<t tx="ekr.20090401102247.275"></t>
<t tx="ekr.20090401102247.276">def redraw_after_contract (self,p=None,setFocus=False):

    c = self

    c.endEditing()

    if p:
        c.setCurrentPosition(p)
    else:
        p = c.currentPosition()

    c.frame.tree.redraw_after_contract(p)

    if setFocus:
        c.treeFocusHelper()
</t>
<t tx="ekr.20090401102247.277">def redraw_after_expand (self,p=None,setFocus=False):

    c = self

    c.endEditing()

    if p:
        c.setCurrentPosition(p)
    else:
        p = c.currentPosition()

    c.frame.tree.redraw_after_expand(p)

    if setFocus:
        c.treeFocusHelper()
</t>
<t tx="ekr.20090401102247.278">def redraw_after_head_changed(self):

    '''Redraw the screen (if needed) when editing ends.
    This may be a do-nothing for some gui's.'''

    return self.frame.tree.redraw_after_head_changed()
</t>
<t tx="ekr.20090401102247.279">def redraw_after_icons_changed(self):

    '''Update the icon for the presently selected node,
    or all icons if the 'all' flag is true.'''

    c = self

    c.frame.tree.redraw_after_icons_changed()

    # c.treeFocusHelper()
</t>
<t tx="ekr.20090401102247.280">def expandNodeAndGoToFirstChild (self,event=None):

    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.p
    if not p.hasChildren():
        c.treeFocusHelper()
        return

    if not p.isExpanded():
        c.expandNode() # Calls redraw_after_expand.

def expandNodeOrGoToFirstChild (self,event=None):

    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.p
    if p.hasChildren():
        if not p.isExpanded():
            c.expandNode() # Calls redraw_after_expand.
        else:
            c.redraw_after_expand(p.firstChild(),setFocus=True)</t>
<t tx="ekr.20090401102247.281">def expandNode (self,event=None):

    '''Expand the presently selected node.'''

    c = self ; p = c.p

    p.expand()

    c.redraw_after_expand(p,setFocus=True)

</t>
<t tx="ekr.20090401102247.282"></t>
<t tx="ekr.20090401102247.283">def clone (self,event=None):

    '''Create a clone of the selected outline.'''

    c = self ; u = c.undoer ; p = c.p
    if not p: return

    undoData = c.undoer.beforeCloneNode(p)
    c.endEditing() # Capture any changes to the headline.
    clone = p.clone()
    dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
    c.setChanged(True)
    if c.validateOutline():
        u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
        c.redraw(clone)
        return clone # For mod_labels and chapters plugins.
    else:
        clone.doDelete()
        c.setCurrentPosition(p)
        return None
</t>
<t tx="ekr.20090401102247.284"># The fix was to create minibufferFind.editWidget,
# an override of baseEditCommandsClass.editWidget.</t>
<t tx="ekr.20090401102247.285">def editWidget (self,event):

    '''An override of baseEditCommands.editWidget

    that does *not* set focus when using anything other than the tk gui.

    This prevents this class from caching an edit widget
    that is about to be deallocated.'''

    c = self.c ; w = event and event.widget
    bodyCtrl = self.c.frame.body and self.c.frame.body.bodyCtrl

    # g.trace('isText',g.app.gui.isTextWidget(w),'w',w,g.app.gui.widget_name(w))

    if g.app.gui.guiName() == 'tkinter':

        # New in Leo 4.5: single-line editing commands apply to minibuffer widget.
        if w and g.app.gui.isTextWidget(w):
            self.w = w
        else:
            self.w = bodyCtrl
        if self.w:
            c.widgetWantsFocusNow(self.w)
    else:
        # Do not cache a pointer to a headline!
        # It will die when the minibuffer is selected.
        self.w = bodyCtrl

    return self.w
</t>
<t tx="ekr.20090401102247.286"># It's not clear whether this is a good idea.</t>
<t tx="ekr.20090401102247.287">@nocolor-node

&gt; Sometimes, but not always, after creating a node (and changing its
&gt; headline), I come back later to the created node and find that its
&gt; headline has reverted to 'New headline'.

*** 

Ctrl-i, type in headline
Ctrl-f, ctrl-g
Ctrl-i, first headline reverts.


***

Ctrl-N for a new leo doc.

Expose the Spell tab.

Ctrl-I to create new headline, type "here's that critical phone number".

Click the Find button in the Spell tab - everything appears to be ok.

(Minor bug - Ctrl-I doesn't work when Find/Spell/Etc. tabs have focus)

Click tree or body (because of minor bug above)

Ctrl-I to create new headline.... "here's that critical phone number"
node which was looking ok reverts...
</t>
<t tx="ekr.20090401102247.288"></t>
<t tx="ekr.20090401102247.289">class minibufferFind (baseEditCommandsClass):

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others
</t>
<t tx="ekr.20090401102247.290">def __init__(self,c,finder):

    baseEditCommandsClass.__init__(self,c) # init the base class.

    # g.trace('minibufferFind: finder',finder)

    self.c = c
    self.k = k = c.k
    self.w = None
    self.finder = finder
    self.findTextList = []
    self.changeTextList = []

    commandName = 'replace-string'
    s = k.getShortcutForCommandName(commandName)
    s = k.prettyPrintKey(s)
    s = k.shortcutFromSetting(s)
    # g.trace('replaceStringShortcut',s)
    self.replaceStringShortcut = s
</t>
<t tx="ekr.20090401102247.291"></t>
<t tx="ekr.20090401102247.292">def setFindScope(self,where):

    '''Set the find-scope radio buttons.

    `where` must be in ('node-only','entire-outline','suboutline-only'). '''

    h = self.finder

    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.svarDict['radio-search-scope'].get()
        if var:
            h.svarDict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)
</t>
<t tx="ekr.20090401102247.293"># This redirection is required to remove gui-dependencies.

def getOption (self,ivar):          return self.finder.getOption(ivar)
def setOption (self,ivar,val):      self.finder.setOption(ivar,val)
def toggleOption (self,ivar):       self.finder.toggleOption(ivar)
</t>
<t tx="ekr.20090401102247.294">def showFindOptions (self):

    '''Show the present find options in the status line.'''

    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')

    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )

    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))
</t>
<t tx="ekr.20090401102247.295">def setupChangePattern (self,pattern):

    h = self.finder ; w = h.change_ctrl

    s = g.toUnicode(pattern,g.app.tkEncoding)

    w.delete(0,'end')
    w.insert(0,s)

    h.update_ivars()
</t>
<t tx="ekr.20090401102247.296">def setupSearchPattern (self,pattern):

    h = self.finder ; w = h.find_ctrl

    # g.trace('pattern',pattern)

    s = g.toUnicode(pattern,g.app.tkEncoding)

    w.delete(0,'end')
    w.insert(0,s)

    h.update_ivars()
</t>
<t tx="ekr.20090401102247.297">def addChangeStringToLabel (self,protect=True):

    c = self.c ; k = c.k ; h = self.finder ; w = h.change_ctrl

    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = w.getAllText()

    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
</t>
<t tx="ekr.20090401102247.298">def addFindStringToLabel (self,protect=True):

    c = self.c ; k = c.k ; h = self.finder ; w = h.find_ctrl

    c.frame.log.selectTab('Find')
    c.minibufferWantsFocusNow()

    s = w.getAllText()
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1]

    k.extendLabel(s,select=True,protect=protect)
</t>
<t tx="ekr.20090401102247.299">def changeAll (self,event):

    k = self.k ; tag = 'change-all' ; state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Change All From: ',protect=True)
        k.getArg(event,tag,1,self.changeAll)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = 'Change All: %s With: ' % (self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,tag,2,self.changeAll,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg,changeAll=True)

</t>
<t tx="ekr.20090401102247.300">def cloneFindAll (self,event):

    c = self.c ; k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)
        c.treeWantsFocus()
</t>
<t tx="ekr.20090401102247.301">def findAgain (self,event):

    f = self.finder

    f.p = self.c.p
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
</t>
<t tx="ekr.20090401102247.302">def findAll (self,event):

    k = self.k ; state = k.getState('find-all')
    if state == 0:
        w = self.editWidget(event) # sets self.w
        if not w: return
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Find All: ',protect=True)
        k.getArg(event,'find-all',1,self.findAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,findAll=True)
</t>
<t tx="ekr.20090401102247.303">def generalChangeHelper (self,find_pattern,change_pattern,changeAll=False):

    # g.trace(repr(change_pattern))

    c = self.c

    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)

    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.p
    self.finder.v = self.finder.p.v

    # Bug fix: 2007-12-14: remove call to self.finder.findNextCommand.
    # This was the cause of replaces not starting in the right place!

    if changeAll:
        self.finder.changeAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
</t>
<t tx="ekr.20090401102247.304">def generalSearchHelper (self,pattern,cloneFindAll=False,findAll=False):

    c = self.c

    self.setupSearchPattern(pattern)

    c.widgetWantsFocusNow(self.w)

    self.finder.p = self.c.p
    self.finder.v = self.finder.p.v

    if findAll:
        self.finder.findAllCommand()
    elif cloneFindAll:
        self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()
</t>
<t tx="ekr.20090401102247.305">def lastStateHelper (self):

    k = self.k
    k.clearState()
    k.resetLabel()
    k.showStateAndMode()
</t>
<t tx="ekr.20090401102247.306">def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        self.updateFindList(k.arg)
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.updateChangeList(k.arg)
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)
</t>
<t tx="ekr.20090401102247.307">def reSearchBackward (self,event):

    k = self.k ; tag = 're-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search Backward:',self.reSearchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; tag = 're-search-forward' ; state = k.getState(tag)
    if state == 0:
        self.setupArgs(forward=True,regexp=True,word=None)
        self.stateZeroHelper(
            event,tag,'Regexp Search:',self.reSearchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20090401102247.308">def searchBackward (self,event):

    k = self.k ; tag = 'search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search Backward: ',self.searchBackward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; tag = 'search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=False)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchForward,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20090401102247.309">def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    state = k.getState(tag)

    # g.trace('state',state)
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        self.stateZeroHelper(
            event,tag,'Search: ',self.searchWithPresentOptions,
            escapes=[self.replaceStringShortcut])
    elif k.getArgEscape:
        # Switch to the replace command.
        k.setState('replace-string',1,self.replaceString)
        self.replaceString(event=None)
    else:
        self.updateFindList(k.arg)
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20090401102247.310">def setupArgs (self,forward=False,regexp=False,word=False):

    h = self.finder ; k = self.k

    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val)

    h.p = p = self.c.p
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()
</t>
<t tx="ekr.20090401102247.311">def stateZeroHelper (self,event,tag,prefix,handler,escapes=None):

    k = self.k
    self.w = self.editWidget(event)
    if not self.w: return

    k.setLabelBlue(prefix,protect=True)
    self.addFindStringToLabel(protect=False)

    # g.trace(escapes,g.callers())
    if escapes is None: escapes = []
    k.getArgEscapes = escapes
    k.getArgEscape = None # k.getArg may set this.
    k.getArg(event,tag,1,handler, # enter state 1
        tabList=self.findTextList,completion=True,prefix=prefix)
</t>
<t tx="ekr.20090401102247.312">def updateChangeList (self,s):

    if s not in self.changeTextList:
        self.changeTextList.append(s)

def updateFindList (self,s):

    if s not in self.findTextList:
        self.findTextList.append(s)
</t>
<t tx="ekr.20090401102247.313">def wordSearchBackward (self,event):

    k = self.k ; tag = 'word-search-backward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=False,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search Backward: ',self.wordSearchBackward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; tag = 'word-search-forward' ; state = k.getState(tag)

    if state == 0:
        self.setupArgs(forward=True,regexp=False,word=True)
        self.stateZeroHelper(event,tag,'Word Search: ',self.wordSearchForward)
    else:
        self.lastStateHelper()
        self.generalSearchHelper(k.arg)
</t>
<t tx="ekr.20090401102247.314">class searchCommandsClass (baseEditCommandsClass):

    '''Implements many kinds of searches.'''

    @others
</t>
<t tx="ekr.20090401102247.315">def __init__ (self,c):

    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c)
        # init the base class.
        # sets self.c

    self.findTabHandler = None
    self.minibufferFindHandler = None
    self.inited = False

    # For isearch commands.
    self.ifinder = None
    self.stack = [] # Entries are (p,sel)
    self.ignoreCase = None
    self.forward = None
    self.regexp = None
</t>
<t tx="ekr.20090401102247.316">def getPublicCommands (self):

    return {
        'clone-find-all':                       self.cloneFindAll,

        'find-all':                             self.findAll,
        'change-all':                           self.changeAll,

        # Thin wrappers on Find tab
        'change':                               self.findTabChange,
        'change-then-find':                     self.findTabChangeThenFind,
        'find-next':                            self.findTabFindNext,
        'find-prev':                            self.findTabFindPrev,

        'hide-find-tab':                        self.hideFindTab,

        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
        'isearch-with-present-options':         self.isearchWithPresentOptions,

        'open-find-tab':                        self.openFindTab,

        'replace-string':                       self.replaceString,

        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.

        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,

        'show-find-options':                    self.showFindOptions,

        'toggle-find-collapses_nodes':          self.toggleFindCollapesNodes,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,

        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }
</t>
<t tx="ekr.20090401102247.317"></t>
<t tx="ekr.20090401102247.318">def openFindTab (self,event=None,show=True):

    '''Open the Find tab in the log pane.'''

    c = self.c ; log = c.frame.log ; tabName = 'Find'

    wasOpen = self.inited

    if self.inited:
        log.selectTab(tabName)
    else:
        self.inited = True
        log.selectTab(tabName,createText=False)
        f = log.frameDict.get(tabName)
        self.findTabHandler = g.app.gui.createFindTab(c,f)

    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)
</t>
<t tx="ekr.20090401102247.319"># Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):
    '''Execute the 'Change' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):
    '''Execute the 'Replace, Find' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()

def findTabFindAll(self,event=None):
    '''Execute the 'Find All' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findAllCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    '''Execute the 'Find Next' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    '''Execute the 'Find Previous' command with the settings shown in the Find tab.'''
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()

def hideFindTab (self,event=None):
    '''Hide the Find tab.'''
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')
</t>
<t tx="ekr.20090401102247.320">def getHandler(self,show=False):

    '''Return the minibuffer handler, creating it if necessary.'''

    c = self.c

    self.openFindTab(show=show)
        # sets self.findTabHandler,
        # but *not* minibufferFindHandler.

    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    return self.minibufferFindHandler
</t>
<t tx="ekr.20090401102247.321">def setFindScopeEveryWhere (self, event):
    '''Set the 'Entire Outline' radio button in the Find tab.'''
    return self.setFindScope('entire-outline')

def setFindScopeNodeOnly  (self, event):
    '''Set the 'Node Only' radio button in the Find tab.'''
    return self.setFindScope('node-only')

def setFindScopeSuboutlineOnly (self, event):
    '''Set the 'Suboutline Only' radio button in the Find tab.'''
    return self.setFindScope('suboutline-only')

def showFindOptions (self,event):
    '''Show all Find options in the minibuffer label area.'''
    self.getHandler().showFindOptions()

def toggleFindCollapesNodes(self,event):
    '''Toggle the 'Collapse Nodes' checkbox in the find tab.'''
    # return self.toggleOption('collapse_nodes')
    c = self.c ; p = c.p
    val = c.config.getBool('collapse_nodes_during_finds')
    c.config.set(p,'collapse_nodes_during_finds',not val)
    g.es('collapse_nodes_during_finds',c.config.getBool('collapse_nodes_during_finds'))

def toggleIgnoreCaseOption     (self, event):
    '''Toggle the 'Ignore Case' checkbox in the Find tab.'''
    return self.toggleOption('ignore_case')

def toggleMarkChangesOption (self, event):
    '''Toggle the 'Mark Changes' checkbox in the Find tab.'''
    return self.toggleOption('mark_changes')
def toggleMarkFindsOption (self, event):
    '''Toggle the 'Mark Finds' checkbox in the Find tab.'''
    return self.toggleOption('mark_finds')
def toggleRegexOption (self, event):
    '''Toggle the 'Regexp' checkbox in the Find tab.'''
    return self.toggleOption('pattern_match')
def toggleReverseOption        (self, event):
    '''Toggle the 'Reverse' checkbox in the Find tab.'''
    return self.toggleOption('reverse')

def toggleSearchBodyOption (self, event):
    '''Set the 'Search Body' checkbox in the Find tab.'''
    return self.toggleOption('search_body')

def toggleSearchHeadlineOption (self, event):
    '''Toggle the 'Search Headline' checkbox in the Find tab.'''
    return self.toggleOption('search_headline')

def toggleWholeWordOption (self, event):
    '''Toggle the 'Whole Word' checkbox in the Find tab.'''
    return self.toggleOption('whole_word')

def toggleWrapSearchOption (self, event):
    '''Toggle the 'Wrap Around' checkbox in the Find tab.'''
    return self.toggleOption('wrap')

def setFindScope (self, where):  self.getHandler().setFindScope(where)
def toggleOption (self, ivar):   self.getHandler().toggleOption(ivar)
</t>
<t tx="ekr.20090401102247.322">def changeAll(self,event=None):
    '''Execute the 'Change All' command with the settings shown in the Find tab.'''
    self.getHandler().changeAll(event)

def cloneFindAll (self,event):
    '''Do search-with-present-options and print all matches in the log pane. It
    also creates a node at the beginning of the outline containing clones of all
    nodes containing the 'find' string. Only one clone is made of each node,
    regardless of how many clones the node has, or of how many matches are found
    in each node.'''
    self.getHandler().cloneFindAll(event)

def findAll            (self,event):
    '''Do search-with-present-options and print all matches in the log pane.'''
    self.getHandler().findAll(event)

def replaceString      (self,event):
    '''Prompts for a search string. Type &lt;Return&gt; to end the search string. The
    command will then prompt for the replacement string. Typing a second
    &lt;Return&gt; key will place both strings in the Find tab and executes a **find**
    command, that is, the search-with-present-options command.'''
    self.getHandler().replaceString(event)

def reSearchBackward   (self,event):
    '''Set the 'Regexp' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().reSearchBackward(event)

def reSearchForward    (self,event):
    '''Set the 'Regexp' checkbox to True, then do search-with-present-options.'''
    self.getHandler().reSearchForward(event)

def searchBackward     (self,event):
    '''Set the 'Word Search' checkbox to False and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().searchBackward(event)

def searchForward      (self,event):
    '''Set the 'Word Search' checkbox to False, then do search-with-present-options.'''
    self.getHandler().searchForward(event)

def wordSearchBackward (self,event):
    '''Set the 'Word Search' checkbox to True, then do search-with-present-options.'''
    self.getHandler().wordSearchBackward(event)

def wordSearchForward  (self,event):
    '''Set the Word Search' checkbox to True and the 'Reverse' checkbox to True,
    then do search-with-present-options.'''
    self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    '''Prompts for a search string. Typing the &lt;Return&gt; key puts the search
    string in the Find tab and executes a search based on all the settings in
    the Find tab. Recommended as the default search command.'''
    self.getHandler().searchWithPresentOptions(event)
</t>
<t tx="ekr.20090401102247.323">def findAgain (self,event):

    '''The find-again command is the same as the find-next command
    if the search pattern in the Find tab is not '&lt;find pattern here&gt;'
    Otherwise, the find-again is the same as the search-with-present-options command.'''

    h = self.getHandler()

    # h.findAgain returns False if there is no search pattern.
    # In that case, we revert to search-with-present-options.
    if not h.findAgain(event):
        h.searchWithPresentOptions(event)
</t>
<t tx="ekr.20090401102247.324">def isearchForward (self,event):
    '''Begin a forward incremental search.'''
    self.startIncremental(event,'isearch-forward',
        forward=True,ignoreCase=False,regexp=False)

def isearchBackward (self,event):
    '''Begin a backward incremental search.'''
    self.startIncremental(event,'isearch-backward',
        forward=False,ignoreCase=False,regexp=False)

def isearchForwardRegexp (self,event):
    '''Begin a forward incremental regexp search.'''
    self.startIncremental(event,'isearch-forward-regexp',
        forward=True,ignoreCase=False,regexp=True)

def isearchBackwardRegexp (self,event):
    '''Begin a backard incremental regexp search.'''
    self.startIncremental(event,'isearch-backward-regexp',
        forward=False,ignoreCase=False,regexp=True)

def isearchWithPresentOptions (self,event):
    '''Begin an incremental regexp search using find panel options.'''
    self.startIncremental(event,'isearch-with-present-options',
        forward=None,ignoreCase=None,regexp=None)
</t>
<t tx="ekr.20090401102247.325">def abortSearch (self):

    '''Restore the original position and selection.'''

    c = self.c ; k = self.k ; w = c.frame.body.bodyCtrl

    k.clearState()
    k.resetLabel()

    p,i,j,in_headline = self.stack[0]
    self.ifinder.in_headline = in_headline
    c.selectPosition(p)
    c.redraw_after_select(p)
    c.bodyWantsFocusNow()
    w.setSelectionRange(i,j)

    # g.trace(p.h,i,j)
</t>
<t tx="ekr.20090401102247.326">def endSearch (self):

    c,k = self.c,self.k

    k.clearState()
    k.resetLabel()
    c.bodyWantsFocusNow()
</t>
<t tx="ekr.20090401102247.327">def iSearch (self,again=False):

    '''Handle the actual incremental search.'''

    c = self.c ; k = self.k ; p = c.p
    ifinder = self.ifinder
    reverse = not self.forward
    pattern = k.getLabel(ignorePrompt=True)
    if not pattern:
        return self.abortSearch()
    ifinder.c = c ; ifinder.p = p.copy()
    # Get the base ivars from the find tab.
    ifinder.update_ivars()
    # Save
    oldPattern = ifinder.find_text
    oldRegexp  = ifinder.pattern_match
    oldReverse = ifinder.reverse
    oldWord =  ifinder.whole_word
    # Override
    ifinder.pattern_match = self.regexp
    ifinder.reverse = reverse
    ifinder.find_text = pattern
    ifinder.whole_word = False # Word option can't be used!
    # Prepare the search.
    if len(self.stack) &lt;= 1: ifinder.in_headline = False
    w = self.setWidget()
    s = w.getAllText()
    i,j = w.getSelectionRange()
    if again:   ins = g.choose(reverse,i,j+len(pattern))
    else:       ins = g.choose(reverse,j+len(pattern),i)
    ifinder.init_s_ctrl(s,ins)
    # Do the search!
    pos, newpos = ifinder.findNextMatch()
    # Restore.
    ifinder.find_text = oldPattern
    ifinder.pattern_match = oldRegexp
    ifinder.reverse = oldReverse
    ifinder.whole_word = oldWord
    # Handle the results of the search.
    if pos is not None: # success.
        w = ifinder.showSuccess(pos,newpos,showState=False)
        if w: i,j = w.getSelectionRange(sort=False)
        # else: g.trace('****')
        if not again: self.push(c.p,i,j,ifinder.in_headline)
    elif ifinder.wrapping:
        g.es("end of wrapped search")
    else:
        g.es("not found","'%s'" % (pattern))
        event = g.Bunch(char='\b',keysym='\b',stroke='BackSpace')
        k.updateLabel(event)
</t>
<t tx="ekr.20090401102247.328"># Called from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    trace = False and not g.unitTesting
    c = self.c ; k = self.k
    stroke = event.stroke
    if trace: g.trace('stroke',repr(stroke))

    # No need to recognize ctrl-z.
    if stroke in ('Escape','Return'):
        self.endSearch()
    elif stroke in self.iSearchStrokes:
        self.iSearch(again=True)
    elif stroke == 'BackSpace':
        k.updateLabel(event)
        self.iSearchBackspace()
    elif stroke.startswith('Ctrl+') or stroke.startswith('Alt+'):
        # End the search and execute the command.
        self.endSearch()
        k.masterKeyHandler(event,stroke=stroke)
    else:
        if trace: g.trace('event',event)
        k.updateLabel(event)
        self.iSearch()</t>
<t tx="ekr.20090401102247.329">def iSearchBackspace (self):

    trace = False and not g.unitTesting
    c = self.c ; ifinder = self.ifinder

    if len(self.stack) &lt;= 1:
        self.abortSearch()
        return

    # Reduce the stack by net 1.
    junk = self.pop()
    p,i,j,in_headline = self.pop()
    self.push(p,i,j,in_headline)
    if trace: g.trace(p.h,i,j,in_headline)

    if in_headline:
        # Like ifinder.showSuccess.
        selection = i,j,i
        c.redrawAndEdit(p,selectAll=False,
            selection=selection,
            keepMinibuffer=True)
    else:
        c.selectPosition(p)
        w = c.frame.body.bodyCtrl
        c.bodyWantsFocusNow()
        if i &gt; j: i,j = j,i
        w.setSelectionRange(i,j)

    if len(self.stack) &lt;= 1:
        self.abortSearch()



</t>
<t tx="ekr.20090401102247.330">def getStrokes (self,commandName):

    c = self.c

    aList = self.inverseBindingDict.get(commandName,[])
    return [key for pane,key in aList]
</t>
<t tx="ekr.20090401102247.331">def push (self,p,i,j,in_headline):

    data = p.copy(),i,j,in_headline
    self.stack.append(data)

def pop (self):

    data = self.stack.pop()
    p,i,j,in_headline = data
    return p,i,j,in_headline
</t>
<t tx="ekr.20090401102247.332">def setWidget (self):

    c = self.c ; p = c.currentPosition()
    bodyCtrl = c.frame.body.bodyCtrl
    ifinder = self.ifinder

    if ifinder.in_headline:
        w = c.edit_widget(p)
        if not w:
            # Selecting the minibuffer can kill the edit widget.
            selection = 0,0,0
            c.redrawAndEdit(p,selectAll=False,
                selection=selection,keepMinibuffer=True)
            w = c.edit_widget(p)
        if not w: # Should never happen.
            g.trace('**** no edit widget!')
            ifinder.in_headline = False ; w = bodyCtrl
    else:
        w = bodyCtrl
    if w == bodyCtrl:
        c.bodyWantsFocusNow()
    return w
</t>
<t tx="ekr.20090401102247.333">def startIncremental (self,event,commandName,forward,ignoreCase,regexp):

    c = self.c ; k = self.k

    # None is a signal to get the option from the find tab.

    if forward is None or not self.findTabHandler:
        self.openFindTab(show=False)

    self.ifinder = self.findTabHandler

    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    getOption = self.minibufferFindHandler.getOption

    self.event = event
    self.forward    = g.choose(forward is None,not getOption('reverse'),forward)
    self.ignoreCase = g.choose(ignoreCase is None,getOption('ignore_case'),ignoreCase)
    self.regexp     = g.choose(regexp  is None,getOption('pattern_match'),regexp)
    # Note: the word option can't be used with isearches!

    self.w = w = c.frame.body.bodyCtrl
    self.p1 = c.p.copy()
    self.sel1 = w.getSelectionRange(sort=False)
    i,j = self.sel1
    self.push(c.p,i,j,self.ifinder.in_headline)
    self.inverseBindingDict = k.computeInverseBindingDict()
    self.iSearchStrokes = self.getStrokes(commandName)

    k.setLabelBlue('Isearch%s%s%s: ' % (
            g.choose(self.forward,'',' Backward'),
            g.choose(self.regexp,' Regexp',''),
            g.choose(self.ignoreCase,' NoCase',''),
        ),protect=True)

    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocusNow()
</t>
<t tx="ekr.20090401102247.334">def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=[],completion=True,oneCharacter=False,
    stroke=None, # New in 4.4.1.
    useMinibuffer=True # New in 4.4.1
):

    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; gui  = g.app.gui
    state = k.getState('getArg')
    keysym = gui.eventKeysym(event)
    trace = False or (c.config.getBool('trace_modes') and not g.app.unitTesting)
    if trace: g.trace(
        'state',state,'keysym',keysym,'stroke',stroke,'escapes',k.getArgEscapes,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = ''
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if useMinibuffer: c.minibufferWantsFocusNow()
    elif keysym == 'Escape':
        k.keyboardQuit(event)
    elif keysym == 'Return' or k.oneCharacterArg or (stroke and stroke in k.getArgEscapes):
        if stroke and stroke in k.getArgEscapes: k.getArgEscape = stroke
        if k.oneCharacterArg:
            k.arg = event.char
        else:
            k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        trace and g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'
</t>
<t tx="ekr.20090401102247.335">k.argTabList = tabList and tabList[:] or []
k.arg_completion = completion
# g.trace('completion',completion,'tabList',tabList)

k.mb_prefix = prefix or k.getLabel()
k.mb_prompt = prefix or ''
k.mb_tabList = []

# Clear the list: any non-tab indicates that a new prefix is in effect.
k.mb_tabListPrefix = k.getLabel()
k.oneCharacterArg = oneCharacter
</t>
<t tx="ekr.20090401102247.336"></t>
<t tx="ekr.20090401102247.337"># The bug was due to a duplicate call to c.endEditing.
# It only affected the qt gui.</t>
<t tx="ekr.20090401102247.338"># To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    '''Paste an outline into the present outline from the clipboard.
    Nodes do *not* retain their original identify.'''

    c = self ; u = c.undoer ; current = c.p
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    tnodeInfoDict = {}
    if pasteAsClone:
        &lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;
    # create a *position* to be pasted.
    if isLeo:
        pasted = c.fileCommands.getLeoOutlineFromClipboard(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)

    if not pasted: return

    copiedBunchList = []
    if pasteAsClone:
        &lt;&lt; put only needed info in copiedBunchList &gt;&gt;
    undoData = u.beforeInsertNode(current,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)

    c.validateOutline()
    c.selectPosition(pasted)
    pasted.setDirty()
    c.setChanged(True)
    # paste as first child if back is expanded.
    back = pasted.back()
    if back and back.isExpanded():
        pasted.moveToNthChildOf(back,0)
    c.setRootPosition(c.findRootPosition(pasted)) # New in 4.4.2.
    u.afterInsertNode(pasted,undoType,undoData)
    c.redraw(pasted)
    c.recolor()
</t>
<t tx="ekr.20090401102247.339">@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for v in c.all_unique_vnodes_iter():
    t = v.t
    if t not in tnodeInfoDict:
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=v.headString(),body=v.b)
</t>
<t tx="ekr.20090401102247.340"># Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t

# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict:
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
</t>
<t tx="ekr.20090401102247.341">@nocolor-node

To reproduce:

1. open .leo file: 'leo a3_report.leo'
2. turn the top 10 non-directive lines of the file into a &lt;&lt;test&gt;&gt; section
3. save the file (ctrl-s)
4. close leo
5. start leo
6. open the a3_report.leo file again.

now you should see the problem in the log window.

===============

base directory: c:\prog\leo_shadow_problem


updated private .leo_shadow\xa3-report.tex from public a3-report.tex

Bad @+leo sentinel in: .leo_shadow\xa3-report.tex

readOpenFile: run,createFrame,openWithFileName,open,getLeoFile,readAll,readOneAtShadowNode,read
readOpenFile: invalid @shadow private file .leo_shadow\xa3-report.tex

invalid @shadow private file .leo_shadow\xa3-report.tex
</t>
<t tx="ekr.20090401102247.342"># Internally, lower case is used for all language names.
self.language_delims_dict = {
    # Keys are languages, values are 1,2 or 3-tuples of delims.
    "ada"           : "--",
    "batch"         : "REM", # Leo 4.5.1
    "actionscript"  : "// /* */", #jason 2003-07-03
    "autohotkey"    : "; /* */", #TL - AutoHotkey language
    "c"             : "// /* */", # C, C++ or objective C.
    "config"        : "#", # Leo 4.5.1
    "csharp"        : "// /* */", # C#
    "cpp"           : "// /* */",# C++.
    "css"           : "/* */", # 4/1/04
    "cweb"          : "@q@ @&gt;", # Use the "cweb hack"
    "elisp"         : ";",
    "forth"         : "\\_ _(_ _)", # Use the "REM hack"
    "fortran"       : "C",
    "fortran90"     : "!",
    "html"          : "&lt;!-- --&gt;",
    "ini"           : ";",
    "java"          : "// /* */",
    "kshell"        : "#", # Leo 4.5.1.
    "latex"         : "%",
    "lua"           : "--",  # ddm 13/02/06
    "noweb"         : "%", # EKR: 2009-01-30. Use Latex for doc chunks.
    "pascal"        : "// { }",
    "perl"          : "#",
    "perlpod"       : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php"           : "// /* */", # 6/23/07: was "//",
    "plain"         : "#", # We must pick something.
    "plsql"         : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python"        : "#",
    "rapidq"        : "'", # fil 2004-march-11
    "rebol"         : ";",  # jason 2003-07-03
    "ruby"          : "#",  # thyrsus 2008-11-05
    "shell"         : "#",  # shell scripts
    "tcltk"         : "#",
    "tex"           : "%", # Bug fix: 2008-1-30: Fixed Mark Edginton's bug.
    "unknown"       : "#", # Set when @comment is seen.
    "unknown_language" : '#--unknown-language--', # For unknown extensions in @shadow files.
    "vimoutline"    : "#",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "&lt;!-- --&gt;",
    "xslt"          : "&lt;!-- --&gt;",
}

self.language_extension_dict = {
    # Keys are languages, values are extensions.
    "ada"           : "ada",
    "actionscript"  : "as", #jason 2003-07-03
    "autohotkey"    : "ahk", #TL - AutoHotkey language
    "batch"         : "bat", # Leo 4.5.1.
    "c"             : "c",
    "config"        : "cfg",
    "cpp"           : "cpp",
    "css"           : "css", # 4/1/04
    "cweb"          : "w",
    "elisp"         : "el",
    "forth"         : "forth",
    "fortran"       : "f",
    "fortran90"     : "f",
    "html"          : "html",
    "ini"           : "ini",
    "java"          : "java",
    "kshell"        : "ksh", # Leo 4.5.1.
    "latex"         : "tex", # 1/8/04
    "lua"           : "lua",  # ddm 13/02/06
    "noweb"         : "nw",
    "pascal"        : "p",
    "perl"          : "pl",      # 11/7/05
    "perlpod"       : "pod",  # 11/7/05
    "php"           : "php",
    "plain"         : "txt",
    "python"        : "py",
    "plsql"         : "sql", # qt02537 2005-05-27
    "rapidq"        : "bas", # fil 2004-march-11
    "rebol"         : "r",    # jason 2003-07-03
    "ruby"          : "rb",   # thyrsus 2008-11-05
    "shell"         : "sh",   # DS 4/1/04
    "tex"           : "tex",
    "tcltk"         : "tcl",
    "unknown"       : "txt", # Set when @comment is seen.
    "vimoutline"    : "otl",  #TL 8/25/08 Vim's outline plugin
    "xml"           : "xml",
    "xslt"          : "xsl",
}

self.extension_dict = {
    # Keys are extensions, values are languages.
    "ada"   : "ada",
    "adb"   : "ada",
    "ahk"   : "autohotkey",  # EKR: 2009-01-30.
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "bat"   : "batch",
    "c"     : "c",
    "cfg"   : "config",
    "cpp"   : "cpp",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "h"     : "c",
    "html"  : "html",
    "ini"   : "ini",
    "java"  : "java",
    "ksh"   : "kshell", # Leo 4.5.1.
    "lua"   : "lua",  # ddm 13/02/06
    "nw"    : "noweb",
    "otl"   : "vimoutline",  #TL 8/25/08 Vim's outline plugin
    "p"     : "pascal",
    "pl"    : "perl",   # 11/7/05
    "pod"   : "perlpod", # 11/7/05
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "rb"    : "ruby", # thyrsus 2008-11-05
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb",
    "xml"   : "xml",
    "xsl"   : "xslt",
}

# Extra language extensions, used to associate extensions with mode files.
# Used by importCommands.languageForExtension.
# Keys are extensions, values are corresponding mode file (without .py)
# A value of 'none' is a signal to unit tests that no extension file exists.
self.extra_extension_dict = {
    'actionscript': 'actionscript',
    'ada'   : 'ada95',
    'adb'   : 'none', # ada??
    'awk'   : 'awk',
    'bas'   : 'none', # rapidq
    'bat'   : 'none', # batch
    'cfg'   : 'none', # Leo 4.5.1
    'cpp'   : 'c',
    'el'    : 'lisp',
    'f'     : 'fortran',
    'ksh'   : 'none', # Leo 4.5.1
    'nw'    : 'none', # noweb.
    'otl'   : 'none', # vimoutline.
    'pod'   : 'perl',
    'tcl'   : 'tcl',
    'unknown_language': 'none',
    'w'     : 'none', # cweb
}</t>
<t tx="ekr.20090401102247.343"># No changes were made here, except to traces.</t>
<t tx="ekr.20090401102247.344"># This has an up arrow for a control key.

def selectVisBack (self,event=None):

    '''Select the visible node preceding the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisBack(): return

    p.moveToVisBack(c)
    c.treeSelectHelper(p)
</t>
<t tx="ekr.20090401102247.345">def selectVisNext (self,event=None):

    '''Select the visible node following the presently selected node.'''

    c = self ; p = c.p
    if not p: return
    if not c.canSelectVisNext(): return

    p.moveToVisNext(c)
    c.treeSelectHelper(p)
</t>
<t tx="ekr.20090401102247.346"># treeSelectHelper cause a redraw only if the new item isn't visible.
# That is, the redraw flag isn't used, and will be eventually removed.</t>
<t tx="ekr.20090401102247.347">def goToParent (self,event=None):

    '''Select the parent of the selected node.'''

    c = self ; p = c.p

    c.treeSelectHelper(p and p.parent())
</t>
<t tx="ekr.20090401102247.348">def treeSelectHelper (self,p):

    c = self

    if not p: p = c.p

    if p:
        # Do not call expandAllAncestors here.
        c.selectPosition(p)
        c.redraw_after_select(p)

    c.treeFocusHelper()
</t>
<t tx="ekr.20090401102247.349"></t>
<t tx="ekr.20090401102247.350">class baseTextWidget:

    '''The base class for all wrapper classes for leo Text widgets.'''

    @others
</t>
<t tx="ekr.20090401102247.351">def __init__ (self,c,baseClassName,name,widget,highLevelInterface=False):

    self.baseClassName = baseClassName
    self.c = c
    self.highLevelInterface = highLevelInterface
    self.name = name
    self.virtualInsertPoint = None
    self.widget = widget # Not used at present.

    # For unit testing.
    aList = g.choose(highLevelInterface,
        self.mustBeDefinedInHighLevelSubclasses,
        self.mustBeDefinedInLowLevelSubclasses)
    self.mustBeDefinedInSubclasses.extend(aList)
    # g.trace(g.listToString(self.mustBeDefinedInSubclasses))

def __repr__(self):
    return '%s: %s' % (self.baseClassName,id(self))
</t>
<t tx="ekr.20090401102247.352">mustBeDefinedOnlyInBaseClass = (
    'clipboard_append', # uses g.app.gui method.
    'clipboard_clear', # usesg.app.gui method.
    'onChar',
)</t>
<t tx="ekr.20090401102247.353">@
The subclass must implement all high-level wrappers or all low-level wrappers,
depending on the highLevelWrapper ivar. The ctor extends .mustBeDefinedInSubclasses
by one of the following lists:
@c

mustBeDefinedInSubclasses = [
]

mustBeDefinedInHighLevelSubclasses = (
    'appendText',
    'get',
    'getAllText',
    'getFocus',
    'getInsertPoint',
    'getSelectedText',
    'getSelectionRange',
    'getYScrollPosition',
    'insert',
    'scrollLines',
    'see',
    'seeInsertPoint',
    'setAllText',
    'setBackgroundColor',
    'setForegroundColor',
    'setFocus',
    'setInsertPoint',
    'setSelectionRange',
    'setYScrollPosition',
)

mustBeDefinedInLowLevelSubclasses = (
    '_appendText',
    '_get',
    '_getAllText',
    '_getFocus',
    '_getInsertPoint',
    '_getLastPosition',
    '_getSelectedText',
    '_getSelectionRange',
    '_getYScrollPosition',
    '_hitTest',
    '_insertText',
    '_scrollLines',
    '_see',
    '_setAllText',
    '_setBackgroundColor',
    '_setFocus',
    '_setForegroundColor',
    '_setInsertPoint',
    '_setSelectionRange',
    '_setYScrollPosition',
)</t>
<t tx="ekr.20090401102247.354">
mustBeDefined = (
    'bind',
    'flashCharacter',
    'deleteTextSelection',
)
</t>
<t tx="ekr.20090401102247.355"></t>
<t tx="ekr.20090401102247.356"># Don't even think of using key up/down events.
# They don't work reliably and don't support auto-repeat.

def onChar (self, event):

    c = self.c
    keycode = event.GetKeyCode()
    event.leoWidget = self
    keysym = g.app.gui.eventKeysym(event)
    #g.trace('text: keycode %3s keysym %s' % (keycode,keysym))
    if keysym:
        c.k.masterKeyHandler(event,stroke=keysym)
        c.outerUpdate()</t>
<t tx="ekr.20090401102247.357">def clipboard_clear (self):

    g.app.gui.replaceClipboardWith('')

def clipboard_append(self,s):

    s1 = g.app.gui.getTextFromClipboard()

    g.app.gui.replaceClipboardWith(s1 + s)
</t>
<t tx="ekr.20090401102247.358"># These are high-level interface methods that do not call low-level methods.</t>
<t tx="ekr.20090401102247.359">def bind (self,kind,*args,**keys):          pass
def getWidth (self):                        return 0
def flashCharacter(self,i,bg='white',fg='red',flashes=3,delay=75):
    pass
def indexIsVisible (self,i):                return False
    # Code will loop if this returns True forever.
def mark_set(self,markName,i):              pass
def setWidth (self,width):                  pass
def tag_add(self,tagName,i,j=None,*args):   pass
def tag_configure (self,colorName,**keys):  pass
def tag_delete (self,tagName,*args,**keys): pass
def tag_names (self, *args):                return []
def tag_ranges(self,tagName):               return tuple()
def tag_remove(self,tagName,i,j=None,*args):pass
def update (self,*args,**keys):             pass
def update_idletasks (self,*args,**keys):   pass
def xyToPythonIndex (self,x,y):             return 0
def yview (self,*args):                     return 0,0

tag_config = tag_configure</t>
<t tx="ekr.20090401102247.360">def toPythonIndexRowCol(self,index):

    w = self
    s = w.getAllText()
    i = w.toPythonIndex(index)
    row,col = g.convertPythonIndexToRowCol(s,i)
    return i,row,col
</t>
<t tx="ekr.20090401102247.361">def delete(self,i,j=None):

    w = self
    i = w.toPythonIndex(i)
    if j is None: j = i+ 1
    j = w.toPythonIndex(j)

    # g.trace(i,j,len(s),repr(s[:20]))
    s = w.getAllText()
    w.setAllText(s[:i] + s[j:])
</t>
<t tx="ekr.20090401102247.362">def deleteTextSelection (self):

    i,j = self.getSelectionRange()
    self.delete(i,j)
</t>
<t tx="ekr.20090401102247.363">def event_generate(self,stroke):

    trace = False
    w = self ; c = self.c ; char = stroke

    # Canonicalize the setting.
    stroke = c.k.shortcutFromSetting(stroke)

    if trace: g.trace('baseTextWidget','char',char,'stroke',stroke,'w',w)

    class eventGenerateEvent:
        def __init__ (self,c,w,char,keysym):
            self.c = c
            self.char = char
            self.keysym = keysym
            self.leoWidget = w
            self.widget = w

    event = eventGenerateEvent(c,w,char,stroke)
    c.k.masterKeyHandler(event,stroke=stroke)
    c.outerUpdate()
</t>
<t tx="ekr.20090401102247.364">def GetName(self):

    return self.name

getName = GetName</t>
<t tx="ekr.20090401102247.365">def hasSelection (self):

    w = self
    i,j = w.getSelectionRange()
    return i != j
</t>
<t tx="ekr.20090401102247.366">def oops (self):

    g.pr('baseTextWidget oops:',self,g.callers(4),
        'must be overridden in subclass')
</t>
<t tx="ekr.20090401102247.367">def replace (self,i,j,s):

    w = self
    w.delete(i,j)
    w.insert(i,s)
</t>
<t tx="ekr.20090401102247.368">def selectAllText (self,insert=None):

    '''Select all text of the widget.'''

    w = self
    w.setSelectionRange(0,'end',insert=insert)
</t>
<t tx="ekr.20090401102247.369"># This method is called only from the colorizer.
# It provides a huge speedup over naive code.

def rowColToGuiIndex (self,s,row,col):

    return g.convertRowColToPythonIndex(s,row,col)    
</t>
<t tx="ekr.20090401102247.370">def toPythonIndex (self,index):

    w = self

    if type(index) == type(99):
        return index
    elif index == '1.0':
        return 0
    elif index == 'end':
        return w._getLastPosition()
    else:
        # g.trace(repr(index))
        s = w._getAllText()
        row,col = index.split('.')
        row,col = int(row),int(col)
        i = g.convertRowColToPythonIndex(s,row-1,col)
        # g.trace(index,row,col,i,g.callers(6))
        return i

toGuiIndex = toPythonIndex</t>
<t tx="ekr.20090401102247.371"># Define these here to keep pylint happy.

def _appendText(self,s):            self.oops()
def _get(self,i,j):                 self.oops() ; return ''
def _getAllText(self):              self.oops() ; return ''
def _getFocus(self):                self.oops() ; return None
def _getInsertPoint(self):          self.oops() ; return 0
def _getLastPosition(self):         self.oops() ; return 0
def _getSelectedText(self):         self.oops() ; return ''
def _getSelectionRange(self):       self.oops() ; return (0,0)
def _getYScrollPosition(self):      self.oops() ; return None # A flag
def _hitTest(self,pos):             self.oops()
def _insertText(self,i,s):          self.oops()
def _scrollLines(self,n):           self.oops()
def _see(self,i):                   self.oops()
def _setAllText(self,s):            self.oops()
def _setBackgroundColor(self,color): self.oops()
def _setForegroundColor(self,color): self.oops()
def _setFocus(self):                self.oops()
def _setInsertPoint(self,i):        self.oops()
def _setSelectionRange(self,i,j):   self.oops()
def _setYScrollPosition(self,i):    self.oops()

_findFocus = _getFocus
</t>
<t tx="ekr.20090401102247.372"># These methods are widget-independent because they call the corresponding _xxx methods.</t>
<t tx="ekr.20090401102247.373">def appendText (self,s):

    w = self
    w._appendText(s)
</t>
<t tx="ekr.20090401102247.374">def get(self,i,j=None):

    w = self

    i = w.toPythonIndex(i)
    if j is None: j = i+ 1
    j = w.toPythonIndex(j)

    s = w._get(i,j)
    return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20090401102247.375">def getAllText (self):

    w = self

    s = w._getAllText()
    return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20090401102247.376">def getFocus (self):

    w = self
    w2 = w._getFocus()
    # g.trace('w',w,'focus',w2)
    return w2

findFocus = getFocus
</t>
<t tx="ekr.20090401102247.377">def getInsertPoint(self):

    w = self
    i = w._getInsertPoint()

    # g.trace(self,'baseWidget: i:',i,'virtual',w.virtualInsertPoint)

    if i is None:
        if w.virtualInsertPoint is None:
            i = 0
        else:
            i = w.virtualInsertPoint

    w.virtualInsertPoint = i

    return i
</t>
<t tx="ekr.20090401102247.378">def getSelectedText (self):

    w = self
    s = w._getSelectedText()
    return g.toUnicode(s,g.app.tkEncoding)
</t>
<t tx="ekr.20090401102247.379">def getSelectionRange (self,sort=True):

    """Return a tuple representing the selected range of the widget.

    Return a tuple giving the insertion point if no range of text is selected."""

    w = self

    sel = w._getSelectionRange() # wx.richtext.RichTextCtrl returns (-1,-1) on no selection.
    if len(sel) == 2 and sel[0] &gt;= 0 and sel[1] &gt;= 0:
        #g.trace(self,'baseWidget: sel',repr(sel),g.callers(6))
        i,j = sel
        if sort and i &gt; j: sel = j,i # Bug fix: 10/5/07
        return sel
    else:
        # Return the insertion point if there is no selected text.
        i =  w._getInsertPoint()
        #g.trace(self,'baseWidget: i',i,g.callers(6))
        return i,i
</t>
<t tx="ekr.20090401102247.380">def getYScrollPosition (self):

    w = self
    return w._getYScrollPosition()
</t>
<t tx="ekr.20090401102247.381"># The signature is more restrictive than the Tk.Text.insert method.

def insert(self,i,s):

    w = self
    i = w.toPythonIndex(i)
    # w._setInsertPoint(i)
    w._insertText(i,s)
</t>
<t tx="ekr.20090401102247.382">def scrollLines (self,n):

    w = self
    w._scrollLines(n)</t>
<t tx="ekr.20090401102247.383">def see(self,index):

    w = self
    i = self.toPythonIndex(index)
    w._see(i)

def seeInsertPoint(self):

    w = self
    i = w._getInsertPoint()
    w._see(i)
</t>
<t tx="ekr.20090401102247.384">def setAllText (self,s):

    w = self
    w._setAllText(s)</t>
<t tx="ekr.20090401102247.385">def setBackgroundColor (self,color):

    w = self

    # Translate tk colors to wx colors.
    d = { 'lightgrey': 'light grey', 'lightblue': 'leo blue',}

    color = d.get(color,color)

    return w._setBackgroundColor(color)

SetBackgroundColour = setBackgroundColor</t>
<t tx="ekr.20090401102247.386">def setFocus (self):

    w = self
    # g.trace('baseText')
    return w._setFocus()

SetFocus = setFocus
</t>
<t tx="ekr.20090401102247.387">def setForegroundColor (self,color):

    w = self

    # Translate tk colors to wx colors.
    d = { 'lightgrey': 'light grey', 'lightblue': 'leo blue',}

    color = d.get(color,color)

    return w._setForegroundColor(color)

SetForegroundColour = setForegroundColor</t>
<t tx="ekr.20090401102247.388">def setInsertPoint (self,pos):

    w = self
    w.virtualInsertPoint = i = w.toPythonIndex(pos)
    # g.trace(self,i)
    w._setInsertPoint(i)
</t>
<t tx="ekr.20090401102247.389">def setSelectionRange (self,i,j,insert=None):

    w = self
    i1, j1, insert1 = i,j,insert
    i,j = w.toPythonIndex(i),w.toPythonIndex(j)

    # g.trace(self,'baseWidget',repr(i1),'=',repr(i),repr(j1),'=',repr(j),repr(insert1),'=',repr(insert),g.callers(4))

    if i == j:
        w._setInsertPoint(j)
    else:
        w._setSelectionRange(i,j)

    if insert is not None and insert in (i,j):
        ins = w.toPythonIndex(insert)
        if ins in (i,j):
            self.virtualInsertPoint = ins
</t>
<t tx="ekr.20090401102247.390">def setYScrollPosition (self,i):

    w = self
    w._setYScrollPosition(i)</t>
<t tx="ekr.20090401102247.391">master_key_count = 0

def masterKeyHandler (self,event,stroke=None):

    '''This is the handler for almost all key bindings.'''

    &lt;&lt; define vars &gt;&gt;
    trace = False and not g.app.unitTesting # or self.trace_masterKeyHandler)
    traceGC = self.trace_masterKeyHandlerGC and not g.app.unitTesting
    verbose = True

    if keysym in special_keys:
        if trace and verbose: g.trace('keysym',keysym)
        return None
    if traceGC: g.printNewObjects('masterKey 1')
    if trace:
        g.trace('stroke:',repr(stroke),'keysym:',
            repr(event.keysym),'ch:',repr(event.char),'state',state)
        # g.trace('callers',g.callers(5))
            # 'state.kind:',k.state.kind),'\n',g.callers())
        # if (self.master_key_count % 100) == 0: g.printGcSummary()

    # if stroke == 'Return': g.pdb()

    # Handle keyboard-quit first.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        # g.trace('special case')
        if c.macroCommands.recordingMacro:
            c.macroCommands.endKbdMacro()
            return 'break'
        else:
            return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')

    if k.inState():
        # This will return unless k.autoCompleterStateHandler
        # (called from k.callStateFunction) returns 'do-standard-keys'
        &lt;&lt; handle mode bindings &gt;&gt;

    if traceGC: g.printNewObjects('masterKey 2')

    if stroke and isPlain:
        &lt;&lt; handle special cases for plain keys &gt;&gt;

    &lt;&lt; handle per-pane bindings &gt;&gt;

    if traceGC: g.printNewObjects('masterKey 5')

    return k.handleUnboundKeys(event,char,keysym,stroke)
</t>
<t tx="ekr.20090401102247.392">k = self ; c = k.c ; gui = g.app.gui

if event:
    # This is a leoGui base class event.
    event = gui.leoKeyEvent(event,c,stroke=stroke)

w = event.widget
char = event.char
keysym = event.keysym
if stroke and not keysym:
    event.keysym = keysym = stroke

w_name = c.widget_name(w)
state = k.state.kind

special_keys = (
    'Alt_L','Alt_R',
    'Caps_Lock','Control_L','Control_R',
    'Meta_L','Meta_R', # Meta support.
    'Num_Lock',
    'Shift_L','Shift_R',
    'Win_L','Win_R',
)

self.master_key_count += 1

isPlain =  k.isPlainKey(stroke)</t>
<t tx="ekr.20090401102247.393"># First, honor minibuffer bindings for all except user modes.

if state in ('getArg','getFileName','full-command','auto-complete'):
    if k.handleMiniBindings(event,state,stroke):
        return 'break'

# Second, honor general modes.
if state == 'getArg':
    return k.getArg(event,stroke=stroke)
elif state == 'getFileName':
    return k.getFileName(event)
elif state in ('full-command','auto-complete'):
    # Do the default state action.
    if trace: g.trace('calling state function',k.state.kind) # k.state.handler)
    val = k.callStateFunction(event) # Calls end-command.
    if val != 'do-standard-keys': return 'break'

# Third, pass keys to user modes.
else:
    d =  k.masterBindingsDict.get(state)
    if d:
        b = d.get(stroke)
        if b:
            if trace: g.trace('calling generalModeHandler',stroke)
            k.generalModeHandler (event,
                commandName=b.commandName,func=b.func,
                modeName=state,nextMode=b.nextMode)
            return 'break'
        else:
            # New in Leo 4.5: unbound keys end mode.
            if trace: g.trace('unbound key ends mode',stroke,state)
            k.endMode(event)
    else:
        # New in 4.4b4.
        handler = k.getStateHandler()
        if handler:
            handler(event)
        else:
            g.trace('No state handler for %s' % state)
        return 'break'
</t>
<t tx="ekr.20090401102247.394"># g.trace('plain key','state',k.unboundKeyAction,'stroke',stroke)

# Important: only keys bound somewhere have a stroke.
# All unbound plain keys will be handled by handleUnboundKeys.

if k.unboundKeyAction in ('insert','overwrite'):

    for key in (k.unboundKeyAction,'body','log','text','all'):
        # Ignore bindings for all plain keys in insert/overwrite mode *except* auto-complete.
        d = k.masterBindingsDict.get(key,{})
        if d:
            b = d.get(stroke)
            if b and b.commandName == 'auto-complete':
                if trace: g.trace('%s: auto-complete key in %s mode' % (stroke,k.unboundKeyAction))
                k.masterCommand(event,b.func,b.stroke,b.commandName)
                return 'break'

    if trace: g.trace('unbound key: %s in %s mode' % (stroke,k.unboundKeyAction))
    k.masterCommand(event,func=None,stroke=stroke,commandName=None)
    return 'break'

# Bound   plain keys in command mode are by the per-pane logic.
# Unbound plain keys in command mode are ignored by handleUnboundKeys.

# This code ignores all command-state keys if we are not in a text widget.
elif k.unboundKeyAction == 'command':
    if not g.app.gui.isTextWidget(w):
        c.onCanvasKey(event)
        return 'break'</t>
<t tx="ekr.20090401102247.395">keyStatesTuple = ('command','insert','overwrite')

# g.trace('w_name',w_name,'stroke',stroke,'w',w,'isTextWidget(w)',g.app.gui.isTextWidget(w))

for key,name in (
    # Order here is similar to bindtags order.
    ('command',None),
    ('insert',None),
    ('overwrite',None),
    ('button',None),
    ('body','body'),
    ('text','head'), # Important: text bindings in head before tree bindings.
    ('tree','head'),
    ('tree','canvas'),
    ('log', 'log'),
    ('text','log'),
    ('text',None),
    ('all',None),
):
    if (
        # key in keyStatesTuple and isPlain and k.unboundKeyAction == key or
        name and w_name.startswith(name) or
        key in ('text','all') and g.app.gui.isTextWidget(w) or
        key in ('button','all')
    ):
        d = k.masterBindingsDict.get(key,{})
        # g.trace('key',key,'name',name,'stroke',stroke,'stroke in d.keys',stroke in d)
        # g.trace(key,'keys',g.listToString(d.keys(),sort=True)) # [:5])
        if d:
            b = d.get(stroke)
            if b:
                if trace: g.trace('%s found %s = %s' % (key,repr(b.stroke),b.commandName))
                if traceGC: g.printNewObjects('masterKey 3')
                return k.masterCommand(event,b.func,b.stroke,b.commandName)
</t>
<t tx="ekr.20090401102247.396">def callStateFunction (self,event):

    k = self ; val = None ; ch = g.app.gui.eventChar(event)

    # g.trace(k.state.kind,'ch',ch,'ignore-non-ascii',k.ignore_unbound_non_ascii_keys)

    if k.state.kind:
        if (
            k.ignore_unbound_non_ascii_keys and
            ch and ch not in ('\b','\n','\r','\t') and
            (ord(ch) &lt; 32 or ord(ch) &gt; 128)
        ):
            # g.trace('non-ascii',ord(ch))
            pass
        elif k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for',k.state.kind,color='red')

    return val
</t>
<t tx="ekr.20090401102247.397">def handleMiniBindings (self,event,state,stroke):

    k = self ; c = k.c
    trace = False or (self.trace_masterKeyHandler and not g.app.unitTesting)

    # Special case for bindings handled in k.getArg:
    if state in ('getArg','full-command'):
        if stroke in ('BackSpace','Return','Tab','Escape'):
            return False

    if not state.startswith('auto-'):
        # New in Leo 4.5: ignore plain key binding in the minibuffer.
        if not stroke or k.isPlainKey(stroke):
            if trace: g.trace('plain key',stroke)
            return False
        # New in Leo 4.5: The minibuffer inherits 'text' and 'all' bindings
        # for all single-line editing commands.
        for pane in ('mini','all','text'):
            d = k.masterBindingsDict.get(pane)
            if d:
                b = d.get(stroke)
                if b:
                    if b.commandName == 'replace-string' and state == 'getArg':
                        if trace: g.trace('%s binding for replace-string' % (pane),stroke)
                        return False # Let getArg handle it.
                    elif b.commandName not in k.singleLineCommandList:
                        if trace: g.trace('%s binding terminates minibuffer' % (pane),b.commandName,stroke)
                        k.keyboardQuit(event,hideTabs=True)
                    else:
                        if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                        c.minibufferWantsFocusNow() # New in Leo 4.5.
                    # Pass this on for macro recording.
                    k.masterCommand(event,b.func,stroke,b.commandName)
                    # Careful: the command could exit.
                    if c.exists and not k.silentMode:
                        c.minibufferWantsFocus()
                    return True

    return False
</t>
<t tx="ekr.20090401102247.398">def handleUnboundKeys (self,event,char,keysym,stroke):

    k = self ; c = k.c ; trace = False
    modesTuple = ('insert','overwrite')

    if trace:
        # if stroke: g.trace('***unexpected stroke***')
        g.trace('keysym:',repr(event.keysym),'ch:',repr(event.char))
            # 'state.kind:',k.state.kind),'\n',g.callers())
        # if (self.master_key_count % 100) == 0: g.printGcSummary()

    if k.unboundKeyAction == 'command':
        # Ignore all unbound characters in command mode.
        w = g.app.gui.get_focus(c)
        if w and g.app.gui.widget_name(w).lower().startswith('canvas'):
            c.onCanvasKey(event)
        return 'break'

    elif stroke and k.isPlainKey(stroke) and k.unboundKeyAction in modesTuple:
        # insert/overwrite normal character.  &lt;Return&gt; is *not* a normal character.
        if trace: g.trace('plain key in insert mode',repr(stroke))
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)

    elif k.ignore_unbound_non_ascii_keys and len(char) &gt; 1:
        # (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'

    elif keysym.find('Escape') != -1:
        # Never insert escape characters.
        return 'break'

    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)
</t>
<t tx="ekr.20090401102247.399"></t>
<t tx="ekr.20090401102247.400"># Not all versions of Qt have this crucial method.</t>
<t tx="ekr.20090401102247.401">@nocolor

- Setting a node dirty does not set ancestor @&lt;file&gt; nodes dirty.

- In both qt and tk, write-at-file-nodes does not clear dirty bit of @file nodes.
  Is there a reason for this?

- (fixed) New nodes are not marked dirty (In either tk or qt).

@color</t>
<t tx="ekr.20090401102247.402">def insertHeadline (self,event=None,op_name="Insert Node",as_child=False):

    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.p

    if not current: return

    c.endEditing()

    undoData = c.undoer.beforeInsertNode(current)
    # Make sure the new node is visible when hoisting.
    if (as_child or
        (current.hasChildren() and current.isExpanded()) or
        (c.hoistStack and current == c.hoistStack[-1].p)
    ):
        if c.config.getBool('insert_new_nodes_at_end'):
            p = current.insertAsLastChild()
        else:
            p = current.insertAsNthChild(0)
    else:
        p = current.insertAfter()
    p.setDirty(setDescendentsDirty=False)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    c.setChanged(True)
    u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    c.redrawAndEdit(p,selectAll=True)

    return p # for mod_labels plugin.
</t>
<t tx="ekr.20090401102247.403">def writeAtFileNodes (self,event=None):

    '''Write all @file nodes in the selected outline.'''

    c = self.c

    changedFiles,atOk = c.atFileCommands.writeAll(writeAtFileNodesFlag=True)

    if changedFiles:
        g.es("auto-saving outline",color="blue")
        c.save() # Must be done to set or clear tnodeList.
</t>
<t tx="ekr.20090401102247.404">def writeAll(self,
    writeAtFileNodesFlag=False,
    writeDirtyAtFileNodesFlag=False,
    toString=False,
):

    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False ; atOk = True

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.p
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    &lt;&lt; Clear all orphan bits &gt;&gt;
    atOk = True
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            &lt;&lt; handle v's tree &gt;&gt;
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    &lt;&lt; say the command is finished &gt;&gt;
    return mustAutoSave,atOk
</t>
<t tx="ekr.20090401102247.405">@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c

for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()
</t>
<t tx="ekr.20090401102247.406">if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False

    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtAutoNode():
        at.writeOneAtAutoNode(p,toString=toString,force=False)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtEditNode():
        at.writeOneAtEditNode(p,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtShadowFileNode():
        at.writeOneAtShadowNode(p,toString=toString,force=False)
        writtenFiles.append(p.v.t) ; autoSave = True # 2008/7/29
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if at.errors: atOk = False

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True
</t>
<t tx="ekr.20090401102247.407">if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) &gt; 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")
</t>
<t tx="ekr.20090401102247.408">def replaceTargetFileIfDifferent (self,root):

    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.

    Return True if the original file was changed.
    '''

    c = self.c

    assert(self.outputFile is None)

    if self.toString:
        # Do *not* change the actual file or set any dirty flag.
        self.fileChangedFlag = False
        return False

    if root:
        # The default: may be changed later.
        root.clearOrphan()
        root.clearDirty()

    if g.os_path_exists(self.targetFileName):
        if self.compareFiles(self.outputFileName,self.targetFileName,not self.explicitLineEnding):
            # Files are identical.
            ok = self.remove(self.outputFileName)
            g.es('unchanged:',self.shortFileName)
            if not ok:
                # self.remove gives the error.
                if root: root.setDirty() # New in 4.4.8.
            self.fileChangedFlag = False
            return False
        else:
            &lt;&lt; report if the files differ only in line endings &gt;&gt;
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                c.setFileTimeStamp(self.targetFileName)
                g.es('wrote:    ',self.shortFileName)
            else:
                # self.rename gives the error.
                g.es('unchanged:',self.shortFileName)
                if root: root.setDirty() # New in 4.4.8.

            self.fileChangedFlag = ok
            return ok
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            c.setFileTimeStamp(self.targetFileName)
            g.es('created:  ',self.targetFileName)
        else:
            # self.rename gives the error.
            if root: root.setDirty() # New in 4.4.8.

        # No original file to change. Return value tested by a unit test.
        self.fileChangedFlag = False 
        return False
</t>
<t tx="ekr.20090401102247.409">if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in:",self.targetFileName,color="blue")
</t>
<t tx="ekr.20090401102247.410"></t>
<t tx="ekr.20090401102247.411">def clearDirty (self):

    p = self
    p.v.clearDirty()
</t>
<t tx="ekr.20090401102247.412">def findAllPotentiallyDirtyNodes(self):

    trace = False and not g.unitTesting
    p = self ; c = p.v.context

    # Start with all nodes in the vnodeList.
    nodes = []
    newNodes = p.v.t.vnodeList[:]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        # g.trace(len(newNodes))
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.t.vnodeList:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
            for v2 in v.parents:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
        newNodes = addedNodes[:]

    # Remove the hidden vnode.
    if c.hiddenRootNode in nodes:
        if trace: g.trace('removing hidden root',c.hiddenRootNode)
        nodes.remove(c.hiddenRootNode)

    # g.trace('done',len(nodes))
    if trace: g.trace(nodes)
    return nodes
</t>
<t tx="ekr.20090401102247.413">def inAtIgnoreRange (self):

    """Returns True if position p or one of p's parents is an @ignore node."""

    p = self

    for p in p.self_and_parents_iter():
        if p.isAtIgnoreNode():
            return True

    return False
</t>
<t tx="ekr.20090401102247.414">def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    trace = False and not g.unitTesting
    verbose = False
    p = self
    dirtyVnodeList = []

    # Calculate all nodes that are joined to p or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()

    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)

    if trace and verbose:
        for v in nodes:
            print v.t.isDirty(),v.isAnyAtFileNode(),v

    dirtyVnodeList = [v for v in nodes
        if not v.t.isDirty() and v.isAnyAtFileNode()]
    changed = len(dirtyVnodeList) &gt; 0

    for v in dirtyVnodeList:
        v.t.setDirty() # Do not call v.setDirty here!

    if trace: g.trace(dirtyVnodeList) #,g.callers(5))

    return dirtyVnodeList
</t>
<t tx="ekr.20090401102247.415">def setDirty (self,setDescendentsDirty=True):

    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; dirtyVnodeList = []

    # g.trace(p.h,g.callers(4))

    if not p.v.t.isDirty():
        p.v.t.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)

    return dirtyVnodeList
</t>
<t tx="ekr.20090401102247.416"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,oldSel=None,oldText=None,oldYview=None):

    '''Update Leo after the body has been changed.'''

    trace = False and not g.unitTesting
    body = self ; c = self.c
    bodyCtrl = w = body.bodyCtrl
    p = c.p
    insert = w.getInsertPoint()
    ch = g.choose(insert==0,'',w.get(insert-1))
    ch = g.toUnicode(ch,g.app.tkEncoding)
    newText = w.getAllText() # Note: getAllText converts to unicode.
    newSel = w.getSelectionRange()
    if not oldText:
        oldText = p.b ; changed = True
    else:
        changed = oldText != newText
    if trace: g.trace(repr(ch),'changed:',changed,'newText:',len(newText),'w',w)
    if not changed: return
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setBodyString(newText)
    p.v.t.insertSpot = body.getInsertPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed: c.setChanged(True)
    self.updateEditors()
    &lt;&lt; update icons if necessary &gt;&gt;
</t>
<t tx="ekr.20090401102247.417">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False

if g.app.unitTesting:
    g.app.unitTestDict['colorized'] = True
</t>
<t tx="ekr.20090401102247.418">
redraw_flag = False
# Update dirty bits.
# p.setDirty() sets all cloned and @file dirty bits.
if not p.isDirty() and p.setDirty():
    redraw_flag = True

# Update icons. p.v.iconVal may not exist during unit tests.
val = p.computeIcon()
# g.trace('new val:',val,'old val:',hasattr(p.v,'iconVal') and p.v.iconVal or '&lt;None&gt;')
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True

if redraw_flag:
    c.redraw_after_icons_changed()
</t>
<t tx="ekr.20090401102247.419"># When editing headline text.</t>
<t tx="ekr.20090401102247.420">def save (self,event=None):

    '''Save a Leo outline to a file.'''

    c = self ; p = c.currentPosition()
    w = g.app.gui.get_focus(c)

    if g.app.disableSave:
        g.es("save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName:
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = ''.join(c.k.givenArgs) or g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        c.bringToFront()

        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)
            g.chdir(c.mFileName)

    # Done in fileCommands.save.
    # c.redraw_after_icons_changed()
    c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20090401102247.421">def save(self,fileName):

    c = self.c ; v = c.currentVnode()

    # New in 4.2.  Return ok flag so shutdown logic knows if all went well.
    ok = g.doHook("save1",c=c,p=v,v=v,fileName=fileName)

    if ok is None:
        c.endEditing() # Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        ok = c.checkFileTimeStamp(fileName)
        if ok:
            ok = self.write_Leo_file(fileName,False) # outlineOnlyFlag
        if ok:
            self.putSavedMessage(fileName)
            c.setChanged(False) # Clears all dirty bits.
            if c.config.save_clears_undo_buffer:
                g.es("clearing undo")
                c.undoer.clearUndoState()

        c.redraw_after_icons_changed()

    g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
    return ok
</t>
<t tx="ekr.20090401102247.422">def outerUpdate (self):

    trace = False and not g.unitTesting
    verbose = True ; traceFocus = False
    c = self ; aList = []
    if not c.exists or not c.k:
        return

    # Suppress any requested redraw until we have iconified or diconified.
    redrawFlag = c.requestRedrawFlag
    c.requestRedrawFlag = False

    # The iconify requests are made only by c.bringToFront.
    if c.requestedIconify == 'iconify':
        if verbose: aList.append('iconify')
        c.frame.iconify()

    if c.requestedIconify == 'deiconify':
        if verbose: aList.append('deiconify')
        c.frame.deiconify()

    if redrawFlag:
        g.trace('****','tree.drag_p',c.frame.tree.drag_p)
        # A hack: force the redraw, even if we are dragging.
        aList.append('*** redraw')
        c.frame.tree.redraw_now(forceDraw=True)

    if c.requestRecolorFlag:
        if verbose: aList.append('%srecolor' % (
            g.choose(c.incrementalRecolorFlag,'','full ')))
        # This should be the only call to c.recolor_now.
        c.recolor_now(incremental=c.incrementalRecolorFlag)
        # c.frame.body.colorizer.colorize(c.p,
            # incremental=c.incrementalRecolorFlag,interruptable=True)

    if c.requestedFocusWidget:
        w = c.requestedFocusWidget
        if traceFocus: aList.append('focus: %s' % (
            g.app.gui.widget_name(w)))
        c.set_focus(w)
    else:
        # We can not set the focus to the body pane:
        # That would make nested calls to c.outerUpdate significant.
        pass

    if trace and aList:
        g.trace(', '.join(aList)) # ,c.shortFileName() or '&lt;no name&gt;',g.callers())

    c.incrementalRecolorFlag = False
    c.requestRecolorFlag = None
    c.requestRedrawFlag = False
    c.requestedFocusWidget = None
    c.requestedIconify = ''

    # g.trace('after')
</t>
<t tx="ekr.20090401102247.423"># k.showStateAndMode does nothing in isearch mode.

# Also fixed a bug in iSearchBackspace.</t>
<t tx="ekr.20090401102247.424">def setLabel (self,s,protect=False):

    trace = (False or self.trace_minibuffer) and not g.app.unitTesting
    k = self ; c = k.c ; w = self.widget
    if not w: return

    if trace: g.trace(repr(s),g.callers(4))

    w.setAllText(s)
    n = len(s)
    w.setSelectionRange(n,n,insert=n)

    if protect:
        k.mb_prefix = s
</t>
<t tx="ekr.20090401102247.425">def showStateAndMode(self,w=None,prompt=None):

    k = self ; c = k.c
    state = k.unboundKeyAction
    mode = k.getStateKind()
    inOutline = False
    if not g.app.gui: return

    if not w:
        w = g.app.gui.get_focus(c)
        if not w: return

    # g.trace(w, state, mode,g.callers(5))

    # This fixes a problem with the tk gui plugin.
    if mode and mode.lower().startswith('isearch'):
        return

    wname = g.app.gui.widget_name(w).lower()

    if mode:
        if mode in ('getArg','getFileName','full-command'):
            s = None
        elif prompt:
            s = prompt
        else:
            mode = mode.strip()
            if mode.endswith('-mode'):
                mode = mode[:-5]
            s = '%s Mode' % mode.capitalize()
    elif w and (wname.startswith('canvas') or wname.startswith('head')):
        s = 'In Outline'
        inOutline = True
    else:
        s = '%s State' % state.capitalize()

    if s:
        # g.trace(s,w,g.callers(4))
        k.setLabelBlue(label=s,protect=True)

    if w and g.app.gui.isTextWidget(w):
        k.showStateColors(inOutline,w)
</t>
<t tx="ekr.20090401102247.426"># The problem is in the qt select logic.</t>
<t tx="ekr.20090401102247.427">def findAll(self):

    c = self.c ; w = self.s_ctrl ; u = c.undoer
    undoType = 'Clone Find All'
    if not self.checkArgs():
        return
    self.initInHeadline()
    if self.clone_find_all:
        self.p = None # Restore will select the root position.
    data = self.save()
    self.initBatchCommands()
    count = 0 ; clones = []
    while 1:
        pos, newpos = self.findNextMatch()
        if pos is None: break
        count += 1
        s = w.getAllText()
        i,j = g.getLine(s,pos)
        line = s[i:j]
        if not self.clone_find_all:
            self.printLine(line,allFlag=True)
        if self.clone_find_all and self.p.v.t not in clones:
            # g.trace(self.p.v.t,self.p.h)
            if not clones:
                undoData = u.beforeInsertNode(c.p)
                &lt;&lt; create the found node &gt;&gt;
            clones.append(self.p.v.t)
            &lt;&lt; create a clone of p under the find node &gt;&gt;

    if self.clone_find_all and clones:
        u.afterInsertNode(found,undoType,undoData,dirtyVnodeList=[])
        c.selectPosition(found)
        c.setChanged(True)

    self.restore(data)
    c.redraw()
    g.es("found",count,"matches")
</t>
<t tx="ekr.20090401102247.428">oldRoot = c.rootPosition()
found = oldRoot.insertAfter()
found.moveToRoot(oldRoot)
c.setHeadString(found,'Found: ' + self.find_text)
c.setRootPosition(found) # New in Leo 4.5.
</t>
<t tx="ekr.20090401102247.429">q = self.p.clone()
q.moveToLastChildOf(found)
</t>
<t tx="ekr.20090401102247.430">def createChaptersNode (self):

    cc = self ; c = cc.c ; root = c.rootPosition()

    # Create the node with a postion method
    # so we don't involve the undo logic.
    # g.trace('root',root)
    p = root.insertAsLastChild()
    p.initHeadString('@chapters')
    p.moveToRoot(oldRoot=root)
    c.setRootPosition(p)
    cc.chaptersNode = p.copy()
    t = p.v.t
    if t.fileIndex:
        self.error('***** t.fileIndex already exists')
    else:
        t.setFileIndex(g.app.nodeIndices.getNewIndex())
    c.setChanged(True)
</t>
<t tx="ekr.20090401102247.431">def moveOutlineUp (self,event=None):

    '''Move the selected node up if possible.'''

    c = self ; u = c.undoer ; p = c.p
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: self.cantMoveMessage()
        c.treeFocusHelper()
        return
    back = p.visBack(c)
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack(c)

    sparseMove = c.config.getBool('sparse_move_outline_left')
    c.endEditing()
    undoData = u.beforeMoveNode(p)
    dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
    moved = False
    &lt;&lt; Move p up &gt;&gt;
    if moved:
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
    c.redraw(p,setFocus=True)
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.</t>
<t tx="ekr.20090401102247.432">if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

parent = p.parent()

# For this special case we move p after back2.
specialCase = back2 and p.v in back2.v.t.vnodeList

if specialCase:
    # The move must be legal.
    moved = True
    back2.contract()
    p.moveAfter(back2)
elif not back2:
    if c.hoistStack: # hoist or chapter.
        limit,limitIsVisible = c.visLimit()
        assert limit
        if limitIsVisible:
            # canMoveOutlineUp should have caught this.
            g.trace('can not happen. In hoist')
        else:
            # g.trace('chapter first child')
            moved = True
            p.moveToFirstChildOf(limit)
    else:
        # p will be the new root node
        p.moveToRoot(oldRoot=c.rootPosition())
        moved = True
elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)
else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)
if moved and sparseMove and parent and not parent.isAncestorOf(p):
    # New in Leo 4.4.2: contract the old parent if it is no longer the parent of p.
    parent.contract()
</t>
<t tx="ekr.20090401102247.433">@nocolor-node

- Made several changes to Leo's core. The new pattern is to call c.redraw or
  c.redraw_after_select after c.selectPosition. That is, c.selectPosition no
  longer does an automatic redraw.

- **However**, qtGui.redraw_after_select *does* do a redraw if the selected node
  was not previously visible.</t>
<t tx="ekr.20090401102247.434">def executeScript(self,event=None,args=None,p=None,script=None,
    useSelectedText=True,define_g=True,define_name='__main__',silent=False):

    """This executes body text as a Python script.

    We execute the selected text, or the entire body text if no text is selected."""

    c = self ; script1 = script
    writeScriptFile = c.config.getBool('write_script_file')
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    self.redirectScriptOutput()
    try:
        log = c.frame.log
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            # g.pr('*** script',script)
            try:
                p = c.p
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                if args:
                    # g.trace('setting sys.argv',args)
                    sys.argv = args
                # A kludge: reset c.inCommand here to handle the case where we *never* return.
                # (This can happen when there are multiple event loops.)
                # This does not prevent zombie windows if the script puts up a dialog...
                c.inCommand = False
                # g.trace('**** before',writeScriptFile)
                if writeScriptFile:
                    scriptFile = self.writeScriptFile(script)
                    execfile(scriptFile,d)
                else:
                    exec(script,d)
                # g.trace('**** after')
                if not script1 and not silent:
                    # Careful: the script may have changed the log tab.
                    tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
                    g.es("end of script",color="purple",tabName=tabName)
            except Exception:
                g.handleScriptException(c,p,script,script1)
            del sys.path[0]
        else:
            tabName = log and hasattr(log,'tabName') and log.tabName or 'Log'
            g.es("no script selected",color="blue",tabName=tabName)
    finally:
        self.unredirectScriptOutput()
</t>
<t tx="ekr.20090401102247.435">def redirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.config.redirect_execute_script_output_to_log_pane:

        g.redirectStdout() # Redirect stdout
        g.redirectStderr() # Redirect stderr
</t>
<t tx="ekr.20090401102247.436">def unredirectScriptOutput (self):

    c = self

    # g.trace('original')

    if c.exists and c.config.redirect_execute_script_output_to_log_pane:

        g.restoreStderr()
        g.restoreStdout()
</t>
<t tx="ekr.20090401102247.437">def writeScriptFile (self,script):

    # Get the path to the file.
    c = self
    path = c.config.getString('script_file_path')
    if path:
        isAbsPath = os.path.isabs(path)
        driveSpec, path = os.path.splitdrive(path)
        parts = path.split('/')
        path = g.app.loadDir
        if isAbsPath:
            # make the first element absolute
            parts[0] = driveSpec + os.sep + parts[0]
        allParts = [path] + parts
        path = c.os_path_finalize_join(*allParts)
    else:
        path = c.os_path_finalize_join(
            g.app.loadDir,'..','test','scriptFile.py')

    # Write the file.
    try:
        f = open(path,'w')
        f.write(script)
        f.close()
    except Exception:
        g.es("Failed to write script to %s" % path)
        g.es("Check your configuration of script_file_path, currently %s" % c.config.getString('script_file_path'))
        path = None

    return path</t>
<t tx="ekr.20090401102247.438">def selectChapterForPosition (self,p):

    '''
    Select a chapter containing position p.
    Do nothing if p if p does not exist or is in the presently selected chapter.
    '''
    cc = self ; c = cc.c ; trace = False

    if not p or not c.positionExists(p):
        return

    theChapter = cc.getSelectedChapter()
    if not theChapter:
        if trace: g.trace('no chapter')
        return

    if trace: g.trace('selected:',theChapter.name)
    # First, try the presently selected chapter.
    firstName = theChapter.name
    if firstName == 'main' or theChapter.positionIsInChapter(p):
        if trace: g.trace('in chapter:',theChapter.name)
        return

    for name in cc.chaptersDict:
        if name not in (firstName,'main'):
            theChapter = cc.chaptersDict.get(name)
            if theChapter.positionIsInChapter(p):
                if trace: g.trace('select:',theChapter.name)
                cc.selectChapterByName(name)
                return
    else:
        if trace: g.trace('select main')
        cc.selectChapterByName('main')
</t>
<t tx="ekr.20090401102247.439">def selectChapterByName (self,name):

    '''Select a chapter.  Return True if a redraw is needed.'''

    cc = self ; c = cc.c

    chapter = cc.chaptersDict.get(name)

    if chapter:
        self.selectChapterByNameHelper(chapter)
    else:
        cc.error('cc.selectChapter: no such chapter: %s' % name)
        chapter = cc.chaptersDict.get('main')
        if chapter:
            self.selectChapterByNameHelper(chapter)
        else:
            cc.error('no main chapter!')</t>
<t tx="ekr.20090401102247.440">def selectChapterByNameHelper (self,chapter):

    cc = self ; c = cc.c

    if chapter != cc.selectedChapter:
        if cc.selectedChapter:
            cc.selectedChapter.unselect()
        chapter.select()
        c.setCurrentPosition(chapter.p)
        cc.selectedChapter = chapter

        # Do not call c.redraw here!
</t>
<t tx="ekr.20090401102247.441">@nocolor-node
</t>
<t tx="ekr.20090401102247.442">@nocolor

Pulled trunk, got r1599

python launchLeo.py leo/plugins/leoPlugins.leo

go to

Plugins--&gt;Graph world--&gt;@shadow backlink.py--&gt;backlink declarations

All I did was add the full stop at the end of the docstring, but see
the diff:

=== modified file 'leo/plugins/backlink.py'
--- leo/plugins/backlink.py     2009-02-19 18:16:01 +0000
+++ leo/plugins/backlink.py     2009-02-25 22:14:46 +0000
@@ -1,4 +1,4 @@
-'''Backlink - allow arbitrary links between nodes
+'''Backlink - allow arbitrary links between nodes.
 '''

 # Notes
@@ -296,7 +296,7 @@
                break
        else:
            self.showMessage("Error: no such link")
-
+
        gcc = getattr(self.c, 'graphcanvasController')
        if gcc:
            gcc.update()
</t>
<t tx="ekr.20090401102247.443">@color
    def linkAction(self, dir_, newChild=False):
        """link to/from current position from/to mark node"""
        if not self.linkMark or not self.c.positionExists(self.linkMark):
            self.showMessage('Link mark not specified or no longer valid', color='red')
            return

@nocolor
The new version has a completely blank line after the return.
The old version had 4 blanks in the blank line.

The problem probably arises from the write_strips_blank_lines option.</t>
<t tx="ekr.20090401102247.444">def writeOneAtAutoNode(self,p,toString,force):

    '''Write p, an @auto node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy()

    fileName = p.atAutoNodeName()
    if not fileName: return False

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fileName = c.os_path_finalize_join(at.default_directory,fileName)
    exists = g.os_path_exists(fileName)

    if not toString and not self.shouldWriteAtAutoNode(p,exists,force):
        return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"&lt;string-file&gt;",fileName)
    at.initWriteIvars(root,at.targetFileName,
        atAuto=True,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString)

    ok = at.openFileForWriting (root,fileName=fileName,toString=toString)
    if ok:
        at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        if at.errors == 0:
            at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
        else:
            g.es("not written:",at.outputFileName)
            root.setDirty() # New in Leo 4.4.8.

    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("not written:",at.outputFileName)

    return ok
</t>
<t tx="ekr.20090401102247.445">@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @auto x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @auto node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @auto file.
- The explicit commands that read and write @auto trees must always be honored.
@c

def shouldWriteAtAutoNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantTree(p): # There is noting of value to write.
        g.es_print(p.h,'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
</t>
<t tx="ekr.20090401102247.446">def writeOneAtShadowNode(self,p,toString,force):

    '''Write p, an @shadow node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy() ; x = c.shadowController

    fn = p.atShadowFileNodeName()
    if not fn:
        g.es_print('can not happen: not an @shadow node',p.h,color='red')
        return False

    # A hack to support unknown extensions.
    self.adjustTargetLanguage(fn) # May set c.target_language.

    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fn = c.os_path_finalize_join(at.default_directory,fn)
    exists = g.os_path_exists(fn)

    if not toString and not self.shouldWriteAtShadowNode(p,exists,force,fn):
        return False

    c.endEditing() # Capture the current headline.
    at.initWriteIvars(root,targetFileName=None, # Not used.
        atShadow=True,
        nosentinels=None, # set below.  Affects only error messages (sometimes).
        thinFile=True, # New in Leo 4.5 b2: private files are thin files.
        scriptWrite=False,
        toString=False, # True: create a fileLikeObject.  This is done below.
        forcePythonSentinels=True) # A hack to suppress an error message.
            # The actual sentinels will be set below.

    # Bug fix: Leo 4.5.1: use x.markerFromExtension to force the delim to match
    #                     what is used in x.propegate changes.
    # Note: x.marker_from_extension takes the file name as the argument,
    # not the extension itself
    marker = x.marker_from_extension(fn,addAtSign=False)
    # g.trace('write marker',marker)
    at.startSentinelComment = marker
    at.endSentinelComment = None

    if g.app.unitTesting: ivars_dict = g.getIvarsDict(at)

    # Write the public and private files to public_s and private_s strings.
    data = []
    for sentinels in (False,True):
        theFile = at.openStringFile(fn)
        at.sentinels = sentinels
        at.writeOpenFile(root,
            nosentinels=not sentinels,toString=False)
            # nosentinels only affects error messages, and then only if atAuto is True.
        s = at.closeStringFile(theFile)
        data.append(s)

    # Set these new ivars for unit tests.
    at.public_s, at.private_s = data

    if g.app.unitTesting:
        exceptions = ('public_s','private_s','sentinels','stringOutput')
        assert g.checkUnchangedIvars(at,ivars_dict,exceptions)

    if at.errors == 0 and not toString:
        ### It may be better to compute the public file by removing sentinels from at.private_s
        # by calling x.copy_file_removing_sentinels. This would ensure that the (dubious!!)
        # x.isSentinel logic is used consistently by the @shadow read/write logic.
        # OTOH, Leo's write logic should actually dominate x.isSentinel.

        # Write the public and private files.
        private_fn = x.shadowPathName(fn)
        x.makeShadowDirectory(fn) # makeShadowDirectory takes a *public* file name.
        at.replaceFileWithString(private_fn,at.private_s)
        at.replaceFileWithString(fn,at.public_s)

    if at.errors == 0:
        root.clearOrphan()
        root.clearDirty()
    else:
        g.es("not written:",at.outputFileName,color='red')
        root.setDirty() # New in Leo 4.4.8.

    return at.errors == 0
</t>
<t tx="ekr.20090401102247.447">@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @shadow x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @shadow node which will be populated the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @shadow file.
- The explicit commands that read and write @shadow trees must always be honored.
@c

def shouldWriteAtShadowNode (self,p,exists,force,fn):

    '''Return True if we should write the @shadow node at p.'''

    at = self ; x = at.c.shadowController

    if force: # We are executing write-at-shadow-node or write-dirty-at-shadow-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantTree(p): # There is noting of value to write.
        g.es_print(p.h,'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @shadow tree is dirty and contains significant info.
        return True
</t>
<t tx="ekr.20090401102247.448">def adjustTargetLanguage (self,fn):

    """Use the language implied by fn's extension if
    there is a conflict between it and c.target_language."""

    at = self ; c = at.c

    if c.target_language:
        junk,target_ext = g.os_path_splitext(fn)  
    else:
        target_ext = ''

    junk,ext = g.os_path_splitext(fn)

    if ext:
        if ext.startswith('.'): ext = ext[1:]

        language = g.app.extension_dict.get(ext)
        if language:
            c.target_language = language
        else:
            # An unknown language.
            pass # Use the default language, **not** 'unknown_language'
</t>
<t tx="ekr.20090401102247.449">def openFileForWriting (self,root,fileName,toString):

    at = self
    at.outputFile = None

    if toString:
        at.shortFileName = g.shortFileName(fileName)
        at.outputFileName = "&lt;string: %s&gt;" % at.shortFileName
        at.outputFile = g.fileLikeObject()
    else:
        ok = at.openFileForWritingHelper(fileName)

        # New in Leo 4.4.8: set dirty bit if there are errors.
        if not ok: at.outputFile = None

    # New in 4.3 b2: root may be none when writing from a string.
    if root:
        if at.outputFile:
            root.clearOrphan()
        else:
            root.setOrphan()
            root.setDirty()

    return at.outputFile is not None
</t>
<t tx="ekr.20090401102247.450">def openFileForWritingHelper (self,fileName):

    '''Open the file and return True if all went well.'''

    at = self ; c = at.c

    try:
        at.shortFileName = g.shortFileName(fileName)
        at.targetFileName = c.os_path_finalize_join(at.default_directory,fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            if path:
                path = g.makeAllNonExistentDirectories(path,c=c)
            if not path or not g.os_path_exists(path):
                path = g.os_path_dirname(at.targetFileName)
                at.writeError("path does not exist: " + path)
                return False
    except Exception:
        at.exception("exception creating path: %s" % repr(path))
        g.es_exception()
        return False

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not open: read only: " + at.targetFileName)
                return False
        except AttributeError:
            pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        kind,at.outputFile = self.openForWrite(at.outputFileName,'wb')
        if not at.outputFile:
            kind = g.choose(kind=='check',
                'did not overwrite','can not create')
            at.writeError("%s %s" % (kind,at.outputFileName))
            return False
    except Exception:
        at.exception("exception creating:" + at.outputFileName)
        return False

    return True
</t>
<t tx="ekr.20090401102247.451">def openForWrite (self, filename, wb='wb'):

    '''Open a file for writes, handling shadow files.'''

    trace = False # or x.trace
    at = self ; c = at.c ; x = c.shadowController

    try:
        shadow_filename = x.shadowPathName(filename)
        self.writing_to_shadow_directory = os.path.exists(shadow_filename)
        open_file_name       = g.choose(self.writing_to_shadow_directory,shadow_filename,filename)
        self.shadow_filename = g.choose(self.writing_to_shadow_directory,shadow_filename,None)

        if self.writing_to_shadow_directory:
            if trace and not g.app.unitTesting: g.trace(filename,shadow_filename)
            x.message('writing %s' % shadow_filename)
            return 'shadow',open(open_file_name,wb)
        else:
            ok = c.checkFileTimeStamp(at.targetFileName)
            return 'check',ok and open(open_file_name,wb)

    except IOError:
        if not g.app.unitTesting:
            g.es_print('openForWrite: exception opening file: %s' % (open_file_name),color='red')
            g.es_exception()
        return 'error',None
</t>
<t tx="ekr.20090401102247.452"># New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,
    nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""

    at = self ; s = g.choose(fromString,fromString,root.v.t._bodyString)

    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)

    if self.atAuto or (not toString and not nosentinels):
        at.warnAboutOrphandAndIgnoredNodes()
</t>
<t tx="ekr.20090401102247.453"></t>
<t tx="ekr.20090401102247.454"># oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):

    """ Generate the body enclosed in sentinel lines."""

    at = self

    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.b)

    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
    s = self.cleanLines(p,s)
    i = 0
    while i &lt; len(s):
        next_i = g.skip_line(s,i)
        assert(next_i &gt; i)
        kind = at.directiveKind4(s,i)
        &lt;&lt; handle line at s[i] &gt;&gt;
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
</t>
<t tx="ekr.20090401102247.455">@

If we add a trailing newline, we'll generate an @nonl sentinel below.

- We always ensure a newline in @file and @thin trees.
- This code is not used used in @asis trees.
- New in Leo 4.4.3 b1: We add a newline in @nosent trees unless
  @bool force_newlines_in_at_nosent_bodies = False
@c

if s:
    trailingNewlineFlag = s[-1] == '\n'
    if not trailingNewlineFlag:
        if (at.sentinels or 
            (not at.atAuto and at.force_newlines_in_at_nosent_bodies)
        ):
            # g.trace('Added newline',repr(s))
            s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
</t>
<t tx="ekr.20090401102247.456"># g.trace(kind,repr(s[i:next_i]))

if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.startVerbatim:
    at.putSentinel("@verbatim")
    at.putIndent(at.indent)
    i = next_i
    next_i = g.skip_line(s,i)
    at.os(s[i:next_i])
elif kind == at.miscDirective:
    # g.trace('miscDirective')
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
</t>
<t tx="ekr.20090401102247.457"></t>
<t tx="ekr.20090401102247.458"></t>
<t tx="ekr.20090401102247.459">def putAtAllLine (self,s,i,p):

    """Put the expansion of @others."""

    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+all")
    else:
        at.putSentinel("@+all")

    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putSentinel("@-all")
    at.indent -= delta
</t>
<t tx="ekr.20090401102247.460">def putAtAllBody(self,p):

    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.b

    p.v.setVisited()   # Make sure v is never expanded again.
    p.v.t.setVisited() # Use the tnode for the orphans check.
    if not at.thinFile and not s: return
    inCode = True
    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
    i = 0
    while i &lt; len(s):
        next_i = g.skip_line(s,i)
        assert(next_i &gt; i)
        if inCode:
            # Use verbatim sentinels to write all directives.
            at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
        i = next_i

    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
</t>
<t tx="ekr.20090401102247.461"># 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
</t>
<t tx="ekr.20090401102247.462">@
This code puts only the first of two or more cloned siblings, preceding the
clone with an @clone n sentinel.

This is a debatable choice: the cloned tree appears only once in the derived
file. This should be benign; the text created by @all is likely to be used only
for recreating the outline in Leo. The representation in the derived file
doesn't matter much.
@c

def putAtAllChild(self,p):

    at = self

    parent_v = p._parentVnode()
    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(parent_v,p.v)
    if clonedSibs &gt; 1:
        if thisClonedSibIndex == 1:
            at.putSentinel("@clone %d" % (clonedSibs))
        else: return # Don't write second or greater trees.

    at.putOpenNodeSentinel(p,inAtAll=True) # Suppress warnings about @file nodes.
    at.putAtAllBody(p) 

    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putCloseNodeSentinel(p)
</t>
<t tx="ekr.20090401102247.463"></t>
<t tx="ekr.20090401102247.464">def inAtOthers(self,p):

    """Returns True if p should be included in the expansion of the at-others directive

    in the body text of p's parent."""

    # Return False if this has been expanded previously.
    if  p.v.isVisited():
        # g.trace("previously visited",p.v)
        return False

    # Return False if this is a definition node.
    h = p.h ; i = g.skip_ws(h,0)
    isSection,junk = self.isSectionName(h,i)
    if isSection:
        # g.trace("is section",p)
        return False

    # Return False if p's body contains an @ignore directive.
    if p.isAtIgnoreNode():
        # g.trace("is @ignore",p)
        return False
    else:
        # g.trace("ok",p)
        return True
</t>
<t tx="ekr.20090401102247.465">def putAtOthersChild(self,p):

    at = self

    parent_v = p._parentVnode()
    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(parent_v,p.v)
    if clonedSibs &gt; 1 and thisClonedSibIndex == 1:
        at.writeError("Cloned siblings are not valid in @thin trees")

    at.putOpenNodeSentinel(p)
    at.putBody(p) 

    # Insert expansions of all children.
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    at.putCloseNodeSentinel(p)
</t>
<t tx="ekr.20090401102247.466">def putAtOthersLine (self,s,i,p):

    """Put the expansion of @others."""

    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+others")
    else:
        at.putSentinel("@+others")

    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    at.putSentinel("@-others")
    at.indent -= delta
</t>
<t tx="ekr.20090401102247.467">def putCodeLine (self,s,i):

    '''Put a normal code line.'''

    trace = False and not g.unitTesting
    at = self

    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel('@verbatim')

    j = g.skip_line(s,i)
    line = s[i:j]

    if trace: g.trace(self.atShadow,repr(line))

    # Don't put any whitespace in otherwise blank lines.
    if line.strip(): # The line has non-empty content.
        if not at.raw:
            at.putIndent(at.indent,line)

        if line[-1:]=='\n':
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
    elif line and line[-1] == '\n':
        at.onl()
    else:
        g.trace('Can not happen: completely empty line')

</t>
<t tx="ekr.20090401102247.468"></t>
<t tx="ekr.20090401102247.469">def putRefLine(self,s,i,n1,n2,p):

    """Put a line containing one or more references."""

    at = self

    # Compute delta only once.
    delta = self.putRefAt(s,i,n1,n2,p,delta=None)
    if delta is None: return # 11/23/03

    while 1:
        i = n2 + 2
        hasRef,n1,n2 = at.findSectionName(s,i)
        if hasRef:
            self.putAfterMiddleRef(s,i,n1,delta)
            self.putRefAt(s,n1,n1,n2,p,delta)
        else:
            break

    self.putAfterLastRef(s,i,delta)
</t>
<t tx="ekr.20090401102247.470">def putRefAt (self,s,i,n1,n2,p,delta):

    """Put a reference at s[n1:n2+2] from p."""

    at = self ; c = at.c ; name = s[n1:n2+2]

    ref = g.findReference(c,name,p)
    if not ref:
        if not g.unitTesting:
            at.writeError(
                "undefined section: %s\n\treferenced from: %s" %
                    ( name,p.h))
        return None

    # Expand the ref.
    if not delta:
        junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

    at.putLeadInSentinel(s,i,n1,delta)

    inBetween = []
    if at.thinFile: # @+-middle used only in thin files.
        parent = ref.parent()
        while parent != p:
            inBetween.append(parent)
            parent = parent.parent()

    at.indent += delta

    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + name)
    else:
        at.putSentinel("@" + name)

    if inBetween:
        # Bug fix: reverse the +middle sentinels, not the -middle sentinels.
        inBetween.reverse()
        for p2 in inBetween:
            at.putOpenNodeSentinel(p2,middle=True)

    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)

    if inBetween:
        inBetween.reverse()
        for p2 in inBetween:
            at.putCloseNodeSentinel(p2,middle=True)

    at.indent -= delta

    return delta
</t>
<t tx="ekr.20090401102247.471">def putAfterLastRef (self,s,start,delta):

    """Handle whatever follows the last ref of a line."""

    at = self

    j = g.skip_ws(s,start)

    if j &lt; len(s) and s[j] != '\n':
        end = g.skip_line(s,start)
        after = s[start:end] # Ends with a newline only if the line did.
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl() # Add a newline if the line didn't end with one.
        at.indent -= delta
    else:
        # Temporarily readjust delta to make @nl look better.
        at.indent += delta
        at.putSentinel("@nl")
        at.indent -= delta
</t>
<t tx="ekr.20090401102247.472">def putAfterMiddleRef (self,s,start,end,delta):

    """Handle whatever follows a ref that is not the last ref of a line."""

    at = self

    if start &lt; end:
        after = s[start:end]
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after) ; at.onl_sent() # Not a real newline.
        at.putSentinel("@nonl")
        at.indent -= delta
</t>
<t tx="ekr.20090401102247.473"></t>
<t tx="ekr.20090401102247.474">def putBlankDocLine (self):

    at = self

    at.putPending(split=False)

    if not at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.startSentinelComment) ; at.oblank()

    at.onl()
</t>
<t tx="ekr.20090401102247.475">def putStartDocLine (self,s,i,kind):

    """Write the start of a doc part."""

    at = self ; at.docKind = kind

    sentinel = g.choose(kind == at.docDirective,"@+doc","@+at")
    directive = g.choose(kind == at.docDirective,"@doc","@")

    if 0: # New code: put whatever follows the directive in the sentinel
        # Skip past the directive.
        i += len(directive)
        j = g.skip_to_end_of_line(s,i)
        follow = s[i:j]

        # Put the opening @+doc or @-doc sentinel, including whatever follows the directive.
        at.putSentinel(sentinel + follow)

        # Put the opening comment if we are using block comments.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    else: # old code.
        # Skip past the directive.
        i += len(directive)

        # Get the trailing whitespace.
        j = g.skip_ws(s,i)
        ws = s[i:j]

        # Put the opening @+doc or @-doc sentinel, including trailing whitespace.
        at.putSentinel(sentinel + ws)

        # Put the opening comment.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()

        # Put an @nonl sentinel if there is significant text following @doc or @.
        if not g.is_nl(s,j):
            # Doesn't work if we are using block comments.
            at.putSentinel("@nonl")
            at.putDocLine(s,j)
</t>
<t tx="ekr.20090401102247.476">def putDocLine (self,s,i):

    """Handle one line of a doc part.

    Output complete lines and split long lines and queue pending lines.
    Inserted newlines are always preceded by whitespace."""

    at = self
    j = g.skip_line(s,i)
    s = s[i:j]

    if at.endSentinelComment:
        leading = at.indent
    else:
        leading = at.indent + len(at.startSentinelComment) + 1

    if not s or s[0] == '\n':
        # A blank line.
        at.putBlankDocLine()
    else:
        &lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;
</t>
<t tx="ekr.20090401102247.477">@ All inserted newlines are preceeded by whitespace:
we remove trailing whitespace from lines that have not been split.
@c

i = 0
while i &lt; len(s):

    # Scan to the next word.
    word1 = i # Start of the current word.
    word2 = i = g.skip_ws(s,i)
    while i &lt; len(s) and s[i] not in (' ','\t'):
        i += 1
    word3 = i = g.skip_ws(s,i)
    # g.trace(s[word1:i])

    if leading + word3 - word1 + len(''.join(at.pending)) &gt;= at.page_width:
        if at.pending:
            # g.trace("splitting long line.")
            # Ouput the pending line, and start a new line.
            at.putPending(split=True)
            at.pending = [s[word2:word3]]
        else:
            # Output a long word on a line by itself.
            # g.trace("long word:",s[word2:word3])
            at.pending = [s[word2:word3]]
            at.putPending(split=True)
    else:
        # Append the entire word to the pending line.
        # g.trace("appending",s[word1:word3])
        at.pending.append(s[word1:word3])

# Output the remaining line: no more is left.
at.putPending(split=False)
</t>
<t tx="ekr.20090401102247.478">def putEndDocLine (self):

    """Write the conclusion of a doc part."""

    at = self

    at.putPending(split=False)

    # Put the closing delimiter if we are using block comments.
    if at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.endSentinelComment)
        at.onl() # Note: no trailing whitespace.

    sentinel = g.choose(at.docKind == at.docDirective,"@-doc","@-at")
    at.putSentinel(sentinel)
</t>
<t tx="ekr.20090401102247.479">def putPending (self,split):

    """Write the pending part of a doc part.

    We retain trailing whitespace iff the split flag is True."""

    at = self ; s = ''.join(at.pending) ; at.pending = []

    # g.trace("split",s)

    # Remove trailing newline temporarily.  We'll add it back later.
    if s and s[-1] == '\n':
        s = s[:-1]

    if not split:
        s = s.rstrip()
        if not s:
            return

    at.putIndent(at.indent)

    if not at.endSentinelComment:
        at.os(at.startSentinelComment) ; at.oblank()

    at.os(s) ; at.onl()
</t>
<t tx="ekr.20090401102247.480"></t>
<t tx="ekr.20090401102247.481"></t>
<t tx="ekr.20090401102247.482"></t>
<t tx="ekr.20090401102247.483">def putClass (self,s,i,sigEnd,codeEnd,start,parent):

    '''Creates a child node c of parent for the class, and a child of c for each def in the class.'''

    # Enter a new class 1: save the old class info.
    oldMethodName = self.methodName
    oldStartSigIndent = self.startSigIndent

    # Enter a new class 2: init the new class info.
    self.indentRefFlag = None

    class_kind = self.classId
    class_name = self.sigId
    headline = '%s %s' % (class_kind,class_name)
    headline = headline.strip()
    self.methodName = headline

    # Compute the starting lines of the class.
    prefix = self.createClassNodePrefix()
    if not self.sigId:
        g.trace('Can not happen: no sigId')
        self.sigId = 'Unknown class name'
    classHead = s[start:sigEnd]
    i = self.extendSignature(s,sigEnd)
    extend = s[sigEnd:i]
    if extend:
        classHead = classHead + extend

    # Create the class node.
    class_node = self.createHeadline(parent,'',headline)

    # Remember the indentation of the class line.
    undentVal = self.getLeadingIndent(classHead,0)

    # Call the helper to parse the inner part of the class.
    putRef,bodyIndent,classDelim,decls,trailing = self.putClassHelper(
        s,i,codeEnd,class_node)
    # g.trace('bodyIndent',bodyIndent,'undentVal',undentVal)

    # Set the body of the class node.
    ref = putRef and self.getClassNodeRef(class_name) or ''

    # Give ref the same indentation as the body of the class.
    if ref:
        bodyWs = g.computeLeadingWhitespace (bodyIndent,self.tab_width)
        ref = '%s%s' % (bodyWs,ref)

    # Remove the leading whitespace.
    result = (
        prefix +
        self.undentBy(classHead,undentVal) +
        self.undentBy(classDelim,undentVal) +
        self.undentBy(decls,undentVal) +
        self.undentBy(ref,undentVal) +
        self.undentBy(trailing,undentVal))

    # Append the result to the class node.
    self.appendTextToClassNode(class_node,result)

    # Exit the new class: restore the previous class info.
    self.methodName = oldMethodName
    self.startSigIndent = oldStartSigIndent
</t>
<t tx="ekr.20090401102247.484">def appendTextToClassNode (self,class_node,s):

    c = self.c

    self.appendStringToBody(class_node,s) 
</t>
<t tx="ekr.20090401102247.485">def createClassNodePrefix (self):

    '''Create the class node prefix.'''

    if  self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + self.methodName + ' methods ') + '=\n\n'
        self.methodsSeen = True

    return prefix
</t>
<t tx="ekr.20090401102247.486">def getClassNodeRef (self,class_name):

    '''Insert the proper body text in the class_vnode.'''

    if self.treeType == '@file':
        s = '@others'
    else:
        s = g.angleBrackets(' class %s methods ' % (class_name))

    return '%s\n' % (s)
</t>
<t tx="ekr.20090401102247.487">def putClassHelper(self,s,i,end,class_node):

    '''s contains the body of a class, not including the signature.

    Parse s for inner methods and classes, and create nodes.'''

    # Increase the output indentation (used only in startsHelper).
    # This allows us to detect over-indented classes and functions.
    old_output_indent = self.output_indent
    self.output_indent += abs(self.tab_width)

    # Parse the decls.
    j = i ; i = self.skipDecls(s,i,end,inClass=True)
    decls = s[j:i]

    # Set the body indent if there are real decls.
    bodyIndent = decls.strip() and self.getIndent(s,i) or None

    # Parse the rest of the class.
    delim1, delim2 = self.outerBlockDelim1, self.outerBlockDelim2
    if g.match(s,i,delim1):
        # Do *not* use g.skip_ws_and_nl here!
        j = g.skip_ws(s,i + len(delim1))
        if g.is_nl(s,j): j = g.skip_nl(s,j)
        classDelim = s[i:j]
        end2 = self.skipBlock(s,i,delim1=delim1,delim2=delim2)
        start,putRef,bodyIndent2 = self.scanHelper(s,j,end=end2,parent=class_node,kind='class')
    else:
        classDelim = ''
        start,putRef,bodyIndent2 = self.scanHelper(s,i,end=end,parent=class_node,kind='class')

    if bodyIndent is None: bodyIndent = bodyIndent2

    # Restore the output indentation.
    self.output_indent = old_output_indent

    # Return the results.
    trailing = s[start:end]
    return putRef,bodyIndent,classDelim,decls,trailing
</t>
<t tx="ekr.20090401102247.488">def undentBody (self,s,ignoreComments=True):

    '''Remove the first line's leading indentation from all lines of s.'''

    trace = False
    if trace: g.trace('before...\n',g.listToString(g.splitLines(s)))

    # Copy an @code line as is.
    # i = 0
    # if g.match(s,i,'@code'):
        # j = i ; i = g.skip_line(s,i) # don't use get_line: it is only for dumping.
        # result += s[j:i]

    # Calculate the amount to be removed from each line.
    undentVal = self.getLeadingIndent(s,0,ignoreComments=ignoreComments)
    if undentVal == 0:
        return s
    else:
        result = self.undentBy(s,undentVal)
        if trace: g.trace('after...\n',g.listToString(g.splitLines(result)))
        return result</t>
<t tx="ekr.20090401102247.489">def undentBy (self,s,undentVal):

    '''Remove leading whitespace equivalent to undentVal from each line.
    add an underindentEscapeString for underindented line.'''

    # return ''.join(
        # [g.removeLeadingWhitespace(line,undentVal,self.tab_width)
            # for line in g.splitLines(s)])

    trace = False and not g.app.unitTesting
    tag = self.c.atFileCommands.underindentEscapeString
    result = [] ; tab_width = self.tab_width
    for line in g.splitlines(s):
        lws_s = g.get_leading_ws(line)
        lws = g.computeWidth(lws_s,tab_width)
        s = g.removeLeadingWhitespace(line,undentVal,tab_width)
        n = lws - undentVal
        if s.strip() and lws &lt; undentVal:
            if trace: g.trace('undentVal: %s, lws: %s, %s' % (
                undentVal,lws,repr(line)))
            result.append("%s%s%s" % (tag,undentVal-lws,s.lstrip()))
        else:
            result.append(s)

    return ''.join(result)

</t>
<t tx="ekr.20090401102247.490">@nocolor-node

https://bugs.launchpad.net/leo-editor/+bug/335149

Gack - I see

Ctrl-I
some text here
Ctrl-I
other text

is reverting "some text here" to NewHeadline in r1641
</t>
<t tx="ekr.20090401102247.491"># The problem was in handling backspace.
# I added a hack to autoCompleterStateHandler.

@nocolor-node

Starting with  g.b

Type backspace

Tk shows the completions for g., qt does not

Now type a

Tk shows the completions for g.a, qt does not.</t>
<t tx="ekr.20090401102247.492">def autoCompleterStateHandler (self,event):

    trace = (False or self.trace) and not g.app.unitTesting
    c = self.c ; k = self.k ; gui = g.app.gui
    tag = 'auto-complete' ; state = k.getState(tag)
    ch = gui.eventChar(event)
    keysym = gui.eventKeysym(event)

    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in (' ','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym in ('\b','BackSpace'): # Horrible hack for qt plugin.
        self.doBackSpace()
    elif keysym == '.':
        self.chain()
    elif keysym == '?':
        self.info()
    elif keysym == '!':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.theObject) == types.DictType:
            self.membersList = self.theObject.keys()
        elif type(self.theObject) in (types.ListType,types.TupleType):
            self.membersList = self.theObject
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        # if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'
</t>
<t tx="ekr.20090401102247.493">@

http://groups.google.com/group/leo-editor/browse_thread/thread/dcd6e32a98b17ed3

It seems at least setMoveCol is easy to optimize (getAllText not needed - and
w.toPythonIndex can lose getAllText as well).
</t>
<t tx="ekr.20090401102247.494">def convertPythonIndexToRowCol (s,i):

    '''Convert index i into string s into zero-based row/col indices.'''

    if not s or i &lt;= 0:
        return 0,0

    i = min(i,len(s))

    # works regardless of what s[i] is
    row = s.count('\n',0,i) # Don't include i
    if row == 0:
        return row,i
    else:
        prevNL = s.rfind('\n',0,i) # Don't include i
        # g.trace('prevNL',prevNL,'i',i,g.callers())
        return row,i-prevNL-1
</t>
<t tx="ekr.20090401102247.495">@nocolor-node

The selection is not handled properly.
The fix was to save/restore the selection range in
the top-level undo/redo logic before calling c.redraw.</t>
<t tx="ekr.20090401102247.496">@nocolor-node

This @shadow functionality is a great enhancement to Leo, and I would
like to use it more.

I am using Leo 4.5.1 Final on Windows XP.

My particulars, as reported by Leo :
  | Leo Log Window...
  | Leo 4.5.1 final, build  1.244 , September 14, 2008
  | python 2.6.1, Tk 8.5.2, Pmw 1.3
  | Windows 5, 1, 2600, 2, Service Pack 3

I've seen 3 discussion threads titled
  - "@shadow node failing to shadow" 01/23/2009
  - "@shadow notes" 08/31/2008
  - "Problem with shadow files" 09/10/2008
that seem to imply the problem was resolved before Leo 4.5.1 Final.

However, I still see the problem and can reproduce the problem as
follows:

0) Sample c code created

  &gt;type sampleHello.c
  #include &lt;stdio.h&gt;

  void main(void){
     printf("hello world\n");
     printf("hello again everybody!\n");
  }

1) Place sampleHello.c in an empty folder, eg c:/tmp/sampleHello.c
2) Open a new Leo window, and add "@shadow sampleHello.c" node.
3) Save the Leo file to c:/tmp/sampleHello.leo, then close it.
4) Reopen c:/tmp/sampleHello.leo and
   - confirm that @shadow node has a "main" outline node inside.
   - confirm that .leo_shadow is created
   - confirm .leo_shadow/xsampleHello.c contains sentinels
5) Close the Leo file. Reopen the Leo file.

  Get error message :
  | reading: G:\projects\test\tmp\sampleHello.leo
  | wrote:     G:\projects\test\tmp\.leo_shadow\xsampleHello.c
  | updated private G:\projects\test\tmp\.leo_shadow\xsampleHello.c
from public G:\projects\test\tmp\sampleHello.c
  | reading: @shadow sampleHello.c
  | Bad @+leo sentinel in: G:\projects\test\tmp\.leo_shadow
\xsampleHello.c
  |invalid @shadow private file G:\projects\test\tmp\.leo_shadow
\xsampleHello.c

  - confirm that shadow node in Leo file is now empty.
  - confirm that /tmp/.leo_shadow/xsampleHello.c is exact copy of /
tmp/sampleHello.c

If there is a workaround, please let me know.

Thanks for a very useful tool,</t>
<t tx="ekr.20090401102247.497"># Added call to c.redraw at *end* of runLeo.py:</t>
<t tx="ekr.20090401102247.498"></t>
<t tx="ekr.20090401102247.499">http://webpages.charter.net/edreamleo/scripting.html#getting-interactive-input-from-scripts</t>
<t tx="ekr.20090401102247.500">@nocolor

How can I hook my own completer into this?

What I need is that leo will call my own hook function when the user tries to
autocomplete, and my own function will tell leo what completions are suggested
(and thus what leo should show for the user).

@color</t>
<t tx="ekr.20090401102247.501">class autoCompleterClass:

    '''A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.

    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    '''

    @others
</t>
<t tx="ekr.20090401102247.502">def __init__ (self,k):

    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.globalPythonFunctionsDict = {}
    self.language = None
    self.leadinWord = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfClassName = None
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfTnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.theObject = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.useTabs = True # True: show results in autocompleter tab.
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.
</t>
<t tx="ekr.20090401102247.503">def defineClassesDict (self):

    self.allClassesDict = {}

    # gc may not exist.
    try: import gc
    except ImportError: return

    for z in gc.get_objects():
        t = type(z)
        if t == types.ClassType:
            name = z.__name__
        elif t == types.InstanceType:
            name = z.__class__.__name__
        elif repr(t).startswith('&lt;class'): # A wretched kludge.
            name = z.__class__.__name__
        elif t == types.TypeType:
            name = z.__name__
        else:
            name = None
        if name:
            # if name == 'position': g.trace(t,z)
            self.allClassesDict [name] = z

    # g.printList(self.allClassesDict.keys(),tag='Classes',sort=True)
    # g.trace(len(self.allClassesDict.keys()))
    # g.trace('position:',self.allClassesDict.get('position'))
</t>
<t tx="ekr.20090401102247.504">def defineObjectDict (self):

    c = self.c ; k = c.k ; p = c.p

    table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'), # An actual string object.
        (['cc'],                'object',c.chapterController),
        (['c','old_c','new_c'], 'object',c),            
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), 
        (['g'],                 'object',g),       
        (['gui'],               'object',g.app.gui),
        (['k'],                 'object',k),
        (['p','p1','p2'],       'object',p),             
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string), # Python's string module.
        (['t','t1','t2'],       'object',p.v.t),  
        (['v','v1','v2'],       'object',p.v),
        (['w','widget'],        'object',c.frame.body.bodyCtrl),
    ]

    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)

    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        for z in idList:
            if obj:
                self.objectDict[z]=obj
</t>
<t tx="ekr.20090401102247.505"></t>
<t tx="ekr.20090401102247.506">def autoComplete (self,event=None,force=False):

    '''An event handler called from k.masterKeyHanderlerHelper.'''

    c = self.c ; k = self.k ; gui = g.app.gui
    w = gui.eventWidget(event) or c.get_focus()

    # First, handle the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)

    # Don't allow autocompletion in headlines.
    if not c.widget_name(w).startswith('head'):
        self.language = g.scanForAtLanguage(c,c.p)
        if w and self.language == 'python' and (k.enable_autocompleter or force):
            self.start(event=event,w=w)

    return 'break'
</t>
<t tx="ekr.20090401102247.507">def autoCompleteForce (self,event=None):

    '''Show autocompletion, even if autocompletion is not presently enabled.'''

    return self.autoComplete(event,force=True)
</t>
<t tx="ekr.20090401102247.508">def getExternalCompletions (self,s,p=None,language='python'):

    '''Return the completions possible at the end of string 's'.
    Return (theObject,completions):
    - theObject is None unless the last character is 's' is a period.
    - completions is the list of valid completions.'''

    c = self.c ; k = c.k
    if not p: p = c.p

    # Use a separate widget containing just s.
    self.widget = w = leoFrame.stringTextWidget(c,'compute-completions-widget')
    w.setAllText(s)

    # A big kludge: scan back for the first period.
    i = len(s)-1
    while i &gt; 0 and s[i] != '.':
        i -= 1
    if s[i] == '.': i += 1
    prefix = s[i:].strip()

    # Remember the prefix, but put the insert before the period.
    w.setSelectionRange(i, len(s)-1, insert=i)

    # Init the ivars...
    self.language = p and g.scanForAtLanguage(c,p) or language
    self.tabName = ''
    old_enable = c.k.enable_autocompleter

    # Get the completions.
    try:
        c.k.enable_autocompleter = True
        self.useTabs = False
        self.start(prefix=prefix)
    finally:
        c.k.enable_autocompleter = old_enable
        self.useTabs = True

    theObject,tabList = self.theObject,self.tabList
    self.abort()
    return theObject,tabList
</t>
<t tx="ekr.20090401102247.509">def disableAutocompleter (self,event=None):
    '''Disable the autocompleter.'''
    self.k.enable_autocompleter = False
    self.showAutocompleterStatus()

def disableCalltips (self,event=None):
    '''Disable calltips.'''
    self.k.enable_calltips = False
    self.showCalltipsStatus()

def enableAutocompleter (self,event=None):
    '''Enable the autocompleter.'''
    self.k.enable_autocompleter = True
    self.showAutocompleterStatus()

def enableCalltips (self,event=None):
    '''Enable calltips.'''
    self.k.enable_calltips = True
    self.showCalltipsStatus()

def toggleAutocompleter (self,event=None):
    '''Toggle whether the autocompleter is enabled.'''
    self.k.enable_autocompleter = not self.k.enable_autocompleter
    self.showAutocompleterStatus()

def toggleCalltips (self,event=None):
    '''Toggle whether calltips are enabled.'''
    self.k.enable_calltips = not self.k.enable_calltips
    self.showCalltipsStatus()
</t>
<t tx="ekr.20090401102247.510">def showCalltips (self,event=None,force=False):

    '''Show the calltips at the cursor.'''

    c = self.c ; k = c.k ; w = g.app.gui.eventWidget(event)
    if not w: return

    # Insert the calltip if possible, but not in headlines.
    if (k.enable_calltips or force) and not c.widget_name(w).startswith('head'):
        self.widget = w
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        self.leadinWord = self.findCalltipWord(w)
        # g.trace(self.leadinWord)
        self.theObject = None
        self.membersList = None
        self.calltip()
    else:
        # Just insert the invocation character as usual.
        k.masterCommand(event,func=None,stroke=None,commandName=None)

    return 'break'
</t>
<t tx="ekr.20090401102247.511">def showCalltipsForce (self,event=None):

    '''Show the calltips at the cursor, even if calltips are not presently enabled.'''

    return self.showCalltips(event,force=True)
</t>
<t tx="ekr.20090401102247.512">def showAutocompleterStatus (self):
    '''Show the autocompleter status on the status line.'''

    k = self.k
    s = 'autocompleter %s' % g.choose(k.enable_autocompleter,'On','Off')
    g.es(s,color='red')

def showCalltipsStatus (self):
    '''Show the autocompleter status on the status line.'''
    k = self.k
    s = 'calltips %s' % g.choose(k.enable_calltips,'On','Off')
    g.es(s,color='red')</t>
<t tx="ekr.20090401102247.513"></t>
<t tx="ekr.20090401102247.514">def abort (self):

    k = self.k
    k.keyboardQuit(event=None,setDefaultStatus=False)
        # Stay in the present input state.
    self.exit(restore=True)

def exit (self,restore=False): # Called from keyboard-quit.

    k = self ; c = self.c 
    w = self.widget or c.frame.body.bodyCtrl
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
    c.widgetWantsFocusNow(w)
    i,j = w.getSelectionRange()
    if restore:
        if i != j: w.delete(i,j)
        w.insert(i,self.selectedText)
    w.setSelectionRange(j,j,insert=j)

    self.clear()
    self.theObject = None
</t>
<t tx="ekr.20090401102247.515">def appendTabName (self,word):

    self.setTabName(self.tabName + word + '.')

def beginTabName (self,word):

    # g.trace(word,g.callers())
    if word == 'self' and self.selfClassName:
        word = '%s (%s)' % (word,self.selfClassName)
    self.setTabName('AutoComplete ' + word + '.')

def clearTabName (self):

    self.setTabName('AutoComplete ')

def popTabName (self):

    s = self.tabName
    i = s.rfind('.',0,-1)
    if i &gt; -1:
        self.setTabName(s[0:i])

# Underscores are not valid in Pmw tab names!
def setTabName (self,s):

    c = self.c
    if self.useTabs:
        if self.tabName:
            c.frame.log.deleteTab(self.tabName)
        self.tabName = s.replace('_','') or ''
        c.frame.log.clearTab(self.tabName)
</t>
<t tx="ekr.20090401102247.516">def appendToKnownObjects (self,obj):

    if 0:
        if type(obj) in (types.InstanceType,types.ModuleType,types):
            if hasattr(obj,'__name__'):
                self.knownObjects[obj.__name__] = obj
                # g.trace('adding',obj.__name__)
</t>
<t tx="ekr.20090401102247.517">def calltip (self,obj=None):

    c = self.c
    w = self.widget
    isStringMethod = False ; s = None
    # g.trace(self.leadinWord,obj)

    if self.leadinWord and (not obj or type(obj) == types.BuiltinFunctionType):
        &lt;&lt; try to set s from a Python global function &gt;&gt;

    if not s:
        &lt;&lt; get s using inspect &gt;&gt;

    &lt;&lt; remove 'self' from s, but not from args &gt;&gt;
    if isStringMethod:
        &lt;&lt; remove 's' from s *and* args &gt;&gt;

    # s = s.rstrip(')') # Not so convenient.
    &lt;&lt; insert the text and set j1 and j2 &gt;&gt;

    # End autocompletion mode, putting the insertion point after the suggested calltip.
    self.finish()
    c.widgetWantsFocusNow(w)
    if 1: # Seems to be more useful.
        w.setSelectionRange(j1,j2,insert=j2)
    else:
        w.setInsertPoint(j2)
    &lt;&lt; put the status line &gt;&gt;
</t>
<t tx="ekr.20090401102247.518"># The first line of the docstring is good enough, except for classes.
f = __builtins__.get(self.leadinWord)
doc = f and type(f) != types.ClassType and f.__doc__
if doc:
    # g.trace(doc)
    s = g.splitLines(doc)
    s = args = s and s [0] or ''
    i = s.find('(')
    if i &gt; -1: s = s [i:]
    else: s = '(' + s
    s = s and s.strip() or ''
</t>
<t tx="ekr.20090401102247.519">isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType

# g.trace(self.prevObjects)

if isStringMethod and hasattr(string,obj.__name__):
    # A hack. String functions are builtins, and getargspec doesn't handle them.
    # Get the corresponding string function instead, and remove the s arg later.
    obj = getattr(string,obj.__name__)

try:
    s1,s2,s3,s4 = inspect.getargspec(obj)
except:
    self.extendSelection('(')
    self.finish()
    return # Not a function.  Just '('.

s = args = inspect.formatargspec(s1,s2,s3,s4)
</t>
<t tx="ekr.20090401102247.520">if g.match(s,1,'self,'):
    s = s[0] + s[6:].strip()
elif g.match_word(s,1,'self'):
    s = s[0] + s[5:].strip()
</t>
<t tx="ekr.20090401102247.521">if g.match(s,1,'s,'):
    s = s[0] + s[3:]
    args = args[0] + args[3:]
elif g.match_word(s,1,'s'):
    s = s[0] + s[2:]
    args = args[0] + args[2:]
</t>
<t tx="ekr.20090401102247.522">junk,j = w.getSelectionRange() # Returns insert point if no selection.
w.insert(j,s)
c.frame.body.onBodyChanged('Typing')
j1 = j + 1 ; j2 = j + len(s)
</t>
<t tx="ekr.20090401102247.523">c.frame.clearStatusLine()
if obj:
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
else:
    name = self.leadinWord
c.frame.putStatusLine('%s %s' % (name,args))
</t>
<t tx="ekr.20090401102247.524">def chain (self):

    c = self.c ; w = self.widget
    word = w.getSelectedText()
    old_obj = self.theObject

    if word and old_obj and type(old_obj) == type([]) and old_obj == sys.modules:
        obj = old_obj.get(word)
        if obj:
            self.theObject = obj
            self.clearTabName()
    elif word and old_obj and self.hasAttr(old_obj,word):
        self.push(old_obj)
        self.theObject = obj = self.getAttr(old_obj,word)
    else: obj = None

    if obj:
        self.appendToKnownObjects(obj)
        self.leadinWord = word
        self.membersList = self.getMembersList(obj)
        self.appendTabName(word)
        self.extendSelection('.')
        i = w.getInsertPoint()
        w.setSelectionRange(i,i,insert=i)
        # g.trace('chaining to',word,self.theObject)
        # Similar to start logic.
        self.prefix = ''
        self.selection = w.getSelectionRange()
        self.selectedText = w.getSelectedText()
        if self.membersList:
            # self.autoCompleterStateHandler(event=None)
            self.computeCompletionList()
            return
    self.extendSelection('.')
    self.finish()
</t>
<t tx="ekr.20090401102247.525">def doBackSpace (self):

    '''Cut back to previous prefix.'''

    trace = False and not g.unitTesting
    if trace: g.trace('(autocompleter)',self.prefix,self.theObject,self.prevObjects)

    c = self.c
    if self.prefix:
        self.prefix = self.prefix[:-1]
        self.setSelection(self.prefix)
        self.computeCompletionList()
    elif self.theObject:
        if self.prevObjects:
            obj = self.pop()
        else:
            obj = self.theObject
        # g.trace(self.theObject,obj)
        w = self.widget
        s = w.getAllText()
        i,junk = w.getSelectionRange()
        ch = 0 &lt;= i-1 &lt; len(s) and s[i-1] or ''
        # g.trace(ch)
        if ch == '.':
            self.theObject = obj
            w.delete(i-1)
            c.frame.body.onBodyChanged(undoType='Typing')
            i,j = g.getWord(s,i-2)
            word = s[i:j]
            # g.trace(i,j,repr(word))
            w.setSelectionRange(i,j,insert=j)
            self.prefix = word
            self.popTabName()
            self.membersList = self.getMembersList(obj)
            # g.trace(len(self.membersList))
            if self.membersList:
                self.computeCompletionList()
            else:
                self.abort()
        else:
            self.abort() # should not happen.
    else:
        self.abort()            
</t>
<t tx="ekr.20090401102247.526">def doTabCompletion (self):

    '''Handle tab completion when the user hits a tab.'''

    c = self.c ; w = self.widget
    s = w.getSelectedText()

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex &gt;= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.widgetWantsFocusNow(w)
</t>
<t tx="ekr.20090401102247.527">def extendSelection (self,s):

    '''Append s to the presently selected text.'''

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    i,j = w.getSelectionRange()
    w.insert(j,s)
    j += 1
    w.setSelectionRange(i,j,insert=j)
    c.frame.body.onBodyChanged('Typing')</t>
<t tx="ekr.20090401102247.528">def findCalltipWord (self,w):

    i = w.getInsertPoint()
    s = w.getAllText()
    if i &gt; 0:
        i,j = g.getWord(s,i-1)
        word = s[i:j]
        return word
    else:
        return ''</t>
<t tx="ekr.20090401102247.529">def findAnchor (self,w):

    '''Returns (j,word) where j is a Python index.'''

    i = j = w.getInsertPoint()
    s = w.getAllText()

    # New in Leo 4.5: Fix a hanger by stopping when i &lt;= 1.
    while i &gt; 1 and s[i-1] == '.':
        i,j = g.getWord(s,i-2)

    word = s[i:j]
    if word == '.': word = None

    # g.trace(i,j,repr(word))
    return j,word</t>
<t tx="ekr.20090401102247.530">def finish (self):

    c = self.c ; k = c.k

    k.keyboardQuit(event=None,setDefaultStatus=False)
        # Stay in the present input state.

    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)

    c.frame.body.onBodyChanged('Typing')
    c.recolor()
    self.clear()
    self.theObject = None
</t>
<t tx="ekr.20090401102247.531"># The values of self.attrDictDic are anonymous attrDict's.
# attrDicts: keys are strings, values are lists of strings.

def getAttr (self,obj,attr):

    '''Simulate getattr function, regardless of langauge.'''

    if self.language == 'python':
        return getattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList and attr

def hasAttr (self,obj,attr):

    '''Simulate hasattr function, regardless of langauge.'''

    if self.language == 'python':
        return hasattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList
</t>
<t tx="ekr.20090401102247.532">def getLeadinWord (self,w):

    self.verbose = False # User must explicitly ask for verbose.
    self.leadinWord = None
    start = w.getInsertPoint()
    s = w.getAllText()
    start -= 1
    i,word = self.findAnchor(w)

    if word and word.isdigit():
        self.membersList = []
        return False

    self.setObjectAndMembersList(word)
    # g.trace(word,self.theObject,len(self.membersList))

    if not word:
        self.membersList = []
        return False
    elif not self.theObject:
        self.membersList = []
        return False
    else:
        self.beginTabName(word)
        while 0 &lt;= i &lt; start and i &lt;len(s):
            if s[i] != '.':
                return False
            i,j = g.getWord(s,i+1)
            word = s[i:j]
            # g.trace(word,i,j,start)
            self.setObjectAndMembersList(word)
            if not self.theObject:
                # g.trace('unknown',word)
                return False
            self.appendTabName(word)
            i = j
        self.leadinWord = word
        return True
</t>
<t tx="ekr.20090401102247.533">def getMembersList (self,obj):

    '''Return a list of possible autocompletions for self.leadinWord.'''

    if obj:
        aList = inspect.getmembers(obj)
        members = ['%s:%s' % (a,g.prettyPrintType(b))
            for a,b in aList if not a.startswith('__')]
        members.sort()
        return members
    else:
        return []
</t>
<t tx="ekr.20090401102247.534">def info (self):

    c = self.c ; doc = None ; obj = self.theObject ; w = self.widget

    word = w.getSelectedText()

    if not word:
        # Never gets called, but __builtin__.f will work.
        word = self.findCalltipWord(w)
        if word:
            # Try to get the docstring for the Python global.
            f = __builtins__.get(self.leadinWord)
            doc = f and f.__doc__

    if not doc:
        if not self.hasAttr(obj,word):
            g.es('no docstring for',word,color='blue')
            return
        obj = self.getAttr(obj,word)
        doc = inspect.getdoc(obj)

    if doc:
        c.frame.log.clearTab('Info',wrap='word')
        g.es('',doc,tabName='Info')
    else:
        g.es('no docstring for',word,color='blue')
</t>
<t tx="ekr.20090401102247.535">def insertNormalChar (self,ch,keysym):

    k = self.k ; w = self.widget

    if g.isWordChar(ch):
        # Look ahead to see if the character completes any item.
        s = w.getSelectedText() + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = w.getSelectedText()
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = w.getSelectedText()
        if ch == '(':
            # Similar to chain logic.
            obj = self.theObject
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.theObject)
                self.theObject = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()
</t>
<t tx="ekr.20090401102247.536">def push (self,obj):

    if obj is not None:
        self.prevObjects.append(obj)
        # g.trace(self.stackNames())

def pop (self):

    obj = self.prevObjects.pop()
    # g.trace(obj)
    return obj

def clear (self):

    self.prevObjects = []
    # g.trace(g.callers())

def stackNames (self):

    aList = []
    for z in self.prevObjects:
        if hasattr(z,'__name__'):
            aList.append(z.__name__)
        elif hasattr(z,'__class__'):
            aList.append(z.__class__.__name__)
        else:
            aList.append(str(z))
    return aList
</t>
<t tx="ekr.20090401102247.537">def setObjectAndMembersList (self,word):

    c = self.c

    if not word:
        # Leading dot shows all classes.
        self.leadinWord = None
        self.theObject = sys.modules
        self.membersList = sys.modules.keys()
        self.beginTabName('Modules')
    elif word in ( "'",'"'):
        word = 'aString' # This is in the objectsDict.
        self.clear()
        self.push(self.theObject)
        self.theObject = 'aString'
        self.membersList = self.getMembersList(self.theObject)
    elif self.theObject:
        self.getObjectFromAttribute(word)
    # elif word == 'self':
        # self.completeSelf()
    else:
        obj = self.objectDict.get(word) or sys.modules.get(word)
        self.completeFromObject(obj)

    # g.trace(word,self.theObject,len(self.membersList))
</t>
<t tx="ekr.20090401102247.538">def getObjectFromAttribute (self,word):

    obj = self.theObject

    if obj and self.hasAttr(obj,word):
        self.push(self.theObject)
        self.theObject = self.getAttr(obj,word)
        self.appendToKnownObjects(self.theObject)
        self.membersList = self.getMembersList(self.theObject)
    else:
        # No special support for 'self' here.
        # Don't clear the stack here!
        self.membersList = []
        self.theObject = None
</t>
<t tx="ekr.20090401102247.539">def completeSelf (self):

    # This scan will be fast if an instant object already exists.
    className,obj,p,s = self.classScanner.scan()
    # g.trace(className,obj,p,s and len(s))

    # First, look up the className.
    if not obj and className:
        obj = self.allClassesDict.get(className)
        # if obj: g.trace('found in allClassesDict: %s = %s' % (className,obj))

    # Second, create the object from class definition.
    if not obj and s:
        theClass = self.computeClassObjectFromString(className,s)
        if theClass:
            obj = self.createProxyObjectFromClass(className,theClass)
            if obj:
                self.selfObjectsDict [className] = obj
                # This prevents future rescanning, even if the node moves.
                self.selfTnodesDict [p.v.t] = obj
    if obj:
        self.selfClassName = className
        self.push(self.theObject)
        self.theObject = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        # No further action possible or desirable.
        self.selfClassName = None
        self.theObject = None
        self.clear()
        self.membersList = []
</t>
<t tx="ekr.20090401102247.540">def completeFromObject (self,obj):

    if obj:
        self.appendToKnownObjects(obj)
        self.push(self.theObject)
        self.theObject = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        self.theObject = None
        self.clear()
        self.membersList = []
</t>
<t tx="ekr.20090401102247.541">def setSelection (self,s):

    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)

    if w.hasSelection():
        i,j = w.getSelectionRange()
        w.delete(i,j)
    else:
        i = w.getInsertPoint()

    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n &gt; -1: s = s[:n]

    w.insert(i,s)
    j = i + len(s)
    w.setSelectionRange(i,j,insert=j)

    # New in Leo 4.4.2: recolor immediately to preserve the new selection in the new colorizer.
    c.frame.body.recolor(c.p,incremental=True)
    # Usually this call will have no effect because the body text has not changed.
    c.frame.body.onBodyChanged('Typing')
</t>
<t tx="ekr.20090401102247.542">def start (self,event=None,w=None,prefix=None):

    c = self.c
    if w: self.widget = w
    else: w = self.widget

    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = g.choose(prefix is None,'',prefix)
    self.selection = w.getSelectionRange()
    self.selectedText = w.getSelectedText()
    flag = self.getLeadinWord(w)
    if self.membersList:
        if not flag:
            # Remove the (leading) invocation character.
            i = w.getInsertPoint()
            s = w.getAllText()
            if i &gt; 0 and s[i-1] == '.':
                s = g.app.gui.stringDelete(s,i-1)
                w.setAllText(s)
                c.frame.body.onBodyChanged('Typing')
        if self.useTabs:
            self.autoCompleterStateHandler(event)
        else:
            self.computeCompletionList()
            return self.tabList
    else:
        self.abort()
</t>
<t tx="ekr.20090401102247.543">if 0: # Not used at present.
    @others
</t>
<t tx="ekr.20090401102247.544"># Don't call this finishCreate: the startup logic would call it too soon.

def initialScan (self):

    g.trace(g.callers())

    self.scan(thread=True)
</t>
<t tx="ekr.20090401102247.545">def scan (self,event=None,verbose=True,thread=True):

    c = self.c
    if not c or not c.exists or c.frame.isNullFrame: return
    if g.app.unitTesting: return

    # g.trace('autocompleter')

    if 0: # thread:
        # Use a thread to do the initial scan so as not to interfere with the user.            
        def scan ():
            #g.es("This is for testing if g.es blocks in a thread", color = 'pink' )
            # During unit testing c gets destroyed before the scan finishes.
            if not g.app.unitTesting:
                self.scanOutline(verbose=True)

        t = threading.Thread(target=scan)
        t.setDaemon(True)
        t.start()
    else:
        self.scanOutline(verbose=verbose)
</t>
<t tx="ekr.20090401102247.546">def definePatterns (self):

    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))

    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars </t>
<t tx="ekr.20090401102247.547">def scanOutline (self,verbose=True):

    '''Traverse an outline and build the autocommander database.'''

    if verbose: g.es_print('scanning for auto-completer...')

    c = self.c ; k = self.k ; count = 0
    for p in c.allNodes_iter():
        if verbose:
            count += 1 ;
            if (count % 200) == 0: g.es('','.',newline=False)
        language = g.scanForAtLanguage(c,p)
        # g.trace('language',language,p.h)
        s = p.b
        if k.enable_autocompleter:
            self.scanForAutoCompleter(s)
        if k.enable_calltips:
            self.scanForCallTip(s,language)

    if 0:
        g.trace('watchwords...\n\n')
        for key in sorted(self.watchwords):
            aList = self.watchwords.get(key)
            g.trace('%s:\n\n' % (key), g.listToString(aList))
    if 0:
        g.trace('calltips...\n\n')
        for key in sorted(self.calltips):
            d = self.calltips.get(key)
            if d:
                g.trace('%s:\n\n' % (key), g.dictToString(d))

    if verbose:        
        g.es_print('\nauto-completer scan complete',color='blue')
</t>
<t tx="ekr.20090401102247.548">def scanForCallTip (self,s,language):

    '''this function scans text for calltip info'''

    d = self.calltips.get(language,{})
    pat = self.pats.get(language or 'python')

    # Set results to a list of all the function/method defintions in s.
    results = pat and pat.findall(s) or []

    for z in results:
        if isinstance(z,tuple): z = z [0]
        pieces2 = z.split('(')
        # g.trace(pieces2)
        pieces2 [0] = pieces2 [0].split() [-1]
        a, junk = pieces2 [0], pieces2 [1]
        aList = d.get(a,[])
        if str(z) not in aList:
            aList.append(str(z))
            d [a] = aList

    self.calltips [language] = d
</t>
<t tx="ekr.20090401102247.549">def scanForAutoCompleter (self,s):

    '''This function scans text for the autocompleter database.'''

    aList = [] ; t1 = s.split('.')

    if 1: # Slightly faster.
        t1 = s.split('.') ; 
        i = 0 ; n = len(t1)-1
        while i &lt; n:
            self.makeAutocompletionList(t1[i],t1[i+1],aList)
            i += 1
    else:
        reduce(lambda a,b: self.makeAutocompletionList(a,b,aList),t1)

    if aList:
        for a, b in aList:
            z = self.watchwords.get(a,[])
            if str(b) not in z:
                z.append(str(b))
                self.watchwords [a] = z
</t>
<t tx="ekr.20090401102247.550">def makeAutocompletionList (self,a,b,glist):

    '''We have seen a.b, where a and b are arbitrary strings.
    Append (a1.b1) to glist.
    To compute a1, scan backwards in a until finding whitespace.
    To compute b1, scan forwards in b until finding a char not in okchars.
    '''

    if 1: # Do everything inline.  It's a few percent faster.

        # Compute reverseFindWhitespace inline.
        i = len(a) -1
        while i &gt;= 0:
            if a[i].isspace() or a [i] == '.':
                a1 = a [i+1:] ; break
            i -= 1
        else:
            a1 = a

        # Compute getCleanString inline.
        i = 0
        for ch in b:
            if ch not in self.okchars:
                b1 = b[:i] ; break
            i += 1
        else:
            b1 = b

        if b1:
            glist.append((a1,b1),)

        return b # Not needed unless we are using reduce.
    else:
        a1 = self.reverseFindWhitespace(a)
        if a1:
            b1 = self.getCleanString(b)
            if b1:
                glist.append((a1,b1))
        return b
</t>
<t tx="ekr.20090401102247.551">def reverseFindWhitespace (self,s):

    '''Return the longest tail of s containing no whitespace or period.'''

    i = len(s) -1
    while i &gt;= 0:
        if s[i].isspace() or s [i] == '.': return s [i+1:]
        i -= 1

    return s
</t>
<t tx="ekr.20090401102247.552">def getCleanString (self,s):

    '''Return the prefix of s containing only chars in okchars.'''

    i = 0
    for ch in s:
        if ch not in self.okchars:
            return s[:i]
        i += 1

    return s
</t>
<t tx="ekr.20090401102247.553"></t>
<t tx="ekr.20090401102247.554">def createProxyObjectFromClass (self,className,theClass):

    '''Create a dummy instance object by instantiating theClass with a dummy ctor.'''

    if 0: # Calling the real ctor is way too dangerous.
        # Set args to the list of required arguments.
        args = inspect.getargs(theClass.__init__.im_func.func_code)
        args = args[0] ; n = len(args)-1
        args = [None for z in range(n)]

    def dummyCtor (self):
        pass

    try:
        obj = None
        old_init = hasattr(theClass,'__init__') and theClass.__init__
        theClass.__init__ = dummyCtor
        obj = theClass()
    finally:
        if old_init:
            theClass.__init__ = old_init
        else:
            delattr(theClass,'__init__')

    g.trace(type(theClass),obj)

    # Verify that it has all the proper attributes.
    # g.trace(g.listToString(dir(obj)))
    return obj
</t>
<t tx="ekr.20090401102247.555">def computeClassObjectFromString (self,className,s):

    try:
        # Add the the class definition to the present environment.
        exec(s) ### Security violation!

        # Get the newly created object from the locals dict.
        theClass = locals().get(className)
        return theClass

    except Exception:
        if 1: # Could be a weird kind of user error.
            g.es_print('unexpected exception in',computeProxyObject)
            g.es_exception()
        return None
</t>
<t tx="ekr.20090401102247.556">class forgivingParserClass:

    '''A class to create a valid class instances from
    a class definition that may contain syntax errors.'''

    @others
</t>
<t tx="ekr.20090401102247.557">def __init__ (self,c):

    self.c = c
    self.excludedTnodesList = []
    self.old_putBody = None # Set in parse for communication with newPutBody.
</t>
<t tx="ekr.20090401102247.558">def parse (self,p):

    '''The top-level parser method.

    It patches c.atFileCommands.putBody, calls the forgiving parser and finally
    restores c.atFileCommands.putBody.'''

    c = self.c

    # Create an ivar for communication with newPutBody.
    self.old_putBody = c.atFileCommands.putBody

    # Override atFile.putBody.
    c.atFileCommands.putBody = self.newPutBody

    try:
        s = None
        s = self.forgivingParser(p)
    finally:
        c.atFileCommands.putBody = self.old_putBody

    return s # Don't put a return in a finally clause.


</t>
<t tx="ekr.20090401102247.559">def forgivingParser (self,p):

    c = self.c ; root = p.copy()
    self.excludedTnodesList = []
    s = g.getScript(c,root,useSelectedText=False)
    while s:
        try:
            val = compiler.parse(s+'\n')
            break
        except (parser.ParserError,SyntaxError):
            fileName, n = g.getLastTracebackFileAndLineNumber()
            p = self.computeErrorNode(c,root,n,lines=g.splitLines(s))
            if not p or p == root:
                g.es_print('syntax error in class node: can not continue')
                s = None ; break
            else:
                # g.es_print('syntax error: deleting',p.h)
                self.excludedTnodesList.append(p.v.t)
                s = g.getScript(c,root,useSelectedText=False)
    return s or ''
</t>
<t tx="ekr.20090401102247.560">def computeErrorNode (self,c,root,n,lines):

    '''The from c.goToLineNumber that applies to scripts.
    Unlike c.gotoLineNumberOpen, this function returns a position.'''

    if n == 1 or n &gt;= len(lines):
        return root

    vnodeName, junk, junk, junk, junk = c.convertLineToVnodeNameIndexLine(
        lines, n, root, scriptFind = True)

    if vnodeName:
        for p in root.self_and_subtree_iter():
            if p.matchHeadline(vnodeName):
                return p

    return None
</t>
<t tx="ekr.20090401102247.561">def newPutBody (self,p,oneNodeOnly=False,fromString=''):

    if p.v.t in self.excludedTnodesList:
        pass
        # g.trace('ignoring',p.h)
    else:
        self.old_putBody(p,oneNodeOnly,fromString)
</t>
<t tx="ekr.20090401102247.562">class classScannerClass:

    '''A class to find class definitions in a node or its parents.'''

    @others
</t>
<t tx="ekr.20090401102247.563">def __init__ (self,c):

    self.c = c

    # Ignore @root for now:
    # self.start_in_doc = c.config.getBool('at_root_bodies_start_in_doc_mode')

    self.start_in_doc = False
</t>
<t tx="ekr.20090401102247.564">def scan (self):

    c = self.c

    className,obj,p = self.findParentClass(c.p)
    # g.trace(className,obj,p)

    if p and not obj:
        parser = c.k.autoCompleter.forgivingParser
        s = parser.parse(p)
    else:
        s = None

    return className,obj,p,s
</t>
<t tx="ekr.20090401102247.565">def findParentClass (self,root):

    autoCompleter = self.c.k.autoCompleter

    # First, see if any parent has already been scanned.
    for p in root.self_and_parents_iter():
        obj = autoCompleter.selfTnodesDict.get(p.v.t)
        if obj:
            # g.trace('found',obj,'in',p.h)
            return None,obj,p

    # Next, do a much slower scan.
    # g.trace('slow scanning...')
    for p in root.self_and_parents_iter():
        className = self.findClass(p)
        if className:
            # g.trace('found',className,'in',p.h)
            return className,None,p

    return None,None,None
</t>
<t tx="ekr.20090401102247.566">def findClass (self,p):

    lines = g.splitLines(p.b)
    inDoc = self.start_in_doc
    # g.trace(p.h)
    for s in lines:
        if inDoc:
            if self.endsDoc(s):
                inDoc = False
        else:
            if self.startsDoc(s):
                inDoc = True
            else:
                # Not a perfect scan: a triple-string could start with 'class',
                # but perfection is not important.
                className = self.startsClass(s)
                if className: return className
    else:
        return None
</t>
<t tx="ekr.20090401102247.567">def endsDoc (self,s):

    return s.startswith('@c')
</t>
<t tx="ekr.20090401102247.568">def startsClass (self,s):

    if s.startswith('class'):
        i = 5
        i = g.skip_ws(s,i)
        j = g.skip_id(s,i)
        word = s[i:j]
        # g.trace(word)
        return word
    else:
        return None
</t>
<t tx="ekr.20090401102247.569">def startsDoc (self,s):

    for s2 in ('@doc','@ ','@\n', '@r', '@\t'):
        if s.startswith(s2):
            return True
    else:
        return False
</t>
<t tx="ekr.20090401102247.570">@nocolor

I was playing around with this and I discovered that if I open
unitTest.leo from the File-&gt;Open menu pick of another leo outline and
then I run a unit test, then all the nodes from unitTest.leo appear in
the original document.  If I execute a save on the original document
(now with the unitTest.leo nodes), then the leo file gets overwritten
with the contents unitTest.leo.

=====

Added a warning in unitTest.leo:

Do not run tests from this file after opening unitTest.leo from another .leo
file. The unit tests in this file open and close many .leo files and many
strange things can happen if you have opened this file from another file.</t>
<t tx="ekr.20090401102247.571"></t>
<t tx="ekr.20090401102247.572">- Use sorted(dict) everywhere.

- Removed many calls to d.keys()</t>
<t tx="ekr.20090401102247.573"># They were due to __cmp__ not being called.
# Replaced p.__cmp__ with p.__eq__ and p.__ne__.</t>
<t tx="ekr.20090401102247.574"></t>
<t tx="ekr.20090401102247.575">def doMenus (self,p,kind,name,val):

    c = self.c ; aList = [] ; tag = '@menu' ; trace = False and g.isPython3
    p = p.copy() ; after = p.nodeAfterTree()
    if trace: g.trace('******',p.h,'after',after and after.h)
    while p and p != after:
        self.debug_count += 1
        h = p.h
        # if trace:
            # if p.h==after.h:
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace('***',self.debug_count,p.h)
            # if self.debug_count &gt;= 1000:
                # g.trace('*'*10,'terminating!') ; return
        if g.match_word(h,0,tag):
            name = h[len(tag):].strip()
            if name:
                for z in aList:
                    name2,junk,junk = z
                    if name2 == name:
                        self.error('Replacing previous @menu %s' % (name))
                        break
                aList2 = []
                kind = '%s %s' % (tag,name)
                self.doItems(p,aList2)
                aList.append((kind,aList2,None),)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
        else:
            p.moveToThreadNext()

    # g.trace('localFlag',self.localFlag,c)
    if self.localFlag:
        self.set(p,kind='menus',name='menus',val=aList)
    else:
        if not g.app.unitTesting and not g.app.silentMode:
            g.es_print('Using menus from',c.shortFileName(),color='blue')
        g.app.config.menusList = aList
        g.app.config.menusFileName = c and c.shortFileName() or '&lt;no settings file&gt;'
</t>
<t tx="ekr.20090401102247.576">def doItems (self,p,aList):

    trace = False and g.isPython3
    if trace: g.trace(p.h)
    p = p.copy()
    after = p.nodeAfterTree()
    p.moveToThreadNext()
    if trace: g.trace(self.debug_count,p.h,'after',after and after.h)
    while p and p != after:
        self.debug_count += 1
        h = p.h
        # if trace:
            # if p.h==after.h:
                # val = p != after
                # g.trace('*' * 10, 'terminating via headString',p,after)
                # return
            # g.trace(self.debug_count,h)
            # if self.debug_count &gt;= 1000:
                # g.trace('*'*10,'terminating!') ; return
        for tag in ('@menu','@item'):
            if g.match_word(h,0,tag):
                itemName = h[len(tag):].strip()
                if itemName:
                    if tag == '@menu':
                        aList2 = []
                        kind = '%s %s' % (tag,itemName)
                        self.doItems(p,aList2)
                        aList.append((kind,aList2,None),)
                        p.moveToNodeAfterTree()
                        break
                    else:
                        kind = tag
                        head = itemName
                        body = p.b
                        aList.append((kind,head,body),)
                        p.moveToThreadNext()
                        break
        else:
            # g.trace('***skipping***',p.h)
            p.moveToThreadNext()
</t>
<t tx="ekr.20090401102247.577">def dumpMenuList (self,aList,level=0):

    for z in aList:
        kind,val,val2 = z
        if kind == '@item':
            g.trace(level,kind,val,val2)
        else:
            g.pr('')
            g.trace(level,kind,'...')
            self.dumpMenuList(val,level+1)</t>
<t tx="ekr.20090401102247.578">def traverse (self):

    c = self.c

    p = g.app.config.settingsRoot(c)
    if not p:
        # g.trace('no settings tree for %s' % c)
        return None

    self.settingsDict = {}
    self.shortcutsDict = {}
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        # if g.isPython3:
            # g.trace(result,p.h)
            # if p.h == 'Menus': g.pdb()
        if result == "skip":
            # g.es_print('skipping settings in',p.h,color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    return self.settingsDict
</t>
<t tx="ekr.20090401102247.579">def readSettingsFiles (self,fileName,verbose=True):

    seen = []
    self.write_recent_files_as_needed = False # Will be set later.
    &lt;&lt; define localDirectory, localConfigFile &amp; myLocalConfigFile &gt;&gt;

    # g.trace(g.app.oneConfigFilename)
    table = (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (localConfigFile,False),
        (self.myGlobalConfigFile,False),
        (self.myHomeConfigFile,False),
        (self.machineConfigFile,False),
        (myLocalConfigFile,False),
        # New in Leo 4.6: the -c file is in *addition* to other config files.
        (g.app.oneConfigFilename,False),
        (fileName,True),
    )

    # Init settings from leoSettings.leo and myLeoSettings.leo files.
    for path,localFlag in table:
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            # Bug fix: 6/3/08: make sure we mark files seen no matter how they are specified.
        isZipped = path and zipfile.is_zipfile(path)
        isLeo = isZipped or (path and path.endswith('.leo'))
        if isLeo and path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose and not g.app.unitTesting and not self.silent and not g.app.batchMode:
                s = 'reading settings in %s' % path
                # This occurs early in startup, so use the following instead of g.es_print.
                if not g.isPython3:
                    s = g.toEncodedString(s,'ascii')
                g.pr(s)
                g.app.logWaiting.append((s+'\n','blue'),)

            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
                self.write_recent_files_as_needed = c.config.getBool('write_recent_files_as_needed')
                self.setIvarsFromSettings(c)
    self.readRecentFiles(localConfigFile)
    # self.createMyLeoSettingsFile(myLocalConfigFile)
    self.inited = True
    self.setIvarsFromSettings(None)
</t>
<t tx="ekr.20090401102247.580"># This can't be done in initSettingsFiles because
# the local directory does not yet exist.
localDirectory = g.os_path_dirname(fileName)

#  Set the local leoSettings.leo file.
localConfigFile = g.os_path_join(localDirectory,'leoSettings.leo')
if not g.os_path_exists(localConfigFile):
    localConfigFile = None

# Set the local myLeoSetting.leo file.
myLocalConfigFile = g.os_path_join(localDirectory,'myLeoSettings.leo')
if not g.os_path_exists(myLocalConfigFile):
    myLocalConfigFile = None</t>
<t tx="ekr.20090401102247.581">def createMyLeoSettingsFile (self,localConfigFile):

    '''Create home.myLeoSettings.leo if no other myLeoSettings.leo file exists.'''

    &lt;&lt; define s, a minimalMyLeoSettings.leo string &gt;&gt;

    for path in (
        localConfigFile,
        self.myGlobalConfigFile,
        self.myHomeConfigFile
    ):
        # g.trace(path)
        if path:
            path = g.os_path_realpath(g.os_path_finalize(path))
            if g.os_path_exists(path):
                # g.trace('exists',path)
                return

    if g.app.homeDir:
        path = g.os_path_finalize_join(g.app.homeDir,'myLeoSettings.leo')
        try:
            f = open(path,'wb')
            f.write(s)
            f.close()
            self.myHomeConfigFile = path
            # It's early in the startup: g.es does not work yet.
            s = 'created: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
        except Exception:
            s = 'can not create: %s' % (self.myHomeConfigFile)
            g.pr(s)
            g.app.logWaiting.append((s+'\n','red'),)
            g.es_exception()
</t>
<t tx="ekr.20090401102247.582">s = '''&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;?xml-stylesheet ekr_test?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/&gt;
&lt;globals body_outline_ratio="0.5"&gt;
	&lt;global_window_position top="26" left="122" height="781" width="953"/&gt;
	&lt;global_log_window_position top="0" left="0" height="0" width="0"/&gt;
&lt;/globals&gt;
&lt;preferences/&gt;
&lt;find_panel_settings/&gt;
&lt;vnodes&gt;
&lt;v t="ekr.20070411164127" str_leo_pos="0"&gt;&lt;vh&gt;@chapters&lt;/vh&gt;
&lt;v t="ekr.20070411164127.1"&gt;&lt;vh&gt;@chapter trash&lt;/vh&gt;&lt;/v&gt;
&lt;/v&gt;
&lt;v t="ekr.20070411164127.2"&gt;&lt;vh&gt;@settings&lt;/vh&gt;&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;t tx="ekr.20070411164127"&gt;&lt;/t&gt;
&lt;t tx="ekr.20070411164127.1"&gt;trash&lt;/t&gt;
&lt;t tx="ekr.20070411164127.2"&gt;&lt;/t&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;
'''
</t>
<t tx="ekr.20090401102247.583">def openSettingsFile (self,path):

    theFile,isZipped = g.openLeoOrZipFile(path)
    if not theFile: return None

    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=path,relativeFileName=None,
        initEditCommanders=False,updateRecentFiles=False)
    frame.log.enable(False)
    c.setLog()
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
</t>
<t tx="ekr.20090401102247.584">def updateSettings (self,c,localFlag):

    d = self.readSettings(c,localFlag)

    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)

    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.trace(d and d.keys())
</t>
<t tx="ekr.20090401102247.585"># Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c,localFlag):

    """Read settings from a file that may contain an @settings tree."""

    # g.trace('=' * 20, c.fileName())

    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c,localFlag)
    d = parser.traverse()

    return d
</t>
<t tx="ekr.20090401102247.586"></t>
<t tx="ekr.20090401102247.587">def parse_leo_file (self,theFile,inputFileName,silent,inClipboard,s=None):

    c = self.c
    # g.trace('hiddenRootNode',c.hiddenRootNode)

    try:
        if g.isPython3:
            if theFile:
                pass # Just use the open binary file, opened by g.openLeoOrZipFile.
            else:
                theFile = StringIO(s)
        else:
            if theFile:
                s = theFile.read()
            theFile = cStringIO.StringIO(s)
        parser = xml.sax.make_parser()
        parser.setFeature(xml.sax.handler.feature_external_ges,1)
            # Include external general entities, esp. xml-stylesheet lines.
        if 0: # Expat does not read external features.
            parser.setFeature(xml.sax.handler.feature_external_pes,1)
                # Include all external parameter entities
                # Hopefully the parser can figure out the encoding from the &lt;?xml&gt; element.
        handler = saxContentHandler(c,inputFileName,silent,inClipboard)
        parser.setContentHandler(handler)
        parser.parse(theFile) # expat does not support parseString
        # g.trace('parsing done')
        sax_node = handler.getRootNode()
    except xml.sax.SAXParseException:
        g.es_print('error parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None
    except Exception:
        g.es_print('unexpected exception parsing',inputFileName,color='red')
        g.es_exception()
        sax_node = None

    return sax_node
</t>
<t tx="ekr.20090401102247.588"></t>
<t tx="ekr.20090401102247.589">def doPlugins(tag,keywords):

    if g.app.killed:
        return

    if g.isPython3:
        g.trace('ignoring all plugins')
        return

    # g.trace(tag)
    if tag in ('start1','open0'):
        loadHandlers(tag)

    return doHandlersForTag(tag,keywords)
</t>
<t tx="ekr.20090401102247.590"></t>
<t tx="ekr.20090401102247.591">def run(fileName=None,pymacs=None,*args,**keywords):

    """Initialize and run Leo"""

    trace = False and not g.unitTesting
    if trace: print ('runLeo.run: sys.argv %s' % sys.argv)
    if not isValidPython(): return
    g.computeStandardDirectories()
    adjustSysPath()
    fileName2,gui,script,windowFlag = scanOptions()
    if fileName2: fileName = fileName2
    # print ('runLeo.run: sys.argv %s' % sys.argv)
    # print ('runLeo.run: fileName %s' % fileName)
    if pymacs: script,windowFlag = None,False
    verbose = script is None
    initApp(verbose)
    fileName,relativeFileName = getFileName(fileName,script)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config and *before* opening plugins.
    # This means if-gui has effect only in per-file settings.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    createSpecialGui(gui,pymacs,script,windowFlag)
    g.doHook("start1") # Load plugins. Plugins may create g.app.gui.
    if g.app.killed: return # Support for g.app.forceShutdown.
    # g.trace('g.app.gui after plugins loaded',g.app.gui)
    if g.app.gui == None: g.app.createTkGui() # Creates global windows.
    g.init_sherlock(args)  # Init tracing and statistics.
    if g.app and g.app.use_psyco: startPsyco()
    # Clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName,relativeFileName,script)
    if not frame: return
    finishInitApp(c)
    p = c.p
    g.app.initComplete = True
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    if c.config.getBool('allow_idle_time_hook'): g.enableIdleTimeHook()
    initFocusAndDraw(c,fileName)
    g.app.gui.runMainLoop()
</t>
<t tx="ekr.20090401102247.592">def adjustSysPath ():

    '''Adjust sys.path to enable imports as usual with Leo.'''

    #g.trace('loadDir',g.app.loadDir)

    leoDirs = ('config','doc','extensions','modes','plugins','core','test')

    for theDir in leoDirs:
        path = g.os_path_finalize_join(g.app.loadDir,'..',theDir)
        if path not in sys.path:
            sys.path.append(path)
</t>
<t tx="ekr.20090401102247.593">def createFrame (fileName,relativeFileName,script):

    """Create a LeoFrame during Leo's startup process."""

    # Only allow .zip and .leo files.
    if fileName:
        table = ('.leo','.zip',)
        for ext in table:
            if fileName.endswith(ext):
                break
        else:
            g.es_print('invalid Leo file extension: %s' % (
                relativeFileName))
            fileName = relativeFileName = None

    # New in Leo 4.6: support for 'default_leo_file' setting.
    if not fileName and not script:
        fileName = g.app.config.getString(c=None,setting='default_leo_file')
        fileName = g.os_path_finalize(fileName)
        if fileName and g.os_path_exists(fileName):
            g.es_print('opening default_leo_file:',fileName,color='blue')

    # Try to create a frame for the file.
    if fileName and g.os_path_exists(fileName):
        ok, frame = g.openWithFileName(relativeFileName or fileName,None)
        if ok: return frame.c,frame

    # Create a _new_ frame &amp; indicate it is the startup window.
    c,frame = g.app.newLeoCommanderAndFrame(
        fileName=fileName,
        relativeFileName=relativeFileName,
        initEditCommanders=True)
    assert frame.c == c and c.frame == frame
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio)
    frame.startupWindow = True
    if c.chapterController:
        c.chapterController.finishCreate()
        c.setChanged(False) # Clear the changed flag set when creating the @chapters node.
    # Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    p = c.p
    if not g.doHook("menu1",c=frame.c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)

    # Report the failure to open the file.
    if fileName:
        g.es_print("file not found:",fileName,color='red')

    c.redraw()
    return c,frame
</t>
<t tx="ekr.20090401102247.594">def createSpecialGui(gui,pymacs,script,windowFlag):

    if False and g.isPython3:
        # Create the curses gui.
        leoPlugins.loadOnePlugin ('cursesGui',verbose=True)
    elif pymacs:
        createNullGuiWithScript(None)
    # elif jyLeo:
        # import leo.core.leoSwingGui as leoSwingGui
        # g.app.gui = leoSwingGui.swingGui()
    elif script:
        if windowFlag:
            g.app.createTkGui() # Creates global windows.
            g.app.gui.setScript(script)
            sys.args = []
        else:
            createNullGuiWithScript(script)
    elif gui == 'qt':   g.app.createQtGui()
    elif gui == 'tk':   g.app.createTkGui()
    elif gui == 'wx':   g.app.createWxGui()</t>
<t tx="ekr.20090401102247.595">def createNullGuiWithScript (script):

    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    g.app.gui.setScript(script)
</t>
<t tx="ekr.20090401102247.596">def finishInitApp(c):

    g.app.trace_gc          = c.config.getBool('trace_gc')
    g.app.trace_gc_calls    = c.config.getBool('trace_gc_calls')
    g.app.trace_gc_verbose  = c.config.getBool('trace_gc_verbose')

    g.app.writeWaitingLog()

    if g.app.disableSave:
        g.es("disabling save commands",color="red")
</t>
<t tx="ekr.20090401102247.597">def initApp (verbose):

    # Force the user to set g.app.leoID.
    g.app.setLeoID(verbose=verbose)
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
</t>
<t tx="ekr.20090401102247.598">def initFocusAndDraw(c,fileName):

    w = g.app.gui.get_focus(c)

    if not fileName:
        c.redraw()

    # Respect c's focus wishes if posssible.
    if w != c.frame.body.bodyCtrl and w != c.frame.tree.canvas:
        c.bodyWantsFocus()
        c.k.showStateAndMode(w)

    c.outerUpdate()
</t>
<t tx="ekr.20090401102247.599">def isValidPython():

    if sys.platform == 'cli':
        return True

    minimum_python_version = '2.4'

    message = """\
Leo requires Python %s or higher.
You may download Python from
http://python.org/download/
""" % minimum_python_version

    try:
        version = '.'.join([str(sys.version_info[i]) for i in (0,1,2)])
        # ok = g.CheckVersion(version,'2.4.0') # Soon.
        ok = g.CheckVersion(version,minimum_python_version)
        if not ok:
            print(message)
            try:
                # g.app.gui does not exist yet.
                import Tkinter as Tk
                &lt;&lt; define emergency dialog class &gt;&gt;
                d = emergencyDialog(title='Python Version Error',message=message)
                d.run()
            except Exception:
                pass
        return ok
    except Exception:
        print("isValidPython: unexpected exception: g.CheckVersion")
        traceback.print_exc()
        return 0
</t>
<t tx="ekr.20090401102247.600">class emergencyDialog:

    """A class that creates an Tkinter dialog with a single OK button."""

    @others
</t>
<t tx="ekr.20090401102247.601">def __init__(self,title,message):

    """Constructor for the leoTkinterDialog class."""

    self.answer = None # Value returned from run()
    self.title = title
    self.message=message

    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # Created in createTopFrame.
    self.top = None # The toplevel Tk widget.

    self.createTopFrame()
    buttons = {"text":"OK","command":self.okButton,"default":True}, # Singleton tuple.
    self.createButtons(buttons)
    self.top.bind("&lt;Key&gt;", self.onKey)
</t>
<t tx="ekr.20090401102247.602">def createButtons (self,buttons):

    """Create a row of buttons.

    buttons is a list of dictionaries containing the properties of each button."""

    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","&lt;missing button name&gt;")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)

        if isDefault and command:
            self.defaultButtonCommand = command

    return buttonList
</t>
<t tx="ekr.20090401102247.603">def createTopFrame(self):

    """Create the Tk.Toplevel widget for a leoTkinterDialog."""

    self.root = Tk.Tk()
    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)
    self.root.withdraw()

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")

    label = Tk.Label(self.frame,text=message,bg='white')
    label.pack(pady=10)
</t>
<t tx="ekr.20090401102247.604">def okButton(self):

    """Do default click action in ok button."""

    self.top.destroy()
    self.top = None

</t>
<t tx="ekr.20090401102247.605">def onKey(self,event):

    """Handle Key events in askOk dialogs."""

    self.okButton()

    return "break"
</t>
<t tx="ekr.20090401102247.606">def run (self):

    """Run the modal emergency dialog."""

    self.top.geometry("%dx%d%+d%+d" % (300,200,50,50))
    self.top.lift()

    self.top.grab_set() # Make the dialog a modal dialog.
    self.root.wait_window(self.top)
</t>
<t tx="ekr.20090401102247.607">@ To gather statistics, do the following in a Python window, not idle:

    import leo
    import leo.core.runLeo as runLeo
    runLeo.profile_leo()  (this runs leo)
    load leoDocs.leo (it is very slow)
    quit Leo.
@c

def profile_leo ():

    """Gather and print statistics about Leo"""

    import cProfile as profile
    import pstats
    import leo.core.leoGlobals as g
    import os

    # name = r"c:\leo.repo\trunk\leo\test\leoProfile.txt"
    # name = g.os_path_finalize_join(g.app.loadDir,'..','test','leoProfile.txt')
    theDir = os.getcwd()

    # On Windows, name must be a plain string. An apparent cProfile bug.
    name = str(g.os_path_normpath(g.os_path_join(theDir,'leoProfile.txt')))
    print ('profiling to %s' % name)
    profile.run('import leo ; leo.run()',name)
    p = pstats.Stats(name)
    p.strip_dirs()
    p.sort_stats('module','calls','time','name')
    reFiles='leoAtFile.py:|leoFileCommands.py:|leoGlobals.py|leoNodes.py:'
    p.print_stats(reFiles)

prof = profile_leo
</t>
<t tx="ekr.20090401102247.608">def reportDirectories(verbose):

    if verbose:
        for kind,theDir in (
            ("load",g.app.loadDir),
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir:" % (kind),theDir,color="blue")
</t>
<t tx="ekr.20090401102247.609">def scanOptions():

    '''Handle all options and remove them from sys.argv.'''

    parser = optparse.OptionParser()
    parser.add_option('-c', '--config', dest="one_config_path")
    parser.add_option('-f', '--file',   dest="fileName")
    parser.add_option('--gui',          dest="gui")
    parser.add_option('--silent',       action="store_true",dest="silent")
    parser.add_option('--script',       dest="script")
    parser.add_option('--script-window',dest="script_window")
    parser.add_option('--ipython',      action="store_true",dest="use_ipython")

    # Parse the options, and remove them from sys.argv.
    options, args = parser.parse_args()
    sys.argv = [sys.argv[0]] ; sys.argv.extend(args)
    # g.trace(sys.argv)

    # Handle the args...

    # -c or --config
    path = options.one_config_path
    if path:
        path = g.os_path_finalize_join(os.getcwd(),path)
        if g.os_path_exists(path):
            g.app.oneConfigFilename = path
        else:
            g.es_print('Invalid -c option: file not found:',path,color='red')

    # -f or --file
    fileName = options.fileName

    # -- gui
    gui = options.gui
    if gui:
        gui = gui.lower()
        if gui not in ('tk','qt','wx'):
            g.trace('unknown gui: %s' % gui)
            gui = None

    # --script
    script_path = options.script
    script_path_w = options.script_window
    if script_path and script_path_w:
        parser.error("--script and script-window are mutually exclusive")

    script_name = script_path or script_path_w
    if script_name:
        script_name = g.os_path_finalize_join(g.app.loadDir,script_name)
        try:
            f = None
            try:
                f = open(script_name,'r')
                script = f.read()
                # g.trace("script",script)
            except IOError:
                g.es_print("can not open script file:",script_name, color="red")
                script = None
        finally:
            if f: f.close()
    else:
        script = None

    # --silent
    g.app.silentMode = options.silent
    # g.trace('silentMode',g.app.silentMode)

    # --ipython

    g.app.useIpython = options.use_ipython
    # Compute the return values.
    windowFlag = script and script_path_w
    return fileName, gui, script, windowFlag
</t>
<t tx="ekr.20090401102247.610">def startPsyco ():

    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to:",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")

    except ImportError:
        g.app.use_psyco = False

    except:
        g.pr("unexpected exception importing psyco")
        g.es_exception()
        g.app.use_psyco = False
</t>
<t tx="ekr.20090401102247.611"></t>
<t tx="ekr.20090401102247.612"></t>
<t tx="ekr.20090401102247.613">def openLeoOrZipFile (fileName):

    try:
        isZipped = zipfile.is_zipfile(fileName)
        if isZipped:
            theFile = zipfile.ZipFile(fileName,'r')
            # g.trace('opened zip file',theFile)
        else:
            # mode = g.choose(g.isPython3,'r','rb')
            # 9/19/08: always use binary mode??
            mode = 'rb'
            theFile = open(fileName,mode)
        return theFile,isZipped
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.unitTesting:
            g.es_print("can not open:",fileName,color="blue")
        return None,False</t>
<t tx="ekr.20090401102247.614"></t>
<t tx="ekr.20090401102247.615"># 4.0: Don't use newline-pending logic.

def closeWriteFile (self):

    at = self

    if at.outputFile:
        at.outputFile.flush()
        if at.toString:
            at.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None
        return at.stringOutput
    else:
        return None
</t>
<t tx="ekr.20090401102247.616"># Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.

    The caller is responsible for handling newlines correctly."""

    @others
</t>
<t tx="ekr.20090401102247.617">def __init__(self,encoding='utf-8',fromString=None):

    # g.trace('g.fileLikeObject:__init__','fromString',fromString)

    # New in 4.2.1: allow the file to be inited from string s.

    self.encoding = encoding

    if fromString:
        self.list = g.splitLines(fromString) # Must preserve newlines!
    else:
        self.list = []

    self.ptr = 0

# In CStringIO the buffer is read-only if the initial value (fromString) is non-empty.
</t>
<t tx="ekr.20090401102247.618">def clear (self):

    self.list = []
</t>
<t tx="ekr.20090401102247.619">def close (self):

    pass

    # The StringIo version free's the memory buffer.
</t>
<t tx="ekr.20090401102247.620">def flush (self):

    pass
</t>
<t tx="ekr.20090401102247.621">def get (self):

    return ''.join(self.list)

getvalue = get # for compatibility with StringIo
read = get # for use by sax.
</t>
<t tx="ekr.20090401102247.622">def readline(self): # New for read-from-string (readOpenFile).

    if self.ptr &lt; len(self.list):
        line = self.list[self.ptr]
        # g.trace(repr(line))
        self.ptr += 1
        return line
    else:
        return ''
</t>
<t tx="ekr.20090401102247.623">def write (self,s):

    if s:
        if g.isBytes(s):
            s = g.toUnicode(s,self.encoding)

        self.list.append(s)
</t>
<t tx="ekr.20090401102247.624"></t>
<t tx="ekr.20090401102247.625"># The syntax of these functions must be valid on Python2K and Python3K.

def isBytes(s):
    '''Return True if s is Python3k bytes type.'''
    if g.isPython3:
        # Generates a pylint warning, but that can't be helped.
        return type(s) == type(bytes('a','utf-8'))
    else:
        return False

def isChar(s):
    '''Return True if s is a Python2K character type.'''
    if g.isPython3:
        return False
    else:
        return type(s) == types.StringType

def isString(s):
    '''Return True if s is any string, but not bytes.'''
    if g.isPython3:
        return type(s) == type('a')
    else:
        return type(s) in types.StringTypes

def isUnicode(s):
    '''Return True if s is a unicode string.'''
    if g.isPython3:
        return type(s) == type('a')
    else:
        return type(s) == types.UnicodeType
</t>
<t tx="ekr.20090401102247.626">def toEncodedString (s,encoding,reportErrors=False):

    if isPython3:
        if g.isString(s):
            try:
                s = s.encode(encoding,"strict")
            except UnicodeError:
                if reportErrors:
                    g.reportBadChars(s,encoding)
                s = s.encode(encoding,"replace")

    else:
        if type(s) == types.UnicodeType:
            try:
                s = s.encode(encoding,"strict")
            except UnicodeError:
                if reportErrors:
                    g.reportBadChars(s,encoding)
                s = s.encode(encoding,"replace")
    return s
</t>
<t tx="ekr.20090401102247.627">def toUnicode (s,encoding,reportErrors=False):

    if isPython3:
        convert,mustConvert,nullVal = str,g.isBytes,''
    else:
        convert,nullVal = unicode,unicode('')
        def mustConvert (s):
            return type(s) != types.UnicodeType

    if not s:
        s = nullVal
    elif mustConvert(s):
        try:
            s = convert(s,encoding,'strict')
        except UnicodeError:
            s = convert(s,encoding,'replace')
            if reportErrors: g.reportBadChars(s,encoding)
    else:
        pass

    return s</t>
<t tx="ekr.20090401102247.628"># Convert all args to strings.

def trace (*args,**keys):

    # Compute the effective args.
    d = {'align':0,'newline':True}
    d = g.doKeywordArgs(keys,d)
    newline = d.get('newline')
    align = d.get('align')
    if align is None: align = 0

    # Compute the caller name.
    try: # get the function name from the call stack.
        f1 = sys._getframe(1) # The stack frame, one level up.
        code1 = f1.f_code # The code object
        name = code1.co_name # The code name
    except Exception: name = ''
    if name == "?":
        name = "&lt;unknown&gt;"

    # Pad the caller name.
    if align != 0 and len(name) &lt; abs(align):
        pad = ' ' * (abs(align) - len(name))
        if align &gt; 0: name = name + pad
        else:         name = pad + name

    # Munge *args into s.
    # print ('g.trace:args...')
    # for z in args: print (g.isString(z),repr(z))
    result = []
    for arg in args:
        if g.isString(arg):
            pass
        elif g.isBytes(arg):
            arg = g.toUnicode(arg,'utf-8')
        else:
            arg = repr(arg)
        if result:
            result.append(" " + arg)
        else:
            result.append(arg)
    s = ''.join(result)
    try:
        g.pr('%s: %s' % (name,s),newline=newline)
    except Exception:
        s = g.toEncodedString(s,'ascii')
        g.pr('%s: %s' % (name,s),newline=newline)

</t>
<t tx="ekr.20090401102247.629"># see: http://www.diveintopython.org/xml_processing/unicode.html

def pr(*args,**keys):

    '''Print all non-keyword args, and put them to the log pane.
    The first, third, fifth, etc. arg translated by g.translateString.
    Supports color, comma, newline, spaces and tabName keyword arguments.
    '''

    # Compute the effective args.
    d = {'commas':False,'newline':True,'spaces':True}
    d = g.doKeywordArgs(keys,d)

    # Important:  Python's print statement *can* handle unicode.
    # However, the following must appear in Python\Lib\sitecustomize.py:
    #    sys.setdefaultencoding('utf-8')
    s = g.translateArgs(args,d) # Translates everything to unicode.

    try: # We can't use any print keyword args in Python 2.x!
        # print(s) # Not quite right.
        if d.get('newline'):
            sys.stdout.write(s+'\n')
        else:
            sys.stdout.write(s)
    except Exception:
        print('unexpected Exception in g.pr')
        g.es_exception()
        g.trace(g.callers())
</t>
<t tx="ekr.20090401102247.630">@
The problem was that __cmp__ was not being called.
It has now been replaced by the __eq__ and __ne__ operators.</t>
<t tx="ekr.20090401102247.631"></t>
<t tx="ekr.20090401102247.632">def __init__ (self,v,childIndex=0,stack=None,trace=False):

    '''Create a new position with the given childIndex and parent stack.'''

    # To support ZODB the code must set v._p_changed = 1
    # whenever any mutable vnode object changes.

    self._childIndex = childIndex
    self.v = v

    # New in Leo 4.5: stack entries are tuples (v,childIndex).
    if stack:
        self.stack = stack[:] # Creating a copy here is safest and best.
    else:
        self.stack = []

    g.app.positions += 1

    # if g.app.tracePositions and trace: g.trace(g.callers())

    self.txtOffset = None # see self.textOffset()
</t>
<t tx="ekr.20090401102247.633">def __eq__(self,p2):

    """Return True if two postions are equivalent."""

    p1 = self

    # Don't use g.trace: it might call p.__eq__ or p.__ne__.
    # print ('p.__eq__: %s %s' % (
        # p1 and p1.v and p1.h,p2 and p2.v and p2.h))

    if p2 is None or p2.v is None:
        return p1.v is None
    else:
        return ( p1.v == p2.v and
            p1._childIndex == p2._childIndex and
            p1.stack == p2.stack )

def __ne__(self,p2):

    """Return True if two postions are not equivalent."""

    return not self.__eq__(p2) # For possible use in Python 2.x.
</t>
<t tx="ekr.20090401102247.634">if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):

        """Convert references to p.t into references to p.v.t.

        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                g.pr("unknown position attribute:",attr)
                import traceback ; traceback.print_stack()
            raise AttributeError(attr)</t>
<t tx="ekr.20090401102247.635">@
Tests such as 'if p' or 'if not p' are the _only_ correct ways to test whether a position p is valid.
In particular, tests like 'if p is None' or 'if p is not None' will not work properly.
@c

if g.isPython3:

    def __bool__ ( self):

        """Return True if a position is valid."""

        # Tracing this appears to cause unbounded prints.
        # print("__bool__",self.v and self.v.cleanHeadString())

        return self.v is not None

else:

    def __nonzero__ ( self):

        """Return True if a position is valid."""

        # if g.app.trace: "__nonzero__",self.v

        # g.trace(repr(self))

        return self.v is not None
</t>
<t tx="ekr.20090401102247.636">def __str__ (self):

    p = self

    if p.v:
        return "&lt;pos %d childIndex: %d lvl: %d [%d] %s&gt;" % (
            id(p),p._childIndex,p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "&lt;pos %d [%d] None&gt;" % (id(p),len(p.stack))

__repr__ = __str__
</t>
<t tx="ekr.20090401102247.637">def archivedPosition (self,root_p=None):

    '''Return a representation of a position suitable for use in .leo files.'''

    p = self

    if root_p is None:
        aList = [z._childIndex for z in p.self_and_parents_iter()]
    else:
        aList = []
        for z in p.self_and_parents_iter():
            if z == root_p:
                aList.append(0)
                break
            else:
                aList.append(z._childIndex)
        # g.trace(aList)

    aList.reverse()
    return aList</t>
<t tx="ekr.20090401102247.638"># Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):

    """"Return an independent copy of a position."""

    # if g.app.tracePositions: g.trace(g.callers())

    return position(self.v,self._childIndex,self.stack,trace=False)
</t>
<t tx="ekr.20090401102247.639">def dumpLink (self,link):

    return g.choose(link,link,"&lt;none&gt;")

def dump (self,label=""):

    p = self
    g.pr('-'*10,label,p)
    if p.v:
        p.v.dump() # Don't print a label

def vnodeListIds (self):

    p = self
    return [id(v) for v in p.v.t.vnodeList]
</t>
<t tx="ekr.20090401102247.640">def key (self):

    p = self

    vList = [z[0] for z in p.stack]

    return '%s:%s.%s' % (
        id(p.v),
        p._childIndex,
        ','.join([str(id(z)) for z in vList])
    )
</t>
<t tx="ekr.20090401102247.641"></t>
<t tx="ekr.20090401102247.642">@nocolor





@color</t>
<t tx="ekr.20090401102247.643">What I did:

- Changed g.scanDirectives(c,p) to c.scanAllDirectives(p) in core.

- A deprecated g.scanDirectives just calls c.scanAllDirectives.</t>
<t tx="ekr.20090401102247.644">@killcolor
https://sourceforge.net/forum/message.php?msg_id=2936513
By: ktenney

In the @view plugin is a method, currentPath() which examines the current headline
and body, and the headlines and bodies of it's parents, looking for @path and
@view directives. It builds a path from them and checks for validity.

if a top level node contains;
@path /home/ktenney

and a descendant of that node contains;
@path projects/myproject

Then a node further down the tree which contains;
@view readme.txt

will display /home/ktenney/projects/myproject/readme.txt

I like this principle of cumulative paths, and would like other plugins to work
the same way ... @image, @url etc.

This brings me to my question, would it make sense for Leo to offer a 'Plugin'
class to inherit from? It seems that there are some operations that are being
re-written in many plugins.


============

QQQQQQ
nested @paths don't do what I expected: 

For a leo file in directory foo: 

@path src 
....@path tmpl

should refer to foo/src and foo/src/tmpl

using @path src/tmpl works fine though.
QQQQQQQ</t>
<t tx="ekr.20090401102247.645"># This is the elegant, clear way to support os.path.expanduser.</t>
<t tx="ekr.20090401102247.646">def os_path_expanduser(path,encoding=None):

    """wrap os.path.expanduser"""

    path = g.toUnicodeFileEncoding(path,encoding)

    result = os.path.normpath(os.path.expanduser(path))

    # g.trace('path',path,'expanduser', result)

    return result
</t>
<t tx="ekr.20090401102247.647">def os_path_join(*args,**keys):

    c = keys.get('c')
    encoding = keys.get('encoding')

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]

    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            # g.trace(c.openDirectory)

    uargs = [g.os_path_expanduser(z,encoding=encoding) for z in uargs if z]

    path = os.path.join(*uargs)

    # May not be needed on some Pythons.
    path = g.toUnicodeFileEncoding(path,encoding)
    return path
</t>
<t tx="ekr.20090401102247.648"></t>
<t tx="ekr.20090401102247.649"></t>
<t tx="ekr.20090401102247.650"></t>
<t tx="ekr.20090401102247.651">@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.
</t>
<t tx="ekr.20090401102247.652">def os_path_abspath(path,encoding=None):

    """Convert a path to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.abspath(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
</t>
<t tx="ekr.20090401102247.653">def os_path_basename(path,encoding=None):

    """Return the second half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.basename(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
</t>
<t tx="ekr.20090401102247.654">def os_path_dirname(path,encoding=None):

    """Return the first half of the pair returned by split(path)."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.dirname(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
</t>
<t tx="ekr.20090401102247.655">def os_path_exists(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.exists(path)
</t>
<t tx="ekr.20090401102247.656">def os_path_getmtime(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.getmtime(path)
</t>
<t tx="ekr.20090401102247.657">def os_path_getsize (path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.getsize(path)
</t>
<t tx="ekr.20090401102247.658">def os_path_isabs(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isabs(path)
</t>
<t tx="ekr.20090401102247.659">def os_path_isdir(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isdir(path)
</t>
<t tx="ekr.20090401102247.660">def os_path_isfile(path,encoding=None):

    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isfile(path)
</t>
<t tx="ekr.20090401102247.661">def os_path_normcase(path,encoding=None):

    """Normalize the path's case."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normcase(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
</t>
<t tx="ekr.20090401102247.662">def os_path_normpath(path,encoding=None):

    """Normalize the path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normpath(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
</t>
<t tx="ekr.20090401102247.663">def os_path_realpath(path,encoding=None):


    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.realpath(path)

    path = g.toUnicodeFileEncoding(path,encoding)

    return path
</t>
<t tx="ekr.20090401102247.664">def os_path_split(path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.split(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail
</t>
<t tx="ekr.20090401102247.665">def os_path_splitext(path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.splitext(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail
</t>
<t tx="ekr.20090401102247.666">def toUnicodeFileEncoding(path,encoding):

    if path: path = path.replace('\\', os.sep)

    if not encoding:
        if sys.platform == "win32" or sys.platform.lower().startswith('java'):
            # encoding = "mbcs" # Leo 4.2 and previous.
            encoding = 'utf-8' # New in Leo 4.3
        else:
            encoding = app.tkEncoding

    # Yes, this is correct.  All os_path_x functions return Unicode strings.
    return g.toUnicode(path,encoding)
</t>
<t tx="ekr.20090401102247.667">def readOneAtShadowNode (self,fn,p):

    at = self ; c = at.c ; x = c.shadowController

    if not fn == p.atShadowFileNodeName():
        return at.error('can not happen: fn: %s != atShadowNodeName: %s' % (
            fn, p.atShadowFileNodeName()))

    at.scanDefaultDirectory(p,importing=True) # Sets at.default_directory

    fn = c.os_path_finalize_join(at.default_directory,fn)
    shadow_fn     = x.shadowPathName(fn)
    shadow_exists = g.os_path_exists(shadow_fn) and g.os_path_isfile(shadow_fn)

    if shadow_exists:
        # at.read (via at.openFileForReading) calls x.updatePublicAndPrivateFiles.
        at.read(p,thinFile=True,atShadow=True)
    else:
        if not g.unitTesting: g.es("reading:",p.h)
        ok = at.importAtShadowNode(fn,p)
        if ok:
            # Create the private file automatically.
            at.writeOneAtShadowNode(p,toString=False,force=True)
</t>
<t tx="ekr.20090401102247.668">def importAtShadowNode (self,fn,p):

    at = self ; c = at.c  ; ic = c.importCommands
    oldChanged = c.isChanged()

    # Delete all the child nodes.
    while p.hasChildren():
        p.firstChild().doDelete()

    # Import the outline, exactly as @auto does.
    ic.createOutline(fn,parent=p.copy(),atAuto=True,atShadow=True)

    if ic.errors:
        g.es_print('errors inhibited read @shadow',fn,color='red')

    if ic.errors or not g.os_path_exists(fn):
        p.clearDirty()
        c.setChanged(oldChanged)

    # else: g.doHook('after-shadow', p = p)

    return ic.errors == 0
</t>
<t tx="ekr.20090401102247.669">@nocolor

- Replaced g.scanDirectives with c.scanAllDirectives in scripts.leo, unitTest.leo and plugins.
- Removed obsolete helper methods.
- Rewrote tangle.scanAllDirectives.
- Rewrote scanForTabWidth.
- Replaced scanColorDirectives with new version.
- Replaced at.scanAllDirectives with new version.

@color</t>
<t tx="ekr.20090401102247.670"># These are all new in Leo 4.5.1.</t>
<t tx="ekr.20090401102247.671"># Called only by scanColorDirectives.

def scanAtRootDirectives(self,aList):

    '''Scan aList for @root-code and @root-doc directives.'''

    c = self

    # To keep pylint happy.
    tag = 'at_root_bodies_start_in_doc_mode'
    start_in_doc = hasattr(c.config,tag) and getattr(c.config,tag)

    # New in Leo 4.6: dashes are valid in directive names.
    for d in aList:
        if 'root-code' in d:
            return 'code'
        elif 'root-doc' in d:
            return 'doc'
        elif 'root' in d:
            return g.choose(start_in_doc,'doc','code')

    return None
</t>
<t tx="ekr.20090401102247.672">def getNodePath (self,p):

    '''Return the path in effect at node p.'''

    c = self
    aList = g.get_directives_dict_list(p)
    path = c.scanAtPathDirectives(aList)
    return path

def getNodeFileName (self,p):

    '''Return the full file name at node p,
    including effects of all @path directives.

    Return None if p is no kind of @file node.'''

    d = self.scanAllDirectives(p)
    path = d.get('path')

    name = ''
    for p in p.self_and_parents_iter():
        name = p.anyAtFileNodeName()
        if name: break

    if name:
        name = g.os_path_finalize_join(path,name)
    return name
</t>
<t tx="ekr.20090401102247.673"></t>
<t tx="ekr.20090401102247.674">def scanColorDirectives(self,p):

    '''Scan position p and p's ancestors looking for @comment, @language and @root directives,
    setting corresponding colorizer ivars.'''

    c = self.c
    if not c: return # May be None for testing.

    table = (
        ('lang-dict',   g.scanAtCommentAndAtLanguageDirectives),
        ('root',        c.scanAtRootDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,func in table:
        val = func(aList)
        if val: d[key]=val

    # Post process.
    lang_dict       = d.get('lang-dict')
    self.rootMode   = d.get('root') or None

    if lang_dict:
        self.language       = lang_dict.get('language')
        self.comment_string = lang_dict.get('comment')
    else:
        self.language       = c.target_language and c.target_language.lower()
        self.comment_string = None

    # g.trace('self.language',self.language)
    return self.language # For use by external routines.
</t>
<t tx="ekr.20090401102247.675">def scanAllDirectives(self,p,require_path_flag,issue_error_flag):

    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """

    c = self.c
    print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.b
        &lt;&lt; Collect @first attributes &gt;&gt;

    # delims = (self.single_comment_string,self.start_comment_string,self.end_comment_string)
    lang_dict = {'language':self.language,'delims':None,} # Delims not used

    table = (
        ('encoding',    self.encoding,  g.scanAtEncodingDirectives),
        ('lang-dict',   lang_dict,      g.scanAtCommentAndAtLanguageDirectives),
        ('lineending',  None,           g.scanAtLineendingDirectives),
        ('pagewidth',   c.page_width,   g.scanAtPagewidthDirectives),
        ('path',        None,           c.scanAtPathDirectives),
        ('tabwidth',    c.tab_width,    g.scanAtTabwidthDirectives),
    )

    # Set d by scanning all directives.
    aList = g.get_directives_dict_list(p)
    d = {}
    for key,default,func in table:
        val = func(aList)
        d[key] = g.choose(val is None,default,val)

    # Post process.
    lang_dict       = d.get('lang-dict')
    lineending      = d.get('lineending')
    if lineending:
        self.output_newline = lineending
    self.encoding             = d.get('encoding')
    self.language             = lang_dict.get('language')
    self.page_width           = d.get('pagewidth')
    self.default_directory    = d.get('path')
    self.tab_width            = d.get('tabwidth')

    # For unit testing.
    return {
        "encoding"  : self.encoding,
        "language"  : self.language,
        "lineending": self.output_newline,
        "pagewidth" : self.page_width,
        "path"      : self.default_directory,
        "tabwidth"  : self.tab_width,
    }

</t>
<t tx="ekr.20090401102247.676">@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i&gt;j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i &gt;= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break
</t>
<t tx="ekr.20090401102247.677">@nocolor 

This make's Leo's syntax compatible with Python 3.0.</t>
<t tx="ekr.20090401102247.678"># Added support for @string default_leo_file = ~/.leo/workbook.leo</t>
<t tx="ekr.20090401102247.679">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/d6449236bc140713#

Now it's easier than ever to add *quick* notes with leo. ILeo knows of
"special" leo file ~/.ipython/ipython_notebook.leo, which is opened
automatically when you do:

lleo

("launch leo" without specifying a .leo file to open. The old
behaviour was to open untitled file, saving of which iIs pain).

lno This is my note

("leo note")

This opens ipython_notebook.leo if leo is not running already, and
adds a headline with "This is my note" under headline "Scratch". Of
course the focus still remains in the ipython window, so you can
proceed adding more notes with %lno without losing your concentration
or touching your mouse. If you run  %lno with a note string that
already exists, the existing note is focused instead.

To enable all this goodness, you just need to add

_ip.load('ipy_leo')

to your ipy_user_conf.py.

You also need to install leo with "setup.py develop".

I guess this is leo's equivalent of Chandler's "Quick entry bar",
described here:

http://www.youtube.com/watch?v=JJBxajDwmLI 

@color</t>
<t tx="ekr.20090401102247.680"></t>
<t tx="ekr.20090401102247.681">def doEarlyInits(verbose):

    import leo.core.leoGlobals as g
    import leo.core.leoNodes as leoNodes
    import leo.core.leoConfig as leoConfig

    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.

    # There is a circular dependency between leoCommands and leoEditCommands.
    import leo.core.leoCommands as leoCommands

    # New in Leo 4.5 b3: make sure we call the new leoPlugins.init top-level function.
    # This prevents a crash when run is called repeatedly from IPython's lleo extension.
    import leo.core.leoPlugins as leoPlugins
    leoPlugins.init()

    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
</t>
<t tx="ekr.20090401102247.682"></t>
<t tx="ekr.20090401102247.683">def openWithFileName(fileName,old_c,
    enableLog=True,gui=None,readAtFileNodesFlag=True):

    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None

    def munge(name):
        return g.os_path_normpath(name or '').lower()

    # Create a full, normalized, Unicode path name, preserving case.
    relativeFileName = g.os_path_normpath(fileName)
    fileName = g.os_path_finalize(fileName)
    isZipped = fileName and zipfile.is_zipfile(fileName)
    isLeo = isZipped or fileName.endswith('.leo')
    # g.trace(relativeFileName,'--&gt;',fileName)

    # If the file is already open just bring its window to the front.
    if isLeo:
        theList = app.windowList
        for frame in theList:
            if munge(fileName) == munge(frame.c.mFileName):
                frame.bringToFront()
                frame.c.setLog()
                frame.c.outerUpdate()
                return True, frame
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
            g.doHook('open0')

        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile,isZipped = g.openLeoOrZipFile(fileName)
        if not theFile: return False, None
        c,frame = app.newLeoCommanderAndFrame(
            fileName=fileName,
            relativeFileName=relativeFileName,
            gui=gui)
    else:
        c,frame = g.openWrapperLeoFile(old_c,fileName,gui)
        if not c: return False,None

    assert frame.c == c and c.frame == frame
    c.isZipped = isZipped
    frame.log.enable(enableLog)
    g.app.writeWaitingLog() # New in 4.3: write queued log first.
    if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
        c.setLog()
        if isLeo:
            app.lockLog()
            ok = frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            if not ok:
                g.app.closeLeoWindow(frame)
                return False,frame
            for z in g.app.windowList: # Bug fix: 2007/12/07: don't change frame var.
                # The recent files list has been updated by c.updateRecentFiles.
                z.c.config.setRecentFiles(g.app.config.recentFiles)
    # Bug fix in 4.4.
    frame.openDirectory = c.os_path_finalize(g.os_path_dirname(fileName))
    g.doHook("open2",old_c=old_c,c=c,new_c=c,fileName=fileName)
    p = c.p
    # New in Leo 4.4.8: create the menu as late as possible so it can use user commands.
    if not g.doHook("menu1",c=c,p=p,v=p):
        frame.menu.createMenuBar(frame)
        c.updateRecentFiles(relativeFileName or fileName)
        g.doHook("menu2",c=frame.c,p=p,v=p)
        g.doHook("after-create-leo-frame",c=c)
    # New in Leo 4.6: provide an official way for very late initialization.
    c.frame.tree.initAfterLoad()
    c.initAfterLoad()
    c.redraw()
    assert frame.c == c and c.frame == frame
    # chapterController.finishCreate must be called after the first real redraw
    # because it requires a valid value for c.rootPosition().
    # g.trace('c.chapterController',c.chapterController)
    if c.chapterController:
        c.chapterController.finishCreate()
    k = c.k
    if k:
        k.setDefaultInputState()
    if c.config.getBool('outline_pane_has_initial_focus'):
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    if k:
        k.showStateAndMode()

    c.frame.initCompleteHint()

    return True, frame
</t>
<t tx="ekr.20090401102247.684">http://groups.google.com/group/leo-editor/browse_thread/thread/f1c7c5134b95c77e

The suggestion: paste fonts into myLeoSettings.leo.

Can they be a better default?</t>
<t tx="ekr.20090401102247.685">@nocolor
@

Valid values:

weight: bold, normal, None
slant: roman, italic, None

Use the show-fonts command to pick fonts, then copy the values shown
by the show-fonts command to the values here.

@c

import sys ; print sys.platform
</t>
<t tx="ekr.20090401102247.686">body_text_font_family = fixed
body_text_font_size = 11
body_text_font_slant = None
body_text_font_weight = None
</t>
<t tx="ekr.20090401102247.687">button_text_font_family = fixed
button_text_font_size = 8
button_text_font_slant = roman
button_text_font_weight = normal
</t>
<t tx="ekr.20090401102247.688"># The font for the log pane. Default is
default font for Tk.Text widgets.
# Tk translates invalid font names to another font in a system-dependent way.
#
# Default size is 12 for Linux, 9 otherwise.

log_text_font_family = Courier
log_text_font_size = 9
log_text_font_slant = roman
log_text_font_weight = normal
</t>
<t tx="ekr.20090401102247.689">menu_text_font_family = None
menu_text_font_size = None
menu_text_font_slant = None
menu_text_font_weight = None</t>
<t tx="ekr.20090401102247.690">headline_text_font_family = fixed
headline_text_font_size = 11
headline_text_font_slant = roman
headline_text_font_weight = normal
</t>
<t tx="ekr.20090401102247.691"># It's surprisingly annoying not to be able to move the tree just created.</t>
<t tx="ekr.20090401102247.692">@nocolor

http://groups.google.com/group/leo-editor/browse_thread/thread/4ad91984a6d0acac

&gt; As I said, all I need would be is for leo to call callback/hook with
&gt; signature like
&gt; def complete(line-up-to-cursor, current_node) =&gt; list of strings

The actual signature is:

theObject,completionList = getExternalCompletions (self,s,p=None,language='python')

p is used only to get the language, or you can set the language by hand.

@color</t>
<t tx="ekr.20090401102247.693"># Useful: we don't need a closing @color to enable coloring in descendants.</t>
<t tx="ekr.20090401102247.694">def useSyntaxColoring (self,p):

    """Return True unless p is unambiguously under the control of @nocolor."""

    p = p.copy() ; first = p.copy()
    self.killFlag = False

    # New in Leo 4.6: @nocolor-node disables one node only.
    theDict = g.get_directives_dict(p)
    if 'nocolor-node' in theDict:
        return False

    for p in p.self_and_parents_iter():
        theDict = g.get_directives_dict(p)
        no_color = 'nocolor' in theDict
        color = 'color' in theDict
        kill_color = 'killcolor' in theDict
        # A killcolor anywhere disables coloring.
        if kill_color:
            self.killFlag = True
            return False
        # A color anywhere in the target enables coloring.
        elif color and p == first:
            return True
        # Otherwise, the @nocolor specification must be unambiguous.
        elif no_color and not color:
            return False
        elif color and not no_color:
            return True

    return True
</t>
<t tx="ekr.20090401102247.695">def skip_id(s,i,chars=None):

    chars = chars and g.toUnicode(chars,encoding='ascii') or ''
    n = len(s)
    while i &lt; n and (g.isWordChar(s[i]) or s[i] in chars):
        i += 1
    return i</t>
<t tx="ekr.20090401102247.696"></t>
<t tx="ekr.20090401102247.697">def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if s.find(pattern,i,i+j) != i:
        return False
    if i+j &gt;= len(s):
        return True
    ch = s[i+j]
    return not g.isWordChar(ch)
</t>
<t tx="ekr.20090401102247.698">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/3b5f1232ecc6bba7</t>
<t tx="ekr.20090401102247.699">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/b6a39ed672a28c65?pli=1

Patches made to leoKeys.py</t>
<t tx="ekr.20090401102247.700">@nocolor-node

c.config.doEnabledPlugins sets g.app.config.enabledPluginsFileName</t>
<t tx="ekr.20090401102247.701">def loadOnePlugin (moduleOrFileName, verbose=False):

    global loadedModules,loadingModuleNameStack

    verbose = False or verbose or g.app.config.getBool(c=None,setting='trace_plugins')
    warn_on_failure = g.app.config.getBool(c=None,setting='warn_when_plugins_fail_to_load')

    if moduleOrFileName.endswith('.py'):
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if verbose:
            g.es_print('plugin',moduleName,'already loaded',color="blue")
        return module

    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)

    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path,pluginName=moduleName,verbose=True)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)
        if hasattr(result,'init'):
            try:
                # Indicate success only if init_result is True.
                init_result = result.init()
                # g.trace('result',result,'init_result',init_result)
                if init_result:
                    loadedModules[moduleName] = result
                    loadedModulesFilesDict[moduleName] = g.app.config.enabledPluginsFileName
                else:
                    if verbose and not g.app.initing:
                        g.es_print('loadOnePlugin: failed to load module',moduleName,color="red")
                    result = None
            except Exception:
                g.es('exception loading plugin',color='red')
                g.es_exception()
                result = None
        else:
            # No top-level init function.
            # Guess that the module was loaded correctly,
            # but do *not* load the plugin if we are unit testing.
            g.trace('no init()',moduleName)
            if g.app.unitTesting:
                result = None
                loadedModules[moduleName] = None
            else:
                loadedModules[moduleName] = result
        loadingModuleNameStack.pop()

    if g.unitTesting or g.app.batchMode or g.app.inBridge:
        pass
    elif result is None:
        if warn_on_failure or (verbose and not g.app.initing): # or not g.app.unitTesting:
            g.es_print('can not load enabled plugin:',moduleName,color="red")
    elif verbose:
        g.es_print('loaded plugin:',moduleName,color="blue")

    return result
</t>
<t tx="ekr.20090401102247.702">def printPluginHandlers (self,event=None):

    leoPlugins.printHandlers(self.c)

def printPlugins (self,event=None):

    leoPlugins.printPlugins(self.c)

def printPluginsInfo (self,event=None):

    leoPlugins.printPluginsInfo(self.c)
</t>
<t tx="ekr.20090401102247.703">def printPluginsInfo (c):

    '''Print the file name responsible for loading a plugin.

    This is the first .leo file containing an @enabled-plugins node
    that enables the plugin.'''

    d = loadedModulesFilesDict
    tabName = 'Plugins'
    c.frame.log.selectTab(tabName)

    data = []
    for z in g.app.loadedPlugins:
        print (z, d.get(z))

    data = [] ; n = 4
    for moduleName in d:
        fileName = d.get(moduleName)
        n = max(n,len(moduleName))
        data.append((moduleName,fileName),)

    lines = ['%*s %s\n' % (-n,s1,s2) for (s1,s2) in data]
    g.es('',''.join(lines),tabName=tabName)
</t>
<t tx="ekr.20090401102247.704">def printHandlers (c,moduleName=None):

    tabName = 'Plugins'
    c.frame.log.selectTab(tabName)

    if moduleName:
        s = 'handlers for %s...\n' % (moduleName)
    else:
        s = 'all plugin handlers...\n'
    g.es(s+'\n',tabName=tabName)

    data = []
    modules = {}
    for tag in handlers:
        bunches = handlers.get(tag)
        for bunch in bunches:
            name = bunch.moduleName
            tags = modules.get(name,[])
            tags.append(tag)
            modules[name] = tags

    n = 4
    for key in sorted(modules):
        tags = modules.get(key)
        if moduleName in (None,key):
            for tag in tags:
                n = max(n,len(tag))
                data.append((tag,key),)

    lines = ['%*s %s\n' % (-n,s1,s2) for (s1,s2) in data]
    g.es('',''.join(lines),tabName=tabName)

</t>
<t tx="ekr.20090401102247.705">def printPlugins (c):

    tabName = 'Plugins'
    c.frame.log.selectTab(tabName)

    data = []
    data.append('enabled plugins...\n')
    for z in sorted(loadedModules):
        data.append(z)

    lines = ['%s\n' % (s) for s in data]
    g.es('',''.join(lines),tabName=tabName)
</t>
<t tx="ekr.20090401102247.706"></t>
<t tx="ekr.20090401102247.707"></t>
<t tx="ekr.20090401102247.708"></t>
<t tx="ekr.20090401102247.709">def adjustTripleString (s,tab_width):

    '''Remove leading indentation from a triple-quoted string.

    This works around the fact that Leo nodes can't represent underindented strings.
    '''

    # Compute the minimum leading whitespace of all non-blank lines.
    lines = g.splitLines(s)
    w = -1
    for s in lines:
        if s.strip():
            lws = g.get_leading_ws(s)
            w2 = g.computeWidth(lws,tab_width)
            if w &lt; 0: w = w2
            else:     w = min(w,w2)
            # g.trace('w',w)

    if w &lt;= 0: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)

    return result
</t>
<t tx="ekr.20090401102247.710"># Returns optimized whitespace corresponding to width with the indicated tab_width.

def computeLeadingWhitespace (width, tab_width):

    if width &lt;= 0:
        return ""
    if tab_width &gt; 1:
        tabs   = width / tab_width
        blanks = width % tab_width
        return ('\t' * tabs) + (' ' * blanks)
    else: # 7/3/02: negative tab width always gets converted to blanks.
        return (' ' * width)
</t>
<t tx="ekr.20090401102247.711"># Returns the width of s, assuming s starts a line, with indicated tab_width.

def computeWidth (s, tab_width):

    w = 0
    for ch in s:
        if ch == '\t':
            w += (abs(tab_width) - (w % abs(tab_width)))
        else:
            w += 1
    return w
</t>
<t tx="ekr.20090401102247.712">def get_leading_ws(s):

    """Returns the leading whitespace of 's'."""

    i = 0 ; n = len(s)
    while i &lt; n and s[i] in (' ','\t'):
        i += 1
    return s[0:i]
</t>
<t tx="ekr.20090401102247.713"># Optimize leading whitespace in s with the given tab_width.

def optimizeLeadingWhitespace (line,tab_width):

    i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
    s = g.computeLeadingWhitespace(width,tab_width) + line[i:]
    return s
</t>
<t tx="ekr.20090401102247.714">@

The caller should call g.stripBlankLines before calling this routine if desired.

This routine does _not_ simply call rstrip(): that would delete all trailing whitespace-only lines, and in some cases that would change the meaning of program or data.

@c

def regularizeTrailingNewlines(s,kind):

    """Kind is 'asis', 'zero' or 'one'."""

    pass
</t>
<t tx="ekr.20090401102247.715"># Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace (s,first_ws,tab_width):

    j = 0 ; ws = 0
    for ch in s:
        if ws &gt;= first_ws:
            break
        elif ch == ' ':
            j += 1 ; ws += 1
        elif ch == '\t':
            j += 1 ; ws += (abs(tab_width) - (ws % abs(tab_width)))
        else: break
    if j &gt; 0:
        s = s[j:]
    return s
</t>
<t tx="ekr.20090401102247.716">def removeExtraLws (s,tab_width):

    '''Remove extra indentation from one or more lines.

    Warning: used by getScript.  This is *not* the same as g.adjustTripleString.'''

    lines = g.splitLines(s)

    # Find the first non-blank line and compute w, the width of its leading whitespace.
    for s in lines:
        if s.strip():
            lws = g.get_leading_ws(s)
            w = g.computeWidth(lws,tab_width)
            # g.trace('w',w)
            break
    else: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)

    if 0:
        g.trace('lines...')
        for line in g.splitLines(result):
            g.pr(repr(line))

    return result
</t>
<t tx="ekr.20090401102247.717"># Warning: string.rstrip also removes newlines!

def removeTrailingWs(s):

    j = len(s)-1
    while j &gt;= 0 and (s[j] == ' ' or s[j] == '\t'):
        j -= 1
    return s[:j+1]
</t>
<t tx="ekr.20090401102247.718"># Skips leading up to width leading whitespace.

def skip_leading_ws(s,i,ws,tab_width):

    count = 0
    while count &lt; ws and i &lt; len(s):
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else: break

    return i
</t>
<t tx="ekr.20090401102247.719">def skip_leading_ws_with_indent(s,i,tab_width):

    """Skips leading whitespace and returns (i, indent), 

    - i points after the whitespace
    - indent is the width of the whitespace, assuming tab_width wide tabs."""

    count = 0 ; n = len(s)
    while i &lt; n:
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else: break

    return i, count
</t>
<t tx="ekr.20090401102247.720">def stripBlankLines(s):

    lines = g.splitLines(s)

    for i in range(len(lines)):

        line = lines[i]
        j = g.skip_ws(line,0)
        if j &gt;= len(line):
            lines[i] = ''
            # g.trace("%4d %s" % (i,repr(lines[i])))
        elif line[j] == '\n':
            lines[i] = '\n'
            # g.trace("%4d %s" % (i,repr(lines[i])))

    return ''.join(lines)
</t>
<t tx="ekr.20090401102247.721"></t>
<t tx="ekr.20090401102247.722">def check (self,unused_s,unused_parent):

    '''Make sure the generated nodes are equivalent to the original file.

    1. Regularize and check leading whitespace.
    2. Check that a trial write produces the original file.

    Return True if the nodes are equivalent to the original file.
    '''

    if self.fullChecks and self.treeType == '@file':
        return self.checkTrialWrite()
    else:
        return True
</t>
<t tx="ekr.20090401102247.723">def checkLeadingWhitespace (self,line):

    tab_width = self.tab_width
    lws = line[0:g.skip_ws(line,0)]
    w = g.computeWidth(lws,tab_width)
    ok = (w % abs(tab_width)) == 0

    if not ok:
        self.report('leading whitespace not consistent with @tabwidth %d' % tab_width)
        g.es_print('line:',repr(line),color='red')

    return ok
</t>
<t tx="ekr.20090401102247.724"></t>
<t tx="ekr.20090401102247.725">def underindentedComment (self,line):

    if self.atAutoWarnsAboutLeadingWhitespace:
        self.warning(
            'underindented python comments.\nExtra leading whitespace will be added\n' + line)

def underindentedLine (self,line):

    self.error(
        'underindented line.\nExtra leading whitespace will be added\n' + line)
</t>
<t tx="ekr.20090401102247.726">def startsHelper(self,s,i,kind,tags):
    '''return True if s[i:] starts a class or function.
    Sets sigStart, sigEnd, sigId and codeEnd ivars.'''

    # if not tags: return False

    trace = False or self.trace
    verbose = False # kind=='function'
    self.codeEnd = self.sigEnd = self.sigId = None
    self.sigStart = i

    # Underindented lines can happen in any language, not just Python.
    # The skipBlock method of the base class checks for such lines.
    self.startSigIndent = self.getLeadingIndent(s,i)

    # Get the tag that starts the class or function.
    j = g.skip_ws_and_nl(s,i)
    i = self.skipId(s,j)
    self.sigId = theId = s[j:i] # Set sigId ivar 'early' for error messages.
    if not theId: return False

    if tags:
        if theId not in tags:
            if trace and verbose: g.trace('**** %s theId: %s not in tags: %s' % (kind,theId,tags))
            return False

    if trace and verbose: g.trace('kind',kind,'id',theId)

    # Get the class/function id.
    if kind == 'class' and self.sigId in self.anonymousClasses:
        # A hack for Delphi Pascal: interfaces have no id's.
        # g.trace('anonymous',self.sigId)
        classId = theId
        sigId = ''
    else:
        i, ids, classId = self.skipSigStart(s,j,kind,tags) # Rescan the first id.
        sigId = self.getSigId(ids)
        if not sigId:
            if trace and verbose: g.trace('**no sigId',g.get_line(s,i))
            return False

    if self.output_indent &lt; self.startSigIndent:
        if trace: g.trace('**over-indent',sigId)
            #,'output_indent',self.output_indent,'startSigIndent',self.startSigIndent)
        return False

    # Skip the argument list.
    i, ok = self.skipArgs(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no args',g.get_line(s,i))
        return False
    i = g.skip_ws_and_nl(s,i)

    # Skip the tail of the signature
    i, ok = self.skipSigTail(s,i,kind)
    if not ok:
        if trace and verbose: g.trace('no tail',g.get_line(s,i))
        return False
    sigEnd = i

    # A trick: make sure the signature ends in a newline,
    # even if it overlaps the start of the block.
    if not g.match(s,sigEnd,'\n') and not g.match(s,sigEnd-1,'\n'):
        if trace and verbose: g.trace('extending sigEnd')
        sigEnd = g.skip_line(s,sigEnd)

    if self.blockDelim1:
        i = g.skip_ws_and_nl(s,i)
        if kind == 'class' and self.sigId in self.anonymousClasses:
            pass # Allow weird Pascal unit's.
        elif not g.match(s,i,self.blockDelim1):
            if trace and verbose: g.trace('no block',g.get_line(s,i))
            return False

    i,ok = self.skipCodeBlock(s,i,kind)
    if not ok: return False
        # skipCodeBlock skips the trailing delim.

    # Success: set the ivars.
    self.sigStart = self.adjustDefStart(s,self.sigStart)
    self.codeEnd = i
    self.sigEnd = sigEnd
    self.sigId = sigId
    self.classId = classId

    # Note: backing up here is safe because
    # we won't back up past scan's 'start' point.
    # Thus, characters will never be output twice.
    k = self.sigStart
    if not g.match(s,k,'\n'):
        self.sigStart = g.find_line_start(s,k)

    # Issue this warning only if we have a real class or function.
    if 0: # wrong.
        if s[self.sigStart:k].strip():
            self.error('%s definition does not start a line\n%s' % (
                kind,g.get_line(s,k)))

    if trace: g.trace(kind,'returns\n'+s[self.sigStart:i])
    return True
</t>
<t tx="ekr.20090401102247.727">def skipInterface(self,s,i):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False
    start = i
    delim2 = 'end.'
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i &lt; len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i &gt; 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent &lt; startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and g.match(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif g.match(s,i,delim2):
            i += len(delim2)
            if trace: g.trace('returns\n',repr(s[start:i]))
            return i

        else: i += 1
        assert progress &lt; i

    self.error('no interface')
    if 1:
        g.pr('** no interface **')
        i,j = g.getLine(s,start)
        g.trace(i,s[i:j])
    else:
        if trace: g.trace('** no interface')
    return start
</t>
<t tx="ekr.20090401102247.728">def skipBlock(self,s,i,delim1=None,delim2=None):

    '''Skip from the opening delim to *past* the matching closing delim.

    If no matching is found i is set to len(s)'''

    trace = False and not g.unitTesting
    start = i
    if delim1 is None: delim1 = self.blockDelim1
    if delim2 is None: delim2 = self.blockDelim2
    match1 = g.choose(len(delim1)==1,g.match,g.match_word)
    match2 = g.choose(len(delim2)==1,g.match,g.match_word)
    assert match1(s,i,delim1)
    level = 0 ; start = i
    startIndent = self.startSigIndent
    if trace: g.trace('***','startIndent',startIndent,g.callers())
    while i &lt; len(s):
        progress = i
        if g.is_nl(s,i):
            backslashNewline = i &gt; 0 and g.match(s,i-1,'\\\n')
            i = g.skip_nl(s,i)
            if not backslashNewline and not g.is_nl(s,i):
                j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                line = g.get_line(s,j)
                if trace: g.trace('indent',indent,line)
                if indent &lt; startIndent and line.strip():
                    # An non-empty underindented line.
                    # Issue an error unless it contains just the closing bracket.
                    if level == 1 and match2(s,j,delim2):
                        pass
                    else:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedLine(line)
        elif s[i] in (' ','\t',):
            i += 1 # speed up the scan.
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        elif self.startsString(s,i):
            i = self.skipString(s,i)
        elif match1(s,i,delim1):
            level += 1 ; i += len(delim1)
        elif match2(s,i,delim2):
            level -= 1 ; i += len(delim2)
            # Skip junk following Pascal 'end'
            for z in self.blockDelim2Cruft:
                i2 = g.skip_ws(s,i)
                if g.match(s,i2,z):
                    i = i2 + len(z)
                    break
            if level &lt;= 0:
                if trace: g.trace('returns:',repr(s[start:i]))
                return i

        else: i += 1
        assert progress &lt; i

    self.error('no block')
    if 1:
        g.pr('** no block **')
        i,j = g.getLine(s,start)
        g.trace(i,s[i:j])
    else:
        if trace: g.trace('** no block')
    return start
</t>
<t tx="ekr.20090401102247.729">class pythonScanner (baseScannerClass):

    @others
</t>
<t tx="ekr.20090401102247.730">def __init__ (self,importCommands,atAuto):

    # Init the base class.
    baseScannerClass.__init__(self,importCommands,atAuto=atAuto,language='python')

    # Set the parser delims.
    self.lineCommentDelim = '#'
    self.classTags = ['class',]
    self.functionTags = ['def',]
    self.blockDelim1 = self.blockDelim2 = None
        # Suppress the check for the block delim.
        # The check is done in skipSigTail.
    self.strict = True

</t>
<t tx="ekr.20090401102247.731">def adjustDefStart (self,s,i):

    '''A hook to allow the Python importer to adjust the 
    start of a class or function to include decorators.'''

    if i == 0 or s[i-1] != '\n':
        return i

    while i &gt; 0:
        progress = i

        start = j = g.find_line_start(s,i-2)
        j = g.skip_ws(s,j)
        if not g.match(s,j,'@'):
            return i

        j += 1
        k = g.skip_id(s,j)
        word = s[j:k]

        if word and word not in g.globalDirectiveList:
            # g.trace(repr(word),repr(s[start:i]))
            i = start
            assert i &lt; progress
        else:
            return i
</t>
<t tx="ekr.20090401102247.732">def extendSignature(self,s,i):

    '''Extend the text to be added to the class node following the signature.

    The text *must* end with a newline.'''

    # Add a docstring to the class node,
    # And everything on the line following it
    j = g.skip_ws_and_nl(s,i)
    if g.match(s,j,'"""') or g.match(s,j,"'''"):
        j = g.skip_python_string(s,j)
        if j &lt; len(s): # No scanning error.
            # Return the docstring only if nothing but whitespace follows.
            j = g.skip_ws(s,j)
            if g.is_nl(s,j):
                return j + 1

    return i
</t>
<t tx="ekr.20090401102247.733">def skipString (self,s,i):

    # Returns len(s) on unterminated string.
    return g.skip_python_string(s,i,verbose=False)
</t>
<t tx="ekr.20090401102247.734">def skipCodeBlock (self,s,i,kind):

    trace = False ; verbose = True
    # if trace: g.trace('***',g.callers())
    startIndent = self.startSigIndent
    if trace: g.trace('startIndent',startIndent)
    assert startIndent is not None
    i = start = g.skip_ws_and_nl(s,i)
    parenCount = 0
    underIndentedStart = None # The start of trailing underindented blank or comment lines.
    while i &lt; len(s):
        progress = i
        ch = s[i]
        if g.is_nl(s,i):
            i = g.skip_nl(s,i)
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                pass # We have already made progress.
            else:
                if trace and verbose: g.trace(g.get_line(s,i))
                backslashNewline = (i &gt; 0 and g.match(s,i-1,'\\\n'))
                if not backslashNewline:
                    i,underIndentedStart,breakFlag = self.pythonNewlineHelper(
                        s,i,parenCount,startIndent,underIndentedStart)
                    if breakFlag: break
        elif ch == '#':
            i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif ch in '[{(':
            i += 1 ; parenCount += 1
            # g.trace('ch',ch,parenCount)
        elif ch in ']})':
            i += 1 ; parenCount -= 1
            # g.trace('ch',ch,parenCount)
        else: i += 1
        assert(progress &lt; i)

    # The actual end of the block.
    if underIndentedStart is not None:
        i = underIndentedStart
        if trace: g.trace('***backtracking to underindent range')
        if trace: g.trace(g.get_line(s,i))

    if 0 &lt; i &lt; len(s) and not g.match(s,i-1,'\n'):
        g.trace('Can not happen: Python block does not end in a newline.')
        g.trace(g.get_line(s,i))
        return i,False

    if (trace or self.trace) and s[start:i].strip():
        g.trace('%s returns\n' % (kind) + s[start:i])
    return i,True
</t>
<t tx="ekr.20090401102247.735">def pythonNewlineHelper (self,s,i,parenCount,startIndent,underIndentedStart):

    trace = False
    breakFlag = False
    j, indent = g.skip_leading_ws_with_indent(s,i,self.tab_width)
    if trace: g.trace(
        'startIndent',startIndent,'indent',indent,'parenCount',parenCount,
        'line',repr(g.get_line(s,j)))
    if indent &lt;= startIndent and parenCount == 0:
        # An underindented line: it ends the block *unless*
        # it is a blank or comment line or (2008/9/1) the end of a triple-quoted string.
        if g.match(s,j,'#'):
            if trace: g.trace('underindent: comment')
            if underIndentedStart is None: underIndentedStart = i
            i = j
        elif g.match(s,j,'\n'):
            if trace: g.trace('underindent: blank line')
            # Blank lines never start the range of underindented lines.
            i = j
        else:
            if trace: g.trace('underindent: end of block')
            breakFlag = True # The actual end of the block.
    else:
        if underIndentedStart and g.match(s,j,'\n'):
            # Add the blank line to the underindented range.
            if trace: g.trace('properly indented blank line extends underindent range')
        elif underIndentedStart and g.match(s,j,'#'):
            # Add the (properly indented!) comment line to the underindented range.
            if trace: g.trace('properly indented comment line extends underindent range')
        elif underIndentedStart is None:
            pass
        else:
            # A properly indented non-comment line.
            # Give a message for all underindented comments in underindented range.
            if trace: g.trace('properly indented line generates underindent errors')
            s2 = s[underIndentedStart:i]
            lines = g.splitlines(s2)
            for line in lines:
                if line.strip():
                    junk, indent = g.skip_leading_ws_with_indent(line,0,self.tab_width)
                    if indent &lt;= startIndent:
                        if j not in self.errorLines: # No error yet given.
                            self.errorLines.append(j)
                            self.underindentedComment(line)
            underIndentedStart = None
    if trace: g.trace('breakFlag',breakFlag,'returns',i,'underIndentedStart',underIndentedStart)
    return i,underIndentedStart,breakFlag
</t>
<t tx="ekr.20090401102247.736"># This must be overridden in order to handle newlines properly.

def skipSigTail(self,s,i,kind):

    '''Skip from the end of the arg list to the start of the block.'''

    while i &lt; len(s):
        ch = s[i]
        if ch == '\n':
            break
        elif ch in (' ','\t',):
            i += 1
        elif self.startsComment(s,i):
            i = self.skipComment(s,i)
        else:
            break

    return i,g.match(s,i,':')
</t>
<t tx="ekr.20090401102247.737">@ None of these methods should ever need to be overridden in subclasses.

</t>
<t tx="ekr.20090401102247.738">def addRef (self,parent):

    '''Create an unindented @others or section reference in the parent node.'''

    c = self.c

    # g.trace(parent.h)

    if self.treeType == '@file':
        self.appendStringToBody(parent,'@others\n')

    if self.treeType == '@root' and self.methodsSeen:
        self.appendStringToBody(parent,
            g.angleBrackets(' ' + self.methodName + ' methods ') + '\n\n')
</t>
<t tx="ekr.20090401102247.739">def appendStringToBody (self,p,s,encoding="utf-8"):

    '''Similar to c.appendStringToBody,
    but does not recolor the text or redraw the screen.'''

    return self.importCommands.appendStringToBody(p,s,encoding)

def setBodyString (self,p,s,encoding="utf-8"):

    '''Similar to c.setBodyString,
    but does not recolor the text or redraw the screen.'''

    return self.importCommands.setBodyString(p,s,encoding)
</t>
<t tx="ekr.20090401102247.740">def createDeclsNode (self,parent,s):

    '''Create a child node of parent containing s.'''

    # Create the node for the decls.
    headline = self.methodName + ' declarations'
    body = self.undentBody(s)
    self.createHeadline(parent,body,headline)
</t>
<t tx="ekr.20090401102247.741">def createFunctionNode (self,headline,body,parent):

    # Create the prefix line for @root trees.
    if self.treeType == '@file':
        prefix = ''
    else:
        prefix = g.angleBrackets(' ' + headline + ' methods ') + '=\n\n'
        self.methodsSeen = True

    # Create the node.
    self.createHeadline(parent,prefix + body,headline)

</t>
<t tx="ekr.20090401102247.742">def createHeadline (self,parent,body,headline):

    # g.trace('parent,headline:',parent.h,headline)

    # Create the node.
    p = parent.insertAsLastChild()
    p.initHeadString(headline,self.encoding)

    # Set the body.
    if body:
        self.setBodyString(p,body,self.encoding)
    return p
</t>
<t tx="ekr.20090401102247.743">def getLeadingIndent (self,s,i,ignoreComments=True):

    '''Return the leading whitespace of a line.
    Ignore blank and comment lines if ignoreComments is True'''

    width = 0
    i = g.find_line_start(s,i)
    if ignoreComments:
        while i &lt; len(s):
            # g.trace(g.get_line(s,i))
            j = g.skip_ws(s,i)
            if g.is_nl(s,j) or g.match(s,j,self.comment_delim):
                i = g.skip_line(s,i) # ignore blank lines and comment lines.
            else:
                i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)
                break      
    else:
        i, width = g.skip_leading_ws_with_indent(s,i,self.tab_width)

    # g.trace('returns:',width)
    return width
</t>
<t tx="ekr.20090401102247.744">def indentBody (self,s,lws=None):

    '''Add whitespace equivalent to one tab for all non-blank lines of s.'''

    result = []
    if not lws: lws = self.tab_ws

    for line in g.splitLines(s):
        if line.strip():
            result.append(lws + line)
        elif line.endswith('\n'):
            result.append('\n')

    result = ''.join(result)
    return result
</t>
<t tx="ekr.20090401102247.745">def insertIgnoreDirective (self,parent):

    self.appendStringToBody(parent,'@ignore')

    if not g.unitTesting:
        g.es_print('inserting @ignore',color='blue')
</t>
<t tx="ekr.20090401102247.746">def putFunction (self,s,sigStart,codeEnd,start,parent):

    '''Create a node of parent for a function defintion.'''

    trace = False and self.trace

    # Enter a new function: save the old function info.
    oldStartSigIndent = self.startSigIndent

    if self.sigId:
        headline = self.sigId
    else:
        g.trace('Can not happen: no sigId')
        headline = 'unknown function'

    body1 = s[start:sigStart]
    # Bug fix: 2007/20/31: adjust start backwards to get a better undent.
    if body1.strip():
        while start &gt; 0 and s[start-1] in (' ','\t'):
            start -= 1

    body1 = self.undentBody(s[start:sigStart],ignoreComments=False)

    body2 = self.undentBody(s[sigStart:codeEnd])
    body = body1 + body2
    if trace: g.trace('body\n%s' % body)

    tail = body[len(body.rstrip()):]
    if not '\n' in tail:
        self.warning(
            'function %s does not end with a newline; one will be added\n%s' % (
                self.sigId,g.get_line(s,codeEnd)))
        # g.trace(g.callers())

    self.createFunctionNode(headline,body,parent)

    # Exit the function: restore the function info.
    self.startSigIndent = oldStartSigIndent
</t>
<t tx="ekr.20090401102247.747">def putRootText (self,p):

    c = self.c

    self.appendStringToBody(p,'%s@language %s\n@tabwidth %d\n' % (
        self.rootLine,self.language,self.tab_width))
</t>
<t tx="ekr.20090401102247.748"></t>
<t tx="ekr.20090401102247.749">def __init__(self,c):

    # **Warning**: all these ivars must **also** be inited in initCommonIvars.
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = False # True: enable additional checks.
    self.errors = 0 # Make sure at.error() works even when not inited.
    # New in Leo 4.4a5: For createThinChild4 (LeoUser).
    self._forcedGnxPositionList = []
        # Must be here, putting it in initReadIvars doesn't work.

    self.underindentEscapeString = c.config.getString(
        'underindent-escape-string') or '\\-'

    &lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;
</t>
<t tx="ekr.20090401102247.750">self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }
</t>
<t tx="ekr.20090401102247.751">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/c80fd8375534afdf

&gt; Given that most of my commits to the Trunk over the last year have
&gt; been lost and needed to be restored, I suggest anyone who has changed
&gt; files on the Trunk verify that they have not been lost.

This typically happens because Leo doesn't check whether files have
been changed behind leo's back (e.g. when leo is open, you do bzr
merge / bzr pull, then merrily press ctrl+s =&gt; leo overwrites the
derived files without checking first).

This is easy to fix: just have a dict with { filename :
timestamp_at_time_of_read }, and check those before writing out a
file.

Another layer of security is studying bzr diff well after merge. </t>
<t tx="ekr.20090401102247.752"></t>
<t tx="ekr.20090401102247.753">def setFileTimeStamp (self,fn):

    c = self

    timeStamp = os.path.getmtime(fn)
    c.timeStampDict[fn] = timeStamp

    # g.trace('%20s' % (timeStamp),fn)

</t>
<t tx="ekr.20090401102247.754">def checkFileTimeStamp (self,fn):

    '''
    Return True if the file given by fn has not been changed
    since Leo read it or if the user agrees to overwrite it.
    '''

    c = self
    timeStamp = c.timeStampDict.get(fn)
    if not timeStamp:
        # g.trace('no stamp for %s' % (fn))
        return True

    timeStamp2 = os.path.getmtime(fn)
    if timeStamp == timeStamp2:
        return True

    if g.app.unitTesting:
        return False

    # g.trace(timeStamp, timeStamp2)
    message = '%s\n%s\n%s' % (
        fn,
        g.tr('has been modified outside of Leo.'),
        g.tr('Overwrite this file?'))
    ok = g.app.gui.runAskYesNoCancelDialog(c,
        title = 'Overwrite modified file?',
        message = message)
    return ok == 'yes'
</t>
<t tx="ekr.20090401102247.755"></t>
<t tx="ekr.20090401102247.756"># The caller should follow this with a call to c.redraw().

def getLeoFile (self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # May be set when reading @file nodes.
    &lt;&lt; warn on read-only files &gt;&gt;
    self.checking = False
    self.mFileName = c.mFileName
    self.initReadIvars()
    c.loading = True # disable c.changed

    try:
        ok = True
        # t1 = time.clock()
        v = self.readSaxFile(theFile,fileName,silent,inClipboard=False,reassignIndices=False)
        if v: # v is None for minimal .leo files.
            c.setRootVnode(v)
            self.rootVnode = v
        else:
            v = leoNodes.vnode(context=c)
            v.setHeadString('created root node')
            p = leoNodes.position(v)
            p._linkAsRoot(oldRoot=None)
            self.rootVnode = v
            c.setRootPosition(p)
            c.changed = False
    except BadLeoFile:
        junk, message, junk = sys.exc_info()
        if not silent:
            g.es_exception()
            g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
        ok = False

    # Do this before reading derived files.
    self.resolveTnodeLists()

    if ok and readAtFileNodesFlag:
        # Redraw before reading the @file nodes so the screen isn't blank.
        # This is important for big files like LeoPy.leo.
        c.redraw()
        c.setFileTimeStamp(fileName)
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    # Do this after reading derived files.
    if readAtFileNodesFlag:
        # The descendent nodes won't exist unless we have read the @thin nodes!
        self.restoreDescendentAttributes()

    self.setPositionsFromVnodes()
    c.selectVnode(c.p) # load body pane

    self.initAllParents()

    if c.config.getBool('check_outline_after_read'):
        g.trace('@bool check_outline_after_read = True',color='blue')
        c.checkOutline(event=None,verbose=True,unittest=False,full=True)

    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    self.initReadIvars()
    return ok, self.ratio
</t>
<t tx="ekr.20090401102247.757"># os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False

if self.read_only:
    g.es("read only:",fileName,color="red")
</t>
<t tx="ekr.20090401102247.758">def read(self,root,importFileName=None,thinFile=False,fromString=None,atShadow=False):

    """Read any @thin, @file and @noref trees."""

    at = self ; c = at.c
    &lt;&lt; set fileName &gt;&gt;
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile,atShadow=atShadow)
    if at.errors: return False
    fileName = at.openFileForReading(fileName,fromString=fromString)
    if at.inputFile:
        c.setFileTimeStamp(fileName)
    else:
        return False
    if not g.unitTesting:
        g.es("reading:",root.h)
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if at.errors == 0:
        &lt;&lt; advise user to delete all unvisited nodes &gt;&gt;
    if at.errors == 0 and not at.importing:
        # Package this as a method for use by mod_labels plugin.
        self.copyAllTempBodyStringsToTnodes(root,thinFile)

    &lt;&lt; delete all tempBodyStrings &gt;&gt;
    return at.errors == 0
</t>
<t tx="ekr.20090401102247.759">if fromString:
    fileName = "&lt;string-file&gt;"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
</t>
<t tx="ekr.20090401102247.760">resurrected = 0
for p in root.self_and_subtree_iter():

    if not p.v.t.isVisited():
        g.es('resurrected node:',p.h,color='blue')
        g.es('in file:',fileName,color='blue')
        resurrected += 1

if resurrected:
    g.es('you may want to delete ressurected nodes')

</t>
<t tx="ekr.20090401102247.761">for t in c.all_unique_tnodes_iter():

    if hasattr(t,"tempBodyString"):
        delattr(t,"tempBodyString")
</t>
<t tx="ekr.20090401102247.762">def write_Leo_file(self,fileName,outlineOnlyFlag,toString=False,toOPML=False):

    c = self.c
    self.putCount = 0
    self.toString = toString
    theActualFile = None
    toZip = False
    atOk = True

    if c.config.getBool('check_outline_before_save'):
        g.trace('@bool check_outline_before_save = True',color='blue')
        errors = c.checkOutline(event=None,verbose=True,unittest=False,full=True)
        if errors &gt; 0:
            g.es_print('outline not written',color='red')
            return False

    if not outlineOnlyFlag or toOPML:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        &lt;&lt; write all @file nodes &gt;&gt;
    &lt;&lt; return if the .leo file is read-only &gt;&gt;
    try:
        &lt;&lt; create backup file &gt;&gt;
        self.mFileName = fileName
        if toOPML:
            &lt;&lt; ensure that filename ends with .opml &gt;&gt;
        self.outputFile = StringIO()
        &lt;&lt; create theActualFile &gt;&gt;
        # t1 = time.clock()
        if toOPML:
            self.putToOPML()
        else:
            # An important optimization: we have already assign the file indices.
            self.putLeoFile()
        # t2 = time.clock()
        s = self.outputFile.getvalue()
        # g.trace(self.leo_file_encoding)
        if toZip:
            self.writeZipFile(s)
        elif toString:
            # For support of chapters plugin.
            g.app.write_Leo_file_string = s
        else:
            theActualFile.write(s)
            theActualFile.close()
            c.setFileTimeStamp(fileName)
            &lt;&lt; delete backup file &gt;&gt;
            # t3 = time.clock()
            # g.es_print('len',len(s),'putCount',self.putCount) # 'put',t2-t1,'write&amp;close',t3-t2)
        self.outputFile = None
        self.toString = False
        return atOk
    except Exception:
        g.es("exception writing:",fileName)
        g.es_exception(full=True)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        if backupName:
            &lt;&lt; delete fileName &gt;&gt;
            &lt;&lt; rename backupName to fileName &gt;&gt;
        self.toString = False
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.
</t>
<t tx="ekr.20090401102247.763">try:
    # Write all @file nodes and set orphan bits.
    # An important optimization: we have already assign the file indices.
    changedFiles,atOk = c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False
</t>
<t tx="ekr.20090401102247.764"># self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not write: read only:",fileName,color="red")
            return False
    except Exception:
        pass # os.access() may not exist on all platforms.
</t>
<t tx="ekr.20090401102247.765">backupName = None

# rename fileName to fileName.bak if fileName exists.
if not toString and g.os_path_exists(fileName):

    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"

    if g.os_path_exists(backupName):
        g.utils_remove(backupName)

    ok = g.utils_rename(c,fileName,backupName)

    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False</t>
<t tx="ekr.20090401102247.766">if not self.mFileName.endswith('opml'):
    self.mFileName = self.mFileName + '.opml'
fileName = self.mFileName</t>
<t tx="ekr.20090401102247.767">if toString:
    theActualFile = None
elif c.isZipped:
    self.toString = toString = True
    theActualFile = None
    toZip = True
else:
    theActualFile = open(fileName, 'wb')
</t>
<t tx="ekr.20090401102247.768">if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')
</t>
<t tx="ekr.20090401102247.769">if fileName and g.os_path_exists(fileName):

    self.deleteFileWithMessage(fileName,'')
</t>
<t tx="ekr.20090401102247.770">if backupName:
    g.es("restoring",fileName,"from",backupName)
    g.utils_rename(c,backupName,fileName)
</t>
<t tx="ekr.20090401102247.771">def writeZipFile (self,s):

    # The name of the file in the archive.
    contentsName = g.toEncodedString(
        g.shortFileName(self.mFileName),
        self.leo_file_encoding,reportErrors=True)

    # The name of the archive itself.
    fileName = g.toEncodedString(
        self.mFileName,
        self.leo_file_encoding,reportErrors=True)

    # Write the archive.
    theFile = zipfile.ZipFile(fileName,'w',zipfile.ZIP_DEFLATED)
    theFile.writestr(contentsName,s)
    theFile.close()
</t>
<t tx="ekr.20090401102247.772"></t>
<t tx="ekr.20090401102247.773"></t>
<t tx="ekr.20090401102247.774">class posList(list):
    &lt;&lt; docstring for posList &gt;&gt;
    def __init__ (self,c,aList=None):
        self.c = c
        list.__init__(self) # Init the base class
        if aList is None:
            for p in c.allNodes_iter():
                self.append(p.copy())
        else:
            for p in aList:
                self.append(p.copy())

    def dump (self,sort=False,verbose=False):
        if verbose: return g.listToString(self,sort=sort)
        else: return g.listToString([p.h for p in self],sort=sort)

    def select(self,pat,regex=False,removeClones=True):
        '''Return a new posList containing all positions
        in self that match the given pattern.'''
        c = self.c ; aList = []
        if regex:
            for p in self:
                if re.match(pat,p.h):
                    aList.append(p.copy())
        else:
            for p in self:
                if p.h.find(pat) != -1:
                    aList.append(p.copy())
        if removeClones:
            aList = self.removeClones(aList)
        return posList(c,aList)

    def removeClones(self,aList):
        seen = {} ; aList2 = []
        for p in aList:
            if p.v.t not in seen:
                seen[p.v.t] = p.v.t
                aList2.append(p)
        return aList2
</t>
<t tx="ekr.20090401102247.775">'''A subclass of list for creating and selecting lists of positions.

    aList = g.posList(c)
        # Creates a posList containing all positions in c.

    aList = g.posList(c,aList2)
        # Creates a posList from aList2.

    aList2 = aList.select(pattern,regex=False,removeClones=True)
        # Creates a posList containing all positions p in aList
        # such that p.h matches the pattern.
        # The pattern is a regular expression if regex is True.
        # if removeClones is True, all positions p2 are removed
        # if a position p is already in the list and p2.v.t == p.v.t.

    aList.dump(sort=False,verbose=False)
        # Prints all positions in aList, sorted if sort is True.
        # Prints p.h, or repr(p) if verbose is True.
'''
</t>
<t tx="ekr.20090401102247.776"></t>
<t tx="ekr.20090401102247.777"></t>
<t tx="ekr.20090401102247.778">def __get_b(self):

    p = self
    return p.bodyString()

def __set_b(self,val):

    p = self ; c = p.v and p.v.context
    if c:
        c.setBodyString(p, val)
        # Don't redraw the screen: p.b must be fast.
        # c.redraw_after_icons_changed()

b = property(
    __get_b, __set_b,
    doc = "position body string property")
</t>
<t tx="ekr.20090401102247.779">def __get_h(self):

    p = self
    return p.headString()

def __set_h(self,val):

    p = self ; c = p.v and p.v.context
    if c:
        c.setHeadString(p,val)
        # Don't redraw the screen: p.h must be fast.
        # c.redraw_after_head_changed()

h = property(
    __get_h, __set_h,
    doc = "position headline string property")  
</t>
<t tx="ekr.20090401102247.780">def __get_gnx(self):
    p = self
    return g.app.nodeIndices.toString(p.v.t.fileIndex)

gnx = property(
    __get_gnx, # __set_gnx,
    doc = "position gnx property")
</t>
<t tx="ekr.20090401102247.781"></t>
<t tx="ekr.20090401102247.782">def __get_b(self):

    v = self
    return v.bodyString()

def __set_b(self,val):

    v = self
    v.setBodyString(val)

b = property(
    __get_b, __set_b,
    doc = "vnode body string property")
</t>
<t tx="ekr.20090401102247.783">def __get_h(self):

    v = self
    return v.headString()

def __set_h(self,val):

    v = self
    v.setHeadString(val)

h = property(
    __get_h, __set_h,
    doc = "vnode headline string property")  
</t>
<t tx="ekr.20090401102247.784">def __get_u(self):
    v = self
    if not hasattr(v,'unknownAttributes'):
        v.unknownAttributes = {}
    return v.unknownAttributes

def __set_u(self,val):
    v = self
    if val is None:
        if hasattr(v,'unknownAttributes'):
            delattr(v,'unknownAttributes')
    elif type(val) == type({}):
        v.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_u, __set_u,
    doc = "vnode unknownAttribute property")
</t>
<t tx="ekr.20090401102247.785">def __get_gnx(self):
    v = self
    return g.app.nodeIndices.toString(v.t.fileIndex)

gnx = property(
    __get_gnx, # __set_gnx,
    doc = "vnode gnx property")
</t>
<t tx="ekr.20090401102247.786"></t>
<t tx="ekr.20090401102247.787">def __get_b(self):

    t = self
    return t._bodyString # Faster.

def __set_b(self,val):

    t = self
    t.setBodyString(val)

b = property(
    __get_b, __set_b,
    doc = "tnode body string property")
</t>
<t tx="ekr.20090401102247.788">def __get_h(self):

    t = self
    return t.headString()

def __set_h(self,val):

    t = self
    t.setHeadString(val)

h = property(
    __get_h, __set_h,
    doc = "tnode headline string property")  
</t>
<t tx="ekr.20090401102247.789">def __get_t(self):
    t = self
    if not hasattr(t,'unknownAttributes'):
        t.unknownAttributes = {}
    return t.unknownAttributes

def __set_t(self,val):
    t = self
    if val is None:
        if hasattr(t,'unknownAttributes'):
            delattr(t,'unknownAttributes')
    elif type(val) == type({}):
        t.unknownAttributes = val
    else:
        raise ValueError

u = property(
    __get_t, __set_t,
    doc = "tnode unknownAttribute property")
</t>
<t tx="ekr.20090401102247.790">def __get_gnx(self):
    t = self
    return g.app.nodeIndices.toString(t.fileIndex)

gnx = property(
    __get_gnx, # __set_gnx,
    doc = "tnode gnx property")
</t>
<t tx="ekr.20090401102247.791">@nocolor-node

Changed config.get so that settings in leoSettings.leo are read *last*.
This means that myLeoSettings.leo will override leoSettings.leo,
even when leoSettigns.leo is the local file.</t>
<t tx="ekr.20090401102247.792">def get (self,c,setting,kind):

    """Get the setting and make sure its type matches the expected type."""

    isLeoSettings = c and c.shortFileName().endswith('leoSettings.leo')

    # New in Leo 4.6. Use settings in leoSettings.leo *last*.
    if c and not isLeoSettings:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,junk = self.getValFromDict(d,setting,kind)
            if val is not None:
                # if setting == 'targetlanguage':
                    # g.trace(c.shortFileName(),setting,val,g.callers())
                return val

    for d in self.localOptionsList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','&lt;no hash&gt;')
            # if setting == 'targetlanguage':
                # g.trace(kind,setting,val,g.callers())
            return val

    for d in self.dictList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','&lt;no hash&gt;')
            # if setting == 'targetlanguage':
                # g.trace(kind,setting,val,g.callers())
            return val

    # New in Leo 4.6. Use settings in leoSettings.leo *last*.
    if c and isLeoSettings:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,junk = self.getValFromDict(d,setting,kind)
            if val is not None:
                # if setting == 'targetlanguage':
                    # g.trace(c.shortFileName(),setting,val,g.callers())
                return val

    return None
</t>
<t tx="ekr.20090401102247.793">def getValFromDict (self,d,setting,requestedType,warn=True):

    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''

    bunch = d.get(self.munge(setting))
    if not bunch: return None,False

    # g.trace(setting,requestedType,bunch.toString())
    val = bunch.val

    if g.isPython3:
        isNone = val in ('None','none','',None)
    else:
        isNone = val in (
            unicode('None'),unicode('none'),unicode(''),
            'None','none','',None)


    if not self.typesMatch(bunch.kind,requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            g.es_print('warning: ignoring',bunch.kind,'',setting,'is not',requestedType,color='red')
            g.es_print('there may be conflicting settings!',color='red')
        return None, False
    # elif val in (u'None',u'none','None','none','',None):
    elif isNone:
        return None, True # Exists, but is None
    else:
        # g.trace(setting,val)
        return val, True
</t>
<t tx="ekr.20090401102247.794"></t>
<t tx="ekr.20090401102247.795">@nocolor-node

http://groups.google.com/group/leo-editor/browse_thread/thread/3417ff5e9c02c626

The open file dialog now shows all files by default.
Selecting a non-.leo file will load that file into a new node in the present outline.

This plugs maybe the biggest hole in Leo's history.
</t>
<t tx="ekr.20090401102247.796">@nocolor-node

Rev 1111 of the trunk now contains what might be called a first draft
of this idea.

For example, the following work:

1) leo c:\leo.repo\trunk\leo\modes\python.py

This opens a new, untitled, .leo file, and reads python.py into the
body text of a node.  Some experimentation showed that using the
import code is not likely to be what people want.  There is disabled
code to do that if desired, but I'm not going to add yet another
option unless somebody really would use that feature.

2) leo --silent --script c:\leo.repo\trunk\leo\test\unittest
\batchTest.py

This illustrates one of the many complications that I dealt with in
revising the startup logic.  This code does *not* open the default
(notebook) file: that would not be a reasonable default (imo) for
batch runs.

Another complication: Leo does not try to open a file as a settings
file unless either it is zipped or it has a .leo extension.  That
should not cause any great hardships, and prevents sax from barfing on
modes/python.py.

Your comments and suggestions please.

Edward

P.S. The present code now properly handles the --silent option:  this
option had been broken when moving to optparse.

P.P.S. I heavily refactored the startup logic in runLeo.py.  In
particular, imports are now done at the module level, rather than in
run() and its helpers.  This cleans up the code and generally makes
the module less weird.  However, it means that trying to import
runLeo.py from within Leo **will not work**.  So I had to remove a
unittest for runLeo.run().  That was a pretty silly test anyway:
runLeo.py and run() will be exercised more thoroughly every time Leo
is run! </t>
<t tx="ekr.20090401102247.797"></t>
<t tx="ekr.20090401102247.798">def open (self,event=None):

    '''Open a Leo window containing the contents of a .leo file.'''

    c = self
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;
    table = [("All files","*"),("Leo files","*.leo"),
        ("Python files","*.py"),]

    fileName = ''.join(c.k.givenArgs) or g.app.gui.runOpenFileDialog(
        title = "Open",filetypes = table,defaultextension = ".leo")
    c.bringToFront()

    ok = False
    if fileName:
        if fileName.endswith('.leo'):
            ok, frame = g.openWithFileName(fileName,c)
            if ok:
                g.chdir(fileName)
                g.setGlobalOpenDir(fileName)
            if ok and closeFlag:
                g.app.destroyWindow(c.frame)
        else:
            ok = c.createNodeFromExternalFile(fileName)

    # openWithFileName sets focus if ok.
    if not ok:
        if c.config.getBool('outline_pane_has_initial_focus'):
            c.treeWantsFocusNow()
        else:
            c.bodyWantsFocusNow()
</t>
<t tx="ekr.20090401102247.799">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c

closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="ekr.20090401102247.800">def createNodeFromExternalFile(self,fn):

    '''Read the file into a node.
    Return None, indicating that c.open should set focus.'''

    c = self

    f = None
    try:
        f = open(fn)
        s = f.read()
        f.close()
    except IOError:
        g.es('can not open %s' % fn)
        return

    head,ext = g.os_path_splitext(fn)
    if ext.startswith('.'): ext = ext[1:]
    language = g.app.extension_dict.get(ext)
    if language:
        prefix = '@color\n@language %s\n\n' % language
    else:
        prefix = '@killcolor\n\n'
    p2 = c.insertHeadline(op_name='Open File', as_child=False)
    p2.h = '@edit %s' % fn # g.shortFileName(fn)
    p2.b = prefix + s
    w = c.frame.body.bodyCtrl
    if w: w.setInsertPoint(0)
    c.redraw()
    c.recolor()</t>
<t tx="ekr.20090401102247.801">leo c:\leo.repo\trunk\leo\modes\python.py

# --silent optional below
leo --script c:\leo.repo\trunk\leo\test\unittest\batchTest.py</t>
<t tx="ekr.20090401102247.802">@nocolor-node

Only .zip and .leo extensions are allowed at present.</t>
<t tx="ekr.20090401102247.803"></t>
<t tx="ekr.20090401102247.804"></t>
<t tx="ekr.20090401102247.805">def runAtFileTest(c,p):

    """Common code for testing output of @file, @thin, etc."""

    at = c.atFileCommands
    child1 = p.firstChild()
    child2 = child1.next()
    h1 = child1.h.lower().strip()
    h2 = child2.h.lower().strip()
    assert(g.match(h1,0,"#@"))
    assert(g.match(h2,0,"output"))
    expected = child2.b

    # Compute the type from child1's headline.
    j = g.skip_c_id(h1,2)
    theType = h1[1:j]
    assert theType in ("@edit","@file","@thin","@nosent",
        "@noref","@asis","@root",), "bad type: %s" % type

    thinFile = theType == "@thin"
    nosentinels = theType in ("@asis","edit","@nosent")

    if theType == "@root":
        c.tangleCommands.tangle_output = ''
        c.tangleCommands.tangle(event=None,p=child1)
        at.stringOutput = c.tangleCommands.tangle_output
    elif theType == "@asis":
        at.asisWrite(child1,toString=True)
    elif theType == "@edit":
        at.writeOneAtEditNode(child1,toString=True)
    elif theType == "@noref":
        at.norefWrite(child1,toString=True)
    else:
        at.write(child1,thinFile=thinFile,nosentinels=nosentinels,toString=True)
    try:
        result = g.toUnicode(at.stringOutput,"ascii")
        assert(result == expected)
    except AssertionError:
        &lt;&lt; dump result and expected &gt;&gt;
        raise
</t>
<t tx="ekr.20090401102247.806">g.pr('\n','-' * 20)
g.pr("result...")
for line in g.splitLines(result):
    g.pr("%3d" % len(line),repr(line))
g.pr('-' * 20)
g.pr("expected...")
for line in g.splitLines(expected):
    g.pr("%3d" % len(line),repr(line))
g.pr('-' * 20)
</t>
<t tx="ekr.20090401102247.807">def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atAutoNodeName            (self): return self.v.atAutoNodeName()
def atEditNodeName            (self): return self.v.atEditNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atShadowFileNodeName      (self): return self.v.atShadowFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtAutoNode            (self): return self.v.isAtAutoNode()
def isAtEditNode            (self): return self.v.isAtEditNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtShadowFileNode      (self): return self.v.isAtShadowFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
</t>
<t tx="ekr.20090401102247.808"># These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atAutoNodeName (self):
    # h = self.headString() ; tag = '@auto'
    # # Prevent conflicts with autotrees plugin: don't allow @auto-whatever to match.
    # return g.match_word(h,0,tag) and not g.match(h,0,tag+'-') and h[len(tag):].strip()
    names = ("@auto",)
    return self.findAtFileName(names)

def atEditNodeName (self):
    names = ("@edit",)
    return self.findAtFileName(names)

def atFileNodeName (self):
    names = ("@file",)
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)

def atShadowFileNodeName (self):
    names = ("@shadow",)
    return self.findAtFileName(names)

def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)

def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName
</t>
<t tx="ekr.20090401102247.809">def anyAtFileNodeName (self):

    """Return the file name following an @file node or an empty string."""

    names = (
        "@auto",
        "@edit",
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile",
        "@shadow",)

    return self.findAtFileName(names)
</t>
<t tx="ekr.20090401102247.810">def readAll(self,root,partialFlag=False,forceGnx=False):

    """Scan vnodes, looking for @file nodes to read."""

    use_tracer = False
    if use_tracer: tt = g.startTracer()

    at = self ; c = at.c
    if partialFlag:
        # Capture the current headline only if we aren't doing the initial read.
        c.endEditing() 
    anyRead = False
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and p != after:
        # g.trace(p.h)
        if not p.h.startswith('@'):
            p.moveToThreadNext()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            if forceGnx: # New in Leo 4.4.2 b1: support for sax read.
                at.forceGnxOnPosition(p)
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtAutoNode():
            fileName = p.atAutoNodeName()
            at.readOneAtAutoNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtEditNode():
            fileName = p.atEditNodeName()
            at.readOneAtEditNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtShadowFileNode():
            fileName = p.atShadowFileNodeName()
            at.readOneAtShadowNode (fileName,p)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty()
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for v in c.all_unique_vnodes_iter():
        v.clearOrphan()

    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")

    if use_tracer: tt.stop()
</t>
<t tx="ekr.20090401102247.811">def readOneAtEditNode (self,fn,p):

    at = self ; c = at.c ; ic = c.importCommands
    oldChanged = c.isChanged()
    at.scanDefaultDirectory(p,importing=True) # Set default_directory
    fn = c.os_path_finalize_join(at.default_directory,fn)
    junk,ext = g.os_path_splitext(fn)

    if not g.unitTesting:
        g.es("reading @edit:", g.shortFileName(fn))

    # Read the file into s.
    try:
        s = open(fn).read()
    except IOError:
        g.es("can not open @edit ",fn,color='red')
        leoTest.fail()
        return

    # Delete all children.
    while p.hasChildren():
        p.firstChild().doDelete()

    changed = c.isChanged()
    head = ''
    ext = ext.lower()
    if ext in ('.html','.htm'):   head = '@language html\n'
    elif ext in ('.txt','.text'): head = '@nocolor\n'
    else:
        language = ic.languageForExtension(ext)
        if language and language != 'unknown_language':
            head = '@language %s\n' % language
        else:
            head = '@nocolor'

    p.b = head + s
    if not changed: c.setChanged(False)
    g.doHook('after-edit',p=p)
</t>
<t tx="ekr.20090401102247.812">def languageForExtension (self,ext):

    '''Return the language corresponding to the extensiion ext.'''

    unknown = 'unknown_language'

    if ext.startswith('.'): ext = ext[1:]

    if ext:
        z = g.app.extra_extension_dict.get(ext)
        if z not in (None,'none','None'):
            language = z
        else:
            language = g.app.extension_dict.get(ext)
        if language in (None,'none','None'):
            language = unknown
    else:
        language = unknown

    # g.trace(ext,repr(language))

    # Return the language even if there is no colorizer mode for it.
    return language
</t>
<t tx="ekr.20090401102247.813"># Similar to writeOneAtAutoNode.

def writeOneAtEditNode(self,p,toString,force=False):

    '''Write p, an @edit node.

    File indices *must* have already been assigned.'''

    at = self ; c = at.c ; root = p.copy()

    fn = p.atEditNodeName()

    if fn:
        at.scanDefaultDirectory(p,importing=True) # Set default_directory
        fn = c.os_path_finalize_join(at.default_directory,fn)
        exists = g.os_path_exists(fn)
        if not self.shouldWriteAtEditNode(p,exists,force):
            return False
    elif not toString:
        return False

    # This code is similar to code in at.write.
    c.endEditing() # Capture the current headline.
    at.targetFileName = g.choose(toString,"&lt;string-file&gt;",fn)
    at.initWriteIvars(root,at.targetFileName,
        atAuto=True,
        nosentinels=True,thinFile=False,scriptWrite=False,
        toString=toString)

    ok = at.openFileForWriting(root,fileName=fn,toString=toString)
    if ok:
        at.writeOpenFile(root,nosentinels=True,toString=toString)
        at.closeWriteFile() # Sets stringOutput if toString is True.
        if at.errors == 0:
            at.replaceTargetFileIfDifferent(root) # Sets/clears dirty and orphan bits.
        else:
            g.es("not written:",at.outputFileName)
            root.setDirty()

    elif not toString:
        root.setDirty() # Make _sure_ we try to rewrite this file.
        g.es("not written:",at.outputFileName)

    return ok
</t>
<t tx="ekr.20090401102247.814">@ Much thought went into this decision tree:

- We do not want decisions to depend on past history.  That's too confusing.
- We must ensure that the file will be written if the user does significant work.
- We must ensure that the user can create an @edit x node at any time
  without risk of of replacing x with empty or insignificant information.
- We want the user to be able to create an @edit node which will be read
  the next time the .leo file is opened.
- We don't want minor import imperfections to be written to the @edit file.
- The explicit commands that read and write @edit trees must always be honored.
@c

def shouldWriteAtEditNode (self,p,exists,force):

    '''Return True if we should write the @auto node at p.'''

    if force: # We are executing write-at-auto-node or write-dirty-at-auto-nodes.
        return True
    elif not exists: # We can write a non-existent file without danger.
        return True
    elif not p.isDirty(): # There is nothing new to write.
        return False
    elif not self.isSignificantTree(p): # There is noting of value to write.
        g.es_print(p.h,'not written:',color='red')
        g.es_print('no children and less than 10 characters (excluding directives)',color='red')
        return False
    else: # The @auto tree is dirty and contains significant info.
        return True
</t>
<t tx="ekr.20090401102247.815">@nocolor-node

This works, but stops Leo in the middle of the command-handling logic.

However, it is possible to pick up the commander by stepping out into
k.masterKeyHandler or k.masterCommandHandler. Using c, one can then get all
other info.</t>
<t tx="ekr.20090401102247.816"></t>
<t tx="ekr.20090401102247.817">def indentBody (self,event=None):

    '''The indent-region command indents each line of the selected body text,
    or each line of a node if there is no selected text. The @tabwidth directive
    in effect determines amount of indentation. (not yet) A numeric argument
    specifies the column to indent to.'''

    c = self ; current = c.p ; undoType='Indent Region'
    d = c.scanAllDirectives(current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = ''.join(result)
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20090401102247.818"></t>
<t tx="ekr.20090401102247.819">def dedentBody (self,event=None):

    '''Remove one tab's worth of indentation from all presently selected lines.'''

    c = self ; current = c.p ; undoType='Unindent'

    d = c.scanAllDirectives(current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = ''.join(result)
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
</t>
<t tx="ekr.20090401102247.820">class leoKeyEvent:

    '''A gui-independent wrapper for gui events.'''

    def __init__ (self,event,c,stroke=None):

        # g.trace('leoKeyEvent(leoGui)')
        self.actualEvent = event
        self.c      = c # Required to access c.k tables.
        self.char   = hasattr(event,'char') and event.char or ''
        self.keysym = hasattr(event,'keysym') and event.keysym or ''
        self.state  = hasattr(event,'state') and event.state or 0
        self.stroke = hasattr(event,'stroke') and event.stroke or ''
        self.w      = hasattr(event,'widget') and event.widget or None
        self.x      = hasattr(event,'x') and event.x or 0
        self.y      = hasattr(event,'y') and event.y or 0
        # Support for fastGotoNode plugin
        self.x_root = hasattr(event,'x_root') and event.x_root or 0
        self.y_root = hasattr(event,'y_root') and event.y_root or 0

        if self.keysym and c.k:
            # Translate keysyms for ascii characters to the character itself.
            self.keysym = c.k.guiBindNamesInverseDict.get(self.keysym,self.keysym)

        if stroke and not self.stroke:
            self.stroke = self.actualEvent.stroke = stroke

        self.widget = self.w

    def __repr__ (self):

        if self.stroke:
            return 'leoGui.leoKeyEvent: stroke: %s' % (repr(self.stroke))
        else:
            return 'leoGui.leoKeyEvent: char: %s, keysym: %s' % (
                repr(self.char),repr(self.keysym))</t>
<t tx="ekr.20090401102247.821">def event_generate(self,w,kind,*args,**keys):
    '''Generate an event.'''
    # g.trace('baseGui','kind',kind,'args,keys',*args,**keys)
    return w.event_generate(kind,*args,**keys)

def eventChar (self,event,c=None):
    '''Return the char field of an event.'''
    return event and event.char or ''

def eventKeysym (self,event,c=None):
    '''Return the keysym value of an event.'''
    return event and event.keysym

def eventStroke (self,event,c=None):
    return event and hasattr(event,'stroke') and event.stroke or ''

def eventWidget (self,event,c=None):
    '''Return the widget field of an event.'''
    return event and event.widget

def eventXY (self,event,c=None):
    if event:
        return event.x,event.y
    else:
        return 0,0
</t>
<t tx="ekr.20090401102247.822"></t>
<t tx="ekr.20090401102247.823">def masterClickHandler (self,event,func=None):

    g.app.gui.killPopupMenu()

    k = self ; c = k.c ; gui = g.app.gui
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    trace = not g.app.unitTesting and (False or k.trace_masterClickHandler)

    if trace: g.trace(wname,func and func.__name__)
    # c.frame.body.colorizer.interrupt() # New in 4.4.1

    # A click outside the minibuffer terminates any state.
    if k.inState() and w != c.frame.miniBufferWidget:
        if not c.widget_name(w).startswith('log'):
            k.keyboardQuit(event,hideTabs=False)
            # k.endMode(event) # Less drastic than keyboard-quit.
            w and c.widgetWantsFocusNow(w)
            if trace: g.trace('inState: break')
            return 'break'

    # Update the selection point immediately for updateStatusLine.
    k.previousSelection = None
    if wname.startswith('body'):
        c.frame.body.onClick(event) # New in Leo 4.4.2.
    elif wname.startswith('mini'):
        x,y = gui.eventXY(event)
        x = w.xyToPythonIndex(x,y)
        i,j = k.getEditableTextRange()
        if i &lt;= x &lt;= j:
            w.setSelectionRange(x,x,insert=x)
        else:
            if trace: g.trace('2: break')
            return 'break'
    if event and func:
        if trace: g.trace(func.__name__)
        val = func(event) # Don't even *think* of overriding this.
        if trace: g.trace('val:',val,g.callers())
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.widgetWantsFocusNow(w)
        if trace: g.trace('end: None')
        return None

masterClick3Handler = masterClickHandler
masterDoubleClick3Handler = masterClickHandler
</t>
<t tx="ekr.20090401102247.824">def masterDoubleClickHandler (self,event,func=None):

    k = self ; c = k.c ; w = event and event.widget

    if c.config.getBool('trace_masterClickHandler'):
        g.trace(c.widget_name(w),func and func.__name__)

    if event and func:
        # Don't event *think* of overriding this.
        return func(event)
    else:
        gui = g.app.gui
        x,y = gui.eventXY(event)
        i = w.xyToPythonIndex(x,y)
        s = w.getAllText()
        start,end = g.getWord(s,i)
        w.setSelectionRange(start,end)
        return 'break'
</t>
<t tx="ekr.20090401102247.825">def masterMenuHandler (self,stroke,func,commandName):

    k = self ; c = k.c
    w = c.frame.getFocus()

    # g.trace('focus',w)
    # g.trace('stroke',stroke,'func',func and func.__name__,commandName,g.callers())

    # Create a minimal event for commands that require them.
    event = g.Bunch(c=c,char='',keysym='',widget=w)

    if stroke:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)
</t>
<t tx="ekr.20090401102247.826"></t>
<t tx="ekr.20090401102247.827">@nocolor

The setting is called -c or --config.  The one-config-file arg no longer exists.

http://groups.google.com/group/leo-editor/browse_thread/thread/f3f95d93bcd93b94

Personally, I'd like to see another config file available via -c on
the command line:
(a common idiom)

leo myproject.leo -c /usr/lib/myproject/myLeoSettings.leo

or better yet:

leo myproject.leo -c /etc/leo/style01.leo
leo myotherproject.leo -c /etc/leo/style02.leo
leo anotherproject.leo -c /etc/leo/style23.leo

Each file opens in an editor with the shortcuts, buttons, commands,
plugins, appearance etc.  that has been tuned for that data management task.

or best yet:

leo myproject.leo -c /usr/lib/python2.5/site-packages/leo/config/style94.leo

==================

http://groups.google.com/group/leo-editor/browse_thread/thread/b5a736089079acaf#

Please, I think each file has a distinct and required role.

- config/leoSettings.leo = Edward's base, required for a sane starting point

- home/.leo/myLeoSettings.leo = adjust Edwards suggestions to taste

- cwd/myLeoSettings.leo = provide a customized working environment in
this folder

- leo -c /usr/lib/leo-editor/src/config/zope3_ide.leo =
  - open this file in a specialized environments, mine or community contributed
  - ...

- currentfile/@settings =
  - I'm working on some customization ideas
  - Here, try out this Leo file I sent you, check out all the spiffy
modifications 

@color</t>
<t tx="ekr.20090401102247.828">@nocolor

c.config.getSettingSource('show_full_tracebacks_in_scripts')
returns the name of the file which Leo used to determine the setting

- D indicates default settings.
- F indicates the file being loaded
- L indicates leoSettings.leo
- M indicates myLeoSettings.leo

theHash = d.get('_hash').lower()

if letter:
    pass
elif theHash.endswith('myleosettings.leo'):
    letter = '[M]'
elif theHash.endswith('leosettings.leo'):
    letter = ' ' * 3
else:
    letter = '[D]'

@color</t>
<t tx="ekr.20090401102247.829"></t>
<t tx="ekr.20090401102247.830">def addIconButton (self,*args,**keys):
    if self.iconBar: return self.iconBar.add(*args,**keys)
    else: return None

def addIconRow(self):
    if self.iconBar: return self.iconBar.addRow()

def addIconWidget(self,w):
    if self.iconBar: return self.iconBar.addWidget(w)

def clearIconBar (self):
    if self.iconBar: self.iconBar.clear()

def createIconBar (self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c,self.outerFrame)
    return self.iconBar

def getIconBar(self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c,self.outerFrame)
    return self.iconBar

getIconBarObject = getIconBar

def getNewIconFrame (self):
    if not self.iconBar:
        self.iconBar = self.iconBarClass(self.c,self.outerFrame)
    return self.iconBar.getNewFrame()

def hideIconBar (self):
    if self.iconBar: self.iconBar.hide()

def showIconBar (self):
    if self.iconBar: self.iconBar.show()
</t>
<t tx="ekr.20090401102247.831">class tkIconBarClass:

    '''A class representing the singleton Icon bar'''

    @others
</t>
<t tx="ekr.20090401102247.832">def __init__ (self,c,parentFrame):

    self.c = c

    self.buttons = {}

    # Create a parent frame that will never be unpacked.
    # This allows us to pack and unpack the container frame without it moving.
    self.iconFrameParentFrame = Tk.Frame(parentFrame)
    self.iconFrameParentFrame.pack(fill="x",pady=0)

    # Create a container frame to hold individual row frames.
    # We hide all icons by doing pack_forget on this one frame.
    self.iconFrameContainerFrame = Tk.Frame(self.iconFrameParentFrame)
        # Packed in self.show()

    self.addRow()
    self.font = None
    self.parentFrame = parentFrame
    self.visible = False
    self.widgets_per_row = c.config.getInt('icon_bar_widgets_per_row') or 10
    self.show() # pack the container frame.
</t>
<t tx="ekr.20090401102247.833">def add(self,*args,**keys):

    """Add a button containing text or a picture to the icon bar.

    Pictures take precedence over text"""

    c = self.c
    text = keys.get('text')
    imagefile = keys.get('imagefile')
    image = keys.get('image')
    command = keys.get('command')
    bg = keys.get('bg')

    if not imagefile and not image and not text: return

    self.addRowIfNeeded()
    f = self.iconFrame # Bind this after possibly creating a new row.

    if command:
        def commandCallBack(c=c,command=command):
            val = command()
            if c.exists:
                c.bodyWantsFocus()
                c.outerUpdate()
            return val
    else:
        def commandCallback(n=g.app.iconWidgetCount):
            g.pr("command for widget %s" % (n))
        command = commandCallback

    if imagefile or image:
        &lt;&lt; create a picture &gt;&gt;
    elif text:
        b = Tk.Button(f,text=text,relief="groove",bd=2,command=command)
        if not self.font:
            self.font = c.config.getFontFromParams(
                "button_text_font_family", "button_text_font_size",
                "button_text_font_slant",  "button_text_font_weight",)
        b.configure(font=self.font)
        if bg: b.configure(bg=bg)
        b.pack(side="left", fill="none")
        return b

    return None
</t>
<t tx="ekr.20090401102247.834">try:
    if imagefile:
        # Create the image.  Throws an exception if file not found
        imagefile = g.os_path_join(g.app.loadDir,imagefile)
        imagefile = g.os_path_normpath(imagefile)
        image = Tk.PhotoImage(master=g.app.root,file=imagefile)
        g.trace(image,imagefile)

        # Must keep a reference to the image!
        try:
            refs = g.app.iconImageRefs
        except:
            refs = g.app.iconImageRefs = []

        refs.append((imagefile,image),)

    if not bg:
        bg = f.cget("bg")

    try:
        b = Tk.Button(f,image=image,relief="flat",bd=0,command=command,bg=bg)
    except Exception:
        g.es_print('image does not exist',image,color='blue')
        b = Tk.Button(f,relief='flat',bd=0,command=command,bg=bg)
    b.pack(side="left",fill="y")
    return b

except:
    g.es_exception()
    return None
</t>
<t tx="ekr.20090401102247.835">def addRow(self,height=None):

    if height is None:
        height = '5m'

    w = Tk.Frame(self.iconFrameContainerFrame,height=height,bd=2,relief="groove")
    w.pack(fill="x",pady=2)
    self.iconFrame = w
    self.c.frame.iconFrame = w
    return w
</t>
<t tx="ekr.20090401102247.836">def addRowIfNeeded (self):

    '''Add a new icon row if there are too many widgets.'''

    try:
        n = g.app.iconWidgetCount
    except:
        n = g.app.iconWidgetCount = 0

    if n &gt;= self.widgets_per_row:
        g.app.iconWidgetCount = 0
        self.addRow()

    g.app.iconWidgetCount += 1
</t>
<t tx="ekr.20090401102247.837">def addWidget (self,w):

    self.addRowIfNeeded()
    w.pack(side="left", fill="none")


</t>
<t tx="ekr.20090401102247.838">def clear(self):

    """Destroy all the widgets in the icon bar"""

    f = self.iconFrameContainerFrame

    for slave in f.pack_slaves():
        slave.pack_forget()
    f.pack_forget()

    self.addRow(height='0m')

    self.visible = False

    g.app.iconWidgetCount = 0
    g.app.iconImageRefs = []
</t>
<t tx="ekr.20090401102247.839">def deleteButton (self,w):

    w.pack_forget()
    self.c.bodyWantsFocus()
    self.c.outerUpdate()
</t>
<t tx="ekr.20090401102247.840">def getFrame (self):

    return self.iconFrame

def getNewFrame (self):

    # Pre-check that there is room in the row, but don't bump the count.
    self.addRowIfNeeded()
    g.app.iconWidgetCount -= 1

    # Allocate the frame in the possibly new row.
    frame = Tk.Frame(self.iconFrame)
    return frame

</t>
<t tx="ekr.20090401102247.841">def pack (self):

    """Show the icon bar by repacking it"""

    if not self.visible:
        self.visible = True
        self.iconFrameContainerFrame.pack(fill='x',pady=2)

show = pack
</t>
<t tx="ekr.20090401102247.842">def setCommandForButton(self,b,command):

    b.configure(command=command)
</t>
<t tx="ekr.20090401102247.843">def unpack (self):

    """Hide the icon bar by unpacking it."""

    if self.visible:
        self.visible = False
        w = self.iconFrameContainerFrame
        w.pack_forget()

hide = unpack
</t>
<t tx="ekr.20090401102247.844"></t>
<t tx="ekr.20090401102247.845">def createControl (self):

    tt = self ; c = tt.c

    # Create the main container, possibly in a new row.
    tt.frame = c.frame.getNewIconFrame()

    # Create the chapter menu.
    self.chapterVar = var = Tk.StringVar()
    var.set('main')

    tt.chapterMenu = menu = Pmw.OptionMenu(tt.frame,
        labelpos = 'w', label_text = 'chapter',
        menubutton_textvariable = var,
        items = [],
        command = tt.selectTab,
    )
    menu.pack(side='left',padx=5)

    # Actually add tt.frame to the icon row.
    c.frame.addIconWidget(tt.frame)</t>
<t tx="ekr.20090401102247.846"></t>
<t tx="ekr.20090401102247.847"># It didn't work and there are plenty of good alternatives.</t>
<t tx="ekr.20090401102247.848">classesList = [
    ('abbrevCommands',      abbrevCommandsClass),
    ('bufferCommands',      bufferCommandsClass),
    ('editCommands',        editCommandsClass),
    ('chapterCommands',     chapterCommandsClass),
    ('controlCommands',     controlCommandsClass),
    ('debugCommands',       debugCommandsClass),
    ('editFileCommands',    editFileCommandsClass),
    ('helpCommands',        helpCommandsClass),
    ('keyHandlerCommands',  keyHandlerCommandsClass),
    ('killBufferCommands',  killBufferCommandsClass),
    ('leoCommands',         leoCommandsClass),
    ('macroCommands',       macroCommandsClass),
    # ('queryReplaceCommands',queryReplaceCommandsClass),
    ('rectangleCommands',   rectangleCommandsClass),
    ('registerCommands',    registerCommandsClass),
    ('searchCommands',      searchCommandsClass),
    ('spellCommands',       spellCommandsClass),
]
</t>
<t tx="ekr.20090401102247.849"></t>
<t tx="ekr.20090401102247.850">@nocolor-node

To do:

- allow searches in headlines.</t>
<t tx="ekr.20090401102247.851">def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''

    trace = False or self.trace_minibuffer and not g.app.unitTesting
    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''

    trace and g.trace('ch',ch,'keysym',keysym,'k.stroke',k.stroke)
    # g.trace(g.callers())

    if ch and ch not in ('\n','\r'):
        c.widgetWantsFocusNow(w)
        i,j = w.getSelectionRange()
        ins = w.getInsertPoint()
        # g.trace(i,j,ins)
        if i != j:
            w.delete(i,j)
        if ch == '\b':
            s = w.getAllText()
            if len(s) &gt; len(k.mb_prefix):
                w.delete(i-1)
                i-=1
        else:
            w.insert(ins,ch)
            i = ins+1</t>
<t tx="ekr.20090401102247.852"># Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    c = self.c ; trace = False or self.trace

    if trace: g.trace('entry','p',self.p,
        'search_headline',self.search_headline,
        'search_body',self.search_body)

    if not self.search_headline and not self.search_body:
        if trace: g.trace('nothing to search')
        return None, None

    if len(self.find_text) == 0:
        if trace: g.trace('no find text')
        return None, None

    p = self.p ; self.errors = 0
    attempts = 0
    self.backwardAttempts = 0

    # New in Leo 4.4.8: precompute the regexp for regexHelper.
    if self.pattern_match:
        try: # Precompile the regexp.
            flags = re.MULTILINE
            if self.ignore_case: flags |= re.IGNORECASE
            # New in Leo 4.5: escape the search text.
            self.re_obj = re.compile(self.find_text,flags)
            # self.re_obj = re.compile(re.escape(self.find_text),flags)
        except Exception:
            g.es('invalid regular expression:',self.find_text,color='blue')
            self.errors += 1 # Abort the search.
            return None,None

    while p:
        pos, newpos = self.search()
        if trace: g.trace('attempt','pos',pos,'p',p.h)
        if pos is not None:
            if self.mark_finds:
                p.setMarked()
                c.frame.tree.drawIcon(p) # redraw only the icon.
            if trace: g.trace('success',pos,newpos)
            return pos, newpos
        elif self.errors:
            g.trace('find errors')
            return None,None # Abort the search.
        elif self.node_only:
            if trace: g.trace('fail: node only')
            return None,None # We are only searching one node.
        else:
            if trace: g.trace('failed attempt',p)
            attempts += 1
            p = self.p = self.selectNextPosition()

    if trace: g.trace('attempts',attempts,'backwardAttempts',self.backwardAttempts)
    return None, None
</t>
<t tx="ekr.20090401102247.853"></t>
<t tx="ekr.20090401102247.854"></t>
<t tx="ekr.20090401102247.855">def goPrevVisitedNode (self,event=None):

    '''Select the previously visited node.'''

    c = self

    p = c.nodeHistory.goPrev()

    if p:
        c.selectPosition(p)
        c.redraw_after_select(p)
</t>
<t tx="ekr.20090401102247.856">def goNextVisitedNode (self,event=None):

    '''Select the next visited node.'''

    c = self

    p = c.nodeHistory.goNext()

    if p:
        c.selectPosition(p)
        c.redraw_after_select(p)

</t>
<t tx="ekr.20090401102247.857">class nodeHistory:

    '''A class encapsulating knowledge of visited nodes.'''

    @others
</t>
<t tx="ekr.20090401102247.858">def __init__ (self,c):

    self.c = c
    self.beadList = []
        # list of (position,chapter) tuples for
        # nav_buttons and nodenavigator plugins.
    self.beadPointer = -1
    self.trace = False</t>
<t tx="ekr.20090401102247.859">def canGoToNextVisited (self):

    if self.trace:
        g.trace(
            self.beadPointer + 1 &lt; len(self.beadList),
            self.beadPointer,len(self.beadList))

    return self.beadPointer + 1 &lt; len(self.beadList)

def canGoToPrevVisited (self):

    if self.trace:
        g.trace(self.beadPointer &gt; 0,
            self.beadPointer,len(self.beadList))

    return self.beadPointer &gt; 0
</t>
<t tx="ekr.20090401102247.860">def clear (self):

    self.beadList = []
    self.beadPointer = -1
</t>
<t tx="ekr.20090401102247.861">def goNext (self):

    '''Return the next visited node, or None.'''
    if self.beadPointer + 1 &lt; len(self.beadList):
        self.beadPointer += 1
        p,chapter = self.beadList[self.beadPointer]
        self.selectChapter(chapter)
        return p
    else:
        return None

def goPrev (self):

    '''Return the previous visited node, or None.'''
    if self.beadPointer &gt; 0:
        self.beadPointer -= 1
        p,chapter = self.beadList[self.beadPointer]
        self.selectChapter(chapter)
        return p
    else:
        return None
</t>
<t tx="ekr.20090401102247.862">def remove (self,p):

    '''Remove an item from the nav_buttons list.'''

    c = self.c
    target = self.beadPointer &gt; -1 and self.beadList[self.beadPointer]

    self.beadList = [z for z in self.beadList
                        if z[0] != p and c.positionExists(z[0])]

    try:
        self.beadPointer = self.beadList.index(target)
    except ValueError:
        self.beadPointer = max(0,self.beadPointer-1)

    if self.trace:
        g.trace('bead list',p.h)
        g.pr([z[0].h for z in self.beadList])
</t>
<t tx="ekr.20090401102247.863">def selectChapter (self,chapter):

    c = self.c ; cc = c.chapterController

    if cc and chapter and chapter != cc.getSelectedChapter():
        cc.selectChapterByName(chapter.name)
</t>
<t tx="ekr.20090401102247.864">def update (self,p):

    c = self.c

    self.beadList = [z for z in self.beadList
                        if c.positionExists(z[0])]

    positions = [z[0] for z in self.beadList]

    try:
        self.beadPointer = positions.index(p)
    except ValueError:
        cc = c.chapterController
        theChapter = cc and cc.getSelectedChapter()
        data = (p.copy(),theChapter)
        self.beadList.append(data)
        self.beadPointer = len(self.beadList)-1

    if self.trace:
        g.trace('bead list',p.h)
        g.pr([z[0].h for z in self.beadList])

</t>
<t tx="ekr.20090401102247.865">def visitedPositions (self):

    return [p.copy() for p,chapter in self.beadList]
</t>
<t tx="ekr.20090401102247.866"></t>
<t tx="ekr.20090401102247.867">leoEditCommands.getImage -&gt; g.app.gui.getImage</t>
<t tx="ekr.20090401102247.868">def appendImageDictToList(self,aList,iconDir,path,xoffset,**kargs):

    c = self.c
    path = c.os_path_finalize_join(iconDir,path)
    relPath = g.makePathRelativeTo(path,iconDir)

    image,image_height = g.app.gui.getTreeImage(c,path)
    if not image:
        g.es('can not load image:',path)
        return xoffset

    if image_height is None:
        yoffset = 0
    else:
        yoffset = 0 # (c.frame.tree.line_height-image_height)/2
        # TNB: I suspect this is being done again in the drawing code

    newEntry = {
        'type' : 'file',
        'file' : path,
        'relPath': relPath,
        'where' : 'beforeHeadline',
        'yoffset' : yoffset, 'xoffset' : xoffset, 'xpad' : 1, # -2,
        'on' : 'tnode',
    }
    newEntry.update(kargs)  # may switch 'on' to 'vnode'
    aList.append (newEntry)
    xoffset += 2

    return xoffset
</t>
<t tx="ekr.20090401102247.869"></t>
<t tx="ekr.20090401102247.870">def alert(message):

    g.es(message)
    g.app.gui.alert(message)
</t>
<t tx="ekr.20090401102247.871"></t>
<t tx="ekr.20090401102247.872">def checkMoveWithParentWithWarning (self,root,parent,warningFlag):

    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedTnodes = {}
    for ancestor in parent.self_and_parents_iter():
        if ancestor.isCloned():
            t = ancestor.v.t
            clonedTnodes[t] = t

    if not clonedTnodes:
        return True

    for p in root.self_and_subtree_iter():
        if p.isCloned() and clonedTnodes.get(p.v.t):
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            elif warningFlag:
                g.alert(message)
            return False
    return True
</t>
<t tx="ekr.20090401102247.873">def checkDrag (self,root,target):

    """Return False if target is any descendant of root."""

    message = "Can not drag a node into its descendant tree."

    # g.trace('root',root.h,'target',target.h)

    for z in root.subtree_iter():
        if z == target:
            if g.app.unitTesting:
                g.app.unitTestDict['checkMoveWithParentWithWarning']=True
            else:
                g.alert(message)
            return False
    return True</t>
<t tx="ekr.20090401102247.874">def invalidOutline (self, message):

    p = self

    if p.hasParent():
        node = p.parent()
    else:
        node = p

    g.alert("invalid outline: %s\n%s" % (message,node))
</t>
<t tx="ekr.20090401102247.875">This contains all gui plugins.</t>
<t tx="ekr.20090401102247.876"></t>
<t tx="ekr.20090401102247.877">def createWxGui (self,fileName=None):

    # Do NOT omit fileName param: it is used in plugin code.

    """A convenience routines for plugins to create the wx gui class."""

    leoPlugins.loadOnePlugin ('wxGui',verbose=True)
</t>
<t tx="ekr.20090401102247.878"></t>
<t tx="ekr.20090401102247.879"># This was the cause of Mark Edgington's bug.</t>
<t tx="ekr.20090401102247.880"></t>
<t tx="ekr.20090401102247.881"></t>
<t tx="ekr.20090401102247.882"></t>
<t tx="ekr.20090401102247.883">def is_sentinel (line,delims):

    &lt;&lt; is_sentinel doc tests &gt;&gt;

    delim1,delim2,delim3 = delims

    line = line.lstrip()

    if delim1:
        return line.startswith(delim1+'@')
    elif delim2 and delim3:
        i = line.find(delim2+'@')
        j = line.find(delim3)
        return 0 == i &lt; j
    else:
        g.trace("can't happen. delims: %s" % repr(delims),color="red")
        return False
</t>
<t tx="ekr.20090401102247.884">"""

Return True if line starts with a sentinel comment.

&gt;&gt;&gt; import leo.core.leoGlobals as g
&gt;&gt;&gt; py_delims = g.comment_delims_from_extension('.py')
&gt;&gt;&gt; g.is_sentinel("#@+node",py_delims)
True
&gt;&gt;&gt; g.is_sentinel("#comment",py_delims)
False

&gt;&gt;&gt; c_delims = g.comment_delims_from_extension('.c')
&gt;&gt;&gt; g.is_sentinel("//@+node",c_delims)
True
&gt;&gt;&gt; g.is_sentinel("//comment",c_delims)
False

&gt;&gt;&gt; html_delims = g.comment_delims_from_extension('.html')
&gt;&gt;&gt; g.is_sentinel("&lt;!--@+node--&gt;",html_delims)
True
&gt;&gt;&gt; g.is_sentinel("&lt;!--comment--&gt;",html_delims)
False

"""
</t>
</tnodes>
</leo_file>
